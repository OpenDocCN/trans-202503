- en: '1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '1'
- en: BY THE C, BY THE C, BY THE BEAUTIFUL C
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 C， 通过 C， 通过美丽的 C
- en: “By the Beautiful Sea"
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: “美丽的海边”
- en: —Carroll and Atteridge, 1914
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —Carroll 和 Atteridge, 1914
- en: '![image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: This chapter presents an overview of C programming written for students who
    have some experience programming in another language. It’s specifically written
    for Python programmers and uses a few Python examples for comparison purposes.
    However, it should be useful as an introduction to C programming for anyone with
    basic programming experience in any language.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为有一定其他语言编程经验的学生提供了 C 编程的概述。它特别为 Python 程序员编写，并通过一些 Python 示例进行对比。然而，对于任何具有基本编程经验的人来说，它作为
    C 编程的入门书籍都是有用的。
- en: C is a high-level programming language like other languages you might know,
    such as Python, Java, Ruby, or C++. It’s an imperative and a procedural programming
    language, which means that a C program is expressed as a sequence of statements
    (steps) for the computer to execute and that C programs are structured as a set
    of functions (procedures). Every C program must have at least one function, the
    `main` function, which contains the set of statements that execute when the program
    begins.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: C 是一种高级编程语言，像你可能熟悉的其他语言一样，如 Python、Java、Ruby 或 C++。它是一种命令式和过程式编程语言，这意味着 C 程序以一系列语句（步骤）的形式表达，供计算机执行，并且
    C 程序结构是由一组函数（过程）组成的。每个 C 程序必须至少包含一个函数，即 `main` 函数，其中包含程序开始时执行的一组语句。
- en: The C programming language is less abstracted from the computer’s machine language
    than some other languages with which you might be familiar. This means that C
    doesn’t have support for object-oriented programming (like Python, Java, and C++)
    or have a rich set of high-level programming abstractions (such as strings, lists,
    and dictionaries in Python). As a result, if you want to use a dictionary data
    structure in your C program, you need to implement it yourself, as opposed to
    just importing the one that is part of the programming language (as in Python).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与你可能熟悉的其他编程语言相比，C 编程语言相对于计算机的机器语言抽象程度较低。这意味着 C 不支持面向对象编程（像 Python、Java 和 C++），也没有丰富的高级编程抽象（例如
    Python 中的字符串、列表和字典）。因此，如果你想在 C 程序中使用字典数据结构，你需要自己实现它，而不是像 Python 那样直接导入语言内置的字典。
- en: C’s lack of high-level abstractions might make it seem like a less appealing
    programming language to use. However, being less abstracted from the underlying
    machine makes C easier for a programmer to see and understand the relationship
    between a program’s code and the computer’s execution of it. C programmers retain
    more control over how their programs execute on the hardware, and they can write
    code that runs more efficiently than equivalent code written using the higher-level
    abstractions provided by other programming languages. In particular, they have
    more control over how their programs manage memory, which can have a significant
    impact on performance. Thus, C remains the *de facto* language for computer systems
    programming where low-level control and efficiency are crucial.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: C 缺乏高级抽象可能使其看起来不像其他语言那样具吸引力。然而，正因为 C 与底层机器的抽象较少，它使程序员更容易看到并理解程序代码与计算机执行之间的关系。C
    程序员对程序在硬件上的执行方式有更多控制权，而且他们能够编写比使用其他编程语言的高级抽象所写的等效代码更高效的代码。特别是，他们对程序如何管理内存有更多控制，这对性能有显著影响。因此，C
    仍然是计算机系统编程的*事实标准*语言，在低级控制和效率至关重要的领域尤为重要。
- en: We use C in this book because of its expressiveness of program control and its
    relatively straightforward translation to assembly and machine code that a computer
    executes. This chapter introduces programming in C, beginning with an overview
    of its features. [Chapter 2](ch02.xhtml#ch02) then describes C’s features in more
    detail.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用 C 是因为它在程序控制方面的表现力，以及它相对直接地翻译为计算机执行的汇编语言和机器代码。本章介绍了 C 编程，首先概述了其特性。[第二章](ch02.xhtml#ch02)则更详细地描述了
    C 的特性。
- en: 1.1 Getting Started Programming in C
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1 开始学习 C 编程
- en: Let’s start by looking at a “hello world" program that includes an example of
    calling a function from the math library. We compare the Python version of this
    program (first) to the C version (second). The C version might be put in a file
    named `hello.c` (`.c` is the suffix convention for C source code files), whereas
    the Python version might be in a file named `hello.py`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个包含调用数学库函数的“hello world”程序开始。我们将 Python 版本的程序（首先）与 C 版本的程序（其次）进行比较。C 版本可能保存在名为
    `hello.c` 的文件中（`.c` 是 C 源代码文件的后缀约定），而 Python 版本则可能保存在名为 `hello.py` 的文件中。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Python version
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python 版本
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: C version
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C 版本
- en: '**Note** Both the C version^([1](ch01.xhtml#fn1_1)) and Python version^([2](ch01.xhtml#fn1_2))
    are available for download.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意** C 版本^([1](ch01.xhtml#fn1_1)) 和 Python 版本^([2](ch01.xhtml#fn1_2)) 都可以下载。'
- en: 'Notice that both versions of this program have similar structure and language
    constructs, albeit with different language syntax. In particular:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个程序的两个版本结构和语言构造类似，尽管语法不同。具体来说：
- en: '**Comments:**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**注释：**'
- en: In Python, multiline comments begin and end with `'''`, and single-line comments
    begin with `#`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，多行注释以 `'''` 开始和结束，单行注释以 `#` 开始。
- en: In C, multiline comments begin with `/*` and end with `*/`, and single-line
    comments begin with `//`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中，多行注释以 `/*` 开始和以 `*/` 结束，单行注释以 `//` 开始。
- en: '**Importing library code:**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**导入库代码：**'
- en: In Python, libraries are included (imported) using `import`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，使用 `import` 导入库。
- en: In C, libraries are included (imported) using `#include`. All `#include` statements
    appear at the top of the program, outside of function bodies.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中，使用 `#include` 导入库。所有的 `#include` 语句都出现在程序的顶部，在函数体外。
- en: '**Blocks:**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码块：**'
- en: In Python, indentation denotes a block.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，缩进表示一个代码块。
- en: In C, blocks (for example, function, loop, and conditional bodies) start with
    `{` and end with `}`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中，代码块（例如，函数、循环和条件体）以 `{` 开始，以 `}` 结束。
- en: '**The main function:**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**主函数：**'
- en: In Python, `def main():` defines the main function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，`def main():` 定义了主函数。
- en: In C, `int main(){ }` defines the main function. The `main` function returns
    a value of type `int`, which is C’s name for specifying the signed integer type
    (signed integers are values like –3, 0, 1234). The `main` function returns the
    `int` value 0 to signify running to completion without error.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中，`int main(){ }` 定义了主函数。`main` 函数返回一个 `int` 类型的值，`int` 是 C 语言中用于指定带符号整数类型的名称（带符号整数是像
    -3、0、1234 这样的值）。`main` 函数返回 `int` 值 0，表示程序无错误地运行完成。
- en: '**Statements:**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**语句：**'
- en: In Python, each statement is on a separate line.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，每个语句都单独占一行。
- en: In C, each statement ends with a semicolon `;`. In C, statements must be within
    the body of some function (in `main` in this example).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中，每个语句以分号 `;` 结束。在 C 中，语句必须位于某个函数的主体内（在本示例中是 `main` 函数内）。
- en: '**Output:**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: In Python, the `print` function prints a formatted string. Values for the placeholders
    in the format string follow a `%` symbol in a comma-separated list of values (for
    example, the value of `sqrt(4)` will be printed in place of the `%f` placeholder
    in the format string).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，`print` 函数打印格式化字符串。格式字符串中的占位符的值通过 `%` 符号和以逗号分隔的值列表传入（例如，`sqrt(4)`
    的值将替换格式字符串中的 `%f` 占位符）。
- en: In C, the `printf` function prints a formatted string. Values for the placeholders
    in the format string are additional arguments separated by commas (for example,
    the value of `sqrt(4)` will be printed in place of the `%f` placeholder in the
    format string).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中，`printf` 函数打印格式化字符串。格式字符串中的占位符的值作为额外的参数通过逗号分隔传入（例如，`sqrt(4)` 的值将替换格式字符串中的
    `%f` 占位符）。
- en: 'There are a few important differences to note in the C and Python versions
    of this program:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 和 Python 版本的程序中有几个重要的区别：
- en: '**Indentation:**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**缩进：**'
- en: In C, indentation doesn’t have meaning, but it’s good programming style to indent
    statements based on the nested level of their containing block.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中，缩进没有特殊含义，但根据语句所在的嵌套级别进行缩进是良好的编程风格。
- en: '**Output:**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: C’s `printf` function doesn’t automatically print a newline character at the
    end like Python’s `print` function does. As a result, C programmers need to explicitly
    specify a newline character (`\n`) in the format string when a newline is desired
    in the output.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言的 `printf` 函数不像 Python 的 `print` 函数那样自动在结尾打印换行符。因此，C 程序员需要在格式字符串中显式指定换行符（`\n`），以便输出时换行。
- en: main **function:**
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 主 **函数：**
- en: A C program must have a function named `main`, and its return type must be `int`.
    This means that the `main` function returns a signed integer type value. Python
    programs don’t need to name their main function `main`, but they often do by convention.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: C程序必须有一个名为`main`的函数，并且其返回类型必须是`int`。这意味着`main`函数返回一个有符号整数类型的值。Python程序不需要将主函数命名为`main`，但通常按照惯例也会这样做。
- en: The C `main` function has an explicit `return` statement to return an `int`
    value (by convention, `main` should return `0` if the main function is successfully
    executed without errors).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: C的`main`函数有一个显式的`return`语句，用于返回一个`int`类型的值（按照惯例，如果`main`函数成功执行且没有错误，它应该返回`0`）。
- en: A Python program needs to include an explicit call to its `main` function to
    run it when the program executes. In C, its `main` function is automatically called
    when the C program executes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序需要显式地调用其`main`函数来执行它，而C程序在执行时会自动调用其`main`函数。
- en: 1.1.1 Compiling and Running C Programs
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1 编译和运行C程序
- en: 'Python is an interpreted programming language, which means that another program,
    the Python interpreter, runs Python programs: the Python interpreter acts like
    a virtual machine on which Python programs are run. To run a Python program, the
    program source code (`hello.py`) is given as input to the Python interpreter program
    that runs it. For example (`$` is the Linux shell prompt):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种解释型编程语言，这意味着另一个程序——Python解释器——来运行Python程序：Python解释器就像是一个虚拟机，Python程序在其上运行。要运行一个Python程序，程序源代码（`hello.py`）作为输入提供给Python解释器程序，后者运行该程序。例如（`$`是Linux命令行提示符）：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Python interpreter is a program that is in a form that can be run directly
    on the underlying system (this form is called *binary executable*) and takes as
    input the Python program that it runs ([Figure 1-1](ch01.xhtml#ch1fig1)).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Python解释器是一个可以直接在底层系统上运行的程序（这种形式被称为*二进制可执行文件*），并以Python程序作为输入来运行它（见[图1-1](ch01.xhtml#ch1fig1)）。
- en: '![image](../images/01fig01.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig01.jpg)'
- en: '*Figure 1-1: A Python program is directly executed by the Python interpreter,
    which is a binary executable program that is run on the underlying system (OS
    and hardware).*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-1：Python程序由Python解释器直接执行，Python解释器是一个二进制可执行程序，在底层系统（操作系统和硬件）上运行。*'
- en: To run a C program, it must first be translated into a form that a computer
    system can directly execute. A C *compiler* is a program that translates C source
    code into a *binary executable* form that the computer hardware can directly execute.
    A binary executable consists of a series of 0’s and 1’s in a well-defined format
    that a computer can run.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行C程序，必须先将其翻译成计算机系统可以直接执行的形式。C *编译器*是将C源代码翻译成计算机硬件可以直接执行的*二进制可执行*格式的程序。二进制可执行文件由一系列0和1组成，采用计算机能够运行的特定格式。
- en: 'For example, to run the C program `hello.c` on a Unix system, the C code must
    first be compiled by a C compiler (for example, the GNU C compiler, GCC ^([3](ch01.xhtml#fn1_3)))
    that produces a binary executable (by default named `a.out`). The binary executable
    version of the program can then be run directly on the system ([Figure 1-2](ch01.xhtml#ch1fig2)):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在Unix系统上运行C程序`hello.c`，必须首先通过C编译器（例如GNU C编译器GCC ^([3](ch01.xhtml#fn1_3)))编译C代码，生成二进制可执行文件（默认命名为`a.out`）。然后，可以直接在系统上运行该二进制可执行版本的程序（见[图1-2](ch01.xhtml#ch1fig2)）：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '(Note that some C compilers might need to be explicitly told to link in the
    math library: `-lm`):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: （注意，一些C编译器可能需要显式地告诉它链接数学库：`-lm`）：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![image](../images/01fig02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig02.jpg)'
- en: '*Figure 1-2: The C compiler (gcc) builds C source code into a binary executable
    file (a.out). The underlying system (OS and hardware) directly executes the a.out
    file to run the program.*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-2：C编译器（gcc）将C源代码构建为二进制可执行文件（a.out）。底层系统（操作系统和硬件）直接执行a.out文件以运行程序。*'
- en: Detailed Steps
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 详细步骤
- en: In general, the following sequence describes the necessary steps for editing,
    compiling, and running a C program on a Unix system.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，以下步骤描述了在Unix系统上编辑、编译和运行C程序的必要步骤。
- en: 'First, using a text editor (e.g., `vim`^([4](ch01.xhtml#fn1_4))), write and
    save your C source code program in a file (e.g., `hello.c`):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用文本编辑器（例如`vim`^([4](ch01.xhtml#fn1_4)))，编写并保存你的C源代码程序到一个文件中（例如`hello.c`）：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, compile the source to an executable form, and then run it. The most basic
    syntax for compiling with `gcc` is:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将源代码编译成可执行形式，然后运行它。使用`gcc`进行编译的最基本语法是：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If compilation yields no errors, the compiler creates a binary executable file
    named `a.out`. The compiler also allows you to specify the name of the binary
    executable file to generate using the `-o` flag:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译没有产生错误，编译器会创建一个名为`a.out`的二进制可执行文件。编译器还允许你使用`-o`标志来指定生成的二进制可执行文件的名称：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For example, this command instructs `gcc` to compile `hello.c` into an executable
    file named `hello`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个命令指示`gcc`将`hello.c`编译成名为`hello`的可执行文件：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can invoke the executable program using `./hello`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`./hello`来调用可执行程序：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Any changes made to the C source code (the `hello.c` file) must be recompiled
    with `gcc` to produce a new version of `hello`. If the compiler detects any errors
    during compilation, the `./hello` file won’t be created/re-created (but beware,
    an older version of the file from a previous successful compilation might still
    exist).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对C源代码（`hello.c`文件）所做的任何更改都必须使用`gcc`重新编译，以生成`hello`的新版本。如果编译器在编译过程中检测到任何错误，则不会创建/重新创建`./hello`文件（但要注意，来自之前成功编译的旧版本文件可能仍然存在）。
- en: 'Often when compiling with `gcc`, you want to include several command line options.
    For example, these options enable more compiler warnings and build a binary executable
    with extra debugging information:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`gcc`进行编译时，通常你需要包括几个命令行选项。例如，这些选项启用更多的编译器警告，并生成一个包含额外调试信息的二进制可执行文件：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Because the `gcc` command line can be long, frequently the `make` utility is
    used to simplify compiling C programs and for cleaning up files created by `gcc`.
    Using `make` and writing a `Makefile` are important skills that you will develop
    as you build up experience with C programming.^([5](ch01.xhtml#fn1_5))
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`gcc`命令行可能很长，所以经常使用`make`工具来简化C程序的编译过程，并清理`gcc`创建的文件。使用`make`并编写`Makefile`是你在积累C编程经验时将会掌握的重要技能。^([5](ch01.xhtml#fn1_5))
- en: We cover compiling and linking with C library code in more detail at the end
    of [Chapter 2](ch02.xhtml#ch02).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第2章](ch02.xhtml#ch02)的末尾更详细地讨论使用C库代码进行编译和链接。
- en: Variables and C Numeric Types
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变量和C数值类型
- en: Like Python, C uses variables as named storage locations for holding data. Thinking
    about the scope and type of program variables is important to understand the semantics
    of what your program will do when you run it. A variable’s *scope* defines when
    the variable has meaning (that is, where and when in your program it can be used)
    and its lifetime (that is, it could persist for the entire run of a program or
    only during a function activation). A variable’s *type* defines the range of values
    that it can represent and how those values will be interpreted when performing
    operations on its data.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 像Python一样，C语言使用变量作为命名的存储位置来存储数据。考虑程序变量的作用域和类型对于理解程序运行时程序的语义非常重要。一个变量的*作用域*定义了该变量在程序中的意义（即，在程序中何时何地可以使用该变量）和生命周期（即，它可能会在整个程序运行期间持续存在，或者只在函数激活期间存在）。一个变量的*类型*定义了它可以表示的值的范围，以及在对数据进行操作时如何解释这些值。
- en: 'In C, all variables must be declared before they can be used. To declare a
    variable, use the following syntax:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，所有变量必须在使用之前声明。声明变量的语法如下：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A variable can have only a single type. The basic C types include `char`, `int`,
    `float`, and `double`. By convention, C variables should be declared at the beginning
    of their scope (at the top of a `{ }` block), before any C statements in that
    scope.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一个变量只能有一个类型。C语言的基本类型包括`char`、`int`、`float`和`double`。按照约定，C语言变量应该在其作用域的开始部分（即`{
    }`块的顶部）声明，在该作用域中的任何C语句之前。
- en: Below is an example C code snippet that shows declarations and uses of variables
    of some different types. We discuss types and operators in more detail after the
    example.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例C代码片段，展示了声明和使用几种不同类型变量的例子。我们将在示例之后更详细地讨论类型和运算符。
- en: vars.c
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: vars.c
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note the semicolons galore. Recall that C statements are delineated by `;`,
    not line breaks—C expects a semicolon after every statement. You’ll forget some,
    and `gcc` almost never informs you that you missed a semicolon, even though that
    might be the only syntax error in your program. In fact, often when you forget
    a semicolon, the compiler indicates a syntax error on the line *after* the one
    with the missing semicolon: the reason is that `gcc` interprets it as part of
    the statement from the previous line. As you continue to program in C, you’ll
    learn to correlate `gcc` errors with the specific C syntax mistakes that they
    describe.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，分号很多。回想一下，C 语句是由 `;` 来分隔的，而不是换行符——C 希望每个语句后都有一个分号。你会忘记加分号，而 `gcc` 几乎从不告诉你漏掉了分号，即使那可能是你程序中唯一的语法错误。实际上，当你忘记分号时，编译器通常会在缺少分号的行*之后*指出语法错误：原因是
    `gcc` 将它解释为上一行语句的一部分。随着你继续用 C 编程，你会学会将 `gcc` 错误与它们描述的具体 C 语法错误相关联。
- en: 1.1.2 C Types
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2 C 类型
- en: C supports a small set of built-in data types, and it provides a few ways in
    which programmers can construct basic collections of types (arrays and structs).
    From these basic building blocks, a C programmer can build complex data structures.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: C 支持一小部分内建数据类型，并且提供了几种方法，程序员可以用来构造基本的类型集合（数组和结构体）。通过这些基本构建块，C 程序员可以构建复杂的数据结构。
- en: 'C defines a set of basic types for storing numeric values. Here are some examples
    of numeric literal values of different C types:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: C 定义了一组用于存储数值的基本类型。以下是不同 C 类型的数值字面量的一些示例：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The C `char` type stores a numeric value. However, it’s often used by programmers
    to store the value of an ASCII character. A character literal value is specified
    in C as a single character between single quotes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: C 的 `char` 类型存储一个数值。然而，它通常被程序员用来存储一个 ASCII 字符的值。字符字面量值在 C 中是通过单引号括起来的单个字符来指定的。
- en: 'C doesn’t support a string type, but programmers can create strings from the
    `char` type and C’s support for constructing arrays of values, which we discuss
    in later sections. C does, however, support a way of expressing string literal
    values in programs: a string literal is any sequence of characters between double
    quotes. C programmers often pass string literals as the format string argument
    to `printf`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: C 不支持字符串类型，但程序员可以通过 `char` 类型以及 C 对构造值数组的支持来创建字符串，稍后的章节中我们将讨论这一点。C 确实支持在程序中表达字符串字面量值的方法：字符串字面量是任何位于双引号之间的字符序列。C
    程序员通常将字符串字面量作为格式字符串传递给 `printf`：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Python supports strings, but it doesn’t have a `char` type. In C, a string
    and a `char` are two very different types, and they evaluate differently. This
    difference is illustrated by contrasting a C string literal that contains one
    character with a C `char` literal. For example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Python 支持字符串，但没有 `char` 类型。在 C 中，字符串和 `char` 是两种非常不同的类型，它们的处理方式也不同。这种差异通过对比一个包含单个字符的
    C 字符串字面量和一个 C `char` 字面量来说明。例如：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We discuss C strings and `char` variables in more detail in the “Strings and
    the String Library” section on [page 93](ch02.xhtml#lev1_14). Here, we’ll mainly
    focus on C’s numeric types.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在“字符串与字符串库”一节中更详细地讨论了 C 字符串和 `char` 变量，内容位于[第 93 页](ch02.xhtml#lev1_14)。在这里，我们将主要关注
    C 的数值类型。
- en: C Numeric Types
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: C 数值类型
- en: C supports several different types for storing numeric values. The types differ
    in the format of the numeric values they represent. For example, the `float` and
    `double` types can represent real values, `int` represents signed integer values,
    and `unsigned int` represents unsigned integer values. Real values are positive
    or negative values with a decimal point, such as – 1*.*23 or 0*.*0056\. Signed
    integers store positive, negative, or zero integer values, such as – 333, 0, or
    3456\. Unsigned integers store strictly non-negative integer values, such as 0
    or 1234.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: C 支持多种不同类型来存储数值。不同的类型在表示数值的格式上有所不同。例如，`float` 和 `double` 类型可以表示实数值，`int` 表示有符号整数值，而
    `unsigned int` 表示无符号整数值。实数值是带有小数点的正数或负数，例如 -1.23 或 0.0056。带符号整数存储正数、负数或零的整数值，例如
    -333、0 或 3456。无符号整数存储严格非负的整数值，例如 0 或 1234。
- en: C’s numeric types also differ in the range and precision of the values they
    can represent. The range or precision of a value depends on the number of bytes
    associated with its type. Types with more bytes can represent a larger range of
    values (for integer types), or higher-precision values (for real types), than
    types with fewer bytes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: C 的数值类型在它们能够表示的值的范围和精度上也有所不同。一个值的范围或精度取决于与其类型相关联的字节数。字节数更多的类型可以表示更大的值范围（对于整数类型）或更高精度的值（对于实数类型），而字节数较少的类型则不能。
- en: '[Table 1-1](ch01.xhtml#ch1tab1) shows the number of storage bytes, the kind
    of numeric values stored, and how to declare a variable for a variety of common
    C numeric types (note that these are typical sizes—the exact number of bytes depends
    on the hardware architecture).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-1](ch01.xhtml#ch1tab1) 显示了多种常见 C 数值类型的存储字节数、存储的数值类型，以及如何声明变量（请注意，这些是典型大小——确切的字节数取决于硬件体系结构）。'
- en: '**Table 1-1:** C Numeric Types'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-1：** C 数值类型'
- en: '| **Type name** | **Usual size** | **Values stored** | **How to declare** |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| **类型名称** | **常见大小** | **存储的值** | **如何声明** |'
- en: '| `char` | 1 byte | integers | `char x;` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `char` | 1 字节 | 整数 | `char x;` |'
- en: '| `short` | 2 bytes | signed integers | `short x;` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `short` | 2 字节 | 有符号整数 | `short x;` |'
- en: '| `int` | 4 bytes | signed integers | `int x;` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 4 字节 | 有符号整数 | `int x;` |'
- en: '| `long` | 4 or 8 bytes | signed integers | `long x;` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `long` | 4 或 8 字节 | 有符号整数 | `long x;` |'
- en: '| `long long` | 8 bytes | signed integers | `long long x;` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `long long` | 8 字节 | 有符号整数 | `long long x;` |'
- en: '| `float` | 4 bytes | signed real numbers | `float x;` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 4 字节 | 有符号实数 | `float x;` |'
- en: '| `double` | 8 bytes | signed real numbers | `double x;` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `double` | 8 字节 | 有符号实数 | `double x;` |'
- en: 'C also provides *unsigned* versions of the integer numeric types (`char`, `short`,
    `int`, `long`, and `long long`). To declare a variable as unsigned, add the keyword
    `unsigned` before the type name. For example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: C 还提供了整数数值类型（`char`、`short`、`int`、`long` 和 `long long`）的*无符号*版本。要声明一个无符号变量，请在类型名称前添加关键字`unsigned`。例如：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The C standard doesn’t specify whether the `char` type is signed or unsigned.
    As a result, some implementations might implement `char` as signed integer values
    and others as unsigned. It’s good programming practice to explicitly declare `unsigned
    char` if you want to use the unsigned version of a `char` variable.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: C 标准并未指定 `char` 类型是有符号还是无符号。因此，一些实现可能将 `char` 实现为有符号整数值，另一些实现则为无符号。为了明确使用 `char`
    的无符号版本，良好的编程实践是显式声明 `unsigned char`。
- en: 'The exact number of bytes for each of the C types might vary from one architecture
    to the next. The sizes in [Table 1-1](ch01.xhtml#ch1tab1) are minimum (and common)
    sizes for each type. You can print the exact size on a given machine using C’s
    `sizeof` operator, which takes the name of a type as an argument and evaluates
    to the number of bytes used to store that type. For example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每种 C 类型的字节数可能因体系结构的不同而有所变化。表 [1-1](ch01.xhtml#ch1tab1) 中的大小是每种类型的最小（且常见）大小。你可以使用
    C 的 `sizeof` 运算符在特定的机器上打印出每种类型的准确大小，`sizeof` 运算符接受类型名称作为参数，并计算出存储该类型所使用的字节数。例如：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `sizeof` operator evaluates to an unsigned long value, so in the call to
    `printf`, use the placeholder `%lu` to print its value. On most architectures
    the output of these statements will be:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`sizeof` 运算符的结果为无符号长整型值，因此在调用 `printf` 时，使用占位符 `%lu` 来打印其值。在大多数体系结构中，以下语句的输出将是：'
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Arithmetic Operators
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 算术运算符
- en: Arithmetic operators combine values of numeric types. The resulting type of
    the operation is based on the types of the operands. For example, if two `int`
    values are combined with an arithmetic operator, the resulting type is also an
    integer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符结合数值类型的值。运算结果的类型取决于操作数的类型。例如，如果两个 `int` 值用算术运算符结合，结果类型也将是整数。
- en: C performs automatic type conversion when an operator combines operands of two
    different types. For example, if an `int` operand is combined with a `float` operand,
    the integer operand is first converted to its floating-point equivalent before
    the operator is applied, and the type of the operation’s result is `float`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: C 在运算符组合两种不同类型的操作数时会进行自动类型转换。例如，如果一个 `int` 操作数与一个 `float` 操作数结合，整数操作数会首先转换为其浮点数等价物，然后应用运算符，操作结果的类型为
    `float`。
- en: 'The following arithmetic operators can be used on most numeric type operands:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算术运算符可以用于大多数数值类型操作数：
- en: add (`+`) and subtract (`-`)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加法（`+`）和减法（`-`）
- en: 'multiply (`*`), divide (`/`), and mod(`%`):'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法（`*`）、除法（`/`）和取模（`%`）：
- en: The mod operator (`%`) can only take integer-type operands (`int`, `unsigned
    int`, `short`, and so on).
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 求余运算符（`%`）只能接受整数类型的操作数（`int`、`unsigned int`、`short` 等）。
- en: If both operands are `int` types, the divide operator (`/`) performs integer
    division (the resulting value is an `int`, truncating anything beyond the decimal
    point from the division operation). For example `8/3` evaluates to `2`.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果两个操作数都是 `int` 类型，则除法运算符（`/`）执行整数除法（结果为 `int`，并截断除法操作后的小数部分）。例如，`8/3` 结果为 `2`。
- en: If one or both of the operands are `float` (or `double`), `/` performs real
    division and evaluates to a `float` (or `double`) result. For example, `8/3.0`
    evaluates to approximately `2.666667`.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一个或两个操作数是 `float`（或 `double`），则 `/` 执行实数除法，结果为 `float`（或 `double`）。例如，`8/3.0`
    结果约为 `2.666667`。
- en: 'assignment (`=`):'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值（`=`）：
- en: '[PRE19]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'assignment with update (`+=`, `-=`, `*=`, `/=`, and `%=`):'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带更新的赋值（`+=`、`-=`、`*=`、`/=` 和 `%=`）：
- en: '[PRE20]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'increment (`++`) and decrement (`--`):'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增量（`++`）和减量（`--`）：
- en: '[PRE21]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Warning PRE- VERSUS POST-INCREMENT**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告：前增量与后增量的区别**'
- en: 'The operators `++variable` and `variable++` are both valid, but they’re evaluated
    slightly differently:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符`++variable`和`variable++`都有效，但它们的计算顺序略有不同：
- en: '`++x`: increment `x` first, then use its value.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`++x`：先递增 `x`，然后使用它的值。'
- en: '`x++`: use `x`’s value first, then increment it.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x++`：先使用 `x` 的值，然后再递增它。'
- en: 'In many cases, it doesn’t matter which you use because the value of the incremented
    or decremented variable isn’t being used in the statement. For example, these
    two statements are equivalent (although the first is the most commonly used syntax
    for this statement):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，使用哪种形式并不重要，因为增量或减量变量的值并没有在语句中被使用。例如，以下两条语句是等效的（尽管第一种是最常用的语法）：
- en: x++;
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: x++;
- en: ++x;
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ++x;
- en: 'In some cases, the context affects the outcome (when the value of the incremented
    or decremented variable *is* being used in the statement). For example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，上下文会影响结果（当增量或减量变量的*值*在语句中被使用时）。例如：
- en: x = 6;
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: x = 6;
- en: 'y = ++x + 2;  // y is assigned 9: increment x first, then evaluate x + 2 (9)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: y = ++x + 2;  // y 被赋值为 9：先递增 x，再计算 x + 2（9）
- en: x = 6;
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: x = 6;
- en: 'y = x++ + 2;  // y is assigned 8: evaluate x + 2 first (8), then increment
    x'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: y = x++ + 2;  // y 被赋值为 8：先计算 x + 2（8），然后递增 x
- en: Code like the preceding example that uses an arithmetic expression with an increment
    operator is often hard to read, and it’s easy to get wrong. As a result, it’s
    generally best to avoid writing code like this; instead, write separate statements
    for exactly the order you want. For example, if you want to first increment `x`
    and then assign `x + 1` to `y`, just write it as two separate statements.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 像前面的例子那样，使用带有增量运算符的算术表达式通常很难阅读，而且容易出错。因此，最好避免编写这样的代码；相反，应编写单独的语句，确保按照所需的顺序执行。例如，如果你想先递增`x`，然后将`x
    + 1`赋值给`y`，就将其写成两个单独的语句。
- en: Instead of writing this
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 不要写成这样
- en: y = ++x + 1;
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: y = ++x + 1;
- en: 'write it as two separate statements:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将其写为两个单独的语句：
- en: x++;
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: x++;
- en: y = x + 1;
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: y = x + 1;
- en: 1.2 Input/Output (printf and scanf)
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2 输入/输出（printf 和 scanf）
- en: C’s `printf` function prints values to the terminal, and the `scanf` function
    reads in values entered by a user. The `printf` and `scanf` functions belong to
    C’s standard I/O library, which needs to be explicitly included at the top of
    any `.c` file that uses these functions by using `#include <stdio.h>`. In this
    section, we introduce the basics of using `printf` and `scanf` in C programs.
    “I/O in C (Standard and File)” on [page 113](ch02.xhtml#lev1_16) discusses C’s
    input and output functions in more detail.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: C 的 `printf` 函数将值打印到终端，而 `scanf` 函数则读取用户输入的值。`printf` 和 `scanf` 函数属于 C 的标准输入输出库，必须在使用这些函数的
    `.c` 文件顶部显式包含 `#include <stdio.h>`。在本节中，我们介绍了在 C 程序中使用 `printf` 和 `scanf` 的基本知识。有关
    C 的输入输出函数的详细讨论，请参见 [第113页](ch02.xhtml#lev1_16)中的“C语言中的I/O（标准和文件）”。
- en: 1.2.1 printf
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1 printf
- en: 'C’s `printf` function is very similar to formatted print in Python, where the
    caller specifies a format string to print. The format string often contains formatting
    specifiers, such as special characters that will print tabs (`\t`) or newlines
    (`\n`), or placeholders for values in the output. Placeholders consist of `%`
    followed by a type specifier letter (for example, `%d` represents a placeholder
    for an integer value). For each placeholder in the format string, `printf` expects
    an additional argument. Here, you can see an example program in Python and C with
    formatted output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: C的`printf`函数与Python中的格式化打印非常相似，调用者指定一个格式字符串来打印。格式字符串通常包含格式化说明符，例如打印制表符（`\t`）或换行符（`\n`）的特殊字符，或输出值的占位符。占位符由`%`后跟一个类型说明符字母组成（例如，`%d`表示整数值的占位符）。对于格式字符串中的每个占位符，`printf`期望一个附加的参数。这里有一个Python和C的示例程序，展示了格式化输出：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Python version
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: C version
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: C版本
- en: 'When run, both versions of this program produce identically formatted output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，这两个版本的程序会产生格式完全相同的输出：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The main difference between C’s `printf` and Python’s `print` functions are
    that the Python version implicitly prints a newline character at the end of the
    output string, but the C version does not. As a result, the C format strings in
    this example have newline (`\n`) characters at the end to explicitly print a newline
    character. The syntax for listing the argument values for the placeholders in
    the format string is also slightly different in C’s `printf` and Python’s `print`
    functions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: C的`printf`和Python的`print`函数之间的主要区别在于，Python版本在输出字符串末尾会隐式打印一个换行符，而C版本则不会。因此，本例中的C格式字符串在末尾包含换行符（`\n`），以显式地打印换行符。C的`printf`和Python的`print`函数在格式字符串中列出占位符参数值的语法也略有不同。
- en: 'C uses the same formatting placeholders as Python for specifying different
    types of values. The preceding example demonstrates the following formatting placeholders:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: C使用与Python相同的格式化占位符来指定不同类型的值。前面的示例演示了以下格式化占位符：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'C additionally supports the `%c` placeholder for printing a character value.
    This placeholder is useful when a programmer wants to print the ASCII character
    associated with a particular numeric encoding. Here’s a C code snippet that prints
    a `char` as its numeric value (`%d`) and as its character encoding (`%c`):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: C还支持`%c`占位符，用于打印字符值。当程序员想要打印与特定数字编码关联的ASCII字符时，这个占位符非常有用。以下是一个C代码片段，它打印一个`char`类型的数值（`%d`）和字符编码（`%c`）：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When run, the program’s output looks like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，程序的输出如下所示：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 1.2.2 scanf
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.2 scanf
- en: C’s `scanf` function represents one method for reading in values entered by
    the user (via the keyboard) and storing them in program variables. The `scanf`
    function can be a bit picky about the exact format in which the user enters data,
    which means that it’s not very robust to badly formed user input. In “I/O in C
    (Standard and File)” on [page 113](ch02.xhtml#lev1_16), we discuss more robust
    ways of reading input values from the user. For now, remember that if your program
    gets into an infinite loop due to badly formed user input, you can always press
    CTRL-C to terminate it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: C的`scanf`函数表示读取用户输入的一个方法（通过键盘输入），并将它们存储在程序变量中。`scanf`函数对于用户输入数据的准确格式要求较为严格，这意味着它对格式错误的用户输入不是很容错。在《C语言中的输入输出（标准与文件）》一节中（参见[第113页](ch02.xhtml#lev1_16)），我们讨论了更为健壮的读取用户输入值的方法。现在，记住如果你的程序因为用户输入格式错误而进入无限循环，你可以随时按CTRL-C终止程序。
- en: 'Reading input is handled differently in Python and C: Python uses the `input`
    function to read in a value as a string, and then the program converts the string
    value to an `int`, whereas C uses `scanf` to read in an `int` value and to store
    it at the location in memory of an `int` program variable (for example, `&num1`).
    This code displays example programs for reading user input values in Python and
    C:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python和C中，读取输入的方式不同：Python使用`input`函数将输入值作为字符串读取，然后程序将字符串值转换为`int`类型，而C使用`scanf`读取`int`类型的值，并将其存储在`int`程序变量的内存位置（例如，`&num1`）。这段代码展示了在Python和C中读取用户输入值的示例程序：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Python version
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: C version
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: C版本
- en: 'When run, both programs read in two values (here, 30 and 67):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，两个程序都读取两个值（这里是30和67）：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Like `printf`, `scanf` takes a format string that specifies the number and types
    of values to read in (for example, `"%d"` specifies one `int` value). The `scanf`
    function skips over leading and trailing whitespace as it reads in a numeric value,
    so its format string only needs to contain a sequence of formatting placeholders,
    usually with no whitespace or other formatting characters between the placeholders
    in its format string. The arguments for the placeholders in the format string
    specify the *locations* of program variables into which the values read in will
    be stored. Prefixing the name of a variable with the `&` operator produces the
    location of that variable in the program’s memory — the memory address of the
    variable. “C’s Pointer Variables” on [page 66](ch02.xhtml#lev1_10) discusses the
    `&` operator in more detail. For now, we use it only in the context of the `scanf`
    function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `printf` 类似，`scanf` 也接受一个格式字符串，用来指定要读取的值的数量和类型（例如，`"%d"` 指定一个 `int` 类型的值）。`scanf`
    函数在读取数字值时会跳过前导和尾随的空格，因此其格式字符串只需要包含一系列格式占位符，通常这些占位符之间没有空格或其他格式字符。格式字符串中的占位符的参数指定了程序变量的*位置*，这些变量将存储读取到的值。将变量名前加上
    `&` 操作符会得到该变量在程序内存中的位置——即该变量的内存地址。“C 的指针变量”在[第66页](ch02.xhtml#lev1_10)中更详细地讨论了
    `&` 操作符。现在，我们只在 `scanf` 函数的上下文中使用它。
- en: 'Here’s another `scanf` example, in which the format string has placeholders
    for two values, the first an `int` and the second a `float`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个 `scanf` 示例，其中格式字符串包含两个值的占位符，第一个是 `int`，第二个是 `float`：
- en: scanf_ex.c
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: scanf_ex.c
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When inputting data to a program via `scanf`, individual numeric input values
    must be separated by at least one whitespace character. However, because `scanf`
    skips over additional leading and trailing whitespace characters (for example,
    spaces, tabs, and newlines), a user could enter input values with any amount of
    space before or after each input value. For instance, if a user enters the following
    for the call to `scanf` in the preceding example, `scanf` will read in 8 and store
    it in the `x` variable, and then read in 3.14 and store it in the `pi` variable:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过 `scanf` 输入数据时，单独的数字输入值必须至少由一个空白字符分隔。然而，由于 `scanf` 会跳过额外的前导和尾随空白字符（例如空格、制表符和换行符），用户可以在每个输入值的前后输入任意数量的空白字符。例如，如果用户在前面的
    `scanf` 示例中输入以下内容，`scanf` 将读取 8 并将其存储在 `x` 变量中，然后读取 3.14 并将其存储在 `pi` 变量中：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 1.3 Conditionals and Loops
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3 条件语句与循环
- en: The code examples that follow show that the syntax and semantics of `if`–`else`
    statements in C and Python are very similar. The main syntactic difference is
    that Python uses indentation to indicate “body” statements, whereas C uses curly
    braces (but you should still use good indentation in your C code).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码示例展示了 C 和 Python 中的 `if`–`else` 语句的语法和语义非常相似。主要的语法差异在于，Python 使用缩进来表示“主体”语句，而
    C 使用大括号（但在 C 代码中仍应使用良好的缩进）。
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Python version
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Python 版本
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: C version
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: C 版本
- en: 'The Python and C syntax for `if`–`else` statements is almost identical with
    only minor differences. In both, the `else` part is optional. Python and C also
    support multiway branching by chaining `if` and `else if` statements. The following
    describes the full `if`–`else` C syntax:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Python 和 C 的 `if`–`else` 语句的语法几乎相同，仅有一些细微的差异。在两者中，`else` 部分是可选的。Python 和 C 也都通过链式使用
    `if` 和 `else if` 语句来支持多路分支。以下描述了完整的 `if`–`else` C 语法：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 1.3.1 Boolean Values in C
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.1 C语言中的布尔值
- en: 'C doesn’t provide a Boolean type with true or false values. Instead, integer
    values evaluate to *true* or *false* when used in conditional statements. When
    used in conditional expressions, an integer expression that is:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: C 不提供带有真或假值的布尔类型。相反，整数值在条件语句中被评估为 *真* 或 *假*。在条件表达式中使用时，一个整数表达式：
- en: '*zero* (0) evaluates to *false*;'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*零*（0）被评估为 *假*；'
- en: '*nonzero* (any positive or negative value) evaluates to *true*.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*非零*（任何正值或负值）被评估为 *真*。'
- en: 'C has a set of relational and logical operators for Boolean expressions. The
    *relational operators* take operand(s) of the same type and evaluate to zero (false)
    or nonzero (true). The set of relational operators are:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: C 提供了一组关系和逻辑运算符用于布尔表达式。*关系运算符*接受相同类型的操作数，并计算出零（假）或非零（真）。关系运算符的集合包括：
- en: equality (`==` and inequality (not equal, `!=`);
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 相等（`==`）和不等（`!=`）；
- en: 'comparison operators: less than (`<`), less than or equal (`<=`), greater than
    (`>`), and greater than or equal (`>=`).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符：小于（`<`）、小于或等于（`<=`）、大于（`>`）和大于或等于（`>=`）。
- en: 'The following C code snippets show examples of relational operators:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下C语言代码片段显示了关系运算符的示例：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'C’s *logical operators* take integer “Boolean” operand(s) and evaluate to either
    zero (false) or nonzero (true). The set of logical operators are:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: C语言的*逻辑运算符*接受整数“布尔”操作数，并评估为零（假）或非零（真）。逻辑运算符包括：
- en: logical negation (`!`);
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑非（`!`）；
- en: 'logical and (`&&`): stops evaluating at the first false expression (short-circuiting);'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑与（`&&`）：在遇到第一个假表达式时停止评估（短路运算）；
- en: 'logical or (`||`): stops evaluating at the first true expression (short-circuiting).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑或（`||`）：在遇到第一个真表达式时停止评估（短路运算）。
- en: C’s *short-circuit* logical operator evaluation stops evaluating a logical expression
    as soon as the result is known. For example, if the first operand to a logical
    and (`&&`) expression evaluates to false, the result of the `&&` expression must
    be false. As a result, the second operand’s value need not be evaluated, and it
    is not evaluated.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: C语言的*短路*逻辑运算符评估逻辑表达式时，如果结果已知，就停止评估。例如，如果逻辑与（`&&`）表达式的第一个操作数评估为假，则`&&`表达式的结果必须为假。因此，第二个操作数的值不需要再评估，也不会被评估。
- en: 'The following is an example of conditional statements in C that use logical
    operators (it’s always best to use parentheses around complex Boolean expressions
    to make them easier to read):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用逻辑运算符的C语言条件语句示例（通常最好在复杂的布尔表达式周围使用括号，使其更易于阅读）：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 1.3.2 Loops in C
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.2 C语言中的循环
- en: Like Python, C supports `for` and `while` loops. Additionally, C provides `do`–`while`
    loops.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 和Python一样，C语言支持`for`和`while`循环。此外，C语言还提供了`do`–`while`循环。
- en: while Loops
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`while`循环'
- en: 'The `while` loop syntax in C and Python is almost identical, and the behavior
    is the same. Here, you can see example programs with `while` loops in C and Python:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: C语言和Python中的`while`循环语法几乎相同，行为也相同。在这里，你可以看到使用`while`循环的C语言和Python示例程序：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Python version
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: C version
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: C版本
- en: 'The `while` loop syntax in C is very similar in Python, and both are evaluated
    in the same way:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: C语言中的`while`循环语法与Python非常相似，并且两者的评估方式相同：
- en: '[PRE40]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `while` loop checks the Boolean expression first and executes the body
    if true. In the preceding example program, the value of the `val` variable will
    be repeatedly printed in the `while` loop until its value is greater than the
    value of the `num` variable. If the user enters `10`, the C and Python programs
    will print:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环首先检查布尔表达式，如果为真，则执行循环体。在上面的示例程序中，`val`变量的值将在`while`循环中反复打印，直到其值大于`num`变量的值。如果用户输入`10`，C语言和Python程序将打印：'
- en: '[PRE41]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'C also has a `do`–`while` loop that is similar to its `while` loop, but it
    executes the loop body first and then checks a condition and repeats executing
    the loop body for as long as the condition is true. That is, a `do`–`while` loop
    will always execute the loop body at least one time:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: C语言也有一个`do`–`while`循环，它与`while`循环类似，但它首先执行循环体，然后检查条件，并在条件为真时重复执行循环体。也就是说，`do`–`while`循环至少会执行一次循环体：
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For additional `while` loop examples, have a look at `whileLoop1.c`^([6](ch01.xhtml#fn1_6))
    and `whileLoop2.c`.^([7](ch01.xhtml#fn1_7))
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多`while`循环示例，请参阅`whileLoop1.c`^([6](ch01.xhtml#fn1_6))和`whileLoop2.c`。^([7](ch01.xhtml#fn1_7))
- en: for Loops
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: 'The `for` loop is different in C than it is in Python. In Python, `for` loops
    are iterations over sequences, whereas in C, `for` loops are more general looping
    constructs. Here are example programs that use `for` loops to print all the values
    between 0 and a user-provided input number:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: C语言中的`for`循环与Python中的`for`循环有所不同。在Python中，`for`循环是对序列的迭代，而在C语言中，`for`循环是一种更通用的循环结构。以下是使用`for`循环打印0到用户提供的输入数之间所有值的示例程序：
- en: '[PRE43]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Python version
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: C version
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: C版本
- en: In this example, you can see that the C `for` loop syntax is quite different
    from the Python `for` loop syntax. It’s also evaluated differently.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到C语言的`for`循环语法与Python的`for`循环语法有很大不同。它们的评估方式也不同。
- en: 'The C `for` loop syntax is:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: C语言的`for`循环语法是：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `for` loop evaluation rules are:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的评估规则是：'
- en: 1\. Evaluate <initialization> one time when first entering the loop.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 在第一次进入循环时评估<initialization>一次。
- en: 2\. Evaluate the <boolean expression> . If it’s 0 (false), drop out of the `for`
    loop (in other words, the program is done repeating the loop body statements).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 评估<boolean expression>。如果为0（假），则退出`for`循环（换句话说，程序完成了对循环体语句的重复执行）。
- en: 3\. Evaluate the statements inside the loop <body> .
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 评估循环体内的语句<body>。
- en: 4\. Evaluate the <step> expression.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 评估<step>表达式。
- en: 5\. Repeat from step (2).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 从步骤（2）重复。
- en: 'Here’s a simple example `for` loop to print the values 0, 1, and 2:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的`for`循环示例，用于打印 0、1 和 2 的值：
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Executing the `for` loop evaluation rules on the preceding loop yields the
    following sequence of actions:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对前面的循环执行`for`循环评估规则会得到以下操作顺序：
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The following program shows a more complicated `for` loop example (it’s also
    available to download^([8](ch01.xhtml#fn1_8))). Note that just because C supports
    `for` loops with a list of statements for its <initialization> and <step> parts,
    it’s best to keep it simple. (This example illustrates a more complicated `for`
    loop syntax, but the `for` loop would be easier to read and understand if it were
    simplified by moving the `j` `+= 10` step statement to the end of the loop body
    and having just a single step statement, `i += 1`.)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序展示了一个更复杂的`for`循环示例（也可以下载^([8](ch01.xhtml#fn1_8))）。请注意，仅仅因为 C 支持具有语句列表作为其<初始化>和<步骤>部分的`for`循环，并不意味着必须复杂化。
    （这个示例展示了一个更复杂的`for`循环语法，但如果通过将`j += 10`步骤语句移到循环体的末尾，并仅使用一个步骤语句`i += 1`，`for`循环会更易读和理解。）
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In C, `for` loops and `while` loops are equivalent in power, meaning that any
    `while` loop can be expressed as a `for` loop, and vice versa. The same is not
    true in Python, where `for` loops are iterations over a sequence of values. As
    such, they cannot express some looping behavior that the more general Python `while`
    loop can express. Indefinite loops are one example that can only be written as
    a `while` loop in Python.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中，`for`循环和`while`循环是等价的，这意味着任何`while`循环都可以用`for`循环来表示，反之亦然。 Python 中情况不同，`for`循环是对一系列值的迭代。因此，它们不能表达一些更通用的
    Python `while`循环能够表达的循环行为。像不确定循环就是一个只能用`while`循环在 Python 中实现的例子。
- en: 'Consider the following `while` loop in C:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 C 语言中的`while`循环：
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This loop can be translated to an equivalent `for` loop in C:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环可以翻译为一个等效的 C 语言`for`循环：
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In Python, however, this type of looping behavior can be expressed only by using
    a `while` loop.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Python 中，这种类型的循环行为只能通过使用`while`循环来表达。
- en: Because `for` and `while` loops are equally expressive in C, only one looping
    construct is needed in the language. However, `for` loops are a more natural language
    construct for definite loops (like iterating over a range of values), whereas
    `while` loops are a more natural language construct for indefinite loops (like
    repeating until the user enters an even number). As a result, C provides both
    to programmers.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在 C 语言中，`for`和`while`循环具有相同的表达能力，所以语言中只需要一种循环结构。然而，`for`循环对于确定次数的循环（例如迭代一系列值）来说是更自然的语言结构，而`while`循环则是更自然的语言结构，用于不确定次数的循环（例如，重复执行直到用户输入一个偶数）。因此，C
    提供了这两种循环结构供程序员使用。
- en: 1.4 Functions
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4 函数
- en: 'Functions break code into manageable pieces and reduce code duplication. Functions
    might take zero or more *parameters* as input and they *return* a single value
    of a specific type. A function *declaration* or *prototype* specifies the function’s
    name, its return type, and its parameter list (the number and types of all the
    parameters). A function *definition* includes the code to be executed when the
    function is called. All functions in C must be declared before they’re called.
    This can be done by declaring a function prototype or by fully defining the function
    before calling it:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将代码分解成可管理的部分，并减少代码重复。函数可能接受零个或多个*参数*作为输入，并且*返回*一个特定类型的单一值。函数*声明*或*原型*指定函数的名称、返回类型和参数列表（所有参数的数量和类型）。函数*定义*包括函数调用时要执行的代码。所有的
    C 函数在调用之前必须声明。这可以通过声明函数原型或在调用之前完全定义函数来实现：
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here’s an example function definition. Note that the comments describe what
    the function does, the details of each parameter (what it’s used for and what
    it should be passed), and what the function returns:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数定义的示例。请注意，注释描述了函数的功能、每个参数的详细信息（它的用途以及应该传递什么），以及函数返回的内容：
- en: '[PRE52]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Functions that don’t return a value should specify the `void` return type.
    Here’s an example of a `void` function:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 不返回值的函数应该指定`void`返回类型。以下是一个`void`函数的示例：
- en: '[PRE53]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As in any programming language that supports functions or procedures, a *function
    call* invokes a function, passing specific argument values for the particular
    call. A function is called by its name and is passed arguments, with one argument
    for each corresponding function parameter. In C, calling a function looks like
    this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如同任何支持函数或过程的编程语言一样，*函数调用*通过传递特定的参数值来调用函数。一个函数通过其名称被调用，并传入与函数参数一一对应的参数。在 C 中，调用函数的方式如下：
- en: '[PRE54]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Arguments to C functions are *passed by value*: each function parameter is
    assigned the *value* of the corresponding argument passed to it in the function
    call by the caller. Pass by value semantics mean that any change to a parameter’s
    value in the function (that is, assigning a parameter a new value in the function)
    is *not visible* to the caller.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: C函数的参数是*按值传递*的：每个函数参数被赋予调用者在函数调用时传递给它的对应参数的*值*。按值传递的语义意味着，函数内对参数值的任何改变（即在函数内给参数赋新值）对调用者来说是*不可见的*。
- en: 'Here are some example function calls to the `max` and `print_table` functions
    listed earlier:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些对前面提到的`max`和`print_table`函数的示例调用：
- en: '[PRE55]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here is another example of a full program that shows a call to a slightly different
    implementation of the `max` function that has an additional statement to change
    the value of its parameter (`x = y`):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个完整程序的示例，展示了对`max`函数一个稍有不同实现的调用，该实现增加了一条语句来改变它的参数值（`x = y`）：
- en: '[PRE56]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The following output shows what two runs of this program might look like. Note
    the difference in the parameter `x`’s value (printed from inside the `max` function)
    in the two runs. Specifically, notice that changing the value of parameter `x`
    in the second run does *not* affect the variable that was passed in as an argument
    to `max` after the call returns:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出展示了该程序两次运行的可能结果。注意在两次运行中，参数`x`的值（从`max`函数内部打印出来）有所不同。特别是，注意到在第二次运行中，改变参数`x`的值并*不会*影响在调用返回后传递给`max`的变量。
- en: '[PRE57]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Because arguments are *passed by value* to functions, the preceding version
    of the `max` function that changes one of its parameter values behaves identically
    to the original version of `max` that does not.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 因为参数是*按值传递*给函数的，所以前述的`max`函数版本，它改变了一个参数的值，行为与原始版本的`max`函数相同，后者没有改变任何参数的值。
- en: 1.4.1 The Stack
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.1 栈
- en: The *execution stack* keeps track of the state of active functions in a program.
    Each function call creates a new *stack frame* (sometimes called an *activation
    frame* or *activation record*) containing its parameter and local variable values.
    The frame on the top of the stack is the active frame; it represents the function
    activation that is currently executing, and only its local variables and parameters
    are in scope. When a function is called, a new stack frame is created for it (*pushed*
    on the top of the stack), and space for its local variables and parameters is
    allocated in the new frame. When a function returns, its stack frame is removed
    from the stack (*popped* from the top of the stack), leaving the caller’s stack
    frame on the top of the stack.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*执行栈*跟踪程序中活动函数的状态。每次函数调用都会创建一个新的*栈帧*（有时称为*激活帧*或*激活记录*），其中包含该函数的参数和局部变量的值。栈顶的帧是活动帧，它代表当前正在执行的函数激活，只有它的局部变量和参数在作用域内。当函数被调用时，会为其创建一个新的栈帧（*推入*栈顶），并在新帧中分配空间存储其局部变量和参数。当函数返回时，其栈帧会从栈中移除（*弹出*栈顶），留下调用者的栈帧作为栈顶。'
- en: For the preceding example program, at the point in its execution right before
    `max` executes the `return` statement, the execution stack will look like [Figure
    1-3](ch01.xhtml#ch1fig3). Recall that the argument values to `max` passed by `main`
    are *passed by value*, meaning that the parameters to `max`, `x` and `y`, are
    assigned the values of their corresponding arguments, `a` and `b` from the call
    in `main`. Despite the `max` function changing the value of `x`, the change doesn’t
    affect the value of `a` in `main`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的示例程序，在执行到`max`执行`return`语句之前，执行栈的状态如[图1-3](ch01.xhtml#ch1fig3)所示。回想一下，`main`传递给`max`的参数值是*按值传递*的，这意味着`max`的参数`x`和`y`被赋予了它们对应的参数`a`和`b`的值，这些值来自`main`中的调用。尽管`max`函数改变了`x`的值，但这个变化并不会影响`main`中`a`的值。
- en: '![image](../images/01fig03.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/01fig03.jpg)'
- en: '*Figure 1-3: The execution stack contents just before returning from the `max`
    function*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-3：从`max`函数返回前的执行栈内容*'
- en: The following full program includes two functions and shows examples of calling
    them from the `main` function. In this program, we declare function prototypes
    for `max` and `print_table` above the `main` function so that `main` can access
    them despite being defined first. The `main` function contains the high-level
    steps of the full program, and defining it first echoes the top-down design of
    the program. This example includes comments describing the parts of the program
    that are important to functions and function calls. You can also download and
    run the full program.^([9](ch01.xhtml#fn1_9))
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下完整程序包含两个函数，并展示了如何从 `main` 函数调用它们。在这个程序中，我们在 `main` 函数之前声明了 `max` 和 `print_table`
    的函数原型，这样 `main` 即使先定义，也能访问它们。`main` 函数包含程序的高层步骤，先定义它反映了程序的自顶向下设计。此示例包括描述程序中重要部分（如函数和函数调用）的注释。你还可以下载并运行完整程序。^([9](ch01.xhtml#fn1_9))
- en: '[PRE58]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 1.5 Arrays and Strings
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5 数组与字符串
- en: An *array* is a C construct that creates an ordered collection of data elements
    of the same type and associates this collection with a single program variable.
    *Ordered* means that each element is in a specific position in the collection
    of values (that is, there is an element in position 0, position 1, and so on),
    not that the values are necessarily sorted. Arrays are one of C’s primary mechanisms
    for grouping multiple data values and referring to them by a single name. Arrays
    come in several flavors, but the basic form is a *one-dimensional array*, which
    is useful for implementing list-like data structures and strings in C.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组*是 C 中的一种结构，它创建了一个有序的数据元素集合，这些元素都是相同类型，并将该集合与一个程序变量关联。*有序*意味着每个元素在集合中的位置是特定的（即，位置
    0、位置 1 等），而不是说这些值必须是排序的。数组是 C 中用于将多个数据值组合在一起并通过一个单一名称引用它们的主要机制之一。数组有多种形式，但基本形式是*一维数组*，它对于实现类似列表的数据结构和字符串在
    C 中非常有用。'
- en: 1.5.1 Introduction to Arrays
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.1 数组简介
- en: C arrays can store multiple data values of the *same* type. In this chapter,
    we discuss *statically declared* arrays, meaning that the total capacity (the
    maximum number of elements that can be stored in an array) is fixed and is defined
    when the array variable is declared. In the next chapter, we discuss other array
    types such as “Dynamically Allocated” on [page 153](ch02.xhtml#lev3_9) and “Two-Dimensional
    Arrays” on [page 84](ch02.xhtml#lev2_23).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: C 数组可以存储多个相同类型的数据值。本章我们讨论的是*静态声明*的数组，意味着数组的总容量（即可以存储的最大元素数量）是固定的，并且在数组变量声明时就已定义。在下一章中，我们将讨论其他数组类型，如“动态分配”数组，详见
    [第 153 页](ch02.xhtml#lev3_9)，以及“两维数组”，详见 [第 84 页](ch02.xhtml#lev2_23)。
- en: The following code shows Python and C versions of a program that initializes
    and then prints a collection of integer values. The Python version uses its built-in
    list type to store the list of values, whereas the C version uses an array of
    `int` types to store the collection of values.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了 Python 和 C 版本的程序，程序初始化并打印一个整数值集合。Python 版本使用内置的列表类型存储这些值，而 C 版本则使用 `int`
    类型的数组来存储这些值。
- en: In general, Python provides a high-level list interface to the programmer that
    hides much of the low-level implementation details. C, on the other hand, exposes
    a low-level array implementation to the programmer and leaves it up to the programmer
    to implement higher-level functionality. In other words, arrays enable low-level
    data storage without higher-level list functionality, such as `len`, `append`,
    `insert`, and so on.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Python 提供了一个高级的列表接口，隐藏了许多低级的实现细节。而 C 则向程序员暴露了低级的数组实现，并由程序员来实现更高级的功能。换句话说，数组允许低级数据存储，而没有高级的列表功能，例如
    `len`、`append`、`insert` 等。
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Python version
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Python 版本
- en: '[PRE60]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '*C version*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*C 版本*'
- en: The C and Python versions of this program have several similarities, most notably
    that individual elements can be accessed via *indexing*, and that index values
    start at `0`. That is, both languages refer to the very first element in a collection
    as the element at position `0`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: C 版本和 Python 版本的程序有许多相似之处，最明显的是可以通过*索引*访问各个元素，而且索引值从 `0` 开始。也就是说，两种语言都将集合中的第一个元素称为位置
    `0` 的元素。
- en: 'The main differences in the C and Python versions of this program relate to
    the capacity of the list or array and how their sizes (number of elements) are
    determined. For a Python list:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的 C 版本和 Python 版本的主要区别在于列表或数组的容量以及它们的大小（元素个数）如何确定。对于 Python 列表：
- en: '[PRE61]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'For a C array:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 C 数组：
- en: '[PRE62]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the Python version, the programmer doesn’t need to specify the capacity
    of a list in advance: Python automatically increases a list’s capacity as needed
    by the program. For example, the Python `append` function automatically increases
    the size of the Python list and adds the passed value to the end.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 版本中，程序员不需要事先指定列表的容量：Python 会根据程序需要自动增加列表的容量。例如，Python 的 `append` 函数会自动增加列表的大小，并将传入的值添加到列表的末尾。
- en: 'In contrast, when declaring an array variable in C, the programmer must specify
    its type (the type of each value stored in the array) and its total capacity (the
    maximum number of storage locations). For example:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在 C 语言中声明数组变量时，程序员必须指定其类型（数组中每个值的类型）和总容量（最大存储位置数量）。例如：
- en: '[PRE63]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The preceding declarations create one variable named `arr`, an array of `int`
    values with a total capacity of 10, and another variable named `str`, an array
    of `char` values with a total capacity of 20.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 上述声明创建了一个名为 `arr` 的变量，这是一个容量为 10 的 `int` 数组；另一个名为 `str` 的变量，是一个容量为 20 的 `char`
    数组。
- en: To compute the size of a list (size meaning the total number of values in the
    list), Python provides a `len` function that returns the size of any list passed
    to it. In C, the programmer has to explicitly keep track of the number of elements
    in the array (for example, the `size` variable in the C listing on [page 47](ch01.xhtml#lev2_10)).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 计算列表的大小（大小是指列表中的总值个数），Python 提供了一个 `len` 函数，它返回传入的任何列表的大小。在 C 语言中，程序员必须显式地跟踪数组中元素的数量（例如，在
    [第 47 页](ch01.xhtml#lev2_10) C 示例中的 `size` 变量）。
- en: Another difference that might not be apparent from looking at the Python and
    C versions of this program is how the Python list and the C array are stored in
    memory. C dictates the array layout in program memory, whereas Python hides how
    lists are implemented from the programmer. In C, individual array elements are
    allocated in consecutive locations in the program’s memory. For example, the third
    array position is located in memory immediately following the second array position
    and immediately before the fourth array position.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 和 C 版本的程序来看，另一个可能不明显的差异是 Python 列表和 C 数组在内存中的存储方式。C 语言规定了数组在程序内存中的布局，而
    Python 则隐藏了列表的实现方式。在 C 语言中，单个数组元素会在程序内存中连续分配位置。例如，第三个数组位置紧接着第二个数组位置，并紧接在第四个数组位置之前。
- en: 1.5.2 Array Access Methods
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.2 数组访问方法
- en: 'Python provides multiple ways to access elements in its lists. C, however,
    supports only indexing, as described earlier. Valid index values range from 0
    to the capacity of the array minus 1\. Here are some examples:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了多种访问列表元素的方法，而 C 语言则仅支持索引，如前所述。有效的索引值范围从 0 到数组容量减去 1。以下是一些示例：
- en: '[PRE64]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This example declares the array with a capacity of 10 (it has 10 elements),
    but it only uses the first six (our current collection of values is size 6, not
    10). It’s often the case when using statically declared arrays that some of an
    array’s capacity will remain unused. As a result, we need another program variable
    to keep track of the actual size (number of elements) in the array (`num` in this
    example).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例声明了一个容量为 10 的数组（它有 10 个元素），但只使用了前六个（我们当前的值集合大小是 6，而不是 10）。在使用静态声明数组时，通常会有一些数组的容量未被使用。因此，我们需要另一个程序变量来跟踪数组中的实际大小（元素数量）（在这个例子中是
    `num`）。
- en: Python and C differ in their error-handling approaches when a program attempts
    to access an invalid index. Python throws an `IndexError` exception if an invalid
    index value is used to access elements in a list (e.g., indexing beyond the number
    of elements in a list). In C, it’s up to the programmer to ensure that their code
    uses only valid index values when indexing into arrays. As a result, for code
    like the following that accesses an array element beyond the bounds of the allocated
    array, the program’s runtime behavior is undefined.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序尝试访问无效索引时，Python 和 C 在错误处理方法上有所不同。如果使用无效的索引值访问列表中的元素（例如，索引超出列表元素数量），Python
    会抛出 `IndexError` 异常。而在 C 语言中，程序员需要确保代码仅使用有效的索引值来访问数组。因此，对于像下面这样访问超出分配数组范围的数组元素的代码，程序的运行时行为是未定义的。
- en: '[PRE65]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The C compiler is happy to compile code that accesses array positions beyond
    the bounds of the array; there is no bounds checking by the compiler or at runtime.
    As a result, running this code can lead to unexpected program behavior (and the
    behavior might differ from run to run). It can lead to your program crashing,
    it can change another variable’s value, or it might have no effect on your program’s
    behavior. In other words, this situation leads to a program bug that might or
    might not show up as unexpected program behavior. Thus, as a C programmer, it’s
    up to you to ensure that your array accesses refer to valid positions!
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: C语言编译器可以愉快地编译访问数组越界位置的代码；编译器或运行时都没有进行边界检查。因此，运行这段代码可能会导致程序行为异常（并且这种行为可能每次运行都不同）。它可能导致程序崩溃，可能更改其他变量的值，或者可能对程序行为没有任何影响。换句话说，这种情况会导致程序错误，这种错误可能会表现为意外的程序行为，也可能不会。作为C程序员，你需要确保你的数组访问指向有效的位置！
- en: 1.5.3 Arrays and Functions
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.3 数组与函数
- en: 'The semantics of passing arrays to functions in C is similar to that of passing
    lists to functions in Python: the function can alter the elements in the passed
    array or list. Here’s an example function that takes two parameters, an `int`
    array parameter (`arr`), and an `int` parameter (`size`):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，传递数组给函数的语义类似于在Python中传递列表给函数：函数可以修改传递的数组或列表中的元素。以下是一个示例函数，接受两个参数，一个是`int`类型的数组参数（`arr`），另一个是`int`类型的参数（`size`）：
- en: '[PRE66]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `[]` after the parameter name tells the compiler that the type of the parameter
    `arr` is *array of int*, not `int` like the parameter `size`. In the next chapter,
    we show an alternate syntax for specifying array parameters. The capacity of the
    array parameter `arr` isn’t specified: `arr[]` means that this function can be
    called with an array argument of any capacity. Because there is no way to get
    an array’s size or capacity just from the array variable, functions that are passed
    arrays almost always also have a second parameter that specifies the array’s size
    (the `size` parameter in the preceding example).'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 参数名后面的`[]`告诉编译器，参数`arr`的类型是*整数数组*，而不是像参数`size`那样的`整数`。在下一章，我们将展示指定数组参数的另一种语法。数组参数`arr`的容量没有指定：`arr[]`意味着这个函数可以接受任何容量的数组作为参数。因为无法仅通过数组变量获取数组的大小或容量，所以传递数组的函数几乎总是会有第二个参数来指定数组的大小（如前面示例中的`size`参数）。
- en: 'To call a function that has an array parameter, pass *the name of the array*
    as the argument. Here is a C code snippet with example calls to the `print_array`
    function:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用一个有数组参数的函数，请将*数组的名称*作为参数传递。以下是一个C语言代码片段，包含调用`print_array`函数的示例：
- en: '[PRE67]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In C, the name of the array variable is equivalent to the *base address* of
    the array (i.e., the memory location of its 0th element). Due to C’s *pass by
    value* function call semantics, when you pass an array to a function, each element
    of the array is *not* individually passed to the function. In other words, the
    function isn’t receiving a copy of each array element. Instead, an array parameter
    gets the *value of the array’s base address*. This behavior implies that when
    a function modifies the elements of an array that was passed as a parameter, the
    changes *will* persist when the function returns. For example, consider this C
    program snippet:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，数组变量的名称等同于数组的*基地址*（即其第一个元素的内存位置）。由于C语言的*按值传递*函数调用语义，当你将数组传递给函数时，并不是将数组的每个元素单独传递给函数。换句话说，函数并没有接收到每个数组元素的副本。相反，数组参数接收到的是*数组基地址的值*。这种行为意味着，当一个函数修改了作为参数传递的数组的元素时，修改*会*在函数返回时保留。例如，考虑下面这个C语言程序片段：
- en: '[PRE68]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The call in `main` to the `test` function is passed the argument `arr`, whose
    value is the base address of the `arr` array in memory. The parameter `a` in the
    test function gets a copy of this base address value. In other words, parameter
    `a` *refers to the same array storage locations as its argument*, `arr`. As a
    result, when the test function changes a value stored in the `a` array (`a[3]
    = 8`), it affects the corresponding position in the argument array (`arr[3]` is
    now 8). The reason is that the value of `a` is the base address of `arr`, and
    the value of `arr` is the base address of `arr`, so both `a` and `arr` refer to
    the same array (the same storage locations in memory)! [Figure 1-4](ch01.xhtml#ch1fig4)
    shows the stack contents at the point in the execution just before the test function
    returns.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`中调用`test`函数时，传递了参数`arr`，其值是`arr`数组在内存中的基地址。`test`函数中的参数`a`获得了这个基地址值的副本。换句话说，参数`a`*指向与其参数*`arr`*相同的数组存储位置*。因此，当`test`函数更改存储在`a`数组中的值（`a[3]
    = 8`）时，它会影响参数数组中的相应位置（`arr[3]`现在为8）。原因是`a`的值是`arr`的基地址，`arr`的值也是`arr`的基地址，因此`a`和`arr`指向相同的数组（即内存中的相同存储位置）！[图
    1-4](ch01.xhtml#ch1fig4)显示了在`test`函数返回之前执行时堆栈中的内容。
- en: '![image](../images/01fig04.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/01fig04.jpg)'
- en: '*Figure 1-4: The stack contents for a function with an array parameter*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-4：带有数组参数的函数的堆栈内容*'
- en: Parameter `a` is passed the value of the base address of the array argument
    `arr`, which means they both refer to the same set of array storage locations
    in memory. We indicate this with the arrow from `a` to `arr`. Values that get
    modified by the function `test` are highlighted. Changing the value of the parameter
    `size` does *not* change the value of its corresponding argument `n`, but changing
    the value of one of the elements referred to by `a` (e.g., `a[3] = 8`) does affect
    the value of the corresponding position in `arr`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`a`被传入数组参数`arr`的基地址值，这意味着它们都指向内存中相同的一组数组存储位置。我们通过从`a`指向`arr`的箭头来表示这一点。函数`test`修改的值被突出显示。修改参数`size`的值*不会*改变其对应参数`n`的值，但修改`a`所指向的某个元素的值（例如，`a[3]
    = 8`）会影响`arr`中对应位置的值。
- en: 1.5.4 Introduction to Strings and the C String Library
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.4 字符串及 C 字符串库简介
- en: Python implements a string type and provides a rich interface for using strings,
    but there is no corresponding string type in C. Instead, strings are implemented
    as arrays of `char` values. Not every character array is used as a C string, but
    every C string is a character array.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Python 实现了一种字符串类型并提供了丰富的接口来使用字符串，但 C 语言中没有对应的字符串类型。相反，字符串在 C 中实现为`char`类型的数组。并不是每个字符数组都作为
    C 字符串使用，但每个 C 字符串都是字符数组。
- en: 'Recall that arrays in C might be defined with a larger size than a program
    ultimately uses. For example, we saw in the “Array Access Methods” section on
    [page 47](ch01.xhtml#lev2_10) that we might declare an array of size 10 but only
    use the first six positions. This behavior has important implications for strings:
    we can’t assume that a string’s length is equal to that of the array that stores
    it. For this reason, strings in C must end with a special character value, the
    *null character* (`’\0’`), to indicate the end of the string.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，C 语言中的数组可能被定义为比程序最终使用的大小更大的尺寸。例如，在“数组访问方法”一节中我们看到，可能声明一个大小为 10 的数组，但只使用前六个位置。这种行为对字符串有重要影响：我们不能假设字符串的长度等于存储它的数组的大小。因此，C
    语言中的字符串必须以一个特殊字符值——*空字符*（`’\0’`）——来表示字符串的结束。
- en: Strings that end with a null character are said to be *null-terminated*. Although
    all strings in C *should* be null-terminated, failing to properly account for
    null characters is a common source of errors for novice C programmers. When using
    strings, it’s important to keep in mind that your character arrays must be declared
    with enough capacity to store each character value in the string plus the null
    character (`’\0’`). For example, to store the string `"hi"`, you need an array
    of at least three chars (one to store `'h'`, one to store `'i'`, and one to store
    `'\0'`).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 以空字符结尾的字符串称为*空终止*。尽管所有 C 语言中的字符串*应该*是空终止的，但未正确处理空字符是初学 C 语言的程序员常见的错误来源。在使用字符串时，必须记住字符数组必须声明足够的容量来存储字符串中的每个字符值以及空字符（`’\0’`）。例如，要存储字符串`"hi"`，你需要一个至少包含三个字符的数组（一个存储`'h'`，一个存储`'i'`，一个存储`'\0'`）。
- en: Because strings are commonly used, C provides a string library that contains
    functions for manipulating strings. Programs that use these string library functions
    need to include the `string.h` header.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串是常用的，C 提供了一个包含字符串操作函数的字符串库。使用这些字符串库函数的程序需要包含`string.h`头文件。
- en: When printing the value of a string with `printf`, use the `%s` placeholder
    in the format string. The `printf` function will print all the characters in the
    array argument until it encounters the `’\0’` character. Similarly, string library
    functions often either locate the end of a string by searching for the `’\0’`
    character or add a `’\0’` character to the end of any string that they modify.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`printf`打印字符串的值时，使用格式字符串中的`%s`占位符。`printf`函数会打印数组参数中的所有字符，直到遇到`’\0’`字符。同样，字符串库函数通常通过查找`’\0’`字符来定位字符串的结尾，或者向任何它们修改的字符串末尾添加`’\0’`字符。
- en: 'Here’s an example that uses strings and string library functions:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用字符串和字符串库函数的示例：
- en: '[PRE69]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `strlen` function in the C string library returns the number of characters
    in its string argument. A string’s terminating null character doesn’t count as
    part of the string’s length, so the call to `strlen(str1)` returns 2 (the length
    of the string `"hi"`). The `strcpy` function copies one character at a time from
    a source string (the second parameter) to a destination string (the first parameter)
    until it reaches a null character in the source.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: C 字符串库中的`strlen`函数返回字符串参数中字符的数量。字符串的终止空字符不算作字符串长度的一部分，因此对`strlen(str1)`的调用返回
    2（字符串`"hi"`的长度）。`strcpy`函数会从源字符串（第二个参数）一个字符一个字符地复制到目标字符串（第一个参数），直到遇到源字符串中的空字符为止。
- en: Note that most C string library functions expect the call to pass in a character
    array that has enough capacity for the function to perform its job. For example,
    you wouldn’t want to call `strcpy` with a destination string that isn’t large
    enough to contain the source; doing so will lead to undefined behavior in your
    program!
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，大多数 C 字符串库函数期望传入一个字符数组，数组的容量足以让函数完成其任务。例如，你不希望调用`strcpy`时，目标字符串的容量不足以容纳源字符串；这样做会导致程序出现未定义行为！
- en: C string library functions also require that string values passed to them are
    correctly formed, with a terminating `’\0’` character. It’s up to you as the C
    programmer to ensure that you pass in valid strings for C library functions to
    manipulate. Thus, in the call to `strcpy` in the preceding example, if the source
    string (`str1`) was not initialized to have a terminating `’\0’` character, `strcpy`
    would continue beyond the end of the `str1` array’s bounds, leading to undefined
    behavior that could cause it to crash.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: C 字符串库函数还要求传入的字符串值是正确格式的，并且以`’\0’`字符作为终止符。作为 C 程序员，你有责任确保传递给 C 库函数的字符串是有效的。因此，在前面的示例中，如果源字符串（`str1`）没有初始化以包含终止的`’\0’`字符，`strcpy`会继续访问超出`str1`数组边界的内存，导致未定义行为，可能会导致程序崩溃。
- en: '**Warning STRCPY CAN BE AN UNSAFE FUNCTION**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告 STRCPY 可能是一个不安全的函数**'
- en: The previous example uses the `strcpy` function safely. In general, though,
    `strcpy` poses a security risk because it assumes that its destination is large
    enough to store the entire string, which may not always be the case (for example,
    if the string comes from user input).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例安全地使用了`strcpy`函数。但一般来说，`strcpy`存在安全风险，因为它假设目标足够大，能够存储整个字符串，但这并不总是成立（例如，如果字符串来自用户输入）。
- en: We chose to show `strcpy` now to simplify the introduction to strings, but we
    illustrate safer alternatives in the “Strings and the String Library" section.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择现在展示`strcpy`是为了简化对字符串的介绍，但我们在“字符串与字符串库”章节中展示了更安全的替代方法。
- en: In the next chapter, we discuss C strings and the string library in more detail.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地讨论 C 字符串和字符串库。
- en: 1.6 Structs
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6 结构体
- en: Arrays and structs are the two ways in which C supports creating collections
    of data elements. Arrays are used to create an ordered collection of data elements
    of the same type, whereas *structs* are used to create a collection of data elements
    of *different types*. A C programmer can combine array and struct building blocks
    in many different ways to create more complex data types and structures. This
    section introduces structs, and in the next chapter we characterize structs in
    more detail (“C Structs” on [page 103](ch02.xhtml#lev1_15)) and show how you can
    combine them with arrays (“Arrays of Structs” on [page 198](ch02.xhtml#lev2_30)).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: C is not an object-oriented language; thus, it doesn’t support classes. It does,
    however, support defining structured types, which are like the data part of classes.
    A `struct` is a type used to represent a heterogeneous collection of data; it’s
    a mechanism for treating a set of different types as a single, coherent unit.
    C structs provide a level of abstraction on top of individual data values, treating
    them as a single type. For example, a student has a name, age, grade point average
    (GPA), and graduation year. A programmer could define a new `struct` type to combine
    those four data elements into a single `struct student` variable that contains
    a name value (type `char []`, to hold a string), an age value (type `int`), a
    GPA value (type `float`), and a graduation year value (type `int`). A single variable
    of this struct type can store all four pieces of data for a particular student;
    for example, (“Freya”, 19, 3.7, 2021).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three steps to defining and using `struct` types in C programs:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Define a new `struct` type that represents the structure.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Declare variables of the new `struct` type.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Use dot (`.`) notation to access individual field values of the variable.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.1 Defining a Struct Type
  id: totrans-332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A struct type definition should appear *outside of any function*, typically
    near the top of the program’s `.c` file. The syntax for defining a new struct
    type is the following (`struct` is a reserved keyword):'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here’s an example of defining a new `struct studentT` type for storing student
    data:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This struct definition adds a new type to C’s type system, and the type’s name
    is `struct studentT`. This struct defines four fields, and each field definition
    includes the type and name of the field. Note that in this example, the `name`
    field’s type is a character array, for use as a string (see “Introduction to Strings
    and the C String Library” on [page 50](ch01.xhtml#lev2_12)).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.2 Declaring Variables of Struct Types
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once the type has been defined, you can declare variables of the new type, `struct`
    `studentT`. Note that unlike the other types we’ve encountered so far that consist
    of just a single word (for example, `int`, `char`, and `float`), the name of our
    new struct type is two words, `struct studentT`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 1.6.3 Accessing Field Values
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To access field values in a struct variable, use *dot notation*:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: When accessing structs and their fields, carefully consider the types of the
    variables you’re using. Novice C programmers often introduce bugs into their programs
    by failing to account for the types of struct fields. [Table 1-2](ch01.xhtml#ch1tab2)
    shows the types of several expressions surrounding our `struct studentT` type.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 1-2:** The Types Associated with Various `struct studentT` Expressions'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **C type** |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
- en: '| `student1` | `struct studentT` |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
- en: '| `student1.age` | integer (`int`) |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
- en: '| `student1.name` | array of characters (`char []`) |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
- en: '| `student1.name[3]` | character (`char`), the type stored in each position
    of the `name` array |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
- en: 'Here are some examples of assigning a `struct studentT` variable’s fields:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[Figure 1-5](ch01.xhtml#ch1fig5) illustrates the layout of the `student1` variable
    in memory after the field assignments in the preceding example. Only the struct
    variable’s fields (the areas in boxes) are stored in memory. The field names are
    labeled on the figure for clarity, but to the C compiler, fields are simply storage
    locations or *offsets* from the start of the struct variable’s memory. For example,
    based on the definition of a `struct studentT`, the compiler knows that to access
    the field named `gpa`, it must skip past an array of 64 characters (`name`) and
    one integer (`age`). Note that in the figure, the `name` field only depicts the
    first six characters of the 64-character array.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/01fig05.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-5: The `student1` variable’s memory after assigning each of its fields*'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'C struct types are *lvalues*, meaning they can appear on the left side of an
    assignment statement. Thus, a struct variable can be assigned the value of another
    struct variable using a simple assignment statement. The field values of the struct
    on the right side of the assignment statement are *copied* to the field values
    of the struct on the left side of the assignment statement. In other words, the
    contents of memory of one struct are copied to the memory of the other. Here’s
    an example of assigning a struct’s values in this way:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[Figure 1-6](ch01.xhtml#ch1fig6) shows the values of the two student variables
    after the assignment statement and call to `strcpy` have executed. Note that the
    figure depicts the `name` fields as the string values they contain rather than
    the full array of 64 characters.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/01fig06.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-6: Layout of the `student1` and `student2` structs after executing
    the struct assignment and `strcpy` call*'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'C provides a `sizeof` operator that takes a type and returns the number of
    bytes used by the type. The `sizeof` operator can be used on any C type, including
    struct types, to see how much memory space a variable of that type needs. For
    example, we can print the size of a `struct studentT` type:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: When run, this line should print out a value of *at least* 76 bytes, because
    64 characters are in the `name` array (1 byte for each `char`), 4 bytes for the
    `int age` field, 4 bytes for the `float gpa` field, and 4 bytes for the `int`
    `grad_yr` field. The exact number of bytes might be larger than 76 on some machines.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a full example program (available for download^([10](ch01.xhtml#fn1_10)))
    that defines and demonstrates the use of our `struct studentT` type:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'When run, this program outputs the following:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: LVALUES
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: An *lvalue* is an expression that can appear on the left side of an assignment
    statement. It’s an expression that represents a memory storage location. As we
    introduce C pointer types and examples of creating more complicated structures
    that combine C arrays, structs, and pointers, it’s important to think carefully
    about types and to keep in mind which C expressions are valid lvalues (which can
    be used on the left side of an assignment statement).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'From what we know about C so far, single variables of base types, array elements,
    and structs are all lvalues. The name of a statically declared array is *not*
    an lvalue (you cannot change the base address of a statically declared array in
    memory). The following example code snippet illustrates valid and invalid C assignment
    statements based on the lvalue status of different types:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 1.6.4 Passing Structs to Functions
  id: totrans-372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In C, arguments of all types are *passed by value* to functions. Thus, if a
    function has a struct type parameter, then when called with a struct argument,
    the argument’s *value* is passed to its parameter, meaning that the parameter
    gets a copy of its argument’s value. The value of a struct variable is the contents
    of its memory, which is why we can assign the fields of one struct to be the same
    as another struct in a single assignment statement like this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Because the value of a struct variable represents the full contents of its memory,
    passing a struct as an argument to a function gives the parameter a *copy* of
    all the argument struct’s field values. If the function changes the field values
    of a struct parameter, the changes to the parameter’s field values have *no effect*
    on the corresponding field values of the argument. That is, changes to the parameter’s
    fields only modify values in the parameter’s memory locations for those fields,
    not in the argument’s memory locations for those fields.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a full example program (available for download^([11](ch01.xhtml#fn1_11)))
    using the `checkID` function that takes a struct parameter:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'When `main` calls `checkID`, the value of the `student` struct (a copy of the
    memory contents of all its fields) is passed to the `s` parameter. When the function
    changes the value of its parameter’s `age` field, it *doesn’t* affect the `age`
    field of its argument (`student`). This behavior can be seen by running the program,
    which outputs the following:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The output shows that when `checkID` prints the `age` field, it reflects the
    function’s change to the `age` field of the parameter `s`. However, after the
    function call returns, `main` prints the `age` field of `student` with the same
    value it had prior to the `checkID` call. [Figure 1-7](ch01.xhtml#ch1fig7) illustrates
    the contents of the call stack just before the `checkID` function returns.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/01fig07.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-7: The contents of the call stack before returning from the `checkID`
    function*'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the pass by value semantics of struct parameters is particularly
    important when a struct contains a statically declared array field (like the `name`
    field in `struct studentT`). When such a struct is passed to a function, the struct
    argument’s entire memory contents, including every array element in the array
    field, is copied to its parameter. If the parameter struct’s array contents are
    changed by the function, those changes will *not* persist after the function returns.
    This behavior might seem odd given what we know about how arrays are passed to
    functions (“Arrays and Functions” on [page 48](ch01.xhtml#lev2_11)), but it’s
    consistent with the struct copying behavior described earlier.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 1.7 Summary
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we introduced many parts of the C programming language by comparing
    them to similar language constructs in Python, a language that many readers might
    know. C has similar language features to those of many other high-level imperative
    and object-oriented programming languages, including variables, loops, conditionals,
    functions, and I/O. Some key differences between the C and Python features we
    discussed include C requiring that all variables be declared of a specific type
    before they’re used, and that C arrays and strings are a lower-level abstraction
    than Python’s lists and strings. The lower-level abstractions allow a C programmer
    more control over how their program accesses its memory and thus more control
    over their program’s efficiency.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we cover the C programming language in detail. We revisit
    in more depth the many language features presented in this chapter, and we introduce
    some new C language features, most notably C pointer variables and support for
    dynamic memory allocation.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[1.](ch01.xhtml#rfn1_1) *[https://diveintosystems.org/antora/diveintosystems/1.0/C_intro/_attachments/hello.c](https://diveintosystems.org/antora/diveintosystems/1.0/C_intro/_attachments/hello.c)*'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[2.](ch01.xhtml#rfn1_2) *[https://diveintosystems.org/antora/diveintosystems/1.0/C_intro/_attachments/hello.py](https://diveintosystems.org/antora/diveintosystems/1.0/C_intro/_attachments/hello.py)*'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[3.](ch01.xhtml#rfn1_3) *[https://gcc.gnu.org](https://gcc.gnu.org)*'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[4.](ch01.xhtml#rfn1_4) See *[https://www.cs.swarthmore.edu/help/editors.html](https://www.cs.swarthmore.edu/help/editors.html)*'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[5.](ch01.xhtml#rfn1_5) See “Using make and writing Makefile” at *[https://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html](https://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html)*'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '[5.](ch01.xhtml#rfn1_5) 请参阅“使用 make 和编写 Makefile”在 *[https://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html](https://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html)*'
- en: '[6.](ch01.xhtml#rfn1_6) *book/modules/C_intro/assets/attachments/whileLoop1.c*'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[6.](ch01.xhtml#rfn1_6) *book/modules/C_intro/assets/attachments/whileLoop1.c*'
- en: '[7.](ch01.xhtml#rfn1_7) *book/modules/C_intro/assets/attachments/whileLoop2.c*'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[7.](ch01.xhtml#rfn1_7) *book/modules/C_intro/assets/attachments/whileLoop2.c*'
- en: '[8.](ch01.xhtml#rfn1_8) *book/modules/C_intro/assets/attachments/forLoop2.c*'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '[8.](ch01.xhtml#rfn1_8) *book/modules/C_intro/assets/attachments/forLoop2.c*'
- en: '[9.](ch01.xhtml#rfn1_9) *book/modules/C_intro/assets/attachments/function.c*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.](ch01.xhtml#rfn1_9) *book/modules/C_intro/assets/attachments/function.c*'
- en: '[10.](ch01.xhtml#rfn1_10) *book/modules/C_intro/assets/attachments/studentTstruct.c*'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '[10.](ch01.xhtml#rfn1_10) *book/modules/C_intro/assets/attachments/studentTstruct.c*'
- en: '[11.](ch01.xhtml#rfn1_11) *book/modules/C_intro/assets/attachments/structfunc.c*'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '[11.](ch01.xhtml#rfn1_11) *book/modules/C_intro/assets/attachments/structfunc.c*'
