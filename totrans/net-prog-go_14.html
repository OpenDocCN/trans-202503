<html><head></head><body>
<section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_241" title="241"/>11</span><br/>&#13;
<span class="ChapterTitle">Securing Communications with TLS</span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" src="image_fi/book_art/chapterart.png"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Five years before whistleblower Edward Snowden showed us how much we took our electronic privacy for granted, author and activist Cory Doctorow wrote, “We should treat personal electronic data with the same care and respect as weapons-grade plutonium—it is dangerous, long-lasting, and once it has leaked, there’s no getting it back.”</p>&#13;
<p>Prior to 2013, most people communicated on the internet by using plaintext. Social Security numbers, credit card details, passwords, sensitive emails, and other potentially embarrassing information traveled over the internet, ripe for interception by malicious actors. Most popular websites defaulted to HTTP; Google was one of the only major tech companies supporting HTTPS.</p>&#13;
<p>Today, it’s unusual to find a website that doesn’t support HTTPS, particularly now that Let’s Encrypt offers free TLS certificates for your domain. We’re treating information in transit more like weapons-grade plutonium, <span epub:type="pagebreak" id="Page_242" title="242"/>helping ensure the privacy and integrity of the information we share. Our network applications should be no different. We should strive to authenticate our communication and use encryption where appropriate, particularly when that information has the potential to leak over insecure networks.</p>&#13;
<p>Up to this point, we’ve used TLS only as an afterthought in our code. This is partly because Go’s <code>net/http</code> library makes its use relatively effortless, but it’s also because we haven’t adequately explored the TLS protocol and the infrastructure that makes it possible. To write secure software, you should carefully plan for security before development starts and then use good security practices as you write code. TLS is a terrific way to improve the security posture of your software by protecting data in transit. </p>&#13;
<p>This chapter will introduce you to the basics of TLS from a programmer’s perspective. You’ll learn about the client-server handshake process and the inherent trust that makes that process work. Then we’ll discuss how things can (and do) go wrong even when you use TLS. Finally, we’ll look at practical examples of how to incorporate TLS into your applications, including mutual client-server authentication.</p>&#13;
<h2 id="h1-500884c11-0001">A Closer Look at Transport Layer Security</h2>&#13;
<p class="BodyFirst">The TLS protocol supplies secure communication between a client and a server. It allows the client to authenticate the server and optionally permits the server to authenticate clients. The client uses TLS to encrypt its communication with the server, preventing third-party interception and manipulation.</p>&#13;
<p>TLS uses a handshake process to establish certain criteria for the stateful TLS session. If the client initiated a TLS 1.3 handshake with the server, it would go something like this:</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead">Client</span>  Hello <em>google.com</em>. I’d like to communicate with you using TLS version 1.3. Here is a list of ciphers I’d like to use to encrypt our messages, in order of my preference. I generated a public- and private-key pair specifically for this conversation. Here’s my public key.</li>&#13;
<li><span class="RunInHead">Server</span>  Greetings, client. TLS version 1.3 suits me fine. Based on your cipher list, I’ve decided we’ll use the Advanced Encryption Standard with Galois/Counter Mode (AES-GCM) cipher. I, too, created a new key pair for this conversation. Here is my public key and my certificate so you can prove that I truly am <em>google.com</em>. I’m also sending along a 32-byte value that corresponds to the TLS version you asked me to use. Finally, I’m including both a signature and a <em>message authentication code</em> <em>(MAC)</em> derived using your public key of everything we’ve discussed so far so you can verify the integrity of my reply when you receive it.</li>&#13;
<li><span class="RunInHead">Client (to self)</span>  An authority I trust signed the server’s certificate, so I’m confident I’m speaking to <em>google.com</em>. I’ve derived this conversation’s symmetric key from the server’s signature by using my private key. Using this symmetric key, I’ve verified the MAC and made sure no one has tampered with the server’s reply. The 32 bytes in the reply <span epub:type="pagebreak" id="Page_243" title="243"/>corresponds to TLS version 1.3, so no one is attempting to trick the server into using an older, weaker version of TLS. I now have everything I need to securely communicate with the server.</li>&#13;
<li><span class="RunInHead">Client (to server)</span>  <em>Here is some encrypted data.</em></li>&#13;
</ol>&#13;
<p>The 32-byte value in the server’s hello message prevents <em>downgrade attacks</em>, in which an attacker intercepts the client’s hello message and modifies it to request an older, weaker version of TLS. If the client asked for TLS v1.3, but an attacker changed the client’s hello message to ask for TLS v1.1, the 32-byte value in the server’s hello message would correspond to TLS v1.1. When the client received the server’s hello message, it would notice that the value indicated the wrong TLS version and abort the handshake.</p>&#13;
<p>From this point forward, the client and server communicate using AES-GCM symmetric-key cryptography (in this hypothetical example). Both the client and the server encapsulate application layer payloads in TLS records before passing the payloads onto the transport layer.</p>&#13;
<p>Despite its name, TLS is not a transport layer protocol. Instead, it’s situated between the transport and application layers of the TCP/IP stack. TLS encrypts an application layer protocol’s payload before passing the payload onto the transport layer. Once the payload reaches its destination, TLS receives the payload from the transport layer, decrypts it, and passes the payload along to the application layer protocol.</p>&#13;
<h3 id="h2-500884c11-0001">Forward Secrecy</h3>&#13;
<p class="BodyFirst">The handshake method in our hypothetical conversation is an example of the Diffie-Hellman (DH) key exchange used in TLS v1.3. The <em>DH key exchange</em> calls for the creation of new client and server key pairs, and a new symmetric key, all of which should exist for only the duration of the session. Once a session ends, the client and server shall discard the session keys.</p>&#13;
<p>The use of per-session keys means that TLS v1.3 gives you <em>forward secrecy</em>; an attacker who compromises your session keys can compromise only the data exchanged during that session. An attacker cannot use those keys to decrypt data exchanged during any other session.</p>&#13;
<h3 id="h2-500884c11-0002">In Certificate Authorities We Trust</h3>&#13;
<p class="BodyFirst">My father and I took a trip to Ireland shortly before I started authoring this book. In preparation for our adventure, I needed to obtain a new passport, since my old one had long since expired. The process was easy. I filled out an application, collected my vital records, took a picture of the bad side of my head, and presented everything, along with an application fee, to my local US Post Office branch. I also attested I was myself to the notary. A few weeks later, I received a newly minted US passport in the mail.</p>&#13;
<p> When we arrived in Ireland, a lovely customs agent greeted us and requested our passports. She asked questions about our holiday as her computer authenticated our identities. After no more than three minutes, she returned our passports and welcomed us to Ireland.</p>&#13;
<p><span epub:type="pagebreak" id="Page_244" title="244"/>My passport represents the US government’s attestation that I am Adam Woodbeck. But it’s only as good as Ireland’s trust in the US government’s ability to verify my identity. If Ireland doesn’t trust the United States, it will not take the United States’ word that I am me and will most likely refuse to let me enter the country. (If I’m being honest, I’m not charming enough to convince the customs agent to let me in on my word alone.)</p>&#13;
<p>TLS’s certificates work in much the same way as my passport. If I wanted a new TLS certificate for <em>woodbeck.net</em>, I would send a request to a certificate authority, such as Let’s Encrypt. The certificate authority would then verify I am the proper owner of <em>woodbeck.net</em>. Once satisfied, the certificate authority would issue a new certificate for <em>woodbeck.net</em> and cryptographically sign it with its certificate. My server can present this certificate to clients so they can authenticate my server by confirming the certificate authority’s signature, giving them the confidence that they’re communicating with the real <em>woodbeck.net</em>, not an impostor.</p>&#13;
<p> A certificate authority issuing a signed certificate for <em>woodbeck.net</em> is analogous to the US government issuing my passport. They are both issued by trusted institutions that attest to their subject’s authenticity. Like Ireland’s trust of the United States, clients are inclined to trust the <em>woodbeck.net</em> certificate only if they trust the certificate authority that signed it. I could create my own certificate authority and self-sign certificates as easy as I could create a document claiming to be my passport. But Ireland would sooner admit that Jack Daniel’s Tennessee Whiskey is superior to Jameson Irish Whiskey than trust my self-issued passport, and no operating system or web browser in the world would trust my self-signed certificate.</p>&#13;
<h3 id="h2-500884c11-0003">How to Compromise TLS</h3>&#13;
<p class="BodyFirst">On December 24, 2013, Google learned that the Turktrust certificate authority in Turkey had mistakenly issued a certificate that allowed a malicious actor to masquerade as <em>google.com</em>. This meant that attackers could fool your web browser into thinking it was talking to Google over a TLS connection and trick you into divulging your credentials. Google quickly noticed the mistake and took steps to remedy the situation.</p>&#13;
<p>Turktrust’s mess-up undermined its authority and compromised our trust. But even if the certificate authorities operate correctly, attackers can narrow their focus and target individuals instead. If an attacker were able to install his own CA certificate in your operating system’s trusted certificate storage, your computer would trust any certificate he signs. This means an attacker could compromise all your TLS traffic.</p>&#13;
<p>Most people don’t get this kind of special attention. Instead, an attacker is more likely to compromise a server. Once compromised, the attacker could capture all TLS traffic and the corresponding session keys from memory.</p>&#13;
<p>You’re unlikely to encounter any of these scenarios, but it’s important to be aware that they are possible. Overall, TLS 1.3 offers excellent security and is tough to compromise because of its full handshake signature, downgrade protection, forward secrecy, and strong encryption.</p>&#13;
<h2 id="h1-500884c11-0002"><span epub:type="pagebreak" id="Page_245" title="245"/>Protecting Data in Transit</h2>&#13;
<p class="BodyFirst">Ensuring the integrity of the data you transmit over a network should be your primary focus, no matter whether it’s your own data or the data of others. Go makes using TLS so easy that you would have a tough time justifying not using it. In this section, you’ll learn how to add TLS support to both the client and the server. You’ll also see how TLS works over TCP and how to mitigate the threat of malicious certificates with certificate pinning.</p>&#13;
<h3 id="h2-500884c11-0004">Client-side TLS</h3>&#13;
<p class="BodyFirst">The client’s primary concern during the handshake process is to authenticate the server by using its certificate. If the client cannot trust the server, it cannot consider its communication with the server secure. The <code>net/http/httptest</code> package provides constructs that easily demonstrate Go’s HTTP-over-TLS support (see <a href="#listing11-1" id="listinganchor11-1">Listing 11-1</a>).</p>&#13;
<pre><code>package ch11&#13;
&#13;
import (&#13;
    "crypto/tls"&#13;
    "net"&#13;
    "net/http"&#13;
    "net/http/httptest"&#13;
    "strings"&#13;
    "testing"&#13;
    "time"&#13;
&#13;
    "golang.org/x/net/http2"&#13;
)&#13;
&#13;
func TestClientTLS(t *testing.T) {&#13;
    ts := <span class="CodeAnnotation">1</span>httptest.NewTLSServer(&#13;
        http.HandlerFunc(&#13;
            func(w http.ResponseWriter, r *http.Request) {&#13;
                if <span class="CodeAnnotation">2</span>r.TLS == nil {&#13;
                    u := "https://" + r.Host + r.RequestURI&#13;
                    http.Redirect(w, r, u, http.StatusMovedPermanently)&#13;
                    return&#13;
                }&#13;
&#13;
                w.WriteHeader(http.StatusOK)&#13;
            },&#13;
        ),&#13;
    )&#13;
    defer ts.Close()&#13;
&#13;
    resp, err := <span class="CodeAnnotation">3</span>ts.Client().Get(ts.URL)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
<span epub:type="pagebreak" id="Page_246" title="246"/>    if resp.StatusCode != http.StatusOK {&#13;
        t.Errorf("expected status %d; actual status %d",&#13;
            http.StatusOK, resp.StatusCode)&#13;
    }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-1">Listing 11-1</a>: Testing HTTPS client and server support (<em>tls_client_test.go</em>)</p>&#13;
<p>The <code>httptest.NewTLSServer</code> function returns an HTTPS server <span class="CodeAnnotation">1</span>. Aside from the function name, this bit of code looks identical to our use of <code>httptest</code> in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>. Here, the <code>httptest.NewTLSServer</code> function handles the HTTPS server’s TLS configuration details, including the creation of a new certificate. No trusted authority signed this certificate, so no discerning HTTPS client would trust it. You’ll see how to work around this detail in just a moment by using a preconfigured client.</p>&#13;
<p>If the server receives the client’s request over HTTP, the request’s <code>TLS</code> field will be <code>nil</code>. You can check for this case <span class="CodeAnnotation">2</span> and redirect the client to the HTTPS endpoint accordingly.</p>&#13;
<p>For testing purposes, the server’s <code>Client</code> method <span class="CodeAnnotation">3</span> returns a new <code>*http.Client</code> that inherently trusts the server’s certificate. You can use this client to test TLS-specific code within your handlers. </p>&#13;
<p>Let’s see what happens in <a href="#listing11-2" id="listinganchor11-2">Listing 11-2</a> when you attempt to communicate with the same server by using a new client without inherent trust for the server’s certificate.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    tp := &amp;http.Transport{&#13;
        TLSClientConfig: &amp;tls.Config{&#13;
            CurvePreferences: []tls.CurveID{<span class="CodeAnnotation">1</span>tls.CurveP256},&#13;
            MinVersion:       tls.VersionTLS12,&#13;
        },&#13;
    }&#13;
&#13;
    err = <span class="CodeAnnotation">2</span>http2.ConfigureTransport(tp)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    client2 := &amp;http.Client{Transport: tp}&#13;
&#13;
    _, err = client2.Get(ts.URL)&#13;
    if err == nil || !strings.Contains(err.Error(),&#13;
        "certificate signed by unknown authority") {&#13;
        t.Fatalf("expected unknown authority error; actual: %q", err)&#13;
    }&#13;
&#13;
 <span class="CodeAnnotation">3</span> tp.TLSClientConfig.InsecureSkipVerify = true&#13;
&#13;
    resp, err = client2.Get(ts.URL)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
<span epub:type="pagebreak" id="Page_247" title="247"/>    if resp.StatusCode != http.StatusOK {&#13;
        t.Errorf("expected status %d; actual status %d",&#13;
            http.StatusOK, resp.StatusCode)&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-2">Listing 11-2</a>: Testing the HTTPS server with a discerning client (<em>tls_client_test.go</em>)</p>&#13;
<p>You override the default TLS configuration in your client’s transport by creating a new transport, defining its TLS configuration, and configuring <code>http2</code> to use this transport. It’s good practice to restrict your client’s curve preference to the P-256 curve <span class="CodeAnnotation">1</span> and avoid the use of P-384 and P-521. P-256 is immune to timing attacks, whereas P-384 and P-521 are not. Also, your client will negotiate a minimum of TLS 1.2. </p>&#13;
<p>An <em>elliptic curve</em> is a plane curve in which all points along the curve satisfy the same polynomial equation. Whereas first-generation cryptography like RSA uses large prime numbers to derive keys, elliptic curve cryptography uses points along an elliptic curve for key generation. P-256, P-384, and P-521 are specific elliptic curves defined in the National Institute of Standards and Technology’s Digital Signature Standard. You can find more details in the Federal Information Processing Standards (FIPS) publication 186-4 (<a class="LinkURL" href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf">https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf</a>).</p>&#13;
<p>Since your transport no longer relies on the default TLS configuration, the client no longer has inherent HTTP/2 support. You need to explicitly bless your transport with HTTP/2 support <span class="CodeAnnotation">2</span> if you want to use it. Of course, this test doesn’t rely on HTTP/2, but this implementation detail can trip you up if you’re unaware that overriding the transport’s TLS configuration removes HTTP/2 support.</p>&#13;
<p>Your client uses the operating system’s trusted certificate store because you don’t explicitly tell it which certificates to trust. The first call to the test server results in an error because your client doesn’t trust the server certificate’s signatory. You could work around this and configure your client’s transport to skip verification of the server’s certificate by setting its <code>InsecureSkipVerify</code> field to <code>true</code><span class="CodeAnnotation">3</span>. I don’t recommend you entertain enabling <code>InsecureSkipVerify</code> for anything other than debugging. Shipping code with this enabled is a code smell in my opinion. You’ll learn a better alternative later in this chapter when we discuss a concept known as <em>certificate pinning</em>. As the field name implies, enabling it makes your client inherently insecure and susceptible to man-in-the-middle attacks, since it now blindly trusts any certificate a server offers up. If you make the same call with your newly naive client, you’ll see that it happily negotiates TLS with the server.</p>&#13;
<h3 id="h2-500884c11-0005">TLS over TCP</h3>&#13;
<p class="BodyFirst">TLS is stateful; a client and a server negotiate session parameters during the initial handshake only, and once they’ve agreed, they exchange encrypted TLS records for the duration of the session. Since TCP is also stateful, it’s the ideal transport layer protocol with which to implement TLS, because you can leverage TCP’s reliability guarantees to maintain your TLS sessions.</p>&#13;
<p><span epub:type="pagebreak" id="Page_248" title="248"/>Let’s take the application protocol out of the picture for a moment and learn how to establish a TLS connection over TCP. <a href="#listing11-3" id="listinganchor11-3">Listing 11-3</a> demonstrates how to use the <code>crypto/tls</code> package to initiate a TLS connection with a few lines of code.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func TestClientTLSGoogle(t *testing.T) {&#13;
    conn, err := <span class="CodeAnnotation">1</span>tls.DialWithDialer(&#13;
        &amp;net.Dialer{Timeout: 30 * time.Second},&#13;
        "tcp",&#13;
        "www.google.com:443",&#13;
        &amp;tls.Config{&#13;
            CurvePreferences: []tls.CurveID{tls.CurveP256},&#13;
            MinVersion:       tls.VersionTLS12,&#13;
        },&#13;
    )&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    state := <span class="CodeAnnotation">2</span>conn.ConnectionState()&#13;
    t.Logf("TLS 1.%d", state.Version-tls.VersionTLS10)&#13;
    t.Log(tls.CipherSuiteName(state.CipherSuite))&#13;
    t.Log(state.VerifiedChains[0][0].Issuer.Organization[0])&#13;
&#13;
    _ = conn.Close()&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-3">Listing 11-3</a>: Starting a TLS connection with <em>www.google.com</em> (<em>tls_client_test.go</em>)</p>&#13;
<p>The <code>tls.DialWithDialer</code> function <span class="CodeAnnotation">1</span> accepts a <code>*net.Dialer</code>, a network, an address, and a <code>*tls.Config</code>. Here, you give your dialer a time-out of 30 seconds and specify recommended TLS settings. If successful, you can inspect the connection’s state <span class="CodeAnnotation">2</span> to glean details about your TLS connection.</p>&#13;
<p><a href="#listing11-4" id="listinganchor11-4">Listing 11-4</a> shows the output of <a href="#listing11-3">Listing 11-3</a>’s test.</p>&#13;
<pre><code>$ <b>go test -race -run TestClientTLSGoogle -v ./...</b>&#13;
=== RUN   TestClientTLSGoogle&#13;
    TestClientTLSGoogle: tls_client_test.go:89: TLS 1.3&#13;
    TestClientTLSGoogle: tls_client_test.go:90: TLS_AES_128_GCM_SHA256&#13;
    TestClientTLSGoogle: tls_client_test.go:91: Google Trust Services&#13;
--- PASS: TestClientTLSGoogle (0.31s)&#13;
PASS</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-4">Listing 11-4</a>: Running the <code>TestClientTLSGoogle</code> test</p>&#13;
<p>Your TLS client is using the TLS_AES_128_GCM_SHA256 cipher suite over TLS version 1.3. Notice that <code>tls.DialWithDialer</code> did not object to the server’s certificate. The underlying TLS client used the operating system’s trusted certificate storage and confirmed that <em>www.google.com</em>’s certificate is signed by a trusted CA—Google Trust Services, in this example.</p>&#13;
<h3 id="h2-500884c11-0006"><span epub:type="pagebreak" id="Page_249" title="249"/>Server-side TLS</h3>&#13;
<p class="BodyFirst">The server-side code isn’t much different from what you’ve learned thus far. The main difference is that the server needs to present a certificate to the client as part of the handshake process. You can create one with the <em>generate_cert.go</em> file found in Go’s <em>src/crypto/tls</em> subdirectory. For production use, you’re better off using certificates from Let’s Encrypt or another certificate authority. You can use the LEGO library (<a class="LinkURL" href="https://github.com/go-acme/lego/">https://github.com/go-acme/lego/</a>) to add certificate management to your services. Generate a new cert and private key, like so:</p>&#13;
<pre><code>$ <b>go run $GOROOT/src/crypto/tls/generate_cert.go -host localhost -ecdsa-curve P256</b></code></pre>&#13;
<p>This command creates a certificate named <em>cert.pem</em> with the hostname <em>localhost</em> and a private key named <em>key.pem</em>. The rest of the code in this section assumes that both files exist in the current directory.</p>&#13;
<p>Keeping with the tradition of earlier chapters, <a href="#listing11-5" id="listinganchor11-5">Listing 11-5</a> includes the first bit of code for a TLS-only echo server.</p>&#13;
<pre><code>package ch11&#13;
&#13;
import (&#13;
    "context"&#13;
    "crypto/tls"&#13;
    "fmt"&#13;
    "net"&#13;
    "time"&#13;
)&#13;
&#13;
func NewTLSServer(ctx context.Context, address string,&#13;
    maxIdle time.Duration, tlsConfig *tls.Config) *Server {&#13;
    return &amp;Server{&#13;
        ctx:       ctx,&#13;
        ready:     make(chan struct{}),&#13;
        addr:      address,&#13;
        maxIdle:   maxIdle,&#13;
        tlsConfig: tlsConfig,&#13;
    }&#13;
}&#13;
&#13;
type Server struct {&#13;
    ctx   context.Context&#13;
    ready chan struct{}&#13;
&#13;
    addr      string&#13;
    maxIdle   time.Duration&#13;
    tlsConfig *tls.Config&#13;
}&#13;
&#13;
func (s *Server) <span class="CodeAnnotation">1</span>Ready() {&#13;
    if s.ready != nil {&#13;
        &lt;-s.ready&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-5">Listing 11-5</a>: Server struct type and constructor function (<em>tls_echo.go</em>)</p>&#13;
<p><span epub:type="pagebreak" id="Page_250" title="250"/>The <code>Server</code> struct has a few fields used to record its settings, its TLS configuration, and a channel to signal when the server is ready for incoming connections. You’ll write a test case and use the <code>Ready</code> method <span class="CodeAnnotation">1</span> a little later in this section to block until the server is ready to accept connections.</p>&#13;
<p>The <code>NewTLSServer</code> function accepts a context for stopping the server, an address, the maximum duration the server should allow connections to idle, and a TLS configuration. Although controlling for idling clients isn’t related to TLS, you’ll use the maximum idle duration to push the socket deadline forward, as in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>.</p>&#13;
<p>Servers you used in earlier chapters rely on the separate concepts of listening and serving. Often, you’ll invoke a helper function that will do both for you, such as the <code>net/http</code> server’s <code>ListenAndServe</code> method. <a href="#listing11-6" id="listinganchor11-6">Listing 11-6</a> adds a similar method to the echo server.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func (s *Server) ListenAndServeTLS(certFn, keyFn string) error {&#13;
    if s.addr == "" {&#13;
        s.addr = "localhost:443"&#13;
    }&#13;
&#13;
    l, err := net.Listen("tcp", s.addr)&#13;
    if err != nil {&#13;
        return fmt.Errorf("binding to tcp %s: %w", s.addr, err)&#13;
    }&#13;
&#13;
    if s.ctx != nil {&#13;
        go func() {&#13;
            &lt;-s.ctx.Done()&#13;
            _ = l.Close()&#13;
        }()&#13;
    }&#13;
&#13;
    return s.ServeTLS(l, certFn, keyFn)&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-6">Listing 11-6</a>: Adding methods to listen and serve and signal the server’s readiness for connections (<em>tls_echo.go</em>)</p>&#13;
<p>The <code>ListenAndServe</code> method accepts full paths to a certificate and a private key and returns an error. It creates a new <code>net.Listener</code> bound to the server’s address and then spins off a goroutine to close the listener when you cancel the context. Finally, the method passes the listener, the certificate path, and the key path onto the server’s <code>ServeTLS</code> method.</p>&#13;
<p><a href="#listing11-7" id="listinganchor11-7">Listing 11-7</a> rounds out the echo server’s implementation with its <code>ServeTLS</code> method.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func (s Server) ServeTLS(l net.Listener, certFn, keyFn string) error {&#13;
    if s.tlsConfig == nil {&#13;
        s.tlsConfig = &amp;tls.Config{&#13;
<span epub:type="pagebreak" id="Page_251" title="251"/>            CurvePreferences:         []tls.CurveID{tls.CurveP256},&#13;
            MinVersion:               tls.VersionTLS12,&#13;
         <span class="CodeAnnotation">1</span> PreferServerCipherSuites: true,&#13;
        }&#13;
    }&#13;
&#13;
    if len(s.tlsConfig.Certificates) == 0 &amp;&amp;&#13;
        s.tlsConfig.GetCertificate == nil {&#13;
        cert, err := <span class="CodeAnnotation">2</span>tls.LoadX509KeyPair(certFn, keyFn)&#13;
        if err != nil {&#13;
            return fmt.Errorf("loading key pair: %v", err)&#13;
        }&#13;
&#13;
        s.tlsConfig.Certificates = []tls.Certificate{cert}&#13;
    }&#13;
&#13;
    tlsListener := <span class="CodeAnnotation">3</span>tls.NewListener(l, s.tlsConfig)&#13;
    if s.ready != nil {&#13;
        close(s.ready)&#13;
    }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-7">Listing 11-7</a>: Adding TLS support to a net.Listener (<em>tls_echo.go</em>)</p>&#13;
<p>The <code>ServeTLS</code> method first checks the server’s TLS configuration. If it’s <code>nil</code>, it adds a default configuration with <code>PreferServerCipherSuites</code> set to <code>true</code><span class="CodeAnnotation">1</span>. <code>PreferServerCipherSuites</code> is meaningful to the server only, and it makes the server use its preferred cipher suite instead of deferring to the client’s preference.</p>&#13;
<p>If the server’s TLS configuration does not have at least one certificate, or if its <code>GetCertificate</code> method is <code>nil</code>, you create a new <code>tls.Certificate</code> by reading in the certificate and private-key files from the filesystem <span class="CodeAnnotation">2</span>.</p>&#13;
<p>At this point in the code, the server has a TLS configuration with at least one certificate ready to present to clients. All that’s left is to add TLS support to the <code>net.Listener</code> by passing it and the server’s TLS configuration to the <code>tls.NewListener</code> function <span class="CodeAnnotation">3</span>. The <code>tls.NewListener</code> function acts like middleware, in that it augments the listener to return TLS-aware connection objects from its <code>Accept</code> method.</p>&#13;
<p><a href="#listing11-8" id="listinganchor11-8">Listing 11-8</a> finishes up the <code>ServeTLS</code> method by accepting connections from the listener and handling them in separate goroutines.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    for {&#13;
        conn, err := <span class="CodeAnnotation">1</span>tlsListener.Accept()&#13;
        if err != nil {&#13;
            return fmt.Errorf("accept: %v", err)&#13;
        }&#13;
&#13;
        go func() {&#13;
            defer func() { _ = <span class="CodeAnnotation">2</span>conn.Close() }()&#13;
&#13;
            for {&#13;
                if s.maxIdle &gt; 0 {&#13;
<span epub:type="pagebreak" id="Page_252" title="252"/>                    err := <span class="CodeAnnotation">3</span>conn.SetDeadline(time.Now().Add(s.maxIdle))&#13;
                    if err != nil {&#13;
                        return&#13;
                    }&#13;
                }&#13;
&#13;
                buf := make([]byte, 1024)&#13;
                n, err := <span class="CodeAnnotation">4</span>conn.Read(buf)&#13;
                if err != nil {&#13;
                    return&#13;
                }&#13;
&#13;
                _, err = conn.Write(buf[:n])&#13;
                if err != nil {&#13;
                    return&#13;
                }&#13;
            }&#13;
        }()&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-8">Listing 11-8</a>: Accepting TLS-aware connections from the listener (<em>tls_echo.go</em>)</p>&#13;
<p>This pattern is like the one you’ve seen in earlier chapters. You use an endless <code>for</code> loop to continually block on the listener’s <code>Accept</code> method <span class="CodeAnnotation">1</span>, which returns a new <code>net.Conn</code> object when a client successfully connects. Since you’re using a TLS-aware listener, it returns connection objects with underlying TLS support. You interact with these connection objects the same as you always do. Go abstracts the TLS details away from you at this point. You then spin off this connection into its own goroutine to handle the connection from that point forward.</p>&#13;
<p>The server handles each connection the same way. It first conditionally sets the socket deadline to the server’s maximum idle duration <span class="CodeAnnotation">3</span>, then waits for the client to send data. If the server doesn’t read anything from the socket before it reaches the deadline, the connection’s <code>Read</code> method <span class="CodeAnnotation">4</span> returns an <em>I/O time-out</em> error, ultimately causing the connection to close <span class="CodeAnnotation">2</span>.</p>&#13;
<p>If, instead, the server reads data from the connection, it writes that same payload back to the client. Control loops back around to reset the deadline and then wait for the next payload from the client.</p>&#13;
<h3 id="h2-500884c11-0007">Certificate Pinning</h3>&#13;
<p class="BodyFirst">Earlier in the chapter, we discussed ways to compromise the trust that TLS relies on, whether by a certificate authority issuing fraudulent certificates or an attacker injecting a malicious certificate into your computer’s trusted certificate storage. You can mitigate both attacks by using certificate pinning. </p>&#13;
<p><em>Certificate pinning</em> is the process of scrapping the use of the operating system’s trusted certificate storage and explicitly defining one or more trusted certificates in your application. Your application will trust connections only from hosts presenting a pinned certificate or a certificate signed <span epub:type="pagebreak" id="Page_253" title="253"/>by a pinned certificate. If you plan on deploying clients in zero-trust environments that must securely communicate with your server, consider pinning your server’s certificate to each client.</p>&#13;
<p>Assuming the server introduced in the preceding section uses the <em>cert.pem</em> and the <em>key.pem</em> you generated for the hostname <em>localhost</em>, all clients will abort the TLS connection as soon as the server presents its certificate. Clients won’t trust the server’s certificate because no trusted certificate authority signed it.</p>&#13;
<p>You could set the <code>tls.Config</code>’s <code>InsecureSkipVerify</code> field to <code>true</code>, but as this method is insecure, I don’t recommend you consider it a practical choice. Instead, let’s explicitly tell our client it can trust the server’s certificate by pinning the server’s certificate to the client. <a href="#listing11-9" id="listinganchor11-9">Listing 11-9</a> has the beginnings of a test to show that process.</p>&#13;
<pre><code>package ch11&#13;
&#13;
import (&#13;
    "bytes"&#13;
    "context"&#13;
    "crypto/tls"&#13;
    "crypto/x509"&#13;
    "io"&#13;
    "io/ioutil"&#13;
    "strings"&#13;
    "testing"&#13;
    "time"&#13;
)&#13;
&#13;
func TestEchoServerTLS(t *testing.T) {&#13;
    ctx, cancel := context.WithCancel(context.Background())&#13;
    defer cancel()&#13;
&#13;
    serverAddress := "localhost:34443"&#13;
    maxIdle := time.Second&#13;
    server := NewTLSServer(ctx, serverAddress, maxIdle, nil)&#13;
    done := make(chan struct{})&#13;
&#13;
    go func() {&#13;
        err := <span class="CodeAnnotation">1</span>server.ListenAndServeTLS("cert.pem", "key.pem")&#13;
        if err != nil &amp;&amp; !strings.Contains(err.Error(),&#13;
            "use of closed network connection") {&#13;
            t.Error(err)&#13;
            return&#13;
        }&#13;
        done &lt;- struct{}{}&#13;
    }()&#13;
<span class="CodeAnnotationHang">2</span>     server.Ready()</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-9">Listing 11-9</a>: Creating a new TLS echo server and starting it in the background (<em>tls_echo_test.go</em>)</p>&#13;
<p>Since the hostname in <em>cert.pem</em> is <em>localhost</em>, you create a new TLS echo server listening on <em>localhost</em> port 34443. The port isn’t important here, but clients expect the server to be reachable by the same hostname as the one <span epub:type="pagebreak" id="Page_254" title="254"/>in the certificate it presents. You spin up the server in the background by using the <em>cert.pem</em> and <em>key.pem</em> files <span class="CodeAnnotation">1</span> and block until it’s ready for incoming connections <span class="CodeAnnotation">2</span>.</p>&#13;
<p><a href="#listing11-10" id="listinganchor11-10">Listing 11-10</a> picks up where we left off by creating a client TLS configuration with explicit trust for the server’s certificate.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    cert, err := ioutil.ReadFile("cert.pem")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    certPool := <span class="CodeAnnotation">1</span>x509.NewCertPool()&#13;
    if ok := certPool.AppendCertsFromPEM(cert); !ok {&#13;
        t.Fatal("failed to append certificate to pool")&#13;
    }&#13;
&#13;
    tlsConfig := &amp;tls.Config{&#13;
        CurvePreferences: []tls.CurveID{tls.CurveP256},&#13;
        MinVersion:       tls.VersionTLS12,&#13;
     <span class="CodeAnnotation">2</span> RootCAs:          certPool,&#13;
    }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-10">Listing 11-10</a>: Pinning the server certificate to the client (<em>tls_echo_test.go</em>)</p>&#13;
<p>Pinning a server certificate to the client is straightforward. First, you read in the <em>cert.pem</em> file. Then, you create a new certificate pool <span class="CodeAnnotation">1</span> and append the certificate to it. Finally, you add the certificate pool to the <code>tls.Config</code>’s <code>RootCAs</code> field <span class="CodeAnnotation">2</span>. As the name suggests, you can add more than one trusted certificate to the certificate pool. This can be useful when you are migrating to a new certificate but have yet to completely phase out the old certificate.</p>&#13;
<p>The client, using this configuration, will authenticate only servers that present the <em>cert.pem</em> certificate or any certificate signed by it. Let’s confirm this behavior in the rest of the test (see <a href="#listing11-11" id="listinganchor11-11">Listing 11-11</a>).</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    conn, err := <span class="CodeAnnotation">1</span>tls.Dial("tcp", serverAddress, tlsConfig)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    hello := []byte("hello")&#13;
    _, err = conn.Write(hello)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    b := make([]byte, 1024)&#13;
    n, err := conn.Read(b)&#13;
    if err != nil {&#13;
<span epub:type="pagebreak" id="Page_255" title="255"/>        t.Fatal(err)&#13;
    }&#13;
&#13;
    if actual := b[:n]; !bytes.Equal(hello, actual) {&#13;
        t.Fatalf("expected %q; actual %q", hello, actual)&#13;
    }&#13;
&#13;
 <span class="CodeAnnotation">2</span> time.Sleep(2 * maxIdle)&#13;
    _, err = conn.Read(b)&#13;
    if err != <span class="CodeAnnotation">3</span>io.EOF {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    err = conn.Close()&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    cancel()&#13;
    &lt;-done&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-11">Listing 11-11</a>: Authenticating the server by using a pinned certificate (<em>tls_echo_test.go</em>)</p>&#13;
<p>You pass <code>tls.Dial</code> the <code>tls.Config</code> with the pinned server certificate <span class="CodeAnnotation">1</span>. Your TLS client authenticates the server’s certificate without having to resort to using <code>InsecureSkipVerify</code> and all the insecurity that option introduces. </p>&#13;
<p>Now that you’ve set up a trusted connection with a server, even though the server presented an unsigned certificate, let’s make sure the server works as expected. It should echo back any message you send it. If you idle long enough <span class="CodeAnnotation">2</span>, you find that your next interaction with the socket results in an error <span class="CodeAnnotation">3</span>, showing the server closed the socket.</p>&#13;
<h2 id="h1-500884c11-0003">Mutual TLS Authentication</h2>&#13;
<p class="BodyFirst">In the preceding section, you learned how clients authenticate servers by using the server’s certificate and a trusted third-party certificate or by configuring the client to explicitly trust the server’s certificate. Servers can authenticate clients in the same manner. This is particularly useful in zero-trust network infrastructures, where clients and servers must each prove their identities. For example, you may have a client outside your network that must present a certificate to a proxy before the proxy will allow the client to access your trusted network resources. Likewise, the client authenticates the certificate presented by your proxy to make sure it’s talking to your proxy and not one controlled by a malicious actor.</p>&#13;
<p>You can instruct your server to set up TLS sessions with only authenticated clients. Those clients would have to present a certificate signed by a trusted certificate authority or pinned to the server. Before you can look at example code, the client needs a certificate it can present to the server for <span epub:type="pagebreak" id="Page_256" title="256"/>authentication. However, clients cannot use the certificates generated with <em>$GOROOT/src/crypto/tls/generate_cert.go</em> for client authentication. Instead, you need to create your own certificate and private key.</p>&#13;
<h3 id="h2-500884c11-0008">Generating Certificates for Authentication</h3>&#13;
<p class="BodyFirst">Go’s standard library contains everything you need to generate your own certificates using the elliptic curve digital signature algorithm (ECDSA) and the P-256 elliptic curve. <a href="#listing11-12" id="listinganchor11-12">Listing 11-12</a> shows the beginnings of a command line utility for doing exactly that. As you go through it, keep in mind that it may not entirely fit your use case. For example, it creates 10-year certificates and uses my name as the certificate’s subject, which you likely don’t want to use in your code (though if you do, I’m flattered). Tweak, as necessary.</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "crypto/ecdsa"&#13;
    "crypto/elliptic"&#13;
    "crypto/rand"&#13;
    "crypto/x509"&#13;
    "crypto/x509/pkix"&#13;
    "encoding/pem"&#13;
    "flag"&#13;
    "log"&#13;
    "math/big"&#13;
    "net"&#13;
    "os"&#13;
    "strings"&#13;
    "time"&#13;
)&#13;
&#13;
var (&#13;
    host = flag.String("host", "localhost",&#13;
        "Certificate's comma-separated host names and IPs")&#13;
    certFn = flag.String("cert", "cert.pem", "certificate file name")&#13;
    keyFn  = flag.String("key", "key.pem", "private key file name")&#13;
)&#13;
&#13;
func main() {&#13;
    flag.Parse()&#13;
&#13;
    serial, err := <span class="CodeAnnotation">1</span>rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), &#13;
        128))&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
    notBefore := time.Now()&#13;
    template := x509.Certificate{&#13;
        SerialNumber: serial,&#13;
<span epub:type="pagebreak" id="Page_257" title="257"/>        Subject: pkix.Name{&#13;
            Organization: []string{"Adam Woodbeck"},&#13;
        },&#13;
        NotBefore: notBefore,&#13;
        NotAfter:  notBefore.Add(10 * 356 * 24 * time.Hour),&#13;
        KeyUsage: x509.KeyUsageKeyEncipherment |&#13;
            x509.KeyUsageDigitalSignature |&#13;
            x509.KeyUsageCertSign,&#13;
        ExtKeyUsage: []x509.ExtKeyUsage{&#13;
            x509.ExtKeyUsageServerAuth,&#13;
          <span class="CodeAnnotation">2</span>x509.ExtKeyUsageClientAuth,&#13;
        },&#13;
        BasicConstraintsValid: true,&#13;
        IsCA:                  true,&#13;
    }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-12">Listing 11-12</a>: Creating an X.509 certificate template (<em>cert/generate.go</em>)</p>&#13;
<p>The command line utility accepts a comma-separated list of hostnames and IP addresses that will use the certificate. It also allows you to specify the certificate and private-key filenames, but it defaults to our familiar <em>cert.pem</em> and <em>key.pem</em> filenames.</p>&#13;
<p>The process of generating a certificate and a private key involves building a template in your code that you then encode to the X.509 format. Each certificate needs a serial number, which a certificate authority typically assigns. Since you’re generating your own self-signed certificate, you generate your own serial number using a cryptographically random, unsigned 128-bit integer <span class="CodeAnnotation">1</span>. You then create an <code>x509.Certificate</code> object that represents an X.509-formatted certificate and set various values, such as the serial number, the certificate’s subject, the validity lifetime, and various usages for this certificate. Since you want to use this certificate for client authentication, you must include the <code>x509.ExtKeyUsageClientAuth</code> value <span class="CodeAnnotation">2</span>. If you omit this value, the server won’t be able to verify the certificate when presented by the client.</p>&#13;
<p>The template is almost ready. You just need to add the hostnames and IP addresses before generating the certificate (see <a href="#listing11-13" id="listinganchor11-13">Listing 11-13</a>).</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    for _, h := range <span class="CodeAnnotation">1</span>strings.Split(*host, ",") {&#13;
        if ip := net.ParseIP(h); ip != nil {&#13;
         <span class="CodeAnnotation">2</span> template.IPAddresses = append(template.IPAddresses, ip)&#13;
        } else {&#13;
         <span class="CodeAnnotation">3</span> template.DNSNames = append(template.DNSNames, h)&#13;
        }&#13;
    }&#13;
&#13;
    priv, err := <span class="CodeAnnotation">4</span>ecdsa.GenerateKey(elliptic.P256(), rand.Reader)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
<span epub:type="pagebreak" id="Page_258" title="258"/>    der, err := <span class="CodeAnnotation">5</span>x509.CreateCertificate(rand.Reader, &amp;template,&#13;
        &amp;template, &amp;priv.PublicKey, priv)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
    cert, err := os.Create(*certFn)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
    err = <span class="CodeAnnotation">6</span>pem.Encode(cert, &amp;pem.Block{Type: "CERTIFICATE", Bytes: der})&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
    if err := cert.Close(); err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
    log.Println("wrote", *certFn)</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-13">Listing 11-13</a>: Writing the Privacy-Enhanced Mail (PEM)–encoded certificate (<em>cert/generate.go</em>)</p>&#13;
<p>You loop through the comma-separated list of hostnames and IP addresses <span class="CodeAnnotation">1</span>, assigning each to its appropriate slice in the template. If the hostname is an IP address, you assign it to the <code>IPAddresses</code> slice <span class="CodeAnnotation">2</span>. Otherwise, you assign the hostname to the <code>DNSNames</code> slice <span class="CodeAnnotation">3</span>. Go’s TLS client uses these values to authenticate a server. For example, if the client connects to <em>https://www.google.com</em> but the common name or alternative names in the server’s certificate do not match <em>www.google.com</em>’s hostname or resolved IP address, the client fails to authenticate the server.</p>&#13;
<p>Next you generate a new ECDSA private key <span class="CodeAnnotation">4</span> using the P-256 elliptic curve. At this point, you have everything you need to generate the certificate. The <code>x509.CreateCertificate</code> function <span class="CodeAnnotation">5</span> accepts a source of entropy (<code>crypto/rand</code>’s <code>Reader</code> is ideal), the template for the new certificate, a parent certificate, a public key, and a corresponding private key. It then returns a slice of bytes containing the Distinguished Encoding Rules (DER)–encoded certificate. You use your template for the parent certificate since the resulting certificate signs itself. All that’s left to do is create a new file, generate a new <code>pem.Block</code> with the DER-encoded byte slice, and PEM-encode everything to the new file <span class="CodeAnnotation">6</span>. You don’t have to concern yourself with the various encodings. Go is quite happy with using PEM-encoded certificates on disk.</p>&#13;
<p>Now that you have a new certificate on disk, let’s write the corresponding private key in <a href="#listing11-14" id="listinganchor11-14">Listing 11-14</a>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    key, err := os.OpenFile(*keyFn, os.O_WRONLY|os.O_CREATE|os.O_TRUNC,&#13;
      <span class="CodeAnnotation">1</span>0600)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
<span epub:type="pagebreak" id="Page_259" title="259"/>    }&#13;
&#13;
    privKey, err := <span class="CodeAnnotation">2</span>x509.MarshalPKCS8PrivateKey(priv)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
    err = <span class="CodeAnnotation">3</span>pem.Encode(key, &amp;pem.Block{Type: "EC PRIVATE KEY",&#13;
    Bytes: privKey})&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
    if err := key.Close(); err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
    log.Println("wrote", *keyFn)&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-14">Listing 11-14</a>: Writing the PEM-encoded private key (<em>cert/generate.go</em>)</p>&#13;
<p>Whereas the certificate is meant to be publicly shared, the private key is just that: private. You should take care to assign it minimal permissions. Here, you’re giving only the user read-write access to the private-key file <span class="CodeAnnotation">1</span> and removing access for everyone else. We marshal the private key into a byte slice <span class="CodeAnnotation">2</span> and, similarly, assign it to a new <code>pem.Block</code> before writing the PEM-encoded output to the private-key file <span class="CodeAnnotation">3</span>.</p>&#13;
<p><a href="#listing11-15" id="listinganchor11-15">Listing 11-15</a> uses the preceding code to generate certificate and key pairs for the server and the client.</p>&#13;
<pre><code>$ <b>go run cert/generate.go -cert serverCert.pem -key serverKey.pem -host localhost</b>&#13;
2006/01/02 15:04:05 wrote serverCert.pem&#13;
2006/01/02 15:04:05 wrote serverKey.pem&#13;
$ <b>go run cert/generate.go -cert clientCert.pem -key clientKey.pem -host localhost</b>&#13;
2006/01/02 15:04:05 wrote clientCert.pem&#13;
2006/01/02 15:04:05 wrote clientKey.pem</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-15">Listing 11-15</a>: Generating a certificate and private-key pair for the server and the client</p>&#13;
<p>Since the server binds to <em>localhost</em> and the client connects to the server from <em>localhost</em>, this value is appropriate for both the client and server certificates. If you want to move the client to a different hostname or bind the server to an IP address, for example, you’ll need to change the <em>host</em> flag accordingly.</p>&#13;
<h3 id="h2-500884c11-0009">Implementing Mutual TLS</h3>&#13;
<p class="BodyFirst">Now that you’ve generated certificate and private-key pairs for both the server and the client, you can start writing their code. Let’s write a test that implements mutual TLS authentication between our echo server and a client, starting in <a href="#listing11-16" id="listinganchor11-16">Listing 11-16</a>.</p>&#13;
<span epub:type="pagebreak" id="Page_260" title="260"/><pre><code>package ch11&#13;
&#13;
import (&#13;
    "bytes"&#13;
    "context"&#13;
    "crypto/tls"&#13;
    "crypto/x509"&#13;
    "errors"&#13;
    "io/ioutil"&#13;
    "strings"&#13;
    "testing"&#13;
)&#13;
&#13;
func caCertPool(caCertFn string) (*x509.CertPool, error) {&#13;
    caCert, err := <span class="CodeAnnotation">1</span>ioutil.ReadFile(caCertFn)&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
&#13;
    certPool := x509.NewCertPool()&#13;
    if ok := <span class="CodeAnnotation">2</span>certPool.AppendCertsFromPEM(caCert); !ok {&#13;
        return nil, errors.New("failed to add certificate to pool")&#13;
    }&#13;
&#13;
    return certPool, nil&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-16">Listing 11-16</a>: Creating a certificate pool to serve CA certificates (<em>tls_mutual_test.go</em>)</p>&#13;
<p>Both the client and server use the <code>caCertPool</code> function to create a new X.509 certificate pool. The function accepts the file path to a PEM-encoded certificate, which you read in <span class="CodeAnnotation">1</span> and append to the new certificate pool <span class="CodeAnnotation">2</span>. The certificate pool serves as a source of trusted certificates. The client puts the server’s certificate in its certificate pool, and vice versa.</p>&#13;
<p><a href="#listing11-17" id="listinganchor11-17">Listing 11-17</a> details the initial test code to demonstrate mutual TLS authentication between a client and a server.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func TestMutualTLSAuthentication(t *testing.T) {&#13;
    ctx, cancel := context.WithCancel(context.Background())&#13;
    defer cancel()&#13;
&#13;
    serverPool, err := caCertPool(<span class="CodeAnnotation">1</span>"clientCert.pem")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    cert, err := <span class="CodeAnnotation">2</span>tls.LoadX509KeyPair("serverCert.pem", "serverKey.pem")&#13;
    if err != nil {&#13;
        t.Fatalf("loading key pair: %v", err)&#13;
    }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-17">Listing 11-17</a>: Instantiating a CA cert pool and a server certificate (<em>tls_mutual_test.go</em>)</p>&#13;
<p><span epub:type="pagebreak" id="Page_261" title="261"/>Before creating the server, you need to first populate a new CA certificate pool with the client’s certificate <span class="CodeAnnotation">1</span>. You also need to load the server’s certificate at this point <span class="CodeAnnotation">2</span> instead of relying on the server’s <code>ServeTLS</code> method to do it for you, as you have in previous listings. Why you need the server’s certificate now will be clear when you see the TLS configuration changes in <a href="#listing11-18" id="listinganchor11-18">Listing 11-18</a>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    serverConfig := &amp;tls.Config{&#13;
        Certificates: []tls.Certificate{cert},&#13;
     <span class="CodeAnnotation">1</span> GetConfigForClient: func(hello *tls.ClientHelloInfo) (*tls.Config,&#13;
            error) {&#13;
            return &amp;tls.Config{&#13;
                Certificates:             []tls.Certificate{<span class="CodeAnnotation">2</span>cert},&#13;
             <span class="CodeAnnotation">3</span> ClientAuth:               tls.RequireAndVerifyClientCert,&#13;
             <span class="CodeAnnotation">4</span> ClientCAs:                serverPool,&#13;
                CurvePreferences:         []tls.CurveID{tls.CurveP256},&#13;
                MinVersion:             <span class="CodeAnnotation">5</span>tls.VersionTLS13,&#13;
                PreferServerCipherSuites: true,</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-18">Listing 11-18</a>: Accessing the client’s hello information using GetConfigForClient (<em>tls_mutual_test.go</em>)</p>&#13;
<p>Remember that in <a href="#listing11-13">Listing 11-13</a>, you defined the <code>IPAddresses</code> and <code>DNSNames</code> slices of the template used to generate your client’s certificate. These values populate the common name and alternative names portions of the client’s certificate. You learned that Go’s TLS client uses these values to authenticate the server. But the server does not use these values from the client’s certificate to authenticate the client.</p>&#13;
<p>Since you’re implementing mutual TLS authentication, you need to make some changes to the server’s certificate verification process so that it authenticates the client’s IP address or hostnames against the client certificate’s common name and alternative names. To do that, the server at the very least needs to know the client’s IP address. The only way you can get client connection information before certificate verification is by defining the <code>tls.Config</code>’s <code>GetConfigForClient</code> method <span class="CodeAnnotation">1</span>. This method allows you to define a function that receives the <code>*tls.ClientHelloInfo</code> object created as part of the TLS handshake process with the client. From this, you can retrieve the client’s IP address. But first, you need to return a proper TLS configuration.</p>&#13;
<p>You add the server’s certificate to the TLS configuration <span class="CodeAnnotation">2</span> and the server pool to the TLS configuration’s <code>ClientCAs</code> field <span class="CodeAnnotation">4</span>. This field is the server’s equivalent to the TLS configuration’s <code>RootCAs</code> field on the client. You also need to tell the server that every client must present a valid certificate before completing the TLS handshake process <span class="CodeAnnotation">3</span>. Since you control both the client and the server, specify a minimum TLS protocol version of 1.3 <span class="CodeAnnotation">5</span>.</p>&#13;
<p>This function returns the same TLS configuration for every client connection. As mentioned, the only reason you’re using the <code>GetConfigForClient</code> method is so you can retrieve the client’s IP from its hello information. <span epub:type="pagebreak" id="Page_262" title="262"/><a href="#listing11-19" id="listinganchor11-19">Listing 11-19</a> implements the verification process that authenticates the client by using its IP address and its certificate’s common name and alternative names.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
             <span class="CodeAnnotation">1</span> VerifyPeerCertificate: func(rawCerts [][]byte,&#13;
                    verifiedChains [][]*x509.Certificate) error {&#13;
&#13;
                    opts := x509.VerifyOptions{&#13;
                        KeyUsages: []x509.ExtKeyUsage{&#13;
                          <span class="CodeAnnotation">2</span>x509.ExtKeyUsageClientAuth,&#13;
                        },&#13;
                        Roots: <span class="CodeAnnotation">3</span>serverPool,&#13;
                    }&#13;
&#13;
                    ip := strings.Split(hello.Conn.RemoteAddr().String(),&#13;
                        ":")[0]&#13;
                    hostnames, err := <span class="CodeAnnotation">4</span>net.LookupAddr(ip)&#13;
                    if err != nil {&#13;
                        t.Errorf("PTR lookup: %v", err)&#13;
                    }&#13;
                    hostnames = append(hostnames, ip)&#13;
&#13;
                    for _, chain := range verifiedChains {&#13;
                        opts.Intermediates = x509.NewCertPool()&#13;
                        for _, cert := range <span class="CodeAnnotation">5</span>chain[1:] {&#13;
                            opts.Intermediates.AddCert(cert)&#13;
                        }&#13;
&#13;
                        for _, hostname := range hostnames {&#13;
                            opts.DNSName = <span class="CodeAnnotation">6</span>hostname&#13;
                            _, err = chain[0].Verify(opts)&#13;
                            if err == nil {&#13;
                                return nil&#13;
                            }&#13;
                        }&#13;
                    }&#13;
&#13;
                    return errors.New("client authentication failed")&#13;
                },&#13;
            }, nil&#13;
        },&#13;
    }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-19">Listing 11-19</a>: Making the server authenticate the client’s IP and hostnames (<em>tls_mutual_test.go</em>)</p>&#13;
<p>Since you want to augment the usual certificate verification process on the server, you define an appropriate function and assign it to the TLS configuration’s <code>VerifyPeerCertificate</code> method <span class="CodeAnnotation">1</span>. The server calls this method after the normal certificate verification checks. The only check you’re performing above and beyond the normal checks is to verify the client’s hostname with the leaf certificate.</p>&#13;
<p><span epub:type="pagebreak" id="Page_263" title="263"/>The <em>leaf certificate</em> is the last certificate in the certificate chain given to the server by the client. The leaf certificate contains the client’s public key. All other certificates in the chain are intermediate certificates used to verify the authenticity of the leaf certificate and culminate with the certificate authority’s certificate. You’ll find each leaf certificate at index 0 in each <code>verifiedChains</code> slice. In other words, you can find the leaf certificate of the first chain at <code>verifiedChains[0][0]</code>. If the server calls your function assigned to the <code>VerifyPeerCertificate</code> method, the leaf certificate in the first chain exists at a minimum.</p>&#13;
<p>Create a new <code>x509.VerifyOptions</code> object and modify the <code>KeyUsages</code> method to indicate you want to perform client authentication <span class="CodeAnnotation">2</span>. Then, assign the server pool to the <code>Roots</code> method <span class="CodeAnnotation">3</span>. The server uses this pool as its trusted certificate source during verification.</p>&#13;
<p>Now, extract the client’s IP address from the connection object in the <code>*tls.ClientHelloInfo</code> object named <code>hello</code> passed into <a href="#listing11-18">Listing 11-18</a>’s <code>GetConfigForClient</code> method. Use the IP address to perform a reverse DNS lookup <span class="CodeAnnotation">4</span> to consider any hostnames assigned to the client’s IP address. If this lookup fails or returns an empty slice, the way you handle that situation is up to you. If you’re relying on the client’s hostname for authentication and the reverse lookup fails, you cannot authenticate the client. But if you’re using the client’s IP address only in the certificate’s common name or alternative names, then a reverse lookup failure is inconsequential. For demonstration purposes, we’ll consider a failed reverse lookup to equate to a failed test. At minimum, you append the client’s IP address to the <code>hostnames</code> slice.</p>&#13;
<p>All that’s left to do is loop through each verified chain, assign a new intermediate certificate pool to <code>opts.Intermediates</code>, add all certificates but the leaf certificate to the intermediate certificate pool <span class="CodeAnnotation">5</span>, and attempt to verify the client <span class="CodeAnnotation">6</span>. If verification returns a <code>nil</code> error, you authenticated the client. If you fail to verify each hostname with each leaf certificate, return an error to indicate that client authentication failed. The client will receive an error, and the server will terminate the connection.</p>&#13;
<p>Now that the server’s TLS configuration properly authenticates client certificates, continue with the server implementation in <a href="#listing11-20" id="listinganchor11-20">Listing 11-20</a>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    serverAddress := "localhost:44443"&#13;
    server := NewTLSServer(ctx, serverAddress, 0, <span class="CodeAnnotation">1</span>serverConfig)&#13;
    done := make(chan struct{})&#13;
&#13;
    go func() {&#13;
        err := server.ListenAndServeTLS("serverCert.pem", "serverKey.pem")&#13;
        if err != nil &amp;&amp;!strings.Contains(err.Error(),&#13;
            "use of closed network connection") {&#13;
            t.Error(err)&#13;
            return&#13;
        }&#13;
<span epub:type="pagebreak" id="Page_264" title="264"/>        done &lt;- struct{}{}&#13;
    }()&#13;
 <span class="CodeAnnotation">2</span> server.Ready()</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-20">Listing 11-20</a>: Starting the TLS server (<em>tls_mutual_test.go</em>)</p>&#13;
<p>Create a new TLS server instance, making sure to pass in the TLS configuration you just created <span class="CodeAnnotation">1</span>. Call its <code>ListenAndServeTLS</code> method in a goroutine and make sure to wait until the server is ready for connections <span class="CodeAnnotation">2</span> before proceeding.</p>&#13;
<p>Now that the server implementation is ready, let’s move on to the client portion of the test. <a href="#listing11-21" id="listinganchor11-21">Listing 11-21</a> implements a TLS client that can present <em>clientCert.pem</em> upon request by the server.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    clientPool, err := caCertPool(<span class="CodeAnnotation">1</span>"serverCert.pem")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    clientCert, err := tls.LoadX509KeyPair("clientCert.pem", "clientKey.pem")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    conn, err := tls.Dial("tcp", serverAddress, &amp;tls.Config{&#13;
     <span class="CodeAnnotation">2</span> Certificates:     []tls.Certificate{clientCert},&#13;
        CurvePreferences: []tls.CurveID{tls.CurveP256},&#13;
        MinVersion:       tls.VersionTLS13,&#13;
     <span class="CodeAnnotation">3</span> RootCAs:          clientPool,&#13;
    })&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-21">Listing 11-21</a>: Pinning the server certificate to the client (<em>tls_mutual_test.go</em>)</p>&#13;
<p>The client retrieves a new certificate pool populated with the server’s certificate <span class="CodeAnnotation">1</span>. The client then uses the certificate pool in the <code>RootCAs</code> field of its TLS configuration <span class="CodeAnnotation">3</span>, meaning the client will trust only server certificates signed by <em>serverCert.pem</em>. You also configure the client with its own certificate <span class="CodeAnnotation">2</span> to present to the server upon request.</p>&#13;
<p>It’s worth noting that the client and server have not initialized a TLS session yet. They haven’t completed the TLS handshake. If <code>tls.Dial</code> returns an error, it isn’t because of an authentication issue but more likely a TCP connection issue. Let’s continue with the client code to initiate the handshake (see <a href="#listing11-22" id="listinganchor11-22">Listing 11-22</a>).</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    hello := []byte("hello")&#13;
    _, err = conn.Write(hello)&#13;
<span epub:type="pagebreak" id="Page_265" title="265"/>    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    b := make([]byte, 1024)&#13;
    n, err := <span class="CodeAnnotation">1</span>conn.Read(b)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    if actual := b[:n]; !bytes.Equal(hello, actual) {&#13;
        t.Fatalf("expected %q; actual %q", hello, actual)&#13;
    }&#13;
&#13;
    err = conn.Close()&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    cancel()&#13;
    &lt;-done&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing11-22">Listing 11-22</a>: TLS handshake completes as you interact with the connection (<em>tls_mutual_test.go</em>)</p>&#13;
<p>The first read from, or write to, the socket connection automatically initiates the handshake process between the client and the server. If the server rejects the client certificate, the read call <span class="CodeAnnotation">1</span> will return a <em>bad certificate</em> error. But if you created appropriate certificates and properly pinned them, both the client and the server are happy, and this test passes.</p>&#13;
<h2 id="h1-500884c11-0004">What You’ve Learned</h2>&#13;
<p class="BodyFirst">Transport Layer Security provides both authentication and encrypted communication between a client and a server. The server presents a certificate, signed by certificate authority, to a client as part of the TLS handshake process. The client verifies the certificate’s signatory. If a third party, trusted by the client, signed the server’s certificate, the server is authentic in the eyes of the client. From that point forward, the client and server communicate using symmetric-key cryptography.</p>&#13;
<p>By default, Go’s TLS configuration uses the operating system’s trusted certificate storage. This storage typically consists of certificates from the world’s foremost trusted certificate authorities. However, we can modify the TLS configuration to trust specific keys, a process known as key pinning.</p>&#13;
<p>We can also modify a server’s TLS configuration to require a certificate from the client. The server would then use this certificate to authenticate the client in the same manner the client authenticates the server. This process is known as mutual TLS authentication.</p>&#13;
<p><span epub:type="pagebreak" id="Page_266" title="266"/>TLS 1.3 provides forward secrecy for all communication between a client and server. This means that compromising one session does not compromise any other session. Both the client and server generate per-session public- and private-key pairs. They also exchange an ephemeral shared secret as part of the handshake process. Once the session ends, the client and server shall purge the shared secret and their temporary key pairs. An attacker who was able to capture the shared secret and session traffic would be able to decrypt only that session’s traffic. An attacker could not use the shared secret from one session to decrypt traffic from any other session.</p>&#13;
<p>Even though TLS is ubiquitous and secures much of the world’s digital communication, attackers can compromise it. Part of a certificate authority’s job is to verify that the entity requesting a certificate for a specific domain name owns the domain name. If attackers dupe a certificate authority, or the certificate authority otherwise makes a mistake and issues a fraudulent certificate, the owner of the fraudulent certificate could masquerade as Google, for example, and trick people into divulging sensitive information.</p>&#13;
<p>Another attack vector includes fooling a client into adding the attacker’s certificate into the client’s trusted certificate storage. The attacker could then issue and sign any certificate they want, and the client would inherently trust that the attacker is who their certificate claims them to be.</p>&#13;
<p>An attacker could also compromise a server and intercept TLS session keys and secrets, or even capture traffic at the application later after the server has decrypted it.</p>&#13;
<p>Overall, however, these attacks are rare, and TLS succeeds at achieving its goals of authentication and encrypted communication. </p>&#13;
</section>&#13;
</body></html>