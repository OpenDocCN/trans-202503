- en: '**7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: EXAMINATION OF INSTALLED SOFTWARE PACKAGES**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter covers the analysis of software installed on a Linux system, which
    includes software copied during the initial creation of a Linux system and software
    packages installed, updated, and removed during normal system administration.
    From a digital forensics perspective, we are interested in when software packages
    were installed on a system, what was installed, who installed them, and why. These
    same questions apply to software that has been removed (uninstalled). Linux systems
    and package managers have package databases and logs with timestamps that help
    to answer these questions.
  prefs: []
  type: TYPE_NORMAL
- en: In the very early days of Linux, there were no installation GUIs or package
    management systems. People installed software by downloading source files directly
    from the developer (usually via FTP), compiling source files into binaries, and
    installing them with provided install scripts, `make install` commands, or even
    just simple file copying. Fetching and installing software dependencies was done
    manually after reading the requirements listed in the documentation (*README*
    files, and so on). The initial installation was a similar manual process. Partitions
    and filesystems were created by hand, system directories were made, the kernel
    was copied into place, and the bootloader was installed. You can still experience
    this manual process today with the *Linux From Scratch (LFS)*^([1](footnotes.xhtml#ch07foot_01))
    distribution, which is also an excellent way to learn Linux in depth.
  prefs: []
  type: TYPE_NORMAL
- en: Some of a Linux distribution’s defining features include its installation process
    and its package management system. These areas of Linux largely lack common standardization,
    and most distributions still have their own tools, scripts, remote package repositories,
    local package databases, and package file formats.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux community is experiencing some fundamental changes in how it manages
    software. Some distributions are now using a *rolling-release* model, in which
    the system is updated as new software becomes available without having fixed version
    numbers or release dates. This model allows users to have the latest versions
    of software with the newest features and security fixes. Gentoo and Arch Linux
    were the first major distros to pioneer the rolling release concept. Complexity
    and compatibility has driven another change toward software bundled in self-contained
    archives with all the files needed to function (including files that are normally
    shared, like libraries). Both of these software packaging concepts are interesting
    from a forensics perspective, and digital evidence can be found in the metadata
    and logfiles.
  prefs: []
  type: TYPE_NORMAL
- en: Most distros use a traditional software development life cycle which has well-defined
    release dates, names, and version numbers. Version numbers are especially important
    when analyzing compromised systems and intrusions. Known vulnerabilities in a
    particular software version can be potentially linked to malicious activity and
    exploitation. This vulnerability identification also applies to rolling release
    distros, as they install released versions of individual software packages or
    Git-cloned packages from a specific date.
  prefs: []
  type: TYPE_NORMAL
- en: '**System Identification**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a Linux PC, laptop, or acquired image file arrives in your forensic lab
    for analysis, one of the first tasks is to determine which Linux distribution
    is installed. This knowledge helps focus an investigation along a more distro-specific
    analysis. Other artifacts to look for are unique identifiers that can be used
    to link and corroborate evidence from multiple sources. For example, a randomly
    generated unique identification string created during installation might be used
    to positively identify the machine in backup archives or in logs found on other
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: '***Distro Release Information***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The typical software development life cycle involves releasing software at distinct
    points in time, with alphas, betas, release candidates, and releases. This model
    includes pre-release testing, a fixed (frozen) stable release, and post-release
    updates. Fixed releases provide a higher degree of stability and allow for easier
    support. The distro version number is independent of the kernel version (even
    though it’s the kernel that makes it Linux in the first place). The individual
    software packages each have their own version numbers, which are also independent
    of the distro version number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern Linux installations based on systemd provide detailed release information
    in the */etc/os-release* file (usually a symlink to */usr/lib/os-release*); for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This file is designed to be readable from shell scripts (each line is an assigned
    variable). The variables in this example are mostly self-explanatory, but you
    can see the os-release(5) man page for more information. A systemd-based distro
    may also place information about the local machine (location, deployment, and
    so on) in the */etc/machine-info* file. See the machine-info(5) man page for more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Linux Standard Base (LSB)* also defines */etc/*distro*.release* and */etc/
    lsb-release* files that provide distro release information, and some distributions
    may include LSB information files. See the lsb_release(1) man page and `lsb_release`
    source code (it is a simple script) for more information. Here is one example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Some distros write version information to other small text files in the */etc/*
    directory. For example, in Fedora:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Debian stores information in the */etc/debian_version* file. A search for all
    files matching */etc/*release* or */etc/*version* will provide the most common
    distro and release information files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some distros also put version and release information into the */etc/issue*
    or */etc/motd* files, which are displayed when a user logs in via the shell or
    network. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Rolling release distros will often use the date of the last update as the version
    number.
  prefs: []
  type: TYPE_NORMAL
- en: '***Unique Machine ID***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Modern Linux systems have a unique identifier that’s created during installation.
    The */etc/machine-id* file (may be copied or symlinked with the D-Bus machine
    ID stored in */var/lib/dbus/machine-id*) contains a randomly generated 128-bit
    hexadecimal string, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This unique identification string can be used for matching identical copied/
    duplicated machines deployed in multiple places, or for matching a system with
    full system backups. The creation timestamp of this file is a potential indicator
    of the installation time. See the machine-id(5) man page for details. Raspberry
    Pi images initially contain an empty */etc/machine-id* file that’s initialized
    during the first boot.
  prefs: []
  type: TYPE_NORMAL
- en: POSIX-compliant systems also have a hostid that’s typically a hexadecimal representation
    of the IP address (derived from the */etc/hosts* file or a DNS lookup). This ID
    can be stored in the */etc/hostid* file (though most distros don’t have it) and
    is found on a running system by executing the `hostid` command or calling `gethostid()`
    from a program.
  prefs: []
  type: TYPE_NORMAL
- en: '***System Hostname***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The machine’s hostname is another identifier. This hostname is set in the kernel
    at boot time or during network reconfiguration. The hostname can be manually specified
    during installation or dynamically assigned during DHCP network configuration.
    The system administrator chooses the hostname, which is likely to be unique among
    the machines under their responsibility or within a DNS domain. However, the hostname
    is not guaranteed
  prefs: []
  type: TYPE_NORMAL
- en: to be unique in general. The name of the system is typically stored in the */etc/hostname*
    file in a non-FQDN format. Fully qualified domain names (FQDNs) are allowed but
    not preferred.
  prefs: []
  type: TYPE_NORMAL
- en: If a hostname is specified in */etc/hostname* (or another distro-specific location)
    or returned from a DHCP request, the running kernel is configured accordingly.
    Hosts with multiple interfaces, multiple IP addresses (each resolving to a different
    DNS name), or roaming machines (laptops and mobile devices) will still have one
    hostname representing the whole system. Network configuration involving hostnames,
    DNS domain names, interfaces, and so on is explained in [Chapter 8](ch08.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '**Distro Installer Analysis**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Analysis of the initial installation of a Linux system involves identifying
    the locations of logs and files containing potentially interesting information.
    An initial Linux installation can be either user-interactive or automated/unattended
    (enterprise deployment). In both cases, a set of basic configuration parameters
    are specified to guide the installation process. The typical decision information
    needed for installing a system is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Language, locale, keyboard layout, and time zone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drive partitioning, filesystems, and mount points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption of drives or home directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial username and password, and root password (unless using sudo)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic system type (choice of desktop, headless server, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic services (web server, remote access with SSH, printing, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choice of software repositories, non-free software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated enterprise installations (such as Red Hat’s Kickstart or SUSE’s AutoYaST,
    for example) are outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'When analyzing the installation process, a digital forensic investigator is
    trying to answer several basic questions:'
  prefs: []
  type: TYPE_NORMAL
- en: When was the system installed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What were the initial settings provided during install?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there any useful or interesting information that was saved?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Was there anything unusual about the installation (or about the repositories)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the type of incident or investigation in progress, other more specific
    questions related to the installation will need answering.
  prefs: []
  type: TYPE_NORMAL
- en: When building timelines, keep in mind that a system installation is not a single
    point in time, but rather a period with starting and ending timestamps. Depending
    on the speed of the machine, network connection, and number of installed packages,
    an installation may take more than a few minutes to complete. If an installation
    is interactive, and a user is not there to answer the prompted questions, the
    installation may appear to take hours or more to complete (whenever the user returned
    to the installation prompt).
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the starting timestamps of an installation may be unreliable.
    When a computer is booted with the installation media, time has not yet been synchronized
    and the time zone has not been chosen. The installer might still generate logs,
    but it will use whatever time the PC or virtual machine (VM) host happened to
    have (in some obscure cases, this time difference could also be interesting from
    an investigative perspective). Once the network has been configured, the time
    zone has been determined, and the clock has been synchronized, the logs will contain
    more reliable timestamps.
  prefs: []
  type: TYPE_NORMAL
- en: A systemd service called `systemd-firstboot` is able to provide automated or
    interactive configuration on the first boot of a system. See the systemd-firstboot(1)
    man page for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '***Debian Installer***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The initial installation of a Debian system uses *Debian Installer*.^([2](footnotes.xhtml#ch07foot_02))
    Debian Installer itself is a Linux system that can be booted from CD/DVD, USB
    stick, over a network, or from a downloaded image file (for VMs). The documentation
    defines multiple stages of a Debian installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Booting and initialization** Initial booting of the installer; choice of
    keyboard, language, and locale; and hardware detection'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loading additional components** Choice of mirror, fetching and unpacking
    additional components'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network configuration** Detect network hardware and configure network'
  prefs: []
  type: TYPE_NORMAL
- en: '**Partitioning** Detect attached storage, partition drives, create file systems,
    and define mount points'
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing the target system** Install base system and user-selected packages,
    set up user accounts, finalize install, and reboot'
  prefs: []
  type: TYPE_NORMAL
- en: 'Logs from a completed Debian installation are saved in */var/log/installer/*
    and provide a snapshot of information from the time the initial installation was
    made. This snapshot can be interesting. For example, consider this installer log
    directory from a typical Debian installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The *hardware-summary* file provides information about the machine hardware
    at the time of installation, including a list of devices on the PCI bus and attached
    USB devices. The *lsb-release* file contains information about the originally
    installed release (before any upgrades). The *partman* file is the output from
    the drive setup process, and it includes storage devices, partition information,
    and created filesystems. The *status* file contains a detailed list of all installed
    packages (including versions) at the time of installation. The *syslog* file contains
    information sent to the standard syslog during the entire installation process
    (with timestamps). Desktop systems may also have an *Xorg.0.log* file containing
    the startup output of the X11 server, which has information about the graphics
    card, monitors, and attached peripheral input devices. The *cdebconf* package
    has files containing the options and choices made during the install process.
    These files provide insight into the system’s state at the time of installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ubuntu-based systems have a bootable live system (called *Casper*) with a graphical
    installer program called *Ubiquity*. The Debian Installer is used as a backend
    to Ubiquity and leaves files in */var/log/installer/* but with slightly different
    contents. Following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The *casper.log* and *debug* files are the output from the installer scripts
    and contain error messages. The *media-info* file shows the release information
    at the time of install. Some Ubuntu-based distros (Mint, for example) may also
    have a version file. The *initial-status.gz* file (compressed) contains a list
    of initially installed packages.
  prefs: []
  type: TYPE_NORMAL
- en: '***Raspberry Pi Raspian***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Raspberry Pi uses a Debian-based distribution called Raspian. Debian Installer
    isn’t necessary, because Raspian is available as a preinstalled image file for
    download. This preinstalled image is available in two formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOOBS** A beginner-friendly process in which the user formats the SD card
    (FAT) and copies files and no special tools needed'
  prefs: []
  type: TYPE_NORMAL
- en: '**Drive image** A raw image that needs to be unzipped and transferred to the
    SD card with `dd` or a similar tool'
  prefs: []
  type: TYPE_NORMAL
- en: Because there is no “installation” in the usual sense, investigators will want
    to determine the time when the user first powered on the Pi and saved the initial
    settings. However, finding this initial setup time is tricky for a number of reasons.
    The initial filesystem timestamps are from the Raspian image that was downloaded,
    and not created from local installer scripts. The Raspberry Pi has no hardware
    clock with battery backup,^([3](footnotes.xhtml#ch07foot_03)) so every time the
    Pi is powered on, the clock starts with the Unix epoch (00:00 January 1, 1970).
    The booting operating system sets the clock to the time nearest to the last power-off
    until network time synchronization is achieved (see [Chapter 9](ch09.xhtml) for
    more details on system time). By default, the filesystem is mounted with the `noatime`
    option, so the last-accessed timestamps are not updated. Other timestamps may
    have been updated and log entries written before the correct time was established,
    rendering those times unreliable.
  prefs: []
  type: TYPE_NORMAL
- en: When a Raspberry Pi is used for the first time, the filesystem is resized to
    fit the SD card. After a reboot, the `piwiz` application starts,^([4](footnotes.xhtml#ch07foot_04))
    which allows the user to configure a network, reset the password (the default
    is `raspberry`), and specify the country, language, and time-zone settings. The
    `piwiz` app starts automatically from the file */etc/xdg/autostart/piwiz.desktop*,
    which is deleted after the user provides their initial preferences. If this *piwiz.desktop*
    file still exists, it indicates an unused Raspberry Pi installation. If your filesystem
    forensic analysis tool can determine the time when the file */etc/xdg/ autostart/piwiz.desktop*
    was deleted, that would indicate an approximate time of a completed installation.
    An alternative is to find the timestamp of the first entry in the */var/log/dpkg.log*
    file (or the oldest saved log rotation). Packages are updated for the first time
    when `piwiz` runs, which happens only after time synchronization was successful.
  prefs: []
  type: TYPE_NORMAL
- en: '***Fedora Anaconda***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Fedora-based systems (CentOS, Red Hat, and so on) use an installer called Anaconda.^([5](footnotes.xhtml#ch07foot_05))
    After the initial desktop installation is complete and the new system reboots
    for the first time, a separate application called `Initial Setup` is run. This
    application can provide additional configuration possibilities, including the
    user acceptance of end-user licensing agreements (EULAs).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Anaconda installer leaves logfiles of the initial installation in */var/
    log/anaconda/* that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The *anaconda.log* file tracks the progress of various installation tasks. The
    *X.log* file shows the output from the Xorg server used by Anaconda and contains
    information about the graphics card, monitors, and attached peripheral input devices
    at the time of installation.
  prefs: []
  type: TYPE_NORMAL
- en: The *journal.log* and *syslog* files are very similar, with the main difference
    being that *journal.log* shows more dracut activity (see [Chapter 6](ch06.xhtml)).
    They both include the initialization of the kernel (dmesg output) and systemd
    at the time of first installation. These logs can help determine the start and
    end times of an installation. Information about storage devices, partitioning,
    and volume management can be found in *storage.log* and *lvm.log*. The *dnf.librepo.log*
    file lists all of the packages downloaded for installation. The *ks-script-*.log*
    files contain log output from kickstart scripts. Other files contain logs with
    D-Bus activity and library calls. See *[https://fedoraproject.org/wiki/Anaconda/Logging](https://fedoraproject.org/wiki/Anaconda/Logging)*
    for more information about Anaconda logging.
  prefs: []
  type: TYPE_NORMAL
- en: These logs provide information about the user-specified configuration, the hardware
    of the original machine, packages installed, and storage configuration at the
    time of installation.
  prefs: []
  type: TYPE_NORMAL
- en: '***SUSE YaST***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SUSE Linux has one of the oldest distro installers still maintained today. *YaST*,
    or “Yet another Setup Tool,” was designed to combine the initial installation
    with other system configuration tasks into one tool.^([6](footnotes.xhtml#ch07foot_06))
    YaST can be used to install the system, set up peripherals like printers, install
    packages, configure hardware, configure the network, and more. SUSE also provides
    AutoYaST for unattended enterprise deployment.
  prefs: []
  type: TYPE_NORMAL
- en: The YaST log directory is */var/log/YaST2/*. It contains logs from both the
    installation and other regular configuration tasks. Logs from the installation
    are stored in the compressed archive file *yast-installation-logs.tar.xz*, and
    are of particular interest from a forensics perspective. The following is an example
    (partial) list of contents:^([7](footnotes.xhtml#ch07foot_07))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The release information at the time of install is found in the sub-directory
    `etc/os-release`. The file *Xorg.0.log* contains information about the graphics
    card, monitors, and attached peripheral input devices at the time of installation.
    The *boot.msg*, *dmesg*, and *messages* files contain logs from the installation,
    the kernel ring buffer, and other information at the time of install. The *wickedd.log*
    file from the network manager records the configuring of the network, including
    the system’s IP and other network configuration from the time of installation.
  prefs: []
  type: TYPE_NORMAL
- en: The start and end times of the logfile entries from this directory provide an
    approximate time period of when the installation took place.
  prefs: []
  type: TYPE_NORMAL
- en: '***Arch Linux***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The native Arch Linux system does not have a comfortable installer. Booting
    the Arch installation media drops the user into a root shell with a reference
    to the wiki installation guide (earlier versions had an *install.txt* file containing
    further instructions). The user is expected to create the partitions and filesystem
    manually, and then run the `pacstrap` script that populates the mounted install
    target directory. After that, the user chroots into the directory and manually
    completes the installation. The installation process is documented at *[https://wiki.archlinux.org/index.php/Installation_guide](https://wiki.archlinux.org/index.php/Installation_guide)*.
  prefs: []
  type: TYPE_NORMAL
- en: A basic installer script called `archinstall` is included with Arch Linux install
    media. If used, this script logs the initial configuration settings and activity
    in */var/log/archinstall/install.log*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The creation (`Birth:`) timestamp of the root directory (if the filesystem
    supports it) is a rough indicator of the start of installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Installing Arch is a manual and ongoing process. A user may continue installing
    and tweaking the system indefinitely, and an install “end” time may not make sense
    in this context.
  prefs: []
  type: TYPE_NORMAL
- en: The terse and non-intuitive process of installing Arch Linux has spawned several
    distros for users who want all the benefits of a bleeding-edge rolling distro,
    but with a comfortable installation. The most popular Arch-based distro is Manjaro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Manjaro’s installer is called Calamares, and it provides minimal logging of
    the installation process. These logs are found in */var/log/Calamares.log*. The
    content of *Calamares.log* includes specified configuration (time zone, locale,
    and so on), partition information, user information, and more. Calamares (on Manjaro)
    doesn’t log an IP address, but it does perform a Geo-IP lookup to determine the
    location of the system being installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Calamares has become well known because of Manjaro, but it was developed with
    the intention of being a general installer for any distribution. See *[https://calamares.io/](https://calamares.io/)*
    for more information on Calamares.
  prefs: []
  type: TYPE_NORMAL
- en: '**Package File Format Analysis**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section covers the file formats of the individual software packages used
    in common Linux distributions. Linux distribution software packages are single
    archive files containing all the information and files needed to install and remove
    them from the Linux system. In addition, Linux systems typically have package
    management systems that keep track of installed packages, manage dependencies,
    perform updates, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Analysis of a software package file can reveal interesting artifacts. Some
    forensic analysis tasks that can be performed on a package file include:'
  prefs: []
  type: TYPE_NORMAL
- en: Discovering when a package was built
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying package integrity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing package metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing package file contents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting supporting scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting individual files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying additional timestamps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, a vulnerability assessment may involve matching the version numbers
    of individual packages with known published vulnerabilities; for example, matching
    a particular software version installed on a system with a CVE published by Mitre
    (*[https://cve.mitre.org/](https://cve.mitre.org/)*). This is typically the task
    of an enterprise vulnerability management function within an organization.
  prefs: []
  type: TYPE_NORMAL
- en: '***Debian Binary Package Format***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Debian binary package format (DEB), is used by Debian and Debian-based distributions.
    See the deb(5) man page on a Debian or Debian-based system for more information.
    A DEB file has the **.deb* extension and an initial magic string of seven characters
    (`!<arch>`). [Figure 7-1](ch07.xhtml#ch07fig01) on the following page shows the
    structure of a DEB file.
  prefs: []
  type: TYPE_NORMAL
- en: 'DEB files use the `ar` archive format and contain three standard components.
    In this example, the `ed` package (a line-oriented text editor) is listed using
    the GNU `ar` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the flags (`-tv`) for `ar` specify a verbose listing of the
    contents. The file timestamps indicate when the DEB package archive was built.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three files in the archive have the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '***debian-binary*** A file containing the package format version string'
  prefs: []
  type: TYPE_NORMAL
- en: '***control*** A compressed archive with scripts/metadata about the package'
  prefs: []
  type: TYPE_NORMAL
- en: '***data*** A compressed archive containing the files to be installed'
  prefs: []
  type: TYPE_NORMAL
- en: 'These components can be extracted with `ar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The (`-xov`) flags instruct `ar` to extract files, keep original timestamps,
    and show verbose output. The *control.tar.xz* and *data.tar.xz* files are compressed
    archives that can be further examined.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch07fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: Debian “DEB” package format (modified from Wikipedia:* [https://upload.wikimedia.org/wikipedia/commons/6/67/Deb_File_Structure.svg](https://upload.wikimedia.org/wikipedia/commons/6/67/Deb_File_Structure.svg)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *debian-binary* file contains a single line with the package format version
    number (2.0). To list the contents of the archives, we rely on `tar` to decompress
    the file and list the archive contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to extract a particular file from the **.tar.xz* archives, we can
    use the same command, but give `tar` specific instructions to extract the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The contents of the extracted control file list the version, CPU architecture,
    maintainer, dependencies, and other information. The *control* file is mandatory
    and the other files within the *control.tar.xz* component are optional. Other
    common package control files include pre-install, post-install, pre-remove, and
    post-remove scripts (`preinst`, `postinst`, `prerm`, and `postrm`, respectively).
    See the deb-control(5) man page for more information about the *control* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extract files and directories from the data archive the same way. However,
    doing so will extract a full directory tree to the current working directory with
    the file(s) specified. It is also possible to extract individual files to `stdout`,
    allowing redirection to a file or program. In this example, a single file is extracted
    to `stdout` using the `-xOf` flags (`O` is an uppercase O, not zero):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Individual files can be saved using file redirection, or the entire archive
    can be unpacked to a local analysis directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although not mandatory, it is normal practice for DEB packages to contain a
    list of MD5 hashes to verify file integrity. These are stored in the *md5sums*
    file in the control component of the package archive file. This example displays
    the list of expected MD5 hashes in the package, followed by the verification of
    an installed binary file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `md5sum` tool has a flag (`-c`) that reads a list of MD5s from files like
    *md5sums* and performs checks on all files listed. There has been discussion of
    replacing the *md5sums* file with SHA hashes (for more information, see *[https://wiki.debian.org/Sha256sumsInPackages](https://wiki.debian.org/Sha256sumsInPackages)*).
  prefs: []
  type: TYPE_NORMAL
- en: On a Debian system, the `dpkg-deb` tool performs all the above analysis tasks
    of listing files, extracting files, viewing control data, and so on. If you are
    trying to recover data from a corrupted DEB file, `ar -tO` (`O` is uppercase O,
    not zero) will provide hexadecimal offsets to the three components, which may
    allow extraction with tools such as `dd`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Red Hat Package Manager***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *Red Hat Package Manager (RPM)* is a binary package format developed by
    Red Hat. RPM packages can be identified by an *.rpm* extension and a four-byte
    magic string (`ED AB EE DB`) at the start of the file. The structure of RPM package
    files is documented in the `rpm` tool’s source code, and the file */doc/manual/format*
    describes four logical sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lead** 96 bytes of “magic” and other information'
  prefs: []
  type: TYPE_NORMAL
- en: '**Signature** Collection of “digital signatures”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Header** Holding area for all the package information (aka, metadata)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Payload** Compressed archive of the file(s) in the package (aka, payload)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rpm` command, which can also be installed on non–Red Hat distros, can
    be used on a separate analysis machine. The query flag (`-q`) can be used to analyze
    various aspects of RPM files. In this example, the `-q` and `-i` flags provide
    an informational overview of the *xwrits* RPM package file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view other RPM metadata with the following flags (after `rpm -q`) together
    with the RPM filename:'
  prefs: []
  type: TYPE_NORMAL
- en: -lv    Verbose list of files in package
  prefs: []
  type: TYPE_NORMAL
- en: –dump Dumps file information (path, size, mtime, digest, mode, owner, group,
    isconfig, isdoc, rdev, and symlink)
  prefs: []
  type: TYPE_NORMAL
- en: –changes Displays change information for the package with full timestamps (`--changelog`
    is the same, but with dates)
  prefs: []
  type: TYPE_NORMAL
- en: –provides Lists the capabilities this package provides
  prefs: []
  type: TYPE_NORMAL
- en: –enhances Lists capabilities enhanced by package(s)
  prefs: []
  type: TYPE_NORMAL
- en: –obsoletes Lists packages this package obsoletes
  prefs: []
  type: TYPE_NORMAL
- en: –conflicts Lists capabilities this package conflicts with
  prefs: []
  type: TYPE_NORMAL
- en: –requires Lists capabilities on which this package depends
  prefs: []
  type: TYPE_NORMAL
- en: –recommends Lists capabilities recommended by package(s)
  prefs: []
  type: TYPE_NORMAL
- en: –suggests Lists capabilities suggested by package(s)
  prefs: []
  type: TYPE_NORMAL
- en: –supplements Lists capabilities supplemented by package(s)
  prefs: []
  type: TYPE_NORMAL
- en: –scripts Lists the package-specific scriptlet(s) that are used as part of the
    installation and deinstallation processes
  prefs: []
  type: TYPE_NORMAL
- en: –filetriggers Lists file-trigger scriptlets from package(s)
  prefs: []
  type: TYPE_NORMAL
- en: –triggerscripts Displays the trigger scripts, if any, that are contained in
    the package
  prefs: []
  type: TYPE_NORMAL
- en: This list was taken from the rpm(9) man page, where you can find further information
    about rpm files. If a flag returns no output, that header field is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting individual files from RPM packages is a two-step process. First,
    the payload is extracted from the RPM, and then the desired file is extracted
    from that payload. The `rpm2cpio` and `rpm2archive` tools create a *cpio* or compressed
    tar (**.tgz*) archive file containing the payload of the RPM. These are files
    that most file managers and forensic tools should be able to browse for file exporting/extracting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, an individual file is extracted from an RPM. First,
    the RPM payload is extracted, and then an individual file is identified and extracted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `rpm2cpio` command is run and the output is redirected to a file (it can
    be any name, but for clarity, I used same filename with a **.cpio* extension).
    The next command lists the *cpio* archive to find the desired file for extraction.
    The final command extracts the file to `stdout` where it can be piped or redirected
    to a program or file.
  prefs: []
  type: TYPE_NORMAL
- en: 'RPM package headers contain cryptographic signatures and hashes for verifying
    the payload’s integrity. Integrity checking is done with the `rpmkeys`^([8](footnotes.xhtml#ch07foot_08))
    command and can be viewed (verbose) with the `-Kv` flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The GPG keys for signed RPM packages can be imported using the `rpmkeys` command.
    See the rpmkeys(8) man page for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '***Arch Pacman Packages***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Packages for Arch Linux are compressed tar files. The default compression is
    currently in transition from XZ to Zstandard, with file extensions **.xz* and
    **.zst*, respectively.^([9](footnotes.xhtml#ch07foot_09)) The tar file contains
    both the package metadata and the files to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `tar` to view the contents of a `pacman` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows the simplicity of the package format. Several files in the
    root of the archive contain the package metadata. They are described in the Arch
    Linux Wiki (*[https://wiki.archlinux.org/index.php/Creating_packages](https://wiki.archlinux.org/index.php/Creating_packages)*)
    and include:'
  prefs: []
  type: TYPE_NORMAL
- en: '***.PKGINFO*** Contains all the metadata needed by `pacman` to deal with packages,
    dependencies, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '***.BUILDINFO*** Contains information needed for reproducible builds. This
    file is present only if a package is built with Pacman 5.1 or newer.'
  prefs: []
  type: TYPE_NORMAL
- en: '***.MTREE*** Contains hashes and timestamps of the files, which are included
    in the local database so `pacman` can verify the package’s integrity.'
  prefs: []
  type: TYPE_NORMAL
- en: '***.INSTALL*** An optional file used to execute commands after the install/upgrade/remove
    stage (this file is present only if specified in the `PKGBUILD`).'
  prefs: []
  type: TYPE_NORMAL
- en: '***.Changelog*** An optional file kept by the package maintainer documenting
    the changes of the package.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *.PKGINFO* file is regular text and can be easily viewed, but using the
    `pacman` tool provides more complete output (including fields that are undefined).
    The `-Qip` flags specify a query operation, information option, and a package
    filename for a target, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The *.MTREE* file is a compressed list of timestamps, permissions, file sizes,
    and cryptographic hashes. We can extract it by piping the `tar` output into `zcat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This can be used to verify the integrity of the files in the package and provides
    timestamps for timeline reconstruction. We can use this information to analyze
    packages that are rogue, malicious, or have been tampered with.
  prefs: []
  type: TYPE_NORMAL
- en: '**Package Management System Analysis**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous section focused on the file formats of individual software packages
    before they are installed. Here we shift the focus to the package management systems
    for software already installed (or previously installed) on a machine. This includes
    analysis of the repositories from where packages were downloaded, where the package
    contents were placed on the filesystem, databases to track the installed packages,
    installation logs, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Linux distribution’s software packaging system typically has the following
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: Repositories to download compiled binary packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repositories to download package source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repositories with non-free or varying licenses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information to resolve dependencies and conflicts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A database with a record of installed software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logfiles of package management activity (including uninstalls)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frontend user interfaces interacting with backend tools and libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package management systems across Linux distributions are very similar. See
    *[https://wiki.archlinux.org/index.php/Pacman/Rosetta](https://wiki.archlinux.org/index.php/Pacman/Rosetta)*
    for a comparison of package management commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a forensics perspective, we can ask many questions related to package
    management, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What packages are currently installed, and which versions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Who installed them, when, and how?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which packages were upgraded and when?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which packages were removed and when?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which repositories were used?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we confirm the integrity of the packages?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What logs, databases, and cached data can be analyzed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given a particular file on the filesystem, to which package does it belong?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What other timestamps are relevant?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answering these questions will help reconstruct past activity, build timelines,
    and identify possible malicious or suspicious activity. Finding and validating
    cryptographic hashes can also be useful when using NSRL hashsets to exclude known
    software. Packages that have been removed may leave behind traces of custom or
    modified configuration files and data that was not deleted.
  prefs: []
  type: TYPE_NORMAL
- en: The next few sections describe the analysis of the most common distributions.
    Each section provides an introduction to the packaging system and describes the
    various files, databases, and directory locations that are of interest to a forensic
    examiner.
  prefs: []
  type: TYPE_NORMAL
- en: '***Debian apt***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Debian package management system is a collection of programs that manage
    package searching/selection, external repositories, downloads, dependency/conflict
    resolution, installation, removal, updates and upgrades, and other package housekeeping
    functions. The end user interacts with high-level programs like Apt, Aptitude,
    Synaptic, and others to choose which packages to install, remove, or upgrade.
    These high-level programs interact with the `dpkg` command,^([10](footnotes.xhtml#ch07foot_010))
    which manages the installation, removal, and querying of packages on a Debian-based
    system. Forensic investigators are mainly interested in the current package state
    of a system, reconstructing past package activity, and identifying other interesting
    artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: The current installed package state of a Debian-based system is stored in the
    */var/lib/dpkg/status* file (the package “database”). This is a plaintext file
    with each package entry starting with the string `Package:` and ending with a
    blank line (similar style to the email mbox format). Backup copies of this file
    are in the same directory, and may be named *status-old* or */var/backups/ dpkg.status.**
    (multiple copies of previous versions may also be available in compressed form).
  prefs: []
  type: TYPE_NORMAL
- en: 'The *status* file can be easily viewed and searched with any text editor or
    text-processing tool. In this example, the `awk`^([11](footnotes.xhtml#ch07foot_011))
    tool is used to search the status file for a package name (`Package: bc`) and
    print the entire block of information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The Status: line is interesting from a forensic reconstruction perspective.
    A normal installed package file will have Status: install ok installed. Packages
    that have been removed but still have user-modified configuration files are listed
    with a status of Status: deinstall ok config-files. Some packages may have a Conffiles:
    line followed by several lines indicating configuration files an administrator
    might modify, and the MD5 hash of the originally installed version of the file.
    For example, the default configuration files of the Apache web server are shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The MD5 hashes can help identify configuration files that deviate from the package
    defaults. See the dpkg-query(1) man page for more information about the fields
    in the *status* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *status* file does not contain installation timestamps. For installation
    dates, you must analyze the logfiles. Several logfiles record the activity of
    the package management system and the frontend package manager tools. Common package
    management logs found on Debian-based systems include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '***/var/log/dpkg.log*** `dpkg` activity, including changes to package status
    (install, remove, upgrade, and so on)'
  prefs: []
  type: TYPE_NORMAL
- en: '***/var/log/apt/history.log*** Start/end times of `apt` commands and which
    user ran them'
  prefs: []
  type: TYPE_NORMAL
- en: '***/var/log/apt/term.log*** Start/end times of `apt` command output (stdout)'
  prefs: []
  type: TYPE_NORMAL
- en: '***/var/log/apt/eipp.log.**** Logs the current state of the External Installation
    Planner Protocol (EIPP), a system that manages dependency ordering'
  prefs: []
  type: TYPE_NORMAL
- en: '***/var/log/aptitude*** Aptitude actions that were run'
  prefs: []
  type: TYPE_NORMAL
- en: '***/var/log/unattended-upgrades/**** Logs from automated/unattended upgrades'
  prefs: []
  type: TYPE_NORMAL
- en: Rotated logs may be compressed and renamed to filenames with a number indicating
    the relative age of the logfile (*dpkg.log.1.gz*, for example). The larger the
    number, the older the log.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration information for `dpkg` is stored in the */etc/dpkg/* directory.
    Configuration information for `apt` is stored in the */etc/apt/* directory. The
    */etc/apt/* directory contains the *sources.list* and *sources.list.d/** files.
    These files are interesting because they define the configured external repositories
    for a particular Debian release. Explicitly added (legitimate or rogue) repositories
    will be appended to this file or saved to a file in the *sources.list.d/* directory.
    Ubuntu also has Personal Package Archives (PPAs) that use its central Launchpad
    server to help users add sources for individual packages.
  prefs: []
  type: TYPE_NORMAL
- en: The */var/lib/dpkg/info/* directory contains several files for each installed
    package (this is the metadata from the DEB files). This information includes the
    file list (**.list*), cryptographic hashes (**.md5sums*), preinstall/postinstall
    and remove scripts, and more. The **.conffiles* (if they exist) are a potentially
    useful resource for forensic investigators, as they list the location of configuration
    files and are often modified by the system owner.
  prefs: []
  type: TYPE_NORMAL
- en: The */var/cache/apt/archives/* directory contains **.deb* files that have been
    downloaded in the past. The */var/cache/debconf/* directory is a central location
    for package configuration information and templates. Of potential interest here
    is the *passwords.dat* file that contains system-generated passwords needed for
    local daemons.
  prefs: []
  type: TYPE_NORMAL
- en: See the dpkg(1) and apt(8) man pages, as well as the Debian manual (*[https://www.debian.org/doc/manuals/debian-reference/ch02.en.html#_the_dpkg_command](https://www.debian.org/doc/manuals/debian-reference/ch02.en.html#_the_dpkg_command)*)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '***Fedora dnf***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Fedora-based systems manage packages using `dnf` (Dandified Yum), the successor
    to yum (Yellow Dog Update Manager). The `dnf` tool is written in Python and uses
    the `librpm` library to manage the installed `rpm` packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current installed package state is stored in a collection of Berkeley database
    files in the */var/lib/rpm/* directory. The easiest way to analyze this is to
    use the `rpm` command on a separate analysis machine^([12](footnotes.xhtml#ch07foot_012))
    with the `--dbpath` flag pointing to a read-only copy of the database files. For
    example, to list the installed packages in a collection of database files stored
    in a separate directory, use the --dbpath and -qa flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the metadata for a specific installed package, use the --dbpath and
    -qai flags with the package name. Several examples using the Evince document viewer
    package are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To see a list of files belonging to a package, use the --dbpath and -ql flags
    (lowercase letter L, as in “list”) flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To determine which package a file belongs to, use the --dbpath and -qf flags
    with the full path and filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: All of these commands can be used with read-only offline copies of the RPM database
    files found in the */var/lib/rpm/* directory of the Linux image under analysis.
    Be aware that running the `rpm` command on your forensic workstation will use
    the local RPM configuration (for example, */usr/lib/rpm/ rpmrc*), but that shouldn’t
    affect the accuracy of the output shown in the examples above.
  prefs: []
  type: TYPE_NORMAL
- en: The RPM database files traditionally have been standard Berkeley DB files and
    could be analyzed individually with tools like `db_dump`. Fedora 33 transitioned
    to SQLite for the RPM database, and associated tools can be used to examine package
    data. In addition, the */var/lib/dnf/* directory contains SQLite databases with
    dnf package information, allowing analysis with SQLite tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dnf` command generates multiple logs, which are stored in the */var/ log/*
    directory and listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/var/log/dnf.librepo.log*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/var/log/dnf.log*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/var/log/dnf.rpm.log*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/var/log/dnf.librepo.log*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/var/log/hawkey.log*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of these are less interesting from a forensics perspective and may show
    only that a machine was online at a particular time (checking for updates, and
    so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'The *dnf.log* (or rotated versions) contain activity performed using the `dnf`
    command. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `dnf install` command was used to install `openssh-server` at a particular
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration data for `dnf` is potentially found in several locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '***/etc/dnf/*** Configuration data and modules for `dnf`'
  prefs: []
  type: TYPE_NORMAL
- en: '***/etc/rpm/*** Configuration data and macros for `rpm`'
  prefs: []
  type: TYPE_NORMAL
- en: '***/etc/yum.repos.d/*** Remote package repositories'
  prefs: []
  type: TYPE_NORMAL
- en: See the dnf.conf(5) man page for more information about `dnf` configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '***SUSE zypper***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SUSE Linux originally had its own package manager tightly integrated with its
    YaST configuration tool. SUSE later switched to using RPM for the package format
    and developed the ZYpp package manager. The primary tool for interfacing with
    the ZYpp library (libzypp) is `zypper`. The configuration information is in the
    */etc/zypp/zypper.conf* and */etc/zypp/zypp.conf* files, which control the `zypper`
    tool and ZYpp library, respectively. The configuration files specify various parameters,
    including the locations of files and directories. See the zypper(8) man page for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: The ZYpp library calls the `rpm` tool to perform the low-level installation
    and removal tasks. Because the packages are standard RPMs, the installed package
    state can be analyzed in the same way as Fedora-based systems. The */var/lib/rpm/*
    directory contains the installed package databases, as described in the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'ZYpp has several detailed logs of package management activity. The */var/log/zypp/history*
    log records the actions of the ZYpp library, which multiple frontend tools might
    use. The following example shows logs for the installation and removal of the
    `cowsay` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The log contains basic `libzypp` actions, including package install/remove,
    repository add/remove, repository changes, and the commands used.
  prefs: []
  type: TYPE_NORMAL
- en: The */var/log/zypper.log* file shows detailed activity of the `zypper` command
    line tool, and the */var/log/pk_backend_zypp* has logs of PackageKit activity.
    Both of these logs contain a field with the local system’s hostname. This could
    be interesting from a forensics perspective if the hostname is dynamically generated
    from DHCP because it indicates the hostname during the time the tools were run.
    If the hostname is an FQDN, it could have a valid domain name resolving to an
    IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SUSE `zypper-log` tool can print formatted output of a *zypper.log* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This output is similar to shell history in that all `zypper` commands entered
    are shown, including misspelled or failed attempts. The `-l` (lowercase letter
    L) flag specifies the name of the logfile to use if the log has been copied to
    an analysis machine.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration of repositories is stored in definition files in the */etc/
    repos.d/* and */etc/services.d/* directories. Service definition files manage
    the repositories and contain the `lrf_dat` variable, which is a timestamp (in
    Unix epoch format) indicating the date of last refresh. Information about remote
    package repositories (metadata) is cached locally in the */var/cache/zypp/** directories.
  prefs: []
  type: TYPE_NORMAL
- en: Some SUSE installations are configured to save bug report information whenever
    a distribution upgrade (`zypper dist-upgrade`) is run. This will create a directory
    in */var/log/updateTestcase-**, where *** is a date and time. The directory will
    contain compressed XML files of available repository packages and installed packages
    (such as *solver-system.xml.gz*).
  prefs: []
  type: TYPE_NORMAL
- en: The `zypper` tool can also be run as an interactive shell (`zypper shell`),
    in which case, histories of commands are stored in the *~/.zypper_history* file
    of the user who ran them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The */var/lib/zypp/* directory also contains persistent information about the
    installed system. A unique identifier is generated during installation and used
    for statistics every time files are downloaded from SUSE. The file *AnonymousUniqueId*
    contains the string, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This string is embedded in the HTTP user-agent (`X-ZYpp-AnonymousId:`) and sent
    to SUSE’s servers when files are requested.
  prefs: []
  type: TYPE_NORMAL
- en: '***Arch pacman***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Arch Linux uses the `pacman` command line tool for downloading and managing
    packages. The configuration file */etc/pacman.conf* is used to control how `pacman`
    and the associated `libalpm` library are used. Packages are fetched from remote
    mirror sites, which are configured in */etc/pacman.d/mirrorlist* and used in the
    order listed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arch Linux systems typically install packages from one of four sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '***core*** Packages needed for a basic operational Arch system'
  prefs: []
  type: TYPE_NORMAL
- en: '***extra*** Packages that add non-core functionality (desktops and such)'
  prefs: []
  type: TYPE_NORMAL
- en: '***community*** Packages from the Arch User Repository (AUR) that have sufficient
    community votes and are managed by trusted users (TUs)'
  prefs: []
  type: TYPE_NORMAL
- en: PKGBUILD Community-driven scripts in the AUR to build a package from source
    or proprietary binaries (where trust is unknown)
  prefs: []
  type: TYPE_NORMAL
- en: 'The first three sources are official Arch repositories with compiled binary
    packages. The list of available packages in the official repositories are synchronized
    with files in the */var/lib/pacman/sync/* directory. These files are simply zipped
    tar archives (with a different filename extension) and can be extracted with regular
    tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The timestamps indicate when the repository package lists and individual packages
    were last updated.
  prefs: []
  type: TYPE_NORMAL
- en: The integrity of signed^([13](footnotes.xhtml#ch07foot_013)) packages and databases
    is verified using GnuPG and described in the pacman(8) man page. The GPG keys
    used to verify signatures are stored in the */etc/pacman.d/gnupg/* directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default location of installed package metadata is the */var/lib/pacman/
    local/* directory. A separate directory for every installed package exists on
    the system and contains these files:'
  prefs: []
  type: TYPE_NORMAL
- en: '***desc*** Provides a description of the installed package (the metadata) and
    an install timestamp'
  prefs: []
  type: TYPE_NORMAL
- en: '***files*** A list of files and directories installed by the package'
  prefs: []
  type: TYPE_NORMAL
- en: '***mtree*** A zipped text file with information about individual files and
    directories'
  prefs: []
  type: TYPE_NORMAL
- en: '***install*** An optional file containing commands after install, upgrade,
    or removal'
  prefs: []
  type: TYPE_NORMAL
- en: '***changelog*** An optional file documenting changes to the package'
  prefs: []
  type: TYPE_NORMAL
- en: These correspond to the files listed earlier when describing the Arch Linux
    package format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *mtree* file contains the package’s filenames, timestamps, cryptographic
    hashes, and permissions needed to install the package. See the mtree(5) man page
    for more information about the format. The contents of *mtree* are gzip-compressed
    (but without a filename extension) and can be viewed with `zless` or `zcat`. In
    this example, the *mtree* file from the sfsimage^([14](footnotes.xhtml#ch07foot_014))
    package is analyzed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When a package is removed, the installed files are deleted together with this
    package metadata directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The history of package installation, updates, and removal is logged in the
    */var/log/pacman.log* file. The following example shows a package being installed
    and then removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the logs, `PACMAN` refers to `pacman` commands executed by the user, and
    `ALPM` refers to `libalpm` library activity (which includes installing dependencies).
  prefs: []
  type: TYPE_NORMAL
- en: Packages downloaded from the various repositories are cached in the */var/cache/pacman/pkg/*
    directory. This can be interesting from a forensics perspective because the directory
    contains previous versions of updated package files and does not delete removed
    package files. The filesystem timestamps will indicate when a package was downloaded
    for installation or update.
  prefs: []
  type: TYPE_NORMAL
- en: Packages in the AUR that are not part of the Arch community repository require
    several manual steps to install. This process is typically automated using AUR
    helper scripts (two examples of popular AUR helpers are `yay` and `pacaur`). These
    programs download the *PKGBUILD* and source files, unpack and compile source code,
    create and install a package, and then clean up any temporary files. These helper
    scripts may leave files and data in the user’s *~/.cache/* directory with filesystem
    timestamps from when the package was built. Many AUR helper programs are available,
    and each one might have its own configuration and save log information. See *[https://wiki.archlinux.org/index.php/AUR_helpers](https://wiki.archlinux.org/index.php/AUR_helpers)*
    for a list of AUR helpers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Universal Software Package Analysis**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some software installation and packaging systems bypass the standard mechanisms
    of Linux distributions. These are sometimes called *universal software packages*
    or *universal package systems* if they were designed to function independently
    of the chosen Linux distribution (or version of some particular distribution).
  prefs: []
  type: TYPE_NORMAL
- en: Some software packaging systems also are designed to function across non-Linux
    operating systems or enterprise container platforms (Docker, for example). This
    section focuses primarily on Linux-specific local packaging systems.
  prefs: []
  type: TYPE_NORMAL
- en: '***AppImage***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: AppImage was designed to provide compatible binaries that would work across
    multiple Linux distributions and versions by creating a self-contained portable
    file format. The most popular use of AppImage is to have the latest versions of
    desktop apps running on stable Linux distributions that have older app versions
    in their native package repository. AppImage can also be used to run old versions
    of software. The example presented later in this section will analyze a working
    AppImage of the NCSA Mosaic browser from the mid-1990s.
  prefs: []
  type: TYPE_NORMAL
- en: The AppImage format bundles all the needed binaries, libraries, and supporting
    files into a single executable file. Any user can download an AppImage file, give
    it execute permissions, and then run it. No further installation or root privileges
    are necessary. An AppImage binary embeds a squashfs filesystem where the directory
    structure of files is stored. When the binary is run, this squashfs filesystem
    is mounted (via FUSE), and execution is passed to an internal program called AppRun.
    AppImage binaries are not running in an isolated sandbox and have access to the
    rest of the filesystem. The user’s home directory may have configs, cache, and
    other files related to the AppImage program.
  prefs: []
  type: TYPE_NORMAL
- en: Every AppImage executable includes flags for file extraction, squashfs mounting,
    and more. The most interesting flag from a forensics perspective is `--appimage-offset`,
    which provides the byte offset of the embedded squashfs filesystem. This offset
    allows us to access the filesystem with the `unsquashfs` command to extract detailed
    information and files (including preserved timestamps). The problem with this
    flag is that we must execute the binary, which is a security risk (especially
    when analyzing suspicious or malicious files). To avoid this risk, the offset
    can be independently calculated using the `readelf` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `readelf` tool provides information about the executable header with the
    `-h` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The squashfs filesystem starts after the section headers. This offset is easily
    calculated from the section header lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The byte offset is calculated from the `Start` + (`Size` * `Number`) of the
    section headers, or in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This byte offset number (112888) can be used with `unsquashfs` to extract information
    and files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following `unsquashfs` example, the `-o` specifies the offset within
    the AppImage file, and the `-s` displays information about the filesystem (including
    a timestamp):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the offset and `-ll` flag (two lowercase Ls) for a more detailed
    file listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The entire filesystem tree can be extracted, or we can extract individual files.
    In this example, a single file is extracted (unsquashfs will create the *squashfs-root*
    directory if it doesn’t exist):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The byte offset can also be used to mount the embedded filesystem on your forensic
    analysis machine, where it can be browsed with other programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Because this is squashfs, it’s read-only, so there is no danger of accidentally
    modifying the mounted directory contents.
  prefs: []
  type: TYPE_NORMAL
- en: AppImage files can be found anywhere a user has write permission. Because they
    are normal ELF executables, they have the same magic string and other properties
    as other executables. The **.AppImage* filename extension might be the only indicator
    of the file type. The filesystem timestamps (`Birth` and `Modify`) of the AppImage
    file may indicate when the file was downloaded, and the timestamps inside squashfs
    indicate when the AppImage file was built.
  prefs: []
  type: TYPE_NORMAL
- en: '***Flatpak***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Flatpak (renamed from `xdg-app`) is designed for Linux distro-independent packaging
    and distribution of desktop apps. Flatpak uses repositories to transfer and update
    files using the *OSTree* system. OSTree is similar to Git, but it tracks binary
    files rather than source code. The apps are run in containers with explicit permissions
    to access local system resources.
  prefs: []
  type: TYPE_NORMAL
- en: Flatpak has several configuration files to examine. System-wide configuration
    in */etc/flatpak/* may contain config files (**.conf* ) that override defaults
    and also configure the repositories used in a system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The configuration file describes the repository, or repo, specifies the URL
    location, and stores the GPG public key used to verify signatures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system-wide directory is */var/lib/flatpak/*, which contains runtime data
    and further configuration. Configuration describing the basic behavior of repos
    can be found in the */var/lib/flatpak/repo/config* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Individual users can also install Flatpak repos, data, and configuration, which
    are fully contained in their local home directory (*~/.local/share/flatpak/*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Applications are installed into their own subdirectories and found in */var/lib/flatpak/app/**.
    Multiple versions may exist, and symlinks indicate the current or active version.
    The *current/active/metadata* file in the Flatpak application’s directory provides
    configuration data for running and setting up the sandbox environment; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here, the different permissions, policies, paths, and more can be defined. See
    the flatpak-metadata(5) man page for a description of this file format.
  prefs: []
  type: TYPE_NORMAL
- en: Flatpak explicitly records installations, updates, and uninstalls in the systemd
    journal, which can be viewed with the `flatpak history` command. See the flatpak-history(1)
    man page for more information about Flatpak logging.
  prefs: []
  type: TYPE_NORMAL
- en: 'The installing and uninstalling of Flatpaks is logged to the systemd journal,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, two log entries in the systemd journal show that the Flatpak for Sugar
    Labs’s Music Keyboard was installed and then uninstalled a few minutes later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The starting and stopping of Flatpak apps may also be logged in the journal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, two log entries show the application was started and run for a few minutes
    before being closed. This information is also stored in the systemd user journal
    and can be used in a forensic examination to reconstruct past application usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to have Flatpak package bundles. They are called single-file
    bundles, and they have a **.flatpak* file extension. Flatpak files start with
    a magic string of `flatpak` and contain the files needed to install:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This file format is taken from Docker’s Open Container Initiative (OCI). Using
    single-file bundles is less common than the developer-recommended use of repositories.
  prefs: []
  type: TYPE_NORMAL
- en: '***Snap***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Software developers at Canonical created a self-contained package format called
    Snap together with a central app store (*[https://snapcraft.io/](https://snapcraft.io/)*).
    Snap packages are designed to be distribution-independent, but Ubuntu is the only
    mainstream distro that uses them by default. In a forensic investigation of a
    system using snaps, we can determine which snaps are installed, when they were
    installed or updated, and information about the snap contents (files, configs,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Snap packages have a **.snap* extension, but they are regular squashfs compressed
    filesystems. They can be easily mounted and browsed for additional information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Once installed, these squashfs files are mounted under the */snap/* directory
    on a running system (not visible during a postmortem forensic examination). Information
    about the package is found in *meta/snap.yaml* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installed snaps can be found in the */var/lib/snapd/snaps/* directory, with
    a single file per application (and version), as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The example output here shows multiple versions of the Brave and Chromium browsers.
    The mounting is done using systemd mount unit files, which can be found in the
    */etc/systemd/system/* directory with a *snap-*.mount* filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'Snaps rely on the snapd daemon to manage basic housekeeping. Various snapd
    actions are logged in the journal (or syslog):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This journal output shows the snapd logs for the Subsurface snap package.^([15](footnotes.xhtml#ch07foot_015))
    The output indicates the installation date, refresh (update) checks, and mounting/unmounting
    activity (which also corresponds to system reboots).
  prefs: []
  type: TYPE_NORMAL
- en: See the snap(8) man page and *[https://snapcraft.io/](https://snapcraft.io/)*
    for more information about snap packages.
  prefs: []
  type: TYPE_NORMAL
- en: '***Software Centers and GUI Frontends***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Historically, package management has been highly distro specific. A collaborative
    effort between the major distributions began working toward a common solution
    to this problem. PackageKit was developed to unify package management across different
    distros. It provides an interface between generic frontend software management
    applications and backend (distro-specific) package management systems (apt, dnf,
    and so on). Universal package systems like Flatpak or Snap can also be managed
    through the same PackageKit applications. A specification for generic package
    metadata called AppStream was created for use across distributions and package
    management systems.
  prefs: []
  type: TYPE_NORMAL
- en: Installed applications can store an AppStream metadata XML file in the */usr/share/metainfo/*
    directory. This file contains information such as descriptions (including translations),
    license and version information, the project team’s homepage and contact person,
    the URL of screenshots displayed, and more. The screenshots are fetched from the
    URL specified by the project team when the user views the application in the software
    center. This web location and associated network traffic may be of interest in
    a forensic investigation. See *[https://www.freedesktop.org/software/appstream/docs/chap-Quickstart.html](https://www.freedesktop.org/software/appstream/docs/chap-Quickstart.html)*
    for more information about what is stored in the AppStream metadata.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration files for PackageKit are found in the */etc/PackageKit/* directory.
    An SQLite database of packages installed by PackageKit is stored in the file */var/lib/PackageKit/transactions.db*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This effort to harmonize package management resulted in the development of
    universal package managers called software centers that are easy-to-use graphical
    applications that run on any Linux distribution. The concept of software centers
    is analogous to the app store programs that are popular on mobile devices and
    other operating systems. The following list includes some examples of Linux software
    centers with their command line and graphical app names:'
  prefs: []
  type: TYPE_NORMAL
- en: '| gnome-software | (Software) for GNOME systems |'
  prefs: []
  type: TYPE_TB
- en: '| plasma-discover | (Discover) for KDE Plasma systems |'
  prefs: []
  type: TYPE_TB
- en: '| pamac-manager | (Pamac) for Arch Linux systems |'
  prefs: []
  type: TYPE_TB
- en: '| mintinstall | (Software Manager) for Linux Mint systems |'
  prefs: []
  type: TYPE_TB
- en: '| pi-packages | (PiPackages) for Raspberry Pi systems |'
  prefs: []
  type: TYPE_TB
- en: These tools all have a similar look and feel (see [Figure 7-2](ch07.xhtml#ch07fig02)
    for an example).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch07fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: GNOME Software*'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to generic frontends using PackageKit and AppStream, many distributions
    have graphical frontend tools that interface directly with their local package
    management system. Examples include Debian’s Synaptic or SUSE’s YaST.
  prefs: []
  type: TYPE_NORMAL
- en: In the background, these graphical tools are typically running low-level tools
    (like apt or dnf) or calling libraries (like libalpm or libdnf). For a forensic
    examination, the package management activity should be seen in the logs and local
    package databases as discussed earlier in this chapter. Individual tools may have
    their own logs (for example, they may have a daemon logging to a file or to syslog).
    Persistent or cache data may also reside in the user’s *~/.cache/* or *~/.local/*
    directories. Configuration information will usually be in */etc/* (for system-wide
    defaults) and in *~/.config/* (for user-customized settings).
  prefs: []
  type: TYPE_NORMAL
- en: '**Other Software Installation Analysis**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Several other methods exist for adding software either manually or as plug-ins
    to existing software packages. These examples completely bypass the software package
    management done by the Linux distribution. However, they may still leave traces
    of information useful in a forensic context.
  prefs: []
  type: TYPE_NORMAL
- en: '***Manually Compiled and Installed Software***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'GNU software packages can be compiled and installed manually, bypassing any
    package management systems (leaving no traces in the package management logs or
    databases). The GNU Coding Standards documentation can be found at *[https://www.gnu.org/prep/standards/](https://www.gnu.org/prep/standards/)*.
    The typical process involves finding the source software package online (usually
    a compressed tar file), downloading it to a working directory, unpacking, and
    running `configure` and `make` scripts. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The install directory can be specified and non-privileged users may install
    software in their home directory (like *~/.local/bin/*, for example). Typically,
    the download site will include a separate file containing a cryptographic hash
    of the compressed archive file so it can be verified.
  prefs: []
  type: TYPE_NORMAL
- en: Manual downloads may also involve synchronizing (or cloning) with a software
    development repository like Git. A manual installation may also involve simply
    copying stand-alone scripts and binaries to a location in the executable path.
    With manual installs, there is no package management or tracking with install
    timestamps. The filesystem timestamps are the best indicator of when a file was
    installed (in particular, matching timestamps of files in the compile directory
    with timestamps of the installed files). The manual removal of software may involve
    a `make uninstall` command or script. If source code directories are found, it
    is worth examining the Makefiles to understand what was modified on the filesystem
    during the install (and uninstall) process. The shell history can also be examined
    for evidence of manual downloading, compiling, and installing of software packages.
  prefs: []
  type: TYPE_NORMAL
- en: '***Programming Language Packages***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some programming languages, especially interpreted languages, have their own
    package manager for adding additional code modules and libraries that provide
    extended functionality. These packages may use the distribution’s package management
    system or bypass it completely. This section describes a few examples of software
    packages that were installed directly using the programming language’s package
    management system.
  prefs: []
  type: TYPE_NORMAL
- en: The Python programming language has several package managers, the most popular
    being `pip`, the Python Package Installer. The `pip` tool is used to fetch, install,
    and manage Python packages. If a non-privileged user installs a package, it will
    be written to their home directory in *~/.local/lib/python*/ site-packages/*.
    If it is a site installation (intended for all users) it is installed in */usr/lib/python*/site-packages/*.
    Files or directories with the extension *.egg-info* contain the package metadata.
  prefs: []
  type: TYPE_NORMAL
- en: The Perl programming language has CPAN, the Comprehensive Perl Archive Network.
    The `cpan` command is used to fetch, install, and manage Perl modules. The user’s
    installed modules are found in *~/.cpan*.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is Ruby Gems (*[https://rubygems.org/](https://rubygems.org/)*),
    which downloads Ruby code from a central repository and stores it in a user’s
    home directory or to a site-wide location.
  prefs: []
  type: TYPE_NORMAL
- en: During a forensic examination, every user’s home directory should be analyzed
    to determine whether they were programmers and under which programming languages
    they developed. The programming languages may have a module or library package
    management system that was used.
  prefs: []
  type: TYPE_NORMAL
- en: '***Application Plug-ins***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Application plug-ins are mentioned only briefly here, as the analysis is outside
    the scope of this book. Many large applications are extensible with themes, plug-ins,
    add-ons, or extensions, which are installed from within the app. This is typical
    of web browsers, file managers, office suites, window environments, and other
    programs. Plug-ins are not only used by big graphical programs, but also smaller
    utilities (for example, vim or neovim).
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, these plug-ins are available from the distro’s package repository
    and are installed in standard locations that are available to other users. In
    other cases, a user may install plug-ins for their own use. In the latter case,
    the plug-ins are usually stored in the user’s home directory (in a hidden dot
    “.” directory together with other files associated with the application). If the
    application has a log or history of activity, a timestamp of installation might
    be found; otherwise, the filesystem timestamps are the best indicator of when
    the installation happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I’ve described how to examine the installed software on a Linux
    system. You now should be able to identify the installed distro and version numbers,
    and reconstruct the initial installation process. You also should be able to determine
    which additional software packages are installed and how to analyze the details
    of those packages.
  prefs: []
  type: TYPE_NORMAL
