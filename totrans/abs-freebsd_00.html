<html><head></head><body>
<h2 class="h2" id="intro"><span epub:type="pagebreak" id="page_xxxiii"/>INTRODUCTION</h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">Welcome to <em>Absolute FreeBSD</em>! This book is a one-stop shop for system administrators who want to build, configure, and manage FreeBSD servers. It will also be useful for those folks who want to run FreeBSD on their desktops, embedded devices, server farms, and so on. By the time you finish this book, you should be able to use FreeBSD to provide network services. You should also understand how to manage, patch, and maintain your FreeBSD systems and have a basic understanding of networking, system security, and software management. We’ll discuss FreeBSD versions 11 and 12, which are the most recent versions at the time this book is being released; however, most of this book applies to earlier and later versions as well.</p>
<h3 class="h3" id="lev1"><span epub:type="pagebreak" id="page_xxxiv"/><strong>What Is FreeBSD?</strong></h3>
<p class="noindent"><em>FreeBSD</em> is a freely available Unix-like operating system popular with internet service providers, in appliances and embedded systems, and anywhere that reliability on commodity hardware is paramount. One day last week, FreeBSD miraculously appeared on the internet, fully formed, extruded directly from the mutant brain of its heroic creator’s lofty intellect. Just kidding—the truth is far more impressive. FreeBSD is a result of almost four decades of continuous development, research, and refinement. The story of FreeBSD begins in 1979, with BSD.</p>
<h4 class="h4" id="lev2"><strong><em>BSD: FreeBSD’s Granddaddy</em></strong></h4>
<p class="noindent">Many years ago, AT&amp;T needed a lot of specialized, custom-written computer software to run its business. It wasn’t allowed to compete in the computer industry, however, so it couldn’t sell its software. Instead, AT&amp;T licensed various pieces of software and the source code for that software to universities at low, low prices. The universities could save money by using this software instead of commercial equivalents with pricey licenses, and university students with access to this nifty technology could read the source code to see how everything worked. In return, AT&amp;T got exposure, some pocket change, and a generation of computer scientists who had cut their teeth on AT&amp;T technology. Everyone got something out of the deal. The best-known software distributed under this licensing plan was Unix.</p>
<p class="indent">Compared with modern operating systems, the original Unix had a lot of problems. Thousands of students had access to its source code, however, and hundreds of teachers needed interesting projects for their students. If a program behaved oddly, or if the operating system itself had a problem, the people who lived with the system on a day-to-day basis had the tools and the motivation to fix it. Their efforts quickly improved Unix and created many features we now take for granted. Students added the ability to control running processes, also known as <em>job control</em>. The Unix S51K filesystem made system administrators bawl like exhausted toddlers, so they replaced it with the Fast File System (FFS), whose features have spread into every modern filesystem. Many small, useful programs were written over the years, gradually replacing entire swaths of Unix.</p>
<p class="indent">The Computer Systems Research Group (CSRG) at the University of California, Berkeley, participated in these improvements and also acted as a central clearinghouse for Unix code improvements. CSRG collected changes from other universities, evaluated them, packaged them, and distributed the compilation for free to anyone with a valid AT&amp;T UNIX license. The CSRG also contracted with the Defense Advanced Research Projects Agency (DARPA) to implement various features in Unix, such as TCP/IP. The resulting collection of software came to be known as the <em>Berkeley Software Distribution</em>, or <em>BSD</em>.</p>
<p class="indent">BSD users took the software, improved it further, and then fed their enhancements back into BSD. Today, we consider this to be a fairly standard <span epub:type="pagebreak" id="page_xxxv"/>way for an open source project to run, but in 1979 it was revolutionary. BSD was also quite successful; if you check the copyright statement on an old BSD system, you’ll see this:</p>
<pre>Copyright 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994<br/>        The Regents of the University of California. All rights reserved.</pre>
<p class="indent">Yep, 15 years of work—a lifetime in software development. How many other pieces of software are not only still in use, but still in active development, 15 years after work began? In fact, so many enhancements and improvements went into BSD that the CSRG found that over the years, it had replaced almost all of the original Unix with code created by the CSRG and its contributors. You had to look hard to find any original AT&amp;T code.</p>
<p class="indent">Eventually, the CSRG’s funding ebbed, and it became clear that the BSD project would end. After some political wrangling within the University of California, in 1992 the BSD code was released to the general public under what became known as the <em>BSD license</em>.</p>
<h4 class="h4" id="lev3"><strong><em>The BSD License</em></strong></h4>
<p class="noindent">BSD code is available for anyone to use under what is probably the most liberal license in the history of software development. The license can be summarized as follows:</p>
<ul>
<li class="noindent">Don’t claim you wrote this.</li>
<li class="noindent">Don’t blame us if it breaks.</li>
<li class="noindent">Don’t use our name to promote your product.</li>
</ul>
<p class="indent">This means that you can do almost anything you want with BSD code. (The original BSD license did require that users be notified if a software product included BSD-licensed code, but that requirement was later dropped.) There’s not even a requirement that you share your changes with the original authors! People were free to take BSD and include it in proprietary products, open source products, or free products—they could even print it out on punch cards and cover the lawn with it. You want to run off 10,000 BSD CDs and distribute them to your friends? Enjoy. Instead of <em>copyright</em>, the BSD license is sometimes referred to as <em>copycenter</em>, as in <em>Take this down to the copy center and run off a few for yourself</em>. Not surprisingly, companies such as Sun Microsystems jumped right on it: it was free, it worked, and plenty of new graduates had experience with the technology—including Bill Joy, one of Sun’s founders. One company, BSDi, was formed specifically to take advantage of BSD Unix.</p>
<h4 class="h4" id="lev4"><strong><em>The AT&amp;T/CSRG/BSDi Iron Cage Match</em></strong></h4>
<p class="noindent">At AT&amp;T, UNIX work continued apace even as the CSRG went on its merry way. AT&amp;T took parts of the BSD Unix distribution, integrated them with its UNIX, and then relicensed the result back to the universities that provided those improvements. This worked well for AT&amp;T until the company <span epub:type="pagebreak" id="page_xxxvi"/>was broken up and the resulting companies were permitted to compete in the computer software business. AT&amp;T had one particularly valuable property: a high-end operating system that had been extensively debugged by thousands of people. This operating system had many useful features, such as a variety of small but powerful commands, a modern filesystem, job control, and TCP/IP. AT&amp;T started a subsidiary, Unix Systems Laboratories (USL), which happily started selling Unix to enterprises and charging very high fees for it, all the while maintaining the university relationship that had given it such an advanced operating system in the first place.</p>
<p class="indent">Berkeley’s public release of the BSD code in 1992 was met with great displeasure from USL. Almost immediately, USL sued the university and the software companies that had taken advantage of the software, particularly BSDi. The University of California claimed that the CSRG had compiled BSD from thousands of third-party contributors unrelated to AT&amp;T, and so it was the CSRG’s intellectual property to dispose of as it saw fit.</p>
<p class="indent">This lawsuit motivated many people to grab a copy of BSD to see what all the fuss was about, while others started building products on top of it. One of these products was 386BSD, which would eventually be used as the core of FreeBSD 1.0.</p>
<p class="indent">In 1994, after two years of legal wrangling, the University of California lawyers proved that the majority of AT&amp;T UNIX was actually taken in its entirety from BSD, rather than the other way around. To add insult to injury, AT&amp;T had actually violated the BSD license by stripping the CSRG copyright from files it had assimilated. (Only a very special company can violate the world’s most generous software license!) A half-dozen files were the only sources of contention, and to resolve these outstanding issues, USL donated some of them to BSD while retaining some as proprietary information.</p>
<p class="indent">Once the dust settled, a new version of BSD Unix was released to the world as BSD 4.4-Lite. A subsequent update, BSD 4.4-Lite2, is the grandfather of the current FreeBSD, as well as ancestor to every other BSD variant in use today.</p>
<h4 class="h4" id="lev5"><strong><em>The Birth of FreeBSD</em></strong></h4>
<p class="noindent">One early result of BSD was 386BSD, a version of BSD designed to run on the cheap 386 processor.<sup><a href="footnote.xhtml#introfn1" id="introfn1a">1</a></sup> The 386BSD project successfully ported BSD to Intel’s 386 processor, but it stalled. After a period of neglect, a group of 386BSD users decided to branch out on their own and create FreeBSD so they could keep the operating system up to date. (Several other groups started their own branches off of 386BSD around the same time, of which only NetBSD remains.)</p>
<p class="indent">386BSD and FreeBSD 1 were derived from 1992’s BSD release, the subject of AT&amp;T’s wrath. As a result of the lawsuit, all users of the original BSD were requested to base any further work on BSD 4.4-Lite2. BSD 4.4-Lite2 was not a complete operating system—in particular, those few files AT&amp;T <span epub:type="pagebreak" id="page_xxxvii"/>had retained as proprietary were vital to the system’s function. (After all, if those files hadn’t been vital, AT&amp;T wouldn’t have bothered!) The FreeBSD development team worked frantically to replace those missing files, and FreeBSD 2.0 was released shortly afterward. Development has continued ever since.</p>
<p class="indent">Today, FreeBSD is used across the internet by some of the most vital and visible internet-oriented companies. Netflix’s content delivery system runs entirely on FreeBSD. IBM, Dell/EMC, Juniper, NetApp, Sony and many other hardware companies use FreeBSD in embedded systems where you’d never even know it unless someone told you. The fact is, if a company needs to pump serious internet bandwidth, it’s probably running FreeBSD or one of its BSD relatives.</p>
<p class="indent">FreeBSD also finds its way into all sorts of embedded and dedicated-purpose devices. Do you have a PlayStation 4? Congratulations, you’re running FreeBSD. I hear a root shell is hard to get on one of them, though.</p>
<p class="indent">Like smog, spiders, and corn syrup, FreeBSD is all around you; you simply don’t see it because FreeBSD just works. The key to FreeBSD’s reliability is the development team and user community—which are really the same thing.</p>
<h3 class="h3" id="lev6"><strong>FreeBSD Development</strong></h3>
<p class="noindent">There’s an old saying that managing programmers is like herding cats. Despite the fact that the FreeBSD development team is scattered across the world and speaks dozens of languages, for the most part, the members work well together as parts of the FreeBSD community. They’re more like a pride of lions than a collection of house cats. Unlike some other projects, all FreeBSD development happens in public. Three groups of people are responsible for FreeBSD’s progress: committers, contributors, and users.</p>
<h4 class="h4" id="lev7"><strong><em>Committers</em></strong></h4>
<p class="noindent">FreeBSD has about 500 developers, or committers. <em>Committers</em> have read-and-write access to the FreeBSD master source code repository and can develop, debug, or enhance any piece of the system. (The term <em>committer</em> comes from their ability to <em>commit</em> changes to the source code.) Because these commits can break the operating system in both subtle and obvious ways, committers carry a heavy responsibility. Committers are responsible for keeping FreeBSD working or, at worst, not breaking it as they add new features and evaluate patches from contributors. Most of these developers are volunteers; only a handful are actually paid to do this painstaking work, and most of those people are paid only as it relates to other work. For example, Intel employs committers to ensure that FreeBSD properly supports its network cards. FreeBSD has a high profile in the internet’s heavy-lifting crowd, so Intel needs its cards to work on FreeBSD.</p>
<p class="indent">To plug yourself into the beehive of FreeBSD development, consider subscribing to the mailing list <em><a href="mailto:FreeBSD-hackers@FreeBSD.org">FreeBSD-hackers@FreeBSD.org</a></em>, which contains <span epub:type="pagebreak" id="page_xxxviii"/>most of the technical discussion. Some of the technical talk is broken out into more specific mailing lists—for example, fine details of the networking implementation are discussed in <em><a href="mailto:FreeBSD-net@FreeBSD.org">FreeBSD-net@FreeBSD.org</a></em>.</p>
<p class="indent">Every few years, the committer team elects a small number of its members to serve as a core team, or <em>Core</em>. Core’s work is simultaneously vital, underrated, and misunderstood. Core is theoretically responsible for the overall management of FreeBSD, but in practice, it manages little other than resolving personality disputes and procedural conflicts among committers. Core also approves new committers and delegates responsibility for large parts of FreeBSD to individuals or groups. For example, it delegates authority over the ports and packages system to the ports management team. Core does not set architectural direction for FreeBSD, nor does it dictate processes or procedures; that’s up to the committers, who must agree en masse. Core does suggest, cajole, mediate, and inspire, however.</p>
<p class="indent">Core also experiences the worst part of management. Some of the key functions of management in a company are oversight, motivation, and handling problems between people. Oversight is provided by the millions of users who will complain loudly when anything breaks or behaves unexpectedly, and FreeBSD committers are self-motivated. The ugly part of management is settling squabbles between two people, and that’s the part Core gets stuck with. The status one gets from saying “I’m in Core” is an insufficient reward for having to manage the occasional argument between two talented developers who’ve gotten on each other’s nerves. Fortunately such disagreements are rare and usually resolved quickly.</p>
<h4 class="h4" id="lev8"><strong><em>Contributors</em></strong></h4>
<p class="noindent">In addition to the committer team, FreeBSD has thousands of contributors. <em>Contributors</em> don’t have to worry about breaking the main operating system source code repository; they submit their patches for consideration by committers. Committers evaluate contributor submissions and decide what to accept and what to reject. A contributor who submits many high-quality patches is often asked to become a committer themselves.</p>
<p class="indent">For example, I spent several years contributing to FreeBSD whenever the urge struck me. Any time I feel that I’ve wasted my life, I can look at the FreeBSD website and see where my work was accepted by the committers and distributed to thousands of people. After I submitted the first edition of this book to the publisher, I spent my spare time submitting patches to the FreeBSD FAQ. Eventually, some members of the FreeBSD Documentation Project approached me and asked me to become a committer. As a reward, I got an email address and the opportunity to humiliate myself before thousands of people, once again demonstrating that no good deed goes unpunished.</p>
<p class="indent">If I had never contributed anything, I’d remain a user. Nothing’s wrong with that, either.</p>
<h4 class="h4" id="lev9"><span epub:type="pagebreak" id="page_xxxix"/><strong><em>Users</em></strong></h4>
<p class="noindent"><em>Users</em> are the people who run FreeBSD systems. It’s impossible to realistically estimate the number of FreeBSD users. While organizations such as the BSDstats Project (<em><a href="http://www.bsdstats.org/">http://www.bsdstats.org/</a></em>) make an effort, these projects are opt-in. They measure only folks who have installed FreeBSD and then installed the software that adds their system to the count. Most users download the whole of FreeBSD for free and never register, upgrade, or email a mailing list. We have no idea how many FreeBSD users are in the world.</p>
<p class="indent">Since FreeBSD is by far the most popular open source BSD, that’s not an inconsiderable number of machines. And since one FreeBSD server can handle hundreds of thousands of internet domains, a disproportionate number of sites use FreeBSD as their supporting operating system. This means that there are hundreds of thousands, if not millions, of FreeBSD system administrators out in the world today.</p>
<h3 class="h3" id="lev10"><strong>Other BSDs</strong></h3>
<p class="noindent">FreeBSD might be the most popular BSD, but it’s not the only one. BSD 4.4-Lite2 spawned several different projects, each with its own focus and purpose. Those projects in turn had their own offspring, several of which thrive today.</p>
<h4 class="h4" id="lev11"><strong><em>NetBSD</em></strong></h4>
<p class="noindent">NetBSD is similar to FreeBSD in many ways, and NetBSD and FreeBSD share developers and code. NetBSD’s main goal is to provide a secure and reliable operating system that can be ported to any hardware platform with minimal effort. As such, NetBSD runs on Vixens, PocketPC devices, and high-end SPARC and Alpha servers. I ran NetBSD on my HP Jornada handheld computer.<sup><a href="footnote.xhtml#introfn2" id="introfn2a">2</a></sup></p>
<h4 class="h4" id="lev12"><strong><em>OpenBSD</em></strong></h4>
<p class="noindent">OpenBSD branched off from NetBSD in 1996 with the goal of becoming the most secure BSD. OpenBSD was the first to support hardware-accelerated cryptography, and its developers are rightfully proud of the fact that their default installation was largely immune to remote exploits for several years. The OpenBSD team has contributed several valuable pieces of software to the world, including the LibreSSL TLS library and the OpenSSH suite used by almost everyone from Linux to Microsoft.</p>
<h4 class="h4" id="lev13"><strong><em>DragonFly BSD</em></strong></h4>
<p class="noindent">DragonFly BSD forked from FreeBSD 4 in 2003. It developed in a different direction than FreeBSD, with a new kernel messaging system. <span epub:type="pagebreak" id="page_xl"/>DragonFly BSD has very high performance and its HAMMER filesystem supports snapshots and fine-grained history. Check out <em><a href="http://www.dragonflybsd.org/">http://www.dragonflybsd.org/</a></em> for more information.</p>
<h4 class="h4" id="lev14"><strong><em>macOS</em></strong></h4>
<p class="noindent">Apple’s macOS? That’s right. Apple incorporates large chunks of FreeBSD into its macOS on an ongoing basis. If you’re looking for a stable operating system with a friendly face and a powerful core, macOS is unquestionably for you. While FreeBSD makes an excellent desktop for a computer professional, I wouldn’t put it in front of a random user. I would put macOS in front of that same random user without a second thought, however, and I’d even feel that I was doing the right thing. But macOS includes many things that aren’t at all necessary for an internet server, and it runs only on Apple hardware, so I don’t recommend it as an inexpensive general-purpose server.</p>
<h4 class="h4" id="lev15"><strong><em>FreeBSD’s Children</em></strong></h4>
<p class="noindent">Several projects have taken FreeBSD and built other projects or products on top of it. The award-winning FreeNAS transforms a commodity system into a network fileserver. The pfSense project transforms your system into a firewall with a nice web management interface. TrueOS gives FreeBSD a friendly face while supporting resource-intensive advanced features, like ZFS, while GhostBSD puts a friendly face on equipment with less computing oomph. Other projects like this appear from time to time; while not all are successful, I’m sure by the time this book comes out, we’ll have one or two more solid members of this group.</p>
<h3 class="h3" id="lev16"><strong>Other Unixes</strong></h3>
<p class="noindent">Several other operating systems derive from or emulate primordial Unix in one way or another. This list is by no means exhaustive, but I’ll touch on the high points.</p>
<h4 class="h4" id="lev17"><strong><em>Solaris</em></strong></h4>
<p class="noindent">The best-known Unix might be Oracle Solaris. Solaris runs on high-end hardware that supports dozens of processors and gobs of disk. (Yes, <em>gobs</em> is a technical term, meaning <em>more than you could possibly ever need, and I know very well that you need more disk than I think you need</em>.) Solaris, especially early versions of Solaris, had strong BSD roots. Many enterprise-level applications run on Solaris. Solaris runs mainly on the SPARC hardware platform manufactured by Sun, which allows Sun to support interesting features, such as hot-swappable memory and mainboards.</p>
<p class="indent">The Oracle Corporation acquired Solaris when they bought Sun Microsystems in 2009. Oracle ceased Solaris development in 2016. While there’s still an extensive installed base of Solaris systems and you can still get Solaris from Oracle, as of today, Oracle Solaris has no future.</p>
<h4 class="h4" id="lev18"><span epub:type="pagebreak" id="page_xli"/><strong><em>illumos</em></strong></h4>
<p class="noindent">Several years before Oracle purchased Sun Microsystems, Sun open sourced the majority of Solaris and sponsored the OpenSolaris project to improve that codebase. OpenSolaris ran successfully until Oracle shut down source access and reclaimed all of the OpenSolaris resources.</p>
<p class="indent">The OpenSolaris code was still available, though. The OpenSolaris community forked OpenSolaris into illumos (<em><a href="http://illumos.org/">http://illumos.org/</a></em>). If you miss Solaris, you can still use a free, modern, Solaris-like operating system. FreeBSD includes two important features from OpenSolaris, the Zetabyte Filesystem (ZFS) and DTrace, a full-system tracing system.</p>
<h4 class="h4" id="lev19"><strong><em>AIX</em></strong></h4>
<p class="noindent">Another Unix contender is IBM’s entry, AIX. AIX’s main claim to fame is its journaling filesystem, which records all disk transactions as they happen and allows for fast recovery from a crash. It was also IBM’s standard Unix for many years, and anything backed by Big Blue shows up all over the place. AIX started life based on BSD, but AT&amp;T has twiddled just about everything so that you won’t find much BSD today.</p>
<h4 class="h4" id="lev20"><strong><em>Linux</em></strong></h4>
<p class="noindent">Linux is a close cousin of Unix, written from the ground up. Linux is similar to FreeBSD in many ways, though FreeBSD has a much longer heritage and is friendlier to commercial use than Linux. Linux includes a requirement that any user who distributes Linux must make his or her changes available to the end user, while BSD has no such restriction. Of course, a Linux fan would say, “FreeBSD is more vulnerable to commercial exploitation than Linux.” Linux developers believe in share-and-share-alike, while BSD developers offer a no-strings-attached gift to everyone. It all depends on what’s important to you.</p>
<p class="indent">Many new Unix users have a perception of conflict between the BSD and Linux camps. If you dig a little deeper, however, you’ll find that most of the developers of these operating systems communicate and cooperate in a friendly and open manner. It’s just a hard fringe of users and developers that generate friction, much like different soccer teams’ hooligans or different <em>Star Trek</em> series’ fans.<sup><a href="footnote.xhtml#introfn3" id="introfn3a">3</a></sup></p>
<h4 class="h4" id="lev21"><strong><em>Other Unixes</em></strong></h4>
<p class="noindent">Many Unixes have come and gone, while others stagger on. Past contenders include Silicon Graphics’ IRIX, Hewlett-Packard’s HP/UX, Tru64 Unix, and the suicidal SCO Group’s UnixWare. Dig further and you’ll find older castoffs, including Apple’s A/UX and Microsoft’s Xenix. (Yes, Microsoft was a licensed Unix vendor, back in that age when dinosaurs watched the skies nervously and my dad hunted mammoth for all the tribal rituals.) Many <span epub:type="pagebreak" id="page_xlii"/>high-end applications are designed to run best on one particular flavor of Unix. All modern Unixes have learned lessons from these older operating systems, and today’s Unixes and Unix-like operating systems are remarkably similar.</p>
<div class="sidebar">
<p class="sidebart"><strong>WHY UNIX-LIKE?</strong></p>
<p class="spara">One thing to note is that FreeBSD, Linux, and so on are called <em>Unix-like</em> instead of <em>Unix</em>. The term <em>Unix</em> is a trademark of The Open Group. For an operating system to receive the right to call itself Unix, the vendor must prove that the OS complies with the current version of the Single Unix Specification. While FreeBSD generally meets the standard, continuous testing and recertification cost money, which the FreeBSD Project doesn’t have to spare. Certification as Unix also requires that someone sign a paper stating not only that he or she is responsible for FreeBSD’s conformance to the Single Unix Specification but that he or she will fix any deviations from the standard that are found in the future. FreeBSD’s development model makes this even more difficult—bugs are found and deviations are fixed, but there’s nobody who can sign a piece of paper that guarantees 100 percent standards compliance.</p>
</div>
<h3 class="h3" id="lev22"><strong>FreeBSD’s Strengths</strong></h3>
<p class="noindent">After all this, what makes FreeBSD unique?</p>
<h4 class="h4" id="lev23"><strong><em>Portability</em></strong></h4>
<p class="noindent">The FreeBSD Project’s goal is to provide a freely redistributable, stable, and secure operating system that runs on the computer hardware that people are most likely to have access to. People have ported FreeBSD to a variety of less popular platforms as well.</p>
<p class="indent">The best supported FreeBSD platform is the common 64-bit hardware developed by AMD, used by almost everyone, and even copied by Intel. FreeBSD also fully supports the older 32-bit computers, such as 486s and all the flavors of Pentiums. This book uses 64-bit commodity hardware, or <em>amd64</em>, as a reference platform.</p>
<p class="indent">FreeBSD runs well on several other hardware architectures but is not completely supported yet. These include 32-bit ARM processors and PowerPC. While these other platforms are not afterthoughts, they don’t receive the same level of attention that x86 and amd64 do. The 64-bit ARM platform is expected to become Tier 1 shortly after this book comes out, however.</p>
<p class="indent">You can also load FreeBSD on certain older architectures, such as 64-bit SPARC. These platforms were once well supported but are on their way out.</p>
<h4 class="h4" id="lev24"><span epub:type="pagebreak" id="page_xliii"/><strong><em>Power</em></strong></h4>
<p class="noindent">Since FreeBSD runs adequately on 486 processors, it runs extremely well on modern computers. It’s rather nice to have an operating system that doesn’t demand 8 cores and 12 gigs of RAM just to run the user interface. As a result, you can actually dedicate your hardware to accomplishing real work rather than tasks you don’t care about. If you choose to run a pretty graphical interface with all sorts of spinning gewgaws and fancy whistles, FreeBSD will support you, and it won’t penalize you if you choose otherwise. FreeBSD will also support you on the latest <em>n</em> -CPU hardware.</p>
<h4 class="h4" id="lev25"><strong><em>Simplified Software Management</em></strong></h4>
<p class="noindent">FreeBSD also simplifies software management through the packaging system and the Ports Collection. Traditionally, running software on a Unix-like system required a great deal of expertise. Packages and ports simplify this considerably by automating and documenting the install, uninstall, and configuration processes for thousands of software packages.</p>
<p class="indent">We discuss packages in <a href="ch15.xhtml#ch15">Chapter 15</a> and ports in <a href="ch16.xhtml#ch16">Chapter 16</a>.</p>
<h4 class="h4" id="lev26"><strong><em>Customizable Builds</em></strong></h4>
<p class="noindent">FreeBSD provides a painless upgrade procedure, but it also lets you precisely customize the operating system for your hardware. Companies like Apple do exactly this, but they control both the hardware and the software; FreeBSD pulls off the same trick on commodity hardware.</p>
<h4 class="h4" id="lev27"><strong><em>Advanced Filesystems</em></strong></h4>
<p class="noindent">A <em>filesystem</em> is how information is stored on the physical disk—it’s what maps the file <em>My Resume</em> to a series of zeros and ones on a hard drive. FreeBSD includes two well-supported filesystems, UFS (<a href="ch11.xhtml#ch11">Chapter 11</a>) and ZFS (<a href="ch12.xhtml#ch12">Chapter 12</a>). UFS has been around for multiple decades and is highly damage-resistant. ZFS is younger but includes features such as network replication and self-healing.</p>
<h3 class="h3" id="lev28"><strong>Who Should Use FreeBSD?</strong></h3>
<p class="noindent">While FreeBSD can be used as a powerful desktop or development machine, its history shows a strong bias toward network services: web, mail, file, and ancillary applications. FreeBSD is most famous for its strengths as an internet server, and it’s an excellent choice as an underlying platform for any network service. If major firms such as Netflix count on FreeBSD to provide reliable service, it will work as well for you.</p>
<p class="indent">If you’re thinking of running FreeBSD (or any Unix) on your desktop, you’ll need to understand how your computer works. FreeBSD is not your best choice if you need point-and-click simplicity. If that’s your goal, get <span epub:type="pagebreak" id="page_xliv"/>a Mac so you can use the power of Unix when you need it and not worry about it the rest of the time. If you want to learn FreeBSD, though, running it on your desktop is the best way—as we’ll discuss later.</p>
<h3 class="h3" id="lev29"><strong>Who Should Run Another BSD?</strong></h3>
<p class="noindent">NetBSD and OpenBSD are FreeBSD’s closest competitors. Unlike competitors in the commercial world, this competition is mostly friendly. FreeBSD, NetBSD, and OpenBSD freely share code and developers; some people even maintain the same subsystems in multiple operating systems.</p>
<p class="indent">If you want to use old or oddball hardware, NetBSD is a good choice for you. For several years, I ran NetBSD on an ancient SGI workstation that I used as a Domain Name System (DNS) and fileserver. It did the job well until the hardware finally released a cloud of smoke and stopped working.</p>
<p class="indent">OpenBSD has implemented an impressive variety of security features. Some of the tools are eventually integrated into FreeBSD, but that takes months or years. Some of the tools can never be duplicated in FreeBSD, however. If you have real security concerns and can use a Unix-like system without the feature set FreeBSD provides, consider OpenBSD. Take a look at my book <em>Absolute OpenBSD</em> (No Starch Press, 2013) for an introduction.</p>
<p class="indent">If you’re just experimenting to see what’s out there, any BSD is good!</p>
<h3 class="h3" id="lev30"><strong>Who Should Run a Proprietary Operating System?</strong></h3>
<p class="noindent">Operating systems such as macOS, Windows, AIX, and their ilk are still quite popular, despite the open source operating systems gnawing at their market share. High-end enterprises are pretty tightly shackled to commercial operating systems. While this is slowly changing, you’re probably stuck with commercial operating systems in such environments. But slipping in an occasional FreeBSD machine to handle basic services, such as monitoring and department file serving, can make your life much easier at much lower cost. Companies like Dell/EMC/Isilon have built entire businesses using FreeBSD instead of commercial operating systems.</p>
<p class="indent">Of course, if the software you need runs only on a proprietary operating system, your choice is pretty clear. Still, always ask a vendor whether a FreeBSD version is available; you might be pleasantly surprised.</p>
<h3 class="h3" id="lev31"><strong>How to Read This Book</strong></h3>
<p class="noindent">Many computer books are thick and heavy enough to stun an ox, if you have the strength to lift them high enough. Plus, they’re either encyclopedic in scope or so painfully detailed that they’re difficult to actually read. Do you really need to reference a screenshot when you’re told to click OK or accept the license agreement? And when was the last time you actually sat down to read the encyclopedia?</p>
<p class="indent"><span epub:type="pagebreak" id="page_xlv"/><em>Absolute FreeBSD</em> is a little different. It’s designed to be read once, from front to back. You can skip around if you want to, but each chapter builds on what comes before it. While this isn’t a small book, it’s smaller than many popular computer books. After you’ve read it once, it makes a decent reference.</p>
<p class="indent">If you’re a frequent buyer of computer books, please feel free to insert all that usual crud about “read a chapter at a time for best learning” and so on. I’m not going to coddle you—if you picked up this book, you either have two brain cells to rub together or you’re visiting someone who does. (If it’s the latter, hopefully your host is smart enough to take this book away from you before you learn enough to become dangerous.)</p>
<h3 class="h3" id="lev32"><strong>What Must You Know?</strong></h3>
<p class="noindent">This book is aimed at the new Unix administrator. Three decades ago, the average Unix administrator had kernel programming experience and was working on their master’s degree in computer science. Even a decade ago, they were already a skilled Unix user with real programming skills and most of a bachelor’s degree in comp sci. Today, Unix-like operating systems are freely available, computers are cheaper than food, and even 12-year-old children can run Unix, read the source code, and learn enough to intimidate older folks. As such, I don’t expect you to know a huge amount about Unix before firing it up.</p>
<p class="indent">To use this book to its full potential, you need to have familiarity with some basic tasks, such as how to change directories, list files in a directory, and log in with a username and password. If you’re not familiar with basic commands and the Unix shell, I recommend you begin with a book like <em>UNIX System Administration Handbook</em> by Evi Nemeth and friends (Prentice Hall PTR, 2017). To make things easier on newer system administrators, I include the exact commands needed to produce the desired results. If you learn best by example, you should have everything you need right here.</p>
<p class="indent">You’ll also need to know something about computer hardware—not a huge amount, mind you, but something. It helps to know how to recognize a SATA cable. Your need for this knowledge depends on the hardware you’re using, but if you’re interested enough to pick up this book and read this far, you probably know enough.</p>
<h3 class="h3" id="lev33"><strong>For the New System Administrator</strong></h3>
<p class="noindent">If you’re new to Unix, the best way to learn is to eat your own dog food. No, I’m not suggesting that you dine with Rover. If you ran a dog food company, you’d want to make a product that your own dog eats happily. If your dog turns his nose up at your latest recipe, you have a problem. The point here is that if you work with a tool or create something, you should actually use it. The same thing applies to any Unix-like operating system, including FreeBSD.</p>
<h4 class="h4" id="lev34"><span epub:type="pagebreak" id="page_xlvi"/><strong><em>Desktop FreeBSD</em></strong></h4>
<p class="noindent">If you’re serious about learning FreeBSD, I suggest wiping out the operating system on your main computer and running FreeBSD instead. No, not a desktop-oriented FreeBSD derivative like TrueOS or GhostBSD: run raw FreeBSD. Yes, I know, now that dog food doesn’t sound so bad. But learning an operating system is like learning a language; total immersion is the quickest and most powerful way to learn. That’s what I did, and today I can make a Unix-like system do anything I want. I’ve written entire books on a FreeBSD laptop, using the open source text editor XEmacs and the LibreOffice.org business suite. I’ve also used FreeBSD to watch movies, rip and listen to MP3s, balance my bank accounts, process my email, and surf the web. The desktop in my lab has a dozen animated BSD daemons running around the window manager, and I occasionally take a break to zap them with my mouse. If this doesn’t count as a Stupid Desktop Trick, I don’t know what does.<sup><a href="footnote.xhtml#introfn4" id="introfn4a">4</a></sup></p>
<p class="indent">Many Unix system administrators these days come from a Windows background. They’re beavering away in their little world when their manager swoops by and says, “You can handle one more system, can’t you? Glad to hear it! It’s a Unix box, by the way,” and then vanishes into the managerial ether. Once the new Unix administrator decides not to quit her job and start a fresh and exciting career as a whale necropsy technician, she tentatively pokes at the system. She learns that <code>ls</code> is like <code>dir</code> and that <code>cd</code> is the same on both platforms. She can learn the commands by rote, reading, and experience. What she can’t learn, coming from this background, is how a Unix machine <em>thinks</em>. Unix will not adjust to you; you must adjust to it. Windows and macOS require similar adjustments but hide them behind a glittering facade. With that in mind, let’s spend a little time learning how to think about Unix.</p>
<h4 class="h4" id="lev35"><strong><em>How to Think About Unix</em></strong></h4>
<p class="noindent">These days, most Unix systems come with pretty GUIs out of the box, but they’re just eye candy. No matter how graphically delicious the desktop looks, the real work happens on the command line. The Unix command line is actually one of Unix’s strengths, and it’s responsible for its unparalleled flexibility.</p>
<p class="indent">Unix’s underlying philosophy is <em>many small tools, each of which does a single job well</em>. My mail server’s local programs directory (<em>/usr/local/bin</em>) has 262 programs in it. I installed every one of them, either directly or indirectly. Most are small, simple programs that do only one task. This array of small tools makes Unix extremely flexible and adaptable. Many commercial software packages try to do everything; they wind up with all <span epub:type="pagebreak" id="page_xlvii"/>sorts of capabilities but only mediocre performance in their core functions. Remember, at one time you needed to be a programmer to use a Unix system, let alone run one. Programmers don’t mind building their own tools. The Unix concept of pipes encouraged this.</p>
<h5 class="h5" id="lev36"><strong>Pipes</strong></h5>
<p class="noindent">People used to GUI environments, such as Windows and macOS, are probably unfamiliar with how Unix handles output and input. They’re used to clicking something and seeing either an OK message, an error, nothing, or (all too often) a pretty blue screen with nifty high-tech letters explaining in the language called <em>Geek</em> why the system crashed. Unix does things a little differently.</p>
<p class="indent">Unix programs have three channels of communication, or <em>pipes</em>: standard input, standard output, and standard error. Once you understand how each of these pipes works, you’re a good way along to understanding the whole system.</p>
<p class="indent"><em>Standard input</em> is the source of information. When you’re at the console typing a command, the standard input is the data coming from the keyboard. If a program is listening to the network, the standard input is the network. Many programs can rearrange standard input to accept data from the network, a file, another program, the keyboard, or any other source.</p>
<p class="indent">The <em>standard output</em> is where the program’s output is displayed. This is frequently the console (screen). Network programs usually return their output to the network. Programs might send their output to a file, to another program, over the network, or anywhere else available to the computer.</p>
<p class="indent">Finally, <em>standard error</em> is where the program sends its error messages. Frequently, console programs return their errors to the console; others log errors in a file. If you set up a program incorrectly, it just might discard all error information.</p>
<p class="indent">These three pipes can be arbitrarily arranged, a concept that’s perhaps the biggest hurdle for new Unix users and administrators. For example, if you don’t like the error messages appearing on the terminal, you can redirect them to a file. If you don’t want to repeatedly type a lot of information into a command, you can put the information into a file (so you can reuse it) and dump the file into the command’s standard input. Or, better still, you can run a command to generate that information and put it in a file, or just pipe (send) the output of the first command directly to the second, without even bothering with a file.</p>
<h5 class="h5" id="lev37"><strong>Small Programs, Pipes, and the Command Line</strong></h5>
<p class="noindent">Taken to their logical extreme, these input/output pipes and the variety of tools seem overwhelming. When I saw a sysadmin type something like the following during my initial Unix training session, I gave serious consideration to changing careers.</p>
<pre>$ tail -f /var/log/messages | grep -v popper | grep -v named &amp;</pre>
<p class="indent"><span epub:type="pagebreak" id="page_xlviii"/>Lines of incomprehensible text began spilling across the screen, and they kept coming. And worse still, my mentor kept typing as gibberish poured out! If you’re from a point-and-click computing environment, a long string of commands like this is definitely intimidating. What do all those funky words mean? And an ampersand? You want me to learn <em>what</em>?</p>
<p class="indent">Think of learning to use the command line as learning a language. When learning a language, we start with simple words. As we increase our vocabulary, we also learn how to string the words together. We learn that placing words in a certain order makes sense, and that a different order makes no sense at all. You didn’t speak that well at three years old—give yourself some slack and you’ll get there.</p>
<p class="indent">Small, simple programs and pipes provide almost unlimited flexibility. Have you ever wished you could use a function from one program in another program? By using a variety of smaller programs and arranging the inputs and outputs as you like, you can make a Unix system behave in any manner that amuses you. Eventually, you’ll feel positively hogtied if you can’t just run a command’s output through <code>| sort -rnk 6 | less</code>.<sup><a href="footnote.xhtml#introfn5" id="introfn5a">5</a></sup></p>
<h5 class="h5" id="lev38"><strong>Everything Is a File</strong></h5>
<p class="noindent">You can’t be around Unix for very long before hearing that everything is a file. Programs, account information, and system configuration are all stored in files. Unix has no Windows-style registry; if you back up the files, you have the whole system.</p>
<p class="indent">What’s more, the system identifies system hardware as files! Your CD-ROM drive is a file, <em>/dev/cd0</em>. Serial ports appear as files like <em>/dev/cuaa0</em>. Even virtual devices, such as packet sniffers and partitions on hard drives, are files.</p>
<p class="indent">When you have a problem, keep this fact in mind. Everything is a file, or is in a file, somewhere on your system. All you have to do is find it!</p>
<h3 class="h3" id="lev39"><strong>Notes on the Third Edition</strong></h3>
<p class="noindent"><em>Absolute BSD</em> (No Starch Press, 2002) was my first technology book and was written when the various BSD operating systems had more in common than they wanted to admit. The second edition, <em>Absolute FreeBSD</em> (No Starch Press, 2007), came out after the BSDs had diverged, and detailed FreeBSD’s advances in the previous five years. With another decade of growth, FreeBSD has evolved to compete with the best commercial operating systems. You’ll find multiple top-tier filesystems. Disk management has changed to accommodate new partitioning methods. Virtualization is now a thing, and FreeBSD supports it as either a client or a host.</p>
<p class="indent"><span epub:type="pagebreak" id="page_xlix"/>This growth has driven changes in this book.</p>
<p class="indent">We won’t discuss configuring mail, DNS, or web servers. You have more software choices for these tasks than ever before. Entire books have been written about those choices and how to use them. I’ve written some of those books. Those topics have been dropped to make space for FreeBSD-specific material, like ZFS and jails.</p>
<p class="indent">Some of these new features are hugely complex. Complete coverage of ZFS would fill entire books—I know, because I’ve written those books, too. FreeBSD supports a whole bunch of special-purpose filesystems, each incredibly useful to the folks who need them and totally irrelevant to those who don’t. Rather than write a monster tome that nobody would actually read, I’ve elected to cover the material that every FreeBSD sysadmin <em>must</em> know. If you’re interested in deeper coverage of a particular topic, it’s available.</p>
<p class="indent">Some subsystems are undergoing radical revision. I could wait to write this book until every FreeBSD subsystem has a stable interface, but then it would come out about . . . never. As I write this, the bhyve developers are actively rototilling their entire configuration system. Given the choice between glossing over a topic and providing flat-out wrong material, I’ve chosen to skip detail on bhyve. I hope to be able to delete this paragraph before this book goes to press.</p>
<p class="indent">I’ve ruthlessly excised obsolete information from this edition. For example, modern disk drives don’t generally have to worry about write caching. If you discover that a piece of advice you remember using doesn’t appear in this book, please check FreeBSD’s information resources to see whether that advice is still applicable.</p>
<h3 class="h3" id="lev40"><strong>Contents of This Book</strong></h3>
<p class="noindent"><em>Absolute FreeBSD</em>, 3rd Edition contains the following chapters.</p>
<p class="noindentt"><strong><a href="ch01.xhtml#ch01">Chapter 1: Getting More Help</a></strong></p>
<p class="hang">This chapter discusses the information resources the FreeBSD Project and its devotees provide for users. No one book can cover everything, but knowing how to use the many FreeBSD resources on the internet helps fill any gaps you find here.</p>
<p class="noindentt"><strong><a href="ch02.xhtml#ch02">Chapter 2: Before You Install</a></strong></p>
<p class="hang">Getting FreeBSD installed isn’t that hard. Make poor choices during the install, though, and you’ll have a system that isn’t suited for your needs. The best way to avoid reinstalling is to think about your requirements and make all the decisions beforehand so that the actual install doesn’t require any thought.</p>
<p class="noindentt"><strong><a href="ch03.xhtml#ch03">Chapter 3: Installing</a></strong></p>
<p class="hang">This chapter gives you an overview of installing FreeBSD using different partitioning schemes and filesystems.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_l"/><strong><a href="ch04.xhtml#ch04">Chapter 4: Start Me Up! The Boot Process</a></strong></p>
<p class="hang">This chapter teaches you about the FreeBSD boot process and how to make your system start, stop, and reboot in different configurations.</p>
<p class="noindentt"><strong><a href="ch05.xhtml#ch05">Chapter 5: Read This Before You Break Something Else! (Backup and Recovery)</a></strong></p>
<p class="hang">Here we discuss how to back up your data on both a system-wide and a file-by-file level, and how to make your changes so that they can be easily undone.</p>
<p class="noindentt"><strong><a href="ch06.xhtml#ch06">Chapter 6: Kernel Games</a></strong></p>
<p class="hang">This chapter describes configuring the FreeBSD kernel. Unlike some other operating systems, you’re expected to tune FreeBSD’s kernel to best suit your purposes. This gives you tremendous flexibility and lets you optimize your hardware’s potential.</p>
<p class="noindentt"><strong><a href="ch07.xhtml#ch07">Chapter 7: The Network</a></strong></p>
<p class="hang">Here we discuss the TCP/IP protocol that underlies the modern internet, both version 4 and version 6.</p>
<p class="noindentt"><strong><a href="ch08.xhtml#ch08">Chapter 8: Configuring the Network</a></strong></p>
<p class="hang">FreeBSD doesn’t only shuffle packets crazy fast, but it also supports virtual LANs, link aggregation, and more. We’ll configure all of that here.</p>
<p class="noindentt"><strong><a href="ch09.xhtml#ch09">Chapter 9: Securing Your System</a></strong></p>
<p class="hang">This chapter teaches you how to make your computer resist attackers and intruders.</p>
<p class="noindentt"><strong><a href="ch10.xhtml#ch10">Chapter 10: Disks, Partitioning, and GEOM</a></strong></p>
<p class="hang">This chapter covers some of the details of working with hard drives in FreeBSD. Working with modern hardware means understanding multiple partitioning schemes, disk alignment, and FreeBSD’s disk management infrastructure.</p>
<p class="noindentt"><strong><a href="ch11.xhtml#ch11">Chapter 11: The Unix File System</a></strong></p>
<p class="hang">UFS has been FreeBSD’s standard filesystem for decades, and the concepts of UFS pervade the whole operating system. Whether you intend to use UFS or not, you must understand its essentials.</p>
<p class="noindentt"><strong><a href="ch12.xhtml#ch12">Chapter 12: The Z File System</a></strong></p>
<p class="hang">ZFS is a newer filesystem very popular on larger systems. If you’re managing large amounts of data, you’ll want ZFS.</p>
<p class="noindentt"><strong><a href="ch13.xhtml#ch13">Chapter 13: Foreign Filesystems</a></strong></p>
<p class="hang">Every sysadmin needs to mount disks over the network or use ISOs without burning them to CD. This chapter takes you through those duties, as well as introducing FreeBSD-specific filesystems like devfs.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_li"/><strong><a href="ch14.xhtml#ch14">Chapter 14: Exploring /etc</a></strong></p>
<p class="hang">This chapter describes the many configuration files in FreeBSD and how they operate.</p>
<p class="noindentt"><strong><a href="ch15.xhtml#ch15">Chapter 15: Making Your System Useful</a></strong></p>
<p class="hang">Here I describe the packages system that FreeBSD uses to manage add-on software.</p>
<p class="noindentt"><strong><a href="ch16.xhtml#ch16">Chapter 16: Customizing Software with Ports</a></strong></p>
<p class="hang">Sometimes the prebuilt packages won’t cover everything you need. You can leverage FreeBSD’s package-building system to create your own software packages, tuned to meet your exact needs.</p>
<p class="noindentt"><strong><a href="ch17.xhtml#ch17">Chapter 17: Advanced Software Management</a></strong></p>
<p class="hang">This chapter discusses some of the finer points of running software on FreeBSD systems.</p>
<p class="noindentt"><strong><a href="ch18.xhtml#ch18">Chapter 18: Upgrading FreeBSD</a></strong></p>
<p class="hang">This chapter teaches you how to use FreeBSD’s upgrade process. The upgrade system is among the most remarkable and smooth of any operating system.</p>
<p class="noindentt"><strong><a href="ch19.xhtml#ch19">Chapter 19: Advanced Security Features</a></strong></p>
<p class="hang">Here we discuss some of the more interesting security features found in FreeBSD.</p>
<p class="noindentt"><strong><a href="ch20.xhtml#ch20">Chapter 20: Small System Services</a></strong></p>
<p class="hang">Here we discuss some of the small programs you’ll need to manage in order to use FreeBSD properly.</p>
<p class="noindentt"><strong><a href="ch21.xhtml#ch21">Chapter 21: System Performance and Monitoring</a></strong></p>
<p class="hang">This chapter covers some of FreeBSD’s performance-testing and troubleshooting tools and shows you how to interpret the results. We also discuss logging and FreeBSD’s SNMP implementation.</p>
<p class="noindentt"><strong><a href="ch22.xhtml#ch22">Chapter 22: Jails</a></strong></p>
<p class="hang">FreeBSD has a process-isolation subsystem, much like Linux and Solaris containers, called <em>jails</em>. We’ll cover the jail system and how you can leverage it for system security.</p>
<p class="noindentt"><strong><a href="ch23.xhtml#ch23">Chapter 23: The Fringe of FreeBSD</a></strong></p>
<p class="hang">This chapter teaches you some of the more interesting tricks you can do with FreeBSD, such as running systems without disks and with tiny disks, as well as cloud-friendly features, like libxo.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_lii"/><strong><a href="ch24.xhtml#ch24">Chapter 24: Problem Reports and Panics</a></strong></p>
<p class="hang">This chapter teaches you how to deal with those rare occasions when a FreeBSD system fails, how to debug problems, and how to create a useful problem report.</p>
<p class="indentt">You’ll also find an annotated bibliography, an afterword, and a really spiffy professionally prepared index.</p>
<p class="indent">Okay, enough introductory stuff. Onward!</p>
</body></html>