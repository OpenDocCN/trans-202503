- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 8 ADVANCED ARITHMETIC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter covers extended-precision arithmetic and arithmetic on operands
    of different sizes. By the end of this chapter, you should know how to apply arithmetic
    and logical operations to integer operands of any size, including those larger
    than 64 bits, and how to convert operands of different sizes into a compatible
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 Extended-Precision Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Assembly language does not limit the size of integer operations, a major advantage
    over HLLs (which typically rely on functions, written in assembly language, to
    handle extended-precision arithmetic). For example, the standard C programming
    language defines four integer sizes: short int, int, long int, and long long int.
    On the PC, these are often 16-, 32-, and 64-bit integers.'
  prefs: []
  type: TYPE_NORMAL
- en: Although the ARM machine instructions limit you to processing 32- or 64-bit
    integers with a single instruction, you can use multiple instructions to process
    integers of any size. This section describes how to extend various arithmetic
    and logical operations from 32 or 64 bits to as many bits as you please.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.1 Addition
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ARM add/adds instruction adds two 32- or 64-bit numbers. After the execution
    of adds, the ARM carry flag is set if you have an overflow out of the HO bit of
    the sum. You can use this information to do extended-precision addition operations.
    (This book uses *multidigit* and *multibyte* as synonyms for *extended precision*.)
  prefs: []
  type: TYPE_NORMAL
- en: Consider the way you manually perform a multidigit addition operation, as shown
    in [Figure 8-1](chapter8.xhtml#fig8-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-1: Multidigit addition'
  prefs: []
  type: TYPE_NORMAL
- en: The ARM handles extended-precision arithmetic the same way, except instead of
    adding the numbers a digit at a time, it adds them together a word or double word
    at a time, breaking a larger operation into a sequence of smaller ones. For example,
    consider the three-double-word (192-bit) addition operation in [Figure 8-2](chapter8.xhtml#fig8-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-2: Adding two 192-bit objects together'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the ARM processor family is capable of adding together at most 64 bits
    at a time (using general-purpose registers), the operation must proceed in blocks
    of 64 bits or fewer, according to the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Add the two LO double words together just as you would add the two LO digits
    of a decimal number together in the manual algorithm, using the adds instruction.
    If there is a carry out of the LO addition, adds sets the carry flag to 1\. Otherwise,
    it clears the carry flag.
  prefs: []
  type: TYPE_NORMAL
- en: '2.  Add together the second pair of double words in the two 192-bit values,
    plus the carry out of the previous addition (if any), using the adcs (add with
    carry) instruction. The adcs instruction uses the same syntax as adds and performs
    almost the same operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The only difference is that adcs adds in the value of the carry flag along with
    the source operands. It sets the flags the same way adds does (including setting
    the carry flag if there is an unsigned overflow). This is exactly what we need
    in order to add together the middle two double words of our 192-bit sum.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Add the HO double words of the 192-bit value with the carry out of the sum
    of the middle two quad words by using adcs. (You could also use a plain adc instruction
    if you don’t need the flag settings after the instruction.)
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, the adds instruction adds the LO double words together, and adcs
    adds all other double-word pairs together. At the end of the extended-precision
    addition sequence, the carry flag indicates unsigned overflow (if set), a set
    overflow flag indicates signed overflow, and the sign flag indicates the sign
    of the result. The zero flag doesn’t have any real meaning at the end of the extended-precision
    addition; it simply means that the sum of the two HO double words is 0 and does
    not indicate that the whole result is 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you have two 128-bit values you wish to add together,
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Say you want to store the sum in a third variable Z, which is also a qword.
    The following ARM code will accomplish this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first seven instructions add the LO double words of X and Y together and
    store the result into the LO double word of Z. The last four instructions add
    the HO double words of X and Y together, along with the carry from the LO word,
    and store the result in the HO double word of Z.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can extend this algorithm to any number of bits by using adcs to add in
    the higher-order values. For example, to add together two 256-bit values declared
    as arrays of four double words, you could use code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This produces a 256-bit sum and stores it in the memory location BigVal3.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.2 Subtraction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ARM also performs multibyte subtraction the same way you would manually,
    except that it subtracts whole words or double words at a time rather than decimal
    digits. Use the subs instruction on the LO word or double word and the sbc/sbcs
    (subtract with carry) instruction on the HO values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates a 128-bit subtraction using the 64-bit registers
    on the ARM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example demonstrates a 256-bit subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This produces a 256-bit difference and stores it in the memory location BigVal3.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.3 Comparisons
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unfortunately, there’s no “compare with carry” instruction that you can use
    to perform extended-precision comparisons. However, you can compare extended-precision
    values by using just a cmp instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the two unsigned values 0x2157 and 0x1293\. The LO bytes of these two
    values do not affect the outcome of the comparison. Simply comparing the HO bytes,
    0x21 with 0x12, tells you that the first value is greater than the second.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must look at both bytes of a pair of values if the HO bytes are equal.
    In all other cases, comparing the HO bytes tells you everything you need to know
    about the values. This is true for any number of bytes, not just two. The following
    code compares two signed 128-bit integers by comparing their HO double words first
    and comparing their LO double words only if the HO quad words are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To compare unsigned values, use the bhi and blo instructions in place of bgt
    and blt.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can synthesize any comparison from the preceding sequence, as shown in
    the following examples that demonstrate signed comparisons; just substitute bhi,
    bhs, blo, and bls for bgt, bge, blt, and ble (respectively) if you want unsigned
    comparisons. Each of the following examples assumes these declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code implements a 128-bit test to see if OW1 < OW2 (signed).
    Control transfers to the IsLess label if OW1 < OW2. Control falls through to the
    next statement (label NotLess) if this is not true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a 128-bit test to see if OW1 <= OW2 (signed). This code jumps to IsLessEQ
    if the condition is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a 128-bit test to see if OW1 > OW2 (signed). It jumps to IsGtr if this
    condition is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a 128-bit test to see if OW1 >= OW2 (signed). This code jumps
    to label IsGtrEQ if this is the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a 128-bit test to see if OW1 == OW2 (signed or unsigned). This code
    branches to the label IsEqual if OW1 == OW2. It falls through to the next instruction
    if they are not equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a 128-bit test to see if OW1 != OW2 (signed or unsigned).
    This code branches to the label IsNotEqual if OW1 != OW2. It falls through to
    the next instruction if they are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To generalize the preceding code for objects larger than 128 bits, start the
    comparison with the objects’ HO double words and work your way down to their LO
    double words, as long as the corresponding double words are equal. The following
    example compares two 256-bit values to see if the first is less than or equal
    (unsigned) to the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Presumably, there is a branch immediately before the notLE label to skip over
    the code to execute if Big1 > Big2.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.4 Multiplication
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although 64 × 64-bit multiplication (or one of the smaller variants) is usually
    sufficient, sometimes you may want to multiply larger values. Use the ARM single-operand
    umul and smul instructions for extended-precision multiplication operations, using
    the same techniques that you employ when manually multiplying two values.
  prefs: []
  type: TYPE_NORMAL
- en: You likely perform multidigit multiplication by hand using the method shown
    in [Figure 8-3](chapter8.xhtml#fig8-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-3: Multidigit multiplication'
  prefs: []
  type: TYPE_NORMAL
- en: The ARM does extended-precision multiplication in the same manner, but with
    words and double words rather than digits, as shown in [Figure 8-4](chapter8.xhtml#fig8-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-4: Extended-precision multiplication'
  prefs: []
  type: TYPE_NORMAL
- en: When performing an extended-precision multiplication, remember that you must
    also perform an extended-precision addition at the same time. Adding up all the
    partial products requires several additions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The umul and smul instructions you’ve seen thus far multiply two *n*-bit operands
    (32 or 64 bits), producing an *n*-bit result, ignoring any overflow. You can’t
    easily use these instructions for multiprecision multiplication operations. Fortunately,
    the ARM CPU provides two sets of extended-precision multiplication instructions
    that will do the job: one set for 32 × 32 multiplications (producing a 64-bit
    result), and a second set for 64 × 64 multiplications (producing a 128-bit result).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the instructions that produce 64-bit results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The smull (signed multiply long) and umull (unsigned multiply long) instructions
    multiply the 32-bit registers to produce a 64-bit result, storing the result in
    the 64-bit destination register. The smnegl and umnegl also multiply two 32-bit
    values but negate the 64-bit result before storing it in the destination register.
  prefs: []
  type: TYPE_NORMAL
- en: The smaddl/umaddl and smsubl/umsubl instructions multiply their 32-bit operands,
    producing a 64-bit result, then add or subtract a 64-bit register from the result
    before storing the result into the 64-bit destination register. You could use
    the smaddl/umaddl instruction, for example, to multiply C × B and simultaneously
    add in D × A in [Figure 8-4](chapter8.xhtml#fig8-4).
  prefs: []
  type: TYPE_NORMAL
- en: The 32 × 32 multiplication instructions are less useful than they seem because
    the existing mxxx instructions will accept 64-bit operands (producing a 64-bit
    result). You can easily zero- or sign-extend a 32-bit value into a 64-bit register
    and use the standard multiply instructions to achieve the same result as the long
    multiply instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could use the 32-bit long multiply instructions to synthesize larger multiplications
    (for example, a 128-bit multiplication). However, the ARM provides two additional
    instructions that are better suited for this: smulh and umulh (signed and unsigned
    multiply high):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'These instructions multiply the two 64-bit source operands and store the HO
    64 bits of the 128-bit result into the destination register. The standard mul
    instruction produces the LO 64 bits of the result, so between the mul and smulh/umulh
    instructions, you can compute the full 128-bit result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: For signed multiplication, simply substitute smulh for umulh.
  prefs: []
  type: TYPE_NORMAL
- en: To multiply larger values together, you can use the mul, umulh, and smulh instructions
    to implement the algorithm depicted in [Figure 8-4](chapter8.xhtml#fig8-4). Listing
    8-1 demonstrates how to multiply two 128-bit values (producing a 256-bit result)
    by using 64-bit instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The mul128 procedure ❶ multiplies two 128-bit values passed on the stack (note
    that this is not ARM ABI–compliant). Although X0 through X7 are volatile in the
    ARM ABI, this function is nice and preserves those registers ❷. The code loads
    the two 128-bit values from the stack into the X1:X0 and X3:X2 register pairs
    ❸. The 128-bit multiplication algorithm follows, as described in the program comments.
  prefs: []
  type: TYPE_NORMAL
- en: The code stores the 256-bit result into the memory location passed to this function
    in the X8 register ❹; then the mul128 function restores the preserved registers
    and returns to the caller. The main program calls mul128 ❺ and displays the result
    (in hexadecimal form) ❻.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and output from Listing 8-1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The code works only for unsigned operands. To multiply two signed values, you
    must change the umulh instructions to smulh.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8-1 is fairly straightforward because it is possible to keep the partial
    products in various registers. If you need to multiply larger values together,
    you will need to maintain the partial products in temporary (memory) variables.
    Other than that, the algorithm that Listing 8-1 uses generalizes to any number
    of words.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.5 Division
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You cannot synthesize a general *n*-bit / *m*-bit division operation by using
    the sdiv and udiv instructions. A generic extended-precision division requires
    a sequence of shift and subtract operations, which takes quite a few instructions
    and runs much slower. This section presents the algorithm for extended-precision
    division.
  prefs: []
  type: TYPE_NORMAL
- en: As with multiplication, the best way to understand how the computer performs
    division is to study how you were probably taught to do long division by hand.
    Consider the steps you’d take to manually divide 3,456 by 12, as shown in [Figure
    8-5](chapter8.xhtml#fig8-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-5: Manual digit-by-digit division operation'
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is easier in binary because you don’t have to guess at each step
    how many times 12 goes into the remainder, nor do you have to multiply 12 by your
    guess to obtain the amount to subtract. At each step in the binary algorithm,
    the divisor goes into the remainder exactly zero or one times. For example, [Figure
    8-6](chapter8.xhtml#fig8-6) shows how to divide 27 by 3 in binary (that is, dividing
    11011 by 11).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-6: Longhand division in binary'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following algorithm implements this binary division operation in a way
    that computes the quotient and the remainder at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: NumberBits is the number of bits in the Remainder, Quotient, Divisor, and Dividend
    variables. LSL is the shift-left operator. The statement Quotient := Quotient
    + 1; sets the LO bit of Quotient to 1 because this algorithm previously shifted
    Quotient 1 bit to the left. Listing 8-2 implements this algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The div128 function ❶ is a 128 × 128-bit division operation that simultaneously
    produces the quotient and the remainder. Unlike the extended-precision multiplication
    given earlier, this function passes its arguments by reference (in X0 and X1)
    rather than by value on the stack. It stores the 128-bit quotient in the location
    pointed at by X8 and the remainder in the location pointed at by X9\. As in the
    multiplication code, the div128 function ❷ preserves all the volatile registers
    it modifies.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the division algorithm ❸, as described in the program comments. The
    code stores the quotient and remainder away ❹ and then restores the preserved
    registers ❺. The main program ❻ demonstrates the div128 function with a pair of
    calls, along with the code to display the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and program output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This code does not check for division by 0 (it will produce the quotient 0xFFFF_FFFF_FFFF_FFFF
    if you attempt to divide by 0). It handles only unsigned values and is very slow,
    a couple of orders of magnitude worse than the sdiv/udiv instructions. To handle
    division by 0, check the divisor against 0 prior to running this code and return
    an appropriate error code if the divisor is 0\. To deal with signed values, note
    the signs, take the operands’ absolute values, do the unsigned division, and then
    fix the sign afterward by setting the result negative if the operand signs were
    different.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.6 Negation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The neg instruction doesn’t provide a generic extended-precision form. However,
    a negation is equivalent to subtracting a value from 0, so you can easily simulate
    an extended-precision negation by using the subs and sbcs instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code provides a simple way to negate a (320-bit) value by subtracting
    that value from 0, using an extended-precision subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can extend this algorithm to any number of bits (or reduce it to fewer bits)
    by using the scheme I presented for extended-precision subtraction.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.7 AND
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Performing an *n*-byte AND operation is easy: simply AND the corresponding
    bytes between the two operands, saving the result. For example, to perform the
    AND operation with all operands 128 bits long, you could use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To extend this technique to any number of dwords, logically AND the corresponding
    dwords together in the operands.
  prefs: []
  type: TYPE_NORMAL
- en: 'When testing the flags after an AND sequence, remember that the ands instruction
    will set the flags only for that particular portion of the AND sequence. If you
    convert the last and to an ands instruction, it will properly set the N flag but
    will not properly set the Z flag. To set the Z flag (indicating a 0 result for
    the entire 128 bits), you can use ccmp (conditional compare) to test the Z flag
    from the ands instruction and compare X2 with 0 (see section 6.1.4, “Conditional
    Instructions,” on [page 297](chapter6.xhtml#pg_297)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you need to test both the N and Z flags after this sequence, consider using
    the tbz/tbnz instructions to test the HO bit of register X3, which contains the
    sign bit.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.8 OR
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Multibyte logical OR operations are performed in the same way as multibyte
    AND operations: you OR the corresponding bytes in the two operands together. For
    example, to logically OR two 256-bit values, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the orr instruction does not affect any flags (and there is no
    orrs instruction). If you need to test the zero flag after an extended-precision
    OR, you must compare all the resulting double words to 0.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the V*n* registers to perform extended-precision logical operations,
    up to 128 bits at a time. See section 11.13, “Use of SIMD Instructions in Real
    Programs,” on [page 699](chapter11.xhtml#pg_699) for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.9 XOR
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As with other logical operations, extended-precision XOR operations will XOR
    the corresponding bytes in the two operands to obtain the extended-precision result.
    The following code sequence operates on two 128-bit operands, computes their exclusive-OR,
    and stores the result into a 128-bit variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The comment about the zero flag in the previous section applies here, as well
    as the comment about V*n* registers.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.10 NOT
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The mvn instruction inverts all the bits in the specified operand. Perform
    an extended-precision NOT by executing the mvn instruction on all the affected
    operands. For example, to perform a 128-bit NOT operation on the value in X1:X0,
    execute the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you execute the mvn instruction twice, you wind up with the original value.
    Also, exclusive-ORing a value with all 1s (such as 0xFF, 0xFFFF, 0xFFFF_FFFF,
    or 0xFFFF_FFFF_FFFF_FFFF) performs the same operation as the mvn instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.11 Shift Operations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Extended-precision shift operations on the ARM are somewhat problematic. Traditionally,
    the way you accomplish an extended-precision shift is to shift a bit out of one
    register into the carry flag, then rotate that carry bit into another register.
    Unfortunately, the ARM doesn’t provide such instructions, so a different approach
    is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exact approach depends on two things, as described in the following subsections:
    the number of bits to shift and the direction of the shift.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.11.1 Shift Left
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A 128-bit lsl (logical shift left) takes the form shown in [Figure 8-7](chapter8.xhtml#fig8-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-7: The 128-bit shift-left operation'
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this with machine instructions, you must first shift the LO dword
    to the left (for example, using the lsls instruction) and capture the output from
    bit 63 (conveniently, the carry flag does this for us). Next, shift this bit into
    the LO bit of the HO dword while simultaneously shifting all the other bits to
    the left (and capturing the output by using the carry flag). No instruction specifically
    rotates the carry flag into a register, but you can use the magic instruction
    adc/adcs to do this if you supply appropriate operands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, a shift left is the same thing as a multiplication by 2\. Adding
    a value to itself is the very definition of a multiplication by 2\. Therefore,
    the lsls and adds instructions can both shift an operand to the left, moving the
    overflow bit into the carry flag. In order for adds to behave like a shift-left
    operation, you must supply the same operand in both source positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The adcs instruction (with the same operands) will also shift all the bits to
    the left one position and shift the carry flag into bit 0 (as well as shift the
    HO bit into the carry flag at the end of the operation). This is, effectively,
    a single-bit *rotate-through-carry-left* operation, as illustrated in [Figure
    8-8](chapter8.xhtml#fig8-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-8: The rotate-through-carry-left operation'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the adds and adcs instructions to implement a 128-bit shift. For
    example, to shift the 128-bit quantity in X1:X0 one position to the left, use
    the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The adds instruction shifts a 0 into bit 0 of the 128-bit operand and shifts
    bit 63 into the carry flag. The adcs instruction then shifts the carry flag into
    bit 64 and shifts bit 127 into the carry flag, giving you exactly the result you
    want, as shown in [Figure 8-9](chapter8.xhtml#fig8-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-9: Extended-precision shift left using adds/adcs'
  prefs: []
  type: TYPE_NORMAL
- en: Using this technique, you can shift an extended-precision value only 1 bit at
    a time. You cannot shift an extended-precision operand several bits by using a
    register, nor can you specify a constant value greater than 1 when using this
    technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform a shift left on an operand larger than 128 bits, use additional
    adcs instructions. An extended-precision shift-left operation always starts with
    the least-significant double word, and each succeeding adcs instruction operates
    on the next-most-significant double word. For example, to perform a 192-bit shift-left
    operation on a memory location, you could use the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to shift your data by 2 or more bits, you can either repeat the
    preceding sequence the desired number of times for a constant number of shifts
    or place the instructions in a loop to repeat them a certain number of times.
    For example, the following code shifts the 192-bit value in X0, X1, and X2 to
    the left by the number of bits specified in W3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The only problem with this multibit shift is that it can run rather slowly when
    shifting more than a few bits to the left. In general, we say that this algorithm
    is O(n), meaning the runtime is proportional to the number of bits we shift to
    the left.
  prefs: []
  type: TYPE_NORMAL
- en: 'An instruction to shift multiple bits simultaneously, as the lsl instruction
    can do, would help solve this problem. If a rol instruction existed, you could
    use it to shift the 128 bits in X1:X0 to the left 8 bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the ARM CPU’s instruction set has no rol instruction; however,
    you can use the ror instruction to do anything a rol instruction would do. For
    any bit shift that occurs in the range 1–63, rol(n) is equivalent to ror((64 -
    n) % 64), where rox(n) means “rotate left/right *n* bits.” For the special case
    of rol(0), ror(0) ((64 - 0) % 64) is 0) will also rotate the value 0 bits. Therefore,
    you can replace the previous noncompiling code with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When *n* is greater than 2 or 3, this sequence will execute much faster than
    the adds/adcs loop given earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figures 8-10](chapter8.xhtml#fig8-10) through [8-14](chapter8.xhtml#fig8-14)
    show the operations for this extended-precision shift left.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-10: Extended-precision shift left using ror, before the shift'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 8-11](chapter8.xhtml#fig8-11), the algorithm makes a temporary copy
    of bits 0 to 63 and rotates the value to the left by 8 bits.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-11: Step 1: Making a temporary copy and shifting bits'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-12](chapter8.xhtml#fig8-12) shows shifting the original value to
    the left 8 bits (which clears the LO bits) and clearing the HO temporary bits
    (via an AND operation).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-12: Step 2: Shifting and clearing bits'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-13](chapter8.xhtml#fig8-13) shows the merging of the temporary and
    HO dwords (OR operation).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-13: Step 3: Merging the temporary and HO dwords'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-14](chapter8.xhtml#fig8-14) shows the result after the shift.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-14: Step 4: After the shift'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a variable extended-precision shift-left operation, the code needs
    to generate a bitmask to clear the LO bits (the and instructions in the previous
    code). As it turns out, you can generate the mask for an *n*-bit shift by using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The trick here is that lsl(n) produces 2*^n*. Then, 2*^n* – 1 is all 1 bits
    from bit 0 to position *n* – 1.  ##### 8.1.11.2 Shift Right and Arithmetic Shift
    Right'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, no trick like using the adds/adcs instructions allows you to
    perform a *rotate through carry right* operation (shifting all the bits right
    through the carry, and shifting the original carry back into the HO bit). Therefore,
    to do an extended-precision shift right (or arithmetic shift right), you must
    use the ror instruction again. Here’s an example that shifts a 128-bit value in
    X1:X0 to the right 8 bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for the extended-precision arithmetic shift-right operation is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you substitute an asr instruction for the lsr on the HO dword.
    Note that you continue to use a lsr instruction on the LO dword; lsr is necessary
    to shift 0s into the HO bits so that the orr instruction properly merges the bits
    shifted out of the HO dword.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a last example, here’s a 192-bit arithmetic shift right that shifts the
    bits in X2:X1:X0 to the right 4 bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The Neon instructions allow you to shift 128-bit values left and right; see
    [Chapter 11](chapter11.xhtml) for details.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2 Operating on Different-Size Operands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Occasionally, you may need to do a computation on a pair of operands that are
    not the same size (*mixed-size*, or *mixed-mode*, arithmetic). For example, you
    may need to add a word and a double word together or subtract a byte value from
    a word value. To do so, extend the smaller operand to the size of the larger operand,
    then operate on two same-size operands. For signed operands, sign-extend the smaller
    operand to the same size as the larger operand; for unsigned values, zero-extend
    the smaller operand. This works for any operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples demonstrate adding a byte variable, a half-word variable,
    and a dword variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, the byte variable is loaded into the W0 register, extended to
    32 bits, and then added with the half-word operand (also extended to 32 bits).
  prefs: []
  type: TYPE_NORMAL
- en: All these examples add a byte value to a half-word value. By zero- or sign-extending
    the operands to the same size, you can easily add any two different-size variables
    together.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a last example, consider adding an 8-bit signed value to a qword (128-bit)
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The trick in this code is the asr instruction. This instruction sign-extends
    X0 into X1:X0 by copying the sign bit in X0 throughout X1 (an arithmetic shift
    right by 63 bits effectively copies bit 63 into bits 0–62). Once X0 has been sign-extended
    into X1, you have a 128-bit value in X1:X0 that you can add to the 128-bit value
    in variable var3.
  prefs: []
  type: TYPE_NORMAL
- en: The previous examples in this chapter assumed that the different-size operands
    were memory variables. They used the ldrb/ldrsb and ldrh/ldrsh instructions to
    zero- and sign-extend 8- and 16-bit operands to 32 bits (which could also extend
    their operands to 64 bits by supplying a 64-bit register). Although these examples
    did not demonstrate mixing 32- and 64-bit operands, you could also have used the
    ldrsw instruction to sign-extend 32 bits to 64.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your operands are already in registers (not memory), you can use the uxtb/uxth/uxtw
    and sxtb/sxth/sxtw instructions to zero- or sign-extend the operands. For example,
    the following code sign-extends the 32-bit value in W0 to 128 bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When adding smaller values to 32- or 64-bit registers that don’t require sign-extending
    the smaller value to 128 bits or more, you can use the sign-extension modifiers
    for Operand2 in arithmetic instructions to zero- and sign-extend the smaller values
    to the larger size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: To add bytes and half words to 64-bit dwords, just change the W1 registers to
    X1 in this code.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3 Moving On
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Extended-precision arithmetic is difficult or impossible in HLLs but is fairly
    easy in assembly language. This chapter described the extended-precision arithmetic,
    comparison, and logical operations in ARM assembly language. It concluded by discussing
    mixed-mode (mixed-size) arithmetic, where the operands have differing sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with the information from this chapter, it’s easy to handle arithmetic
    and logical operations that are difficult to achieve in most HLLs. The next chapter,
    which covers numeric-to-string conversions, will use these extended-precision
    operations when converting values larger than 64 bits.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 For More Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One arithmetic feature missing from the ARM instruction set is *decimal arithmetic*
    (base-10), meaning if the need arises, you’ll have to perform that arithmetic
    in software. Though most of the code is in C, visit the General Decimal Arithmetic
    site if you want to implement decimal arithmetic: *[https://<wbr>speleotrove<wbr>.com<wbr>/decimal<wbr>/](https://speleotrove.com/decimal/)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Donald Knuth’s *The Art of Computer Programming, Volume 2: Seminumerical Algorithms*
    (Addison-Wesley Professional, 1997) contains lots of useful information about
    decimal arithmetic and extended-precision arithmetic, though the text is generic
    and describes how to do this in MIXAL assembly language rather than ARM assembly
    language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
