- en: '**4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4'
- en: THE PLOTTING SYSTEM**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**绘图系统**'
- en: '*There is nothing worse than a sharp image of a fuzzy concept.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*没有什么比一个模糊概念的清晰图像更糟糕的了。*'
- en: —Ansel Adams
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —安塞尔·亚当斯
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: This chapter introduces the large and rich subject of visualization in Julia.
    Plots and diagrams play a role in scientific communication equal in importance
    to words and equations. Julia’s plotting ecosystem is diverse and powerful; you’ll
    be able to craft a solution to any type of visualization challenge without leaving
    the language. The ability to keep both your calculation and its visualization
    within a single program simplifies the process of exploring and reporting results.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Julia中可视化这一庞大而丰富的主题。图形和图表在科学传播中的作用，与文字和方程式同样重要。Julia的绘图生态系统丰富且强大；你将能够在不离开语言的情况下，解决任何类型的可视化挑战。将计算和其可视化放在一个程序中，简化了探索和报告结果的过程。
- en: Plotting in Julia is a hotspot of rapid development. This is mostly good, as
    it means new features and packages arise regularly. The downside, however, is
    a higher than average incidence of conflicts among packages, incomplete documentation,
    and bugs, exacerbated by the frequent need for plotting routines to depend on
    external graphics libraries. With this in mind, I’ve confined the treatment in
    this chapter to packages that seem to be stable and mature. The examples here
    should work over the long term. I’ve avoided discussing some potentially useful
    packages that still have too many rough edges.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，绘图是一个快速发展的热点。这大多数时候是件好事，因为这意味着新的功能和包会定期出现。然而，缺点是包之间的冲突发生率高于平均水平，文档不完整，而且存在bug，尤其是绘图常常需要依赖外部图形库来加剧这些问题。考虑到这一点，本章只讨论那些看起来稳定和成熟的包。这里的示例应该能在长时间内有效。我避免讨论一些仍然存在太多问题的潜在有用包。
- en: '**Plots**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Plots**'
- en: The main, and in a sense “official,” plotting package for Julia is `Plots`.
    Later in the book we’ll explore other graphical methods, but this chapter is about
    the package at the center of Julia’s visualization universe.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的主要、也是某种意义上的“官方”绘图包是`Plots`。本书后面会探讨其他图形方法，但本章主要讲解Julia可视化宇宙核心中的包。
- en: '`Plots` is not in the standard library, so we need to install it in the package
    manager with add Plots. The initial installation will take some time, as `Plots`
    has many dependencies, all of which need to be (automatically) installed as well.
    Precompilation of this assortment of packages will take a few minutes.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`Plots`不在标准库中，因此我们需要通过包管理器安装它，使用命令 `add Plots`。初次安装会花费一些时间，因为`Plots`有许多依赖项，所有这些依赖项都需要被（自动）安装。这个包的预编译需要几分钟时间。'
- en: '`Plots` is a unique approach to providing a programming language with plotting
    abilities. It’s often described as a plotting *metapackage*, because `Plots` doesn’t
    do any actual plotting on its own. Rather, it orchestrates the creation of visualizations
    by calling on a choice of *backends*.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`Plots`是为编程语言提供绘图能力的独特方法。它通常被描述为一个绘图*元包*，因为`Plots`本身并不进行实际绘图。相反，它通过调用不同的*后端*来协调可视化的创建。'
- en: '**The Backend System**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**后端系统**'
- en: The backend is the package that actually draws the picture. Each backend has
    particular strengths and weaknesses, and is suitable for a different type of application.
    The job of `Plots` is to provide a unified interface to all of the backends and
    to apply a degree of intelligence in translating our plotting call into a form
    that the backend can understand. It tries to figure out what we mean and how to
    produce the plot we want.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 后端是实际绘制图形的包。每个后端都有其特定的优缺点，适用于不同类型的应用。`Plots`的工作是提供一个统一的接口，连接所有后端，并通过一定的智能将我们的绘图调用转换成后端可以理解的形式。它试图弄清楚我们的意图，并生成我们想要的图形。
- en: The advantage of using a plotting metapackage is that we can change the backend
    used in a program without having to change the plotting commands. During research,
    we may want to have a simulation code produce rough plots directly in the terminal
    or 3D plots that we can rotate with the mouse. Later, we may want to run the simulation
    again, but this time save publication-quality plots to disk. With the `Plots`
    system, we can accomplish that by simply changing one line of code that selects
    a different backend.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用绘图元包的优势在于，我们可以在程序中更换后端，而无需更改绘图命令。在研究过程中，我们可能希望让一个仿真代码直接在终端中生成粗略图，或者生成可以用鼠标旋转的
    3D 图。后来，我们可能希望再次运行仿真，但这次将高质量的图表保存到磁盘上。通过`Plots`系统，我们只需更改一行选择不同后端的代码即可实现这一点。
- en: Some of `Plots`’s backends are automatically installed when we install the package,
    but we’ll need to install others manually, as separate packages (these are subject
    to change, but we’ll be prompted to install a missing backend when we try to use
    it). When we `add` the `Plots` package, one backend that always comes along for
    the ride is the default backend. Recently this default has been `GR`, a reasonably
    fast and featureful plotting engine. To see the list of available backends, execute
    the backends() function in the REPL. To see the currently active backend, execute
    the backend() function.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一些`Plots`的后端在我们安装包时会自动安装，但我们需要手动安装其他一些后端，作为单独的包（这些可能会发生变化，但当我们尝试使用某个后端时，会提示我们安装缺失的后端）。当我们`add``Plots`包时，一个总是随之安装的后端是默认后端。最近，默认后端是`GR`，它是一个相当快速且功能丰富的绘图引擎。要查看可用后端的列表，可以在
    REPL 中执行`backends()`函数。要查看当前激活的后端，可以执行`backend()`函数。
- en: To activate a backend, we use the appropriate name that `backends()` returns
    to form a function and simply call it. If it’s installed, the function responds
    by confirming the name of the package. If not, we’ll get an error message explaining
    that we need to `add` it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活一个后端，我们使用`backends()`返回的适当名称来构建一个函数并简单地调用它。如果它已安装，函数将通过确认包的名称来响应。如果没有，我们将收到一条错误消息，解释我们需要`add`它。
- en: 'Here is part of a REPL session showing the process:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是显示该过程的部分 REPL 会话：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Asking for available backends ➊ returns a list in the form of a `Vector` of
    `Symbol`s, indicated by the leading colons. “Symbols and Metaprogramming” on [page
    167](ch06.xhtml#ch06lev3) will explain the `Symbol` data type, but for now, think
    of it as a string.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请求可用后端 ➊ 返回一个`Symbol`类型的`Vector`列表，符号前有冒号。在[第167页](ch06.xhtml#ch06lev3)的“符号与元编程”部分将解释`Symbol`数据类型，但现在，可以将其视为字符串。
- en: Asking for the current backend ➋ returns `Plots.GRBackend()`. The multiple names
    for each backend is somewhat confusing, as the capitalized form used to refer
    to a package differs from the lowercase form used to activate it. The form that
    `backend()` returns isn’t used for anything.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请求当前后端 ➋ 返回`Plots.GRBackend()`。每个后端的多个名称有些令人困惑，因为用于引用包的首字母大写形式与用于激活它的小写形式不同。`backend()`返回的形式没有被用于任何操作。
- en: The next move is to make `UnicodePlots` the current backend ➌; the operation
    was confirmed. Then we change our mind and decide to plot with HDF5, but our attempt
    to switch to it gives us an error because it’s not in the load path. Apparently
    we never added it to the environment. After adding HDF5 in package mode ➍, we
    switch to it and call `backend()` to confirm.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将`UnicodePlots`设为当前后端 ➌；操作已确认。然后我们改变主意，决定使用 HDF5 进行绘图，但我们尝试切换到它时出现错误，因为它不在加载路径中。显然，我们从未将其添加到环境中。在将
    HDF5 以包模式添加 ➍ 后，我们切换到它并调用`backend()`进行确认。
- en: The package system doesn’t consider the various backends to be dependencies
    of `Plots`. This was a deliberate choice to spare users from having to install
    all of the backends when installing `Plots`, as there are many of them, and most
    users will need only a modest subset. This creates occasional incompatibilities,
    however, as `Plots` and its various backends evolve, since the package system
    cannot automatically keep them in sync. If something doesn’t work, try a different
    backend if possible; otherwise, search the web and the resources in “Further Reading”
    on [page 121](ch04.xhtml#fur4) for a resolution.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理系统并不将各种后端视为`Plots`的依赖项。这是一个故意的选择，目的是避免用户在安装`Plots`时不得不安装所有后端，因为后端非常多，大多数用户只需要一个较小的子集。然而，这也会导致偶尔的不兼容，因为`Plots`及其各种后端在发展过程中，包管理系统无法自动同步它们。如果某些功能不起作用，尽量尝试切换到另一个后端；如果不行，可以在网络上搜索或查阅[第121页](ch04.xhtml#fur4)中的“进一步阅读”资源，找到解决方案。
- en: '**Modes of Interaction with Plots**'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**与 Plots 的交互模式**'
- en: If you are following along in Pluto, you can enter each plotting command in
    a new cell and produce a sequence of figures embedded in the page. If you’re using
    the REPL, each plot should reuse the display window opened by the first, replacing
    the existing plot. If you want to close that window, use the statement `closeall()`.
    Closing it using your window manager sometimes leads to errors in the REPL, a
    known bug.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Pluto中跟随操作，可以在新的单元格中输入每个绘图命令，并在页面中嵌入一系列图形。如果你使用的是REPL，每个图形应该重用第一次打开的显示窗口，替换现有的图形。如果你想关闭该窗口，可以使用`closeall()`语句。使用窗口管理器关闭时，有时会导致REPL中的错误，这是一个已知的bug。
- en: If you’re saving plot commands in a program file, you may have noticed that
    you don’t see any output when you run it. First, you need to include the statement
    `gui()` at the point in the program where you want to display the current state
    of the plot. However, the plot window thus created will vanish when the program
    exits, perhaps so quickly that you may not be able to see the window at all. You
    need to make the program pause until you’re done admiring your plot. One way is
    to insert the `readline()` statement directly after `gui()`. This statement waits
    for input at the terminal. When you’re ready to dismiss the plot window, simply
    press RETURN and it will vanish, and the program will continue.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在程序文件中保存绘图命令，可能会注意到运行时没有任何输出。首先，你需要在程序中插入`gui()`语句，放在你希望显示当前图形状态的位置。然而，这样创建的图形窗口在程序退出时会消失，可能会快得让你根本没时间看到窗口。你需要让程序暂停，直到你欣赏完图形。一个方法是在`gui()`后直接插入`readline()`语句。这个语句会在终端等待输入。当你准备好关闭图形窗口时，只需按下回车键，它就会消失，程序继续执行。
- en: '**2D Plots**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**二维图形**'
- en: The term *2D plot* refers to a variety of visualizations involving maps between
    two variables. The basic type, a *line plot*, takes the form of a curve, or set
    of curves, for functions of a single variable, where typically the independent
    variable is represented by the horizontal x-axis and the dependent variable by
    the vertical y-axis in a rectangular coordinate system. The *polar coordinate
    plot* maps an angle to the distance from some origin, in a polar coordinate system.
    A third common type is a *parametric plot*, where both variables depend on a third
    variable, called the parameter. These three basic types, along with other varieties
    such as bar and pie charts and scatterplots, are all called *two-dimensional plots*,
    and they are all handled by the `plot()` function provided by the `Plots` package
    and understood by all of its backends.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*2D 图形*一词指的是涉及两个变量之间映射的各种可视化方式。基本类型是*线形图*，它以曲线或一组曲线的形式显示单个变量的函数，其中通常独立变量由水平x轴表示，因变量由垂直y轴表示，在矩形坐标系中。*极坐标图*将角度映射到从某个原点到达的距离，采用极坐标系。第三种常见类型是*参数图*，其中两个变量依赖于第三个变量，称为参数。这三种基本类型，以及条形图、饼图、散点图等其他变种，统称为*二维图形*，它们都由`Plots`包提供的`plot()`函数处理，并且所有后端都能理解。'
- en: For the examples in this section, any backend will work, but I suggest sticking
    with the default setup when you execute `using Plots`. This will always be a relatively
    stable and performant engine that displays color plots either in a new window
    when using the REPL, or on the page when using Pluto or VS Code. In all of the
    examples in this chapter, `using Plots` is assumed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例可以使用任何后端，但我建议在执行`using Plots`时保持默认设置。这将始终是一个相对稳定且高效的引擎，可以在使用REPL时在新窗口中显示彩色图形，或者在使用Pluto或VS
    Code时直接在页面上显示。在本章中的所有示例中，假设都使用了`using Plots`。
- en: The `plot()` function accepts arguments of various kinds, and, as mentioned
    previously, usually does what we expect. It returns a result in the form of a
    plot object. In the REPL, a notebook interface such as Pluto, or another interactive
    environment, it immediately displays the plot, unless we suppress the output by
    following the call with a semicolon. We can display the plot later with a call
    to `gui()` or by storing the plot object in a variable and simply evaluating it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot()`函数接受各种类型的参数，正如之前提到的，它通常会按预期执行。它返回一个图形对象形式的结果。在REPL、Pluto这样的笔记本界面，或其他交互式环境中，它会立即显示该图形，除非我们通过在调用后加上分号来抑制输出。我们也可以稍后通过调用`gui()`或者将图形对象存储在变量中并直接评估它来显示图形。'
- en: '***Plotting from Vectors***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***从向量绘图***'
- en: 'We can call the function with a single `Vector` argument:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用单个`Vector`参数来调用这个函数：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This plots the numbers in the `Vector`, in order, against an independent variable
    that gives their index. [Figure 4-1](ch04.xhtml#ch4fig1) shows the plot.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按顺序绘制`Vector`中的数字，并与一个给出其索引的自变量进行比较。[图 4-1](ch04.xhtml#ch4fig1)显示了这个图。
- en: '![Image](../images/ch04fig01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch04fig01.jpg)'
- en: '*Figure 4-1: Plotting a single vector*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：绘制单个向量的图*'
- en: We get a legend, which at the moment is not very informative. We’ll learn shortly
    how to adjust this, and change other things about the graph, but first let’s look
    at the different ways we can use `plot()`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个图例，目前它的信息量不大。我们稍后会学习如何调整图例，并改变图表的其他方面，但首先让我们看一下使用`plot()`的不同方法。
- en: '**NOTE**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I’ve created grayscale versions of all the examples in this chapter for printing,
    but the original color output from each plot command is available from the book’s
    supplementary website at* [https://julia.lee-phillips.org](https://julia.lee-phillips.org)*.*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*我为本章的所有示例创建了灰度版本，以便打印，但每个绘图命令的原始彩色输出可以通过本书的补充网站获得，网址是* [https://julia.lee-phillips.org](https://julia.lee-phillips.org)*。*'
- en: 'The second form supplies both *x*- and *y*-variables, with two `Vector`s:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式提供了*x*和*y*变量，使用两个`Vector`：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The result ([Figure 4-2](ch04.xhtml#ch4fig2)) shows the same *y*-values plotted
    at different horizontal locations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 结果（[图 4-2](ch04.xhtml#ch4fig2)）显示相同的*y*值在不同的水平位置上绘制。
- en: '![Image](../images/ch04fig02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch04fig02.jpg)'
- en: '*Figure 4-2: Plotting a vector versus another vector*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-2：绘制一个向量与另一个向量的关系图*'
- en: '***Plotting Functions***'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制函数***'
- en: 'To plot a function, we can supply a vector as the first argument and a second
    vector created by broadcasting the function over the first argument (see “Broadcasting”
    on [page 51](ch02.xhtml#ch02lev1sec13)):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制一个函数，我们可以将一个向量作为第一个参数，第二个向量通过将函数广播到第一个参数上来创建（参见[第51页](ch02.xhtml#ch02lev1sec13)中的“广播”部分）：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example we first create a function, `f()`, using the succinct one-line
    function definition syntax. Next we define a range and store it in x; the range
    excludes `0` to avoid the singularity there. The `plot()` command has two `Vector`
    arguments, as before. The range is instantiated into a `Vector` and the dot after
    `f()` broadcasts the function over `x`, returning a `Vector` for the dependent
    variable. [Figure 4-3](ch04.xhtml#ch4fig3) shows the result.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先使用简洁的一行函数定义语法创建一个函数`f()`。接下来我们定义一个范围并将其存储在x中；该范围排除了`0`，以避免出现奇点。`plot()`命令有两个`Vector`参数，如之前所示。该范围被实例化为一个`Vector`，`f()`后的点符号将该函数广播到`x`上，返回一个用于因变量的`Vector`。[图
    4-3](ch04.xhtml#ch4fig3)显示了结果。
- en: '![Image](../images/ch04fig03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch04fig03.jpg)'
- en: '*Figure 4-3: A plot of a function broadcast over a vector*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-3：一个在向量上广播的函数图*'
- en: We can see the plot becoming inaccurate as we approach the origin and the π`/1000`
    resolution fails to keep up with the rapid oscillations in that region.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，随着我们接近原点，图形变得不准确，π`/1000`的分辨率无法跟上该区域内快速的振荡变化。
- en: The `plot()` function and its comrades offer a convenient shorthand. Instead
    of supplying the second argument as a broadcast expression that explicitly creates
    a vector, we can simply write the name of a function, or construct an anonymous
    function. The `plot()` function will broadcast the function we name over the independent
    variable vector that we pass in the first argument.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot()`函数及其相关函数提供了一个方便的简写方式。我们可以不必显式创建一个广播表达式作为第二个参数，而只需写出函数的名称，或构造一个匿名函数。`plot()`函数会将我们指定的函数广播到我们在第一个参数中传入的自变量向量上。'
- en: In other words, we can write `plot(x, f.(x))` as simply `plot(x, f)`. If we
    had not already defined `f()`, we could insert an anonymous function directly
    as `plot(x, s -> sin(1/s))`. These three ways of calling `plot()` are all equivalent.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们可以将`plot(x, f.(x))`简化为`plot(x, f)`。如果我们没有事先定义`f()`，我们可以直接插入一个匿名函数，写作`plot(x,
    s -> sin(1/s))`。这三种调用`plot()`的方法是等价的。
- en: We can even leave out the independent variable and supply only a function name
    or an anonymous function. In this case, `plot()` will plot the function for us,
    choosing the locations of the independent variable and handling singularities
    automatically. We can supply a domain on the horizontal axis using a second and
    third argument, with default values of –5 and 5\. If we use a `Vector` of functions
    in the first argument, we’ll get a plot of all of them on the same axes. Using
    the same definition for `f`, executing `plot([sin, cos, f], -`π`,` π`)` produces
    [Figure 4-4](ch04.xhtml#ch4fig4).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以省略自变量，只提供函数名或匿名函数。在这种情况下，`plot()`会为我们绘制函数，自动选择自变量的位置并处理奇异点。我们可以使用第二和第三个参数为水平轴提供一个默认值范围，从–5到5。如果我们在第一个参数中使用一个函数的`Vector`，我们将获得所有函数在同一坐标轴上的图。使用相同的`f`定义，执行`plot([sin,
    cos, f], -π, π)`将生成[图 4-4](ch04.xhtml#ch4fig4)。
- en: '![Image](../images/ch04fig04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch04fig04.jpg)'
- en: '*Figure 4-4: Plotting three functions*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-4：绘制三个函数*'
- en: 'In this use of `plot()`, we supply the names of the functions. We’re not *calling*
    these functions, so we omit the parentheses. Plotting is a common application
    for anonymous functions (see “Creating Anonymous Functions” on [page 51](ch02.xhtml#ch02lev1sec12)).
    This is their purpose: to pass a function as an argument to another function,
    in this case `plot()`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`plot()`的用法中，我们提供了函数的名称。我们并没有*调用*这些函数，因此省略了括号。绘图是匿名函数的常见应用（详见[第51页](ch02.xhtml#ch02lev1sec12)的“创建匿名函数”）。它们的目的是：将一个函数作为参数传递给另一个函数，在此例中是`plot()`。
- en: '***Plotting Vectors of Vectors or Functions***'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制向量的向量或函数***'
- en: If we supply vectors of vectors in the first two argument positions, `plot()`
    will cycle through both arguments, reusing elements as necessary. For example,
    if we call `plot([x1, x2], [y1, y2])`, we’ll get a plot of `y1` versus `x1` and
    `y2` versus `x2`, both on the same set of axes. But if we call `plot(x1, [y1,
    y2])`, we’ll get a plot of `y1` versus `x1` and `y2` versus `x1`. If we call `plot([x1,
    x2], y1)`, we’ll see `y1` versus `x1` and `y1` versus `x2`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在前两个参数位置提供向量的向量，`plot()`会依次循环这两个参数，必要时重复使用元素。例如，如果我们调用`plot([x1, x2], [y1,
    y2])`，我们将得到`y1`与`x1`，以及`y2`与`x2`的图，两个图会显示在同一坐标轴上。但如果我们调用`plot(x1, [y1, y2])`，我们将得到`y1`与`x1`，以及`y2`与`x1`的图。如果我们调用`plot([x1,
    x2], y1)`，我们会看到`y1`与`x1`，以及`y1`与`x2`的图。
- en: We’ll get the same results if we use horizontal concatenation; in other words,
    `plot([x1, x2], [y1, y2])` produces the same plot as `plot([x1 x2],` `[y1 y2])`.
    When given `Matrix` arguments, `plot()` plots by columns. We can even call `plot([x1,
    x2], [y1 y2])`, mixing a vector of vectors with a matrix, and `plot()` will know
    what we mean and draw the same graph as in the two preceding examples.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用水平拼接，结果也会相同；换句话说，`plot([x1, x2], [y1, y2])`和`plot([x1 x2], [y1 y2])`会产生相同的图。当传入`Matrix`类型的参数时，`plot()`按列绘制。我们甚至可以调用`plot([x1,
    x2], [y1 y2])`，将一个向量的向量与矩阵混合，`plot()`会明白我们的意思，并绘制与前两个示例相同的图。
- en: 'If we use *vertical* concatenation, we will simply create longer vectors. We
    can use this to plot different functions over different ranges:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用*垂直*拼接，我们将简单地创建更长的向量。我们可以用它来绘制不同范围内的不同函数：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we join the `x` vector to itself shifted to the right by 5π
    and supply the result as the independent variable. Against that, we plot a `sin`
    function joined to the same function multiplied by a decaying exponential (note
    the use of broadcast notation throughout). [Figure 4-5](ch04.xhtml#ch4fig5) shows
    the result.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`x`向量与右移5π的自己拼接，并将结果作为自变量。然后，我们将绘制一个`sin`函数，它与相同的函数相乘并与衰减指数相结合（注意始终使用广播符号）。[图
    4-5](ch04.xhtml#ch4fig5)展示了结果。
- en: '![Image](../images/ch04fig05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch04fig05.jpg)'
- en: '*Figure 4-5: Joining vectors to model a damped oscillation*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-5：连接向量以模拟阻尼振荡*'
- en: The graph can be interpreted as an initially frictionless oscillation with damping
    applied at *x* = 5π.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该图可以解释为最初没有摩擦的振荡，在*x* = 5π时施加了阻尼。
- en: '***Displaying and Mutating***'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***显示与变换***'
- en: I mentioned earlier that we cause the display of a plot in a program file with
    the call `gui()`. But how does the `gui()` function know what plot to display?
    The plotting system maintains a *current plot* in the global namespace, along
    with other settings and state related to the display of graphics. This is convenient
    during interactive plotting, as it allows us to incrementally adjust and add things
    to the current plot by mutating it. The mutating version of `plot()` is `plot!()`,
    following the convention (see “Functions That Mutate Their Arguments” on [page
    56](ch02.xhtml#ch02lev1sec17)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，在程序文件中，我们通过调用`gui()`来显示图形。那么，`gui()`函数是如何知道显示哪个图形的呢？绘图系统在全局命名空间中维护一个*当前图形*，以及与图形显示相关的其他设置和状态。这在交互式绘图中非常方便，因为它允许我们通过变更当前图形来逐步调整和添加内容。`plot()`的变更版本是`plot!()`，符合约定（请参见[第56页](ch02.xhtml#ch02lev1sec17)中的“变更其参数的函数”部分）。
- en: 'Using mutation, we can produce [Figure 4-4](ch04.xhtml#ch4fig4) with these
    three lines:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变更操作，我们可以通过这三行代码生成[图4-4](ch04.xhtml#ch4fig4)：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `plot!()` function maintains the domain established in the first call. We
    can use the mutating form to change many aspects of the plot, in addition to adding
    curves.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot!()`函数保持首次调用时设定的范围。我们可以使用该函数的变更形式，除了添加曲线外，还能改变图形的许多其他方面。'
- en: The `plot()` and `plot!()` functions return plot objects, which we can assign
    to variables. The reason we see a plot when we call the function in the REPL or
    in a notebook is that Julia calls `gui()` automatically in interactive contexts
    whenever a plot object is returned from an expression. If we’ve assigned some
    plots to variables, anytime we want to see one, we can simply type its name in
    the REPL and press RETURN. In a program file, we can supply the plot object as
    an argument to `gui()`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot()`和`plot!()`函数返回图形对象，我们可以将它们赋值给变量。我们在REPL或笔记本中调用这些函数时看到图形，是因为Julia在交互式环境中，每当从表达式返回图形对象时，会自动调用`gui()`。如果我们将某些图形赋值给变量，每次想查看其中一个时，只需在REPL中输入其名称并按下回车键即可。在程序文件中，我们可以将图形对象作为参数传递给`gui()`。'
- en: 'If we give `plot!()` a plot object as its first argument, it will mutate that
    plot instead of the current plot. For example, if we execute `ps = plot(sin)`,
    then `ps` is a plot of the `sin()` function. A call to `plot!(ps, cos)` will do
    two things: it will mutate `ps`, adding a `cos()` curve to it, and it will return
    the result, so that the altered plot pops up on the screen. Making the same call
    using the non-mutating version, `plot()`, will display the plot with both curves,
    but won’t alter `ps`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个图形对象作为`plot!()`的第一个参数，它将变更该图形，而不是当前图形。例如，如果我们执行`ps = plot(sin)`，则`ps`是`sin()`函数的图形。调用`plot!(ps,
    cos)`将执行两件事：它将变更`ps`，向其中添加一条`cos()`曲线，并返回结果，因此修改后的图形将出现在屏幕上。使用不变更版本的`plot()`进行相同的调用，将显示包含两条曲线的图形，但不会修改`ps`。
- en: We can supply any number of plot objects as arguments to `plot()`, and it will
    arrange them automatically into a grid. See “Layouts” on [page 117](ch04.xhtml#ch04lev12)
    for details on how to get more control over this arrangement.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将任意数量的图形对象作为参数传递给`plot()`，它会自动将它们排列成一个网格。有关如何更精确地控制这种排列，请参见[第117页](ch04.xhtml#ch04lev12)中的“布局”部分。
- en: 'This REPL session creates several plots and then combines them:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个REPL会话创建了几个图形，然后将它们组合起来：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All the lines end with a semicolon except the last, where we want to see the
    plot. First we give the variable `parabola` the value of a plot object depicting
    a parabola, constructed with an anonymous function. The value of the variable
    is now a data type representing a complete plot, with axes, tick marks, and so
    on. We don’t specify a domain, so the parabola is plotted from –5 to 5.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的行都以分号结尾，除了最后一行，在这里我们希望看到图形。首先，我们将变量`parabola`赋值为一个表示抛物线的图形对象，该图形对象是通过匿名函数构建的。此时变量的值是一个数据类型，表示一个完整的图形，包含坐标轴、刻度线等内容。我们没有指定范围，因此抛物线会从-5到5绘制。
- en: Then we assign `ps` to a plot of the `sin` function, this time with a domain
    from 0 to 2π.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将`ps`赋值为`sin`函数的图形，这次设置了从0到2π的范围。
- en: Next we decide we would like `ps` to also contain a `cos` curve, so we change
    it; `plot!()` will keep the existing domain.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们决定让`ps`也包含一条`cos`曲线，因此我们进行了更改；`plot!()`将保持现有的范围。
- en: The final line creates the plot shown in [Figure 4-6](ch04.xhtml#ch4fig6).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行生成了[图4-6](ch04.xhtml#ch4fig6)中显示的图形。
- en: '![Image](../images/ch04fig06.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch04fig06.jpg)'
- en: '*Figure 4-6: Plotting four plot objects*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-6：绘制四个图形对象*'
- en: We call `plot()` with four plot-object arguments. The first and last are the
    two plot-holding variables, the second is a plot object created directly with
    a `plot()` function on the previous `f` function, and the third uses an anonymous
    function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过四个绘图对象参数调用 `plot()`。第一个和最后一个是两个绘图变量，第二个是直接通过 `plot()` 函数在之前的 `f` 函数上创建的绘图对象，第三个使用匿名函数。
- en: '***Creating Parametric Plots***'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建参数化图***'
- en: Parametric plots in the plane are also classified with 2D plots because there
    is one independent variable, now called the *parameter*. In this type of plot,
    *x* and *y* both depend on the parameter. If we pass two arguments that are both
    functions to `plot()`, it recognizes this as the signature for a parametric plot
    and produces a graph with the *x*-dependence given by the first function and the
    *y*-dependence given by the second (where, as usual, *x* is plotted on the horizontal
    axis and *y* on the vertical). We must specify the domain for the parameter with
    two additional arguments; however, there is no default as when plotting non-parametric
    functions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 平面中的参数化图也被归类为二维图，因为有一个自变量，现在称为 *参数*。在这种类型的图中，*x* 和 *y* 都依赖于参数。如果我们将两个都是函数的参数传递给
    `plot()`，它会识别出这是一个参数化图的签名，并生成一个图形，其中 *x* 的依赖关系由第一个函数给出，*y* 的依赖关系由第二个函数给出（通常，*x*
    被绘制在横轴上，*y* 被绘制在纵轴上）。我们必须通过两个附加参数来指定参数的定义域；然而，与非参数函数绘图时不同，这里没有默认值。
- en: Parametric plotting allows us to render various complex shapes and such plots
    as circles and spirals, as shown in [Figure 4-7](ch04.xhtml#ch4fig7).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化绘图使我们能够渲染各种复杂的形状，如圆和螺旋线，如 [图 4-7](ch04.xhtml#ch4fig7) 所示。
- en: '![Image](../images/ch04fig07.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch04fig07.jpg)'
- en: '*Figure 4-7: Two parametric plots*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-7：两个参数化图*'
- en: The left-hand plot is produced with the call `circle = plot(sin, cos, 0, 2`π`)`
    and the spiral in the right-hand plot is created by `spiral = plot(r -> r*sin(r),`
    `r -> r*cos(r), 0, 8`π`)`. We draw the composite figure by calling `plot(circle,`
    `spiral)`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的图形通过调用 `circle = plot(sin, cos, 0, 2`π`)` 创建，右侧的螺旋线通过 `spiral = plot(r ->
    r*sin(r), r -> r*cos(r), 0, 8`π`)` 创建。我们通过调用 `plot(circle, spiral)` 绘制复合图形。
- en: As in the case of regular function plotting, the independent variable, in this
    case the parameter, can be implicit, as in the call we used to draw the circle.
    When the functions to be plotted are too complex to allow this, as in the spiral
    example, we must employ a dummy variable, which we named `r` in this case.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规函数绘图一样，自变量（在这里是参数）可以是隐式的，正如我们绘制圆形时使用的调用。当要绘制的函数过于复杂，无法允许这种情况时，如螺旋线示例所示，我们必须使用一个虚拟变量，在本例中我们命名为
    `r`。
- en: '***Making Polar Plots***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***制作极坐标图***'
- en: A polar plot uses the conventional polar coordinate system rather than a rectangular
    coordinate system. The independent variable is the angle, measured counterclockwise
    from the horizontal axis, and the dependent variable is the distance from the
    origin.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 极坐标图使用常规的极坐标系，而不是矩形坐标系。自变量是角度，从水平轴开始逆时针测量，因变量是距离原点的距离。
- en: '[Figure 4-8](ch04.xhtml#ch4fig8) shows two simple plots in polar coordinates.
    The `plot()` function renders the coordinate grid to reflect the symmetry of the
    polar geometry.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-8](ch04.xhtml#ch4fig8) 显示了两个简单的极坐标图。`plot()` 函数呈现坐标网格，以反映极坐标几何的对称性。'
- en: '![Image](../images/ch04fig08.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch04fig08.jpg)'
- en: '*Figure 4-8: Two polar plots*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-8：两个极坐标图*'
- en: 'We created the plot on the left with `plot(0:2`π`/500:2`π`, t -> 1 + 0.2*sin(8t);
    proj=:polar)` and the spiral on the right with `plot(0:8`π`/200:8`π`, t -> t;
    proj=: polar)`. The first arguments in these calls are arrays of angular coordinates,
    and the second arguments are functions mapping the angle to the distance from
    the origin, using `t` as a dummy variable. The argument `proj=:polar` tells `plot()`
    to make a polar plot. This is a keyword argument, as explained in “Optional and
    Keyword Arguments” on [page 96](ch04.xhtml#ch04lev5).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `plot(0:2`π`/500:2`π`, t -> 1 + 0.2*sin(8t); proj=:polar)` 创建了左侧的图形，通过
    `plot(0:8`π`/200:8`π`, t -> t; proj=:polar)` 创建了右侧的螺旋线。这些调用中的第一个参数是角度坐标数组，第二个参数是将角度映射到距离原点的函数，使用
    `t` 作为虚拟变量。参数 `proj=:polar` 告诉 `plot()` 生成极坐标图。这是一个关键字参数，正如在 [第96页](ch04.xhtml#ch04lev5)
    的“可选和关键字参数”部分所解释的那样。
- en: '***Making Scatterplots***'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***制作散点图***'
- en: 'The 2D plots we’ve seen so far draw a continuous line through a set of points.
    Sometimes we need to plot a collection of dots or other markers, each at a particular
    (*x*, *y*) position: a *scatterplot*. The `scatter()` function works identically
    to the `plot()` function, but it draws point collections rather than curves.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的二维图形通过一组点绘制了一条连续的线。有时我们需要绘制一组点或其他标记，每个标记位于特定的(*x*, *y*)位置：*散点图*。`scatter()`函数与`plot()`函数的工作方式相同，但它绘制的是点集而不是曲线。
- en: 'As an example application, suppose we wanted to visualize the output of the
    iterated map:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个示例应用，假设我们想要可视化迭代映射的输出：
- en: '![Image](../images/math95.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/math95.jpg)'
- en: 'This simple map produces a fascinating variety of patterns with an unpredictable
    dependence on *a*. The Julia version is:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的映射产生了多种迷人的模式，且依赖于*a*的关系是不可预测的。Julia版本如下：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'I’ve named it after the common nickname for the map: the *gingerbread man*.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我将它命名为映射的常见别名：*姜饼人*。
- en: 'We’ll store the sequence of values in two vectors, `x` and `y`, initialized
    with the starting coordinates, and iterate 4,000 times:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将值的序列存储在两个向量`x`和`y`中，初始化为起始坐标，并迭代4000次：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The listing uses a form of *destructuring* ➊. The `ginger()` function returns
    a tuple with its first member stored in `x2` and its second in `y2`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该列表使用了一种*解构*形式➊。`ginger()`函数返回一个元组，其第一个成员存储在`x2`中，第二个成员存储在`y2`中。
- en: After running this loop, we can see what’s in `x` and `y` with a scatterplot.
    The call `scatter(x, y; ms=0.5, legend=false)` produces the plot shown in [Figure
    4-9](ch04.xhtml#ch4fig9).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个循环后，我们可以通过散点图查看`x`和`y`的内容。调用`scatter(x, y; ms=0.5, legend=false)`会生成[图4-9](ch04.xhtml#ch4fig9)所示的图形。
- en: '![Image](../images/ch04fig09.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch04fig09.jpg)'
- en: '*Figure 4-9: The gingerbread man iterated map*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-9：姜饼人迭代映射*'
- en: In the call to `scatter()`, after the `x` and `y` arguments, we add something
    new after a semicolon. These two *optional keyword arguments* affect the plot’s
    appearance, as explained in the next section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在对`scatter()`的调用中，`x`和`y`参数后，我们在分号后添加了新内容。这两个*可选关键字参数*影响图形的外观，详细内容将在下一节中解释。
- en: '**Optional and Keyword Arguments**'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**可选和关键字参数**'
- en: 'In a function definition, we can supply default values for arguments. Doing
    so makes those arguments *optional*, as the user can call the function without
    using them:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数定义中，我们可以为参数提供默认值。这样做使这些参数变为*可选*，因为用户可以不使用它们就调用函数：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, the definition of `g()` includes the default value of `2` for
    `y`. If we call it with no second argument, it returns `x + 2`. When we do supply
    a second argument, it uses that instead.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`g()`的定义包括了`y`的默认值`2`。如果我们调用它时没有第二个参数，它将返回`x + 2`。当我们提供第二个参数时，它将使用该参数。
- en: So far we’ve learned how to define and call functions with *positional arguments*.
    Values are assigned based on the order in which we put them in the argument list
    when calling the function, whether they’re optional or not.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何定义和调用带有*位置参数*的函数。无论这些参数是否可选，值的分配是根据我们在调用函数时在参数列表中的顺序来确定的。
- en: 'Julia also has *keyword arguments*, identified by name rather than position.
    Unlike some other languages, we must make a distinction when defining a function
    between its positional and keyword arguments; we separate them with a semicolon,
    as in this example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 也有*关键字参数*，这些参数通过名称而非位置来识别。与其他一些语言不同，在定义函数时，我们必须区分位置参数和关键字参数；我们用分号分隔它们，正如这个例子所示：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here we define `p()` to have one positional argument and one keyword argument,
    named `y`, with the default value of `2`. We can call `p()` omitting the keyword
    argument ➊, because the default makes it optional. If we supply two positional
    arguments, that returns an error because the function takes only one. Make sure
    you understand the difference between the functions `g()` and `p()`: they differ
    only in their function signatures.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了`p()`，它有一个位置参数和一个名为`y`的关键字参数，默认值为`2`。我们可以省略关键字参数➊调用`p()`，因为默认值使其成为可选项。如果我们提供两个位置参数，将会返回一个错误，因为该函数只接受一个位置参数。确保理解`g()`和`p()`函数的区别：它们仅在函数签名上有所不同。
- en: '**NOTE**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When calling a function we have the option to use a comma instead of a semicolon
    because there’s no chance of ambiguity; however, the semicolon is required in
    function definitions.*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*在调用函数时，我们可以选择使用逗号代替分号，因为没有歧义的可能；然而，在函数定义中，分号是必需的。*'
- en: The plotting functions in the `Plots` ecosystem use positional arguments for
    data or functions and keyword arguments for setting plot options. Because all
    the plot options have default values, we haven’t had to use them until now.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Plots`生态系统中的绘图函数使用位置参数来传递数据或函数，使用关键字参数来设置绘图选项。由于所有绘图选项都有默认值，直到现在我们都没有必要使用它们。'
- en: '**Basic Plot Settings**'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**基础绘图设置**'
- en: To adjust a plot’s appearance, we use keyword arguments. There are four components
    that can make up a visualization made with the `Plots` package, and each one has
    a collection of settings that applies to it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要调整绘图的外观，我们使用关键字参数。使用`Plots`包创建的可视化包含四个组件，每个组件都有一组适用的设置。
- en: These four components are *plot*, *subplot*, *axis*, and *series*. Plots can
    contain subplots, and either of those can contain axes or series.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个组件是*绘图*、*子图*、*轴*和*系列*。绘图可以包含子图，而每个子图又可以包含轴或系列。
- en: The overall illustration is called the plot; it contains other plots, the subplots,
    when there are more than one, as in [Figure 4-6](ch04.xhtml#ch4fig6). Settings
    such as an overall title and background color apply to the plot.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 整体插图被称为绘图；它包含其他子图，若有多个子图，则类似于[图 4-6](ch04.xhtml#ch4fig6)。如总体标题和背景色这类设置适用于整个绘图。
- en: Within a plot, each subplot can have its own title, background color, margin,
    and many other settings.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个绘图中，每个子图可以有自己的标题、背景色、边距以及其他许多设置。
- en: The actual curves or other visualizations of functions or data are the series,
    and a subplot can contain many series.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的曲线或其他函数或数据的可视化是系列，子图可以包含多个系列。
- en: Each subplot contains an axis object. Its settings determine such things as
    whether the coordinate axes are drawn with arrows, the color of tick labels, or
    the numbers on the coordinate axes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子图包含一个轴对象。其设置决定了是否在坐标轴上绘制箭头、刻度标签的颜色、坐标轴上的数字等内容。
- en: For the most part, we can simply use the appropriate keyword to set the desired
    *attribute* of our visualization, and the plotting system will apply it where
    it makes sense. But when designing complicated visualizations, we sometimes need
    to target specific components.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们只需要使用合适的关键字来设置我们可视化的*属性*，然后绘图系统会在合适的地方应用它。但在设计复杂的可视化时，我们有时需要针对特定组件进行调整。
- en: 'The official plotting system documentation at [*https://docs.juliaplots.org/stable/*](https://docs.juliaplots.org/stable/)
    contains the complete list of attributes for all components, as well as which
    attributes are supported by which backends. The following list provides the most
    important ones and gives examples of their effects:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 官方绘图系统文档在[*https://docs.juliaplots.org/stable/*](https://docs.juliaplots.org/stable/)中包含了所有组件的完整属性列表，以及哪些属性被哪些后端支持。以下列表提供了最重要的属性，并举例说明它们的效果：
- en: '**Titles**'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**标题**'
- en: 'Overall title: `plot_title`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '总体标题: `plot_title`'
- en: 'Title for subplot: `title`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '子图标题: `title`'
- en: 'Title for legend: `legendtitle`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '图例标题: `legendtitle`'
- en: '**Other labels**'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**其他标签**'
- en: 'Legend text: `label`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '图例文本: `label`'
- en: 'Legend existence and position: `legend`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '图例存在与位置: `legend`'
- en: 'Axis labels: `[x,y]guide`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '轴标签: `[x,y]guide`'
- en: 'Label anywhere: `annotation=(x, y, "Text")`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在任意位置标注: `annotation=(x, y, "Text")`'
- en: '**Font colors**'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**字体颜色**'
- en: 'Overall title: `plot_titlefontcolor`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '总体标题: `plot_titlefontcolor`'
- en: 'Subplot title: `titlefontcolor`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '子图标题: `titlefontcolor`'
- en: 'Legend: `legendfontcolor`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '图例: `legendfontcolor`'
- en: 'Axis labels: `[x,y]guidefontcolor`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '轴标签: `[x,y]guidefontcolor`'
- en: '**Area colors**'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**区域颜色**'
- en: 'Margin area: `background_outside`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '边距区域: `background_outside`'
- en: 'Plot area only: `background_inside`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '仅绘制图形区域: `background_inside`'
- en: '**Curves**'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**曲线**'
- en: 'Line color: `lc`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '线条颜色: `lc`'
- en: 'Line width: `lw`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '线条宽度: `lw`'
- en: 'Line style: `ls`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '线条样式: `ls`'
- en: '**Scatterplots**'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**散点图**'
- en: 'Marker shape: `shape`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '标记形状: `shape`'
- en: 'Marker color: `mc`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '标记颜色: `mc`'
- en: 'Marker size: `ms`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '标记大小: `ms`'
- en: '**Contour plots**'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**等高线图**'
- en: 'Give contours labels (Boolean): `clabels`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '为等高线添加标签（布尔值）: `clabels`'
- en: 'Contour levels: `levels`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '等高线等级: `levels`'
- en: '**Axes and ticks**'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**轴与刻度**'
- en: 'Reverse axis (Boolean): `[x,y]flip`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '反转轴（布尔值）: `[x,y]flip`'
- en: 'Rotation of tick labels: `[x,y]rotation`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '刻度标签旋转: `[x,y]rotation`'
- en: 'Draw axis: `showaxis [x,y]ticks`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '绘制轴线: `showaxis [x,y]ticks`'
- en: 'Frame style: `framestyle`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '框架样式: `framestyle`'
- en: '**Grid**'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**网格**'
- en: 'Draw a grid (Boolean): `grid`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '绘制网格（布尔值）: `grid`'
- en: 'Gridline opacity: `gridalpha [0,1]`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '网格线透明度: `gridalpha [0,1]`'
- en: 'Gridline style: `gridstyle`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '网格线样式: `gridstyle`'
- en: '**Coordinate system**'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**坐标系统**'
- en: 'Use polar coordinates: `:proj=polar`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用极坐标: `:proj=polar`'
- en: '**Sizes and margins**'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**尺寸与边距**'
- en: 'Margin around subplot: `[left,right,top,bottom]margin`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '子图的边距: `[left,right,top,bottom]margin`'
- en: 'Overall plot size: `sizes(a, b)` (in px)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '总体绘图大小: `sizes(a, b)`（单位：像素）'
- en: 'Subplot aspect ratio: `ratio`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子图纵横比：`ratio`
- en: Each of the keywords in these lists has a set of abbreviations and alternative
    spellings, all listed in the official documentation. I’ve picked one version in
    each case; it’s not always the briefest alternative, but a choice designed to
    be memorable and to avoid confusion.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些列表中的每个关键字都有一组缩写和替代拼写，所有这些都在官方文档中列出。我为每个案例选择了一个版本；它并不总是最简短的替代方案，而是一个设计上便于记忆并避免混淆的选择。
- en: The purposes of a few of these settings will not be clear until we discuss them
    later, but I’ve listed them all here for easy reference.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些设置的目的，在我们稍后讨论之前可能不太明确，但我已经将它们都列在这里，供大家方便参考。
- en: '***Font Attributes***'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字体属性***'
- en: To form the keyword for setting a font attribute such as the font size or family,
    look up the corresponding name for setting the font color in the attribute list
    shown earlier, and substitute the desired attribute, such as `fontsize` or `fontfamily`
    in place of `fontcolor`. For example, to make the plot title have a size of 30pt,
    use the setting `plot_titlefontsize=30`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要形成设置字体属性（如字体大小或字体家族）的关键字，可以查找前面列出的字体颜色设置对应的名称，并用所需的属性（如 `fontsize` 或 `fontfamily`）替换
    `fontcolor`。例如，要使图表标题的字体大小为 30pt，可以使用设置 `plot_titlefontsize=30`。
- en: The font *families* are dependent on which backend is in use. A list for the
    GR backend is at [*https://gr-framework.org/fonts.html*](https://gr-framework.org/fonts.html).
    Some of the more useful families, which also may be available in other backends,
    are Times (Roman, Italic, Bold), Courier, Bookman, DejaVu Sans, and Computer Modern.
    Supply the setting as a string. If we set the attribute `fontfamily`, that will
    apply to all or most of the text on the plot. For example, to get the ticks, axis
    labels, and other annotations in Computer Modern, but the title in Times, we’d
    call `plot(...; fontfamily="Computer Modern", legendfontfamily="Times")`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 字体*家族*取决于使用的后端类型。GR 后端的字体列表请参见 [*https://gr-framework.org/fonts.html*](https://gr-framework.org/fonts.html)。一些常用的字体家族（也可能在其他后端中可用）包括
    Times（Roman、Italic、Bold）、Courier、Bookman、DejaVu Sans 和 Computer Modern。将设置作为字符串提供。如果我们设置
    `fontfamily` 属性，它将应用于图表上的所有或大多数文本。例如，为了让刻度线、坐标轴标签和其他注释使用 Computer Modern 字体，但标题使用
    Times 字体，我们可以使用 `plot(...; fontfamily="Computer Modern", legendfontfamily="Times")`。
- en: If we mutate a plot that contains subplots, and we’re adding or changing attributes
    that apply to subplots, we must specify which subplot to mutate, unless we want
    our changes to apply to all of them. This is the purpose of the `subplot` keyword.
    Set it to an integer indexing the subplots as they appear in the `plot()` statement.
    For example, for two graphs displayed side by side with `plot(p1, p2)`, we can
    put a label on the horizontal axis of `p2` with `plot`!(`; xguide` `="Time", subplot=2)`.
    Without the `subplot` keyword, both plots would get the label.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们修改一个包含子图的图表，并且我们正在添加或更改适用于子图的属性，那么我们必须指定要修改的子图，除非我们希望更改应用于所有子图。这就是 `subplot`
    关键字的作用。将其设置为整数，索引 `plot()` 语句中按顺序出现的子图。例如，对于两个并排显示的图表 `plot(p1, p2)`，我们可以通过 `plot`!(`;
    xguide` `="Time", subplot=2)`) 在 `p2` 的横轴上添加标签。如果没有 `subplot` 关键字，两个图表都会得到标签。
- en: '***The Frame Styles***'
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***框架样式***'
- en: The `framestyle` setting determines the type of axis. [Figure 4-10](ch04.xhtml#ch4fig10)
    displays the six possibilities.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`framestyle` 设置决定了坐标轴的类型。[图 4-10](ch04.xhtml#ch4fig10)展示了六种可能的选择。'
- en: '![Image](../images/ch04fig10.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch04fig10.jpg)'
- en: '*Figure 4-10: The six possible frame styles*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-10：六种可能的框架样式*'
- en: We set the attribute to the symbol version of the term printed on the graph.
    For example, to get the style in the lower-left corner, we’d use the setting `framestyle=:zerolines`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将属性设置为图表中显示的符号版本。例如，要获取左下角的样式，我们可以使用设置 `framestyle=:zerolines`。
- en: '**Working with Plot Settings**'
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**处理绘图设置**'
- en: Now we can understand the call to `scatter(x, y; ms=0.5, legend=false)` that
    produced [Figure 4-9](ch04.xhtml#ch4fig9). After the first two positional arguments,
    the arrays holding the points to be plotted, we have a semicolon indicating the
    start of the keyword arguments. The first sets a small marker size and the second
    turns off the legend.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以理解 `scatter(x, y; ms=0.5, legend=false)` 的调用，它生成了[图 4-9](ch04.xhtml#ch4fig9)。在前两个位置参数之后，表示要绘制的点的数组，我们看到一个分号，表示关键字参数的开始。第一个设置了较小的标记大小，第二个关闭了图例。
- en: Let’s use some combinations of the basic attributes listed in “Basic Plot Settings”
    on [page 98](ch04.xhtml#ch04lev6) to solve some other visualization problems.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用“基础绘图设置”中列出的一些基本属性组合，来解决一些其他的可视化问题。[第 98 页](ch04.xhtml#ch04lev6)。
- en: '***Aspect Ratio and Title Font Size***'
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***宽高比和标题字体大小***'
- en: 'The following program creates a simple plot with two subplots displaying a
    circle and a parabola:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序创建一个简单的图表，包含两个子图，分别显示圆形和抛物线：
- en: '[PRE11]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here we use the `ratio` keyword to set the aspect ratio in the first line. You
    may have noticed that what is supposed to be a circle in [Figure 4-7](ch04.xhtml#ch4fig7)
    is rendered as a noncircular ellipse. The default size of Julia’s plots is not
    square, but is instead longer than it is tall, so the circle is stretched horizontally.
    If it matters, as it does in this case, we can use `ratio` to fix the problem.
    We also turned off the grid and ticks on this plot.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`ratio`关键字在第一行设置宽高比。你可能已经注意到，在[图 4-7](ch04.xhtml#ch4fig7)中本应是圆形的图像被渲染成了一个非圆形的椭圆。Julia
    图表的默认大小不是正方形，而是横向比纵向长，因此圆形被横向拉伸。如果这很重要（如本例中所示），我们可以使用`ratio`来解决这个问题。我们还关闭了该图的网格和刻度。
- en: The default grid in most backends is quite light, so we made it more prominent
    by increasing the `gridalpha` in the plot of the parabola. The default for this
    is `0.1`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数后端的默认网格比较轻，所以我们通过增加抛物线图中的`gridalpha`值使其更加突出。默认值为`0.1`。
- en: The last line creates the combined plot with an overall title set a little larger
    than the default. [Figure 4-11](ch04.xhtml#ch4fig11) shows the result.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行创建了一个组合图，设置了比默认值稍大的整体标题。[图 4-11](ch04.xhtml#ch4fig11)展示了结果。
- en: '![Image](../images/ch04fig11.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch04fig11.jpg)'
- en: '*Figure 4-11: A plot with two subplots*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-11：包含两个子图的图表*'
- en: To get more space between the two subplots, we can, for example, set a `rightmargin`
    on the left subplot. Before setting margins, execute using Plots .PlotMeasures,
    which lets us use literal dimensions in margin settings; for example, `rightmargin=10mm`.
    Other available dimensions are `inch`, `cm`, `px`, and `*pt*`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在两个子图之间增加间距，我们可以例如为左侧子图设置`rightmargin`。在设置边距之前，使用`Plots .PlotMeasures`命令，它允许我们在边距设置中使用实际尺寸；例如，`rightmargin=10mm`。其他可用的单位包括`inch`、`cm`、`px`和`*pt*`。
- en: '**NOTE**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The* plot_title *is a recent addition to the plotting system, and its implementation
    is incomplete. If we choose larger font sizes for the title, it will overlap the
    titles of the subplots, and there is no straightforward way to fix that.*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*plot_title*是绘图系统中的一个新功能，它的实现还不完整。如果我们选择更大的标题字体，标题将与子图标题重叠，而且没有直接的方法解决这个问题。'
- en: '***Labels and Legend Positioning***'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***标签和图例位置***'
- en: 'For our next example, let’s make a plot of *x*^(*n*) for a few values of *n*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，让我们绘制*x*^(*n*)在一些*n*值下的图表：
- en: '[PRE12]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First we’ll clear any existing plots with an empty `plot()` command, and then
    mutate the empty plot once for each function. Since the `for` loop doesn’t return
    a result, we won’t see anything until the final call after the loop, which simply
    makes some plot settings. In the plotting statements, the `label` setting defines
    the text associated with that plot in the legend. It expects a string (or symbol),
    but can convert the integer `n`. The `lw` setting makes the lines thicker than
    the default. The `ls` setting is for the line style. It can take the values `:auto`,
    `:solid`, `:dash`, `:dot`, `:dashdot`, or `:dashdotdot`. The option used here,
    `:auto`, cycles through the other five styles, reusing them if the plot has more
    than five curves. It’s a good choice for print when we can’t use color. [Figure
    4-12](ch04.xhtml#ch4fig12) shows the results.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用一个空的`plot()`命令清除任何现有的图表，然后针对每个函数依次更新空白图表。由于`for`循环没有返回结果，因此我们在循环后的最终调用之前看不到任何内容，最终调用仅仅是进行了一些图表设置。在绘图语句中，`label`设置定义了与该图表相关的图例文本。它期望的是一个字符串（或符号），但可以将整数`n`转换为字符串。`lw`设置使线条比默认值更粗。`ls`设置用于设置线条样式。它可以取值`:auto`、`:solid`、`:dash`、`:dot`、`:dashdot`或`:dashdotdot`。这里使用的选项`:auto`会循环使用其他五种样式，如果图表有超过五条曲线，则重复使用样式。当我们无法使用颜色时，这是一个适合打印的好选择。[图
    4-12](ch04.xhtml#ch4fig12)展示了结果。
- en: '![Image](../images/ch04fig12.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch04fig12.jpg)'
- en: '*Figure 4-12: The five line styles*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-12：五种线条样式*'
- en: The final `plot()` statement sets `legend` to place it at the top left of the
    plot. We can use other similar positioning symbols, optionally preceded by `outer`
    to place the legend outside the axes. For more precise positioning we can use
    an `(x, y)` tuple specifying the coordinates of the legend box. Finally, we can
    set `legend=false` to omit the legend.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`plot()`语句设置了`legend`，将图例放置在图表的左上角。我们可以使用其他类似的定位符号，也可以在前面加上`outer`，将图例放置在坐标轴外部。为了更精确的定位，我们可以使用`(x,
    y)`元组来指定图例框的坐标。最后，我们可以设置`legend=false`来省略图例。
- en: '***LaTeX Titles and Label Positioning by Data***'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***LaTeX 标题与数据驱动的标签位置***'
- en: Let’s plot the same functions with a different style of labeling. We’ll use
    annotations to place labels indicating each exponent on top of each corresponding
    curve, as shown in [Listing 4-1](ch04.xhtml#ch4lis1).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用不同的标签样式绘制相同的函数。我们将使用注释将每个指数的标签放置在对应曲线的顶部，如[示例 4-1](ch04.xhtml#ch4lis1)所示。
- en: '[PRE13]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 4-1: Using calculated labels and a LaTeX title*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 4-1：使用计算得到的标签和 LaTeX 标题*'
- en: Here we calculate coordinates for each of the five labels within the loop. The
    x-coordinate increases to the right with the exponent, to space out the labels
    so they don’t overlap. The label’s y-coordinate ➊ is the same function of *x*
    as the curves we’re plotting, to ensure that they lie precisely on the curves
    that they’re labeling.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为循环中的五个标签计算坐标。x 坐标随着指数的增大向右增加，以便将标签分开，避免重叠。标签的 y 坐标 ➊ 是与我们绘制的曲线相同的 *x*
    函数，以确保它们精确地位于所标记的曲线上。
- en: The setting for the `annotation` has `n`, a variable holding an integer, where
    there should be a `String`, but the `plot()` function converts it for us.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`annotation` 设置中的 `n` 是一个包含整数的变量，原本应该是一个 `String`，但 `plot()` 函数会帮我们转换它。'
- en: 'We then import a package we haven’t seen before: `LaTeXStrings` (note the capitalization)
    lets us put math in our plot titles and annotations using LaTeX syntax. Even non-LaTeX
    users may still need equations in graphs occasionally, and LaTeX’s math syntax
    is straightforward. Check “Further Reading” on [page 121](ch04.xhtml#fur4) for
    a link to a guide. After importing this package, we can prepend `L` to any string
    to turn it into a LaTeX string. In a context where typesetting is possible, such
    as in a plot, Julia will typeset the string appropriately. The entire string is
    in LaTeX math mode, where all letters are treated as mathematical symbols. Therefore,
    if we need some normal text, as we did in this example ➋, we must wrap it in a
    LaTeX command to force it to be set as such. Within these text segments, indicate
    spaces with a tilde (`~`). The plot in [Figure 4-13](ch04.xhtml#ch4fig13) shows
    the result of this REPL session.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们导入一个之前没见过的包：`LaTeXStrings`（注意大小写），它让我们可以在图表标题和注释中使用 LaTeX 语法写数学公式。即使是非 LaTeX
    用户，有时也可能需要在图表中展示公式，而 LaTeX 的数学语法简单直观。在[第121页](ch04.xhtml#fur4)的“进一步阅读”中可以找到相关指南的链接。导入这个包之后，我们可以在任何字符串前加上
    `L`，将其转化为 LaTeX 字符串。在可以排版的环境中，比如图表中，Julia 会适当地排版该字符串。整个字符串都会被放入 LaTeX 数学模式，其中所有字母都被视为数学符号。因此，如果我们需要一些普通文本，如这个例子中的
    ➋，我们必须用 LaTeX 命令将其包裹起来，强制排版为普通文本。在这些文本片段中，用波浪号（`~`）表示空格。[图 4-13](ch04.xhtml#ch4fig13)
    中展示了这个 REPL 会话的结果。
- en: '![Image](../images/ch04fig13.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch04fig13.jpg)'
- en: '*Figure 4-13: Using calculated labels and a LaTeX title*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-13：使用计算得到的标签和 LaTeX 标题*'
- en: In addition to the settings for individual plot elements, two others make larger-scale
    changes. The `thickness_scaling` setting is useful for creating a version of the
    plot with better legibility for presentation. It thickens everything, including
    tick labels. It affects the margins as well, however, and can change the positioning
    of plot elements. Setting the values between 1 and 1.7 produces useful results.
    Use values less than 1 to create a spindly version of the plot.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单个图表元素的设置外，还有两个设置会产生更大范围的变化。`thickness_scaling` 设置非常适用于创建一个在演示中更易阅读的图表版本。它会加粗所有元素，包括刻度标签。它还会影响图表的边距，并可能改变图表元素的位置。将值设置在
    1 和 1.7 之间可以得到较好的效果。使用小于 1 的值则会创建一个较瘦的图表版本。
- en: '***Regression Lines***'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***回归线***'
- en: The `smooth` setting draws a line of best fit, calculated by linear regression,
    through each curve or dataset on the plot.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`smooth` 设置会通过线性回归为图上的每条曲线或数据集绘制最佳拟合线。'
- en: 'Let’s return to the gingerbread map and, using the same initial conditions,
    calculate 20,000 iterations with *a* = 1*.*6, again storing the results in the
    `x` and `y Vector`s. We’ll make two subplots. The first will be a scatterplot
    similar to [Figure 4-9](ch04.xhtml#ch4fig9), but with a regression line showing
    the average orientation of the points. The second will plot the first 100 values
    of `x` versus iteration number, with a regression line showing the trend of a
    gradually increasing distance from the origin:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到姜饼地图，并使用相同的初始条件，计算 20,000 次迭代，设置 *a* = 1*.*6，再次将结果存储在 `x` 和 `y Vector`
    中。我们将绘制两个子图。第一个是类似[图 4-9](ch04.xhtml#ch4fig9)的散点图，但会添加一条回归线，显示点的平均方向。第二个图将绘制前
    100 个 `x` 值与迭代次数的关系，并显示一条回归线，展示距离原点逐渐增大的趋势：
- en: '[PRE14]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First we create a scatterplot of the map as before, adding the trend line with
    the setting `smooth=true`, and assign the result to `sc`. Then we plot the initial
    100 *x*-values, also with a trend line. Plotting the two subplots together with
    a title gives us [Figure 4-14](ch04.xhtml#ch4fig14).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们像之前一样创建姜饼地图的散点图，使用`smooth=true`设置添加趋势线，并将结果赋值给`sc`。然后，我们绘制初始的100个*x*值，同样添加趋势线。将这两个子图一起绘制并加上标题，就得到了[图4-14](ch04.xhtml#ch4fig14)。
- en: '![Image](../images/ch04fig14.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch04fig14.jpg)'
- en: '*Figure 4-14: Trends in the gingerbread map*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-14：姜饼地图的趋势*'
- en: As before, the `plot_title` attribute creates an overall title for the two plots.
    We wanted the plotted curve and the calculated trend line to have different styles,
    but there’s no setting for this, so we resorted to a trick, over-plotting the
    curve in a different style but without a trend line ➊.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，`plot_title`属性为两个图表创建一个总标题。我们希望绘制的曲线和计算的趋势线有不同的样式，但没有为此提供设置，因此我们采用了一个技巧，使用不同样式的曲线进行叠加绘制，但没有趋势线➊。
- en: '**Saving Plots**'
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**保存图表**'
- en: When you’re ready to save your creation to disk, call savefig(p, path) where
    p is the variable holding the visualization and path is the location where you
    would like the image file stored. The filename extension to path determines the
    format, but different backends support different types of images. PDF and PNG
    should always be available, and SVG is also widely supported.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备将创作保存到磁盘时，调用`savefig(p, path)`，其中p是保存可视化内容的变量，path是你希望存储图像文件的位置。路径中的文件名扩展名决定了格式，但不同的后端支持不同类型的图像。PDF和PNG格式应该始终可用，SVG也被广泛支持。
- en: If we omit `p`, it defaults to the current plot. A common workflow is to repeatedly
    mutate a plot, making adjustments until it’s satisfactory, and then call `savefig(`path`)`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略`p`，则默认保存当前图表。一种常见的工作流程是反复修改图表，直到满意为止，然后调用`savefig(path)`。
- en: '**Detail Insets**'
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**细节插图**'
- en: An inset plot is a small plot inside the frame of a larger one. It’s often used
    to provide a magnified view of a section of the outer plot. Julia’s plotting system
    has a built-in function for creating this type of detail inset, called `lens!()`.
    It exists only in a mutating form because the inset plot makes sense only as an
    addition to an existing plot.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 插图是一个小图，位于较大图的框架内。它通常用于提供外部图部分的放大视图。Julia的绘图系统内置了一个创建这种细节插图的函数，叫做`lens!()`。它仅以变更形式存在，因为插图只有在现有图的基础上才有意义。
- en: The first argument to `lens!()` either is an existing plot or is omitted to
    indicate the current plot. The next two arguments are vectors defining the rectangular
    region to be magnified. The required argument `inset` specifies which subplot
    gets the inset as well as the inset’s position and size. The diagram in [Figure
    4-15](ch04.xhtml#ch4fig15) shows how to use these arguments.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`lens!()`的第一个参数是现有图表，或者省略以表示当前图表。接下来的两个参数是定义要放大的矩形区域的向量。必需的参数`inset`指定哪个子图需要插图以及插图的位置和大小。[图4-15](ch04.xhtml#ch4fig15)中的示意图展示了如何使用这些参数。'
- en: '![Image](../images/ch04fig15.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch04fig15.jpg)'
- en: '*Figure 4-15: How to make an inset*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-15：如何制作插图*'
- en: '[Figure 4-15](ch04.xhtml#ch4fig15) uses a blank plot with a grid for illustration.
    The annotations “width” and “height” refer to the width and height of the outer
    plot. The complete command that created the inset is shown near the bottom of
    the plot.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-15](ch04.xhtml#ch4fig15)使用一个带网格的空白图进行说明。注释“width”和“height”指的是外部图的宽度和高度。创建插图的完整命令显示在图的底部附近。'
- en: 'As an application for `lens!()`, I constructed another instance of the gingerbread
    map, this time with *a* = 1*.*4 and 100,000 iterations to produce more detail.
    The following two lines first create the scatterplot and then add the inset:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`lens!()`的应用，我构建了另一个姜饼地图的实例，这次设置*α* = 1*.*4，并进行了100,000次迭代，以产生更多细节。接下来的两行首先创建散点图，然后添加插图：
- en: '[PRE15]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the call to `lens!()`, the settings ➊ for the `ticks` and `Framestyle` apply
    to the inset plot, while the `linecolor` and `linestyle` settings apply to the
    drawing of the magnifying glass that delineates the expanded area. A full frame
    style is a good choice for an inset plot.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`lens!()`时，设置➊用于`ticks`和`Framestyle`应用于插图，而`linecolor`和`linestyle`设置应用于绘制放大镜，后者标示出扩展区域。全框架样式是插图的一个不错选择。
- en: '[Figure 4-16](ch04.xhtml#ch4fig16) shows the result. I’ve used the inset plot
    to magnify one of the corners of the gingerbread map, showing the pattern of points
    within it.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-16](ch04.xhtml#ch4fig16)展示了结果。我使用插图图放大了姜饼地图的一个角落，显示其中的点模式。'
- en: '![Image](../images/ch04fig16.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch04fig16.jpg)'
- en: '*Figure 4-16: Using a detail inset to magnify a section of the gingerbread
    map*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-16：使用细节插图放大姜饼地图的一部分*'
- en: The setting `subplot=2` in the call that creates the inset ensures that the
    other graph settings in that call apply only to the inset, which becomes the second
    subplot. By referring to the number of the subplot, we could create an inset within
    the inset, if we were so inclined.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建插图的调用中，`subplot=2`设置确保其他图形设置仅适用于插图，这使得插图成为第二个子图。通过引用子图的编号，如果需要，我们还可以在插图中创建另一个插图。
- en: '**3D Plots**'
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3D 图形**'
- en: Several types of plots visualize a quantity that depends on two independent
    variables. When in rectangular coordinates, the dependent variable is conventionally
    called *z*, and the two independent variables are called *x* and *y*. The three
    common ways to represent such a relationship are with a surface plot, a heatmap,
    or a contour plot. Which is most effective depends on the nature of the data and
    the features we’re trying to clarify.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 几种类型的图形用来可视化依赖于两个独立变量的量。当使用矩形坐标时，依赖变量通常称为*z*，而两个独立变量称为*x*和*y*。表示这种关系的三种常见方式是：表面图、热图或等高线图。最有效的方式取决于数据的性质以及我们试图阐明的特征。
- en: '***Surface Plots***'
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***表面图***'
- en: After importing the plotting package with `using Plots`, we have access to several
    3D plotting routines. For a *surface plot*, we use the `surface()` function to
    create a perspective rendering of a 2D surface embedded in a 3D space, with the
    height and coloring of the surface indicating the *z*-value.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过`using Plots`导入绘图包后，我们可以使用几个 3D 绘图函数。对于*表面图*，我们使用`surface()`函数来创建一个2D表面嵌入在3D空间中的透视渲染图，表面的高度和着色表示*z*值。
- en: 'Here are a few additional settings that apply to surface plots:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些适用于表面图的额外设置：
- en: 'Draw a colorbar: `colorbar` (`true` or `false`)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制色条：`colorbar`（`true` 或 `false`）
- en: 'Opacity of the surface: `fillalpha`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表面不透明度：`fillalpha`
- en: 'Angle of view: `camera` (azimuth, elevation) (in degrees)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视角：`camera`（方位角，仰角）（以度为单位）
- en: 'Colorbar title: `cbtitle`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 色条标题：`cbtitle`
- en: 'Surface palette: `c`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表面调色板：`c`
- en: 'Let’s put some of these settings to use in making a surface plot of a Gaussian
    distribution of two variables. After defining a vector *x* to go from –1 to 1,
    we can use anonymous function syntax to plot the surface with the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些设置应用于绘制两个变量的高斯分布的表面图。在定义一个从-1到1的*x*向量后，我们可以使用匿名函数语法绘制表面，代码如下：
- en: '[PRE16]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We use an alpha less than 1 in order to see through the surface, and rotated
    the axis tick labels to make them easier to read and to keep them from colliding
    where the axes meet. [Figure 4-17](ch04.xhtml#ch4fig17) shows the surface plot.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用小于1的alpha值以便能够看到表面，并且旋转了轴标签，使它们更容易阅读，避免在坐标轴交汇处发生重叠。[图 4-17](ch04.xhtml#ch4fig17)展示了表面图。
- en: '![Image](../images/ch04fig17.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch04fig17.jpg)'
- en: '*Figure 4-17: A surface plot*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-17：表面图*'
- en: The `c` setting defines the palette used to color the surface. There are several
    ways to define the palette; the one used earlier, with a number of colors in a
    `Vector`, creates a palette by smoothly interpolating between them. `Gray(0)`
    is black, `Gray(1)` is white, and so on. We can also define colors with `RGB(r,
    g, b)`, where `r`, `g`, and `b` are the red, green, and blue components, also
    ranging from `0` (absent) to `1` (fully saturated). Over 600 color names are available
    as symbols, including both memorable names such as `:red` and `:blue` and meaningless
    ones such as `:seashell3` and `:oldlace`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`c`设置定义了用于给表面着色的调色板。有几种方法可以定义调色板；之前使用的那种，通过`Vector`中的多个颜色进行平滑插值来创建调色板。`Gray(0)`为黑色，`Gray(1)`为白色，依此类推。我们还可以通过`RGB(r,
    g, b)`定义颜色，其中`r`、`g`和`b`分别是红、绿和蓝的分量，范围从`0`（没有）到`1`（完全饱和）。有600多种颜色名称作为符号可用，包括易记的名称如`:red`和`:blue`，以及没有实际意义的名称如`:seashell3`和`:oldlace`。'
- en: Instead of a `Vector` of colors, we can supply a symbol giving the name of a
    predefined palette, of which there are scores listed at [*https://docs.juliaplots.org/latest/generated/colorschemes/*](https://docs.juliaplots.org/latest/generated/colorschemes/).
    The more useful ones have names such as `:blues` or `:grays` that use one hue
    and vary the saturation and lightness, but there are plenty to choose from for
    special purposes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供一个符号来指定预定义调色板的名称，而不是提供一个颜色的 `Vector`，预定义调色板有很多可以在 [*https://docs.juliaplots.org/latest/generated/colorschemes/*](https://docs.juliaplots.org/latest/generated/colorschemes/)
    中找到。常用的名称有 `:blues` 或 `:grays`，它们使用相同的色调并调整饱和度和亮度，但还有许多可供选择，适用于特殊用途。
- en: '***Heatmaps***'
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***热图***'
- en: 'A heatmap also visualizes a mapping of two independent variables to one dependent
    variable, but the values of the independent variable are indicated by a color
    or gray value. The call is similar to a surface plot, but uses the `heatmap()`
    function:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 热图也可视化将两个自变量映射到一个因变量，但自变量的值通过颜色或灰度值表示。该调用类似于表面图，但使用 `heatmap()` 函数：
- en: '[PRE17]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This call creates the heatmap shown in [Figure 4-18](ch04.xhtml#ch4fig18).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用创建了在 [图 4-18](ch04.xhtml#ch4fig18) 中显示的热图。
- en: '![Image](../images/ch04fig18.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch04fig18.jpg)'
- en: '*Figure 4-18: A heatmap of a 2D Gaussian*'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-18：二维高斯热图*'
- en: Color palettes for heatmaps work the same way as for surface plots.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 热图的颜色调色板与表面图相同。
- en: '***Contour Plots***'
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***等高线图***'
- en: 'Contour plots are similar to heatmaps, but they use isolines rather than color
    to indicate the values of the independent variable. Here are a few important attributes
    specific to contour plots:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 等高线图类似于热图，但它们使用等高线而非颜色来表示自变量的值。以下是一些与等高线图特定相关的重要属性：
- en: 'Number of contours or specific contour levels: `levels` (integer or vector
    of levels)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等高线数量或特定的等高线级别：`levels`（整数或级别向量）
- en: 'Draw contour labels (Boolean): `clabels`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制等高线标签（布尔值）：`clabels`
- en: 'Fill areas between contours (Boolean): `fill`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充等高线之间的区域（布尔值）：`fill`
- en: 'If we supply an integer for `levels`, Julia will draw that many contours. If
    we also set `clabels` to `true`, it will label the contour lines with the values
    they represent. Unfortunately, these numerical labels are printed with too many
    digits and often become crowded. If we set `levels` to a `Vector` of numbers,
    the plot will have contours at just those values, and their labels will be printed
    using the same precision used for the `levels`. The following example shows this
    use of `levels` and `clabels`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为 `levels` 提供一个整数，Julia 将绘制相应数量的等高线。如果我们还将 `clabels` 设置为 `true`，它将使用表示的值为等高线添加标签。不幸的是，这些数值标签通常打印出过多的数字，导致标签重叠。如果我们将
    `levels` 设置为一个数字 `Vector`，则图形将在这些指定值处绘制等高线，并且它们的标签将使用与 `levels` 相同的精度。以下示例展示了如何使用
    `levels` 和 `clabels`：
- en: '[PRE18]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This call uses the same `x` vector and plots the same function as the surface
    plot and heatmap examples shown in [Figures 4-17](ch04.xhtml#ch4fig17) and [4-18](ch04.xhtml#ch4fig18).
    The result, in [Figure 4-19](ch04.xhtml#ch4fig19), shows the labels with one digit
    of precision.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用使用相同的 `x` 向量，并绘制与图表 4-17 ([ch04.xhtml#ch4fig17](ch04.xhtml#ch4fig17)) 和图表
    4-18 ([ch04.xhtml#ch4fig18](ch04.xhtml#ch4fig18)) 中的表面图和热图示例相同的函数。结果如[图 4-19](ch04.xhtml#ch4fig19)所示，标签精度为一位数字。
- en: '![Image](../images/ch04fig19.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch04fig19.jpg)'
- en: '*Figure 4-19: A labeled contour plot*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-19：带标签的等高线图*'
- en: The `:box framestyle` works well with contour plots. Eliminating the color bar
    is also a good idea. We can color the lines by setting a `c`, but this doesn’t
    always work well with every backend. If we find stray colors creeping into the
    contour lines, we can fix it with `c=:black`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`:box framestyle` 与等高线图非常配合。去除颜色条也是一个好主意。我们可以通过设置 `c` 来为线条上色，但这并不总是适用于每个后端。如果发现颜色溢出到等高线中，可以通过
    `c=:black` 来修复。'
- en: Line styles such as `:dot` work, but not `:auto`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`:dot` 等线条样式有效，但 `:auto` 无效。'
- en: '**NOTE**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When using filled contours with some backends, including* GR*, and manually
    set contour levels, we must include a level greater than or equal to the maximum
    of the data, or the graph will not be properly drawn.*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*当使用某些后端（包括*GR*）并手动设置等高线级别时，必须包括一个大于或等于数据最大值的级别，否则图形将无法正确绘制。*'
- en: The `fill` attribute, when set to `true`, adds colors between the contour lines,
    resulting in a kind of discrete heatmap with contours. The `c` attribute defines
    the palette for these colors. The `contourf()` function is an alias for `contour()`
    with `fill=true`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `fill` 属性设置为 `true` 时，会在等高线之间填充颜色，从而形成一种带有等高线的离散热图。`c` 属性定义这些颜色的调色板。`contourf()`
    函数是 `contour()` 的别名，且 `fill=true`。
- en: 'Let’s repeat the previous contour plot ([Figure 4-19](ch04.xhtml#ch4fig19)),
    but this time leave the color bar in, turn on the `fill`, and use a grayscale
    palette:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重复之前的等高线图（[图 4-19](ch04.xhtml#ch4fig19)），但这次保留颜色条，开启 `fill`，并使用灰度调色板：
- en: '[PRE19]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[Figure 4-20](ch04.xhtml#ch4fig20) shows the filled contour plot.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-20](ch04.xhtml#ch4fig20) 显示了填充等高线图。'
- en: '![Image](../images/ch04fig20.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch04fig20.jpg)'
- en: '*Figure 4-20: A filled contour plot*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-20：填充等高线图*'
- en: In this case, having both contour labels and a color bar is somewhat redundant,
    as they carry the same information, but this may make the plot easier to interpret.
    There is an art to scientific visualization in creating a result that is both
    intuitively clear and quantitatively precise.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，同时拥有等高线标签和颜色条有些多余，因为它们传达的是相同的信息，但这可能会使图表更易于解读。科学可视化的艺术就在于创造一个既直观清晰又定量精确的结果。
- en: '***3D Parametric Plots***'
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3D 参数化图***'
- en: 'Parametric plots in 3D work just as they do in 2D, but they trace a path through
    3D space, with three functions of the single parameter giving the x-, y-, and
    z-coordinates. Unlike in 2D parametric plots, we must supply three vectors, and
    it doesn’t work with functions. Here is an example:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 参数化图与 2D 中的工作方式相同，但它们在 3D 空间中绘制路径，单个参数的三个函数分别给出 x、y 和 z 坐标。与 2D 参数化图不同，我们必须提供三个向量，而且它不适用于函数。以下是一个示例：
- en: '[PRE20]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `plot()` function knows what to do when supplied with three vectors as positional
    arguments, producing the resulting 3D parametric plot shown in [Figure 4-21](ch04.xhtml#ch4fig21).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot()` 函数在接收到三个向量作为位置参数时知道该怎么做，生成的 3D 参数化图如 [图 4-21](ch04.xhtml#ch4fig21)
    所示。'
- en: '![Image](../images/ch04fig21.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch04fig21.jpg)'
- en: '*Figure 4-21: An example of a 3D parametric plot*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-21：3D 参数化图示例*'
- en: We can use the attributes for lines as for ordinary 2D plots, and set the camera
    angle as for surface plots.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像处理普通的 2D 图一样使用线条属性，并像处理表面图一样设置相机角度。
- en: '***Vector Plots***'
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***向量图***'
- en: A vector field maps every point in space to a vector, which can be represented
    by an arrow. The `Plots` package offers vector plots created with the `quiver()`
    function. Its first two arguments are `x` and `y Vector`s containing the coordinates
    of the start of the vectors. The displacements from those coordinates to the vectors’
    endpoints are stored in two other `Vector`s, placed in a `Tuple`, and assigned
    to a keyword argument also called `quiver`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 向量场将空间中的每个点映射到一个向量，这个向量可以用箭头表示。`Plots` 包提供了通过 `quiver()` 函数创建的向量图。它的前两个参数是 `x`
    和 `y Vector`，它们包含了向量起点的坐标。从这些坐标到向量端点的位移存储在另外两个 `Vector` 中，放在一个 `Tuple` 中，并分配给一个同名的关键字参数
    `quiver`。
- en: 'The following example shows how to use `quiver()`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何使用 `quiver()`：
- en: '[PRE21]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These three lines produce the vector plot in [Figure 4-22](ch04.xhtml#ch4fig22).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这三行代码生成了 [图 4-22](ch04.xhtml#ch4fig22) 中的向量图。
- en: '![Image](../images/ch04fig22.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch04fig22.jpg)'
- en: '*Figure 4-22: A vector plot using* quiver()'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-22：使用* quiver() 的向量图'
- en: The `quiver()` function accepts all the attributes for curves; here we set the
    line width to get thicker arrows.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`quiver()` 函数接受所有曲线属性；在这里我们设置线条宽度以获得更粗的箭头。'
- en: '***3D Scatterplots***'
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3D 散点图***'
- en: '`Plots` can extend scatterplots into the third dimension. One way to visualize
    a 3D distribution of some quantity is to plot a regular 3D grid of markers while
    setting some marker attribute, such as size or opacity, to a function of the quantity.
    First we need to establish the grid by making `x`, `y`, and `z` `Vector`s:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`Plots` 可以将散点图扩展到三维。可视化某个量的 3D 分布的一种方法是绘制一个常规的 3D 网格标记，同时将某个标记属性（如大小或不透明度）设置为该量的函数。首先，我们需要通过创建
    `x`、`y` 和 `z` 向量来建立网格：'
- en: '[PRE22]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will create the coordinate arrays ranging from –1 to 1.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建从 -1 到 1 的坐标数组。
- en: 'Let’s imagine a planet sitting in the center of our grid. We could plot the
    shape of the gravitational potential due to the planet by first defining a potential
    function and then using it to set the marker size:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个行星位于网格的中心。我们可以通过首先定义一个势能函数，然后使用它来设置标记大小，从而绘制由于行星产生的引力势的形状：
- en: '[PRE23]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The potential becomes large near the planet, so we need to limit the marker
    size with the `min()` function. It actually becomes infinite at (0, 0, 0), but
    Julia handles that gracefully. The result is shown in [Figure 4-23](ch04.xhtml#ch4fig23).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在行星附近，势能变得很大，因此我们需要使用 `min()` 函数限制标记的大小。实际上，在 (0, 0, 0) 处，它会变得无限大，但 Julia 会优雅地处理这个问题。结果如
    [图 4-23](ch04.xhtml#ch4fig23) 所示。
- en: '![Image](../images/ch04fig23.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch04fig23.jpg)'
- en: '*Figure 4-23: A 3D scatterplot*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-23：一个3D散点图*'
- en: We set an opacity to allow us to see through the markers. This is the same `scatter()`
    function that we used in 2D, but Julia knows what to do if we give it three positional
    arguments.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了透明度，以便能够看到标记的背后。这是我们在2D中使用的相同`scatter()`函数，但如果我们提供三个位置参数，Julia会知道该怎么做。
- en: '**Useful Backends**'
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**有用的后端**'
- en: '`GR`, the current default backend, has the merit of being fast and capable
    of producing most basic categories of visualization.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的默认后端`GR`有一个优点，就是速度快，且能够生成大多数基本类别的可视化图形。
- en: A few other backends are available for special purposes, but most of them require
    us to `add` them in the package manager before use.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他后端可供特定用途使用，但大多数都需要我们在包管理器中`add`后才能使用。
- en: '***UnicodePlots***'
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***UnicodePlots***'
- en: The `unicodeplots` backend plots directly in the terminal. It’s good for a quick
    look at some data, which it plots using characters. We can also use it to generate
    plots to paste into an email, but obviously it’s not suited to making figures
    for publication, and it can’t save plots.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`unicodeplots`后端直接在终端中绘图。它适合快速查看一些数据，用字符进行绘制。我们也可以用它生成图形，然后粘贴到电子邮件中，但显然它不适合用于生成出版用的图形，而且不能保存图形。'
- en: To produce quick plots in the terminal, first execute add UnicodePlots in package
    mode, then call unicodeplots() to activate the backend.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要在终端快速绘图，首先在包模式下执行`add UnicodePlots`，然后调用`unicodeplots()`来激活后端。
- en: The `unicodeplots` backend doesn’t support every plot type. It can make 2D plots,
    including scatterplots, but not contour or surface plots. However, `unicodeplots`
    can render colored heatmaps in the terminal.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`unicodeplots`后端不支持所有的绘图类型。它可以绘制2D图形，包括散点图，但不能绘制等高线或表面图。不过，`unicodeplots`可以在终端中呈现彩色热力图。'
- en: '***PyPlot***'
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***PyPlot***'
- en: The `pyplot` backend uses Python’s Matplotlib, so it may be a good choice for
    those already familiar with that system. Although it can sometimes be a bit slow,
    it creates better plots than the default in some cases.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyplot`后端使用Python的Matplotlib，因此对于已经熟悉该系统的人来说，它可能是一个不错的选择。尽管有时可能会稍慢，但在某些情况下，它能够生成比默认后端更好的图形。'
- en: '***PlotlyJS***'
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***PlotlyJS***'
- en: With the `plotlyjs` backend we can create interactive graphs for the web. Saving
    the plot with the *.html* file extension creates a file containing an HTML fragment
    that we can paste into a web page. The fragment loads some third-party JavaScript
    that supplies interactive controls for panning, zooming, and, for 3D plots, rotating
    in 3D space. Other forms of interactivity vary appropriately with the plot type.
    Two-dimensional plots display data values as the user hovers over the curve, and
    surface plots draw contours on the surfaces at the *z*-value of the mouse pointer.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`plotlyjs`后端，我们可以为网页创建交互式图表。将图形保存为*.html*文件扩展名时，会创建一个包含HTML片段的文件，我们可以将其粘贴到网页中。该片段加载一些第三方JavaScript，提供用于平移、缩放以及对于3D图形，旋转3D空间的交互控件。其他交互形式会根据图形类型适当变化。二维图形在用户悬停在曲线上时显示数据值，而表面图则在鼠标指针的*z*值处绘制等高线。
- en: Plotting is not at all fast, although the results look good and interaction
    is impressively responsive. Contour plots are better with `plotlyjs` than with
    `GR`, especially for colored contours, but the attributes for linewidth or linestyle
    have no effect, and manual levels don’t work.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图并不算非常快速，尽管结果看起来不错，交互也非常流畅。使用`plotlyjs`的等高线图比使用`GR`要好，特别是对于彩色等高线，但线宽或线型的属性没有效果，手动设置的等级也不起作用。
- en: When plotting from the REPL, a separate window pops up for each plot, using
    the same JavaScript interactivity as in the HTML files.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL中绘图时，每个图形都会弹出一个独立的窗口，使用与HTML文件中相同的JavaScript交互性。
- en: '***PGFPlots and PGFPlotsX***'
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***PGFPlots 和 PGFPlotsX***'
- en: I won’t say much about these, because they are useful only to those who have
    LaTeX installed and some knowledge of the LaTeX graphing system PGFPlots. Those
    who do use these systems should be aware of the two Julia interfaces to them.
    The difference between the two versions is that `PGFPlotsX`’s syntax is closer
    to what’s used directly in LaTeX. With `PGFPlots`, we can make extraordinary visualizations
    that are difficult to achieve through other means. LaTeX users who aren’t familiar
    with the system may want to acquaint themselves. This backend does depend on a
    LaTeX installation—not a trivial requirement.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会多说这些，因为它们只对那些安装了 LaTeX 并且对 LaTeX 图形系统 PGFPlots有一定了解的人有用。使用这些系统的人应该知道有两个 Julia
    接口可以使用。两个版本的区别在于，`PGFPlotsX` 的语法更接近 LaTeX 中直接使用的语法。通过 `PGFPlots`，我们可以制作出难以通过其他方式实现的极其出色的可视化。对于那些不熟悉该系统的
    LaTeX 用户，可能需要了解一下。这个后端确实依赖于 LaTeX 安装——这是一个不容小觑的要求。
- en: '***HDF5***'
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***HDF5***'
- en: HDF5 stands for Hierarchical Data Format, version 5\. This backend does not
    display plots directly; its purpose is to bundle data and plots together into
    an HDF file. For anyone who uses HDF in their research, this package will be essential,
    but others will have no use for it.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: HDF5 代表分层数据格式，第 5 版。这个后端不会直接显示图表；它的目的是将数据和图表一起打包成 HDF 文件。对于任何在研究中使用 HDF 的人来说，这个包是必不可少的，但其他人则不会用到它。
- en: The backend not only writes HDF files, it also can read them into the Julia
    session for display with other `Plots` backends.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 该后端不仅可以写入 HDF 文件，还可以将其读入 Julia 会话，配合其他 `Plots` 后端进行显示。
- en: '***Gaston***'
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Gaston***'
- en: '`Gaston` is an interface to gnuplot and depends on a gnuplot installation.
    This backend will be of interest to those already using that venerable and powerful
    graphics program.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gaston` 是 gnuplot 的接口，依赖于 gnuplot 的安装。这个后端对那些已经在使用这个古老且强大的图形程序的人来说会很有兴趣。'
- en: '`Gaston` is fast and powerful, because gnuplot is fast and powerful. If you
    routinely need to make complex 3D plots that the other backends can’t handle,
    or need more fine control over plots for publication, installing gnuplot and using
    it with `Gaston` may be the best choice.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gaston` 既快速又强大，因为 gnuplot 快速且强大。如果你经常需要绘制其他后端无法处理的复杂 3D 图，或者需要更精细的控制来制作用于出版的图表，那么安装
    gnuplot 并与 `Gaston` 一起使用可能是最佳选择。'
- en: '**Layouts**'
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**布局**'
- en: Earlier in this chapter we saw that the `plot()` function will arrange graphs
    in a grid if we pass it a number of plot objects. Sometimes we need more control
    over the arrangement of subplots in an illustration. In such cases, we turn to
    the `Layout` system.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面我们看到，`plot()` 函数会将图形排列成一个网格，如果传入多个图表对象。有时我们需要对插图中的子图布局进行更多控制。在这种情况下，我们可以使用
    `Layout` 系统。
- en: The plotting package’s method for composing plots into larger illustrations
    is one of the jewels of the system. Considering the complexity that it allows,
    it’s remarkably intuitive to use.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图包将图表组合成更大插图的方法是该系统的一大亮点。考虑到它所允许的复杂性，它的使用却非常直观。
- en: In the following demonstrations, the `Vector s` contains six plots, each displaying
    a prominent digit, from 1 to 6\. This will make it clear where the layout engine
    positions each plot.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的演示中，`Vector s` 包含六个图表，每个图表显示一个突出的数字，从 1 到 6。这样可以清楚地看到布局引擎如何定位每个图表。
- en: If you’d like to follow along, you’ll need to create your own `s` vector, with
    plots of your choosing.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跟着一起操作，你需要创建自己的 `s` 向量，包含你选择的图表。
- en: '***Making Simple Rectangular Layouts***'
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***制作简单的矩形布局***'
- en: 'To replace the default square grid of plots with a different rectangular arrangement,
    supply the desired number of rows and columns as a tuple assigned to the `layout`
    attribute:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要将默认的方形网格布局替换为不同的矩形排列，只需将所需的行数和列数作为元组赋值给 `layout` 属性：
- en: '[PRE24]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As [Figure 4-24](ch04.xhtml#ch4fig24) shows, this call arranges the plots using
    one row and four columns.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 4-24](ch04.xhtml#ch4fig24)所示，这个调用通过一行四列的方式排列图表。
- en: '![Image](../images/ch04fig24.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch04fig24.jpg)'
- en: '*Figure 4-24: A one-row layout*'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-24：一行布局*'
- en: The number of plots implied in the layout tuple must match exactly the number
    of subplots. The default in this case would be equivalent to `layout=(2, 2)`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 布局元组中隐含的图表数量必须与子图的数量完全匹配。在这种情况下，默认值相当于 `layout=(2, 2)`。
- en: '***Using grid()***'
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 grid()***'
- en: 'The simple layouts in the previous example make all the subplots the same size.
    To control the heights and widths of the rows and columns, use the `grid()` function,
    as in the following example:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例中的简单布局使所有子图的大小相同。要控制行和列的高度和宽度，可以使用 `grid()` 函数，如下例所示：
- en: '[PRE25]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This call creates the layout in [Figure 4-25](ch04.xhtml#ch4fig25). We can omit
    either the `height` or the `width` specification to get equalized lengths in that
    direction.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用创建了[图 4-25](ch04.xhtml#ch4fig25)中的布局。我们可以省略 `height` 或 `width` 中的任意一个规格，以便在该方向上获得相等的长度。
- en: '![Image](../images/ch04fig25.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch04fig25.jpg)'
- en: '*Figure 4-25: A layout using the* grid() *function*'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-25：使用* grid() *函数的布局*'
- en: When using `grid()`, the dimensions can add up to less than 1, which will simply
    leave some blank space, but they should not add to greater than 1.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `grid()` 时，维度的总和可以小于 1，这将简单地留下空白空间，但总和不应大于 1。
- en: '***Creating Complex Layouts Using @layout***'
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 @layout 创建复杂布局***'
- en: We can create layouts of arbitrary complexity. The next level requires the use
    of the `@layout` macro. We haven’t seen macros yet; they’re introduced in “Macros”
    on [page 170](ch06.xhtml#ch06lev4). For now, I’ll show how to use this particular
    macro to create graph layouts. We’ll be better equipped to understand how it works
    under the hood after we learn a bit more about the language.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建任意复杂度的布局。下一级需要使用 `@layout` 宏。我们尚未看到宏，它将在“宏”一章中介绍，参见[第 170 页](ch06.xhtml#ch06lev4)。现在，我将展示如何使用这个特定的宏来创建图表布局。在我们对语言有了更多了解后，会更好地理解其背后的工作原理。
- en: 'The `@layout` macro creates a layout that follows the shape of a matrix that
    we supply to the macro. We use spaces to place subplots horizontally and newlines
    or semicolons to place them vertically, as when constructing actual matrices.
    However, these `@layout` matrices don’t need to have matching dimensions. As in
    the following example, the rows can have different numbers of elements. I use
    `a` to represent a subplot, but we can use any identifiers. They have no meaning,
    as the layout engine just uses the plots in the order we supply them in the `plot()`
    function. Here’s a simple use of the macro:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`@layout` 宏创建的布局遵循我们提供给宏的矩阵形状。我们使用空格来水平排列子图，使用换行符或分号来垂直排列子图，就像构建实际的矩阵一样。然而，这些
    `@layout` 矩阵不需要具有匹配的维度。如以下示例所示，行可以包含不同数量的元素。我使用 `a` 来表示一个子图，但我们可以使用任何标识符。它们没有特定含义，因为布局引擎只会按照我们在
    `plot()` 函数中提供的顺序使用这些图。以下是宏的一个简单使用示例：'
- en: '[PRE26]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[Figure 4-26](ch04.xhtml#ch4fig26) shows the resulting layout. Observe how
    the arrangement of subplots follows the arrangement of the `a` placeholders used
    in the macro.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-26](ch04.xhtml#ch4fig26)展示了最终的布局。观察子图的排列如何遵循宏中使用的 `a` 占位符的排列。'
- en: '![Image](../images/ch04fig26.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch04fig26.jpg)'
- en: '*Figure 4-26: Using the @layout macro*'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-26：使用 @layout 宏*'
- en: 'The use of `@layout` in this form equalizes the space allotted to the subplots.
    To change the height or width of any of them, use the notation in the following
    example:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种形式使用 `@layout` 宏会使子图分配的空间相等。要更改它们的高度或宽度，可以使用以下示例中的符号：
- en: '[PRE27]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The specifications inside the curly brackets are width or height as a fraction
    of the entire plot. This call creates the layout in [Figure 4-27](ch04.xhtml#ch4fig27).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 花括号内的规格是宽度或高度，占整个图表的比例。这个调用创建了[图 4-27](ch04.xhtml#ch4fig27)中的布局。
- en: '![Image](../images/ch04fig27.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch04fig27.jpg)'
- en: '*Figure 4-27: Using the @layout macro with dimension specifications*'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-27：使用 @layout 宏与维度规格*'
- en: 'We can achieve even greater flexibility in layouts by using a call to `grid()`
    within the `@layout` argument, as in the following example:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 `@layout` 参数中使用 `grid()` 调用来实现更大的布局灵活性，如以下示例所示：
- en: '[PRE28]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The number of subplots passed to the `@layout` macro must equal the number in
    the positional arguments to `plots()`. The `grid(2, 2)` call here accounts for
    four subplots, and the remaining two are represented by `a` and `b`. [Figure 4-28](ch04.xhtml#ch4fig28)
    shows the result.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `@layout` 宏的子图数量必须等于传递给 `plots()` 的位置参数中的数量。这里的 `grid(2, 2)` 调用表示四个子图，剩余的两个由
    `a` 和 `b` 表示。[图 4-28](ch04.xhtml#ch4fig28)展示了结果。
- en: '![Image](../images/ch04fig28.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch04fig28.jpg)'
- en: '*Figure 4-28: Using subgrids within a layout*'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-28：在布局中使用子网格*'
- en: “Detail Insets” on [page 106](ch04.xhtml#ch04lev9) explained how to create inset
    plots that magnified a section of a main plot. We can use the `inset` and `subplot`
    attributes that we used there to make any kind of inset, not merely one using
    `lens!()`, and we can combine it with any layout.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第106页](ch04.xhtml#ch04lev9)中，“Detail Insets”解释了如何创建放大主图部分的插图。我们可以使用那里使用的`inset`和`subplot`属性来制作任何类型的插图，不仅仅是使用`lens!()`，并且可以将其与任何布局结合使用。
- en: 'After creating the layout in the previous example, we can add an inset to it
    with this call:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中创建布局后，我们可以通过以下调用将插图添加到该布局中：
- en: '[PRE29]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `inset` attribute is set to a `bbox`. Since we didn’t supply it with a positional
    argument, the `bbox` parameters will position the plot relative to the entire
    layout, rather than any particular subplot. The `subplot=7` setting makes the
    inset into a new subplot, which is necessary to make this work as intended, as
    the layout already has six subplots. `RGBA` is similar to the `RGB` that we saw
    before, but with a final parameter for the opacity.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`inset`属性被设置为一个`bbox`。由于我们没有为其提供位置参数，`bbox`的参数将使得图表相对于整个布局进行定位，而不是相对于某个特定的子图。`subplot=7`设置将插图变成一个新的子图，这是确保该功能按预期工作的必要条件，因为布局已经包含了六个子图。`RGBA`与我们之前看到的`RGB`类似，但有一个额外的参数用于透明度。'
- en: '[Figure 4-29](ch04.xhtml#ch4fig29) shows the result of adding the inset.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-29](ch04.xhtml#ch4fig29)展示了添加插图后的结果。'
- en: '![Image](../images/ch04fig29.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch04fig29.jpg)'
- en: '*Figure 4-29: Adding a floating inset to a layout*'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-29：向布局添加浮动插图*'
- en: '**Conclusion**'
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结论**'
- en: 'This chapter covered everything about the `Plots` package that you’ll need
    for most scientific graphics: the main types of plots, lenses and annotations,
    how to customize appearance, and how to lay out sets of graphs to form a composite
    illustration. In [Chapter 7](ch07.xhtml) we’ll find out how to make animations
    and explore some packages to create diagrams, and in [Chapter 8](ch08.xhtml) we’ll
    revisit the plotting system to learn about plot recipes.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了你在大多数科学图形中需要使用的`Plots`包的所有内容：主要的图形类型、镜头和注释、如何自定义外观以及如何布置图形集合形成复合图。在[第7章](ch07.xhtml)中，我们将学习如何制作动画，并探索一些创建图表的包，而在[第8章](ch08.xhtml)中，我们将重新审视绘图系统，学习绘图配方。
- en: '**FURTHER READING**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: The official reference for the `Plots` package is available at [*https://docs.juliaplots.org/latest/*](https://docs.juliaplots.org/latest/).
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Plots`包的官方参考可以在[*https://docs.juliaplots.org/latest/*](https://docs.juliaplots.org/latest/)找到。'
- en: 'Here’s where you can find a video about `Plots` by its creator: [*http://www.breloff.com/plots-video*](http://www.breloff.com/plots-video).'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是你可以找到关于`Plots`的视频链接，视频由其创作者提供：[*http://www.breloff.com/plots-video*](http://www.breloff.com/plots-video)。
- en: For a useful guide to making publication-quality plots, visit [*https://nextjournal.com/leandromartinez98/tips-to-create-beautiful-publication-quality-plots-in-julia*](https://nextjournal.com/leandromartinez98/tips-to-create-beautiful-publication-quality-plots-in-julia).
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取关于制作出版质量图表的有用指南，请访问[*https://nextjournal.com/leandromartinez98/tips-to-create-beautiful-publication-quality-plots-in-julia*](https://nextjournal.com/leandromartinez98/tips-to-create-beautiful-publication-quality-plots-in-julia)。
- en: More information on the HDF5 format is available at [*https://www.hdfgroup.org/solutions/hdf5*](https://www.hdfgroup.org/solutions/hdf5).
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于HDF5格式的信息可以在[*https://www.hdfgroup.org/solutions/hdf5*](https://www.hdfgroup.org/solutions/hdf5)找到。
- en: Documentation on using HDF5 files in Julia is available at [*https://juliaio.github.io/HDF5.jl/stable/*](https://juliaio.github.io/HDF5.jl/stable/).
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于如何在Julia中使用HDF5文件的文档可在[*https://juliaio.github.io/HDF5.jl/stable/*](https://juliaio.github.io/HDF5.jl/stable/)找到。
- en: For more information on predefined palettes for plots, visit [*https://docs.juliaplots.org/latest/generated/colorschemes/*](https://docs.juliaplots.org/latest/generated/colorschemes/).
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于预定义调色板的信息，请访问[*https://docs.juliaplots.org/latest/generated/colorschemes/*](https://docs.juliaplots.org/latest/generated/colorschemes/)。
- en: The `Gaston` headquarters, at [*https://mbaz.github.io/Gaston.jl/stable*](https://mbaz.github.io/Gaston.jl/stable),
    contains a well-chosen illustration.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gaston`总部位于[*https://mbaz.github.io/Gaston.jl/stable*](https://mbaz.github.io/Gaston.jl/stable)，并且包含了精心挑选的插图。'
- en: Information and software downloads for gnuplot are available at [*http://gnuplot.info*](http://gnuplot.info).
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关信息和gnuplot软件的下载可在[*http://gnuplot.info*](http://gnuplot.info)找到。
- en: The basics of LaTeX math syntax are available at [*https://www.cs.princeton.edu/courses/archive/spr10/cos433/Latex/latex-guide.pdf*](https://www.cs.princeton.edu/courses/archive/spr10/cos433/Latex/latex-guide.pdf)
    (see Section 7).
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LaTeX 数学语法的基础知识可以在 [*https://www.cs.princeton.edu/courses/archive/spr10/cos433/Latex/latex-guide.pdf*](https://www.cs.princeton.edu/courses/archive/spr10/cos433/Latex/latex-guide.pdf)
    中找到（见第 7 节）。
- en: 'Documentation on a Julia wrapper over the powerful *plotly.js* interactive
    plotting system is available through the `plotlyjs` package: [*https://plotly.com/julia/*](https://plotly.com/julia/).'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Julia 封装器的文档，可以通过强大的*plotly.js*交互式绘图系统获取，文档位于 `plotlyjs` 包中：[*https://plotly.com/julia/*](https://plotly.com/julia/)。
