- en: '**4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: THE PLOTTING SYSTEM**
  prefs: []
  type: TYPE_NORMAL
- en: '*There is nothing worse than a sharp image of a fuzzy concept.*'
  prefs: []
  type: TYPE_NORMAL
- en: —Ansel Adams
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter introduces the large and rich subject of visualization in Julia.
    Plots and diagrams play a role in scientific communication equal in importance
    to words and equations. Julia’s plotting ecosystem is diverse and powerful; you’ll
    be able to craft a solution to any type of visualization challenge without leaving
    the language. The ability to keep both your calculation and its visualization
    within a single program simplifies the process of exploring and reporting results.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting in Julia is a hotspot of rapid development. This is mostly good, as
    it means new features and packages arise regularly. The downside, however, is
    a higher than average incidence of conflicts among packages, incomplete documentation,
    and bugs, exacerbated by the frequent need for plotting routines to depend on
    external graphics libraries. With this in mind, I’ve confined the treatment in
    this chapter to packages that seem to be stable and mature. The examples here
    should work over the long term. I’ve avoided discussing some potentially useful
    packages that still have too many rough edges.
  prefs: []
  type: TYPE_NORMAL
- en: '**Plots**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main, and in a sense “official,” plotting package for Julia is `Plots`.
    Later in the book we’ll explore other graphical methods, but this chapter is about
    the package at the center of Julia’s visualization universe.
  prefs: []
  type: TYPE_NORMAL
- en: '`Plots` is not in the standard library, so we need to install it in the package
    manager with add Plots. The initial installation will take some time, as `Plots`
    has many dependencies, all of which need to be (automatically) installed as well.
    Precompilation of this assortment of packages will take a few minutes.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Plots` is a unique approach to providing a programming language with plotting
    abilities. It’s often described as a plotting *metapackage*, because `Plots` doesn’t
    do any actual plotting on its own. Rather, it orchestrates the creation of visualizations
    by calling on a choice of *backends*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Backend System**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The backend is the package that actually draws the picture. Each backend has
    particular strengths and weaknesses, and is suitable for a different type of application.
    The job of `Plots` is to provide a unified interface to all of the backends and
    to apply a degree of intelligence in translating our plotting call into a form
    that the backend can understand. It tries to figure out what we mean and how to
    produce the plot we want.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using a plotting metapackage is that we can change the backend
    used in a program without having to change the plotting commands. During research,
    we may want to have a simulation code produce rough plots directly in the terminal
    or 3D plots that we can rotate with the mouse. Later, we may want to run the simulation
    again, but this time save publication-quality plots to disk. With the `Plots`
    system, we can accomplish that by simply changing one line of code that selects
    a different backend.
  prefs: []
  type: TYPE_NORMAL
- en: Some of `Plots`’s backends are automatically installed when we install the package,
    but we’ll need to install others manually, as separate packages (these are subject
    to change, but we’ll be prompted to install a missing backend when we try to use
    it). When we `add` the `Plots` package, one backend that always comes along for
    the ride is the default backend. Recently this default has been `GR`, a reasonably
    fast and featureful plotting engine. To see the list of available backends, execute
    the backends() function in the REPL. To see the currently active backend, execute
    the backend() function.
  prefs: []
  type: TYPE_NORMAL
- en: To activate a backend, we use the appropriate name that `backends()` returns
    to form a function and simply call it. If it’s installed, the function responds
    by confirming the name of the package. If not, we’ll get an error message explaining
    that we need to `add` it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is part of a REPL session showing the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Asking for available backends ➊ returns a list in the form of a `Vector` of
    `Symbol`s, indicated by the leading colons. “Symbols and Metaprogramming” on [page
    167](ch06.xhtml#ch06lev3) will explain the `Symbol` data type, but for now, think
    of it as a string.
  prefs: []
  type: TYPE_NORMAL
- en: Asking for the current backend ➋ returns `Plots.GRBackend()`. The multiple names
    for each backend is somewhat confusing, as the capitalized form used to refer
    to a package differs from the lowercase form used to activate it. The form that
    `backend()` returns isn’t used for anything.
  prefs: []
  type: TYPE_NORMAL
- en: The next move is to make `UnicodePlots` the current backend ➌; the operation
    was confirmed. Then we change our mind and decide to plot with HDF5, but our attempt
    to switch to it gives us an error because it’s not in the load path. Apparently
    we never added it to the environment. After adding HDF5 in package mode ➍, we
    switch to it and call `backend()` to confirm.
  prefs: []
  type: TYPE_NORMAL
- en: The package system doesn’t consider the various backends to be dependencies
    of `Plots`. This was a deliberate choice to spare users from having to install
    all of the backends when installing `Plots`, as there are many of them, and most
    users will need only a modest subset. This creates occasional incompatibilities,
    however, as `Plots` and its various backends evolve, since the package system
    cannot automatically keep them in sync. If something doesn’t work, try a different
    backend if possible; otherwise, search the web and the resources in “Further Reading”
    on [page 121](ch04.xhtml#fur4) for a resolution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modes of Interaction with Plots**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are following along in Pluto, you can enter each plotting command in
    a new cell and produce a sequence of figures embedded in the page. If you’re using
    the REPL, each plot should reuse the display window opened by the first, replacing
    the existing plot. If you want to close that window, use the statement `closeall()`.
    Closing it using your window manager sometimes leads to errors in the REPL, a
    known bug.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re saving plot commands in a program file, you may have noticed that
    you don’t see any output when you run it. First, you need to include the statement
    `gui()` at the point in the program where you want to display the current state
    of the plot. However, the plot window thus created will vanish when the program
    exits, perhaps so quickly that you may not be able to see the window at all. You
    need to make the program pause until you’re done admiring your plot. One way is
    to insert the `readline()` statement directly after `gui()`. This statement waits
    for input at the terminal. When you’re ready to dismiss the plot window, simply
    press RETURN and it will vanish, and the program will continue.
  prefs: []
  type: TYPE_NORMAL
- en: '**2D Plots**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term *2D plot* refers to a variety of visualizations involving maps between
    two variables. The basic type, a *line plot*, takes the form of a curve, or set
    of curves, for functions of a single variable, where typically the independent
    variable is represented by the horizontal x-axis and the dependent variable by
    the vertical y-axis in a rectangular coordinate system. The *polar coordinate
    plot* maps an angle to the distance from some origin, in a polar coordinate system.
    A third common type is a *parametric plot*, where both variables depend on a third
    variable, called the parameter. These three basic types, along with other varieties
    such as bar and pie charts and scatterplots, are all called *two-dimensional plots*,
    and they are all handled by the `plot()` function provided by the `Plots` package
    and understood by all of its backends.
  prefs: []
  type: TYPE_NORMAL
- en: For the examples in this section, any backend will work, but I suggest sticking
    with the default setup when you execute `using Plots`. This will always be a relatively
    stable and performant engine that displays color plots either in a new window
    when using the REPL, or on the page when using Pluto or VS Code. In all of the
    examples in this chapter, `using Plots` is assumed.
  prefs: []
  type: TYPE_NORMAL
- en: The `plot()` function accepts arguments of various kinds, and, as mentioned
    previously, usually does what we expect. It returns a result in the form of a
    plot object. In the REPL, a notebook interface such as Pluto, or another interactive
    environment, it immediately displays the plot, unless we suppress the output by
    following the call with a semicolon. We can display the plot later with a call
    to `gui()` or by storing the plot object in a variable and simply evaluating it.
  prefs: []
  type: TYPE_NORMAL
- en: '***Plotting from Vectors***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can call the function with a single `Vector` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This plots the numbers in the `Vector`, in order, against an independent variable
    that gives their index. [Figure 4-1](ch04.xhtml#ch4fig1) shows the plot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Plotting a single vector*'
  prefs: []
  type: TYPE_NORMAL
- en: We get a legend, which at the moment is not very informative. We’ll learn shortly
    how to adjust this, and change other things about the graph, but first let’s look
    at the different ways we can use `plot()`.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I’ve created grayscale versions of all the examples in this chapter for printing,
    but the original color output from each plot command is available from the book’s
    supplementary website at* [https://julia.lee-phillips.org](https://julia.lee-phillips.org)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second form supplies both *x*- and *y*-variables, with two `Vector`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The result ([Figure 4-2](ch04.xhtml#ch4fig2)) shows the same *y*-values plotted
    at different horizontal locations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Plotting a vector versus another vector*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Plotting Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To plot a function, we can supply a vector as the first argument and a second
    vector created by broadcasting the function over the first argument (see “Broadcasting”
    on [page 51](ch02.xhtml#ch02lev1sec13)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example we first create a function, `f()`, using the succinct one-line
    function definition syntax. Next we define a range and store it in x; the range
    excludes `0` to avoid the singularity there. The `plot()` command has two `Vector`
    arguments, as before. The range is instantiated into a `Vector` and the dot after
    `f()` broadcasts the function over `x`, returning a `Vector` for the dependent
    variable. [Figure 4-3](ch04.xhtml#ch4fig3) shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: A plot of a function broadcast over a vector*'
  prefs: []
  type: TYPE_NORMAL
- en: We can see the plot becoming inaccurate as we approach the origin and the π`/1000`
    resolution fails to keep up with the rapid oscillations in that region.
  prefs: []
  type: TYPE_NORMAL
- en: The `plot()` function and its comrades offer a convenient shorthand. Instead
    of supplying the second argument as a broadcast expression that explicitly creates
    a vector, we can simply write the name of a function, or construct an anonymous
    function. The `plot()` function will broadcast the function we name over the independent
    variable vector that we pass in the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we can write `plot(x, f.(x))` as simply `plot(x, f)`. If we
    had not already defined `f()`, we could insert an anonymous function directly
    as `plot(x, s -> sin(1/s))`. These three ways of calling `plot()` are all equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: We can even leave out the independent variable and supply only a function name
    or an anonymous function. In this case, `plot()` will plot the function for us,
    choosing the locations of the independent variable and handling singularities
    automatically. We can supply a domain on the horizontal axis using a second and
    third argument, with default values of –5 and 5\. If we use a `Vector` of functions
    in the first argument, we’ll get a plot of all of them on the same axes. Using
    the same definition for `f`, executing `plot([sin, cos, f], -`π`,` π`)` produces
    [Figure 4-4](ch04.xhtml#ch4fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: Plotting three functions*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this use of `plot()`, we supply the names of the functions. We’re not *calling*
    these functions, so we omit the parentheses. Plotting is a common application
    for anonymous functions (see “Creating Anonymous Functions” on [page 51](ch02.xhtml#ch02lev1sec12)).
    This is their purpose: to pass a function as an argument to another function,
    in this case `plot()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Plotting Vectors of Vectors or Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we supply vectors of vectors in the first two argument positions, `plot()`
    will cycle through both arguments, reusing elements as necessary. For example,
    if we call `plot([x1, x2], [y1, y2])`, we’ll get a plot of `y1` versus `x1` and
    `y2` versus `x2`, both on the same set of axes. But if we call `plot(x1, [y1,
    y2])`, we’ll get a plot of `y1` versus `x1` and `y2` versus `x1`. If we call `plot([x1,
    x2], y1)`, we’ll see `y1` versus `x1` and `y1` versus `x2`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll get the same results if we use horizontal concatenation; in other words,
    `plot([x1, x2], [y1, y2])` produces the same plot as `plot([x1 x2],` `[y1 y2])`.
    When given `Matrix` arguments, `plot()` plots by columns. We can even call `plot([x1,
    x2], [y1 y2])`, mixing a vector of vectors with a matrix, and `plot()` will know
    what we mean and draw the same graph as in the two preceding examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use *vertical* concatenation, we will simply create longer vectors. We
    can use this to plot different functions over different ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we join the `x` vector to itself shifted to the right by 5π
    and supply the result as the independent variable. Against that, we plot a `sin`
    function joined to the same function multiplied by a decaying exponential (note
    the use of broadcast notation throughout). [Figure 4-5](ch04.xhtml#ch4fig5) shows
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: Joining vectors to model a damped oscillation*'
  prefs: []
  type: TYPE_NORMAL
- en: The graph can be interpreted as an initially frictionless oscillation with damping
    applied at *x* = 5π.
  prefs: []
  type: TYPE_NORMAL
- en: '***Displaying and Mutating***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I mentioned earlier that we cause the display of a plot in a program file with
    the call `gui()`. But how does the `gui()` function know what plot to display?
    The plotting system maintains a *current plot* in the global namespace, along
    with other settings and state related to the display of graphics. This is convenient
    during interactive plotting, as it allows us to incrementally adjust and add things
    to the current plot by mutating it. The mutating version of `plot()` is `plot!()`,
    following the convention (see “Functions That Mutate Their Arguments” on [page
    56](ch02.xhtml#ch02lev1sec17)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using mutation, we can produce [Figure 4-4](ch04.xhtml#ch4fig4) with these
    three lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `plot!()` function maintains the domain established in the first call. We
    can use the mutating form to change many aspects of the plot, in addition to adding
    curves.
  prefs: []
  type: TYPE_NORMAL
- en: The `plot()` and `plot!()` functions return plot objects, which we can assign
    to variables. The reason we see a plot when we call the function in the REPL or
    in a notebook is that Julia calls `gui()` automatically in interactive contexts
    whenever a plot object is returned from an expression. If we’ve assigned some
    plots to variables, anytime we want to see one, we can simply type its name in
    the REPL and press RETURN. In a program file, we can supply the plot object as
    an argument to `gui()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we give `plot!()` a plot object as its first argument, it will mutate that
    plot instead of the current plot. For example, if we execute `ps = plot(sin)`,
    then `ps` is a plot of the `sin()` function. A call to `plot!(ps, cos)` will do
    two things: it will mutate `ps`, adding a `cos()` curve to it, and it will return
    the result, so that the altered plot pops up on the screen. Making the same call
    using the non-mutating version, `plot()`, will display the plot with both curves,
    but won’t alter `ps`.'
  prefs: []
  type: TYPE_NORMAL
- en: We can supply any number of plot objects as arguments to `plot()`, and it will
    arrange them automatically into a grid. See “Layouts” on [page 117](ch04.xhtml#ch04lev12)
    for details on how to get more control over this arrangement.
  prefs: []
  type: TYPE_NORMAL
- en: 'This REPL session creates several plots and then combines them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: All the lines end with a semicolon except the last, where we want to see the
    plot. First we give the variable `parabola` the value of a plot object depicting
    a parabola, constructed with an anonymous function. The value of the variable
    is now a data type representing a complete plot, with axes, tick marks, and so
    on. We don’t specify a domain, so the parabola is plotted from –5 to 5.
  prefs: []
  type: TYPE_NORMAL
- en: Then we assign `ps` to a plot of the `sin` function, this time with a domain
    from 0 to 2π.
  prefs: []
  type: TYPE_NORMAL
- en: Next we decide we would like `ps` to also contain a `cos` curve, so we change
    it; `plot!()` will keep the existing domain.
  prefs: []
  type: TYPE_NORMAL
- en: The final line creates the plot shown in [Figure 4-6](ch04.xhtml#ch4fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Plotting four plot objects*'
  prefs: []
  type: TYPE_NORMAL
- en: We call `plot()` with four plot-object arguments. The first and last are the
    two plot-holding variables, the second is a plot object created directly with
    a `plot()` function on the previous `f` function, and the third uses an anonymous
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Parametric Plots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Parametric plots in the plane are also classified with 2D plots because there
    is one independent variable, now called the *parameter*. In this type of plot,
    *x* and *y* both depend on the parameter. If we pass two arguments that are both
    functions to `plot()`, it recognizes this as the signature for a parametric plot
    and produces a graph with the *x*-dependence given by the first function and the
    *y*-dependence given by the second (where, as usual, *x* is plotted on the horizontal
    axis and *y* on the vertical). We must specify the domain for the parameter with
    two additional arguments; however, there is no default as when plotting non-parametric
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Parametric plotting allows us to render various complex shapes and such plots
    as circles and spirals, as shown in [Figure 4-7](ch04.xhtml#ch4fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-7: Two parametric plots*'
  prefs: []
  type: TYPE_NORMAL
- en: The left-hand plot is produced with the call `circle = plot(sin, cos, 0, 2`π`)`
    and the spiral in the right-hand plot is created by `spiral = plot(r -> r*sin(r),`
    `r -> r*cos(r), 0, 8`π`)`. We draw the composite figure by calling `plot(circle,`
    `spiral)`.
  prefs: []
  type: TYPE_NORMAL
- en: As in the case of regular function plotting, the independent variable, in this
    case the parameter, can be implicit, as in the call we used to draw the circle.
    When the functions to be plotted are too complex to allow this, as in the spiral
    example, we must employ a dummy variable, which we named `r` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '***Making Polar Plots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A polar plot uses the conventional polar coordinate system rather than a rectangular
    coordinate system. The independent variable is the angle, measured counterclockwise
    from the horizontal axis, and the dependent variable is the distance from the
    origin.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-8](ch04.xhtml#ch4fig8) shows two simple plots in polar coordinates.
    The `plot()` function renders the coordinate grid to reflect the symmetry of the
    polar geometry.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-8: Two polar plots*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We created the plot on the left with `plot(0:2`π`/500:2`π`, t -> 1 + 0.2*sin(8t);
    proj=:polar)` and the spiral on the right with `plot(0:8`π`/200:8`π`, t -> t;
    proj=: polar)`. The first arguments in these calls are arrays of angular coordinates,
    and the second arguments are functions mapping the angle to the distance from
    the origin, using `t` as a dummy variable. The argument `proj=:polar` tells `plot()`
    to make a polar plot. This is a keyword argument, as explained in “Optional and
    Keyword Arguments” on [page 96](ch04.xhtml#ch04lev5).'
  prefs: []
  type: TYPE_NORMAL
- en: '***Making Scatterplots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The 2D plots we’ve seen so far draw a continuous line through a set of points.
    Sometimes we need to plot a collection of dots or other markers, each at a particular
    (*x*, *y*) position: a *scatterplot*. The `scatter()` function works identically
    to the `plot()` function, but it draws point collections rather than curves.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example application, suppose we wanted to visualize the output of the
    iterated map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/math95.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This simple map produces a fascinating variety of patterns with an unpredictable
    dependence on *a*. The Julia version is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve named it after the common nickname for the map: the *gingerbread man*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll store the sequence of values in two vectors, `x` and `y`, initialized
    with the starting coordinates, and iterate 4,000 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The listing uses a form of *destructuring* ➊. The `ginger()` function returns
    a tuple with its first member stored in `x2` and its second in `y2`.
  prefs: []
  type: TYPE_NORMAL
- en: After running this loop, we can see what’s in `x` and `y` with a scatterplot.
    The call `scatter(x, y; ms=0.5, legend=false)` produces the plot shown in [Figure
    4-9](ch04.xhtml#ch4fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-9: The gingerbread man iterated map*'
  prefs: []
  type: TYPE_NORMAL
- en: In the call to `scatter()`, after the `x` and `y` arguments, we add something
    new after a semicolon. These two *optional keyword arguments* affect the plot’s
    appearance, as explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional and Keyword Arguments**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a function definition, we can supply default values for arguments. Doing
    so makes those arguments *optional*, as the user can call the function without
    using them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the definition of `g()` includes the default value of `2` for
    `y`. If we call it with no second argument, it returns `x + 2`. When we do supply
    a second argument, it uses that instead.
  prefs: []
  type: TYPE_NORMAL
- en: So far we’ve learned how to define and call functions with *positional arguments*.
    Values are assigned based on the order in which we put them in the argument list
    when calling the function, whether they’re optional or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia also has *keyword arguments*, identified by name rather than position.
    Unlike some other languages, we must make a distinction when defining a function
    between its positional and keyword arguments; we separate them with a semicolon,
    as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we define `p()` to have one positional argument and one keyword argument,
    named `y`, with the default value of `2`. We can call `p()` omitting the keyword
    argument ➊, because the default makes it optional. If we supply two positional
    arguments, that returns an error because the function takes only one. Make sure
    you understand the difference between the functions `g()` and `p()`: they differ
    only in their function signatures.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When calling a function we have the option to use a comma instead of a semicolon
    because there’s no chance of ambiguity; however, the semicolon is required in
    function definitions.*'
  prefs: []
  type: TYPE_NORMAL
- en: The plotting functions in the `Plots` ecosystem use positional arguments for
    data or functions and keyword arguments for setting plot options. Because all
    the plot options have default values, we haven’t had to use them until now.
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic Plot Settings**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To adjust a plot’s appearance, we use keyword arguments. There are four components
    that can make up a visualization made with the `Plots` package, and each one has
    a collection of settings that applies to it.
  prefs: []
  type: TYPE_NORMAL
- en: These four components are *plot*, *subplot*, *axis*, and *series*. Plots can
    contain subplots, and either of those can contain axes or series.
  prefs: []
  type: TYPE_NORMAL
- en: The overall illustration is called the plot; it contains other plots, the subplots,
    when there are more than one, as in [Figure 4-6](ch04.xhtml#ch4fig6). Settings
    such as an overall title and background color apply to the plot.
  prefs: []
  type: TYPE_NORMAL
- en: Within a plot, each subplot can have its own title, background color, margin,
    and many other settings.
  prefs: []
  type: TYPE_NORMAL
- en: The actual curves or other visualizations of functions or data are the series,
    and a subplot can contain many series.
  prefs: []
  type: TYPE_NORMAL
- en: Each subplot contains an axis object. Its settings determine such things as
    whether the coordinate axes are drawn with arrows, the color of tick labels, or
    the numbers on the coordinate axes.
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, we can simply use the appropriate keyword to set the desired
    *attribute* of our visualization, and the plotting system will apply it where
    it makes sense. But when designing complicated visualizations, we sometimes need
    to target specific components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The official plotting system documentation at [*https://docs.juliaplots.org/stable/*](https://docs.juliaplots.org/stable/)
    contains the complete list of attributes for all components, as well as which
    attributes are supported by which backends. The following list provides the most
    important ones and gives examples of their effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Titles**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Overall title: `plot_title`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Title for subplot: `title`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Title for legend: `legendtitle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other labels**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Legend text: `label`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Legend existence and position: `legend`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Axis labels: `[x,y]guide`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Label anywhere: `annotation=(x, y, "Text")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Font colors**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Overall title: `plot_titlefontcolor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subplot title: `titlefontcolor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Legend: `legendfontcolor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Axis labels: `[x,y]guidefontcolor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Area colors**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Margin area: `background_outside`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Plot area only: `background_inside`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Curves**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Line color: `lc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line width: `lw`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line style: `ls`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scatterplots**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Marker shape: `shape`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Marker color: `mc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Marker size: `ms`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contour plots**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Give contours labels (Boolean): `clabels`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contour levels: `levels`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Axes and ticks**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Reverse axis (Boolean): `[x,y]flip`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rotation of tick labels: `[x,y]rotation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Draw axis: `showaxis [x,y]ticks`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Frame style: `framestyle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grid**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Draw a grid (Boolean): `grid`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Gridline opacity: `gridalpha [0,1]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Gridline style: `gridstyle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coordinate system**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Use polar coordinates: `:proj=polar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sizes and margins**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Margin around subplot: `[left,right,top,bottom]margin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Overall plot size: `sizes(a, b)` (in px)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subplot aspect ratio: `ratio`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the keywords in these lists has a set of abbreviations and alternative
    spellings, all listed in the official documentation. I’ve picked one version in
    each case; it’s not always the briefest alternative, but a choice designed to
    be memorable and to avoid confusion.
  prefs: []
  type: TYPE_NORMAL
- en: The purposes of a few of these settings will not be clear until we discuss them
    later, but I’ve listed them all here for easy reference.
  prefs: []
  type: TYPE_NORMAL
- en: '***Font Attributes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To form the keyword for setting a font attribute such as the font size or family,
    look up the corresponding name for setting the font color in the attribute list
    shown earlier, and substitute the desired attribute, such as `fontsize` or `fontfamily`
    in place of `fontcolor`. For example, to make the plot title have a size of 30pt,
    use the setting `plot_titlefontsize=30`.
  prefs: []
  type: TYPE_NORMAL
- en: The font *families* are dependent on which backend is in use. A list for the
    GR backend is at [*https://gr-framework.org/fonts.html*](https://gr-framework.org/fonts.html).
    Some of the more useful families, which also may be available in other backends,
    are Times (Roman, Italic, Bold), Courier, Bookman, DejaVu Sans, and Computer Modern.
    Supply the setting as a string. If we set the attribute `fontfamily`, that will
    apply to all or most of the text on the plot. For example, to get the ticks, axis
    labels, and other annotations in Computer Modern, but the title in Times, we’d
    call `plot(...; fontfamily="Computer Modern", legendfontfamily="Times")`.
  prefs: []
  type: TYPE_NORMAL
- en: If we mutate a plot that contains subplots, and we’re adding or changing attributes
    that apply to subplots, we must specify which subplot to mutate, unless we want
    our changes to apply to all of them. This is the purpose of the `subplot` keyword.
    Set it to an integer indexing the subplots as they appear in the `plot()` statement.
    For example, for two graphs displayed side by side with `plot(p1, p2)`, we can
    put a label on the horizontal axis of `p2` with `plot`!(`; xguide` `="Time", subplot=2)`.
    Without the `subplot` keyword, both plots would get the label.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Frame Styles***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `framestyle` setting determines the type of axis. [Figure 4-10](ch04.xhtml#ch4fig10)
    displays the six possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-10: The six possible frame styles*'
  prefs: []
  type: TYPE_NORMAL
- en: We set the attribute to the symbol version of the term printed on the graph.
    For example, to get the style in the lower-left corner, we’d use the setting `framestyle=:zerolines`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Working with Plot Settings**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we can understand the call to `scatter(x, y; ms=0.5, legend=false)` that
    produced [Figure 4-9](ch04.xhtml#ch4fig9). After the first two positional arguments,
    the arrays holding the points to be plotted, we have a semicolon indicating the
    start of the keyword arguments. The first sets a small marker size and the second
    turns off the legend.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use some combinations of the basic attributes listed in “Basic Plot Settings”
    on [page 98](ch04.xhtml#ch04lev6) to solve some other visualization problems.
  prefs: []
  type: TYPE_NORMAL
- en: '***Aspect Ratio and Title Font Size***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following program creates a simple plot with two subplots displaying a
    circle and a parabola:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here we use the `ratio` keyword to set the aspect ratio in the first line. You
    may have noticed that what is supposed to be a circle in [Figure 4-7](ch04.xhtml#ch4fig7)
    is rendered as a noncircular ellipse. The default size of Julia’s plots is not
    square, but is instead longer than it is tall, so the circle is stretched horizontally.
    If it matters, as it does in this case, we can use `ratio` to fix the problem.
    We also turned off the grid and ticks on this plot.
  prefs: []
  type: TYPE_NORMAL
- en: The default grid in most backends is quite light, so we made it more prominent
    by increasing the `gridalpha` in the plot of the parabola. The default for this
    is `0.1`.
  prefs: []
  type: TYPE_NORMAL
- en: The last line creates the combined plot with an overall title set a little larger
    than the default. [Figure 4-11](ch04.xhtml#ch4fig11) shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-11: A plot with two subplots*'
  prefs: []
  type: TYPE_NORMAL
- en: To get more space between the two subplots, we can, for example, set a `rightmargin`
    on the left subplot. Before setting margins, execute using Plots .PlotMeasures,
    which lets us use literal dimensions in margin settings; for example, `rightmargin=10mm`.
    Other available dimensions are `inch`, `cm`, `px`, and `*pt*`.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The* plot_title *is a recent addition to the plotting system, and its implementation
    is incomplete. If we choose larger font sizes for the title, it will overlap the
    titles of the subplots, and there is no straightforward way to fix that.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Labels and Legend Positioning***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For our next example, let’s make a plot of *x*^(*n*) for a few values of *n*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: First we’ll clear any existing plots with an empty `plot()` command, and then
    mutate the empty plot once for each function. Since the `for` loop doesn’t return
    a result, we won’t see anything until the final call after the loop, which simply
    makes some plot settings. In the plotting statements, the `label` setting defines
    the text associated with that plot in the legend. It expects a string (or symbol),
    but can convert the integer `n`. The `lw` setting makes the lines thicker than
    the default. The `ls` setting is for the line style. It can take the values `:auto`,
    `:solid`, `:dash`, `:dot`, `:dashdot`, or `:dashdotdot`. The option used here,
    `:auto`, cycles through the other five styles, reusing them if the plot has more
    than five curves. It’s a good choice for print when we can’t use color. [Figure
    4-12](ch04.xhtml#ch4fig12) shows the results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-12: The five line styles*'
  prefs: []
  type: TYPE_NORMAL
- en: The final `plot()` statement sets `legend` to place it at the top left of the
    plot. We can use other similar positioning symbols, optionally preceded by `outer`
    to place the legend outside the axes. For more precise positioning we can use
    an `(x, y)` tuple specifying the coordinates of the legend box. Finally, we can
    set `legend=false` to omit the legend.
  prefs: []
  type: TYPE_NORMAL
- en: '***LaTeX Titles and Label Positioning by Data***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s plot the same functions with a different style of labeling. We’ll use
    annotations to place labels indicating each exponent on top of each corresponding
    curve, as shown in [Listing 4-1](ch04.xhtml#ch4lis1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-1: Using calculated labels and a LaTeX title*'
  prefs: []
  type: TYPE_NORMAL
- en: Here we calculate coordinates for each of the five labels within the loop. The
    x-coordinate increases to the right with the exponent, to space out the labels
    so they don’t overlap. The label’s y-coordinate ➊ is the same function of *x*
    as the curves we’re plotting, to ensure that they lie precisely on the curves
    that they’re labeling.
  prefs: []
  type: TYPE_NORMAL
- en: The setting for the `annotation` has `n`, a variable holding an integer, where
    there should be a `String`, but the `plot()` function converts it for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then import a package we haven’t seen before: `LaTeXStrings` (note the capitalization)
    lets us put math in our plot titles and annotations using LaTeX syntax. Even non-LaTeX
    users may still need equations in graphs occasionally, and LaTeX’s math syntax
    is straightforward. Check “Further Reading” on [page 121](ch04.xhtml#fur4) for
    a link to a guide. After importing this package, we can prepend `L` to any string
    to turn it into a LaTeX string. In a context where typesetting is possible, such
    as in a plot, Julia will typeset the string appropriately. The entire string is
    in LaTeX math mode, where all letters are treated as mathematical symbols. Therefore,
    if we need some normal text, as we did in this example ➋, we must wrap it in a
    LaTeX command to force it to be set as such. Within these text segments, indicate
    spaces with a tilde (`~`). The plot in [Figure 4-13](ch04.xhtml#ch4fig13) shows
    the result of this REPL session.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-13: Using calculated labels and a LaTeX title*'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the settings for individual plot elements, two others make larger-scale
    changes. The `thickness_scaling` setting is useful for creating a version of the
    plot with better legibility for presentation. It thickens everything, including
    tick labels. It affects the margins as well, however, and can change the positioning
    of plot elements. Setting the values between 1 and 1.7 produces useful results.
    Use values less than 1 to create a spindly version of the plot.
  prefs: []
  type: TYPE_NORMAL
- en: '***Regression Lines***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `smooth` setting draws a line of best fit, calculated by linear regression,
    through each curve or dataset on the plot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s return to the gingerbread map and, using the same initial conditions,
    calculate 20,000 iterations with *a* = 1*.*6, again storing the results in the
    `x` and `y Vector`s. We’ll make two subplots. The first will be a scatterplot
    similar to [Figure 4-9](ch04.xhtml#ch4fig9), but with a regression line showing
    the average orientation of the points. The second will plot the first 100 values
    of `x` versus iteration number, with a regression line showing the trend of a
    gradually increasing distance from the origin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First we create a scatterplot of the map as before, adding the trend line with
    the setting `smooth=true`, and assign the result to `sc`. Then we plot the initial
    100 *x*-values, also with a trend line. Plotting the two subplots together with
    a title gives us [Figure 4-14](ch04.xhtml#ch4fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-14: Trends in the gingerbread map*'
  prefs: []
  type: TYPE_NORMAL
- en: As before, the `plot_title` attribute creates an overall title for the two plots.
    We wanted the plotted curve and the calculated trend line to have different styles,
    but there’s no setting for this, so we resorted to a trick, over-plotting the
    curve in a different style but without a trend line ➊.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving Plots**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you’re ready to save your creation to disk, call savefig(p, path) where
    p is the variable holding the visualization and path is the location where you
    would like the image file stored. The filename extension to path determines the
    format, but different backends support different types of images. PDF and PNG
    should always be available, and SVG is also widely supported.
  prefs: []
  type: TYPE_NORMAL
- en: If we omit `p`, it defaults to the current plot. A common workflow is to repeatedly
    mutate a plot, making adjustments until it’s satisfactory, and then call `savefig(`path`)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Detail Insets**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An inset plot is a small plot inside the frame of a larger one. It’s often used
    to provide a magnified view of a section of the outer plot. Julia’s plotting system
    has a built-in function for creating this type of detail inset, called `lens!()`.
    It exists only in a mutating form because the inset plot makes sense only as an
    addition to an existing plot.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to `lens!()` either is an existing plot or is omitted to
    indicate the current plot. The next two arguments are vectors defining the rectangular
    region to be magnified. The required argument `inset` specifies which subplot
    gets the inset as well as the inset’s position and size. The diagram in [Figure
    4-15](ch04.xhtml#ch4fig15) shows how to use these arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-15: How to make an inset*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-15](ch04.xhtml#ch4fig15) uses a blank plot with a grid for illustration.
    The annotations “width” and “height” refer to the width and height of the outer
    plot. The complete command that created the inset is shown near the bottom of
    the plot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an application for `lens!()`, I constructed another instance of the gingerbread
    map, this time with *a* = 1*.*4 and 100,000 iterations to produce more detail.
    The following two lines first create the scatterplot and then add the inset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the call to `lens!()`, the settings ➊ for the `ticks` and `Framestyle` apply
    to the inset plot, while the `linecolor` and `linestyle` settings apply to the
    drawing of the magnifying glass that delineates the expanded area. A full frame
    style is a good choice for an inset plot.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-16](ch04.xhtml#ch4fig16) shows the result. I’ve used the inset plot
    to magnify one of the corners of the gingerbread map, showing the pattern of points
    within it.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-16: Using a detail inset to magnify a section of the gingerbread
    map*'
  prefs: []
  type: TYPE_NORMAL
- en: The setting `subplot=2` in the call that creates the inset ensures that the
    other graph settings in that call apply only to the inset, which becomes the second
    subplot. By referring to the number of the subplot, we could create an inset within
    the inset, if we were so inclined.
  prefs: []
  type: TYPE_NORMAL
- en: '**3D Plots**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Several types of plots visualize a quantity that depends on two independent
    variables. When in rectangular coordinates, the dependent variable is conventionally
    called *z*, and the two independent variables are called *x* and *y*. The three
    common ways to represent such a relationship are with a surface plot, a heatmap,
    or a contour plot. Which is most effective depends on the nature of the data and
    the features we’re trying to clarify.
  prefs: []
  type: TYPE_NORMAL
- en: '***Surface Plots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After importing the plotting package with `using Plots`, we have access to several
    3D plotting routines. For a *surface plot*, we use the `surface()` function to
    create a perspective rendering of a 2D surface embedded in a 3D space, with the
    height and coloring of the surface indicating the *z*-value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few additional settings that apply to surface plots:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Draw a colorbar: `colorbar` (`true` or `false`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Opacity of the surface: `fillalpha`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Angle of view: `camera` (azimuth, elevation) (in degrees)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Colorbar title: `cbtitle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Surface palette: `c`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s put some of these settings to use in making a surface plot of a Gaussian
    distribution of two variables. After defining a vector *x* to go from –1 to 1,
    we can use anonymous function syntax to plot the surface with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We use an alpha less than 1 in order to see through the surface, and rotated
    the axis tick labels to make them easier to read and to keep them from colliding
    where the axes meet. [Figure 4-17](ch04.xhtml#ch4fig17) shows the surface plot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-17: A surface plot*'
  prefs: []
  type: TYPE_NORMAL
- en: The `c` setting defines the palette used to color the surface. There are several
    ways to define the palette; the one used earlier, with a number of colors in a
    `Vector`, creates a palette by smoothly interpolating between them. `Gray(0)`
    is black, `Gray(1)` is white, and so on. We can also define colors with `RGB(r,
    g, b)`, where `r`, `g`, and `b` are the red, green, and blue components, also
    ranging from `0` (absent) to `1` (fully saturated). Over 600 color names are available
    as symbols, including both memorable names such as `:red` and `:blue` and meaningless
    ones such as `:seashell3` and `:oldlace`.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a `Vector` of colors, we can supply a symbol giving the name of a
    predefined palette, of which there are scores listed at [*https://docs.juliaplots.org/latest/generated/colorschemes/*](https://docs.juliaplots.org/latest/generated/colorschemes/).
    The more useful ones have names such as `:blues` or `:grays` that use one hue
    and vary the saturation and lightness, but there are plenty to choose from for
    special purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '***Heatmaps***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A heatmap also visualizes a mapping of two independent variables to one dependent
    variable, but the values of the independent variable are indicated by a color
    or gray value. The call is similar to a surface plot, but uses the `heatmap()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This call creates the heatmap shown in [Figure 4-18](ch04.xhtml#ch4fig18).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-18: A heatmap of a 2D Gaussian*'
  prefs: []
  type: TYPE_NORMAL
- en: Color palettes for heatmaps work the same way as for surface plots.
  prefs: []
  type: TYPE_NORMAL
- en: '***Contour Plots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Contour plots are similar to heatmaps, but they use isolines rather than color
    to indicate the values of the independent variable. Here are a few important attributes
    specific to contour plots:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of contours or specific contour levels: `levels` (integer or vector
    of levels)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Draw contour labels (Boolean): `clabels`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fill areas between contours (Boolean): `fill`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we supply an integer for `levels`, Julia will draw that many contours. If
    we also set `clabels` to `true`, it will label the contour lines with the values
    they represent. Unfortunately, these numerical labels are printed with too many
    digits and often become crowded. If we set `levels` to a `Vector` of numbers,
    the plot will have contours at just those values, and their labels will be printed
    using the same precision used for the `levels`. The following example shows this
    use of `levels` and `clabels`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This call uses the same `x` vector and plots the same function as the surface
    plot and heatmap examples shown in [Figures 4-17](ch04.xhtml#ch4fig17) and [4-18](ch04.xhtml#ch4fig18).
    The result, in [Figure 4-19](ch04.xhtml#ch4fig19), shows the labels with one digit
    of precision.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-19: A labeled contour plot*'
  prefs: []
  type: TYPE_NORMAL
- en: The `:box framestyle` works well with contour plots. Eliminating the color bar
    is also a good idea. We can color the lines by setting a `c`, but this doesn’t
    always work well with every backend. If we find stray colors creeping into the
    contour lines, we can fix it with `c=:black`.
  prefs: []
  type: TYPE_NORMAL
- en: Line styles such as `:dot` work, but not `:auto`.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When using filled contours with some backends, including* GR*, and manually
    set contour levels, we must include a level greater than or equal to the maximum
    of the data, or the graph will not be properly drawn.*'
  prefs: []
  type: TYPE_NORMAL
- en: The `fill` attribute, when set to `true`, adds colors between the contour lines,
    resulting in a kind of discrete heatmap with contours. The `c` attribute defines
    the palette for these colors. The `contourf()` function is an alias for `contour()`
    with `fill=true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s repeat the previous contour plot ([Figure 4-19](ch04.xhtml#ch4fig19)),
    but this time leave the color bar in, turn on the `fill`, and use a grayscale
    palette:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 4-20](ch04.xhtml#ch4fig20) shows the filled contour plot.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-20: A filled contour plot*'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, having both contour labels and a color bar is somewhat redundant,
    as they carry the same information, but this may make the plot easier to interpret.
    There is an art to scientific visualization in creating a result that is both
    intuitively clear and quantitatively precise.
  prefs: []
  type: TYPE_NORMAL
- en: '***3D Parametric Plots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Parametric plots in 3D work just as they do in 2D, but they trace a path through
    3D space, with three functions of the single parameter giving the x-, y-, and
    z-coordinates. Unlike in 2D parametric plots, we must supply three vectors, and
    it doesn’t work with functions. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `plot()` function knows what to do when supplied with three vectors as positional
    arguments, producing the resulting 3D parametric plot shown in [Figure 4-21](ch04.xhtml#ch4fig21).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-21: An example of a 3D parametric plot*'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the attributes for lines as for ordinary 2D plots, and set the camera
    angle as for surface plots.
  prefs: []
  type: TYPE_NORMAL
- en: '***Vector Plots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A vector field maps every point in space to a vector, which can be represented
    by an arrow. The `Plots` package offers vector plots created with the `quiver()`
    function. Its first two arguments are `x` and `y Vector`s containing the coordinates
    of the start of the vectors. The displacements from those coordinates to the vectors’
    endpoints are stored in two other `Vector`s, placed in a `Tuple`, and assigned
    to a keyword argument also called `quiver`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to use `quiver()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: These three lines produce the vector plot in [Figure 4-22](ch04.xhtml#ch4fig22).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-22: A vector plot using* quiver()'
  prefs: []
  type: TYPE_NORMAL
- en: The `quiver()` function accepts all the attributes for curves; here we set the
    line width to get thicker arrows.
  prefs: []
  type: TYPE_NORMAL
- en: '***3D Scatterplots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Plots` can extend scatterplots into the third dimension. One way to visualize
    a 3D distribution of some quantity is to plot a regular 3D grid of markers while
    setting some marker attribute, such as size or opacity, to a function of the quantity.
    First we need to establish the grid by making `x`, `y`, and `z` `Vector`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This will create the coordinate arrays ranging from –1 to 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s imagine a planet sitting in the center of our grid. We could plot the
    shape of the gravitational potential due to the planet by first defining a potential
    function and then using it to set the marker size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The potential becomes large near the planet, so we need to limit the marker
    size with the `min()` function. It actually becomes infinite at (0, 0, 0), but
    Julia handles that gracefully. The result is shown in [Figure 4-23](ch04.xhtml#ch4fig23).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-23: A 3D scatterplot*'
  prefs: []
  type: TYPE_NORMAL
- en: We set an opacity to allow us to see through the markers. This is the same `scatter()`
    function that we used in 2D, but Julia knows what to do if we give it three positional
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Useful Backends**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`GR`, the current default backend, has the merit of being fast and capable
    of producing most basic categories of visualization.'
  prefs: []
  type: TYPE_NORMAL
- en: A few other backends are available for special purposes, but most of them require
    us to `add` them in the package manager before use.
  prefs: []
  type: TYPE_NORMAL
- en: '***UnicodePlots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `unicodeplots` backend plots directly in the terminal. It’s good for a quick
    look at some data, which it plots using characters. We can also use it to generate
    plots to paste into an email, but obviously it’s not suited to making figures
    for publication, and it can’t save plots.
  prefs: []
  type: TYPE_NORMAL
- en: To produce quick plots in the terminal, first execute add UnicodePlots in package
    mode, then call unicodeplots() to activate the backend.
  prefs: []
  type: TYPE_NORMAL
- en: The `unicodeplots` backend doesn’t support every plot type. It can make 2D plots,
    including scatterplots, but not contour or surface plots. However, `unicodeplots`
    can render colored heatmaps in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '***PyPlot***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `pyplot` backend uses Python’s Matplotlib, so it may be a good choice for
    those already familiar with that system. Although it can sometimes be a bit slow,
    it creates better plots than the default in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: '***PlotlyJS***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With the `plotlyjs` backend we can create interactive graphs for the web. Saving
    the plot with the *.html* file extension creates a file containing an HTML fragment
    that we can paste into a web page. The fragment loads some third-party JavaScript
    that supplies interactive controls for panning, zooming, and, for 3D plots, rotating
    in 3D space. Other forms of interactivity vary appropriately with the plot type.
    Two-dimensional plots display data values as the user hovers over the curve, and
    surface plots draw contours on the surfaces at the *z*-value of the mouse pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting is not at all fast, although the results look good and interaction
    is impressively responsive. Contour plots are better with `plotlyjs` than with
    `GR`, especially for colored contours, but the attributes for linewidth or linestyle
    have no effect, and manual levels don’t work.
  prefs: []
  type: TYPE_NORMAL
- en: When plotting from the REPL, a separate window pops up for each plot, using
    the same JavaScript interactivity as in the HTML files.
  prefs: []
  type: TYPE_NORMAL
- en: '***PGFPlots and PGFPlotsX***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I won’t say much about these, because they are useful only to those who have
    LaTeX installed and some knowledge of the LaTeX graphing system PGFPlots. Those
    who do use these systems should be aware of the two Julia interfaces to them.
    The difference between the two versions is that `PGFPlotsX`’s syntax is closer
    to what’s used directly in LaTeX. With `PGFPlots`, we can make extraordinary visualizations
    that are difficult to achieve through other means. LaTeX users who aren’t familiar
    with the system may want to acquaint themselves. This backend does depend on a
    LaTeX installation—not a trivial requirement.
  prefs: []
  type: TYPE_NORMAL
- en: '***HDF5***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: HDF5 stands for Hierarchical Data Format, version 5\. This backend does not
    display plots directly; its purpose is to bundle data and plots together into
    an HDF file. For anyone who uses HDF in their research, this package will be essential,
    but others will have no use for it.
  prefs: []
  type: TYPE_NORMAL
- en: The backend not only writes HDF files, it also can read them into the Julia
    session for display with other `Plots` backends.
  prefs: []
  type: TYPE_NORMAL
- en: '***Gaston***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Gaston` is an interface to gnuplot and depends on a gnuplot installation.
    This backend will be of interest to those already using that venerable and powerful
    graphics program.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Gaston` is fast and powerful, because gnuplot is fast and powerful. If you
    routinely need to make complex 3D plots that the other backends can’t handle,
    or need more fine control over plots for publication, installing gnuplot and using
    it with `Gaston` may be the best choice.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Layouts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier in this chapter we saw that the `plot()` function will arrange graphs
    in a grid if we pass it a number of plot objects. Sometimes we need more control
    over the arrangement of subplots in an illustration. In such cases, we turn to
    the `Layout` system.
  prefs: []
  type: TYPE_NORMAL
- en: The plotting package’s method for composing plots into larger illustrations
    is one of the jewels of the system. Considering the complexity that it allows,
    it’s remarkably intuitive to use.
  prefs: []
  type: TYPE_NORMAL
- en: In the following demonstrations, the `Vector s` contains six plots, each displaying
    a prominent digit, from 1 to 6\. This will make it clear where the layout engine
    positions each plot.
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to follow along, you’ll need to create your own `s` vector, with
    plots of your choosing.
  prefs: []
  type: TYPE_NORMAL
- en: '***Making Simple Rectangular Layouts***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To replace the default square grid of plots with a different rectangular arrangement,
    supply the desired number of rows and columns as a tuple assigned to the `layout`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As [Figure 4-24](ch04.xhtml#ch4fig24) shows, this call arranges the plots using
    one row and four columns.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-24: A one-row layout*'
  prefs: []
  type: TYPE_NORMAL
- en: The number of plots implied in the layout tuple must match exactly the number
    of subplots. The default in this case would be equivalent to `layout=(2, 2)`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using grid()***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The simple layouts in the previous example make all the subplots the same size.
    To control the heights and widths of the rows and columns, use the `grid()` function,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This call creates the layout in [Figure 4-25](ch04.xhtml#ch4fig25). We can omit
    either the `height` or the `width` specification to get equalized lengths in that
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-25: A layout using the* grid() *function*'
  prefs: []
  type: TYPE_NORMAL
- en: When using `grid()`, the dimensions can add up to less than 1, which will simply
    leave some blank space, but they should not add to greater than 1.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Complex Layouts Using @layout***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can create layouts of arbitrary complexity. The next level requires the use
    of the `@layout` macro. We haven’t seen macros yet; they’re introduced in “Macros”
    on [page 170](ch06.xhtml#ch06lev4). For now, I’ll show how to use this particular
    macro to create graph layouts. We’ll be better equipped to understand how it works
    under the hood after we learn a bit more about the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@layout` macro creates a layout that follows the shape of a matrix that
    we supply to the macro. We use spaces to place subplots horizontally and newlines
    or semicolons to place them vertically, as when constructing actual matrices.
    However, these `@layout` matrices don’t need to have matching dimensions. As in
    the following example, the rows can have different numbers of elements. I use
    `a` to represent a subplot, but we can use any identifiers. They have no meaning,
    as the layout engine just uses the plots in the order we supply them in the `plot()`
    function. Here’s a simple use of the macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 4-26](ch04.xhtml#ch4fig26) shows the resulting layout. Observe how
    the arrangement of subplots follows the arrangement of the `a` placeholders used
    in the macro.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-26: Using the @layout macro*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of `@layout` in this form equalizes the space allotted to the subplots.
    To change the height or width of any of them, use the notation in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The specifications inside the curly brackets are width or height as a fraction
    of the entire plot. This call creates the layout in [Figure 4-27](ch04.xhtml#ch4fig27).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-27: Using the @layout macro with dimension specifications*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can achieve even greater flexibility in layouts by using a call to `grid()`
    within the `@layout` argument, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The number of subplots passed to the `@layout` macro must equal the number in
    the positional arguments to `plots()`. The `grid(2, 2)` call here accounts for
    four subplots, and the remaining two are represented by `a` and `b`. [Figure 4-28](ch04.xhtml#ch4fig28)
    shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-28: Using subgrids within a layout*'
  prefs: []
  type: TYPE_NORMAL
- en: “Detail Insets” on [page 106](ch04.xhtml#ch04lev9) explained how to create inset
    plots that magnified a section of a main plot. We can use the `inset` and `subplot`
    attributes that we used there to make any kind of inset, not merely one using
    `lens!()`, and we can combine it with any layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the layout in the previous example, we can add an inset to it
    with this call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `inset` attribute is set to a `bbox`. Since we didn’t supply it with a positional
    argument, the `bbox` parameters will position the plot relative to the entire
    layout, rather than any particular subplot. The `subplot=7` setting makes the
    inset into a new subplot, which is necessary to make this work as intended, as
    the layout already has six subplots. `RGBA` is similar to the `RGB` that we saw
    before, but with a final parameter for the opacity.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-29](ch04.xhtml#ch4fig29) shows the result of adding the inset.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-29: Adding a floating inset to a layout*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter covered everything about the `Plots` package that you’ll need
    for most scientific graphics: the main types of plots, lenses and annotations,
    how to customize appearance, and how to lay out sets of graphs to form a composite
    illustration. In [Chapter 7](ch07.xhtml) we’ll find out how to make animations
    and explore some packages to create diagrams, and in [Chapter 8](ch08.xhtml) we’ll
    revisit the plotting system to learn about plot recipes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  prefs: []
  type: TYPE_NORMAL
- en: The official reference for the `Plots` package is available at [*https://docs.juliaplots.org/latest/*](https://docs.juliaplots.org/latest/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s where you can find a video about `Plots` by its creator: [*http://www.breloff.com/plots-video*](http://www.breloff.com/plots-video).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a useful guide to making publication-quality plots, visit [*https://nextjournal.com/leandromartinez98/tips-to-create-beautiful-publication-quality-plots-in-julia*](https://nextjournal.com/leandromartinez98/tips-to-create-beautiful-publication-quality-plots-in-julia).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information on the HDF5 format is available at [*https://www.hdfgroup.org/solutions/hdf5*](https://www.hdfgroup.org/solutions/hdf5).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on using HDF5 files in Julia is available at [*https://juliaio.github.io/HDF5.jl/stable/*](https://juliaio.github.io/HDF5.jl/stable/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on predefined palettes for plots, visit [*https://docs.juliaplots.org/latest/generated/colorschemes/*](https://docs.juliaplots.org/latest/generated/colorschemes/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Gaston` headquarters, at [*https://mbaz.github.io/Gaston.jl/stable*](https://mbaz.github.io/Gaston.jl/stable),
    contains a well-chosen illustration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information and software downloads for gnuplot are available at [*http://gnuplot.info*](http://gnuplot.info).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of LaTeX math syntax are available at [*https://www.cs.princeton.edu/courses/archive/spr10/cos433/Latex/latex-guide.pdf*](https://www.cs.princeton.edu/courses/archive/spr10/cos433/Latex/latex-guide.pdf)
    (see Section 7).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Documentation on a Julia wrapper over the powerful *plotly.js* interactive
    plotting system is available through the `plotlyjs` package: [*https://plotly.com/julia/*](https://plotly.com/julia/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
