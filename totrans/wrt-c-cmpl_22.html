<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch19">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_556" aria-label="556"/>&#13;
<figure class="co-img"><img id="fig-pg556" class="img40" src="../images/pg556.jpg" alt="" width="691" height="2236"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11"> <a href="description-51.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_557" aria-label="557"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch19">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">19</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">OPTIMIZING TACKY PROGRAMS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.jpg" alt="" width="407" height="405"/></figure>&#13;
<p class="ChapterIntro">In the first two parts of this book, you wrote a compiler that supported much of the C language. You made sure that the executable programs you produced were correct— in other words, that their behavior conformed to the C standard—but you didn’t worry about their performance. You didn’t try to make them run faster, take up less storage space, or consume less memory. In <span class="chapterintro_Xref-1"><a href="part3.xhtml">Part III</a></span>, you’ll focus on <i>optimizing</i> these programs—that is, making them smaller and faster without changing their behavior.</p>&#13;
<p class="TX">Some compiler optimizations are <i>machine-independent</i>. This means they aren’t affected by the details of the target architecture, like the number of available registers or constraints on specific assembly instructions. A compiler typically performs these optimizations on an intermediate <span role="doc-pagebreak" epub:type="pagebreak" id="pg_558" aria-label="558"/>representation like TACKY before converting it to assembly. <i>Machine-dependent</i> optimizations, on the other hand, need to take the target architecture into account, so these are usually performed later, after the program has been converted to assembly. This chapter covers four widely used machine-independent optimizations: constant folding, unreachable code elimination, copy propagation, and dead store elimination. You’ll add a new optimization stage, bolded in the diagram at the start of the chapter, to apply these four optimizations to TACKY programs. The next chapter covers register allocation, a machine-dependent optimization.</p>&#13;
<p class="TX">You don’t need to complete <span class="Xref-1"><a href="part2.xhtml">Part II</a></span> before you start on <span class="Xref-1"><a href="part3.xhtml">Part III</a></span>. For each optimization, we’ll start with an implementation that doesn’t account for the language features from <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>. Then, if necessary, we’ll extend it to support those features; you’ll skip this step if you didn’t do <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>. We’ll need this extra step for every optimization except unreachable code elimination, which isn’t affected by the features from <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>.</p>&#13;
<p class="TX">These two chapters include just a few of the optimizations you’d find in a production compiler, but the basic concepts we’ll cover apply to lots of other optimizations too. Before we get started, let’s consider a question that’s fundamental to every compiler optimization: How do we know our optimized code is correct?</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1"><span id="sec1"/><span id="h1-171"/><samp class="SANS_Futura_Std_Bold_B_11">Safety and Observable Behavior</samp></h3>&#13;
<p class="TNI">First and foremost, compiler optimizations must be <i>safe</i>, meaning they cannot change the program’s semantics. (It doesn’t matter how speedy your program is if it doesn’t behave correctly!) In particular, an optimization must not change the program’s <i>observable behavior</i>, which is the behavior visible to its execution environment. Returning an exit status, printing a message to stdout, and writing to a file are all examples of observable behavior. Most of the actions that a program takes—like calculating values, updating local variables, and transferring control from one statement to another—are not visible to the execution environment, so they affect the program’s observable behavior only indirectly. This gives us lots of flexibility to transform the program. We can reorder, replace, and even delete code as long as the observable behavior doesn’t change.</p>&#13;
<p class="TX">Let’s look at how GCC optimizes a simple C program. <a href="chapter19.xhtml#list19-1">Listing 19-1</a> initializes three variables with the values <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>, then adds them up and returns the result.</p>&#13;
<a id="list19-1"/>&#13;
<pre><code>int main(void) {&#13;
    int x = 1;&#13;
    int y = 2;&#13;
    int z = 3;&#13;
    return x + y + z;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-1: A C program that adds three variables</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_559" aria-label="559"/>This program will have the same observable behavior every time it runs: it will terminate with an exit status of <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>. You can run the following command to compile the program without optimizations:</p>&#13;
<pre><code>$ <b>gcc -S -fno-asynchronous-unwind-tables -fcf-protection=none listing_19_1.c</b></code></pre>&#13;
<p class="TX">This will produce the assembly in <a href="chapter19.xhtml#list19-2">Listing 19-2</a>, or something similar.</p>&#13;
<a id="list19-2"/>&#13;
<pre><code>    .text&#13;
    .globl main&#13;
main:&#13;
    pushq   %rbp&#13;
    movq    %rsp, %rbp&#13;
    movl    $1, -4(%rbp)&#13;
    movl    $2, -8(%rbp)&#13;
    movl    $3, -12(%rbp)&#13;
    movl    -4(%rbp), %edx&#13;
    movl    -8(%rbp), %eax&#13;
    addl    %eax, %edx&#13;
    movl    -12(%rbp), %eax&#13;
    addl    %edx, %eax&#13;
    popq    %rbp&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-2: The unoptimized assembly for <a href="chapter19.xhtml#list19-1">Listing 19-1</a></samp></p>&#13;
<p class="TX">This assembly program faithfully implements <a href="chapter19.xhtml#list19-1">Listing 19-1</a>’s source code: it initializes three locations on the stack with the values <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>; adds them up; and then returns the result in EAX. Now let’s compile the same source code with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-O</samp> switch to enable optimizations:</p>&#13;
<pre><code>$ <b>gcc -S -O -fno-asynchronous-unwind-tables -fcf-protection=none listing_19_1.c</b></code></pre>&#13;
<p class="TX">This will generate the assembly in <a href="chapter19.xhtml#list19-3">Listing 19-3</a>.</p>&#13;
<a id="list19-3"/>&#13;
<pre><code>    .text&#13;
    .globl main&#13;
main:&#13;
    movl    $6, %eax&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-3: The optimized assembly for <a href="chapter19.xhtml#list19-1">Listing 19-1</a></samp></p>&#13;
<p class="TX">Instead of initializing three variables and then adding them up, this assembly program just returns the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>. <a href="chapter19.xhtml#list19-2">Listings 19-2</a> and <a href="chapter19.xhtml#list19-3">19-3</a> look quite different, but they both produce the right observable behavior.</p>&#13;
<aside class="box" aria-label="box-68"><p class="BoxTitle" id="box-68"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_560" aria-label="560"/><samp class="SANS_Dogma_OT_Bold_B_11">OBSERVABLE BEHAVIOR FOR PEDANTS</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">You can find a more formal definition of observable behavior in section 5.1.2.3, paragraph 6, of the C standard. This section lists three kinds of observable behaviors: operations on files, operations on interactive devices, and access to volatile objects. C programs can operate on files and interactive devices using the I/O functions in the standard library. An</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">interactive device</samp> <samp class="SANS_Futura_Std_Book_11">is typically a terminal or something similar, although the exact meaning is implementation-defined. The basic idea is that output to files can be buffered, but output to interactive devices needs to be delivered right away. The optimizations we implement in this chapter will preserve all function calls, including calls to standard library functions that operate on files and interactive devices.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">A</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">volatile object</samp> <samp class="SANS_Futura_Std_Book_11">is an object that interacts with the execution environment in ways that the compiler can’t understand. For example, it might be read by a signal handler or used to communicate with a hardware device through memory-mapped I/O. You declare a volatile object with the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp> <samp class="SANS_Futura_Std_Book_11">type qualifier. We didn’t implement this qualifier, so we don’t need to worry about volatile accesses.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">The C standard’s definition of observable behavior isn’t meant to be exhaustive; individual implementations can, and generally do, provide stronger guarantees about program behavior. So it’s understandable that this definition leaves out a lot of behaviors that you might expect to be observable, like launching a new process and other non-I/O system calls. More surprisingly, it leaves out some behaviors that are implied to be observable by other parts of the standard itself. For example, a program’s exit status isn’t an observable behavior under this definition, but section 5.1.2.2.3 states that the exit status should be “returned to the host environment.” Maybe there’s a good reason for this omission, but it seems like a problem with the standard to me.</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">In practice, no C compiler performs optimizations that might change a program’s exit status. Our compiler is no exception; its optimizations will preserve the return value of every function call, including the exit status returned by</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1"><span id="sec2"/><span id="h1-172"/><samp class="SANS_Futura_Std_Bold_B_11">Four TACKY Optimizations</samp></h3>&#13;
<p class="TNI">This section introduces the optimizations we’ll implement in this chapter: constant folding, unreachable code elimination, copy propagation, and dead store elimination. These optimizations aim to speed up our code and reduce the amount of space it takes up. Individually, some of them further one or both of these goals, while others aren’t particularly helpful on their own. The real payoff comes from the way they work together, because running any one of them creates new opportunities to apply the other three. We’ll look at these four optimizations in turn, then discuss how each one makes the others more effective.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_561" aria-label="561"/>Before we jump in, be aware that I’ll use minimal notation in most of this chapter’s TACKY listings. I’ll write copies as <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy(Var("x"), Var("y"))</samp>, as I’ve occasionally done in earlier chapters, and I’ll take similar shortcuts with other instructions. For example, I’ll write binary operations as <samp class="SANS_TheSansMonoCd_W5Regular_11">x = a + b</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Add, Var("a"), Var("b"), Var("x"))</samp> and labels as <samp class="SANS_TheSansMonoCd_W5Regular_11">Target:</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Label(Target)</samp>. This notation lets us focus on the high-level logic of our TACKY programs, not the details of each TACKY instruction.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2"><span id="sec3"/><span id="h2-204"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constant Folding</samp></h4>&#13;
<p class="TNI">The <i>constant folding</i> pass evaluates constant expressions at compile time. For example, constant folding will replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> TACKY instruction</p>&#13;
<pre><code>a = 6 / 2</code></pre>&#13;
<p class="BodyContinued">with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction:</p>&#13;
<pre><code>a = 3</code></pre>&#13;
<p class="TX">Constant folding can also turn conditional jumps into unconditional jumps or eliminate them entirely. It will transform</p>&#13;
<pre><code>JumpIfZero(0, Target)</code></pre>&#13;
<p class="BodyContinued">into</p>&#13;
<pre><code>Jump(Target)</code></pre>&#13;
<p class="BodyContinued">because the program will always make this jump. It will also delete the instruction</p>&#13;
<pre><code>JumpIfZero(1, Target)</code></pre>&#13;
<p class="BodyContinued">because the program will never make this jump. (Deleting useless jumps is often considered a type of dead code elimination rather than constant folding, but we’re transforming conditional jumps in this pass anyway, so we might as well delete the useless ones too.)</p>&#13;
<p class="TX">Constant folding helps with both speed and code size. A single arithmetic operation or comparison might require several assembly instructions. Some of those instructions, like <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>, are quite slow. Constant folding ultimately replaces that assembly code with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2"><span id="sec4"/><span id="h2-205"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unreachable Code Elimination</samp></h4>&#13;
<p class="TNI"><i>Unreachable code elimination</i> removes instructions that we know will never run. Consider the fragment of TACKY in <a href="chapter19.xhtml#list19-4">Listing 19-4</a>.</p>&#13;
<a id="list19-4"/>&#13;
<pre><code>x = 5&#13;
Jump(Target)&#13;
x = my_function()&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_562" aria-label="562"/>Target:&#13;
Return(x)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-4: A fragment of TACKY with an unreachable instruction</samp></p>&#13;
<p class="TX">Since we’ll always jump over the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">my_function</samp>, we can get rid of it:</p>&#13;
<pre><code>x = 5&#13;
Jump(Target)&#13;
Target:&#13;
Return(x)</code></pre>&#13;
<p class="TX">Now the <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> instruction is useless, since it jumps to the instruction that we’d execute next anyway. We’ll remove this instruction too:</p>&#13;
<pre><code>x = 5&#13;
Target:&#13;
Return(x)</code></pre>&#13;
<p class="TX">Finally, we can also eliminate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp> label, assuming no other instruction jumps to it:</p>&#13;
<pre><code>x = 5&#13;
Return(x)</code></pre>&#13;
<p class="TX">Strictly speaking, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> instructions we just removed aren’t unreachable code; a running program will reach both of them, though they won’t have any effect. But removing unreachable code often makes jumps and labels useless, so this pass is a logical place to remove them.</p>&#13;
<p class="TX">Eliminating unreachable code clearly reduces code size. It’s also pretty clear that removing useless jumps saves time; even a useless instruction takes some amount of time to execute. It turns out that removing truly unreachable instructions, like the <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> in <a href="chapter19.xhtml#list19-4">Listing 19-4</a>, can speed up the program too, by reducing memory pressure and freeing up space in the processor’s instruction cache.</p>&#13;
<p class="TX">Removing unused labels, on the other hand, won’t impact speed or code size, since labels don’t become machine instructions in the final executable. We’ll remove these labels anyway because it makes our TACKY programs a bit easier to read and debug and requires very little extra work.</p>&#13;
<p class="TX">This pass is especially handy for cleaning up the extra <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction we add to the end of every TACKY function. Recall that we add this instruction as a backstop in case the source code is missing a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement. When we convert a program to TACKY, we can’t tell whether this extra <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> is necessary, so we end up adding it to functions that don’t need it. The unreachable code elimination pass removes all the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instructions that we added unnecessarily, while retaining any that we actually need. This is one example of a broader principle: generating inefficient code and optimizing it later is often easier than generating efficient code to begin with.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_563" aria-label="563"/>&#13;
<h4 class="H2"><span id="sec5"/><span id="h2-206"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Copy Propagation</samp></h4>&#13;
<p class="TNI">When a program includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">dst = src</samp>, the <i>copy propagation</i> pass tries to replace <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> in later instructions. Take the following snippet of TACKY:</p>&#13;
<pre><code>x = 3&#13;
Return(x)</code></pre>&#13;
<p class="TX">We can replace <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with its current value, <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>, in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction:</p>&#13;
<pre><code>x = 3&#13;
Return(3)</code></pre>&#13;
<p class="TX">Replacing a variable with a constant is a special case of copy propagation called <i>constant propagation</i>. In other cases, we’ll replace one variable with another. For instance, we can rewrite</p>&#13;
<pre><code>x = y&#13;
Return(x)</code></pre>&#13;
<p class="BodyContinued">as:</p>&#13;
<pre><code>x = y&#13;
Return(y)</code></pre>&#13;
<p class="TX">Sometimes, figuring out whether it’s safe to perform copy propagation can be tricky. Take the following example:</p>&#13;
<pre><code>x = 4&#13;
JumpIfZero(flag, Target)&#13;
x = 3&#13;
Target:&#13;
Return(x)</code></pre>&#13;
<p class="TX">Depending on which path we take, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>’s value will be either <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> when we reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction. Since we don’t know which path we’ll take to that instruction, we can’t safely replace <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with either value. To handle cases like this one, we’ll need to analyze every possible path to the instruction we’d like to rewrite. We’ll use a technique called <i>data-flow analysis</i> to look at all the paths through a function and find the places where we can perform copy propagation safely. Data-flow analysis isn’t just useful for copy propagation; it’s used in lots of different compiler optimizations, including dead store elimination, which we’ll discuss next.</p>&#13;
<p class="TX">Some of the copies we analyze will involve variables with static storage duration, which can be accessed by multiple functions (or just multiple invocations of the same function, in the case of local static variables). We won’t always be able to tell exactly when these variables are updated, so our data-flow analysis will need to treat them a bit differently than variables with automatic storage duration. If you completed <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>, you’ll need to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_564" aria-label="564"/>account for similar uncertainty around variables whose address is taken with the <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator, since they can be updated through pointers.</p>&#13;
<p class="TX">Copy propagation isn’t useful by itself, but it makes our other optimizations more effective. When we propagate constants, we create new opportunities for constant folding. And we’ll sometimes replace every use of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction’s destination with its source, which makes the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> itself useless. We’ll remove these useless instructions in our last optimization pass: dead store elimination.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2"><span id="sec6"/><span id="h2-207"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dead Store Elimination</samp></h4>&#13;
<p class="TNI">When an instruction updates a variable’s value but we never use that new value, the instruction is called a <i>dead store</i>. (The term <i>store</i> here refers to any instruction that stores a value in a variable, not the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction we introduced in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>.) Because dead stores don’t impact a program’s observable behavior, it’s safe to remove them. Let’s look at a simple example:</p>&#13;
<pre><code>x = 10&#13;
Return(y)</code></pre>&#13;
<p class="TX">Assuming <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> has automatic storage duration, the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp> is a dead store. We don’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> between this instruction and the end of the function, which is also the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>’s lifetime.</p>&#13;
<p class="TX">Here’s another kind of dead store:</p>&#13;
<pre><code>x = a + b&#13;
x = 2&#13;
Return(x)</code></pre>&#13;
<p class="TX">In this example, we’ll never use the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">a + b</samp>, because we’ll overwrite it first; this means <samp class="SANS_TheSansMonoCd_W5Regular_11">x = a + b</samp> is a dead store. The dead store elimination pass will identify such useless instructions and remove them. The challenge is proving that an instruction really is a dead store; to do this, we’ll need to analyze every path through the function and make sure that the value it assigns to its destination is never used. Once again, we’ll use data-flow analysis to figure out when we can apply this optimization safely.</p>&#13;
<p class="TX">Like copy propagation, dead store elimination gets more complicated when you factor in objects that can be accessed by multiple functions or through pointers. For instance, if <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is a global variable, the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp> in our first example is <i>not</i> a dead store; <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> might be used after the function returns. Our data-flow analysis will have to take this possibility into account.</p>&#13;
<aside class="box-rule" aria-label="box-125"><p class="BoxTitle" id="box-125"><samp class="SANS_Dogma_OT_Bold_B_11">WHEN OPTIMIZATIONS ATTACK!</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Dead store elimination is safe in the sense that it won’t change a program’s observable behavior. But in another, more intuitive sense, it’s unsafe: it can</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_565" aria-label="565"/><samp class="SANS_Futura_Std_Book_11">make a program less secure. A conscientious, security-minded programmer will overwrite sensitive data as soon as they’re done processing it. The longer a secret lives in memory, the greater the risk that an attacker will be able to read it, perhaps by exploiting another vulnerability in the program or even dumping the entire system’s memory. Unfortunately, operations that clear sensitive data are often dead stores. Dead store elimination tends to, well, eliminate them. Consider this code fragment that tries to zero out an encryption key:</samp></p>&#13;
<pre><code>char *encryption_key = malloc(encryption_key_size);&#13;
// initialize encryption_key and use it to encrypt some things&#13;
--<var>snip</var>--&#13;
memset(encryption_key, 0, encryption_key_size);&#13;
free(encryption_key);&#13;
return 0;&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Normally, calling</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> <samp class="SANS_Futura_Std_Book_11">would zero out the buffer that</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">encryption_key</samp> <samp class="SANS_Futura_Std_Book_11">points to, preventing the data in that buffer from being leaked later on. But the compiler might optimize away the call to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> <samp class="SANS_Futura_Std_Book_11">because it’s technically a dead store; it just updates a buffer that we’ll never use again. Our implementation of dead store elimination wouldn’t remove</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> <samp class="SANS_Futura_Std_Book_11">from this example, because it never optimizes away function calls, but GCC and Clang actually do eliminate</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> <samp class="SANS_Futura_Std_Book_11">in code like this. You can compile a toy example to see for yourself.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">C programs can avoid this problem by clearing memory with a dedicated library function that the compiler knows not to optimize away. There are several platform-specific functions that serve this purpose, like</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">SecureZeroMemory</samp> <samp class="SANS_Futura_Std_Book_11">on Windows and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">explicit_bzero</samp> <samp class="SANS_Futura_Std_Book_11">on many Linux distributions. The</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_s</samp> <samp class="SANS_Futura_Std_Book_11">function to write to memory securely was added to the C standard library back in the C11 revision of the standard, but it’s part of an optional annex that was never widely implemented. C23 introduces a similar function that isn’t optional,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_explicit</samp><samp class="SANS_Futura_Std_Book_11">, so C programmers</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">finally</samp> <samp class="SANS_Futura_Std_Book_11">have a standard, portable way to clear sensitive data from memory.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Functions like</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_explicit</samp> <samp class="SANS_Futura_Std_Book_11">solve the immediate problem with dead stores. But they don’t address the more fundamental issue: the concept of observable behavior doesn’t cover every kind of behavior that programmers care about. The C standard guarantees that your code will behave the way you intended it to when everything goes right—when your code has no undefined behavior, the libraries it relies on have no undefined behavior, and nobody tampers with the underlying system—but it provides no guarantees about what happens when things go wrong. Without those guarantees, it’s difficult, and sometimes impossible, to write secure code. (If you’d like to learn more about the security impact of compiler optimizations, see “Additional Resources” on <a href="#pg_610">page 610</a> for links to a couple of relevant papers.)</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">We won’t worry about the security impact of the optimizations we implement here. If you’re using the compiler you wrote for this book to compile security-critical software, dead store elimination is the least of your problems.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_566" aria-label="566"/>&#13;
<h4 class="H2"><span id="sec7"/><span id="h2-208"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">With Our Powers Combined …</samp></h4>&#13;
<p class="TNI">Now let’s look at how the four optimizations we’ll implement in this chapter work together. We’ll use the TACKY program in <a href="chapter19.xhtml#list19-5">Listing 19-5</a> as a running example.</p>&#13;
<a id="list19-5"/>&#13;
<pre><code>my_function(flag):&#13;
    x = 4&#13;
    y = 4 - x&#13;
    JumpIfZero(y, Target)&#13;
    x = 3&#13;
    Target:&#13;
    JumpIfNotZero(flag, End)&#13;
    z = 10&#13;
    End:&#13;
    z = x + 5&#13;
    Return(z)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-5: An unoptimized TACKY program</samp></p>&#13;
<p class="TX">Using all four optimizations, we can reduce this function to a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction. I’ll display the results of each round of optimization, highlighting any changed instructions. Because each optimization can create more opportunities to apply the other three, we’ll need to run most of them several times to fully optimize this function. For now, we’ll decide which optimization to run at each step in an ad hoc way, by looking at the code and seeing which one will be most useful. We’ll use a more systematic approach when we actually implement our optimization pipeline.</p>&#13;
<p class="TX">Let’s start with a copy propagation pass, substituting <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 4 - x</samp>:</p>&#13;
<pre><code>my_function(flag):&#13;
    x = 4&#13;
<b>    y = 4 - 4</b>&#13;
    JumpIfZero(y, Target)&#13;
    x = 3&#13;
    Target:&#13;
    JumpIfNotZero(flag, End)&#13;
    z = 10&#13;
    End:&#13;
    z = x + 5&#13;
    Return(z)</code></pre>&#13;
<p class="TX">We can’t replace the second use of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, in <samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + 5</samp>, because <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> has more than one possible value at that point: it might be <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, depending on whether we take the conditional jump. Next, we’ll apply constant folding to evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 4 - 4</samp>:</p>&#13;
<pre><code>my_function(flag):&#13;
    x = 4&#13;
<b>    y = 0</b>&#13;
    JumpIfZero(y, Target)&#13;
    x = 3&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_567" aria-label="567"/>    Target:&#13;
    JumpIfNotZero(flag, End)&#13;
    z = 10&#13;
    End:&#13;
    z = x + 5&#13;
    Return(z)</code></pre>&#13;
<p class="TX">By replacing a binary operation with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction, we’ve created another opportunity for copy propagation. We can replace <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> with its value, <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, in the <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> instruction:</p>&#13;
<pre><code>my_function(flag):&#13;
    x = 4&#13;
    y = 0&#13;
<b>    JumpIfZero(0, Target)</b>&#13;
    x = 3&#13;
    Target:&#13;
    JumpIfNotZero(flag, End)&#13;
    z = 10&#13;
    End:&#13;
    z = x + 5&#13;
    Return(z)</code></pre>&#13;
<p class="TX">Now that <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> depends on a constant condition, we can run constant folding again to turn it into an unconditional <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>:</p>&#13;
<pre><code>my_function(flag):&#13;
    x = 4&#13;
    y = 0&#13;
<b>    Jump(Target)</b>&#13;
    x = 3&#13;
    Target:&#13;
    JumpIfNotZero(flag, End)&#13;
    z = 10&#13;
    End:&#13;
    z = x + 5&#13;
    Return(z)</code></pre>&#13;
<p class="TX">This change makes <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 3</samp> unreachable, so we’ll run unreachable code elimination to delete it. This pass will also remove the <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> instruction and <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp> label, which have no effect once we’ve removed <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 3</samp>:</p>&#13;
<pre><code>my_function(flag):&#13;
    x = 4&#13;
    y = 0&#13;
    JumpIfNotZero(flag, End)&#13;
    z = 10&#13;
    End:&#13;
    z = x + 5&#13;
    Return(z)</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_568" aria-label="568"/>We couldn’t rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + 5</samp> earlier, because <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> had two different values on the different paths to that instruction. We just solved that problem by eliminating the path through <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 3</samp>. Now we can run copy propagation again:</p>&#13;
<pre><code>my_function(flag):&#13;
    x = 4&#13;
    y = 0&#13;
    JumpIfNotZero(flag, End)&#13;
    z = 10&#13;
    End:&#13;
<b>    z = 4 + 5</b>&#13;
    Return(z)</code></pre>&#13;
<p class="TX">Then we’ll run another round of constant folding:</p>&#13;
<pre><code>my_function(flag):&#13;
    x = 4&#13;
    y = 0&#13;
    JumpIfNotZero(flag, End)&#13;
    z = 10&#13;
    End:&#13;
<b>    z = 9</b>&#13;
    Return(z)</code></pre>&#13;
<p class="TX">And we’ll run copy propagation one last time:</p>&#13;
<pre><code>my_function(flag):&#13;
    x = 4&#13;
    y = 0&#13;
    JumpIfNotZero(flag, End)&#13;
    z = 10&#13;
    End:&#13;
    z = 9&#13;
<b>    Return(9)</b></code></pre>&#13;
<p class="TX">We’ve managed to calculate this function’s return value at compile time, eliminating every use of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp> in the process. Now we’ll run dead store elimination to clean up the instructions that assign to these three variables:</p>&#13;
<pre><code>my_function(flag):&#13;
    JumpIfNotZero(flag, End)&#13;
    End:&#13;
    Return(9)</code></pre>&#13;
<p class="TX">Finally, we’ll run unreachable code elimination to remove the <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNot Zero</samp> instruction and the <samp class="SANS_TheSansMonoCd_W5Regular_11">End</samp> label. These are both redundant, since we <span role="doc-pagebreak" epub:type="pagebreak" id="pg_569" aria-label="569"/>just eliminated the one instruction that <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp> jumps over. This last round of optimization will reduce our function to a single instruction:</p>&#13;
<pre><code>my_function(flag):&#13;
    Return(9)</code></pre>&#13;
<p class="TX">This example highlighted some of the ways our optimizations work together. Copy propagation may replace variables with constants, creating new opportunities for constant folding; constant folding rewrites arithmetic operations as <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instructions, creating new opportunities for copy propagation. Constant folding can replace conditional jumps with unconditional ones, making some instructions unreachable; eliminating unreachable code simplifies the program’s control flow, which promotes copy propagation. Copy propagation may make <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instructions redundant, which lets us remove them during dead store elimination. And dead store elimination can potentially remove every instruction between a jump and the label it jumps to, which makes the jump, and possibly the label, candidates for unreachable code elimination.</p>&#13;
<p class="TX">Now we know what each optimization does and how they all work together. Next, we’ll add a few new command line options that will allow us to test them out.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1"><span id="sec8"/><span id="h1-173"/><samp class="SANS_Futura_Std_Bold_B_11">Testing the Optimization Passes</samp></h3>&#13;
<p class="TNI">This chapter’s tests work differently than the tests in earlier chapters. We need to verify that our optimizations don’t change the program’s observable behavior but do simplify constant expressions and remove useless code. Our current strategy—compiling C programs, running them, and making sure they behave correctly—satisfies the first requirement but not the second. Just running a program can’t tell you whether the optimization phase <i>did</i> anything. To address the second point, the test script will inspect your compiler’s assembly output for each test program. To address the first point, it will also run each test program and verify its behavior, like in earlier chapters.</p>&#13;
<p class="TX">To support this chapter’s tests, you’ll need to add a few command line options to your compiler:</p>&#13;
<p class="RunInParaF"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">-S</samp> Directs your compiler to emit an assembly file, but not assemble or link it. Running <samp class="SANS_TheSansMonoCd_W5Regular_11">./</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">YOUR_COMPILER</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-S /path/to/program.c</samp> should write an assembly file to <i>/path/to/program.s</i>. (I suggested adding this option to help with debugging back in <span class="runinpara_Xref-1"><a href="chapter1.xhtml">Chapter 1</a></span>; you’ll need to add it now if you haven’t already.)</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">--fold-constants</samp> Enables constant folding.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">--propagate-copies</samp> Enables copy propagation.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">--eliminate-unreachable-code</samp> Enables unreachable code elimination.</p>&#13;
<p class="RunInPara"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_570" aria-label="570"/><samp class="SANS_TheSansMonoCd_W7Bold_B_11">--eliminate-dead-stores</samp> Enables dead store elimination.</p>&#13;
<p class="RunInParaL"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">--optimize</samp> Enables all four optimizations.</p>&#13;
<p class="TX">The options to enable optimizations should be passed to the optimization stage, which we’ll implement next. It should be possible to enable more than one individual optimization; for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">./</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">YOUR_COMPILER</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">--fold-constants --propagate-copies</samp> should enable both constant folding and copy propagation, but not the other two optimizations.</p>&#13;
<p class="TX">If your compiler doesn’t generate assembly exactly the way I’ve laid out in this book, the test script should still be able to validate your assembly output for this chapter’s tests, but there are a couple of caveats to keep in mind. First, the test script understands only AT&amp;T assembly syntax, which is the syntax we’ve been using throughout the book. Second, the script doesn’t recognize every single assembly instruction; it only knows about the instructions we’ve used in this book and a handful of others that are particularly common in real-world assembly code. If you emit instructions that the test script doesn’t understand, some tests may fail.</p>&#13;
<p class="TX">Next, we’ll wire up the new optimization stage, which will control when we call each individual optimization.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1"><span id="sec9"/><span id="h1-174"/><samp class="SANS_Futura_Std_Bold_B_11">Wiring Up the Optimization Stage</samp></h3>&#13;
<p class="TNI">The optimization stage will run right after we convert the program to TACKY. This stage will optimize each TACKY function independently, without any knowledge of the other functions defined in the program. For example, it won’t try to evaluate function calls during the constant folding pass or remove them during dead store elimination. (We can’t remove function calls during dead store elimination because we don’t know whether they have side effects. We <i>can</i> remove them during unreachable code elimination, though—if a function call will never execute, it doesn’t matter what side effects the function has.) Optimizations like these, which transform one function at a time, are called <i>intraprocedural optimizations</i>. Most production compilers also perform <i>interprocedural optimizations</i>, which transform whole translation units instead of individual functions.</p>&#13;
<p class="TX">Each individual optimization will take the body of a TACKY function as input and return a semantically equivalent function body as output. In the constant folding pass, we’ll represent the function body as a list of TACKY instructions, like we normally do. But in the other three optimization passes, we’ll represent each function as a <i>control-flow graph</i>. This is an intermediate representation that explicitly models the different execution paths through a piece of code. We’ll talk more about how to construct control-flow graphs and why they’re useful later in the chapter.</p>&#13;
<p class="TX">The optimization stage will process each function by running through all of the enabled optimizations over and over. It will stop once it reaches a <i>fixed point</i>, where running them again doesn’t change the function further. <a href="chapter19.xhtml#list19-6">Listing 19-6</a> illustrates this optimization pipeline.</p>&#13;
<a id="list19-6"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_571" aria-label="571"/>optimize(function_body, enabled_optimizations):&#13;
    if function_body is empty:&#13;
        return function_body&#13;
&#13;
    while True:&#13;
        if enabled_optimizations contains "CONSTANT_FOLDING":&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> post_constant_folding = constant_folding(function_body)&#13;
        else:&#13;
            post_constant_folding = function_body&#13;
&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> cfg = make_control_flow_graph(post_constant_folding)&#13;
&#13;
        if enabled_optimizations contains "UNREACHABLE_CODE_ELIM":&#13;
            cfg = unreachable_code_elimination(cfg)&#13;
&#13;
        if enabled_optimizations contains "COPY_PROP":&#13;
            cfg = copy_propagation(cfg)&#13;
&#13;
        if enabled_optimizations contains "DEAD_STORE_ELIM":&#13;
            cfg = dead_store_elimination(cfg)&#13;
&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> optimized_function_body = cfg_to_instructions(cfg)&#13;
&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> if (optimized_function_body == function_body&#13;
            or optimized_function_body is empty):&#13;
            return optimized_function_body&#13;
&#13;
        function_body = optimized_function_body</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-6: The TACKY optimization pipeline</samp></p>&#13;
<p class="TX">In this listing, <samp class="SANS_TheSansMonoCd_W5Regular_11">function_body</samp> is the list of instructions in the body of a TACKY function and <samp class="SANS_TheSansMonoCd_W5Regular_11">enabled_optimizations</samp> is a list of strings representing the optimizations that we enabled on the command line. (This would be a pretty kludgy way to store command line options in a real program; feel free to represent these options differently in your own code.) If <samp class="SANS_TheSansMonoCd_W5Regular_11">function_body</samp> is empty, we’ll just return it, since there’s nothing to optimize. Otherwise, we’ll perform constant folding if it’s enabled <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">Next, we’ll convert the function body from a list of instructions into a control-flow graph <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We’ll apply all the other enabled optimizations to this representation. Then, we’ll convert the optimized control-flow graph back to a list of instructions <span class="CodeAnnotation" aria-label="annotation3">❸</span>, which we’ll compare to the original list <span class="CodeAnnotation" aria-label="annotation4">❹</span>. If it’s different, and if we haven’t optimized away the entire function, we’ll go through the loop again to take advantage of any new optimization opportunities. If it’s the same, we can’t optimize it any further, so we’re done.</p>&#13;
<aside class="box-rule" aria-label="box-126"><p class="BoxTitle" id="box-126"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_572" aria-label="572"/><samp class="SANS_Dogma_OT_Bold_B_11">HOW DO WE KNOW LISTING 19-6 WILL TERMINATE?</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">At first glance, it looks like the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">optimize</samp> <samp class="SANS_Futura_Std_Book_11">function in <a href="chapter19.xhtml#list19-6">Listing 19-6</a> might get caught in an infinite loop. The TACKY function we’re optimizing could keep changing on every iteration, without ever converging on a final result. But if we think about these optimizations more carefully, we can convince ourselves that the optimization pipeline must terminate.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">First, both dead store elimination and unreachable code elimination remove instructions, and none of our optimizations ever add new instructions. These two optimizations can’t keep changing a function forever, because we’ll eventually run out of instructions. To be more precise, if our TACKY function initially has</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">n</samp> <samp class="SANS_Futura_Std_Book_11">instructions, we’ll see at most</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">n</samp> <samp class="SANS_Futura_Std_Book_11">loop iterations where either of these optimizations changes anything.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Similarly, constant folding replaces several kinds of TACKY instructions (including</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp><samp class="SANS_Futura_Std_Book_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp><samp class="SANS_Futura_Std_Book_11">, type conversions, and conditional jumps) with other kinds of TACKY instructions (specifically</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> <samp class="SANS_Futura_Std_Book_11">and the unconditional</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> <samp class="SANS_Futura_Std_Book_11">instruction). None of our other optimizations will introduce the kinds of instructions that constant folding replaces. The constant folding pass can change a function only so many times before we’ve eliminated every instruction it could potentially rewrite.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">That leaves copy propagation. We’ve already put an upper bound on how many times each of the other optimizations can change a function, so</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">optimize</samp> <samp class="SANS_Futura_Std_Book_11">will terminate unless copy propagation by itself can get stuck in an infinite loop, changing the function every time we apply it. To see why this is impossible, let’s think about how many times copy propagation could rewrite a single instruction,</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">i</samp><samp class="SANS_Futura_Std_Book_11">. We’ll assume this instruction has one operand, but it’s easy to extend this logic to instructions with multiple operands. If there are no</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> <samp class="SANS_Futura_Std_Book_11">instructions on the shortest path to</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">i</samp><samp class="SANS_Futura_Std_Book_11">, we know that</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">i</samp> <samp class="SANS_Futura_Std_Book_11">will never be rewritten. (Keep in mind that we can propagate a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> <samp class="SANS_Futura_Std_Book_11">instruction only if it appears on</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">every</samp> <samp class="SANS_Futura_Std_Book_11">path to</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">i</samp><samp class="SANS_Futura_Std_Book_11">.) Now imagine there’s exactly one</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> <samp class="SANS_Futura_Std_Book_11">on the path to</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">i</samp><samp class="SANS_Futura_Std_Book_11">. In that case, we’ll be able to rewrite</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">i</samp> <samp class="SANS_Futura_Std_Book_11">at most once. We might propagate the value from that</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> <samp class="SANS_Futura_Std_Book_11">instruction to</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">i</samp><samp class="SANS_Futura_Std_Book_11">, but we won’t be able to rewrite it again after that. Now let’s generalize this: if there are</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">n</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> <samp class="SANS_Futura_Std_Book_11">instructions on the shortest path to</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">i</samp><samp class="SANS_Futura_Std_Book_11">, we’ll rewrite</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">i</samp> <samp class="SANS_Futura_Std_Book_11">at most</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">n</samp> <samp class="SANS_Futura_Std_Book_11">times. Whenever we rewrite</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">i</samp><samp class="SANS_Futura_Std_Book_11">, we replace its operand with another operand that was defined earlier on the shortest path to</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">i</samp> <samp class="SANS_Futura_Std_Book_11">(or with a constant). If we rewrite</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">i</samp> <samp class="SANS_Futura_Std_Book_11">multiple times, each rewrite must propagate a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> <samp class="SANS_Futura_Std_Book_11">instruction from earlier in the program than the one before, until there are no copies left to propagate.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">It’s helpful to look at an example:</samp></p>&#13;
<pre><code>w = foo()&#13;
x = w&#13;
y = x&#13;
Return(y)&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_573" aria-label="573"/><samp class="SANS_Futura_Std_Book_11">Initially, this code snippet returns</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp><samp class="SANS_Futura_Std_Book_11">, which is defined by</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp><samp class="SANS_Futura_Std_Book_11">. After one round of copy propagation, we’ll rewrite the final instruction as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp><samp class="SANS_Futura_Std_Book_11">. Of course,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_Futura_Std_Book_11">is defined before</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp><samp class="SANS_Futura_Std_Book_11">, in the instruction</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x = w</samp><samp class="SANS_Futura_Std_Book_11">. The next round of copy propagation will replace</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_Futura_Std_Book_11">with</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">w</samp><samp class="SANS_Futura_Std_Book_11">, which is defined even earlier, in the instruction</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">w = foo()</samp><samp class="SANS_Futura_Std_Book_11">. The key point here is that we’ll never replace one operand with another that’s defined later on the path to the instruction that we’re rewriting, so we can replace each operand only a finite number of times. Therefore, the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">optimize</samp> <samp class="SANS_Futura_Std_Book_11">function has to terminate.</samp></p>&#13;
</aside>&#13;
<p class="TX">Using the optimization pipeline in <a href="chapter19.xhtml#list19-6">Listing 19-6</a>, we’ll never miss an optimization opportunity. Whenever one optimization changes the program, we’ll rerun the other three to take advantage of those changes. This is feasible because we’re implementing only four optimizations, and all of our test programs are small enough to optimize pretty quickly. Production compilers, which implement dozens of optimizations and compile much larger programs, don’t take this approach; if they did, compilation would take way too long. Instead, they apply a fixed sequence of optimizations just once, running each individual optimization in the place where it’s likely to have the biggest impact. As a result, they can end up missing optimization opportunities. (Finding the best order to run optimizations for any given program is an open research question called the <i>phase ordering problem</i>.)</p>&#13;
<p class="TX">Go ahead and add the optimization pipeline to your compiler. For now, define each individual optimization as a stub that takes a list of instructions and returns them unchanged. You can stub out the conversions to and from control-flow graphs the same way. Write this plumbing code now so that you can test the individual optimization passes as you implement them.</p>&#13;
<p class="TX">Once everything is wired up, you can start on your first optimization: constant folding!</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1"><span id="sec10"/><span id="h1-175"/><samp class="SANS_Futura_Std_Bold_B_11">Constant Folding</samp></h3>&#13;
<p class="TNI">Constant folding is the simplest optimization in this chapter. This pass iterates through all the instructions in a TACKY function and evaluates any instructions with constant source operands. First, we’ll talk briefly about how to add constant folding to the version of the compiler you implemented in <span class="Xref-1"><a href="part1.xhtml">Part I</a></span>. Then, we’ll discuss how to handle the types and TACKY instructions you added in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>. If you haven’t worked through <span class="Xref-1"><a href="part2.xhtml">Part II</a></span> yet, feel free to skip the latter discussion.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2"><span id="sec11"/><span id="h2-209"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constant Folding for Part I TACKY Programs</samp></h4>&#13;
<p class="TNI">The constant folding pass should evaluate four of the TACKY instructions from <span class="Xref-1"><a href="part1.xhtml">Part I</a></span>: <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>. When you find a <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> instruction with a constant source operand, or a <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> instruction <span role="doc-pagebreak" epub:type="pagebreak" id="pg_574" aria-label="574"/>with two constant source operands, replace it with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>. For example, you should replace</p>&#13;
<pre><code>Binary(binary_operator=Add, src1=Constant(1), src2=Constant(2), dst=Var("b"))</code></pre>&#13;
<p class="BodyContinued">with:</p>&#13;
<pre><code>Copy(src=Constant(3), dst=Var("b"))</code></pre>&#13;
<p class="TX">Your constant folding pass could run into two kinds of invalid expressions: division by zero and operations that result in integer overflow. These are both undefined behaviors, so it doesn’t matter how you evaluate them. However, your compiler can’t just fail if it encounters one of these invalid expressions, because the program’s behavior is undefined only if it actually reaches the invalid expression at runtime. For example, if a program includes division by zero in a branch that’s never taken, you should still be able to compile it.</p>&#13;
<p class="TX">You should also evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp> instructions with constant conditions. If the condition is met, replace the instruction with an unconditional <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>. If the condition isn’t met, remove the instruction from the program. That’s all there is to it! If you completed only <span class="Xref-1"><a href="part1.xhtml">Part I</a></span>, you can skip to the test suite once you’ve implemented constant folding for these four instructions. If you completed <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>, there are a few more instructions you’ll need to handle.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2"><span id="sec12"/><span id="h2-210"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Supporting Part II TACKY Programs</samp></h4>&#13;
<p class="TNI">When we added the new arithmetic types in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>, we also added type conversion instructions: <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble</samp>. The constant folding pass should evaluate all of these instructions when their source operands are constants.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction can perform type conversions too; we use it to convert between signed and unsigned integers of the same size. When a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction copies an unsigned constant to a signed variable, or vice versa, this pass should convert the constant to the correct type. For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, you should replace</p>&#13;
<pre><code>Copy(src=Constant(ConstUChar(255)), dst=Var("a"))</code></pre>&#13;
<p class="BodyContinued">with:</p>&#13;
<pre><code>Copy(src=Constant(ConstChar(-1)), dst=Var("a"))</code></pre>&#13;
<p class="TX">Be careful to perform every type conversion with exactly the same semantics that the program would use at runtime. For example, when you convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to an integer type, truncate its value toward zero; when you convert an integer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, round to the nearest representable value. The good news is that you already know how to perform all of these type conversions at compile time, since you had to convert static initializers to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_575" aria-label="575"/>the correct type throughout <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>. Ideally, you’ll be able to reuse the code you’ve already written to perform these type conversions.</p>&#13;
<p class="TX">You’ll also need to adhere to C semantics when you evaluate unsigned arithmetic operations. In particular, you should ensure that unsigned arithmetic wraps around, like it would at runtime. How you accomplish this will depend entirely on what language you’re writing your compiler in. Some languages support wraparound unsigned arithmetic as part of their standard library. In Rust, for example, methods like <samp class="SANS_TheSansMonoCd_W5Regular_11">wrapping_add</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">wrapping_sub</samp> provide the same semantics as unsigned arithmetic in C. In other languages, you might use a third-party library for unsigned arithmetic. For example, Python doesn’t provide unsigned integer types, but the NumPy library does. If you don’t want to use an external library, or you can’t find a suitable one, it isn’t terribly difficult to implement wraparound unsigned arithmetic yourself.</p>&#13;
<p class="TX">Finally, when you evaluate floating-point operations, you’ll need to use round-to-nearest, ties-to-even rounding and handle negative zero and infinity correctly. If you added support for NaN for extra credit in <span class="Xref-1"><a href="chapter13.xhtml">Chapter 13</a></span>, you’ll need to evaluate operations on NaN correctly too. This shouldn’t require any special effort on your part—the vast majority of programming languages use IEEE 754 semantics—but there’s a small chance that your implementation language handles negative zero, NaN, or infinity differently than C. Start with a simple implementation of constant folding that doesn’t try to address these edge cases; you can rely on the test suite to catch any problems. If you run into any cases that your implementation language doesn’t evaluate correctly, you have two options: either find a third-party library to handle them for you or evaluate them yourself as a special case.</p>&#13;
<aside class="box" aria-label="box-69"><p class="BoxTitle" id="box-69"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE CONSTANT FOLDING PASS</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">If you completed Part I but not</samp> <samp class="SANS_Futura_Std_Book_11">Part II, use the following command to test your constant folding implementation:</samp></p>&#13;
<pre><code>$ <b>./test_compiler </b><b><var>/path/to/your_compiler</var></b><b> --chapter 19 --fold-constants</b>&#13;
<b>--int-only</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">This will run the tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_19/constant_folding/int_only</samp><samp class="SANS_Futura_Std_Book_11">, which use only language features from Part I. It will also compile all the test programs from Part I with constant folding enabled. It won’t inspect the assembly output for these earlier test programs, but it will run them to confirm that they still behave correctly.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">If you completed Parts I and II, run the same command without the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">--int-only</samp> <samp class="SANS_Futura_Std_Book_11">option:</samp></p>&#13;
<pre><code>$ <b>./test_compiler </b><b><var>/path/to/your_compiler</var></b><b> --chapter 19 --fold-constants</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_576" aria-label="576"/><samp class="SANS_Futura_Std_Book_11">This command runs both the Part I–specific tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_19/constant_folding/int_only</samp> <samp class="SANS_Futura_Std_Book_11">and the tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_19/constant_folding/all_types</samp><samp class="SANS_Futura_Std_Book_11">, which cover constant folding with types besides</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp><samp class="SANS_Futura_Std_Book_11">. It will also run all the tests from Parts I and II with constant folding enabled. As usual, you can include the appropriate flags to verify that your constant folding pass correctly handles extra credit features like NaN and bitwise operations.</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Until you implement copy propagation, your compiler won’t be able to fully evaluate nested source-level expressions that involve more than one operation, like</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-1 * 2</samp><samp class="SANS_Futura_Std_Book_11">, because it can’t propagate the result from one operation to the next. This means the test suite can’t exercise certain cases yet, including constant folding with negative numbers or constants of character type. The tests for the whole pipeline, which you’ll run at the end of the chapter, will cover these cases. In the meantime, you might want to write your own unit tests to fill in those gaps.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h3 class="H1"><span id="sec13"/><span id="h1-176"/><samp class="SANS_Futura_Std_Bold_B_11">Control-Flow Graphs</samp></h3>&#13;
<p class="TNI">For the rest of the chapter, we’ll represent TACKY functions as control-flow graphs. A graph representation is a good fit for our remaining optimizations, which have to account for the different paths we might take through a function. The nodes in the control-flow graph represent sequences of straight-line code called <i>basic blocks</i>, except for two special nodes that represent the function’s entry and exit points. Each node has outgoing edges to the nodes that could execute immediately after it.</p>&#13;
<p class="TX">As an example, let’s look at the control-flow graph for <a href="chapter19.xhtml#list19-7">Listing 19-7</a>.</p>&#13;
<a id="list19-7"/>&#13;
<pre><code>processing_loop():&#13;
    LoopStart:&#13;
    input = get_input()&#13;
    JumpIfNotZero(input, ProcessIt)&#13;
    Return(-1)&#13;
    ProcessIt:&#13;
    done = process_input(input)&#13;
    JumpIfNotZero(done, LoopStart)&#13;
    Return(0)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-7: A TACKY function with multiple execution paths</samp></p>&#13;
<p class="TX">This function executes a loop that repeatedly retrieves a value by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">get_input</samp>, then processes that value by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">process_input</samp>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">get_input</samp> ever returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, this function immediately returns <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">process_input</samp> ever returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, the function immediately returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. <a href="#fig19-1">Figure 19-1</a> shows the corresponding control-flow graph.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_577" aria-label="577"/>&#13;
<figure class="IMG"><img id="fig19-1" class="img70" src="../images/fig19-1.jpg" alt="" width="886" height="816"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-1: The control-flow graph for <a href="chapter19.xhtml#list19-7">Listing 19-7</a> <a href="description-52.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">There’s a single outgoing edge from the special <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp> node to block <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>, since we’ll always execute <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> at the start of the function. (<samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp> will have exactly one outgoing edge in every control-flow graph, since C functions have only one entry point.) After we execute <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>, there are two possibilities: we can execute the next block in the program, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, or we can jump to block <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>. Therefore, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> has outgoing edges to both of those blocks. By the same logic, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp> has outgoing edges to both <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">3</samp>. A <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction exits the function, so <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">3</samp> each have a single outgoing edge to <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2"><span id="sec14"/><span id="h2-211"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining the Control-Flow Graph</samp></h4>&#13;
<p class="TNI">Now that you know what a control-flow graph looks like, let’s look at how to construct one. First, we’ll define the graph data structure. <a href="chapter19.xhtml#list19-8">Listing 19-8</a> sketches out one possible representation.</p>&#13;
<a id="list19-8"/>&#13;
<pre><code>node_id = ENTRY | EXIT | BlockId(int num)&#13;
node = BasicBlock(node_id id, instruction* instructions,&#13;
                  node_id* predecessors, node_id* successors)&#13;
     | EntryNode(node_id* successors)&#13;
     | ExitNode(node_id* predecessors)&#13;
graph = Graph(node* nodes)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-8: One way to represent the control-flow graph</samp></p>&#13;
<p class="TX">Every node in the graph has a unique <samp class="SANS_TheSansMonoCd_W5Regular_11">node_id</samp>, which identifies it as <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>, or a numbered basic block. We’ll assign numeric IDs to basic blocks according to their order in the original TACKY function. Each basic block holds a list of TACKY instructions, a list of <i>successors</i> (the blocks that could execute right after it), and another list of <i>predecessors</i> (the blocks that could execute right before it). The entry and exit nodes don’t hold any instructions. <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>, as the very first point in the function, has successors <span role="doc-pagebreak" epub:type="pagebreak" id="pg_578" aria-label="578"/>but no predecessors. <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>, on the other hand, has predecessors but no successors.</p>&#13;
<p class="TX">You’ll need a way to associate both basic blocks and individual instructions with extra information so that you can track the results of data-flow analysis in the copy propagation and dead store elimination passes. The definition in <a href="chapter19.xhtml#list19-8">Listing 19-8</a> doesn’t include a way to track this information. You could either attach it directly to the graph or store it in a separate data structure. The pseudocode throughout this chapter will use <samp class="SANS_TheSansMonoCd_W5Regular_11">annotate _instruction</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">get_instruction_annotation</samp> to save and look up information about individual instructions. It will use <samp class="SANS_TheSansMonoCd_W5Regular_11">annotate_block</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">get_block _annotation</samp> to save and look up information about basic blocks by block ID.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Your graph data structure might look quite different from <a href="chapter19.xhtml#list19-8">Listing 19-8</a>. For instance, you might want to represent the graph as a map from node_id to node, instead of a list of nodes, or track the entry and exit nodes separately from the nodes that represent basic blocks. You can define your control-flow graph in whatever way makes sense to you and suits your implementation language, as long as it includes all the information you’ll need.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2"><span id="sec15"/><span id="h2-212"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating Basic Blocks</samp></h4>&#13;
<p class="TNI">Next, let’s see how to partition the body of a TACKY function into basic blocks. You can’t have any jumps into or out of the middle of a basic block. The only way to execute a basic block is to start at its first instruction and continue all the way to the end. This implies that <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> can appear only as the first instruction in a block, and a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> or jump instruction can appear only as the last instruction. <a href="chapter19.xhtml#list19-9">Listing 19-9</a> demonstrates how to split a list of instructions into basic blocks along these boundaries.</p>&#13;
<a id="list19-9"/>&#13;
<pre><code>partition_into_basic_blocks(instructions):&#13;
    finished_blocks = []&#13;
    current_block = []&#13;
    for instruction in instructions:&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if instruction is Label:&#13;
            if current_block is not empty:&#13;
                finished_blocks.append(current_block)&#13;
            current_block = [instruction]&#13;
&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> else if instruction is Jump, JumpIfZero, JumpIfNotZero, or Return:&#13;
            current_block.append(instruction)&#13;
            finished_blocks.append(current_block)&#13;
            current_block = []&#13;
&#13;
        else:&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> current_block.append(instruction)&#13;
&#13;
    if current_block is not empty:&#13;
        finished_blocks.append(current_block)&#13;
&#13;
    return finished_blocks</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-9: Partitioning a list of instructions into basic blocks</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_579" aria-label="579"/>When we encounter a <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> instruction, we start a new basic block beginning with that <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. When we encounter a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction or a conditional or unconditional jump, we add it to the current block, then start a new empty block <span class="CodeAnnotation" aria-label="annotation2">❷</span>. When we encounter any other instruction, we add it to the current block without starting a new block <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX"><a href="chapter19.xhtml#list19-9">Listing 19-9</a> just partitions a function body into a list of lists of instructions. The next step (which I won’t provide pseudocode for) is to convert these lists of instructions into <samp class="SANS_TheSansMonoCd_W5Regular_11">BasicBlock</samp> nodes with increasing block IDs. We’ll then add these nodes to the graph, along with the entry and exit nodes.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2"><span id="sec16"/><span id="h2-213"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Edges to the Control-Flow Graph</samp></h4>&#13;
<p class="TNI">After adding every node to the graph, we’ll add edges from each node to its successors, as <a href="chapter19.xhtml#list19-10">Listing 19-10</a> demonstrates.</p>&#13;
<a id="list19-10"/>&#13;
<pre><code>add_all_edges( <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> graph):&#13;
&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> add_edge(ENTRY, BlockId(0))&#13;
&#13;
    for node in graph.nodes:&#13;
        if node is EntryNode or ExitNode:&#13;
            continue&#13;
&#13;
        if node.id == max_block_id(graph.nodes):&#13;
            next_id = EXIT&#13;
        else:&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> next_id = BlockId(node.id.num + 1)&#13;
&#13;
        instr = get_last(node.instructions)&#13;
        match instr with&#13;
        | Return(maybe_val) -&gt; add_edge(node.id, EXIT)&#13;
        | Jump(target) -&gt;&#13;
            target_id = get_block_by_label(target)&#13;
            add_edge(node.id, target_id)&#13;
        | JumpIfZero(condition, target) -&gt;&#13;
            target_id = get_block_by_label(target)&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> add_edge(node.id, target_id)&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> add_edge(node.id, next_id)&#13;
        | JumpIfNotZero(condition, target) -&gt;&#13;
            // same as JumpIfZero&#13;
<var>            --snip--</var>&#13;
        | _ -&gt; add_edge(node.id, next_id)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-10: Adding edges to the control-flow graph</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">graph</samp> argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">add_all_edges</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span> is our unfinished control-flow graph, which has nodes but no edges. We’ll begin by adding an edge from <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp> to the first basic block <span class="CodeAnnotation" aria-label="annotation2">❷</span>. (We can assume that the function contains at least one basic block, since we don’t optimize empty functions.) Throughout this listing, we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edge</samp> function, which takes two <span role="doc-pagebreak" epub:type="pagebreak" id="pg_580" aria-label="580"/>node IDs, to add edges to the graph. Keep in mind that whenever we add an edge from <samp class="SANS_TheSansMonoCd_W5Regular_11">node1</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">node2</samp>, we must update both the successors of <samp class="SANS_TheSansMonoCd_W5Regular_11">node1</samp> and the predecessors of <samp class="SANS_TheSansMonoCd_W5Regular_11">node2</samp>. I’ve omitted the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edge</samp>, since it will depend on how you’ve defined your control-flow graph.</p>&#13;
<p class="TX">Next, we’ll add outgoing edges from the nodes that correspond to basic blocks. To process one of these nodes, we’ll first determine which other node will follow it by default if we don’t jump or return at the end of the block. If we’re processing the very last block, the next node will be <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>. Otherwise, it will just be whatever basic block comes next in the original TACKY function <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">We’ll figure out what edges to add by inspecting the last instruction in the current basic block. If it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction, we’ll add one outgoing edge to <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>. If it’s an unconditional <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>, we’ll add an edge to the block that begins with the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>. We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_block_by_label</samp> helper function, which I won’t show the pseudocode for, to look up which block begins with a particular label. I recommend building a map from labels to block IDs ahead of time so that this function can just perform a map lookup.</p>&#13;
<p class="TX">If a block ends with a conditional jump, we’ll add two outgoing edges. The first edge, which represents taking the jump, will go to the block that starts with the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> <span class="CodeAnnotation" aria-label="annotation4">❹</span>. The other edge, which represents not taking the jump <span class="CodeAnnotation" aria-label="annotation5">❺</span>, will go to the default next node, identified by <samp class="SANS_TheSansMonoCd_W5Regular_11">next_id</samp>. If a block ends with any other instruction, we’ll add a single outgoing edge to the default next node.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2"><span id="sec17"/><span id="h2-214"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting a Control-Flow Graph to a List of Instructions</samp></h4>&#13;
<p class="TNI">At this point, you should have working code to convert a TACKY function into a control-flow graph. You’ll also need code to go in the other direction and convert a control-flow graph back to a list of instructions. This operation is much simpler: just sort all the basic blocks by ID, then concatenate all their instructions.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h4 class="H2"><span id="sec18"/><span id="h2-215"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Making Your Control-Flow Graph Code Reusable</samp></h4>&#13;
<p class="TNI">In the next chapter, we’ll build control-flow graphs of assembly programs. We’ll use the same algorithm to construct these graphs, but we’ll look for different individual control-flow instructions. For instance, <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>, and conditional jump instructions like <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">je</samp> all signal the end of a basic block in assembly.</p>&#13;
<p class="TX">Once you have working code to construct control-flow graphs, you might want to refactor it so you can use it for assembly programs too. This is completely optional, but it will save you some effort in the next chapter.</p>&#13;
<p class="TX">First, you’ll need to generalize the <samp class="SANS_TheSansMonoCd_W5Regular_11">graph</samp> data type so that a block can contain either TACKY or assembly instructions. Next, you’ll need to generalize the logic to analyze specific instructions in <a href="chapter19.xhtml#list19-9">Listings 19-9</a> and <a href="chapter19.xhtml#list19-10">19-10</a>. For instance, you could define a one-off data type to represent both assembly <span role="doc-pagebreak" epub:type="pagebreak" id="pg_581" aria-label="581"/>and TACKY instructions, which captures just the information you need to build the control-flow graph:</p>&#13;
<pre><code>generic_instruction = Return&#13;
                    | Jump&#13;
                    | ConditionalJump(identifier label)&#13;
                    | Label(identifier)&#13;
                    | Other</code></pre>&#13;
<p class="TX">Instead of inspecting individual TACKY instructions to determine where a basic block ends or what its successors are, you can convert each instruction to a <samp class="SANS_TheSansMonoCd_W5Regular_11">generic_instruction</samp> and inspect that. Then, when you need to build control-flow graphs for assembly programs, you’ll use a different helper function to convert an assembly instruction to a <samp class="SANS_TheSansMonoCd_W5Regular_11">generic_instruction</samp> but leave everything else the same.</p>&#13;
<p class="TX">That wraps up our discussion of control-flow graphs. We’re now ready to move on to our second optimization pass: unreachable code elimination.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h3 class="H1"><span id="sec19"/><span id="h1-177"/><samp class="SANS_Futura_Std_Bold_B_11">Unreachable Code Elimination</samp></h3>&#13;
<p class="TNI">We’ll split up this pass into three steps, first removing basic blocks that will never execute, then useless jumps, and finally useless labels. The last two steps might leave us with empty blocks that don’t contain any instructions. Optionally, we can clean up after this optimization by removing these empty blocks from the control-flow graph.</p>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h4 class="H2"><span id="sec20"/><span id="h2-216"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Eliminating Unreachable Blocks</samp></h4>&#13;
<p class="TNI">To find every block that might possibly execute, we’ll traverse the control-flow graph starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>. We’ll visit <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>’s successor, then all of that node’s successors, and so on, until we run out of nodes to explore. If this traversal never reaches a particular basic block, we’ll know that block is safe to remove. Let’s try out this approach on the example from <a href="chapter19.xhtml#list19-4">Listing 19-4</a>, which we looked at when we first introduced unreachable code elimination:</p>&#13;
<pre><code>x = 5&#13;
Jump(Target)&#13;
x = my_function()&#13;
Target:&#13;
Return(x)</code></pre>&#13;
<p class="TX">We determined earlier that <samp class="SANS_TheSansMonoCd_W5Regular_11">x = my_function()</samp> is unreachable. Assuming this listing is the entire body of a TACKY function, it will have the control-flow graph shown in <a href="#fig19-2">Figure 19-2</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_582" aria-label="582"/>&#13;
<figure class="IMG"><img id="fig19-2" class="img40" src="../images/fig19-2.jpg" alt="" width="606" height="819"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-2: The control-flow graph for <a href="chapter19.xhtml#list19-4">Listing 19-4</a> <a href="description-53.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Note that there’s no path from <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>. If we traverse this graph starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>, we’ll visit <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>. Along the way, we’ll keep track of which nodes we’ve visited so far. Once we’re done, we’ll see that we never visited <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, so we’ll remove it. I won’t provide the pseudocode for exploring the graph, since it’s just an ordinary breadth- or depth-first graph traversal.</p>&#13;
<p class="TX">When you remove a node from the graph, remember to remove its outgoing edges too. For example, when we remove <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp> from the graph in <a href="#fig19-2">Figure 19-2</a>, we should also remove it from <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>’s list of predecessors.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h4 class="H2"><span id="sec21"/><span id="h2-217"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Useless Jumps</samp></h4>&#13;
<p class="TNI">Next, we’ll remove any useless jump instructions. Remember that by default, if a block doesn’t end with a jump or <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction, control falls through to the next block from the original program order. We can delete a jump instruction if it targets this default next block.</p>&#13;
<p class="TX">We’ll look at each basic block that ends with a conditional or unconditional jump and figure out which block would follow it by default if the jump weren’t taken. If this default next block is its only successor, the jump instruction is redundant. <a href="chapter19.xhtml#list19-11">Listing 19-11</a> demonstrates this approach.</p>&#13;
<a id="list19-11"/>&#13;
<pre><code>remove_redundant_jumps(graph):&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> sorted_blocks = sort_basic_blocks(graph)&#13;
    i = 0&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> while i &lt; length(sorted_blocks) - 1:&#13;
        block = sorted_blocks[i]&#13;
        if block.instructions ends with Jump, JumpIfZero, or JumpIfNotZero:&#13;
            keep_jump = False&#13;
            default_succ = sorted_blocks[i + 1]&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_583" aria-label="583"/>            for succ_id in block.successors:&#13;
                if succ_id != default_succ.id:&#13;
                    keep_jump = True&#13;
                    break&#13;
            if not keep_jump:&#13;
              <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> remove_last(block.instructions)&#13;
        i += 1</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-11: Removing redundant jumps</samp></p>&#13;
<p class="TX">First, we’ll sort the basic blocks by their position in the original TACKY function <span class="CodeAnnotation" aria-label="annotation1">❶</span>; this is one reason we numbered the blocks when we first constructed the graph. Next, we’ll iterate over this sorted list of basic blocks (except the last one, since a jump at the very end of the function is never redundant) <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If a block ends with a jump, we’ll search for a successor other than the next block in the list. If we find one, we’ll keep the jump instruction. Otherwise, we’ll remove it <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Note that the next block in the list won’t necessarily have the next consecutive numerical ID, since we may have deleted blocks earlier. Block 2, for example, might be followed by block 4. That’s why we can’t just increment a block’s ID number to find its default successor.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h4 class="H2"><span id="sec22"/><span id="h2-218"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Useless Labels</samp></h4>&#13;
<p class="TNI">Removing useless labels is similar to removing useless jumps. After sorting basic blocks by numeric ID, we can delete the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> instruction at the start of a block if we’ll enter it only by falling through from the previous block, rather than jumping to it explicitly. More concretely, we can delete the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> at the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[i]</samp> if its only predecessor is <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[i - 1]</samp>. We can also delete the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> at the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[0]</samp> if its only predecessor is <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>. This transformation is safe because we just deleted redundant jump instructions; we know that <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[i - 1]</samp> won’t end with an explicit jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[i]</samp>. I won’t provide pseudocode for this step, since it would look basically the same as <a href="chapter19.xhtml#list19-11">Listing 19-11</a>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h4 class="H2"><span id="sec23"/><span id="h2-219"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Empty Blocks</samp></h4>&#13;
<p class="TNI">Eliminating unreachable jumps and labels might result in blocks with no instructions. If you want, you can remove them; this will shrink the graph and might speed up later optimization passes a bit. When you remove a block, make sure to update the edges in the control-flow graph accordingly. For example, if the graph has edges from <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>, and you delete <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, you’ll need to add an edge from <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>.</p>&#13;
<aside class="box" aria-label="box-70"><p class="BoxTitle" id="box-70"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_584" aria-label="584"/><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE UNREACHABLE CODE ELIMINATION PASS</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">If you completed only Part I, test this optimization pass with the following command:</samp></p>&#13;
<pre><code>$ <b>./test_compiler </b><b><var>/path/to/your_compiler</var></b><b> --chapter 19 --eliminate-unreachable-code</b>&#13;
<b>--int-only</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">This will run the tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_19/unreachable_code_elimination</samp><samp class="SANS_Futura_Std_Book_11">. Some of these tests rely on the constant folding pass you implemented earlier in the chapter. None of them use the features we added in Part II, because those features don’t interact with this optimization. This command will also rerun the tests from Part I with both constant folding and unreachable code elimination enabled. To rerun the tests from Part II as well, omit the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">--int-only</samp> <samp class="SANS_Futura_Std_Book_11">option:</samp></p>&#13;
<pre><code>$ <b>./test_compiler </b><b><var>/path/to/your_compiler</var></b><b> --chapter 19 --eliminate-unreachable-code</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h3 class="H1"><span id="sec24"/><span id="h1-178"/><samp class="SANS_Futura_Std_Bold_B_11">A Little Bit About Data-Flow Analysis</samp></h3>&#13;
<p class="TNI">This section will give a quick overview of data-flow analysis, which we’ll rely on in the next two optimization passes. You’ll learn what it is, when it’s useful, and what features all data-flow analyses have in common. This isn’t intended to be a complete explanation of data-flow analysis; my goal here is just to introduce a few key ideas and describe how they fit together, to make the specific analyses in later sections easier to follow.</p>&#13;
<p class="TX">Data-flow analysis answers questions about how values are defined and used throughout a function. Different data-flow analyses answer different questions. In the copy propagation pass, for example, we’ll implement <i>reaching copies analysis</i>. This answers the question: Given some instruction <i>i</i> in a TACKY function, and two operands <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp> that appear in that function, can we guarantee that <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp> are equal at the point just before <i>i</i> executes?</p>&#13;
<p class="TX">We can divide all data-flow analyses into two broad categories: forward and backward analyses. In a <i>forward analysis</i>, information travels forward through the control-flow graph. Reaching copies analysis is a forward analysis. When we see a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>, that tells us that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> might have the same value later in the same basic block or in one of that block’s successors. In a <i>backward analysis</i>, the reverse is true. In the dead store elimination pass, we’ll implement a backward analysis called <i>liveness analysis</i>. This analysis tells us whether a variable’s current value will ever be used. If we see an instruction that uses <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, that tells us that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> may be live earlier in the same basic block or in one of that block’s predecessors.</p>&#13;
<p class="TX">Each data-flow analysis has its own transfer function and meet operator. The <i>transfer function</i> calculates the analysis results within a single basic <span role="doc-pagebreak" epub:type="pagebreak" id="pg_585" aria-label="585"/>block. This function analyzes how individual instructions impact the results, but it doesn’t need to deal with multiple execution paths. The <i>meet operator</i> combines information from multiple paths to calculate how each basic block is impacted by its neighbors. We’ll use an <i>iterative algorithm</i> to drive the entire analysis. This algorithm calls the transfer function and meet operator on each basic block and keeps track of which blocks still need to be analyzed. It’s iterative because we may need to visit some blocks multiple times as we propagate information along different execution paths. This algorithm will traverse the control-flow graph, analyzing each basic block it visits, until it reaches a fixed point where the analysis results no longer change. At that point, we’ll know that every possible execution path is accounted for. The iterative algorithm isn’t the only way to solve data-flow analysis problems, but it’s the only one we’ll discuss in this book.</p>&#13;
<p class="TX">While different analyses use different transfer functions and meet operators, they all use essentially the same iterative algorithm. Forward and backward analyses use different versions of this algorithm because they propagate data in opposite directions. We’ll implement both versions in the next two sections.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h3 class="H1"><span id="sec25"/><span id="h1-179"/><samp class="SANS_Futura_Std_Bold_B_11">Copy Propagation</samp></h3>&#13;
<p class="TNI">If the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> appears in a function, we can sometimes replace <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> later in that function. Let’s call the instruction where we’d like to perform this substitution <i>i</i>. The substitution is safe when two conditions are met. First, <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> must appear on every path from the program’s entry point to <i>i</i>. Consider the control-flow graph in <a href="#fig19-3">Figure 19-3</a>, which doesn’t meet this condition.</p>&#13;
<figure class="IMG"><img id="fig19-3" class="img40" src="../images/fig19-3.jpg" alt="" width="587" height="836"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-3: A control-flow graph for a function where we cannot perform copy propagation <a href="description-54.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_586" aria-label="586"/>In this control-flow graph, there are two paths from the start of the function to <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>. Because only one of these paths passes through <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 2</samp>, it isn’t safe to substitute <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> in this <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction. In <a href="#fig19-4">Figure 19-4</a>, on the other hand, every path to <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp> passes through <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 2</samp>.</p>&#13;
<figure class="IMG"><img id="fig19-4" class="img40" src="../images/fig19-4.jpg" alt="" width="592" height="895"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-4: A control-flow graph for a function where we can perform copy propagation <a href="description-55.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">No matter which path we take through <a href="#fig19-4">Figure 19-4</a>, we’ll execute <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 2</samp> before we reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction, so we can safely rewrite that instruction as <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(2)</samp>.</p>&#13;
<p class="TX"><a href="#fig19-5">Figure 19-5</a> shows another, slightly trickier example.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_587" aria-label="587"/>&#13;
<figure class="IMG"><img id="fig19-5" class="img60" src="../images/fig19-5.jpg" alt="" width="780" height="856"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-5: Another control-flow graph where copy propagation is safe <a href="description-56.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Once again, there are two different paths to <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>. Both paths pass through <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>, but they pass through different instances of this instruction that appear in different blocks. In <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>’s value is <samp class="SANS_TheSansMonoCd_W5Regular_11">20</samp>; in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>, it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>. But in either case, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> will have the same value when we reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction. That means it’s still safe to rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp> as <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(y)</samp>.</p>&#13;
<p class="TX">Before we rewrite instruction <i>i</i>, there’s a second condition that each path to <i>i</i> must satisfy: between the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> and <i>i</i>, neither <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> nor <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> can be updated again. Consider this fragment of TACKY:</p>&#13;
<pre><code>x = 10&#13;
x = foo()&#13;
Return(x)</code></pre>&#13;
<p class="TX">We can’t replace <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>, because <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>’s value is no longer <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> at that point. Updating the variable that appeared on the right-hand side of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction causes the same problem:</p>&#13;
<pre><code>x = y&#13;
y = 0&#13;
Return(x)</code></pre>&#13;
<p class="TX">Right before <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 0</samp>, we know that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> have the same value. But after that instruction, their values will be different, so we can’t rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>. When a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction’s source or destination is updated, we say the copy is <i>killed</i>. Once a copy is killed, we can’t propagate it to later points in the program.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_588" aria-label="588"/>It’s possible for <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> to appear multiple times on some path to <i>i</i>. It’s unsafe to propagate it only if it’s killed after the <i>last</i> time it appears. In the following example, it’s safe to rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp> as <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(2)</samp>:</p>&#13;
<pre><code>x = 2&#13;
x = foo()&#13;
x = 2&#13;
Return(x)</code></pre>&#13;
<p class="TX">If there are multiple paths to <i>i</i>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction we’re interested in must not be killed on any of them. Take a look at <a href="#fig19-6">Figure 19-6</a>, where <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> is killed on one path but not another.</p>&#13;
<figure class="IMG"><img id="fig19-6" class="img40" src="../images/fig19-6.jpg" alt="" width="551" height="848"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-6: A control-flow graph where a reaching copy is killed along one path <a href="description-57.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If we jump over <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> will have the same value when we reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>. But if we take the path through <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, their values will be different. Because we don’t know ahead of time which path the program will take, we can’t rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>.</p>&#13;
<p class="TX">Let’s consider one final edge case. Suppose that <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> is followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>, with no intervening kills:</p>&#13;
<pre><code>x = y&#13;
<var>--snip--</var>&#13;
y = x&#13;
z = x + y</code></pre>&#13;
<p class="TX">Normally, updating <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> would kill the earlier <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction. But after <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> still have the same value. There are multiple correct ways to handle this case. One option is to say that <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp> kills <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>, so only <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_589" aria-label="589"/>reaches <samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + y</samp>. In that case, we’d rewrite the final instruction as <samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + x</samp>. This might let us remove <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp> later, during dead store elimination, depending on where else <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is used. Another option is to simply ignore <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp> during our analysis, on the grounds that it has no effect; it just assigns <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> the same value it already had. Then, when we’re rewriting instructions, we can go ahead and eliminate <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp> and rewrite the last instruction as <samp class="SANS_TheSansMonoCd_W5Regular_11">z = y + y</samp>. A third option is to propagate <i>both</i> copies in the final instruction, substituting <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> for <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. This substitution is safe but not particularly helpful, since it won’t help us get rid of either <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction. We’ll go with the second option and eliminate the redundant <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>.</p>&#13;
<p class="TX">If a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction appears on every path to instruction <i>i</i>, and it isn’t killed on any of those paths, we say that it <i>reaches</i> instruction <i>i</i>. At the start of the copy propagation pass, we’ll perform reaching copies analysis to determine which copies reach each instruction in the TACKY function. Then, we’ll use the results of this analysis to identify instructions that we can rewrite safely.</p>&#13;
<p class="TX">We’ll implement this whole optimization for the subset of TACKY we defined in <span class="Xref-1"><a href="part1.xhtml">Part I</a></span>, then extend it to handle the new language features from <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h4 class="H2"><span id="sec26"/><span id="h2-220"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reaching Copies Analysis</samp></h4>&#13;
<p class="TNI">To implement reaching copies analysis, we’ll define each of the elements of data-flow analysis that we discussed earlier: the transfer function, meet operator, and iterative algorithm. The transfer function and meet operator we’ll discuss in this section are specific to reaching copies analysis, while the iterative algorithm applies to every forward data-flow analysis.</p>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h5 class="H3"><span id="sec27"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Transfer Function</samp></h5>&#13;
<p class="TNI">The transfer function takes all the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instructions that reach the beginning of a basic block and calculates which copies reach each individual instruction within the block. It also calculates which copies reach the end of the block, just after the final instruction. The rules here are pretty simple. First, if <i>i</i> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction, it reaches the instruction that comes right after it. Second, if some <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction reaches <i>i</i>, it also reaches the instruction right after <i>i</i>, unless <i>i</i> kills it. Let’s work through an example. Suppose a basic block contains the instructions in <a href="chapter19.xhtml#list19-12">Listing 19-12</a>.</p>&#13;
<a id="list19-12"/>&#13;
<pre><code>x = a&#13;
y = 10&#13;
x = y * 3&#13;
Return(x)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-12: A basic block</samp></p>&#13;
<p class="TX">Let’s assume that one <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">a = y</samp>, reaches the start of this basic block. This <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> will reach the first instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">x = a</samp>. Once we encounter <samp class="SANS_TheSansMonoCd_W5Regular_11">x = a</samp>, we add it to the current set of reaching copies, so both <samp class="SANS_TheSansMonoCd_W5Regular_11">a = y</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">x = a</samp> reach the next instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 10</samp>. Because this next instruction updates <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, it kills <samp class="SANS_TheSansMonoCd_W5Regular_11">a = y</samp>. We therefore remove <samp class="SANS_TheSansMonoCd_W5Regular_11">a = y</samp> from the set of reaching <span role="doc-pagebreak" epub:type="pagebreak" id="pg_590" aria-label="590"/>copies, but we add <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 10</samp>. Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y * 3</samp> kills <samp class="SANS_TheSansMonoCd_W5Regular_11">x = a</samp>. We don’t add <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y * 3</samp> as a reaching copy because it’s not a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction. The final <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction doesn’t add or remove any reaching copies. <a href="chapter19.xhtml#tab19-1">Table 19-1</a> lists which copies reach each instruction in this basic block.</p>&#13;
<p class="TT" id="tab19-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 19-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Copies Reaching Each Instruction in <a href="chapter19.xhtml#list19-12">Listing 19-12</a></samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Reaching copies</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">x = a</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">{a = y}</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">y = 10</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">{a = y, x = a}</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">x = y * 3</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">{x = a, y = 10}</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">{y = 10}</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">End of block</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">{y = 10}</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Things get a little trickier when we consider variables with static storage duration. As <a href="chapter19.xhtml#list19-13">Listing 19-13</a> demonstrates, these variables can be updated in other functions.</p>&#13;
<a id="list19-13"/>&#13;
<pre><code>int static_var = 0;&#13;
&#13;
int update_var(void) {&#13;
    static_var = 4;&#13;
    return 0;&#13;
}&#13;
&#13;
int main(void) {&#13;
    static_var = 5;&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> update_var();&#13;
    return static_var;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-13: A C program where multiple functions access the same variable with static storage duration</samp></p>&#13;
<p class="TX">Our reaching copies analysis should recognize that the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">update _var</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> kills <samp class="SANS_TheSansMonoCd_W5Regular_11">static_var = 5</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Otherwise, it will incorrectly rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> to return the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>. At first glance, it might look like this problem applies only to file scope variables, but as <a href="chapter19.xhtml#list19-14">Listing 19-14</a> illustrates, it impacts static local variables too.</p>&#13;
<a id="list19-14"/>&#13;
<pre><code>int indirect_update(void);&#13;
&#13;
int f(int new_total) {&#13;
    static int total = 0;&#13;
    total = new_total;&#13;
    if (total &gt; 100)&#13;
        return 0;&#13;
    total = 10;&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> indirect_update();&#13;
    return total;&#13;
}&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_591" aria-label="591"/>int indirect_update(void) {&#13;
    f(101);&#13;
    return 0;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-14: A C program where a function call indirectly updates a static local variable</samp></p>&#13;
<p class="TX">When we analyze <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>, we’ll need to know that the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">indirect_update</samp> at <span class="CodeAnnotation" aria-label="annotation1">❶</span> can update <samp class="SANS_TheSansMonoCd_W5Regular_11">total</samp>. Otherwise, we’ll incorrectly rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> to return <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>.</p>&#13;
<p class="TX">There are a couple of ways to solve this problem. One option is to figure out which function calls will update which static variables. This would make reaching copies analysis an interprocedural analysis, which gathers information about multiple functions. This approach gets complicated very quickly. Our other option is to assume that every function call updates every static variable. We’ll go with this option because it’s much simpler. Whenever we encounter a function call, we’ll kill any copies to or from static variables. This approach is <i>conservative</i>; it guarantees that we’ll never perform an unsafe optimization, but it may lead us to kill some reaching copies unnecessarily and miss some safe optimizations. In contrast, using interprocedural analysis would be a more <i>aggressive</i> approach because it would miss fewer optimizations. More aggressive optimization techniques aren’t always better; they often come at the cost of increased complexity and longer compilation times.</p>&#13;
<p class="TX"><a href="chapter19.xhtml#list19-15">Listing 19-15</a> gives the pseudocode for the transfer function.</p>&#13;
<a id="list19-15"/>&#13;
<pre><code>transfer(block, initial_reaching_copies):&#13;
    current_reaching_copies = initial_reaching_copies&#13;
&#13;
    for instruction in block.instructions:&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> annotate_instruction(instruction, current_reaching_copies)&#13;
        match instruction with&#13;
        | Copy(src, dst) -&gt;&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if Copy(dst, src) is in current_reaching_copies:&#13;
                continue&#13;
&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> for copy in current_reaching_copies:&#13;
                if copy.src == dst or copy.dst == dst:&#13;
                    current_reaching_copies.remove(copy)&#13;
&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> current_reaching_copies.add(instruction)&#13;
        | FunCall(fun_name, args, dst) -&gt;&#13;
            for copy in current_reaching_copies:&#13;
              <span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> if (copy.src is static&#13;
                    or copy.dst is static&#13;
                    or copy.src == dst&#13;
                    or copy.dst == dst):&#13;
                    current_reaching_copies.remove(copy)&#13;
        | Unary(operator, src, dst) -&gt;&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span> for copy in current_reaching_copies:&#13;
                if copy.src == dst or copy.dst == dst:&#13;
                    current_reaching_copies.remove(copy)&#13;
        | Binary(operator, src1, src2, dst) -&gt;&#13;
            // same as Unary&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_592" aria-label="592"/><var>            --snip--</var>&#13;
        | _ -&gt; continue&#13;
&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation7">❼</span> annotate_block(block.id, current_reaching_copies)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-15: The transfer function for reaching copies analysis</samp></p>&#13;
<p class="TX">To process an instruction, we’ll first record the set of copies that reach the point just before that instruction executes <span class="CodeAnnotation" aria-label="annotation1">❶</span>. (We’ll refer to this information later when we actually rewrite the instruction.) Then, we’ll inspect the instruction itself to calculate which copies reach the point just after it. In the special case where <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> reaches <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>, we won’t add or remove any reaching copies <span class="CodeAnnotation" aria-label="annotation2">❷</span>. As we saw earlier, <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp> will have no effect, since <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> already have the same value. Otherwise, we’ll handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> by killing any copies to or from <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <span class="CodeAnnotation" aria-label="annotation3">❸</span>, then adding <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> to the set of reaching copies <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">When we encounter a <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> instruction, we’ll kill any copies to or from variables with static storage duration along with any copies to or from <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>, the variable that will hold the result of the function call <span class="CodeAnnotation" aria-label="annotation5">❺</span>. The two other instructions from <span class="Xref-1"><a href="part1.xhtml">Part I</a></span> that update variables are <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>. To handle either of these, we’ll kill any copies to or from its destination <span class="CodeAnnotation" aria-label="annotation6">❻</span>. The remaining TACKY instructions from <span class="Xref-1"><a href="part1.xhtml">Part I</a></span>, like <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>, don’t add or kill any reaching copies. After processing every instruction, we’ll record which copies reach the very end of the block <span class="CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h5 class="H3"><span id="sec28"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Meet Operator</samp></h5>&#13;
<p class="TNI">Next, we’ll implement the meet operator, which propagates information about reaching copies from one block to another. This operator calculates the set of initial reaching copies that we’ll pass to the transfer function. Recall that a copy reaches some point in the program only if it appears, and isn’t killed, on <i>every</i> path to that point. Therefore, a copy reaches the beginning of a block only if it reaches the end of all of that block’s predecessors. In other words, we’ll just take the set intersection of the results from every predecessor. <a href="chapter19.xhtml#list19-16">Listing 19-16</a> gives the pseudocode for the meet operator.</p>&#13;
<a id="list19-16"/>&#13;
<pre><code>meet(block, all_copies):&#13;
&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> incoming_copies = all_copies&#13;
    for pred_id in block.predecessors:&#13;
        match pred_id with&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> | ENTRY -&gt; return {}&#13;
        | BlockId(id) -&gt;&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> pred_out_copies = get_block_annotation(pred_id)&#13;
            incoming_copies = intersection(incoming_copies, pred_out_copies)&#13;
        | EXIT -&gt; fail("Malformed control-flow graph")&#13;
&#13;
    return incoming_copies</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-16: The meet operator for reaching copies analysis</samp></p>&#13;
<p class="TX">The meet operator takes two arguments. The first is the block whose incoming copies we want to calculate. The second, <samp class="SANS_TheSansMonoCd_W5Regular_11">all_copies</samp>, is the set <span role="doc-pagebreak" epub:type="pagebreak" id="pg_593" aria-label="593"/>of all <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instructions that appear in the function. We initialize the set of incoming copies to this value <span class="CodeAnnotation" aria-label="annotation1">❶</span>, because it’s the <i>identity element</i> for set intersection. That is, given any set of reaching copies, <i>S</i>, the intersection of <i>S</i> with <samp class="SANS_TheSansMonoCd_W5Regular_11">all_copies</samp> is just <i>S</i>.</p>&#13;
<p class="TX">Next, we iterate over the block’s predecessors, which might include other basic blocks, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp> node, or both. No copies reach the very start of a function, so if we find <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp> in the list of predecessors we just return the empty set <span class="CodeAnnotation" aria-label="annotation2">❷</span>. (The intersection of the empty set and anything else is still the empty set, so there’s no need to look at the block’s other predecessors.) Otherwise, we look up the set of copies that reach the end of each predecessor <span class="CodeAnnotation" aria-label="annotation3">❸</span>, which we recorded at the end of <a href="chapter19.xhtml#list19-15">Listing 19-15</a>, and take the intersection of <samp class="SANS_TheSansMonoCd_W5Regular_11">incoming_copies</samp> with each of these sets.</p>&#13;
<p class="TX">We have one edge case to consider. If unreachable code elimination is disabled, the block we’re analyzing might not have any predecessors. Calling <samp class="SANS_TheSansMonoCd_W5Regular_11">meet</samp> on a block with no predecessors will return <samp class="SANS_TheSansMonoCd_W5Regular_11">all_copies</samp>, so we assume that every possible <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction reaches the start of the block. We don’t care how this ultimately impacts the block itself, which will never execute anyway. We <i>do</i> care how this impacts the block’s successors, which might be reachable. For instance, if a reachable block <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> and unreachable block <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> both jump to block <samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>, then block <samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp> is reachable.</p>&#13;
<p class="TX">Luckily, our analysis is still safe. The intersection of the real results from <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> and the junk results from <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> will always be a subset of the copies that actually reach <samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>; this is a conservative approximation of the results we’d get if we enabled unreachable code elimination and deleted <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> entirely.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h5 class="H3"><span id="sec29"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Iterative Algorithm</samp></h5>&#13;
<p class="TNI">We can analyze a basic block with the meet operator and transfer function once we know the results from the blocks that preceded it. Now we’ll tie everything together and analyze the entire function. There’s just one problem: control-flow graphs can have loops! We can’t analyze a block until we’ve analyzed all of its predecessors, which requires us to analyze all of their predecessors, and so on. Once we hit a loop, it seems like we’re stuck; we can’t analyze any of the blocks in the loop, because each block directly or indirectly precedes itself.</p>&#13;
<p class="TX">To get unstuck, we need some way to analyze a block even if we don’t have complete results from all of its predecessors. The solution is to maintain a provisional result for every block; if we need to analyze a block before some of its predecessors, we can use those predecessors’ provisional results. At first, before we’ve explored any paths to a block, its provisional result includes every <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction in the function. Then, with each new path to the block (or rather, the end of the block) that we explore, we eliminate any copies that don’t appear, or are killed, along that path. This means a block’s provisional result always tells us which reaching copies appear (and aren’t killed) on <i>every</i> path to the end of that block that we’ve explored so far. Once we’ve explored every possible path, we’ll have the block’s final result.</p>&#13;
<p class="TX">That’s the basic idea; now let’s put it into practice. First, we’ll annotate each basic block with the set of all <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instructions in the function. As <span role="doc-pagebreak" epub:type="pagebreak" id="pg_594" aria-label="594"/>we learned earlier, this set is the identity element for our meet operator. Initializing every block with the identity element ensures that blocks we haven’t yet analyzed don’t change the result of the meet operator. Let’s try out this approach on the control-flow graph in <a href="#fig19-7">Figure 19-7</a>.</p>&#13;
<figure class="IMG"><img id="fig19-7" class="img30" src="../images/fig19-7.jpg" alt="" width="470" height="997"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-7: A control-flow graph with a loop <a href="description-58.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This control-flow graph contains two <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instructions: <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 3</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 4</samp>. We’ll initially annotate each block with the set containing both copies. Then, we’ll analyze the blocks in order. We can calculate the final results for <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> in just one pass because its only predecessor is <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>. <a href="#fig19-8">Figure 19-8</a> illustrates the annotations on each block after we’ve processed <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_595" aria-label="595"/>&#13;
<figure class="IMG"><img id="fig19-8" class="img30" src="../images/fig19-8.jpg" alt="" width="479" height="995"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-8: The provisional results of reaching copies analysis for <a href="#fig19-7">Figure 19-7</a>, after processing B</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I-SUB_11">0 <a href="description-59.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">At this point, the annotation on <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> is correct: only <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 3</samp> reaches the end of that block. The other two blocks are still annotated with every copy. Next, we’ll apply the meet operator to see which copies reach the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>. This block has two predecessors: <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> and itself. We’ll therefore take the intersection of <samp class="SANS_TheSansMonoCd_W5Regular_11">{y = 3}</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">{y = 3, y = 4}</samp>, which is <samp class="SANS_TheSansMonoCd_W5Regular_11">{y = 3}</samp>. This is the same result we’d get if <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> were <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>’s only predecessor. That’s exactly the behavior we want: because we haven’t analyzed <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp> yet, it shouldn’t contribute to the result of the meet operator. Once we apply the transfer function to <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, we’ll recognize that only <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 4</samp> reaches the end of the block. We’ll then have all the information we need to process <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp> too. <a href="#fig19-9">Figure 19-9</a> shows the annotations on each block after we’ve analyzed <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_596" aria-label="596"/>&#13;
<figure class="IMG"><img id="fig19-9" class="img30" src="../images/fig19-9.jpg" alt="" width="472" height="1002"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-9: The provisional results of reaching copies analysis after analyzing each basic block once <a href="description-60.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Each block now has the correct set of reaching copies. But we don’t yet have the right answer for each individual instruction in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>. (<a href="#fig19-8">Figures 19-8</a> and <a href="#fig19-9">19-9</a> don’t show the annotations on individual instructions.) When we last analyzed <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, we assumed that <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 3</samp> reached the start of the block, which would imply that it also reaches <samp class="SANS_TheSansMonoCd_W5Regular_11">x = process(y)</samp>. Now that we have more accurate information, we need to analyze <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp> again. This time, the meet operator will take the intersection of <samp class="SANS_TheSansMonoCd_W5Regular_11">{y = 3}</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">{y = 4}</samp>, which is the empty set. We’ll pass this result to the transfer function to recalculate the results for individual instructions in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>. This time around, we’ll correctly conclude that no <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instructions reach <samp class="SANS_TheSansMonoCd_W5Regular_11">x = process(y)</samp> (or any point in the block before <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 4</samp>, for that matter).</p>&#13;
<p class="TX">Now that we’ve seen the iterative algorithm in action, let’s implement it. <a href="chapter19.xhtml#list19-17">Listing 19-17</a> gives the pseudocode for this algorithm.</p>&#13;
<a id="list19-17"/>&#13;
<pre><code>find_reaching_copies(graph):&#13;
&#13;
    all_copies = find_all_copy_instructions(graph)&#13;
    worklist = []&#13;
&#13;
    for node in graph.nodes:&#13;
        if node is EntryNode or ExitNode:&#13;
            continue&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> worklist.append(node)&#13;
        annotate_block(node.id, all_copies)&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_597" aria-label="597"/>    while worklist is not empty:&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> block = take_first(worklist)&#13;
        old_annotation = get_block_annotation(block.id)&#13;
        incoming_copies = meet(block, all_copies)&#13;
        transfer(block, incoming_copies)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> if old_annotation != get_block_annotation(block.id):&#13;
            for successor_id in block.successors:&#13;
                match successor_id with&#13;
                | EXIT -&gt; continue&#13;
                | ENTRY -&gt; fail("Malformed control-flow graph")&#13;
                | BlockId(id) -&gt;&#13;
                    successor = get_block_by_id(successor_id)&#13;
                    if successor is not in worklist:&#13;
                        worklist.append(successor)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-17: The iterative algorithm for reaching copies analysis</samp></p>&#13;
<p class="TX">We’ll maintain a worklist of basic blocks we need to process, including blocks that we need to revisit after updating one of their predecessors. In the initial setup for this algorithm, we’ll add each basic block to the worklist <span class="CodeAnnotation" aria-label="annotation1">❶</span>, since we need to analyze every block at least once. We’ll also initialize each block with the set of all <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instructions that appear in the function.</p>&#13;
<p class="TX">Next, we enter our main processing loop, where we’ll remove a block from the front of the worklist <span class="CodeAnnotation" aria-label="annotation2">❷</span>, then analyze it using the meet operator and transfer function. If this analysis changes the block’s outgoing reaching copies, we’ll add all of its successors to the worklist so we can reanalyze them using those new results <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If a successor is already in the worklist, we don’t need to add it again. We’ll repeat this process until the worklist is empty.</p>&#13;
<aside class="box-rule" aria-label="box-127"><p class="BoxTitle" id="box-127"><samp class="SANS_Dogma_OT_Bold_B_11">GETTING MORE BANG FOR YOUR BLOCK</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">It’s possible to improve on the code in <a href="chapter19.xhtml#list19-17">Listing 19-17</a>: when you initialize the worklist, you could add blocks in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">reverse postorder</samp><samp class="SANS_Futura_Std_Book_11">. To sort the nodes of a graph in postorder, you perform a depth-first search, adding each node to the sorted list after you return from traversing its successors. To sort them in reverse postorder, you take the list of nodes sorted in postorder and reverse it. In a reverse postorder traversal, you generally don’t visit a block until you’ve visited all of its predecessors. (If you’re traversing a graph with a loop, of course, you’ll hit a few exceptions to this general rule.) This helps you gather as much information as possible about a block’s predecessors before you try to analyze it, which minimizes how many times you need to revisit each block. If you don’t add blocks to the worklist in this order, the algorithm will still be correct; it will just take longer. “Additional Resources” on <a href="#pg_610">page 610</a> lists a couple of references with more details about how to sort a graph in postorder or reverse postorder.</samp></p>&#13;
</aside>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_598" aria-label="598"/><a href="chapter19.xhtml#list19-17">Listing 19-17</a> works for any forward data-flow analysis. Only the transfer function, the meet operator, and the identity element used to initialize each basic block will vary.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
&#13;
<h4 class="H2"><span id="sec30"/><span id="h2-221"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rewriting TACKY Instructions</samp></h4>&#13;
<p class="TNI">After running reaching copies analysis, we’ll look for opportunities to rewrite, or even remove, each instruction in the TACKY function. To rewrite an instruction, we’ll check whether the copies that reach it define any of its operands. If they do, we’ll replace those operands with their values. If we encounter a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> and its reaching copies include <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>, we’ll remove it instead of trying to rewrite it; the instruction has no effect if <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> already have the same value. <a href="chapter19.xhtml#list19-18">Listing 19-18</a> demonstrates how to process each instruction.</p>&#13;
<a id="list19-18"/>&#13;
<pre><code>replace_operand(op, reaching_copies):&#13;
    if op is a constant:&#13;
        return op&#13;
&#13;
    for copy in reaching_copies:&#13;
        if copy.dst == op:&#13;
            return copy.src&#13;
    return op&#13;
&#13;
rewrite_instruction(instr):&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> reaching_copies = get_instruction_annotation(instr)&#13;
    match instr with&#13;
    | Copy(src, dst) -&gt;&#13;
        for copy in reaching_copies:&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if (copy == instr) or (copy.src == dst and copy.dst == src):&#13;
                return null&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> new_src = replace_operand(src, reaching_copies)&#13;
        return Copy(new_src, dst)&#13;
    | Unary(operator, src, dst) -&gt;&#13;
        new_src = replace_operand(src, reaching_copies)&#13;
        return Unary(operator, new_src, dst)&#13;
    | Binary(operator, src1, src2, dst) -&gt;&#13;
        new_src1 = replace_operand(src1, reaching_copies)&#13;
        new_src2 = replace_operand(src2, reaching_copies)&#13;
        return Binary(operator, new_src1, new_src2, dst)&#13;
    | <var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-18: Rewriting an instruction based on the results of reaching copies analysis</samp></p>&#13;
<p class="TX">Given the set of copies that reach the current instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">replace_operand</samp> replaces a single TACKY operand with its value. If the operand is a constant or we can’t find a reaching copy that assigns to it, we just return the original value.</p>&#13;
<p class="TX">In <samp class="SANS_TheSansMonoCd_W5Regular_11">rewrite_instruction</samp>, we start by looking up the set of copies that reach the current instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">instr</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">instr</samp> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction, we’ll search this set, which we call <samp class="SANS_TheSansMonoCd_W5Regular_11">reaching_copies</samp>, for a copy from its source to its destination or vice versa <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If we find one, <samp class="SANS_TheSansMonoCd_W5Regular_11">instr</samp>’s operands already have the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_599" aria-label="599"/>same value, so we can delete it. (<a href="chapter19.xhtml#list19-18">Listing 19-18</a> returns <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> to indicate that we should delete the instruction; your code might indicate this differently.) Otherwise, we try to replace the instruction’s source operand using <samp class="SANS_TheSansMonoCd_W5Regular_11">replace _operand</samp> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. We’ll attempt to replace the source operands of other TACKY instructions in the same way. <a href="chapter19.xhtml#list19-18">Listing 19-18</a> demonstrates how to rewrite the source operands in <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>; I’ve omitted the remaining TACKY instructions from <span class="Xref-1"><a href="part1.xhtml">Part I</a></span> because the logic is the same.</p>&#13;
<p class="TX">At this point, you have a complete copy propagation pass that performs reaching copies analysis and uses the results to optimize a TACKY function. If you skipped <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>, you can move on to this section’s test suite. But if you completed <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>, you still have some work to do.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
&#13;
<h4 class="H2"><span id="sec31"/><span id="h2-222"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Supporting Part II TACKY Programs</samp></h4>&#13;
<p class="TNI">To make copy propagation work with the TACKY code we generate in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>, we need to solve a couple of problems. The first problem is that we sometimes use <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instructions to perform type conversions. We don’t want to propagate copies between signed and unsigned types, because we sometimes generate different assembly code for operations on signed and unsigned values. If we replace a signed value with an unsigned one in a comparison, for example, we’ll end up generating the wrong condition code for that comparison. Our reaching copies analysis will treat any <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> between signed and unsigned operands like a type conversion instruction instead of a normal copy operation. We won’t add it as a reaching copy in the transfer function, and we won’t include it in the set of initial reaching copies at the start of the iterative algorithm.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Another solution would be to introduce separate signed and unsigned TACKY operators for comparisons, remainder operations, and division, so we wouldn’t have to check the types of operands to distinguish between these cases during code generation. The LLVM IR uses this approach.</i></p>&#13;
<p class="TX">The second problem is that variables can be updated through pointers. These updates are difficult to analyze. If we see the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">Store(v, ptr)</samp>, we don’t know which object <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> points to, so we don’t know which copies to kill. This is similar to the issue we ran into with static variables, which could be updated in other functions. To solve this problem, we’ll find all the variables that could be accessed through pointers (these are called <i>aliased variables</i>). We’ll assume that every <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction updates every one of these variables. We’ll assume that function calls update these variables too, since we can declare a variable in one function and then update it through a pointer in a different function. Let’s use this approach to analyze <a href="chapter19.xhtml#list19-19">Listing 19-19</a>.</p>&#13;
<a id="list19-19"/>&#13;
<pre><code>function_with_pointers():&#13;
    x = 1&#13;
    y = 2&#13;
    z = 3&#13;
    ptr1 = GetAddress(x)&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_600" aria-label="600"/>    Store(10, ptr1)&#13;
    ptr2 = GetAddress(y)&#13;
    z = x + y&#13;
    Return(z)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-19: A TACKY function that updates variables through pointers</samp></p>&#13;
<p class="TX">First, we’ll identify the aliased variables in <samp class="SANS_TheSansMonoCd_W5Regular_11">function_with_pointers</samp>. Both <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are aliased because they’re both used in <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp> instructions. (Let’s assume that none of the variables in this listing are static, so we don’t have to worry about whether other functions take their address.) Next, we’ll run reaching copies analysis. Since this whole function body is one basic block, we can just apply the transfer function to the entire thing. We’ll add <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">z = 3</samp> to the set of reaching copies, as usual. Then, when we reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction, we’ll kill the copies to our two aliased variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>. <a href="chapter19.xhtml#tab19-2">Table 19-2</a> describes which copies will reach each instruction in this function.</p>&#13;
<p class="TT" id="tab19-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 19-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Copies Reaching Each Instruction in <a href="chapter19.xhtml#list19-19">Listing 19-19</a></samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Reaching copies</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">x = 1</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">y = 2</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">{x = 1}</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">z = 3</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">{x = 1, y = 2}</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">ptr1 = GetAddress(x)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">{x = 1, y = 2, z = 3}</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Store(10, ptr1)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">{x = 1, y = 2, z = 3}</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">ptr2 = GetAddress(y)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">{z = 3}</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + y</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">{z = 3}</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Return(z)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">End of block</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">We correctly recognize that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction might overwrite <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, which means that we can’t replace <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + y</samp>. We also assume that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction might overwrite <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> because our analysis isn’t smart enough to realize that <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr1</samp> couldn’t possibly point to <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>. Therefore, we won’t replace <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + y</samp>, even though it would be safe to do so. Once again, we’re making a conservative assumption; we’ll miss some safe optimizations, but we’ll never apply any that are unsafe.</p>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
&#13;
<h5 class="H3"><span id="sec32"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing Address-Taken Analysis</samp></h5>&#13;
<p class="TNI">The approach we just used to identify aliased variables is called <i>address-taken analysis</i>. To perform this analysis, we’ll inspect each instruction in a TACKY function and identify every variable that either has static storage duration or has its address taken by a <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp> instruction. (We’ll assume that all static variables are aliased, because their addresses might be taken in other functions.) We’ll rerun this analysis on every iteration through the optimization pipeline because the results can change if we optimize away any <span role="doc-pagebreak" epub:type="pagebreak" id="pg_601" aria-label="601"/><samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp> instructions. <a href="chapter19.xhtml#list19-20">Listing 19-20</a> demonstrates how it fits into the overall optimization pipeline we defined in <a href="chapter19.xhtml#list19-6">Listing 19-6</a>.</p>&#13;
<a id="list19-20"/>&#13;
<pre><code>optimize(function_body, enabled_optimizations):&#13;
<var>    --snip--</var>&#13;
    while True:&#13;
<b>        aliased_vars = address_taken_analysis(function_body)</b>&#13;
<var>        --snip--</var>&#13;
        if enabled_optimizations contains "COPY_PROP":&#13;
            cfg = copy_propagation(cfg, <b>aliased_vars</b>)&#13;
        if enabled_optimizations contains "DEAD_STORE_ELIM":&#13;
            cfg = dead_store_elimination(cfg, <b>aliased_vars</b>)&#13;
<var>        --snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-20: Adding address-taken analysis to the TACKY optimization pipeline</samp></p>&#13;
<p class="TX">Address-taken analysis is just one kind of <i>alias analysis</i>, also known as <i>pointer analysis</i>, which tries to determine whether two pointers or variables can refer to the same object. Most pointer analysis algorithms are more powerful than address-taken analysis. For example, they could figure out that <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr1</samp> will never point to <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> in <a href="chapter19.xhtml#list19-19">Listing 19-19</a>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec33">&#13;
&#13;
<h5 class="H3"><span id="sec33"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Updating the Transfer Function</samp></h5>&#13;
<p class="TNI">Next, we’ll extend the transfer function to support the new types and instructions we added in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>.</p>&#13;
<p class="TX"><a href="chapter19.xhtml#list19-21">Listing 19-21</a> illustrates our new and improved transfer function. It reproduces <a href="chapter19.xhtml#list19-15">Listing 19-15</a>, with the changes to support additional types bolded.</p>&#13;
<a id="list19-21"/>&#13;
<pre><code>transfer(block, initial_reaching_copies, <b>aliased_vars</b>):&#13;
    current_reaching_copies = initial_reaching_copies&#13;
&#13;
    for instruction in block.instructions:&#13;
        annotate_instruction(instruction, current_reaching_copies)&#13;
        match instruction with&#13;
        | Copy(src, dst) -&gt;&#13;
            <var>--snip--</var>&#13;
            <b>if (get_type(src) == get_type(dst)) or (signedness(src) == signedness(dst)):</b>&#13;
                current_reaching_copies.add(instruction)&#13;
        | FunCall(fun_name, args, dst) -&gt;&#13;
            for copy in current_reaching_copies:&#13;
                if (copy.src is <b>in aliased_vars</b>&#13;
                    or copy.dst is <b>in aliased_vars</b>&#13;
                    or (<b>dst is not null and</b> (copy.src == dst or copy.dst == dst))):&#13;
                    current_reaching_copies.remove(copy)&#13;
        <b>| Store(src, dst_ptr) -&gt;</b>&#13;
            <b>for copy in current_reaching_copies:</b>&#13;
                <b>if (copy.src is in aliased_vars) or (copy.dst is in aliased_vars):</b>&#13;
                    <b>current_reaching_copies.remove(copy)</b>&#13;
        | Unary(operator, src, dst) <b>or any other instruction with dst field</b> -&gt;&#13;
            <var>--snip--</var>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_602" aria-label="602"/>        | _ -&gt; continue&#13;
&#13;
    annotate_block(block.id, current_reaching_copies)</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-21: The transfer function for reaching copies analysis, with support for features from Part II</samp></p>&#13;
<p class="TX">We’ve already touched on most of the changes in this listing. Before we add a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction to <samp class="SANS_TheSansMonoCd_W5Regular_11">current_reaching_copies</samp>, we’ll make sure that its source and destination have the same type, or at least types with the same signedness. The <samp class="SANS_TheSansMonoCd_W5Regular_11">signedness</samp> helper function should count <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> as a signed type and all pointer types as unsigned types, so we can propagate copies between <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, between different pointer types, and between pointers and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. (The concept of signedness doesn’t apply to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> or non-scalar types. That’s fine, because we don’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instructions to convert to or from these types. If a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> or non-scalar operand, both operands will have the same type, so we won’t need to check their signedness.)</p>&#13;
<p class="TX">When we encounter a function call or <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction, we’ll kill any copies to or from aliased variables. We’ll also account for the fact that a function call may not have a destination operand. Note that we don’t kill the <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction’s <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_ptr</samp> operand. <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> doesn’t change the value of the destination pointer itself, just the value of the object it points to. Finally, when we encounter any of the other instructions we added in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>—including type conversions, <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>—we’ll kill any copies to or from its destination. We won’t track copies to or from individual subobjects within structures or arrays, so <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> will kill reaching copies without generating any new ones.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec34">&#13;
&#13;
<h5 class="H3"><span id="sec34"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Updating rewrite_instruction</samp></h5>&#13;
<p class="TNI">We’ll rewrite most of the new TACKY instructions from <span class="Xref-1"><a href="part2.xhtml">Part II</a></span> in the same way as the instructions from <span class="Xref-1"><a href="part1.xhtml">Part I</a></span>, replacing any source operands that are defined by reaching copies. The one exception is <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>, which we’ll never rewrite. It wouldn’t make sense to apply copy propagation to <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>, because it uses its source operand’s address rather than its value.</p>&#13;
<aside class="box" aria-label="box-71"><p class="BoxTitle" id="box-71"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE COPY PROPAGATION PASS</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">If you completed only Part I, run the following command to test your implementation of copy propagation:</samp></p>&#13;
<pre><code>$ <b>./test_compiler </b><b><var>/path/to/your_compiler</var></b><b> --chapter 19 --propagate-copies</b>&#13;
<b>--int-only</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">If you completed Parts I</samp> <samp class="SANS_Futura_Std_Book_11">and II, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler </b><b><var>/path/to/your_compiler</var></b><b> --chapter 19 --propagate-copies</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec35">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_603" aria-label="603"/>&#13;
<h3 class="H1"><span id="sec35"/><span id="h1-180"/><samp class="SANS_Futura_Std_Bold_B_11">Dead Store Elimination</samp></h3>&#13;
<p class="TNI">Our last optimization is dead store elimination. We’ll use liveness analysis, a backward data-flow analysis, to calculate which variables are live at every point in the function we’re optimizing. Then, we’ll use the results of this analysis to identify dead stores and eliminate them.</p>&#13;
<p class="TX">A variable is <i>live</i> at a particular point if its value at that point might be read later in the program. Otherwise, it’s <i>dead</i>. To be more precise, a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is live at any given point <i>p</i> when two conditions are met. First, there must be at least one path from <i>p</i> to some later instruction that uses <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. We say that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is <i>generated</i> by any instruction that uses it. Second, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> must not be updated on the path from <i>p</i> to that later instruction. We say that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is <i>killed</i> by any instruction that updates it, just like a reaching copy is killed when either of its operands is updated. (You’ll see the terms <i>generate</i> and <i>kill</i> in discussions of most data-flow analyses, not just the two in this chapter.) Consider the control-flow graph in <a href="#fig19-10">Figure 19-10</a>.</p>&#13;
<figure class="IMG"><img id="fig19-10" class="img70" src="../images/fig19-10.jpg" alt="" width="1022" height="894"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-10: A control-flow graph in which x is live just after it’s defined <a href="description-61.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">There are two paths from <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>. On the path through <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is never used. On the path through <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is used in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction. We know that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is live at the point after <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp> because it’s generated on one of these paths. By the same logic, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is also live at the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>, at the beginning of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>, and just before the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>. On the other hand, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is dead at the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp> and at every point in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, since there are no paths from those points to an instruction that uses <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is also dead at the very beginning of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>, since we don’t use its (uninitialized) value before we assign it a new value in <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp>.</p>&#13;
<p class="TX">Now let’s look at the control-flow graph in <a href="#fig19-11">Figure 19-11</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_604" aria-label="604"/>&#13;
<figure class="IMG"><img id="fig19-11" class="img70" src="../images/fig19-11.jpg" alt="" width="1022" height="894"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-11: A control-flow graph with a dead store to x <a href="description-62.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Again, we have two paths from <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>. Both paths pass through <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instructions that use <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, but on both paths <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is killed between <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction that generates it. This means that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is dead right after <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp>. It’s alive at just two points in this control-flow graph: right after <samp class="SANS_TheSansMonoCd_W5Regular_11">x = f()</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp> and right after <samp class="SANS_TheSansMonoCd_W5Regular_11">x = g()</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>.</p>&#13;
<p class="TX">An instruction is a dead store if it assigns to a dead variable and has no other side effects. Therefore, <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp> is a dead store in <a href="#fig19-11">Figure 19-11</a> but not in <a href="#fig19-10">Figure 19-10</a>. Note that we care whether the variable is dead just <i>after</i> the instruction, not before it. In the code fragment</p>&#13;
<pre><code>x = x + 1&#13;
Return(0)</code></pre>&#13;
<p class="BodyContinued"><samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is live just before <samp class="SANS_TheSansMonoCd_W5Regular_11">x = x + 1</samp> but dead after it. The fact that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is dead just after we update it means that this instruction is a dead store, so we can eliminate it.</p>&#13;
<section epub:type="division" aria-labelledby="sec36">&#13;
&#13;
<h4 class="H2"><span id="sec36"/><span id="h2-223"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Liveness Analysis</samp></h4>&#13;
<p class="TNI">Like every data-flow analysis, liveness analysis requires a transfer function, a meet operator, and an iterative algorithm. Because this is a backward-flow problem, the transfer function will start at the end of a basic block and work its way to the beginning, instead of working from start to finish like we did in reaching copies analysis. Similarly, the meet operator will gather information from a block’s successors, not its predecessors. We’ll also use a slightly different iterative algorithm to send data backward through the control-flow graph. Let’s take a closer look at each of these pieces.</p>&#13;
<section epub:type="division" aria-labelledby="sec37">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_605" aria-label="605"/>&#13;
<h5 class="H3"><span id="sec37"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Transfer Function</samp></h5>&#13;
<p class="TNI">The transfer function takes the set of variables that are live at the end of a basic block and figures out which variables are live just before each instruction. As we saw in <a href="#fig19-10">Figures 19-10</a> and <a href="#fig19-11">19-11</a>, an instruction generates any variables that it reads and kills any variables that it updates. For example, to calculate the live variables before the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y * z</samp>, we would take the set of variables that are live right after the instruction, add <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>, and remove <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. If an instruction reads and writes the same variable, it generates the variable instead of killing it. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">x = x + 1</samp> generates <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.</p>&#13;
<p class="TX">Let’s apply the transfer function to the basic block in <a href="chapter19.xhtml#list19-22">Listing 19-22</a>.</p>&#13;
<a id="list19-22"/>&#13;
<pre><code>x = 4&#13;
x = x + 1&#13;
y = 3 * x&#13;
Return(y)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-22: A basic block</samp></p>&#13;
<p class="TX">The transfer function will start at the bottom of this basic block and work its way up. Let’s assume that there are no live variables at the end of the block, after the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction. (This assumption might not hold if the function deals with static variables, but we’ll worry about that later.) When we process the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction, we’ll add <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> to the set of live variables. Then, <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 3 * x</samp> will kill <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> and generate <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. The next instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">x = x + 1</samp>, generates <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. This has no effect because <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is already live. Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 4</samp> will kill <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, leaving no live variables at the start of the basic block. <a href="chapter19.xhtml#tab19-3">Table 19-3</a> summarizes which variables are live just after each instruction in <a href="chapter19.xhtml#list19-22">Listing 19-22</a>.</p>&#13;
<p class="TT" id="tab19-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 19-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">The Live Variables After Each Instruction in <a href="chapter19.xhtml#list19-22">Listing 19-22</a></samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Live variables</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Beginning of block</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">x = 4</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">{x}</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">x = x + 1</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">{x}</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">y = 3 * x</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">{y}</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Return(y)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Static variables complicate things, much like they did during reaching copies analysis. We don’t know how other functions will interact with any static variables that we encounter; they could read them, update them, or both. We’ll assume that every function reads every static variable. This assumption is conservative, since it prevents us from eliminating earlier writes to those variables. <a href="chapter19.xhtml#list19-23">Listing 19-23</a> gives the pseudocode for the transfer function.</p>&#13;
<a id="list19-23"/>&#13;
<pre><code>transfer(block, end_live_variables, all_static_variables):&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> current_live_variables = end_live_variables&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_606" aria-label="606"/>  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> for instruction in reverse(block.instructions):&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> annotate_instruction(instruction, current_live_variables)&#13;
&#13;
        match instruction with&#13;
        | Binary(operator, src1, src2, dst) -&gt;&#13;
            current_live_variables.remove(dst)&#13;
            if src1 is a variable:&#13;
                current_live_variables.add(src1)&#13;
            if src2 is a variable:&#13;
                current_live_variables.add(src2)&#13;
        | JumpIfZero(condition, target) -&gt;&#13;
            if condition is a variable:&#13;
                current_live_variables.add(condition)&#13;
        | <var>--snip--</var>&#13;
        | FunCall(fun_name, args, dst) -&gt;&#13;
            current_live_variables.remove(dst)&#13;
            for arg in args:&#13;
                if arg is a variable:&#13;
                    current_live_variables.add(arg)&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> current_live_variables.add_all(all_static_variables)&#13;
&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> annotate_block(block.id, current_live_variables)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-23: The transfer function for liveness analysis</samp></p>&#13;
<p class="TX">We’ll start with the set of variables that are live at the end of the block <span class="CodeAnnotation" aria-label="annotation1">❶</span>, then process the list of instructions in reverse <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We annotate each instruction with the set of variables that are live just after it executes <span class="CodeAnnotation" aria-label="annotation3">❸</span>; we’ll use this annotation later to figure out whether the instruction is a dead store. Then, we calculate which variables are live just before the instruction. We’ll kill its destination if it has one, then add every variable that it reads. <a href="chapter19.xhtml#list19-23">Listing 19-23</a> includes the pseudocode to handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> instruction, which updates one operand and reads two others, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> instruction, which reads an operand but doesn’t update anything. It omits the pseudocode to handle most of the other instructions, since they follow the same pattern. <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> is the one special case; we’ll kill its destination and add its arguments, as usual, but we’ll add every static variable too <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Finally, we’ll annotate the whole block with the variables that are live before the first instruction <span class="CodeAnnotation" aria-label="annotation5">❺</span>. The meet operator will use this information later.</p>&#13;
<p class="TX">There are a couple of ways to calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">all_static_variables</samp>. One option is to scan this TACKY function and look for static variables before you start the dead store elimination pass. Another option is to scan the whole symbol table for static variables, without worrying about which variables show up in which functions. There’s no harm in adding superfluous static variables here, since they won’t change which instructions we eventually eliminate.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec38">&#13;
&#13;
<h5 class="H3"><span id="sec38"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Meet Operator</samp></h5>&#13;
<p class="TNI">The meet operator calculates which variables are live at the end of a basic block. To find the live variables at the end of some block <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>, we’ll look at all <span role="doc-pagebreak" epub:type="pagebreak" id="pg_607" aria-label="607"/>of its successors. If a variable is live at the start of at least one successor, it must also be live at the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>, because there’s at least one path from the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> through that successor to an instruction that generates that variable. Basically, we’ll take the set union of all the live variables at the start of all the block’s successors.</p>&#13;
<p class="TX">We’ll assume that every static variable is live at the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp> node. Other functions, or other invocations of the current function, might read those variables. Variables with automatic storage duration are all dead at <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>, since they’re not accessible after we leave the function. The pseudocode in <a href="chapter19.xhtml#list19-24">Listing 19-24</a> defines the meet operator.</p>&#13;
<a id="list19-24"/>&#13;
<pre><code>meet(block, all_static_variables):&#13;
    live_vars = {}&#13;
    for succ_id in block.successors:&#13;
        match succ_id with&#13;
        | EXIT -&gt; live_vars.add_all(all_static_variables)&#13;
        | ENTRY -&gt; fail("Malformed control-flow graph")&#13;
        | BlockId(id) -&gt;&#13;
            succ_live_vars = get_block_annotation(succ_id)&#13;
            live_vars.add_all(succ_live_vars)&#13;
&#13;
    return live_vars</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-24: The meet operator for liveness analysis</samp></p>&#13;
<p class="TX">In reaching copies analysis, we were looking for copies that appeared on <i>every</i> path to a point, so we used set intersection as our meet operator. In liveness analysis, we want to know if a variable is used on <i>any</i> path from a point, so we use set union instead. This is unrelated to the fact that one analysis is forward and the other is backward. Some forward analyses use set union because they care whether at least one path to a point has some property. Some backward analyses use set intersection because they care whether every path from a point has some property. Other, more complex analyses don’t use set union or intersection, and instead use different meet operators entirely.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec39">&#13;
&#13;
<h5 class="H3"><span id="sec39"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Iterative Algorithm</samp></h5>&#13;
<p class="TNI">Finally, we’ll implement the iterative algorithm for liveness analysis. This differs from the iterative algorithm in <a href="chapter19.xhtml#list19-17">Listing 19-17</a> in a couple of ways. First, when the annotation on a block changes, we’ll add its predecessors, rather than its successors, to the worklist. Second, we’ll use a different initial block annotation. Recall that each block’s initial annotation should be the identity element for the meet operator. Since our meet operator is set union, the initial annotation is the empty set. As we analyze more paths from a block to later points in the program, we’ll add more live variables to this set.</p>&#13;
<p class="TX">I won’t provide the pseudocode for the backward iterative algorithm, since it’s so similar to the forward algorithm we’ve already defined. But I will give you a couple of tips about how to implement it. First, you may want <span role="doc-pagebreak" epub:type="pagebreak" id="pg_608" aria-label="608"/>to initialize the worklist in postorder. (Recall that you sort the nodes of a graph in postorder by performing a depth-first traversal and visiting each node after you’ve visited its successors.) This makes the backward algorithm terminate faster, just like initializing the worklist in reverse postorder helps the forward algorithm terminate faster. This ordering means that whenever possible, you’ll visit each block only after you’ve visited all of its successors.</p>&#13;
<p class="TX">My second tip is to make your backward iterative algorithm reusable. In the next chapter, we’ll implement liveness analysis again, this time for assembly programs. The details of the meet operator and transfer function will change, but the iterative algorithm won’t. Try to structure your code so that you’ll be able to reuse the same iterative algorithm with a different meet operator and transfer function; then, you’ll be able to use it to analyze assembly programs in the next chapter.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec40">&#13;
&#13;
<h4 class="H2"><span id="sec40"/><span id="h2-224"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Dead Stores</samp></h4>&#13;
<p class="TNI">After we run liveness analysis, we’ll find any dead stores in the TACKY function and remove them. An instruction is a dead store if its destination is dead as soon as we execute it, like in the following example:</p>&#13;
<pre><code>x = 1&#13;
x = 2</code></pre>&#13;
<p class="TX">Liveness analysis will tell us that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is dead right after <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 1</samp>, making that instruction safe to delete. We’ll never delete function calls, even when they update dead variables, because they may have other side effects. We also won’t delete instructions without destinations, like <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>. <a href="chapter19.xhtml#list19-25">Listing 19-25</a> demonstrates how to identify a dead store.</p>&#13;
<a id="list19-25"/>&#13;
<pre><code>is_dead_store(instr):&#13;
    if instr is FunCall:&#13;
        return False&#13;
&#13;
    if instr has a dst field:&#13;
        live_variables = get_instruction_annotation(instr)&#13;
        if instr.dst is not in live_variables:&#13;
            return True&#13;
&#13;
    return False</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-25: Identifying a dead store</samp></p>&#13;
<p class="TX">If you completed only <span class="Xref-1"><a href="part1.xhtml">Part I</a></span>, you’ve learned everything you need to know about dead store elimination! You can skip straight to the test suite. Otherwise, read on to learn how to handle the types and instructions we added in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec41">&#13;
&#13;
<h4 class="H2"><span id="sec41"/><span id="h2-225"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Supporting Part II TACKY Programs</samp></h4>&#13;
<p class="TNI">To update the transfer function, we’ll need to think through which live variables each new instruction might generate or kill. The type conversion <span role="doc-pagebreak" epub:type="pagebreak" id="pg_609" aria-label="609"/>instructions, like <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>, are straightforward. Each one generates its source operand and kills its destination, much like the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> instructions we already handle. <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> also follows the usual pattern: it generates both source operands and kills its destination.</p>&#13;
<p class="TX">The operations on pointers and aggregate types are trickier. Pointers cause essentially the same problem they did in reaching copies analysis: when we read or write through a pointer, we can’t tell which underlying object is being accessed. When in doubt, we should err on the conservative side and assume that a variable is live. Therefore, reading through a pointer should generate every aliased variable, but writing through a pointer shouldn’t kill any of them. We’ll take a similar approach to aggregate variables: reading part of an aggregate variable will generate it, but updating part of it won’t kill it. I won’t provide updated pseudocode for the transfer function; now that we’ve covered the key points, I’ll let you work through the remaining details on your own. The meet operator won’t change; in particular, static variables are still live at <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>, but other aliased variables aren’t, because their lifetimes end when the function returns.</p>&#13;
<p class="TX">Finally, let’s update the last step in this optimization, where we use the results of liveness analysis to find dead stores and eliminate them. We’ll never eliminate a <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction, since we don’t know whether its destination is dead. Even if every single variable in the current function is dead, a <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> might still have a visible side effect. For instance, it could update an object defined in a different function, like in the following example:</p>&#13;
<pre><code>update_through_pointer(param):&#13;
    Store(10, param)&#13;
    Return(0)</code></pre>&#13;
<p class="TX">After the <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction, there are no live variables in <samp class="SANS_TheSansMonoCd_W5Regular_11">update_</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">through _pointer</samp>. But that instruction clearly isn’t a dead store; it updates an object that our analysis didn’t track but that will likely be read later in the program.</p>&#13;
<p class="TX">The usual logic for spotting dead stores applies to all the other instructions from <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>, including <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>.</p>&#13;
<aside class="box" aria-label="box-72"><p class="BoxTitle" id="box-72"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE WHOLE OPTIMIZATION PIPELINE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Now that you’ve implemented the whole optimization pipeline, you can test it out. You might want to start by testing just the dead store elimination pass. If you completed only Part I, you can do that with the following command:</samp></p>&#13;
<pre><code>$ <b>./test_compiler </b><b><var>/path/to/your_compiler</var></b><b> --chapter 19 --eliminate-dead-stores</b>&#13;
<b>--int-only</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_610" aria-label="610"/><samp class="SANS_Futura_Std_Book_11">If you completed Parts I and II, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler </b><b><var>/path/to/your_compiler</var></b><b> --chapter 19 --eliminate-dead-stores</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">The</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">--eliminate-dead-stores</samp> <samp class="SANS_Futura_Std_Book_11">option will run the dead store elimination–specific tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_19/dead_store_elimination</samp><samp class="SANS_Futura_Std_Book_11">. It will also run the tests from earlier chapters with all four optimizations enabled.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">To test the whole optimization pipeline, run</samp></p>&#13;
<pre><code>$ <b>./test_compiler </b><b><var>/path/to/your_compiler</var></b><b> --chapter 19 --int-only</b>&#13;
</code></pre>&#13;
<p class="BoxBodyContinued"><samp class="SANS_Futura_Std_Book_11">or:</samp></p>&#13;
<pre><code>$ <b>./test_compiler </b><b><var>/path/to/your_compiler</var></b><b> --chapter 19</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">This command will run all the tests of individual optimizations and all the tests from previous chapters with all four optimizations enabled (as usual, the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">--int-only</samp> <samp class="SANS_Futura_Std_Book_11">option excludes any tests that rely on language features from Part II). It will also run the tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_19/whole_pipeline</samp><samp class="SANS_Futura_Std_Book_11">, which focus on how the different optimizations work together. These tests validate that each optimization takes advantage of any optimization opportunities that the others create.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec42">&#13;
&#13;
<h3 class="H1"><span id="sec42"/><span id="h1-181"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">In this chapter, you implemented four important compiler optimizations: constant folding, unreachable code elimination, copy propagation, and dead store elimination. You learned how these optimizations work together to transform the TACKY representation of a program, resulting in smaller, faster, simpler assembly code than your compiler produced before. You also learned how to construct a control-flow graph and perform data-flow analysis. These techniques are fundamental to many different optimizations, not just the ones we covered in this chapter. If you ever want to implement more TACKY optimizations on your own, you’ll be well prepared.</p>&#13;
<p class="TX">In the next chapter, you’ll write a register allocator. You’ll use a graph coloring algorithm to map pseudoregisters to hardware registers, and you’ll learn how to spill a register when graph coloring fails and you run out of registers. You’ll also use a technique called register coalescing to clean up many of the unnecessary <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions in your assembly code. By the end of the chapter, your assembly programs still won’t look quite like what a production compiler would generate, but they’ll be a lot closer.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec43">&#13;
&#13;
<h3 class="H1"><span id="sec43"/><span id="h1-182"/><samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp></h3>&#13;
<p class="TNI">This section lists the resources I referred to while writing this chapter, organized by topic.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_611" aria-label="611"/><b>Security implications of compiler optimizations</b></p>&#13;
<ul class="BL">&#13;
<li class="ListBullet">“Dead Store Elimination (Still) Considered Harmful” by Zhaomo Yang et al. surveys the different ways programmers try to avoid unwanted dead store elimination and the limits of each approach (<i><a href="https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-yang.pdf">https://<wbr/>www<wbr/>.usenix<wbr/>.org<wbr/>/system<wbr/>/files<wbr/>/conference<wbr/>/usenixsecurity17<wbr/>/sec17<wbr/>-yang<wbr/>.pdf</a></i>).</li>&#13;
<li class="ListBullet">“The Correctness-Security Gap in Compiler Optimization” by Vijay D’Silva, Mathias Payer, and Dawn Song looks at the security impact of a few different compiler optimizations and formalizes some of the security properties that optimizations should preserve (<i><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=7163211">https://<wbr/>ieeexplore<wbr/>.ieee<wbr/>.org<wbr/>/stamp<wbr/>/stamp<wbr/>.jsp<wbr/>?tp<wbr/>=&amp;arnumber<wbr/>=7163211</a></i>).</li>&#13;
</ul>&#13;
<p class="ListHead"><b>Data-flow analysis</b></p>&#13;
<ul class="BL">&#13;
<li class="ListBullet"><a href="chapter9.xhtml">Chapter 9</a> of <i>Compilers: Principles, Techniques, and Tools</i>, 2nd edition, by Alfred V. Aho et al. (Addison-Wesley, 2006) defines data-flow analysis more rigorously than I did here. It also proves that the iterative algorithm is correct and terminates in a reasonable amount of time and discusses the use of reverse postorder traversal (which it calls <i>depth-first ordering</i>) in this algorithm.</li>&#13;
<li class="ListBullet">Paul Hilfinger’s lecture slides from CS164 at UC Berkeley give an example-heavy overview of the same material (<i><a href="https://inst.eecs.berkeley.edu/~cs164/sp11/lectures/lecture37-2x2.pdf">https://<wbr/>inst<wbr/>.eecs<wbr/>.berkeley<wbr/>.edu<wbr/>/~cs164<wbr/>/sp11<wbr/>/lectures<wbr/>/lecture37<wbr/>-2x2<wbr/>.pdf</a></i>). I found the explanation of liveness analysis in these slides particularly helpful.</li>&#13;
<li class="ListBullet">Eli Bendersky’s blog post “Directed Graph Traversal, Orderings and Applications to Data-Flow Analysis” describes how to sort graphs in postorder and reverse postorder to speed up data-flow analysis (<i><a href="https://eli.thegreenplace.net/2015/directed-graph-traversal-orderings-and-applications-to-data-flow-analysis">https://<wbr/>eli<wbr/>.thegreenplace<wbr/>.net<wbr/>/2015<wbr/>/directed<wbr/>-graph<wbr/>-traversal<wbr/>-orderings<wbr/>-and<wbr/>-applications<wbr/>-to<wbr/>-data<wbr/>-flow<wbr/>-analysis</a></i>).</li>&#13;
</ul>&#13;
<p class="ListHead"><b>Copy propagation</b></p>&#13;
<ul class="BL">&#13;
<li class="ListBullet">Every discussion of reaching copies analysis seems to formulate it slightly differently. The version in this chapter draws on Jeffrey Ullman’s lecture notes on <i>Compilers: Principles, Techniques, and Tools</i> (<i><a href="http://infolab.stanford.edu/~ullman/dragon/slides3.pdf">http://<wbr/>infolab<wbr/>.stanford<wbr/>.edu<wbr/>/~ullman<wbr/>/dragon<wbr/>/slides3<wbr/>.pdf</a></i> and <i><a href="http://infolab.stanford.edu/~ullman/dragon/slides4.pdf">http://<wbr/>infolab<wbr/>.stanford<wbr/>.edu<wbr/>/~ullman<wbr/>/dragon<wbr/>/slides4<wbr/>.pdf</a></i>).</li>&#13;
<li class="ListBullet">I’ve borrowed the idea of deleting redundant copies from LLVM’s low-level copy propagation pass (<i><a href="https://llvm.org/doxygen/MachineCopyPropagation_8cpp_source.html">https://<wbr/>llvm<wbr/>.org<wbr/>/doxygen<wbr/>/MachineCopyPropagation<wbr/>_8cpp<wbr/>_source<wbr/>.html</a></i>).</li>&#13;
</ul>&#13;
<p class="ListHead"><b>Alias analysis</b></p>&#13;
<ul class="BL">&#13;
<li class="ListBullet">You can find a quick overview of alias analysis algorithms in Phillip Gibbons’s lecture slides from his Carnegie Mellon course on compiler optimizations (<i><a href="https://www.cs.cmu.edu/afs/cs/academic/class/15745-s16/www/lectures/L16-Pointer-Analysis.pdf">https://<wbr/>www<wbr/>.cs<wbr/>.cmu<wbr/>.edu<wbr/>/afs<wbr/>/cs<wbr/>/academic<wbr/>/class<wbr/>/15745<wbr/>-s16<wbr/>/www<wbr/>/lectures<wbr/>/L16<wbr/>-Pointer<wbr/>-Analysis<wbr/>.pdf</a></i>).</li>&#13;
</ul>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>