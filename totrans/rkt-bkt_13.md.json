["```\nMEMORY:D984 pop     ax\n\nMEMORY:D985 sub     ax, 0Eh ➊\n\nMEMORY:D988 push    cs\n\nMEMORY:D989 push    ax ➋\n\nMEMORY:D98A push    ds\n\nMEMORY:D98B jmp     short loc_D9A0 ➌\n```", "```\n; Basic Block #2\n\nMEMORY:D9A0 push    es\n\nMEMORY:D9A1 pusha\n\nMEMORY:D9A2 mov     di, 13h\n\nMEMORY:D9A5 push    40h ; '@'\n\nMEMORY:D9A7 pop     ds\n\nMEMORY:D9A8 jmp     short loc_D95D\n\n--snip--\n\n; Basic Block #3\n\nMEMORY:D95D mov     cx, [di]\n\nMEMORY:D95F sub     ecx, 3 ➊\n\nMEMORY:D963 mov     [di], cx\n\nMEMORY:D965 shl     cx, 6\n\nMEMORY:D968 push    cs\n\nMEMORY:D98B jmp     short loc_D98F ➋\n```", "```\n   ; Basic Block #4\n\n   MEMORY:D98F pop     ds\n\n   MEMORY:D990 mov     bx, sp\n\n   MEMORY:D992 mov     bp, 4D4h\n\n   MEMORY:D995 jmp     short loc_D954\n\n   --snip--\n\n   ; Basic Block #5\n\n   MEMORY:D954 push    ax\n\n   MEMORY:D955 push    cx\n\n   MEMORY:D956 add     ax, 0Eh\n\n➊ MEMORY:D959 mov     si, ax\n\n   MEMORY:D95B jmp     short loc_D96B\n\n   --snip--\n\n   ; Basic Block #6\n\n   MEMORY:D96B add     bp, ax\n\n   MEMORY:D96D xor     di, di\n\n➋ MEMORY:D96F pop     es\n\n   MEMORY:D970 jmp     short loc_D93E\n\n   --snip--\n\n   ; Basic Block #7\n\n➌ MEMORY:D93E mov     dx, 0FCE8h\n\n   MEMORY:D941 cld\n\n➍ MEMORY:D942 mov     cx, 4C3h\n\n   MEMORY:D945 loc_D945:\n\n➎ MEMORY:D945 mov     ax, [si]\n\n➏ MEMORY:D947 xor     ax, dx\n\n   MEMORY:D949 jmp     short loc_D972\n\n   --snip--\n\n   ; Basic Block #8\n\n➐ MEMORY:D972 mov     es:[di], ax\n\n   MEMORY:D975 add     si, 2\n\n   MEMORY:D978 add     di, 2\n\n   MEMORY:D97B loop    loc_D945\n\n   MEMORY:D97D pop     di\n\n   MEMORY:D97E mov     ax, 25Eh\n\n   MEMORY:D981 push    es\n\n➑ MEMORY:D982 jmp     short loc_D94B\n```", "```\n   ; Basic Block #9\n\n   MEMORY:D94B push    ds\n\n   MEMORY:D94C pop     es\n\n   MEMORY:D94D mov     cx, 4D4h\n\n   MEMORY:D950 add     ax, cx\n\n   MEMORY:D952 jmp     short loc_D997\n\n   --snip--\n\n   ; Basic Block #10\n\n   MEMORY:D997 mov     si, 4B2h\n\n➊ MEMORY:D99A push    ax\n\n   MEMORY:D99B push    cx\n\n   MEMORY:D99C add     si, bp\n\n   MEMORY:D99E jmp     short loc_D98D\n\n   --snip--\n\n   ; Basic Block #11\n\n   MEMORY:D98D pop     bp\n\n➋ MEMORY:D98E retf\n```", "```\ntypedef struct _LOADER_PARAMETER_BLOCK\n\n{\n\n     LIST_ENTRY LoadOrderListHead;\n\n     LIST_ENTRY MemoryDescriptorListHead;\n\n  ➊ LIST_ENTRY BootDriverListHead;\n\n     ULONG KernelStack;\n\n     ULONG Prcb;\n\n     ULONG Process;\n\n     ULONG Thread;\n\n     ULONG RegistryLength;\n\n     PVOID RegistryBase;\n\n     PCONFIGURATION_COMPONENT_DATA ConfigurationRoot;\n\n     CHAR * ArcBootDeviceName;\n\n     CHAR * ArcHalDeviceName;\n\n     CHAR * NtBootPathName;\n\n     CHAR * NtHalPathName;\n\n     CHAR * LoadOptions;\n\n     PNLS_DATA_BLOCK NlsData;\n\n     PARC_DISK_INFORMATION ArcDiskInformation;\n\n     PVOID OemFontFile;\n\n     _SETUP_LOADER_BLOCK * SetupLoaderBlock;\n\n     PLOADER_PARAMETER_EXTENSION Extension;\n\n     BYTE u[12];\n\n     FIRMWARE_INFORMATION_LOADER_BLOCK FirmwareInformation;\n\n} LOADER_PARAMETER_BLOCK, *PLOADER_PARAMETER_BLOCK;\n```", "```\ntypedef struct _PAYLOAD_CONFIGURATION_BLOCK\n\n{\n\n   DWORD Signature;              // \"JFA\\0\"\n\n   DWORD PayloadRva;             // RVA of the payload start\n\n   DWORD PayloadSize;            // Size of the payload\n\n   DWORD NumberOfProcessNames;   // Number of NULL-terminated strings in ProcessNames\n\n   char ProcessNames[0];         // Array of NULL-terminated process names to inject payload\n\n} PAYLOAD_CONFIGURATION_BLOCK, *PPAYLOAD_CONFIGURATION_BLOCK;\n```", "```\nint __stdcall NewIrpMjInternalHandler(PDEVICE_OBJECT DeviceObject, PIRP Irp)\n\n{\n\n  UCHAR ScsiCommand;\n\n  NTSTATUS Status;\n\n  unsigned __int64 Lba;\n\n  PVOID pTransferBuffer;\n\n➊ if ( DeviceObject != g_DiskDevObj )\n\n    return OriginalIrpMjInternalHandler(DeviceObject, Irp);\n\n➋ ScsiCommand = GetSrbParameters(_Irp, &Lba, &DeviceObject, &pTransferBuffer,\n\n                                                             Irp);\n\n  if ( ScsiCommand == 0x2A || ScsiCommand == 0x3B )\n\n  {\n\n    // SCSI write commands\n\n  ➌ if ( CheckSrbParams(Lba, DeviceObject)\n\n    {\n\n       Status = STATUS_ACCESS_DENIED;\n\n     ➍ Irp->IoStatus.Status = STATUS_ACCESS_DENIED;\n\n       IofCompleteRequest(Irp, 0);\n\n    } else\n\n    {\n\n       return OriginalIrpMjInternalHandler(DeviceObject, Irp);\n\n    }\n\n  } else if ( ScsiCommand == 0x28 || ScsiCommand == 0x3C)\n\n  {\n\n      // SCSI read commands\n\n      if ( CheckSrbParams(Lba, DeviceObject)\n\n      {\n\n     ➎ Status = SetCompletionRoutine(DeviceObject, Irp, Lba,\n\n                                      DeviceObject, pTransferBuffer, Irp);\n\n      } else\n\n      {\n\n        return OriginalIrpMjInternalHandler(DeviceObject, Irp);\n\n      }\n\n  }\n\n  if ( Status == STATUS_REQUEST_NOT_ACCEPTED )\n\n    return OriginalIrpMjInternalHandler(DeviceObject, Irp);\n\n  return Status;\n\n}\n```", "```\nntdll!ZwSetContextThread\n\nntdll!ZwGetContextThread\n\nntdll!ZwUnmapViewOfSection\n\nntdll!ZwMapViewOfSection\n\nntdll!ZwAllocateVirtualMemory\n\nntdll!ZwWriteVirtualMemory\n\nntdll!ZwProtectVirtualMemory\n\nntdll!ZwCreateThread\n\nntdll!ZwOpenProcess\n\nntdll!ZwQueueApcThread\n\nntdll!ZwTerminateProcess\n\nntdll!ZwTerminateThread\n\nntdll!ZwResumeThread\n\nntdll!ZwQueryDirectoryFile\n\nntdll!ZwCreateProcess\n\nntdll!ZwCreateProcessEx\n\nntdll!ZwCreateFile\n\nntdll!ZwDeviceIoControlFile\n\nntdll!ZwClose\n\nntdll!ZwSetInformationProcess\n\nkernel32!CreateRemoteThread\n\nkernel32!WriteProcessMemory\n\nkernel32!VirtualProtectEx\n\nkernel32!VirtualAllocEx\n\nkernel32!SetThreadContext\n\nkernel32!CreateProcessInternalA\n\nkernel32!CreateProcessInternalW\n\nkernel32!CreateFileA\n\nkernel32!CreateFileW\n\nkernel32!CopyFileA\n\nkernel32!CopyFileW\n\nkernel32!CopyFileExW\n\nws2_32!connect\n\nws2_32!send\n\nws2_32!recv\n\nws2_32!gethostbyname\n```"]