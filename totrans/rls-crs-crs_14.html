<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;Performance"><div class="titlepage"><div><div><h1 class="title"><a id="performance"/>Chapter 12. Performance</h1></div></div></div><p><a class="indexterm" id="iddle1600"/><a class="indexterm" id="iddle1915"/><a class="indexterm" id="iddle1949"/><a class="indexterm" id="iddle2128"/>The relative performance of Ruby on Rails compared to other languages and web
        frameworks is still a topic of debate. A quick Google search reveals that many people feel
        Ruby on Rails is slow.</p><p>Newer versions of the Ruby interpreter have made great strides where performance is
        concerned. Ruby 2.0 included garbage collection optimizations and other improvements that
        made it much faster than older versions. Ruby 2.1 introduced a generational garbage
        collector that was even faster still.</p><p>As the Ruby language has improved, so has Ruby on Rails. The Rails framework now
        includes several features designed specifically to improve application performance. This
        chapter starts with discussions of two of those built-in features and then moves on to cover
        some things you can do to improve performance. Finally, I’ll talk about the caching
        techniques supported by Rails.</p><div class="sect1" title="Built-in Optimization Features"><div class="titlepage"><div><div><h1 class="title"><a id="built-in_optimization_features"/>Built-in Optimization Features</h1></div></div></div><p><a class="indexterm" id="iddle1072"/><a class="indexterm" id="iddle1075"/><a class="indexterm" id="iddle1076"/><a class="indexterm" id="iddle1173"/><a class="indexterm" id="iddle1176"/><a class="indexterm" id="iddle1302"/><a class="indexterm" id="iddle1331"/><a class="indexterm" id="iddle1413"/><a class="indexterm" id="iddle1498"/><a class="indexterm" id="iddle1764"/><a class="indexterm" id="iddle1817"/><a class="indexterm" id="iddle1912"/><a class="indexterm" id="iddle1913"/><a class="indexterm" id="iddle1947"/><a class="indexterm" id="iddle2094"/><a class="indexterm" id="iddle2096"/><a class="indexterm" id="iddle2097"/><a class="indexterm" id="iddle2131"/>The asset pipeline and turbolinks are two built-in Rails performance
          optimizations you’ve been using since creating your original blog. Both of these
          features are enabled by default on new Rails applications, and we’ll explore how
          they work here.</p><div class="sect2" title="Asset Pipeline"><div class="titlepage"><div><div><h2 class="title"><a id="asset_pipeline"/>Asset Pipeline</h2></div></div></div><p>The <span class="emphasis"><em>asset pipeline</em></span> is a Rails feature that combines all of the
            individual JavaScript and CSS files used by your application into one JavaScript and one
            CSS file, reducing the number of requests a browser makes to render a web page because
            your application uses more than one file of each type. Web browsers are limited in the
            number of requests they can make in parallel, so fewer requests should result in faster
            loading pages.</p><p>The asset pipeline also <span class="emphasis"><em>minifies</em></span>, or compresses, JavaScript and
            CSS files by removing whitespace and comments. Smaller files load faster, so your web
            pages load faster.</p><p>Finally, the asset pipeline preprocessor also enables you to use higher-level
            languages such as CoffeeScript instead of JavaScript and Sass instead of plain CSS.
            Files in these higher-level languages are precompiled to plain JavaScript and CSS using
            their respective compilers before being served so web browsers can understand
            them.</p><div class="sect3" title="Manifests"><div class="titlepage"><div><div><h3 class="title"><a id="manifests"/>Manifests</h3></div></div></div><p>As you generate controllers for your application, Rails also generates a
              corresponding JavaScript and CSS file in the
                <span class="emphasis"><em>app/assets/javascripts</em></span> and
                <span class="emphasis"><em>app/assets/stylesheets</em></span> directories. Rather than link to each of
              these files separately in your application, Rails uses a manifest file. As mentioned
              in <a class="xref" href="ch05.html" title="Chapter 5. Views">Chapter 5</a>, a manifest file is a list of other files needed by your
              application.</p><p>Manifest files use <span class="emphasis"><em>directives</em></span>, instructions specifying other
              files to include, in order to build a single file for use in the production
              environment. The <code class="literal">require</code> directive includes a single file in the
              manifest. The <code class="literal">require_tree</code> directive includes all files in a
              directory. The <code class="literal">require_self</code> directive includes the contents of the
              manifest file.</p><p>To see an example, open the default CSS manifest at
                <span class="emphasis"><em>app/assets/stylesheets/application.css</em></span>:</p><a id="pro_id00374"/><pre class="programlisting">  /*
   * This is a manifest file that'll be compiled into application.css,
   * which will include all the files listed below.
   *
  --<span class="emphasis"><em>snip</em></span>--
   *
➊  *= require_tree .
➋  *= require bootstrap
➌  *= require_self
   */</pre><p><a class="indexterm" id="iddle1069"/><a class="indexterm" id="iddle1175"/><a class="indexterm" id="iddle1177"/><a class="indexterm" id="iddle1469"/><a class="indexterm" id="iddle1611"/><a class="indexterm" id="iddle1797"/><a class="indexterm" id="iddle2041"/><a class="indexterm" id="iddle2098"/><a class="indexterm" id="iddle2315"/>This file first uses the <code class="literal">require_tree .</code> directive
              ➊ to include all CSS files in the current directory. It then includes the
              Bootstrap stylesheets using the <code class="literal">require bootstrap</code> directive
              ➋ you added in <a class="xref" href="ch09.html" title="Chapter 9. Authentication">Chapter 9</a>. Finally, the
                <code class="literal">require_self</code> directive ➌ includes the contents of this
              file below the comment block. Currently, nothing appears below the comment
              block.</p><p>The asset pipeline searches for assets in three different locations by default.
              You know about one of them already: The <span class="emphasis"><em>app/assets</em></span> directory is
              used for CSS, JavaScript, and image files owned by your application.</p><p>The <span class="emphasis"><em>lib/assets</em></span> directory is for assets needed by libraries
              you have written. Because you haven’t written any libraries yet, this directory
              is currently empty. The <span class="emphasis"><em>vendor/assets</em></span> directory is for assets
              created by third parties, such as code for JavaScript plug-ins and CSS
              frameworks.</p><p>Ruby gems can add their own directories to the list of locations that the asset
              pipeline searches. You can see this in the JavaScript manifest at
                <span class="emphasis"><em>app/assets/javascripts/application.js</em></span>:</p><a id="pro_id00375"/><pre class="programlisting">  // This is a manifest file that'll be compiled into application.js,
  // which will include all the files listed below.
  //
  --<span class="emphasis"><em>snip</em></span>--
  //
➊ //= require jquery
  //= require jquery_ujs
  //= require turbolinks
➋ //= require_tree .
➌ //= require bootstrap</pre><p>This file uses the <code class="literal">require</code> directive ➊ to include the
              jQuery, jQuery UJS, and Turbolinks libraries that are part of the jquery-rails and
              turbolinks gems included in your application’s
              <span class="emphasis"><em>Gemfile</em></span>.</p><p>It then uses <code class="literal">require_tree</code> ➋ to include all JavaScript
              files in the current directory. Finally, it requires the JavaScript files ➌
              needed by the Bootstrap CSS framework.</p><p>You won’t find <span class="emphasis"><em>jquery</em></span>, <span class="emphasis"><em>jquery_ujs</em></span>,
                <span class="emphasis"><em>turbolinks</em></span>, or <span class="emphasis"><em>bootstrap</em></span> in the
                <span class="emphasis"><em>vendor/assets/javascripts</em></span> directory. Instead, the gems that
              provide these files have updated the asset pipeline search path to include their own
              directories.</p><p>You can see the complete list of asset pipeline search paths by entering
                <code class="literal">Rails.application.config.assets.paths</code> in the Rails console. This
              statement returns an array of paths. In this list, you should find paths such as
                <span class="emphasis"><em>jquery-rails-3.1.0/vendor/assets/javascript</em></span>,
                <span class="emphasis"><em>turbolinks-2.2.2/lib/assets/javascripts</em></span>, and
                <span class="emphasis"><em>bootstrap-sass-3.1.1.0/vendor/assets/javascripts</em></span>.</p></div><div class="sect3" title="Debug Mode"><div class="titlepage"><div><div><h3 class="title"><a id="debug_mode"/>Debug Mode</h3></div></div></div><p>As you’ve seen, CSS and JavaScript files are served as separate,
              uncompressed files in the development environment. Your social media application is
              serving 31 separate CSS and JavaScript files according to the server output. An asset
              pipeline configuration called <span class="emphasis"><em>debug mode</em></span> controls how assets are
              handled in each environment.</p><p><a class="indexterm" id="iddle1174"/><a class="indexterm" id="iddle1179"/><a class="indexterm" id="iddle1293"/><a class="indexterm" id="iddle1358"/><a class="indexterm" id="iddle1362"/><a class="indexterm" id="iddle1493"/><a class="indexterm" id="iddle2002"/><a class="indexterm" id="iddle2010"/><a class="indexterm" id="iddle2064"/>In the development environment, debug mode is turned on. That means the
              files referred to in the CSS and JavaScript files are served separately, which is
              useful if you need to debug an issue with a file using your browser’s
              development tools.</p><p>If you want to force assets to be combined and preprocessed so you can see how
              they are served in the production environment, you can turn off debug mode. Just
              change the value of <code class="literal">config.assets.debug</code> near the bottom of the
              development environment configuration file
                <span class="emphasis"><em>config/environments/development.rb</em></span>:</p><a id="pro_id00376"/><pre class="programlisting">config.assets.debug = <span class="strong"><strong>false</strong></span></pre><p>When debug mode is off, Rails concatenates and runs preprocessors, such as the
              CoffeeScript or Sass compiler, on all files before serving them. Restart the Rails
              server after modifying this file, and then check the server output in your terminal to
              see the difference:</p><a id="pro_id00377"/><pre class="programlisting">  Started GET "/login" for 127.0.0.1 at 2014-03-16 20:38:43 -0500
  Processing by SessionsController#new as HTML
    Rendered sessions/new.html.erb within layouts/application (1.5ms)
  Completed 200 OK in 5ms (Views: 4.5ms | ActiveRecord: 0.0ms)

➊ Started GET "/assets/application.css" for 127.0.0.1 at ...

➋ Started GET "/assets/application.js" for 127.0.0.1 at ...</pre><p>Only two files (➊ and ➋) are served now—the CSS and JavaScript
              manifest files. This setting can actually slow down page loads in development because
              the files are combined for every request, so change
                <code class="literal">config.assets.debug</code> back to <code class="literal">true</code> before
              continuing.</p></div><div class="sect3" title="Asset Precompilation"><div class="titlepage"><div><div><h3 class="title"><a id="asset_precompilation"/>Asset Precompilation</h3></div></div></div><p>In the production environment, you should precompile your application’s
              assets and serve them as static files by your web server. You can precom-pile assets
              in several ways. When you deployed your blog to Heroku in <a class="xref" href="ch06.html" title="Chapter 6. Deployment">Chapter 6</a>, you precompiled assets during deployment. Rails also includes a
                <code class="literal">rake</code> task to precompile assets.</p><p>The <code class="literal">rake</code> task compiles all files from your CSS and JavaScript
              manifests and writes them to the <span class="emphasis"><em>public/assets</em></span> directory. You can
              precompile assets for the production environment with the following command:</p><a id="pro_id00378"/><pre class="programlisting">$ <span class="strong"><strong>RAILS_ENV=production bin/rake assets:precompile</strong></span></pre><p>During precompilation, an MD5 hash is generated from the contents of the compiled
              files and inserted into the filenames as the files are saved. Because the filename is
              based on the contents of the file, you can be sure the correct version of the file is
              served if you update a file.</p><p><a class="indexterm" id="iddle2268"/>For example, after precompilation, the file
                <span class="emphasis"><em>app/assets/stylesheets/application.css</em></span> might be named
                <span class="emphasis"><em>public/assets/application-d5ac076c28e38393c3059d7167501
              838.css</em></span>. Rails view helpers use the correct name automatically in
              production. You don’t need the compiled assets for development, so when
              you’re finished looking at them, remove them using the <code class="literal">assets:clobber
                rake</code> task:</p><a id="pro_id00379"/><pre class="programlisting">$ <span class="strong"><strong>RAILS_ENV=production bin/rake assets:clobber</strong></span></pre><p>This command deletes the <span class="emphasis"><em>public/assets</em></span> directory and all of
              its contents.</p><p>In <a class="xref" href="ch15.html" title="Chapter 15. Custom Deployment">Chapter 15</a>, you’ll learn how to deploy your
              application to your own server using a program called Capistrano. You can configure
              Capistrano to precompile assets automatically during deployment just as you did when
              you deployed the blog to Heroku.</p></div></div><div class="sect2" title="Turbolinks"><div class="titlepage"><div><div><h2 class="title"><a id="turbolinks"/>Turbolinks</h2></div></div></div><p>The asset pipeline reduces the number of requests the web browser makes for assets,
            but the browser still needs to parse and recompile the CSS and JavaScript for every
            page. Depending on the amount of CSS and JavaScript your application includes, this
            could take a significant amount of time.</p><p><span class="emphasis"><em>Turbolinks</em></span> is a Rails feature that speeds up the process of
            following links in your application by replacing the contents of the current
            page’s <code class="literal">body</code> and the <code class="literal">title</code> with the data for
            the new page instead of loading an entirely new page. With turbolinks, CSS and
            JavaScript files are not even downloaded when a link is clicked.</p><div class="sect3" title="Turbolinks in Action"><div class="titlepage"><div><div><h3 class="title"><a id="turbolinks_in_action"/>Turbolinks in Action</h3></div></div></div><p>Turbolinks is on by default in new Rails applications. You’ve been using it
              without even knowing since you built your first application in <a class="xref" href="ch02.html" title="Chapter 2. Rails Fundamentals">Chapter 2</a>. You can see it working by watching the output from
              the Rails server. Go to <span class="emphasis"><em>http://localhost:3000/</em></span> in your browser
              and check the output in your terminal:</p><a id="pro_id00380"/><pre class="programlisting">Started GET "/" for 127.0.0.1 at ...
Processing by PostsController#index as HTML

--<span class="emphasis"><em>snip</em></span>--

Started GET "/assets/bootstrap.js?body=1" for 127.0.0.1 at ...

Started GET "/assets/application.js?body=1" for 127.0.0.1 at ...</pre><p>After the <code class="literal">GET</code> request for the posts index page, the browser
              fetches all of the CSS and JavaScript files needed by your application. Now click a
              link such as New Text Post on the index page and check the output again:</p><a id="pro_id00381"/><pre class="programlisting">Started GET "/text_posts/new" for 127.0.0.1 at ...
Processing by TextPostsController#new as HTML
  User Load (0.2ms) SELECT "users".* FROM "users"
    WHERE "users"."id" = ? LIMIT 1 [["id", 7]]
  Rendered text_posts/_form.html.erb (2.4ms)
  Rendered text_posts/new.html.erb within layouts/application (3.3ms)
Completed 200 OK in 38ms (Views: 36.5ms | ActiveRecord: 0.2ms)</pre><p><a class="indexterm" id="iddle1330"/><a class="indexterm" id="iddle1332"/><a class="indexterm" id="iddle1445"/><a class="indexterm" id="iddle1765"/><a class="indexterm" id="iddle1914"/><a class="indexterm" id="iddle2069"/><a class="indexterm" id="iddle2186"/>The browser only makes a <code class="literal">GET</code> request for the New Text
              Post page. It does not fetch the CSS and JavaScript files because they are already
              loaded in memory. Finally, click the Back button in your browser.</p><p>This time there is no output in the terminal window. The index page was cached in
              the browser and no requests were sent to the server. Turbolinks caches ten pages by
              default.</p></div><div class="sect3" title="JavaScript Events"><div class="titlepage"><div><div><h3 class="title"><a id="javascript_events"/>JavaScript Events</h3></div></div></div><p>If your application includes JavaScript code that uses jQuery’s
                <code class="literal">ready</code> function to attach event handlers or trigger other code,
              the JavaScript needs to be modified to work with turbolinks. Because turbolinks
              doesn’t reload the entire page when a link is clicked, the
                <code class="literal">ready</code> function is not called.</p><p>Instead, the <code class="literal">page:load</code> event is fired at the end of the loading
              process. You can see this in action by adding the following CoffeeScript code to
                <span class="emphasis"><em>app/assets/javascripts/posts.js.coffee</em></span>:</p><a id="pro_id00382"/><pre class="programlisting">  --<span class="emphasis"><em>snip</em></span>--

  <span class="strong"><strong>$(document).ready -&gt;</strong></span>
➊   <span class="strong"><strong>console.log 'Document Ready'</strong></span>

  <span class="strong"><strong>$(document).on 'page:load', -&gt;</strong></span>
➋   <span class="strong"><strong>console.log 'Page Load'</strong></span></pre><p>Unfortunately, CoffeeScript is beyond the scope of this book, but you might
              recognize what this code snippet does if you’re already familiar with
              JavaScript. It prints “Document Ready” ➊ in your browser’s
              JavaScript console when the page first loads, and “Page Load” ➋
              when you click a link that uses turbolinks.</p><p>Because you aren’t currently using <code class="literal">$(document).ready()</code> to
              trigger any JavaScript code, you don’t need to worry about this right now. But
              you should revisit this section if you ever start using the <code class="literal">ready</code>
              function.</p></div></div></div><div class="sect1" title="Code Optimizations"><div class="titlepage"><div><div><h1 class="title"><a id="code_optimizations"/>Code Optimizations</h1></div></div></div><p>Now that you’ve seen a few of the built-in optimizations provided by Rails,
          let’s look at extra things you can do to improve performance. I’ll cover some
          techniques you can use to reduce the number of database queries your application makes and
          improve the performance of slow queries.</p><div class="sect2" title="Reducing Database Queries"><div class="titlepage"><div><div><h2 class="title"><a id="reducing_database_queries"/>Reducing Database Queries</h2></div></div></div><p>Rails models make accessing data so easy that you might forget you’re actually
            querying a database. Luckily, the Rails server shows SQL statements in the terminal.
            Look at this output as you navigate your application to spot possible
            inefficiencies.</p><div class="sect3" title="Examining SQL Output"><div class="titlepage"><div><div><h3 class="title"><a id="examining_sql_output"/>Examining SQL Output</h3></div></div></div><p><a class="indexterm" id="iddle1400"/><a class="indexterm" id="iddle1937"/><a class="indexterm" id="iddle2184"/>Make sure your server is running, and keep an eye on your terminal output
              as I walk you through a few examples. Be sure you are logged out of the application
              before you start. First, browse to the login page at
                <span class="emphasis"><em>http://localhost:3000/login</em></span> and check the server output:</p><a id="pro_id00383"/><pre class="programlisting">Started GET "/login" for 127.0.0.1 at 2014-03-18 18:58:39 -0500
Processing by SessionsController#new as HTML
  Rendered sessions/new.html.erb within layouts/application (2.0ms)
Completed 200 OK in 12ms (Views: 11.8ms | ActiveRecord: 0.0ms)</pre><p>This page doesn’t produce any SQL queries.</p><p>Now log in to the application:</p><a id="pro_id00384"/><pre class="programlisting">  Started POST "/sessions" for 127.0.0.1 at 2014-03-18 18:59:01 -0500
  Processing by SessionsController#create as HTML
    Parameters: ...
➊   User Load (0.2ms) SELECT "users".* FROM "users"
      WHERE "users"."email" = 'alice@example.com' LIMIT 1
  Redirected to http://localhost:3000/
  Completed 302 Found in 70ms (ActiveRecord: 0.2ms)</pre><p>This page produces one SQL query ➊ as Rails loads the user matching the
              email address you entered on the previous page. The <code class="literal">create</code> method
              in <code class="literal">SessionsController</code> uses this record to authenticate the password
              you entered.</p><p>After you log in to the application, you should be redirected to the posts index
              page. Your server output for that page should look something like this:</p><a id="pro_id00385"/><pre class="programlisting">  Started GET "/" for 127.0.0.1 at 2014-03-18 18:59:02 -0500
  Processing by PostsController#index as HTML
➊   User Load (0.1ms) SELECT "users".* FROM "users"
      WHERE "users"."id" = ? LIMIT 1 [["id", 1]]
➋    (0.1ms) SELECT "users".id FROM "users" INNER JOIN
      "subscriptions" ON "users"."id" = "subscriptions"."leader_id"
      WHERE "subscriptions"."follower_id" = ? [["follower_id", 1]]
➌   Post Load (0.2ms) SELECT "posts".* FROM "posts"
      WHERE "posts"."user_id" IN (2, 1)
      ORDER BY created_at DESC
➍   User Load (0.1ms) SELECT "users".* FROM "users"
      WHERE "users"."id" = ? LIMIT 1 [["id", 2]]
    User Load (0.1ms) SELECT "users".* FROM "users"
      WHERE "users"."id" = ? LIMIT 1 [["id", 1]]
    CACHE (0.0ms) SELECT "users".* FROM "users"
      WHERE "users"."id" = ? LIMIT 1 [["id", 1]]
    Rendered collection (2.7ms)
    Rendered posts/index.html.erb within layouts/application (3.8ms)
  Completed 200 OK in 13ms (Views: 11.0ms | ActiveRecord: 0.6ms)</pre><p><a class="indexterm" id="iddle1862"/><a class="indexterm" id="iddle2022"/>This page produces six queries. It first finds the user with id 1
              ➊; this query looks up the <code class="literal">current_user</code> inside the
                <code class="literal">authenticate_user!</code> call in <code class="literal">PostController.</code>
              Next, the page finds the ids ➋ of the users the current user is following in
              the call to <code class="literal">current_user.timeline_user_ids</code>. It then finds posts
              ➌ where the <code class="literal">user_id</code> matches the <code class="literal">id</code> of the
                <code class="literal">current_user</code> or one of his or her followers.</p><p>Finally, the page queries for a user ➍ matching an <code class="literal">id</code>
              with <code class="literal">SELECT "users".* FROM "users"</code> three times in a row. That looks
              a little strange to me. My index page has three posts, but there are three extra
              queries. Let’s look at the <code class="literal">index</code> action in
                <span class="emphasis"><em>app/controllers/posts_controller.rb</em></span> and see what’s
              happening:</p><a id="pro_id00386"/><pre class="programlisting">  class PostsController &lt; ApplicationController
➊   before_action :authenticate_user!

    def index
➋     user_ids = current_user.timeline_user_ids
➌     @posts = Post.where(user_id: user_ids)
                 .order("created_at DESC")
    end

  --<span class="emphasis"><em>snip</em></span>--</pre><p>This code calls authenticate_user! ➊ before each action. The index action
              finds the user_ids ➋ that current_user wants to see and then finds the posts
              ➌ matching those users. You’ve already accounted for those queries in the
              previous server output. Since the index action isn’t creating the three user
              queries, they must be coming from the view.</p><p>The <code class="literal">index</code> view renders the collection of posts. That means the
              source of these queries must be in the <code class="literal">TextPost</code> partial in
                <span class="emphasis"><em>app/views/text_posts/_text_post.html.erb</em></span>:</p><a id="pro_id00387"/><pre class="programlisting">  --<span class="emphasis"><em>snip</em></span>-
    &lt;div class="panel-body"&gt;
➊     &lt;p&gt;&lt;em&gt;By &lt;%= text_post.user.name %&gt;&lt;/em&gt;&lt;/p&gt;
--<span class="emphasis"><em>snip</em></span>--</pre><p>Here’s the problem. The name ➊ of the user who created each post is
              displayed by calling text_post.user.name. If you check the ImagePost partial, you can
              verify it does the same thing. For every post displayed, an extra query is generated,
              which explains the three extra queries you saw in the SQL output.</p></div><div class="sect3" title="N + 1 Queries"><div class="titlepage"><div><div><h3 class="title"><a id="n_plus_1_queries"/>N + 1 Queries</h3></div></div></div><p>Code that creates an extra database query for each record in a collection falls
              into a category of problems called <span class="emphasis"><em>N + 1 Queries</em></span>. These problems
              are common in Rails applications, and they occur when associations on a collection are
              referenced without first loading the associated models.</p><p><a class="indexterm" id="iddle1193"/><a class="indexterm" id="iddle1520"/><a class="indexterm" id="iddle1925"/>In this case, I loaded a collection of posts into
                <code class="literal">@posts</code>. I then referenced the <code class="literal">name</code> for the
                <code class="literal">user</code> who created each post. Because I didn’t load all of
              those users in advance, Rails fetches them one at a time from the database as the page
              is rendered. These extra queries meant the three posts on the index page resulted in
              four queries. The number of queries is always one more than the number of items in the
              collection.</p><p>Luckily, this problem is easy to fix. In Rails, you can specify in advance all
              associations that are going to be needed with the <code class="literal">includes</code> method.
              This technique is called <span class="emphasis"><em>eager loading</em></span>.</p><p>Let’s update the <code class="literal">index</code> action in
                <code class="literal">PostsController</code> to use eager loading now:</p><a id="pro_id00388"/><pre class="programlisting">  --<span class="emphasis"><em>snip</em></span>--
    def index
      user_ids = current_user.timeline_user_ids
➊     @posts = Post<span class="strong"><strong>.includes(:user)</strong></span>.where(user_id: user_ids)
                 .order("created_at DESC")
    end
  --<span class="emphasis"><em>snip</em></span>--</pre><p>Here, I chain the includes(:user) method ➊ to the query that sets @posts.
              The symbol passed to includes must match the name of an association on the model. In
              this case, post belongs_to :user.</p><p>With the <code class="literal">includes</code> method, Rails ensures that the specified
              associations are loaded using the minimum number of queries. After you save this file,
              refresh the index page in your browser and check the SQL output in your
              terminal:</p><a id="pro_id00389"/><pre class="programlisting">  --<span class="emphasis"><em>snip</em></span>--
    Post Load (0.3ms) SELECT "posts".* FROM "posts"
      WHERE "posts"."user_id" IN (2, 1) ORDER BY created_at DESC
➊   User Load (0.3ms) SELECT "users".* FROM "users"
      WHERE "users"."id" IN (2, 1)
  --<span class="emphasis"><em>snip</em></span>--</pre><p>The three queries to find each user have been replaced with ➊ a single
              query that finds all users at once.</p><p>Watch out for extra queries as you build applications. Look for calls like
                <code class="literal">text_post.user.name</code> in the view. Notice the two dots in that
              call. The two dots mean you’re accessing data in an associated model, which can
              introduce an N + 1 Queries problem, so you should preload the association before the
              view is rendered.</p></div></div><div class="sect2" title="Pagination"><div class="titlepage"><div><div><h2 class="title"><a id="pagination"/>Pagination</h2></div></div></div><p>You’ve reduced the number of database queries needed to load posts for the
            index page, but think about what happens when you have thousands of posts. The index
            page tries to show them all, increasing your application’s load time by a lot. You
            can use <span class="emphasis"><em>pagination</em></span>, the process of splitting a collection of
            records into multiple pages, to alleviate this problem.</p><p><a class="indexterm" id="iddle1092"/><a class="indexterm" id="iddle1147"/><a class="indexterm" id="iddle1618"/><a class="indexterm" id="iddle1924"/><a class="indexterm" id="iddle2337"/>The will_paginate gem can do all the pagination for you. First, add
              <code class="literal">will_paginate</code> to your application’s
              <span class="emphasis"><em>Gemfile</em></span>:</p><a id="pro_id00390"/><pre class="programlisting">--<span class="emphasis"><em>snip</em></span>--

gem 'bootstrap-sass'

<span class="strong"><strong>gem 'will_paginate'</strong></span>

--<span class="emphasis"><em>snip</em></span>--</pre><p>Remember to always update installed gems after changing the
              <span class="emphasis"><em>Gemfile</em></span>:</p><a id="pro_id00391"/><pre class="programlisting">$ <span class="strong"><strong>bin/bundle install</strong></span></pre><p>Next, update the <code class="literal">index</code> action in
              <span class="emphasis"><em>app/controllers/posts_controller.rb</em></span> to add a call to the
              <code class="literal">paginate</code> method:</p><a id="pro_id00392"/><pre class="programlisting">  --<span class="emphasis"><em>snip</em></span>--
    def index
      user_ids = current_user.timeline_user_ids
      @posts = Post.includes(:user).where(user_id: user_ids)
➊                <span class="strong"><strong>.paginate(page: params[:page], per_page: 5)</strong></span>
                 .order("created_at DESC")
    end
  --<span class="emphasis"><em>snip</em></span>--</pre><p>The <code class="literal">paginate</code> method is chained with the other methods that set
            the instance variable <code class="literal">@posts</code> ➊. The will_paginate gem adds
              <code class="literal">params[:page]</code> automatically. I specified <code class="literal">per_page:
              5</code> so you can see the pagination working with only 6 posts in your database.
            The default is 30 records per page.</p><p>The <code class="literal">paginate</code> method adds the correct <code class="literal">limit</code> and
              <code class="literal">offset</code> calls to the database query automatically so the minimum
            number of records are selected.</p><p>Finally, open the <code class="literal">index</code> view at
              <span class="emphasis"><em>app/views/posts/index.html.erb</em></span> and add a call to
              <code class="literal">will_paginate</code> at the end of the page:</p><a id="pro_id00393"/><pre class="programlisting">  --<span class="emphasis"><em>snip</em></span>--

➊ <span class="strong"><strong>&lt;%= will_paginate @posts %&gt;</strong></span></pre><p>The <code class="literal">will_paginate</code> view helper ➊ accepts a collection of
            records, in this case <code class="literal">@posts</code>, and renders the correct links to
            navigate through the pages of this collection.</p><p>To see this working, you need to restart your Rails server since you added a new
            gem. Then create new posts until you have at least six, and browse to a user page. If
            you click through to the second page, as in <a class="xref" href="ch12.html#pagination_links" title="Figure 12-1. Pagination links">Figure 12-1</a>, you
            should see the new links.</p><div class="figure"><a id="pagination_links"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00024"/><img alt="Pagination links" src="httpatomoreillycomsourcenostarchimages2169106.png.jpg"/></div></div><p class="title">Figure 12-1. Pagination links</p></div><p><a class="indexterm" id="iddle1281"/><a class="indexterm" id="iddle1283"/><a class="indexterm" id="iddle1595"/><a class="indexterm" id="iddle1813"/><a class="indexterm" id="iddle1923"/><a class="indexterm" id="iddle1948"/>The <code class="literal">will_paginate</code> view helper added links to
              <span class="emphasis"><em>Previous</em></span> and <span class="emphasis"><em>1</em></span>, which you can click to go
            back to the first page from the second.</p><p>Check the server output again to see the query used to retrieve posts from the
            database:</p><a id="pro_id00394"/><pre class="programlisting">  Started GET "/posts?page=2" for 127.0.0.1 at 2014-03-26 11:52:27 -0500
  Processing by PostsController#index as HTML
    Parameters: {"page"=&gt;"2"}
  --<span class="emphasis"><em>snip</em></span>--
➊   Post Load (0.4ms) SELECT "posts".* FROM "posts"
      WHERE "posts"."user_id" IN (2, 1)
      ORDER BY created_at DESC LIMIT 5 OFFSET 5
  --<span class="emphasis"><em>snip</em></span>--</pre><p>The query for page two ➊ now includes <code class="literal">LIMIT 5 OFFSET 5</code> as
            expected. This query only fetches posts that are needed to render the page.</p></div></div><div class="sect1" title="Caching"><div class="titlepage"><div><div><h1 class="title"><a id="caching"/>Caching</h1></div></div></div><p>In programming, <span class="emphasis"><em>caching</em></span> is the process of storing frequently used
          data so additional requests for the same data will be faster. Rails calls the place where
          data is stored a <span class="emphasis"><em>cache store</em></span>. Rails applications commonly use two
          types of caching.</p><p><span class="emphasis"><em>Low-level caching</em></span> stores the result of time-consuming
          calculations in the cache—useful for values that are frequently read, but rarely
          change. <span class="emphasis"><em>Fragment caching</em></span> stores parts of a view in the cache to speed
          up page rendering. Rendering a large collection of models can be time consuming. If the
          data rarely changes, fragment caching can increase your application’s page load
          speed.</p><p><a class="indexterm" id="iddle1042"/><a class="indexterm" id="iddle1043"/><a class="indexterm" id="iddle1282"/><a class="indexterm" id="iddle1284"/><a class="indexterm" id="iddle1357"/><a class="indexterm" id="iddle1363"/><a class="indexterm" id="iddle1826"/>Caching is disabled, by default, in the development environment, so before you
          can start learning about it, you need to enable it. Leaving the cache disabled in
          development is a good idea because you always want to work with the latest version of data
          while in development. For example, if you store a value in the cache, then change the code
          that calculates that value, your application could return the cached value instead of the
          value calculated by the new code.</p><p>You’ll enable caching in development for this chapter, so you can see how it
          works and learn about the types of caching used in Rails applications. Open
            <span class="emphasis"><em>config/environments/development.rb</em></span> and change the value of
            <code class="literal">config.action_controller.perform_caching</code> to
          <code class="literal">true</code>:</p><a id="pro_id00395"/><pre class="programlisting">Social::Application.configure do
  --<span class="emphasis"><em>snip</em></span>--

  # Show full error reports and disable caching.
  config.consider_all_requests_local       = true
  config.action_controller.perform_caching = <span class="strong"><strong>true</strong></span>

  --<span class="emphasis"><em>snip</em></span>--
end</pre><p>Once you’re finished with this chapter, change this value back to
            <code class="literal">false</code> to disable caching in the development environment.</p><p>Rails supports several different cache stores. The default, <code class="literal">ActiveSupport::
            Cache::FileStore</code>, stores cached data on the filesystem. A popular choice for
          production applications is <code class="literal">ActiveSupport::Cache::MemCacheStore</code>, which
          uses the memcached server to store data. The memcached server is a high-performance cache
          store that supports distributed caching across several computers.</p><p>Now that you’ve enabled caching, let’s specify a cache store for your
          application to use. Rather than install memcached on your computer, you can use the
            <code class="literal">ActiveSupport::Cache::MemoryStore</code> to demonstrate caching. This option
          also stores cached objects in your computer’s memory, but doesn’t require the
          installation of additional software. Add this line to
            <span class="emphasis"><em>config/environments/development.rb</em></span> under the line you just
          changed:</p><a id="pro_id00396"/><pre class="programlisting">Social::Application.configure do
  --<span class="emphasis"><em>snip</em></span>--

  # Show full error reports and disable caching.
  config.consider_all_requests_local       = true
  config.action_controller.perform_caching = true
  <span class="strong"><strong>config.cache_store = :memory_store</strong></span>

  --<span class="emphasis"><em>snip</em></span>--
end</pre><p>Storing the cache in memory is faster than storing it on disk. The memory store
          allocates 32MB of memory, by default. When the amount <a class="indexterm" id="iddle1035"/><a class="indexterm" id="iddle1158"/><a class="indexterm" id="iddle1276"/><a class="indexterm" id="iddle1279"/><a class="indexterm" id="iddle1287"/><a class="indexterm" id="iddle1561"/><a class="indexterm" id="iddle1814"/><a class="indexterm" id="iddle2042"/>of cached data exceeds this amount, the memory store runs a cleanup process
          that removes the least recently used objects, so you never need to worry about manually
          removing objects from the cache.</p><p>Restart the Rails server for these changes to take effect.</p><div class="sect2" title="Cache Keys"><div class="titlepage"><div><div><h2 class="title"><a id="cache_keys"/>Cache Keys</h2></div></div></div><p>Everything in the cache is referenced by cache key. A <span class="emphasis"><em>cache key</em></span>
            is a unique string that identifies a particular object or other piece of data.</p><p>Active Record models include the <code class="literal">cache_key</code> method for generating
            a key automatically. You can try it in the Rails console by calling
              <code class="literal">cache_key</code> on an instance of a model:</p><a id="pro_id00397"/><pre class="programlisting">  2.1.0 :001 &gt; <span class="strong"><strong>post = Post.first</strong></span>
    Post Load (0.2ms) SELECT "posts".* ...
   =&gt; #&lt;TextPost id: 1, title: ...&gt;
  2.1.0 :002 &gt; <span class="strong"><strong>post.cache_key</strong></span>
➊  =&gt; "text_posts/1-20140317221533035072000"</pre><p>The cache key for this post is the pluralized version of the class name, followed by
            a slash, then the post <code class="literal">id</code>, a dash, and finally the
              <code class="literal">updated_at</code> date as a string ➊.</p><p>Using the <code class="literal">updated_at</code> date as part of the key solves the cache
            invalidation problem. When the post is modified, the <code class="literal">updated_at</code> date
            changes, so its <code class="literal">cache_key</code> also changes. This way you don’t have
            to worry about getting out of date data from the cache.</p></div><div class="sect2" title="Low-Level Caching"><div class="titlepage"><div><div><h2 class="title"><a id="low-level_caching"/>Low-Level Caching</h2></div></div></div><p>Low-level caching is useful when you need to perform a time-consuming calculation or
            database operation. It is frequently used with API requests that might take a while to
            return. Low-level caching in Rails uses the <code class="literal">Rails.cache.fetch</code>
            method.</p><p>The <code class="literal">fetch</code> method takes a cache key and attempts to read a
            matching value from the cache. The <code class="literal">fetch</code> method also takes a block.
            When given a block of Ruby code, if the value is not already in the cache, the method
            evaluates the block, writes the result to the cache, and returns the result.</p><p>To demonstrate low-level caching, let’s show the number of comments for each
            post on the index page. To do this, first edit
              <span class="emphasis"><em>app/views/text_posts/_text_post.html.erb</em></span> and add the comment
            count below the <code class="literal">text_post.body</code>:</p><a id="pro_id00398"/><pre class="programlisting">--<span class="emphasis"><em>snip</em></span>--

    &lt;p&gt;&lt;%= sanitize text_post.body %&gt;&lt;/p&gt;

    <span class="strong"><strong>&lt;p&gt;&lt;%= pluralize text_post.comments.count, "Comment" %&gt;&lt;/p&gt;</strong></span>

--<span class="emphasis"><em>snip</em></span>--</pre><p><a class="indexterm" id="iddle1130"/><a class="indexterm" id="iddle1275"/><a class="indexterm" id="iddle1958"/><a class="indexterm" id="iddle2043"/>This new line of code uses the <code class="literal">pluralize</code> helper method to
            pluralize the word “Comment” correctly based on the number of comments. For
            example, if the post has no comments, it prints “0 Comments”. Make a similar
            change to <span class="emphasis"><em>app/views/image_posts/_image_post.html.erb</em></span>, replacing
              <code class="literal">text_post</code> with <code class="literal">image_post</code>.</p><p>Now refresh the posts index page in your browser and look at the server
            output:</p><a id="pro_id00399"/><pre class="programlisting">  Started GET "/posts" for 127.0.0.1 at 2014-03-26 15:15:05 -0500
  Processing by PostsController#index as HTML
  --<span class="emphasis"><em>snip</em></span>--
➊    (0.1ms) SELECT COUNT(*) FROM "comments"
        WHERE "comments"."post_id" = ? [["post_id", 6]]
     (0.1ms) SELECT COUNT(*) FROM "comments"
        WHERE "comments"."post_id" = ? [["post_id", 5]]
     (0.1ms) SELECT COUNT(*) FROM "comments"
        WHERE "comments"."post_id" = ? [["post_id", 4]]
     (0.1ms) SELECT COUNT(*) FROM "comments"
        WHERE "comments"."post_id" = ? [["post_id", 3]]
     (0.1ms) SELECT COUNT(*) FROM "comments"
        WHERE "comments"."post_id" = ? [["post_id", 2]]
  Rendered collection (5.4ms)
  Rendered posts/index.html.erb within layouts/application (10.1ms)
Completed 200 OK in 22ms (Views: 16.8ms | ActiveRecord: 1.5ms)</pre><p>This change adds five new queries ➊ to count the number of comments for each
            post. Those extra queries take up valuable loading time, but you can improve performance
            by getting rid of them. One way to remove such queries is by caching the values you need
            (in this case, the number of comments per post) using
              <code class="literal">Rails.cache.fetch</code>.</p><p>You can perform the caching by adding a method to the <code class="literal">Post</code> model.
            Edit <span class="emphasis"><em>app/models/post.rb</em></span> and add the
              <code class="literal">cached_comment_count</code> method, as shown here:</p><a id="pro_id00400"/><pre class="programlisting">  class Post &lt; ActiveRecord::Base
    --<span class="emphasis"><em>snip</em></span>--

    <span class="strong"><strong>def cached_comment_count</strong></span>
➊     <span class="strong"><strong>Rails.cache.fetch [self, "comment_count"] do</strong></span>
        <span class="strong"><strong>comments.size</strong></span>
      <span class="strong"><strong>end</strong></span>
    <span class="strong"><strong>end</strong></span>
  end</pre><p>This method passes the array <code class="literal">[self, "comment_count"]</code> ➊ to
            the <code class="literal">Rails.cache.fetch</code> method. Here, <code class="literal">self</code>
            represents the current post. The <code class="literal">fetch</code> method combines these values
            into a single cache key. The block still calls <code class="literal">comments.size</code> as
            before.</p><p><a class="indexterm" id="iddle1113"/><a class="indexterm" id="iddle1195"/><a class="indexterm" id="iddle1277"/><a class="indexterm" id="iddle1285"/><a class="indexterm" id="iddle1596"/><a class="indexterm" id="iddle1982"/><a class="indexterm" id="iddle2047"/><a class="indexterm" id="iddle2264"/><a class="indexterm" id="iddle2321"/>Now update the <code class="literal">TextPost</code> and <code class="literal">ImagePost</code>
            views to use this new method:</p><a id="pro_id00401"/><pre class="programlisting">--<span class="emphasis"><em>snip</em></span>--

    &lt;p&gt;&lt;%= pluralize <span class="strong"><strong>text_post.cached_comment_count</strong></span>, "Comment" %&gt;&lt;/p&gt;

--<span class="emphasis"><em>snip</em></span>--</pre><p>When you refresh the index page in your browser, the six comment count queries are
            executed one more time and the values are cached. Refresh the page again, watch the
            server output, and note the queries are no longer executed.</p><p>This caching solution has one small problem. The Rails <code class="literal">cache_key</code>
            method uses the post <code class="literal">id</code> and <code class="literal">updated_at</code> date to
            create the cache key, but adding a comment to a post does not change the post
              <code class="literal">updated_at</code> date. What you need is a way to update the post when a
            comment is added.</p><p>Rails provides the <code class="literal">touch</code> option to associations just for this
            purpose. When you specify <code class="literal">touch: true</code> on an association, Rails
            automatically sets the <code class="literal">updated_at</code> value of the parent model to the
            current time when any part of the association changes. This happens when a model is
            added or removed from the association or when one of the associated models is
            changed.</p><p>Open <span class="emphasis"><em>app/models/comment.rb</em></span> and add <code class="literal">touch:
              true</code> to the <code class="literal">belongs_to</code> association, as shown here:</p><a id="pro_id00402"/><pre class="programlisting">class Comment &lt; ActiveRecord::Base
  belongs_to :post<span class="strong"><strong>, touch: true</strong></span>
  belongs_to :user

  validates :user_id, presence: true
end</pre><p>Now the <code class="literal">updated_at</code> value on the post changes whenever one of its
            comments is updated or deleted or when a new comment is created for it. If you add a
            comment to a post, then reload the index page, the comment count query is executed for
            this post again and the new count is cached.</p><div class="note" title="Note"><h3 class="title"><a id="ch12note01"/>Note</h3><p><span class="emphasis"><em>You can also solve this problem using a Rails counter cache. With a
                counter cache, Rails keeps track of the number of comments associated with each post
                automatically. Enable this feature by adding a column named
                  <code class="literal">comments_count</code> to the <code class="literal">Post</code> model and adding
                  <code class="literal">counter_cache: true</code> to the <code class="literal">belongs_to :post</code>
                declaration inside the <code class="literal">Comment</code> model.</em></span></p></div></div><div class="sect2" title="Fragment Caching"><div class="titlepage"><div><div><h2 class="title"><a id="fragment_caching"/>Fragment Caching</h2></div></div></div><p>Besides low-level caching of values, you can also use a Rails feature called
              <span class="emphasis"><em>fragment caching</em></span> to cache parts of a view. Caching the view
            decreases your application’s page load time by storing the rendered view data in
            the cache. Fragment caching is usually done inside a partial.</p><p><a class="indexterm" id="iddle1278"/><a class="indexterm" id="iddle2170"/>To demonstrate fragment caching effectively, I need a slow page. Using a
            slow page makes the impact of fragment caching obvious. Let’s use the Ruby
              <code class="literal">sleep</code> method to render posts more slowly. Obviously, you would
            never do this in a real application—this is only for demonstration.</p><p>Open the <span class="emphasis"><em>app/views/text_posts/_text_post.html.erb</em></span> partial and
            add the call to <code class="literal">sleep</code> on the first line as shown here:</p><a id="pro_id00403"/><pre class="programlisting">➊  <span class="strong"><strong>&lt;% sleep 1 %&gt;</strong></span>
   &lt;div class="panel panel-default"&gt;
     --<span class="emphasis"><em>snip</em></span>--
&lt;/div&gt;</pre><p>This call to <code class="literal">sleep</code> ➊ tells Ruby to pause for 1 second.
            Make the same change to the <code class="literal">ImagePost</code> partial at
              <span class="emphasis"><em>app/views/image_posts/_image_post.html.erb</em></span>.</p><p>Now when you refresh the index page, it should take much longer to display. Check
            the server output for the exact time:</p><a id="pro_id00404"/><pre class="programlisting">  Started GET "/posts" for 127.0.0.1 at 2014-03-26 16:03:32 -0500
  Processing by PostsController#index as HTML
    --<span class="emphasis"><em>snip</em></span>--
➊   Rendered collection (5136.5ms)
    Rendered posts/index.html.erb within layouts/application (5191.6ms)
  Completed 200 OK in 5362ms (Views: 5263.1ms | ActiveRecord: 11.8ms)</pre><p>Rendering those five posts took more than five seconds ➊, which makes sense
            with those five <code class="literal">sleep</code> calls.</p><p>Now let’s add fragment caching to the partials. Edit
              <span class="emphasis"><em>app/views/text_posts/_text_post.html.erb</em></span> again and add the
              <code class="literal">cache</code> method call and block, as shown here:</p><a id="pro_id00405"/><pre class="programlisting">➊  <span class="strong"><strong>&lt;% cache text_post do %&gt;</strong></span>
     &lt;% sleep 1 %&gt;
     &lt;div class="panel panel-default"&gt;
       --<span class="emphasis"><em>snip</em></span>--
     &lt;/div&gt;
    <span class="strong"><strong>&lt;% end %&gt;</strong></span></pre><p>The <code class="literal">cache</code> method ➊ calls <code class="literal">cache_key</code> on
            the <code class="literal">text_post</code> automatically. I also indented all of the code inside
            the block. Make the same change to the <code class="literal">ImagePost</code> partial.</p><p>Now when you refresh the page in your browser, you should see some new output from
            the Rails server:</p><a id="pro_id00406"/><pre class="programlisting">  Started GET "/posts" for 127.0.0.1 at 2014-03-26 16:18:08 -0500
  Processing by PostsController#index as HTML
  --<span class="emphasis"><em>snip</em></span>--
➊ Cache digest for text_posts/_text_post.html: 3e...
➋ Read fragment views/text_posts/5-2014... (0.0ms)
➌ Write fragment views/text_posts/5-2014... (0.1ms)
  --<span class="emphasis"><em>snip</em></span>--
  Rendered collection (5021.2ms)
  Rendered posts/index.html.erb within layouts/application (5026.5ms)
Completed 200 OK in 5041ms (Views: 5035.8ms | ActiveRecord: 1.1ms)</pre><p><a class="indexterm" id="iddle1286"/><a class="indexterm" id="iddle1356"/><a class="indexterm" id="iddle1523"/><a class="indexterm" id="iddle2249"/>Rendering the index page now generates several lines of output about the
            cache. First, a digest is generated ➊ for the partial. This digest is the same
            every time this partial is rendered. Next, Rails reads the cache ➋ to see if this
            partial is already there. Finally, since the partial was not found in the cache, it is
            rendered and then written to the cache ➌.</p><p>Refreshing the page again should read all of the partials from the cache, rendering
            the page much more quickly. Check the server output to be sure:</p><a id="pro_id00407"/><pre class="programlisting">  Started GET "/posts" for 127.0.0.1 at 2014-03-26 16:29:13 -0500
  Processing by PostsController#index as HTML
  --<span class="emphasis"><em>snip</em></span>--
  Cache digest for text_posts/_text_post.html: 3e...
➊ Read fragment views/text_posts/22-2014... (0.1ms)
  --<span class="emphasis"><em>snip</em></span>--
➋   Rendered collection (25.9ms)
    Rendered posts/index.html.erb within layouts/application (31.5ms)
  Completed 200 OK in 77ms (Views: 73.1ms | ActiveRecord: 1.0ms)</pre><p>You only see cache reads ➊ now, and the collection renders very quickly
            ➋, in a fraction of the time it took after you added the <code class="literal">sleep</code>
            calls. Caching can obviously result in dramatic performance improvements.</p><p>You should remove the calls to <code class="literal">sleep</code> from the
              <code class="literal">TextPost</code> and <code class="literal">ImagePost</code> partials now, but leave
            the caching in place in the views.</p></div><div class="sect2" title="Issues"><div class="titlepage"><div><div><h2 class="title"><a id="issues"/>Issues</h2></div></div></div><p>Caching is a great way to make your application faster, but it can also cause some
            issues. Unless the cache key for a code block or view fragment includes a user id, then
            the same cached data is sent to every user.</p><p>For example, the <code class="literal">TextPost</code> and <code class="literal">ImagePost</code>
            partials both contain code that checks to see if the post belongs to the current user.
            If so, it displays a button linked to the <code class="literal">edit</code> action.</p><a id="pro_id00408"/><pre class="programlisting">  &lt;% cache text_post do %&gt;
    &lt;div class="panel panel-default"&gt;
      --<span class="emphasis"><em>snip</em></span>--
➊       &lt;% if text_post.user == current_user %&gt;
          &lt;p&gt;&lt;%= link_to 'Edit', edit_text_post_path(text_post),
                  class: "btn btn-default" %&gt;&lt;/p&gt;
        &lt;% end %&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;% end %&gt;</pre><p>The conditional statement in the <code class="literal">TextPost</code> partial at
              <span class="emphasis"><em>app/views/test_posts/_text_post.html.erb</em></span> shows the Edit button if
            the post belongs to <code class="literal">current_user</code> ➊. <a class="indexterm" id="iddle1131"/><a class="indexterm" id="iddle1364"/>The owner of a post is probably going to be the first user to view the post.
            After the owner views the post, the view fragment is cached with the Edit button. When
            another user views the same post, the fragment is read from the cache and the other user
            also sees the Edit button.</p><p>You can correct this issue in a couple of ways. You could include the user id in the
            cache key, but that would create a separate copy of the post in the cache for each user
            and remove the benefit of caching for many users. A simpler solution is to move the
            button outside the fragment being cached, as shown here:</p><a id="pro_id00409"/><pre class="programlisting">&lt;% cache text_post do %&gt;
  &lt;div class="panel panel-default"&gt;
    --<span class="emphasis"><em>snip</em></span>--
  &lt;/div&gt;
&lt;% end %&gt;

<span class="strong"><strong>&lt;% if text_post.user == current_user %&gt;</strong></span>
  <span class="strong"><strong>&lt;p&gt;&lt;%= link_to 'Edit', edit_text_post_path(text_post),</strong></span>
          <span class="strong"><strong>class: "btn btn-default" %&gt;&lt;/p&gt;</strong></span>
<span class="strong"><strong>&lt;% end %&gt;</strong></span></pre><p>Once the Edit button is moved outside the cache block, the conditional is evaluated
            for every user viewing the post and the Edit button is shown only if the current user is
            the owner of the post. Make the same change to the <code class="literal">ImagePost</code> partial
            at <span class="emphasis"><em>app/views/image_posts/_image_post.html.erb</em></span>.</p><p>Remember to edit <span class="emphasis"><em>config/environments/development.rb,</em></span> as shown
            at the beginning of this section, and disable caching in the development environment
            after you complete the exercises at the end of this chapter.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00027"/>Summary</h1></div></div></div><p>No one likes slow web applications! This chapter covered techniques for speeding up
          your application, from Rails built-in features like the asset pipeline and turbolinks to
          database query optimization, pagination, and caching. Now try the following exercises, and
          make your application even faster.</p><p>When you’ve completed the exercises, change
            <code class="literal">config.action_controller.perform_caching</code> back to
            <code class="literal">false</code> in <span class="emphasis"><em>config/environments/development.rb</em></span>.
          Leave caching turned off during development. Otherwise you’ll need to remember to
          clear the cache any time you make a change to a cached view partial.</p><p>The next chapter covers debugging strategies you can use to track elusive problems
          with your application. You’ll look through server output and logs for clues and
          finally dive into a running application to see exactly what’s happening.</p></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="exercises-id00028"/>Exercises</h1></div></div></div><div class="qandaset" title="Frequently Asked Questions"><a id="ch12qa1"/><table border="0" summary="Q and A Set" width="100%"><col align="left" width="1%"/><col/><tbody><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch12qa1qe1"/><a id="ch12qa1q1"/><p>Q:</p></td><td align="left" valign="top"><p>1. So far your performance optimizations have focused on the post index page.
                Open the show page for an individual post, such as
                  <span class="emphasis"><em>http://localhost:3000/posts/1</em></span>. Make sure the post has several
                comments and then examine the server output. Use eager loading in the
                  <code class="literal">PostsController</code> at
                  <span class="emphasis"><em>app/controllers/posts_controller.rb</em></span> to reduce the number of
                queries this page makes.</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch12qa1qe2"/><a id="ch12qa1q2"/><p>Q:</p></td><td align="left" valign="top"><p>2. The post show page renders a collection of comments. Add fragment caching to
                the <code class="literal">comment</code> partial at
                  <span class="emphasis"><em>app/views/comments/_comment.html.erb</em></span>. You only want the
                Destroy button to appear if <code class="literal">@can_moderate</code> is
                  <code class="literal">true</code>. In this case, include the value of
                  <code class="literal">@can_moderate</code> in the cache key by passing the array
                  <code class="literal">[comment, @can_moderate]</code> to the cache method.</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch12qa1qe3"/><a id="ch12qa1q3"/><p>Q:</p></td><td align="left" valign="top"><p>3. You can cache the entire comments collection by wrapping the <code class="literal">render
                  @post.comments</code> call in the show page in a <code class="literal">cache</code>
                block. Open the show page at <span class="emphasis"><em>app/views/posts/show.html.erb</em></span> and
                add the <code class="literal">cache</code> block. Pass the array <code class="literal">[@post, 'comments',
                  @can_moderate]</code> to the <code class="literal">cache</code> method, ensuring the
                Destroy button is only shown to users who can moderate comments as mentioned in
                Exercise 2. The technique of wrapping a cached collection inside another cache block
                is sometimes called <span class="emphasis"><em>Russian-Doll</em></span> caching because multiple
                cached fragments are nested inside each other. When an object is added to the
                collection, only the outer cache needs to be re-created. The cached data for the
                other objects can be reused and only the new object needs to be rendered.</p></td></tr></tbody></table></div></div></div></body></html>