<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch11">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_253" aria-label="253"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch11">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">11</span></span>&#13;
<span class="CT"><span class="Sans_Dogma_B">PERSISTENCE MONITOR</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="377" height="376"/></figure>&#13;
<p class="CO">While KnockKnock, covered in the previous chapter, provides a powerful detection capability, it doesn’t protect the system in real time. To complement it, I created BlockBlock, which monitors the most important persistence locations enumerated by KnockKnock, alerts the user whenever a new item appears, and gives them the ability to block the activity.</p>&#13;
<p class="TX">BlockBlock’s initial versions, written in 2014, were largely proofs of concept, which didn’t stop employees from commercial security companies from labeling the tool “lam[e]ware” and concluding that “providing quality service for nothing can’t be a one-person job.”<sup><a role="doc-noteref" id="chapter11_1" href="#chapter11-1">1</a></sup> Over the years, BlockBlock has matured, consistently proving its merit with a near 100 percent detection rate of persistent Mac malware, even without prior knowledge of these threats.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_254" aria-label="254"/>In this chapter, I’ll discuss BlockBlock’s design and show how it uses Endpoint Security to effectively detect unauthorized persistence events. You’ll learn how to request and apply the required Endpoint Security client entitlement and how XPC can allow tool components to securely communicate with one another. You can find BlockBlock’s source code in its entirety in the Objective-See GitHub repository at <a href="https://github.com/objective-see/BlockBlock"><i>https://<wbr/>github<wbr/>.com<wbr/>/objective<wbr/>-see<wbr/>/BlockBlock</i></a>.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-64"/><span class="SANS_Futura_Std_Bold_B_11">Entitlements</span></h3>&#13;
<p class="TNI">Multiple BlockBlock components leverage Endpoint Security, which means the tool must receive a privileged entitlement from Apple. Without the entitlement, attempts to create an Endpoint Security client at runtime will fail unless we’ve disabled System Integrity Protection (SIP) and Apple Mobile File Integrity (AMFI). So, let’s start by walking through the process of requesting the Endpoint Security client entitlement from Apple and, once it’s granted, applying it to BlockBlock.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-79"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Applying for Endpoint Security Entitlements</span></h4>&#13;
<p class="TNI">You can apply for Endpoint Security entitlements at <a href="https://developer.apple.com/contact/request/system-extension/"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/contact<wbr/>/request<wbr/>/system<wbr/>-extension<wbr/>/</i></a>. The request form asks for developer information, such as your name and company, then presents a drop-down menu containing a list of entitlements you can request. Select the Endpoint Security client entitlement, <b>com.apple.developer.endpoint-security.client</b>. At the bottom of the form, describe how you intend to use the entitlement you’re requesting.</p>&#13;
<p class="TX">Given the power of Endpoint Security, Apple is understandably cautious about granting requests for the client entitlement, even to renowned security companies. That said, you can take several measures to improve your chances of receiving one. First, register as a company, such as an LLC or equivalent. I’m aware of only one instance in which Apple granted the Endpoint Security client entitlement to an individual. Second, in your request, make sure to describe exactly what you plan to do with the entitlement. The Endpoint Security client entitlement is designed for security tools, so include details of the tool you’re developing and articulate exactly why it needs the use of Endpoint Security. Finally, be prepared to wait.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-80"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Registering App IDs</span></h4>&#13;
<p class="TNI">Once Apple has granted you the entitlement, you must register an App ID for your tool, specifying its bundle ID and the entitlements it will use. Log in to your Apple Developer account, click <b>Account</b>, then navigate to <b>Certificates, Identifiers &amp; Profiles</b><span class="MenuArrow"></span><b>Identifiers</b>. If you have any existing identifiers, they should show up here. To create a new identifier, click <b>+</b>. Select <b>App IDs</b>, then click <b>Continue</b>. Select <b>App</b> and <b>Continue</b> again.</p>&#13;
<p class="TX">This should bring you to the App ID registration form. Most of the fields are self-explanatory. For the Bundle ID, Apple recommends using a reverse-domain name style, generally in the form <i>com.company.product</i>. For BlockBlock, I populated the fields as shown in <a href="chapter11.xhtml#fig11-1">Figure 11-1</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_255" aria-label="255"/>&#13;
<figure class="IMG"><img class="img7" id="fig11-1" src="../images/Figure11-1.jpg" alt="" width="1143" height="481"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-1: Registering the BlockBlock app ID</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In the remainder of the form, you’ll see options to specify either capabilities, app services, or additional capabilities for your tool. Assuming Apple has granted you the Endpoint Security client entitlement, click <b>Additional Capabilities</b>, then select the checkbox next to Endpoint Security. To register the new identifier, click <b>Register</b>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-81"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating Provisioning Profiles</span></h4>&#13;
<p class="TNI">Now you can create the provisioning profile, which provides the mechanism that the operating system will use to authorize the use of the entitlement at runtime.<sup><a role="doc-noteref" id="chapter11_2" href="#chapter11-2">2</a></sup> Clicking <b>Profiles</b> in your Developer Account should take you to a page containing all of your current profiles. You can also register a new profile by clicking +. On the first page, specify the provisioning profile’s type. Unless you’ll be distributing your tool via the Mac App Store, select <b>Developer ID</b> at the very bottom of the page. Click <b>Continue</b>, then select the App ID you just created.</p>&#13;
<p class="TX">Next, select the certificate to include in your profile. This is the same certificate you’ll use to sign your application, likely your Apple Developer certificate. On the next page, you’ll be given a list of available entitlements you can add to the provisioning profile. To leverage Endpoint Security, select <b>System Extension EndpointSecurity for macOS</b>. If Apple hasn’t yet granted you this entitlement, it won’t show up in the list.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-82"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Enabling Entitlements in Xcode</span></h4>&#13;
<p class="TNI">Once you’ve generated the provisioning profile, you can head to Xcode to add it to your project. First, tell Xcode that your project will use Endpoint Security by clicking the small <b>+</b> next to <b>Capabilities</b> in the Signing &amp; Capabilities pane and then selecting <b>Endpoint Security</b> capability. Behind the scenes, this will add the entitlement to the project’s entitlement file.</p>&#13;
<p class="TX">Now, when building the tool for deployment, you can select the provisioning profile. The first time you do this, you might have to download and import the profile into Xcode. Download the profile you generated from your Apple Developer account. Then, in Xcode’s Select Certificate and Developer ID Profiles window, select the <b>Import Profile</b> option, found in the drop-down menu next to the application’s name, and browse to the downloaded profile.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_256" aria-label="256"/>If all goes well, you should have a compiled, entitled tool that also contains the provisioning profile. For example, BlockBlock’s provisioning profile is embedded in its app bundle at the standard location, <i>Contents/embedded.provisionprofile</i>. You can dump any embedded provisioning profile by running the macOS <span class="SANS_TheSansMonoCd_W5Regular_11">security</span> tool, along with the command line flags <span class="SANS_TheSansMonoCd_W5Regular_11">cms -D -i</span> and this path. The following output contains BlockBlock’s App ID, information about its code signing certificate, and the entitlements it is authorized to use:</p>&#13;
&#13;
<pre><code>% <b>security cms -D -i BlockBlock.app/Contents/embedded.provisionprofile</b>&#13;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&#13;
...&#13;
&lt;plist version="1.0"&gt;&#13;
&lt;dict&gt;&#13;
    &lt;key&gt;AppIDName&lt;/key&gt;&#13;
    &lt;string&gt;BlockBlock&lt;/string&gt;&#13;
    &lt;key&gt;DeveloperCertificates&lt;/key&gt;&#13;
    &lt;array&gt;&#13;
        &lt;data&gt; ... &lt;/data&gt;&#13;
    &lt;/array&gt;&#13;
    &lt;key&gt;Entitlements&lt;/key&gt;&#13;
    &lt;dict&gt;&#13;
        &lt;key&gt;com.apple.developer.endpoint-security.client&lt;/key&gt;&#13;
        &lt;true/&gt;&#13;
        &lt;key&gt;com.apple.application-identifier&lt;/key&gt;&#13;
        &lt;string&gt;VBG97UB4TA.com.objective-see.blockblock&lt;/string&gt;&#13;
        ...&#13;
    &lt;/dict&gt;&#13;
    ...&#13;
</code></pre>&#13;
<p class="TX">You can use the <span class="SANS_TheSansMonoCd_W5Regular_11">codesign</span> utility to view any entitlements a program possesses. For BlockBlock, this list includes the Endpoint Security client entitlement:</p>&#13;
&#13;
<pre><code>% <b>codesign -d --entitlements - BlockBlock.app</b>&#13;
Executable=BlockBlock.app/Contents/MacOS/BlockBlock&#13;
[Dict]&#13;
    [Key] com.apple.application-identifier&#13;
    [Value]&#13;
        [String] VBG97UB4TA.com.objective-see.blockblock&#13;
    [Key] <b>com.apple.developer.endpoint-security.client</b>&#13;
    [Value]&#13;
        [Bool] true&#13;
    ...&#13;
</code></pre>&#13;
<p class="TX">Because macOS requires a provisioning profile to authorize the entitlement, even programs not typically developed as applications, such as daemons, must be packaged as application bundles to leverage Endpoint Security. You can read more about this design choice in Apple’s documentation,<sup><a role="doc-noteref" id="chapter11_3" href="#chapter11-3">3</a></sup> which also notes that if you switch from a daemon to a system extension, Xcode will automatically handle the packaging for you.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_257" aria-label="257"/>&#13;
<h3 class="H1" id="sec6"><span id="h1-65"/><span class="SANS_Futura_Std_Bold_B_11">Tool Design</span></h3>&#13;
<p class="TNI">BlockBlock is composed of two pieces: a launch daemon and a login item. The daemon is packaged as an application bundle to accommodate the use of entitlements and provisioning profiles. It runs in the background with root privileges, monitoring for persistence events (by ingesting file input/output and other events delivered from Endpoint Security), managing rules, and blocking user-specified persistent items. Anytime it detects a persistence event, the daemon sends an XPC message to the login item. The login item, which runs in the context of the user’s desktop session and thus is capable of displaying user interface (UI) elements, will then show the user an alert (<a href="chapter11.xhtml#fig11-2">Figure 11-2</a>).</p>&#13;
<figure class="IMG"><img class="img1" id="fig11-2" src="../images/Figure11-2.jpg" alt="" width="1390" height="727"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-2: A BlockBlock alert</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">BlockBlock’s alerts contain plenty of information about the item that installed the persistent item and the persistent item itself. This information can assist the user in deciding whether to allow or delete the item. For example, various red flags in the alert shown in <a href="chapter11.xhtml#fig11-2">Figure 11-2</a> indicate an infection. First, the item that installed the launch agent, <i>airportpaird</i>, is unsigned, as indicated by the perplexed frowning face. From its path, you can also see that it’s running from a temporary directory.</p>&#13;
<p class="TX">If you turn your attention to the persistent item, you’ll notice that the property list is prefixed with <span class="SANS_TheSansMonoCd_W5Regular_11">com.apple</span>, implying that it belongs to Apple. However, it’s installed in the user’s Launch Agent directory, which only ever contains third-party agents. Moreover, the persistent item that this property list references is installed and runs from a hidden directory (<i>.local</i>). Finally, if you manually examined the code signing information of this binary, <i>softwareupdate</i>, you would see it is unsigned.</p>&#13;
<p class="TX">When I originally released BlockBlock in 2014, Apple didn’t yet support System Extensions, which is why I placed the tool’s core logic in a launch daemon. Today, BlockBlock continues to make use of a daemon even though <span role="doc-pagebreak" epub:type="pagebreak" id="pg_258" aria-label="258"/>doing so isn’t strictly necessary, as the approach still has benefits. For one, you might want to develop tools that maintain compatibility with older versions of macOS. It’s also easy for any sufficiently privileged tool to install and manage launch daemons. On the other hand, System Extensions require additional entitlements, and to install or remove them, you’ll typically need explicit user approval. This adds complexity and requires additional code. Still, there are cases where putting your code into a System Extension makes sense, as you’ll see in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-83"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Plug-ins</span></h4>&#13;
<p class="TNI">Like KnockKnock, BlockBlock uses statically compiled plug-ins to detect multiple types of persistence. Each plug-in is responsible for handling either one unique persistent event or several related ones. The tool stores metadata about each plug-in in a property list file, including the name of the plug-in class, various descriptions of it to customize alerts, and, most importantly, a regular expression describing the path or paths of file events in which the plug-in is interested. For example, <a href="chapter11.xhtml#Lis11-1">Listing 11-1</a> shows the metadata for the plug-in that monitors file events for the additions of new launch daemons and agents.</p>&#13;
<span id="Lis11-1"/>&#13;
<pre><code>&lt;dict&gt;&#13;
   &lt;key&gt;description&lt;/key&gt;&#13;
   &lt;string&gt;Launch D &amp;amp; A&lt;/string&gt;&#13;
   &lt;key&gt;paths&lt;/key&gt;&#13;
   &lt;array&gt;&#13;
      &lt;string&gt;^(\/System|\/Users\/[^\/]+|)\/Library\/(LaunchDaemons|&#13;
      LaunchAgents)\/.+\.(?i)plist$&lt;/string&gt;&#13;
   &lt;/array&gt;&#13;
   &lt;key&gt;class&lt;/key&gt;&#13;
   &lt;string&gt;Launchd&lt;/string&gt;&#13;
   &lt;key&gt;alert&lt;/key&gt;&#13;
   &lt;string&gt;installed a launch daemon or agent&lt;/string&gt;&#13;
   ...&#13;
&lt;/dict&gt;&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-1: Metadata for the launch item plug-in</span></p>&#13;
<p class="TX">The regular expression will be applied to incoming file input/output events, matching on those that were ingested due to the addition of property lists added to the launch daemons and agents directories such as <i>/System/Library/LaunchDaemons</i> or <i>~/ Library/LaunchAgents</i>.</p>&#13;
<p class="TX">All plug-ins inherit from a custom base class named <span class="SANS_TheSansMonoCd_W5Regular_11">PluginBase</span> that implements base methods, such as a standard initialization method and methods to check whether a file event matches an event of interest. The initialization method <span class="SANS_TheSansMonoCd_W5Regular_11">initWithParams:</span> takes one parameter, a dictionary containing a plug-in’s metadata (<a href="chapter11.xhtml#Lis11-2">Listing 11-2</a>).</p>&#13;
<span id="Lis11-2"/>&#13;
<pre><code>-(id)initWithParams:(NSDictionary*)watchItemInfo {&#13;
    ...&#13;
    NSMutableArray* regexes = [NSMutableArray array];&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_259" aria-label="259"/>    for(NSString* regex in watchItemInfo[@"paths"]) {&#13;
        NSRegularExpression* compiledRegex =&#13;
        [NSRegularExpression regularExpressionWithPattern:regex&#13;
        options:NSRegularExpressionCaseInsensitive error:NULL];&#13;
&#13;
        [self.regexes addObject:compiledRegex];&#13;
    }&#13;
&#13;
    self.alertMsg = watchItemInfo[@"alert"];&#13;
    self.description = watchItemInfo[@"description"];&#13;
    ...&#13;
    return self;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-2: The base class logic for plug-in object initialization</span></p>&#13;
<p class="TX">Here, you can see that the method first compiles each of the plug-in’s paths of interest into regular expressions and then extracts other values from the metadata dictionary to save into instance variables.</p>&#13;
<p class="TX">Another important base method, <span class="SANS_TheSansMonoCd_W5Regular_11">isMatch:</span>, accepts a file object representing an event from the <i>FileMonitor</i> library, then checks for a match against the plug-in paths of interest (<a href="chapter11.xhtml#Lis11-3">Listing 11-3</a>).</p>&#13;
<span id="Lis11-3"/>&#13;
<pre><code>-(BOOL)isMatch:(File*)file {&#13;
    __block BOOL matched = NO;&#13;
    NSString* path = file.destinationPath;&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> [self.regexes enumerateObjectsWithOptions:NSEnumerationConcurrent&#13;
    usingBlock:^(NSRegularExpression* _Nonnull regex, NSUInteger idx, BOOL&#13;
    * _Nonnull stop) {&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> NSTextCheckingResult* match = [regex firstMatchInString:path options:0&#13;
        range:NSMakeRange(0, path.length)];&#13;
        if((nil == match) || (NSNotFound == match.range.location)) {&#13;
            return;&#13;
        }&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> matched = YES;&#13;
        *stop = YES;&#13;
    }];&#13;
&#13;
    return matched;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-3: Filepath matching</span></p>&#13;
<p class="TX">The method runs <span class="SANS_TheSansMonoCd_W5Regular_11">enumerateObjectsWithOptions:usingBlock:</span> on the array of the plug-in’s regular expressions so it can iterate over all of them concurrently <span class="CodeAnnotation" aria-label="annotation1">❶</span>. In the concurrently invoked callback block, it uses the current regular expression to check whether the destination file matches an event of interest to the plug-in <span class="CodeAnnotation" aria-label="annotation2">❷</span>. For example, for the launch item plug-in, the method will check whether the file event corresponds to the creation of a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_260" aria-label="260"/>property list in a launch daemon or agent directory. If a match does occur, the method sets a flag and terminates the enumeration <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Other methods in the base plug-in class are left for each plug-in to implement. For example, the <span class="SANS_TheSansMonoCd_W5Regular_11">block:</span> method, invoked when the user clicks the Block button on the alert, will remove the persistent item. This logic must differ based on the type of item persisted. If you’re interested in the specific uninstallation logic for each kind of persistent item, take a look at the code of each plug-in’s <span class="SANS_TheSansMonoCd_W5Regular_11">block:</span> method.</p>&#13;
<p class="TX">At its core, BlockBlock ingests events from the <i>FileMonitor</i> library, which leverages Apple’s Endpoint Security. After initializing a <span class="SANS_TheSansMonoCd_W5Regular_11">FileMonitor</span> object with the specific events of interest, it specifies a callback block and then begins file monitoring (<a href="chapter11.xhtml#Lis11-4">Listing 11-4</a>).</p>&#13;
<span id="Lis11-4"/>&#13;
<pre><code>es_event_type_t events[] = {ES_EVENT_TYPE_NOTIFY_CREATE, ES_EVENT_TYPE_NOTIFY_WRITE,&#13;
ES_EVENT_TYPE_NOTIFY_RENAME, ES_EVENT_TYPE_NOTIFY_EXEC, ES_EVENT_TYPE_NOTIFY_EXIT}; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
FileCallbackBlock block = ^(File* file) {&#13;
    ...&#13;
    [self processEvent:file plugin:nil message:nil]; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
};&#13;
&#13;
FileMonitor* fileMon = [[FileMonitor alloc] init];&#13;
[fileMon start:events count:sizeof(events)/sizeof(events[0]) csOption:csNone callback:block];&#13;
...&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-4: A helper method invoked for each file event</span></p>&#13;
<p class="TX">If you look carefully at the Endpoint Security events of interest passed to the file monitor, you’ll see both file and process events <span class="CodeAnnotation" aria-label="annotation1">❶</span>. It makes sense to initialize a file monitor with file events, and we need the process events to record the arguments of processes creating persistent items. Although not every process that persists an item is invoked with arguments, many are, and in those cases, we include the arguments in the alert shown to the user to help them determine whether the persistence event is benign or malicious. Before we discuss the processing of file input/output events, note that the file monitor logic is started by invoking the <span class="SANS_TheSansMonoCd_W5Regular_11">start:count:csOption:callback</span>: method.</p>&#13;
<p class="TX">When the file monitor receives events, it invokes the specified callback block with a <span class="SANS_TheSansMonoCd_W5Regular_11">File</span> object representing the event. The callback simply hands this object a helper method named <span class="SANS_TheSansMonoCd_W5Regular_11">processEvent:plugin:message:</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. This method calls each plug-in’s <span class="SANS_TheSansMonoCd_W5Regular_11">isMatch:</span> method to see whether the file event matches any persistence locations, such as the creation of a <i>.plist</i> in the launch daemon or agent directories. If any plug-in is interested in the file event, BlockBlock creates a custom <span class="SANS_TheSansMonoCd_W5Regular_11">Event</span> object with both the file object representing the persistence event and the relevant plug-in.</p>&#13;
<p class="TX">Next, the method checks whether the event matches any existing rules. Rules get created when a user interacts with an alert. They can either allow or block persistence items based on factors like the item’s startup file or the process responsible for triggering the event. For example, on my developer box, where I also dabble in photography and photo editing, there are rules allowing the creation of various Adobe Creative Cloud launch agents (<a href="chapter11.xhtml#fig11-3">Figure 11-3</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_261" aria-label="261"/>&#13;
<figure class="IMG"><img class="img1" id="fig11-3" src="../images/Figure11-3.jpg" alt="" width="1690" height="380"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-3: BlockBlock rules can allow or block events from specified processes.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Because Adobe frequently updates these persistent items, without these rules I’d be regularly responding to BlockBlock alerts. If it finds a matching rule, BlockBlock automatically takes the action specified in the rule. Otherwise, it delivers the event to the BlockBlock login item to show an alert to the user. Shortly, we’ll take a closer look at how bidirectional XPC achieves this communication. First, though, let’s explore BlockBlock’s use of the Endpoint Security Background Task Management events.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-84"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Background Task Management Events</span></h4>&#13;
<p class="TNI">One downside to using a global file monitor to detect persistence is that it’s rather inefficient, as file events happen almost constantly as part of normal system behavior. While we could mitigate the influx of traffic using Endpoint Security’s mute inversion capabilities covered in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>, BlockBlock needs to monitor many locations to detect multiple methods of persistence, and mute inversion may not fully alleviate the inefficiencies of a file monitor–based approach.</p>&#13;
<p class="TX">A better solution for our purposes would be to subscribe to persistence events rather than file events. In previous chapters, I discussed the Background Task Management subsystem, a recent addition to macOS that governs the most popular types of persistence, including login items, launch agents, and daemons. Background Task Management also added two events to Endpoint Security: <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_BTM_LAUNCH_ITEM_ADD</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_BTM_LAUNCH_ITEM_REMOVE</span>, which clients can receive whenever a login or launch item is persisted or removed.</p>&#13;
<p class="TX">Recent versions of BlockBlock leverage the first of these events to deprecate much of its file monitoring–based approach, providing a significant boost in efficiency and simplifying the code base. The tool still monitors persistence mechanisms such as cronjobs, however, for which Background Task Management doesn’t yet generate Endpoint Security events, so it can’t wholly deprecate its file monitoring.</p>&#13;
<p class="NOTE"><span class="Sans_Dogma_B">NOTE:</span></p>&#13;
<p class="NOTE-TXT"><i>Although Endpoint Security technically added these Background Task Management events in macOS 13, they didn’t work correctly. For example, Endpoint Security would deliver a notification not just for a newly installed item but for every existing item as well. Worse, for login items, it delivered no event at all! After I reported these flaws, Apple fixed both issues in macOS 14.</i><sup><a role="doc-noteref" id="chapter11_4" href="#chapter11-4">4</a></sup> <i>When run on macOS 13 and earlier, BlockBlock falls back to the file monitoring–based approach.</i></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_262" aria-label="262"/>You can find the code that implements an Endpoint Security client for Background Task Management in the <i>Daemon/Monitors/BTMMonitor.m</i> folder and the plug-in to process the events in <i>Daemon/Plugins/Btm.m</i>. Let’s start by considering the Background Task Management monitor. As with any code that wants to leverage Endpoint Security events, we start by defining the events of interest, creating an Endpoint Security client with a handler block, and subscribing to the specified events (<a href="chapter11.xhtml#Lis11-5">Listing 11-5</a>).</p>&#13;
<span id="Lis11-5"/>&#13;
<pre><code>es_event_type_t btmESEvents[] = {ES_EVENT_TYPE_NOTIFY_BTM_LAUNCH_ITEM_ADD}; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
es_new_client(&amp;_endpointClient, ^(es_client_t* client, const es_message_t* message) { <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
    // Message handler code removed for brevity <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
});&#13;
&#13;
es_subscribe(self.endpointClient, btmESEvents, sizeof(btmESEvents)/sizeof(btmESEvents[0])); <span class="codewide_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-5: Subscribing to <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ES_EVENT_TYPE_NOTIFY_BTM_LAUNCH_ITEM_ADD</span> events</span></p>&#13;
<p class="TX">The code starts by creating an array with the single event to subscribe to <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then, using the <span class="SANS_TheSansMonoCd_W5Regular_11">es_new_client</span> API, it creates a new Endpoint Security client. Because the client is an instance variable of the <span class="SANS_TheSansMonoCd_W5Regular_11">BTMMonitor</span> class, we prepend it with an underscore (<span class="SANS_TheSansMonoCd_W5Regular_11">_</span>) to pass it to the <span class="SANS_TheSansMonoCd_W5Regular_11">es_new_client</span> API <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We must do this because the compiler automatically generates an instance variable prefixed with an underscore whenever we declare an instance variable using the Objective-C <span class="SANS_TheSansMonoCd_W5Regular_11">@property</span> keyword.<sup><a role="doc-noteref" id="chapter11_5" href="#chapter11-5">5</a></sup> We normally don’t directly reference instance variables, but rather access them through an object; however, in the case of Endpoint Security’s C APIs, such as <span class="SANS_TheSansMonoCd_W5Regular_11">es_new_client</span>, which expects a pointer, we must perform a direct reference.</p>&#13;
<p class="TX">Recall that the <span class="SANS_TheSansMonoCd_W5Regular_11">es_new_client</span> API accepts a handler block to invoke each time a subscribed-to event occurs <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Shortly, you’ll see the code that BlockBlock’s Background Task Management monitor executes in this callback. Of course, before Endpoint Security can deliver events, we must tell it that we’re interested in subscribing, which we do via the <span class="SANS_TheSansMonoCd_W5Regular_11">es_subscribe</span> API <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX"><a href="chapter11.xhtml#Lis11-6">Listing 11-6</a> shows the code in the handler block.</p>&#13;
<span id="Lis11-6"/>&#13;
<pre><code>es_new_client(&amp;_endpointClient, ^(es_client_t* client, const es_message_t* message) {&#13;
    File* file = [[File alloc] init:(es_message_t*)message csOption:csNone]; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
    if((ES_BTM_ITEM_TYPE_AGENT == message-&gt;event.btm_launch_item_add-&gt;item-&gt;item_type) || <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
        (ES_BTM_ITEM_TYPE_DAEMON == message-&gt;event.btm_launch_item_add-&gt;item-&gt;item_type)) {&#13;
        file.destinationPath =&#13;
        convertStringToken(&amp;message-&gt;event.btm_launch_item_add-&gt;item-&gt;item_url);&#13;
    }&#13;
    es_message_t* messageCopy = NULL;&#13;
&#13;
    if(@available(macOS 11.0, *)) { <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
        es_retain_message(message);&#13;
        messageCopy = (es_message_t*)message;&#13;
    } else {&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_263" aria-label="263"/>        messageCopy = es_copy_message(message);&#13;
    }&#13;
    [monitor processEvent:file plugin:btmPlugin message:messageCopy]; <span class="codewide_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
});&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-6: The Background Task Management event monitoring logic</span></p>&#13;
<p class="TX">First, the code initializes a BlockBlock <span class="SANS_TheSansMonoCd_W5Regular_11">File</span> object, passing in the received Endpoint Security message <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then, for launch agents and daemons, it directly sets the file’s destination path to the property list of the item just created. We find this property list in the <span class="SANS_TheSansMonoCd_W5Regular_11">item_url</span> member of the <span class="SANS_TheSansMonoCd_W5Regular_11">item</span> structure in the <span class="SANS_TheSansMonoCd_W5Regular_11">btm_launch_item_add</span> structure, within the Endpoint Security message <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">Finally, the code calls BlockBlock’s <span class="SANS_TheSansMonoCd_W5Regular_11">processEvent:plugin:message:</span> method covered earlier in the chapter <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Here, though, the plug-in passed to the method is an instance of BlockBlock’s Background Task Management plug-in, which I’ll discuss next. Notice that we pass a retained instance or copy of the Endpoint Security message. This is because BlockBlock needs to retain the message for later use (for example, to process the user’s asynchronous response). Note that the code will invoke the more modern <span class="SANS_TheSansMonoCd_W5Regular_11">es_retain_message</span> API if running on a recent version of macOS, though falls back to using the <span class="SANS_TheSansMonoCd_W5Regular_11">es_copy_message</span> if running on older versions <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Because it explicitly retained or copied the message, BlockBlock must free it when it’s no longer needed by invoking the appropriate <span class="SANS_TheSansMonoCd_W5Regular_11">es_release_message</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">es_free_message</span> API.</p>&#13;
<p class="TX">Like all other BlockBlock plug-ins, the Background Task Management plug-in implements methods to retrieve the name and path of the persisted item, to block the item if instructed by the user, and more. Of course, the logic it uses to do so is specific to Background Task Management persistence events. Let’s take a look at the plug-in’s <span class="SANS_TheSansMonoCd_W5Regular_11">itemObject:</span> method, which returns the path to the persisted executable. As shown in <a href="chapter11.xhtml#Lis11-7">Listing 11-7</a>, we can extract this information from the delivered Endpoint Security message, although it differs slightly depending on whether the item persisted as a launch item or a login item.</p>&#13;
<span id="Lis11-7"/>&#13;
<pre><code>-(NSString*)itemObject:(Event*)event {&#13;
    NSString* itemObject = nil;&#13;
&#13;
    if((ES_BTM_ITEM_TYPE_AGENT ==&#13;
    event.esMessage-&gt;event.btm_launch_item_add-&gt;item-&gt;item_type) || <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
    (ES_BTM_ITEM_TYPE_DAEMON ==&#13;
    event.esMessage-&gt;event.btm_launch_item_add-&gt;item-&gt;item_type)) {&#13;
        itemObject =&#13;
        convertStringToken(&amp;event.esMessage-&gt;event.btm_launch_item_add-&gt;executable_path);&#13;
    } else {&#13;
        NSString* stringToken =&#13;
        convertStringToken(&amp;event.esMessage-&gt;event.btm_launch_item_add-&gt;item-&gt;item_url); <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
        itemObject = [[NSURL URLWithString:stringToken] path];&#13;
    }&#13;
    return itemObject;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-7: Returning the path to the persisted item</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_264" aria-label="264"/>The code first checks the type of the persisted item <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Conveniently, Endpoint Security indicates this information with constants such as <span class="SANS_TheSansMonoCd_W5Regular_11">ES_BTM_ITEM_TYPE_AGENT</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ES_BTM_ITEM_TYPE_DAEMON</span> and specifies the item type in the <span class="SANS_TheSansMonoCd_W5Regular_11">item_type</span> member of the <span class="SANS_TheSansMonoCd_W5Regular_11">item</span> structure. Assuming the persisted item is a launch item, the code extracts its executable path from the <span class="SANS_TheSansMonoCd_W5Regular_11">executable _path</span> member of the <span class="SANS_TheSansMonoCd_W5Regular_11">btm_launch_item_add</span> structure. To convert it from an <span class="SANS_TheSansMonoCd_W5Regular_11">es_string_token_t</span> type to an Objective-C string object, we invoke the BlockBlock <span class="SANS_TheSansMonoCd_W5Regular_11">convertStringToken</span> helper function.</p>&#13;
<p class="TX">For login items, we can find the path to the persisted item in the <span class="SANS_TheSansMonoCd_W5Regular_11">item_url</span> member of the <span class="SANS_TheSansMonoCd_W5Regular_11">item</span> structure <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Again, we invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">convertStringToken</span> helper function. However, the path to the item is really a URL object, so we must convert it back to a URL, then use the <span class="SANS_TheSansMonoCd_W5Regular_11">path</span> property of the URL to get the filepath in the form of a string.</p>&#13;
<p class="TX">The other notable method in the Background Task Management plug-in is <span class="SANS_TheSansMonoCd_W5Regular_11">block:</span>, which BlockBlock invokes when the user clicks Block on the alert shown for a persisted item. Because there is logic to remove both launch and login items in the older, file monitor–based plug-ins, the Background Task Management plug-in can call into the relevant plug-ins to block the item (<a href="chapter11.xhtml#Lis11-8">Listing 11-8</a>).</p>&#13;
<span id="Lis11-8"/>&#13;
<pre><code>-(BOOL)block:(Event*)event {&#13;
    __block BOOL wasBlocked = NO;&#13;
&#13;
    switch(event.esMessage-&gt;event.btm_launch_item_add-&gt;item-&gt;item_type) {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> case ES_BTM_ITEM_TYPE_APP:&#13;
        case ES_BTM_ITEM_TYPE_LOGIN_ITEM: {&#13;
            LoginItem* loginItem = [[LoginItem alloc] init];&#13;
            wasBlocked = [loginItem block:event];&#13;
            break;&#13;
        }&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> case ES_BTM_ITEM_TYPE_AGENT:&#13;
        case ES_BTM_ITEM_TYPE_DAEMON: {&#13;
            Launchd* launchItem = [[Launchd alloc] init];&#13;
            wasBlocked = [launchItem block:event];&#13;
            break;&#13;
        }&#13;
        ...&#13;
     }&#13;
     return wasBlocked;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-8: Blocking logic that calls into login and launch item plug-ins</span></p>&#13;
<p class="TX">To determine the type of the Background Task Management item, the code once again makes use of the <span class="SANS_TheSansMonoCd_W5Regular_11">item_type</span> member found in the Endpoint Security Background Task Management message. For login items (which can include persisted user applications), the code instantiates an instance of BlockBlock’s Login Item plug-in and then invokes its <span class="SANS_TheSansMonoCd_W5Regular_11">block:</span> method <span class="CodeAnnotation" aria-label="annotation1">❶</span>. For launch agents and daemons, it takes a similar approach, instantiating the launch item plug-in <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_265" aria-label="265"/>This wraps up the discussion of BlockBlock’s Background Task Management monitor and plug-in. Next, let’s look at XPC communications, which BlockBlock makes extensive use of.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1" id="sec9"><span id="h1-66"/><span class="SANS_Futura_Std_Bold_B_11">XPC</span></h3>&#13;
<p class="TNI">XPC is the de facto interprocess communication (IPC) mechanism on macOS. Anytime you write tools with multiple components, such as a privileged daemon or System Extension and an agent or app running in the user’s desktop session, the components will likely need to communicate via XPC. In this section, I’ll provide an overview of the topic, including the XPC APIs and specific examples. If you’re interested in learning more, you can dig deeper into BlockBlock code, which makes extensive use of bidirectional XPC.</p>&#13;
<p class="TX">To some extent, XPC conforms to a traditional client/server model. One component (in our case, the BlockBlock daemon) sets up an XPC server, or <i>listener</i>. An authorized client (for example, BlockBlock’s login item) can connect to the listener, then remotely invoke privileged methods implemented within the listener. Say a user responds to a BlockBlock alert, instructing the tool to block a persistently installed item, then creates a rule to automatically block related items in the future. Via XPC, BlockBlock’s login item can invoke the daemon’s privileged <i>block</i> and <i>create rule</i> methods. These methods run in the context of the privileged daemon to ensure that they have the appropriate permissions to remove even privileged persistent items. They can also create rules in a privileged context to help protect against malicious subversions.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-85"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating Listeners and Delegates</span></h4>&#13;
<p class="TNI">Let’s explore how the BlockBlock daemon creates the XPC listener and, more importantly, ensures that only authorized clients can connect to it. The latter point is essential for security tools, because if we leave the XPC interface unprotected, nothing stops malware or anything else from connecting to it and invoking the daemon’s privileged methods.</p>&#13;
<p class="TX">BlockBlock implements the XPC listener and connection logic in an interface named <span class="SANS_TheSansMonoCd_W5Regular_11">XPCListener</span> that conforms to the <span class="SANS_TheSansMonoCd_W5Regular_11">NSXPCListenerDelegate</span> protocol (<a href="chapter11.xhtml#Lis11-9">Listing 11-9</a>).</p>&#13;
<span id="Lis11-9"/>&#13;
<pre><code>@interface XPCListener : NSObject &lt;NSXPCListenerDelegate&gt;&#13;
    @property(weak)NSXPCConnection* client;&#13;
    @property(nonatomic, retain)NSXPCListener* listener;&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-9: An XPC listener class</span></p>&#13;
<p class="TX">To create an XPC interface, you can use the <span class="SANS_TheSansMonoCd_W5Regular_11">NSXPCListener initWithMachServiceName:</span> initialization method, which takes the name of the XPC service <span role="doc-pagebreak" epub:type="pagebreak" id="pg_266" aria-label="266"/>as an argument. <a href="chapter11.xhtml#Lis11-10">Listing 11-10</a> is the code from BlockBlock’s <span class="SANS_TheSansMonoCd_W5Regular_11">XPCListener</span> class that creates its XPC listener.</p>&#13;
<span id="Lis11-10"/>&#13;
<pre><code>#define DAEMON_MACH_SERVICE @"com.objective-see.blockblock"&#13;
&#13;
self.listener = [[NSXPCListener alloc] initWithMachServiceName:DAEMON_MACH_SERVICE];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-10: Initializing an XPC listener</span></p>&#13;
<p class="TX">Note that Apple built XPC atop the much older Mach message passing framework. This explains why you’ll run into method names such as <span class="SANS_TheSansMonoCd_W5Regular_11">initWithMachServiceName:</span>.</p>&#13;
<p class="TX">Once you’ve created a listener, you should specify the <i>delegate</i>, which contains pertinent XPC delegate methods. The XPC system frameworks will automatically invoke these delegate methods if implemented. Once invoked, they can perform important tasks, such as verifying any clients.</p>&#13;
<p class="TX">Because BlockBlock’s <span class="SANS_TheSansMonoCd_W5Regular_11">XPCListener</span> class conforms to the <span class="SANS_TheSansMonoCd_W5Regular_11">NSXPCListenerDelegate</span> protocol, it simply sets the listener delegate to itself. Then it invokes the listener’s <span class="SANS_TheSansMonoCd_W5Regular_11">resume</span> method to start processing client connections (<a href="chapter11.xhtml#Lis11-11">Listing 11-11</a>).</p>&#13;
<span id="Lis11-11"/>&#13;
<pre><code>self.listener.delegate = self;&#13;
[self.listener resume];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-11: Setting the delegate and resuming the listener</span></p>&#13;
<p class="TX">Now clients such as BlockBlock’s login item can initiate a connection to the listener. But before we show exactly how the client can perform this action, we must ensure that only authorized clients can connect.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-86"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extracting Audit Tokens</span></h4>&#13;
<p class="TNI">If you allow any client to connect to your privileged XPC interface, untrusted code could run the listener’s privileged methods. This issue has plagued core macOS XPC listeners as well as many third-party tools. For a specific example, see my 2015 DEF CON talk, which details the exploitation of the unprotected and privileged macOS <span class="SANS_TheSansMonoCd_W5Regular_11">writeConfig</span> XPC interface to elevate privileges to root.<sup><a role="doc-noteref" id="chapter11_6" href="#chapter11-6">6</a></sup></p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="SANS_Dogma_OT_Bold_B_21">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Versions of macOS beginning with 13 simplify the authorization process, and I’ll cover these steps in “Setting Client Requirements” on <a href="chapter11.xhtml#pg_270">page 270</a>. In this section, I’ll cover authorization methods that make your tools compatible with earlier versions of the operating system.</i></p>&#13;
<p class="TX">To authorize clients, we can turn to the <span class="SANS_TheSansMonoCd_W5Regular_11">NSXPCListenerDelegate listener: shouldAcceptNewConnection:</span> method.<sup><a role="doc-noteref" id="chapter11_7" href="#chapter11-7">7</a></sup> If a delegate provides an implementation of this method, the XPC subsystem will automatically invoke it whenever a client attempts to connect. The method should examine the candidate client and then return a Boolean value indicating whether to accept the client.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_267" aria-label="267"/>For authorized clients, this method should also configure the connection; I’ll discuss how to do this shortly. Finally, because all connections start in a suspended state while they’re being authorized and configured, this method should invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">resume</span> method on the passed-in <span class="SANS_TheSansMonoCd_W5Regular_11">NSXPCConnection</span> object for authorized clients. This allows the connection to start processing any received messages, as well as to send its own (<a href="chapter11.xhtml#Lis11-12">Listing 11-12</a>).</p>&#13;
<span id="Lis11-12"/>&#13;
<pre><code>-(BOOL)listener(NSXPCListener*)listener shouldAcceptNewConnection:&#13;
(NSXPCConnection*)newConnection {&#13;
    BOOL shouldAccept = NO;&#13;
&#13;
    // Code to authorize the client, and ignore unauthorized ones, removed for brevity&#13;
&#13;
    [newConnection resume];&#13;
    shouldAccept = YES;&#13;
&#13;
bail:&#13;
    return shouldAccept;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-12: Resuming a connection</span></p>&#13;
<p class="TX">While we could attempt to verify the client in several ways, many approaches are flawed or incomplete. For example, using the candidate client’s process ID is dangerous, as an attacker can exploit the fact that the system reuses process IDs to coerce the listener into allowing an unauthorized client.</p>&#13;
<p class="TX">A better method is to check the client’s audit token and retrieve its code signing information. Unfortunately, in older versions of macOS, Apple doesn’t readily expose the client’s audit token, which means we have to resort to some Objective-C trickery. The <span class="SANS_TheSansMonoCd_W5Regular_11">listener:shouldAcceptNewConnection:</span> method’s second argument is a pointer to an <span class="SANS_TheSansMonoCd_W5Regular_11">NSXPCConnection</span> object, which contains information about the client attempting to connect to the XPC service. While it does contain the audit token in its <span class="SANS_TheSansMonoCd_W5Regular_11">auditToken</span> property, this property is private, meaning we can’t directly access it. Luckily, Objective-C is introspective, so we can access private properties via a class extension. In <a href="chapter11.xhtml#Lis11-13">Listing 11-13</a>, BlockBlock creates an extension to the <span class="SANS_TheSansMonoCd_W5Regular_11">NSXPCConnection</span> class.</p>&#13;
<span id="Lis11-13"/>&#13;
<pre><code>@interface ExtendedNSXPCConnection : NSXPCConnection {&#13;
    audit_token_t auditToken;&#13;
}&#13;
    @property audit_token_t auditToken;&#13;
@end&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-13: Extending the <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NSXPCConnection</span> class to access its private audit token</span></p>&#13;
<p class="TX">Note that the extension defines a single property: the private audit token found within the <span class="SANS_TheSansMonoCd_W5Regular_11">NSXPCConnection</span> class. Once we’ve declared this extension, we can access the private audit token of the connecting client, as shown in <a href="chapter11.xhtml#Lis11-14">Listing 11-14</a>.</p>&#13;
<span id="Lis11-14"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_268" aria-label="268"/>-(BOOL)listener:(NSXPCListener*)listener shouldAcceptNewConnection:(NSXPCConnection*)&#13;
newConnection {&#13;
    ...&#13;
    audit_token_t auditToken = ((ExtendedNSXPCConnection*)newConnection).auditToken;&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-14: Accessing the connecting client’s audit token</span></p>&#13;
<p class="TX">This code typecasts the <span class="SANS_TheSansMonoCd_W5Regular_11">NSXPCConnection</span> object, representing the connecting client, as an <span class="SANS_TheSansMonoCd_W5Regular_11">ExtendedNSXPCConnection</span> object. Then it can readily extract the client’s audit token member. With an audit token in hand, the code can verify code signing information about the client, then securely verify the identity of the client and approve the connection if the client is authorized.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-87"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extracting Code Signing Details</span></h4>&#13;
<p class="TNI">To verify the client’s code signing information, BlockBlock’s implementation of the <span class="SANS_TheSansMonoCd_W5Regular_11">listener:shouldAcceptNewConnection:</span> delegate method takes the following steps. First, it uses the extracted audit token to obtain a dynamic code signing reference for the client process. It uses this reference to validate that the client’s code signing information is valid, then extracts the information. Additionally, it extracts the client code signing flags to ensure that the client was compiled with the hardened runtime, guarding against runtime injection attacks. Finally, it checks that the validated code signing information contains the bundle ID of the BlockBlock helper application, the Objective-See developer code signing certificate, and supported client versions. <a href="chapter11.xhtml#Lis11-15">Listing 11-15</a> shows the implementation of this requirement.</p>&#13;
<span id="Lis11-15"/>&#13;
<pre><code>" <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> anchor apple generic and <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> identifier \"com.objective-see.blockblock&#13;
.helper\" and <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> certificate leaf [subject.CN] = \"Developer ID Application:&#13;
Objective-See, LLC (VBG97UB4TA)\" and <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> info [CFBundleShortVersionString]&#13;
&gt;= \"2.0.0\"";&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-15: A code signing requirement to validate connecting XPC clients</span></p>&#13;
<p class="TX"><span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span> covered code signing requirements, but let’s break this one down. First, we require that the client be signed using a certificate issued by Apple to developers <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Next, we require the client identifier to match that of Objective-See’s BlockBlock helper <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We also require that the client be signed with Objective-See’s code signing certificate <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Finally, we require client versions of 2.0.0 or newer <span class="CodeAnnotation" aria-label="annotation4">❹</span>, as older versions of BlockBlock’s helper don’t support the more recent hardened runtime, leaving them vulnerable to subversion.<sup><a role="doc-noteref" id="chapter11_8" href="#chapter11-8">8</a></sup></p>&#13;
<p class="TX">If all these validation and verification steps succeed, the BlockBlock daemon knows that the client attempting to connect to its XPC interface is indeed a recent version of the BlockBlock helper component and that an attacker or malware hasn’t surreptitiously tampered with this component.</p>&#13;
<p class="TX"><a href="chapter11.xhtml#Lis11-16">Listing 11-16</a> shows the code that implements the full client authorization. Note the use of various <span class="SANS_TheSansMonoCd_W5Regular_11">SecTask*</span> code signing APIs, covered in <span role="doc-pagebreak" epub:type="pagebreak" id="pg_269" aria-label="269"/><span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>. As it’s imperative to always check the return value of these APIs, this code contains basic error handling.</p>&#13;
<span id="Lis11-16"/>&#13;
<pre><code>#define HELPER_ID @"com.objective-see.blockblock.helper"&#13;
#define SIGNING_AUTH @"Developer ID Application: Objective-See, LLC (VBG97UB4TA)"&#13;
&#13;
-(BOOL)listener:(NSXPCListener*)listener shouldAcceptNewConnection:(NSXPCConnection*)&#13;
newConnection {&#13;
    BOOL shouldAccept = NO;&#13;
    audit_token_t auditToken = ((ExtendedNSXPCConnection*)newConnection).auditToken;&#13;
&#13;
    OSStatus status = SecCodeCopyGuestWithAttributes(NULL, (__bridge CFDictionaryRef _Nullable)&#13;
    (@{(__bridge NSString*)kSecGuestAttributeAudit : [NSData dataWithBytes:&amp;auditToken&#13;
    length:sizeof(audit_token_t)]}), kSecCSDefaultFlags, &amp;codeRef);&#13;
    if(errSecSuccess != status) {&#13;
        goto bail;&#13;
    }&#13;
&#13;
    status = SecCodeCheckValidity(codeRef, kSecCSDefaultFlags, NULL);&#13;
    if(errSecSuccess != status)  {&#13;
        goto bail;&#13;
    }&#13;
&#13;
    status = SecCodeCopySigningInformation(codeRef, kSecCSDynamicInformation, &amp;csInfo);&#13;
    if(errSecSuccess != status)  {&#13;
        goto bail;&#13;
    }&#13;
&#13;
    uint32_t csFlags = [((__bridge NSDictionary*)csInfo)[(__bridge NSString*)&#13;
    kSecCodeInfoStatus] unsignedIntValue];&#13;
    if(!(CS_VALID &amp; csFlags) &amp;&amp; !(CS_RUNTIME &amp; csFlags)) {&#13;
        goto bail;&#13;
    }&#13;
&#13;
    NSString* requirement = [NSString stringWithFormat:@"anchor apple generic and&#13;
    identifier \"%@\" and certificate leaf [subject.CN] = \"%@\" and info&#13;
    [CFBundleShortVersionString] &gt;= \"2.0.0\"", HELPER_ID, SIGNING_AUTH];&#13;
&#13;
    SecTaskRef taskRef = SecTaskCreateWithAuditToken(NULL, ((ExtendedNSXPCConnection*)&#13;
    newConnection).auditToken);&#13;
&#13;
    status = SecTaskValidateForRequirement(taskRef, (__bridge CFStringRef)(requirement));&#13;
    if(errSecSuccess != status) {&#13;
        goto bail;&#13;
    }&#13;
&#13;
    shouldAccept = YES;&#13;
&#13;
    // Add code here to configure and finalize the NSXPCConnection.&#13;
&#13;
bail:&#13;
    return shouldAccept;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-16: Authorizing XPC clients</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_270" aria-label="270"/>You may be surprised by how hard it is to protect privileged XPC interfaces. Apple eventually realized this too, and luckily, in macOS 13, it provided two new APIs specifically designed to simplify the process of ensuring that only authorized clients could connect. If your tools will run only on versions of macOS 13 or newer, you should make use of these APIs so you don’t have to worry about accessing private audit tokens or manually extracting and verifying code signing information. The next section will detail these APIs.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h2-88"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting Client Requirements</span></h4>&#13;
<p class="TNI">On macOS 13 and newer, the <span class="SANS_TheSansMonoCd_W5Regular_11">NSXPCListener</span> class’s <span class="SANS_TheSansMonoCd_W5Regular_11">setConnectionCodeSigningRequirement:</span> method<sup><a role="doc-noteref" id="chapter11_9" href="#chapter11-9">9</a></sup> and the <span class="SANS_TheSansMonoCd_W5Regular_11">NSXPCConnection</span> class’s <span class="SANS_TheSansMonoCd_W5Regular_11">setCodeSigningRequirement:</span> method<sup><a role="doc-noteref" id="chapter11_10" href="#chapter11-10">10</a></sup> allow you to set code signing requirements on either the listener or the connection object. The first option applies to all connections, while the second applies to only specific ones, but you can use either to keep unauthorized clients from connecting to an XPC interface.</p>&#13;
<p class="TX">BlockBlock uses the listener method, which requires less granularity; it denies any and all connections that don’t belong to the BlockBlock helper client. Recall that <a href="chapter11.xhtml#Lis11-10">Listing 11-10</a> showed the code for initializing an XPC listener. <a href="chapter11.xhtml#Lis11-17">Listing 11-17</a> builds on this foundation by adding code to run on macOS versions 13 and newer.</p>&#13;
<span id="Lis11-17"/>&#13;
<pre><code>#define DAEMON_MACH_SERVICE @"com.objective-see.blockblock"&#13;
#define HELPER_ID @"com.objective-see.blockblock.helper"&#13;
#define SIGNING_AUTH @"Developer ID Application: Objective-See, LLC (VBG97UB4TA)"&#13;
&#13;
self.listener = [[NSXPCListener alloc] initWithMachServiceName:DAEMON_MACH_SERVICE];&#13;
&#13;
if(@available(macOS 13.0, *)) {&#13;
    NSString* requirement = [NSString stringWithFormat:@"anchor apple generic and&#13;
    identifier \"%@\" and certificate leaf [subject.CN] = \"%@\" and info&#13;
    [CFBundleShortVersionString] &gt;= \"2.0.0\"", HELPER_ID, SIGNING_AUTH]; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
    [self.listener setConnectionCodeSigningRequirement:requirement]; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
}&#13;
&#13;
self.listener.delegate = self;&#13;
[self.listener resume];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-17: Authorizing clients on macOS versions 13 and newer</span></p>&#13;
<p class="TX">After allocating and initializing an <span class="SANS_TheSansMonoCd_W5Regular_11">NSXPCListener</span> object, we use the Objective-C <span class="SANS_TheSansMonoCd_W5Regular_11">@available</span> attribute with a value of <span class="SANS_TheSansMonoCd_W5Regular_11">macOS 13.0, *</span> to instruct the compiler to execute the following lines on macOS 13 or newer only <span class="CodeAnnotation" aria-label="annotation1">❶</span>, as the <span class="SANS_TheSansMonoCd_W5Regular_11">setConnectionCodeSigningRequirement:</span> method isn’t available on earlier versions of macOS.</p>&#13;
<p class="TX">We then dynamically initialize a code signing requirement string <span class="CodeAnnotation" aria-label="annotation2">❷</span> with which to validate any clients attempting to connect to the listener. The requirement is identical to the one shown previously. Finally, BlockBlock invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">setConnectionCodeSigningRequirement:</span> method to instruct the XPC <span role="doc-pagebreak" epub:type="pagebreak" id="pg_271" aria-label="271"/>runtime to only accept connections from clients that conform to the specified code signing requirement string. Now we no longer have to manually verify clients; macOS will take care of it for us!</p>&#13;
<p class="TX">To confirm that the authorization works, compile and execute BlockBlock on macOS version 13 or newer, then attempt to connect to its XPC interface with an illegitimate client. The connection should fail, and the system’s XPC library should print the following message to the unified log:</p>&#13;
&#13;
<pre><code>Default     0x0     56198  0    BlockBlock: (libxpc.dylib) <b>Bogus check-in attempt. Ignoring</b>.</code></pre>&#13;
<p class="TX">Now that BlockBlock can authorize XPC clients, it can configure and then activate the connection.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h2-89"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Enabling Remote Connections</span></h4>&#13;
<p class="TNI">XPC communications usually occur in only one direction; a client connects to a listener and invokes its methods. BlockBlock, however, implements bidirectional communications. The daemon implements most of the XPC methods for tasks like blocking or removing persistent items and creating rules, and the client invokes these. However, the daemon also calls methods implemented in the client to, for example, display alerts to the user.</p>&#13;
<p class="TX">To facilitate this bidirectional IPC, we must configure the <span class="SANS_TheSansMonoCd_W5Regular_11">NSXPCConnection</span> object. First, let’s configure the listener object on the server side. This involves defining the remote methods that the client can invoke and specifying an object on the server side of the XPC interface that implements these methods. Both the server and the client must agree on what methods the client can remotely call. We can achieve this by setting the listener’s <span class="SANS_TheSansMonoCd_W5Regular_11">exportedInterface</span> property to an <span class="SANS_TheSansMonoCd_W5Regular_11">NSXPCInterface</span> object that describes the protocol for the exported object.<sup><a role="doc-noteref" id="chapter11_11" href="#chapter11-11">11</a></sup></p>&#13;
<p class="TX">In this context, a <i>protocol</i> is simply a list of methods that conformant objects will implement.<sup><a role="doc-noteref" id="chapter11_12" href="#chapter11-12">12</a></sup> We normally declare these protocols in header (<i>.h</i>) files, making them easy to include in both server and client code. <a href="chapter11.xhtml#Lis11-18">Listing 11-18</a> is the BlockBlock daemon’s XPC protocol.</p>&#13;
<span id="Lis11-18"/>&#13;
<pre><code>@protocol XPCDaemonProtocol&#13;
    -(void)getPreferences:(void (^)(NSDictionary*))reply;&#13;
    -(void)updatePreferences:(NSDictionary*)preferences;&#13;
    -(void)getRules:(void (^)(NSData*))reply;&#13;
    -(void)deleteRule:(Rule*)rule reply:(void (^)(NSData*))reply;&#13;
    -(void)alertReply:(NSDictionary*)alert;&#13;
@end&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-18: The XPC daemon protocol</span></p>&#13;
<p class="TX">Once we’ve declared this protocol, the daemon can set the <span class="SANS_TheSansMonoCd_W5Regular_11">exportedInterface</span> property to an <span class="SANS_TheSansMonoCd_W5Regular_11">NSXPCInterface</span> object conformant to the <span class="SANS_TheSansMonoCd_W5Regular_11">XPCDaemonProtocol</span> protocol. You can find the code to enable client connections in the <span class="SANS_TheSansMonoCd_W5Regular_11">listener:shouldAcceptNewConnection:</span> delegate method (<a href="chapter11.xhtml#Lis11-19">Listing 11-19</a>).</p>&#13;
<span id="Lis11-19"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_272" aria-label="272"/>-(BOOL)listener:(NSXPCListener*)listener shouldAcceptNewConnection:&#13;
(NSXPCConnection*)newConnection {&#13;
    // Code to authorize the client, and ignore unauthorized ones, removed for brevity&#13;
&#13;
    newConnection.exportedInterface =&#13;
    [NSXPCInterface interfaceWithProtocol:@protocol(XPCDaemonProtocol)];&#13;
    ...&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-19: Setting the exported interface for the <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NSXPCConnection</span></span></p>&#13;
<p class="TX">Of course, you must also specify the object on the server side that implements these methods (in this case, the BlockBlock daemon). You can do this by setting the <span class="SANS_TheSansMonoCd_W5Regular_11">exportedObject</span> property on the listener (<a href="chapter11.xhtml#Lis11-20">Listing 11-20</a>).</p>&#13;
<span id="Lis11-20"/>&#13;
<pre><code>-(BOOL)listener:(NSXPCListener*)listener shouldAcceptNewConnection:&#13;
(NSXPCConnection*)newConnection {&#13;
    // Code to authorize the client, and ignore unauthorized ones, removed for brevity&#13;
    ...&#13;
    newConnection.exportedObject = [[XPCDaemon alloc] init];&#13;
    ...&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-20: Setting the object that implements the exported interface</span></p>&#13;
<p class="TX">BlockBlock creates a class named <span class="SANS_TheSansMonoCd_W5Regular_11">XPCDaemon</span> to implement client-callable methods. As expected, this class conforms to the daemon protocol, <span class="SANS_TheSansMonoCd_W5Regular_11">XPCDaemonProtocol</span> (<a href="chapter11.xhtml#Lis11-21">Listing 11-21</a>).</p>&#13;
<span id="Lis11-21"/>&#13;
<pre><code>@interface XPCDaemon : NSObject &lt;<b>XPCDaemonProtocol</b>&gt;&#13;
@end&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-21: An interface conformant to <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XPCDaemonProtocol</span></span></p>&#13;
<p class="TX">Next, we’ll briefly look at a few of the privileged XPC methods that the BlockBlock helper component running in the limited-privilege user session can invoke.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h2-90"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exposing Methods</span></h4>&#13;
<p class="TNI">BlockBlock lets users define rules to automatically allow common persistence events. The privileged BlockBlock daemon manages these rules to keep unprivileged malware from tampering with them (for example, by adding an allow rule that permits the malware to persist). To display the rules to the user, the BlockBlock client will invoke the daemon’s <span class="SANS_TheSansMonoCd_W5Regular_11">getRules:</span> method via XPC (<a href="chapter11.xhtml#Lis11-22">Listing 11-22</a>).</p>&#13;
<span id="Lis11-22"/>&#13;
<pre><code>-(void)getRules:(void (^)(NSData*))reply {&#13;
    NSData* archivedRules = [NSKeyedArchiver archivedDataWithRootObject:&#13;
    rules.rules requiringSecureCoding:YES error:nil];&#13;
&#13;
    reply(archivedRules);&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-22: Returning serialized rules</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_273" aria-label="273"/>Because XPC is asynchronous, methods that return data should do so in a block. The <span class="SANS_TheSansMonoCd_W5Regular_11">getRules:</span> method declared in <span class="SANS_TheSansMonoCd_W5Regular_11">XPCDaemonProtocol</span> takes such a block, which the caller can invoke with a data object containing the list of rules. Notice that the method’s implementation is rather basic; it simply serializes the rules and sends them back to the client.</p>&#13;
<p class="TX">A more involved example of an XPC method is <span class="SANS_TheSansMonoCd_W5Regular_11">alertReply:</span>, which the client invokes via XPC once a user has interacted with a persistence alert (for example, by clicking Block). The method takes a dictionary that encapsulates the alert. The user doesn’t expect any response, so the method doesn’t use any callback block. <a href="chapter11.xhtml#Lis11-23">Listing 11-23</a> shows the method’s main code implemented within the daemon.</p>&#13;
<span id="Lis11-23"/>&#13;
<pre><code>-(void)alertReply:(NSDictionary*)alert {&#13;
    Event* event = nil;&#13;
    @synchronized(events.reportedEvents) {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> event = events.reportedEvents[alert[ALERT_UUID]];&#13;
    }&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> event.action = [alert[ALERT_ACTION] unsignedIntValue];&#13;
    if(BLOCK_EVENT == event.action) {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> [event.plugin block:event];&#13;
    }&#13;
    ...&#13;
    if(YES != [alert[ALERT_TEMPORARY] boolValue]) {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> [rules add:event];&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-23: Handling the user’s response to an alert</span></p>&#13;
<p class="TX">First, we retrieve an object representing the persistent event from the alert dictionary using a UUID <span class="CodeAnnotation" aria-label="annotation1">❶</span>. We wrap the object in a <span class="SANS_TheSansMonoCd_W5Regular_11">@synchronized</span> block to ensure thread synchronization. Next, we extract the user-specified action (either block or allow) from the alert <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If the user has decided to block the persistent event, BlockBlock will call in the relevant plug-in’s <span class="SANS_TheSansMonoCd_W5Regular_11">block:</span> method. This will execute the plug-in–specific code to remove the persistent item <span class="CodeAnnotation" aria-label="annotation3">❸</span> and add a rule for the event, so long as the user didn’t click the “temporary” checkbox on the alert <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">I mentioned that the BlockBlock daemon also needs to call methods implemented in the helper, for example, to display an alert to the user. It can do so over the same XPC interface once the helper has connected, although we need to specify a dedicated protocol. BlockBlock names this client protocol <span class="SANS_TheSansMonoCd_W5Regular_11">XPCUserProtocol</span> (<a href="chapter11.xhtml#Lis11-24">Listing 11-24</a>). It contains methods the client will implement and that the daemon can remotely invoke over XPC.</p>&#13;
<span id="Lis11-24"/>&#13;
<pre><code>@protocol XPCUserProtocol&#13;
    -(void)alertShow:(NSDictionary*)alert;&#13;
    ...&#13;
@end&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-24: The XPC user protocol</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_274" aria-label="274"/>Back in the <span class="SANS_TheSansMonoCd_W5Regular_11">listener:shouldAcceptNewConnection:</span> method, we configure the listener to allow the daemon to invoke the client’s remote methods (<a href="chapter11.xhtml#Lis11-25">Listing 11-25</a>).</p>&#13;
<span id="Lis11-25"/>&#13;
<pre><code>-(BOOL)listener:(NSXPCListener*)listener shouldAcceptNewConnection:&#13;
(NSXPCConnection*)newConnection {&#13;
    // Code to authorize the client, and ignore unauthorized ones, removed for brevity&#13;
    ...&#13;
    newConnection.remoteObjectInterface =&#13;
    [NSXPCInterface interfaceWithProtocol:@protocol(XPCUserProtocol)];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-25: Setting the remote object interface</span></p>&#13;
<p class="TX">We set the <span class="SANS_TheSansMonoCd_W5Regular_11">remoteObjectInterface</span> property and specify the <span class="SANS_TheSansMonoCd_W5Regular_11">XPCUserProtocol</span> protocol.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2" id="sec16"><span id="h2-91"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Initiating Connections</span></h4>&#13;
<p class="TNI">So far, I’ve shown how the BlockBlock daemon sets up an XPC listener, exposes methods, and ensures that only authorized clients can connect. However, I haven’t yet shown how the client initiates a connection or how it and the daemon remotely invoke the XPC methods.</p>&#13;
<p class="TX">Once the BlockBlock daemon is running, its XPC interface becomes available for authorized connections. To connect to the daemon, the BlockBlock helper uses the <span class="SANS_TheSansMonoCd_W5Regular_11">NSXPCConnection</span> object’s <span class="SANS_TheSansMonoCd_W5Regular_11">initWithMachServiceName:options:</span> method, specifying the same name used by the daemon (<a href="chapter11.xhtml#Lis11-26">Listing 11-26</a>).</p>&#13;
<span id="Lis11-26"/>&#13;
<pre><code>#define DAEMON_MACH_SERVICE @"com.objective-see.blockblock"&#13;
NSXPCConnection* daemon = [[NSXPCConnection alloc]&#13;
initWithMachServiceName:DAEMON_MACH_SERVICE options:0];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-26: Initializing a connection to the daemon XPC service</span></p>&#13;
<p class="TX">As we did on the server side, we must set the protocol for the remote object interface. Because we’re now on the client side, the “remote object interface” in this case refers to the XPC object on the daemon that exposes remotely invocable methods (<a href="chapter11.xhtml#Lis11-27">Listing 11-27</a>).</p>&#13;
<span id="Lis11-27"/>&#13;
<pre><code>#define DAEMON_MACH_SERVICE @"com.objective-see.blockblock"&#13;
&#13;
NSXPCConnection* daemon = [[NSXPCConnection alloc]&#13;
initWithMachServiceName:DAEMON_MACH_SERVICE options:0];&#13;
&#13;
daemon.remoteObjectInterface =&#13;
[NSXPCInterface interfaceWithProtocol: @protocol(XPCDaemonProtocol)]; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
daemon.exportedInterface = [NSXPCInterface interfaceWithProtocol:@protocol(XPCUserProtocol)];&#13;
daemon.exportedObject = [[XPCUser alloc] init]; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
[daemon resume]; <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-27: Setting up the XPC connection object on the client side</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_275" aria-label="275"/>Recall that this object conforms to <span class="SANS_TheSansMonoCd_W5Regular_11">XPCDaemonProtocol</span>, so we specify it here <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Also, because the daemon needs to call methods implemented in the client, the client needs to set up its own exported object. It does this via the <span class="SANS_TheSansMonoCd_W5Regular_11">exportedInterface</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">exportedObject</span> methods <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The former specifies the protocol (<span class="SANS_TheSansMonoCd_W5Regular_11">XPCUserProtocol</span>), while the latter specifies the object (<span class="SANS_TheSansMonoCd_W5Regular_11">XPCUser</span>) in the client that implements the exported XPC methods. Finally, we resume the connection <span class="CodeAnnotation" aria-label="annotation3">❸</span>, which triggers the actual connection to the daemon’s XPC listener.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2" id="sec17"><span id="h2-92"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Invoking Remote Methods</span></h4>&#13;
<p class="TNI">At this point, we’ve finished implementing the XPC connection. I’ll end this discussion of BlockBlock’s XPC utilization by showing how it actually invokes remote methods, focusing on the more common case of the client side. To abstract its communications with the daemon, the BlockBlock client uses a custom class named <span class="SANS_TheSansMonoCd_W5Regular_11">XPCDaemonClient</span>. The code in <a href="chapter11.xhtml#Lis11-26">Listing 11-26</a> that establishes an XPC connection lives in this class, as does the code that invokes the remote XPC methods.</p>&#13;
<p class="TX">To connect to the daemon and invoke one of its remote privileged XPC methods (for example, to get the current rules), the client can execute the code in <a href="chapter11.xhtml#Lis11-28">Listing 11-28</a>.</p>&#13;
<span id="Lis11-28"/>&#13;
<pre><code>XPCDaemonClient* xpcDaemonClient = [[XPCDaemonClient alloc] init];&#13;
NSArray* rules = [[xpcDaemonClient getRules];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-28: Invoking remote XPC methods</span></p>&#13;
<p class="TX">Let’s take a closer look at the <span class="SANS_TheSansMonoCd_W5Regular_11">getRules</span> method, which invokes the daemon’s remotely exposed corresponding <span class="SANS_TheSansMonoCd_W5Regular_11">getRules:</span> method. This method provides a good example of how you can invoke XPC methods, taking into account their nuances. Note that though the method contains additional logic to deserialize the rules it receives from the daemon, here we’re only focusing on the XPC logic (<a href="chapter11.xhtml#Lis11-29">Listing 11-29</a>).</p>&#13;
<span id="Lis11-29"/>&#13;
<pre><code>-(NSArray*)getRules {&#13;
    __block NSDictionary* unarchivedRules = nil;&#13;
    ...&#13;
    [[self.daemon synchronousRemoteObjectProxyWithErrorHandler:^(NSError* proxyError) { <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
        // Code to handle any errors removed for brevity <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
    }] getRules:^(NSData* archivedRules) {&#13;
        // Code to process the serialized rules from the daemon removed for brevity <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
    }];&#13;
    ...&#13;
    return rules;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-29: Getting rules from the daemon</span></p>&#13;
<p class="TX">First, the code invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">NSXPCConnection</span> class’s synchronous connection method <span class="CodeAnnotation" aria-label="annotation1">❶</span>. While XPC is generally asynchronous, we’re expecting the daemon to return data, so using a synchronous call makes the most sense in <span role="doc-pagebreak" epub:type="pagebreak" id="pg_276" aria-label="276"/>this situation. In other places, BlockBlock uses the more common asynchronous <span class="SANS_TheSansMonoCd_W5Regular_11">remoteObjectProxyWithErrorHandler:</span> method.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">XPCDaemonClient</span> class’s <span class="SANS_TheSansMonoCd_W5Regular_11">init</span> method previously established the connection and saved it in the instance variable named <span class="SANS_TheSansMonoCd_W5Regular_11">daemon</span>. The connection method returns the remote object, which exposes remotely invocable XPC methods. If any errors occur while retrieving this object, the code invokes an error block <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">With a remote object in hand, we can then invoke its methods, such as its <span class="SANS_TheSansMonoCd_W5Regular_11">getRules:</span> method. To return data, this XPC call takes a reply block; <a href="chapter11.xhtml#Lis11-22">Listing 11-22</a> showed the implementation of this method, found within the daemon. When the call completes, the block executes, taking as a parameter a data object containing the serialized rules from the daemon <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec18">&#13;
&#13;
<h3 class="H1" id="sec18"><span id="h1-67"/><span class="SANS_Futura_Std_Bold_B_11">Conclusion</span></h3>&#13;
<p class="TNI">BlockBlock’s approach is simple: detect persistent items, alert the user, and allow them to remove unwanted items. While straightforward, this design has proved incredibly effective against even the most sophisticated of persistent Mac malware.</p>&#13;
<p class="TX">In this chapter, you saw how to request an Endpoint Security entitlement from Apple. You also looked at BlockBlock’s design, its use of Endpoint Security events, and its bidirectional XPC communications. If you’re building your own security tools, I encourage you to draw from the system frameworks, APIs, and mechanisms that BlockBlock employs.</p>&#13;
<p class="TX">The next chapter explores a tool designed to heuristically detect some of the most insidious malware specimens: those that surreptitiously spy on victims through their mics and webcams.</p>&#13;
</section>&#13;
<section epub:type="rearnotes" role="doc-endnotes" aria-labelledby="sec19">&#13;
&#13;
<h3 class="H1" id="sec19"><span class="SANS_Futura_Std_Bold_B_11">Notes</span></h3>&#13;
<ol class="footnotes">&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter11-1" href="#chapter11_1">  1</a></span>.  “Writing Bad @$$ Lamware for OS X,” <i>reverse.put.as</i>, August 7, 2015, <a href="https://reverse.put.as/2015/08/07/writing-bad-lamware-for-os-x/"><i>https://<wbr/>reverse<wbr/>.put<wbr/>.as<wbr/>/2015<wbr/>/08<wbr/>/07<wbr/>/writing<wbr/>-bad<wbr/>-lamware<wbr/>-for<wbr/>-os<wbr/>-x<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter11-2" href="#chapter11_2">  2</a></span>.  “TN3125: Inside Code Signing: Provisioning Profiles,” <span class="endnoteentry_Endnote-Text-Char">Apple Developer Documentation,</span> <a href="https://developer.apple.com/documentation/technotes/tn3125-inside-code-signing-provisioning-profiles"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/technotes<wbr/>/tn3125<wbr/>-inside<wbr/>-code<wbr/>-signing<wbr/>-provisioning<wbr/>-profiles</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter11-3" href="#chapter11_3">  3</a></span>.  “Signing a Daemon with a Restricted Entitlement,” <span class="endnoteentry_Endnote-Text-Char">Apple Developer Documentation,</span> <a href="https://developer.apple.com/documentation/xcode/signing-a-daemon-with-a-restricted-entitlement"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/xcode<wbr/>/signing<wbr/>-a<wbr/>-daemon<wbr/>-with<wbr/>-a<wbr/>-restricted<wbr/>-entitlement</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter11-4" href="#chapter11_4">  4</a></span>.  asfdadsfasdfasdfsasdafads, “Endpoint Security Event: ES_EVENT _TYPE_NOTIFY_BTM_LAUNCH_ITEM_ADD is . . . broken?,” <span class="endnoteentry_Endnote-Text-Char">Apple Developer Forums, November 15, 2024,</span> <a href="https://developer.apple.com/forums/thread/720468"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/forums<wbr/>/thread<wbr/>/720468</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter11-5" href="#chapter11_5">  5</a></span>.  Keith Harrison, “Automatic Property Synthesis with Xcode 4.4,” <i>Use Your Loaf</i>, August 1, 2012, <a href="https://useyourloaf.com/blog/property-synthesis-with-xcode-4-dot-4/"><i>https://<wbr/>useyourloaf<wbr/>.com<wbr/>/blog<wbr/>/property<wbr/>-synthesis<wbr/>-with<wbr/>-xcode<wbr/>-4<wbr/>-dot<wbr/>-4<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_277" aria-label="277"/><span class="en_tx"><a id="chapter11-6" href="#chapter11_6">  6</a></span>.  Patrick Wardle, “Stick That in Your (Root) Pipe and Smoke It,” Speaker Deck, August 9, 2015, <a href="https://speakerdeck.com/patrickwardle/stick-that-in-your-root-pipe-and-smoke-it"><i>https://<wbr/>speakerdeck<wbr/>.com<wbr/>/patrickwardle<wbr/>/stick<wbr/>-that<wbr/>-in<wbr/>-your<wbr/>-root<wbr/>-pipe<wbr/>-and<wbr/>-smoke<wbr/>-it</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter11-7" href="#chapter11_7">  7</a></span>.  “listener:shouldAcceptNewConnection:,” Apple Developer Documentation, accessed May 25, 2024, <a href="https://developer.apple.com/documentation/foundation/nsxpclistenerdelegate/1410381-listener?language=objc"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/foundation<wbr/>/nsxpclistenerdelegate<wbr/>/1410381<wbr/>-listener<wbr/>?language<wbr/>=objc</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter11-8" href="#chapter11_8">  8</a></span>.  You can read about such subversive attacks in “The Story Behind CVE-2019-13013,” <i>Objective Development</i>, August 26, 2019, <a href="https://blog.obdev.at/what-we-have-learned-from-a-vulnerability"><i>https://<wbr/>blog<wbr/>.obdev<wbr/>.at<wbr/>/what<wbr/>-we<wbr/>-have<wbr/>-learned<wbr/>-from<wbr/>-a<wbr/>-vulnerability</i></a>, which details the exploitation of a popular commercial macOS firewall product.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter11-9" href="#chapter11_9">  9</a></span>.  “<span class="endnoteentry_Endnote-Text-Char">setConnectionCodeSigningRequirement:</span>,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/foundation/nsxpclistener/3943310-setconnectioncodesigningrequirem?language=objc"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/foundation<wbr/>/nsxpclistener<wbr/>/3943310<wbr/>-setconnectioncodesigningrequirem<wbr/>?language<wbr/>=objc</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter11-10" href="#chapter11_10">10</a></span>.  “<span class="endnoteentry_Endnote-Text-Char">setCodeSigningRequirement:</span>,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/foundation/nsxpcconnection/3943309-setcodesigningrequirement?language=objc"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/foundation<wbr/>/nsxpcconnection<wbr/>/3943309<wbr/>-setcodesigningrequirement<wbr/>?language<wbr/>=objc</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter11-11" href="#chapter11_11">11</a></span>.  “exportedInterface,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/foundation/nsxpcconnection/1408106-exportedinterface"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/foundation<wbr/>/nsxpcconnection<wbr/>/1408106<wbr/>-exportedinterface</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter11-12" href="#chapter11_12">12</a></span>.  “Working with Protocols,” Apple Developer Documentation, <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithProtocols/WorkingwithProtocols.html"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/library<wbr/>/archive<wbr/>/documentation<wbr/>/Cocoa<wbr/>/Conceptual<wbr/>/ProgrammingWithObjectiveC<wbr/>/WorkingwithProtocols<wbr/>/WorkingwithProtocols<wbr/>.html</i></a>.</p></li>&#13;
</ol>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>