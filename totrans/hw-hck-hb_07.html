<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="223" id="Page_223"/>7</span><br/>
<span class="ChapterTitle">X Marks the Spot: Trezor One Wallet Memory Dump</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">Let’s complete this series of chapters on fault injection by breaking a real target: the Trezor One wallet. We’ll use electromagnetic fault injection to demonstrate memory dumping and to allow us to extract the recovery seed, which is all that’s needed to access the wallet’s contents.</p>
<p>This chapter will be the most open-ended one in the book. It describes an advanced attack that may require more specialized equipment and has a very low success rate, even when well-tuned. In fact, re-creating this attack would make a good academic term project. To follow along with the entire attack, you’ll need a solid understanding of embedded design, along with some complicated instrumentation setup and a little bit of luck on top. However, we think it’s important to show what it takes to move from simple devices to actual products.</p>
<p>We discussed electromagnetic fault injection, or EMFI, in the section “Electromagnetic Fault Injection” in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>. EMFI tries to build a powerful <span epub:type="pagebreak" title="224" id="Page_224"/>pulse immediately above the top surface of the device itself, causing all sorts of corruption within the target. In this chapter, we’ll use an EMFI tool called ChipSHOUTER to perform the injection.</p>
<h2 id="h1-278748c07-0001">Attack Introduction</h2>
<p class="BodyFirst">Our victim is a Trezor One bitcoin wallet. This little device can be used to store bitcoins, which ultimately means that it provides a method of securely storing a private key used for cryptographic operations. We don’t need to dig into details of the wallet’s operation, but understanding the idea of a <em>recovery seed</em> is critical. The recovery seed is a series of words that encode a recovery key, and knowing that recovery seed is sufficient to recover the private key. This means that someone who steals only the recovery seed (without further access to the wallet) could access funds stored in the wallet itself. An attack that finds the key would be rather detrimental to the security of the owner’s precious coin.</p>
<p>The attack we describe here was inspired by some other work. The “wallet.fail” presentation at Chaos Computer Club (CCC) by Dmitry Nedospasov, Thomas Roth, and Josh Datko demonstrated how to break the STM32F2 security protection and dump the static RAM (SRAM) contents. Instead, we’ll show how to dump the flash memory contents directly where the seed is stored, so it’s a different attack but with similar end results.</p>
<p>We’ll use EMFI, allowing us to perform the attack without even removing the enclosure. This means someone can perform the attack without leaving any trace of modifying the wallet, no matter how carefully it’s inspected. This chapter introduces several more advanced tools, and you’ll see in their usage that it can be worth the investment when it comes to looking at real targets. As an example, we’ll use USB as a way of timing our attack. A true USB sniffer (such as a Total Phase Beagle USB 480) is instrumental here in understanding this timing. We have a longer discussion of tools in Appendix A.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The attack in this chapter, first described by Colin as part of the paper “MIN()imum Failure: EMFI Attacks Against USB Stacks,” was presented at the USENIX Workshop on Offensive Technology (WOOT) in 2019.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-278748c07-0002">Trezor One Wallet Internals</h2>
<p class="BodyFirst">The Trezor One wallet is open source, which makes this attack a wonderful demonstration for teaching EMFI and fault injection. You can freely modify the code or program older versions that have not yet patched the vulnerability.</p>
<p>The Trezor sources are available on GitHub in the trezor-mcu project. If you want to follow the steps in this chapter, select the “v1.7.3” tag on GitHub, or follow the link <a href="https://github.com/trezor/trezor-mcu/tree/v1.7.3/" class="LinkURL">https://github.com/trezor/trezor-mcu/tree/v1.7.3/</a>, which will take you to this exact version. These flaws have long been fixed in a firmware release that will be available by the time you read this book, <span epub:type="pagebreak" title="225" id="Page_225"/>so you’ll need to look at the older (vulnerable) code to better understand the exact attack. The Trezor is based on an STM32F205. <a href="#figure7-1" id="figureanchor7-1">Figure 7-1</a> shows the device sans enclosure.</p>
<figure>
<img src="image_fi/278748c07/f07001.png" alt="f07001"/>
<figcaption><p><a id="figure7-1">Figure 7-1</a>: Trezor One wallet internals</p></figcaption>
</figure>
<p>The six pin sockets on the left-hand side of the printed circuit board (PCB) are the JTAG header. The STM32F205 is just below the surface of the enclosure, a feature we’ll use to make our attack more realistic in practical scenarios.</p>
<p>The actual sensitive recovery seed is stored in flash memory in a section called the <em>metadata</em>. It’s located just after the bootloader, as shown in <a href="#listing7-1" id="listinganchor7-1">Listing 7-1</a>. Part of the header file defines the location of various items of interest within the flash memory space.</p>
<pre><code><var>--snip--</var>
#define FLASH_BOOT_START     (FLASH_ORIGIN)
#define FLASH_BOOT_LEN       (0x8000)

#define FLASH_META_START     (FLASH_BOOT_START + FLASH_BOOT_LEN)
#define FLASH_META_LEN       (0x8000)

#define FLASH_APP_START      (FLASH_META_START + FLASH_META_LEN)
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing7-1">Listing 7-1</a>: Location of various items of interest within the flash memory space</p>
<p>The <code>FLASH_META_START</code> address is at the end of the bootloader section. You can enter the bootloader by holding down the two buttons on the front of the Trezor, which allows a firmware update to be loaded over USB. Since a malicious firmware update could simply read out the metadata, the bootloader verifies that various signatures are present on a firmware update in order to prevent such an attack. Using fault injection to load unverified <span epub:type="pagebreak" title="226" id="Page_226"/>firmware would be one method of attack, but it’s not what we are going to use. The problem with all of these attacks is that the Trezor erases the flash memory <em>before</em> loading and validating the new file, storing the sensitive metadata in SRAM during this process. The wallet.fail disclosure actually attacked this process, since it’s possible to glitch the STM32 to go from code read-protection level RDP2 (which completely disables JTAG) to level RDP1 (which enables JTAG to read from SRAM, but not from code).</p>
<p>If our attack corrupted the SRAM (or needed a power cycle to recover from error states), performing that erase is very dangerous. The wallet.fail attack was able to recover the SRAM, but the attack method we’ll use could corrupt the SRAM, which means any mistake would permanently destroy the recovery seed. Instead, we’ll try to read out the flash memory directly, which is much safer since we make sure that an erase command won’t be performed, meaning that the data is safely stored in memory, waiting for us to extract it.</p>
<h2 id="h1-278748c07-0003">USB Read Request Faulting</h2>
<p class="BodyFirst">Since the bootloader supports USB, it also contains very standard USB processing code. <a href="#listing7-2" id="listinganchor7-2">Listing 7-2</a> shows part of it, which comes from the <em>winusb.c</em> file in the Trezor firmware source tree. We’ve chosen this particular “control vendor request” function because it sends out the “guid” through USB.</p>
<pre><code>static int winusb_control_vendor_request(usbd_device *usbd_dev,
                                   struct usb_setup_data *req,
                                   uint8_t **buf, uint16_t *len,
                                   usbd_control_complete_callback* complete) {
  (void)complete;
  (void)usbd_dev;

  if (req-&gt;bRequest != WINUSB_MS_VENDOR_CODE) {
    return USBD_REQ_NEXT_CALLBACK;
  }

  int status = USBD_REQ_NOTSUPP;
  if (((req-&gt;bmRequestType &amp; USB_REQ_TYPE_RECIPIENT) == USB_REQ_TYPE_DEVICE) &amp;&amp;
     (req-&gt;wIndex == WINUSB_REQ_GET_COMPATIBLE_ID_FEATURE_DESCRIPTOR))
  {
       *buf = (uint8_t*)(&amp;winusb_wcid);
       *len = MIN(*len, winusb_wcid.header.dwLength);
       status = USBD_REQ_HANDLED;

  } else if (((req-&gt;bmRequestType &amp; USB_REQ_TYPE_RECIPIENT) ==
             USB_REQ_TYPE_INTERFACE) &amp;&amp;
       (req-&gt;wIndex == WINUSB_REQ_GET_EXTENDED_PROPERTIES_OS_FEATURE_DESCRIPTOR)
      &amp;&amp; (usb_descriptor_index(req-&gt;wValue) ==
          winusb_wcid.functions[0].bInterfaceNumber))
  {
        *buf = (uint8_t*)(&amp;guid);
      <span class="CodeAnnotation" aria-label="annotation1">1</span> *len = MIN(*len, guid.header.dwLength);
        status = USBD_REQ_HANDLED;

<span epub:type="pagebreak" title="227" id="Page_227"/>  } else {
        status = USBD_REQ_NOTSUPP;
  }

  return status;
}</code></pre>
<p class="CodeListingCaption"><a id="listing7-2">Listing 7-2</a>: The WinUSB control request function that we attempt to fault</p>
<p>The control request function first checks some information sent about the USB request. It looks for a matching <code>bRequest</code>, <code>bmRequestType</code>, and <code>wIndex</code>, which are all attributes of a USB request. Finally, the original USB request itself contains a <code>wLength</code> field, which is how much data the computer is requesting be sent back. This is passed into the function from <a href="#listing7-2">Listing 7-2</a> as the <code>*len</code> argument. (The careful observer will also note the <code>dwLength</code> struct member in <a href="#listing7-2">Listing 7-2</a>, which has a completely different function: <code>dwLength</code> is the size of the available data to send back based on the descriptor programmed into the device.) We can freely request up to <code>0xFFFF</code> bytes of data, and that’s exactly what we’ll do. However, the code performs a <code>MIN()</code> operation <span class="CodeAnnotation" aria-label="annotation1">1</span> to limit the length of the actual data sent back to the computer to the minimum of either the requested length or the size of the descriptor we’ll send back. The computer can always request a smaller amount of data than the size of the descriptor, but if it requests more data than the device has (that is, if it requests a larger response size than the length of the descriptor), the device simply sends back only the valid data.</p>
<p>What happens if that <code>MIN()</code> call on <code>wLength</code> returns the wrong value? While the code would respond with the descriptor (as expected), it would also send all data after the descriptor up to offset <code>0xFFFF</code> from the start of the descriptor. This happens because the <code>MIN()</code> call is ensuring the user request allows only the read-back of the valid memory, but if the <code>MIN()</code> call returns the wrong value, it now means the user request can read back more than the anticipated memory. This “more than anticipated” memory section includes our precious metadata. The USB stack doesn’t know the data shouldn’t be sent back. The USB stack is simply sending back the block of data as the computer requested. The entire security of the system depends on one simple length check.</p>
<p>Here’s our plan: We’ll use fault injection to bypass the check <span class="CodeAnnotation" aria-label="annotation1">1</span> that depends on a single instruction. We take advantage of the fact that the bootloader (and the “guid”) is located at a lower address in memory than where the sensitive recovery seed is. We are planning on dumping memory by reading from a lower address to a higher address, so the attack is likely to succeed only when attacking USB code in the bootloader. If we attack USB code in the regular application that lives at <code>FLASH_APP_START</code>, it’s most likely that the interesting parts are already pointing beyond the sensitive <code>FLASH_META_START</code> area (refer back to <a href="#listing7-1">Listing 7-1</a>).</p>
<p>Before we dive into the details of performing the actual fault, let’s do a bit of a sanity checking on our claims. You can use such checks in your own code to help understand the impact of similar vulnerabilities.</p>
<h2 id="h1-278748c07-0004"><span epub:type="pagebreak" title="228" id="Page_228"/>Disassembling Code</h2>
<p class="BodyFirst">The first sanity check is to confirm that a simple fault can cause our intended operation. We easily can do that by inspecting a disassembly of the Trezor firmware running on the device using the Interactive Disassembler (IDA), which displays a breakdown of the assembly code (from <a href="#listing7-2">Listing 7-2</a>), as shown in <a href="#figure7-2" id="figureanchor7-2">Figure 7-2</a>.</p>
<figure>
<img src="image_fi/278748c07/f07002.png" alt="f07002"/>
<figcaption><p><a id="figure7-2">Figure 7-2</a>: Example of possible fault-injection location</p></figcaption>
</figure>
<p>The incoming value of <code>wLength</code> was stored in <code>R1</code>, and <code>R1</code> is compared to <code>0x92</code> in the disassembly. If it’s larger, it’s set to <code>0x92</code> with a conditional move (<code>MOVCS</code> in Arm assembly). These assembly lines are the implementation of the <code>MIN(*len, guid.header.dwLength)</code> call in the C source from <a href="#listing7-2">Listing 7-2</a>. Due to the resulting code flow that we can observe in the disassembly, we need to skip only the <code>MOVCS</code> instruction to accomplish our goal of having the user-supplied <code>wLength</code> field be accepted.</p>
<p>The second sanity check is to confirm no higher-layer protection exists. For example, maybe the USB stack does not actually accept such a large response since there is no real requirement to do so. Confirming this is a little harder to do by simple inspection, but the Trezor’s open source nature makes it possible. We can simply modify the code to comment out the security check, and then verify that we can request a large amount of memory. If you don’t want to recompile the code but have debugger access, you could also use an attached debugger to set a breakpoint on the <code>MOVCS</code> and toggle the status of the flag or manipulate the program counter to bypass the instruction.</p>
<p><span epub:type="pagebreak" title="229" id="Page_229"/>Validating this sanity check is done in the same way as the actual attack. We’ll work out all the details in the sections that follow. For now, we’ll just show how no other obstacles exist to getting out a large buffer through the control request. The attack code sends a length request of <code>0xFFFF</code> for the request. <a href="#figure7-3" id="figureanchor7-3">Figure 7-3</a> shows the USB traffic captured with Total Phase Beagle USB 480. When we don’t modify the <code>MOVCS</code> instruction, the USB request results in the expected length of 146 (<code>0x92</code>) bytes, shown at index 3, index 24, and index 45.</p>
<figure>
<img src="image_fi/278748c07/f07003.png" alt="f07003"/>
<figcaption><p><a id="figure7-3">Figure 7-3</a>: Capturing USB traffic with the length check disabled</p></figcaption>
</figure>
<p>Modifying the instruction (or using a debugger to clear the comparison flag manually) to bypass this check results in a full-size response, as the length of index 66 is 65535, or <code>0xFFFF</code>. This demonstrates that no hidden feature exists that will fundamentally prevent the attack from working.</p>
<h2 id="h1-278748c07-0005">Building Firmware and Validating the Glitch</h2>
<p class="BodyFirst">We’ll roughly be following the documentation for building the Trezor firmware from the Trezor Developer’s Guide available on the Trezor Wiki (<a href="https://wiki.trezor.io/" class="LinkURL">https://wiki.trezor.io/</a>). Here are the specific steps:</p>
<ol class="decimal">
<li value="1">Clone the production firmware and check out a known vulnerable revision.</li>
<li value="2">Build the firmware without memory protection.</li>
<li value="3">Program and test the device.</li>
<li value="4">Edit the firmware to remove the USB length check and try our attack.</li>
</ol>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Warning</span></h2>
<p><b>	</b>To follow the steps, you’ll need a Trezor device on which you can load your own bootloader. Production Trezor devices do not allow you to reprogram the bootloader with unsigned versions for security reasons and similarly have JTAG disabled, even if you use an external programmer. You’ll need either a Trezor where you have replaced the STM32F205RGT6 with a blank replacement chip or a Trezor-compatible development board. Check the Trezor wiki for more information.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><a href="#figure7-4" id="figureanchor7-4">Figure 7-4</a> shows the Trezor with a JTAG debugger attached. This Trezor is a production unit with the main chip replaced.</p>
<span epub:type="pagebreak" title="230" id="Page_230"/><figure>
<img src="image_fi/278748c07/f07004.png" alt="f07004"/>
<figcaption><p><a id="figure7-4">Figure 7-4</a>: A production Trezor that has had the JTAG port enabled by replacing the STM32F205 with a new device</p></figcaption>
</figure>
<p>We used a SEGGER J-Link for the debugger, but an ST-Link/V2 would work as well and costs much less. The schematic for the Trezor board is available in the Trezor hardware GitHub repository, <a href="https://github.com/trezor/trezor-hardware/tree/master/electronics/trezor_one/" class="LinkURL">https://github.com/trezor/trezor-hardware/tree/master/electronics/trezor_one/</a>, which details the pinout of the test points on the board.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	You could use the wallet.fail disclosure to unlock JTAG and erase the device as well if you really want to be elite. If you don’t want to validate the glitch in simulation, try applying the glitch directly on a production version of the 1.7.3 firmware. Use the <code>trezorctl</code> command line utility to load a specific version of the firmware onto the device with the <code>trezorctl firmware-update -v 1.7.3</code> command. You should see the screen indicate that “Loader 1.6.1” is running, where 1.6.1 is the bootloader version that shipped with main firmware 1.7.3. You must have that exact version for this attack to work.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Because any firmware we build this way will be unsigned, the Trezor will block our ability to reprogram the bootloader from the unsigned firmware. This means fully building the final firmware is pointless since that means we’d need to rewrite the bootloader. <a href="#listing7-3" id="listinganchor7-3">Listing 7-3</a> shows a section of the code that protects the bootloader.</p>
<pre><code><span epub:type="pagebreak" title="231" id="Page_231"/>jump:jump_to_firmware(const vector_table_t *ivt, int trust) {
  if (FW_SIGNED == trust) {    // trusted signed firmware
    SCB_VTOR = (uint32_t)ivt;  // * relocate vector table
    // Set stack pointer
    __asm__ volatile("msr msp, %0" ::"r"(ivt-&gt;initial_sp_value));
  } else {  // untrusted firmware
    timer_init();
    mpu_config_firmware();  // * configure MPU for the firmware
    __asm__ volatile("msr msp, %0" ::"r"(_stack));
  }</code></pre>
<p class="CodeListingCaption"><a id="listing7-3">Listing 7-3</a>: The bootloader disables an application’s ability to overwrite itself for untrusted firmware (taken from <em>util.h</em>)</p>
<p>If untrusted firmware is loaded, the memory protection unit is configured to disable access to the bootloader section of the flash memory. Had the code in <a href="#listing7-3">Listing 7-3</a> not been there, we could have used a custom application code build to load the bootloader we want to evaluate.</p>
<p>The first few steps to building the bootloader are easy (see <a href="#listing7-4" id="listinganchor7-4">Listing 7-4</a>) and roughly follow the documentation. You’ll need to do this on a Linux box or Linux virtual machine; our examples are on Ubuntu. We’ll build only the bootloader itself since that’s where the vulnerability lies. This build sequence avoids a few dependencies for building the full application (mainly <code>protobuf</code>) that can be a little more effort to install.</p>
<pre><code><b>sudo apt install git make gcc-arm-none-eabi protobuf-compiler python3 python3-pip</b>
<b>git clone --recursive https://github.com/trezor/trezor-mcu.git</b>
<b>cd trezor-mcu</b>
<b>git checkout v1.7.3</b>
<b>make vendor</b>
<b>make -C vendor/nanopb/generator/proto</b>
<b>make -C vendor/libopencm3 lib/stm32/f2</b>
<b>make MEMORY_PROTECT=0 &amp;&amp; make -C bootloader align MEMORY_PROTECT=0</b></code></pre>
<p class="CodeListingCaption"><a id="listing7-4">Listing 7-4</a>: Setting up and building the bootloader for Trezor 1.7.3</p>
<p>You may need to make additional tweaks to make this work. Depending on the compiler, the bootloader may get too large, in which case <code>export CFLAGS=-Os</code> can help. If this works, you’ll produce a file named <em>bootloader/bootloader.elf</em>. </p>
<p>The line with <code>MEMORY_PROTECT=0</code> is critical for debugging. If you misspell (or forget) this line, some memory protection logic is enabled. One thing that memory protection does is <em>lock the JTAG</em> such that future use is impossible. To save yourself from future mistakes, we recommend editing the <em>memory.c</em> file and immediately returning from the function <code>memory_protect()</code> at line 30. Should you program and run the bootloader without disabling memory protection, you will<em> immediately lose the ability to reprogram or debug the chip</em> (permanently). Editing that file will prevent you from becoming very unhappy when you need to replace the chip on your board.</p>
<p><span epub:type="pagebreak" title="232" id="Page_232"/>The main <em>Makefile</em> file builds a small library, which includes the memory protection logic. To avoid accidentally forgetting to rebuild the library, we suggest running the two commands on one line as shown in <a href="#listing7-3">Listing 7-3</a>. This will also build the <em>winusb.c</em> file that has the code we want to validate.</p>
<p>What next? You can now load the built firmware code using a programmer. We used an ST-Link/V2. Before programming the code, once again confirm that you’ve disabled the memory protection code on this build. Again, <a href="#figure7-4">Figure 7-4</a> shows the JTAG’s physical connection. You’ll need the programming software for the ST-Link/V2; on Windows, this is the ST-provided STM32 ST-LINK utility, and on Mac or Linux, you can build the open source <code>stlink</code> utility.</p>
<p>The next step is to keep bootloader mode on and send some interesting USB requests. To do so, plug in the device while holding down the two buttons to enter bootloader mode. If you’re using a device with an LCD (not required for this experiment), you’ll see the bootloader mode listed.</p>
<p>Next, you’ll use Python with PyUSB, which you can install with the <code>pip install pyusb</code> command.</p>
<p>On Linux, you should be able to talk to the Trezor device directly. The goal is to run the Python code in <a href="#listing7-5" id="listinganchor7-5">Listing 7-5</a>, which will print that it has read 146 bytes. You will likely need to perform the <code>udev</code> rules setup for the Trezor device (or run the script as root).</p>
<p>Using a Unix-like system directly will provide the most reliable results. Windows often disables a USB port if too many odd events happen on it, which complicates our research attempts.</p>
<p><a href="#listing7-5">Listing 7-5</a> assumes you’re using Linux.</p>
<pre><code>import usb.core
import time

dev = usb.core.find(idProduct=0x53c0)
dev.set_configuration()

#Get WinUSB GUID structure
resp = dev.ctrl_transfer(0xC1, 0x21, wValue=0, wIndex=0x05, data_or_wLength=0x1ff)
resp = list(resp)

print(len(resp))</code></pre>
<p class="CodeListingCaption"><a id="listing7-5">Listing 7-5</a>: Attempting to read the USB descriptor</p>
<p>The <code>data_or_wLength</code> variable has requested <code>0x1ff</code> (511) bytes, but only 146 should be returned, as that’s the length of the descriptor. Experiment with how much data you can request. You may notice that at some point your OS actually returns an “invalid parameter.” In theory, on some systems, we can request up to <code>0xFFFF</code> bytes, but many OSs don’t let you go that high. When it comes time to glitch, you’ll want to ensure that your request isn’t killed by the OS itself, so find the upper limit of your setup.</p>
<p><span epub:type="pagebreak" title="233" id="Page_233"/>You also may need to increase the timeout for the <code>dev.ctrl_transfer()</code> call in <a href="#listing7-5">Listing 7-5</a> by appending the <code>timeout=50</code> parameter. The control requests normally return very quickly, but if you successfully read huge blocks of data, the default timeouts may be too short.</p>
<h2 id="h1-278748c07-0006">USB Triggering and Timing</h2>
<p class="BodyFirst">Before we can insert the glitch, we need to know when to insert it. We know the exact instruction we want the glitch to target, and we know the command we sent over USB. We need to do better than that, however, to time the fault on the exact instruction. In our case, since we have access to the software, we’re going to “cheat” during our first test and measure the actual execution time. If we didn’t have this capability, we would end up with a much slower process or need to brute-force the right timing by trial and error.</p>
<p>First, we’ll need to get a more solid trigger on the USB data itself. The classic method for this is to use something like the Total Phase Beagle USB 480, which can perform triggering based on physical data going over the USB line. <a href="#figure7-5" id="figureanchor7-5">Figure 7-5</a> shows the setup.</p>
<figure>
<img src="image_fi/278748c07/f07005.png" alt="f07005"/>
<figcaption><p><a id="figure7-5">Figure 7-5</a>: Setup for triggering on the WinUSB message</p></figcaption>
</figure>
<p>The Total Phase Beagle USB 480 also has a beautiful sniffer interface, so we can sniff the traffic and better understand what (malformed) packets are coming back. This capability is very useful since we can see, for example, the exact portion of the USB request being interrupted/corrupted, which might provide some hints as to how far into the code the program has executed.</p>
<p>If you don’t have the Beagle, Micah Scott developed a simple module to perform real-time glitching called FaceWhisperer, which is available on GitHub (<a href="https://github.com/scanlime/facewhisperer/" class="LinkURL">https://github.com/scanlime/facewhisperer/</a>). It uses USB for glitch triggering and has been used with voltage glitching to dump the firmware from <span epub:type="pagebreak" title="234" id="Page_234"/>a drawing tablet. Kate Temkin at Great Scott Gadgets has also made several tools, including add-ons for the GreatFET and various USB tools such as LUNA. We use a tool that Colin developed, the PhyWhisperer-USB.</p>
<p>The open source PhyWhisperer-USB is designed to perform USB triggering based on specific packets. The Trezor USB passes through the PhyWhisperer-USB such that a computer is still sending the actual USB messages to the Trezor device.</p>
<p>The PhyWhisperer-USB is used via a Python program (or Jupyter notebooks). <a href="#listing7-6" id="listinganchor7-6">Listing 7-6</a> shows the initial setup, which simply connects to the PhyWhisperer-USB.</p>
<pre><code>import phywhisperer.usb as pw
import time
phy = pw.Usb()
phy.con()
phy.set_power_source("off")
time.sleep(0.5)
phy.reset_fpga()
phy.set_power_source("host")
#Let device enumerate
time.sleep(1.0)</code></pre>
<p class="CodeListingCaption"><a id="listing7-6">Listing 7-6</a>: PhyWhisperer-USB setup</p>
<p>The setup requires that you hold down buttons on the Trezor to ensure that it starts in bootloader mode. This script power-cycles the target so that the PhyWhisperer-USB can match the USB speed by observing the enumeration sequence.</p>
<p>Every time we want a trigger, we set up the trigger and arm the PhyWhisperer-USB, as in <a href="#listing7-7" id="listinganchor7-7">Listing 7-7</a>.</p>
<pre><code>#Configure pattern for request we want, arm
phy.set_pattern(pattern=[0xC1, 0x21], mask=[0xff, 0xff])
phy.set_trigger(delays=[0])
phy.arm()</code></pre>
<p class="CodeListingCaption"><a id="listing7-7">Listing 7-7</a>: Trigger based on the request we’re sending</p>
<p>Here we set the trigger based on the request we’re sending (shown in <a href="#listing7-5">Listing 7-5</a>). We can run the code in <a href="#listing7-5">Listing 7-5</a> on the host system, which starts the code we want to fault in <a href="#listing7-2">Listing 7-2</a> on the Trezor. The Trig Out connector on the PhyWhisperer-USB will have a short trigger pulse that coincides with the USB request going over the wire.</p>
<p>Later, during the fault attack, we’ll use the PhyWhisperer-USB to determine the time interval between the USB request and the specific instruction we want to fault. After the USB request triggers the code execution, it will take a small amount of time before the actual target instruction is executed. Adjusting the <code>set_trigger()</code> parameters lets us change the trigger output to a later point in time in order to line up the timing of the fault to the target instruction.</p>
<p><span epub:type="pagebreak" title="235" id="Page_235"/>The advantage of PhyWhisperer-USB is that we can also monitor the USB traffic. The USB data capture starts with the trigger; we used the code in <a href="#listing7-8" id="listinganchor7-8">Listing 7-8</a> to read it out of the PhyWhisperer-USB.</p>
<pre><code>raw = phy.read_capture_data()
phy.addpattern = True
packets = phy.split_packets(raw)
phy.print_packets(packets)</code></pre>
<p class="CodeListingCaption"><a id="listing7-8">Listing 7-8</a>: Code to read USB data out of the PhyWhisperer-USB</p>
<p><a href="#listing7-9" id="listinganchor7-9">Listing 7-9</a> shows the capture results, which are useful to observe that the right packets were used for the trigger and whether USB errors have been thrown.</p>
<pre><code>[      ]   0.000000 d=  0.000000 [   .0 +  0.017] [ 10] Err - bad PID of 01
[      ]   0.000006 d=  0.000006 [   .0 +  5.933] [  1] ACK
[      ]   0.000013 d=  0.000007 [   .0 + 12.933] [  3] IN   : 41.0
[      ]   0.000016 d=  0.000003 [   .0 + 16.350] [ 67] DATA1: 92 00 00 00 00 01 05 00 01 00 88 00 00 00 07 00 00 00 2a 00 44 00 65 00 76 00 69 00 63 00 65 00 49 00 6e 00 74 00 65 00 72 00 66 00 61 00 63 00 65 00 47 00 55 00 49 00 44 00 73 00 00 00 50 00 52 11
[      ]   0.000062 d=  0.000046 [   .0 + 62.350] [  1] ACK
[      ]   0.000064 d=  0.000002 [   .0 + 64.267] [  3] IN   : 41.0
[      ]   0.000068 d=  0.000003 [   .0 + 67.600] [ 67] DATA0: 00 00 7b 00 30 00 32 00 36 00 33 00 62 00 35 00 31 00 32 00 2d 00 38 00 38 00 63 00 62 00 2d 00 34 00 31 00 33 00 36 00 2d 00 39 00 36 00 31 00 33 00 2d 00 35 00 63 00 38 00 65 00 31 00 30 00 2d a6
[      ]   0.000114 d=  0.000046 [   .0 +113.600] [  1] ACK
[      ]   0.000149 d=  0.000036 [168   +  3.250] [  3] IN   : 41.0
[      ]   0.000153 d=  0.000003 [168   +  6.667] [ 21] DATA1: 39 00 64 00 38 00 65 00 66 00 35 00 7d 00 00 00 00 00 e7 b2
[      ]   0.000168 d=  0.000015 [168   + 22.000] [  1] ACK
[      ]   0.000174 d=  0.000006 [168   + 28.000] [  3] OUT  : 41.0
[      ]   0.000177 d=  0.000003 [168   + 31.250] [  3] DATA1: 00 00
[      ]   0.000181 d=  0.000003 [168   + 34.500] [  1] ACK</code></pre>
<p class="CodeListingCaption"><a id="listing7-9">Listing 7-9</a>: The output from running the code in <a href="#listing7-8">Listing 7-8</a></p>
<p>Note the <code>Err - bad PID of 01</code> error on the first line due to the capture having started partway through a control packet. Adjusting the trigger pattern to include the full packet would prevent this error. For our attack here, this error is irrelevant.</p>
<p>When automating our fault attack, we can detect faults that aren’t the desired effect (reading too much data) but that still corrupt USB data or cause errors. Knowing the timing of those errors is useful information. If we see an error occurring after we’ve already returned the USB data, we know our fault is too late to be effective, for example.</p>
<p>Once we have a trigger based on the USB request going “over the wire,” we will also insert a second trigger by setting an I/O pin high on the Trezor when the sensitive code runs. We use this to characterize the timing, since we can use an oscilloscope to measure the time from the USB packet going over the wire to the time of sensitive code executing.</p>
<p><span epub:type="pagebreak" title="236" id="Page_236"/>We can find a useful spare I/O pin by inspecting the Trezor board’s schematic; in our case, we find the schematic for v1.1 at <a href="https://github.com/trezor/trezor-hardware/blob/master/electronics/trezor_one/trezor_v1.1.sch.png" class="LinkURL">https://github.com/trezor/trezor-hardware/blob/master/electronics/trezor_one/trezor_v1.1.sch.png</a>. We see that the SWO pin from header K2 (visible in <a href="#figure7-1">Figure 7-1</a>) is routed to I/O pin PB3. If the Trezor can toggle PB3 during the comparison operation, this will provide useful timing information for doing fault injection. It saves us from having to sweep a large time span. <a href="#listing7-10" id="listinganchor7-10">Listing 7-10</a> shows a simple example of how to perform a GPIO toggle on the STM32F215 in the Trezor.</p>
<pre><code>//Add this at top of winusb.c
#include &lt;libopencm3/stm32/gpio.h&gt;

//Somewhere we want to make a trigger:
gpio_mode_setup(GPIOB, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, GPIO3);
gpio_set(GPIOB, GPIO3);
gpio_clear(GPIOB, GPIO3);</code></pre>
<p class="CodeListingCaption"><a id="listing7-10">Listing 7-10</a>: Toggling PB3, which routes to the SWO pin on header K2</p>
<p>If we insert the code in <a href="#listing7-10">Listing 7-10</a> at the location we want to fault, rebuild the bootloader, and then run the code, we should get a short pulse on the SWO pin that we can use for the timing. Again, to perform this evaluation, you’ll need a Trezor that has been hacked to allow reprogramming.</p>
<p>In this case, the time between the PhyWhisperer-USB trigger and the Trezor trigger ends up being around 4.2 to 5.5 microseconds. It’s not perfect timing, since there appears to be some jitter due to the USB packets being processed by a queue. Seeing such jitter tells us that when performing the fault injection, we shouldn’t expect to achieve perfect reliability. However, it gives us a range in which we can vary the timing parameter.</p>
<h2 id="h1-278748c07-0007">Glitching Through the Case</h2>
<p class="BodyFirst">In this section, we’ll go from exploration of the target to actually faulting it.</p>
<h3 id="h2-278748c07-0001">Setting Up</h3>
<p class="BodyFirst">To insert the glitch, our setup (shown in <a href="#figure7-6" id="figureanchor7-6">Figure 7-6</a>) includes a ChipSHOUTER EMFI tool mounted on a manual XY table for accurately positioning the coil. The Trezor target is also mounted on an XY table, and the PhyWhisperer-USB provides triggering and target power control via a switch inside the PhyWhisperer-USB. The power control capability is useful as we can reset the target when it crashes. The power control is a common feature on fault-injection-specific equipment, but general-purpose tools such as the Beagle USB 480 are missing.</p>
<p>The physical “jig” on which the Trezor is mounted depresses the two front panel buttons, ensuring that it always enters bootloader mode on startup.</p>
<span epub:type="pagebreak" title="237" id="Page_237"/><figure>
<img src="image_fi/278748c07/f07006.png" alt="f07006"/>
<figcaption><p><a id="figure7-6">Figure 7-6</a>: Complete setup with Trezor (middle), ChipSHOUTER (left), and PhyWhisperer-USB (right)</p></figcaption>
</figure>
<h3 id="h2-278748c07-0002">Reviewing the Code for Fault Injection</h3>
<p class="BodyFirst">The script in Listings 7-11 and 7-12 (split for readability) allows us to power-cycle the device, issue the WinUSB requests, and trigger the ChipSHOUTER based on the WinUSB request detected in the PhyWhisperer-USB.</p>
<pre><code>#PhyWhisperer-USB Setup
import time
import usb.core
import phywhisperer.usb as pw
phy = pw.Usb()
phy.con()

delay_start = phy.us_trigger(1.0) # Start at 1us from trigger
delay_end = phy.us_trigger(5.5) # Sweep to 5.5us from trigger

delay = delay_start
go = True

golden_valid = False

#Re-init power cycles the target when it’s fully crashed
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> def reinit():
    phy.set_power_source("off") 
    time.sleep(0.25)
    phy.reset_fpga()
    phy.set_capture_size(500)
    phy.set_power_source("host")
    time.sleep(0.8)

fails = 0</code></pre>
<p class="CodeListingCaption"><a id="listing7-11">Listing 7-11</a>: Part 1 of a simple script for glitching the Trezor bitcoin wallet when in bootloader mode</p>
<p><span epub:type="pagebreak" title="238" id="Page_238"/>In this setup, we use the PhyWhisperer-USB target device power control features, as evidenced by the <code>reinit()</code> function <span class="CodeAnnotation" aria-label="annotation1">1</span> that power-cycles the target when called. This function is performing error recovery when the target crashes. A more robust script might power-cycle the device on every attempt, but there is a trade-off here, as the power cycling is the slowest operation in the loop. We can attempt to perform a faster glitch loop by power-cycling only when the target stops responding, but the trade-off there is we don’t guarantee that the device is actually starting in the same state every time.</p>
<p><a href="#listing7-12" id="listinganchor7-12">Listing 7-12</a> shows the actual loop body of the attack.</p>
<pre><code>while go:
    if delay &gt; delay_end:
        print("New Loop Entered")
        delay = delay_start

    #Re-init on first run through (golden_valid is False) or if a number of fails
    if golden_valid is False or fails &gt; 10:
        reinit()
        fails = 0
    phy.set_trigger(delays=[delay], widths=[12]) #12 is width of EMFI pulse <span class="CodeAnnotationCode" aria-label="annotation1">1</span>
    phy.set_pattern(pattern=[0xC1, 0x21]) <span class="CodeAnnotationCode" aria-label="annotation2">2</span>
    dev = None

    try:
        dev = usb.core.find(idProduct=0x53c0)
        dev.set_configuration() <span class="CodeAnnotationCode" aria-label="annotation3">3</span>
    except:
        #If we fail multiple times, eventually triggers DUT power cycle
        fails += 1
        continue

    #Glitch only once we've recorded the 'golden sample' of expected output
    if golden_valid is True:
        phy.arm() <span class="CodeAnnotationCode" aria-label="annotation4">4</span>
    time.sleep(0.1)

    resp = [0]
    try:
        resp = dev.ctrl_transfer(0xC1, 0x21, wValue=0, wIndex=0x05, data_or_wLength=0x1ff) <span class="CodeAnnotationCode" aria-label="annotation5">5</span>
        resp = list(resp)

        if golden_valid is False:
            gold = resp[:] <span class="CodeAnnotationCode" aria-label="annotation6">6</span>
            golden_valid = True

        if resp != gold:
            #Odd (but valid!) response
            print("Delay: %d"%delay)
            print("Length: %d"%len(resp))
            print("[", ", ".join("{:02x}".format(num) for num in resp), "]")
            raw = phy.read_capture_data() <span class="CodeAnnotationCode" aria-label="annotation7">7</span>
            phy.addpattern = True
            packets = phy.split_packets(raw)
            phy.print_packets(packets)
<span epub:type="pagebreak" title="239" id="Page_239"/>
        if len(resp) &gt; 146:
            #Too-long response is desired result
            print(len(resp))
            go = False
            break

    except OSError: <span class="CodeAnnotationCode" aria-label="annotation8">8</span>
        #OSError catches USBError, normally means device crashed
        reinit()

    delay += 1

    if (delay % 10) == 0:
        print(delay)</code></pre>
<p class="CodeListingCaption"><a id="listing7-12">Listing 7-12</a>: Part 2 of a simple script for glitching the Trezor bitcoin wallet when in bootloader mode</p>
<p>The actual timing of the trigger output relative to the USB message trigger and the width of the EMFI pulse are set <span class="CodeAnnotation" aria-label="annotation1">1</span>. The width (<code>12</code>) was discovered using the techniques discussed previously, mostly by adjusting the width until we saw the device reset (probably too wide a pulse!) and then reducing the width until the device appeared to be on the edge of crashing. We confirm this edge is a successful width by looking for signs of corruption without a full device crash. For the Trezor, we can find that by looking for invalid messages or certain error messages being displayed. For tuning the width, we didn’t use the loop from <a href="#listing7-12">Listing 7-12</a>. Instead, we’d insert the glitch during the device boot when it’s performing validation of the internal memory. The Trezor displays a message if the signature check fails, and we could use this message to indicate that we had found good parameters for our EMFI tool that will cause a fault on this device. The signature check failing in the presence of a glitch most likely means we somehow affected the program flow (enough to disrupt the signature check), but the glitch wasn’t “too strong” such that it caused a crash of the device.</p>
<p>The message pattern on which our setup is being triggered is set <span class="CodeAnnotation" aria-label="annotation2">2</span>, which should match the later USB request we are sending to the device. On each iteration, the Trezor bootloader is reconnected using the <code>libusb</code> call <code>dev.set_configuration()</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>, which is also part of the error handling. If this line throws an exception, it’s likely because the host USB stack didn’t detect the device.</p>
<p>Beware of the <code>except</code> block’s silent error suppression right after the <code>libusb</code> call <span class="CodeAnnotation" aria-label="annotation3">3</span>. This <code>except</code> block assumes that a power cycle is sufficient to recover the target, but if the host USB stack has crashed, the script silently stops working. As mentioned before, we recommend running this on a bare-metal Unix system, as Windows typically causes problems quickly due to the host USB stack blocking the device after several quick disconnect/reconnect cycles. We’ve had similarly negative experiences inside virtual machines.</p>
<p>In order to know whether the glitch had any effect, we keep a “golden reference” of the expected USB request response. The actual glitch is <span epub:type="pagebreak" title="240" id="Page_240"/>inserted only when the <code>arm()</code> function <span class="CodeAnnotation" aria-label="annotation4">4</span> is called prior to the USB request <span class="CodeAnnotation" aria-label="annotation5">5</span>. The first time through, when the golden reference is taken <span class="CodeAnnotation" aria-label="annotation6">6</span>, the <code>arm()</code> function is not called to ensure that we capture unglitched (“golden”) output.</p>
<p>With this golden reference, we can now mark any odd response. The USB traffic that occurred during the fault injection is printed <span class="CodeAnnotation" aria-label="annotation7">7</span>. This downloads the data that was automatically captured when the request matched the pattern set <span class="CodeAnnotation" aria-label="annotation2">2</span>.</p>
<p>The code currently prints information only about valid responses. You may also want to print USB captures for invalid responses to determine whether the fault is causing errors to be inserted. The PhyWhisperer-USB still captures the invalid data. You would need to move the capture and print routine into the <code>except OSError</code> block <span class="CodeAnnotation" aria-label="annotation8">8</span>. Any errors will branch the code to the <code>OSError</code> exception block, because the USB stack does not return partial or invalid data.</p>
<h3 id="h2-278748c07-0003">Running the Code</h3>
<p class="BodyFirst">As an example, <a href="#listing7-13" id="listinganchor7-13">Listing 7-13</a> shows the golden reference for the WinUSB request.</p>
<pre><code>Length: 146
[ 92, 00, 00, 00, 00, 01, 05, 00, 01, 00, 88, 00, 00, 00, 07, 00, 00, 00, 2a, 00, 44, 00, 65, 00, 76, 00, 69, 00, 63, 00, 65, 00, 49, 00, 6e, 00, 74, 00, 65, 00, 72, 00, 66, 00, 61, 00, 63, 00, 65, 00, 47, 00, 55, 00, 49, 00, 44, 00, 73, 00, 00, 00, 50, 00, 00, 00, 7b, 00, 30, 00, 32, 00, 36, 00, 33, 00, 62, 00, 35, 00, 31, 00, 32, 00, 2d, 00, 38, 00, 38, 00, 63, 00, 62, 00, 2d, 00, 34, 00, 31, 00, 33, 00, 36, 00, 2d, 00, 39, 00, 36, 00, 31, 00, 33, 00, 2d, 00, 35, 00, 63, 00, 38, 00, 65, 00, 31, 00, 30, 00, 39, 00, 64, 00, 38, 00, 65, 00, 66, 00, 35, 00, 7d, 00, 00, 00, 00, 00 ]</code></pre>
<p class="CodeListingCaption"><a id="listing7-13">Listing 7-13</a>: The golden reference for the USB transaction</p>
<p>This golden reference is the value of the returned data, so any returned data that differs is expected to indicate an interesting (or useful) fault.</p>
<p><a href="#listing7-14" id="listinganchor7-14">Listing 7-14</a> shows one repeatable condition we observed in an experiment. The returned data (82 bytes) is shorter than the length of the golden reference (146 bytes).</p>
<pre><code>Delay: 1293
Length: 82
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> [ 00, 00, 7b, 00, 30, 00, 32, 00, 36, 00, 33, 00, 62, 00, 35, 00, 31, 00, 32, 
00, 2d, 00, 38, 00, 38, 00, 63, 00, 62, 00, 2d, 00, 34, 00, 31, 00, 33, 00, 36, 00, 2d, 00, 39, 00, 36, 00, 31, 00, 33, 00, 2d, 00, 35, 00, 63, 00, 38, 00, 65, 00, 31, 00, 30, 00, 39, 00, 64, 00, 38, 00, 65, 00, 66, 00, 35, 00, 7d, 00, 00, 00, 00, 00 ]
[      ]   0.000000 d=  0.000000 [   .0 +  0.017] [  3] Err - bad PID of 01
[      ]   0.000001 d=  0.000001 [   .0 +  1.200] [  1] ACK
[      ]   0.000029 d=  0.000028 [186   +  3.417] [  3] IN   : 6.0
[      ]   0.000032 d=  0.000003 [186   +  6.750] [ 67] DATA0: 92 00 00 00 00 01 05 00 01 00 88 00 00 00 07 00 00 00 2a 00 44 00 65 00 76 00 69 00 63 00 65 <span epub:type="pagebreak" title="241" id="Page_241"/>00 49 00 6e 00 74 00 65 00 72 00 66 00 61 00 63 00 65 00 47 00 55 00 49 00 44 00 73 00 00 00 50 00 52 11
[      ]   0.000078 d=  0.000046 [186   + 53.000] [  1] ACK
[      ]   0.000087 d=  0.000008 [186   + 61.417] [  3] IN   : 6.0
[      ]   0.000090 d=  0.000003 [186   + 64.750] [ 67] DATA1: 00 00 7b 00 30 00 32 00 36 00 33 00 62 00 35 00 31 00 32 00 2d 00 38 00 38 00 63 00 62 00 2d 00 34 00 31 00 33 00 36 00 2d 00 39 00 36 00 31 00 33 00 2d 00 35 00 63 00 38 00 65 00 31 00 30 00 2d a6
[      ]   0.000136 d=  0.000046 [186   +110.917] [  1] ACK
[      ]   0.000156 d=  0.000019 [186   +130.167] [  3] IN   : 6.0
[      ]   0.000159 d=  0.000003 [186   +133.500] [ 21] DATA0: 39 00 64 00 38 00 65 00 66 00 35 00 7d 00 00 00 00 00 e7 b2
[      ]   0.000174 d=  0.000016 [186   +149.000] [  1] ACK
[      ]   0.000183 d=  0.000009 [186   +157.583] [  3] OUT  : 6.0
[      ]   0.000186 d=  0.000003 [186   +161.000] [  3] DATA1: 00 00
[      ]   0.000190 d=  0.000003 [186   +164.250] [  1] ACK</code></pre>
<p class="CodeListingCaption"><a id="listing7-14">Listing 7-14</a>: Output of Listings 7-11 and 7-12 with the first 64 bytes missing</p>
<p>The returned data is simply the golden reference <em>without</em> the first 64 bytes <span class="CodeAnnotation" aria-label="annotation1">1</span>. It appears that a whole USB <code>IN</code> transaction is missing, which suggests that an entire USB data transfer was “skipped” on this fault injection run. Since no error was flagged on this transfer, the USB device must have thought it was only <em>supposed</em> to return the shorter length of data. Such a fault is interesting, because it proves that program flow changes in the target device are occurring, which is good to know since it shows that our overall goal is reasonable. Note again the <code>bad PID error</code>, which is due to missing the first part of a USB packet; it’s on the first decoded frame only and not indicative of an error caused by a fault.</p>
<h3 id="h2-278748c07-0004">Confirming a Dump</h3>
<p class="BodyFirst">How do we confirm we actually have a successful glitch (and get the magic recovery seed)? Initially, we just look for a “too-long” response and hope that the returned area of memory includes the recovery seed. Because the secret recovery seed is stored as a human-readable string, if we had a binary, we would simply run <code>strings -a</code> on the returned memory. Because we are implementing the attack in Python, we could instead use the <code>re</code> (regular expression) module. Assuming we have a list of data called <code>resp</code> (for example, from <a href="#listing7-14">Listing 7-14</a>), we could simply find all strings with only letters or spaces of length four or longer with a regular expression, as shown in <a href="#listing7-15" id="listinganchor7-15">Listing 7-15</a>.</p>
<pre><code>import re
re.findall(b"([a-zA-Z ]{4,})", bytearray(resp))</code></pre>
<p class="CodeListingCaption"><a id="listing7-15">Listing 7-15</a>: A “simple” regular expression to find strings consisting of four or more letters or a space</p>
<p>With any luck, we’ll get a list of strings present in the returned data, as in <a href="#listing7-16" id="listinganchor7-16">Listing 7-16</a>.</p>
<pre><code><span epub:type="pagebreak" title="242" id="Page_242"/>[b'WINUSB',
 b'TRZR',
 b'stor',
 b'exercise muscle tone skate lizard trigger hospital weapon volcano rigid veteran elite speak outer place logic old abandon aspect ski spare victory blast language',
 b'My Trezor',
 b'FjFS',
 b'XhYF',
 b'JFAF',
 b'FHDMD',</code></pre>
<p class="CodeListingCaption"><a id="listing7-16">Listing 7-16</a>: The recovery seed would be the long string with 24 English words.</p>
<p>One of the strings should be the recovery seed, which will be the long string of English language words. Seeing that means a successful attack!</p>
<h3 id="h2-278748c07-0005">Fine-Tuning the EM Pulse</h3>
<p class="BodyFirst">The final step when running the experiment is to fine-tune the EM pulse itself, which in this case means physically scanning the coil above the surface, along with adjusting the glitch width and power level. We can control the glitch width from the PhyWhisperer-USB script, but the power level is adjusted via the ChipSHOUTER serial interface. A more powerful glitch is simply likely to reset the device, whereas a less powerful glitch may have no effect. In between those extremes, we may see indications that we’re injecting errors, such as triggering error handlers or causing invalid USB responses. Triggering error handlers indicates that we’re probably not fully rebooting the device but are having some effects on the internal data being manipulated. On the Trezor in particular, the LCD screen visually indicates when the device entered an error handler routine and reports the type of error. Again, the USB protocol analyzer can be helpful in seeing whether invalid or strange results are occurring. Finding a location that occasionally enters an error is typically a useful starting point, as this suggests that the area is sensitive but is not so aggressive that it causes memory or bus faults 100 percent of the time.</p>
<h3 id="h2-278748c07-0006">Tuning Timing Based on USB Messages</h3>
<p class="BodyFirst">A successful glitch is one where the USB request comes through with the full length of data, having been able to bypass the length check. Finding the exact timing takes some experimentation. You will get many system crashes due to memory errors, hard faults, and resets. Using a hardware USB analyzer, you can see where these errors are occurring, which helps you understand the glitch timing, as previously shown in <a href="#listing7-14">Listing 7-14</a>. Without the “cheat” of being able to modify the source code in order to discover the timing, it would be absolutely essential to understand where those errors are occurring; they are flags we can use to understand the timing.</p>
<p><a href="#figure7-7" id="figureanchor7-7">Figure 7-7</a> shows another sample capture, this time with a Total Phase Beagle USB 480.</p>
<span epub:type="pagebreak" title="243" id="Page_243"/><figure>
<img src="image_fi/278748c07/f07007.png" alt="f07007"/>
<figcaption><p><a id="figure7-7">Figure 7-7</a>: A simple example where a USB error indicates when a fault injection corrupts program flow</p></figcaption>
</figure>
<p>The upper few rows in <a href="#figure7-7">Figure 7-7</a> show a number of correct 146-byte control transfers. The first part is the <code>SETUP</code> phase. The Trezor has <code>ACK</code>’d the <code>SETUP</code> packet but then never sends the follow-up data. The Trezor entered an infinite loop as it jumped to one of the various interrupt handlers for error detection. As the timing of the fault is shifted, various effects on the USB traffic are observed: moving the glitch earlier often prevents the <code>ACK</code> of the setup packet; moving the glitch later allows the first packet of follow-up data to be sent but not the second; and moving the glitch much later allows the complete USB transaction to be carried out but then crashes the device. This knowledge helps us understand in which part of the USB code the fault is being inserted, even if that fault continues to be a sledgehammer causing a device reset instead of an intended single instruction skip.</p>
<p>As you can see, this gives us a timing window for faulting the device, without using our earlier “cheat.”</p>
<h2 id="h1-278748c07-0008">Summary</h2>
<p class="BodyFirst">In this chapter, we walked through taking an unmodified bitcoin wallet and finding the recovery seed stored within it. We leveraged some features of the target’s open source design to provide insight, although the attack could have succeeded without that information. The target’s open source design means you can also use it as a reference for investigating your own products where you do have access to the source code. In particular, we showed how you could easily simulate the effect of a fault injection using a debugger attached to the device.</p>
<p>Finding a successful glitch timing is not easy. The previous experiments demonstrated when the comparison was happening, which is when we want the glitch to be inserted. As this time had jitter, there is no single “correct” time. In addition to time, some spatial positioning is required. If you had a computer-controlled XY scanning table, you could also automate the search for the correct location. In this example, we simply used a manual table, as very specific positioning didn’t seem necessary.</p>
<p>Again, due to the nature of the glitch timing, take care to decide on an economical strategy of how to search for candidate glitch settings. You can quickly see that the combination of physical location, glitch time, glitch width, and EMFI power settings means a huge number of parameters to <span epub:type="pagebreak" title="244" id="Page_244"/>search. Finding ways to narrow the search range (such as using information about error states to understand effective zones) is critical in keeping the problem space tractable. Logging “odd” outputs is also useful when investigating possible effects, because if you are looking only for a very narrow range of “success,” you may miss some other useful glitches.</p>
<p>The ultimate success rate of EMFI dumping is low. Once the glitches have been correctly tuned, 99.9 percent of the glitches return a result that is too short and, thus, they aren’t successful. We can, however, achieve a successful glitch within about one or two hours on average (subsequent to tuning location and timing), making it a relatively useful attack in practice.</p>
<p>We want to highlight that when you perform fault injection on real devices, a significant portion of reverse engineering goes on in order to figure out what can be faulted, such as USB dumping, looking at code, and so on. We hope the earlier chapters have prepared you for some of that, but you’ll certainly bump into challenges that aren’t covered here. As always, try to bring the challenges down to the simplest instance, solve them there, and then map them back to the full device.</p>
<p>If you try to re-create this full attack, you’ll likely find it more difficult than the labs we covered in Chapter 6, which should give you a feel for how fault attacks on a real device can be more difficult in practice, even though the fundamental operations are similar.</p>
<p>And now for something completely different. In the next chapter, we’ll move on to side-channel analysis and dive into more details on what we alluded to in earlier chapters: how power consumed by a device can tell us both the operations and data being used by the device under attack. </p>
</section>
</body></html>