- en: '**4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4'
- en: THE OBJECT LIFE CYCLE**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象生命周期**'
- en: '*Things you used to own, now they own you.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*你曾经拥有的东西，现在它们拥有你。*'
- en: —Chuck Palahniuk,* Fight Club
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —Chuck Palahniuk, *搏击俱乐部*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: The object life cycle is the series of stages a C++ object goes through during
    its lifetime. This chapter begins with a discussion of an object’s storage duration,
    the time during which storage is allocated for an object. You’ll learn about how
    the object life cycle dovetails with exceptions to handle error conditions and
    cleanup in a robust, safe, and elegant way. The chapter closes with a discussion
    of move and copy semantics that provides you with granular control over an object’s
    life cycle.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对象生命周期是C++对象在其生命周期中经历的一系列阶段。本章从讨论对象的存储持续时间开始，即为对象分配存储的时间。你将学习对象生命周期如何与异常处理结合，以一种稳健、安全和优雅的方式处理错误和清理工作。章节的最后讨论了移动和拷贝语义，帮助你对对象的生命周期进行细粒度的控制。
- en: '**An Object’s Storage Duration**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**对象的存储持续时间**'
- en: An *object* is a region of storage that has a type and a value. When you declare
    a variable, you create an object. A variable is simply an object that has a name.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象*是一个具有类型和值的存储区域。当你声明一个变量时，你就创建了一个对象。变量只是一个有名字的对象。'
- en: '***Allocation, Deallocation, and Lifetime***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分配、释放和生命周期***'
- en: Every object requires storage. You reserve storage for objects in a process
    called *allocation*. When you’re done with an object, you release the object’s
    storage in a process called *deallocation*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都需要存储。你通过*分配*过程为对象保留存储。当你不再使用对象时，你通过*释放*过程释放对象的存储。
- en: 'An object’s *storage duration* begins when the object is allocated and ends
    when the object is deallocated. The *lifetime* of an object is a runtime property
    that is bound by the object’s storage duration. An object’s lifetime begins once
    its constructor completes, and it ends just before a destructor is invoked. In
    summary, each object passes through the following stages:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的*存储持续时间*从对象分配开始，到对象被释放结束。对象的*生命周期*是一个运行时属性，受对象存储持续时间的约束。对象的生命周期从构造函数完成时开始，到析构函数被调用前结束。总的来说，每个对象都会经历以下几个阶段：
- en: The object’s storage duration begins, and storage is allocated.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象的存储持续时间开始，存储被分配。
- en: The object’s constructor is called.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象的构造函数被调用。
- en: The object’s lifetime begins.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象的生命周期开始。
- en: You can use the object in your program.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在程序中使用该对象。
- en: The object’s lifetime ends.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象的生命周期结束。
- en: The object’s destructor is called.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象的析构函数被调用。
- en: The object’s storage duration ends, and storage is deallocated.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象的存储持续时间结束，存储被释放。
- en: '***Memory Management***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内存管理***'
- en: If you’ve been programming in an application language, chances are you’ve used
    an *automatic memory manager*, or a *garbage collector*. At runtime, programs
    create objects. Periodically, the garbage collector determines which objects are
    no longer required by the program and safely deallocates them. This approach frees
    the programmer from worrying about managing an object’s life cycle, but it incurs
    several costs, including runtime performance, and requires some powerful programming
    techniques like deterministic resource management.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经在应用程序语言中编程过，你很可能使用过*自动内存管理器*或*垃圾回收器*。在运行时，程序会创建对象。垃圾回收器会定期检查哪些对象不再被程序需要，并安全地释放它们。这个方法让程序员不必担心管理对象的生命周期，但它也带来了几个成本，包括运行时性能问题，并且需要一些强大的编程技巧，比如确定性的资源管理。
- en: C++ takes a more efficient approach. The trade-off is that C++ programmers must
    have intimate knowledge of storage durations. It’s *our* job, not the garbage
    collector’s, to craft object lifetimes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: C++采用了一种更高效的方法。其折衷之处在于，C++程序员必须深入了解存储持续时间。*这*是我们的工作，而不是垃圾回收器的工作，我们需要设计对象的生命周期。
- en: '***Automatic Storage Duration***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***自动存储持续时间***'
- en: An *automatic object* is allocated at the beginning of an enclosing code block,
    and it’s deallocated at the end. The enclosing block is the automatic object’s
    *scope*. Automatic objects are said to have *automatic storage duration*. Note
    that function parameters are automatic, even though notationally they appear outside
    the function body.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*自动对象*会在一个代码块开始时分配，并在代码块结束时释放。这个代码块是自动对象的*作用域*。自动对象被认为具有*自动存储持续时间*。请注意，即使函数参数的符号上看起来在函数体外部，函数参数也是自动的。'
- en: In [Listing 4-1](ch04.xhtml#ch04ex01), the function `power_up_rat_thing` is
    the scope for the automatic variables `nuclear_isotopes` and `waste_heat`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单4-1](ch04.xhtml#ch04ex01)中，函数`power_up_rat_thing`是自动变量`nuclear_isotopes`和`waste_heat`的作用域。
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 4-1: A function with two automatic variables, `nuclear_isotopes` and
    `waste_heat`*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-1：一个包含两个自动变量`nuclear_isotopes`和`waste_heat`的函数*'
- en: Both `nuclear_isotopes` and `waste_heat` are allocated each time `power_up_rat_thing`
    is invoked. Just before `power_up_rat_thing` returns, these variables are deallocated.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`power_up_rat_thing`时，`nuclear_isotopes`和`waste_heat`都会被分配。在`power_up_rat_thing`返回之前，这些变量会被释放。
- en: Because you cannot access these variables outside of `power_up_rat_thing`, automatic
    variables are also called *local variables*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你无法在`power_up_rat_thing`之外访问这些变量，自动变量也被称为*局部变量*。
- en: '***Static Storage Duration***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***静态存储持续时间***'
- en: A *static object* is declared using the `static` or `extern` keyword. You declare
    static variables at the same level you declare functions—at global scope (or *namespace
    scope*). Static objects with global scope have *static storage duration* and are
    allocated when the program starts and deallocated when the program stops.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`static`或`extern`关键字声明一个*静态对象*。你在声明函数的同一层次上声明静态变量——在全局作用域（或*命名空间作用域*）中。具有全局作用域的静态对象具有*静态存储持续时间*，它们在程序启动时分配，并在程序停止时释放。
- en: The program in [Listing 4-2](ch04.xhtml#ch04ex02) powers up a Rat Thing with
    nuclear isotopes by calling the `power_up_rat_thing` function. When it does, the
    Rat Thing’s power increases, and the variable `rat_things_power` keeps track of
    the power level between power-ups.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单4-2](ch04.xhtml#ch04ex02)中的程序通过调用`power_up_rat_thing`函数来为Rat Thing提供能量。当这样做时，Rat
    Thing的能量增加，变量`rat_things_power`在每次能量提升之间跟踪能量水平。
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 4-2: A program with a static variable and several automatic variables*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-2：一个包含静态变量和多个自动变量的程序*'
- en: The variable `rat_things_power` ➊ is a static variable because it’s declared
    at global scope with the `static` keyword. Another feature of being declared at
    global scope is that `rat_things_power` can be accessed from any function in the
    translation unit. (Recall from [Chapter 1](ch01.xhtml#ch01) that a translation
    unit is what a preprocessor produces after acting on a single source file.) At
    ➋, you see `power_up_rat_thing` increasing `rat_things_power` by the number of
    `nuclear_isotopes`. Because `rat_things_power` is a static variable—and hence
    its lifetime is the program’s lifetime—each time you call `power_up_rat_thing`,
    the value of `rat_things_power` carries over into the next call.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`rat_things_power`➊是静态变量，因为它在全局作用域中使用`static`关键字声明。作为在全局作用域中声明的另一个特点是，`rat_things_power`可以从翻译单元中的任何函数访问。（回想一下[第1章](ch01.xhtml#ch01)，翻译单元是预处理器处理单个源文件后产生的内容。）在➋处，你看到`power_up_rat_thing`通过`nuclear_isotopes`的数量增加`rat_things_power`。由于`rat_things_power`是静态变量——因此它的生命周期是程序的生命周期——每次调用`power_up_rat_thing`时，`rat_things_power`的值都会延续到下一次调用。
- en: Next, you calculate how much waste heat is produced given the new value of `rat_things_power`,
    and you store the result in the automatic variable `waste_heat` ➌. Its storage
    duration begins when `power_up_rat_thing` is called and ends when `power_up_rat_thing`
    returns, so its values aren’t saved between function calls. Finally, you check
    whether waste_heat is over a threshold value of `1000` ➍. If it is, you print
    a warning message ➎
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你根据新的`rat_things_power`值计算产生的废热，并将结果存储在自动变量`waste_heat`中➌。它的存储持续时间从调用`power_up_rat_thing`开始，到`power_up_rat_thing`返回时结束，因此它的值不会在函数调用之间保存。最后，你检查`waste_heat`是否超过`1000`的阈值➍。如果是，你打印警告信息➎。
- en: Within `main`, you alternate between printing the value of `rat_things_power`
    ➏ and calling `power_up_rat_thing` ➐.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`中，你交替打印`rat_things_power`的值➏并调用`power_up_rat_thing`➐。
- en: Once you’ve increased the Rat Thing’s power from `300` to `800`, you get the
    warning message in the output ➑. The effects of modifying `rat_things_power` last
    for the lifetime of the program due to its static storage duration.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将Rat Thing的能量从`300`增加到`800`，你将在输出中看到警告信息➑。由于`rat_things_power`具有静态存储持续时间，因此修改`rat_things_power`的效果会持续到程序的生命周期。
- en: When you use the `static` keyword, you specify *internal linkage*. Internal
    linkage means that a variable is inaccessible to other translation units. You
    can alternately specify *external linkage*, which makes a variable accessible
    to other translation units. For external linkage, you use the `extern` keyword
    instead of `static`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`static`关键字时，你指定了*内部链接*。内部链接意味着一个变量对其他翻译单元不可访问。你也可以指定*外部链接*，使变量对其他翻译单元可访问。对于外部链接，你使用`extern`关键字而不是`static`。
- en: 'You could modify [Listing 4-2](ch04.xhtml#ch04ex02) in the following way to
    achieve external linkage:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像下面这样修改[清单 4-2](ch04.xhtml#ch04ex02)以实现外部链接：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With `extern` rather than `static`, you can access `rat_things_power` from other
    translation units.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`extern`而不是`static`，你可以从其他翻译单元访问`rat_things_power`。
- en: '**Local Static Variables**'
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**局部静态变量**'
- en: A *local static variable* is a special kind of static variable that is a local—rather
    than global—variable. Local static variables are declared at function scope, just
    like automatic variables. But their lifetimes begin upon the first invocation
    of the enclosing function and end when the program exits.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*局部静态变量*是一种特殊的静态变量，它是局部的——而不是全局的——变量。局部静态变量在函数作用域内声明，就像自动变量一样。但它们的生命周期从包含函数第一次调用开始，直到程序退出时结束。'
- en: For example, you could refactor [Listing 4-2](ch04.xhtml#ch04ex02) to make `rat_things_power`
    a local static variable, as demonstrated in [Listing 4-3](ch04.xhtml#ch04ex03).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以将[清单 4-2](ch04.xhtml#ch04ex02)重构，使`rat_things_power`成为一个局部静态变量，如[清单 4-3](ch04.xhtml#ch04ex03)所示。
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 4-3: A refactor of [Listing 4-2](ch04.xhtml#ch04ex02) using a local
    static variable.*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-3：使用局部静态变量重构[清单 4-2](ch04.xhtml#ch04ex02)。*'
- en: Unlike in [Listing 4-2](ch04.xhtml#ch04ex02), you cannot refer to `rat_things_power`
    from outside of the `power_up_rat_thing` function due to its local scope. This
    is an example of a programming pattern called *encapsulation*, which is the bundling
    of data with a function that operates on that data. It helps to protect against
    unintended modification.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与[清单 4-2](ch04.xhtml#ch04ex02)不同，由于`rat_things_power`的局部作用域，你不能从`power_up_rat_thing`函数外部引用它。这是一个被称为*封装*的编程模式的例子，封装是将数据与操作该数据的函数捆绑在一起。它有助于防止意外修改。
- en: '**Static Members**'
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**静态成员**'
- en: '*Static members* are members of a class that aren’t associated with a particular
    instance of the class. Normal class members have lifetimes nested within the class’s
    lifetime, but static members have static storage duration.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态成员*是类的成员，不与类的特定实例关联。正常的类成员生命周期嵌套在类的生命周期内，但静态成员具有静态存储持续时间。'
- en: These members are essentially similar to static variables and functions declared
    at global scope; however, you must refer to them by the containing class’s name,
    using the scope resolution operator `::`. In fact, you must initialize static
    members at global scope. You cannot initialize a static member within a containing
    class definition.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些成员本质上与在全局作用域声明的静态变量和函数类似；然而，你必须使用包含类的名称来引用它们，使用作用域解析运算符`::`。事实上，你必须在全局作用域初始化静态成员。你不能在包含类定义内初始化静态成员。
- en: '**NOTE**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There is an exception to the static member initialization rule: you can declare
    and define integral types within a class definition as long as they’re also `const`.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态成员初始化规则有一个例外：你可以在类定义中声明并定义整型类型，只要它们也是`const`。*'
- en: Like other static variables, static members have only a single instance. All
    instances of a class with static members share the same member, so if you modify
    a static member, *all* class instances will observe the modification. To illustrate,
    you could convert `power_up_rat_thing` and `rat_things_power` in [Listing 4-2](ch04.xhtml#ch04ex02)
    to static members of a `RatThing` class, as shown in [Listing 4-4](ch04.xhtml#ch04ex04).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他静态变量一样，静态成员只有一个实例。所有包含静态成员的类实例共享相同的成员，因此如果你修改了静态成员，*所有*类实例都会看到这个修改。为了说明这一点，你可以将[清单
    4-2](ch04.xhtml#ch04ex02)中的`power_up_rat_thing`和`rat_things_power`转换为`RatThing`类的静态成员，如[清单
    4-4](ch04.xhtml#ch04ex04)所示。
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 4-4: A refactor of [Listing 4-2](ch04.xhtml#ch04ex02) using static
    members*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-4：使用静态成员重构[清单 4-2](ch04.xhtml#ch04ex02)*'
- en: The `RatThing` class contains `rat_things_power` as a static member variable
    ➊ and `power_up_rat_thing` as a static method ➋. Because `rat_things_power` is
    a member of `RatThing`, you don’t need the scope resolution operator ➌; you access
    it like any other member.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`RatThing`类包含作为静态成员变量的`rat_things_power` ➊ 和作为静态方法的`power_up_rat_thing` ➋。由于`rat_things_power`是`RatThing`的成员，你无需使用作用域解析符号
    ➌；你可以像访问其他成员一样访问它。'
- en: You see the scope resolution operator in action where `rat_things_power` is
    initialized ➍ and where you invoke the static method `power_up_rat_thing` ➎.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到作用域解析符号的作用，在这里`rat_things_power`被初始化 ➍，并在这里调用了静态方法`power_up_rat_thing`
    ➎。
- en: '***Thread-Local Storage Duration***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***线程局部存储持续时间***'
- en: One of the fundamental concepts in concurrent programs is the *thread*. Each
    program has one or more threads that can perform independent operations. The sequence
    of instructions that a thread executes is called its *thread of execution*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 并发程序中的一个基本概念是*线程*。每个程序有一个或多个线程，可以执行独立的操作。线程执行的指令序列称为它的*执行线程*。
- en: Programmers must take extra precautions when using more than one thread of execution.
    Code that multiple threads can execute safely is called *thread-safe code*. Mutable
    global variables are the source of many thread safety issues. Sometimes, you can
    avoid these issues by giving each thread its own copy of a variable. You can do
    this by specifying that an object has *thread storage duration*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员在使用多个执行线程时必须格外小心。多个线程可以安全执行的代码称为*线程安全代码*。可变的全局变量是许多线程安全问题的根源。有时，你可以通过为每个线程提供自己的一份变量副本来避免这些问题。你可以通过指定对象具有*线程存储持续时间*来实现这一点。
- en: You can modify any variable with static storage duration to have thread-local
    storage duration by adding the `thread_local` keyword to the `static` or `extern`
    keyword. If only `thread_local` is specified, `static` is assumed. The variable’s
    linkage is unchanged.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在`static`或`extern`关键字前添加`thread_local`关键字，将任何具有静态存储持续时间的变量修改为线程局部存储持续时间。如果仅指定`thread_local`，则默认使用`static`。变量的连接性保持不变。
- en: '[Listing 4-3](ch04.xhtml#ch04ex03) is not thread safe. Depending on the order
    of reads and writes, `rat_things_power` could become corrupted. You could make
    [Listing 4-3](ch04.xhtml#ch04ex03) thread safe by specifying `rat_things_power`
    as `thread_local`, as demonstrated here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 4-3](ch04.xhtml#ch04ex03)不是线程安全的。根据读写的顺序，`rat_things_power`可能会被破坏。你可以通过将`rat_things_power`指定为`thread_local`，使[Listing
    4-3](ch04.xhtml#ch04ex03)变得线程安全，如下所示：'
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now each thread would represent its own Rat Thing; if one thread modifies its
    `rat_things_power`, the modification will not affect the other threads. Each copy
    of `rat_things_power` is initialized to 200 ➊.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个线程都会代表它自己的鼠标物体（Rat Thing）；如果一个线程修改了它的`rat_things_power`，该修改不会影响其他线程。每个`rat_things_power`的副本初始化为200
    ➊。
- en: '**NOTE**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Concurrent programming is discussed in more detail in [Chapter 19](ch19.xhtml#ch19).
    Thread storage duration is presented here for completeness.*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*并发编程在[第19章](ch19.xhtml#ch19)中有更详细的讨论。线程存储持续时间在此处列出，以补充完整。*'
- en: '***Dynamic Storage Duration***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***动态存储持续时间***'
- en: Objects with *dynamic storage duration* are allocated and deallocated on request.
    You have manual control over when a *dynamic object*’s life begins and when it
    ends. Dynamic objects are also called *allocated objects* for this reason.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 具有*动态存储持续时间*的对象会根据请求进行分配和解除分配。你可以手动控制*动态对象*的生命周期何时开始，何时结束。由于这个原因，动态对象也被称为*分配对象*。
- en: The primary way to allocate a dynamic object is with a *new expression*. A new
    expression begins with the `new` keyword followed by the desired type of the dynamic
    object. New expressions create objects of a given type and then return a pointer
    to the newly minted object.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 分配动态对象的主要方式是使用*new表达式*。new表达式以`new`关键字开始，后面跟着所需的动态对象类型。new表达式创建给定类型的对象，并返回指向新创建对象的指针。
- en: 'Consider the following example where you create an `int` with dynamic storage
    duration and save it into a pointer called `my_int_ptr`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，其中你创建了一个具有动态存储持续时间的`int`类型，并将其保存在一个名为`my_int_ptr`的指针中：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You declare a pointer to `int` and initialize it with the result of the new
    expression on the right side of the equal sign ➊. The new expression is composed
    of the `new` keyword ➋ followed by the desired type `int` ➌. When the new expression
    executes, the C++ runtime allocates memory to store an `int` and then returns
    its pointer.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明了一个指向`int`的指针，并用右侧等号的new表达式的结果对其进行初始化 ➊。new表达式由`new`关键字 ➋ 和所需类型`int` ➌ 组成。当new表达式执行时，C++运行时分配内存来存储一个`int`，然后返回其指针。
- en: 'You can also initialize a dynamic object within a new expression, as shown
    here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在新表达式中初始化一个动态对象，如下所示：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After allocating storage for the `int`, the dynamic object will be initialized
    as usual. After initialization completes, the dynamic object’s lifetime begins.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 `int` 分配存储空间后，动态对象将像往常一样初始化。初始化完成后，动态对象的生命周期开始。
- en: You deallocate dynamic objects using the *delete expression*, which is composed
    of the `delete` keyword followed by a pointer to the dynamic object. Delete expressions
    always return `void`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过 *删除表达式* 来释放动态对象，该表达式由 `delete` 关键字和指向动态对象的指针组成。删除表达式始终返回 `void`。
- en: 'To deallocate the object pointed to by `my_int_ptr`, you would use the following
    delete expression:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要释放由 `my_int_ptr` 指向的对象，可以使用以下删除表达式：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The value contained in memory where the deleted object resided is undefined,
    meaning the compiler can produce code that leaves anything there. In practice,
    major compilers will try to be as efficient as possible, so typically the object’s
    memory will remain untouched until the program reuses it for some other purposes.
    You would have to implement a custom destructor to, for example, zero out some
    sensitive contents.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 删除对象所在内存的值是未定义的，这意味着编译器可以生成留下任何内容的代码。实际上，主要编译器会尽可能高效，因此通常对象的内存会保持不变，直到程序为其他用途重新使用它。你需要实现一个自定义析构函数，例如将一些敏感内容清零。
- en: '**NOTE**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Because the compiler doesn’t typically clean up memory after an object is
    deleted, a subtle and potentially serious type of bug called a *use after free*
    can occur. If you delete an object and accidentally reuse it, your program might
    appear to function correctly because the deallocated memory might still contain
    reasonable values. In some situations, the problems don’t manifest until the program
    has been in production for a long time—or until a security researcher finds a
    way to exploit the bug and discloses it!*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于编译器通常不会在删除对象后清理内存，可能会发生一种微妙且潜在严重的错误，称为 *释放后使用*。如果你删除了一个对象并意外地重新使用它，程序可能看起来正常工作，因为释放的内存可能仍然包含合理的值。在某些情况下，问题直到程序投入生产很长时间后才会显现出来，或者直到安全研究人员找到漏洞的利用方式并公开披露！*'
- en: '**Dynamic Arrays**'
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**动态数组**'
- en: '*Dynamic arrays* are arrays with dynamic storage duration. You create dynamic
    arrays with *array new expressions*. Array new expressions have the following
    form:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态数组* 是具有动态存储持续时间的数组。你可以通过 *数组新表达式* 来创建动态数组。数组新表达式的形式如下：'
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`MyType` is the desired type of the array elements, `n_elements` is the length
    of the desired array, and the optional `init-list` is an initialization list to
    initialize the array. Array new expressions return a pointer to the first element
    of the newly allocated array.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyType` 是数组元素的期望类型，`n_elements` 是所需数组的长度，`init-list` 是一个可选的初始化列表，用于初始化数组。数组新表达式返回一个指向新分配数组第一个元素的指针。'
- en: 'In the following example, you allocate an `int` array of length 100 and save
    the result into a pointer called `my_int_array_ptr`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，你分配一个长度为 100 的 `int` 数组，并将结果保存到一个名为 `my_int_array_ptr` 的指针中：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The number of elements ➊ doesn’t need to be constant: the size of the array
    can be determined at runtime, meaning the value between brackets ➊ could be a
    variable rather than a literal.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 元素的数量 ➊ 不需要保持不变：数组的大小可以在运行时确定，这意味着括号中的值 ➊ 可以是一个变量，而不是字面量。
- en: 'To deallocate a dynamic array, use the *array delete expression*. Unlike the
    array new expression, the array delete expression doesn’t require a length:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要释放动态数组，使用 *数组删除表达式*。与数组新表达式不同，数组删除表达式不需要指定长度：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Like the delete expression, the array delete expression returns `void`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 像删除表达式一样，数组删除表达式返回 `void`。
- en: '**Memory Leaks**'
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**内存泄漏**'
- en: With privilege comes responsibility, so you must make sure that dynamic objects
    you allocate are also deallocated. Failure to do so causes *memory leaks* in which
    memory that is no longer needed by your program isn’t released. When you leak
    memory, you use up a resource in your environment that you’ll never reclaim. This
    can cause performance problems or worse.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 权力伴随着责任，因此你必须确保分配的动态对象也被释放。如果不这样做，会导致 *内存泄漏*，即程序不再需要的内存没有被释放。当内存泄漏发生时，你消耗了一个环境中的资源，且永远无法恢复。这可能会导致性能问题，甚至更严重的后果。
- en: '**NOTE**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In practice, your program’s operating environment might clean up leaked resources
    for you. For example, if you’ve written user-mode code, modern operating systems
    will clean up the resources when the program exits. However, if you’ve written
    kernel code, those operating systems won’t clean up the resources. You’ll only
    reclaim them when the computer reboots.*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*实际上，你程序的操作环境可能会为你清理泄漏的资源。例如，如果你编写的是用户模式代码，现代操作系统将在程序退出时清理资源。然而，如果你编写的是内核代码，这些操作系统则不会清理资源。你只有在计算机重新启动时才会回收它们。*'
- en: '**Tracing the Object Life Cycle**'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**追踪对象生命周期**'
- en: The object life cycle is as daunting to newcomers as it is powerful. Let’s clarify
    with an example that explores each of the storage durations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对象生命周期对新手来说既令人生畏又强大。让我们通过一个例子来澄清它，探索每种存储持续时间。
- en: Consider the `Tracer` class in [Listing 4-5](ch04.xhtml#ch04ex05), which prints
    a message whenever a `Tracer` object is constructed or destructed. You can use
    this class to investigate object life cycles, because each `Tracer` clearly indicates
    when its life is beginning and ending.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考 [清单 4-5](ch04.xhtml#ch04ex05) 中的 `Tracer` 类，每当一个 `Tracer` 对象被构造或析构时，它都会打印一条消息。你可以使用这个类来调查对象生命周期，因为每个
    `Tracer` 清楚地指示了它的生命周期何时开始和结束。
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 4-5: A `Tracer` class that announces construction and destruction*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-5：一个 `Tracer` 类，用于宣布构造和析构*'
- en: The constructor takes a single parameter ➊ and saves it into the member `name`
    ➋. It then prints a message containing `name` ➌. The destructor ➍ also prints
    a message with `name`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受一个参数 ➊ 并将其保存到成员 `name` ➋ 中。然后，它打印包含 `name` 的消息 ➌。析构函数 ➍ 也打印包含 `name` 的消息。
- en: Consider the program in [Listing 4-6](ch04.xhtml#ch04ex06). Four different `Tracer`
    objects have different storage durations. By looking at the order of the program’s
    `Tracer` output, you can verify what you’ve learned about storage durations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考 [清单 4-6](ch04.xhtml#ch04ex06) 中的程序。四个不同的 `Tracer` 对象有不同的存储持续时间。通过查看程序中 `Tracer`
    输出的顺序，你可以验证你学到的关于存储持续时间的知识。
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 4-6: A program using the `Tracer` class in [Listing 4-5](ch04.xhtml#ch04ex05)
    to illustrate storage duration*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-6：一个使用 [清单 4-5](ch04.xhtml#ch04ex05) 中的 `Tracer` 类来说明存储持续时间的程序*'
- en: '[Listing 4-6](ch04.xhtml#ch04ex06) contains a `Tracer` with static duration
    ➊, thread local duration ➋, automatic duration ➍, and dynamic duration ➎. Between
    each line in `main`, you print the character `A`, `B`, or `C` for reference ➌.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-6](ch04.xhtml#ch04ex06) 包含一个具有静态持续时间 ➊、线程局部持续时间 ➋、自动持续时间 ➍ 和动态持续时间 ➎
    的 `Tracer`。在 `main` 中的每一行之间，你会打印字符 `A`、`B` 或 `C` 作为参考 ➌。'
- en: Running the program yields [Listing 4-7](ch04.xhtml#ch04ex07).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序会生成 [清单 4-7](ch04.xhtml#ch04ex07) 中的输出。
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 4-7: Sample output from running [Listing 4-6](ch04.xhtml#ch04ex06)*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-7：运行 [清单 4-6](ch04.xhtml#ch04ex06) 的示例输出*'
- en: 'Before the first line of `main` ➌, the static and thread local variables `t1`
    and `t2` have been initialized ➊ ➋. You can see this in [Listing 4-7](ch04.xhtml#ch04ex07):
    both variables have printed their initialization messages before `A`. As an automatic
    variable, the scope of `t3` is bounded by the enclosing function `main`. Accordingly,
    `t3` is constructed where it is initialized just after `A`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 的第一行 ➌ 之前，静态和线程局部变量 `t1` 和 `t2` 已经初始化 ➊ ➋。你可以在 [清单 4-7](ch04.xhtml#ch04ex07)
    中看到：在打印 `A` 之前，这两个变量已经打印了它们的初始化消息。作为一个自动变量，`t3` 的作用域由封闭的函数 `main` 限制。因此，`t3` 在初始化时构造，紧接着在
    `A` 后面。
- en: After `B`, you see the message corresponding to the initialization of `t4` ➎.
    Notice that there’s no corresponding message generated by the dynamic destructor
    of `Tracer`. The reason is that you’ve (intentionally) leaked the object pointed
    to by `t4`. Because there’s no command to `delete t4`, the destructor is never
    called.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `B` 之后，你会看到与 `t4` 初始化对应的消息 ➎。注意，没有由 `Tracer` 的动态析构函数生成相应的消息。原因是你（故意）泄漏了 `t4`
    指向的对象。由于没有 `delete t4` 的命令，析构函数永远不会被调用。
- en: Just before `main` returns, `C` prints. Because `t3` is an automatic variable
    whose scope is `main`, it’s destroyed at this point because `main` is returning.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 返回之前，`C` 会打印。因为 `t3` 是一个自动变量，其作用域为 `main`，所以在此时它会被销毁，因为 `main` 正在返回。
- en: Finally, the static and thread-local variables `t1` and `t2` are destroyed just
    before program exit, yielding the final two messages in [Listing 4-7](ch04.xhtml#ch04ex07).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，静态和线程局部变量 `t1` 和 `t2` 在程序退出前被销毁，从而输出了 [清单 4-7](ch04.xhtml#ch04ex07) 中的最后两条消息。
- en: '**Exceptions**'
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**异常**'
- en: '*Exceptions* are types that communicate an error condition. When an error condition
    occurs, you *throw* an exception. After you throw an exception, it’s *in flight*.
    When an exception is in flight, the program stops normal execution and searches
    for an *exception handler* that can manage the in-flight exception. Objects that
    fall out of scope during this process are destroyed.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*异常*是用来传达错误条件的类型。当错误条件发生时，你*抛出*一个异常。在你抛出异常后，异常处于*处理中*状态。当异常处于处理中时，程序停止正常执行，并搜索一个可以处理该异常的*异常处理器*。在这个过程中，超出作用域的对象将被销毁。'
- en: In situations where there’s no good way to handle an error locally, such as
    in a constructor, you generally use exceptions. Exceptions play a crucial role
    in managing object life cycles in such circumstances.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在无法局部处理错误的情况下，比如在构造函数中，你通常会使用异常。异常在这种情况下在管理对象生命周期中发挥着至关重要的作用。
- en: The other option for communicating error conditions is to return an error code
    as part of a function’s prototype. These two approaches are complementary. In
    situations where an error occurs that can be dealt with locally or that is expected
    to occur during the normal course of a program’s execution, you generally return
    an error code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种传达错误条件的方式是将错误代码作为函数原型的一部分返回。这两种方法是互补的。在发生可以局部处理的错误，或者在程序正常执行过程中预期会发生的错误时，通常会返回错误代码。
- en: '***The throw Keyword***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***`throw`关键字***'
- en: To throw an exception, use the `throw` keyword followed by a throwable object.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要抛出异常，使用`throw`关键字，后跟一个可抛出的对象。
- en: Most objects are throwable. But it’s good practice to use one of the exceptions
    available in stdlib, such as `std::runtime_error` in the `<stdexcept>` header.
    The `runtime_error` constructor accepts a null-terminated `const char*` describing
    the nature of the error condition. You can retrieve this message via the `what`
    method, which takes no parameters.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数对象都是可抛出的。但遵循一个好习惯是使用`<stdexcept>`头文件中可用的异常之一，如`std::runtime_error`。`runtime_error`构造函数接受一个以空字符结尾的`const
    char*`，用于描述错误条件的性质。你可以通过`what`方法来获取这个消息，`what`方法不接受任何参数。
- en: The `Groucho` class in [Listing 4-8](ch04.xhtml#ch04ex08) throws an exception
    whenever you invoke the `forget` method with an argument equal to `0xFACE`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 4-8](ch04.xhtml#ch04ex08)中的`Groucho`类，每当你使用参数`0xFACE`调用`forget`方法时，它都会抛出异常。
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 4-8: The `Groucho` class*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-8：`Groucho`类*'
- en: To throw an exception, [Listing 4-8](ch04.xhtml#ch04ex08) uses the `throw` keyword
    ➊ followed by a `std::runtime_error` object ➋.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要抛出异常，[清单 4-8](ch04.xhtml#ch04ex08)使用`throw`关键字 ➊，后跟一个`std::runtime_error`对象
    ➋。
- en: '***Using try-catch Blocks***'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用`try`-`catch`块***'
- en: You use `try`-`catch` blocks to establish exception handlers for a block of
    code. Within the `try` block, you place code that might throw an exception. Within
    the `catch` block, you specify a handler for each exception type you can handle.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`try`-`catch`块来为一段代码建立异常处理程序。在`try`块内，放置可能抛出异常的代码。在`catch`块内，你指定一个处理程序来处理每种可以处理的异常类型。
- en: '[Listing 4-9](ch04.xhtml#ch04ex09) illustrates the use of a `try`-`catch` block
    to handle exceptions thrown by a `Groucho` object.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-9](ch04.xhtml#ch04ex09)演示了使用`try`-`catch`块来处理`Groucho`对象抛出的异常。'
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 4-9: The use of `try`-`catch` to handle the exceptions of the `Groucho`
    class*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-9：使用`try`-`catch`来处理`Groucho`类的异常*'
- en: 'In `main`, you construct a `Groucho` object and then establish a `try`-`catch`
    block ➊. Within the `try` portion, you invoke the `groucho` class’s `forget` method
    with several different parameters: `0xC0DE` ➋, `0xFACE` ➌, and `0xC0FFEE` ➍. Within
    the `catch` portion, you handle any `std::runtime_error` exceptions ➎ by printing
    the message to the console ➏.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`中，你构造了一个`Groucho`对象，并建立了一个`try`-`catch`块 ➊。在`try`部分，你调用了`groucho`类的`forget`方法，并传入了几个不同的参数：`0xC0DE`
    ➋、`0xFACE` ➌和`0xC0FFEE` ➍。在`catch`部分，你通过打印消息到控制台 ➏来处理任何`std::runtime_error`异常
    ➎。
- en: 'When you run the program in [Listing 4-9](ch04.xhtml#ch04ex09), you get the
    following output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行[清单 4-9](ch04.xhtml#ch04ex09)中的程序时，输出如下：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When you invoked `forget` with the argument `0xC0DE` ➋, `groucho` printed `Forgot
    0xc0de` and returned. When you invoked `forget` with the argument `0xFACE` ➌,
    `groucho` threw an exception. This exception stopped normal program execution,
    so `forget` is never invoked again ➍. Instead, the in-flight exception is caught
    ➎, and its message is printed ➏.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你用参数`0xC0DE` ➋调用`forget`时，`groucho`打印了`Forgot 0xc0de`并返回。当你用参数`0xFACE` ➌调用`forget`时，`groucho`抛出了异常。这个异常中断了正常的程序执行，因此`forget`再也没有被调用
    ➍。相反，正在处理中异常被捕获 ➎，并打印了它的消息 ➏。
- en: '**A CRASH COURSE IN INHERITANCE**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承的速成课程**'
- en: Before introducing the stdlib exceptions, you need to understand simple C++
    class inheritance at a very high level. Classes can have subclasses that inherit
    the functionality of their superclasses. The syntax in [Listing 4-10](ch04.xhtml#ch04ex10)
    defines this relationship.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍std库异常之前，你需要在一个非常高的层次上理解简单的C++类继承。类可以有子类，子类继承父类的功能。[清单4-10](ch04.xhtml#ch04ex10)中的语法定义了这种关系。
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 4-10: Defining superclasses and subclasses*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-10：定义超类和子类*'
- en: 'There’s nothing special about `Superclass`. But the declaration of `Subclass`
    ➊ is special. It defines the inheritance relationship using the : `Superclass`
    syntax. `Subclass` inherits members from `Superclass` that are not marked private.
    You can see this in action where `Subclass` uses the field x ➋. This is a field
    belonging to `Superclass`, but because `Subclass` inherits from Superclass, x
    is accessible.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Superclass`没有什么特别之处。但`Subclass`的声明 ➊ 是特殊的。它使用`: Superclass`语法定义了继承关系。`Subclass`继承了`Superclass`中未标记为私有的成员。你可以看到它的作用，`Subclass`使用字段x
    ➋。这个字段属于`Superclass`，但是由于`Subclass`继承自`Superclass`，所以x是可以访问的。'
- en: Exceptions use these inheritance relationships to determine whether a handler
    catches an exception. Handlers will catch a given type and any of its childrens’
    types.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 异常使用这些继承关系来判断一个处理程序是否捕获某个异常。处理程序将捕获给定类型及其任何子类型的异常。
- en: '***stdlib Exception Classes***'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***stdlib异常类***'
- en: You can arrange classes into parent-child relationships using *inheritance*.
    Inheritance has a big impact on how the code handles exceptions. There is a nice,
    simple hierarchy of existing exception types available for use in the stdlib.
    You should try to use these types for simple programs. Why reinvent the wheel?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用*继承*将类安排成父子关系。继承对代码如何处理异常有很大影响。std库提供了一个简洁明了的现有异常类型层次结构，供你使用。对于简单的程序，你应该尝试使用这些类型。为什么要重新发明轮子呢？
- en: '**Standard Exception Classes**'
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**标准异常类**'
- en: 'The stdlib provides you with the *standard exception classes* in the `<stdexcept>`
    header. These should be your first port of call when you’re programming exceptions.
    The superclass for all the standard exception classes is the class `std::exception`.
    All the subclasses in `std::exception` can be partitioned into three groups: logic
    errors, runtime errors, and language support errors. While language support errors
    are not generally relevant to you as a programmer, you’ll definitely encounter
    logic errors and runtime errors. [Figure 4-1](ch04.xhtml#ch04fig01) summarizes
    their relationship.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: std库在`<stdexcept>`头文件中为你提供了*标准异常类*。当你编程处理异常时，这些应该是你首先参考的内容。所有标准异常类的超类是`std::exception`类。`std::exception`中的所有子类可以分为三组：逻辑错误、运行时错误和语言支持错误。虽然语言支持错误通常与作为程序员的你无关，但你肯定会遇到逻辑错误和运行时错误。[图4-1](ch04.xhtml#ch04fig01)总结了它们之间的关系。
- en: '![image](../images/fig4_1.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig4_1.jpg)'
- en: '*Figure 4-1: How stdlib exceptions are nested under std::exception*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-1：std库异常如何嵌套在std::exception下*'
- en: '**Logic Errors**'
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**逻辑错误**'
- en: '*Logic errors* derive from the `logic_error` class. Generally, you could avoid
    these exceptions through more careful programming. A primary example is when a
    logical precondition of a class isn’t satisfied, such as when a class invariant
    cannot be established. (Remember from [Chapter 2](ch02.xhtml#ch02) that a class
    invariant is a feature of a class that is always true.)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*逻辑错误*源自`logic_error`类。一般来说，通过更小心的编程，你可以避免这些异常。一个主要的例子是，当一个类的逻辑前置条件未被满足时，例如当类的不变式无法建立时。（回想一下[第2章](ch02.xhtml#ch02)中提到的类不变式，它是类的一个特性，总是为真。）'
- en: Since a class invariant is something that the programmer defines, neither the
    compiler nor the runtime environment can enforce it without help. You can use
    a class constructor to check for various conditions, and if you cannot establish
    a class invariant, you can throw an exception. If the failure is the result of,
    say, passing an incorrect parameter to the constructor, a `logic_error` is an
    appropriate exception to throw.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类不变式是由程序员定义的，编译器和运行时环境无法在没有帮助的情况下强制执行它。你可以使用类构造函数检查各种条件，如果无法建立类的不变式，可以抛出异常。如果失败是由于例如传递给构造函数的参数不正确，则抛出`logic_error`是一个合适的选择。
- en: 'The `logic_error` has several subclasses that you should be aware of:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`logic_error`有几个子类，你需要了解它们：'
- en: The `domain_error` reports errors related to valid input range, especially for
    math functions. The square root, for example, only supports non-negative numbers
    (in the real case). If a negative argument is passed, a square root function could
    throw a `domain_error`.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domain_error`报告与有效输入范围相关的错误，特别是在数学函数中。例如，平方根函数只支持非负数（在实数情况下）。如果传递一个负数作为参数，平方根函数可能会抛出`domain_error`异常。'
- en: The `invalid_argument` exception reports generally unexpected arguments.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invalid_argument`异常报告一般性的无效参数。'
- en: The `length_error` exception reports that some action would violate a maximum
    size constraint.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length_error`异常报告某些操作会违反最大大小限制。'
- en: The `out_of_range` exception reports that some value isn’t in an expected range.
    The canonical example is bounds-checked indexing into a data structure.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`out_of_range`异常报告某个值不在预期的范围内。经典的例子是对数据结构进行边界检查的索引。'
- en: '**Runtime Errors**'
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**运行时错误**'
- en: '*Runtime errors* derive from the `runtime_error` class. These exceptions help
    you report error conditions that are outside the program’s scope. Like `logic_error`,
    `runtime_error` has some subclasses that you might find useful:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*运行时错误*派生自`runtime_error`类。这些异常帮助你报告程序范围外的错误条件。类似于`logic_error`，`runtime_error`也有一些子类，你可能会发现它们有用：'
- en: The `system_error` reports that the operating system encountered some error.
    You can get a lot of mileage out of this kind of exception. Inside of the `<system_error>`
    header, there’s a large number of *error codes* and *error conditions*. When a
    `system_error` is constructed, information about the error is packed in so you
    can determine the nature of the error. The `.code()` method returns an `enum class`
    of type `std::errc` that has a large number of values, such as `bad_file_descriptor`,
    `timed_out`, and `permission_denied`.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system_error`报告操作系统遇到错误。你可以从这种异常中获取很多信息。在`<system_error>`头文件中，有大量的*错误代码*和*错误条件*。当构造一个`system_error`时，关于错误的信息会被打包进去，便于你判断错误的性质。`.code()`方法返回一个类型为`std::errc`的`enum
    class`，它有大量的值，例如`bad_file_descriptor`、`timed_out`和`permission_denied`。'
- en: The `overflow_error` and `underflow_error` report arithmetic overflow and underflow,
    respectively.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`overflow_error`和`underflow_error`分别报告算术溢出和下溢错误。'
- en: Other errors inherit directly from `exception`. A common one is the `bad_alloc`
    exception, which reports that `new` failed to allocate the required memory for
    dynamic storage.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 其他错误直接继承自`exception`。一个常见的错误是`bad_alloc`异常，它报告`new`操作未能分配所需的动态存储内存。
- en: '**Language Support Errors**'
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**语言支持错误**'
- en: You won’t use language support errors directly. They exist to indicate that
    some core language feature failed at runtime.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会直接使用语言支持错误。它们存在的目的是表示某些核心语言特性在运行时失败。
- en: '***Handling Exceptions***'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***处理异常***'
- en: The rules for exception handling are based on class inheritance. When an exception
    is thrown, a `catch` block handles the exception if the thrown exception’s type
    matches the `catch` handler’s exception type or if the thrown exception’s type
    *inherits from* the `catch` handler’s exception type.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理的规则基于类继承。当异常被抛出时，如果抛出的异常类型与`catch`处理程序的异常类型匹配，或者抛出的异常类型*继承自*`catch`处理程序的异常类型，`catch`块就会处理该异常。
- en: 'For example, the following handler catches any exception that inherits from
    `std::exception`, including a `std::logic_error`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下处理程序捕获任何继承自`std::exception`的异常，包括`std::logic_error`：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following special handler catches *any* exception regardless of its type:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下特殊处理程序捕获*任何*异常，不论其类型：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Special handlers are typically used as a safety mechanism to log the program’s
    catastrophic failure to catch an exception of a specific type.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的处理程序通常作为安全机制，用于记录程序因未能捕获特定类型异常而导致的灾难性失败。
- en: 'You can handle different types of exceptions originating from the same `try`
    block by chaining together `catch` statements, as demonstrated here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将多个`catch`语句链在一起，处理来自同一`try`块的不同类型异常，如下所示：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It’s common to see such code in a program’s entry point.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的入口点中常见这样的代码。
- en: '**RETHROWING AN EXCEPTION**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**重新抛出异常**'
- en: In a `catch` block, you can use the throw keyword to resume searching for an
    appropriate exception handler. This is called rethrowing an exception. There are
    some unusual but important cases where you might want to further inspect an exception
    before deciding to handle it, as shown in [Listing 4-11](ch04.xhtml#ch04ex11).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在`catch`块中，你可以使用throw关键字继续查找合适的异常处理程序。这被称为重新抛出异常。有一些不寻常但重要的情况，你可能想在决定如何处理异常之前进一步检查它，如[Listing
    4-11](ch04.xhtml#ch04ex11)所示。
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 4-11: Rethrowing an error*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-11：重新抛出错误*'
- en: In this example, some code that might throw a `system_error` is wrapped in a
    `try-catch` block. All `system_errors` are handled, but unless it’s an `EACCES
    (permission denied)` error, you rethrow the exception ➊ There are some performance
    penalties to this approach, and the resulting code is often needlessly convoluted.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，可能抛出`system_error`的代码被包装在`try-catch`块中。所有的`system_error`都被处理，但除非是`EACCES
    (权限被拒绝)`错误，否则你会重新抛出异常 ➊。这种方法会带来一些性能损失，且最终的代码通常不必要地复杂。
- en: Rather than rethrowing, you can define a new exception type and create a separate
    `catch` handler for the `EACCES` error, as demonstrated in [Listing 4-12](ch04.xhtml#ch04ex12).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义一个新的异常类型，而不是重新抛出异常，并为`EACCES`错误创建一个单独的`catch`处理程序，如[Listing 4-12](ch04.xhtml#ch04ex12)所示。
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 4-12: Catching a specific exception rather than rethrowing*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-12：捕获特定异常而非重新抛出*'
- en: If a `std::system_error` is thrown, the `PermissionDenied` handler ➊ won’t catch
    it. (Of course, you could still keep the `std::system_error` handler to catch
    such exceptions if you wish.)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出`std::system_error`，`PermissionDenied`处理程序 ➊将不会捕获它。（当然，如果你愿意，仍然可以保留`std::system_error`处理程序来捕获此类异常。）
- en: '***User-Defined Exceptions***'
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***用户定义的异常***'
- en: You can define your own exceptions whenever you’d like; usually, these *user-defined
    exceptions* inherit from `std::exception`. All the classes from stdlib use exceptions
    that derive from `std::exception`. This makes it easy to catch all exceptions,
    whether from your code or from the stdlib, with a single `catch` block.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时定义自己的异常；通常，这些*用户定义的异常*继承自`std::exception`。std库中的所有类使用的是从`std::exception`派生的异常类型。这使得你可以使用一个`catch`块捕获所有异常，无论是来自你的代码还是std库。
- en: '***The noexcept Keyword***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***noexcept关键字***'
- en: 'The keyword `noexcept` is another exception-related term you should know. You
    can, and should, mark any function that cannot possibly throw an exception `noexcept`,
    as in the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`noexcept`是另一个与异常相关的术语，你应该了解它。你可以并且应该标记任何不可能抛出异常的函数为`noexcept`，如下所示：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Functions marked `noexcept` make a rigid contract. When you’re using a function
    marked `noexcept`, you can rest assured that the function cannot throw an exception.
    In exchange, you must be extremely careful when you mark your own function `noexcept`,
    since the compiler won’t check for you. If your code throws an exception inside
    a function marked `noexcept`, it’s bad juju. The C++ runtime will call the function
    `std::terminate`, a function that by default will exit the program via `abort`.
    Your program cannot recover:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 被标记为`noexcept`的函数具有严格的契约。当你使用标记为`noexcept`的函数时，你可以放心，它不能抛出异常。作为交换，你必须在标记自己的函数为`noexcept`时格外小心，因为编译器不会为你检查。如果你的代码在标记为`noexcept`的函数中抛出异常，那就非常糟糕。C++运行时将调用`std::terminate`函数，默认情况下会通过`abort`退出程序。你的程序无法恢复：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Marking a function `noexcept` enables some code optimizations that rely on the
    function’s not being able to throw an exception. Essentially, the compiler is
    liberated to use move semantics, which may be faster (more about this in “Move
    Semantics” on [page 122](ch04.xhtml#page_122)).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 标记一个函数为`noexcept`可以启用一些依赖于函数无法抛出异常的代码优化。实质上，编译器可以使用移动语义，这可能会更快（更多内容请参见“移动语义”部分，[第122页](ch04.xhtml#page_122)）。
- en: '**NOTE**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Check out Item 14 of Effective Modern C++ by Scott Meyers for a thorough discussion
    of `noexcept`. The gist is that some move constructors and move assignment operators
    might throw an exception, for example, if they need to allocate memory and the
    system is out. Unless a move constructor or move assignment operator specifies
    otherwise, the compiler must assume that a move could cause an exception. This
    disables certain optimizations.*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*查看Scott Meyers的《Effective Modern C++》第14条，详细讨论`noexcept`。核心思想是，有些移动构造函数和移动赋值操作符可能会抛出异常，例如，如果它们需要分配内存，而系统内存不足。除非移动构造函数或移动赋值操作符另有说明，否则编译器必须假设移动操作可能会导致异常。这会禁用某些优化。*'
- en: '***Call Stacks and Exceptions***'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***调用栈与异常***'
- en: The *call stack* is a runtime structure that stores information about active
    functions. When a piece of code (the *caller*) invokes a function (the *callee*),
    the machine keeps track of who called whom by pushing information onto the call
    stack. This allows programs to have many function calls nested within each other.
    The callee could then, in turn, become the caller by invoking another function.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用栈* 是一个运行时结构，存储有关活动函数的信息。当一段代码（*调用者*）调用一个函数（*被调用者*）时，机器通过将信息压入调用栈来跟踪谁调用了谁。这允许程序有许多相互嵌套的函数调用。被调用者随后可以通过调用另一个函数，反过来成为调用者。'
- en: '**Stacks**'
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**栈**'
- en: 'A stack is a flexible data container that can hold a dynamic number of elements.
    There are two essential operations that all stacks support: *pushing* elements
    onto the top of the stack and *popping* those elements off. It is a last-in, first-out
    data structure, as illustrated in [Figure 4-2](ch04.xhtml#ch04fig02).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一个灵活的数据容器，可以容纳动态数量的元素。所有栈都支持两个基本操作：*压入* 元素到栈顶和 *弹出* 这些元素。它是一个后进先出（LIFO）数据结构，如
    *[图 4-2](ch04.xhtml#ch04fig02)* 所示。
- en: '![image](../images/fig4_2.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig4_2.jpg)'
- en: '*Figure 4-2: Elements being pushed onto and popped off of a stack*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-2：元素被压入和弹出栈的过程*'
- en: As its name suggests, the call stack is functionally similar to its namesake
    data container. Each time a function is invoked, information about the function
    invocation is arranged into a *stack frame* and pushed onto the call stack. Because
    a new stack frame is pushed onto the stack for every function call, a callee is
    free to call other functions, forming arbitrarily deep call chains. Whenever a
    function returns, its stack frame is popped off the top of the call stack, and
    execution control resumes as indicated by the previous stack frame.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名字所示，调用栈在功能上类似于同名的数据容器。每次调用一个函数时，关于该函数调用的信息会被安排成一个 *栈帧* 并压入调用栈。由于每次函数调用都会将一个新的栈帧压入栈中，被调用者可以自由地调用其他函数，形成任意深度的调用链。每当一个函数返回时，它的栈帧会从调用栈的顶部弹出，执行控制权将恢复到上一个栈帧所指示的位置。
- en: '**Call Stacks and Exception Handling**'
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**调用栈与异常处理**'
- en: The runtime seeks the closest exception handler to a thrown exception. If there
    is a matching exception handler in the current stack frame, it will handle the
    exception. If no matching handler is found, the runtime will unwind the call stack
    until it finds a suitable handler. Any objects whose lifetimes end are destroyed
    in the usual way.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时会寻找离抛出的异常最近的异常处理程序。如果当前栈帧中有匹配的异常处理程序，它将处理该异常。如果没有找到匹配的处理程序，运行时会展开调用栈，直到找到一个合适的处理程序。任何生命周期结束的对象都会按常规方式销毁。
- en: '**Throwing in Destructors**'
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在析构函数中抛出异常**'
- en: If you throw an exception in a destructor, you are juggling with chainsaws.
    Such an exception absolutely must be caught within the destructor.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在析构函数中抛出异常，那么你就像在玩链锯。这类异常必须在析构函数内部被捕获。
- en: Suppose an exception is thrown, and during stack unwinding, another exception
    is thrown by a destructor during normal cleanup. Now you have *two* exceptions
    in flight. How should the C++ runtime handle such a situation?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 假设抛出了一个异常，在展开栈的过程中，析构函数在正常清理时抛出了另一个异常。现在你就有了 *两个* 正在发生的异常。C++ 运行时应该如何处理这种情况？
- en: 'You can have an opinion on the matter, but the runtime will call `terminate`.
    Consider [Listing 4-13](ch04.xhtml#ch04ex13), which illustrates what can happen
    when you throw an exception from a destructor:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对这个问题有自己的看法，但运行时会调用 `terminate`。考虑 *[列表 4-13](ch04.xhtml#ch04ex13)*，它演示了当你从析构函数抛出异常时可能发生的情况：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 4-13: A program illustrating the perils of throwing an exception within
    a destructor*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-13：一个程序，演示了在析构函数中抛出异常的危险性*'
- en: '**NOTE**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*[Listing 4-13](ch04.xhtml#ch04ex13) calls `std::terminate`, so depending on
    your environment, you might get a nasty pop-up indicating this.*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*[列表 4-13](ch04.xhtml#ch04ex13) 调用了 `std::terminate`，因此根据你的环境，你可能会看到一个讨厌的弹窗提示。*'
- en: First, you declare the `CyberdyneSeries800` class, which has a simple constructor
    that prints a message ➊ and a thoroughly belligerent destructor that throws an
    uncaught exception ➋. Within `main`, you set up a `try` block where you initialize
    a `CyberdyneSeries800` called `t800` ➌ and throw a `runtime_error` ➍. Under better
    circumstances, the `catch` block ➎ would handle this exception, print its message
    ➏, and exit gracefully. Because `t800` is an automatic variable within the `try`
    block, it destructs during the normal process of finding a handler for the exception
    you’ve thrown ➍. And because `t800` throws an exception in its destructor ➋, your
    program invokes `std::terminate` and ends abruptly.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你声明了`CyberdyneSeries800`类，它有一个简单的构造函数，打印一条消息➊，还有一个彻底好斗的析构函数，抛出一个未捕获的异常➋。在`main`中，你设置了一个`try`块，其中初始化了一个名为`t800`的`CyberdyneSeries800`对象➌，并抛出了一个`runtime_error`异常➍。在更好的情况下，`catch`块➎会处理这个异常，打印其消息➏，并优雅地退出。因为`t800`是`try`块中的自动变量，它会在查找异常处理程序的正常过程中被析构➒。由于`t800`在其析构函数中抛出了异常➋，你的程序调用了`std::terminate`并突然结束。
- en: As a general rule, treat destructors as if they were `noexcept`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，将析构函数视为`noexcept`。
- en: '**A SimpleString Class**'
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**一个SimpleString类**'
- en: Using an extended example, let’s explore how constructors, destructors, members,
    and exceptions gel together. The `SimpleString` class in [Listing 4-14](ch04.xhtml#ch04ex14)
    allows you to add C-style strings together and print the result.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个扩展的示例，让我们探索构造函数、析构函数、成员和异常如何协同工作。[示例 4-14](ch04.xhtml#ch04ex14)中的`SimpleString`类允许你将C风格的字符串连接起来，并打印结果。
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 4-14: The constructor and destructor of a `SimpleString` class*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 4-14：`SimpleString`类的构造函数和析构函数*'
- en: The constructor ➊ takes a single `max_size` argument. This is the maximum length
    of your string, which includes a null terminator. The member initializer ➋ saves
    this length into the `max_size` member variable. This value is also used in the
    array new expression to allocate a buffer to store your string ➎. The resulting
    pointer is stored into `buffer`. You initialize length to zero ➌ and ensure that
    there is at least enough size for a null byte ➍. Because the string is initially
    empty, you assign the first byte of the buffer to zero ➏.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数➊接受一个`max_size`参数。这个值是你的字符串的最大长度，包括一个空字符终止符。成员初始化器➋将这个长度保存到`max_size`成员变量中。这个值还用于数组new表达式来分配一个缓冲区，用于存储你的字符串➎。得到的指针被存储在`buffer`中。你将长度初始化为零➌，并确保至少为一个空字节分配足够的大小➍。由于字符串最初是空的，你将缓冲区的第一个字节赋值为零➏。
- en: '**NOTE**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Because `max_size` is a `size_t`, it is unsigned and cannot be negative, so
    you don’t need to check for this bogus condition.*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*因为`max_size`是一个`size_t`，它是无符号的，不能为负数，所以你不需要检查这个虚假的条件。*'
- en: The `SimpleString` class owns a resource—the memory pointed to by `buffer`—which
    must be released when it’s no longer needed. The destructor contains a single
    line ➐ that deallocates `buffer`. Because you’ve paired the allocation and deallocation
    of `buffer` with the constructor and destructor of `SimpleString`, you’ll never
    leak the storage.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleString`类拥有一个资源——由`buffer`指向的内存——当不再需要时，必须释放。析构函数包含一行代码➐，用于释放`buffer`。因为你已经将`buffer`的分配和释放与`SimpleString`的构造函数和析构函数配对，所以你永远不会泄露存储。'
- en: This pattern is called *resource acquisition is initialization (RAII)* or *constructor
    acquires, destructor releases (CADRe)*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式称为*资源获取即初始化（RAII）*或*构造函数获取，析构函数释放（CADRe）*。
- en: '**NOTE**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The `SimpleString` class still has an implicitly defined copy constructor.
    Although it might never leak the storage, it will potentially double free if copied.
    You’ll learn about copy constructors in “Copy Semantics” on [page 115](ch04.xhtml#page_115).
    Just be aware that [Listing 4-14](ch04.xhtml#ch04ex14) is a teaching tool, not
    production-worthy code.*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*`SimpleString`类仍然有一个隐式定义的拷贝构造函数。尽管它可能永远不会泄露存储，但如果被拷贝，它可能会导致双重释放。你将在“拷贝语义”章节中学习拷贝构造函数，见[第115页](ch04.xhtml#page_115)。只需注意，[示例
    4-14](ch04.xhtml#ch04ex14)是一个教学工具，而不是生产级的代码。*'
- en: '***Appending and Printing***'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***追加和打印***'
- en: The `SimpleString` class isn’t of much use yet. [Listing 4-15](ch04.xhtml#ch04ex15)
    adds the ability to print the string and append a line to the end of the string.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleString`类还不太有用。[示例 4-15](ch04.xhtml#ch04ex15)添加了打印字符串和向字符串末尾追加一行的功能。'
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 4-15: The `print` and `append_line` methods of `SimpleString`*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 4-15：`SimpleString`的`print`和`append_line`方法*'
- en: The first method `print` ➊ prints your string. For convenience, you can provide
    a `tag` string so you can match an invocation of `print` with the result. This
    method is `const` because it doesn’t need to modify the state of a `SimpleString`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法`print` ➊打印你的字符串。为方便起见，你可以提供一个`tag`字符串，这样你就能将`print`的调用与结果对应起来。这个方法是`const`的，因为它不需要修改`SimpleString`的状态。
- en: 'The `append_line` method ➋ takes a null-terminated string `x` and adds its
    contents—plus a newline character—to `buffer`. It returns `true` if `x` was successfully
    appended and `false` if there wasn’t enough space. First, `append_line` must determine
    the length of `x`. For this, you employ the `strlen` function ➌ from the `<cstring>`
    header, which accepts a null-terminated string and returns its length:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`append_line`方法 ➋接受一个以空字符结尾的字符串`x`，并将其内容——加上一个换行符——追加到`buffer`中。如果`x`成功追加，返回`true`；如果空间不足，则返回`false`。首先，`append_line`必须确定`x`的长度。为此，你使用`<cstring>`头文件中的`strlen`函数
    ➌，该函数接受一个以空字符结尾的字符串并返回其长度：'
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You use `strlen` to compute the length of `x` and initialize `x_len` with the
    result. This result is used to compute whether appending `x` (a newline character)
    and a null byte to the current string would result in a string with length greater
    than `max_size` ➍. If it would, `append_line` returns `false`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`strlen`来计算`x`的长度，并用结果初始化`x_len`。这个结果用于计算将`x`（一个换行符）和一个空字节追加到当前字符串后是否会导致字符串长度超过`max_size`
    ➍。如果会，`append_line`返回`false`。
- en: 'If there is enough room to append `x`, you need to copy its bytes into the
    correct location in `buffer`. The `std::strncpy` function ➎ from the `<cstring>`
    header is one possible tool for this job. It accepts three arguments: the `destination`
    address, the `source` address, and the `num` of characters to copy:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有足够的空间追加`x`，你需要将它的字节复制到`buffer`中的正确位置。`std::strncpy`函数 ➎（来自`<cstring>`头文件）是完成此工作的一个可能工具。它接受三个参数：`destination`地址、`source`地址和要复制的字符数`num`：
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `strncpy` function will copy up to `num` bytes from `source` into `destination`.
    Once complete, it will return `destination` (which you discard).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`strncpy`函数会将最多`num`个字节从`source`复制到`destination`中。复制完成后，它将返回`destination`（你会丢弃这个返回值）。'
- en: After adding the number of bytes `x_len` copied into `buffer` to `length`, you
    finish by adding a newline character `\n` and a null byte to the end of `buffer`.
    You return `true` to indicate that you’ve successfully appended the input `x`
    as a line to the end of `buffer`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在将复制到`buffer`中的字节数`x_len`加到`length`后，你通过在`buffer`末尾添加换行符`\n`和空字节来完成操作。你返回`true`以表明已成功将输入`x`作为一行追加到`buffer`末尾。
- en: '**WARNING**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Use `strncpy` very carefully. It’s too easy to forget the null-terminator
    in the `source` string or not allocate enough space in the `destination` string.
    Both errors will cause undefined behavior. We’ll cover a safer alternative in
    [Part II](part02.xhtml#part02) of the book.*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*请非常小心使用`strncpy`。很容易忘记在`source`字符串中添加空字符，或者在`destination`字符串中分配不够的空间。这两种错误都会导致未定义的行为。我们将在本书的[第二部分](part02.xhtml#part02)中介绍一个更安全的替代方案。*'
- en: '***Using SimpleString***'
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用SimpleString***'
- en: '[Listing 4-16](ch04.xhtml#ch04ex16) illustrates an example use of `SimpleString`
    where you append several strings and print intermediate results to the console.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-16](ch04.xhtml#ch04ex16)展示了一个使用`SimpleString`的示例，你可以在其中追加多个字符串并打印中间结果到控制台。'
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 4-16: The methods of `SimpleString`*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-16：`SimpleString`的方法*'
- en: First, you create a `SimpleString` with `max_length=115` ➊. You use the `append_line`
    method twice ➋ to add some data to `string` and then print the contents along
    with the tag `A` ➌. You then append more text ➍ and print the contents again,
    this time with the tag `B` ➎. When `append_line` determines that `SimpleString`
    has run out of space ➏, it returns `false` ➐. (It’s your responsibility as a user
    of `SimpleString` to check for this condition.)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个`SimpleString`，其`max_length=115` ➊。你使用`append_line`方法两次 ➋将一些数据添加到`string`中，然后打印内容并附上标签`A`
    ➌。接着你追加更多的文本 ➍并再次打印内容，这次附上标签`B` ➎。当`append_line`判断`SimpleString`已经没有足够的空间 ➏时，它返回`false`
    ➐。（作为`SimpleString`的用户，检查这种情况是你的责任。）
- en: '[Listing 4-17](ch04.xhtml#ch04ex17) contains output from running this program.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-17](ch04.xhtml#ch04ex17)包含了运行该程序的输出结果。'
- en: '[PRE32]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 4-17: Output from running the program in [Listing 4-16](ch04.xhtml#ch04ex16)*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-17：运行[列表 4-16](ch04.xhtml#ch04ex16)中的程序输出结果*'
- en: As expected, the string contains `Starbuck, whaddya hear?\nNothin' but the rain.\n`
    at `A` ➊. (Recall from [Chapter 2](ch02.xhtml#ch02) that `\n` is the newline special
    character.) After appending `Grab your gun and bring the cat in.` and `Aye-aye
    sir, coming home.`, you get the expected output at `B` ➋.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，字符串在 `A` ➊ 处包含 `Starbuck, whaddya hear?\nNothin' but the rain.\n`。（回想一下
    [第2章](ch02.xhtml#ch02)，`\n` 是换行符。）在附加了 `Grab your gun and bring the cat in.` 和
    `Aye-aye sir, coming home.` 后，您会在 `B` ➋ 处得到预期的输出。
- en: When [Listing 4-17](ch04.xhtml#ch04ex17) tries to append `Galactica!` to `string`,
    `append_line` returns `false` because there is not enough space in `buffer`. This
    causes the message `String was not big enough to append another message` to print
    ➌.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当 [Listing 4-17](ch04.xhtml#ch04ex17) 尝试将 `Galactica!` 附加到 `string` 时，`append_line`
    返回 `false`，因为 `buffer` 中没有足够的空间。这导致打印出消息 `String was not big enough to append
    another message` ➌。
- en: '***Composing a SimpleString***'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***组合一个 SimpleString***'
- en: Consider what happens when you define a class with a `SimpleString` member,
    as demonstrated in [Listing 4-18](ch04.xhtml#ch04ex18).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在 [Listing 4-18](ch04.xhtml#ch04ex18) 中演示的，当你定义一个包含 `SimpleString` 成员的类时，会发生什么。
- en: '[PRE33]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 4-18: The implementation of `SimpleStringOwner`*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-18: `SimpleStringOwner` 的实现*'
- en: 'As suggested by the member initializer ➊, `string` is fully constructed, and
    its class invariants are established once the constructor of `SimpleStringOwner`
    executes. This illustrates the order of an object’s members during construction:
    *members are constructed before the enclosing object’s constructor*. This makes
    sense: how can you establish a class’s invariants if you don’t know about its
    members’ invariants?'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如成员初始化器➊所示，`string` 在 `SimpleStringOwner` 的构造函数执行后完全构造，并且其类的不变式已建立。这说明了对象成员在构造过程中的顺序：*成员在封闭对象的构造函数之前被构造*。这很有道理：如果你不了解成员的不变式，怎么能确立类的不变式呢？
- en: Destructors work the opposite way. Inside `~SimpleStringOwner()` ➋, you need
    the class invariants of `string` to hold so you can print its contents. *All members
    are destructed after the object’s destructor is invoked.*
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数的工作方式恰好相反。在 `~SimpleStringOwner()` ➋ 中，你需要确保 `string` 的类不变式成立，这样你才能打印其内容。*所有成员在对象的析构函数被调用后才会被析构*。
- en: '[Listing 4-19](ch04.xhtml#ch04ex19) exercises a `SimpleStringOwner`.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 4-19](ch04.xhtml#ch04ex19) 演示了 `SimpleStringOwner` 的使用。'
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 4-19: A program containing a `SimpleStringOwner`*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-19: 一个包含 `SimpleStringOwner` 的程序*'
- en: 'As expected, the member `string` of `x` is created appropriately because *an
    object’s member constructors are called before the object’s constructor*, resulting
    in the message `Constructed: x` ➊. As an automatic variable, `x` is destroyed
    just before `main` returns, and you get `About to destroy: x` ➋. The member `string`
    is still valid at this point because member destructors are called after the enclosing
    object’s destructor.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '如预期的那样，`x` 的成员 `string` 被适当地创建，因为 *对象的成员构造函数在对象的构造函数之前被调用*，因此输出消息 `Constructed:
    x` ➊。作为自动变量，`x` 会在 `main` 返回之前销毁，你会看到 `About to destroy: x` ➋。此时，成员 `string` 仍然有效，因为成员析构函数在封闭对象的析构函数之后被调用。'
- en: '***Call Stack Unwinding***'
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***调用栈展开***'
- en: '[Listing 4-20](ch04.xhtml#ch04ex20) demonstrates how exception handling and
    stack unwinding work together. You establish a `try`-`catch` block in `main` and
    then make a series of function calls. One of these calls causes an exception.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 4-20](ch04.xhtml#ch04ex20) 演示了异常处理和栈展开是如何协同工作的。你在 `main` 中建立了一个 `try`-`catch`
    块，然后进行了一系列的函数调用，其中一个调用导致了异常。'
- en: '[PRE35]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 4-20: A program illustrating the use of `SimpleStringOwner` and call
    stack unwinding*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-20: 一个演示如何使用 `SimpleStringOwner` 和调用栈展开的程序*'
- en: '[Listing 4-21](ch04.xhtml#ch04ex21) shows the results of running the program
    in [Listing 4-20](ch04.xhtml#ch04ex20).'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 4-21](ch04.xhtml#ch04ex21) 显示了运行 [Listing 4-20](ch04.xhtml#ch04ex20)
    程序的结果。'
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 4-21: Output from running the program in [Listing 4-20](ch04.xhtml#ch04ex20)*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-21: 运行 [Listing 4-20](ch04.xhtml#ch04ex20) 程序的输出*'
- en: 'You’ve set up a `try`-`catch` block ➌. The first `SimpleStringOwner`, `a`,
    gets constructed without incident, and you see `Constructed: a` printed to the
    console. Next, `fn_b` is called ➍. Notice that you’re still in the `try`-`catch`
    block, so any `exception` that gets thrown *will* be handled. Inside `fn_b`, another
    `SimpleString Owner`, `b`, gets constructed successfully, and `Constructed: b`
    is printed to the console. Next, there’s a call into yet another function, `fn_c`
    ➋.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '你已经设置了一个 `try`-`catch` 块 ➌。第一个 `SimpleStringOwner`，`a`，成功构造并且你看到 `Constructed:
    a` 被打印到控制台。接着，调用了 `fn_b` ➍。注意，你仍然在 `try`-`catch` 块中，因此任何抛出的 `exception` 都*会*被处理。在
    `fn_b` 中，另一个 `SimpleStringOwner`，`b`，成功构造，且 `Constructed: b` 被打印到控制台。接着，又调用了另一个函数
    `fn_c` ➋。'
- en: 'Let’s pause for a moment to take an account of what the call stack looks like,
    what objects are alive, and what the exception-handling situation looks like.
    You have two `SimpleStringOwner` objects alive and valid: `a` and `b`. The call
    stack looks like `main() → fn_b() → fn_c()`, and you have an exception handler
    set up inside `main` to handle any exceptions. [Figure 4-3](ch04.xhtml#ch04fig03)
    summarizes this situation.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂停一下，看看调用栈的样子，哪些对象仍然存活，异常处理情况如何。你有两个 `SimpleStringOwner` 对象存活且有效：`a` 和 `b`。调用栈的情况是
    `main() → fn_b() → fn_c()`，并且你在 `main` 中设置了异常处理器来处理任何异常。[图 4-3](ch04.xhtml#ch04fig03)
    总结了这种情况。
- en: At ➊, you run into a little problem. Recall that `SimpleStringOwner` has a member
    `SimpleString` that is always initialized with a `max_size` of 10\. When you try
    to construct `c`, the constructor of `SimpleStringOwner` throws an `exception`
    because you’ve tried to append `"cccccccccc"`, which has length 10 and is too
    big to fit alongside a newline and a null terminator.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，你遇到了一个小问题。回想一下，`SimpleStringOwner` 有一个成员 `SimpleString`，它的 `max_size`
    始终初始化为 10。当你尝试构造 `c` 时，`SimpleStringOwner` 的构造函数抛出了一个 `exception`，因为你试图附加 `"cccccccccc"`，它的长度是
    10，且太大，无法与换行符和空字符一起放入。
- en: 'Now you have an exception in flight. The stack will unwind until an appropriate
    handler is found, and all objects that fall out of scope as a result of this unwinding
    will be destructed. The handler is all the way up the stack ➏, so `fn_c` and `fn_b`
    unwind. Because `SimpleStringOwner b` is an automatic variable in `fn_b`, it gets
    destructed and you see `About to destroy: b` printed to the console. After `fn_b`,
    the automatic variables inside `try{}` are destroyed. This includes `SimpleStringOwner
    a`, so you see `About to destroy: a` printed to the console.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，异常正在飞行中。栈将会展开，直到找到合适的处理程序，所有由于此展开而超出作用域的对象都会被销毁。处理程序位于栈的最上方 ➏，因此 `fn_c`
    和 `fn_b` 会被展开。由于 `SimpleStringOwner b` 是 `fn_b` 中的自动变量，它会被销毁，且你会看到 `About to destroy:
    b` 被打印到控制台。在 `fn_b` 之后，`try{}` 中的自动变量会被销毁。这包括 `SimpleStringOwner a`，因此你会看到 `About
    to destroy: a` 被打印到控制台。'
- en: '![image](../images/fig4_3.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig4_3.jpg)'
- en: '*Figure 4-3: The call stack when `fn_c` calls the constructor of `SimpleStringOwner
    c`*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-3: 当 `fn_c` 调用 `SimpleStringOwner c` 的构造函数时的调用栈*'
- en: 'Once an exception occurs in a `try{}` block, no further statements execute.
    As a result, `d` never initializes ➎, and you never see the constructor of `d`
    print to console. After the call stack is unwound, execution proceeds immediately
    to the `catch` block. In the end, you print the message `Exception: Not enough
    memory!` to the console ➏.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦在 `try{}` 块中发生异常，后续语句将不再执行。因此，`d` 永远不会被初始化 ➎，你也不会看到 `d` 的构造函数打印到控制台。在调用栈被展开后，执行会立即转到
    `catch` 块。最终，你会将 `Exception: Not enough memory!` 的消息打印到控制台 ➏。'
- en: '***Exceptions and Performance***'
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***异常与性能***'
- en: 'In your programs, you must handle errors; errors are unavoidable. When you
    use exceptions correctly and no errors occur, your code is faster than manually
    error-checked code. If an error does occur, exception handling can sometimes be
    slower, but you make huge gains in robustness and maintainability over the alternative.
    Kurt Guntheroth, the author of *Optimized C++*, puts it well: “use of exception
    handling leads to programs that are faster when they execute normally, and better
    behaved when they fail.” When a C++ program executes normally (without exceptions
    being thrown), there is no runtime overhead associated with checking exceptions.
    It’s only when an exception is thrown that you pay overhead.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的程序中，你必须处理错误；错误是不可避免的。当你正确使用异常且没有发生错误时，你的代码比手动进行错误检查的代码更快。如果发生错误，异常处理有时可能会更慢，但相较于替代方案，你在程序的健壮性和可维护性上会获得巨大的提升。*《优化
    C++》*的作者库尔特·冈瑟罗斯说得好：“使用异常处理会让程序在正常执行时更快，在失败时表现得更好。”当 C++ 程序正常执行时（没有抛出异常），检查异常不会带来运行时开销。只有在抛出异常时，你才会支付额外的开销。
- en: Hopefully, you’re convinced of the central role exceptions play in idiomatic
    C++ programs. Sometimes, unfortunately, you won’t be able to use exceptions. One
    example is embedded development where real-time guarantees are required. Tools
    simply don’t (yet) exist in this setting. With luck, this will change soon, but
    for now, you’re stuck without exceptions in most embedded contexts. Another example
    is with some legacy code. Exceptions are elegant because of how they fit in with
    RAII objects. When destructors are responsible for cleaning up resources, stack
    unwinding is a direct and effective way to guarantee against resource leakages.
    In legacy code, you might find manual resource management and error handling instead
    of RAII objects. This makes using exceptions very dangerous, because stack unwinding
    is safe only with RAII objects. Without them, you could easily leak resources.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你已经认识到异常在惯用 C++ 程序中的核心作用。不幸的是，有时你可能无法使用异常。一个例子是嵌入式开发，那里需要实时保证。在这种情况下，工具（目前）根本不存在。幸运的话，这种情况很快会有所改变，但目前，在大多数嵌入式环境中，你只能在没有异常的情况下工作。另一个例子是一些遗留代码。异常因为它们与
    RAII 对象的结合方式而显得非常优雅。当析构函数负责清理资源时，堆栈展开是确保资源不会泄漏的直接有效方式。在遗留代码中，你可能会发现手动资源管理和错误处理，而不是使用
    RAII 对象。这使得使用异常非常危险，因为堆栈展开只有在 RAII 对象存在时才是安全的。没有它们，你可能会轻易泄漏资源。
- en: '***Alternatives to Exceptions***'
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***异常的替代方案***'
- en: 'In situations where exceptions are not available, all is not lost. Although
    you’ll need to keep track of errors manually, there are some helpful C++ features
    that you can employ to take the sting out a bit. First, you can manually enforce
    class invariants by exposing some method that communicates whether the class invariants
    could be established, as shown here:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在无法使用异常的情况下，并非一切都失去希望。尽管你需要手动跟踪错误，但仍有一些有用的 C++ 特性可以帮助你稍微减轻负担。首先，你可以通过暴露一些方法来手动强制类的不变性，从而传达是否能够建立类的不变性，示例如下：
- en: '[PRE37]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In idiomatic C++, you would just throw an exception in the constructor, but
    here you must remember to check and treat the situation as an error condition
    in your calling code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在惯用的 C++ 编程中，你可能会在构造函数中直接抛出异常，但在这里，你必须记得在调用代码中检查并将这种情况视为错误条件来处理：
- en: '[PRE38]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The second, complementary coping strategy is to return multiple values using
    *structured binding declaration*, a language feature that allows you to return
    multiple values from a function call. You can use this feature to return success
    flags alongside the usual return value, as demonstrated in [Listing 4-22](ch04.xhtml#ch04ex22).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种补充的应对策略是使用 *结构化绑定声明* 来返回多个值，这是一个语言特性，允许你从函数调用中返回多个值。你可以利用这个特性来返回成功标志和通常的返回值，如
    [列表 4-22](ch04.xhtml#ch04ex22) 中所示。
- en: '[PRE39]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 4-22: A code segment illustrating structured binding declaration*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-22：展示结构化绑定声明的代码片段*'
- en: First, you declare a POD that contains a `HumptyDumpty` and a `success` flag
    ➊. Next, you define the function `make_humpty` ➋, which builds and validates a
    `HumptyDumpty`. Such methods are called *factory methods*, because their purpose
    is to initialize objects. The `make_humpty` function packs this and the success
    flag into a `Result` when it returns. The syntax at the call site ➌ illustrates
    how you can unpack the `Result` into multiple, `auto`-type-deduced variables.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声明一个包含`HumptyDumpty`和`success`标志的POD ➊。接下来，定义函数`make_humpty` ➋，该函数构建并验证一个`HumptyDumpty`。此类方法被称为*工厂方法*，因为它们的目的是初始化对象。`make_humpty`函数将该对象和成功标志打包成一个`Result`并返回。调用站点的语法
    ➌ 演示了如何将`Result`解包成多个由`auto`类型推导的变量。
- en: '**NOTE**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You’ll explore structured bindings in more detail in “Structured Bindings”
    on [page 222](ch08.xhtml#page_222).*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*你将在“结构绑定”章节中更详细地了解结构绑定，参见[第222页](ch08.xhtml#page_222)。*'
- en: '**Copy Semantics**'
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**复制语义**'
- en: '*Copy semantics* is “the meaning of copy.” In practice, programmers use the
    term to mean the rules for making copies of objects: after `x` is *copied into*
    `y`, they’re *equivalent* and *independent*. That is, `x == y` is true after a
    copy (equivalence), and a modification to `x` doesn’t cause a modification of
    `y` (independence).'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*复制语义*是“复制的含义”。在实践中，程序员使用这个术语来表示复制对象的规则：在`x`被*复制到*`y`之后，它们是*等价的*和*独立的*。也就是说，复制后`x
    == y`为真（等价性），并且修改`x`不会导致`y`的修改（独立性）。'
- en: Copying is extremely common, especially when passing objects to functions by
    value, as demonstrated in [Listing 4-23](ch04.xhtml#ch04ex23).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 复制是非常常见的，特别是在按值传递对象给函数时，如[清单4-23](ch04.xhtml#ch04ex23)所示。
- en: '[PRE40]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 4-23: A program illustrating that passing by value generates a copy*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-23：一个示例程序，说明按值传递会生成副本*'
- en: Here, `add_one_to` takes its argument `x` by value. It then modifies the value
    of `x` ➊. This modification is isolated from the caller ➋; `original` is unaffected
    because `add_one_to` gets a copy.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`add_one_to`按值传递其参数`x`。然后它修改`x`的值 ➊。这个修改与调用者是隔离的 ➋；`original`不受影响，因为`add_one_to`接收到的是副本。
- en: For user-defined POD types, the story is similar. Passing by value causes each
    member value to be copied into the parameter (a *member-wise copy*), as demonstrated
    in [Listing 4-24](ch04.xhtml#ch04ex24).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户定义的POD类型，情况类似。按值传递导致每个成员值被复制到参数中（*逐成员复制*），如[清单4-24](ch04.xhtml#ch04ex24)所示。
- en: '[PRE41]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 4-24: The function `make_transpose` generates a copy of the POD type
    `Point`.*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-24：函数`make_transpose`生成POD类型`Point`的副本。*'
- en: When `make_transpose` is invoked, it receives a copy `Point` in `p`, and the
    original is unaffected.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`make_transpose`时，它接收到`Point`的副本`p`，而原始数据不受影响。
- en: For fundamental and POD types, the story is straightforward. Copying these types
    is memberwise, which means each member gets copied into its corresponding destination.
    This is effectively a bitwise copy from one memory address to another.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本类型和POD类型，情况非常简单。复制这些类型是逐成员复制，这意味着每个成员都会被复制到对应的目标位置。这实际上是从一个内存地址到另一个内存地址的按位复制。
- en: Fully featured classes require some more thought. The default copy semantics
    for fully featured classes is also the memberwise copy, and this can be extremely
    dangerous. Consider again the `SimpleString` class. You would invite disaster
    if you allowed a user to make a memberwise copy of a live `SimpleString` class.
    Two `SimpleString` classes would point to the same `buffer`. With both of the
    copies appending to the same `buffer`, they’ll clobber each other. [Figure 4-4](ch04.xhtml#ch04fig04)
    summarizes the situation.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 完整特性的类则需要更多的思考。完整特性的类的默认复制语义也是逐成员复制，这可能非常危险。再考虑一下`SimpleString`类。如果你允许用户对一个活跃的`SimpleString`类进行逐成员复制，那将是灾难性的。两个`SimpleString`类将指向同一个`buffer`，当这两个副本都向同一个`buffer`中添加内容时，它们将相互覆盖。[图4-4](ch04.xhtml#ch04fig04)总结了这种情况。
- en: '![image](../images/fig4_4.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig4_4.jpg)'
- en: '*Figure 4-4: A depiction of default copy semantics on the `SimpleString` class*'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-4：`SimpleString`类默认复制语义的示意图*'
- en: This result is bad, but even worse things happen when the `SimpleString` classes
    start destructing. When one of the `SimpleString` classes is destructed, `buffer`
    will be freed. When the remaining `SimpleString` class tries to write its `buffer`—bang!—you
    have undefined behavior. At some point, this remaining `SimpleString` class will
    be destructed and free `buffer` again, resulting in what is commonly called a
    *double free*.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果很糟糕，但更糟糕的是当`SimpleString`类开始析构时发生的事情。当其中一个`SimpleString`类被析构时，`buffer`会被释放。当剩余的`SimpleString`类尝试写入它的`buffer`时——砰！——你会遇到未定义的行为。最终，剩余的`SimpleString`类将被析构并再次释放`buffer`，从而导致通常所说的*双重释放*。
- en: '**NOTE**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Like its nefarious cousin the use after free, the double free can result in
    subtle and hard-to-diagnose bugs that manifest only very infrequently. A double
    free occurs when you deallocate an object twice. Recall that once you’ve deallocated
    an object, its storage lifetime ends. This memory is now in an undefined state,
    and if you destruct an object that’s already been destructed, you’ve got undefined
    behavior. In certain situations, this can cause serious security vulnerabilities.*'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*与它的恶名昭著的表兄“使用后释放”类似，双重释放可能导致微妙且难以诊断的错误，这些错误很少出现。双重释放发生在你两次释放一个对象时。请回想一下，一旦你释放了一个对象，它的存储生命周期就结束了。此时，这块内存处于未定义状态，如果你析构一个已经被析构的对象，你就会遇到未定义的行为。在某些情况下，这可能会导致严重的安全漏洞。*'
- en: You can avoid this dumpster fire by taking control of copy semantics. You can
    specify copy constructors and copy assignment operators, as described in the following
    sections.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过控制拷贝语义来避免这种灾难。你可以指定拷贝构造函数和拷贝赋值运算符，具体内容将在以下章节中介绍。
- en: '***Copy Constructors***'
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***拷贝构造函数***'
- en: 'There are two ways to copy an object. One is to use *copy construction*, which
    creates a copy and assigns it to a brand-new object. The copy constructor looks
    like other constructors:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以复制一个对象。一种是使用*拷贝构造*，它创建一个副本并将其分配给一个全新的对象。拷贝构造函数与其他构造函数类似：
- en: '[PRE42]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice that `other` is `const`. You’re copying from some original `SimpleString`,
    and you have no reason to modify it. You use the copy constructor just like other
    constructors, using the uniform initialization syntax of braced initializers:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`other`是`const`。你正在从某个原始的`SimpleString`对象进行拷贝，且没有修改它的理由。你像使用其他构造函数一样使用拷贝构造函数，采用统一初始化语法和大括号初始化器：
- en: '[PRE43]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The second line invokes the copy constructor of `SimpleString` with `a` to yield
    `a_copy`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行调用了`SimpleString`的拷贝构造函数，使用`a`生成`a_copy`。
- en: Let’s implement the copy constructor of `SimpleString`. You want what is known
    as a *deep copy* where you copy the data pointed to by the original `buffer` into
    a new `buffer`, as depicted in [Figure 4-5](ch04.xhtml#ch04fig05).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现`SimpleString`的拷贝构造函数。你需要的是一种被称为*深拷贝*的方法，即将原始`buffer`指向的数据复制到一个新的`buffer`中，如[图
    4-5](ch04.xhtml#ch04fig05)所示。
- en: '![image](../images/fig4_5.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig4_5.jpg)'
- en: '*Figure 4-5: A depiction of a deep copy on the `SimpleString` class*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-5：`SimpleString`类的深拷贝示意图*'
- en: 'Rather than copying the pointer `buffer`, you’ll make a new allocation on the
    free store and then copy all the data pointed to by the original `buffer`. This
    gives you two independent `SimpleString` classes. [Listing 4-25](ch04.xhtml#ch04ex25)
    implements the copy constructor of `SimpleString`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 与其拷贝指针`buffer`，不如在自由存储区上进行新的分配，然后复制原始`buffer`指向的所有数据。这将给你两个独立的`SimpleString`类。[清单
    4-25](ch04.xhtml#ch04ex25)实现了`SimpleString`的拷贝构造函数：
- en: '[PRE44]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 4-25: `SimpleString` class’s copy constructor*'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-25：`SimpleString`类的拷贝构造函数*'
- en: You use member initializers for `max_size` ➊, `buffer` ➋, and `length` ➌ and
    pass in the corresponding fields on `other`. You can use array new ➋ to initialize
    `buffer` because you know `other.max_size` is greater than 0\. The copy constructor’s
    body contains a single statement ➍ that copies the contents pointed to by `other.buffer`
    into the array pointed to by `buffer`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你为`max_size` ➊、`buffer` ➋ 和 `length` ➌ 使用成员初始化器，并传递`other`上的相应字段。你可以使用数组`new`
    ➋ 来初始化`buffer`，因为你知道`other.max_size`大于0。拷贝构造函数的主体包含一个语句 ➍，该语句将`other.buffer`指向的内容复制到`buffer`指向的数组中。
- en: '[Listing 4-26](ch04.xhtml#ch04ex26) uses this copy constructor by initializing
    a `SimpleString` with an existing `SimpleString`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-26](ch04.xhtml#ch04ex26)通过使用现有的`SimpleString`来初始化一个`SimpleString`，从而使用了这个拷贝构造函数：'
- en: '[PRE45]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Listing 4-26: A program using `SimpleString` class’s copy constructor*'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-26：使用`SimpleString`类的拷贝构造函数的程序*'
- en: In the program, `SimpleString a_copy` ➊ is copy constructed from `a`. It’s equivalent
    to—and independent from—the original. You can append different messages to the
    end of `a` ➋ and `a_copy` ➌, and the changes are isolated.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，`SimpleString a_copy` ➊ 是通过复制构造从 `a` 创建的。它等同于并独立于原始对象。你可以将不同的消息追加到 `a`
    ➋ 和 `a_copy` ➌ 的末尾，且这些更改是相互独立的。
- en: The copy constructor is invoked when passing `SimpleString` into a function
    by value, as demonstrated in [Listing 4-27](ch04.xhtml#ch04ex27).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当将 `SimpleString` 作为值传递到函数中时，会调用复制构造函数，如 [列表 4-27](ch04.xhtml#ch04ex27) 所示。
- en: '[PRE46]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*Listing 4-27: A program illustrating that copy constructors get invoked when
    passing an object by value*'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-27：一个示例程序，说明通过值传递对象时会调用复制构造函数*'
- en: '**NOTE**'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You shouldn’t pass by value to avoid modification. Use a `const` reference.*'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '*你不应该通过值传递以避免修改。使用 `const` 引用。*'
- en: The performance impact of copying can be substantial, especially in a situation
    where free store allocations and buffer copies are involved. For example, suppose
    you have a class that manages the life cycle of a gigabyte of data. Each time
    you copy the object, you’ll need to allocate and copy a gigabyte of data. This
    can take a lot of time, so you should be absolutely sure you need the copy. If
    you can get away with passing a `const` reference, strongly prefer it.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 复制的性能影响可能很大，特别是在涉及到自由存储区分配和缓冲区复制的情况下。例如，假设你有一个管理 gigabyte 数据生命周期的类。每次复制对象时，都需要分配并复制一
    gigabyte 的数据。这可能需要很长时间，所以你应该确保确实需要进行复制。如果可以通过传递 `const` 引用来避免复制，强烈建议这么做。
- en: '***Copy Assignment***'
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***复制赋值***'
- en: The other way to make a copy in C++ is with the *copy assignment operator*.
    You can create a copy of an object and assign it to another existing object, as
    demonstrated in [Listing 4-28](ch04.xhtml#ch04ex28).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在 C++ 中进行复制的方法是使用 *复制赋值运算符*。你可以创建对象的副本并将其赋值给另一个已存在的对象，如 [列表 4-28](ch04.xhtml#ch04ex28)
    所示。
- en: '[PRE47]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 4-28: Using the default copy assignment operator to create a copy
    of an object and assign it to another existing object*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-28：使用默认的复制赋值运算符创建对象的副本并将其赋值给另一个已存在的对象*'
- en: '**NOTE**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The code in [Listing 4-28](ch04.xhtml#ch04ex28) causes undefined behavior
    because it doesn’t have a user-defined copy assignment operator.*'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '*[列表 4-28](ch04.xhtml#ch04ex28) 中的代码会导致未定义行为，因为它没有用户定义的复制赋值运算符。*'
- en: The line at ➊ *copy assigns* `a` to `b`. The major difference between copy assignment
    and copy construction is that in copy assignment, `b` might already have a value.
    You must clean up `b`’s resources before copying `a`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 第 ➊ 行 *复制赋值* 将 `a` 赋值给 `b`。复制赋值与复制构造的主要区别在于，在复制赋值中，`b` 可能已经有一个值。在复制 `a` 之前，必须清理
    `b` 的资源。
- en: '**WARNING**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*The default copy assignment operator for simple types just copies the members
    from the source object to the destination object. In the case of `*SimpleString*`,
    this is very dangerous for two reasons. First, the original `*SimpleString*` class’s
    buffer gets rewritten without freeing the dynamically allocated `*char*` array.
    Second, now two `*SimpleString*` classes own the same buffer, which can cause
    dangling pointers and double frees. You must implement a copy assignment operator
    that performs a clean hand-off.*'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '*简单类型的默认复制赋值运算符只是将源对象的成员复制到目标对象。在 `*SimpleString*` 的情况下，这非常危险，原因有二。首先，原始的 `*SimpleString*`
    类的缓冲区被重写，而没有释放动态分配的 `*char*` 数组。其次，现在两个 `*SimpleString*` 类拥有相同的缓冲区，这可能导致悬空指针和双重释放。你必须实现一个复制赋值运算符，确保资源的干净交接。*'
- en: The copy assignment operator uses the `operator=` syntax, as demonstrated in
    [Listing 4-29](ch04.xhtml#ch04ex29).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 复制赋值运算符使用 `operator=` 语法，如 [列表 4-29](ch04.xhtml#ch04ex29) 所示。
- en: '[PRE48]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Listing 4-29: A user-defined copy assignment operator for `SimpleString`*'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-29：一个用户定义的 `SimpleString` 类的复制赋值运算符*'
- en: The copy assignment operator returns a reference to the result, which is always
    `*this` ➋. It’s also generally good practice to check whether `other` refers to
    `this` ➊.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 复制赋值运算符返回结果的引用，这个引用总是 `*this` ➋。通常的好做法是检查 `other` 是否引用了 `this` ➊。
- en: 'You can implement copy assignment for `SimpleString` by following these guidelines:
    free the current `buffer` of `this` and then copy `other` as you did in copy construction,
    as shown in [Listing 4-30](ch04.xhtml#ch04ex30).'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下准则为 `SimpleString` 实现复制赋值：释放当前 `buffer` 的资源，然后像复制构造一样复制 `other`，如 [列表
    4-30](ch04.xhtml#ch04ex30) 所示。
- en: '[PRE49]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '*Listing 4-30: A copy assignment operator for `SimpleString`*'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-30：`SimpleString` 的复制赋值运算符*'
- en: The copy assignment operator starts by allocating a `new_buffer` with the appropriate
    size ➊. Next, you clean up `buffer` ➋. The rest is essentially identical to the
    copy constructor in [Listing 4-25](ch04.xhtml#ch04ex25). You copy `buffer` ➌,
    `length` ➍, and `max_size` ➎ and then copy the contents from `other.buffer` into
    your own `buffer` ➏.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 复制赋值操作符首先会分配一个适当大小的`new_buffer` ➊。接着，你清理`buffer` ➋。其余部分与[清单4-25](ch04.xhtml#ch04ex25)中的复制构造函数基本相同。你复制`buffer`
    ➌，`length` ➍和`max_size` ➎，然后将`other.buffer`中的内容复制到你自己的`buffer` ➏。
- en: '[Listing 4-31](ch04.xhtml#ch04ex31) illustrates how `SimpleString` copy assignment
    works (as implemented in [Listing 4-30](ch04.xhtml#ch04ex30)).'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单4-31](ch04.xhtml#ch04ex31)演示了`SimpleString`复制赋值如何工作（如[清单4-30](ch04.xhtml#ch04ex30)中实现的那样）。'
- en: '[PRE50]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*Listing 4-31: A program illustrating copy assignment with the `SimpleString`
    class*'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-31：一个展示`SimpleString`类复制赋值的程序*'
- en: 'You begin by declaring two `SimpleString` classes with different messages:
    the string `a` contains `We apologize for the` ➊, and `b` contains `Last` `message`
    ➋. You print these strings to verify that they contain the text you’ve specified
    ➌➍. Next, you copy assign `b` equal to `a` ➎. Now, `a` and `b` contain copies
    of the same message, `We apologize for the` ➏➐. But—and this is important—that
    message resides in two separate memory locations.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先声明两个`SimpleString`类，分别包含不同的消息：字符串`a`包含`We apologize for the` ➊，而`b`包含`Last`
    `message` ➋。你打印这些字符串以验证它们包含你指定的文本 ➌➍。接下来，你将`b`复制赋值为`a` ➎。此时，`a`和`b`包含相同消息的副本，即`We
    apologize for the` ➏➐。但——这很重要——这个消息位于两个不同的内存位置。
- en: '***Default Copy***'
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***默认复制***'
- en: Often, the compiler will generate default implementations for copy construction
    and copy assignment. The default implementation is to invoke copy construction
    or copy assignment on each of a class’s members.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编译器会为复制构造和复制赋值生成默认实现。默认实现是对每个类成员调用复制构造函数或复制赋值操作符。
- en: 'Any time a class manages a resource, you must be extremely careful with default
    copy semantics; they’re likely to be wrong (as you saw with `SimpleString`). Best
    practice dictates that you explicitly declare that default copy assignment and
    copy construction are acceptable for such classes using the `default` keyword.
    The `Replicant` class, for example, has default copy semantics, as demonstrated
    here:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候一个类管理资源时，你必须非常小心默认的复制语义；它们很可能是错误的（就像你在`SimpleString`中看到的那样）。最佳实践是明确声明默认的复制赋值和复制构造对这样的类是可接受的，可以使用`default`关键字。比如，`Replicant`类具有默认的复制语义，正如这里展示的那样：
- en: '[PRE51]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Some classes simply cannot or should not be copied—for example, if your class
    manages a file or if it represents a mutual exclusion lock for concurrent programming.
    You can suppress the compiler from generating a copy constructor and a copy assignment
    operator using the `delete` keyword. The `Highlander` class, for example, cannot
    be copied:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 有些类根本不能或不应该被复制——例如，如果你的类管理一个文件，或者它代表了一个用于并发编程的互斥锁。你可以使用`delete`关键字来抑制编译器生成复制构造函数和复制赋值操作符。例如，`Highlander`类就不能被复制：
- en: '[PRE52]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Any attempt to copy a `Highlander` will result in a compiler error:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 任何试图复制`Highlander`的操作都会导致编译错误：
- en: '[PRE53]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: I highly recommend that you explicitly define the copy assignment operator and
    copy constructor for *any* class that owns a resource (like a printer, a network
    connection, or a file). If custom behavior is not needed, use either `default`
    or `delete`. This will save you from a lot of nasty and difficult-to-debug errors.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你为*任何*拥有资源的类（如打印机、网络连接或文件）显式定义复制赋值操作符和复制构造函数。如果不需要自定义行为，可以使用`default`或`delete`。这将帮助你避免许多棘手且难以调试的错误。
- en: '***Copy Guidelines***'
  id: totrans-351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***复制指南***'
- en: 'When you implement copy behavior, think about the following criteria:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实现复制行为时，请考虑以下标准：
- en: '**Correctness** You must ensure that class invariants are maintained. The `SimpleString`
    class demonstrated that the default copy constructor can violate invariants.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**正确性** 你必须确保类的不变性得到维护。`SimpleString`类演示了默认的复制构造函数如何违反不变性。'
- en: '**Independence** After copy assignment or copy construction, the original object
    and the copy shouldn’t change each other’s state during modification. Had you
    simply copied `buffer` from one `SimpleString` to another, writing to one `buffer`
    could overwrite the data from the other.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**独立性** 复制赋值或复制构造后，原始对象和复制品在修改时不应该相互改变对方的状态。如果你只是将一个`SimpleString`的`buffer`复制到另一个，写入一个`buffer`可能会覆盖另一个`buffer`的数据。'
- en: '**Equivalence** The original and the copy should be the *same*. The semantics
    of sameness depend on context. But generally, an operation applied to the original
    should yield the same result when applied to the copy.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**等价性** 原始对象和副本应该是*相同的*。相同性的语义取决于上下文。但通常，对原始对象应用的操作，在副本上应用时应该得到相同的结果。'
- en: '**Move Semantics**'
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**移动语义**'
- en: Copying can be quite time-consuming at runtime when a large amount of data is
    involved. Often, you just want to *transfer ownership* of resources from one object
    to another. You could make a copy and destroy the original, but this is often
    inefficient. Instead, you can *move*.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理大量数据时，复制可能会非常耗时。通常，你只想将资源的*所有权*从一个对象转移到另一个对象。你可以进行复制并销毁原始对象，但这通常效率低下。相反，你可以*移动*。
- en: '*Move semantics* is move’s corollary to copy semantics, and it requires that
    after an object `y` is *moved into* an object `x`, `x` is equivalent to the former
    value of `y`. After the move, `y` is in a special state called the *moved-from*
    state. You can perform only two operations on moved-from objects: (re)assign them
    or destruct them. Note that moving an object `y` into an object `x` isn’t just
    a renaming: these are separate objects with separate storage and potentially separate
    lifetimes.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '*移动语义*是移动对复制语义的补充，它要求在将对象`y`*移动到*对象`x`之后，`x`等价于`y`的原始值。移动之后，`y`进入一个特殊状态，称为*移动后*状态。对于移动后的对象，你只能进行两种操作：（重新）赋值或销毁它们。请注意，将对象`y`移动到对象`x`并不只是重新命名：这些是独立的对象，具有独立的存储和可能独立的生命周期。'
- en: Similar to how you specify copying behavior, you specify how objects move with
    *move constructors* and *move assignment operators*.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于你指定复制行为的方式，你可以使用*移动构造函数*和*移动赋值运算符*来指定对象的移动方式。
- en: '***Copying Can Be Wasteful***'
  id: totrans-360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***复制可能是浪费的***'
- en: 'Suppose you want to move a `SimpleString` into a `SimpleStringOwner` in the
    following way:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想通过以下方式将`SimpleString`移动到`SimpleStringOwner`中：
- en: '[PRE54]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You could add a constructor for `SimpleStringOwner` and then copy-construct
    its `SimpleString` member, as demonstrated in [Listing 4-32.](ch04.xhtml#ch04ex32)
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为`SimpleStringOwner`添加一个构造函数，然后像[示例 4-32](ch04.xhtml#ch04ex32)中演示的那样，复制构造它的`SimpleString`成员。
- en: '[PRE55]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '*Listing 4-32: A naive approach to member initialization containing a wasteful
    copy*'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 4-32：包含浪费复制的成员初始化的简单方法*'
- en: There is hidden waste in this approach. You have a copy construction ➊, but
    the caller never uses the pointed-to object again after constructing `string`
    ➋. [Figure 4-6](ch04.xhtml#ch04fig06) illustrates the issue.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法中隐藏了浪费。你有一个复制构造 ➊，但调用者在构造`string` ➋后，再也不会使用指向的对象。[图 4-6](ch04.xhtml#ch04fig06)说明了这个问题。
- en: '![image](../images/fig4_6.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig4_6.jpg)'
- en: '*Figure 4-6: Using the copy constructor for `string` is wasteful.*'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-6：使用`string`的复制构造函数是浪费的。*'
- en: 'You should move the guts of `SimpleString a` into the `string` field of `SimpleStringOwner`.
    [Figure 4-7](ch04.xhtml#ch04fig07) shows what you want to achieve: `SimpleString
    Owner b` steals `buffer` and sets `SimpleString a` into a destructible state.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将`SimpleString a`的核心内容移到`SimpleStringOwner`的`string`字段中。[图 4-7](ch04.xhtml#ch04fig07)展示了你想要实现的目标：`SimpleString
    Owner b`偷走了`buffer`并将`SimpleString a`置于可销毁状态。
- en: '![image](../images/fig4_7.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig4_7.jpg)'
- en: '*Figure 4-7: Swapping the buffer of `a` into `b`*'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-7：将`a`的缓冲区交换到`b`中*'
- en: After moving `a`, the `SimpleString` of `b` is equivalent to the former state
    of `a`, and `a` is destructible.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 移动`a`后，`b`的`SimpleString`等价于`a`的原始状态，而`a`处于可销毁状态。
- en: Moving can be dangerous. If you accidentally use moved-from `a`, you’d invite
    disaster. The class invariants of `SimpleString` aren’t satisfied when `a` is
    moved from.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 移动可能是危险的。如果你不小心使用了移动后的`a`，将引发灾难。当`a`被移动后，`SimpleString`的类不变量不再满足。
- en: 'Fortunately, the compiler has built-in safeguards: *lvalues* and *rvalues*.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，编译器内置了保护机制：*左值*和*右值*。
- en: '***Value Categories***'
  id: totrans-375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***值类别***'
- en: 'Every expression has two important characteristics: its *type* and its *value
    category*. A value category describes what kinds of operations are valid for the
    expression. Thanks to the evolutionary nature of C++, value categories are complicated:
    an expression can be a “generalized lvalue” (*glvalue*), a “pure rvalue” (*prvalue*),
    an “expiring value” (*xvalue*), an *lvalue* (a glvalue that isn’t an xvalue),
    or an *rvalue* (a prvalue or an xvalue). Fortunately for the newcomer, you don’t
    need to know much about most of these value categories.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 每个表达式有两个重要特性：它的 *类型* 和 *值类别*。值类别描述了该表达式可以进行哪些操作。得益于 C++ 的演化特性，值类别是复杂的：一个表达式可以是“广义左值”(*glvalue*)、“纯右值”(*prvalue*)、
    “过期值”(*xvalue*)、*左值*（一个不是 xvalue 的 glvalue），或者*右值*（一个 prvalue 或 xvalue）。幸运的是，对于初学者来说，你不需要了解大多数值类别的细节。
- en: We’ll consider a very simplified view of value categories. For now, you’ll just
    need a general understanding of lvalues and rvalues. An *lvalue* is any value
    that has a name, and an *rvalue* is anything that isn’t an lvalue.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑值类别的一个简化视图。目前，你只需要对左值和右值有一个大致的理解。*左值* 是任何有名字的值，而 *右值* 是任何不是左值的东西。
- en: 'Consider the following initializations:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下初始化：
- en: '[PRE56]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The etymology of these terms is *right value* and *left value*, referring to
    where each appears with respect to the equal sign in construction. In the statement
    `int x = 50;`, `x` is left of the equal sign (lvalue) and `50` is right of the
    equal sign (rvalue). These terms aren’t totally accurate because you can have
    an lvalue on the right side of an equal sign (as in copy assignment, for example).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这些术语的词源是 *右值* 和 *左值*，指的是它们在构造中相对于等号的位置。在语句 `int x = 50;` 中，`x` 位于等号左侧（左值），而
    `50` 位于等号右侧（右值）。这些术语并不完全准确，因为你也可以在等号的右侧使用左值（例如在复制赋值中）。
- en: '**NOTE**'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The ISO C++ Standard details Value Categories in [basic] and [expr].*'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '*ISO C++ 标准在 [basic] 和 [expr] 中详细说明了值类别。*'
- en: '***lvalue and rvalue References***'
  id: totrans-383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***左值和右值引用***'
- en: You can communicate to the compiler that a function accepts lvalues or rvalues
    using *lvalue references* and *rvalue references*. Up to this point in this book,
    every reference parameter has been an lvalue reference, and these are denoted
    with a single `&`. You can also take a parameter by rvalue reference using `&&`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 *左值引用* 和 *右值引用* 向编译器传达一个函数接受左值或右值。到目前为止，本书中的每个引用参数都是左值引用，这些由单个 `&` 表示。你也可以通过
    `&&` 来接受一个右值引用参数。
- en: Fortunately, the compiler does an excellent job of determining whether an object
    is an lvalue or an rvalue. In fact, you can define multiple functions with the
    same name but with different parameters, and the compiler will automatically call
    the correct version depending on what arguments you provide when you invoke the
    function.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，编译器在判断对象是左值还是右值时表现得非常出色。实际上，你可以定义多个具有相同名称但参数不同的函数，编译器会根据你调用函数时传入的参数自动调用正确的版本。
- en: '[Listing 4-33](ch04.xhtml#ch04ex33) contains two functions with the name `ref_type`
    function to discern whether the invoker passed an lvalue or an rvalue reference.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-33](ch04.xhtml#ch04ex33) 包含了两个名为 `ref_type` 的函数，用于辨别调用者传递的是左值还是右值引用。'
- en: '[PRE57]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '*Listing 4-33: A program containing an overloaded function with lvalue and
    rvalue references*'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-33：包含左值和右值引用重载函数的程序*'
- en: The `int &x` version ➊ takes an lvalue reference, and the `int &&x` version
    ➋ takes an rvalue reference. You invoke `ref_type` three times. First, you invoke
    the lvalue reference version, because `x` is an lvalue (it has a name) ➌. Second,
    you invoke the rvalue reference version because `2` is an integer literal without
    a name ➍. Third, the result of adding 2 to `x` is not bound to a name, so it’s
    an rvalue ➎.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`int &x` 版本 ➊ 接受一个左值引用，而 `int &&x` 版本 ➋ 接受一个右值引用。你调用 `ref_type` 三次。首先，调用左值引用版本，因为
    `x` 是一个左值（它有名字） ➌。第二，调用右值引用版本，因为 `2` 是一个没有名字的整数常量 ➍。第三，`x` 加 2 的结果没有绑定到一个名字，因此它是一个右值
    ➎。'
- en: '**NOTE**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Defining multiple functions with the same name but different parameters is
    called *function overloading*, a topic you’ll explore in detail in [Chapter 9](ch09.xhtml#ch09).*'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '*定义多个具有相同名称但不同参数的函数称为 *函数重载*，这是你将在[第 9 章](ch09.xhtml#ch09)中详细探讨的内容。*'
- en: '***The std::move Function***'
  id: totrans-392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***std::move 函数***'
- en: You can cast an lvalue reference to an rvalue reference using the `std::move`
    function from the `<utility>` header. [Listing 4-34](ch04.xhtml#ch04ex34) updates
    [Listing 4-33](ch04.xhtml#ch04ex33) to illustrate the use of the `std::move` function.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用来自`<utility>`头文件的`std::move`函数将左值引用转换为右值引用。[清单 4-34](ch04.xhtml#ch04ex34)更新了[清单
    4-33](ch04.xhtml#ch04ex33)，以说明`std::move`函数的使用。
- en: '[PRE58]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '*Listing 4-34: An update to [Listing 4-33](ch04.xhtml#ch04ex33) using `std::move`
    to cast `x` to an rvalue*'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-34：使用`std::move`将`x`转换为右值，更新[清单 4-33](ch04.xhtml#ch04ex33)*'
- en: As expected, `std::move` changes the lvalue `x` into an rvalue ➊. You never
    call the lvalue `ref_type` overload.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`std::move`将左值`x`转换为右值➊。你永远不会调用左值`ref_type`重载。
- en: '**NOTE**'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The C++ committee probably should have named `std::move` as `std::rvalue`,
    but it’s the name we’re stuck with. The `std:move` function doesn’t actually move
    anything—it casts.*'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '*C++委员会本应将`std::move`命名为`std::rvalue`，但我们只能使用现有的名称。`std::move`函数实际上并不移动任何东西——它只是进行类型转换。*'
- en: 'Be very careful when you’re using `std::move`, because you remove the safeguards
    keeping you from interacting with a moved-from object. You can perform two actions
    on a moved-from object: destroy it or reassign it.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::move`时要非常小心，因为它移除了保护措施，使你可以与一个已移动的对象交互。你只能对一个已移动的对象执行两种操作：销毁它或重新赋值。
- en: How lvalue and rvalue semantics enable move semantics should now be clear. If
    an lvalue is at hand, moving is suppressed. If an rvalue is at hand, moving is
    enabled.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该可以清楚地理解左值和右值语义如何支持移动语义。如果是左值，则移动被抑制；如果是右值，则启用移动。
- en: '***Move Construction***'
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***移动构造***'
- en: Move constructors look like copy constructors except they take rvalue references
    instead of lvalue references.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 移动构造函数看起来像复制构造函数，只不过它们接受右值引用而不是左值引用。
- en: Consider the `SimpleString` move constructor in [Listing 4-35](ch04.xhtml#ch04ex35).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[清单 4-35](ch04.xhtml#ch04ex35)中的`SimpleString`移动构造函数。
- en: '[PRE59]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '*Listing 4-35: A move constructor for `SimpleString`*'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-35：`SimpleString`的移动构造函数*'
- en: 'Because `other` is an rvalue reference, you’re allowed to cannibalize it. In
    the case of `SimpleString`, this is easy: just copy all fields of `other` into
    `this` ➊ and then zero out the fields of `other` ➋. The latter step is important:
    it puts `other` in a moved-from state. (Consider what would happen upon the destruction
    of `other` had you not cleared its members.)'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`other`是右值引用，所以你可以对其进行“自食其力”。在`SimpleString`的情况下，这很容易：将`other`的所有字段复制到`this`➊，然后将`other`的字段清零➋。后一步很重要：它将`other`置于一个已移动的状态。（考虑一下，如果你没有清除`other`的成员，当`other`销毁时会发生什么。）
- en: Executing this move constructor is a *lot* less expensive than executing the
    copy constructor.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此移动构造函数的成本比执行复制构造函数要*低*得多。
- en: The move constructor is designed to *not* throw an exception, so you mark it
    `noexcept`. Your preference should be to use `noexcept` move constructors; often,
    the compiler cannot use exception-throwing move constructors and will use copy
    constructors instead. Compilers prefer slow, correct code instead of fast, incorrect
    code.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 移动构造函数设计为*不*抛出异常，因此你会将其标记为`noexcept`。你的首选应为使用`noexcept`的移动构造函数；通常，编译器无法使用会抛出异常的移动构造函数，而会使用复制构造函数。编译器更喜欢慢而正确的代码，而不是快而不正确的代码。
- en: '***Move Assignment***'
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***移动赋值***'
- en: You can also create a move analogue to copy assignment via `operator=`. The
    move assignment operator takes an rvalue reference rather than a `const` lvalue
    reference, and you usually mark it `noexcept`. [Listing 4-36](ch04.xhtml#ch04ex36)
    implements such a move assignment operator for `SimpleString`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过`operator=`创建类似于复制赋值的移动赋值运算符。移动赋值运算符采用右值引用，而不是`const`左值引用，通常会标记为`noexcept`。[清单
    4-36](ch04.xhtml#ch04ex36)实现了`SimpleString`的移动赋值运算符。
- en: '[PRE60]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '*Listing 4-36: A move assignment operator for `SimpleString`*'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-36：`SimpleString`的移动赋值运算符*'
- en: You declare the move assignment operator using the rvalue reference syntax and
    the `noexcept` qualifier, as with the move constructor ➊. The self-reference check
    ➋ handles the move assignment of a `SimpleString` to itself. You clean up `buffer`
    ➌ before assigning the fields of `this` to the fields of `other` ➍ and zero out
    the fields of `other` ➎. Aside from the self-reference check ➋ and the cleanup
    ➌, the move assignment operator and the move constructor are functionally identical.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过右值引用语法和`noexcept`限定符声明移动赋值运算符，就像移动构造函数➊一样。自引用检查➋处理将`SimpleString`移动赋值给自身的情况。在将`this`的字段赋值给`other`的字段之前，你会清理`buffer`➌，并将`other`的字段清零➎。除了自引用检查➋和清理➌之外，移动赋值运算符和移动构造函数在功能上是相同的。
- en: 'Now that `SimpleString` is movable, you can complete the `SimpleString` constructor
    of `SimpleStringOwner`:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`SimpleString`是可移动的，你可以完成`SimpleStringOwner`的`SimpleString`构造函数：
- en: '[PRE61]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `x` is an lvalue, so you must `std::move x` into the move constructor of
    `string` ➊. You might find `std::move` odd, because `x` is an rvalue reference.
    Recall that lvalue/rvalue and lvalue reference/rvalue reference are distinct descriptors.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`是一个左值，所以你必须将`std::move x`传入`string`的移动构造函数 ➊。你可能会觉得`std::move`很奇怪，因为`x`是一个右值引用。请记住，左值/右值和左值引用/右值引用是不同的描述符。'
- en: 'Consider if `std::move` weren’t required here: what if you moved from `x` and
    then used it inside the constructor? This could lead to bugs that are hard to
    diagnose. Remember that you cannot use moved-from objects except to reassign or
    destruct them. Doing anything else is undefined behavior.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下如果这里不需要`std::move`会怎么样：假设你从`x`移动了内容然后在构造函数内部使用它？这可能会导致难以诊断的错误。记住，除非重新赋值或析构，否则你不能使用已移动的对象。做任何其他操作都会导致未定义的行为。
- en: '[Listing 4-37](ch04.xhtml#ch04ex37) illustrates the `SimpleString` move assignment.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-37](ch04.xhtml#ch04ex37)展示了`SimpleString`的移动赋值。'
- en: '[PRE62]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '*Listing 4-37: A program illustrating move assignment with the `SimpleString`
    class*'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-37：一个展示`SimpleString`类移动赋值的程序*'
- en: 'As in [Listing 4-31](ch04.xhtml#ch04ex31), you begin by declaring two `SimpleString`
    classes with different messages: the string `a` contains `We apologize for the`
    ➊, and `b` contains `Last message` ➋. You print these strings to verify that they
    contain the strings you’ve specified ➌➍. Next, you move assign `b` equal to `a`
    ➎. Note that you had to cast `a` to an `rvalue` using `std::move`. After the move
    assignment, `a` is in a moved-from state, and you can’t use it unless you reassign
    it to a new value. Now, `b` owns the message that `a` used to own, `We apologize
    for the` ➏.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 如同[列表 4-31](ch04.xhtml#ch04ex31)中所示，你首先声明两个具有不同消息的`SimpleString`类：字符串`a`包含`We
    apologize for the` ➊，`b`包含`Last message` ➋。你打印这些字符串以验证它们是否包含你指定的字符串 ➌➍。接下来，你将`b`移赋给`a`
    ➎。注意，你需要使用`std::move`将`a`强制转换为右值。移赋后，`a`进入已移动状态，你不能在不重新赋值的情况下使用它。现在，`b`拥有了原来属于`a`的消息`We
    apologize for the` ➏。
- en: '***The Final Product***'
  id: totrans-422
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***最终产品***'
- en: You now have a fully implemented `SimpleString` that supports move and copy
    semantics. [Listing 4-38](ch04.xhtml#ch04ex38) brings these all together for your
    reference.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个完整实现的`SimpleString`，它支持移动和复制语义。[列表 4-38](ch04.xhtml#ch04ex38)将这些都汇总在一起供你参考。
- en: '[PRE63]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '*Listing 4-38: A fully specified `SimpleString` class supporting copy and move
    semantics*'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-38：一个完整的`SimpleString`类，支持复制和移动语义*'
- en: '***Compiler-Generated Methods***'
  id: totrans-426
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编译器生成的方法***'
- en: 'Five methods govern move and copy behavior:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 五个方法控制着移动和复制行为：
- en: The destructor
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 析构函数
- en: The copy constructor
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制构造函数
- en: The move constructor
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动构造函数
- en: The copy assignment operator
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制赋值运算符
- en: The move assignment operator
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动赋值运算符
- en: The compiler can generate default implementations for each under certain circumstances.
    Unfortunately, the rules for which methods get generated are complicated and potentially
    uneven across compilers.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在某些情况下可以为每个方法生成默认实现。不幸的是，哪些方法会被生成的规则是复杂的，而且在不同的编译器中可能不一致。
- en: You can eliminate this complexity by setting these methods to `default`/`delete`
    or by implementing them as appropriate. This general rule is the *rule of five*,
    because there are five methods to specify. Being explicit costs a little time,
    but it saves a lot of future headaches.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将这些方法设置为`default`/`delete`，或者根据需要实现它们，来消除这种复杂性。这个通用规则被称为*五法则*，因为有五个方法需要指定。明确地指定这些方法虽然花费一些时间，但可以避免未来的许多麻烦。
- en: The alternative is memorizing [Figure 4-8](ch04.xhtml#ch04fig08), which summarizes
    the interactions between each of the five functions you implement and each that
    the compiler generates on your behalf.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方式是记住[图 4-8](ch04.xhtml#ch04fig08)，它总结了你实现的五个函数和编译器为你生成的每个函数之间的交互。
- en: '![image](../images/fig4_8.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig4_8.jpg)'
- en: '*Figure 4-8: A chart illustrating which methods the compiler generates when
    given various inputs*'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-8：一张图表，展示了在不同输入下编译器生成的方法*'
- en: If you provide nothing, the compiler will generate all five destruct/copy/move
    functions. This is the *rule of zero*.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你什么都不提供，编译器将会生成所有五个析构/复制/移动函数。这就是*零规则*。
- en: 'If you explicitly define any of destructor/copy constructor/copy assignment
    operator, you get all three. This is dangerous, as demonstrated earlier with `SimpleString`:
    it’s too easy to get into an unintended situation in which the compiler will essentially
    convert all your moves into copies.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你显式地定义了析构函数/复制构造函数/复制赋值操作符，你会得到所有三个。这是危险的，正如之前通过`SimpleString`所演示的那样：很容易陷入编译器实际上将所有的移动操作都转换为复制操作的意外情况。
- en: Finally, if you provide only move semantics for your class, the compiler will
    not automatically generate anything except a destructor.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你只为你的类提供移动语义，编译器将不会自动生成任何东西，除了析构函数。
- en: '**Summary**'
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: You’ve completed the exploration of the object life cycle. Your journey began
    in storage durations, where you saw an object lifetime from construction to destruction.
    Subsequent study of exception handling illustrated deft, lifetime-aware error
    handling and enriched your understanding of RAII. Finally, you saw how copy and
    move semantics grant you granular control over object lifetimes.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了对对象生命周期的探索。你的旅程从存储持续时间开始，在那里你看到了从构造到析构的对象生命周期。随后研究异常处理展示了灵活的、生命周期感知的错误处理，并加深了你对RAII的理解。最后，你看到了复制和移动语义如何让你对对象生命周期进行细粒度的控制。
- en: '**EXERCISES**'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题**'
- en: '**4-1.** Create a `struct TimerClass`. In its constructor, record the current
    time in a field called `timestamp` (compare with the POSIX function `gettimeofday`).'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '**4-1.** 创建一个`struct TimerClass`。在它的构造函数中，记录当前时间到一个名为`timestamp`的字段（与POSIX函数`gettimeofday`进行比较）。'
- en: '**4-2.** In the destructor of TimerClass, record the current time and subtract
    the time at construction. This time is roughly the *age* of the timer. Print this
    value.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**4-2.** 在`TimerClass`的析构函数中，记录当前时间并减去构造时的时间。这个时间大致是定时器的*年龄*。打印这个值。'
- en: '**4-3.** Implement a copy constructor and a copy assignment operator for TimerClass.
    The copies should share timestamp values.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '**4-3.** 为`TimerClass`实现一个复制构造函数和复制赋值操作符。复制应共享时间戳值。'
- en: '**4-4.** Implement a move constructor and a move assignment operator for TimerClass.
    A moved-from TimerClass shouldn’t print any output to the console when it gets
    destructed.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '**4-4.** 为`TimerClass`实现一个移动构造函数和一个移动赋值操作符。一个被移动的`TimerClass`在析构时不应向控制台打印任何输出。'
- en: '**4-5.** Elaborate the TimerClass constructor to accept an additional `const
    char* name` parameter. When `TimerClass` is destructed and prints to stdout, include
    the name of the timer in the output.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '**4-5.** 扩展`TimerClass`的构造函数，接受一个额外的`const char* name`参数。当`TimerClass`被析构并打印到标准输出时，包含定时器的名称。'
- en: '**4-6.** Experiment with your TimerClass. Create a timer and move it into a
    function that performs some computationally intensive operation (for example,
    lots of math in a loop). Verify that your timer behaves as you expect.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '**4-6.** 尝试你的`TimerClass`。创建一个定时器并将它传入一个执行一些计算密集型操作的函数中（例如，在循环中进行大量数学运算）。验证你的定时器是否按预期工作。'
- en: '**4-7.** Identify each method in the SimpleString class ([Listing 4-38](ch04.xhtml#ch04ex38)).
    Try reimplementing it from scratch without referring to the book.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**4-7.** 找出`SimpleString`类中的每个方法（[清单 4-38](ch04.xhtml#ch04ex38)）。尝试从头开始重新实现它，而不参考书中的内容。'
- en: '**FURTHER READING**'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*Optimized C++: Proven Techniques for Heightened Performance* by Kurt Guntheroth
    (O’Reilly Media, 2016)'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优化的C++：提升性能的验证技巧*，作者：Kurt Guntheroth（O''Reilly Media，2016）'
- en: '*Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14*
    by Scott Meyers (O’Reilly Media, 2015)'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Effective Modern C++: 提升你使用C++11和C++14的42个具体方法*，作者：Scott Meyers（O''Reilly
    Media，2015）'
