- en: '**4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4'
- en: THE OBJECT LIFE CYCLE**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象生命周期**'
- en: '*Things you used to own, now they own you.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*你曾经拥有的东西，现在它们拥有你。*'
- en: —Chuck Palahniuk,* Fight Club
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —Chuck Palahniuk, *搏击俱乐部*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: The object life cycle is the series of stages a C++ object goes through during
    its lifetime. This chapter begins with a discussion of an object’s storage duration,
    the time during which storage is allocated for an object. You’ll learn about how
    the object life cycle dovetails with exceptions to handle error conditions and
    cleanup in a robust, safe, and elegant way. The chapter closes with a discussion
    of move and copy semantics that provides you with granular control over an object’s
    life cycle.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对象生命周期是C++对象在其生命周期中经历的一系列阶段。本章从讨论对象的存储持续时间开始，即为对象分配存储的时间。你将学习对象生命周期如何与异常处理结合，以一种稳健、安全和优雅的方式处理错误和清理工作。章节的最后讨论了移动和拷贝语义，帮助你对对象的生命周期进行细粒度的控制。
- en: '**An Object’s Storage Duration**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**对象的存储持续时间**'
- en: An *object* is a region of storage that has a type and a value. When you declare
    a variable, you create an object. A variable is simply an object that has a name.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象*是一个具有类型和值的存储区域。当你声明一个变量时，你就创建了一个对象。变量只是一个有名字的对象。'
- en: '***Allocation, Deallocation, and Lifetime***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分配、释放和生命周期***'
- en: Every object requires storage. You reserve storage for objects in a process
    called *allocation*. When you’re done with an object, you release the object’s
    storage in a process called *deallocation*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都需要存储。你通过*分配*过程为对象保留存储。当你不再使用对象时，你通过*释放*过程释放对象的存储。
- en: 'An object’s *storage duration* begins when the object is allocated and ends
    when the object is deallocated. The *lifetime* of an object is a runtime property
    that is bound by the object’s storage duration. An object’s lifetime begins once
    its constructor completes, and it ends just before a destructor is invoked. In
    summary, each object passes through the following stages:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的*存储持续时间*从对象分配开始，到对象被释放结束。对象的*生命周期*是一个运行时属性，受对象存储持续时间的约束。对象的生命周期从构造函数完成时开始，到析构函数被调用前结束。总的来说，每个对象都会经历以下几个阶段：
- en: The object’s storage duration begins, and storage is allocated.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象的存储持续时间开始，存储被分配。
- en: The object’s constructor is called.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象的构造函数被调用。
- en: The object’s lifetime begins.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象的生命周期开始。
- en: You can use the object in your program.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在程序中使用该对象。
- en: The object’s lifetime ends.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象的生命周期结束。
- en: The object’s destructor is called.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象的析构函数被调用。
- en: The object’s storage duration ends, and storage is deallocated.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象的存储持续时间结束，存储被释放。
- en: '***Memory Management***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内存管理***'
- en: If you’ve been programming in an application language, chances are you’ve used
    an *automatic memory manager*, or a *garbage collector*. At runtime, programs
    create objects. Periodically, the garbage collector determines which objects are
    no longer required by the program and safely deallocates them. This approach frees
    the programmer from worrying about managing an object’s life cycle, but it incurs
    several costs, including runtime performance, and requires some powerful programming
    techniques like deterministic resource management.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经在应用程序语言中编程过，你很可能使用过*自动内存管理器*或*垃圾回收器*。在运行时，程序会创建对象。垃圾回收器会定期检查哪些对象不再被程序需要，并安全地释放它们。这个方法让程序员不必担心管理对象的生命周期，但它也带来了几个成本，包括运行时性能问题，并且需要一些强大的编程技巧，比如确定性的资源管理。
- en: C++ takes a more efficient approach. The trade-off is that C++ programmers must
    have intimate knowledge of storage durations. It’s *our* job, not the garbage
    collector’s, to craft object lifetimes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: C++采用了一种更高效的方法。其折衷之处在于，C++程序员必须深入了解存储持续时间。*这*是我们的工作，而不是垃圾回收器的工作，我们需要设计对象的生命周期。
- en: '***Automatic Storage Duration***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***自动存储持续时间***'
- en: An *automatic object* is allocated at the beginning of an enclosing code block,
    and it’s deallocated at the end. The enclosing block is the automatic object’s
    *scope*. Automatic objects are said to have *automatic storage duration*. Note
    that function parameters are automatic, even though notationally they appear outside
    the function body.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*自动对象*会在一个代码块开始时分配，并在代码块结束时释放。这个代码块是自动对象的*作用域*。自动对象被认为具有*自动存储持续时间*。请注意，即使函数参数的符号上看起来在函数体外部，函数参数也是自动的。'
- en: In [Listing 4-1](ch04.xhtml#ch04ex01), the function `power_up_rat_thing` is
    the scope for the automatic variables `nuclear_isotopes` and `waste_heat`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 4-1: A function with two automatic variables, `nuclear_isotopes` and
    `waste_heat`*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Both `nuclear_isotopes` and `waste_heat` are allocated each time `power_up_rat_thing`
    is invoked. Just before `power_up_rat_thing` returns, these variables are deallocated.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Because you cannot access these variables outside of `power_up_rat_thing`, automatic
    variables are also called *local variables*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '***Static Storage Duration***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *static object* is declared using the `static` or `extern` keyword. You declare
    static variables at the same level you declare functions—at global scope (or *namespace
    scope*). Static objects with global scope have *static storage duration* and are
    allocated when the program starts and deallocated when the program stops.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The program in [Listing 4-2](ch04.xhtml#ch04ex02) powers up a Rat Thing with
    nuclear isotopes by calling the `power_up_rat_thing` function. When it does, the
    Rat Thing’s power increases, and the variable `rat_things_power` keeps track of
    the power level between power-ups.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 4-2: A program with a static variable and several automatic variables*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The variable `rat_things_power` ➊ is a static variable because it’s declared
    at global scope with the `static` keyword. Another feature of being declared at
    global scope is that `rat_things_power` can be accessed from any function in the
    translation unit. (Recall from [Chapter 1](ch01.xhtml#ch01) that a translation
    unit is what a preprocessor produces after acting on a single source file.) At
    ➋, you see `power_up_rat_thing` increasing `rat_things_power` by the number of
    `nuclear_isotopes`. Because `rat_things_power` is a static variable—and hence
    its lifetime is the program’s lifetime—each time you call `power_up_rat_thing`,
    the value of `rat_things_power` carries over into the next call.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Next, you calculate how much waste heat is produced given the new value of `rat_things_power`,
    and you store the result in the automatic variable `waste_heat` ➌. Its storage
    duration begins when `power_up_rat_thing` is called and ends when `power_up_rat_thing`
    returns, so its values aren’t saved between function calls. Finally, you check
    whether waste_heat is over a threshold value of `1000` ➍. If it is, you print
    a warning message ➎
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Within `main`, you alternate between printing the value of `rat_things_power`
    ➏ and calling `power_up_rat_thing` ➐.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve increased the Rat Thing’s power from `300` to `800`, you get the
    warning message in the output ➑. The effects of modifying `rat_things_power` last
    for the lifetime of the program due to its static storage duration.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: When you use the `static` keyword, you specify *internal linkage*. Internal
    linkage means that a variable is inaccessible to other translation units. You
    can alternately specify *external linkage*, which makes a variable accessible
    to other translation units. For external linkage, you use the `extern` keyword
    instead of `static`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'You could modify [Listing 4-2](ch04.xhtml#ch04ex02) in the following way to
    achieve external linkage:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With `extern` rather than `static`, you can access `rat_things_power` from other
    translation units.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**Local Static Variables**'
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *local static variable* is a special kind of static variable that is a local—rather
    than global—variable. Local static variables are declared at function scope, just
    like automatic variables. But their lifetimes begin upon the first invocation
    of the enclosing function and end when the program exits.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: For example, you could refactor [Listing 4-2](ch04.xhtml#ch04ex02) to make `rat_things_power`
    a local static variable, as demonstrated in [Listing 4-3](ch04.xhtml#ch04ex03).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 4-3: A refactor of [Listing 4-2](ch04.xhtml#ch04ex02) using a local
    static variable.*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Unlike in [Listing 4-2](ch04.xhtml#ch04ex02), you cannot refer to `rat_things_power`
    from outside of the `power_up_rat_thing` function due to its local scope. This
    is an example of a programming pattern called *encapsulation*, which is the bundling
    of data with a function that operates on that data. It helps to protect against
    unintended modification.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '**Static Members**'
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Static members* are members of a class that aren’t associated with a particular
    instance of the class. Normal class members have lifetimes nested within the class’s
    lifetime, but static members have static storage duration.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: These members are essentially similar to static variables and functions declared
    at global scope; however, you must refer to them by the containing class’s name,
    using the scope resolution operator `::`. In fact, you must initialize static
    members at global scope. You cannot initialize a static member within a containing
    class definition.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '*There is an exception to the static member initialization rule: you can declare
    and define integral types within a class definition as long as they’re also `const`.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Like other static variables, static members have only a single instance. All
    instances of a class with static members share the same member, so if you modify
    a static member, *all* class instances will observe the modification. To illustrate,
    you could convert `power_up_rat_thing` and `rat_things_power` in [Listing 4-2](ch04.xhtml#ch04ex02)
    to static members of a `RatThing` class, as shown in [Listing 4-4](ch04.xhtml#ch04ex04).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 4-4: A refactor of [Listing 4-2](ch04.xhtml#ch04ex02) using static
    members*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The `RatThing` class contains `rat_things_power` as a static member variable
    ➊ and `power_up_rat_thing` as a static method ➋. Because `rat_things_power` is
    a member of `RatThing`, you don’t need the scope resolution operator ➌; you access
    it like any other member.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: You see the scope resolution operator in action where `rat_things_power` is
    initialized ➍ and where you invoke the static method `power_up_rat_thing` ➎.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '***Thread-Local Storage Duration***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the fundamental concepts in concurrent programs is the *thread*. Each
    program has one or more threads that can perform independent operations. The sequence
    of instructions that a thread executes is called its *thread of execution*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Programmers must take extra precautions when using more than one thread of execution.
    Code that multiple threads can execute safely is called *thread-safe code*. Mutable
    global variables are the source of many thread safety issues. Sometimes, you can
    avoid these issues by giving each thread its own copy of a variable. You can do
    this by specifying that an object has *thread storage duration*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: You can modify any variable with static storage duration to have thread-local
    storage duration by adding the `thread_local` keyword to the `static` or `extern`
    keyword. If only `thread_local` is specified, `static` is assumed. The variable’s
    linkage is unchanged.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-3](ch04.xhtml#ch04ex03) is not thread safe. Depending on the order
    of reads and writes, `rat_things_power` could become corrupted. You could make
    [Listing 4-3](ch04.xhtml#ch04ex03) thread safe by specifying `rat_things_power`
    as `thread_local`, as demonstrated here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now each thread would represent its own Rat Thing; if one thread modifies its
    `rat_things_power`, the modification will not affect the other threads. Each copy
    of `rat_things_power` is initialized to 200 ➊.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '*Concurrent programming is discussed in more detail in [Chapter 19](ch19.xhtml#ch19).
    Thread storage duration is presented here for completeness.*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '***Dynamic Storage Duration***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Objects with *dynamic storage duration* are allocated and deallocated on request.
    You have manual control over when a *dynamic object*’s life begins and when it
    ends. Dynamic objects are also called *allocated objects* for this reason.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The primary way to allocate a dynamic object is with a *new expression*. A new
    expression begins with the `new` keyword followed by the desired type of the dynamic
    object. New expressions create objects of a given type and then return a pointer
    to the newly minted object.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example where you create an `int` with dynamic storage
    duration and save it into a pointer called `my_int_ptr`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You declare a pointer to `int` and initialize it with the result of the new
    expression on the right side of the equal sign ➊. The new expression is composed
    of the `new` keyword ➋ followed by the desired type `int` ➌. When the new expression
    executes, the C++ runtime allocates memory to store an `int` and then returns
    its pointer.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also initialize a dynamic object within a new expression, as shown
    here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After allocating storage for the `int`, the dynamic object will be initialized
    as usual. After initialization completes, the dynamic object’s lifetime begins.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: You deallocate dynamic objects using the *delete expression*, which is composed
    of the `delete` keyword followed by a pointer to the dynamic object. Delete expressions
    always return `void`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'To deallocate the object pointed to by `my_int_ptr`, you would use the following
    delete expression:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The value contained in memory where the deleted object resided is undefined,
    meaning the compiler can produce code that leaves anything there. In practice,
    major compilers will try to be as efficient as possible, so typically the object’s
    memory will remain untouched until the program reuses it for some other purposes.
    You would have to implement a custom destructor to, for example, zero out some
    sensitive contents.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '*Because the compiler doesn’t typically clean up memory after an object is
    deleted, a subtle and potentially serious type of bug called a *use after free*
    can occur. If you delete an object and accidentally reuse it, your program might
    appear to function correctly because the deallocated memory might still contain
    reasonable values. In some situations, the problems don’t manifest until the program
    has been in production for a long time—or until a security researcher finds a
    way to exploit the bug and discloses it!*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic Arrays**'
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Dynamic arrays* are arrays with dynamic storage duration. You create dynamic
    arrays with *array new expressions*. Array new expressions have the following
    form:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`MyType` is the desired type of the array elements, `n_elements` is the length
    of the desired array, and the optional `init-list` is an initialization list to
    initialize the array. Array new expressions return a pointer to the first element
    of the newly allocated array.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, you allocate an `int` array of length 100 and save
    the result into a pointer called `my_int_array_ptr`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The number of elements ➊ doesn’t need to be constant: the size of the array
    can be determined at runtime, meaning the value between brackets ➊ could be a
    variable rather than a literal.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'To deallocate a dynamic array, use the *array delete expression*. Unlike the
    array new expression, the array delete expression doesn’t require a length:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Like the delete expression, the array delete expression returns `void`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory Leaks**'
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: With privilege comes responsibility, so you must make sure that dynamic objects
    you allocate are also deallocated. Failure to do so causes *memory leaks* in which
    memory that is no longer needed by your program isn’t released. When you leak
    memory, you use up a resource in your environment that you’ll never reclaim. This
    can cause performance problems or worse.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '*In practice, your program’s operating environment might clean up leaked resources
    for you. For example, if you’ve written user-mode code, modern operating systems
    will clean up the resources when the program exits. However, if you’ve written
    kernel code, those operating systems won’t clean up the resources. You’ll only
    reclaim them when the computer reboots.*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '**Tracing the Object Life Cycle**'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The object life cycle is as daunting to newcomers as it is powerful. Let’s clarify
    with an example that explores each of the storage durations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Consider the `Tracer` class in [Listing 4-5](ch04.xhtml#ch04ex05), which prints
    a message whenever a `Tracer` object is constructed or destructed. You can use
    this class to investigate object life cycles, because each `Tracer` clearly indicates
    when its life is beginning and ending.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 4-5: A `Tracer` class that announces construction and destruction*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: The constructor takes a single parameter ➊ and saves it into the member `name`
    ➋. It then prints a message containing `name` ➌. The destructor ➍ also prints
    a message with `name`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Consider the program in [Listing 4-6](ch04.xhtml#ch04ex06). Four different `Tracer`
    objects have different storage durations. By looking at the order of the program’s
    `Tracer` output, you can verify what you’ve learned about storage durations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 4-6: A program using the `Tracer` class in [Listing 4-5](ch04.xhtml#ch04ex05)
    to illustrate storage duration*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-6](ch04.xhtml#ch04ex06) contains a `Tracer` with static duration
    ➊, thread local duration ➋, automatic duration ➍, and dynamic duration ➎. Between
    each line in `main`, you print the character `A`, `B`, or `C` for reference ➌.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Running the program yields [Listing 4-7](ch04.xhtml#ch04ex07).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 4-7: Sample output from running [Listing 4-6](ch04.xhtml#ch04ex06)*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the first line of `main` ➌, the static and thread local variables `t1`
    and `t2` have been initialized ➊ ➋. You can see this in [Listing 4-7](ch04.xhtml#ch04ex07):
    both variables have printed their initialization messages before `A`. As an automatic
    variable, the scope of `t3` is bounded by the enclosing function `main`. Accordingly,
    `t3` is constructed where it is initialized just after `A`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: After `B`, you see the message corresponding to the initialization of `t4` ➎.
    Notice that there’s no corresponding message generated by the dynamic destructor
    of `Tracer`. The reason is that you’ve (intentionally) leaked the object pointed
    to by `t4`. Because there’s no command to `delete t4`, the destructor is never
    called.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Just before `main` returns, `C` prints. Because `t3` is an automatic variable
    whose scope is `main`, it’s destroyed at this point because `main` is returning.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the static and thread-local variables `t1` and `t2` are destroyed just
    before program exit, yielding the final two messages in [Listing 4-7](ch04.xhtml#ch04ex07).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '**Exceptions**'
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Exceptions* are types that communicate an error condition. When an error condition
    occurs, you *throw* an exception. After you throw an exception, it’s *in flight*.
    When an exception is in flight, the program stops normal execution and searches
    for an *exception handler* that can manage the in-flight exception. Objects that
    fall out of scope during this process are destroyed.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: In situations where there’s no good way to handle an error locally, such as
    in a constructor, you generally use exceptions. Exceptions play a crucial role
    in managing object life cycles in such circumstances.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: The other option for communicating error conditions is to return an error code
    as part of a function’s prototype. These two approaches are complementary. In
    situations where an error occurs that can be dealt with locally or that is expected
    to occur during the normal course of a program’s execution, you generally return
    an error code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '***The throw Keyword***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To throw an exception, use the `throw` keyword followed by a throwable object.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Most objects are throwable. But it’s good practice to use one of the exceptions
    available in stdlib, such as `std::runtime_error` in the `<stdexcept>` header.
    The `runtime_error` constructor accepts a null-terminated `const char*` describing
    the nature of the error condition. You can retrieve this message via the `what`
    method, which takes no parameters.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The `Groucho` class in [Listing 4-8](ch04.xhtml#ch04ex08) throws an exception
    whenever you invoke the `forget` method with an argument equal to `0xFACE`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 4-8: The `Groucho` class*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: To throw an exception, [Listing 4-8](ch04.xhtml#ch04ex08) uses the `throw` keyword
    ➊ followed by a `std::runtime_error` object ➋.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '***Using try-catch Blocks***'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You use `try`-`catch` blocks to establish exception handlers for a block of
    code. Within the `try` block, you place code that might throw an exception. Within
    the `catch` block, you specify a handler for each exception type you can handle.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-9](ch04.xhtml#ch04ex09) illustrates the use of a `try`-`catch` block
    to handle exceptions thrown by a `Groucho` object.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 4-9: The use of `try`-`catch` to handle the exceptions of the `Groucho`
    class*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main`, you construct a `Groucho` object and then establish a `try`-`catch`
    block ➊. Within the `try` portion, you invoke the `groucho` class’s `forget` method
    with several different parameters: `0xC0DE` ➋, `0xFACE` ➌, and `0xC0FFEE` ➍. Within
    the `catch` portion, you handle any `std::runtime_error` exceptions ➎ by printing
    the message to the console ➏.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the program in [Listing 4-9](ch04.xhtml#ch04ex09), you get the
    following output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When you invoked `forget` with the argument `0xC0DE` ➋, `groucho` printed `Forgot
    0xc0de` and returned. When you invoked `forget` with the argument `0xFACE` ➌,
    `groucho` threw an exception. This exception stopped normal program execution,
    so `forget` is never invoked again ➍. Instead, the in-flight exception is caught
    ➎, and its message is printed ➏.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '**A CRASH COURSE IN INHERITANCE**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承的速成课程**'
- en: Before introducing the stdlib exceptions, you need to understand simple C++
    class inheritance at a very high level. Classes can have subclasses that inherit
    the functionality of their superclasses. The syntax in [Listing 4-10](ch04.xhtml#ch04ex10)
    defines this relationship.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍std库异常之前，你需要在一个非常高的层次上理解简单的C++类继承。类可以有子类，子类继承父类的功能。[清单4-10](ch04.xhtml#ch04ex10)中的语法定义了这种关系。
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 4-10: Defining superclasses and subclasses*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-10：定义超类和子类*'
- en: 'There’s nothing special about `Superclass`. But the declaration of `Subclass`
    ➊ is special. It defines the inheritance relationship using the : `Superclass`
    syntax. `Subclass` inherits members from `Superclass` that are not marked private.
    You can see this in action where `Subclass` uses the field x ➋. This is a field
    belonging to `Superclass`, but because `Subclass` inherits from Superclass, x
    is accessible.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Superclass`没有什么特别之处。但`Subclass`的声明 ➊ 是特殊的。它使用`: Superclass`语法定义了继承关系。`Subclass`继承了`Superclass`中未标记为私有的成员。你可以看到它的作用，`Subclass`使用字段x
    ➋。这个字段属于`Superclass`，但是由于`Subclass`继承自`Superclass`，所以x是可以访问的。'
- en: Exceptions use these inheritance relationships to determine whether a handler
    catches an exception. Handlers will catch a given type and any of its childrens’
    types.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 异常使用这些继承关系来判断一个处理程序是否捕获某个异常。处理程序将捕获给定类型及其任何子类型的异常。
- en: '***stdlib Exception Classes***'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***stdlib异常类***'
- en: You can arrange classes into parent-child relationships using *inheritance*.
    Inheritance has a big impact on how the code handles exceptions. There is a nice,
    simple hierarchy of existing exception types available for use in the stdlib.
    You should try to use these types for simple programs. Why reinvent the wheel?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用*继承*将类安排成父子关系。继承对代码如何处理异常有很大影响。std库提供了一个简洁明了的现有异常类型层次结构，供你使用。对于简单的程序，你应该尝试使用这些类型。为什么要重新发明轮子呢？
- en: '**Standard Exception Classes**'
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**标准异常类**'
- en: 'The stdlib provides you with the *standard exception classes* in the `<stdexcept>`
    header. These should be your first port of call when you’re programming exceptions.
    The superclass for all the standard exception classes is the class `std::exception`.
    All the subclasses in `std::exception` can be partitioned into three groups: logic
    errors, runtime errors, and language support errors. While language support errors
    are not generally relevant to you as a programmer, you’ll definitely encounter
    logic errors and runtime errors. [Figure 4-1](ch04.xhtml#ch04fig01) summarizes
    their relationship.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: std库在`<stdexcept>`头文件中为你提供了*标准异常类*。当你编程处理异常时，这些应该是你首先参考的内容。所有标准异常类的超类是`std::exception`类。`std::exception`中的所有子类可以分为三组：逻辑错误、运行时错误和语言支持错误。虽然语言支持错误通常与作为程序员的你无关，但你肯定会遇到逻辑错误和运行时错误。[图4-1](ch04.xhtml#ch04fig01)总结了它们之间的关系。
- en: '![image](../images/fig4_1.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig4_1.jpg)'
- en: '*Figure 4-1: How stdlib exceptions are nested under std::exception*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-1：std库异常如何嵌套在std::exception下*'
- en: '**Logic Errors**'
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**逻辑错误**'
- en: '*Logic errors* derive from the `logic_error` class. Generally, you could avoid
    these exceptions through more careful programming. A primary example is when a
    logical precondition of a class isn’t satisfied, such as when a class invariant
    cannot be established. (Remember from [Chapter 2](ch02.xhtml#ch02) that a class
    invariant is a feature of a class that is always true.)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*逻辑错误*源自`logic_error`类。一般来说，通过更小心的编程，你可以避免这些异常。一个主要的例子是，当一个类的逻辑前置条件未被满足时，例如当类的不变式无法建立时。（回想一下[第2章](ch02.xhtml#ch02)中提到的类不变式，它是类的一个特性，总是为真。）'
- en: Since a class invariant is something that the programmer defines, neither the
    compiler nor the runtime environment can enforce it without help. You can use
    a class constructor to check for various conditions, and if you cannot establish
    a class invariant, you can throw an exception. If the failure is the result of,
    say, passing an incorrect parameter to the constructor, a `logic_error` is an
    appropriate exception to throw.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类不变式是由程序员定义的，编译器和运行时环境无法在没有帮助的情况下强制执行它。你可以使用类构造函数检查各种条件，如果无法建立类的不变式，可以抛出异常。如果失败是由于例如传递给构造函数的参数不正确，则抛出`logic_error`是一个合适的选择。
- en: 'The `logic_error` has several subclasses that you should be aware of:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`logic_error`有几个子类，你需要了解它们：'
- en: The `domain_error` reports errors related to valid input range, especially for
    math functions. The square root, for example, only supports non-negative numbers
    (in the real case). If a negative argument is passed, a square root function could
    throw a `domain_error`.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `invalid_argument` exception reports generally unexpected arguments.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `length_error` exception reports that some action would violate a maximum
    size constraint.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `out_of_range` exception reports that some value isn’t in an expected range.
    The canonical example is bounds-checked indexing into a data structure.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime Errors**'
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Runtime errors* derive from the `runtime_error` class. These exceptions help
    you report error conditions that are outside the program’s scope. Like `logic_error`,
    `runtime_error` has some subclasses that you might find useful:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: The `system_error` reports that the operating system encountered some error.
    You can get a lot of mileage out of this kind of exception. Inside of the `<system_error>`
    header, there’s a large number of *error codes* and *error conditions*. When a
    `system_error` is constructed, information about the error is packed in so you
    can determine the nature of the error. The `.code()` method returns an `enum class`
    of type `std::errc` that has a large number of values, such as `bad_file_descriptor`,
    `timed_out`, and `permission_denied`.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `overflow_error` and `underflow_error` report arithmetic overflow and underflow,
    respectively.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other errors inherit directly from `exception`. A common one is the `bad_alloc`
    exception, which reports that `new` failed to allocate the required memory for
    dynamic storage.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '**Language Support Errors**'
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You won’t use language support errors directly. They exist to indicate that
    some core language feature failed at runtime.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '***Handling Exceptions***'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The rules for exception handling are based on class inheritance. When an exception
    is thrown, a `catch` block handles the exception if the thrown exception’s type
    matches the `catch` handler’s exception type or if the thrown exception’s type
    *inherits from* the `catch` handler’s exception type.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following handler catches any exception that inherits from
    `std::exception`, including a `std::logic_error`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following special handler catches *any* exception regardless of its type:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Special handlers are typically used as a safety mechanism to log the program’s
    catastrophic failure to catch an exception of a specific type.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'You can handle different types of exceptions originating from the same `try`
    block by chaining together `catch` statements, as demonstrated here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It’s common to see such code in a program’s entry point.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '**RETHROWING AN EXCEPTION**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: In a `catch` block, you can use the throw keyword to resume searching for an
    appropriate exception handler. This is called rethrowing an exception. There are
    some unusual but important cases where you might want to further inspect an exception
    before deciding to handle it, as shown in [Listing 4-11](ch04.xhtml#ch04ex11).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 4-11: Rethrowing an error*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: In this example, some code that might throw a `system_error` is wrapped in a
    `try-catch` block. All `system_errors` are handled, but unless it’s an `EACCES
    (permission denied)` error, you rethrow the exception ➊ There are some performance
    penalties to this approach, and the resulting code is often needlessly convoluted.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Rather than rethrowing, you can define a new exception type and create a separate
    `catch` handler for the `EACCES` error, as demonstrated in [Listing 4-12](ch04.xhtml#ch04ex12).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 4-12: Catching a specific exception rather than rethrowing*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: If a `std::system_error` is thrown, the `PermissionDenied` handler ➊ won’t catch
    it. (Of course, you could still keep the `std::system_error` handler to catch
    such exceptions if you wish.)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '***User-Defined Exceptions***'
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can define your own exceptions whenever you’d like; usually, these *user-defined
    exceptions* inherit from `std::exception`. All the classes from stdlib use exceptions
    that derive from `std::exception`. This makes it easy to catch all exceptions,
    whether from your code or from the stdlib, with a single `catch` block.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '***The noexcept Keyword***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The keyword `noexcept` is another exception-related term you should know. You
    can, and should, mark any function that cannot possibly throw an exception `noexcept`,
    as in the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Functions marked `noexcept` make a rigid contract. When you’re using a function
    marked `noexcept`, you can rest assured that the function cannot throw an exception.
    In exchange, you must be extremely careful when you mark your own function `noexcept`,
    since the compiler won’t check for you. If your code throws an exception inside
    a function marked `noexcept`, it’s bad juju. The C++ runtime will call the function
    `std::terminate`, a function that by default will exit the program via `abort`.
    Your program cannot recover:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Marking a function `noexcept` enables some code optimizations that rely on the
    function’s not being able to throw an exception. Essentially, the compiler is
    liberated to use move semantics, which may be faster (more about this in “Move
    Semantics” on [page 122](ch04.xhtml#page_122)).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '*Check out Item 14 of Effective Modern C++ by Scott Meyers for a thorough discussion
    of `noexcept`. The gist is that some move constructors and move assignment operators
    might throw an exception, for example, if they need to allocate memory and the
    system is out. Unless a move constructor or move assignment operator specifies
    otherwise, the compiler must assume that a move could cause an exception. This
    disables certain optimizations.*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '***Call Stacks and Exceptions***'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *call stack* is a runtime structure that stores information about active
    functions. When a piece of code (the *caller*) invokes a function (the *callee*),
    the machine keeps track of who called whom by pushing information onto the call
    stack. This allows programs to have many function calls nested within each other.
    The callee could then, in turn, become the caller by invoking another function.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '**Stacks**'
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A stack is a flexible data container that can hold a dynamic number of elements.
    There are two essential operations that all stacks support: *pushing* elements
    onto the top of the stack and *popping* those elements off. It is a last-in, first-out
    data structure, as illustrated in [Figure 4-2](ch04.xhtml#ch04fig02).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig4_2.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Elements being pushed onto and popped off of a stack*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: As its name suggests, the call stack is functionally similar to its namesake
    data container. Each time a function is invoked, information about the function
    invocation is arranged into a *stack frame* and pushed onto the call stack. Because
    a new stack frame is pushed onto the stack for every function call, a callee is
    free to call other functions, forming arbitrarily deep call chains. Whenever a
    function returns, its stack frame is popped off the top of the call stack, and
    execution control resumes as indicated by the previous stack frame.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '**Call Stacks and Exception Handling**'
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The runtime seeks the closest exception handler to a thrown exception. If there
    is a matching exception handler in the current stack frame, it will handle the
    exception. If no matching handler is found, the runtime will unwind the call stack
    until it finds a suitable handler. Any objects whose lifetimes end are destroyed
    in the usual way.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '**Throwing in Destructors**'
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you throw an exception in a destructor, you are juggling with chainsaws.
    Such an exception absolutely must be caught within the destructor.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Suppose an exception is thrown, and during stack unwinding, another exception
    is thrown by a destructor during normal cleanup. Now you have *two* exceptions
    in flight. How should the C++ runtime handle such a situation?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'You can have an opinion on the matter, but the runtime will call `terminate`.
    Consider [Listing 4-13](ch04.xhtml#ch04ex13), which illustrates what can happen
    when you throw an exception from a destructor:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 4-13: A program illustrating the perils of throwing an exception within
    a destructor*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '*[Listing 4-13](ch04.xhtml#ch04ex13) calls `std::terminate`, so depending on
    your environment, you might get a nasty pop-up indicating this.*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: First, you declare the `CyberdyneSeries800` class, which has a simple constructor
    that prints a message ➊ and a thoroughly belligerent destructor that throws an
    uncaught exception ➋. Within `main`, you set up a `try` block where you initialize
    a `CyberdyneSeries800` called `t800` ➌ and throw a `runtime_error` ➍. Under better
    circumstances, the `catch` block ➎ would handle this exception, print its message
    ➏, and exit gracefully. Because `t800` is an automatic variable within the `try`
    block, it destructs during the normal process of finding a handler for the exception
    you’ve thrown ➍. And because `t800` throws an exception in its destructor ➋, your
    program invokes `std::terminate` and ends abruptly.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, treat destructors as if they were `noexcept`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '**A SimpleString Class**'
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using an extended example, let’s explore how constructors, destructors, members,
    and exceptions gel together. The `SimpleString` class in [Listing 4-14](ch04.xhtml#ch04ex14)
    allows you to add C-style strings together and print the result.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 4-14: The constructor and destructor of a `SimpleString` class*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The constructor ➊ takes a single `max_size` argument. This is the maximum length
    of your string, which includes a null terminator. The member initializer ➋ saves
    this length into the `max_size` member variable. This value is also used in the
    array new expression to allocate a buffer to store your string ➎. The resulting
    pointer is stored into `buffer`. You initialize length to zero ➌ and ensure that
    there is at least enough size for a null byte ➍. Because the string is initially
    empty, you assign the first byte of the buffer to zero ➏.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '*Because `max_size` is a `size_t`, it is unsigned and cannot be negative, so
    you don’t need to check for this bogus condition.*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The `SimpleString` class owns a resource—the memory pointed to by `buffer`—which
    must be released when it’s no longer needed. The destructor contains a single
    line ➐ that deallocates `buffer`. Because you’ve paired the allocation and deallocation
    of `buffer` with the constructor and destructor of `SimpleString`, you’ll never
    leak the storage.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is called *resource acquisition is initialization (RAII)* or *constructor
    acquires, destructor releases (CADRe)*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '*The `SimpleString` class still has an implicitly defined copy constructor.
    Although it might never leak the storage, it will potentially double free if copied.
    You’ll learn about copy constructors in “Copy Semantics” on [page 115](ch04.xhtml#page_115).
    Just be aware that [Listing 4-14](ch04.xhtml#ch04ex14) is a teaching tool, not
    production-worthy code.*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '***Appending and Printing***'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `SimpleString` class isn’t of much use yet. [Listing 4-15](ch04.xhtml#ch04ex15)
    adds the ability to print the string and append a line to the end of the string.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 4-15: The `print` and `append_line` methods of `SimpleString`*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: The first method `print` ➊ prints your string. For convenience, you can provide
    a `tag` string so you can match an invocation of `print` with the result. This
    method is `const` because it doesn’t need to modify the state of a `SimpleString`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'The `append_line` method ➋ takes a null-terminated string `x` and adds its
    contents—plus a newline character—to `buffer`. It returns `true` if `x` was successfully
    appended and `false` if there wasn’t enough space. First, `append_line` must determine
    the length of `x`. For this, you employ the `strlen` function ➌ from the `<cstring>`
    header, which accepts a null-terminated string and returns its length:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You use `strlen` to compute the length of `x` and initialize `x_len` with the
    result. This result is used to compute whether appending `x` (a newline character)
    and a null byte to the current string would result in a string with length greater
    than `max_size` ➍. If it would, `append_line` returns `false`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is enough room to append `x`, you need to copy its bytes into the
    correct location in `buffer`. The `std::strncpy` function ➎ from the `<cstring>`
    header is one possible tool for this job. It accepts three arguments: the `destination`
    address, the `source` address, and the `num` of characters to copy:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `strncpy` function will copy up to `num` bytes from `source` into `destination`.
    Once complete, it will return `destination` (which you discard).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: After adding the number of bytes `x_len` copied into `buffer` to `length`, you
    finish by adding a newline character `\n` and a null byte to the end of `buffer`.
    You return `true` to indicate that you’ve successfully appended the input `x`
    as a line to the end of `buffer`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '*Use `strncpy` very carefully. It’s too easy to forget the null-terminator
    in the `source` string or not allocate enough space in the `destination` string.
    Both errors will cause undefined behavior. We’ll cover a safer alternative in
    [Part II](part02.xhtml#part02) of the book.*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '***Using SimpleString***'
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 4-16](ch04.xhtml#ch04ex16) illustrates an example use of `SimpleString`
    where you append several strings and print intermediate results to the console.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 4-16: The methods of `SimpleString`*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: First, you create a `SimpleString` with `max_length=115` ➊. You use the `append_line`
    method twice ➋ to add some data to `string` and then print the contents along
    with the tag `A` ➌. You then append more text ➍ and print the contents again,
    this time with the tag `B` ➎. When `append_line` determines that `SimpleString`
    has run out of space ➏, it returns `false` ➐. (It’s your responsibility as a user
    of `SimpleString` to check for this condition.)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-17](ch04.xhtml#ch04ex17) contains output from running this program.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 4-17: Output from running the program in [Listing 4-16](ch04.xhtml#ch04ex16)*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: As expected, the string contains `Starbuck, whaddya hear?\nNothin' but the rain.\n`
    at `A` ➊. (Recall from [Chapter 2](ch02.xhtml#ch02) that `\n` is the newline special
    character.) After appending `Grab your gun and bring the cat in.` and `Aye-aye
    sir, coming home.`, you get the expected output at `B` ➋.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: When [Listing 4-17](ch04.xhtml#ch04ex17) tries to append `Galactica!` to `string`,
    `append_line` returns `false` because there is not enough space in `buffer`. This
    causes the message `String was not big enough to append another message` to print
    ➌.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '***Composing a SimpleString***'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider what happens when you define a class with a `SimpleString` member,
    as demonstrated in [Listing 4-18](ch04.xhtml#ch04ex18).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 4-18: The implementation of `SimpleStringOwner`*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'As suggested by the member initializer ➊, `string` is fully constructed, and
    its class invariants are established once the constructor of `SimpleStringOwner`
    executes. This illustrates the order of an object’s members during construction:
    *members are constructed before the enclosing object’s constructor*. This makes
    sense: how can you establish a class’s invariants if you don’t know about its
    members’ invariants?'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Destructors work the opposite way. Inside `~SimpleStringOwner()` ➋, you need
    the class invariants of `string` to hold so you can print its contents. *All members
    are destructed after the object’s destructor is invoked.*
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-19](ch04.xhtml#ch04ex19) exercises a `SimpleStringOwner`.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 4-19: A program containing a `SimpleStringOwner`*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'As expected, the member `string` of `x` is created appropriately because *an
    object’s member constructors are called before the object’s constructor*, resulting
    in the message `Constructed: x` ➊. As an automatic variable, `x` is destroyed
    just before `main` returns, and you get `About to destroy: x` ➋. The member `string`
    is still valid at this point because member destructors are called after the enclosing
    object’s destructor.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '***Call Stack Unwinding***'
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 4-20](ch04.xhtml#ch04ex20) demonstrates how exception handling and
    stack unwinding work together. You establish a `try`-`catch` block in `main` and
    then make a series of function calls. One of these calls causes an exception.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 4-20: A program illustrating the use of `SimpleStringOwner` and call
    stack unwinding*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-21](ch04.xhtml#ch04ex21) shows the results of running the program
    in [Listing 4-20](ch04.xhtml#ch04ex20).'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 4-21: Output from running the program in [Listing 4-20](ch04.xhtml#ch04ex20)*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve set up a `try`-`catch` block ➌. The first `SimpleStringOwner`, `a`,
    gets constructed without incident, and you see `Constructed: a` printed to the
    console. Next, `fn_b` is called ➍. Notice that you’re still in the `try`-`catch`
    block, so any `exception` that gets thrown *will* be handled. Inside `fn_b`, another
    `SimpleString Owner`, `b`, gets constructed successfully, and `Constructed: b`
    is printed to the console. Next, there’s a call into yet another function, `fn_c`
    ➋.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s pause for a moment to take an account of what the call stack looks like,
    what objects are alive, and what the exception-handling situation looks like.
    You have two `SimpleStringOwner` objects alive and valid: `a` and `b`. The call
    stack looks like `main() → fn_b() → fn_c()`, and you have an exception handler
    set up inside `main` to handle any exceptions. [Figure 4-3](ch04.xhtml#ch04fig03)
    summarizes this situation.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: At ➊, you run into a little problem. Recall that `SimpleStringOwner` has a member
    `SimpleString` that is always initialized with a `max_size` of 10\. When you try
    to construct `c`, the constructor of `SimpleStringOwner` throws an `exception`
    because you’ve tried to append `"cccccccccc"`, which has length 10 and is too
    big to fit alongside a newline and a null terminator.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you have an exception in flight. The stack will unwind until an appropriate
    handler is found, and all objects that fall out of scope as a result of this unwinding
    will be destructed. The handler is all the way up the stack ➏, so `fn_c` and `fn_b`
    unwind. Because `SimpleStringOwner b` is an automatic variable in `fn_b`, it gets
    destructed and you see `About to destroy: b` printed to the console. After `fn_b`,
    the automatic variables inside `try{}` are destroyed. This includes `SimpleStringOwner
    a`, so you see `About to destroy: a` printed to the console.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig4_3.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: The call stack when `fn_c` calls the constructor of `SimpleStringOwner
    c`*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Once an exception occurs in a `try{}` block, no further statements execute.
    As a result, `d` never initializes ➎, and you never see the constructor of `d`
    print to console. After the call stack is unwound, execution proceeds immediately
    to the `catch` block. In the end, you print the message `Exception: Not enough
    memory!` to the console ➏.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '***Exceptions and Performance***'
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In your programs, you must handle errors; errors are unavoidable. When you
    use exceptions correctly and no errors occur, your code is faster than manually
    error-checked code. If an error does occur, exception handling can sometimes be
    slower, but you make huge gains in robustness and maintainability over the alternative.
    Kurt Guntheroth, the author of *Optimized C++*, puts it well: “use of exception
    handling leads to programs that are faster when they execute normally, and better
    behaved when they fail.” When a C++ program executes normally (without exceptions
    being thrown), there is no runtime overhead associated with checking exceptions.
    It’s only when an exception is thrown that you pay overhead.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you’re convinced of the central role exceptions play in idiomatic
    C++ programs. Sometimes, unfortunately, you won’t be able to use exceptions. One
    example is embedded development where real-time guarantees are required. Tools
    simply don’t (yet) exist in this setting. With luck, this will change soon, but
    for now, you’re stuck without exceptions in most embedded contexts. Another example
    is with some legacy code. Exceptions are elegant because of how they fit in with
    RAII objects. When destructors are responsible for cleaning up resources, stack
    unwinding is a direct and effective way to guarantee against resource leakages.
    In legacy code, you might find manual resource management and error handling instead
    of RAII objects. This makes using exceptions very dangerous, because stack unwinding
    is safe only with RAII objects. Without them, you could easily leak resources.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '***Alternatives to Exceptions***'
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In situations where exceptions are not available, all is not lost. Although
    you’ll need to keep track of errors manually, there are some helpful C++ features
    that you can employ to take the sting out a bit. First, you can manually enforce
    class invariants by exposing some method that communicates whether the class invariants
    could be established, as shown here:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In idiomatic C++, you would just throw an exception in the constructor, but
    here you must remember to check and treat the situation as an error condition
    in your calling code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The second, complementary coping strategy is to return multiple values using
    *structured binding declaration*, a language feature that allows you to return
    multiple values from a function call. You can use this feature to return success
    flags alongside the usual return value, as demonstrated in [Listing 4-22](ch04.xhtml#ch04ex22).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 4-22: A code segment illustrating structured binding declaration*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: First, you declare a POD that contains a `HumptyDumpty` and a `success` flag
    ➊. Next, you define the function `make_humpty` ➋, which builds and validates a
    `HumptyDumpty`. Such methods are called *factory methods*, because their purpose
    is to initialize objects. The `make_humpty` function packs this and the success
    flag into a `Result` when it returns. The syntax at the call site ➌ illustrates
    how you can unpack the `Result` into multiple, `auto`-type-deduced variables.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '*You’ll explore structured bindings in more detail in “Structured Bindings”
    on [page 222](ch08.xhtml#page_222).*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '**Copy Semantics**'
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Copy semantics* is “the meaning of copy.” In practice, programmers use the
    term to mean the rules for making copies of objects: after `x` is *copied into*
    `y`, they’re *equivalent* and *independent*. That is, `x == y` is true after a
    copy (equivalence), and a modification to `x` doesn’t cause a modification of
    `y` (independence).'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Copying is extremely common, especially when passing objects to functions by
    value, as demonstrated in [Listing 4-23](ch04.xhtml#ch04ex23).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 4-23: A program illustrating that passing by value generates a copy*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Here, `add_one_to` takes its argument `x` by value. It then modifies the value
    of `x` ➊. This modification is isolated from the caller ➋; `original` is unaffected
    because `add_one_to` gets a copy.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: For user-defined POD types, the story is similar. Passing by value causes each
    member value to be copied into the parameter (a *member-wise copy*), as demonstrated
    in [Listing 4-24](ch04.xhtml#ch04ex24).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 4-24: The function `make_transpose` generates a copy of the POD type
    `Point`.*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: When `make_transpose` is invoked, it receives a copy `Point` in `p`, and the
    original is unaffected.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: For fundamental and POD types, the story is straightforward. Copying these types
    is memberwise, which means each member gets copied into its corresponding destination.
    This is effectively a bitwise copy from one memory address to another.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Fully featured classes require some more thought. The default copy semantics
    for fully featured classes is also the memberwise copy, and this can be extremely
    dangerous. Consider again the `SimpleString` class. You would invite disaster
    if you allowed a user to make a memberwise copy of a live `SimpleString` class.
    Two `SimpleString` classes would point to the same `buffer`. With both of the
    copies appending to the same `buffer`, they’ll clobber each other. [Figure 4-4](ch04.xhtml#ch04fig04)
    summarizes the situation.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig4_4.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A depiction of default copy semantics on the `SimpleString` class*'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: This result is bad, but even worse things happen when the `SimpleString` classes
    start destructing. When one of the `SimpleString` classes is destructed, `buffer`
    will be freed. When the remaining `SimpleString` class tries to write its `buffer`—bang!—you
    have undefined behavior. At some point, this remaining `SimpleString` class will
    be destructed and free `buffer` again, resulting in what is commonly called a
    *double free*.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '*Like its nefarious cousin the use after free, the double free can result in
    subtle and hard-to-diagnose bugs that manifest only very infrequently. A double
    free occurs when you deallocate an object twice. Recall that once you’ve deallocated
    an object, its storage lifetime ends. This memory is now in an undefined state,
    and if you destruct an object that’s already been destructed, you’ve got undefined
    behavior. In certain situations, this can cause serious security vulnerabilities.*'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: You can avoid this dumpster fire by taking control of copy semantics. You can
    specify copy constructors and copy assignment operators, as described in the following
    sections.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '***Copy Constructors***'
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two ways to copy an object. One is to use *copy construction*, which
    creates a copy and assigns it to a brand-new object. The copy constructor looks
    like other constructors:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice that `other` is `const`. You’re copying from some original `SimpleString`,
    and you have no reason to modify it. You use the copy constructor just like other
    constructors, using the uniform initialization syntax of braced initializers:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The second line invokes the copy constructor of `SimpleString` with `a` to yield
    `a_copy`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement the copy constructor of `SimpleString`. You want what is known
    as a *deep copy* where you copy the data pointed to by the original `buffer` into
    a new `buffer`, as depicted in [Figure 4-5](ch04.xhtml#ch04fig05).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig4_5.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: A depiction of a deep copy on the `SimpleString` class*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than copying the pointer `buffer`, you’ll make a new allocation on the
    free store and then copy all the data pointed to by the original `buffer`. This
    gives you two independent `SimpleString` classes. [Listing 4-25](ch04.xhtml#ch04ex25)
    implements the copy constructor of `SimpleString`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 4-25: `SimpleString` class’s copy constructor*'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: You use member initializers for `max_size` ➊, `buffer` ➋, and `length` ➌ and
    pass in the corresponding fields on `other`. You can use array new ➋ to initialize
    `buffer` because you know `other.max_size` is greater than 0\. The copy constructor’s
    body contains a single statement ➍ that copies the contents pointed to by `other.buffer`
    into the array pointed to by `buffer`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-26](ch04.xhtml#ch04ex26) uses this copy constructor by initializing
    a `SimpleString` with an existing `SimpleString`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Listing 4-26: A program using `SimpleString` class’s copy constructor*'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: In the program, `SimpleString a_copy` ➊ is copy constructed from `a`. It’s equivalent
    to—and independent from—the original. You can append different messages to the
    end of `a` ➋ and `a_copy` ➌, and the changes are isolated.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: The copy constructor is invoked when passing `SimpleString` into a function
    by value, as demonstrated in [Listing 4-27](ch04.xhtml#ch04ex27).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*Listing 4-27: A program illustrating that copy constructors get invoked when
    passing an object by value*'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '*You shouldn’t pass by value to avoid modification. Use a `const` reference.*'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: The performance impact of copying can be substantial, especially in a situation
    where free store allocations and buffer copies are involved. For example, suppose
    you have a class that manages the life cycle of a gigabyte of data. Each time
    you copy the object, you’ll need to allocate and copy a gigabyte of data. This
    can take a lot of time, so you should be absolutely sure you need the copy. If
    you can get away with passing a `const` reference, strongly prefer it.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '***Copy Assignment***'
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The other way to make a copy in C++ is with the *copy assignment operator*.
    You can create a copy of an object and assign it to another existing object, as
    demonstrated in [Listing 4-28](ch04.xhtml#ch04ex28).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 4-28: Using the default copy assignment operator to create a copy
    of an object and assign it to another existing object*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '*The code in [Listing 4-28](ch04.xhtml#ch04ex28) causes undefined behavior
    because it doesn’t have a user-defined copy assignment operator.*'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➊ *copy assigns* `a` to `b`. The major difference between copy assignment
    and copy construction is that in copy assignment, `b` might already have a value.
    You must clean up `b`’s resources before copying `a`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '*The default copy assignment operator for simple types just copies the members
    from the source object to the destination object. In the case of `*SimpleString*`,
    this is very dangerous for two reasons. First, the original `*SimpleString*` class’s
    buffer gets rewritten without freeing the dynamically allocated `*char*` array.
    Second, now two `*SimpleString*` classes own the same buffer, which can cause
    dangling pointers and double frees. You must implement a copy assignment operator
    that performs a clean hand-off.*'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: The copy assignment operator uses the `operator=` syntax, as demonstrated in
    [Listing 4-29](ch04.xhtml#ch04ex29).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Listing 4-29: A user-defined copy assignment operator for `SimpleString`*'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: The copy assignment operator returns a reference to the result, which is always
    `*this` ➋. It’s also generally good practice to check whether `other` refers to
    `this` ➊.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'You can implement copy assignment for `SimpleString` by following these guidelines:
    free the current `buffer` of `this` and then copy `other` as you did in copy construction,
    as shown in [Listing 4-30](ch04.xhtml#ch04ex30).'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '*Listing 4-30: A copy assignment operator for `SimpleString`*'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: The copy assignment operator starts by allocating a `new_buffer` with the appropriate
    size ➊. Next, you clean up `buffer` ➋. The rest is essentially identical to the
    copy constructor in [Listing 4-25](ch04.xhtml#ch04ex25). You copy `buffer` ➌,
    `length` ➍, and `max_size` ➎ and then copy the contents from `other.buffer` into
    your own `buffer` ➏.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-31](ch04.xhtml#ch04ex31) illustrates how `SimpleString` copy assignment
    works (as implemented in [Listing 4-30](ch04.xhtml#ch04ex30)).'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*Listing 4-31: A program illustrating copy assignment with the `SimpleString`
    class*'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'You begin by declaring two `SimpleString` classes with different messages:
    the string `a` contains `We apologize for the` ➊, and `b` contains `Last` `message`
    ➋. You print these strings to verify that they contain the text you’ve specified
    ➌➍. Next, you copy assign `b` equal to `a` ➎. Now, `a` and `b` contain copies
    of the same message, `We apologize for the` ➏➐. But—and this is important—that
    message resides in two separate memory locations.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '***Default Copy***'
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Often, the compiler will generate default implementations for copy construction
    and copy assignment. The default implementation is to invoke copy construction
    or copy assignment on each of a class’s members.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'Any time a class manages a resource, you must be extremely careful with default
    copy semantics; they’re likely to be wrong (as you saw with `SimpleString`). Best
    practice dictates that you explicitly declare that default copy assignment and
    copy construction are acceptable for such classes using the `default` keyword.
    The `Replicant` class, for example, has default copy semantics, as demonstrated
    here:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Some classes simply cannot or should not be copied—for example, if your class
    manages a file or if it represents a mutual exclusion lock for concurrent programming.
    You can suppress the compiler from generating a copy constructor and a copy assignment
    operator using the `delete` keyword. The `Highlander` class, for example, cannot
    be copied:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Any attempt to copy a `Highlander` will result in a compiler error:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: I highly recommend that you explicitly define the copy assignment operator and
    copy constructor for *any* class that owns a resource (like a printer, a network
    connection, or a file). If custom behavior is not needed, use either `default`
    or `delete`. This will save you from a lot of nasty and difficult-to-debug errors.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '***Copy Guidelines***'
  id: totrans-351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you implement copy behavior, think about the following criteria:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '**Correctness** You must ensure that class invariants are maintained. The `SimpleString`
    class demonstrated that the default copy constructor can violate invariants.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '**Independence** After copy assignment or copy construction, the original object
    and the copy shouldn’t change each other’s state during modification. Had you
    simply copied `buffer` from one `SimpleString` to another, writing to one `buffer`
    could overwrite the data from the other.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '**Equivalence** The original and the copy should be the *same*. The semantics
    of sameness depend on context. But generally, an operation applied to the original
    should yield the same result when applied to the copy.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '**Move Semantics**'
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Copying can be quite time-consuming at runtime when a large amount of data is
    involved. Often, you just want to *transfer ownership* of resources from one object
    to another. You could make a copy and destroy the original, but this is often
    inefficient. Instead, you can *move*.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '*Move semantics* is move’s corollary to copy semantics, and it requires that
    after an object `y` is *moved into* an object `x`, `x` is equivalent to the former
    value of `y`. After the move, `y` is in a special state called the *moved-from*
    state. You can perform only two operations on moved-from objects: (re)assign them
    or destruct them. Note that moving an object `y` into an object `x` isn’t just
    a renaming: these are separate objects with separate storage and potentially separate
    lifetimes.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Similar to how you specify copying behavior, you specify how objects move with
    *move constructors* and *move assignment operators*.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '***Copying Can Be Wasteful***'
  id: totrans-360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Suppose you want to move a `SimpleString` into a `SimpleStringOwner` in the
    following way:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You could add a constructor for `SimpleStringOwner` and then copy-construct
    its `SimpleString` member, as demonstrated in [Listing 4-32.](ch04.xhtml#ch04ex32)
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '*Listing 4-32: A naive approach to member initialization containing a wasteful
    copy*'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: There is hidden waste in this approach. You have a copy construction ➊, but
    the caller never uses the pointed-to object again after constructing `string`
    ➋. [Figure 4-6](ch04.xhtml#ch04fig06) illustrates the issue.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig4_6.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Using the copy constructor for `string` is wasteful.*'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'You should move the guts of `SimpleString a` into the `string` field of `SimpleStringOwner`.
    [Figure 4-7](ch04.xhtml#ch04fig07) shows what you want to achieve: `SimpleString
    Owner b` steals `buffer` and sets `SimpleString a` into a destructible state.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig4_7.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-7: Swapping the buffer of `a` into `b`*'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: After moving `a`, the `SimpleString` of `b` is equivalent to the former state
    of `a`, and `a` is destructible.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Moving can be dangerous. If you accidentally use moved-from `a`, you’d invite
    disaster. The class invariants of `SimpleString` aren’t satisfied when `a` is
    moved from.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the compiler has built-in safeguards: *lvalues* and *rvalues*.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '***Value Categories***'
  id: totrans-375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Every expression has two important characteristics: its *type* and its *value
    category*. A value category describes what kinds of operations are valid for the
    expression. Thanks to the evolutionary nature of C++, value categories are complicated:
    an expression can be a “generalized lvalue” (*glvalue*), a “pure rvalue” (*prvalue*),
    an “expiring value” (*xvalue*), an *lvalue* (a glvalue that isn’t an xvalue),
    or an *rvalue* (a prvalue or an xvalue). Fortunately for the newcomer, you don’t
    need to know much about most of these value categories.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: We’ll consider a very simplified view of value categories. For now, you’ll just
    need a general understanding of lvalues and rvalues. An *lvalue* is any value
    that has a name, and an *rvalue* is anything that isn’t an lvalue.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following initializations:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The etymology of these terms is *right value* and *left value*, referring to
    where each appears with respect to the equal sign in construction. In the statement
    `int x = 50;`, `x` is left of the equal sign (lvalue) and `50` is right of the
    equal sign (rvalue). These terms aren’t totally accurate because you can have
    an lvalue on the right side of an equal sign (as in copy assignment, for example).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '*The ISO C++ Standard details Value Categories in [basic] and [expr].*'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '***lvalue and rvalue References***'
  id: totrans-383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can communicate to the compiler that a function accepts lvalues or rvalues
    using *lvalue references* and *rvalue references*. Up to this point in this book,
    every reference parameter has been an lvalue reference, and these are denoted
    with a single `&`. You can also take a parameter by rvalue reference using `&&`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the compiler does an excellent job of determining whether an object
    is an lvalue or an rvalue. In fact, you can define multiple functions with the
    same name but with different parameters, and the compiler will automatically call
    the correct version depending on what arguments you provide when you invoke the
    function.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-33](ch04.xhtml#ch04ex33) contains two functions with the name `ref_type`
    function to discern whether the invoker passed an lvalue or an rvalue reference.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '*Listing 4-33: A program containing an overloaded function with lvalue and
    rvalue references*'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: The `int &x` version ➊ takes an lvalue reference, and the `int &&x` version
    ➋ takes an rvalue reference. You invoke `ref_type` three times. First, you invoke
    the lvalue reference version, because `x` is an lvalue (it has a name) ➌. Second,
    you invoke the rvalue reference version because `2` is an integer literal without
    a name ➍. Third, the result of adding 2 to `x` is not bound to a name, so it’s
    an rvalue ➎.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '*Defining multiple functions with the same name but different parameters is
    called *function overloading*, a topic you’ll explore in detail in [Chapter 9](ch09.xhtml#ch09).*'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '***The std::move Function***'
  id: totrans-392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can cast an lvalue reference to an rvalue reference using the `std::move`
    function from the `<utility>` header. [Listing 4-34](ch04.xhtml#ch04ex34) updates
    [Listing 4-33](ch04.xhtml#ch04ex33) to illustrate the use of the `std::move` function.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '*Listing 4-34: An update to [Listing 4-33](ch04.xhtml#ch04ex33) using `std::move`
    to cast `x` to an rvalue*'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: As expected, `std::move` changes the lvalue `x` into an rvalue ➊. You never
    call the lvalue `ref_type` overload.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '*The C++ committee probably should have named `std::move` as `std::rvalue`,
    but it’s the name we’re stuck with. The `std:move` function doesn’t actually move
    anything—it casts.*'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'Be very careful when you’re using `std::move`, because you remove the safeguards
    keeping you from interacting with a moved-from object. You can perform two actions
    on a moved-from object: destroy it or reassign it.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: How lvalue and rvalue semantics enable move semantics should now be clear. If
    an lvalue is at hand, moving is suppressed. If an rvalue is at hand, moving is
    enabled.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '***Move Construction***'
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Move constructors look like copy constructors except they take rvalue references
    instead of lvalue references.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Consider the `SimpleString` move constructor in [Listing 4-35](ch04.xhtml#ch04ex35).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '*Listing 4-35: A move constructor for `SimpleString`*'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `other` is an rvalue reference, you’re allowed to cannibalize it. In
    the case of `SimpleString`, this is easy: just copy all fields of `other` into
    `this` ➊ and then zero out the fields of `other` ➋. The latter step is important:
    it puts `other` in a moved-from state. (Consider what would happen upon the destruction
    of `other` had you not cleared its members.)'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Executing this move constructor is a *lot* less expensive than executing the
    copy constructor.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: The move constructor is designed to *not* throw an exception, so you mark it
    `noexcept`. Your preference should be to use `noexcept` move constructors; often,
    the compiler cannot use exception-throwing move constructors and will use copy
    constructors instead. Compilers prefer slow, correct code instead of fast, incorrect
    code.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '***Move Assignment***'
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also create a move analogue to copy assignment via `operator=`. The
    move assignment operator takes an rvalue reference rather than a `const` lvalue
    reference, and you usually mark it `noexcept`. [Listing 4-36](ch04.xhtml#ch04ex36)
    implements such a move assignment operator for `SimpleString`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '*Listing 4-36: A move assignment operator for `SimpleString`*'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: You declare the move assignment operator using the rvalue reference syntax and
    the `noexcept` qualifier, as with the move constructor ➊. The self-reference check
    ➋ handles the move assignment of a `SimpleString` to itself. You clean up `buffer`
    ➌ before assigning the fields of `this` to the fields of `other` ➍ and zero out
    the fields of `other` ➎. Aside from the self-reference check ➋ and the cleanup
    ➌, the move assignment operator and the move constructor are functionally identical.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that `SimpleString` is movable, you can complete the `SimpleString` constructor
    of `SimpleStringOwner`:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `x` is an lvalue, so you must `std::move x` into the move constructor of
    `string` ➊. You might find `std::move` odd, because `x` is an rvalue reference.
    Recall that lvalue/rvalue and lvalue reference/rvalue reference are distinct descriptors.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider if `std::move` weren’t required here: what if you moved from `x` and
    then used it inside the constructor? This could lead to bugs that are hard to
    diagnose. Remember that you cannot use moved-from objects except to reassign or
    destruct them. Doing anything else is undefined behavior.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-37](ch04.xhtml#ch04ex37) illustrates the `SimpleString` move assignment.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '*Listing 4-37: A program illustrating move assignment with the `SimpleString`
    class*'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: 'As in [Listing 4-31](ch04.xhtml#ch04ex31), you begin by declaring two `SimpleString`
    classes with different messages: the string `a` contains `We apologize for the`
    ➊, and `b` contains `Last message` ➋. You print these strings to verify that they
    contain the strings you’ve specified ➌➍. Next, you move assign `b` equal to `a`
    ➎. Note that you had to cast `a` to an `rvalue` using `std::move`. After the move
    assignment, `a` is in a moved-from state, and you can’t use it unless you reassign
    it to a new value. Now, `b` owns the message that `a` used to own, `We apologize
    for the` ➏.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '***The Final Product***'
  id: totrans-422
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You now have a fully implemented `SimpleString` that supports move and copy
    semantics. [Listing 4-38](ch04.xhtml#ch04ex38) brings these all together for your
    reference.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '*Listing 4-38: A fully specified `SimpleString` class supporting copy and move
    semantics*'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '***Compiler-Generated Methods***'
  id: totrans-426
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Five methods govern move and copy behavior:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: The destructor
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The copy constructor
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The move constructor
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The copy assignment operator
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The move assignment operator
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiler can generate default implementations for each under certain circumstances.
    Unfortunately, the rules for which methods get generated are complicated and potentially
    uneven across compilers.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: You can eliminate this complexity by setting these methods to `default`/`delete`
    or by implementing them as appropriate. This general rule is the *rule of five*,
    because there are five methods to specify. Being explicit costs a little time,
    but it saves a lot of future headaches.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: The alternative is memorizing [Figure 4-8](ch04.xhtml#ch04fig08), which summarizes
    the interactions between each of the five functions you implement and each that
    the compiler generates on your behalf.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig4_8.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-8: A chart illustrating which methods the compiler generates when
    given various inputs*'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: If you provide nothing, the compiler will generate all five destruct/copy/move
    functions. This is the *rule of zero*.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 'If you explicitly define any of destructor/copy constructor/copy assignment
    operator, you get all three. This is dangerous, as demonstrated earlier with `SimpleString`:
    it’s too easy to get into an unintended situation in which the compiler will essentially
    convert all your moves into copies.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you provide only move semantics for your class, the compiler will
    not automatically generate anything except a destructor.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve completed the exploration of the object life cycle. Your journey began
    in storage durations, where you saw an object lifetime from construction to destruction.
    Subsequent study of exception handling illustrated deft, lifetime-aware error
    handling and enriched your understanding of RAII. Finally, you saw how copy and
    move semantics grant you granular control over object lifetimes.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '**EXERCISES**'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '**4-1.** Create a `struct TimerClass`. In its constructor, record the current
    time in a field called `timestamp` (compare with the POSIX function `gettimeofday`).'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '**4-2.** In the destructor of TimerClass, record the current time and subtract
    the time at construction. This time is roughly the *age* of the timer. Print this
    value.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '**4-3.** Implement a copy constructor and a copy assignment operator for TimerClass.
    The copies should share timestamp values.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '**4-4.** Implement a move constructor and a move assignment operator for TimerClass.
    A moved-from TimerClass shouldn’t print any output to the console when it gets
    destructed.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '**4-5.** Elaborate the TimerClass constructor to accept an additional `const
    char* name` parameter. When `TimerClass` is destructed and prints to stdout, include
    the name of the timer in the output.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '**4-6.** Experiment with your TimerClass. Create a timer and move it into a
    function that performs some computationally intensive operation (for example,
    lots of math in a loop). Verify that your timer behaves as you expect.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '**4-7.** Identify each method in the SimpleString class ([Listing 4-38](ch04.xhtml#ch04ex38)).
    Try reimplementing it from scratch without referring to the book.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '*Optimized C++: Proven Techniques for Heightened Performance* by Kurt Guntheroth
    (O’Reilly Media, 2016)'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14*
    by Scott Meyers (O’Reilly Media, 2015)'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
