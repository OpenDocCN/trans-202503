<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>Arduino for Arduinians</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:67118b6d-3178-4c1c-99a1-6e412fe74179" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch18" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch18">
<span class="CN"><span aria-label=" Page 303. " epub:type="pagebreak" id="pg_303" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">18</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">ARDUINO-TO-RS485 COMMUNICATION</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="INTRO">In the previous chapter, you used the RS232 bus to create long, reliable wired data connections between Arduino microcontrollers and other devices. This chapter introduces the RS485 bus, which you can use for even longer wired connections.</p>
<p class="TX">The RS485 data bus is used for a wide range of devices, from device controllers for heating, ventilation, and air conditioning (HVAC) systems to remote-sensor communications and security system networks. It requires a twin-core shielded wire. Depending on the data speed, your cable length can extend more than 800 meters, and you can connect up to 256 devices on a single bus. This secure, interference-free communication between devices isn’t possible with wireless data modules. RS485 modules are quite inexpensive, allowing you to easily use them in your own projects.</p>
<p class="TX">In this chapter, I’ll explain how to connect RS485 interface modules with Arduino. You’ll learn to:</p>
<ul class="ul">
<li class="BL">Send data from a remote Arduino to your PC via a circuit</li>
<li class="BL">Create a remote thermometer with LCD readout</li>
<li class="BL"><span aria-label=" Page 304. " epub:type="pagebreak" id="pg_304" role="doc-pagebreak"/>Build remote-controlled Arduino projects with one primary controller and two or more secondary remote-controlled Arduinos</li>
</ul>
<p class="TX">You can use these projects as a framework for your future Arduino-to-RS485 communication needs.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h1-131"/><samp class="SANS_Futura_Std_Bold_B_11">The RS485 Bus</samp></h2>
<p class="TNI">The RS485 data bus was designed to connect two or more data terminal equipment devices directly without needing modems over a longer distance than is possible with other data buses like the RS232. It’s ideal for connecting two microcontroller-based devices that need to communicate with each other, as it’s more reliable than wireless data links and works over a much greater distance between units.</p>
<p class="TX">Like RS232, RS485 is a serial data bus that operates in a similar manner to the Arduino’s serial port (usually found on pins D0 and D1). However, data doesn’t simply pass from the Arduino through an RS485 interface to the RS485-based device at the other end. The Arduino must tell the RS485 device whether it’s transmitting or receiving data before the data can move along the bus as required. The data then travels along the RS485 bus as required to another RS485 device, then to the attached Arduino.</p>
<p class="TX">Although the RS485 bus sends sequential bits of data representing ones and zeros, the signal type differs from the TTL serial you’re used to with Arduino. For comparison, the image in <a href="chapter18.xhtml#fig18-1">Figure 18-1</a> shows some data being sent from an Arduino’s serial port, as captured on an oscilloscope. As you can see, the ones are at 5 V and the zeros are at 0 V.</p>
<figure class="IMG"><img alt="AN IMAGE OF TTL LOGIC DATA CAPTURED FROM AN OSCILLOSCOPE" class="img1" id="fig18-1" src="../images/fig18-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-1: Data being sent from an Arduino serial port</samp></p></figcaption>
</figure>
<p class="TX">Now consider the same piece of data being sent along RS485, as shown in <a href="chapter18.xhtml#fig18-2">Figure 18-2</a>. RS485 uses two wires, A and B. When a 1 is sent, the A line <span aria-label=" Page 305. " epub:type="pagebreak" id="pg_305" role="doc-pagebreak"/>has a voltage higher than the B line, and when a 0 is sent, the A line has a voltage lower than the B line. The voltages used can vary between <span class="symbol">−</span>7 V and 12 V DC or more, depending on the RS485 interface hardware used.</p>
<figure class="IMG"><img alt="AN IMAGE OF RS485 LOGIC DATA CAPTURED FROM AN OSCILLOSCOPE" class="img1" id="fig18-2" src="../images/fig18-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-2: Data being sent from an RS485 interface</samp></p></figcaption>
</figure>
<p class="TX">Using different voltages for ones and zeros over two wires enables clear definition of the two bits, removing chance of confusion and thus increasing data accuracy. Thanks to the wide voltage range, the length of the RS485 cable has less effect on the signal integrity, as there’s more scope for a change in signal voltage due to cable length (the longer the cable, the larger the voltage drop over the cable due to the resistance of wire). Combined with the use of shielded cable, this voltage range means you can use RS485 over much longer distances than other data buses, such as RS232.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h2 class="H1" id="sec2"><span id="h1-132"/><samp class="SANS_Futura_Std_Bold_B_11">Connecting to RS485</samp></h2>
<p class="TNI">The basic RS485 interface board or module has a transmit terminal (called RO) and receive terminal (called DI) used for communication between the Arduino, along with power (usually 5V) and GND. An additional signal from the microcontroller to the RS485 interface, usually labeled DE/RE, indicates whether data will be received or transmitted. On some modules, DE and RE are separate pins which you must connect with one other. Finally, as described in the previous section, connection between the RS485 interfaces uses two wires, A and B. This allows for <i>half-duplex communication</i>, in which data travels in one direction at a time.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>The RS485 bus also supports full-duplex communication over four wires, but describing this in detail is outside the scope of this book.</i></p>
<p class="TX"><span aria-label=" Page 306. " epub:type="pagebreak" id="pg_306" role="doc-pagebreak"/>You can see all the pins clearly labeled on an inexpensive RS485 module, such as PMD Way part number 600197, shown in <a href="chapter18.xhtml#fig18-3">Figure 18-3</a>. These modules can be placed conveniently in solderless breadboards for experimenting or rapid prototyping. You’ll use them in projects throughout this chapter.</p>
<figure class="IMG"><img alt="AN IMAGE OF THE RS485 INTERFACE MODULE" class="img4" id="fig18-3" src="../images/fig18-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-3: An inexpensive RS485 interface module</samp></p></figcaption>
</figure>
<p class="TX"><a href="chapter18.xhtml#fig18-4">Figure 18-4</a> shows the schematic symbol used for these modules.</p>
<p class="TX">The 5V and GND pins in the schematic connect to a power source. The A and B pins of the interface modules connect to other interface modules; A pins are connected to A pins, and B pins to B pins. The DI (data in) pin receives data from the Arduino and sends it out along RS485. The R0 pin sends data received over RS485 to the Arduino. Finally, use the DE and RE pins in your circuits to set the interface module to transmit or receive data, setting them HIGH to transmit and LOW to receive data, as you’ll do in the following project.</p>
<figure class="IMG"><img alt="AN IMAGE OF THE RS485 INTERFACE MODULE SCHEMATIC SYMBOL" class="img4" id="fig18-4" src="../images/fig18-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-4: The RS485 interface module schematic symbol</samp></p></figcaption>
</figure>
<p class="HeadProject"><span id="h1-133"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #51: Creating an Arduino-to-PC Data Link</samp></p>
<p class="TNI">This project demonstrates how easy it is to send data from one Arduino, to another Arduino, to a PC with the RS485 bus. You can also use it to capture data to a PC from a remote Arduino.</p>
<p class="TX">You’ll need the following parts:</p>
<ul class="ul">
<li class="BL">Two Arduino Uno or compatible boards and one USB cable</li>
<li class="BL">Two RS485 interface modules</li>
<li class="BL">Two solderless breadboards</li>
<li class="BL">Assorted jumper wires</li>
<li class="BL">A suitable power supply for an Arduino Uno or compatible board</li>
<li class="BL">A twin-core wire for a long-distance communication (optional)</li>
</ul>
<p class="TX">As with all the projects in this chapter, you’ll create two Arduino-to- RS485 circuits: a receiver circuit and a transmitter circuit. The transmitter’s Arduino will send data to the receiver’s Arduino via RS485, and that data will then travel to the PC via the usual USB connection. You may find it easier to upload the receiver and transmitter sketches for this project to their respective Arduinos before constructing the circuits, as it is then easier to build out the circuits, especially over a distance.</p>
<p class="TX"><span aria-label=" Page 307. " epub:type="pagebreak" id="pg_307" role="doc-pagebreak"/>If you want to run a long RS485 cable, use shielded twin-core cable and use the cable shield to connect the GND of the transmitter and receiver. However, you can also test this project with short hook-up wire.</p>
<p class="TX"><a href="chapter18.xhtml#fig18-5">Figure 18-5</a> shows the schematic diagram for the receiver circuit.</p>
<figure class="IMG"><img alt="AN IMAGE OF THE PROJECT #51 RECEIVER CIRCUIT SCHEMATIC" class="img8" id="fig18-5" src="../images/fig18-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-5: The Project #51 receiver circuit schematic</samp></p></figcaption>
</figure>
<p class="TX"><a href="chapter18.xhtml#fig18-6">Figure 18-6</a> shows the schematic diagram for the transmitter circuit.</p>
<figure class="IMG"><img alt="AN IMAGE OF THE PROJECT #51 TRANSMITTER CIRCUIT SCHEMATIC" class="img8" id="fig18-6" src="../images/fig18-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-6: The Project #51 transmitter circuit schematic</samp></p></figcaption>
</figure>
<p class="TX">Once you’ve built the circuits and uploaded the sketches, connect the receiver unit to the PC via USB and open the Arduino’s Serial Monitor or terminal software such as CoolTerm (as first explained in <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span>). The terminal should display values for analog pin 0 on the transmitter circuit’s Arduino, as shown in <a href="chapter18.xhtml#fig18-7">Figure 18-7</a>.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE RESULTS OF PROJECT #51 IN THE COOLTERM WINDOW" class="img7" id="fig18-7" src="../images/fig18-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-7: Example output from Project #51</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 308. " epub:type="pagebreak" id="pg_308" role="doc-pagebreak"/>Let’s see how this works, first taking a closer look at the sketch for the transmitter circuit:</p>
<span id="pro-51"/>

<pre><code>// Project #51 - Transmitter

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #include &lt;SoftwareSerial.h&gt;
SoftwareSerial RS485(4, 3);

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> #define TXRX 2 // Using D2 for RS485 DE/RE

void setup()
{
    RS485.begin(9600);
    pinMode(TXRX, OUTPUT);
    digitalWrite(TXRX, HIGH); // RS485 transmit
}

void loop()
{
    RS485.print("A0 measures: ");
    RS485.println(analogRead(0));
}
</code></pre>

<p class="TX">The sketch configures software serial to communicate with the RS485 interface modules using digital pins D4 and D3 <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. It uses Arduino digital pin D2 to control the DE/RE pins that determine the data direction on the RS485 bus <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the sketch starts the software serial that will communicate with the RS485 module, then sets pin D2 to output to control the data direction on the RS485 module. It then sets the direction to transmit. Finally, in <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>, the sketch continuously sends the example data in the form of the value for analog input 0 along the RS485 bus via software serial.</p>
<p class="TX">Now consider the receiver circuit sketch:</p>
<span id="pro-51a"/>

<pre><code>// Project #51 - Receiver

#include &lt;SoftwareSerial.h&gt;
SoftwareSerial RS485(4, 3);

#define TXRX 2 // Using D2 for RS485 DE/RE

void setup()
{
    Serial.begin(9600);
    pinMode(TXRX, OUTPUT);
  <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> digitalWrite(TXRX, LOW); // RS485 receive
}

<span aria-label=" Page 309. " epub:type="pagebreak" id="pg_309" role="doc-pagebreak"/>void loop()
{
    if (RS485.available())
    {
      <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> Serial.write(RS485.read());
    }
}
</code></pre>

<p class="TX">Configuration for the receiver sketch is identical to the transmitter sketch, except that the program sets the RS485 module to receive mode by setting digital pin D2 to LOW <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The Arduino then waits for a character of text to come from the RS485 bus via software serial. When a character arrives, the Arduino sends it to the attached computer via hardware serial and USB <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. You can use this project to send any type of data generated by devices connected to an Arduino over an RS485 data link and back to a PC for recording.</p>
<p class="TX">The next project demonstrates a way of viewing data received over an RS485 data link that is independent of using a computer for operation.</p>
<p class="HeadProject"><span id="h1-134"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #52: Creating an Arduino-to-Arduino Data Link</samp></p>
<p class="TNI">In this project, you’ll build an RS485 data link that sends temperature data from a BMP180 sensor over the bus, to be displayed using an I<sup>2</sup>C PCF8574 LCD module. Apart from being another good demonstration of using the RS485 data bus, this project serves as a framework for building remote real-time monitoring systems that don’t require a host computer at the receiving end, such as operating temperature, machine speed, or other sensor data.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>If you’re not familiar with I</i><i><sup>2</sup></i><i>C PCF8574 module LCDs, review their use as described in <a href="chapter13.xhtml">Chapter 13</a>. I also cover the BMP180 sensor in <a href="chapter10.xhtml">Chapter 10</a>.</i></p>
<p class="TX">You’ll need the following parts for this project:</p>
<ul class="ul">
<li class="BL">Two Arduino Uno or compatible boards and one USB cable</li>
<li class="BL">Two RS485 interface modules</li>
<li class="BL">Two solderless breadboards</li>
<li class="BL">Assorted jumper wires</li>
<li class="BL">Two suitable power supplies for an Arduino Uno or compatible board</li>
<li class="BL">A PCF8574 LCD module</li>
<li class="BL">A BMP180 temperature and air pressure sensor board</li>
<li class="BL">A twin-core wire for a longer distance communication (optional)</li>
</ul>
<p class="TX">You’ll again build two Arduino-to-RS485 circuits, a receiver and a transmitter. In this project, the transmitter’s Arduino will send temperature data to the receiver’s Arduino via RS485 to be displayed on the LCD. Again, you may find it easier to upload the two sketches for this project to their respective Arduinos before constructing the circuits.</p>
<p class="TX"><span aria-label=" Page 310. " epub:type="pagebreak" id="pg_310" role="doc-pagebreak"/><a href="chapter18.xhtml#fig18-8">Figure 18-8</a> shows the schematic diagram for the receiver circuit.</p>
<figure class="IMG"><img alt="AN IMAGE OF THE PROJECT #52 RECEIVER CIRCUIT SCHEMATIC" class="img8" id="fig18-8" src="../images/fig18-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-8: The Project #52 receiver circuit schematic</samp></p></figcaption>
</figure>
<p class="TX"><a href="chapter18.xhtml#fig18-9">Figure 18-9</a> shows the schematic for the transmitter circuit.</p>
<figure class="IMG"><img alt="AN IMAGE OF THE PROJECT #52 TRANSMITTER CIRCUIT SCHEMATIC" class="img8" id="fig18-9" src="../images/fig18-9.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-9: The Project #52 transmitter circuit schematic</samp></p></figcaption>
</figure>
<p class="TX">Once you have uploaded the sketches to their respective Arduino boards and the circuits are complete, power both circuits up. The current ambient temperature should appear on the LCD, as shown in <a href="chapter18.xhtml#fig18-10">Figure 18-10</a>.</p>
<figure class="IMG"><img alt="AN IMAGE OF THE PROJECT #52 LCD DISPLAYING: “TEMPERATURE: 28.10 CELSIUS" class="img8" id="fig18-10" src="../images/fig18-10.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-10: Example output from Project #52</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 311. " epub:type="pagebreak" id="pg_311" role="doc-pagebreak"/>Let’s see how this works, first taking a closer look at the transmitter sketch:</p>
<span id="pro-52"/>

<pre><code>// Project #52 - Transmitter

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #include &lt;Adafruit_BMP085.h&gt;
Adafruit_BMP085 bmp;

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> #include &lt;SoftwareSerial.h&gt;
SoftwareSerial RS485(4, 3);

<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> #define TXRX 2 // Using D2 for RS485 DE/RE

void setup()
{
    RS485.begin(9600);
    pinMode(TXRX, OUTPUT);
    digitalWrite(TXRX, HIGH); // RS485 transmit
    bmp.begin();
}

void loop()
{
    RS485.print(bmp.readTemperature());
    delay(500);
}
</code></pre>

<p class="TX">The sketch first includes the library required to use the BMP180 temperature sensor and creates the instance <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Again, the sketch configures software serial to communicate with the RS485 interface modules using digital pins D4 and D3 <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. The sketch uses Arduino digital pin D2 to control the DE/RE pins that determine the data direction on the RS485 bus <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the sketch starts the software serial that will communicate with the RS485 module, then sets pin D2 to output to control the data direction on the RS485 module. It then sets the direction to transmit and starts the BMP180 sensor. Finally, in <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>, it sends temperature data from the BMP180 sensor every half a second along the RS485 bus via software serial.</p>
<p class="TX">Now consider the receiver circuit sketch:</p>
<span id="pro-52a"/>

<pre><code>// Project #52 - Receiver

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #include &lt;Wire.h&gt;
#include &lt;LiquidCrystal_PCF8574.h&gt;
LiquidCrystal_PCF8574 lcd(0x27);

#include &lt;SoftwareSerial.h&gt;
SoftwareSerial RS485(4, 3);

#define TXRX 2 // Using D2 for RS485 DE/RE

float temperature = 0;

<span aria-label=" Page 312. " epub:type="pagebreak" id="pg_312" role="doc-pagebreak"/>void setup()
{
    Wire.begin();
    Wire.beginTransmission(0x27);
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> lcd.begin(16, 2);
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> lcd.setBacklight(255);
  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> lcd.clear();
    RS485.begin(9600);
    pinMode(TXRX, OUTPUT);
    digitalWrite(TXRX, LOW); // RS485 receive
}

void loop()
{
    byte incoming = RS485.available();
  <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> if (incoming != 0)
    {
        temperature = RS485.parseFloat();
      <span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> lcd.home();
        lcd.clear();
        lcd.setCursor(0, 0);
        lcd.print("Temperature:");
        lcd.setCursor(0, 1);
        lcd.print(temperature);
        lcd.print(" Celsius");
    }
}
</code></pre>

<p class="TX">Since the receiver uses the PCF8574 I<sup>2</sup>C LCD, the required library for the I<sup>2</sup>C bus, the sketch includes the LCD display and instance <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, it starts the I<sup>2</sup>C bus and begins communication to the LCD in order to configure the LCD display size <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, turn on the backlight <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, and clear the display <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. The sketch then includes the RS485 configuration for the receiver sketch. This is identical to that of the transmitter sketch, except that the sketch sets the RS485 module to receive mode by setting digital pin D2 to LOW.</p>
<p class="TX">The Arduino waits for text to come from the RS485 bus via software serial <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. Once the text arrives, the sketch converts it into a floating-point number using the <samp class="SANS_TheSansMonoCd_W5Regular_11">.parsefloat()</samp> function from the serial library. The temperature information is then displayed on the LCD <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. The process repeats when more temperature data arrives from the transmitter circuit.</p>
<p class="HeadProject"><span id="h1-135"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #53: Remote Control Operation</samp></p>
<p class="TNI">Since it supports longer cable runs, the RS485 bus also lends itself well to remote-control applications. This project demonstrates remote-control operation over RS485, in which one Arduino circuit (the primary) sends signals to another Arduino (the secondary) over RS485 to take various actions.</p>
<p class="TX"><span aria-label=" Page 313. " epub:type="pagebreak" id="pg_313" role="doc-pagebreak"/>You’ll need the following parts for this project:</p>
<ul class="ul">
<li class="BL">Two Arduino Uno or compatible boards and one USB cable</li>
<li class="BL">Two RS485 interface modules</li>
<li class="BL">Two solderless breadboards</li>
<li class="BL">Assorted jumper wires</li>
<li class="BL">Two suitable power supplies for an Arduino Uno or compatible board</li>
<li class="BL">A twin-core wire for a longer distance communication (optional)</li>
</ul>
<p class="TX">In this project, the primary Arduino sends single characters to the secondary Arduino via RS485. You’ll program the secondary Arduino to take various actions depending on the character received; if an unknown command is received, a default action will occur. Again, you may find it easier to upload the sketches to each Arduino before constructing the circuits.</p>
<p class="TX"><a href="chapter18.xhtml#fig18-11">Figure 18-11</a> shows the schematic diagram for the primary circuit.</p>
<figure class="IMG"><img alt="AN IMAGE OF THE PROJECT #53 PRIMARY CIRCUIT SCHEMATIC" class="img8" id="fig18-11" src="../images/fig18-11.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-11: The Project #53 primary circuit schematic</samp></p></figcaption>
</figure>
<p class="TX"><a href="chapter18.xhtml#fig18-12">Figure 18-12</a> shows the schematic diagram for the secondary circuit.</p>
<figure class="IMG"><img alt="AN IMAGE OF THE PROJECT #53 SECONDARY CIRCUIT SCHEMATIC" class="img8" id="fig18-12" src="../images/fig18-12.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-12: The Project #53 secondary circuit schematic</samp></p></figcaption>
</figure>
<p class="TX">Once you have uploaded the project sketches to their respective Arduino boards and built the circuits, power them both up. The primary Arduino should start sending commands to the secondary, which will act on those commands by blinking the Arduino’s onboard LED in various sequences.</p>
<p class="TX"><span aria-label=" Page 314. " epub:type="pagebreak" id="pg_314" role="doc-pagebreak"/>Let’s see how this works, first examining the sketch for the primary circuit:</p>
<span id="pro-53"/>

<pre><code>// Project #53 - Primary

#include &lt;SoftwareSerial.h&gt;
SoftwareSerial RS485(4, 3);

#define TXRX 2 // Using D2 for RS485 DE/RE

void setup()
{
    RS485.begin(9600);
    pinMode(TXRX, OUTPUT);
    digitalWrite(TXRX, HIGH); // RS485 transmit
}

void loop()
{
    RS485.print("0");
    delay(1000);
    RS485.print("1");
    delay(1000);
    RS485.print("2");
    delay(1000);
    RS485.print("3");
    delay(1000);
    RS485.print("8");
    delay(5000);
}
</code></pre>

<p class="TX">This sketch configures the primary circuit to transmit over RS485, as did previous projects. The point of difference is the example commands sent in <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>. The secondary Arduino is configured to act upon the commands 0, 1, 2, and 3, so the primary sketch sends those commands as a demonstration. It also sends the number 8 to demonstrate the function on the receiver which deals with unknown commands. Each command is sent in turn with a delay between each.</p>
<p class="TX">Here’s the sketch for the secondary circuit:</p>
<span id="pro-53a"/>

<pre><code>// Project #53 - Secondary

#include &lt;SoftwareSerial.h&gt;
SoftwareSerial RS485(4, 3);

#define TXRX 2 // Using D2 for RS485 DE/RE

void blinkLED(int i)
{
    for (int j = 0; j &lt; i; j++)
    {
        digitalWrite(13, HIGH);
        delay(100);
        digitalWrite(13, LOW);
        delay(100);
    }
}

void setup()
{
    RS485.begin(9600);
    pinMode(TXRX, OUTPUT);
    digitalWrite(TXRX, LOW); // RS485 receive
    pinMode(13, OUTPUT);
}

void loop()
{
  <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> if (RS485.available() &gt; 0)
    {
        char receivedChar = RS485.read();
      <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> switch (receivedChar)
        {
            case '0': blinkLED(5); break;
            case '1': blinkLED(10); break;
            case '2': blinkLED(15); break;
            case '3': blinkLED(20); break;
          <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> default: blinkLED(2); break;
        }
    }
}
</code></pre>

<span aria-label=" Page 315. " epub:type="pagebreak" id="pg_315" role="doc-pagebreak"/>
<p class="TX">The secondary circuit is configured to receive commands over RS485 then act based on those commands. To demonstrate this, the sketch uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">blinkLED()</samp> function, which accepts an integer and blinks the onboard LED that number of times. The secondary circuit awaits a character of text (the command) from the RS485 bus via the software serial port <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The secondary unit uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp> function <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> to determine which function to call, depending on the command received from the primary unit. If it receives a command that isn’t covered in the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp> function, it blinks the LED twice <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">You can modify this project for your own remote-control needs by replacing the calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">blinkLED()</samp> function with your own actionable requirements.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h2 class="H1" id="sec3"><span id="h1-136"/><samp class="SANS_Futura_Std_Bold_B_11">Controlling Two or More Secondary RS485 Devices</samp></h2>
<p class="TNI">So far, you’ve learned how to communicate between two RS485-connected Arduino boards. As mentioned earlier, however, you can control more than one secondary device with the RS485 bus, up to 256 devices in total. In this section and the following project, I’ll show you how to do so.</p>
<p class="TX">The wiring of the RS485 bus is slightly different when using three or more devices. The transceiver IC found on the modules you’ve been using <span aria-label=" Page 316. " epub:type="pagebreak" id="pg_316" role="doc-pagebreak"/>also requires a 120 Ω terminating resistor across the A and B wires at each end of the RS485 bus. This resistor is fitted with the required terminating resistor, so if you’re just using the two modules, you don’t need to change anything. If you’re using three or more of the RS485 modules covered in this chapter, though, you’ll need to desolder the terminating resistor labeled R7 on the PCB (with the value 121 on the resistor, which is interpreted as 12 Ω, with a 0 added on the end for 120 Ω) from the module. This resistor is circled in <a href="chapter18.xhtml#fig18-13">Figure 18-13</a>.</p>
<figure class="IMG"><img alt="AN IMAGE OF THE TERMINATING RESISTOR ON THE RS485 MODULE" class="img1" id="fig18-13" src="../images/fig18-13.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-13: An RS485 terminating resistor</samp></p></figcaption>
</figure>
<p class="TX">When wiring your devices over distances longer than that used for demonstration on your workbench, ensure the A/B pair of wires travel from device to device in a “daisy-chain” configuration, as shown in <a href="chapter18.xhtml#fig18-14">Figure 18-14</a>. Don’t create a separate run from each device back to a main A/B pair.</p>
<figure class="IMG"><img alt="AN EXAMPLE OF THE RS485 WIRING CONFIGURATION FOR THREE DEVICES" class="img1" id="fig18-14" src="../images/fig18-14.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-14: Example RS485 wiring configuration for three devices</samp></p></figcaption>
</figure>
<p class="TX">You’ll put this technique to work in the next project.</p>
<p class="HeadProject"><span id="h1-137"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #54: Controlling Two or More Secondary Arduino Boards</samp></p>
<p class="TNI">This project demonstrates controlling two or more secondary Arduino boards over RS485 from one primary board. One Arduino circuit (the primary) will send commands to other Arduinos (the secondary devices) over RS485, telling them to take various actions.</p>
<p class="TX"><span aria-label=" Page 317. " epub:type="pagebreak" id="pg_317" role="doc-pagebreak"/>The hardware for this project is the same as that used in Project #53, except that you’ll use two or more secondary devices. Start by building one primary device and two secondary devices, connecting them via the RS485 bus as shown in <a href="chapter18.xhtml#fig18-14">Figure 18-14</a> in the previous section. Again, it’s a good idea to upload the sketches to each Arduino before building the circuits. You can add more secondary devices to the project later, if you like, once you’ve got your three-device setup working.</p>
<p class="TX">If you’re just testing this project on your workbench, the distance of the RS485 bus will be short enough that you may not need to remove the terminating resistors from the RS485 modules, so test the code before making any changes to your hardware.</p>
<p class="TX">In this project, the primary board sends a three-digit number across the RS485 bus, which is received by all the secondary boards. The first digit of the command represents the number of the secondary unit to control (units 1 through 9), and the final 2 digits represent the command being sent to the specific secondary unit. For example, to send command 12 to secondary unit 2, the primary would send 212 across the RS485 bus, since the sketch loaded onto the second secondary unit is programmed to act based on receiving 12. If you add 10 or more secondary units, you can change the commands in the sketch so they send four-digit numbers, or modify the command coding method for your own needs.</p>
<p class="TX">This project is just a demonstration of multiple-secondary-device control over RS485. In its current form, each command sent from the primary will trigger the matching secondary device to blink its onboard LED a certain number of times. However, in your own future projects, you can replace the simple example actions in the secondary units with your own requirements.</p>
<p class="TX">Let’s see how this works in the sketches, starting with the primary device sketch:</p>
<span id="pro-54"/>

<pre><code>// Project #54 - Primary

#include &lt;SoftwareSerial.h&gt;
SoftwareSerial RS485(4, 3);

#define TXRX 2 // Using D2 for RS485 DE/RE

void setup()
{
    RS485.begin(9600);
    pinMode(TXRX, OUTPUT);
    digitalWrite(TXRX, HIGH); // RS485 transmit
}

void loop()
{
  <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> RS485.println(105); // Command for secondary 1
    delay(5000);
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> RS485.println(205); // Command for secondary 2
    delay(5000);
}
</code></pre>

<p class="TX"><span aria-label=" Page 318. " epub:type="pagebreak" id="pg_318" role="doc-pagebreak"/>In a sequence that should be familiar to you by now, the sketch first configures the primary unit to send data to the RS485 bus. In <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>, it sends two new example commands: 105 <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, which is command 5 for the secondary unit 1, and 205 <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, which is command 5 for secondary unit 2. Remember that the commands are three digits, with the first being the secondary unit to address, and the following two digits (00 to 99) being the actual command.</p>
<p class="TX">The following is the sketch for secondary device 1:</p>
<span id="pro-54a"/>

<pre><code>// Project #54 - Secondary device 1

#include &lt;SoftwareSerial.h&gt;
SoftwareSerial RS485(4, 3);

#define TXRX 2 // Using D2 for RS485 DE/RE

void blinkLED(int i)
{
    for (int j = 0; j &lt; i; j++)
    {
        digitalWrite(13, HIGH);
        delay(250);
        digitalWrite(13, LOW);
        delay(250);
    }
}

void setup()
{
    RS485.begin(9600);
    pinMode(TXRX, OUTPUT);
    digitalWrite(TXRX, LOW); // RS485 receive
    pinMode(13, OUTPUT);
}

void loop()
{
    while (RS485.available() == 0) {}
  <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> int commandType = RS485.parseInt();
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> if (commandType &gt;= 100 &amp;&amp; commandType &lt; 200)
    {
        switch (commandType)
        {
          <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> case 105: blinkLED(5); break;
            case 110: blinkLED(10); break;
            case 115: blinkLED(15); break;
            case 120: blinkLED(20); break;
          <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> default: blinkLED(2); break;
        }
    }
}
</code></pre>

<p class="TX"><span aria-label=" Page 319. " epub:type="pagebreak" id="pg_319" role="doc-pagebreak"/>This sketch is configured so that commands received from the primary unit call the <samp class="SANS_TheSansMonoCd_W5Regular_11">blinkLED()</samp> function with a varying parameter to blink the LED a different number of times. In <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>, the secondary awaits an incoming integer from the RS485 bus <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. It then checks whether the received integer falls between 100 and 199 inclusive <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. If so, meaning the command is intended for this unit, the sketch compares the integer against the preset commands using the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp> function. For example, if the command 105 is received, the <samp class="SANS_TheSansMonoCd_W5Regular_11">blinkLED()</samp> function is called to blink the onboard LED five times <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. If a command is received but not recognized <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, the LED blinks twice.</p>
<p class="TX">The first part of the sketch for secondary device 2 is the same as for secondary device 1. Only the <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp> section of the sketch differs:</p>

<pre><code>void loop()
{
    while (RS485.available() == 0) {}
    int commandType = RS485.parseInt();
  <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> if (commandType &gt;= 200 &amp;&amp; commandType &lt; 300)
    {
        switch (commandType)
        {
          <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> case 205: blinkLED(5); break;
            case 210: blinkLED(10); break;
            case 215: blinkLED(15); break;
            case 220: blinkLED(20); break;
          <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> default: blinkLED(2); break;
        }
    }
}
</code></pre>

<p class="TX">The sketch tests the received command to see whether it falls between 200 and 299 inclusive <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, as the first digit of the command (2) notes the command is for this secondary unit. If the command is for this unit, the sketch compares it against the preset commands using the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp> function. For example, if the device receives the command 205, the sketch calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">blinkLED()</samp> function to blink the onboard LED five times <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. If a command is received but not recognized <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, the LED blinks twice.</p>
<p class="TX">To add additional secondary units, you’d simply change the test line <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> so the new unit can check whether a command from the primary device falls within its required numeric range. You’d also need to add the appropriate commands and required actions in the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp> function.</p>
<p class="TX">For a challenge, you might try creating a system that returns data from the secondary devices back to the primary device.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h2 class="H1" id="sec4"><span id="h1-138"/><samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp></h2>
<p class="TNI">This chapter has given you the basic building blocks for implementing the RS485 data bus with Arduino. You can use this knowledge to make your own data transfer and control applications over longer distances, such as <span aria-label=" Page 320. " epub:type="pagebreak" id="pg_320" role="doc-pagebreak"/>monitoring sensors or controlling devices in other rooms in an office or factory.</p>
<p class="TX">In the next chapter, you’ll get started with popular Wi-Fi-capable Arduino-compatible boards to make remote-control devices that can be controlled from a cell phone or any web-enabled device.</p>
</section>
</section>
</body>
</html>