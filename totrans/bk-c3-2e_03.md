## **3**

**SELECTORS**

![Image](graphics/common-01.jpg)

Selectors are the heart of CSS, and although the original CSS1 specification had only 5 or 6, CSS2 expanded the range with 12 more. CSS3 goes further still, roughly doubling the number of available selectors.

Selectors can be broadly separated into two categories. The first are those that act directly on elements defined in the document tree (`p` elements and `href` attributes, for example); this category contains *class*, *type*, and *attribute* selectors. For the sake of expediency, I’ll group these together under the banner of *DOM selectors*. The second category contains *pseudo-selectors* that act on elements or information that sits outside of the document tree (such as the first letter of a paragraph or the last child of a parent element). I cover pseudo-selectors in [Chapter 4](ch04.html#ch04)—here I discuss DOM selectors.

CSS3 provides three new attribute selectors and one new *combinator*—that is, a selector that joins other selectors together, such as the child combinator (`>`) from CSS2\. These are defined in the Selectors Level 3 Module (*[http://www.w3.org/TR/css3-selectors/](http://www.w3.org/TR/css3-selectors/)*), which is a *W3C Recommendation* and has widespread and stable implementation across browsers. Unless you specifically need to support IE6, you can start using these CSS3 selectors right away—many sites already do.

### **Attribute Selectors**

Attribute selectors were introduced in CSS2, and, as you may expect from the name, they allow you to specify rules that match elements based on their attributes—such as `href` or `title`—and the values of those attributes. The four selectors defined in CSS2 are:

```
E[attr] {…} /* Simple Attribute Selector */
E[attr='value'] {…} /* Exact Attribute Value Selector */
E[attr~='value'] {…} /* Partial Attribute Value Selector */
E[attr|='value'] {…} /* Language Attribute Selector */
```

Before moving on to the new selectors in CSS3, a quick recap of how each selector is utilized is worthwhile. For this, I’ll use the following markup, which is a (very short) contact list:

```
  <ul>
➊ <li><a href="" lang="en-GB" rel="friend met">Peter</a></li>
➋ <li><a href="" lang="es-ES" rel="friend">Pedro</a></li>
➌ <li><a href="" lang="es-MX" rel="contact">Pancho</a></li>
  </ul>
```

The *Simple Attribute Selector* applies rules to elements that have the specified attribute defined, regardless of that attribute’s value. So given the following code:

```
a[rel] { color: red; }
```

all of the `a` elements in my markup have a `rel` attribute, despite their having different values. In this case, therefore, all elements have the rule applied. If you want to be more specific, you can use the *Exact Attribute Value Selector* to define a value:

```
a[rel='friend'] { color: red; }
```

This code applies the rule only to the second `a` element in the markup (➋) because it selects only elements that have the exact value of `friend`. If you want to select both of the elements that have this value, you would use the *Partial Attribute Value Selector*:

```
a[rel~='friend'] { color: red; }
```

This code looks for the value of `friend` as part of a space-separated list (in most cases, a word) in any `rel` attribute and so applies the rule to elements ➊ and ➋.

The final selector, the *Language Attribute Selector*, applies rules to elements that have an attribute matching the first argument in the selector, the value of which is the second argument in the selector followed immediately by a hyphen. If that sounds weirdly specific, it’s because this selector is really only intended to match language subcodes. The example markup has two Spanish names, each of which has a `lang` attribute beginning with `es-` although one is for Spain (`es-ES`) and the other is for Mexico (`es-MX`). To select both of these, you use this code:

```
a[lang|='es'] { color: red; }
```

This selects all elements with `lang` attributes whose value begins with *es*, regardless of their country values—that is, elements ➋ and ➌. You could use this selector for any attributes with hyphen-separated values, but in the great majority of cases, those will be language codes.

**NOTE**
*The attribute names used here aren’t taken from the spec but from Eric Meyer’s book* CSS Pocket Reference *(O’Reilly Media, 2011).*

### **New Attribute Selectors in CSS3**

You’ve seen how useful attribute selectors can be for finding exact or partial values, but what if you want even more flexibility? CSS3’s new selectors provide flexibility with the power to match substrings within an attribute value. This feature makes them especially great for applying rules to XML documents, which can often have more varied attribute values than HTML—though they are still quite useful for HTML developers as well.

#### ***Beginning Substring Attribute Value Selector***

The first new attribute selector—which, to avoid having to repeat that mouthful of a title, I’ll refer to as the *Beginning Selector*—finds elements whose chosen attribute begins with the string supplied to it as an argument. It uses the caret (`^`) symbol to modify the equals sign in the selector. Here’s the full syntax:

```
E[attr^='value'] {…}
```

This code looks for the supplied value at the beginning of the specified attribute. To illustrate, consider the following example markup, showing a list of three items, each of which contains a hyperlink with different (albeit similar) values for the `title` attribute:

```
<li><a href="http://example.com/" title="Image Library">Example</a></li>
<li><a href="http://example.com/" title="Free Image Library">Example</a></li>
<li><a href="http://example.com/" title="Free Sound Library">Example</a></li>
```

I’ll apply this selector to the example markup:

```
a[title^='image'] {…}
```

In this case, the rule will be applied to the `a` element in the first list item because the `title` attribute string begins with the word *image*. The rule will not be applied to the `a` element in the second item, however, because, although its `title` attribute contains that string, it doesn’t begin with it. Nor will it be applied to the third string, as that string doesn’t match.

**NOTE**
*In HTML documents, the attribute selector value is case insensitive; for XML documents, however, the value is case sensitive.*

The Beginning Selector is especially handy when you want to add visual information to hyperlinks. Here’s an example of a typical hyperlink to an external website:

```
<p>This is a <a href="http://example.com/">hyperlink</a>.</p>
```

When you see this link in your browser, you can’t immediately tell whether it’s a link to a page on the same website or to an external URI. With this new attribute, however, you can pass the protocol (*http*) as the argument and add an icon to signify external links clearly:

```
a[href^='http'] {
    background: url('link.svg') no-repeat left center;
    display: inline-block;
    padding-left: 20px;
}
```

The result is shown in [Figure 3-1](ch03.html#ch03fig1).

![Image](graphics/f03-01.jpg)

*Figure 3-1: An icon applied with the Beginning Selector*

You can extend this to cover many other web protocols, some of which—*mailto*, *ftp*, and *https*—are shown in the following example and illustrated in [Figure 3-2](ch03.html#ch03fig2).

```
a[href^='mailto'] { background-image: url('email.svg'); }
a[href^='ftp'] { background-image: url('folder.svg'); }
a[href^='https'] { background-image: url('lock.svg'); }
```

![Image](graphics/f03-02.jpg)

*Figure 3-2: More examples of link icons with the Beginning Selector*

Of course, the Beginning Selector also has many applications with attributes—such as `alt`, `cite`, and `title`—that accept more verbose values. And with the introduction of HTML5 and a whole range of new form elements and attributes, this selector and its soon-to-be-introduced siblings will become even more useful.

Consider, for example, the proposed `datetime` attribute, which accepts date-string values such as `2015-03-14`:

```
<time datetime="2015-03-14">March 14/time>
```

This means that you could use the Beginning Selector to apply styles to all elements meeting a supplied year value, which is quite handy for calendar or archiving applications:

```
[datetime^='2015'] {…}
```

#### ***Ending Substring Attribute Value Selector***

The *Ending Selector*, as I call it, works exactly like the Beginning Selector—just the other way around! That is, you use it to select attributes that *end* with the supplied value. The syntax differs by just one character: This time you use the dollar sign character (`$`) to modify the equal sign (`=`). Here’s the full syntax:

```
E[attr$='value'] {…}
```

Let’s look at the markup example from the previous section again, only this time apply the Ending Selector along with a new value:

```
a[title$='library'] {…}
```

This time the rule applies to all of the list items, as all of their `title` attribute values end with the string `library`.

Just like the Beginning Selector, you can use this selector to provide visual clarity to hyperlinks. But this time, instead of using the protocols at the beginning of the `href` attribute, you use the file types at the end. The code here shows rules for many popular file-type extensions:

```
a[href$='.pdf'] { background-image: url('pdf.svg'); }
a[href$='.doc'] { background-image: url('word.svg'); }
a[href$='.rss'] { background-image: url('feed.svg'); }
```

[Figure 3-3](ch03.html#ch03fig3) shows examples of these rules applied.

![Image](graphics/f03-03.jpg)

*Figure 3-3: Link icons applied with the Ending Selector*

To achieve this effect using CSS2, you would have to apply set `class` values to the markup (`class="pdf"`, for example). The advantage of using the Ending Selector is that links to files can be detected automatically, without requiring you to apply a particular class. The disadvantage is that sometimes the file-type suffix is not at the end of the URI. But the next new selector helps get around that situation.

#### ***Arbitrary Substring Attribute Value Selector***

The final new attribute selector—which I call the *Arbitrary Selector*—works in the same way as the previous two, but it searches for the provided substring value *anywhere* inside the specified attribute string. This selector uses the asterisk (`*`) character. Here’s the new syntax:

```
E[attr*='value'] {…}
```

To demonstrate this selector, I’ll once again use the same markup that I used for the Beginning and Ending Selectors, only this time applying the Arbitrary Selector:

```
a[title*='image'] {…}
```

This rule is applied to the first and second list items because they both contain the text string `image` in their `title` attributes, even though the string appears in a different position in each example.

You may notice that this selector is somewhat similar to the Partial Attribute Value Selector from CSS2, and, indeed, in this example, they are interchangeable:

```
a[title~='image'] {…}
```

But the two selectors differ in a major way. In the example markup, with CSS3, you could match this element using just a substring:

```
a[title*='im'] {…}
```

The Partial Attribute Value Selector, however, requires that you enter a value that matches a full item in a space-separated list—in the example that would be either `free`, `image`, or `library`—so the `im` value would not be matched anywhere in the markup when using the CSS2 selector.

To continue with the examples provided for the first two attribute selectors, the Arbitrary Selector is also handy for adding file-type icons to URIs that have parameters at the end. Consider this fairly typical URI:

```
<a href="http://example.com/example.pdf?foo=bar">Example</a>
```

If you use the Ending Selector with a value of `pdf`, this element would not be recognized as a valid target, even though the file type is a PDF, because the value does not appear at the very end of the string. Providing the same value using the Arbitrary Selector does the trick, however; the `.pdf` substring value occurs within the specified attribute, so the icon is applied.

```
a[href*='.pdf'] { background-image: url('pdf.svg'); }
```

This selector is the most flexible of the three new attribute selectors as it can match substrings no matter where they appear within strings. But this extra flexibility means you must take more care when defining the values provided to the selector; simple combinations of letters are far more likely to occur when you can match anywhere within a string—which is the reason I used it to search for `.pdf` (the file extension) rather than `pdf` (the common abbreviation).

#### ***Multiple Attribute Selectors***

You can also chain multiple selectors together, which allows you to be really specific. Using multiple selectors, you can create rules to apply to attributes with values defined for the start, end, and anywhere in between. Imagine, for example, that you had links to two files with identical names but that were located in different folders:

```
<p><a href="http://example.com/folder1/file.pdf">Example</a></p>
<p><a href="http://example.com/folder2/file.pdf">Example</a></p>
```

If you want to specify a rule to apply to only the second `p` element, you can chain some selectors together:

```
a[href^='http://'][href*='/folder2/'][href$='.pdf'] {…}
```

This code looks for `a` elements that have an `href` attribute beginning with `http://`, ending with `.pdf`, and with `/folder2/` contained within it. That’s specific!

### **The General Sibling Combinator**

Our final new DOM selector in CSS3 is a combinator, which you’ll recall means that it joins together more than one selector. The General Sibling Combinator is an extension of the Adjacent Sibling Combinator, which was introduced in CSS2\. The syntaxes differ by just a single character:

```
E + F {…} /* Adjacent Sibling Combinator */
E ~ F {…} /* General Sibling Combinator */
```

The difference between the two is subtle but important: Adjacent Sibling selects any element (`*F*`) that is immediately preceded by element (`*E*`) on the same level of the document tree, but General Sibling selects any element (`*F*`) that is preceded by element (`*E*`) on the same level of the tree, regardless of whether it is immediately adjacent.

If that still sounds confusing, I’ll explain with an example. Let’s start with this CSS:

```
h2 + p { font-weight: bolder; } /* Adjacent Sibling */
h2 ~ p { font-style: italic; } /* General Sibling */
```

And apply it to the following markup (truncated for clarity):

```
➊ <p>Next we're going to discuss…</p>
  <h2>Ren&eacute; Descartes</h2>
➋ <p>A highly influential French philosopher…</p>
➌ <p>He once famously declared:</p>
  <blockquote>
➍    <p>I think, therefore I am.</p>
  </blockquote>
➎ <p>However, this presumes the existence of the thinker.</p>
```

You can see the outcome in [Figure 3-4](ch03.html#ch03fig4). In the CSS, I’m using the Adjacent Sibling Combinator to bold the `p` element immediately adjacent to the `h2` element—that is, element ➋. I’m also using the General Sibling Combinator to italicize all the `p` elements following the `h2` element, which applies to elements ➋, ➌, and ➎.

![Image](graphics/f03-04.jpg)

*Figure 3-4: The difference between the Adjacent Sibling and General Sibling Combinators*

The paragraph elements ➊ and ➍ have neither bold nor italic rules applied to them. Why not? Because element ➊ precedes the `h2`, and element ➍ is inside a `blockquote` and, therefore, on a different level (the level below) in the document tree, so neither is affected by the rules.

To achieve the desired effect of only italicizing the paragraphs on the same level as the `h2` element in CSS2, without the General Sibling Combinator, you would need to set all `p` elements to display in italic and then add an extra rule for the `p` inside the `blockquote` to overrule the inheritance:

```
p { font-style: italic; }
blockquote p { font-style: normal; }
```

You probably won’t need to use the General Sibling Combinator often because much of its function overlaps with the basic DOM selectors. That said, you will still discover plenty of occasions where this combinator can save you a little bit of code (and time).

### **Summary**

Although attributes are a key feature of HTML4, most of them accept only a limited range of values, so many of them do not really require the attribute selectors I’ve introduced in this chapter. Aside from the `href` attribute, only a handful of attributes accept more verbose values (`alt`, `class`, `id`, `rel`, and `title` are the ones that spring to mind). But, as I mentioned before, HTML5 introduces attributes like `datetime` and `pubdate` that allow you to be more creative with selectors.

The new selectors introduced in this chapter, along with those from previous versions of CSS, provide ways to apply style rules based on defined elements and attributes. Of course, on occasion, styling elements and attributes only isn’t sufficient for your purposes. That’s when you need to add classes or nonsemantic elements to act as hooks to hang your styles on. In [Chapter 4](ch04.html#ch04), you’ll discover how CSS3 removes that need.

### **Selectors: Browser Support**

|  | **Chrome** | **Firefox** | **Safari** | **IE** |
| New attribute selectors | Yes | Yes | Yes | Yes |
| General sibling combinator | Yes | Yes | Yes | Yes |