<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_271"/><span class="big">10</span><br/>BRAINFUCK</h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent"><em>Brainfuck</em>, or <em>BF</em> as we’ll call it, is more or less the grandfather of all esolangs. It’s one of the earliest and probably the most extended, modified, discussed, and parodied esolang in existence. In this chapter, we’ll see what all the fuss is about it—there’s more to it than just the name!</p>&#13;
<h3 class="h3" id="lev1sec72"><strong>WTF Is BF?</strong></h3>&#13;
<p class="noindent">BF is the brainchild of Urban Müller, who loosed it upon an unsuspecting world in 1993. His goal was to create a tiny language leading to a tiny compiler for the Amiga computer. His compiler was 296 bytes long. Later in the chapter, we’ll encounter a BF compiler that’s only 166 bytes long.</p>&#13;
<p class="indent">How can BF compilers be so tiny? Because BF itself is tiny (see <a href="ch10.xhtml#ch010tab1">Table 10-1</a>, which describes all <em>eight</em> commands). As a certain pig might say, “Th-th-that’s all, folks!”</p>&#13;
<p class="tabcap" id="ch010tab1"><span epub:type="pagebreak" id="page_272"/><strong>Table 10-1:</strong> BF in All Its Glory</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Command</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Action</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Increment memory pointer</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">&lt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Decrement memory pointer</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">.</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Print memory as a character</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">,</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Input a character to memory</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">+</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Increment memory</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">-</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Decrement memory</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">[</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Begin loop if memory not 0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Continue loop if memory not 0</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The machine BF expects is quite similar to a Turing machine. The BF machine is a vector of cells, each of which holds a single value. Originally, there were 30,000 cells, each capable of holding a single byte [0, 255]. The interpreters we’ll use in this chapter have 32-bit cells. BF is analogous to what’s called a <em>Harvard architecture</em>, a hardware architecture in which the program space and memory are distinct. There’s no self-modifying code here, though I wouldn’t be surprised if someone has created a von Neumann version of BF just to explore what self-modifying BF code might be able to accomplish. Recall that a von Neumann architecture combines program space and memory. Modern PCs are von Neumann machines.</p>&#13;
<p class="indent">A Turing machine has a tape head that moves along a tape to read and write symbols. BF does the same, but in this case we’ll call the “tape head” a memory or cell pointer. The <span class="literal">&gt;</span> and <span class="literal">&lt;</span> instructions move the memory pointer from cell to cell and the remaining BF instructions operate on the current memory cell. When a BF program starts, it assumes each memory cell has a value of 0 and the pointer is looking at cell 0.</p>&#13;
<p class="indent">We now know what two of BF’s eight instructions do. The comma (<span class="literal">,</span>) and period (<span class="literal">.</span>) are input and output, respectively. The <span class="literal">+</span> increments the cell and <span class="literal">-</span> decrements it.</p>&#13;
<p class="indent">What makes BF interesting as a language are the <span class="literal">[</span> and <span class="literal">]</span> loop instructions. Loops begin with <span class="literal">[</span> and end with <span class="literal">]</span>, but both are commands. When BF executes the <span class="literal">[</span> instruction, it looks at the current cell and asks: “Is the value 0?” If the answer is “yes,” BF skips ahead to the <span class="literal">]</span> instruction and continues with the instruction after it. If the answer is “no,” BF moves to the next instruction to begin the loop.</p>&#13;
<p class="indent">When BF encounters a <span class="literal">]</span> instruction, it doesn’t automatically jump to the corresponding <span class="literal">[</span>. Instead, it examines the <em>current</em> memory cell and jumps back if that cell <em>isn’t</em> 0. Otherwise, the loop ends and BF continues with the next instruction.</p>&#13;
<p class="indent">Think about this for a bit. The <span class="literal">[</span> command is a gatekeeper that decides whether a loop begins, but it doesn’t check anything after that. The decision <span epub:type="pagebreak" id="page_273"/>about continuing a loop falls to the matching <span class="literal">]</span> instruction. Also, the cell that initiated the loop need not be the cell that decides whether the loop continues. BF is very flexible when it comes to looping, as we might expect from such a provocatively named language—it’s messing with our brains. BF loops are neither top-tested nor bottom-tested, but rather are a mix of both. There is a top test to decide whether the loop even begins, but from then on, the loop is bottom-tested. In C, we can accomplish something similar by nesting loops:</p>&#13;
<pre>int cond1=1, cond2=1;&#13;
while (cond1) {&#13;
    cond1 = 0;&#13;
    do {&#13;
&#13;
    } while(cond2);&#13;
}</pre>&#13;
<p class="noindent">To begin the loop, <span class="literal">cond1</span> must be true. However, after <span class="literal">cond1</span> begins the loop, it isn’t examined again; the loop runs until <span class="literal">cond2</span> is no longer true. To get the desired effect in C, <span class="literal">cond1</span> must be made false (<span class="literal">cond1 = 0</span>), so the entire structure exits when <span class="literal">cond2</span> becomes false.</p>&#13;
<p class="indent">BF code isn’t particularly easy to write, but it is complete enough to implement interesting, nontrivial programs. BF is more than ABC. We need an interpreter to see that’s the case; we’ll leave compiler design for another day.</p>&#13;
<h3 class="h3" id="lev1sec73"><strong>The Two Implementations</strong></h3>&#13;
<p class="noindent">BF implementations abound. Let’s investigate two in this section. The first is a slightly updated version of Urban Müller’s original 1993 C code for the Amiga computer. The second we’ll build from scratch in SNOBOL because an unusual, minimalist esoteric language deserves an equally unusual implementation. If you skipped <a href="ch05.xhtml#ch05">Chapter 5</a> on SNOBOL, now’s a good time to go back and read it.</p>&#13;
<h4 class="h4" id="lev2sec86"><strong><em>The Original</em></strong></h4>&#13;
<p class="noindent">The original Amiga LHA archive with the first version of BF is in the file <em>brainf-2.lha</em>. Müller’s implementation is in plain C. To work with the code on a modern Linux system, I took the liberty of updating it to compile without warnings, changed the cell size from 8 bits (<span class="literal">unsigned char</span>) to 32 bits (<span class="literal">int</span>), and increased the program space to 70,000 cells. Using 32-bit cells matches the SNOBOL implementation we’ll develop in the next section.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch010list1">Listing 10-1</a> shows the interpreter in its entirety.</p>&#13;
<pre><span epub:type="pagebreak" id="page_274"/>#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#define MAXPROG 70000&#13;
#define MAXMEM 30000&#13;
int  p, r, q;&#13;
int a[MAXMEM];&#13;
char f[MAXPROG], b, o, *s=f;&#13;
&#13;
void interpret(char *c) {&#13;
    char *d;&#13;
    r++;&#13;
    while( *c ) {&#13;
        switch(o=1,*c++) {&#13;
        case '&lt;': p--;        break;&#13;
        case '&gt;': p++;        break;&#13;
        case '+': a[p]++;     break;&#13;
        case '-': a[p]--;     break;&#13;
        case '.': putchar(a[p]); fflush(stdout); break;&#13;
        case ',': a[p]=getchar();fflush(stdout); break;&#13;
        case '[':&#13;
            for( b=1,d=c; b &amp;&amp; *c; c++ )&#13;
                b+=*c=='[', b-=*c==']';&#13;
            if(!b) {&#13;
                c[-1]=0;&#13;
                while( a[p] )&#13;
                 <span class="ent">➊</span> interpret(d);&#13;
                c[-1]=']';&#13;
                break;&#13;
            }&#13;
        case ']':&#13;
            puts("UNBALANCED BRACKETS"), exit(0);&#13;
        case '#':&#13;
            if(q&gt;2)&#13;
                printf("%2d %2d %2d %2d %2d %2d %2d %2d %2d %2d\n%*s\n",&#13;
                       *a,a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],&#13;
                       3*p+2,"^");&#13;
            break;&#13;
        default: o=0;&#13;
        }&#13;
        if( p&lt;0 || p&gt;(MAXMEM-1))&#13;
            puts("RANGE ERROR"), exit(0);&#13;
    }&#13;
    r--;&#13;
}&#13;
&#13;
int main(int argc,char *argv[]) {&#13;
    FILE *z;<span epub:type="pagebreak" id="page_275"/>&#13;
    q=argc;&#13;
    if(z=fopen(argv[1],"r")) {&#13;
        while( (b=getc(z))&gt;0 )&#13;
            *s++=b;&#13;
        *s=0;&#13;
        interpret(f);&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch010list1"><em>Listing 10-1: Urban Müller’s original BF interpreter (updated)</em></p>&#13;
<p class="indent">This implementation is quite compact and handles loops via recursion (notice the recursive call to <span class="literal">interpret</span> <span class="ent">➊</span>). Our SNOBOL implementation will process loops without recursion. Also, notice that <span class="literal">#</span> is a supported command. It prints basic debugging information if the interpreter is called with a second command line argument. The <span class="literal">#</span> command was dropped from later versions of BF. My modifications introduce <span class="literal">MAXMEM</span> and <span class="literal">MAXPROG</span> and the addition of <span class="literal">int</span> before <span class="literal">main</span> to avoid a <span class="literal">gcc</span> warning.</p>&#13;
<p class="indent">The interpreter processes the input BF program loaded into <span class="literal">f</span>. The <span class="literal">interpret</span> function loops over the characters in <span class="literal">f</span>, or the characters of the nested loop enclosed in brackets via the recursive call. If the character is a BF command, the command is performed; otherwise, it is ignored.</p>&#13;
<p class="indent">Building the interpreter is straightforward:</p>&#13;
<pre>&gt; <span class="codestrong1">gcc bfi.c -o bfi</span></pre>&#13;
<p class="noindent">So is testing it:</p>&#13;
<pre>&gt; <span class="codestrong1">bfi examples/hello.b</span>&#13;
Hello World!</pre>&#13;
<p class="indent">All the BF examples in the book’s GitHub repository work with this interpreter. However, not every BF example you’ll find on the web does. Take a look at the <em>README</em> file in the <em>examples</em> directory, as it contains attribution and license information. Credit is given to code authors where authorship is known. I’ll leave working through the operation of <em>hello.b</em> as an exercise, as there are explanatory comments in the file. As you might expect, it involves generating and printing the required sequence of ASCII values.</p>&#13;
<h4 class="h4" id="lev2sec87"><strong><em>SNOBOL Meets BF</em></strong></h4>&#13;
<p class="noindent">The seductive elegance of BF requires, indeed, almost demands that we make our own interpreter. We’ll use SNOBOL because SNOBOL provides all the facilities we need. Besides, it’s fun. The full interpreter is in <em>bf.sno</em>. Let’s begin with the parser:</p>&#13;
<pre>            MAXPROG = 70000&#13;
            MAXMEM = 30000&#13;
            prog = array('0:' MAXPROG)&#13;
          <span class="ent">➊</span> mem = array('0:' MAXMEM, 0)<span epub:type="pagebreak" id="page_276"/>&#13;
            jump = table()&#13;
&#13;
            define('parse(name)c,n,pat')      :(eparse)&#13;
parse       pat = break('&gt;&lt;+-.,[]')&#13;
            input('reader', 10, 'B,1', name)&#13;
parse_l0    c = reader                        :f(parse_l1)&#13;
            c pat                             :f(parse_l0)&#13;
            prog[n] = c &#13;
            n = ne(n,MAXPROG) n + 1           :s(parse_l0)&#13;
parse_l1    endfile(10)    &#13;
            parse = n                         :(return)&#13;
eparse</pre>&#13;
<p class="caption" id="ch010list2"><em>Listing 10-2: Parsing the input file</em></p>&#13;
<p class="indent"><a href="ch10.xhtml#ch010list2">Listing 10-2</a> presents global memory definitions and the <span class="literal">parse</span> function to read the input file and keep only actual program commands. Code is stored in the array <span class="literal">prog</span> with memory in <span class="literal">mem</span>, a second array. BF expects memory to be initialized to 0, which SNOBOL does for us via the second argument to <span class="literal">array</span> <span class="ent">➊</span>. We’ll discuss the <span class="literal">jump</span> table momentarily.</p>&#13;
<p class="indent">The <span class="literal">parse</span> function accepts the <span class="literal">name</span> of the input text file, defines a pattern to match valid program characters (<span class="literal">pat</span>), and opens the file for input, reading one character at a time.</p>&#13;
<p class="indent">The loop (<span class="literal">parse_l0</span>) reads a character into <span class="literal">c</span> and applies the pattern. If the pattern succeeds, then <span class="literal">c</span> contains one of the allowed command characters; therefore, <span class="literal">prog</span> is set and its index is incremented. Notice the SNOBOL idiom of embedding the <span class="literal">ne</span> predicate to test for maximum program length. If the predicate fails, the increment to <span class="literal">n</span> does not happen and execution falls through to <span class="literal">endfile</span>.</p>&#13;
<p class="indent">When <span class="literal">parse</span> finishes processing the input file, <span class="literal">prog</span> contains the valid commands and only the valid commands. The number of commands read is returned by assigning <span class="literal">n</span> to <span class="literal">parse</span>.</p>&#13;
<p class="indent">A BF program is executed sequentially until the interpreter encounters a loop. The original BF interpreter used recursion to handle loops; however, we’ll take a more literal approach. Every time we see an opening bracket (<span class="literal">[</span>), we’ll scan the program text forward to find the corresponding closing bracket (<span class="literal">]</span>). Similarly, for a closing bracket, we’ll scan backward to find the matching opening bracket. We could do this while interpreting the code, but that’s hideously inefficient—imagine a loop running tens of thousands of times.</p>&#13;
<p class="indent">A moment’s thought makes it clear that a single pass through the code before starting the interpreter is sufficient to locate each opening bracket and its corresponding closing bracket. This is where the <span class="literal">jump</span> table comes into play. Recall that a SNOBOL table is like a Python dictionary; it’s an associative array. The index into the table is the index of an opening bracket in <span class="literal">prog</span>. Closing brackets also go in <span class="literal">jump</span>, as their index values are unique. With <span class="literal">jump</span> built ahead of time, a single reference to <span class="literal">jump</span> during program <span epub:type="pagebreak" id="page_277"/>execution returns the proper index into <span class="literal">prog</span> for both the opening and closing brackets.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch010list3">Listing 10-3</a> shows <span class="literal">buildtable</span> and its helper function, <span class="literal">closing</span>.</p>&#13;
<pre>            define('closing(pc,plen)n,p')     :(eclosing)&#13;
closing     n = 1&#13;
            p = pc&#13;
closing_l0  p = p + 1&#13;
            eq(p,plen)                        :s(bad0)&#13;
            ident(prog[p],']')                :s(closing_l1)&#13;
            ident(prog[p],'[')                :s(closing_l2)&#13;
closing_l3  eq(n,0)                           :f(closing_l0)&#13;
            closing = p                       :(return)&#13;
closing_l1  n = n - 1                         :(closing_l3)&#13;
closing_l2  n = n + 1                         :(closing_l3)&#13;
eclosing&#13;
&#13;
            define('buildtable(plen)n,m')     :(ebuildtable)&#13;
buildtable  n = 0&#13;
build_l0    ident(prog[n],'[')                :s(build_l1)&#13;
build_l2    n = n + 1&#13;
            eq(n,plen)                        :f(build_l0)s(return)&#13;
build_l1    m = closing(n,plen)&#13;
            jump[m] = n&#13;
            jump[n] = m                       :(build_l2)&#13;
ebuildtable</pre>&#13;
<p class="caption" id="ch010list3"><em>Listing 10-3: Building the <span class="codeitalic1">jump</span> table</em></p>&#13;
<p class="indent">Here, <span class="literal">buildtable</span> scans the program text looking for an opening bracket. When it finds one, it calls <span class="literal">closing</span> to return the index of the corresponding closing bracket. Next, <span class="literal">buildtable</span> sets the <span class="literal">jump</span> table to the opening and closing locations for rapid lookup during program execution.</p>&#13;
<p class="indent">The <span class="literal">closing</span> function locates the matching closing bracket by scanning forward and incrementing <span class="literal">n</span> each time a new opening bracket is found. When a closing bracket is found, <span class="literal">n</span> is decremented. When <span class="literal">n</span> is zero, the closing bracket matching the initial opening bracket has been found, so its index is returned.</p>&#13;
<p class="indent">BF accepts single-character input that it stores in memory as an ASCII value. SNOBOL has a <span class="literal">char</span> function to return the character associated with a given ASCII value; however, it lacks what many languages call <span class="literal">ord</span>, a function to return the ASCII value of a given character. No matter; we’ll make our own:</p>&#13;
<pre>       define('ord(c)v')         :(eord)&#13;
ord    &amp;alphabet break(c) . v&#13;
       ord = size(v)             :(return)&#13;
eord</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_278"/>SNOBOL includes a special variable, <span class="literal">&amp;alphabet</span>, which is the full range of ASCII characters, [0, 255]. The <span class="literal">ord</span> function uses pattern matching to locate all the characters of this special variable up to the given character, <span class="literal">c</span>. The pattern stores this substring in <span class="literal">v</span> and the length of the substring is the ASCII code for the character.</p>&#13;
<p class="indent">We’re now ready to run the BF program in <span class="literal">prog</span>. Let’s walk through the main portion of the interpreter. We’ll add some debugging abilities to help us later. BF is hard, so we’ll take all the help we can get.</p>&#13;
<p class="indent">The main portion of the interpreter is in <a href="ch10.xhtml#ch010list4">Listing 10-4</a>.</p>&#13;
<pre>           plen = parse(host(2,2))&#13;
           buildtable(plen)&#13;
           input('cin', 10, 'B,1', '-')&#13;
           output('cout', 11, 'WB,1', '-')&#13;
           pc = 0&#13;
           mp = 0&#13;
           gmp = 0&#13;
   loop    ident(prog[pc],'-')               :s(dec)&#13;
           ident(prog[pc],'+')               :s(inc)&#13;
           ident(prog[pc],'&lt;')               :s(decp)&#13;
           ident(prog[pc],'&gt;')               :s(incp)&#13;
           ident(prog[pc],',')               :s(gchar)&#13;
           ident(prog[pc],'.')               :s(pchar)&#13;
           ident(prog[pc],'[')               :s(begin)&#13;
           ident(prog[pc],']')               :s(again)&#13;
   cont    pc = pc + 1&#13;
           ne(pc,plen)                       :f(pend)s(loop)&#13;
   dec     mem[mp] = mem[mp] - 1             :s(cont)f(bad1)&#13;
   inc     mem[mp] = mem[mp] + 1             :s(cont)f(bad1)&#13;
   decp    mp = mp - 1                       :(cont)&#13;
   incp    mp = mp + 1    &#13;
           gmp = gt(mp,gmp) mp               :(cont)&#13;
   gchar   ch = ord(cin)                     :f(pend)&#13;
        <span class="ent">➊</span> eq(ch,13)                         :f(gchar0)&#13;
           ch = 10&#13;
           cout = char(ch)&#13;
   gchar0  mem[mp] = ch                      :s(cont)f(bad1)&#13;
   pchar   cout = char(mem[mp])              :s(cont)f(bad1)&#13;
<span class="ent">➋</span> begin   pc = eq(mem[mp],0) jump[pc]       :(cont)&#13;
   again   pc = ne(mem[mp],0) jump[pc]       :(cont)</pre>&#13;
<p class="caption" id="ch010list4"><em>Listing 10-4: The main BF interpreter loop</em></p>&#13;
<p class="indent"><a href="ch10.xhtml#ch010list4">Listing 10-4</a> consists of some preliminaries followed by a <span class="literal">loop</span> that moves through the program in <span class="literal">prog</span>. The preliminaries call <span class="literal">parse</span> to process the input file and <span class="literal">buildtable</span> to configure the <span class="literal">jump</span> table. BF expects single-character input and output with the console, which SNOBOL supports using the given <span class="literal">input</span> and <span class="literal">output</span> incantations.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_279"/>The current program counter is <span class="literal">pc</span> and the memory pointer is <span class="literal">mp</span>. We’ll use <span class="literal">gmp</span> to track the highest memory cell accessed by the program. Doing this simplifies dumping relevant memory when the program ends.</p>&#13;
<p class="indent">The <span class="literal">loop</span> executes the current instruction depending on its character. Recall that <span class="literal">ident</span> is the SNOBOL predicate to compare two strings. Executing an instruction is a jump to the relevant line. Most instructions are a single statement. For example, <span class="literal">&gt;</span> moves the cell pointer to the right (<span class="literal">mp=mp+1</span>). When incrementing the cell pointer, there’s an extra check to see if <span class="literal">gmp</span> should be updated.</p>&#13;
<p class="indent">SNOBOL has one quirk requiring a bit of extra code. Take a look at <span class="literal">gchar</span>, which reads a single character of input. The <span class="literal">cin</span> variable reads the character and places its ASCII value in <span class="literal">ch</span>. The problem occurs when the user presses ENTER. On Unix systems, this should return the ASCII value 10; however, the SNOBOL interpreter returns the ASCII value 13. So a quick check converts ASCII 13 to ASCII 10 before assigning the character to the current memory location (<span class="literal">gchar0</span>) <span class="ent">➊</span>. Notice that each instruction ends with a jump to <span class="literal">cont</span> to continue processing the next instruction.</p>&#13;
<p class="indent">Additionally, observe how opening and closing brackets are handled as <span class="literal">begin</span> and <span class="literal">again</span>, respectively <span class="ent">➋</span>. Even though there is a single statement for each, a bit of explanation is in order. For example, the code for an opening bracket is</p>&#13;
<pre>pc = eq(mem[mp],0) jump[pc]      :(cont)</pre>&#13;
<p class="indent">The BF standard says to begin a loop if the currently active memory cell is not 0; otherwise, skip the loop. Here, the SNOBOL predicate <span class="literal">eq</span> will succeed if the current memory cell is 0. In that case, the assignment happens and <span class="literal">pc</span> is set to <span class="literal">jump[pc]</span>, which is the <em>end</em> of the loop that we’re currently considering. In contrast, if the memory cell is not 0, <span class="literal">eq</span> fails and the assignment does not happen. Therefore, the interpreter enters the loop as it should. The test in <span class="literal">again</span> is much the same, only the logic is reversed, so we jump to the beginning of the loop if the memory cell is not 0.</p>&#13;
<p class="indent">Take another look at the statement to decrement the current cell:</p>&#13;
<pre>dec  mem[mp] = mem[mp] - 1   :s(cont)f(bad1)</pre>&#13;
<p class="noindent">If the decrement succeeds, flow continues with the next instruction, <span class="literal">s(cont)</span>. However, if <span class="literal">mp</span> is negative or too large, the statement fails and the interpreter jumps to <span class="literal">bad1</span>:</p>&#13;
<pre>bad1  output = 'memory access error, mp = ' mp  :(end)</pre>&#13;
<p class="noindent">This prints an error message and exits. A similar error happens if an opening bracket has no matching closing bracket.</p>&#13;
<p class="indent">If the second command line argument is <span class="literal">dump</span>, the interpreter will dump the final value of all memory locations accessed by the program before exiting. The code for this is in <a href="ch10.xhtml#ch010list5">Listing 10-5</a>.</p>&#13;
<pre>pend   ident(host(2,3),'dump')             :f(end)&#13;
       output =<span epub:type="pagebreak" id="page_280"/>&#13;
       output = 'Memory: (mp = ' mp ')'&#13;
       n = 0&#13;
ploop  ascii = ''&#13;
       gt(mem[n],31)                       :f(print)&#13;
       lt(mem[n],127)                      :f(print)&#13;
       ascii = '  ' char(mem[n])&#13;
print  s = dupl(' ', 6 - size(n)) n&#13;
       s = s ':' dupl(' ', 6 - size(mem[n])) mem[n]&#13;
       output = s ascii&#13;
       n = n + 1&#13;
       gt(n,gmp)                           :f(ploop)&#13;
       output =                            :(end)</pre>&#13;
<p class="caption" id="ch010list5"><em>Listing 10-5: Dumping memory</em></p>&#13;
<p class="noindent">Memory values are dumped, one per line. If the value is in the range 31 &lt; <em>v</em> &lt; 127, the corresponding character is displayed.</p>&#13;
<p class="indent">The BF interpreter is now complete. Let’s test it.</p>&#13;
<pre>&gt; <span class="codestrong1">snobol4 bf.sno examples/hello.b dump</span>&#13;
Hello World!&#13;
&#13;
Memory: (mp = 6)&#13;
     0:     0&#13;
     1:     0&#13;
     2:    72  H&#13;
     3:   100  d&#13;
     4:    87  W&#13;
     5:    33  !&#13;
     6:    10</pre>&#13;
<p class="noindent">The memory dump shows that cells 0 through 6 were used at some point in the program, and that the program ended with the memory pointer looking at cell 6. Knowing which memory cell is active is critical to successful BF programming.</p>&#13;
<p class="indent">Our implementation appears to work. Now, let’s do stuff with it.</p>&#13;
<h3 class="h3" id="lev1sec74"><strong>BF in Action</strong></h3>&#13;
<p class="noindent">Let’s explore BF with worked examples. I encourage you to consider the other examples included on the GitHub site. However, the more complex ones like <em>mandelbrot.b</em> and <em>hanoi.b</em> are the output of programs that generate BF code. They were not written by hand.</p>&#13;
<p class="indent">We’ll start with some basic examples and then develop more advanced examples that require a bit of thought. For example, we’ll end with a program to multiply two numbers.</p>&#13;
<h4 class="h4" id="lev2sec88"><span epub:type="pagebreak" id="page_281"/><strong><em>Baby Steps</em></strong></h4>&#13;
<p class="noindent">Consider the following code:</p>&#13;
<pre>+++++[-]</pre>&#13;
<p class="noindent">It increments cell 0 five times, then starts a loop: <span class="literal">[-]</span>. Incrementing five times is obvious, so let’s work through the loop to see what it does. The first command is <span class="literal">[</span>. It checks to see whether the current cell is 0. In this case, the cell is 5 and not 0, so <span class="literal">[</span> succeeds and the loop begins.</p>&#13;
<p class="indent">The next instruction, <span class="literal">-</span>, decrements the value in the current memory cell (cell 0), so the value is now 4. The closing bracket, <span class="literal">]</span>, asks if cell 0 is 0, which it isn’t, so it jumps to the beginning of the loop. Note that the beginning of the loop isn’t <span class="literal">[</span>, but the first instruction after it (<span class="literal">-</span>). Cell 0 is decremented again and <span class="literal">]</span> runs again. When the value of cell 0 is 0, <span class="literal">]</span> will fail and the program will end. Therefore, the snippet of code above zeroes a cell. You’ll see <span class="literal">[-]</span> in many BF programs.</p>&#13;
<p class="indent">Now that we have a basic loop under our belt, let’s contemplate the following bit of code:</p>&#13;
<pre>,+[-.,+]</pre>&#13;
<p class="noindent">What do you think it might be doing? The code itself is in <em>cat.b</em>. Let’s run it and see what it produces. To run it, use this command line:</p>&#13;
<pre>&gt; <span class="codestrong1">snobol4 bf.sno examples/cat.b &lt;bf.sno</span></pre>&#13;
<p class="noindent">Do you see the text of <em>bf.sno</em>? The filename is a clue, of course, but this simple program acts like the Unix <span class="literal">cat</span> command to display the contents of a file. Let’s add comments to the code to explain what is happening.</p>&#13;
<pre>,    read a character; mem(0) = ch&#13;
+    inc mem(0)&#13;
[    loop if mem(0) is not zero&#13;
  -  dec mem(0)&#13;
  .  print mem(0) as a character&#13;
  ,  read another character to mem(0)&#13;
  +  inc mem(0)&#13;
]    loop if mem(0) is not zero</pre>&#13;
<p class="indent">Reading a character, printing, and looping until there are no more characters to read is a good idea in this case, but what’s with <span class="literal">+</span> and <span class="literal">-</span>? These extra commands handle the case where a 0 character has been read. They are present to deal with how different systems process end-of-file (EOF). For example, this version of the program works nicely with our SNOBOL interpreter</p>&#13;
<pre>,[.,]</pre>&#13;
<p class="noindent">but hangs at EOF when using the C interpreter.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_282"/>Let’s look at another loop example. Honestly, all our examples will be loop examples, as that’s all BF has to offer that isn’t quickly boring. This example is in <em>countdown0.b</em>:</p>&#13;
<pre>++++++++++[-.]</pre>&#13;
<p class="noindent">It’s only slightly more interesting than our first example. Beyond counting down, we also print the value of cell 0. However, BF’s print (<span class="literal">.</span>) expects an ASCII character, so this example won’t print anything visible, only a set of control characters. We can see this by using the Unix <span class="literal">xxd</span> command to dump binary files:</p>&#13;
<pre>&gt; <span class="codestrong1">snobol4 bf.sno examples/countdown0.b | xxd</span>&#13;
00000000: 0908 0706 0504 0302 0100  ..........</pre>&#13;
<p class="indent">The <span class="literal">xxd</span> command dumps binary data as hexadecimal values. Looking at the output you’ll see the countdown (09, 08, 07, . . . , 00). To get a countdown we must convert the current value of cell 0 to a digit. The offset between a digit value and the ASCII code for the digit is 48, so we must add 48 before printing and subtract 48 afterward.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch010list6">Listing 10-6</a> shows us <em>countdown1.b</em>. We’ve included comments to explain the code.</p>&#13;
<pre>++++++++++    mem(0) = 10&#13;
&gt;             look at mem(1)&#13;
++++++++++    mem(1) = 10&#13;
[             enter loop if mem(1) not zero&#13;
 -            decrement mem(1)&#13;
 ++++++++++&#13;
 ++++++++++&#13;
 ++++++++++&#13;
 ++++++++++&#13;
 ++++++++     add 48&#13;
 .            print&#13;
 ----------&#13;
 ----------&#13;
 ----------&#13;
 ----------&#13;
 --------     sub 48&#13;
 &lt;            look at mem(0)&#13;
 .            print it&#13;
 &gt;            look at mem(1)&#13;
]             loop if mem(1) is not zero</pre>&#13;
<p class="caption" id="ch010list6"><em>Listing 10-6: Countdown with ASCII output</em></p>&#13;
<p class="indent">Running <a href="ch10.xhtml#ch010list6">Listing 10-6</a> produces a countdown as output (9, 8, 7, . . . , 0). To output newline repeatedly, it’s easiest to store it somewhere, so we set cell 0 to 10. Next, <span class="literal">&gt;</span> moves the cell pointer to look at cell 1. As you write BF code, <span epub:type="pagebreak" id="page_283"/>pay very close attention to where the cell pointer is looking. Cell 1 is set to 10 as well, but in this case, it is the value to count down.</p>&#13;
<p class="indent">The loop begins by incrementing the value in cell 0 with 48 <span class="literal">+</span> commands. This is boring but quick to implement. The current loop count is now a valid ASCII digit, so we print it and subtract 48 to get back to the actual count. The bottom of the loop looks at cell 0, which is always 10, and prints it to get the newline character. The code then looks again at cell 1, where our count lives, and loops until 0.</p>&#13;
<h4 class="h4" id="lev2sec89"><strong><em>Bunches O’Bits</em></strong></h4>&#13;
<p class="noindent"><em>Bit twiddling</em>, meaning fiddling around with the bits of a byte, is the goal of this section. Here we’ll implement two examples. The first calculates the ones’ complement of a byte. The second calculates the even parity bit. Don’t be concerned if these terms are new to you; I’ll clarify as we go.</p>&#13;
<h5 class="h5" id="lev3sec29"><strong>A Complimentary Complement</strong></h5>&#13;
<p class="noindent">Internally, computers represent integers as a set number of bits, that is, as a base-2 number. One method for encoding negative numbers is to use the <em>ones’ complement</em>, where each bit is the opposite of what it would be for a positive value. For example, if a number is 00001101<sub>2</sub> = 11, then 11110010<sub>2</sub> = <em>–</em>11 where each 1 is now a 0 and vice versa. In this encoding, the leading bit will be one when the number should be interpreted as a negative value. Our goal is to write a BF program to calculate the ones’ complement of an input byte. The byte will be entered as a string of eight characters (each 0 or 1).</p>&#13;
<p class="indent">Let’s think about this task for a bit (or eight). We know we’ll likely want a loop to read eight bits. After reading a bit, we need to subtract 48 to map the ASCII value read to its actual value (0 or 1). Once we have the actual value, we then output a 0 if the value is 1 or a 1 if the value is 0. In typical languages, a simple <span class="literal">if</span> statement would do the trick. Of course, we’re not working with an ordinary language, but rather in the strange world of BF.</p>&#13;
<p class="indent">A loop to read a byte’s worth of bits could be written as</p>&#13;
<pre>++++++++[-&gt;,&lt;]</pre>&#13;
<p class="noindent">In this code, we first set cell 0 to 8 and then start a loop. The loop decrements cell 0, moves to cell 1, and inputs something. It then moves the memory pointer back to cell 0 and loops if the count isn’t 0. This reads eight characters and then exits. Adding a period after the comma echoes the input. Of course, we need a 0 or 1 in memory, not the ASCII code for 0 or 5, so somewhere we’ll have to subtract 48. We’ll use a sequence of 48 <span class="literal">-</span> instructions.</p>&#13;
<p class="indent">All right, we have the input bit, but how do we decide whether we should output a 0 or a 1? If the bit is 1, we could enter a loop that is otherwise skipped if the bit is 0. How can we use that? Well, we might be able to set another memory location to 1, read the input bit, and if it is 1, decrement the preset memory location. If we do that, we’ll be in business. However, before <span epub:type="pagebreak" id="page_284"/>we go too far, it’s a good idea to make a map of how we are using BF memory. So far, we have the setup</p>&#13;
<pre>cell   :   0    1    2&#13;
value  :   8  0|1    1&#13;
pointer:        ^</pre>&#13;
<p class="noindent">where our loop counter is in cell 0, the bit entered by the user is in cell 1, cell 2 holds a 1, and the memory pointer is looking at cell 1.</p>&#13;
<p class="indent">If the user’s bit is 1, we want to enter a loop to decrement cell 2. If the bit is 0, the loop will be skipped and cell 2 will remain 1. Then, we print cell 2 and we have it: a 1 is changed into a 0, and a 0 is changed into a 1. We then move the memory pointer back to cell 0 to decrement the bit counter and repeat until we’re done.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch010list7">Listing 10-7</a> shows <em>ones.b</em>, which implements our algorithm. Let’s walk through the code to see that it does what I claim.</p>&#13;
<pre>++++++++[&#13;
    -&gt;          decrement mem(0); look at mem(1)&#13;
    &gt;+&lt;,        look at mem(2); inc; mem(1); input&#13;
    ----------&#13;
    ----------&#13;
    ----------&#13;
    ----------&#13;
    --------    sub 48&#13;
    [-&gt;-&lt;]      if one then dec mem(2)&#13;
    &gt;           look at mem(2)&#13;
    ++++++++++&#13;
    ++++++++++&#13;
    ++++++++++&#13;
    ++++++++++&#13;
    ++++++++.   add 48; print&#13;
    [-]&lt;        zero mem(2); look at mem(1)&#13;
    &lt;           look at mem(0)&#13;
]&#13;
++++++++++.     mem(0) = 10; print newline</pre>&#13;
<p class="caption" id="ch010list7"><em>Listing 10-7: Ones’ complement</em></p>&#13;
<p class="indent">First, the outermost loop uses cell 0 to count down from 8. Inside this loop, after decrementing the count, the memory pointer is moved to cell 2, which is then incremented. We know that cell 2 was initially 0, so it must be 1 now. We then move back to cell 1 to get the user’s input, which we’ll assume is a 0 or 1. This much is <span class="literal">-&gt;&gt;+&lt;,</span> if the comments are removed. Look at the commands until you are sure you follow what’s going on.</p>&#13;
<p class="indent">The next block of code is an uninspired sequence of 48 <span class="literal">-</span> commands to change the user’s input into either a 0 or 1. Recall that we’re looking at cell 1. At this point, we have memory as we want it: cell 1 is 0 or 1 and cell 2 is 1. The next set of commands are key to the entire program: <span class="literal">[-&gt;-&lt;]&gt;</span>. The <span epub:type="pagebreak" id="page_285"/>small loop (<span class="literal">[-&gt;-&lt;]</span>) executes if the user’s bit is 1 because we are looking at cell 1 and it isn’t 0; therefore, <span class="literal">[</span> enters the loop. Cell 1 is immediately decremented to make it 0 because we only want the code in the loop to execute once. Next, <span class="literal">&gt;</span> looks at cell 2 and <span class="literal">-</span> decrements it to change it from 1 to 0. Lastly, <span class="literal">&lt;</span> looks again at cell 1, which is now 0, so the loop exits, and the final <span class="literal">&gt;</span> executes to look at cell 2. If the user’s bit is a 0, then <span class="literal">[</span> fails, skipping the entire loop and moving directly to the final <span class="literal">&gt;</span> to also look at cell 2. At this point, cell 2 is the focus, and it contains a 1 if the input bit was a 0 or a 0 if the input bit was a 1. The next block of 48 <span class="literal">+</span> commands increments the value in cell 2 to get the corresponding ASCII code and <span class="literal">.</span> prints it.</p>&#13;
<p class="indent">What does <span class="literal">[-]</span> do? As we saw above, <span class="literal">[-]</span> is the BF idiom to zero a memory location. This is necessary to make sure cell 2 is 0 when the outer loop comes around for the next input bit. Right now, cell 2 is either 48 or 49. The final two <span class="literal">&lt;&lt;</span> instructions move focus back to cell 0, the loop counter. The outer <span class="literal">]</span> then loops if cell 0 isn’t 0. When it is, the final line, <span class="literal">++++++++++.</span>, outputs ASCII 10, a newline, and the program exits.</p>&#13;
<p class="indent">Whew! Let’s see <a href="ch10.xhtml#ch010list7">Listing 10-7</a> in action. Run <em>ones.b</em> like so:</p>&#13;
<pre>&gt; <span class="codestrong1">echo 00001101 | snobol4 bf.sno examples/ones.b dump</span>&#13;
11110010&#13;
&#13;
Memory: (mp = 0)&#13;
     0:    10&#13;
     1:     0&#13;
     2:     0</pre>&#13;
<p class="noindent">The <span class="literal">echo</span> command is a convenient way to send input to a program without typing it directly. Notice that the input is 11 as we saw it earlier, 00001101<sub>2</sub>. The output is 11110010<sub>2</sub>, which is –11 in ones’ complement, as we wanted. The memory dump tells us we end the program looking at cell 0, which contains 10 for the final newline. The other two cells used by the program are both 0.</p>&#13;
<p class="indent">One note before moving on. <a href="ch10.xhtml#ch010list7">Listing 10-7</a> excludes a comment block at the top of <em>ones.b</em>. The BF interpreter ignores non-command characters; however, the comments must not include any command characters. That gets a bit annoying at times. The comments at the top of <em>ones.b</em> are enclosed in brackets (<span class="literal">[</span> and <span class="literal">]</span>). This means the entire comment block (at least the characters that are valid BF commands) is a loop. But this doesn’t matter. The comment block is the first loop in the program, and we know cell 0 is always 0, so the loop will never execute and we are free to enter whatever text we want in the comments. This was not my idea, but it is another illustration of the creativity present in the esolang community.</p>&#13;
<h5 class="h5" id="lev3sec30"><strong>Achieving Parity</strong></h5>&#13;
<p class="noindent">Serial communication protocols sometimes use a <em>parity bit</em>, an extra bit transmitted with the data that makes it easier to detect transmission errors. For example, if the data fits in seven bits, as standard ASCII characters do, then an eighth bit can be added to make the number of one bits (bits with a value <span epub:type="pagebreak" id="page_286"/>of 1) in the 8-bit byte even. This is known as even parity. If the received byte does not have an even number of one bits, the receiver immediately knows there is an error and can request the byte again. A single parity bit can capture a single-bit error, which is sufficient in most cases.</p>&#13;
<p class="indent">Our mission is to write a BF program to accept seven input bits and output the proper even parity bit. We’ll input bits as a sequence of seven ASCII characters as before and then output either ASCII 0 or ASCII 1 to make the number of one bits even. The following are some examples of bytes with parity bits:</p>&#13;
<table class="all5">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">0000000</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">→</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">0000000<strong>0</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">0000010</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">→</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">0000010<strong>1</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">0011001</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">→</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">0011001<strong>1</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">1111111</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">→</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">1111111<strong>1</strong></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">The bold output bit ensures that every byte has an even number of 1s.</p>&#13;
<p class="indent">How should we go about getting BF to do this for us? There are likely multiple approaches, but the approach we’ll use here is first to tally the number of 1s present in the seven inputs. Then we’ll decide which bit to output based on this tally. As with <em>ones.b</em> above, we need an outer loop to read the ASCII bits and subtract 48. To tally the one bits, we’ll increment a memory cell each time the bit is a 1.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch010list8">Listing 10-8</a> presents a loop to read seven bits and tally the number of one bits.</p>&#13;
<pre>+++++++[       mem(0) = 7&#13;
    &gt;,.        mem(1) = input; echo&#13;
    --------------------&#13;
    --------------------&#13;
    --------   sub 48&#13;
    [          inner loop if bit is one&#13;
        -      subtract the bit from mem(1)&#13;
        &gt;+     look at mem(2); increment mem(2)&#13;
        &lt;      look at mem(1)&#13;
    ]          exit loop because mem(1) is zero&#13;
    &lt;-         look at mem(0); decrement mem(0)&#13;
]              loop if mem(0) not zero</pre>&#13;
<p class="caption" id="ch010list8"><em>Listing 10-8: Adding the input bits</em></p>&#13;
<p class="indent">As always, tracking memory use is essential. In this case, cell 0 holds the bits read counter, cell 1 is the input bit, and cell 2 the tally of one bits. The first part of the loop is <span class="literal">&gt;,.</span>, which moves to cell 1, reads the input bit, and echoes it. Next comes a block of 48 <span class="literal">-</span> commands to turn the ASCII character code into a 0 or 1.</p>&#13;
<p class="indent">If the bit is a 1, <span class="literal">[</span> begins the inner loop. The loop body, <span class="literal">-&gt;+&lt;</span>, decrements cell 1, looks at cell 2 and increments it, and looks again at cell 1. Because cell 1 is now 0, <span class="literal">]</span> fails and the loop ends. If the input bit is 0, <span class="literal">[</span> skips ahead to <span class="literal">&lt;-</span>. In both cases, the memory pointer is looking at cell 1, so <span class="literal">&lt;</span> looks at cell 0, which <span class="literal">-</span> then decrements. The final <span class="literal">]</span> fires to repeat the loop six more times. <span epub:type="pagebreak" id="page_287"/>When the loop ends, cell 2 contains a tally of the number of one bits read and the memory pointer is looking at cell 0. It’s important to note that cell 0 and cell 1 are both 0 when the outer loop exits.</p>&#13;
<p class="indent">Cell 2 contains the number of one bits in the input. If this number is odd, the output bit should be 1. Otherwise, it should be 0. How do we tell if cell 2 is even or odd? Here’s where things get a bit tricky. Our solution is in <a href="ch10.xhtml#ch010list9">Listing 10-9</a>, but we must walk through it to understand it.</p>&#13;
<pre>&gt;&gt;             look at mem(2)&#13;
[              loop if mem(2) not zero&#13;
    [          if mem(2) not zero&#13;
        -      subtract one&#13;
        &gt;      look at mem(3)&#13;
        +      increment it&#13;
        &gt;      look at mem(4); which is zero&#13;
    ]          do not loop&#13;
 <span class="ent">➊</span> &lt;&lt;         look back to mem(2)&#13;
    [          if mem(2) not zero&#13;
        -      subtract one&#13;
        &gt;      look at mem(3)&#13;
        -      decrement&#13;
        &gt;      look at mem(4); which is zero&#13;
    ]          do not loop&#13;
    &lt;&lt;         look at mem(2) or mem(0) if sum exhausted&#13;
]              loop if not zero</pre>&#13;
<p class="caption" id="ch010list9"><em>Listing 10-9: Using the ones tally to decide the parity bit</em></p>&#13;
<p class="indent">In essence, when the outer loop of <a href="ch10.xhtml#ch010list9">Listing 10-9</a> ends, the memory pointer will be looking at cell 0 if the output bit should be 1 or cell 2 if the output bit should be 0. Additionally, cell 3 will be 1 if we end at cell 0 and cell 5 will be its default value of 0.</p>&#13;
<p class="indent">The code before the main loop of <a href="ch10.xhtml#ch010list9">Listing 10-9</a> is simple enough. Move the memory pointer twice to look at cell 2, which has the one bits tally. If this tally is 0, the loop is skipped by <span class="literal">[</span> and we move to the final bit of code with the memory pointer looking at cell 2. We’ll get to the final bit of code soon.</p>&#13;
<p class="indent">If the tally in cell 2 isn’t 0, we enter the main loop of <a href="ch10.xhtml#ch010list9">Listing 10-9</a>. The body of this loop has two inner loops, one after the other. The body of the first inner loop is <span class="literal">-&gt;+&gt;</span>. It subtracts 1 from cell 2, looks at and increments cell 3, and then looks at cell 4, which is always 0. Because cell 4 is 0, <span class="literal">]</span> exits the loop, meaning the loop never actually loops. Notice that when the loop exits, the memory pointer is looking at cell 4 and cell 3 is 1.</p>&#13;
<p class="indent">If we assume that cell 2 was initially 1 <span class="ent">➊</span>, cell 2 is now 0, cell 3 is 1, and we are looking at cell 4, which is also 0. The <span class="literal">&lt;&lt;</span> between the inner loops moves back to cell 2, which, as it is 0, skips the second inner loop and hits the final <span class="literal">&lt;&lt;</span> to move back from cell 2 to cell 0. Because cell 0 is 0, the outer loop exits, meaning we are looking at cell 0 and cell 3 is still 1.</p>&#13;
<p class="indent">This situation happens every time cell 2 contains an odd value. What if cell 2 contains 2? After the first inner loop of <a href="ch10.xhtml#ch010list9">Listing 10-9</a>, cell 2 contains 1, <span epub:type="pagebreak" id="page_288"/>cell 3 contains 1, and we are looking at cell 2. Therefore, the second inner loop fires to decrement cell 2 and cell 3, making them both 0. The loop then moves to cell 4, which is always 0, exits, and moves back to cell 2, which is now also 0. The outer loop then exits, and we are looking at cell 2 this time, not cell 0. Whenever cell 2 is initially even, both inner loops will repeatedly fire to make cell 2 0. Cell 3 is also decremented by the second inner loop to make sure it only ever contains a 1.</p>&#13;
<p class="indent">We’re almost done. The code in <a href="ch10.xhtml#ch010list9">Listing 10-9</a> ends, leaving BF in one of two states. If the tally in cell 2 was even, we’re looking at cell 2. If the tally is odd, we’re looking at cell 0 and cell 3 is 1. To output the proper bit, we need the code in <a href="ch10.xhtml#ch010list10">Listing 10-10</a>.</p>&#13;
<pre>&gt;&gt;&gt;                   look at mem(3) or mem(5)&#13;
++++++++++++++++++++&#13;
++++++++++++++++++++&#13;
++++++++.             add 48 and print&#13;
&gt;                     look at the next location which is zero&#13;
++++++++++.           set to 10 and print the newline</pre>&#13;
<p class="caption" id="ch010list10"><em>Listing 10-10: Printing the proper parity bit</em></p>&#13;
<p class="indent">We use <span class="literal">&gt;&gt;&gt;</span> to move to either cell 3 or cell 5. Cell 3 would be 1 if we ended at cell 0 and that’s the value we want to output. If we ended at cell 2, we move to cell 5, which is initialized to be 0 and is also the value we want. All that remains is to add 48 to convert the value to the ASCII character code for either 1 or 0, print it, and then move to either cell 4 or cell 6, both of which are initially 0, to output the final newline character.</p>&#13;
<p class="indent">Let’s try <em>parity.b</em> with the example inputs above:</p>&#13;
<pre>&gt; <span class="codestrong1">echo 0000000 | bfi examples/parity.b</span> &#13;
00000000&#13;
&gt; <span class="codestrong1">echo 0000010 | bfi examples/parity.b</span>&#13;
00000101&#13;
&gt; <span class="codestrong1">echo 0011001 | bfi examples/parity.b</span>&#13;
00110011&#13;
&gt; <span class="codestrong1">echo 1111111 | bfi examples/parity.b</span>&#13;
11111111</pre>&#13;
<p class="noindent">The output is as expected, meaning that <em>parity.b</em> works. You’ll get the same results if you use the SNOBOL interpreter as well.</p>&#13;
<p class="indent">Now, let’s work on our final BF example: multiplication.</p>&#13;
<h4 class="h4" id="lev2sec90"><strong><em>Multiplicative Multiplicity</em></strong></h4>&#13;
<p class="noindent">Multiplication is repeated addition. Let’s use that fact to write a BF program to accept two single-digit numbers and compute their product. We’ll write two versions. The first version implements multiplication but leaves the product in memory. This is unsatisfying, so the second version uses freely <span epub:type="pagebreak" id="page_289"/>available code from <em><a href="https://esolangs.org/">https://esolangs.org/</a></em> to output the product as ASCII characters. The full source code for both examples is in <em>mult.b</em> and <em>mult2.b</em>, respectively.</p>&#13;
<p class="indent">We require two inputs, which we’ll store in cells 0 and 1. We’ll use cells 2 and 3 while multiplying and place the final product in cell 3. Reading the input characters is straightforward; see <a href="ch10.xhtml#ch010list11">Listing 10-11</a>.</p>&#13;
<pre>,--------------------&#13;
--------------------     mem(0) = input&#13;
--------                 sub 48&#13;
&gt;++++++++++++++++        mem(1) = 32 (space)&#13;
++++++++++++++++.        print&#13;
++++++++++.              add 10; print *&#13;
----------.              sub 10; print space&#13;
,--------------------    mem(1) = input&#13;
--------------------&#13;
--------                 sub 48</pre>&#13;
<p class="caption" id="ch010list11"><em>Listing 10-11: Reading and printing the inputs</em></p>&#13;
<p class="indent">The first character is read and converted to its numeric value. Then cell 1 is used to output <span class="literal">*</span> before reading the second digit.</p>&#13;
<p class="indent">To multiply, we must increment a memory location as many times as the value in cell 1 dictates (that is, increment it cell 1 times), and repeat until cell 0 is 0. For example, if cell 0 is 5 and cell 1 is 4, the algorithm is to calculate</p>&#13;
<p class="equationc">5 × 4 = 4 + 4 + 4 + 4 + 4 = 20</p>&#13;
<p class="noindent">which we might write in a language like Python as</p>&#13;
<pre>ans = 0&#13;
for i in range(5):&#13;
    for j in range(4):&#13;
        ans += 1</pre>&#13;
<p class="indent">Let’s duplicate this code in BF. However, we have a minor issue. We need two loops, an outer loop running until cell 0 is 0, and an inner loop to increment cell 3 by cell 1 times. Recall that BF loops are destructive. For example, if we write <span class="literal">++++[.-]</span>, we’ll print the current value of cell 0 four times, from 4 down to 1. When the loop exits, cell 0 is 0, meaning its original value has been lost. Thus, we must preserve the value of cell 1 to use it again on the next pass.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch010list12">Listing 10-12</a> shows us the multiplication algorithm. Let’s see how it preserves the inner loop counter.</p>&#13;
<pre>&lt;[-                 dec mem(0)&#13;
    &gt;[-             look at mem(1); dec&#13;
        &gt;+&gt;+&lt;&lt;      inc mem(2); inc mem(3); look at mem(1)&#13;
    ]               continue until mem(1) is zero<span epub:type="pagebreak" id="page_290"/>&#13;
    &gt;[-&lt;+&gt;]         look at mem(2); copy back to mem(1)&#13;
    &lt;&lt;              look at mem(0)&#13;
]                   loop until mem(0) is zero</pre>&#13;
<p class="caption" id="ch010list12"><em>Listing 10-12: Multiplying the two digits</em></p>&#13;
<p class="indent">The first <span class="literal">&lt;</span> moves us back to cell 0 as the code in <a href="ch10.xhtml#ch010list11">Listing 10-11</a> ends with the memory pointer looking at cell 1. Cell 0 isn’t 0, generally, so the outer loop begins, and cell 0 is immediately decremented. Next, <span class="literal">&gt;</span> moves to cell 1, and the first inner loop begins if cell 1 isn’t 0. Cell 1 is also immediately decremented.</p>&#13;
<p class="indent">The body of the first inner loop is <span class="literal">&gt;+&gt;+&lt;&lt;</span>. The <span class="literal">&gt;+</span> instructions move to cell 2 and increment it. The following <span class="literal">&gt;+</span> does the same to cell 3. Lastly, <span class="literal">&lt;&lt;</span> moves back to cell 1 so <span class="literal">]</span> can decide whether to continue the loop or not. When the loop exits, memory looks like this, assuming the user entered <span class="literal">5</span> and <span class="literal">4</span>:</p>&#13;
<pre>cell   :   0    1    2    3&#13;
value  :   4    0    4    4&#13;
pointer:        ^</pre>&#13;
<p class="noindent">Recall that cell 3 holds our product. It’s currently 4 because the first inner loop ran four times. We now must restore cell 1. That’s why the loop incremented both cell 2 and cell 3. We use cell 3 for the product and we can use cell 2 to restore the inner loop counter. That’s what <span class="literal">&gt;[-&lt;+&gt;]</span> does; it decrements cell 2 while incrementing cell 1. The final <span class="literal">&lt;&lt;</span> ensures that the outer loop’s <span class="literal">]</span> instruction is looking at cell 0.</p>&#13;
<p class="indent">Each pass through the outer loop adds cell 1 to cell 3, using cell 2 to restore cell 1 for the next pass. When cell 0 is finally 0, cell 3 holds the product. Note that we entered single digits, but this multiplication routine is generic and will work for any two values. Also, the trick of double incrementing memory to have a place to restore from is another BF idiom. We saw similar code in <a href="ch08.xhtml#ch08">Chapter 8</a> when we implemented multiplication in FRACTRAN.</p>&#13;
<p class="indent">Let’s take <em>mult.b</em> out for a test drive. We’ll use our interpreter’s ability to dump memory to see if it is working. For example:</p>&#13;
<pre>&gt; <span class="codestrong1">snobol4 bf.sno examples/mult.b dump</span>&#13;
<span class="codestrong1">3</span> * <span class="codestrong1">5</span>&#13;
&#13;
Memory: (mp = 0)&#13;
     0:    10&#13;
     1:     5&#13;
     2:     0&#13;
     3:    15&#13;
&#13;
&gt; <span class="codestrong1">snobol4 bf.sno examples/mult.b dump</span>&#13;
<span class="codestrong1">9</span> * <span class="codestrong1">8</span><span epub:type="pagebreak" id="page_291"/>&#13;
Memory: (mp = 0)&#13;
     0:    10&#13;
     1:     8&#13;
     2:     0&#13;
     3:    72  H</pre>&#13;
<p class="noindent">In both cases, we see that cell 3 contains the correct product.</p>&#13;
<p class="indent">To print the product as a number, we add the code in <a href="ch10.xhtml#ch010list13">Listing 10-13</a> to the end of the multiplication routine in <a href="ch10.xhtml#ch010list12">Listing 10-12</a> (see <em>mult2.b</em>).</p>&#13;
<pre>&gt;&gt;&gt;                                    move to mem(3)&#13;
&gt;[-]&gt;[-]+&gt;[-]+&lt;                        set n and d to one to start loop&#13;
[                                      loop on 'n'&#13;
    &gt;[-&lt;-                              on the first loop&#13;
        &lt;&lt;[-&gt;+&gt;+&lt;&lt;]                    copy V into N (and Z)&#13;
        &gt;[-&lt;+&gt;]&gt;&gt;                      restore V from Z&#13;
    ]&#13;
    ++++++++++&gt;[-]+&gt;[-]&gt;[-]&gt;[-]&lt;&lt;&lt;&lt;&lt;   init for the division by 10&#13;
    [-&gt;-[&gt;+&gt;&gt;]&gt;[[-&lt;+&gt;]+&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;]     full division&#13;
    &gt;&gt;-[-&lt;&lt;+&gt;&gt;]                        store remainder into n&#13;
    &lt;[-]++++++++[-&lt;++++++&gt;]            make it an ASCII digit; clear d&#13;
    &gt;&gt;[-&lt;&lt;+&gt;&gt;]                         move quotient into d&#13;
    &lt;&lt;                                 shuffle; new n is where d was and&#13;
                                         old n is a digit&#13;
    ]                                  end loop when n is zero&#13;
&lt;[.[-]&lt;]                               move to where Z should be and&#13;
                                         output the digits til we find Z&#13;
&lt;                                      back to V&#13;
&lt;++++++++++.                           newline</pre>&#13;
<p class="caption" id="ch010list13"><em>Listing 10-13: The print routine</em></p>&#13;
<p class="indent">As mentioned, this routine comes from <em><a href="https://esolangs.org/">https://esolangs.org/</a></em>. What is particularly nice about this routine is that it works with any memory location, so we move from cell 0 to cell 3 prior to running it. The provided comments give some indication of what the routine is doing. Notice that the second line of <a href="ch10.xhtml#ch010list13">Listing 10-13</a> uses the “clear a cell” idiom three times to initialize memory. We won’t walk through <a href="ch10.xhtml#ch010list13">Listing 10-13</a> in any detail, as it is quite challenging. Motivated readers will find the code, with some additional details, at <em><a href="https://esolangs.org/wiki/Brainfuck_algorithms">https://esolangs.org/wiki/Brainfuck_algorithms</a></em> under the heading beginning with “Print value of cell x as number.”</p>&#13;
<p class="indent">Let’s review some examples to see that the routine works as advertised.</p>&#13;
<pre>&gt; <span class="codestrong1">snobol4 bf.sno examples/mult2.b</span>&#13;
<span class="codestrong1">3</span> * <span class="codestrong1">5</span> = 15&#13;
&gt; <span class="codestrong1">snobol4 bf.sno examples/mult2.b</span>&#13;
<span class="codestrong1">9</span> * <span class="codestrong1">8</span> = 72</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_292"/>The examples of this section, <em>ones.b</em>, <em>parity.b</em>, <em>mult.b</em>, and <em>mult2.b</em>, serve as our introduction to BF. There’s much more we might say, but we covered the essentials. Let’s turn now to outside resources to see additional examples, learn more about BF programming, and gain insight on how BF has influenced esolangs as a whole, to say nothing of genuine academic research involving BF.</p>&#13;
<h3 class="h3" id="lev1sec75"><strong>The BF Multiverse</strong></h3>&#13;
<p class="noindent">If Piet generated a universe, then to be fair, we must say that BF has created a multiverse. Let’s briefly investigate some of those universes in this section: examples, tutorials, implementations, inspirations, and academic BF. Enjoy!</p>&#13;
<h4 class="h4" id="lev2sec91"><strong><em>Examples</em></strong></h4>&#13;
<p class="noindent">The best way to learn a language is to use it. We did that in the previous section. The next best way to learn a language is to see how others have used it. Let’s take a cursory look at the BF examples included with this book. I did not write these examples. See the <em>README</em> file for attribution information.</p>&#13;
<p class="indent">The most impressive set of BF programs written by hand and not generated by another system producing BF code as output I’ve found are by Daniel B. Cristofani. You’ll find them at <em><a href="http://brainfuck.org/">http://brainfuck.org/</a></em>, which alone tells you Cristofani’s a serious BF coder—he registered the domain name. I suspect you’ll learn much from the examples and even more from the tutorial information on his site.</p>&#13;
<p class="indent">The book repository contains the following, all of which run with both the C and SNOBOL interpreters:</p>&#13;
<div class="bq5">&#13;
<p class="noindent"><strong><em>squares.b</em></strong>  Print <em>n</em><sup>2</sup> for [0,100].</p>&#13;
<p class="noindent"><strong><em>fib.b</em></strong>  Generate an endless stream of Fibonacci numbers. We encountered the Fibonacci sequence in <a href="ch01.xhtml#ch01">Chapter 1</a> and will again in <a href="ch13.xhtml#ch13">Chapter 13</a>. This version does not use a single cell to hold the number, but rather handles arbitrary-sized numbers. This is a good example of how compact BF code can be while still doing something interesting.</p>&#13;
<p class="noindent"><strong><em>factorial2.b</em></strong>  Another gem. This one calculates an endless stream of factorials.</p>&#13;
<p class="noindent"><strong><em>sierpinski.b</em></strong>  The Sierpiński triangle is a common fractal, one that a straightforward algorithm can generate. This version produces ASCII output. We’ll work with the Sierpiński triangle again in <a href="ch13.xhtml#ch13">Chapter 13</a>. Consider this example a preview.</p>&#13;
<p class="noindent"><strong><em>random.b</em></strong>  Implements Wolfram’s Rule 30, a 1D cellular automaton. This automaton, especially the center bit, passes many tests for randomness and formed the basis for Mathematica’s first pseudorandom generator. To experiment more with Rule 30 and other 1D automatons, see <a href="ch07.xhtml#ch07">Chapter 7</a> of my book <em>Random Numbers and Computers</em> (Springer, 2018).</p>&#13;
<p class="noindent"><strong><em>golden.b</em></strong>  Calculates the decimal expansion of <img src="Images/f0292-01.jpg" alt="Image" width="84" height="32"/>.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_293"/><strong><em>e.b</em></strong>  Calculates the decimal expansion of <em>e</em>, the base of the natural logarithm. The natural log can be defined via an integral, In <img class="middle" src="Images/f0293-1.jpg" alt="Image" width="90" height="28"/> with <em>e</em> the limit such that the log is <img class="middle" src="Images/f0293-2.jpg" alt="Image" width="110" height="28"/>.</p>&#13;
<p class="noindent"><strong><em>tictactoe.b</em></strong>  Tic-tac-toe in BF. You against the computer. Good luck.</p>&#13;
</div>&#13;
<p class="indent">The remaining examples, beyond <em>cat.b</em> and <em>hello.b</em>, which we saw earlier, include the following:</p>&#13;
<div class="bq5">&#13;
<p class="noindent"><strong><em>prime.b</em></strong>  Calculate prime numbers less than the given number. This commented example was written by hand, but I have not succeeded in identifying the author.</p>&#13;
<p class="noindent"><strong><em>hanoi.b</em></strong>  An animated Tower of Hanoi. This example is the output of Claire Wolf’s BF compiler suite (see below). It’s fun to watch, but run it with the C interpreter or you’ll be waiting a very long time indeed.</p>&#13;
<p class="noindent"><strong><em>mandelbrot.b</em></strong>  Creates an ASCII version of the Mandelbrot set. The <em>README</em> file gives the URL of the code. It appears to be the output of Wolf’s BF compiler as well. If you use the SNOBOL interpreter, you’ll eventually finish, but it runs about 100 times slower than the C interpreter.</p>&#13;
</div>&#13;
<h4 class="h4" id="lev2sec92"><strong><em>Tutorials</em></strong></h4>&#13;
<p class="noindent">The tutorials here offer plenty of good BF programming insights, idioms, and explanations.</p>&#13;
<div class="bq5">&#13;
<p class="noindent"><strong>Daniel B Cristofani’s BF pages</strong>  Mentioned earlier but worth mentioning again because of the helpful programming advice. You’ll even find advice on how to write a “compliant” interpreter. Our SNOBOL interpreter is not compliant, but we’re happy with it. (<em><a href="http://brainfuck.org/">http://brainfuck.org/</a></em>)</p>&#13;
<p class="noindent"><strong>Frans Faase’s BF pages</strong>  You’ll find many good reference/tutorial pages here. Some are Faase’s, whereas others are links to still more information about BF. The World Wide Web is a web, after all. (<em><a href="https://www.iwriteiam.nl/Ha_BF.html">https://www.iwriteiam.nl/Ha_BF.html</a></em>)</p>&#13;
<p class="noindent"><strong>Katie Ball’s BF tutorial</strong>  Ball’s tutorial is another good reference. (<em><a href="https://gist.github.com/roachhd/dce54bec8ba55fb17d3a/">https://gist.github.com/roachhd/dce54bec8ba55fb17d3a/</a></em>)</p>&#13;
</div>&#13;
<h4 class="h4" id="lev2sec93"><strong><em>Implementations</em></strong></h4>&#13;
<p class="noindent">The implementations of BF are legion, which is somehow fitting. Only a tiny selection is referenced here, and I’m completely ignoring all the hardware implementations.</p>&#13;
<h5 class="h5" id="lev3sec31"><strong>Compilers</strong></h5>&#13;
<p class="noindent">The phrase <em>BF compiler</em> has multiple meanings. For example, a BF compiler might be a program that takes a higher-level language and produces BF code. In that case, BF is the machine code for the compiler. Alternatively, <span epub:type="pagebreak" id="page_294"/>a BF compiler might be just that: a program that takes BF as input and produces executable code from it. I offer an example of each kind here.</p>&#13;
<div class="bq5">&#13;
<p class="noindent"><strong>Brian Raiter’s native BF compiler</strong>  As promised above, here’s Brian Raiter’s 166-byte BF compiler. It’s written in assembly language (install <span class="literal">nasm</span> on Linux) and produces standalone executables. Not every example in the repository works with this compiler, but many do, and the results are significantly faster than even the C interpreter. Try <em>e.b</em>, <em>golden.b</em>, and <em>tictactoe.b</em>. There are many comments in the source code, <em>bf.asm</em>. Hopefully, your x86 assembly is much stronger than mine. (<em><a href="http://www.muppetlabs.com/~breadbox/software/tiny/bf.asm.txt">http://www.muppetlabs.com/~breadbox/software/tiny/bf.asm.txt</a></em>)</p>&#13;
<p class="noindent"><strong>Claire Wolf’s compiler to BF</strong>  This compiler takes a higher-level macro language and produces executable BF code. It produced two of our examples: <em>hanoi.b</em> and <em>mandelbrot.b</em>. (<em><a href="http://bygone.clairexen.net/bfcpu/bfcomp.html">http://bygone.clairexen.net/bfcpu/bfcomp.html</a></em>)</p>&#13;
</div>&#13;
<h5 class="h5" id="lev3sec32"><strong>Interpreters</strong></h5>&#13;
<p class="noindent">We saw how easy it is to write a BF interpreter, even in SNOBOL. The two links here point to large lists of BF interpreters in all kinds of languages.</p>&#13;
<div class="bq5">&#13;
<p class="noindent"><strong><a href="http://esolangs.org">esolangs.org</a>’s BF implementations</strong>  This page has a long list of BF and BF-related goods and services, er, implementations. (<em><a href="https://esolangs.org/wiki/Brainfuck_implementations">https://esolangs.org/wiki/Brainfuck_implementations</a></em>)</p>&#13;
<p class="noindent"><strong>Rosetta Code’s BF implementations</strong>  BF interpreters in a plethora of languages. Neither Jefe nor I are responsible for time or bits lost due to incomplete or erroneous code. (<em><a href="http://rosettacode.org/wiki/Execute_Brain****">http://rosettacode.org/wiki/Execute_Brain****</a></em>)</p>&#13;
</div>&#13;
<h4 class="h4" id="lev2sec94"><strong><em>Inspirations</em></strong></h4>&#13;
<p class="noindent">Perhaps the greatest tribute to BF is that it has inspired many other esolangs. Some are serious, genuine extensions to core BF. Others are less serious or even outright jokes. If you browse the (long) language list at <em><a href="https://esolangs.org/wiki/Language_list">https://esolangs.org/wiki/Language_list</a></em>, you’ll recognize many BF-related languages from nothing more than the colorful, if not sometimes offensive, names.</p>&#13;
<h4 class="h4" id="lev2sec95"><strong><em>Academic BF</em></strong></h4>&#13;
<p class="noindent">BF isn’t all just fun and games. The language is elementary, yet Turing complete. This makes it attractive to researchers looking for a target or other language to use in their systems. The references here are to academic papers that use BF, either actively or as an example. What’s particularly interesting is that not all of the references are from traditional computer science journals. BF is useful even in relation to more traditional human pursuits, like poetry. This list is by no means exhaustive, merely illustrative, and favors more recent references to BF.<span epub:type="pagebreak" id="page_295"/></p>&#13;
<div class="bq5">&#13;
<p class="noindent"><em>BF++: A Language for General-purpose Program Synthesis</em>, Vadim Liventsev, Aki Härmä, and Milan Petković (2021).</p>&#13;
<p class="noindent"><em>Neural Program Synthesis with Priority Queue Training</em>, Daniel A. Abolafia, Mohammad Norouzi, Jonathan Shen, Rui Zhao, and Quoc V Le (2018).</p>&#13;
<p class="noindent"><em>Resisting Clarity/Highlighting Form: Comparing Vanguard Approaches in Poetry and Programming</em>, Irina Lyubchenko (2020).</p>&#13;
<p class="noindent"><em>Fully Human, Fully Machine: Rhetorics of Digital Disembodiment in Programming</em>, Brandee Easter (2020).</p>&#13;
<p class="noindent"><em>50,000,000,000 Instructions per Second: Design and Implementation of a 256-Core BrainFuck Computer</em>, Sang-Woo Jun (2016).</p>&#13;
<p class="noindent"><em>A Box, Darkly: Obfuscation, Weird Languages, and Code Aesthetics</em>, Michael Mateas and Nick Montfort (2005).</p>&#13;
</div>&#13;
<p class="indent">The first two references use BF with reinforcement learning, thereby combining esolangs and deep machine learning. Advanced neural networks generate BF programs to solve problems.</p>&#13;
<h3 class="h3" id="lev1sec76"><strong>Discussion</strong></h3>&#13;
<p class="noindent">BF is Turing complete. It is imperative, has the requisite control structures (brackets), and, ignoring the self-imposed 30,000-cell memory limit, uses arbitrary memory. Additionally, and impressively, Daniel Cristofani implemented a universal Turing machine in BF, thereby directly demonstrating Turing completeness. The machine is in <em>utm.b</em> in the BF examples directory. Comments in the file explain, in detail, what the program is and what it means.</p>&#13;
<p class="indent">There’s a certain enticing nature to BF due to its simplicity. Yes, it’s challenging to work with, which might have been intentional, like a gauntlet thrown down to see who might pick it up. But I don’t view BF that way. Life is built from the combinatorial mixing of a multitude of smaller components. Might it be possible to view something like BF as the DNA of programming? We already know from <a href="ch03.xhtml#ch03">Chapter 3</a> that a Turing machine captures the essence of what an algorithm is. BF is more advanced than a Turing machine, but just barely, so it can serve the same purpose as an encapsulation of the idea of an “algorithm.”</p>&#13;
<p class="indent">In his famous <em>Epigrams on Programming</em>, Alan Perlis wrote</p>&#13;
<div class="bq">&#13;
<p class="noindent">19. A language that doesn’t affect the way you think about programming, is not worth knowing.</p>&#13;
</div>&#13;
<p class="indent">This is true for every language in this book, but I hope it is especially so for the esolangs, with BF chief among them. Struggling to write code in BF, especially when decades of experience make the necessary code almost instantly present itself in more familiar languages, does affect the way you think about programming. I found myself trying, with varying levels of success, to think in a new way to understand how to fit what BF offers to what <span epub:type="pagebreak" id="page_296"/>I would instinctively do in a language like Python or C. Perhaps that’s the most enduring effect of learning BF. It requires you to think in new ways instead of relying on what is already familiar. BF is a way out of the Python (or C or Java or . . .) echo chamber, as it were.</p>&#13;
<p class="indent">Perlis offers more wisdom directly applicable to BF:</p>&#13;
<div class="bq">&#13;
<p class="noindent">23. To understand a program you must become both the machine and the program.</p>&#13;
</div>&#13;
<p class="indent">For modern, high-level languages, we need not think about the machine too much. Indeed, modern languages go to great lengths to abstract themselves from the machine. With BF, as with a Turing machine, we must consider both the machine and the program if we hope to be successful.</p>&#13;
<p class="indent">As we’re quoting Perlis, I’d be remiss not to include this epigram:</p>&#13;
<div class="bq">&#13;
<p class="noindent">54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.</p>&#13;
</div>&#13;
<p class="indent">Turing tar-pits might be a bit like beauty—in the eye of the beholder. The following that has grown around BF and, by extension, esolangs in general, argues against Perlis in this case, at least to me. Perlis’s first epigram is “One man’s constant is another man’s variable.” I’m tempted to rephrase it: “One man’s Turing tar-pit is another man’s inspiration.”</p>&#13;
<h3 class="h3" id="lev1sec77"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter introduced us to the strangely attractive, if frustratingly difficult, multiverse of BF. We explored what BF is and then implemented it twice: once in C using the original implementation and again in SNOBOL. After this, we wrote a few example programs to get a feel for thinking in BF. With a basic grasp of the language in hand, we then turned our gaze upward to examine some of the brighter lights in the BF multiverse. As with every language, we closed the chapter with a brief discussion.</p>&#13;
<p class="indent">In <a href="ch09.xhtml#ch09">Chapter 9</a> we painted pretty pictures with Piet, a 2D language. Let’s close our survey of existing esolangs by returning to the world of 2D programming, but this time using text instead of pixels. Next stop: Befunge.</p>&#13;
</div></body></html>