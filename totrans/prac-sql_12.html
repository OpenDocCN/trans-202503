<html><head></head><body><div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" title="203" id="Page_203"/>12</span><br/>&#13;
<span class="ChapterTitle">Working with Dates and Times</span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img src="Images/chapterart.png" alt="" width="200" height="200"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Columns filled with dates and times can indicate <em>when</em> events happened or <em>how long</em> they took, and that can lead to interesting lines of inquiry. What patterns exist in the moments on a timeline? Which events were shortest or longest? What relationships exist between a particular activity and the time of day or season in which it occurred?</p>&#13;
<p>In this chapter, we’ll explore these kinds of questions using SQL data types for dates and times and their related functions. We’ll start with a closer look at data types and functions related to dates and times. Then we’ll explore a dataset on trips by New York City taxicabs to look for patterns and try to discover what, if any, story the data tells. We’ll also explore time zones using Amtrak data to calculate the duration of train trips across the United States.</p>&#13;
<h2 id="h1-501065c12-0001"><span epub:type="pagebreak" title="204" id="Page_204"/>Understanding Data Types and Functions for Dates and Times</h2>&#13;
<p class="BodyFirst"><span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span> explored primary SQL data types, but to review, here are the four data types related to dates and times:</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>timestamp</code></span></span>  Records date and time. You will almost always want to add the keywords <code>with time zone</code> to ensure that times stored include time zone information. Otherwise, times recorded around the globe become impossible to compare. The format <code>timestamp with time zone</code> is part of the SQL standard; with PostgreSQL you can specify the same data type using <code>timestamptz</code>. You can specify time zones in three different formats: its UTC offset, an area/location designator, or a standard abbreviation. If you supply a time without a time zone to a <code>timestamptz</code> column, the database will add time zone information using your server’s default setting.</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>date</code></span><span class="LiteralBold"><code/></span></span>  Records only the date and is part of the SQL standard. PostgreSQL accepts several date formats. For example, valid formats for adding the 21st day of September 2022 are <code>September 21, 2022</code> or <code>9/21/2022</code>. I recommend using <var>YYYY-MM-DD</var> (or <code>2022-09-21</code>), which is the ISO 8601 international standard format and also the default PostgreSQL date output. Using the ISO format helps avoid confusion when sharing data internationally.</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>time</code></span><span class="LiteralBold"><code/></span></span>  Records only the time and is part of the SQL standard. Adding <code>with time zone</code> makes the column time zone aware, but without a date the time zone will be meaningless. Given that, using <code>time with time zone</code> and its PostgreSQL shortcut <code>timetz</code> is strongly discouraged. The ISO 8601 format is <var>HH:MM:SS</var>, where <var>HH</var> represents the hour, <var>MM</var> the minutes, and <var>SS</var> the seconds.</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>interval</code></span><span class="LiteralBold"><code/></span></span>  Holds a value that represents a unit of time expressed in the format <var>quantity unit</var>. It doesn’t record the start or end of a period, only its duration. Examples include <code>12 days</code> or <code>8 hours</code>. It’s also part of the SQL standard, although PostgreSQL-specific syntax offers more options.</li>&#13;
</ol>&#13;
<p>The first three data types, <code>date</code>, <code>time</code>, and <code>timestamp with time zone</code> (or <code>timestamptz</code>), are known as <em>datetime types</em> whose values are called <em>datetimes</em>. The <code>interval</code> value is an <em>interval type</em> whose values are <em>intervals</em>. All four data types can track the system clock and the nuances of the calendar. For example, <code>date</code> and <code>timestamp with time zone</code> recognize that June has 30 days. If you try to use June 31, PostgreSQL will display an error: <code>date/time field value out of range</code>. Likewise, the date February 29 is valid only in a leap year, such as 2024.</p>&#13;
<h2 id="h1-501065c12-0002">Manipulating Dates and Times</h2>&#13;
<p class="BodyFirst">We can use SQL functions to perform calculations on dates and times or extract their components. For example, we can retrieve the day of the week from a timestamp or extract just the month from a date. ANSI SQL outlines a handful of functions for this purpose, but many database <span epub:type="pagebreak" title="205" id="Page_205"/>managers (including MySQL and Microsoft SQL Server) deviate from the standard to implement their own date and time data types, syntax, and function names. If you’re using a database other than PostgreSQL, check its documentation.</p>&#13;
<p>Let’s review how to manipulate dates and times using PostgreSQL functions.</p>&#13;
<h3 id="h2-501065c12-0001">Extracting the Components of a timestamp Value</h3>&#13;
<p class="BodyFirst">It’s not unusual to need just one piece of a date or time value for analysis, particularly when you’re aggregating results by month, year, or even minute. We can extract these components using the PostgreSQL <code>date_part()</code> function. Its format looks like this:</p>&#13;
<pre><code>date_part(<var>text</var>, <var>value</var>)</code></pre>&#13;
<p>The function takes two inputs. The first is a string in <code>text</code> format that represents the part of the date or time to extract, such as <code>hour</code>, <code>minute</code>, or <code>week</code>. The second is the <code>date</code>, <code>time</code>, or <code>timestamp</code> value. To see the <code>date_part()</code> function in action, we’ll execute it multiple times on the same value using the code in <a href="#listing12-1" id="listinganchor12-1">Listing 12-1</a>.</p>&#13;
<pre><code>SELECT&#13;
  date_part('year', '2022-12-01 18:37:12 EST'::timestamptz) AS year,&#13;
  date_part('month', '2022-12-01 18:37:12 EST'::timestamptz) AS month,&#13;
  date_part('day', '2022-12-01 18:37:12 EST'::timestamptz) AS day,&#13;
  date_part('hour', '2022-12-01 18:37:12 EST'::timestamptz) AS hour,&#13;
  date_part('minute', '2022-12-01 18:37:12 EST'::timestamptz) AS minute,&#13;
  date_part('seconds', '2022-12-01 18:37:12 EST'::timestamptz) AS seconds,&#13;
  date_part('timezone_hour', '2022-12-01 18:37:12 EST'::timestamptz) AS tz,&#13;
  date_part('week', '2022-12-01 18:37:12 EST'::timestamptz) AS week,&#13;
  date_part('quarter', '2022-12-01 18:37:12 EST'::timestamptz) AS quarter,&#13;
  date_part('epoch', '2022-12-01 18:37:12 EST'::timestamptz) AS epoch;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-1">Listing 12-1</a>: Extracting components of a <code>timestamp</code> value using <code>date_part()</code></p>&#13;
<p>Each column statement in this <code>SELECT</code> query first uses a string to name the component we want to extract: <code>year</code>, <code>month</code>, <code>day</code>, and so on. The second input uses the string <code>2022-12-01 18:37:12 EST</code> cast as a <code>timestamp with time zone</code> with the PostgreSQL double-colon syntax and the <code>timestamptz</code> shorthand. We specify that this timestamp occurs in the Eastern time zone using the Eastern Standard Time (EST) designation.</p>&#13;
<p>Here’s the output as shown on my computer. The database converts the values to reflect your PostgreSQL time zone setting, so your output might be different; for example, if it’s set to the US Pacific time zone, the hour will show as <code>15</code>:</p>&#13;
<pre><code>year    month    day    hour    minute    seconds    tz    week    quarter    epoch&#13;
----    -----    ---    ----    ------    -------    --    ----    -------    ----------&#13;
2022       12      1      18        37         12    -5      48          4    1669937832</code></pre>&#13;
<p><span epub:type="pagebreak" title="206" id="Page_206"/>Each column contains a single component of the timestamp that represents 6:37:12 <span class="KeyCaps">pm</span> on December 1, 2022. The first six values are easy to recognize from the original timestamp, but the last four deserve an explanation.</p>&#13;
<p>In the <code>tz</code> column, PostgreSQL reports back the hours difference, or <em>offset</em>, from Coordinated Universal Time (UTC), the time standard for the world. The value of UTC is +/− 00:00, so <code>-5</code> specifies a time zone five hours behind UTC. From November through early March, UTC -5 represents the Eastern time zone. In March, when the Eastern time zone moves to daylight saving time and clocks “spring forward” an hour, its UTC offset changes to -4. (For a map of UTC time zones, see <a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time#/media/File:Standard_World_Time_Zones.tif" class="LinkURL">https://en.wikipedia.org/wiki/Coordinated_Universal_Time#/media/File:Standard_World_Time_Zones.tif</a>.)</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	You can derive the UTC offset from the time zone but not vice versa. Each UTC offset can refer to multiple named time zones plus standard and daylight saving time variants.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>The <code>week</code> column shows that December 1, 2022, falls in the 48th week of the year. This number is determined by ISO 8601 standards, which start each week on a Monday. A week at the end of a year can extend from December into January of the following year.</p>&#13;
<p>The <code>quarter</code> column shows that our test date is part of the fourth quarter of the year. The <code>epoch</code> column shows a measurement, which is used in computer systems and programming languages, that represents the number of seconds elapsed before or after 12 <span class="KeyCaps">am</span>, January 1, 1970, at UTC 0. A positive value designates a time since that point; a negative value designates a time before it. In this example, 1,669,937,832 seconds elapsed between January 1, 1970, and the timestamp. Epoch can be useful for comparing two timestamps mathematically on an absolute scale.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	Proceed with caution with epoch times. PostgreSQL’s <code>date_part()</code> returns epoch time as a double precision type, which is subject to floating-point computational errors (see <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>). Epoch time also faces the so-called Year 2038 problem, when epoch values will grow too large for some computer systems to store.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>PostgreSQL also supports the SQL-standard <code>extract()</code> function, which parses datetimes in the same way as the <code>date_part()</code> function. I’ve featured <code>date_part()</code> here instead for two reasons. First, its name helpfully reminds us what it does. Second, <code>extract()</code> isn’t widely supported by other database managers. Most notably, it’s absent in Microsoft’s SQL Server. Nevertheless, if you need to use <code>extract()</code>, the syntax takes this form:</p>&#13;
<pre><code>extract(<var>text</var> from <var>value</var>)</code></pre>&#13;
<p>To replicate the first <code>date_part()</code> example in <a href="#listing12-1">Listing 12-1</a> where we pull the year from the timestamp, we’d set up <code>extract()</code> like this (note that we don’t need single quotes around the time unit, in this case <code>year</code>):</p>&#13;
<pre><code>extract(year from '2022-12-01 18:37:12 EST'::timestamptz)</code></pre>&#13;
<p><span epub:type="pagebreak" title="207" id="Page_207"/>PostgreSQL provides additional components you can extract or calculate from dates and times. For the full list of functions, see the documentation at <a href="https://www.postgresql.org/docs/current/functions-datetime.html" class="LinkURL">https://www.postgresql.org/docs/current/functions-datetime.html</a>.</p>&#13;
<h3 id="h2-501065c12-0002">Creating Datetime Values from timestamp Components</h3>&#13;
<p class="BodyFirst">It’s not unusual to come across a dataset in which the year, month, and day exist in separate columns, and you might want to create a datetime value from these components. To perform calculations on a date, it’s helpful to combine and format those pieces correctly into one column.</p>&#13;
<p>You can use the following PostgreSQL functions to make datetime objects:</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>make_date(year, month, day)</code></span><span class="LiteralBold"><code/></span></span>  Returns a value of type <code>date</code>.</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>make_time(hour, minute, seconds)</code></span><span class="LiteralBold"><code/></span></span>  Returns a value of type <code>time</code> without time zone.</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>make_timestamptz(year, month, day, hour, minute, second, time zone)</code></span></span>  Returns a timestamp with time zone.</li>&#13;
</ol>&#13;
<p>The variables for these three functions take <code>integer</code> types as input, with two exceptions: seconds are of the type <code>double precision</code> because you can supply fractions of seconds, and time zones must be specified with a <code>text</code> string that names the time zone.</p>&#13;
<p><a href="#listing12-2" id="listinganchor12-2">Listing 12-2</a> shows examples of the three functions in action using components of February 22, 2022, for the date, and 6:04:30.3 <span class="KeyCaps">pm</span> in Lisbon, Portugal for the time.</p>&#13;
<pre><code>SELECT make_date(2022, 2, 22);&#13;
SELECT make_time(18, 4, 30.3);&#13;
SELECT make_timestamptz(2022, 2, 22, 18, 4, 30.3, 'Europe/Lisbon');</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-2">Listing 12-2</a>: Three functions for making datetimes from components</p>&#13;
<p>When I run each query in order, the output on my computer is as follows. Again, yours may differ depending on your PostgreSQL time zone setting:</p>&#13;
<pre><code>2022-02-22&#13;
18:04:30.3&#13;
2022-02-22 13:04:30.3-05</code></pre>&#13;
<p>Notice that on my computer the timestamp in the third line shows <code>13:04:30.3</code>, which is five hours behind the time input to the function: <code>18:04:30.3</code><span class="KeyCaps">.</span> That output is appropriate because Lisbon’s time zone is at UTC 0, and my PostgreSQL is set to the Eastern time zone, which is UTC –5 in winter months. We’ll explore working with time zones in more detail, and you’ll learn to adjust its display, in the “Working with Time Zones” section.</p>&#13;
<h3 id="h2-501065c12-0003"><span epub:type="pagebreak" title="208" id="Page_208"/>Retrieving the Current Date and Time</h3>&#13;
<p class="BodyFirst">If you need to record the current date or time as part of a query—when updating a row, for example—standard SQL provides functions for that too. The following functions record the time as of the start of the query:</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>current_timestamp</code></span><span class="LiteralBold"><code>  </code></span></span>Returns the current timestamp with time zone. A shorthand PostgreSQL-specific version is <code>now()</code>.</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>localtimestamp</code></span><span class="LiteralBold"><code>  </code></span></span>Returns the current timestamp without time zone. Avoid using <code>localtimestamp</code>, as a timestamp without a time zone can’t be placed in a global location and is thus meaningless.</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>current_</code></span><span class="LiteralBold"><code>date</code></span><span class="LiteralBold"><code>  </code></span></span>Returns the date.</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>current_time</code></span><span class="LiteralBold"><code>  </code></span></span>Returns the current time with time zone. Remember, though, without a date, the time alone with a time zone is useless.</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>localtime</code></span>  </span>Returns the current time without time zone.</li>&#13;
</ol>&#13;
<p>Because these functions record the time at the start of the query (or a collection of queries grouped under a <em>transaction</em>—see <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>), they’ll provide that same time throughout the execution of a query regardless of how long the query runs. So, if your query updates 100,000 rows and takes 15 seconds to run, any timestamp recorded at the start of the query will be applied to each row, and so each row will receive the same timestamp.</p>&#13;
<p>If, instead, you want the date and time to reflect how the clock changes during the execution of the query, you can use the PostgreSQL-specific <code>clock_timestamp()</code> function to record the current time as it elapses. That way, if you’re updating 100,000 rows and inserting a timestamp each time, each row gets the time the row updated rather than the time at the start of the query. Note that <code>clock_timestamp()</code> can slow large queries and may be subject to system limitations.</p>&#13;
<p><a href="#listing12-3" id="listinganchor12-3">Listing 12-3</a> shows <code>current_timestamp</code> and <code>clock_timestamp()</code> in action when inserting a row in a table.</p>&#13;
<pre><code>CREATE TABLE current_time_example (&#13;
    time_id integer GENERATED ALWAYS AS IDENTITY,&#13;
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> current_timestamp_col timestamptz,&#13;
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> clock_timestamp_col timestamptz&#13;
);&#13;
&#13;
INSERT INTO current_time_example&#13;
            (current_timestamp_col, clock_timestamp_col)&#13;
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> (SELECT current_timestamp,&#13;
            clock_timestamp()&#13;
     FROM generate_series(1,1000));&#13;
&#13;
SELECT * FROM current_time_example;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-3">Listing 12-3</a>: Comparing <code>current_timestamp</code> and <code>clock_timestamp()</code> during row insert</p>&#13;
<p>The code creates a table that includes two <code>timestamptz</code> columns (the PostgreSQL shorthand for <code>timestamp with time zone</code>). The first holds the <span epub:type="pagebreak" title="209" id="Page_209"/>result of the <code>current_timestamp</code> function <span class="CodeAnnotation" aria-label="annotation1">1</span>, which records the time at the start of the <code>INSERT</code> statement that adds 1,000 rows to the table. To do that, we use the <code>generate_series()</code> function, which returns a set of integers starting with 1 and ending with 1,000. The second column holds the result of the <code>clock_timestamp()</code> function <span class="CodeAnnotation" aria-label="annotation2">2</span>, which records the time of insertion of each row. You call both functions as part of the <code>INSERT</code> statement <span class="CodeAnnotation" aria-label="annotation3">3</span>. Run the query, and the result from the final <code>SELECT</code> statement should show that the time in the <code>current_timestamp_col</code> is the same for all rows, whereas the time in <code>clock_timestamp_col</code> increases with each row inserted.</p>&#13;
<h2 id="h1-501065c12-0003">Working with Time Zones</h2>&#13;
<p class="BodyFirst">Recording a timestamp is most useful when you know where on the globe that time occurred—whether in Asia, Eastern Europe, or one of the 12 time zones of Antarctica.</p>&#13;
<p>Sometimes, however, datasets contain no time zone data in their datetime columns. This isn’t always a deal-breaker in terms of analyzing the data. If you know that every event happened in the same location—for example, readings from a temperature sensor in Bar Harbor, Maine—you can factor that into your analysis. Better, though, during import is to set your session time zone to represent the time zone of the data and load the datetimes into a <code>timestamptz</code> column. That strategy helps ward off dangerous misinterpretation of the data later.</p>&#13;
<p>Let’s look at some strategies for managing how we work with time zones.</p>&#13;
<h3 id="h2-501065c12-0004">Finding Your Time Zone Setting</h3>&#13;
<p class="BodyFirst">When working with timestamps that contain time zones, it’s important to know your current time zone setting. If you installed PostgreSQL on your own computer, the server’s default will be your local time zone. If you’re connecting to a PostgreSQL database elsewhere, perhaps on a cloud provider such as Amazon Web Services, its time zone setting may be different than your own. To help avoid confusion, database administrators often set a shared server’s time zone to UTC.</p>&#13;
<p><a href="#listing12-4" id="listinganchor12-4">Listing 12-4</a> shows two ways to view your current time zone setting: the <code>SHOW</code> command with <code>timezone</code> keyword and the <code>current_setting()</code> function with a <code>timezone</code> argument.</p>&#13;
<pre><code>SHOW timezone;&#13;
SELECT current_setting('timezone');</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-4">Listing 12-4</a>: Viewing your current time zone setting</p>&#13;
<p>Running either statement will display your time zone setting, which will vary according to your operating system and locale. Entering the statements in <a href="#listing12-4">Listing 12-4</a> into pgAdmin and running both my macOS and Linux computers returns <code>America/New_York</code>, one of several location names that falls into the Eastern time zone, which encompasses eastern Canada and the United <span epub:type="pagebreak" title="210" id="Page_210"/>States, the Caribbean, and parts of Mexico. On my Windows machine, the setting shows as <code>US/Eastern</code>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	You can use <code>SHOW ALL;</code> to see the settings of every parameter on your PostgreSQL server.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>Though both statements provide the same information, you may find <code>current_setting()</code> extra handy as an input to another function such as <code>make_timestamptz()</code>:</p>&#13;
<pre><code> SELECT make_timestamptz(2022, 2, 22, 18, 4, 30.3, current_setting('timezone'));</code></pre>&#13;
<p><a href="#listing12-5" id="listinganchor12-5">Listing 12-5</a> shows how to retrieve all time zone names, abbreviations, and their UTC offsets.</p>&#13;
<pre><code>SELECT * FROM pg_timezone_abbrevs ORDER BY abbrev;&#13;
SELECT * FROM pg_timezone_names ORDER BY name;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-5">Listing 12-5</a>: Showing time zone abbreviations and names</p>&#13;
<p>You can easily filter either of these <code>SELECT</code> statements with a <code>WHERE</code> clause to look up specific location names or time zones:</p>&#13;
<pre><code>SELECT * FROM pg_timezone_names&#13;
WHERE name LIKE 'Europe%'&#13;
ORDER BY name;</code></pre>&#13;
<p>This code should return a table listing that includes the time zone name, abbreviation, UTC offset, and a <code>boolean</code> column <code>is_dst</code> that notes whether the time zone is currently observing daylight saving time:</p>&#13;
<pre><code>name                abbrev    utc_offset    is_dst&#13;
----------------    ------    ----------    ------&#13;
Europe/Amsterdam    CEST      02:00:00      true&#13;
Europe/Andorra      CEST      02:00:00      true&#13;
Europe/Astrakhan    +04       04:00:00      false&#13;
Europe/Athens       EEST      03:00:00      true&#13;
Europe/Belfast      BST       01:00:00      true&#13;
<var>--snip--</var></code></pre>&#13;
<p>This is a faster way of looking up time zones than using Wikipedia. Now let’s look at how to set the time zone to a particular value.</p>&#13;
<h3 id="h2-501065c12-0005">Setting the Time Zone</h3>&#13;
<p class="BodyFirst">When you installed PostgreSQL, the server’s default time zone was set as a parameter in <em>postgresql.conf</em>, a file that contains dozens of values read by PostgreSQL each time it starts. The location of <em>postgresql.conf</em> in your file system varies depending on your operating system and sometimes on the way you installed PostgreSQL. To make permanent changes to <em>postgresql.conf</em>, such as changing your time zone, you need to edit the file and restart the server, which might be impossible if you’re not the owner of the machine. <span epub:type="pagebreak" title="211" id="Page_211"/>Changes to configurations might also have unintended consequences for other users or applications. Instead, we’ll look at setting the time zone on a per-session basis, which should last as long as you’re connected to the server, and then I’ll cover working with <em>postgresql.conf</em> in more depth in <span class="xref" itemid="xref_target_Chapter 19">Chapter 19</span>. This solution is handy when you want to specify how you view a particular table or handle timestamps in a query.</p>&#13;
<p>To set the time zone for the current session while using pgAdmin, we use the command <code>SET TIME ZONE</code>, as shown in <a href="#listing12-6" id="listinganchor12-6">Listing 12-6</a>.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> SET TIME ZONE 'US/Pacific';&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> CREATE TABLE time_zone_test (&#13;
    test_date timestamptz&#13;
);&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> INSERT INTO time_zone_test VALUES ('2023-01-01 4:00');&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> SELECT test_date&#13;
FROM time_zone_test;&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation5">5</span> SET TIME ZONE 'US/Eastern';&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation6">6</span> SELECT test_date&#13;
FROM time_zone_test;&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation7">7</span> SELECT test_date AT TIME ZONE 'Asia/Seoul'&#13;
FROM time_zone_test;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-6">Listing 12-6</a>: Setting the time zone for a client session</p>&#13;
<p>First, we set the time zone to <code>US/Pacific</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, which designates the Pacific time zone that covers western Canada and the United States along with Baja California in Mexico. The syntax <code>SET TIME ZONE</code> is part of the ANSI SQL standard. PostgreSQL also supports the nonstandard syntax <code>SET timezone TO</code>.</p>&#13;
<p>Second, we create a one-column table <span class="CodeAnnotation" aria-label="annotation2">2</span> with a data type of <code>timestamptz</code> and insert a single row to display a test result. Notice that the value inserted, <code>2023-01-01 4:00</code>, is a timestamp with no time zone <span class="CodeAnnotation" aria-label="annotation3">3</span>. You’ll encounter timestamps with no time zone often, particularly when you acquire datasets restricted to a specific location.</p>&#13;
<p>When executed, the first <code>SELECT</code> statement <span class="CodeAnnotation" aria-label="annotation4">4</span> returns <code>2023-01-01 4:00</code> as a timestamp that now contains time zone data:</p>&#13;
<pre><code>test_date&#13;
----------------------&#13;
2023-01-01 04:00:00-08</code></pre>&#13;
<p>Here, the <code>-08</code> shows that the Pacific time zone is eight hours behind UTC in January, when standard time is in effect. Because we set the pgAdmin client’s time zone to <code>US/Pacific</code> for this session, any value without a time zone entered into a column that is time zone-aware will be set to Pacific time. If we had entered a date that falls during daylight saving time, the UTC offset would be <code>-07</code>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<span epub:type="pagebreak" title="212" id="Page_212"/><h2><span class="NoteHead">Note</span></h2>&#13;
<p>	On the server, the <code>timestamp with time zone</code> (or <code>timestamptz</code> shorthand) data type always stores data as UTC internally; the time zone setting governs how it’s displayed.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>Now comes some fun. We change the time zone for this session to the Eastern time zone using the <code>SET</code> command <span class="CodeAnnotation" aria-label="annotation5">5</span> and the <code>US/Eastern</code> designation. Then, when we execute the <code>SELECT</code> statement <span class="CodeAnnotation" aria-label="annotation6">6</span> again, the result should be as follows:</p>&#13;
<pre><code>test_date&#13;
----------------------&#13;
2023-01-01 07:00:00-05</code></pre>&#13;
<p>In this example, two components of the timestamp have changed: the time is now <code>07:00</code>, and the UTC offset is <code>-05</code> because we’re viewing the timestamp from the perspective of the Eastern time zone: 4 <span class="KeyCaps">am</span> Pacific is 7 <span class="KeyCaps">am</span> Eastern. The database converts the original Pacific time value to whatever time zone we set at <span class="CodeAnnotation" aria-label="annotation5">5</span>.</p>&#13;
<p>Even more convenient is that we can view a timestamp through the lens of any time zone without changing the session setting. The final <code>SELECT</code> statement uses the <code>AT TIME ZONE</code> keywords <span class="CodeAnnotation" aria-label="annotation7">7</span> to display the timestamp in our session as the Korea standard time (KST) zone by specifying <code>Asia/Seoul</code>:</p>&#13;
<pre><code>timezone&#13;
-------------------&#13;
2023-01-01 21:00:00</code></pre>&#13;
<p>Now we know that the value of 4 <span class="KeyCaps">am</span> in <code>US/Pacific</code> on January 1, 2023, is equivalent to 9 <span class="KeyCaps">pm</span> that same day in <code>Asia/Seoul</code>. Again, this syntax changes the output data, but the data on the server remains unchanged. When using the <code>AT TIME ZONE</code> keywords, also note this quirk: if the original value is a <code>timestamp with time zone</code>, the output is a <code>timestamp</code> with no time zone. If the original value has no time zone, the output is <code>timestamp with time zone</code>.</p>&#13;
<p>The ability of databases to track time zones is extremely important for accurate calculations of intervals, as you’ll see next.</p>&#13;
<h2 id="h1-501065c12-0004">Performing Calculations with Dates and Times</h2>&#13;
<p class="BodyFirst">We can perform simple arithmetic on datetime and interval types the same way we can on numbers. Addition, subtraction, multiplication, and division are all possible in PostgreSQL using the math operators <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>. For example, you can subtract one date from another date to get an integer that represents the difference in days between the two dates. The following code returns an integer of <code>3</code>:</p>&#13;
<pre><code>SELECT '1929-09-30'::date - '1929-09-27'::date;</code></pre>&#13;
<p>The result indicates that these two dates are exactly three days apart.</p>&#13;
<p><span epub:type="pagebreak" title="213" id="Page_213"/>Likewise, you can use the following code to add a time interval to a date to return a new date:</p>&#13;
<pre><code>SELECT '1929-09-30'::date + '5 years'::interval;</code></pre>&#13;
<p>This code adds five years to the date <code>1929-09-30</code> to return a timestamp value of <code>1934-09-30</code>.</p>&#13;
<p>More examples of math functions you can use with dates and times are available in the PostgreSQL documentation at <a href="https://www.postgresql.org/docs/current/functions-datetime.html" class="LinkURL">https://www.postgresql.org/docs/current/functions-datetime.html</a>. Let’s explore some more practical examples using actual transportation data.</p>&#13;
<h3 id="h2-501065c12-0006">Finding Patterns in New York City Taxi Data</h3>&#13;
<p class="BodyFirst">When I visit New York City, I usually take at least one ride in one of the thousands of iconic yellow cars that ferry hundreds of thousands of people across the city’s five boroughs each day. The New York City Taxi and Limousine Commission releases data on monthly yellow taxi trips plus other for-hire vehicles. We’ll use this large, rich dataset to put date functions to practical use.</p>&#13;
<p>The <em>nyc_yellow_taxi_trips.csv</em> file available from the book’s resources on GitHub (via the link at <a href="https://nostarch.com/practical-sql-2nd-edition/" class="LinkURL">https://nostarch.com/practical-sql-2nd-edition/</a>) holds one day of yellow taxi trip records from June 1, 2016. Save the file to your computer and execute the code in <a href="#listing12-7" id="listinganchor12-7">Listing 12-7</a> to build the <code>nyc_yellow_taxi_trips</code> table. Remember to change the file path in the <code>COPY</code> command to the location where you’ve saved the file and adjust the path format to reflect whether you’re using Windows, macOS, or Linux.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> CREATE TABLE nyc_yellow_taxi_trips (&#13;
    trip_id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,&#13;
    vendor_id text NOT NULL,&#13;
    tpep_pickup_datetime timestamptz NOT NULL,&#13;
    tpep_dropoff_datetime timestamptz NOT NULL,&#13;
    passenger_count integer NOT NULL,&#13;
    trip_distance numeric(8,2) NOT NULL,&#13;
    pickup_longitude numeric(18,15) NOT NULL,&#13;
    pickup_latitude numeric(18,15) NOT NULL,&#13;
    rate_code_id text NOT NULL,&#13;
    store_and_fwd_flag text NOT NULL,&#13;
    dropoff_longitude numeric(18,15) NOT NULL,&#13;
    dropoff_latitude numeric(18,15) NOT NULL,&#13;
    payment_type text NOT NULL,&#13;
    fare_amount numeric(9,2) NOT NULL,&#13;
    extra numeric(9,2) NOT NULL,&#13;
    mta_tax numeric(5,2) NOT NULL,&#13;
    tip_amount numeric(9,2) NOT NULL,&#13;
    tolls_amount numeric(9,2) NOT NULL,&#13;
    improvement_surcharge numeric(9,2) NOT NULL,&#13;
    total_amount numeric(9,2) NOT NULL&#13;
);&#13;
&#13;
<span epub:type="pagebreak" title="214" id="Page_214"/><span class="CodeAnnotationHang" aria-label="annotation2">2</span> COPY nyc_yellow_taxi_trips (&#13;
    vendor_id,&#13;
    tpep_pickup_datetime,&#13;
    tpep_dropoff_datetime,&#13;
    passenger_count,&#13;
    trip_distance,&#13;
    pickup_longitude,&#13;
    pickup_latitude,&#13;
    rate_code_id,&#13;
    store_and_fwd_flag,&#13;
    dropoff_longitude,&#13;
    dropoff_latitude,&#13;
    payment_type,&#13;
    fare_amount,&#13;
    extra,&#13;
    mta_tax,&#13;
    tip_amount,&#13;
    tolls_amount,&#13;
    improvement_surcharge,&#13;
    total_amount&#13;
   )&#13;
FROM '<var>C:\YourDirectory\</var>nyc_yellow_taxi_trips.csv'&#13;
WITH (FORMAT CSV, HEADER);&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> CREATE INDEX tpep_pickup_idx&#13;
ON nyc_yellow_taxi_trips (tpep_pickup_datetime);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-7">Listing 12-7</a>: Creating a table and importing NYC yellow taxi data</p>&#13;
<p>The code in <a href="#listing12-7">Listing 12-7</a> builds the table <span class="CodeAnnotation" aria-label="annotation1">1</span>, imports the rows <span class="CodeAnnotation" aria-label="annotation2">2</span>, and creates an index <span class="CodeAnnotation" aria-label="annotation3">3</span>. In the <code>COPY</code> statement, we provide the names of columns because the input CSV file doesn’t include the <code>trip_id</code> column that exists in the target table. That column is of type <code>bigint</code> and set as an auto-incrementing surrogate primary key. After your import is complete, you should have 368,774 rows, one for each yellow cab ride on June 1, 2016. You can count the rows in your table using the following code:</p>&#13;
<pre><code>SELECT count(*) FROM nyc_yellow_taxi_trips;</code></pre>&#13;
<p>Each row includes data on the number of passengers, the location of pickup and drop-off in latitude and longitude, and the fare and tips in US dollars. The data dictionary that describes all columns and codes is available at <a href="https://www1.nyc.gov/assets/tlc/downloads/pdf/data_dictionary_trip_records_yellow.pdf" class="LinkURL">https://www1.nyc.gov/assets/tlc/downloads/pdf/data_dictionary_trip_records_yellow.pdf</a>. For these exercises, we’re most interested in the timestamp columns <code>tpep_pickup_datetime</code> and <code>tpep_dropoff_datetime</code>, which represent the start and end times of the ride. (The Technology Passenger Enhancements Project [TPEP] is a program that in part includes automated collection of data about taxi rides.)</p>&#13;
<p>The values in both timestamp columns include the time zone: <code>-4</code>. That’s the UTC offset for the Eastern time zone during summer, when daylight saving time is observed. If your PostgreSQL server isn’t set to default to <span epub:type="pagebreak" title="215" id="Page_215"/>Eastern time, I suggest setting your time zone using the following code so your results will match mine:</p>&#13;
<pre><code>SET TIME ZONE 'US/Eastern';</code></pre>&#13;
<p>Now let’s explore the patterns in these timestamps.</p>&#13;
<h4 id="h3-501065c12-0001">The Busiest Time of Day</h4>&#13;
<p class="BodyFirst">One question you might ask of this data is when taxis provide the most rides. Is it morning or evening rush hour, or is there another time when ridership spikes? You can find the answer with a simple aggregation query that uses <code>date_part()</code>.</p>&#13;
<p><a href="#listing12-8" id="listinganchor12-8">Listing 12-8</a> contains the query to count rides by hour using the pickup time as the input.</p>&#13;
<pre><code>SELECT&#13;
   <span class="CodeAnnotationCode" aria-label="annotation1">1</span> date_part('hour', tpep_pickup_datetime) AS trip_hour,&#13;
   <span class="CodeAnnotationCode" aria-label="annotation2">2</span> count(*)&#13;
FROM nyc_yellow_taxi_trips&#13;
GROUP BY trip_hour&#13;
ORDER BY trip_hour;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-8">Listing 12-8</a>: Counting taxi trips by hour</p>&#13;
<p>In the query’s first column <span class="CodeAnnotation" aria-label="annotation1">1</span>, <code>date_part()</code> extracts the hour from <code>tpep_pickup_datetime</code> so we can group the number of rides by hour. Then we aggregate the number of rides in the second column via the <code>count()</code> function <span class="CodeAnnotation" aria-label="annotation2">2</span>. The rest of the query follows the standard patterns for grouping and ordering the results, which should return 24 rows, one for each hour of the day:</p>&#13;
<pre><code>trip_hour    count&#13;
---------    -----&#13;
        0     8182&#13;
        1     5003&#13;
        2     3070&#13;
        3     2275&#13;
        4     2229&#13;
        5     3925&#13;
        6    10825&#13;
        7    18287&#13;
        8    21062&#13;
        9    18975&#13;
       10    17367&#13;
       11    17383&#13;
       12    18031&#13;
       13    17998&#13;
       14    19125&#13;
       15    18053&#13;
       16    15069&#13;
       17    18513&#13;
       18    22689&#13;
<span epub:type="pagebreak" title="216" id="Page_216"/>       19    23190&#13;
       20    23098&#13;
       21    24106&#13;
       22    22554&#13;
       23    17765</code></pre>&#13;
<p>Eyeballing the numbers, it’s apparent that on June 1, 2016, New York City taxis had the most passengers between 6 <span class="KeyCaps">pm</span> and 10 <span class="KeyCaps">pm</span>, possibly reflecting commutes home plus the plethora of city activities on a summer evening. But to see the overall pattern, it’s best to visualize the data. Let’s do this next.</p>&#13;
<h4 id="h3-501065c12-0002">Exporting to CSV for Visualization in Excel</h4>&#13;
<p class="BodyFirst">Charting data with a tool such as Microsoft Excel makes it easier to understand patterns, so I often export query results to a CSV file and work up a quick chart. <a href="#listing12-9" id="listinganchor12-9">Listing 12-9</a> uses the query from the preceding example within a <code>COPY ... TO</code> statement, similar to <a href="c05.xhtml#listing5-9">Listing 5-9</a> in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>.</p>&#13;
<pre><code>COPY&#13;
    (SELECT&#13;
        date_part('hour', tpep_pickup_datetime) AS trip_hour,&#13;
        count(*)&#13;
    FROM nyc_yellow_taxi_trips&#13;
    GROUP BY trip_hour&#13;
    ORDER BY trip_hour&#13;
    )&#13;
TO '<var>C:\YourDirectory\</var>hourly_taxi_pickups.csv'&#13;
WITH (FORMAT CSV, HEADER);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-9">Listing 12-9</a>: Exporting taxi pickups per hour to a CSV file</p>&#13;
<p>When I load the data into Excel and build a line graph, the day’s pattern becomes more obvious and thought-provoking, as shown in <a href="#figure12-1" id="figureanchor12-1">Figure 12-1</a>.</p>&#13;
<figure>&#13;
<img src="Images/f12001.png" alt="f12001" class="" width="671" height="310"/>&#13;
<figcaption><p><a id="figure12-1">Figure 12-1</a>: NYC yellow taxi pickups by hour</p></figcaption>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" title="217" id="Page_217"/>Rides bottomed out in the wee hours of the morning before rising sharply between 5 <span class="KeyCaps">am</span> and 8 <span class="KeyCaps">am.</span> Volume remained relatively steady throughout the day and increased again for evening rush hour after 5 <span class="KeyCaps">pm</span>. But there was a dip between 3 <span class="KeyCaps">pm</span> and 4 <span class="KeyCaps">pm</span>—why?</p>&#13;
<p>To answer that question, we would need to dig deeper to analyze data that spanned several days or even several months to see whether our data from June 1, 2016, is typical. We could use the <code>date_part()</code> function to compare trip volume on weekdays versus weekends by extracting the day of the week. To be even more ambitious, we could check weather reports and compare trips on rainy days versus sunny days. You can slice a dataset many ways to reach conclusions.</p>&#13;
<h4 id="h3-501065c12-0003">When Do Trips Take the Longest?</h4>&#13;
<p class="BodyFirst">Let’s investigate another interesting question: at which hour did taxi trips take the longest? One way to find an answer is to calculate the median trip time for each hour. The median is the middle value in an ordered set of values; it’s often more accurate than an average for making comparisons because a few very small or very large values in the set won’t skew the results as they would with the average.</p>&#13;
<p>In <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>, we used the <code>percentile_cont()</code> function to find medians. We use it again in <a href="#listing12-10" id="listinganchor12-10">Listing 12-10</a> to calculate median trip times.</p>&#13;
<pre><code>SELECT&#13;
   <span class="CodeAnnotationCode" aria-label="annotation1">1</span> date_part('hour', tpep_pickup_datetime) AS trip_hour,&#13;
   <span class="CodeAnnotationCode" aria-label="annotation2">2</span> percentile_cont(.5)&#13;
      <span class="CodeAnnotationCode" aria-label="annotation3">3</span> WITHIN GROUP (ORDER BY&#13;
              tpep_dropoff_datetime - tpep_pickup_datetime) AS median_trip&#13;
FROM nyc_yellow_taxi_trips&#13;
GROUP BY trip_hour&#13;
ORDER BY trip_hour;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-10">Listing 12-10</a>: Calculating median trip time by hour</p>&#13;
<p>We’re aggregating data by the hour portion of the timestamp column <code>tpep_pickup_datetime</code> again, which we extract using <code>date_part()</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. For the input to the <code>percentile_cont()</code> function <span class="CodeAnnotation" aria-label="annotation2">2</span>, we subtract the pickup time from the drop-off time in the <code>WITHIN GROUP</code> clause <span class="CodeAnnotation" aria-label="annotation3">3</span>. The results show that the 1 <span class="KeyCaps">pm</span> hour has the highest median trip time of 15 minutes:</p>&#13;
<pre><code>date_part    median_trip&#13;
---------    -----------&#13;
        0    00:10:04&#13;
        1    00:09:27&#13;
        2    00:08:59&#13;
        3    00:09:57&#13;
        4    00:10:06&#13;
        5    00:07:37&#13;
        6    00:07:54&#13;
        7    00:10:23&#13;
<span epub:type="pagebreak" title="218" id="Page_218"/>        8    00:12:28&#13;
        9    00:13:11&#13;
       10    00:13:46&#13;
       11    00:14:20&#13;
       12    00:14:49&#13;
       13    00:15:00&#13;
       14    00:14:35&#13;
       15    00:14:43&#13;
       16    00:14:42&#13;
       17    00:14:15&#13;
       18    00:13:19&#13;
       19    00:12:25&#13;
       20    00:11:46&#13;
       21    00:11:54&#13;
       22    00:11:37&#13;
       23    00:11:14</code></pre>&#13;
<p>As we would expect, trip times are shortest in the early morning. This makes sense because less traffic early in the day means passengers are more likely to get to their destinations faster.</p>&#13;
<p>Now that we’ve explored ways to extract portions of the timestamp for analysis, let’s dig deeper into analysis that involves intervals.</p>&#13;
<h3 id="h2-501065c12-0007">Finding Patterns in Amtrak Data</h3>&#13;
<p class="BodyFirst">Amtrak, the nationwide rail service in America, offers several packaged trips across the United States. The All American, for example, is a train that departs from Chicago and stops in New York, New Orleans, Los Angeles, San Francisco, and Denver before returning to Chicago. Using data from the Amtrak website (<a href="https://www.amtrak.com/" class="LinkURL">https://www.amtrak.com/</a>), we’ll build a table with information for each segment of the trip. The trip spans four time zones, so we’ll track the time zone with each arrival and departure. Then we’ll calculate the duration of the journey at each segment and figure out the length of the entire trip.</p>&#13;
<h4 id="h3-501065c12-0004">Calculating the Duration of Train Trips</h4>&#13;
<p class="BodyFirst">Using <a href="#listing12-11" id="listinganchor12-11">Listing 12-11</a>, let’s create a table that tracks the six segments of the All American route.</p>&#13;
<pre><code>CREATE TABLE train_rides (&#13;
    trip_id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,&#13;
    segment text NOT NULL,&#13;
    departure timestamptz NOT NULL, <span class="CodeAnnotationCode" aria-label="annotation1">1</span>&#13;
    arrival timestamptz NOT NULL&#13;
);&#13;
&#13;
INSERT INTO train_rides (segment, departure, arrival) <span class="CodeAnnotationCode" aria-label="annotation2">2</span>&#13;
VALUES&#13;
    ('Chicago to New York', '2020-11-13 21:30 CST', '2020-11-14 18:23 EST'),&#13;
    ('New York to New Orleans', '2020-11-15 14:15 EST', '2020-11-16 19:32 CST'),&#13;
    ('New Orleans to Los Angeles', '2020-11-17 13:45 CST', '2020-11-18 9:00 PST'),&#13;
    ('Los Angeles to San Francisco', '2020-11-19 10:10 PST', '2020-11-19 21:24 PST'),&#13;
<span epub:type="pagebreak" title="219" id="Page_219"/>    ('San Francisco to Denver', '2020-11-20 9:10 PST', '2020-11-21 18:38 MST'),&#13;
    ('Denver to Chicago', '2020-11-22 19:10 MST', '2020-11-23 14:50 CST');&#13;
&#13;
SET TIME ZONE 'US/Central'; <span class="CodeAnnotationCode" aria-label="annotation3">3</span>&#13;
&#13;
SELECT * FROM train_rides;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-11">Listing 12-11</a>: Creating a table to hold train trip data</p>&#13;
<p>First, we use the standard <code>CREATE TABLE</code> statement. Note that columns for departure and arrival times are set to <code>timestamptz</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. Next, we insert rows that represent the six legs of the trip <span class="CodeAnnotation" aria-label="annotation2">2</span>. Each timestamp input reflects the time zone of the city of departure or arrival. Specifying the city’s time zone is the key to getting an accurate calculation of trip duration and accounting for time zone changes. It also accounts for annual changes to and from daylight saving time if they were to occur during the time span you’re examining.</p>&#13;
<p>Next, we set the session to the Central time zone, the value for Chicago, using the <code>US/Central</code> designator <span class="CodeAnnotation" aria-label="annotation3">3</span>. We’ll use Central time as our reference when viewing the timestamps so that regardless of your and my machine’s default time zones, we’ll share the same view of the data.</p>&#13;
<p>The final <code>SELECT</code> statement should return the contents of the table like this:</p>&#13;
<pre><code>trip_id  segment                         departure                 arrival&#13;
-------  ----------------------------    ----------------------    ----------------------&#13;
      1  Chicago to New York             2020-11-13 21:30:00-06    2020-11-14 17:23:00-06&#13;
      2  New York to New Orleans         2020-11-15 13:15:00-06    2020-11-16 19:32:00-06&#13;
      3  New Orleans to Los Angeles      2020-11-17 13:45:00-06    2020-11-18 11:00:00-06&#13;
      4  Los Angeles to San Francisco    2020-11-19 12:10:00-06    2020-11-19 23:24:00-06&#13;
      5  San Francisco to Denver         2020-11-20 11:10:00-06    2020-11-21 19:38:00-06&#13;
      6  Denver to Chicago               2020-11-22 20:10:00-06    2020-11-23 14:50:00-06</code></pre>&#13;
<p>All timestamps should now carry a UTC offset of <code>-06</code>, reflecting the Central time zone in the United States during November, when standard time is in effect. All time values display in their Central time equivalents.</p>&#13;
<p>Now that we’ve created segments corresponding to each leg of the trip, we’ll use <a href="#listing12-12" id="listinganchor12-12">Listing 12-12</a> to calculate the duration of each segment.</p>&#13;
<pre><code>SELECT segment,&#13;
     <span class="CodeAnnotationCode" aria-label="annotation1">1</span> to_char(departure, 'YYYY-MM-DD HH12:MI a.m. TZ') AS departure,&#13;
     <span class="CodeAnnotationCode" aria-label="annotation2">2</span> arrival - departure AS segment_duration&#13;
FROM train_rides;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-12">Listing 12-12</a>: Calculating the length of each trip segment</p>&#13;
<p>This query lists the trip segment, the departure time, and the duration of the segment journey. Before we look at the calculation, notice the additional code around the <code>departure</code> column <span class="CodeAnnotation" aria-label="annotation1">1</span>. These are PostgreSQL-specific formatting functions that specify how to format different components of the timestamp. In this case, the <code>to_char()</code> function turns the <code>departure</code> timestamp column into a string of characters formatted as <code>YYYY-MM-DD HH12:MI a.m. TZ</code>. The <code>YYYY-MM-DD</code> portion specifies the ISO format for the date, and <span epub:type="pagebreak" title="220" id="Page_220"/>the<code> HH12:MI a.m.</code> portion presents the time in hours and minutes. The <code>HH12</code> portion specifies the use of a 12-hour clock rather than 24-hour military time. The <code>a.m.</code> portion specifies that we want to show morning or night times using lowercase characters separated by periods, and the <code>TZ</code> portion denotes the time zone.</p>&#13;
<p>For a complete list of formatting functions, check out the PostgreSQL documentation at <a href="https://www.postgresql.org/docs/current/functions-formatting.html" class="LinkURL">https://www.postgresql.org/docs/current/functions-formatting.html</a>.</p>&#13;
<p>Last, we subtract <code>departure</code> from <code>arrival</code> to determine the <code>segment_duration</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>. When you run the query, the output should look like this:</p>&#13;
<pre><code>segment                         departure                    segment_duration&#13;
----------------------------    -------------------------    ----------------&#13;
Chicago to New York             2020-11-13 09:30 p.m. CST    19:53:00&#13;
New York to New Orleans         2020-11-15 01:15 p.m. CST    1 day 06:17:00&#13;
New Orleans to Los Angeles      2020-11-17 01:45 p.m. CST    21:15:00&#13;
Los Angeles to San Francisco    2020-11-19 12:10 p.m. CST    11:14:00&#13;
San Francisco to Denver         2020-11-20 11:10 a.m. CST    1 day 08:28:00&#13;
Denver to Chicago               2020-11-22 08:10 p.m. CST    18:40:00</code></pre>&#13;
<p>Subtracting one timestamp from another produces an <code>interval</code> data type, which was introduced in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>. As long as the value is less than 24 hours, PostgreSQL presents the interval in the <var>HH:MM:SS</var> format. For values greater than 24 hours, it returns the format <code>1 day 08:28:00</code>, as shown in the San Francisco to Denver segment.</p>&#13;
<p>In each calculation, PostgreSQL accounts for the changes in time zones so we don’t inadvertently add or lose hours when subtracting. If we used a <code>timestamp without time zone</code> data type, we would end up with an incorrect trip length if a segment spanned multiple time zones.</p>&#13;
<h4 id="h3-501065c12-0005">Calculating Cumulative Trip Time</h4>&#13;
<p class="BodyFirst">As it turns out, San Francisco to Denver is the longest leg of the All American train trip. But how long does the entire trip take? To answer this question, we’ll revisit window functions, which you first learned about in “Ranking with rank() and dense_rank()” in <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span>.</p>&#13;
<p>Our prior query produced an interval, which we labeled <code>segment_duration</code>. The next natural next step would be to write a query to add those values, creating a cumulative interval after each segment. And indeed, we can use <code>sum()</code> as a window function, combined with the <code>OVER</code> clause used in <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span>, to create running totals. But when we do, the resulting values are odd. To see what I mean, run the code in <a href="#listing12-13" id="listinganchor12-13">Listing 12-13</a>.</p>&#13;
<pre><code>SELECT segment,&#13;
       arrival - departure AS segment_duration,&#13;
       sum(arrival - departure) OVER (ORDER BY trip_id) AS cume_duration&#13;
FROM train_rides;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-13">Listing 12-13</a>: Calculating cumulative intervals using <code>OVER</code></p>&#13;
<p><span epub:type="pagebreak" title="221" id="Page_221"/>In the third column, we sum the intervals generated when we subtract <code>departure</code> from <code>arrival</code>. The resulting running total in the <code>cume_duration</code> column is accurate but formatted in an unhelpful way:</p>&#13;
<pre><code>segment                         segment_duration   cume_duration&#13;
----------------------------    ----------------  ---------------&#13;
Chicago to New York             19:53:00          19:53:00&#13;
New York to New Orleans         1 day 06:17:00    1 day 26:10:00&#13;
New Orleans to Los Angeles      21:15:00          1 day 47:25:00&#13;
Los Angeles to San Francisco    11:14:00          1 day 58:39:00&#13;
San Francisco to Denver         1 day 08:28:00    2 days 67:07:00&#13;
Denver to Chicago               18:40:00          2 days 85:47:00</code></pre>&#13;
<p>PostgreSQL creates one sum for the day portion of the interval and another for the hours and minutes. So, instead of a more understandable cumulative time of <code>5 days 13:47:00</code>, the database reports <code>2 days 85:47:00</code>. Both results amount to the same length of time, but <code>2 days 85:47:00</code> is harder to decipher. This is an unfortunate limitation of summing the database intervals using this syntax.</p>&#13;
<p>To get around the limitation, we’ll wrap the window function calculation for the cumulative duration inside the <code>justify_interval()</code> function, shown in <a href="#listing12-14" id="listinganchor12-14">Listing 12-14</a>.</p>&#13;
<pre><code>SELECT segment,&#13;
       arrival - departure AS segment_duration,&#13;
     <span class="CodeAnnotationCode" aria-label="annotation1">1</span> justify_interval(sum(arrival - departure)&#13;
                        OVER (ORDER BY trip_id)) AS cume_duration&#13;
FROM train_rides;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-14">Listing 12-14</a>: Using <code>justify_interval()</code> to better format cumulative trip duration</p>&#13;
<p>The <code>justify_interval()</code> function <span class="CodeAnnotation" aria-label="annotation1">1</span> standardizes output of interval calculations so that groups of 24 hours are rolled up to days, and groups of 30 days are rolled up to months. So, instead of returning a cumulative duration of <code>2 days 85:47:00</code>, as in the previous listing, <code>justify_interval()</code> converts 72 of those 85 hours to three days and adds them to the <code>days</code> value. The output is easier to understand:</p>&#13;
<pre><code>          segment            segment_duration  cume_duration&#13;
---------------------------- ---------------- --------------&#13;
Chicago to New York          19:53:00         19:53:00&#13;
New York to New Orleans      1 day 06:17:00   2 days 02:10:00&#13;
New Orleans to Los Angeles   21:15:00         2 days 23:25:00&#13;
Los Angeles to San Francisco 11:14:00         3 days 10:39:00&#13;
San Francisco to Denver      1 day 08:28:00   4 days 19:07:00&#13;
Denver to Chicago            18:40:00         5 days 13:47:00</code></pre>&#13;
<p>The final <code>cume_duration</code> adds all the segments to return the total trip duration of <code>5 days 13:47:00</code>. That’s a long time to spend on a train, but I’m sure the scenery is well worth the ride.</p>&#13;
<h2 id="h1-501065c12-0005"><span epub:type="pagebreak" title="222" id="Page_222"/>Wrapping Up</h2>&#13;
<p class="BodyFirst">Handling times and dates in SQL databases adds an intriguing dimension to your analysis, letting you answer questions about when an event occurred along with other temporal concerns in your data. With a solid grasp of time and date formats, time zones, and functions to dissect the components of a timestamp, you can analyze just about any dataset you come across.</p>&#13;
<p>Next, we’ll look at advanced query techniques that help answer more complex questions.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>Try It Yourself</h2>&#13;
<p class="BoxBodyFirst">Try these exercises to test your skills on dates and times:</p>&#13;
<ol>&#13;
<li value="1">Using the New York City taxi data, calculate the length of each ride using the pickup and drop-off timestamps. Sort the query results from the longest ride to the shortest. Do you notice anything about the longest or shortest trips that you might want to ask city officials about?</li>&#13;
<li value="2">Using the <code>AT TIME ZONE</code> keywords, write a query that displays the date and time for London, Johannesburg, Moscow, and Melbourne the moment January 1, 2100, arrives in New York City. Use the code in <a href="#listing12-5">Listing 12-5</a> to find time zone names.</li>&#13;
<li value="3">As a bonus challenge, use the statistics functions in <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span> to calculate the correlation coefficient and <em>r</em>-squared values using trip time and the <code>total_amount</code> column in the New York City taxi data, which represents the total amount charged to passengers. Do the same with the <code>trip_distance</code> and <code>total_amount</code> columns. Limit the query to rides that last three hours or less.</li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div></body></html>