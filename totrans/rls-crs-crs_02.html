<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Ruby Fundamentals"><div class="titlepage"><div><div><h1 class="title"><a id="ruby_fundamentals"/>Chapter 1. Ruby Fundamentals</h1></div></div></div><p><a class="indexterm" id="iddle1045"/><a class="indexterm" id="iddle1524"/><a class="indexterm" id="iddle1802"/><a class="indexterm" id="iddle1823"/><a class="indexterm" id="iddle1950"/><a class="indexterm" id="iddle2119"/><a class="indexterm" id="iddle2172"/>In 1993, Yukihiro “Matz” Matsumoto combined parts of his favorite
        languages (Perl, Smalltalk, Eiffel, Ada, and Lisp) to create his own ideal language, which
        he called Ruby.</p><p>Ruby is a dynamic, object-oriented programming language that also supports imperative
        and functional programming styles. It focuses on simplicity, productivity, and developer
        happiness. The Ruby website refers to it as “A Programmer’s Best Friend,”
        and developers with experience in other languages usually find Ruby easy to write and
        natural to read.</p><p>A solid foundation in Ruby is essential to understanding Ruby on Rails, so I’ll
        cover Ruby fundamentals in this chapter. As we progress through the language features,
        I’ll demonstrate common idioms used by experienced Ruby developers, so you can use
        them in your own programs later.</p><div class="sect1" title="Interactive Ruby"><div class="titlepage"><div><div><h1 class="title"><a id="interactive_ruby"/>Interactive Ruby</h1></div></div></div><p><a class="indexterm" id="iddle1290"/><a class="indexterm" id="iddle1325"/><a class="indexterm" id="iddle1556"/><a class="indexterm" id="iddle1755"/><a class="indexterm" id="iddle1758"/><a class="indexterm" id="iddle1759"/><a class="indexterm" id="iddle1883"/><a class="indexterm" id="iddle1911"/><a class="indexterm" id="iddle1920"/><a class="indexterm" id="iddle2006"/><a class="indexterm" id="iddle2007"/><a class="indexterm" id="iddle2020"/><a class="indexterm" id="iddle2025"/><a class="indexterm" id="iddle2067"/><a class="indexterm" id="iddle2091"/><a class="indexterm" id="iddle2122"/><a class="indexterm" id="iddle2135"/>My favorite way to explore the Ruby language is through the
            <span class="emphasis"><em>Interactive Ruby interpreter (IRB)</em></span>. Most of the time, I develop
          applications in a text editor, but I still keep an IRB session open to test ideas
          quickly.</p><p>To start IRB, open a terminal (or command prompt on Windows), type <span class="strong"><strong><code class="literal">irb</code></strong></span>, and press <span class="smaller">ENTER</span>. You should see a prompt similar to this:</p><a id="pro_id00008"/><pre class="programlisting">irb(main):001:0&gt;</pre><p>If you see an error message after entering <code class="literal">irb</code>, then you probably
          don’t have it installed. Check out the Introduction, and follow the Ruby
          installation instructions to get IRB set up.</p><p>IRB is a type of program called a <span class="emphasis"><em>read-eval-print loop (REPL)</em></span>.
          IRB reads your input, evaluates it, and displays the result. It repeats this process until
          you press <span class="smaller">CTRL</span>-D or enter <code class="literal">quit</code> or
            <code class="literal">exit</code>.</p><p>Try out IRB by typing a few words surrounded by quotation marks:</p><a id="pro_id00009"/><pre class="programlisting">irb(main):001:0&gt; <span class="strong"><strong>"Hello, Ruby"</strong></span>
 =&gt; "Hello, Ruby"</pre><p>Ruby evaluates the expression you entered and displays the result. A simple string
          evaluates to itself, but this isn’t the same as printing the string. To output
          something on the screen, use the Ruby method <code class="literal">puts</code>, as shown
          here:</p><a id="pro_id00010"/><pre class="programlisting">irb(main):002:0&gt; <span class="strong"><strong>puts "Hello, Ruby"</strong></span>
Hello, Ruby
 =&gt; nil</pre><p>Now Ruby outputs the string to the screen and displays <code class="literal">nil</code>, which
          is the result of evaluating the <code class="literal">puts</code> method. In Ruby, every method
          returns something. The <code class="literal">puts</code> method doesn’t have anything useful
          to return, so it returns <code class="literal">nil</code>.</p><p>As you work through the rest of this chapter, you’ll find more examples that you
          can enter into IRB. I encourage you to try them out and explore what you can do with IRB
          and Ruby.</p><div class="note" title="Note"><h3 class="title"><a id="ch01note01"/>Note</h3><p><span class="emphasis"><em>If IRB stops evaluating what you’re typing, you may have
              “confused” it by forgetting a closing quotation mark or some other syntax
              it was expecting. If this happens, press</em></span>
            <span class="smaller"><span class="emphasis"><em>CTRL-C</em></span></span>
            <span class="emphasis"><em>to cancel the current operation and return to a working
            prompt.</em></span></p></div><p>Now, let’s take a look at the data types available in Ruby.</p></div><div class="sect1" title="Data Types"><div class="titlepage"><div><div><h1 class="title"><a id="data_types"/>Data Types</h1></div></div></div><p><a class="indexterm" id="iddle1023"/><a class="indexterm" id="iddle1450"/><a class="indexterm" id="iddle1454"/><a class="indexterm" id="iddle1505"/><a class="indexterm" id="iddle1578"/><a class="indexterm" id="iddle1753"/><a class="indexterm" id="iddle1822"/><a class="indexterm" id="iddle1859"/><a class="indexterm" id="iddle1896"/><a class="indexterm" id="iddle1905"/><a class="indexterm" id="iddle2081"/>Ruby has six main data types: number, string, symbol, array, hash, and
          Boolean. In this section, I’ll briefly discuss each of these data types and how to
          use them.</p><div class="sect2" title="Numbers"><div class="titlepage"><div><div><h2 class="title"><a id="numbers"/>Numbers</h2></div></div></div><p>Ruby supports the math operations you learned in school, plus a few you may not have
            seen before. Type an expression into IRB and press <span class="smaller">ENTER</span> to see the result:</p><a id="pro_id00011"/><pre class="programlisting">irb(main):003:0&gt; <span class="strong"><strong>1 + 1</strong></span>
 =&gt; 2</pre><p>We asked Ruby to evaluate the expression 1 + 1, and it responded with the result,
            which is 2. Try out a few more math operations. Everything should work as expected, at
            least until you try division, as shown here:</p><a id="pro_id00012"/><pre class="programlisting">irb(main):004:0&gt; <span class="strong"><strong>7 / 3</strong></span>
 =&gt; 2</pre><p>Ruby performs <span class="emphasis"><em>integer division</em></span> by default. In other words, it
            drops the remainder. You can find that remainder with the modulus operator
              (<code class="literal">%</code>). If you’d rather get a fractional answer, however, you
            need to tell Ruby explicitly to use floating-point math by including a decimal point and
            zero after at least one of the numbers. Here, you can see examples of both the modulus
            operator and floating-point division in IRB:</p><a id="pro_id00013"/><pre class="programlisting">irb(main):005:0&gt; <span class="strong"><strong>7 % 3</strong></span>
 =&gt; 1
irb(main):006:0&gt; <span class="strong"><strong>7.0 / 3</strong></span>
 =&gt; 2.3333333333333335</pre><p>This concept is important to understand: although these appear to be simple math
            operators, they are actually methods in Ruby. You can even call methods on data types
            that other languages consider primitives.</p><a id="pro_id00014"/><pre class="programlisting">irb(main):007:0&gt; <span class="strong"><strong>1.odd?</strong></span>
 =&gt; true</pre><p>Here, we ask the number 1 if it is odd and IRB responds with
            <code class="literal">true</code>.</p></div><div class="sect2" title="Strings"><div class="titlepage"><div><div><h2 class="title"><a id="strings"/>Strings</h2></div></div></div><p><a class="indexterm" id="iddle1006"/><a class="indexterm" id="iddle1011"/><a class="indexterm" id="iddle1218"/><a class="indexterm" id="iddle1337"/><a class="indexterm" id="iddle1455"/><a class="indexterm" id="iddle1514"/><a class="indexterm" id="iddle1537"/><a class="indexterm" id="iddle1794"/><a class="indexterm" id="iddle1876"/><a class="indexterm" id="iddle2026"/><a class="indexterm" id="iddle2181"/><a class="indexterm" id="iddle2182"/><a class="indexterm" id="iddle2198"/><a class="indexterm" id="iddle2209"/>You can create strings by surrounding characters with single or double
            quotes, as in this example:</p><a id="pro_id00015"/><pre class="programlisting">irb(main):008:0&gt; <span class="strong"><strong>'A String!'</strong></span>
 =&gt; "A String!"</pre><p>You can also combine strings in Ruby to create larger ones. The language understands
            both adding strings and multiplying a string by a number. Let’s look at an example
            of each:</p><a id="pro_id00016"/><pre class="programlisting">irb(main):009:0&gt; <span class="strong"><strong>"Hello" + "World"</strong></span>
 =&gt; "HelloWorld"
irb(main):010:0&gt; <span class="strong"><strong>"Hi" * 3</strong></span>
 =&gt; "HiHiHi"</pre><p>Notice that Ruby doesn’t automatically put spaces between words when adding or
            multiplying. You are responsible for that detail.</p><p>Until now, I haven’t differentiated between single- and double-quoted strings,
            but double-quoted strings actually allow you to combine strings in more complex ways.
            For example, they support a feature called <span class="emphasis"><em>string interpolation</em></span>, in
            which Ruby evaluates an expression surrounded by <code class="literal">#{</code> and
              <code class="literal">}</code>, converts the result to a string, and inserts it into the string
            automatically, as shown here:</p><a id="pro_id00017"/><pre class="programlisting">irb(main):011:0&gt; <span class="strong"><strong>x = 10</strong></span>
 =&gt; 10
irb(main):012:0&gt; <span class="strong"><strong>"x is #{x}"</strong></span>
 =&gt; "x is 10"</pre><p>In this case, <code class="literal">#{x}</code> evaluates to 10, so Ruby converts the number
            10 to a string and returns <code class="literal">"x is 10"</code>.</p><p>Double-quoted strings also support special characters such as newlines and tabs.
            These special characters consist of a backslash followed by a letter. Type <span class="strong"><strong><code class="literal">\n</code></strong></span> to create a newline (shown next) or
              <span class="strong"><strong><code class="literal">\t</code></strong></span> to create a tab. To add a
            literal backslash in a double-quoted string, type two backslashes.</p><a id="pro_id00018"/><pre class="programlisting">irb(main):013:0&gt; <span class="strong"><strong>puts "Line one\nLine two"</strong></span>
Line one
Line two
 =&gt; nil</pre><p>You’ve already seen a few string methods, but many others are handy, including
              <code class="literal">length</code> and <code class="literal">empty?</code>. (Yes, methods in Ruby can end
            with question marks and even exclamation marks.) Let’s look at those two methods
            in action:</p><a id="pro_id00019"/><pre class="programlisting">irb(main):014:0&gt; <span class="strong"><strong>"Hello".length</strong></span>
 =&gt; 5
irb(main):015:0&gt; <span class="strong"><strong>"Hello".empty?</strong></span>
 =&gt; false</pre><p><a class="indexterm" id="iddle1007"/><a class="indexterm" id="iddle1013"/><a class="indexterm" id="iddle1028"/><a class="indexterm" id="iddle1029"/><a class="indexterm" id="iddle1164"/><a class="indexterm" id="iddle1335"/><a class="indexterm" id="iddle1451"/><a class="indexterm" id="iddle1456"/><a class="indexterm" id="iddle1554"/><a class="indexterm" id="iddle1707"/><a class="indexterm" id="iddle1902"/><a class="indexterm" id="iddle2024"/><a class="indexterm" id="iddle2188"/><a class="indexterm" id="iddle2208"/>The <code class="literal">length</code> method returns the number of characters in a
            string, whereas <code class="literal">empty?</code> tells you whether a string contains any
            characters.</p><div class="note" title="Note"><h3 class="title"><a id="ch01note02"/>Note</h3><p><span class="emphasis"><em>A question mark at the end of method name, as in
                  <code class="literal">empty?</code>, indicates that it is a predicate, and it will return a
                true or false value. An exclamation mark (<code class="literal">!</code>) usually signifies
                that the method does something dangerous such as modifying the object in
                place.</em></span></p></div></div><div class="sect2" title="Symbols"><div class="titlepage"><div><div><h2 class="title"><a id="symbols"/>Symbols</h2></div></div></div><p>Ruby has a data type not often seen in other programming languages, and that’s
            the symbol. Symbols are similar to strings in that they are made of characters, but
            instead of being surrounded by quotes, symbols are prefixed with a colon, like
            this:</p><a id="pro_id00020"/><pre class="programlisting">irb(main):016:0&gt; <span class="strong"><strong>:name</strong></span>
 =&gt; :name</pre><p>Symbols are typically used as identifiers. They are created only once and are
            unique. This means they are easy for programmers to read as a string, but also memory
            efficient. You can see this for yourself by creating a few strings and symbols and then
            calling the <code class="literal">object_id</code> method on them.</p><a id="pro_id00021"/><pre class="programlisting">irb(main):017:0&gt; <span class="strong"><strong>"name".object_id</strong></span>
 =&gt; 70156617860420
irb(main):018:0&gt; <span class="strong"><strong>"name".object_id</strong></span>
 =&gt; 70156617844900
irb(main):019:0&gt; <span class="strong"><strong>:name.object_id</strong></span>
 =&gt; 67368
irb(main):020:0&gt; <span class="strong"><strong>:name.object_id</strong></span>
 =&gt; 67368</pre><p>Notice that the two strings here have the same content, but different object ids.
            These are two different objects. The two symbols have the same content and the same
            object id.</p><p>When Ruby compares two strings for equality, it checks each individual character.
            Comparing two symbols for equality requires only a numeric comparison, which is much
            more efficient.</p></div><div class="sect2" title="Arrays"><div class="titlepage"><div><div><h2 class="title"><a id="arrays"/>Arrays</h2></div></div></div><p>An array represents a list of objects in Ruby. You create an array by surrounding a
            list of objects with square brackets. For example, let’s make an array of
            numbers:</p><a id="pro_id00022"/><pre class="programlisting">irb(main):021:0&gt; <span class="strong"><strong>list = [1, 2, 3]</strong></span>
=&gt; [1, 2, 3]</pre><p><a class="indexterm" id="iddle1009"/><a class="indexterm" id="iddle1014"/><a class="indexterm" id="iddle1018"/><a class="indexterm" id="iddle1027"/><a class="indexterm" id="iddle1421"/><a class="indexterm" id="iddle1453"/><a class="indexterm" id="iddle1526"/><a class="indexterm" id="iddle1662"/><a class="indexterm" id="iddle1665"/><a class="indexterm" id="iddle1724"/><a class="indexterm" id="iddle1788"/><a class="indexterm" id="iddle1884"/><a class="indexterm" id="iddle1885"/><a class="indexterm" id="iddle2171"/><a class="indexterm" id="iddle2350"/>Ruby arrays can contain any kind of object, even other arrays. You can
            access individual elements of an array by passing a numeric index to the array’s
              <code class="literal">[]</code> method. The first element is at index zero. Try examining the
            first element in the array just created:</p><a id="pro_id00023"/><pre class="programlisting">irb(main):022:0&gt; <span class="strong"><strong>list[0]</strong></span>
 =&gt; 1</pre><p>Entering <code class="literal">list[0]</code> tells Ruby to fetch the first number in the
            array, and the method returns <code class="literal">1</code>.</p><div class="note" title="Note"><h3 class="title"><a id="ch01note03"/>Note</h3><p><span class="emphasis"><em>If you try to access an element that isn’t in the array, the
                  <code class="literal">[]</code> method will return <code class="literal">nil</code>.</em></span></p></div><p>You can also pass two numbers to the <code class="literal">[]</code> method to create an array
              <span class="emphasis"><em>slice</em></span>, as shown next. The first number you provide specifies the
            starting index, whereas the second tells it how many elements you want in your array
            slice:</p><a id="pro_id00024"/><pre class="programlisting">irb(main):023:0&gt; <span class="strong"><strong>list[0, 2]</strong></span>
 =&gt; [1, 2]</pre><p>Here, the <code class="literal">[]</code> method starts at index zero and returns the first
            two numbers in <code class="literal">list</code>.</p><p>Like strings, you can also add arrays to create a new one using the
              <code class="literal">+</code> operator. If you just want to add elements to the end of an
            existing array, you can use the <code class="literal">&lt;&lt;</code> operator. You can see an
            example of each operation here:</p><a id="pro_id00025"/><pre class="programlisting">irb(main):024:0&gt; <span class="strong"><strong>list + [4, 5, 6]</strong></span>
 =&gt; [1, 2, 3, 4, 5, 6]
irb(main):025:0&gt; <span class="strong"><strong>list &lt;&lt; 4</strong></span>
 =&gt; [1, 2, 3, 4]</pre><p>Though the <code class="literal">+</code> operator returns a new array, it doesn’t
            modify the existing array. The <code class="literal">&lt;&lt;</code> operator does modify the
            existing array. You can also use an index to reassign an existing element or add a new
            element to the array.</p></div><div class="sect2" title="Hashes"><div class="titlepage"><div><div><h2 class="title"><a id="hashes"/>Hashes</h2></div></div></div><p>A hash is a set of key-value pairs. In Ruby, hashes are enclosed in curly braces.
            Unlike an array index, a hash key can be of any data type. For example, symbols are
            frequently used as hash keys. When you need to access a value in a hash, just pass the
            corresponding key to the <code class="literal">[]</code> method, as shown next. Attempting to
            access a key that does not exist returns <code class="literal">nil</code>.</p><a id="pro_id00026"/><pre class="programlisting">irb(main):026:0&gt; <span class="strong"><strong>some_guy = { :name =&gt; "Tony", :age =&gt; 21 }</strong></span>
 =&gt; {:name=&gt;"Tony", :age=&gt;21}
irb(main):027:0&gt; <span class="strong"><strong>some_guy[:name]</strong></span>
 =&gt; "Tony"</pre><p>The combination of an equal sign and a greater-than sign (<code class="literal">=&gt;</code>)
            between the key and value is commonly referred to as a <span class="emphasis"><em>hash rocket</em></span>.
            Because symbols <a class="indexterm" id="iddle1004"/><a class="indexterm" id="iddle1012"/><a class="indexterm" id="iddle1015"/><a class="indexterm" id="iddle1016"/><a class="indexterm" id="iddle1024"/><a class="indexterm" id="iddle1025"/><a class="indexterm" id="iddle1055"/><a class="indexterm" id="iddle1165"/><a class="indexterm" id="iddle1255"/><a class="indexterm" id="iddle1452"/><a class="indexterm" id="iddle1542"/><a class="indexterm" id="iddle1658"/><a class="indexterm" id="iddle1787"/><a class="indexterm" id="iddle1796"/><a class="indexterm" id="iddle1830"/><a class="indexterm" id="iddle1837"/><a class="indexterm" id="iddle1863"/><a class="indexterm" id="iddle1890"/><a class="indexterm" id="iddle1916"/><a class="indexterm" id="iddle1928"/><a class="indexterm" id="iddle2307"/>are used as hash keys so often, Ruby 1.9 added a shorthand syntax
            specifically for them. You can take the colon from the front of the symbol, put it at
            the end, and then leave out the hash rocket. Here’s an example:</p><a id="pro_id00027"/><pre class="programlisting">irb(main):028:0&gt; <span class="strong"><strong>another_guy = { name: "Ben", age: 20 }</strong></span>
 =&gt; {:name=&gt;"Ben", :age=&gt;20}</pre><p>Although you can create a hash with this shorthand, Ruby seems to be sentimental as
            it still uses the old syntax when displaying the hash.</p><p>You can also use the <code class="literal">keys</code> method to get an array of all keys in a
            hash. If you need an array of all the values in the hash, use the method
              <code class="literal">values</code> instead. The code here shows an example of each method,
            using the same hash just created:</p><a id="pro_id00028"/><pre class="programlisting">irb(main):029:0&gt; <span class="strong"><strong>another_guy.keys</strong></span>
 =&gt; [:name, :age]
irb(main):030:0&gt; <span class="strong"><strong>another_guy.values</strong></span>
 =&gt; ["Ben", 20]</pre><p>Hashes are frequently used to represent data structures, as in these examples. They
            are also sometimes used to pass named parameters to a method. If a hash is the last (or
            only) argument to a method call, you can even leave off the curly braces.</p><p>For example, the <code class="literal">merge</code> method combines two hashes. The code here
            merges the hash named <code class="literal">another_guy</code> with a new hash containing
              <code class="literal">{ job: "none" }</code>.</p><a id="pro_id00029"/><pre class="programlisting">irb(main):031:0&gt; <span class="strong"><strong>another_guy.merge job: "none"</strong></span>
 =&gt; {:name=&gt;"Ben", :age=&gt;20, :job=&gt;"none"}</pre><p>Because the only argument to this method call is the new hash, you can leave off the
            curly braces. Rails has many other examples of this type of method call.</p></div><div class="sect2" title="Booleans"><div class="titlepage"><div><div><h2 class="title"><a id="booleans"/>Booleans</h2></div></div></div><p>A Boolean expression is anything that evaluates to true or false. These expressions
            often involve a Boolean operator, and Ruby supports familiar operators including
              <span class="emphasis"><em>less than</em></span> (<code class="literal">&lt;</code>), <span class="emphasis"><em>greater
              than</em></span> (<code class="literal">&gt;</code>), <span class="emphasis"><em>equal</em></span>
              (<code class="literal">==</code>), and <span class="emphasis"><em>not equal</em></span> (<code class="literal">!=</code>).
            Try these Boolean expressions at the IRB prompt:</p><a id="pro_id00030"/><pre class="programlisting">irb(main):032:0&gt; <span class="strong"><strong>1 &lt; 2</strong></span>
 =&gt; true
irb(main):033:0&gt; <span class="strong"><strong>5 == 6</strong></span>
 =&gt; false</pre><p>Ruby also provides <span class="emphasis"><em>and</em></span> (<code class="literal">&amp;&amp;</code>) and
              <span class="emphasis"><em>or</em></span> (<code class="literal">||</code>) operators for combining multiple
            Boolean expressions, as shown next:</p><a id="pro_id00031"/><pre class="programlisting">irb(main):034:0&gt; <span class="strong"><strong>1 &lt; 2 || 1 &gt; 2</strong></span>
 =&gt; true
irb(main):035:0&gt; <span class="strong"><strong>5 != 6 &amp;&amp; 5 == 5</strong></span>
 =&gt; true</pre><p><a class="indexterm" id="iddle1026"/><a class="indexterm" id="iddle1305"/><a class="indexterm" id="iddle1354"/><a class="indexterm" id="iddle1372"/><a class="indexterm" id="iddle2156"/><a class="indexterm" id="iddle2310"/><a class="indexterm" id="iddle2312"/>Both of these operators <span class="emphasis"><em>short circuit</em></span>. That is,
              <code class="literal">&amp;&amp;</code> is only true if the expressions on both sides evaluate
            to true. If the first expression is false, then the second expression is not evaluated.
            Likewise, <code class="literal">||</code> is true if either expression is true. If the first
            expression is true, then the second expression is not evaluated.</p><p>The <code class="literal">||</code> operator is also sometimes used with assignment. You might
            do this when you want to initialize a variable only if it is currently
              <code class="literal">nil</code> and keep the current value otherwise. Ruby provides the
              <code class="literal">||=</code> operator for this case. This is referred to as
              <span class="emphasis"><em>conditional assignment</em></span>, and you can see an example here:</p><a id="pro_id00032"/><pre class="programlisting">irb(main):036:0&gt; <span class="strong"><strong>x = nil</strong></span>
 =&gt; nil
irb(main):037:0&gt; <span class="strong"><strong>x ||= 6</strong></span>
 =&gt; 6</pre><p>If the variable <code class="literal">x</code> had not been a false value, then the
            conditional assignment would have returned the value of <code class="literal">x</code> instead of
            setting it to 6.</p><div class="note" title="Note"><h3 class="title"><a id="ch01note04"/>Note</h3><p><span class="emphasis"><em>Any expression in Ruby can be evaluated as a Boolean expression. In
                Ruby, only <code class="literal">nil</code> and <code class="literal">false</code> are considered false.
                Every other value is considered true. This differs from some other languages, where
                things like empty strings, empty collections, and the number zero are considered
                false.</em></span></p></div></div></div><div class="sect1" title="Constants"><div class="titlepage"><div><div><h1 class="title"><a id="constants"/>Constants</h1></div></div></div><p>A <span class="emphasis"><em>constant</em></span> gives a name to a value that doesn’t change. In
          Ruby, the name of a constant <span class="emphasis"><em>must</em></span> begin with a capital letter.
          Constants are typically written in uppercase, like this one:</p><a id="pro_id00033"/><pre class="programlisting">irb(main):038:0&gt; <span class="strong"><strong>PI = 3.14</strong></span>
=&gt; 3.14
irb(main):039:0&gt; <span class="strong"><strong>2 * PI</strong></span>
=&gt; 6.28</pre><p>Ruby won’t actually stop you from assigning a new value to a constant, but it
          does display a warning if you do.</p></div><div class="sect1" title="Variables"><div class="titlepage"><div><div><h1 class="title"><a id="variables"/>Variables</h1></div></div></div><p>In Ruby, you don’t need to declare a variable in advance or specify a type. Just
          assign a value to a name as shown here:</p><a id="pro_id00034"/><pre class="programlisting">irb(main):040:0&gt; <span class="strong"><strong>x = 10</strong></span>
 =&gt; 10</pre><p><a class="indexterm" id="iddle1262"/><a class="indexterm" id="iddle1306"/><a class="indexterm" id="iddle1355"/><a class="indexterm" id="iddle1374"/><a class="indexterm" id="iddle1528"/><a class="indexterm" id="iddle1529"/><a class="indexterm" id="iddle1710"/><a class="indexterm" id="iddle2173"/>The variable <code class="literal">x</code> now refers to the number 10. Variable names
          are typically written in <span class="emphasis"><em>snake case</em></span>, that is, all lowercase with
          underscores between words.</p><a id="pro_id00035"/><pre class="programlisting">irb(main):041:0&gt; <span class="strong"><strong>first_name = "Matthew"</strong></span>
 =&gt; "Matthew"</pre><p>Variable names can include letters, numbers, and underscores, but they must start with
          either a letter or underscore.</p></div><div class="sect1" title="Control Flow"><div class="titlepage"><div><div><h1 class="title"><a id="control_flow"/>Control Flow</h1></div></div></div><p>The examples we’ve looked at so far have all been linear. Real programs usually
          include statements that only execute when a certain condition is met and statements that
          are repeated multiple times. In this section, I cover Ruby’s conditional statements
          and iteration.</p><div class="sect2" title="Conditionals"><div class="titlepage"><div><div><h2 class="title"><a id="conditionals"/>Conditionals</h2></div></div></div><p><span class="emphasis"><em>Conditional statements</em></span> let your program choose between one or
            more branches of code to execute based on an expression you provide. As such, making a
            decision in code is also called <span class="emphasis"><em>branching</em></span>. For example, the
            following conditional prints the word <span class="emphasis"><em>Child</em></span> only if the expression
              <code class="literal">age &lt; 13</code> evaluates to true.</p><a id="pro_id00036"/><pre class="programlisting">irb(main):042:0&gt; <span class="strong"><strong>age = 21</strong></span>
 =&gt; 21
irb(main):043:0&gt; <span class="strong"><strong>if age &lt; 13</strong></span>
irb(main):044:1&gt;   <span class="strong"><strong>puts "Child"</strong></span>
irb(main):045:1&gt; <span class="strong"><strong>end</strong></span>
 =&gt; nil</pre><p>The variable <code class="literal">age</code> is set to 21, so <code class="literal">age &lt; 13</code>
            will evaluate to <code class="literal">false</code>, and nothing will be printed.</p><p>You can also use <code class="literal">elsif</code> and <code class="literal">else</code> to make more
            complicated conditionals. Let’s look at a code example that has to check multiple
            conditions:</p><a id="pro_id00037"/><pre class="programlisting">irb(main):046:0&gt; <span class="strong"><strong>if age &lt; 13</strong></span>
irb(main):047:1&gt;   <span class="strong"><strong>puts "Child"</strong></span>
irb(main):048:1&gt; <span class="strong"><strong>elsif age &lt; 18</strong></span>
irb(main):049:1&gt;   <span class="strong"><strong>puts "Teen"</strong></span>
irb(main):050:1&gt; <span class="strong"><strong>else</strong></span>
irb(main):051:1&gt;   <span class="strong"><strong>puts "Adult"</strong></span>
irb(main):052:1&gt; <span class="strong"><strong>end</strong></span>
Adult
 =&gt; nil</pre><p>This code can take three different branches depending on the value of
              <code class="literal">age</code>. In our case, it should skip the code inside the
              <code class="literal">if</code> and <code class="literal">elsif</code> statements and just print
              <span class="emphasis"><em>Adult</em></span>.</p><p><a class="indexterm" id="iddle1518"/><a class="indexterm" id="iddle1586"/><a class="indexterm" id="iddle1763"/><a class="indexterm" id="iddle1893"/><a class="indexterm" id="iddle2277"/>All of the previous conditional examples checked for true expressions, but
            what if you want to execute a block of code when an expression is false instead? Like
            other languages, Ruby has a logical <span class="emphasis"><em>not</em></span> operator (either
              <code class="literal">not</code> or <code class="literal">!</code>), which is useful here. The following
            example will print the value of <code class="literal">name</code> if it is not an empty
            string.</p><a id="pro_id00038"/><pre class="programlisting">irb(main):053:0&gt; <span class="strong"><strong>name = "Tony"</strong></span>
 =&gt; "Tony"
irb(main):054:0&gt; <span class="strong"><strong>if !name.empty?</strong></span>
irb(main):055:1&gt;   <span class="strong"><strong>puts name</strong></span>
irb(main):056:1&gt; <span class="strong"><strong>end</strong></span>
 =&gt; nil</pre><p>When <code class="literal">name.empty?</code> is false, the <code class="literal">!</code> operator
            should reverse the result to true so the code inside the <code class="literal">if</code> statement
            executes. A more natural way to say this conditional might be “unless
              <code class="literal">name</code> is empty, print its value.” Unlike an
              <code class="literal">if</code> statement, Ruby’s <code class="literal">unless</code> statement
            executes code when the expression evaluates to false.</p><a id="pro_id00039"/><pre class="programlisting">irb(main):057:0&gt; <span class="strong"><strong>name = "Tony"</strong></span>
 =&gt; ""
irb(main):058:0&gt; <span class="strong"><strong>unless name.empty?</strong></span>
irb(main):059:1&gt;   <span class="strong"><strong>puts name</strong></span>
irb(main):060:1&gt; <span class="strong"><strong>end</strong></span>
 =&gt; nil</pre><p>That still seems a little wordy to me. For one-line expressions such as this, Ruby
            lets you put the conditional at the end of the line:</p><a id="pro_id00040"/><pre class="programlisting">irb(main):061:0&gt; <span class="strong"><strong>name = "Tony"</strong></span>
 =&gt; ""
irb(main):062:0&gt; <span class="strong"><strong>puts name unless name.empty?</strong></span>
 =&gt; nil</pre><p>This example is concise and readable. To me, this code says “print
              <code class="literal">name</code> unless it’s empty.” This code is also a great
            example of Ruby’s flexibility. You can write conditional expressions using the
            style that makes the most sense to you.</p></div><div class="sect2" title="Iteration"><div class="titlepage"><div><div><h2 class="title"><a id="iteration"/>Iteration</h2></div></div></div><p>When you’re working with a collection of objects, such as an array or hash,
            you’ll frequently want to perform operations on each item. In addition to the
              <code class="literal">for</code> loops seen in other languages, Ruby collections provide the
              <code class="literal">each</code> method.</p><p><a class="indexterm" id="iddle1008"/><a class="indexterm" id="iddle1031"/><a class="indexterm" id="iddle1252"/><a class="indexterm" id="iddle1328"/><a class="indexterm" id="iddle1420"/><a class="indexterm" id="iddle1512"/><a class="indexterm" id="iddle1538"/><a class="indexterm" id="iddle1565"/><a class="indexterm" id="iddle1664"/><a class="indexterm" id="iddle1955"/><a class="indexterm" id="iddle2318"/>The <code class="literal">each</code> method accepts a block of code and executes it
            for every element in the collection. A block in Ruby usually starts with the word
              <code class="literal">do</code> and ends with the word <code class="literal">end</code>. A block can also
            accept one or more parameters, which are listed inside a pair of pipe characters. The
              <code class="literal">each</code> method returns the value of the entire collection.</p><p>This next example iterates over each element in the array <code class="literal">list</code>,
            which we created earlier in this chapter as [1, 2, 3, 4]. It assigns the element to the
            variable <code class="literal">number</code> and then prints the value of
              <code class="literal">number</code>.</p><a id="pro_id00041"/><pre class="programlisting">irb(main):063:0&gt; <span class="strong"><strong>list.each do |number|</strong></span>
irb(main):064:1&gt;   <span class="strong"><strong>puts number</strong></span>
irb(main):065:1&gt; <span class="strong"><strong>end</strong></span>
1
2
3
4
 =&gt; [1, 2, 3, 4]</pre><p>Simple blocks like this are often written on one line in Ruby. Instead of writing
              <code class="literal">do</code> and <code class="literal">end</code> to indicate a block, you can use
            opening and closing curly braces, which are common in one-line blocks. Like the previous
            example, this one iterates over the list and prints each element, but it does everything
            in a single line of code.</p><a id="pro_id00042"/><pre class="programlisting">irb(main):066:0&gt; <span class="strong"><strong>list.each { |n| puts n }</strong></span>
1
2
3
4
 =&gt; [1, 2, 3, 4]</pre><p>You can also use the <code class="literal">each</code> method to iterate over a hash. Because
            a hash is a collection of key-value pairs, the block will take two parameters.
            Let’s try using <code class="literal">each</code> with one of our earlier hashes:</p><a id="pro_id00043"/><pre class="programlisting">irb(main):067:0&gt; <span class="strong"><strong>some_guy.each do |key, value|</strong></span>
irb(main):068:1&gt;   <span class="strong"><strong>puts "The #{key} is #{value}."</strong></span>
irb(main):069:1&gt; <span class="strong"><strong>end</strong></span>
The name is Tony.
The age is 21.
 =&gt; {:name=&gt;"Tony", :age=&gt;21}</pre><p>Blocks are useful for more than just iteration. Any method can potentially accept a
            block and use the code it contains. For example, you can pass a block to the
              <code class="literal">File.open</code> method. Ruby should pass the file handle as a variable to
            the block, execute the code within the block, and then close the file
            automatically.</p></div></div><div class="sect1" title="Methods"><div class="titlepage"><div><div><h1 class="title"><a id="methods"/>Methods</h1></div></div></div><p><a class="indexterm" id="iddle1472"/><a class="indexterm" id="iddle1539"/><a class="indexterm" id="iddle1834"/><a class="indexterm" id="iddle1886"/><a class="indexterm" id="iddle1927"/><a class="indexterm" id="iddle2110"/>A <span class="emphasis"><em>method</em></span> is a named block of reusable code. Defining your
          own methods in Ruby is simple. A method definition starts with the word
            <code class="literal">def</code>, followed by a name, and continues until <code class="literal">end</code>.
          This method will print “Hello, World!” each time it is called:</p><a id="pro_id00044"/><pre class="programlisting">irb(main):070:0&gt; <span class="strong"><strong>def hello</strong></span>
irb(main):071:1&gt;   <span class="strong"><strong>puts "Hello, World!"</strong></span>
irb(main):072:1&gt; <span class="strong"><strong>end</strong></span>
 =&gt; nil</pre><p>As you can see in the example, a method definition should return
            <code class="literal">nil</code>.</p><div class="note" title="Note"><h3 class="title"><a id="ch01note05"/>Note</h3><p><span class="emphasis"><em>If you’re using Ruby 2.1, method definitions return the name of the
              method as a symbol.</em></span></p></div><p>Once you’ve defined a method, you can call it by entering its name at the IRB
          prompt:</p><a id="pro_id00045"/><pre class="programlisting">irb(main):073:0&gt; <span class="strong"><strong>hello</strong></span>
Hello, World!
 =&gt; nil</pre><p>Ruby methods always return the value of their last statement; in this case, the last
          statement was <code class="literal">puts</code>, which returns <code class="literal">nil</code>. You can use
            <code class="literal">return</code> to return a value explicitly, or you can just add the value
          you wish to return as the last line of the method.</p><p>For example, if you want the <code class="literal">hello</code> method to return
            <code class="literal">true</code>, you can modify it like this:</p><a id="pro_id00046"/><pre class="programlisting">irb(main):074:0&gt; <span class="strong"><strong>def hello</strong></span>
irb(main):075:1&gt;   <span class="strong"><strong>puts "Hello, World!"</strong></span>
irb(main):076:1&gt;   <span class="strong"><strong>true</strong></span>
irb(main):077:1&gt; <span class="strong"><strong>end</strong></span>
 =&gt; nil</pre><p>Now call the method as before:</p><a id="pro_id00047"/><pre class="programlisting">irb(main):078:0&gt; <span class="strong"><strong>hello</strong></span>
Hello, World!
 =&gt; true</pre><p>Because the last line of the method is the value <code class="literal">true</code>, the method
          returns <code class="literal">true</code> when called.</p><p>In Ruby, you specify method parameters by adding them after the method name,
          optionally enclosed in parentheses, as shown in the next example. Parameters can also have
          default values.</p><a id="pro_id00048"/><pre class="programlisting">irb(main):079:0&gt; <span class="strong"><strong>def hello(name = "World")</strong></span>
irb(main):080:1&gt;   <span class="strong"><strong>puts "Hello, #{name}!"</strong></span>
irb(main):081:1&gt; <span class="strong"><strong>end</strong></span>
 =&gt; nil</pre><p><a class="indexterm" id="iddle1005"/><a class="indexterm" id="iddle1315"/><a class="indexterm" id="iddle1324"/><a class="indexterm" id="iddle1659"/><a class="indexterm" id="iddle1731"/><a class="indexterm" id="iddle1751"/><a class="indexterm" id="iddle1904"/>This example redefines the <code class="literal">hello</code> method to accept a
          parameter called <code class="literal">name</code>. This parameter has a default value of
            <code class="literal">"World"</code>. This method can be called as before to display “Hello,
          World!”, or you can pass a value for the <code class="literal">name</code> parameter to greet
          someone else.</p><a id="pro_id00049"/><pre class="programlisting">irb(main):082:0&gt; <span class="strong"><strong>hello</strong></span>
Hello, World!
 =&gt; nil
irb(main):083:0&gt; <span class="strong"><strong>hello "Tony"</strong></span>
Hello, Tony!
 =&gt; nil</pre><p>The parentheses around method arguments are also optional. Include them if the
          intention is not clear; otherwise, feel free to omit them.</p></div><div class="sect1" title="Classes"><div class="titlepage"><div><div><h1 class="title"><a id="classes"/>Classes</h1></div></div></div><p>In an object-oriented programming language such as Ruby, a <span class="emphasis"><em>class</em></span>
          represents the state and behavior of a distinct type of object. In Ruby, an object’s
          state is stored in instance variables, and methods define its behavior. A Ruby class
          definition starts with the word <code class="literal">class</code>, followed by a capitalized name,
          and continues to the matching <code class="literal">end</code>.</p><p>Class definitions can include a special method called <code class="literal">initialize</code>.
          This method is called when a new instance of the class is created. It is typically used to
          assign values to the instance variables needed by the class. In Ruby, instance variables
          start with an <code class="literal">@</code>, as shown in the following class definition:</p><a id="pro_id00050"/><pre class="programlisting">irb(main):084:0&gt; <span class="strong"><strong>class Person</strong></span>
irb(main):085:1&gt;   <span class="strong"><strong>def initialize(name)</strong></span>
irb(main):086:2&gt;     <span class="strong"><strong>@name = name</strong></span>
irb(main):087:2&gt;   <span class="strong"><strong>end</strong></span>
irb(main):088:1&gt;   <span class="strong"><strong>def greet</strong></span>
irb(main):089:2&gt;     <span class="strong"><strong>puts "Hi, I'm #{@name}."</strong></span>
irb(main):090:2&gt;   <span class="strong"><strong>end</strong></span>
irb(main):091:1&gt; <span class="strong"><strong>end</strong></span>
 =&gt; nil</pre><p>This code defines a new class called <code class="literal">Person</code>. The
            <code class="literal">initialize</code> method takes one parameter and assigns the value of that
          parameter to the instance variable <code class="literal">@name</code>. The <code class="literal">greet</code>
          method prints a friendly greeting. Let’s write some code that uses this new
          class.</p><a id="pro_id00051"/><pre class="programlisting">irb(main):092:0&gt; <span class="strong"><strong>person = Person.new("Tony")</strong></span>
 =&gt; #&lt;Person:0x007fc98418d710 @name="Tony"&gt;
irb(main):093:0&gt; <span class="strong"><strong>person.greet</strong></span>
Hi, I'm Tony.
 =&gt; nil</pre><p><a class="indexterm" id="iddle1196"/><a class="indexterm" id="iddle1316"/><a class="indexterm" id="iddle1319"/><a class="indexterm" id="iddle1627"/><a class="indexterm" id="iddle1746"/><a class="indexterm" id="iddle1750"/><a class="indexterm" id="iddle2153"/>You can create an instance of the <code class="literal">Person</code> class by calling
            <code class="literal">Person.new</code> and passing the required parameters. The previous example
          creates an instance of <code class="literal">Person</code> with the name Tony.</p><p>The return value of <code class="literal">Person.new</code> is a string representation of the
          object. It consists of the class name followed by a reference to the object in memory and
          a list of instance variables. Calling the <code class="literal">greet</code> method should display
          the friendly greeting we expect.</p><p>Instance variables, like <code class="literal">@name</code>, are not accessible outside of the
          class. Try to access <code class="literal">person.name</code> from the IRB prompt, and you should
          see an error.</p><a id="pro_id00052"/><pre class="programlisting">irb(main):094:0&gt; <span class="strong"><strong>person.name</strong></span>
NoMethodError: undefined method 'name'</pre><p>If you need to access or change <code class="literal">@name</code> outside of the class, you
          need to write a <span class="emphasis"><em>getter</em></span> and a <span class="emphasis"><em>setter</em></span>. These are
          methods that <span class="emphasis"><em>get</em></span> or <span class="emphasis"><em>set</em></span> the value of an instance
          variable. Fortunately, Ruby classes provide the method <code class="literal">attr_accessor</code>,
          which writes getters and setters for you.</p><p>You would normally include <code class="literal">attr_accessor :name</code> in your definition
          of the <code class="literal">Person</code> class. Rather than retype the entire class definition,
          you can reopen the class and add this line:</p><a id="pro_id00053"/><pre class="programlisting">irb(main):095:0&gt; <span class="strong"><strong>class Person</strong></span>
irb(main):096:1&gt;   <span class="strong"><strong>attr_accessor :name</strong></span>
irb(main):097:1&gt; <span class="strong"><strong>end</strong></span>
 =&gt; nil</pre><p>This code adds the <code class="literal">attr_accessor</code> call to the
            <code class="literal">Person</code> class and updates all objects of the class automatically. And
          this is another example of the Ruby’s flexibility. You can reopen a class, even at
          runtime, and add new methods as needed.</p><p>Now, if we want to change the name of our person, we can just set it equal to
          something else, as shown here:</p><a id="pro_id00054"/><pre class="programlisting">irb(main):098:0&gt; <span class="strong"><strong>person.name</strong></span>
 =&gt; "Tony"
irb(main):099:0&gt; <span class="strong"><strong>person.name = "Wyatt"</strong></span>
 =&gt; "Wyatt"
irb(main):100:0&gt; <span class="strong"><strong>person.greet</strong></span>
Hi, I'm Wyatt.
 =&gt; nil</pre><p><a class="indexterm" id="iddle1017"/><a class="indexterm" id="iddle1323"/><a class="indexterm" id="iddle1728"/><a class="indexterm" id="iddle1747"/><a class="indexterm" id="iddle1761"/><a class="indexterm" id="iddle1854"/><a class="indexterm" id="iddle1877"/><a class="indexterm" id="iddle2167"/>The <code class="literal">attr_accessor</code> method uses the symbol
            <code class="literal">:name</code> to define the getter <code class="literal">name</code> and the setter
            <code class="literal">name=</code>. You can now get and set the value of the instance variable as
          needed. If you only want a getter, include a call to <code class="literal">attr_reader</code>
          instead of <code class="literal">attr_accessor</code>. Doing this lets you read the value of
            <code class="literal">@name</code>, but not change it.</p><div class="sect2" title="Class Methods"><div class="titlepage"><div><div><h2 class="title"><a id="class_methods"/>Class Methods</h2></div></div></div><p>The <code class="literal">attr_accessor</code> method is different from the methods I’ve
            discussed so far. Note that <code class="literal">attr_accessor</code> is called inside the body
            of the class definition. The methods you’ve seen so far, such as the
              <code class="literal">greet</code> method, are called on an instance of a class.</p><p>In Ruby, methods called on an instance of a class are called <span class="emphasis"><em>instance
              methods</em></span>. Methods called on the class itself are called <span class="emphasis"><em>class
              methods</em></span>. Another example of a class method is <code class="literal">new</code>. When
            you typed <code class="literal">Person.new("Tony")</code> before, you were calling the class
            method <code class="literal">new</code> of the class <code class="literal">Person</code>.</p></div><div class="sect2" title="Inheritance"><div class="titlepage"><div><div><h2 class="title"><a id="inheritance"/>Inheritance</h2></div></div></div><p>In Ruby, you can define a new class that builds on the state and behavior of an
            existing class, and the new class will inherit variables and methods from the existing
            one. <span class="emphasis"><em>Inheritance</em></span> defines an <span class="emphasis"><em>is-a</em></span> relationship
            between those two classes. For example, a student is a person. We can define the class
              <code class="literal">Student</code> like this:</p><a id="pro_id00055"/><pre class="programlisting">irb(main):101:0&gt; <span class="strong"><strong>class Student &lt; Person</strong></span>
irb(main):102:1&gt;  <span class="strong"><strong>def study</strong></span>
irb(main):103:2&gt;    <span class="strong"><strong>puts "ZzzzZzzz"</strong></span>
irb(main):104:2&gt;  <span class="strong"><strong>end</strong></span>
irb(main):105:1&gt; <span class="strong"><strong>end</strong></span>
 =&gt; nil</pre><p>The <code class="literal">&lt; Person</code> on the first line indicates that the
              <code class="literal">Student</code> class inherits from the <code class="literal">Person</code> class.
            The variables and methods defined by <code class="literal">Person</code> are now available to
              <code class="literal">Student</code>:</p><a id="pro_id00056"/><pre class="programlisting">  irb(main):106:0&gt; <span class="strong"><strong>student = Student.new("Matt")</strong></span>
  #&lt;Student:0x007fd7c3ac4d90 @name="Matt"&gt;
➊ irb(main):107:0&gt; <span class="strong"><strong>student.greet</strong></span>
  Hi, I'm Matt.
   =&gt; nil
  irb(main):108:0&gt; <span class="strong"><strong>student.study</strong></span>
  ZzzzzZzzzz
  =&gt; nil</pre><p>Because we created <code class="literal">greet</code> on <code class="literal">Person</code> earlier in
            the chapter, we can have any <code class="literal">Student</code> call this method ➊
            without defining it in our new class.</p><p>Ruby only supports <span class="emphasis"><em>single inheritance</em></span>, which means that one
            class can’t inherit from multiple classes at the same time. You can, however, work
            around this limitation by using <span class="emphasis"><em>modules</em></span>. A module is a collection
            of <a class="indexterm" id="iddle1566"/><a class="indexterm" id="iddle1567"/><a class="indexterm" id="iddle1956"/><a class="indexterm" id="iddle2275"/><a class="indexterm" id="iddle2339"/>methods and constants that cannot be instantiated but can be included in
            other classes to provide additional behavior. We discuss modules and other advanced
            features of Ruby in <a class="xref" href="ch07.html" title="Chapter 7. Advanced Ruby">Chapter 7</a>.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary"/>Summary</h1></div></div></div><p>You are now well on your way to becoming a great Ruby on Rails programmer. The Ruby
          knowledge you gained in this chapter will make understanding the Rails framework much
          easier.</p><p>I recommend working with IRB as much as you need to feel comfortable with Ruby. When
          you’re ready to start exploring Rails, enter <code class="literal">exit</code> to leave IRB,
          and continue on to <a class="xref" href="ch02.html" title="Chapter 2. Rails Fundamentals">Chapter 2</a>.</p></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="exercises"/>Exercises</h1></div></div></div><div class="qandaset" title="Frequently Asked Questions"><a id="ch01qa1"/><table border="0" summary="Q and A Set" width="100%"><col align="left" width="1%"/><col/><tbody><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch01qa1qe1"/><a id="ch01qa1q1"/><p>Q:</p></td><td align="left" valign="top"><p>1. You can read plaintext files in Ruby with the <code class="literal">File.read</code>
                method. Create a file containing a paragraph or two from a blog post or book, and
                name it <span class="emphasis"><em>test.txt</em></span> in the current directory. This next code
                sample reads a file named <span class="emphasis"><em>test.txt</em></span> into the variable
                  <code class="literal">file</code> and displays the contents of the file:</p><a id="pro_id00057"/><pre class="programlisting"><span class="strong"><strong>file = File.read("test.txt")</strong></span>
<span class="strong"><strong>puts file</strong></span></pre><p>As you can see, <code class="literal">file</code> contains a string. Use
                  <code class="literal">file.split</code> to convert the string into an array of words. You
                can now use Ruby’s built-in array methods to operate on the contents of the
                file. For example, use <code class="literal">file.split.length</code> to count words in the
                file. <code class="literal">file.split.uniq.length</code> tells you how many
                  <span class="emphasis"><em>unique</em></span> words are in the file.</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch01qa1qe2"/><a id="ch01qa1q2"/><p>Q:</p></td><td align="left" valign="top"><p>2. Using the array of words from Exercise 1, count how many times each word
                appears in the file. One way to do this is by iterating over the array and storing
                the count for each word in a hash where the key is the word and the value is the
                count.</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch01qa1qe3"/><a id="ch01qa1q3"/><p>Q:</p></td><td align="left" valign="top"><p>3. Create a <code class="literal">WordCounter</code> class to perform the operations from
                Exercises 1 and 2. The class should accept a filename to read when it is initialized
                and include methods named <code class="literal">count</code>, <code class="literal">uniq_count</code>,
                and <code class="literal">frequency</code> for performing the operations from the previous two
                exercises. The following class definition should help you get started:</p><a id="pro_id00058"/><pre class="programlisting">class WordCounter
  def initialize(file_name)
    @file = File.read(file_name)
  end

  # your code here...
end</pre></td></tr></tbody></table></div></div></div></body></html>