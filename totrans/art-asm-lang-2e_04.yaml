- en: Chapter 5. PROCEDURES AND UNITS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章 过程和单元
- en: '![PROCEDURES AND UNITS](tagoreillycom20100401nostarchimages577853.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![过程和单元](tagoreillycom20100401nostarchimages577853.png.jpg)'
- en: In a procedural programming language, the basic unit of code is the *procedure*.
    A procedure is a set of instructions that compute some value or take some action
    (such as printing or reading a character value). This chapter discusses how HLA
    implements procedures. It begins by discussing HLA's high-level syntax for procedure
    declarations and invocations, but it also describes the low-level implementation
    of procedures at the machine level. At this point, you should be getting comfortable
    with assembly language programming, so it's time to start presenting "pure" assembly
    language rather than continuing to rely on HLA's high-level syntax as a crutch.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程式编程语言中，代码的基本单元是*过程*。过程是一组计算某个值或执行某些操作（例如打印或读取字符值）的指令。本章将讨论 HLA 如何实现过程。它首先讨论
    HLA 的高层语法，用于过程声明和调用，但也描述了过程在机器级别的低层实现。此时，你应该已经对汇编语言编程感到熟悉，因此是时候开始呈现“纯”汇编语言，而不是继续依赖
    HLA 的高层语法作为拐杖。
- en: 5.1 Procedures
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.1 过程
- en: Most procedural programming languages implement procedures using the call/return
    mechanism. That is, some code calls a procedure, the procedure does its thing,
    and then the procedure returns to the caller. The call and return instructions
    provide the 80x86's *procedure invocation mechanism*. The calling code calls a
    procedure with the `call` instruction and the procedure returns to the caller
    with the `ret` instruction. For example, the following 80x86 instruction calls
    the HLA Standard Library `stdout.newln` routine:^([[70](#ftn.CHP-5-FN-1)])
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数过程式编程语言通过调用/返回机制实现过程。也就是说，一些代码调用一个过程，过程执行其操作，然后返回给调用者。调用和返回指令提供了 80x86 的*过程调用机制*。调用代码通过
    `call` 指令调用一个过程，而过程通过 `ret` 指令返回给调用者。例如，以下 80x86 指令调用 HLA 标准库的 `stdout.newln`
    例程：^([[70](#ftn.CHP-5-FN-1)])
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `stdout.newln` procedure prints a newline sequence to the console device
    and returns control to the instruction immediately following the `call stdout.newln;`
    instruction.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdout.newln` 过程将换行符序列打印到控制台设备，并将控制权返回给紧接在 `call stdout.newln;` 指令后的指令。'
- en: 'Alas, the HLA Standard Library does not supply all the routines you will ever
    need. Most of the time you''ll have to write your own procedures. To do this,
    you will use HLA''s procedure-declaration facilities. A basic HLA procedure declaration
    takes the following form:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 唉，HLA 标准库并没有提供你可能需要的所有例程。大多数时候，你必须编写自己的过程。为此，你将使用 HLA 的过程声明功能。一个基本的 HLA 过程声明如下所示：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Procedure declarations appear in the declaration section of your program. That
    is, anywhere you can put a `static`, `const`, `type`, or other declaration section,
    you may place a procedure declaration. In the syntax example above, *`ProcName`*
    represents the name of the procedure you wish to define. This can be any valid
    (and unique) HLA identifier. Whatever identifier follows the `procedure` reserved
    word must also follow the `begin` and `end` reserved words in the procedure. As
    you've probably noticed, a procedure declaration looks a whole lot like an HLA
    program. In fact, the only difference (so far) is the use of the `procedure` reserved
    word rather than the `program` reserved word.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 过程声明出现在程序的声明部分。也就是说，在你可以放置 `static`、`const`、`type` 或其他声明部分的任何地方，你都可以放置过程声明。在上面的语法示例中，*`ProcName`*
    代表你希望定义的过程名称。这可以是任何有效且唯一的 HLA 标识符。无论哪个标识符跟在 `procedure` 保留字后面，它也必须跟在过程中的 `begin`
    和 `end` 保留字后面。正如你可能注意到的，过程声明看起来和 HLA 程序非常相似。事实上，唯一的区别（到目前为止）是使用了 `procedure` 保留字，而不是
    `program` 保留字。
- en: 'Here is a concrete example of an HLA procedure declaration. This procedure
    stores zeros into the 256 double words that EBX points at upon entry into the
    procedure:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个具体的 HLA 过程声明示例。此过程在进入过程时将零值存储到 EBX 所指向的 256 个双字中：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can use the 80x86 `call` instruction to call this procedure. When, during
    program execution, the code falls into the `end zeroBytes;` statement, the procedure
    returns to whoever called it and begins executing the first instruction beyond
    the `call` instruction. The program in [Example 5-1](ch05.html#example_of_a_simple_procedure
    "Example 5-1. Example of a simple procedure") provides an example of a call to
    the `zeroBytes` routine.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用80x86的`call`指令来调用这个过程。当程序执行到`end zeroBytes;`语句时，过程会返回给调用它的人，并开始执行`call`指令之后的第一条指令。[示例
    5-1](ch05.html#example_of_a_simple_procedure "示例 5-1. 简单过程的示例")中的程序提供了调用`zeroBytes`例程的一个示例。
- en: Example 5-1. Example of a simple procedure
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-1. 简单过程的示例
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you may have noticed when calling HLA Standard Library procedures, you don''t
    have to use the `call` instruction to call HLA procedures. There is nothing special
    about the HLA Standard Library procedures versus your own procedures. Although
    the formal 80x86 mechanism for calling procedures is to use the `call` instruction,
    HLA provides a high-level extension that lets you call a procedure by simply specifying
    the procedure''s name followed by an empty set of parentheses.^([[71](#ftn.CHP-5-FN-2)])
    For example, either of the following statements will call the HLA Standard Library
    `stdout.newln` procedure:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，当调用HLA标准库过程时，你不必使用`call`指令来调用HLA过程。HLA标准库过程和你自己写的过程没有什么特别之处。虽然正式的80x86调用过程机制是使用`call`指令，但HLA提供了一个高级扩展，允许你通过简单地指定过程名称后跟一对空括号来调用过程。^([[71](#ftn.CHP-5-FN-2)])
    例如，以下任一语句都将调用HLA标准库中的`stdout.newln`过程：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Likewise, either of the following statements will call the `zeroBytes` procedure
    in [Example 5-1](ch05.html#example_of_a_simple_procedure "Example 5-1. Example
    of a simple procedure"):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，以下任一语句都将调用[示例 5-1](ch05.html#example_of_a_simple_procedure "示例 5-1. 简单过程的示例")中的`zeroBytes`过程：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The choice of calling mechanism is strictly up to you. Most people, however,
    find the high-level syntax easier to read.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 调用机制的选择完全取决于你。然而，大多数人发现高级语法更易于阅读。
- en: '* * *'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[70](#CHP-5-FN-1)]) Normally you would call `newln` using the high-level
    `newln()`; syntax, but the `call` instruction works as well.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[70](#CHP-5-FN-1)]) 通常，你会使用高级语法`newln()`来调用`newln`，但是`call`指令也可以正常工作。
- en: ^([[71](#CHP-5-FN-2)]) This assumes that the procedure does not have any parameters.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[71](#CHP-5-FN-2)]) 这假设过程没有任何参数。
- en: 5.2 Saving the State of the Machine
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.2 保存机器的状态
- en: Take a look at the program in [Example 5-2](ch05s02.html#program_with_an_unintended_infinite_loop
    "Example 5-2. Program with an unintended infinite loop"). This section of code
    attempts to print 20 lines of 40 spaces and an asterisk. Unfortunately, there
    is a subtle bug that creates an infinite loop. The main program uses the `repeat..until`
    loop to call `PrintSpaces` 20 times. `PrintSpaces` uses ECX to count off the 40
    spaces it prints. `PrintSpaces` returns with ECX containing 0\. The main program
    then prints an asterisk and a newline, decrements ECX, and then repeats because
    ECX isn't 0 (it will always contain $FFFF_FFFF at this point).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[示例 5-2](ch05s02.html#program_with_an_unintended_infinite_loop "示例 5-2. 程序存在意外的无限循环")中的程序。这段代码试图打印20行，每行40个空格和一个星号。不幸的是，存在一个微妙的bug，导致了无限循环。主程序使用`repeat..until`循环调用`PrintSpaces`
    20次。`PrintSpaces`使用ECX来计数它打印的40个空格。`PrintSpaces`返回时，ECX的值为0。然后主程序打印一个星号和一个换行符，递减ECX，并重复此过程，因为ECX不为0（此时它始终包含$FFFF_FFFF）。
- en: The problem here is that the `PrintSpaces` subroutine doesn't preserve the ECX
    register. Preserving a register means you save it upon entry into the subroutine
    and restore it before leaving. Had the `PrintSpaces` subroutine preserved the
    contents of the ECX register, the program in [Example 5-2](ch05s02.html#program_with_an_unintended_infinite_loop
    "Example 5-2. Program with an unintended infinite loop") would have functioned
    properly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是`PrintSpaces`子例程没有保存ECX寄存器。保存寄存器意味着在进入子例程时保存它，并在离开前恢复它。如果`PrintSpaces`子例程保存了ECX寄存器的内容，[示例
    5-2](ch05s02.html#program_with_an_unintended_infinite_loop "示例 5-2. 程序存在意外的无限循环")中的程序将能够正常运行。
- en: Example 5-2. Program with an unintended infinite loop
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-2. 程序存在意外的无限循环
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can use the 80x86''s `push` and `pop` instructions to preserve register
    values while you need to use them for something else. Consider the following code
    for `PrintSpaces`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用80x86的`push`和`pop`指令来保存寄存器值，同时在需要时使用这些寄存器做其他操作。考虑以下`PrintSpaces`的代码：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that `PrintSpaces` saves and restores EAX and ECX (because this procedure
    modifies these registers). Also, note that this code pops the registers off the
    stack in the reverse order that it pushed them. The last-in, first-out operation
    of the stack imposes this ordering.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`PrintSpaces`保存并恢复了 EAX 和 ECX（因为这个过程修改了这些寄存器）。还要注意，这段代码按照反向顺序从堆栈中弹出寄存器。堆栈的先进后出操作要求了这种顺序。
- en: 'Either the caller (the code containing the `call` instruction) or the callee
    (the subroutine) can take responsibility for preserving the registers. In the
    example above, the callee preserved the registers. The example in [Example 5-3](ch05s02.html#demonstration_of_caller_register_preserv
    "Example 5-3. Demonstration of caller register preservation") shows what this
    code might look like if the caller preserves the registers:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可以由调用者（包含 `call` 指令的代码）或被调用者（子程序）来负责保存寄存器。在上面的示例中，被调用者负责保存寄存器。[示例 5-3](ch05s02.html#demonstration_of_caller_register_preserv
    "示例 5-3. 调用者寄存器保存示范")中的示例展示了如果调用者保存寄存器，代码可能是什么样子：
- en: Example 5-3. Demonstration of caller register preservation
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-3. 调用者寄存器保存示范
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are two advantages to callee preservation: space and maintainability.
    If the callee (the procedure) preserves all affected registers, then there is
    only one copy of the `push` and `pop` instructions, those the procedure contains.
    If the caller saves the values in the registers, the program needs a set of `push`
    and `pop` instructions around every call. Not only does this make your programs
    longer, it also makes them harder to maintain. Remembering which registers to
    push and pop on each procedure call is not easily done.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用者保存寄存器有两个优点：节省空间和易于维护。如果被调用者（过程）保存了所有受影响的寄存器，那么只有一份 `push` 和 `pop` 指令，即过程本身包含的那一份。如果调用者保存寄存器中的值，程序需要在每次调用时都使用一组
    `push` 和 `pop` 指令。这不仅使程序变得更长，而且也更难维护。记住每次调用过程时需要 `push` 和 `pop` 哪些寄存器并非易事。
- en: On the other hand, a subroutine may unnecessarily preserve some registers if
    it preserves all the registers it modifies. In the examples above, the code needn't
    save EAX. Although `PrintSpaces` changes AL, this won't affect the program's operation.
    If the caller is preserving the registers, it doesn't have to save registers it
    doesn't care about (see the program in [Example 5-4](ch05s02.html#demonstrating_that_caller_preservation_n
    "Example 5-4. Demonstrating that caller preservation need not save all registers")).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果子程序保存它所修改的所有寄存器，它可能会不必要地保存某些寄存器。在上面的示例中，代码不需要保存 EAX。尽管`PrintSpaces`修改了
    AL，但这不会影响程序的操作。如果调用者负责保存寄存器，那么它就不需要保存不关心的寄存器（参见[示例 5-4](ch05s02.html#demonstrating_that_caller_preservation_n
    "示例 5-4. 证明调用者保存不需要保存所有寄存器")中的程序））。
- en: Example 5-4. Demonstrating that caller preservation need not save all registers
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-4. 证明调用者保存不需要保存所有寄存器
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This example in [Example 5-4](ch05s02.html#demonstrating_that_caller_preservation_n
    "Example 5-4. Demonstrating that caller preservation need not save all registers")
    provides three different cases. The first loop (`repeat..until`) preserves only
    the ECX register. Modifying the AL register won't affect the operation of this
    loop. Immediately after the first loop, this code calls `PrintSpaces` again in
    the `while` loop. However, this code doesn't save EAX or ECX because it doesn't
    care if `PrintSpaces` changes them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-4](ch05s02.html#demonstrating_that_caller_preservation_n "示例 5-4. 证明调用者保存不需要保存所有寄存器")中的这个示例提供了三种不同的情况。第一个循环（`repeat..until`）只保存
    ECX 寄存器。修改 AL 寄存器不会影响此循环的操作。在第一个循环之后，这段代码在 `while` 循环中再次调用 `PrintSpaces`。然而，这段代码并没有保存
    EAX 或 ECX，因为它不关心 `PrintSpaces` 是否更改了它们。'
- en: One big problem with having the caller preserve registers is that your program
    may change over time. You may modify the calling code or the procedure to use
    additional registers. Such changes, of course, may change the set of registers
    that you must preserve. Worse still, if the modification is in the subroutine
    itself, you will need to locate *every* call to the routine and verify that the
    subroutine does not change any registers the calling code uses.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让调用者保存寄存器的一个大问题是你的程序可能会随着时间的推移而发生变化。你可能会修改调用代码或过程，使用更多的寄存器。当然，这些变化可能会改变你需要保存的寄存器集。更糟糕的是，如果修改发生在子程序本身，你将需要找到*每一个*对该例程的调用，并验证子程序没有更改调用代码所使用的任何寄存器。
- en: Preserving registers isn't all there is to preserving the environment. You can
    also push and pop variables and other values that a subroutine might change. Because
    the 80x86 allows you to push and pop memory locations, you can easily preserve
    these values as well.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 保留寄存器并不是保留环境的全部。你还可以推送和弹出子程序可能改变的变量和其他值。因为80x86允许你推送和弹出内存位置，所以你也可以轻松地保留这些值。
- en: 5.3 Prematurely Returning from a Procedure
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.3 提前从过程返回
- en: The HLA `exit` and `exitif` statements let you return from a procedure without
    having to fall into the corresponding `end` statement in the procedure. These
    statements behave a whole lot like the `break` and `breakif` statements for loops,
    except that they transfer control to the bottom of the procedure rather than out
    of the current loop. These statements are quite useful in many cases.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: HLA的`exit`和`exitif`语句允许你从一个过程返回，而无需落入过程中的相应`end`语句。这些语句的行为很像循环中的`break`和`breakif`语句，不同之处在于它们将控制转移到过程的底部，而不是跳出当前的循环。这些语句在许多情况下非常有用。
- en: 'The syntax for these two statements is the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个语句的语法如下：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The *`procedurename`* operand is the name of the procedure you wish to exit.
    If you specify the name of your main program, the `exit` and `exitif` statements
    will terminate program execution (even if you're currently inside a procedure
    rather than the body of the main program).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*`procedurename`*操作数是你希望退出的过程的名称。如果你指定了主程序的名称，`exit`和`exitif`语句将终止程序执行（即使你当前在过程内部而不是主程序体内）。'
- en: 'The `exit` statement immediately transfers control out of the specified procedure
    or program. The conditional `exitif` statement first tests the boolean expression
    and exits if the result is true. It is semantically equivalent to the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`exit`语句立即将控制转移出指定的过程或程序。条件`exitif`语句首先测试布尔表达式，并在结果为真时退出。它的语义等同于以下内容：'
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Although the `exit` and `exitif` statements are invaluable in many cases, you
    should avoid using them without careful consideration. If a simple `if` statement
    will let you skip the rest of the code in your procedure, then by all means use
    the `if` statement. Procedures that contain a lot of `exit` and `exitif` statements
    will be harder to read, understand, and maintain than procedures without these
    statements (after all, the `exit` and `exitif` statements are really nothing more
    than `goto` statements, and you've probably heard already about the problems with
    `goto`s). `exit` and `exitif` are convenient when you have to return from a procedure
    inside a sequence of nested control structures, and slapping an `if..endif` around
    the remaining code in the procedure is impractical.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`exit`和`exitif`语句在许多情况下非常有用，但在使用它们时应谨慎。如果一个简单的`if`语句可以让你跳过过程中的其余代码，那就使用`if`语句。包含大量`exit`和`exitif`语句的过程比没有这些语句的过程更难阅读、理解和维护（毕竟，`exit`和`exitif`语句实际上不过是`goto`语句，而你可能已经听说过关于`goto`的问题）。当你必须在一系列嵌套控制结构中从一个过程返回时，`exit`和`exitif`语句非常方便，而且用`if..endif`包围过程中的剩余代码是不切实际的。
- en: 5.4 Local Variables
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.4 局部变量
- en: HLA procedures, like procedures and functions in most high-level languages,
    let you declare *local variables*. Local variables are generally accessible only
    within the procedure; they are not accessible by the code that calls the procedure.
    Local variable declarations are identical to variable declarations in your main
    program except, of course, you declare the variables in the procedure's declaration
    section rather than the main program's declaration section. Actually, you may
    declare anything in the procedure's declaration section that is legal in the main
    program's declaration section, including constants, types, and even other procedures.^([[72](#ftn.CHP-5-FN-3)])
    In this section, however, we'll concentrate on local variables.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: HLA过程，就像大多数高级语言中的过程和函数一样，允许你声明*局部变量*。局部变量通常只在过程内部可访问；调用过程的代码无法访问它们。局部变量声明与在主程序中的变量声明相同，唯一的区别是你在过程的声明部分声明变量，而不是在主程序的声明部分声明。实际上，你可以在过程的声明部分声明任何在主程序声明部分合法的东西，包括常量、类型，甚至其他过程。^([[72](#ftn.CHP-5-FN-3)])
    在这一部分，我们将重点讨论局部变量。
- en: 'Local variables have two important attributes that differentiate them from
    the variables in your main program (that is, *global* variables): *lexical scope*
    and *lifetime*. Lexical scope, or just *scope*, determines where an identifier
    is usable in your program. Lifetime determines when a variable has memory associated
    with it and is capable of storing data. Because these two concepts differentiate
    local and global variables, it is wise to spend some time discussing them.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量具有两个重要属性，将它们与主程序中的变量（即*全局*变量）区分开来：*词法作用域*和*生命周期*。词法作用域，或简称*作用域*，决定了标识符在程序中的可用位置。生命周期决定了变量何时具有与之关联的内存并能够存储数据。因为这两个概念区分了局部变量和全局变量，所以花时间讨论它们是明智的。
- en: Perhaps the best place to start when discussing the scope and lifetimes of local
    variables is with the scope and lifetimes of global variables—those variables
    you declare in your main program. Until now, the only rule you've had to follow
    concerning the declaration of your variables has been "you must declare all variables
    that you use in your programs." The position of the HLA declaration section with
    respect to the program statements automatically enforces the other major rule,
    which is "you must declare all variables before their first use." With the introduction
    of procedures, it is now possible to violate this rule because (1) procedures
    may access global variables, and (2) procedure declarations may appear anywhere
    in a declaration section, even before some variable declarations. The program
    in [Example 5-5](ch05s04.html#demonstration_of_global_scope "Example 5-5. Demonstration
    of global scope") demonstrates this source code organization.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论局部变量的作用域和生命周期时，也许最好的起点是从全局变量的作用域和生命周期开始——即你在主程序中声明的那些变量。到目前为止，你需要遵循的关于变量声明的唯一规则是“你必须声明程序中使用的所有变量。”
    HLA 声明部分相对于程序语句的位置自动执行了另一个主要规则，即“你必须在第一次使用变量之前声明所有变量。” 随着过程的引入，现在可以违反这个规则，因为（1）过程可以访问全局变量，且（2）过程声明可以出现在声明部分的任何位置，甚至在一些变量声明之前。[示例
    5-5](ch05s04.html#demonstration_of_global_scope "示例 5-5. 全局作用域演示") 中的程序展示了这种源代码组织。
- en: Example 5-5. Demonstration of global scope
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-5. 全局作用域演示
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This example demonstrates that a procedure can access global variables in the
    main program as long as you declare those global variables before the procedure.
    In this example, the `aProc` procedure cannot access the `InaccessibleInProc`
    variable because its declaration appears after the procedure declaration. However,
    `aProc` may reference `AccessibleInProc` because its declaration appears before
    the `aProc` procedure.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例演示了只要在过程之前声明全局变量，过程就可以访问主程序中的全局变量。在这个例子中，`aProc` 过程无法访问 `InaccessibleInProc`
    变量，因为它的声明出现在过程声明之后。然而，`aProc` 可以引用 `AccessibleInProc`，因为它的声明出现在 `aProc` 过程之前。
- en: A procedure can access any `static`, `storage`, or `readonly` object exactly
    the same way the main program accesses such variables—by referencing the name.
    Although a procedure may access global `var` objects, a different syntax is necessary,
    and you need to learn a little more before you will understand the purpose of
    the additional syntax (for more details, please consult the HLA reference manual).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 过程可以以与主程序访问 `static`、`storage` 或 `readonly` 对象相同的方式访问这些变量——通过引用名称。尽管过程可以访问全局
    `var` 对象，但需要不同的语法，并且在你理解额外语法的目的之前，还需要学些额外的内容（有关更多细节，请查阅 HLA 参考手册）。
- en: Accessing global objects is convenient and easy. Unfortunately, as you've probably
    learned when studying high-level language programming, accessing global objects
    makes your programs harder to read, understand, and maintain. Like most introductory
    programming texts, this book discourages the use of global variables within procedures.
    Accessing global variables within a procedure is sometimes the best solution to
    a given problem. However, such (legitimate) access typically occurs only in advanced
    programs involving multiple threads of execution or in other complex systems.
    Because it is unlikely you would be writing such code at this point, it is equally
    unlikely that you will absolutely need to access global variables in your procedures,
    so you should carefully consider your options before doing so.^([[73](#ftn.CHP-5-FN-4)])
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 访问全局对象既方便又简单。不幸的是，正如你在学习高级语言编程时可能已经了解到的那样，访问全局对象会使你的程序变得更难阅读、理解和维护。像大多数入门级编程教材一样，本书不鼓励在过程内使用全局变量。在某些情况下，在过程内访问全局变量可能是解决某个问题的最佳方案。然而，这种（合法的）访问通常只发生在涉及多线程执行或其他复杂系统的高级程序中。由于你目前不太可能编写这样的代码，因此也不太可能绝对需要在你的过程中访问全局变量，所以在这样做之前你应该仔细考虑自己的选择。^([[73](#ftn.CHP-5-FN-4)])
- en: 'Declaring local variables in your procedures is very easy; you use the same
    declaration sections as the main program: `static`, `readonly`, `storage`, and
    `var`. The same rules and syntax for the declaration sections and the access of
    variables you declare in these sections apply in your procedure. The example code
    in [Example 5-6](ch05s04.html#example_of_a_local_variable_in_a_procedu "Example 5-6. Example
    of a local variable in a procedure") demonstrates the declaration of a local variable.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的过程内声明局部变量非常简单；你使用与主程序相同的声明部分：`static`、`readonly`、`storage`和`var`。在这些部分声明的变量的声明部分和访问规则与主程序中的规则和语法相同。[示例
    5-6](ch05s04.html#example_of_a_local_variable_in_a_procedu "示例 5-6。过程中的局部变量示例")中的示例代码演示了局部变量的声明。
- en: Example 5-6. Example of a local variable in a procedure
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-6。过程中的局部变量示例
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Local variables in a procedure are accessible only within that procedure.^([[74](#ftn.CHP-5-FN-5)])
    Therefore, the variable `i` in procedure `CntTo10` in [Example 5-6](ch05s04.html#example_of_a_local_variable_in_a_procedu
    "Example 5-6. Example of a local variable in a procedure") is not accessible in
    the main program.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 过程中的局部变量仅在该过程内可访问。^([[74](#ftn.CHP-5-FN-5)]) 因此，过程`CntTo10`中的变量`i`在主程序中是不可访问的。
- en: For local variables, HLA relaxes the rule that identifiers must be unique in
    a program. In an HLA program, all identifiers must be unique within a given *scope*.
    Therefore, all global names must be unique with respect to one another. Similarly,
    all local variables within a given procedure must have unique names *but only
    with respect to other local symbols in that same procedure*. In particular, a
    local name may be the same as a global name. When this occurs, HLA creates two
    separate variables. Within the scope of the procedure, any reference to the common
    name accesses the local variable; outside that procedure, any reference to the
    common name references the global identifier. Although the quality of the resultant
    code is questionable, it is perfectly legal to have a global identifier named
    `MyVar` with the same local name in two or more different procedures. The procedures
    each have their own local variant of the object, which is independent of `MyVar`
    in the main program. [Example 5-7](ch05s04.html#local_variables_need_not_have_globally_u
    "Example 5-7. Local variables need not have globally unique names.") provides
    an example of an HLA program that demonstrates this feature.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于局部变量，HLA放宽了标识符在程序中必须唯一的规则。在HLA程序中，所有标识符必须在给定的*作用域*内是唯一的。因此，所有全局名称必须彼此唯一。类似地，给定过程中的所有局部变量必须具有唯一名称，*但仅对于该过程中的其他局部符号而言*。特别地，局部名称可以与全局名称相同。当这种情况发生时，HLA会创建两个独立的变量。在过程的作用域内，任何对该公共名称的引用都会访问局部变量；在该过程之外，任何对该公共名称的引用都会引用全局标识符。尽管生成的代码质量可能存在疑问，但完全合法的是，两个或更多不同过程中的局部名称与全局标识符`MyVar`相同。每个过程都有自己的局部变体，与主程序中的`MyVar`是独立的。[示例
    5-7](ch05s04.html#local_variables_need_not_have_globally_u "示例 5-7。局部变量不需要全局唯一的名称。")提供了一个展示这一特性的HLA程序示例。
- en: Example 5-7. Local variables need not have globally unique names.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-7。局部变量不需要全局唯一的名称。
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There are good and bad points to be made about reusing global names within a
    procedure. On the one hand, there is the potential for confusion. If you use a
    name like `ProfitsThisYear` as a global symbol and you reuse that name within
    a procedure, someone reading the procedure might think that the procedure refers
    to the global symbol rather than the local symbol. On the other hand, simple names
    like `i`, `j`, and `k` are nearly meaningless (almost everyone expects the program
    to use them as loop-control variables or for other local uses), so reusing these
    names as local objects is probably a good idea. From a software engineering perspective,
    it is probably a good idea to keep all variables names that have a very specific
    meaning (like `ProfitsThisYear`) unique throughout your program. General names
    that have a nebulous meaning (like `index` and `counter` and names like `i`, `j`,
    or `k`) will probably be okay to reuse as global variables.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程内重用全局名称有利有弊。一方面，可能会导致混淆。如果你将 `ProfitsThisYear` 用作全局符号，并在一个过程内重用该名称，阅读代码的人可能会认为该过程引用的是全局符号，而非局部符号。另一方面，像
    `i`、`j` 和 `k` 这样的简单名称几乎没有实际意义（几乎每个人都预期它们用作循环控制变量或其他局部用途），因此将这些名称重用为局部对象可能是个好主意。从软件工程的角度来看，最好保持所有具有非常特定含义的变量名称（如
    `ProfitsThisYear`）在程序中唯一。而那些具有模糊意义的通用名称（如 `index` 和 `counter` 以及像 `i`、`j` 或 `k`
    这样的名称）可能可以作为全局变量重用。
- en: 'There is one last point to make about the scope of identifiers in an HLA program:
    variables in separate procedures are separate, even if they have the same name.
    The `First` and `Second` procedures in [Example 5-7](ch05s04.html#local_variables_need_not_have_globally_u
    "Example 5-7. Local variables need not have globally unique names."), for example,
    share the same name (`i`) for a local variable. However, the `i` in `First` is
    a completely different variable from the `i` in `Second`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 HLA 程序中标识符作用域的最后一点需要说明：即使变量在不同的过程（procedure）中有相同的名称，它们也是独立的。例如，在[示例 5-7](ch05s04.html#local_variables_need_not_have_globally_u
    "示例 5-7. 局部变量不需要具有全局唯一名称")中，`First` 和 `Second` 过程中的局部变量共享相同的名称（`i`）。然而，`First`
    中的 `i` 和 `Second` 中的 `i` 是完全不同的变量。
- en: The second major attribute that differentiates local variables from global variables
    is *lifetime*. The lifetime of a variable spans from the point when the program
    first allocates storage for a variable to the point when the program deallocates
    the storage for that variable. Note that lifetime is a dynamic attribute (controlled
    at runtime), whereas scope is a static attribute (controlled at compile time).
    In particular, a variable can actually have several lifetimes if the program repeatedly
    allocates and then deallocates the storage for that variable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 区分局部变量和全局变量的第二个主要特性是*生命周期*。变量的生命周期从程序首次为变量分配存储空间开始，到程序为该变量释放存储空间为止。请注意，生命周期是一个动态特性（在运行时控制），而作用域是一个静态特性（在编译时控制）。特别地，如果程序反复分配然后释放该变量的存储空间，变量实际上可以拥有多个生命周期。
- en: Global variables always have a single lifetime that spans from the moment when
    the main program first begins execution to the point when the main program terminates.
    Likewise, all static objects have a single lifetime that spans the execution of
    the program (remember, static objects are those you declare in the `static`, `readonly`,
    or `storage` sections). This is true even within procedures. So there is no difference
    between the lifetime of a local static object and the lifetime of a global static
    object. Variables you declare in the `var` section, however, are a different matter.
    HLA's `var` objects use *automatic storage allocation*. Automatic storage allocation
    means that the procedure automatically allocates storage for a local variable
    upon entry into a procedure. Similarly, the program deallocates storage for automatic
    objects when the procedure returns to its caller. Therefore, the lifetime of an
    automatic object is from the point of the execution of the first statement in
    a procedure to the point when it returns to its caller.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量始终有一个单一的生命周期，从主程序首次开始执行的时刻到主程序终止时为止。同样，所有静态对象也有一个单一的生命周期，贯穿程序的执行（记住，静态对象是你在
    `static`、`readonly` 或 `storage` 部分声明的对象）。即使在过程内也是如此。因此，局部静态对象的生命周期和全局静态对象的生命周期没有区别。然而，你在
    `var` 部分声明的变量则是另一回事。HLA 的 `var` 对象使用 *自动存储分配*。自动存储分配意味着过程在进入过程时自动为局部变量分配存储空间。类似地，程序在过程返回给调用者时会释放自动对象的存储空间。因此，自动对象的生命周期是从过程中的第一条语句执行开始，到它返回给调用者的时刻。
- en: Perhaps the most important thing to note about automatic variables is that you
    cannot expect them to maintain their values between calls to the procedure. Once
    the procedure returns to its caller, the storage for the automatic variable is
    lost and, therefore, the value is lost as well. Thus, *you must always assume
    that a local* *`var`* *object is uninitialized upon entry into a procedure*, even
    if you know you've called the procedure before and the previous procedure invocation
    initialized that variable. Whatever value the last call stored into the variable
    was lost when the procedure returned to its caller. If you need to maintain the
    value of a variable between calls to a procedure, you should use one of the static
    variable declaration types.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 也许关于自动变量最重要的一点是，你不能指望它们在调用过程之间保持其值。一旦过程返回到调用者，自动变量的存储就会丢失，因此值也会丢失。因此，*你必须始终假设局部*
    *`var`* *对象在进入过程时是未初始化的*，即使你知道之前已经调用过该过程，并且之前的过程调用已初始化了该变量。上一次调用存储到该变量中的任何值在过程返回给调用者时都会丢失。如果你需要在调用过程之间保持变量的值，你应该使用静态变量声明类型之一。
- en: Given that automatic variables cannot maintain their values across procedure
    calls, you might wonder why you would want to use them at all. However, there
    are several benefits to automatic variables that static variables do not have.
    The biggest disadvantage to static variables is that they consume memory even
    when the (only) procedure that references them is not running. Automatic variables,
    on the other hand, consume storage only while their associated procedure is executing.
    Upon return, the procedure returns any automatic storage it allocated back to
    the system for reuse by other procedures. You'll see some additional advantages
    to automatic variables later in this chapter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于自动变量无法在过程调用之间保持其值，你可能会想知道为什么要使用它们。然而，自动变量有一些静态变量所没有的优点。静态变量的最大缺点是，即使引用它们的（唯一）过程未运行，它们仍然会消耗内存。另一方面，自动变量仅在其关联的过程执行时消耗存储空间。返回时，该过程会将其分配的任何自动存储归还给系统，以供其他过程重用。你将在本章稍后看到一些关于自动变量的额外优势。
- en: '* * *'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[72](#CHP-5-FN-3)]) Strictly speaking, this is not true. You may not declare
    external objects within a procedure. External objects are the subject of [5.24
    Units and the external Directive](ch05s24.html "5.24 Units and the external Directive").
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[72](#CHP-5-FN-3)]) 严格来说，这不完全正确。你不能在过程内声明外部对象。外部对象的相关内容可以参考[5.24 单元和 external
    指令](ch05s24.html "5.24 单元和 external 指令")。
- en: ^([[73](#CHP-5-FN-4)]) Note that this argument against accessing global variables
    does not apply to other global symbols. It is perfectly reasonable to access global
    constants, types, procedures, and other objects in your programs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[73](#CHP-5-FN-4)]) 请注意，反对访问全局变量的这个论点不适用于其他全局符号。访问程序中的全局常量、类型、过程和其他对象是完全合理的。
- en: ^([[74](#CHP-5-FN-5)]) Strictly speaking, this is not true. However, accessing
    nonlocal `var` objects is beyond the scope of this text. See the HLA documentation
    for more details.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[74](#CHP-5-FN-5)]) 严格来说，这并不完全正确。不过，访问非局部的 `var` 对象超出了本书的讨论范围。请参阅 HLA 文档了解更多详细信息。
- en: 5.5 Other Local and Global Symbol Types
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.5 其他局部和全局符号类型
- en: As the previous section notes, HLA procedures let you declare constants, values,
    types, and almost everything else legal in the main program's declaration section.
    The same rules for scope apply to these identifiers. Therefore, you can reuse
    constant names, procedure names, type names, and the like in local declarations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，HLA 程序允许你在主程序的声明部分声明常量、值、类型以及几乎所有合法的内容。作用域的相同规则适用于这些标识符。因此，你可以在局部声明中重用常量名、过程名、类型名等。
- en: Referencing global constants, values, and types does not present the same software
    engineering problems that occur when you reference global variables. The problem
    with referencing global variables is that a procedure can change the value of
    a global variable in a nonobvious way. This makes programs more difficult to read,
    understand, and maintain because you can't often tell that a procedure is modifying
    memory by looking only at the call to that procedure. Constants, values, types,
    and other nonvariable objects don't suffer from this problem because you cannot
    change them at runtime. Therefore, the pressure to avoid global objects at nearly
    all costs doesn't apply to nonvariable objects.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 引用全局常量、值和类型不会像引用全局变量那样带来软件工程问题。引用全局变量的问题在于，一个过程可能以一种不明显的方式改变全局变量的值。这会使程序变得更难阅读、理解和维护，因为仅通过查看过程调用，你通常无法判断一个过程是否在修改内存。常量、值、类型和其他非变量对象没有这个问题，因为它们在运行时不能被更改。因此，避免全局对象几乎成为必须遵循的规则，这对非变量对象不适用。
- en: Having said that it's okay to access global constants, types, and so on, it's
    also worth pointing out that you should declare these objects locally within a
    procedure if the only place your program references such objects is within that
    procedure. Doing so will make your programs a little easier to read because the
    person reading your code won't have to search all over the place for the symbol's
    definition.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 既然说了访问全局常量、类型等是可以的，那么也值得指出的是，如果程序仅在某个过程内引用这些对象，你应该在该过程内局部声明这些对象。这样做会使你的程序稍微容易阅读，因为阅读代码的人就不需要到处寻找符号的定义。
- en: 5.6 Parameters
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.6 参数
- en: Although many procedures are totally self-contained, most procedures require
    some input data and return some data to the caller. Parameters are values that
    you pass to and from a procedure. In straight assembly language, passing parameters
    can be a real chore. Fortunately, HLA provides a high-level-language-like syntax
    for procedure declarations and for procedure calls involving parameters. This
    section presents HLA's high-level parameter syntax. Later sections in this chapter
    deal with the low-level mechanisms for passing parameters in pure assembly code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多过程完全自包含，但大多数过程都需要一些输入数据，并将一些数据返回给调用者。参数是你传递给过程并从中返回的值。在纯汇编语言中，传递参数可能是一项繁琐的任务。幸运的是，HLA
    提供了类似高级语言的语法来声明过程和涉及参数的过程调用。本节介绍了 HLA 的高级参数语法。后续章节将介绍在纯汇编代码中传递参数的低级机制。
- en: 'The first thing to consider when discussing parameters is *how* we pass them
    to a procedure. If you are familiar with Pascal or C/C++, you''ve probably seen
    two ways to pass parameters: pass by value and pass by reference. HLA certainly
    supports these two parameter-passing mechanisms. However, HLA also supports pass
    by value/result, pass by result, pass by name, and pass by lazy evaluation. Of
    course, HLA is assembly language, so it is possible to pass parameters in HLA
    using any scheme you can dream up (at least, any scheme that is possible at all
    on the CPU). However, HLA provides special high-level syntax for pass by value,
    reference, value/result, result, name, and lazy evaluation.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论参数时，首先要考虑的是 *如何* 将它们传递给过程。如果你熟悉 Pascal 或 C/C++，你可能见过两种传递参数的方法：按值传递和按引用传递。HLA
    当然支持这两种参数传递机制。然而，HLA 还支持按值/结果传递、按结果传递、按名称传递和懒惰求值传递。当然，HLA 是汇编语言，因此你可以使用任何你能想到的方案来传递参数（至少是
    CPU 上能够实现的任何方案）。不过，HLA 提供了用于按值、引用、值/结果、结果、名称和懒惰求值传递的特殊高级语法。
- en: Because pass by value/result, result, name, and lazy evaluation are somewhat
    advanced, this book will not deal with those parameter-passing mechanisms. If
    you're interested in learning more about these parameter-passing schemes, see
    the HLA reference manual or check out the electronic versions of this text at
    [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) or [http://www.artofasm.com/](http://www.artofasm.com/).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因为按值/结果传递、结果、名称和惰性求值是比较高级的内容，本书不会讨论这些参数传递机制。如果你有兴趣了解更多关于这些参数传递方式的信息，请参阅HLA参考手册或查看本书的电子版，网址为[http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    或 [http://www.artofasm.com/](http://www.artofasm.com/)。
- en: Another concern you will face when dealing with parameters is *where* you pass
    them. There are many different places to pass parameters; in this section we'll
    pass procedure parameters on the stack. You don't really need to concern yourself
    with the details because HLA abstracts them away for you; however, do keep in
    mind that procedure calls and procedure parameters make use of the stack. Therefore,
    whatever you push on the stack immediately before a procedure call is not going
    to be on the top of the stack upon entry into the procedure.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你在处理参数时还需要考虑一个问题，那就是*将参数传递到哪里*。有许多不同的地方可以传递参数；在本节中，我们将把过程参数传递到栈上。你不需要过多关注细节，因为HLA会为你抽象掉这些；不过，记住，过程调用和过程参数都涉及栈的使用。因此，任何在过程调用之前推送到栈上的内容，在进入过程时将不再位于栈顶。
- en: 5.6.1 Pass by Value
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6.1 按值传递
- en: A parameter passed by value is just that—the caller passes a value to the procedure.
    Pass-by-value parameters are input-only parameters. That is, you can pass them
    to a procedure, but the procedure cannot return values through them. Given the
    HLA procedure call
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 按值传递的参数就是如此——调用者将一个值传递给过程。按值传递的参数是输入参数。也就是说，你可以将它们传递给过程，但过程不能通过它们返回值。给定HLA过程调用
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: if you pass `I` by value, then `CallProc` does not change the value of `I`,
    regardless of what happens to the parameter inside `CallProc`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按值传递`I`，那么`CallProc`不会改变`I`的值，无论`CallProc`内部发生了什么。
- en: Because you must pass a copy of the data to the procedure, you should use this
    method only for passing small objects like bytes, words, and double words. Passing
    large arrays and records by value is very inefficient (because you must create
    and pass a copy of the object to the procedure).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你必须将数据的副本传递给过程，因此你应该仅将小对象（如字节、字和双字）按值传递。按值传递大型数组和记录非常低效（因为你必须创建并传递对象的副本给过程）。
- en: HLA, like Pascal and C/C++, passes parameters by value unless you specify otherwise.
    The following is what a typical function looks like with a single pass-by-value
    parameter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: HLA像Pascal和C/C++一样，按值传递参数，除非你另行指定。以下是一个典型的函数，它有一个按值传递的单一参数。
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The parameter `N` in `PrintNSpaces` is known as a *formal parameter*. Anywhere
    the name `N` appears in the body of the procedure, the program references the
    value passed through `N` by the caller.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PrintNSpaces`中，参数`N`被称为*形式参数*。在过程体内任何出现`N`的地方，程序都引用调用者通过`N`传递的值。
- en: 'The calling sequence for `PrintNSpaces` can be any of the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrintNSpaces`的调用顺序可以是以下任意一种：'
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here are some concrete examples of calls to `PrintNSpaces`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些具体的调用`PrintNSpaces`的例子：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The parameter in the calls to `PrintNSpaces` is known as an *actual parameter*.
    In the examples above, `40`, `eax`, and `SpacesToPrint` are the actual parameters.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`PrintNSpaces`时传递的参数被称为*实际参数*。在上面的例子中，`40`、`eax`和`SpacesToPrint`就是实际参数。
- en: Note that pass-by-value parameters behave exactly like local variables you declare
    in the `var` section with the single exception that the procedure's caller initializes
    these local variables before it passes control to the procedure.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，按值传递的参数行为与在`var`部分声明的局部变量完全相同，唯一的例外是过程的调用者在传递控制给过程之前初始化这些局部变量。
- en: 'HLA uses positional parameter notation just as most high-level languages do.
    Therefore, if you need to pass more than one parameter, HLA will associate the
    actual parameters with the formal parameters by their position in the parameter
    list. The following `PrintNChars` procedure demonstrates a simple procedure that
    has two parameters:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: HLA使用位置参数符号，就像大多数高级语言一样。因此，如果需要传递多个参数，HLA会通过参数列表中的位置将实际参数与形式参数关联起来。以下是一个简单的`PrintNChars`过程，它有两个参数：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following is an invocation of the `PrintNChars` procedure that will print
    20 asterisk characters:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对 `PrintNChars` 程序的调用，它将打印 20 个星号字符：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that HLA uses semicolons to separate the formal parameters in the procedure
    declaration, and it uses commas to separate the actual parameters in the procedure
    invocation (Pascal programmers should be comfortable with this notation). Also
    note that each HLA formal parameter declaration takes the following form:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，HLA 使用分号来分隔过程声明中的形式参数，使用逗号来分隔过程调用中的实际参数（Pascal 程序员应该对这种表示法很熟悉）。还要注意，每个 HLA
    形式参数声明采用以下格式：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In particular, note that the parameter type has to be an identifier. None of
    the following are legal parameter declarations because the data type is not a
    single identifier:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意，参数类型必须是标识符。以下的声明都是非法的，因为数据类型不是单一标识符：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, don''t get the impression that you cannot pass pointer, array, record,
    or dynamic array variables as parameters. The trick is to declare a data type
    for each of these types in the `type` section. Then you can use a single identifier
    as the type in the parameter declaration. The following code fragment demonstrates
    how to do this with the four data types above:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不要以为你不能将指针、数组、记录或动态数组变量作为参数传递。诀窍是在 `type` 部分为这些类型中的每一种声明一个数据类型。然后，你可以在参数声明中使用单一标识符作为类型。以下代码片段演示了如何使用上述四种数据类型来做到这一点：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By default, HLA assumes that you intend to pass a parameter by value. HLA also
    lets you explicitly state that a parameter is a value parameter by prefacing the
    formal parameter declaration with the `val` keyword. The following is a version
    of the `PrintNSpaces` procedure that explicitly states that `N` is a pass-by-value
    parameter:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，HLA 假定你打算按值传递参数。HLA 还允许你通过在形式参数声明前加上 `val` 关键字，明确指出某个参数是按值传递的。下面是一个 `PrintNSpaces`
    程序的版本，明确表示 `N` 是一个按值传递的参数：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Explicitly stating that a parameter is a pass-by-value parameter is a good idea
    if you have multiple parameters in the same procedure declaration that use different
    passing mechanisms.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在同一程序声明中有多个参数使用不同的传递机制，明确指出某个参数是按值传递的参数是一个好主意。
- en: When you pass a parameter by value and call the procedure using the HLA high-level
    language syntax, HLA will automatically generate code that will make a copy of
    the actual parameter's value and copy this data into the local storage for that
    parameter (that is, the formal parameter). For small objects, pass by value is
    probably the most efficient way to pass a parameter. For large objects, however,
    HLA must generate code that copies each and every byte of the actual parameter
    into the formal parameter. For large arrays and records, this can be a very expensive
    operation.^([[75](#ftn.CHP-5-FN-6)]) Unless you have specific semantic concerns
    that require you to pass a large array or record by value, you should use pass
    by reference or some other parameter-passing mechanism for arrays and records.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你按值传递参数并使用 HLA 高级语言语法调用过程时，HLA 会自动生成代码，将实际参数的值复制一份，并将该数据复制到该参数的本地存储中（即形式参数）。对于小对象，按值传递可能是最有效的传递方式。然而，对于大对象，HLA
    必须生成代码，将实际参数的每一个字节都复制到形式参数中。对于大型数组和记录，这可能是一个非常昂贵的操作。^([[75](#ftn.CHP-5-FN-6)])
    除非你有特定的语义要求，必须按值传递大型数组或记录，否则你应该使用按引用传递或其他参数传递机制来处理数组和记录。
- en: When passing parameters to a procedure, HLA checks the type of each actual parameter
    and compares this type to the corresponding formal parameter. If the types do
    not agree, HLA then checks to see if either the actual or the formal parameter
    is a byte, word, or double-word object and the other parameter is 1, 2, or 4 bytes
    in length (respectively). If the actual parameter does not satisfy either of these
    conditions, HLA reports a parameter-type mismatch error. If, for some reason,
    you need to pass a parameter to a procedure using a different type than the procedure
    calls for, you can always use the HLA type-coercion operator to override the type
    of the actual parameter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当将参数传递给一个过程时，HLA 会检查每个实际参数的类型，并将该类型与相应的形式参数进行比较。如果类型不匹配，HLA 会检查实际参数或形式参数是否为字节、字（word）或双字（double-word）对象，并且另一个参数的长度分别为
    1、2 或 4 字节。如果实际参数不满足这些条件，HLA 会报告参数类型不匹配的错误。如果出于某种原因，你需要以与程序要求的类型不同的类型传递参数，可以使用
    HLA 类型强制转换操作符来覆盖实际参数的类型。
- en: 5.6.2 Pass by Reference
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6.2 按引用传递
- en: To pass a parameter by reference, you must pass the address of a variable rather
    than its value. In other words, you must pass a pointer to the data. The procedure
    must dereference this pointer to access the data. Passing parameters by reference
    is useful when you must modify the actual parameter or when you pass large data
    structures between procedures.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过引用传递参数，你必须传递一个变量的地址，而不是它的值。换句话说，你必须传递一个指向数据的指针。该过程必须取消引用该指针才能访问数据。当你需要修改实际参数或在过程之间传递大型数据结构时，通过引用传递参数非常有用。
- en: 'To declare a pass-by-reference parameter, you must preface the formal parameter
    declaration with the `var` keyword. The following code fragment demonstrates this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个按引用传递的参数，你必须在形式参数声明前加上`var`关键字。以下代码片段演示了这一点：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Calling a procedure with a pass-by-reference parameter uses the same syntax
    as pass by value except that the parameter has to be a memory location; it cannot
    be a constant or a register. Furthermore, the type of the memory location must
    exactly match the type of the formal parameter. The following are legal calls
    to the procedure above (assuming `i32` is an `int32` variable):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 调用带有按引用传递参数的过程使用的语法与按值传递相同，只是参数必须是一个内存位置；它不能是常量或寄存器。此外，内存位置的类型必须与形式参数的类型完全匹配。以下是对上述过程的合法调用（假设`i32`是一个`int32`变量）：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following are all illegal `UsePassbyReference` invocations (assuming `charVar`
    is of type `char`):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是所有非法的`UsePassbyReference`调用（假设`charVar`是`char`类型）：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Unlike the high-level languages Pascal and C++, HLA does not completely hide
    the fact that you are passing a pointer rather than a value. In a procedure invocation,
    HLA will automatically compute the address of a variable and pass that address
    to the procedure. Within the procedure itself, however, you cannot treat the variable
    like a value parameter (as you could in most high-level languages). Instead, you
    treat the parameter as a double-word variable containing a pointer to the specified
    data. You must explicitly dereference this pointer when accessing the parameter's
    value. The example appearing in [Example 5-8](ch05s06.html#accessing_pass-by-reference_parameters
    "Example 5-8. Accessing pass-by-reference parameters") provides a simple demonstration
    of this.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与高级语言Pascal和C++不同，HLA并没有完全隐藏你传递的是指针而不是值这一事实。在过程调用中，HLA会自动计算一个变量的地址并将该地址传递给过程。然而，在过程内部，你不能像处理值参数那样处理变量（如同在大多数高级语言中）。相反，你需要将该参数视为一个包含指向指定数据的指针的双字变量。你必须显式地取消引用这个指针以访问参数的值。[示例
    5-8](ch05s06.html#accessing_pass-by-reference_parameters "示例 5-8：访问按引用传递的参数")中的示例提供了一个简单的演示。
- en: Example 5-8. Accessing pass-by-reference parameters
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-8：访问按引用传递的参数
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Passing parameters by reference can produce some peculiar results in some rare
    circumstances. Consider the `pbr` procedure in [Example 5-8](ch05s06.html#accessing_pass-by-reference_parameters
    "Example 5-8. Accessing pass-by-reference parameters"). Were you to modify the
    call in the main program to be `pbr(i,i)` rather than `pbr(i,j)`;, the program
    would produce the following nonintuitive output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些罕见的情况下，通过引用传递参数可能会产生一些奇怪的结果。考虑[示例 5-8](ch05s06.html#accessing_pass-by-reference_parameters
    "示例 5-8：访问按引用传递的参数")中的`pbr`过程。如果你修改主程序中的调用为`pbr(i,i)`而不是`pbr(i,j)`，程序将输出以下非直观的结果：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The reason this code displays `a+b=−4` rather than the expected `a+b=−3` is
    because the `pbr(i,i);` call passes the same actual parameter for `a` and `b`.
    As a result, the `a` and `b` reference parameters both contain a pointer to the
    same memory location—that of the variable `i`. In this case, `a` and `b` are *aliases*
    of one another. Therefore, when the code stores −2 at the location pointed at
    by `b`, it overwrites the −1 stored earlier at the location pointed at by `a`.
    When the program fetches the value pointed at by `a` and `b` to compute their
    sum, both `a` and `b` point at the same value, which is −2\. Summing −2 + −2 produces
    the −4 result that the program displays. This nonintuitive behavior is possible
    anytime you encounter aliases in a program. Passing the same variable as two different
    reference parameters probably isn't very common. But you could also create an
    alias if a procedure references a global variable and you pass that same global
    variable by reference to the procedure (this is a good example of yet one more
    reason why you should avoid referencing global variables in a procedure).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码显示`a+b=−4`而不是预期的`a+b=−3`，是因为`pbr(i,i);`调用将相同的实际参数传递给`a`和`b`。结果，`a`和`b`的引用参数都包含指向相同内存位置的指针——即变量`i`的位置。在这种情况下，`a`和`b`是相互的*别名*。因此，当代码将−2存储在`b`指向的位置时，它会覆盖之前存储在`a`指向位置的−1。当程序获取`a`和`b`指向的值并计算它们的和时，`a`和`b`都指向相同的值，即−2。将−2
    + −2相加，得到程序显示的−4结果。这种非直观的行为在程序中遇到别名时是可能的。将同一个变量作为两个不同的引用参数传递，可能并不常见。但如果一个过程引用了全局变量，并且你通过引用将这个全局变量传递给该过程，你也可以创建一个别名（这是另一个你应该避免在过程中引用全局变量的好例子）。
- en: Pass by reference is usually less efficient than pass by value. You must dereference
    all pass-by-reference parameters on each access; this is slower than simply using
    a value because it typically requires at least two instructions. However, when
    passing a large data structure, pass by reference is faster because you do not
    have to copy the large data structure before calling the procedure. Of course,
    you'd probably need to access elements of that large data structure (for example,
    an array) using a pointer, so very little efficiency is lost when you pass large
    arrays by reference.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用传递通常比通过值传递效率低。你必须在每次访问时取消引用所有通过引用传递的参数；这比直接使用值要慢，因为通常至少需要两条指令。然而，在传递大型数据结构时，通过引用传递更快，因为你不需要在调用过程之前复制整个数据结构。当然，你可能需要使用指针来访问这个大型数据结构（例如数组）的元素，因此，当你通过引用传递大型数组时，效率几乎没有损失。
- en: '* * *'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[75](#CHP-5-FN-6)]) Note to C/C++ programmers: HLA does not automatically
    pass arrays by reference. If you specify an array type as a formal parameter,
    HLA will emit code that makes a copy of each and every byte of that array when
    you call the associated procedure.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[75](#CHP-5-FN-6)]) 给C/C++程序员的提示：HLA不会自动按引用传递数组。如果你将数组类型指定为形式参数，HLA将在调用相关过程时生成代码，复制数组的每一个字节。
- en: 5.7 Functions and Function Results
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.7 函数和函数结果
- en: Functions are procedures that return some result to the caller. In assembly
    language, there are very few syntactical differences between a procedure and a
    function, which is why HLA doesn't provide a specific declaration for a function.
    Nevertheless, although there is very little *syntactical* difference between assembly
    procedures and functions, there are some *semantic* differences. That is, although
    you can declare them the same way in HLA, you use them differently.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是返回某些结果给调用者的过程。在汇编语言中，过程和函数之间的语法差异很小，这就是为什么HLA没有为函数提供特定声明的原因。尽管汇编过程和函数在语法上几乎没有区别，但在*语义*上是有一些不同的。也就是说，尽管你可以在HLA中以相同的方式声明它们，但它们的使用方式是不同的。
- en: Procedures are a sequence of machine instructions that fulfill some task. The
    end result of the execution of a procedure is the accomplishment of that activity.
    Functions, on the other hand, execute a sequence of machine instructions specifically
    to compute some value to return to the caller. Of course, a function can perform
    some activity as well and procedures can undoubtedly compute some values, but
    the main difference is that the purpose of a function is to return some computed
    result; procedures don't have this requirement.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 过程是一系列机器指令，用来完成某项任务。执行过程的最终结果是完成该任务。而函数则执行一系列机器指令，专门用于计算某个值并返回给调用者。当然，函数也可以执行一些活动，过程也能计算一些值，但主要的区别在于，函数的目的是返回某个计算结果；而过程没有这个要求。
- en: A good example of a procedure is the `stdout.puti32` procedure. This procedure
    requires a single `int32` parameter. The purpose of this procedure is to print
    the decimal conversion of this integer value to the standard output device. Note
    that `stdout.puti32` doesn't return any kind of value that is usable by the calling
    program.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好例子是`stdout.puti32`过程。这个过程只需要一个`int32`类型的参数。这个过程的目的是将该整数值的十进制转换结果打印到标准输出设备上。需要注意的是，`stdout.puti32`不会返回任何调用程序可以使用的值。
- en: 'A good example of a function is the `cs.member` function. This function expects
    two parameters: The first is a character value and the second is a character set
    value. This function returns true (1) in EAX if the character is a member of the
    specified character set. It returns false if the character parameter is not a
    member of the character set.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数的好例子是`cs.member`函数。这个函数需要两个参数：第一个是字符值，第二个是字符集值。如果字符是指定字符集的成员，它会在EAX中返回真（1）。如果字符参数不是字符集的成员，则返回假。
- en: Logically, the fact that `cs.member` returns a usable value to the calling code
    (in EAX) while `stdout.puti32` does not is a good example of the main difference
    between a function and a procedure. So, in general, a procedure becomes a function
    by virtue of the fact that you explicitly decide to return a value somewhere upon
    procedure return. No special syntax is needed to declare and use a function. You
    still write the code as a procedure.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑上讲，`cs.member`返回一个可用值给调用代码（在EAX中），而`stdout.puti32`则没有返回，这很好地说明了函数和过程之间的主要区别。所以，通常情况下，一个过程通过你明确决定在返回时返回一个值而成为函数。声明和使用一个函数并不需要特别的语法，你依然像写过程一样编写代码。
- en: 5.7.1 Returning Function Results
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7.1 返回函数结果
- en: The 80x86's registers are the most common place to return function results.
    The `cs.member` routine in the HLA Standard Library is a good example of a function
    that returns a value in one of the CPU's registers. It returns true (1) or false
    (0) in the EAX register. By convention, programmers try to return 8-, 16-, and
    32-bit (nonreal) results in the AL, AX, and EAX registers, respectively.^([[76](#ftn.CHP-5-FN-7)])
    This is where most high-level languages return these types of results.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86的寄存器是返回函数结果最常见的地方。HLA标准库中的`cs.member`例程就是一个很好的函数例子，它将值返回到CPU的某个寄存器中。它在EAX寄存器中返回真（1）或假（0）。根据约定，程序员通常会在AL、AX和EAX寄存器中返回8位、16位和32位（非实数）结果。这是大多数高级语言返回这些类型结果的地方。
- en: Of course, there is nothing particularly sacred about the AL/AX/EAX register.
    You could return function results in any register if it is more convenient to
    do so. However, if you don't have a good reason for not using AL/AX/EAX, then
    you should follow the convention. Doing so will help others understand your code
    better because they will generally assume that your functions return small results
    in the AL/AX/EAX register set.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，AL/AX/EAX寄存器并没有什么特别神圣的地方。如果用其他寄存器返回函数结果更方便，也是可以的。然而，如果没有充分的理由不使用AL/AX/EAX寄存器，那么你应该遵循这个约定。这样做将帮助他人更好地理解你的代码，因为他们通常会假设你的函数在AL/AX/EAX寄存器中返回较小的结果。
- en: If you need to return a function result that is larger than 32 bits, you obviously
    must return it somewhere other than in EAX (which can hold only 32-bit values).
    For values slightly larger than 32 bits (e.g., 64 bits or maybe even as many as
    128 bits), you can split the result into pieces and return those parts in two
    or more registers. It is common to see programs returning 64-bit values in the
    EDX:EAX register pair (for example, the HLA Standard Library `stdin.geti64` function
    returns a 64-bit integer in the EDX:EAX register pair).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要返回一个大于32位的函数结果，显然你必须将其返回到EAX以外的地方（因为EAX只能容纳32位的值）。对于稍大于32位的值（例如64位，或者甚至可能是128位），你可以将结果拆分成多个部分，并将这些部分分别返回到两个或更多的寄存器中。常见的做法是将64位的值通过EDX:EAX寄存器对返回（例如，HLA标准库中的`stdin.geti64`函数会在EDX:EAX寄存器对中返回一个64位整数）。
- en: 'If you need to return a large object as a function result, say an array of
    1,000 elements, you obviously are not going to be able to return the function
    result in the registers. There are two common ways to deal with large function
    return results: Either pass the return value as a reference parameter or allocate
    storage on the heap (using `mem.alloc`) for the object and return a pointer to
    it in a 32-bit register. Of course, if you return a pointer to storage you''ve
    allocated on the heap, the calling program must free this storage when it has
    finished with it.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将一个大对象作为函数结果返回，比如一个包含1,000个元素的数组，显然你不可能将函数结果返回到寄存器中。有两种常见的方法来处理大型函数返回结果：要么将返回值作为引用参数传递，要么在堆上分配存储空间（使用`mem.alloc`）来存储该对象，并将其指针返回到32位寄存器中。当然，如果你返回了一个指向堆上分配的存储的指针，调用程序必须在完成后释放这块存储。
- en: 5.7.2 Instruction Composition in HLA
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7.2 HLA中的指令组合
- en: 'Several HLA Standard Library functions allow you to call them as operands of
    other instructions. For example, consider the following code fragment:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 几个HLA标准库函数允许你将它们作为其他指令的操作数来调用。例如，考虑以下代码片段：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As your high-level language experience (and HLA experience) should suggest,
    this code calls the `cs.member` function to check to see if the character in AL
    is a lowercase alphabetic character. If the `cs.member` function returns true,
    then this code fragment executes the `then` section of the `if` statement; however,
    if `cs.member` returns false, this code fragment skips the `if..then` body. There
    is nothing spectacular here except for the fact that HLA doesn't support function
    calls as boolean expressions in the `if` statement (look back at [Chapter 1](ch01.html
    "Chapter 1. HELLO, WORLD OF ASSEMBLY LANGUAGE") to see the complete set of allowable
    expressions). How then, does this program compile and run, producing the intuitive
    results?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你的高级语言经验（和HLA经验）应该能暗示的那样，这段代码调用了`cs.member`函数来检查AL中的字符是否是小写字母。如果`cs.member`函数返回true，那么这段代码将执行`if`语句的`then`部分；然而，如果`cs.member`返回false，这段代码将跳过`if..then`体。这里没有什么特别之处，唯一需要注意的是，HLA不支持在`if`语句中将函数调用作为布尔表达式（可以回顾一下[第1章](ch01.html
    "第1章：HELLO，汇编语言的世界")，查看完整的可用表达式集）。那么，这段程序是如何编译并运行的，并得出直观的结果呢？
- en: The next section describes how you can tell HLA that you want to use a function
    call in a boolean expression. However, to understand how this works, you need
    to first learn about *instruction composition* in HLA.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍如何让HLA知道你希望在布尔表达式中使用函数调用。然而，要理解这一点，你需要先了解HLA中的*指令组合*。
- en: 'Instruction composition lets you use one instruction as the operand of another.
    For example, consider the `mov` instruction. It has two operands: a source operand
    and a destination operand. Instruction composition lets you substitute a valid
    80x86 machine instruction for either (or both) operands. The following is a simple
    example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 指令组合允许你将一个指令作为另一个指令的操作数。例如，考虑`mov`指令。它有两个操作数：一个源操作数和一个目标操作数。指令组合允许你将一个有效的80x86机器指令替换为任一（或两个）操作数。以下是一个简单的例子：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Of course, the immediate question is, "What does this mean?" To understand
    what is going on, you must first realize that most instructions "return" a value
    to the compiler while they are being compiled. For most instructions, the value
    they "return" is their destination operand. Therefore, `mov( 0, eax );` returns
    the string `eax` to the compiler during compilation because EAX is the destination
    operand. Most of the time, specifically when an instruction appears on a line
    by itself, the compiler ignores the returned string result. However, HLA uses
    this string result whenever you supply an instruction in place of some operand;
    specifically, HLA uses that string as the operand in place of the instruction.
    Therefore, the `mov` instruction above is equivalent to the following two-instruction
    sequence:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，直接的问题是，“这是什么意思？”要理解发生了什么，你首先需要意识到，大多数指令在编译时都会“返回”一个值给编译器。对于大多数指令，它们“返回”的值是它们的目标操作数。因此，`mov(
    0, eax );` 在编译过程中返回字符串 `eax` 给编译器，因为 EAX 是目标操作数。大多数情况下，特别是当一条指令单独出现在一行时，编译器会忽略返回的字符串结果。然而，当你将指令作为某些操作数的替代时，HLA
    会使用这个字符串结果；具体来说，HLA 将这个字符串作为操作数代替原来的指令。因此，上面的 `mov` 指令等价于以下两条指令序列：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When processing composed instructions (that is, instruction sequences that
    have other instructions as operands), HLA always works in a "left-to-right then
    depth-first (inside-out)" manner. To make sense of this, consider the following
    instructions:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理组合指令（即作为操作数包含其他指令的指令序列）时，HLA 总是以“从左到右然后深度优先（内向外）”的方式工作。为了理解这一点，请考虑以下指令：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To interpret what is happening here, begin with the source operand. It consists
    of the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要解释这里发生的事情，从源操作数开始。它包含以下内容：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The source operand for this instruction is `mov( i, eax` ) and this instruction
    does not have any composition, so HLA emits this instruction and returns its destination
    operand (`eax`) for use as the source to the `sub` instruction. This effectively
    gives us the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令的源操作数是 `mov( i, eax )`，并且这条指令没有任何组合，因此 HLA 发出此指令并返回其目标操作数（`eax`），作为 `sub`
    指令的源操作数。这实际上给我们带来了以下结果：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now HLA compiles the instruction that appears as the destination operand (`mov(
    j, ebx )`) and returns its destination operand (`ebx`) to substitute for this
    `mov` in the `sub` instruction. This yields the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，HLA 编译了作为目标操作数出现的指令（`mov( j, ebx )`），并返回其目标操作数（`ebx`），以替代 `sub` 指令中的 `mov`。这将产生以下结果：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is a complete instruction, without composition, that HLA can compile. So
    it compiles this instruction and returns its destination operand (`ebx`) as the
    string result to substitute for the `sub` in the original `add` instruction. So
    the original `add` instruction now becomes
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完整的指令，没有组合，HLA 可以编译它。因此，它编译了这条指令，并将其目标操作数（`ebx`）作为字符串结果返回，替代原始 `add` 指令中的
    `sub`。所以，原始的 `add` 指令现在变成了：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: HLA next compiles the `mov` instruction appearing in the destination operand.
    It returns its destination operand as a string that HLA substitutes for the `mov`,
    finally yielding the simple instruction
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 接下来编译了目标操作数中出现的 `mov` 指令。它将其目标操作数作为字符串返回，HLA 用该字符串替代 `mov`，最终生成简单的指令：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The compilation of the original `add` instruction, therefore, yields the following
    instruction sequence:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，原始 `add` 指令的编译结果是以下指令序列：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Whew! It's rather difficult to look at the original instruction and easily see
    that this sequence is the result. As you can see in this example, *overzealous
    use of instruction composition can produce nearly unreadable programs*. You should
    be very careful about using instruction composition in your programs. With only
    a few exceptions, writing a composed instruction sequence makes your program harder
    to read.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！从原始指令来看，很难轻易看出这个序列是结果。正如这个例子所示，*过度使用指令组合可能会导致程序几乎无法阅读*。你在编写程序时应非常小心使用指令组合。除少数例外，编写组合指令序列会使你的程序更难以理解。
- en: 'Note that the excessive use of instruction composition may make errors in your
    program difficult to decipher. Consider the following HLA statement:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，过度使用指令组合可能会使程序中的错误难以解读。请看以下 HLA 语句：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This instruction composition yields the following 80x86 instruction sequence:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令组合生成了以下 80x86 指令序列：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Of course, the compiler will complain that you''re attempting to add one memory
    location to another. However, the instruction composition effectively masks this
    fact and makes it difficult to comprehend the cause of the error message. Moral
    of the story: Avoid using instruction composition unless it really makes your
    program easier to read. The few examples in this section demonstrate how *not*
    to use instruction composition.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，编译器会抱怨你试图将一个内存位置加到另一个内存位置上。然而，指令组合有效地掩盖了这一事实，使得理解错误信息的原因变得困难。这个故事的寓意是：除非真的能使程序更易读，否则避免使用指令组合。本节中的几个示例演示了*不应该*如何使用指令组合。
- en: There are two main areas where using instruction composition can help make your
    programs more readable. The first is in HLA's high-level language control structures.
    The other is in procedure parameters. Although instruction composition is useful
    in these two cases (and probably a few others as well), this doesn't give you
    a license to use extremely convoluted instructions like the `add` instruction
    in the previous example. Instead, most of the time you will use a single instruction
    or a function call in place of a single operand in a high-level language boolean
    expression or in a procedure/function parameter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个主要的领域中，使用指令组合可以帮助使程序更易读。第一个是HLA的高级语言控制结构。另一个是在过程参数中。尽管指令组合在这两种情况下（以及可能的其他几种情况）是有用的，但这并不意味着你可以使用像之前示例中的`add`指令那样复杂的指令。相反，大多数时候，你将使用单个指令或函数调用来替代高级语言布尔表达式中的单个操作数，或在过程/函数参数中使用。
- en: While we're on the subject, exactly what does a procedure call return as the
    string that HLA substitutes for the call in an instruction composition? For that
    matter, what do statements like `if..endif` return? How about instructions that
    don't have a destination operand? Well, function return results are the subject
    of the next section, so you'll read about that in a few moments. As for all the
    other statements and instructions, you should check out the HLA reference manual.
    It lists each instruction and its returns value. The returns value is the string
    that HLA will substitute for the instruction when it appears as the operand to
    another instruction. Note that many HLA statements and instructions return the
    empty string as their returns value (by default, so do procedure calls). If an
    instruction returns the empty string as its composition value, then HLA will report
    an error if you attempt to use it as the operand of another instruction. For example,
    the `if..then..endif` statement returns the empty string as its returns value,
    so you may not bury an `if..then..endif` inside another instruction.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们在讨论这个话题，那么过程调用作为HLA在指令组合中替代调用的字符串返回的到底是什么呢？此外，像`if..endif`这样的语句返回什么？没有目标操作数的指令又返回什么呢？嗯，函数返回结果是下一节的内容，你将在几分钟内阅读到它。至于所有其他语句和指令，你应该查阅HLA参考手册。手册列出了每条指令及其返回值。返回值是HLA在指令作为另一个指令的操作数时替代指令的字符串。请注意，许多HLA语句和指令默认返回空字符串作为返回值（过程调用也是如此）。如果指令返回空字符串作为其组合值，那么如果你试图将其作为另一条指令的操作数使用，HLA会报告错误。例如，`if..then..endif`语句返回空字符串作为返回值，因此你不能将`if..then..endif`嵌套在另一条指令中。
- en: 5.7.3 The HLA @returns Option in Procedures
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7.3 HLA过程中的`@returns`选项
- en: 'HLA procedure declarations allow a special option that specifies the string
    to use when a procedure invocation appears as the operand of another instruction:
    the `@returns` option. The syntax for a procedure declaration with the `@returns`
    option is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: HLA过程声明允许一个特殊选项，指定当过程调用作为另一条指令的操作数时使用的字符串：`@returns`选项。带有`@returns`选项的过程声明语法如下：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If the `@returns` option is not present, HLA assigns the empty string to the
    `@returns` value for the procedure. This effectively makes it illegal to use that
    procedure invocation as the operand to another instruction.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`@returns`选项，HLA会将空字符串赋值给过程的`@returns`值。这实际上使得将该过程调用作为另一个指令操作数成为非法。
- en: The `@returns` option requires a single-string expression surrounded by parentheses.
    HLA will substitute this string constant for the procedure call if it ever appears
    as the operand of another instruction. Typically this string constant is a register
    name; however, any text that would be legal as an instruction operand is okay
    here. For example, you could specify memory addresses or constants. For purposes
    of clarity, you should always specify the location of a function's return value
    in the `@returns` parameter.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`@returns` 选项要求一个被括号包围的单字符串表达式。如果这个字符串常量出现在另一个指令的操作数中，HLA 会将其替换为过程调用。通常，这个字符串常量是一个寄存器名称；不过，任何作为指令操作数合法的文本也可以使用。例如，你可以指定内存地址或常量。为了清晰起见，你应该始终在
    `@returns` 参数中指定函数返回值的位置。'
- en: As an example, consider the following boolean function that returns true or
    false in the EAX register if the single-character parameter is an alphabetic character:^([[77](#ftn.CHP-5-FN-8)])
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，考虑下面的布尔函数，它会在 EAX 寄存器中返回真或假，前提是单字符参数是字母字符：^([[77](#ftn.CHP-5-FN-8)])
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once you tack the `@returns` option on the end of this procedure declaration,
    you can legally use a call to `IsAlphabeticChar` as an operand to other HLA statements
    and instructions:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在这个过程声明的末尾加上 `@returns` 选项，就可以合法地将对 `IsAlphabeticChar` 的调用用作其他 HLA 语句和指令的操作数：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The last example above demonstrates that, via the `@returns` option, you can
    embed calls to your own functions in the boolean expression field of various HLA
    statements. Note that the code above is equivalent to:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的最后一个例子展示了通过 `@returns` 选项，你可以在各种 HLA 语句的布尔表达式字段中嵌入对自定义函数的调用。请注意，以上代码等同于：
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Not all HLA high-level language statements expand composed instructions before
    the statement. For example, consider the following `while` statement:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是所有的 HLA 高级语言语句都会在语句前展开组合指令。例如，考虑下面的 `while` 语句：
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This code does not expand to the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并不会展开成以下内容：
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Instead, the call to `IsAlphabeticChar` expands inside the `while`'s boolean
    expression so that the program calls this function on each iteration of the loop.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`IsAlphabeticChar` 的调用会在 `while` 的布尔表达式内展开，这样程序会在每次循环迭代时调用该函数。
- en: You should exercise caution when entering the `@returns` parameter. HLA does
    not check the syntax of the string parameter when it is compiling the procedure
    declaration (other than to verify that it is a string constant). Instead, HLA
    checks the syntax when it replaces the function call with the `@returns` string.
    So if you had specified `eaz` instead of `eax` as the `@returns` parameter for
    `IsAlphabeticChar` in the previous examples, HLA would not have reported an error
    until you actually used `IsAlphabeticChar` as an operand. Then of course, HLA
    would complain about the illegal operand, and it's not at all clear what the problem
    is by looking at the `IsAlphabeticChar` invocation. So take special care not to
    introduce typographical errors into the `@returns` string; figuring out such errors
    later can be very difficult.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `@returns` 参数时需要小心。HLA 在编译过程声明时不会检查字符串参数的语法（除了验证它是一个字符串常量）。HLA 只会在用 `@returns`
    字符串替换函数调用时检查语法。因此，如果你在前面的示例中为 `IsAlphabeticChar` 指定了 `eaz` 而不是 `eax` 作为 `@returns`
    参数，HLA 直到你实际使用 `IsAlphabeticChar` 作为操作数时才会报告错误。到那时，HLA 会抱怨非法的操作数，但通过查看 `IsAlphabeticChar`
    的调用是无法明确知道问题所在的。因此，要特别小心不要在 `@returns` 字符串中引入排版错误；稍后发现这些错误可能会非常困难。
- en: '* * *'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[76](#CHP-5-FN-7)]) In [Chapter 6](ch06.html "Chapter 6. ARITHMETIC") you'll
    see where most programmers return real results.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[76](#CHP-5-FN-7)]) 在[第 6 章](ch06.html "第 6 章：算术")中，你会看到大多数程序员返回实际的结果。
- en: ^([[77](#CHP-5-FN-8)]) Before you run off and actually use this function in
    your own programs, note that the HLA Standard Library provides the `char.isAlpha`
    function that provides this test. See the HLA documentation for more details.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[77](#CHP-5-FN-8)]) 在你实际使用这个函数到自己的程序中之前，注意 HLA 标准库提供了 `char.isAlpha` 函数来进行此测试。更多详情请参阅
    HLA 文档。
- en: 5.8 Recursion
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.8 递归
- en: '*Recursion* occurs when a procedure calls itself. The following, for example,
    is a recursive procedure:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*递归* 是指过程调用自身。例如，下面就是一个递归过程：'
- en: '[PRE48]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Of course, the CPU will never return from this procedure. Upon entry into `Recursive`,
    this procedure will immediately call itself again, and control will never pass
    to the end of the procedure. In this particular case, runaway recursion results
    in an infinite loop.^([[78](#ftn.CHP-5-FN-9)])
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，CPU 永远不会从这个过程返回。进入`Recursive`时，这个过程会立即再次调用自己，控制永远不会传递到过程的结束部分。在这个特定情况下，失控的递归会导致无限循环。^([[78](#ftn.CHP-5-FN-9)])
- en: 'Like a looping structure, recursion requires a termination condition in order
    to stop infinite recursion. `Recursive` could be rewritten with a termination
    condition as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于循环结构，递归需要一个终止条件来防止无限递归。`Recursive`可以用终止条件重写，如下所示：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This modification to the routine causes `Recursive` to call itself the number
    of times appearing in the EAX register. On each call, `Recursive` decrements the
    EAX register by 1 and then calls itself again. Eventually, `Recursive` decrements
    EAX to 0 and returns from each call until it returns to the original caller.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对该例程的修改使得`Recursive`根据 EAX 寄存器中出现的次数自我调用。在每次调用时，`Recursive` 会将 EAX 寄存器减 1，然后再次调用自己。最终，`Recursive`
    将 EAX 减至 0，并从每次调用中返回，直到它返回到最初的调用者。
- en: 'So far, however, there hasn''t been a real need for recursion. After all, you
    could efficiently code this procedure as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，递归并没有真正的必要。毕竟，你可以高效地像这样编写这个过程：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Both examples would repeat the body of the procedure the number of times passed
    in the EAX register.^([[79](#ftn.CHP-5-FN-10)]) As it turns out, there are only
    a few recursive algorithms that you cannot implement in an iterative fashion.
    However, many recursively implemented algorithms are more efficient than their
    iterative counterparts, and most of the time the recursive form of the algorithm
    is much easier to understand.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例都会根据传入 EAX 寄存器的次数重复执行程序的主体。^([[79](#ftn.CHP-5-FN-10)]) 事实证明，只有少数递归算法无法以迭代方式实现。然而，许多递归实现的算法比它们的迭代版本更高效，而且大多数情况下，算法的递归形式更容易理解。
- en: The quicksort algorithm is probably the most famous algorithm that usually appears
    in recursive form. An HLA implementation of this algorithm appears in [Example 5-9](ch05s08.html#recursive_quicksort_program
    "Example 5-9. Recursive quicksort program").
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序算法可能是最著名的通常以递归形式出现的算法。该算法的 HLA 实现出现在[示例 5-9](ch05s08.html#recursive_quicksort_program
    "示例 5-9. 递归快速排序程序")中。
- en: Example 5-9. Recursive quicksort program
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-9. 递归快速排序程序
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that this quicksort procedure uses registers for all nonparameter local
    variables. Also note how quicksort uses `text` constant definitions to provide
    more readable names for the registers. This technique can often make an algorithm
    easier to read; however, one must take care when using this trick not to forget
    that those registers are being used.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个快速排序过程使用寄存器来存储所有非参数的局部变量。还要注意快速排序如何使用`text`常量定义为寄存器提供更具可读性的名称。这种技巧常常能使算法更易于阅读；然而，使用这种技巧时，必须小心不要忘记这些寄存器已经被使用。
- en: '* * *'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[78](#CHP-5-FN-9)]) Well, not really infinite. The stack will overflow and
    Windows, Mac OS X, FreeBSD, or Linux will raise an exception at that point.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[78](#CHP-5-FN-9)]) 嗯，实际上并不是无限的。栈会溢出，Windows、Mac OS X、FreeBSD 或 Linux 会在那时抛出异常。
- en: ^([[79](#CHP-5-FN-10)]) The latter version will do it considerably faster because
    it doesn't have the overhead of the `call`/`ret` instructions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[79](#CHP-5-FN-10)]) 后者版本会大大加快速度，因为它没有`call`/`ret`指令的开销。
- en: 5.9 Forward Procedures
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.9 前向过程
- en: 'As a general rule, HLA requires that you declare all symbols before their first
    use in a program.^([[80](#ftn.CHP-5-FN-11)]) Therefore, you must define all procedures
    before their first call. There are two reasons this isn''t always practical: mutual
    recursion (two procedures call each other) and source code organization (you prefer
    to place a procedure in your code after the point where you''ve first called it).
    Fortunately, HLA lets you use a *forward procedure definition* to declare a procedure
    *prototype*. Forward declarations let you define a procedure before you actually
    supply the code for that procedure.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，HLA 要求在程序中第一次使用符号之前声明所有符号。^([[80](#ftn.CHP-5-FN-11)]) 因此，你必须在第一次调用之前定义所有过程。之所以不总是可行，有两个原因：互递归（两个过程互相调用）和源代码组织（你可能希望将过程放在首次调用它的代码之后）。幸运的是，HLA
    允许你使用*前向过程定义*来声明过程*原型*。前向声明使你能够在实际提供过程代码之前定义该过程。
- en: 'A forward procedure declaration is a familiar procedure declaration that uses
    the reserved word `forward` in place of the procedure''s declaration section and
    body. The following is a forward declaration for the quicksort procedure appearing
    in the last section:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 前向过程声明是一种常见的过程声明，它使用保留字`forward`代替过程的声明部分和主体。以下是上一节中快速排序过程的前向声明：
- en: '[PRE52]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: A forward declaration in an HLA program is a promise to the compiler that the
    actual procedure declaration will appear, exactly as stated in the forward declaration,
    at a later point in the source code.^([[81](#ftn.CHP-5-FN-12)]) The forward declaration
    must have the same parameters, they must be passed the same way, and they must
    all have the same types as the formal parameters in the procedure.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在HLA程序中，前向声明是向编译器保证，实际的过程声明会在源代码的后续部分以与前向声明完全相同的形式出现。^([[81](#ftn.CHP-5-FN-12)])
    前向声明必须有相同的参数，它们必须以相同的方式传递，并且它们的类型必须与过程中的正式参数类型一致。
- en: Routines that are mutually recursive (that is, procedure `A` calls procedure
    `B` and procedure `B` calls procedure `A`) require at least one forward declaration,
    because you may declare only one of procedure `A` or `B` before the other. In
    practice, however, mutual recursion (direct or indirect) doesn't occur very frequently,
    so you'll rarely forward declarations for this purpose.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 互递归的过程（即过程`A`调用过程`B`，而过程`B`又调用过程`A`）至少需要一个前向声明，因为你只能在另一个之前声明过程`A`或`B`中的一个。然而，实际上，互递归（无论是直接递归还是间接递归）并不常见，因此你很少会为了这个目的使用前向声明。
- en: In the absence of mutual recursion, it is always possible to organize your source
    code so that each procedure declaration appears before its first invocation. What's
    possible and what's desired are two different things, however. You might want
    to group a related set of procedures at the beginning of your source code and
    a different set of procedures toward the end of your source code. This logical
    grouping, by function rather than by invocation, may make your programs much easier
    to read and understand. However, this organization may also yield code that attempts
    to call a procedure before its declaration. No sweat; just use a forward procedure
    definition to resolve the problem.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有互递归的情况下，总是可以组织你的源代码，使得每个过程声明出现在其第一次调用之前。然而，什么是可能的，什么是期望的，是两回事。你可能希望将一组相关的过程放在源代码的开头，而将另一组过程放在源代码的末尾。这种逻辑分组按功能而非调用进行，可能会使你的程序更容易阅读和理解。然而，这种组织方式也可能导致代码在声明之前尝试调用一个过程。没关系；只需使用前向过程定义来解决这个问题。
- en: 'One major difference between the forward definition and the actual procedure
    declaration has to do with the procedure options. Some options, like `@returns`,
    may appear only in the forward declaration (if a `forward` declaration is present).
    Other options may appear only in the actual procedure declaration (we haven''t
    covered any of the other procedure options, so don''t worry about them just yet).
    If your procedure requires an `@returns` option, the `@returns` option must appear
    before the `forward` reserved word. For example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 前向定义和实际过程声明之间的一个主要区别与过程选项有关。有些选项，如`@returns`，可能只出现在前向声明中（如果有`forward`声明）。其他选项可能只出现在实际的过程声明中（我们还没有涉及其他过程选项，所以暂时不用担心它们）。如果你的过程需要`@returns`选项，`@returns`选项必须出现在`forward`保留字之前。例如：
- en: '[PRE53]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `@returns` option must not also appear in the actual procedure declaration
    later in your source file.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`@returns`选项不得在源代码中的实际过程声明中再次出现。'
- en: '* * *'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[80](#CHP-5-FN-11)]) There are a few minor exceptions to this rule, but it
    is certainly true for procedure calls.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[80](#CHP-5-FN-11)]) 这个规则有一些小例外，但对于过程调用来说，这一规则是确实成立的。
- en: ^([[81](#CHP-5-FN-12)]) Actually, `exactly` is too strong a word. You will see
    some exceptions in a moment.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[81](#CHP-5-FN-12)]) 事实上，`exactly`是一个太强的词。稍后你会看到一些例外情况。
- en: 5.10 HLA v2.0 Procedure Declarations
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.10 HLA v2.0 过程声明
- en: HLA v2.0 and later support an alternate procedure declaration syntax that is
    similar to constant, type, and variable declarations. Though this book tends to
    prefer the original procedure declaration syntax (which HLA v2.0 and later still
    support), you will see examples of the new syntax in code that exists out in the
    real world; therefore, this section provides a brief discussion of the new procedure
    declaration syntax.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: HLA v2.0 及更高版本支持一种类似于常量、类型和变量声明的替代过程声明语法。尽管本书倾向于使用原始的过程声明语法（HLA v2.0 及更高版本仍然支持该语法），但你将在现实世界中的代码示例中看到新语法；因此，本节简要讨论了新过程声明语法。
- en: 'The new HLA v2.0 procedure declaration syntax uses the `proc` keyword to begin
    a procedure declaration section (similar to `var` or `static` beginning a variable
    declaration section). Within a `proc` section, procedure declarations take one
    of these forms:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 HLA v2.0 过程声明语法使用 `proc` 关键字开始一个过程声明部分（类似于 `var` 或 `static` 开始一个变量声明部分）。在
    `proc` 部分内，过程声明有以下几种形式：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Please see the HLA v2.0 (or later) reference manual for more details concerning
    this alternate procedure declaration syntax. Just be aware of its existence in
    case you come across it while reading example HLA code you've gotten from some
    other source.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此替代过程声明语法的更多详细信息，请参阅 HLA v2.0（或更高版本）参考手册。只需知道它的存在，以防你在阅读从其他来源获得的示例 HLA 代码时遇到它。
- en: 5.11 Low-Level Procedures and the call Instruction
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.11 低级过程和 `call` 指令
- en: The 80x86 `call` instruction does two things. First, it pushes the address of
    the instruction immediately following the `call` onto the stack; then it transfers
    control to the address of the specified procedure. The value that `call` pushes
    onto the stack is known as the *return address*. When the procedure wants to return
    to the caller and continue execution with the first statement following the `call`
    instruction, the procedure simply pops the return address off the stack and jumps
    (indirectly) to that address. Most procedures return to their caller by executing
    a `ret` (return) instruction. The `ret` instruction pops a return address off
    the stack and transfers control indirectly to the address it pops off the stack.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 的 `call` 指令做两件事。首先，它将紧跟在 `call` 指令之后的指令地址压入堆栈；然后，它将控制权转移到指定过程的地址。`call`
    指令压入堆栈的值称为*返回地址*。当过程想要返回调用者并继续执行紧跟在 `call` 指令之后的第一条语句时，过程只需从堆栈中弹出返回地址，并间接跳转到该地址。大多数过程通过执行
    `ret`（返回）指令来返回调用者。`ret` 指令将返回地址从堆栈中弹出，并将控制权间接转移到它从堆栈中弹出的地址。
- en: 'By default, the HLA compiler automatically places a `ret` instruction (along
    with a few other instructions) at the end of each HLA procedure you write. This
    is why you haven''t had to explicitly use the `ret` instruction up to this point.
    To disable the default code generation in an HLA procedure, specify the following
    options when declaring your procedures:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，HLA 编译器会自动在你编写的每个 HLA 过程的末尾添加一条 `ret` 指令（以及其他几条指令）。这就是为什么到目前为止你无需显式使用
    `ret` 指令的原因。要禁用 HLA 过程中的默认代码生成，请在声明过程时指定以下选项：
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `@noframe` and `@nodisplay` clauses are examples of procedure *options*.
    HLA procedures support several such options, including `@returns`, `@noframe`,
    `@nodisplay`, and `@noalignstack`. You'll see the purpose of `@noalignstack` and
    a couple of other procedure options in Section 5.14\. These procedure options
    may appear in any order following the procedure name (and parameters, if any).
    Note that `@noframe` and `@nodisplay` (as well as `@noalignstack`) may appear
    only in an actual procedure declaration. You cannot specify these options in a
    forward declaration.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`@noframe` 和 `@nodisplay` 子句是过程*选项*的例子。HLA 过程支持几个这样的选项，包括 `@returns`、`@noframe`、`@nodisplay`
    和 `@noalignstack`。你将在 5.14 节看到 `@noalignstack` 和其他几个过程选项的用途。这些过程选项可以按照任意顺序出现在过程名称（及其参数，如果有的话）之后。注意，`@noframe`
    和 `@nodisplay`（以及 `@noalignstack`）只能出现在实际的过程声明中。你不能在前向声明中指定这些选项。'
- en: The `@noframe` option tells HLA that you don't want the compiler to automatically
    generate entry and exit code for the procedure. This tells HLA not to automatically
    generate the `ret` instruction (along with several other instructions).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`@noframe` 选项告诉 HLA 编译器，你不希望编译器为过程自动生成入口和退出代码。这告诉 HLA 不要自动生成 `ret` 指令（以及其他几条指令）。'
- en: The `@nodisplay` option tells HLA that it should not allocate storage in procedure's
    local variable area for a *display*. The display is a mechanism you use to access
    nonlocal `var` objects in a procedure. Therefore, a display is necessary only
    if you nest procedures in your programs. This book will not consider the display
    or nested procedures; for more details on the display and nested procedures see
    the appropriate chapter in the electronic edition appearing at [http://www.artofasm.com/](http://www.artofasm.com/)
    or [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/), or check out the
    HLA reference manual. Until then, you can safely specify the `@nodisplay` option
    on all your procedures. Indeed, for all of the procedures appearing in this chapter
    up to this point, specifying the `@nodisplay` option makes a lot of sense because
    none of those procedures actually use the display. Procedures that have the `@nodisplay`
    option are a tiny bit faster and a tiny bit shorter than those procedures that
    do not specify this option.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`@nodisplay` 选项告诉 HLA 不需要在过程的局部变量区域为 *显示* 分配存储空间。显示是一种机制，用于访问过程中的非局部 `var`
    对象。因此，只有在程序中嵌套过程时，才需要显示。本书不会讨论显示或嵌套过程；有关显示和嵌套过程的更多细节，请参见电子版的相关章节，网址为 [http://www.artofasm.com/](http://www.artofasm.com/)
    或 [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)，或者查阅 HLA 参考手册。在此之前，你可以安全地在所有过程上指定
    `@nodisplay` 选项。事实上，对于本章到目前为止出现的所有过程，指定 `@nodisplay` 选项是很有意义的，因为这些过程并不实际使用显示。使用
    `@nodisplay` 选项的过程比未指定此选项的过程要稍微快一点，且稍微短一点。'
- en: 'The following is an example of the minimal procedure:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最小化过程的示例：
- en: '[PRE56]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If you call this procedure with the `call` instruction, `minimal` will simply
    pop the return address off the stack and return back to the caller. You should
    note that a `ret` instruction is absolutely necessary when you specify the `@noframe`
    procedure option.^([[82](#ftn.CHP-5-FN-13)]) If you fail to put the `ret` instruction
    in the procedure, the program will not return to the caller upon encountering
    the `end minimal;` statement. Instead, the program will fall through to whatever
    code happens to follow the procedure in memory. The example program in [Example 5-10](ch05s11.html#effect_of_a_missing_ret_instruction_in_a
    "Example 5-10. Effect of a missing ret instruction in a procedure") demonstrates
    this problem.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `call` 指令调用此过程，`minimal` 将简单地从栈中弹出返回地址并返回给调用者。你应该注意，在指定 `@noframe` 过程选项时，`ret`
    指令是绝对必要的。^([[82](#ftn.CHP-5-FN-13)]) 如果在过程内未放置 `ret` 指令，程序在遇到 `end minimal;` 语句时将不会返回给调用者。相反，程序会直接跳转到内存中跟随过程的任何代码。示例程序[Example
    5-10](ch05s11.html#effect_of_a_missing_ret_instruction_in_a "Example 5-10. 缺少
    `ret` 指令在过程中的影响")演示了这个问题。
- en: Example 5-10. Effect of a missing `ret` instruction in a procedure
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-10. 缺少 `ret` 指令在过程中的影响
- en: '[PRE57]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Although this behavior might be desirable in certain rare circumstances, it
    usually represents a defect in most programs. Therefore, if you specify the `@noframe`
    option, always remember to explicitly return from the procedure using the `ret`
    instruction.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在某些罕见情况下，这种行为可能是期望的，但在大多数程序中，它通常代表着一个缺陷。因此，如果指定了 `@noframe` 选项，务必记得使用 `ret`
    指令显式地从过程返回。
- en: '* * *'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[82](#CHP-5-FN-13)]) Strictly speaking, this isn't true. But some mechanism
    that pops the return address off the stack and jumps to the return address is
    necessary in the procedure's body.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[82](#CHP-5-FN-13)]) 严格来说，这并不完全正确。但在过程体内，某种机制必须从栈中弹出返回地址并跳转到返回地址。
- en: 5.12 Procedures and the Stack
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.12 过程与栈
- en: 'Because procedures use the stack to hold the return address, you must exercise
    caution when pushing and popping data within a procedure. Consider the following
    simple (and defective) procedure:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于过程使用栈来保存返回地址，因此在过程内推送和弹出数据时必须小心。考虑以下简单（且有缺陷的）过程：
- en: '[PRE58]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: At the point the program encounters the `ret` instruction, the 80x86 stack takes
    the form shown in [Figure 5-1](ch05s12.html#stack_contents_before_ret_in_messedup_pr
    "Figure 5-1. Stack contents before ret in MessedUp procedure").
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序遇到 `ret` 指令时，80x86 栈的状态如[图 5-1](ch05s12.html#stack_contents_before_ret_in_messedup_pr
    "图 5-1. MessedUp 过程中的 `ret` 前栈内容")所示。
- en: '![Stack contents before ret in MessedUp procedure](tagoreillycom20100401nostarchimages578001.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![MessedUp 过程中的 `ret` 前栈内容](tagoreillycom20100401nostarchimages578001.png)'
- en: Figure 5-1. Stack contents before `ret` in `MessedUp` procedure
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-1. `MessedUp` 过程中的 `ret` 前栈内容
- en: The `ret` instruction isn't aware that the value on the top of stack is not
    a valid address. It simply pops whatever value is on the top of the stack and
    jumps to that location. In this example, the top of stack contains the saved EAX
    value. Because it is very unlikely that EAX contains the proper return address
    (indeed, there is about a one in four billion chance it is correct), this program
    will probably crash or exhibit some other undefined behavior. Therefore, you must
    take care when pushing data onto the stack within a procedure that you properly
    pop that data prior to returning from the procedure.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you do not specify the `@noframe` option when writing a procedure, HLA automatically
    generates code at the beginning of the procedure that pushes some data onto the
    stack. Therefore, unless you understand exactly what is going on and you've taken
    care of this data HLA pushes on the stack, you should never execute the bare `ret`
    instruction inside a procedure that does not have the `@noframe` option. Doing
    so will attempt to return to the location specified by this data (which is not
    a return address) rather than properly returning to the caller. In procedures
    that do not have the `@noframe` option, use the `exit` or `exitif` statement to
    return from the procedure.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Popping extra data off the stack prior to executing the `ret` statement can
    also create havoc in your programs. Consider the following defective procedure:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Upon reaching the `ret` instruction in this procedure, the 80x86 stack looks
    something like that shown in [Figure 5-2](ch05s12.html#stack_contents_before_ret_in_messeduptoo
    "Figure 5-2. Stack contents before ret in messedUpToo").
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack contents before ret in messedUpToo](tagoreillycom20100401nostarchimages578003.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2. Stack contents before `ret` in `messedUpToo`
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Once again, the `ret` instruction blindly pops whatever data happens to be on
    the top of the stack and attempts to return to that address. Unlike the previous
    example, where it was very unlikely that the top of stack contained a valid return
    address (because it contained the value in EAX), there is a small possibility
    that the top of stack in this example actually *does* contain a return address.
    However, this will not be the proper return address for the `messedUpToo` procedure;
    instead, it will be the return address for the procedure that called `messedUpToo`.
    To understand the effect of this code, consider the program in [Example 5-11](ch05s12.html#effect_of_popping_too_much_data_off_the
    "Example 5-11. Effect of popping too much data off the stack").
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-11. Effect of popping too much data off the stack
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Because a valid return address is sitting on the top of the stack, you might
    think that this program will actually work (properly). However, note that when
    returning from the `messedUpToo` procedure, this code returns directly to the
    main program rather than to the proper return address in the `callsMU2` procedure.
    Therefore, all code in the `callsMU2` procedure that follows the call to `messedUpToo`
    does not execute. When reading the source code, it may be very difficult to figure
    out why those statements are not executing because they immediately follow the
    call to the `messedUpToo` procedure. It isn't clear, unless you look very closely,
    that the program is popping an extra return address off the stack and therefore
    doesn't return to `callsMU2` but rather returns directly to whoever calls `callsMU2`.
    Of course, in this example it's fairly easy to see what is going on (because this
    example is a demonstration of this problem). In real programs, however, determining
    that a procedure has accidentally popped too much data off the stack can be much
    more difficult. Therefore, you should always be careful about pushing and popping
    data in a procedure. You should always verify that there is a one-to-one relationship
    between the pushes in your procedures and the corresponding pops.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 因为有效的返回地址位于堆栈的顶部，你可能认为这个程序会正常工作（正确）。然而，注意到当从 `messedUpToo` 过程返回时，这段代码直接返回到主程序，而不是返回到
    `callsMU2` 过程中的正确返回地址。因此，`callsMU2` 过程中的所有代码在调用 `messedUpToo` 之后不会执行。在阅读源代码时，可能很难理解为什么那些语句没有执行，因为它们紧跟在调用
    `messedUpToo` 过程之后。除非你非常仔细地查看，否则不会很明显，程序正在从堆栈中弹出一个额外的返回地址，因此没有返回到 `callsMU2`，而是直接返回到调用
    `callsMU2` 的地方。当然，在这个示例中，问题很容易看出来（因为这个示例正是为了演示这个问题）。然而，在真实的程序中，确定一个过程是否不小心从堆栈中弹出了太多数据可能会更加困难。因此，你应该始终小心在过程中的数据推入和弹出操作。你应当始终验证程序中的推入操作与对应的弹出操作之间是否存在一对一的关系。
- en: 5.13 Activation Records
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.13 激活记录
- en: Whenever you call a procedure, there is certain information the program associates
    with that procedure call. The return address is a good example of some information
    the program maintains for a specific procedure call. Parameters and automatic
    local variables (that is, those you declare in the `var` section) are additional
    examples of information the program maintains for each procedure call. *Activation
    record* is the term we'll use to describe the information the program associates
    with a specific call to a procedure.^([[83](#ftn.CHP-5-FN-14)])
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你调用一个过程时，程序会为该过程调用关联某些信息。返回地址就是程序为特定过程调用维护的一类信息。参数和自动局部变量（即在 `var` 部分声明的变量）是程序为每个过程调用维护的其他信息的例子。*激活记录*是我们用来描述程序为特定过程调用关联的这些信息的术语。^([[83](#ftn.CHP-5-FN-14)])
- en: Activation record is an appropriate name for this data structure. The program
    creates an activation record when calling (activating) a procedure and the data
    in the structure is organized in a manner identical to records. Perhaps the only
    thing unusual about an activation record (when comparing it to a standard record)
    is that the base address of the record is in the middle of the data structure,
    so you must access fields of the record at positive and negative offsets.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 激活记录是这个数据结构的恰当名称。程序在调用（激活）过程时创建一个激活记录，并且该结构中的数据按记录的方式组织。激活记录（与标准记录相比）唯一不同的地方可能就是记录的基地址位于数据结构的中间，因此你必须在记录的正负偏移量处访问记录的字段。
- en: Construction of an activation record begins in the code that calls a procedure.
    The caller pushes the parameter data (if any) onto the stack. Then the execution
    of the `call` instruction pushes the return address onto the stack. At this point,
    construction of the activation record continues within the procedure itself. The
    procedure pushes registers and other important state information and then makes
    room in the activation record for local variables. The procedure must also update
    the EBP register so that it points at the base address of the activation record.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 激活记录的构建始于调用过程的代码。调用者将参数数据（如果有的话）推入堆栈。然后，`call` 指令的执行将返回地址推入堆栈。此时，激活记录的构建将在过程内部继续。过程将寄存器和其他重要的状态信息推入堆栈，然后在激活记录中为局部变量腾出空间。过程还必须更新
    EBP 寄存器，使其指向激活记录的基址。
- en: 'To see what a typical activation record looks like, consider the following
    HLA procedure declaration:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Whenever an HLA program calls this `ARDemo` procedure, it begins by pushing
    the data for the parameters onto the stack. The calling code will push the parameters
    onto the stack in the order they appear in the parameter list, from left to right.
    Therefore, the calling code first pushes the value for the `i` parameter, then
    it pushes the value for the `j` parameter, and it finally pushes the data for
    the `k` parameter. After pushing the parameters, the program calls the `ARDemo`
    procedure. Immediately upon entry into the `ARDemo` procedure, the stack contains
    these four items arranged as shown in [Figure 5-3](ch05s13.html#stack_organization_immediately_upon_entr
    "Figure 5-3. Stack organization immediately upon entry into ARDemo").
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: The first few instructions in `ARDemo` (note that it does not have the `@noframe`
    option) will push the current value of EBP onto the stack and then copy the value
    of ESP into EBP. Next, the code drops the stack pointer down in memory to make
    room for the local variables. This produces the stack organization shown in [Figure 5-4](ch05s13.html#activation_record_for_ardemo
    "Figure 5-4. Activation record for ARDemo").
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack organization immediately upon entry into ARDemo](tagoreillycom20100401nostarchimages578005.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3. Stack organization immediately upon entry into `ARDemo`
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![Activation record for ARDemo](tagoreillycom20100401nostarchimages578007.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: Figure 5-4. Activation record for `ARDemo`
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: To access objects in the activation record you must use offsets from the EBP
    register to the desired object. The two items of immediate interest to you are
    the parameters and the local variables. You can access the parameters at positive
    offsets from the EBP register; you can access the local variables at negative
    offsets from the EBP register, as [Figure 5-5](ch05s13.html#offsets_of_objects_in_the_ardemo_activat
    "Figure 5-5. Offsets of objects in the ARDemo activation record") shows.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Intel specifically reserves the EBP (Extended Base Pointer) register for use
    as a pointer to the base of the activation record. This is why you should never
    use the EBP register for general calculations. If you arbitrarily change the value
    in the EBP register, you will lose access to the current procedure's parameters
    and local variables.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![Offsets of objects in the ARDemo activation record](tagoreillycom20100401nostarchimages578009.png.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
- en: Figure 5-5. Offsets of objects in the `ARDemo` activation record
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: ^([[83](#CHP-5-FN-14)]) *Stack frame* is another term many people use to describe
    the activation record.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 5.14 The Standard Entry Sequence
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The caller of a procedure is responsible for pushing the parameters onto the
    stack. Of course, the `call` instruction pushes the return address onto the stack.
    It is the procedure''s responsibility to construct the rest of the activation
    record. You can accomplish this by using the following "standard entry sequence"
    code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If the procedure doesn't have any local variables, the third instruction above,
    `sub(` *`NumVars`*`, esp );`, isn't necessary. *`NumVars`* represents the number
    of *bytes* of local variables needed by the procedure. This is a constant that
    should be a multiple of 4 (so the ESP register remains aligned on a double-word
    boundary). If the number of bytes of local variables in the procedure is not a
    multiple of 4, you should round the value up to the next higher multiple of 4
    before subtracting this constant from ESP. Doing so will slightly increase the
    amount of storage the procedure uses for local variables but will not otherwise
    affect the operation of the procedure.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the `NumVars` constant is not a multiple of 4, subtracting this value from
    ESP (which, presumably, contains a double-word-aligned pointer) will virtually
    guarantee that all future stack accesses are misaligned because the program almost
    always pushes and pops double-word values. This will have a very negative performance
    impact on the program. Worse still, many OS API calls will fail if the stack is
    not double-word aligned upon entry into the operating system. Therefore, you must
    always ensure that your local variable allocation value is a multiple of 4.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of the problems with a misaligned stack, by default HLA will also emit
    a fourth instruction as part of the standard entry sequence. The HLA compiler
    actually emits the following standard entry sequence for the `ARDemo` procedure
    defined earlier:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `and` instruction at the end of this sequence forces the stack to be aligned
    on a 4-byte boundary (it reduces the value in the stack pointer by 1, 2, or 3
    if the value in ESP is not a multiple of 4). Although the `ARDemo` entry code
    correctly subtracts 12 from ESP for the local variables (12 is both a multiple
    of 4 and the number of bytes of local variables), this leaves ESP double-word
    aligned only if it was double-word aligned immediately upon entry into the procedure.
    Had the caller messed with the stack and left ESP containing a value that was
    not a multiple of 4, subtracting 12 from ESP would leave ESP containing an unaligned
    value. The `and` instruction in the sequence above, however, guarantees that ESP
    is dword aligned regardless of ESP's value upon entry into the procedure. The
    few bytes and CPU cycles needed to execute this instruction would pay off handsomely
    if ESP was not double-word aligned.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Although it is always safe to execute the `and` instruction in the standard
    entry sequence, it might not be necessary. If you always ensure that ESP contains
    a double-word-aligned value, the `and` instruction in the standard entry sequence
    above is unnecessary. Therefore, if you've specified the `@noframe` procedure
    option, you don't have to include that instruction as part of the entry sequence.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t specified the `@noframe` option (that is, you''re letting HLA
    emit the instructions to construct the standard entry sequence for you), you can
    still tell HLA not to emit the extra `and` instruction if you''re sure the stack
    will be double-word aligned whenever someone calls the procedure. To do this,
    use the `@noalignstack` procedure option. For example:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'HLA emits the following entry sequence for the procedure above:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 5.15 The Standard Exit Sequence
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before a procedure returns to its caller, it needs to clean up the activation
    record. Although it is possible to share the cleanup duties between the procedure
    and the procedure's caller, Intel has included some features in the instruction
    set that allows the procedure to efficiently handle all the cleanup chores itself.
    Standard HLA procedures and procedure calls, therefore, assume that it is the
    procedure's responsibility to clean up the activation record (including the parameters)
    when the procedure returns to its caller.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'If a procedure does not have any parameters, the exit sequence is very simple.
    It requires only three instructions:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If the procedure has some parameters, then a slight modification to the standard
    exit sequence is necessary in order to remove the parameter data from the stack.
    Procedures with parameters use the following standard exit sequence:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The *`ParmBytes`* operand of the `ret` instruction is a constant that specifies
    the number of bytes of parameter data to remove from the stack after the return
    instruction pops the return address. For example, the `ARDemo` example code in
    the previous sections has three double-word parameters. Therefore, the standard
    exit sequence would take the following form:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If you''ve declared your parameters using HLA syntax (that is, a parameter
    list follows the procedure declaration), then HLA automatically creates a local
    constant in the procedure, `_parms_`, that is equal to the number of bytes of
    parameters in that procedure. Therefore, rather than counting the number of parameter
    bytes yourself, you can use the following standard exit sequence for any procedure
    that has parameters:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note that if you do not specify a byte constant operand to the `ret` instruction,
    the 80x86 will not pop the parameters off the stack upon return. Those parameters
    will still be sitting on the stack when you execute the first instruction following
    the `call` to the procedure. Similarly, if you specify a value that is too small,
    some of the parameters will be left on the stack upon return from the procedure.
    If the `ret` operand you specify is too large, the `ret` instruction will actually
    pop some of the caller's data off the stack, usually with disastrous consequences.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to return early from a procedure that doesn't have the `@noframe`
    option, and you don't particularly want to use the `exit` or `exitif` statement,
    you must execute the standard exit sequence to return to the caller. A simple
    `ret` instruction is insufficient because local variables and the old EBP value
    are probably sitting on the top of the stack.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 5.16 Low-Level Implementation of Automatic (Local) Variables
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your program accesses local variables in a procedure using negative offsets
    from the activation record base address (EBP). Consider the following HLA procedure
    (which admittedly doesn''t do much other than demonstrate the use of local variables):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The activation record for `LocalVars` appears in [Figure 5-6](ch05s16.html#activation_record_for_the_localvars_proc
    "Figure 5-6. Activation record for the LocalVars procedure").
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '![Activation record for the LocalVars procedure](tagoreillycom20100401nostarchimages578011.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
- en: Figure 5-6. Activation record for the `LocalVars` procedure
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: The HLA compiler emits code that is roughly equivalent to the following for
    the body of this procedure:^([[84](#ftn.CHP-5-FN-15)])
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You could actually type these statements into the procedure yourself and they
    would work. Of course, using memory references like `[ebp-4]` and `[ebp-8]` rather
    than `a` or `b` makes your programs very difficult to read and understand. Therefore,
    you should always declare and use HLA symbolic names rather than offsets from
    EBP.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: The standard entry sequence for this `LocalVars` procedure will be:^([[85](#ftn.CHP-5-FN-16)])
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This code subtracts 8 from the stack pointer because there are 8 bytes of local
    variables (two double-word objects) in this procedure. Unfortunately, as the number
    of local variables increases, especially if those variables have different types,
    computing the number of bytes of local variables becomes rather tedious. Fortunately,
    for those who wish to write the standard entry sequence themselves, HLA automatically
    computes this value for you and creates a constant, `_vars_`, that specifies the
    number of bytes of local variables.^([[86](#ftn.CHP-5-FN-17)]) Therefore, if you
    intend to write the standard entry sequence yourself, you should use the `_vars_`
    constant in the `sub` instruction when allocating storage for the local variables:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now that you've seen how assembly language allocates and deallocates storage
    for local variables, it's easy to understand why automatic (`var`) variables do
    not maintain their values between two calls to the same procedure. Because the
    memory associated with these automatic variables is on the stack, when a procedure
    returns to its caller the caller can push other data onto the stack, obliterating
    the values previously held on the stack. Furthermore, intervening calls to other
    procedures (with their own local variables) may wipe out the values on the stack.
    Also, upon reentry into a procedure, the procedure's local variables may correspond
    to different physical memory locations; hence the values of the local variables
    would not be in their proper locations.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'One big advantage to automatic storage is that it efficiently shares a fixed
    pool of memory among several procedures. For example, if you call three procedures
    in a row, like so:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: the first procedure (`ProcA` in the code above) allocates its local variables
    on the stack. Upon return, `ProcA` deallocates that stack storage. Upon entry
    into `ProcB`, the program allocates storage for `ProcB`'s local variables *using
    the same memory locations just freed by* `ProcA`. Likewise, when `ProcB` returns
    and the program calls `ProcC`, `ProcC` uses the same stack space for its local
    variables that `ProcB` recently freed up. This memory reuse makes efficient use
    of the system resources and is probably the greatest advantage to using automatic
    (`var`) variables.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: ^([[84](#CHP-5-FN-15)]) This ignores the code associated with the standard entry
    and exit sequences.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: ^([[85](#CHP-5-FN-16)]) This code assumes that ESP is dword aligned upon entry
    so the `and( $FFFF_FFFC, esp );` instruction is unnecessary.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: ^([[86](#CHP-5-FN-17)]) HLA even rounds this constant up to the next even multiple
    of 4 so you don't have to worry about stack alignment.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 5.17 Low-Level Parameter Implementation
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier, when discussing HLA''s high-level parameter passing mechanism, there
    were several questions concerning parameters. Some important questions are:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Where is the data coming from?
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What mechanism do you use to pass and return data?
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much data are you passing?
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section we will take another look at the two most common parameter-passing
    mechanisms: pass by value and pass by reference. We will discuss three popular
    places to pass parameters by reference or by value: in the registers, on the stack,
    and in the code stream. The amount of parameter data has a direct bearing on where
    and how to pass it. The following sections take up these issues.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 5.17.1 Passing Parameters in Registers
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having touched on *how* to pass parameters to a procedure in Section 5.6, the
    next thing to discuss is *where* to pass parameters. Where you pass parameters
    depends on the size and number of those parameters. If you are passing a small
    number of bytes to a procedure, then the registers are an excellent place to pass
    parameters to a procedure. If you are passing a single parameter to a procedure,
    you should use the following registers for the accompanying data types.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This is not a hard-and-fast rule. If you find it more convenient to pass 16-bit
    values in the SI or BX register, then do so. However, most programmers use the
    registers above to pass parameters.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are passing several parameters to a procedure in the 80x86''s registers,
    you should probably use up the registers in the following order:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In general, you should avoid using the EBP register. If you need more than six
    double words, perhaps you should pass your values elsewhere. This choice of priorities
    is not completely arbitrary. Many high-level languages will attempt to pass parameters
    in the EAX, EDX, and ECX registers (generally in that order). Furthermore, the
    Intel ABI (application binary interface) allows high-level language procedures
    to use EAX, EDX, and ECX without preserving their values. Hence, these three registers
    are a great place to pass parameters because a lot of code assumes their values
    are modified across procedure calls.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the following `strfill( s,c )`; procedure that copies
    the character `c` (passed by value in AL) to each character position in `s` (passed
    by reference in EDI) up to a zero-terminating byte:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: To call the `strfill` procedure you would load the address of the string data
    into EDI and the character value into AL prior to the call. The following code
    fragment demonstrates a typical call to `strfill`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Don't forget that HLA string variables are pointers. This example assumes that
    `s` is an HLA string variable and therefore contains a pointer to a zero-terminated
    string. Thus, the `mov( s, edi );` instruction loads the address of the zero-terminated
    string into the EDI register (hence this code passes the address of the string
    data to `strfill`, that is, it passes the string by reference).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to pass parameters in the registers is to simply load them with the
    appropriate values prior to a call and then reference those registers within the
    procedure. This is the traditional mechanism for passing parameters in registers
    in an assembly language program. HLA, being somewhat more high-level than traditional
    assembly language, provides a formal parameter declaration syntax that lets you
    tell HLA you''re passing certain parameters in the general-purpose registers.
    This declaration syntax is the following:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Where *`parmName`* is the parameter''s name, *`parmType`* is the type of the
    object, and *`reg`* is one of the 80x86''s general-purpose 8-, 16-, or 32-bit
    registers. The size of the parameter''s type must be equal to the size of the
    register or HLA will report an error. Here is a concrete example:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'One nice feature to this syntax is that you can call a procedure that has register
    parameters exactly like any other procedure in HLA using the high-level syntax.
    For example:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: If you specify the same register as an actual parameter that you've declared
    for the formal parameter, HLA does not emit any extra code; it assumes that the
    parameter's value is already in the appropriate register. For example, in the
    call above, the first actual parameter is the value in ECX; because the procedure's
    declaration specifies that first parameter is in ECX, HLA will not emit any code.
    On the other hand, the second actual parameter is in BL, but the procedure will
    expect this parameter value in AL. Therefore, HLA will emit a `mov( bl, al );`
    instruction prior to calling the procedure so that the value is in the proper
    register upon entry to the procedure.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also pass parameters by reference in a register. Consider the following
    declaration:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'A call to this procedure always requires some memory operand as the actual
    parameter. HLA will emit the code to load the address of that memory object into
    the parameter''s register (EDI in this case). Note that when passing reference
    parameters, the register must be a 32-bit general-purpose register because addresses
    are 32 bits long. Here''s an example of a call to `HasRefRegParm`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: HLA will emit either a `mov( &x, edi);` or `lea( edi, x);` instruction to load
    the address of `x` into the EDI registers prior to the `call` instruction.^([[87](#ftn.CHP-5-FN-18)])
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: If you pass an anonymous memory object (for example, `[edi]` or `[ecx]`) as
    a parameter to `HasRefRegParm`, HLA will not emit any code if the memory reference
    uses the same register that you declare for the parameter (i.e., `[edi]`). It
    will use a simple `mov` instruction to copy the actual address into EDI if you
    specify an indirect addressing mode using a register other than EDI (e.g., `[ecx]`).
    It will use a `lea` instruction to compute the effective address of the anonymous
    memory operand if you use a more complex addressing mode like `[edi+ecx*4+2]`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Within the procedure's code, HLA creates text equates for those register parameters
    that map their names to the appropriate register. In the `HasRegParms` example,
    any time you reference the `count` parameter, HLA substitutes `ecx` for `count`.
    Likewise, HLA substitutes `al` for `charVal` throughout the procedure's body.
    Because these names are aliases for the registers, you should take care to always
    remember that you cannot use ECX and AL independently of these parameters. It
    would be a good idea to place a comment next to each use of these parameters to
    remind the reader that `count` is equivalent to ECX and `charVal` is equivalent
    to AL.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 5.17.2 Passing Parameters in the Code Stream
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another place where you can pass parameters is in the code stream immediately
    after the `call` instruction. Consider the following `print` routine that prints
    a literal string constant to the standard output device:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Normally, a subroutine returns control to the first instruction immediately
    following the `call` instruction. Were that to happen here, the 80x86 would attempt
    to interpret the ASCII codes for "This . . . ." as an instruction. This would
    produce undesirable results. Fortunately, you can skip over this string when returning
    from the subroutine.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: So how do you gain access to these parameters? Easy. The return address on the
    stack points at them. Consider the implementation of `print` appearing in [Example 5-12](ch05s17.html#print_procedure_implementation_open_pare
    "Example 5-12. Print procedure implementation (using code stream parameters)").
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-12. Print procedure implementation (using code stream parameters)
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Besides showing how to pass parameters in the code stream, the `print` routine
    also exhibits another concept: *variable-length parameters*. The string following
    the `call` can be any practical length. The zero terminating byte marks the end
    of the parameter list. There are two easy ways to handle variable-length parameters:
    Either use some special terminating value (like 0) or pass a special length value
    that tells the subroutine how many parameters you are passing. Both methods have
    their advantages and disadvantages. Using a special value to terminate a parameter
    list requires that you choose a value that never appears in the list. For example,
    `print` uses 0 as the terminating value, so it cannot print the NUL character
    (whose ASCII code is 0). Sometimes this isn''t a limitation. Specifying a special-length
    parameter is another mechanism you can use to pass a variable-length parameter
    list. While this doesn''t require any special codes or limit the range of possible
    values that can be passed to a subroutine, setting up the length parameter and
    maintaining the resulting code can be a real nightmare.^([[88](#ftn.CHP-5-FN-19)])'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Despite the convenience afforded by passing parameters in the code stream, there
    are some disadvantages to passing parameters there. First, if you fail to provide
    the exact number of parameters the procedure requires, the subroutine will get
    confused. Consider the `print` example. It prints a string of characters up to
    a zero-terminating byte and then returns control to the first instruction following
    the zero-terminating byte. If you leave off the zero-terminating byte, the `print`
    routine happily prints the following opcode bytes as ASCII characters until it
    finds a zero byte. Because zero bytes often appear in the middle of an instruction,
    the `print` routine might return control into the middle of some other instruction.
    This will probably crash the machine. Inserting an extra 0, which occurs more
    often than you might think, is another problem programmers have with the `print`
    routine. In such a case, the `print` routine would return upon encountering the
    first zero byte and attempt to execute the following ASCII characters as machine
    code. Once again, this usually crashes the machine. These are the some of the
    reasons why the HLA `stdout.put` code does *not* pass its parameters in the code
    stream. Problems notwithstanding, however, the code stream is an efficient place
    to pass parameters whose values do not change.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 5.17.3 Passing Parameters on the Stack
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most high-level languages use the stack to pass parameters because this method
    is fairly efficient. By default, HLA also passes parameters on the stack. Although
    passing parameters on the stack is slightly less efficient than passing those
    parameters in registers, the register set is very limited and you can pass only
    a few value or reference parameters through registers. The stack, on the other
    hand, allows you to pass a large amount of parameter data without any difficulty.
    This is the principal reason that most programs pass their parameters on the stack.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA typically passes parameters you specify using the high-level procedure
    call syntax on the stack. For example, suppose you define `strfill` from earlier
    as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Calls of the form `strfill( s, ' ' );` will pass the value of `s` (which is
    an address) and a space character on the 80x86 stack. When you specify a call
    to `strfill` in this manner, HLA automatically pushes the parameters for you,
    so you don't have to push them onto the stack yourself. Of course, if you choose
    to do so, HLA will let you manually push the parameters onto the stack prior to
    the call.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'To manually pass parameters on the stack, push them immediately before calling
    the subroutine. The subroutine then reads this data from the stack memory and
    operates on it appropriately. Consider the following HLA procedure call:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'HLA pushes parameters onto the stack in the order that they appear in the parameter
    list.^([[89](#ftn.CHP-5-FN-20)]) Therefore, the 80x86 code that HLA emits for
    this subroutine call (assuming you''re passing the parameters by value) is:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Upon entry into `CallProc`, the 80x86's stack looks like that shown in [Figure 5-7](ch05s17.html#stack_layout_upon_entry_into_callproc
    "Figure 5-7. Stack layout upon entry into CallProc").
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack layout upon entry into CallProc](tagoreillycom20100401nostarchimages578013.png.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
- en: Figure 5-7. Stack layout upon entry into `CallProc`
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'You could gain access to the parameters passed on the stack by removing the
    data from the stack, as the following code fragment demonstrates:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: As you can see from this code, it first pops the return address off the stack
    and into the `RtnAdrs` variable; then it pops (in reverse order) the values of
    the `p1`, `p2`, and `p3` parameters; finally, it pushes the return address back
    onto the stack (so the `ret` instruction will operate properly). Within the `CallProc`
    procedure, you may access the `p1Parm`, `p2Parm`, and `p3Parm` variables to use
    the `p1`, `p2`, and `p3` parameter values.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, a better way to access procedure parameters. If your procedure
    includes the standard entry and exit sequences, then you may directly access the
    parameter values in the activation record by indexing off the EBP register. Consider
    the layout of the activation record for `CallProc` that uses the following declaration:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Take a look at the stack immediately after the execution of `mov( esp, ebp );`
    in `CallProc`. Assuming you've pushed three double-word parameters onto the stack,
    it should look something like that shown in [Figure 5-8](ch05s17.html#activation_record_for_callproc_after_sta
    "Figure 5-8. Activation record for CallProc after standard entry sequence execution").
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '![Activation record for CallProc after standard entry sequence execution](tagoreillycom20100401nostarchimages578015.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
- en: Figure 5-8. Activation record for `CallProc` after standard entry sequence execution
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can access the parameters by indexing off the EBP register:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Of course, as with local variables, you'd never really access the parameters
    in this way. You can use the formal parameter names (`p1`, `p2`, and `p3`), and
    HLA will substitute a suitable `[ebp+displacement]` memory address. Even though
    you shouldn't actually access parameters using address expressions like `[ebp+12]`,
    it's important to understand their relationship to the parameters in your procedures.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Other items that often appear in the activation record are register values that
    your procedure preserves. The most rational place to preserve registers in a procedure
    is in the code immediately following the standard entry sequence. In a standard
    HLA procedure (one where you do not specify the `@noframe` option), this simply
    means that the code that preserves the registers should appear first in the procedure's
    body. Likewise, the code to restore those register values should appear immediately
    before the `end` clause for the procedure.^([[90](#ftn.CHP-5-FN-21)])
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 5.17.3.1 Accessing Value Parameters on the Stack
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Accessing parameters passed by value is no different from accessing a local
    `var` object. As long as you've declared the parameter in a formal parameter list
    and the procedure executes the standard entry sequence upon entry into the program,
    all you need do is specify the parameter's name to reference the value of that
    parameter. [Example 5-13](ch05s17.html#demonstration_of_value_parameters "Example 5-13. Demonstration
    of value parameters") provides an example program whose procedure accesses a parameter
    the main program passes to it by value.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-13. Demonstration of value parameters
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Although you could access the value of `theParameter` using the anonymous address
    `[EBP+8]` within your code, there is absolutely no good reason for doing so. If
    you declare the parameter list using the HLA high-level language syntax, you can
    access the value parameter by specifying its name within the procedure.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 5.17.3.2 Passing Value Parameters on the Stack
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As [Example 5-13](ch05s17.html#demonstration_of_value_parameters "Example 5-13. Demonstration
    of value parameters") demonstrates, passing a value parameter to a procedure is
    very easy. Just specify the value in the actual parameter list as you would for
    a high-level language call. Actually, the situation is a little more complicated
    than this. Passing value parameters is easy if you're passing constant, register,
    or variable values. It gets a little more complex if you need to pass the result
    of some expression. This section deals with the different ways you can pass a
    parameter by value to a procedure.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you do not have to use the HLA high-level syntax to pass value parameters
    to a procedure. You can push these values on the stack yourself. Because many
    times it is more convenient or more efficient to manually pass the parameters,
    describing how to do this is a good place to start.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier in this chapter, when passing parameters on the stack you push
    the objects in the order they appear in the formal parameter list (from left to
    right). When passing parameters by value, you should push the values of the actual
    parameters onto the stack. The program in [Example 5-14](ch05s17.html#manually_passing_parameters_on_the_stack
    "Example 5-14. Manually passing parameters on the stack") demonstrates how to
    do this.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-14. Manually passing parameters on the stack
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Note that if you manually push the parameters onto the stack as this example
    does, you must use the `call` instruction to call the procedure. If you attempt
    to use a procedure invocation of the form `ThreeValueParms();`, then HLA will
    complain about a mismatched parameter list. HLA won't realize that you've manually
    pushed the parameters (as far as HLA is concerned, those pushes appear to preserve
    some other data).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, there is little reason to manually push a parameter onto the stack
    if the actual parameter is a constant, a register value, or a variable. HLA''s
    high-level syntax handles most such parameters for you. There are several instances,
    however, where HLA''s high-level syntax won''t work. The first such example is
    passing the result of an arithmetic expression as a value parameter. Because runtime
    arithmetic expressions don''t exist in HLA, you will have to manually compute
    the result of the expression and pass that value yourself. There are two possible
    ways to do this: calculate the result of the expression and manually push that
    result onto the stack, or compute the result of the expression into a register
    and pass the register as a parameter to the procedure. The program in [Example 5-15](ch05s17.html#passing_the_result_of_some_arithmetic_ex
    "Example 5-15. Passing the result of some arithmetic expression as a parameter")
    demonstrates these two mechanisms.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-15. Passing the result of some arithmetic expression as a parameter
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The examples up to this point in this section have made an important assumption:
    that the parameter you are passing is a double-word value. The calling sequence
    changes somewhat if you''re passing parameters that are not 4-byte objects. Because
    HLA can generate relatively inefficient code when passing objects that are not
    4 bytes long, manually passing such objects is a good idea if you want to have
    the fastest possible code.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: HLA requires that all value parameters be a multiple of 4 bytes long.^([[91](#ftn.CHP-5-FN-22)])
    If you pass an object that is less than 4 bytes long, HLA requires that you *pad*
    the parameter data with extra bytes so that you always pass an object that is
    at least 4 bytes in length. For parameters that are larger than 4 bytes, you must
    ensure that you pass a multiple of 4 bytes as the parameter value, adding extra
    bytes at the high-order end of the object to pad it, as necessary.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following procedure prototype:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The activation record for this procedure appears in [Figure 5-9](ch05s17.html#onebyteparm_activation_record
    "Figure 5-9. OneByteParm activation record").
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '![OneByteParm activation record](tagoreillycom20100401nostarchimages578017.png)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
- en: Figure 5-9. `OneByteParm` activation record
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are 4 bytes on the stack associated with the `b` parameter,
    but only 1 of the 4 bytes contains valid data (the L.O. byte). The remaining 3
    bytes are just padding, and the procedure should ignore these bytes. In particular,
    you should never assume that these extra bytes contain 0s or some other consistent
    value. Depending on the type of parameter you pass, HLA's automatic code generation
    may or may not push 0 bytes as the extra data on the stack.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'When passing a byte parameter to a procedure, HLA will automatically emit code
    that pushes 4 bytes onto the stack. Because HLA''s parameter-passing mechanism
    guarantees not to disturb any register or other values, HLA sometimes generates
    more code than is actually needed to pass a byte parameter. For example, if you
    decide to pass the AL register as the byte parameter, HLA will emit code that
    pushes the EAX register onto the stack. This single push instruction is a very
    efficient way to pass AL as a 4-byte parameter object. On the other hand, if you
    decide to pass the AH register as the byte parameter, pushing EAX won''t work
    because this would leave the value in AH at offset EBP+9 in the activation record
    shown in [Figure 5-9](ch05s17.html#onebyteparm_activation_record "Figure 5-9. OneByteParm
    activation record"). Unfortunately, the procedure expects this value at offset
    EBP+8, so simply pushing EAX won''t do the job. If you pass AH, BH, CH, or DH
    as a byte parameter, HLA emits code like the following:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: As you can clearly see, passing one of the H registers as a byte parameter is
    less efficient than passing one of the L registers. So you should attempt to use
    the L registers whenever possible if passing an 8-bit register as a parameter.^([[92](#ftn.CHP-5-FN-23)])
    Note, by the way, that there is very little you can do about the efficiency issue,
    even if you manually pass the parameters.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'If the byte parameter you decide to pass is a variable rather than a register,
    HLA generates decidedly worse code. For example, suppose you call `OneByteParm`
    as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'For this call, HLA will emit code similar to the following to push this single-byte
    parameter:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: As you can plainly see, this is a lot of code to pass a single byte onto the
    stack! HLA emits this much code because (1) it guarantees not to disturb any registers,
    and (2) it doesn't know whether *`uns8Var`* is the last variable in allocated
    memory. You can generate much better code if you don't have to enforce either
    of these two constraints.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a spare 32-bit register lying around (especially one of EAX, EBX,
    ECX, or EDX), then you can pass a byte parameter onto the stack using only two
    instructions. Move (or move with zero/sign extension) the byte value into the
    register and then push the register onto the stack. For the current call to `OneByteParm`,
    the calling sequence would look like the following if EAX is available:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'If only ESI or EDI is available, you could use code like this:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Another trick you can use to pass the parameter with only a single `push` instruction
    is to coerce the byte variable to a double-word object. For example:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This last example is very efficient. Note that it pushes the first 3 bytes of
    whatever value happens to follow *`uns8Var`* in memory as the padding bytes. HLA
    doesn't use this technique because there is a (very tiny) chance that using this
    scheme will cause the program to fail. If it turns out that the *`uns8Var`* object
    is the last byte of a given page in memory and the next page of memory is unreadable,
    the `push` instruction will cause a memory access exception. To be on the safe
    side, the HLA compiler does not use this scheme. However, if you always ensure
    that the actual parameter you pass in this fashion is not the last variable you
    declare in a `static` section, then you can get away with code that uses this
    technique. Because it is nearly impossible for the byte object to appear at the
    last accessible address on the stack, it is probably safe to use this technique
    with `var` objects.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'When passing word parameters on the stack, you must also ensure that you include
    padding bytes so that each parameter consumes a multiple of 4 bytes. You can use
    the same techniques we use to pass bytes, except, of course, there are two valid
    bytes of data to pass instead of one. For example, you could use either of the
    following two schemes to pass a word object `w` to a `OneWordParm` procedure:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: When passing large objects by value on the stack (e.g., records and arrays),
    you do not have to ensure that each element or field of the object consumes a
    multiple of 4 bytes; all you need to do is ensure that the entire data structure
    consumes a multiple of 4 bytes on the stack. For example, if you have an array
    of ten 3-byte elements, the entire array will need 2 bytes of padding (10 * 3
    is 30 bytes, which is not divisible by 4, but 10 * 3 + 2 is 32, which is divisible
    by 4). HLA does a fairly good job of passing large data objects by value to a
    procedure. For larger objects, you should use the HLA high-level language procedure
    invocation syntax unless you have some special requirements. Of course, if you
    want efficient operation, you should try to avoid passing large data structures
    by value.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: By default, HLA guarantees that it won't disturb the values of any registers
    when it emits code to pass parameters to a procedure. Sometimes this guarantee
    isn't necessary. For example, if you are returning a function result in EAX and
    you are not passing a parameter to a procedure in EAX, there really is no reason
    to preserve EAX upon entry into the procedure. Rather than generating some crazy
    code like the following to pass a byte parameter,
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: HLA could generate much better code if it knows that it can use EAX (or some
    other register) as follows.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'You can use the `@use` procedure option to tell HLA that it can modify a register''s
    value if doing so would improve the code it generates when passing parameters.
    The syntax for this option is:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The *`reg32`* operand can be EAX, EBX, ECX, EDX, ESI, or EDI. You'll obtain
    the best results if this register is one of EAX, EBX, ECX, or EDX. You should
    note that you cannot specify EBP or ESP here (because the procedure already uses
    those registers).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: The `@use` procedure option tells HLA that it's okay to modify the value of
    the register you specify as an operand. Therefore, if HLA can generate better
    code by not preserving that register's value, it will do so. For example, when
    the `@use eax;` option is provided for the `OneByteParm` procedure given earlier,
    HLA will only emit the two instructions immediately above rather than the five-instruction
    sequence that preserves EAX.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: You must exercise care when specifying the `@use` procedure option. In particular,
    you should not be passing any parameters in the same register you specify in the
    `@use` option (because HLA may inadvertently scramble the parameter's value if
    you do this). Likewise, you must ensure that it's really okay for the procedure
    to change the register's value. As noted above, the best choice for an `@use`
    register is EAX when the procedure is returning a function result in EAX (because,
    clearly, the caller will not expect the procedure to preserve EAX).
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: If your procedure has a `forward` or `external` declaration (see [5.24 Units
    and the external Directive](ch05s24.html "5.24 Units and the external Directive")),
    the `@use` option must appear only in the `forward` or `external` definition,
    not in the actual procedure declaration. If no such procedure prototype appears,
    then you must attach the `@use` option to the procedure declaration.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'This call to `OneByteParm` emits the following instructions:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 5.17.3.3 Accessing Reference Parameters on the Stack
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because HLA passes the address for reference parameters, accessing the reference
    parameters within a procedure is slightly more difficult than accessing value
    parameters because you have to dereference the pointers to the reference parameters.
    Unfortunately, HLA's high-level syntax for procedure declarations and invocations
    does not (and cannot) abstract this detail away for you. You will have to manually
    dereference these pointers yourself. This section reviews how you do this.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 5-16](ch05s17.html#accessing_a_reference_parameter "Example 5-16. Accessing
    a reference parameter") the `RefParm` procedure has a single pass-by-reference
    parameter. A pass-by-reference parameter is always a pointer to an object of the
    type specified by the parameter's declaration. Therefore, `theParameter` is actually
    an object of type `pointer to uns32` rather than an `uns32` value. In order to
    access the value associated with `theParameter`, this code has to load that double-word
    address into a 32-bit register and access the data indirectly. The `mov( theParameter,
    eax );` instruction in [Example 5-16](ch05s17.html#accessing_a_reference_parameter
    "Example 5-16. Accessing a reference parameter") fetches this pointer into the
    EAX register, and then procedure `RefParm` uses the `[eax]` addressing mode to
    access the actual value of `theParameter`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-16. Accessing a reference parameter
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Because this procedure accesses the data of the actual parameter, adding 2 to
    this data affects the values of the variables passed to the `RefParm` procedure
    from the main program. Of course, this should come as no surprise because these
    are the standard semantics for pass-by-reference parameters.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, accessing (small) pass-by-reference parameters is a little less
    efficient than accessing value parameters because you need an extra instruction
    to load the address into a 32-bit pointer register (not to mention you have to
    reserve a 32-bit register for this purpose). If you access reference parameters
    frequently, these extra instructions can really begin to add up, reducing the
    efficiency of your program. Furthermore, it's easy to forget to dereference a
    reference parameter and use the address of the value in your calculations (this
    is especially true when passing double-word parameters, like the `uns32` parameter
    in the example above, to your procedures). Therefore, unless you really need to
    affect the value of the actual parameter, you should use pass by value to pass
    small objects to a procedure.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: Passing large objects, like arrays and records, is where using reference parameters
    becomes efficient. When passing these objects by value, the calling code has to
    make a copy of the actual parameter; if the actual parameter is a large object,
    the copy process can be very inefficient. Because computing the address of a large
    object is just as efficient as computing the address of a small scalar object,
    there is no efficiency loss when passing large objects by reference. Within the
    procedure, you must still dereference the pointer to access the object, but the
    efficiency loss due to indirection is minimal when you contrast this with the
    cost of copying that large object. The program in [Example 5-17](ch05s17.html#passing_an_array_of_records_by_referenci
    "Example 5-17. Passing an array of records by referencing") demonstrates how to
    use pass by reference to initialize an array of records.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-17. Passing an array of records by referencing
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: As you can see from this example, passing large objects by reference is relatively
    efficient. Other than tying up the EDX register throughout the `RefArrayParm`
    procedure, plus a single instruction to load EDX with the address of the reference
    parameter, the `RefArrayParm` procedure doesn't require many more instructions
    than the same procedure where you would pass the parameter by value.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: 5.17.3.4 Passing Reference Parameters on the Stack
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HLA's high-level syntax often makes passing reference parameters a breeze. All
    you need to do is specify the name of the actual parameter you wish to pass in
    the procedure's parameter list. HLA will automatically emit some code that will
    compute the address of the specified actual parameter and push this address onto
    the stack. However, like the code HLA emits for value parameters, the code HLA
    generates to pass the address of the actual parameter on the stack may not be
    the most efficient possible. Therefore, if you want to write fast code, you may
    want to manually write the code to pass reference parameters to a procedure. This
    section discusses how to do exactly that.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever you pass a static object as a reference parameter, HLA generates very
    efficient code to pass the address of that parameter to the procedure. As an example,
    consider the following code fragment:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'For the call to the `HasRefParm` procedure, HLA emits the following instruction
    sequence:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: You really aren't going to be able to do substantially better than this if you
    are passing your reference parameters on the stack. So if you're passing static
    objects as reference parameters, HLA generates fairly good code, and you should
    stick with the high-level syntax for the procedure call.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, when passing automatic (`var`) objects or indexed variables
    as reference parameters, HLA needs to compute the address of the object at runtime.
    This may require the use of the `lea` instruction. Unfortunately, the `lea` instruction
    requires a 32-bit register, and HLA promises not to disturb the values in any
    registers when it automatically generates code for you.^([[93](#ftn.CHP-5-FN-24)])
    Therefore, HLA needs to preserve the value in whatever register it uses when it
    computes an address via `lea` to pass a parameter by reference. The following
    example shows you the code that HLA actually emits:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: As you can see, this is quite a bit of code, especially if you have a 32-bit
    register available and you don't need to preserve that register's value. The following
    is a better code sequence given the availability of EAX.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Remember, when passing an actual parameter by reference, you must compute the
    address of that object and push the address onto the stack. For simple static
    objects you can use the address-of operator (`&`) to easily compute the address
    of the object and push it onto the stack; however, for indexed and automatic objects,
    you will probably need to use the `lea` instruction to compute the address of
    the object. Here are some examples that demonstrate this using the `HasRefParm`
    procedure from the previous examples:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'If you have an extra register to spare, you can tell HLA to use that register
    when computing the address-of reference parameters (without emitting the code
    to preserve that register''s value). The `@use` option will tell HLA that it''s
    okay to use the specified register without preserving its value. As noted in the
    section on value parameters, the syntax for this procedure option is:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: where *`reg32`* may be any of EAX, EBX, ECX, EDX, ESI, or EDI. Because reference
    parameters always pass a 32-bit value, all of these registers are equivalent as
    far as HLA is concerned (unlike value parameters that may prefer the EAX, EBX,
    ECX, or EDX register). Your best choice would be EAX if the procedure is not passing
    a parameter in the EAX register and the procedure is returning a function result
    in EAX; otherwise, any currently unused register will work fine.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: With the `@use eax`; option, HLA emits the shorter code given in the previous
    examples. It does not emit all the extra instructions needed to preserve EAX's
    value. This makes your code much more efficient, especially when passing several
    parameters by reference or when calling procedures with reference parameters several
    times.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 5.17.3.5 Passing Formal Parameters as Actual Parameters
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The examples in the previous two sections show how to pass static and automatic
    variables as parameters to a procedure, either by value or by reference. There
    is one situation that these examples don''t handle properly: the case when you
    are passing a formal parameter in one procedure as an actual parameter to another
    procedure. The following simple example demonstrates the different cases that
    can occur for pass-by-value and pass-by-reference parameters:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: In the statement labeled `(1)` above, procedure `p2` calls procedure `p1` and
    passes its two formal parameters as parameters to `p1`. Note that this code passes
    the first parameter of both procedures by value, and it passes the second parameter
    of both procedures by reference. Therefore, in statement `(1)`, the program passes
    the `v2` parameter into `p2` by value and passes it on to `p1` by value; likewise,
    the program passes `r2` in by reference and it passes the value onto `p1` by reference.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `p2`''s caller passes `v2` in by value and `p2` passes this parameter
    to `p1` by value, all the code needs to do is make a copy of `v2`''s value and
    pass this on to `p1`. The code to do this is nothing more than a single `push`
    instruction. For example:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: As you can see, this code is identical to passing an automatic variable by value.
    Indeed, it turns out that the code you need to write to pass a value parameter
    to another procedure is identical to the code you would write to pass a local
    automatic variable to that other procedure.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing `r2` in statement `(1)` above requires a little more thought. You do
    not take the address of `r2` using the `lea` instruction as you would a value
    parameter or an automatic variable. When passing `r2` on through to `p1`, the
    author of this code probably expects the `r` formal parameter to contain the address
    of the variable whose address `p2`''s caller passed into `p2`. In plain English,
    this means that `p2` must pass the address of `r2`''s actual parameter on through
    to `p1`. Because the `r2` parameter is a double-word value containing the address
    of the corresponding actual parameter, this means that the code must pass the
    double-word value of `r2` on to `p1`. The complete code for statement `(1)` above
    looks like the following:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The important thing to note in this example is that passing a formal reference
    parameter (`r2`) as an actual reference parameter (`r`) does not involve taking
    the address of the formal parameter (`r2`). `p2`'s caller has already done this;
    `p2` simply passes this address on through to `p1`.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: In the second call to `p1` in the example above (`2`), the code swaps the actual
    parameters so that the call to `p1` passes `r2` by value and `v2` by reference.
    Specifically, `p1` expects `p2` to pass it the value of the double-word object
    associated with `r2`; likewise, it expects `p2` to pass it the address of the
    value associated with `v2`.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: 'To pass the value of the object associated with `r2`, your code must dereference
    the pointer associated with `r2` and directly pass the value. Here is the code
    HLA automatically generates to pass `r2` as the first parameter to `p1` in statement
    `(2)`:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'As usual, HLA generates a little more code than may be necessary because it
    won''t destroy the value in the EAX register (you may use the `@use` procedure
    option to tell HLA that it''s okay to use EAX''s value, thereby reducing the code
    it generates). You can write more efficient code if a register is available to
    use in this sequence. If EAX is unused, you could trim this down to the following:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Because you can treat value parameters exactly like local (automatic) variables,
    you use the same code to pass `v2` by reference to `p1` as you would to pass a
    local variable in `p2` to `p1`. Specifically, you use the `lea` instruction to
    compute the address of the value in the `v2`. The code HLA automatically emits
    for statement `(2)` above preserves all registers and takes the following form
    (same as passing an automatic variable by reference):'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Of course, if you have a register available, you can improve on this code.
    Here''s the complete code that corresponds to statement `(2)` above:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 5.17.3.6 HLA Hybrid Parameter-Passing Facilities
  id: totrans-492
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like control structures, HLA provides a high-level language syntax for procedure
    calls that is convenient to use and easy to read. However, this high-level language
    syntax is sometimes inefficient and may not provide the capabilities you need
    (for example, you cannot specify an arithmetic expression as a value parameter
    as you can in high-level languages). HLA lets you overcome these limitations by
    writing low-level ("pure") assembly language code. Unfortunately, low-level code
    is harder to read and maintain than procedure calls that use high-level syntax.
    Furthermore, it's quite possible that HLA generates perfectly fine code for certain
    parameters, while only one or two parameters present a problem. Fortunately, HLA
    provides a hybrid syntax for procedure calls that allows you to use both high-level
    and low-level syntax as appropriate for a given actual parameter. This lets you
    use high-level syntax where appropriate and then drop down into pure assembly
    language to pass those special parameters that HLA's high-level language syntax
    cannot handle efficiently (if at all).
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'Within an actual parameter list (using the high-level language syntax), if
    HLA encounters `#{` followed by a sequence of statements and a closing `}#`, HLA
    will substitute the instructions between the braces in place of the code it would
    normally generate for that parameter. For example, consider the following code
    fragment:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The call to `HybridCall` immediately above is equivalent to the following "pure"
    assembly language code.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'As a second example, consider the example from the previous section:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: HLA generates exceedingly mediocre code for the second call to `p1` in this
    example. If efficiency is important in the context of this procedure call, and
    you have a free register available, you might want to rewrite this code as follows:^([[94](#ftn.CHP-5-FN-25)])
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Note that specifying the `@use reg;` option tells HLA that the register is always
    available for use wherever you call a procedure. If there is one case where the
    procedure's invocation must preserve the specified register, then you cannot use
    the `@use` option to generate better code. However, you may use the hybrid parameter-passing
    mechanism on a case-by-base basis to improve the performance of those particular
    calls.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: 5.17.3.7 Mixing Register and Stack-Based Parameters
  id: totrans-503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can mix register parameters and standard (stack-based) parameters in the
    same high-level procedure declaration. For example:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: When constructing the activation record, HLA ignores the parameters you pass
    in registers and processes only those parameters you pass on the stack. Therefore,
    a call to the `HasBothRegAndStack` procedure will push only a single parameter
    onto the stack (`count`). It will pass the `dest` parameter in the EDI register.
    When this procedure returns to its caller, it will remove only 4 bytes of parameter
    data from the stack.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: Note that when you pass a parameter in a register, you should avoid specifying
    that same register in the `@use` procedure option. In the example above, HLA might
    not generate any code whatsoever at all for the `dest` parameter (because the
    value is already in EDI). Had you specified `@use edi;` and HLA decided it was
    okay to disturb EDI's value, this would destroy the parameter value in EDI; that
    won't actually happen in this particular example (because HLA never uses a register
    to pass a double-word value parameter like `count`), but keep this issue in mind.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: ^([[87](#CHP-5-FN-18)]) The choice of instructions is dictated by whether `x`
    is a static variable (`mov` for static objects, `lea` for other objects).
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: ^([[88](#CHP-5-FN-19)]) This is especially true if the parameter list changes
    frequently.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: ^([[89](#CHP-5-FN-20)]) This assumes, of course, that you don't instruct HLA
    otherwise. It is possible to tell HLA to reverse the order of the parameters on
    the stack. See the electronic edition for more details.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: ^([[90](#CHP-5-FN-21)]) Note that if you use the `exit` statement to exit a
    procedure, you must duplicate the code to pop the register values and place this
    code immediately before the `exit` clause. This is a good example of a maintenance
    nightmare and is also a good reason why you should have only one exit point in
    your program.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: ^([[91](#CHP-5-FN-22)]) This applies only if you use the HLA high-level-language
    syntax to declare and access parameters in your procedures. Of course, if you
    manually push the parameters yourself and you access the parameters inside the
    procedure using an addressing mode like `[ebp+8]`, then you can pass any size
    object you choose. Of course, keep in mind that most operating systems expect
    the stack to be dword aligned, so parameters you push should be a multiple of
    4 bytes long.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: ^([[92](#CHP-5-FN-23)]) Or better yet, pass the parameter directly in the register
    if you are writing the procedure yourself.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: ^([[93](#CHP-5-FN-24)]) This isn't entirely true. You'll see the exception in
    [Chapter 12](ch12.html "Chapter 12. CLASSES AND OBJECTS"). Also, using the @use
    procedure option tells HLA that it's okay to modify the value in one of the registers.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: ^([[94](#CHP-5-FN-25)]) Of course, you could also use the `@use eax`; procedure
    option to achieve the same effect in this example.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: 5.18 Procedure Pointers
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The 80x86 `call` instruction allows three basic forms: direct calls (via a
    procedure name), indirect calls through a 32-bit general-purpose register, and
    indirect calls through a double-word pointer variable. The `call` instruction
    supports the following (low-level) syntax:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The first form we've been using throughout this chapter, so there is little
    need to discuss it here. The second form, the register indirect call, calls the
    procedure whose address is held in the specified 32-bit register. The address
    of a procedure is the byte address of the first instruction to execute within
    that procedure. Remember, on a Von Neumann architecture machine (like the 80x86),
    the system stores machine instructions in memory along with other data. The CPU
    fetches the instruction opcode values from memory prior to executing them. When
    you execute the register indirect `call` instruction, the 80x86 first pushes the
    return address onto the stack and then begins fetching the next opcode byte (instruction)
    from the address specified by the register's value.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: The third form of the call instruction above fetches the address of some procedure's
    first instruction from a double-word variable in memory. Although this instruction
    suggests that the call uses the displacement-only addressing mode, you should
    realize that any legal memory addressing mode is legal here; for example, `call(
    procPtrTable[ebx*4] );` is perfectly legitimate; this statement fetches the double
    word from the array of double words (`procPtrTable`) and calls the procedure whose
    address is the value contained within that double word.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA treats procedure names like static objects. Therefore, you can compute
    the address of a procedure by using the address-of (`&`) operator along with the
    procedure''s name or by using the `lea` instruction. For example, `&Procname`
    is the address of the very first instruction of the `Procname` procedure. So all
    three of the following code sequences wind up calling the `Procname` procedure:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Because the address of a procedure fits in a 32-bit object, you can store such
    an address into a double-word variable; in fact, you can initialize a double-word
    variable with the address of a procedure using code like the following:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Because the use of procedure pointers occurs frequently in assembly language
    programs, HLA provides a special syntax for declaring procedure pointer variables
    and for calling procedures indirectly through such pointer variables. To declare
    a procedure pointer in an HLA program, you can use a variable declaration like
    the following:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Note that this syntax uses the keyword `procedure` as a data type. It follows
    the variable name and a colon in one of the variable declaration sections (`static`,
    `readonly`, `storage`, or `var`). This sets aside exactly 4 bytes of storage for
    the *`procPtr`* variable. To call the procedure whose address is held by *`procPtr`*,
    you can use either of the following two forms:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Note that the high-level syntax for an indirect procedure call is identical
    to the high-level syntax for a direct procedure call. HLA can figure out whether
    to use a direct call or an indirect call by the type of the identifier. If you've
    specified a variable name, HLA assumes it needs to use an indirect call; if you
    specify a procedure name, HLA uses a direct call.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: 'Like all pointer objects, you should not attempt to indirectly call a procedure
    through a pointer variable unless you''ve initialized that variable with an appropriate
    address. There are two ways to initialize a procedure pointer variable: `static`
    and `readonly` objects allow an initializer, or you can compute the address of
    a routine (as a 32-bit value) and store that 32-bit address directly into the
    procedure pointer at runtime. The following code fragment demonstrates both ways
    you can initialize a procedure pointer:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Procedure pointer variable declarations also allow the declaration of parameters.
    To declare a procedure pointer with parameters, you must use a declaration like
    the following:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'This declaration states that `p` is a 32-bit pointer that contains the address
    of a procedure requiring two parameters. If desired, you could also initialize
    this variable `p` with the address of some procedure by using a static initializer.
    For example:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Note that *`SomeProcedure`* must be a procedure whose parameter list exactly
    matches `p`''s parameter list (i.e., two value parameters, the first is an `int32`
    parameter and the second is a `char` parameter). To indirectly call this procedure,
    you could use either of the following sequences:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: or
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The high-level language syntax has the same features and restrictions as the
    high-level syntax for a direct procedure call. The only difference is the actual
    `call` instruction HLA emits at the end of the calling sequence.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: 'Although all the examples in this section use `static` variable declarations,
    don''t get the idea that you can declare simple procedure pointers only in the
    `static` or other variable declaration sections. You can also declare procedure
    pointer types in the `type` section, and you can declare procedure pointers as
    fields of a `record` or a `union`. Assuming you create a type name for a procedure
    pointer in the `type` section, you can even create arrays of procedure pointers.
    The following code fragments demonstrate some of the possibilities:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: One very important thing to keep in mind when using procedure pointers is that
    HLA does not (and cannot) enforce strict type checking on the pointer values you
    assign to a procedure pointer variable. In particular, if the parameter lists
    do not agree between the declarations of the pointer variable and the procedure
    whose address you assign to the pointer variable, the program will probably crash
    when you attempt to call the mismatched procedure indirectly through the pointer
    using the high-level syntax. Like the low-level "pure" procedure calls, it is
    your responsibility to ensure that the proper number and types of parameters are
    on the stack prior to the call.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: 5.19 Procedural Parameters
  id: totrans-545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One place where procedure pointers are quite invaluable is in parameter lists.
    Selecting one of several procedures to call by passing the address of some procedure
    is a common operation. Therefore, HLA lets you declare procedure pointers as parameters.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: 'There is nothing special about a procedure parameter declaration. It looks
    exactly like a procedure variable declaration except it appears within a parameter
    list rather than within a variable declaration section. The following are some
    typical procedure prototypes that demonstrate how to declare such parameters:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The last example above is identical to the first. It does point out, though,
    that you generally pass procedural parameters by value. This may seem counterintuitive
    because procedure pointers are addresses and you will need to pass an address
    as the actual parameter; however, a pass-by-reference procedure parameter means
    something else entirely. Consider the following (legal!) declaration:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: This declaration tells HLA that you are passing a procedure *variable* by reference
    to `p4`. The address HLA expects must be the address of a procedure pointer variable,
    not a procedure.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: When passing a procedure pointer by value, you may specify either a procedure
    variable (whose value HLA passes to the actual procedure) or a procedure pointer
    constant. A procedure pointer constant consists of the address-of operator (`&`)
    immediately followed by a procedure name. Passing procedure constants is probably
    the most convenient way to pass procedural parameters. For example, the following
    calls to the `Plot` routine might plot out the function passed as a parameter
    from −2 to +2.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Note that you cannot pass a procedure as a parameter by simply specifying the
    procedure''s name. That is, `Plot( sineFunc )`; will not work. Simply specifying
    the procedure name doesn''t work because HLA will attempt to directly call the
    procedure whose name you specify (remember, a procedure name inside a parameter
    list invokes instruction composition). If you did not specify a parameter list—or
    at least an empty pair of parentheses—after the parameter/procedure''s name, HLA
    would generate a syntax error message. Moral of the story: Don''t forget to preface
    procedure parameter constant names with the address-of operator (`&`).'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: 5.20 Untyped Reference Parameters
  id: totrans-555
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you will want to write a procedure to which you pass a generic memory
    object by reference without regard to the type of that memory object. A classic
    example is a procedure that zeros out some data structure. Such a procedure might
    have the following prototype:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'This procedure would zero out `count` bytes starting at the address the first
    parameter specifies. The problem with this procedure prototype is that HLA will
    complain if you attempt to pass anything other than a byte object as the first
    parameter. Of course, you can overcome this problem using type coercion like the
    following, but if you call this procedure several times with a lot of different
    data types, then the following coercion operator is rather tedious to use:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Of course, you can always use hybrid parameter passing or manually push the
    parameters yourself, but these solutions are even more tedious than using the
    type coercion operation. Fortunately, HLA provides a convenient solution: untyped
    reference parameters.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: 'Untyped reference parameters are exactly that—pass-by-reference parameters
    for which HLA doesn''t bother to compare the type of the actual parameter against
    the type of the formal parameter. With an untyped reference parameter, the call
    to `ZeroMem` above would take the following form:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '`MyDataObject` could be any type, and multiple calls to `ZeroMem` could pass
    different typed objects without any objections from HLA.'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare an untyped reference parameter, you specify the parameter using
    the normal syntax except that you use the reserved word `var` in place of the
    parameter''s type. This `var` keyword tells HLA that any variable object is legal
    for that parameter. Note that you must pass untyped reference parameters by reference,
    so the `var` keyword must precede the parameter''s declaration as well. Here''s
    the correct declaration for the `ZeroMem` procedure using an untyped reference
    parameter:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: With this declaration, HLA will compute the address of whatever memory object
    you pass as an actual parameter to `ZeroMem` and pass this on the stack.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: 5.21 Managing Large Programs
  id: totrans-567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most assembly language source files are not standalone programs. In general,
    you will call various standard library or other routines that are not defined
    in your main program. For example, you've probably noticed by now that the 80x86
    doesn't provide any machine instructions like `read`, `write`, or `put` for doing
    I/O operations. Of course, you can write your own procedures to accomplish this.
    Unfortunately, writing such routines is a complex task, and beginning assembly
    language programmers are not ready for such tasks. That's where the HLA Standard
    Library comes in. This is a package of procedures you can call to perform simple
    I/O operations like `stdout.put`.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: The HLA Standard Library contains hundreds of thousands of lines of source code.
    Imagine how difficult programming would be if you had to merge these hundreds
    of thousands of lines of code into your simple programs! Imagine how slow compiling
    your programs would be if you had to compile those hundreds of thousands of lines
    with each program you write. Fortunately, you don't have to do this.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: For small programs, working with a single source file is fine. For large programs,
    this gets very cumbersome (consider the example above of having to include the
    entire HLA Standard Library into each of your programs). Furthermore, once you've
    debugged and tested a large section of your code, continuing to assemble that
    same code when you make a small change to some other part of your program is a
    waste of time. The HLA Standard Library, for example, takes several minutes to
    assemble, even on a fast machine. Imagine having to wait 20 or 30 minutes on a
    fast PC to assemble a program to which you've made a one-line change!
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: As for high-level languages, the solution is *separate compilation*. First,
    you break up your large source files into manageable chunks. Then you compile
    the separate files into object code modules. Finally, you link the object modules
    together to form a complete program. If you need to make a small change to one
    of the modules, you only need to reassemble that one module; you do not need to
    reassemble the entire program.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: The HLA Standard Library works in precisely this way. The Standard Library is
    already compiled and ready to use. You simply call routines in the Standard Library
    and link your code with the Standard Library using a *linker* program. This saves
    considerable time when developing a program that uses the Standard Library code.
    Of course, you can easily create your own object modules and link them together
    with your code. You could even add new routines to the Standard Library so they
    will be available for use in future programs you write.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '"Programming in the large" is the term software engineers have coined to describe
    the processes, methodologies, and tools for handling the development of large
    software projects. While everyone has their own idea of what "large" is, separate
    compilation is one of the more popular techniques that support "programming in
    the large." The following sections describe the tools HLA provides for separate
    compilation and how to effectively employ these tools in your programs.'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '5.22 The #include Directive'
  id: totrans-574
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `#include` directive, when encountered in a source file, switches program
    input from the current file to the file specified in the parameter list of the
    `#include` directive. This allows you to construct text files containing common
    constants, types, source code, and other HLA items and include such files into
    the assembly of several separate programs. The syntax for the `#include` directive
    is:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '*`Filename`* must be a valid filename. HLA merges the specified file into the
    compilation at the point of the `#include` directive. Note that you can nest `#include`
    statements inside files you include. That is, a file being included into another
    file during assembly may itself include a third file. In fact, the *stdlib.hhf*
    header file you see in most example programs is really nothing more than a bunch
    of `#include` statements (see [Example 5-18](ch05s22.html#the_original_stdlib.hhf_header_file
    "Example 5-18. The original stdlib.hhf header file") for the original *stdlib.hhf*
    source code; note that this file is considerably different today, but the concept
    is still the same).'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-18. The original *stdlib.hhf* header file
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: By including *stdlib.hhf* in your source code, you automatically include all
    the HLA library modules. It's often more efficient (in terms of compile time and
    size of code generated) to provide only those `#include` statements for the modules
    you actually need in your program. However, including *stdlib.hhf* is extremely
    convenient and takes up less space in this text, which is why most programs appearing
    in this text use *stdlib.hhf*.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `#include` directive does not need to end with a semicolon. If
    you put a semicolon after the `#include`, that semicolon becomes part of the source
    file and is the first character following the included source during compilation.
    HLA generally allows spare semicolons in various parts of the program, so you
    will sometimes see an `#include` statement ending with a semicolon. In general,
    though, you should not get in the habit of putting semicolons after `#include`
    statements because there is the slight possibility this could create a syntax
    error in certain circumstances.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `#include` directive by itself does not provide separate compilation.
    You *could* use the `#include` directive to break up a large source file into
    separate modules and join these modules together when you compile your file. The
    following example would include the `printf.hla` and `putc.hla` files during the
    compilation of your program:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Now your program `will` benefit from the modularity gained by this approach.
    Alas, you will not save any development time. The `#include` directive inserts
    the source file at the point of the `#include` during compilation, exactly as
    though you had typed that code yourself. HLA still has to compile the code, and
    that takes time. Were you to include all the files for the Standard Library routines
    in this manner, your compilations would take *forever*.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: In general, you should *not* use the `#include` directive to include source
    code as shown above.^([[95](#ftn.CHP-5-FN-26)]) Instead, you should use the `#include`
    directive to insert a common set of constants, types, external procedure declarations,
    and other such items into a program. Typically an assembly language include file
    does *not* contain any machine code (outside of a macro; see [Chapter 9](ch09.html
    "Chapter 9. MACROS AND THE HLA COMPILE-TIME LANGUAGE") for details). The purpose
    of using `#include` files in this manner will become clearer after you see how
    the external declarations work.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: ^([[95](#CHP-5-FN-26)]) There is nothing wrong with this, other than the fact
    that it does not take advantage of separate compilation.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: '5.23 Ignoring Duplicate #include Operations'
  id: totrans-588
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you begin to develop sophisticated modules and libraries, you eventually
    discover a big problem: Some header files will need to include other header files
    (e.g., the *stdlib.hhf* header file includes all the other Standard Library header
    files). Well, this isn''t actually a big problem, but a problem will occur when
    one header file includes another, and that second header file includes another,
    and that third header file includes another, and . . . that last header file includes
    the first header file. Now *this* is a big problem.'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: There are two problems with a header file indirectly including itself. First,
    this creates an infinite loop in the compiler. The compiler will happily go on
    about its business including all these files over and over again until it runs
    out of memory or some other error occurs. Clearly this is not a good thing. The
    second problem that occurs (usually before the first problem) is that the second
    time HLA includes a header file, it starts complaining bitterly about duplicate
    symbol definitions. After all, the first time it reads the header file it processes
    all the declarations in that file; the second time around it views all those symbols
    as duplicate symbols.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA provides a special include directive that eliminates this problem: `#includeonce`.
    You use this directive exactly like you use the `#include` directive. For example:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: If *myHeaderFile.hhf* directly or indirectly includes itself (with a `#includeonce`
    directive), then HLA will ignore the new request to include the file. Note, however,
    that if you use the `#include` directive, rather than `#includeonce`, HLA will
    include the file a second time. This was done in case you really do need to include
    a header file twice.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom line is this: You should always use the `#includeonce` directive
    to include header files you''ve created. In fact, you should get in the habit
    of always using `#includeonce`, even for header files created by others (the HLA
    Standard Library already has provisions to prevent recursive includes, so you
    don''t have to worry about using `#includeonce` with the Standard Library header
    files).'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: There is another technique you can use to prevent recursive includes—using conditional
    compilation. [Chapter 9](ch09.html "Chapter 9. MACROS AND THE HLA COMPILE-TIME
    LANGUAGE"), the chapter on macros and the HLA Compile-Time Language, discusses
    this option.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: 5.24 Units and the external Directive
  id: totrans-596
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Technically, the `#include` directive provides you with all the facilities
    you need to create modular programs. You can create several modules, each containing
    some specific routine, and include those modules, as necessary, in your assembly
    language programs using `#include`. However, HLA provides a better way: external
    and public symbols.'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: One major problem with the `#include` mechanism is that once you've debugged
    a routine, including it into a compilation still wastes time because HLA must
    recompile bug-free code every time you assemble the main program. A much better
    solution would be to preassemble the debugged modules and link the object code
    modules together. This is what the `external` directive allows you to do.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `external` facilities, you must create at least two source files.
    One file contains a set of variables and procedures used by the second. The second
    file uses those variables and procedures without knowing how they''re implemented.
    The only problem is that if you create two separate HLA programs, the linker will
    get confused when you try to combine them. This is because both HLA programs have
    their own main program. Which main program does the OS run when it loads the program
    into memory? To resolve this problem, HLA uses a different type of compilation
    module, the `unit`, to compile programs without a main program. The syntax for
    an HLA `unit` is actually simpler than that for an HLA program; it takes the following
    form:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: With one exception (the `var` section), anything that can go in the declaration
    section of an HLA `program` can go into the declaration section of an HLA `unit`.
    Notice that a `unit` does not have a `begin` clause and there are no program statements
    in the unit;^([[96](#ftn.CHP-5-FN-27)]) a unit contains only declarations.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the fact that a unit does not contain a main program section,
    there is one other difference between units and programs. Units cannot have a
    `var` section. This is because the `var` section declares automatic variables
    that are local to the main program's source code. Because there is no "main program"
    associated with a unit, `var` sections are illegal.^([[97](#ftn.CHP-5-FN-28)])
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate, consider the two modules in [Example 5-19](ch05s24.html#example_of_a_simple_hla_unit
    "Example 5-19. Example of a simple HLA unit") and [Example 5-20](ch05s24.html#main_program_that_references_external_ob
    "Example 5-20. Main program that references external objects").
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-19. Example of a simple HLA unit
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Example 5-20. Main program that references external objects
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: The main program references `Var1`, `Var2`, and `Add1and2`, yet these symbols
    are external to this program (they appear in unit `Number1`). If you attempt to
    compile the main program as it stands, HLA will complain that these three symbols
    are undefined.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, you must declare them external with the `external` option. An external
    procedure declaration looks just like a forward declaration except you use the
    reserved word `external` rather than `forward`. To declare external static variables,
    simply follow those variables' declarations with the reserved word `external`.
    The program in [Example 5-21](ch05s24.html#modified_main_program_with_external_decl
    "Example 5-21. Modified main program with external declarations") is a modification
    to the program in [Example 5-20](ch05s24.html#main_program_that_references_external_ob
    "Example 5-20. Main program that references external objects") that includes the
    external declarations.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-21. Modified main program with external declarations
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: If you attempt to compile this second version of `main` using the typical HLA
    compilation command `HLA main2.hla`, you will be somewhat disappointed. This program
    will actually compile without error. However, when HLA attempts to link this code
    it will report that the symbols `Var1`, `Var2`, and `Add1and2` are undefined.
    This happens because you haven't compiled and linked in the associated unit with
    this main program. Before you try that and discover that it still doesn't work,
    you should know that all symbols in a unit, by default, are *private* to that
    unit. This means that those symbols are inaccessible in code outside that unit
    unless you explicitly declare those symbols as *public* symbols. To declare symbols
    as public, you simply put external declarations for those symbols in the unit
    before the actual symbol declarations. If an external declaration appears in the
    same source file as the actual declaration of a symbol, HLA assumes that the name
    is needed externally and makes that symbol a public (rather than private) symbol.
    The unit in [Example 5-22](ch05s24.html#correct_number1_unit_with_external_decla
    "Example 5-22. Correct Number1 unit with external declarations") is a correction
    to the `Number1` unit that properly declares the external objects.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-22. Correct `Number1` unit with external declarations
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: It may seem redundant declaring these symbols twice as occurs in [Example 5-21](ch05s24.html#modified_main_program_with_external_decl
    "Example 5-21. Modified main program with external declarations") and [Example 5-22](ch05s24.html#correct_number1_unit_with_external_decla
    "Example 5-22. Correct Number1 unit with external declarations"), but you'll soon
    see that you don't normally write the code this way.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: If you attempt to compile the `main` program or the `Number1` unit using the
    typical HLA statement, that is,
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'you''ll quickly discover that the linker still returns errors. It returns an
    error on the compilation of *main2.hla* because you still haven''t told HLA to
    link in the object code associated with *unit2.hla*. Likewise, the linker complains
    if you attempt to compile `unit2.hla` by itself because it can''t find a main
    program. The simple solution is to compile both of these modules together with
    the following single command:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: This command will properly compile both modules and link together their object
    code.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the command above defeats one of the major benefits of separate
    compilation. When you issue this command it will compile both `main2` and `unit2`
    prior to linking them together. Remember, a major reason for separate compilation
    is to reduce compilation time on large projects. While the above command is convenient,
    it doesn't achieve this goal.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: 'To separately compile the two modules you must run HLA separately on them.
    Of course, you saw earlier that attempting to compile these modules separately
    produced linker errors. To get around this problem, you need to compile the modules
    without linking them. The `-c` (compile-only) HLA command-line option achieves
    this. To compile the two source files without running the linker, you would use
    the following commands:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'This produces two object code files, `main2.obj` and `unit2.obj`, that you
    can link together to produce a single executable. You could run the linker program
    directly, but an easier way is to use the HLA compiler to link the object modules
    together for you:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Under Windows, this command produces an executable file named *main2.exe*;^([[98](#ftn.CHP-5-FN-29)])
    under Linux, Mac OS X, and FreeBSD this command produces a file named *main2*.
    You could also type the following command to compile the main program and link
    it with a previously compiled *unit2* object module:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'In general, HLA looks at the suffixes of the filenames following the HLA commands.
    If the filename doesn''t have a suffix, HLA assumes it to be *.HLA*. If the filename
    has a suffix, then HLA will do the following with the file:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: If the suffix is *.HLA*, HLA will compile the file with the HLA compiler.
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the suffix is *.ASM*, HLA will assemble the file with MASM (or some other
    default assembler such as FASM, NASM, or TASM under Windows) or Gas (Linux/Mac
    OS X/FreeBSD).
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the suffix is .*OBJ* or .*LIB* (Windows), or .*o* or .*a* (Linux/Mac OS X/FreeBSD),
    then HLA will link that module with the rest of the compilation.
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.24.1 Behavior of the external Directive
  id: totrans-632
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whenever you declare a symbol using the `external` directive, keep in mind
    several limitations of `external` objects:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: Only one `external` declaration of an object may appear in a given source file.
    That is, you cannot define the same symbol twice as an `external` object.
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only `procedure`, `static`, `readonly`, and `storage` variable objects can be
    external. `var`, `type`, `const`, and parameter objects cannot be external.
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`external` objects must appear at the global declaration level. You cannot
    declare `external` objects within a procedure or other nested structure.^([[99](#ftn.CHP-5-FN-30)])'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`external` objects publish their name globally. Therefore, you must carefully
    choose the names of your `external` objects so they do not conflict with other
    symbols.'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This last point is especially important to keep in mind. HLA links your modules
    using a linker. At each step in this process, your choice of external names could
    create problems for you.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following HLA external/public declaration:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: When you compile a program containing these declarations, HLA automatically
    generates a "munged" name for the `localObject` variable that probably won't ever
    have any conflicts with system-global external symbols.^([[100](#ftn.CHP-5-FN-31)])
    Whenever you declare an external symbol, however, HLA uses the object's name as
    the default external name. This can create some problems if you inadvertently
    use some global name as your variable name.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: 'To get around the problem of conflicting external names, HLA supports an additional
    syntax for the `external` option that lets you explicitly specify the external
    name. The following example demonstrates this extended syntax:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: If you follow the `external` keyword with a string constant enclosed by parentheses,
    HLA will continue to use the declared name (`c` in this example) as the identifier
    within your HLA source code. Externally (i.e., in the assembly code) HLA will
    substitute the name `var_c` whenever you reference `c`. This feature helps you
    avoid problems with the misuse of assembler reserved words, or other global symbols,
    in your HLA programs.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: 'You should also note that this feature of the `external` option lets you create
    *aliases*. For example, you may want to refer to an object by the name `StudentCount`
    in one module while referring to the object as `PersonCount` in another module
    (you might do this because you have a general library module that deals with counting
    people and you want to use the object in a program that deals only with students).
    Using a declaration like the following lets you do this:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Of course, you've already seen some of the problems you might encounter when
    you start creating aliases. So you should use this capability sparingly in your
    programs. Perhaps a more reasonable use of this feature is to simplify certain
    OS APIs. For example, the Win32 API uses some really long names for certain procedure
    calls. You can use the `external` directive to provide a more meaningful name
    than the standard one the operating system specifies.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: 5.24.2 Header Files in HLA
  id: totrans-648
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HLA's technique of using the same `external` declaration to define public as
    well as external symbols may seem somewhat counterintuitive. Why not use a `public`
    reserved word for public symbols and the `external` keyword for external definitions?
    Well, as counterintuitive as HLA's external declarations may seem, they are founded
    on decades of solid experience with the C/C++ programming language that uses a
    similar approach to public and external symbols.^([[101](#ftn.CHP-5-FN-32)]) Combined
    with a *header file*, HLA's external declarations make large-program maintenance
    a breeze.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: An important benefit of the `external` directive (versus separate `public` and
    `external` directives) is that it lets you minimize duplication of effort in your
    source files. Suppose, for example, you want to create a module with a bunch of
    support routines and variables for use in several different programs (e.g., the
    HLA Standard Library). In addition to sharing some routines and some variables,
    suppose you want to share constants, types, and other items as well.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: The `#include` file mechanism provides a perfect way to handle this. You simply
    create a `#include` file containing the constants, macros, and `external` definitions
    and include this file in the module that implements your routines and in the modules
    that use those routines (see [Figure 5-10](ch05s24.html#using_header_files_in_hla_programs
    "Figure 5-10. Using header files in HLA programs")).
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: '![Using header files in HLA programs](tagoreillycom20100401nostarchimages578019.png)'
  id: totrans-652
  prefs: []
  type: TYPE_IMG
- en: Figure 5-10. Using header files in HLA programs
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: A typical header file contains only `const`, `val`, `type`, `static`, `readonly`,
    `storage`, and procedure prototypes (plus a few others we haven't look at yet,
    like macros). Objects in the `static`, `readonly`, and `storage` sections, as
    well as all procedure declarations, are always `external` objects. In particular,
    you should not put any `var` objects in a header file, nor should you put any
    nonexternal variables or procedure bodies in a header file. If you do, HLA will
    make duplicate copies of these objects in the different source files that include
    the header file. Not only will this make your programs larger, but it will cause
    them to fail under certain circumstances. For example, you generally put a variable
    in a header file so you can share the value of that variable among several different
    modules. However, if you fail to declare that symbol as external in the header
    file and just put a standard variable declaration there, each module that includes
    the source file will get its own separate variable—the modules will not share
    a common variable.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: If you create a standard header file, containing `const`, `val`, and `type`
    declarations and external objects, you should always be sure to include that file
    in the declaration section of all modules that need the definitions in the header
    file. Generally, HLA programs include all their header files in the first few
    statements after the `program` or `unit` header.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: This text adopts the HLA Standard Library convention of using an *.hhf* suffix
    for HLA header files (*hhf* stands for *HLA header file*).
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: ^([[96](#CHP-5-FN-27)]) Of course, units may contain procedures and those procedures
    may have statements, but the unit itself does not have any executable instructions
    associated with it.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: ^([[97](#CHP-5-FN-28)]) Procedures in the unit may have their own `var` sections,
    but the procedure's declaration section is separate from the unit's declaration
    section.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: ^([[98](#CHP-5-FN-29)]) If you want to explicitly specify the name of the output
    file, HLA provides a command-line option to achieve this. You can get a menu of
    all legal command-line options by entering the command `HLA -?`.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: ^([[99](#CHP-5-FN-30)]) There are a few exceptions, but you cannot declare external
    procedures or variables except at the global level.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: ^([[100](#CHP-5-FN-31)]) Typically, HLA creates a name like *001A_localObject*
    out of *localObject*. This is a legal MASM identifier, but it is not likely it
    will conflict with any other global symbols when HLA compiles the program with
    MASM.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: ^([[101](#CHP-5-FN-32)]) Actually, C/C++ is a little different. All global symbols
    in a module are assumed to be public unless explicitly declared private. HLA's
    approach (forcing the declaration of public items via `external`) is a little
    safer.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: 5.25 Namespace Pollution
  id: totrans-664
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One problem with creating libraries with a lot of different modules is namespace
    pollution. A typical library module will have a `#include` file associated with
    it that provides external definitions for all the routines, constants, variables,
    and other symbols provided in the library. Whenever you want to use some routines
    or other objects from the library, you would typically `#include` the library''s
    header file in your project. As your libraries get larger and you add declarations
    in the header file, it becomes likely that the names you''ve chosen for your library''s
    identifiers will conflict with names you want to use in your current project.
    This is known as *namespace pollution*: library header files pollute the namespace
    with names you typically don''t need in order to gain easy access to the few routines
    in the library you actually use. Most of the time those names don''t harm anything—unless
    you want to use those names for your own purposes.'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: HLA requires that you declare all external symbols at the global (`program/unit`)
    level. You cannot, therefore, include a header file with external declarations
    within a procedure. Thus, there will be no naming conflicts between external library
    symbols and symbols you declare locally within a procedure; the conflicts will
    occur only between the external symbols and your global symbols. While this is
    a good argument for avoiding global symbols as much as possible in your program,
    the fact remains that most symbols in an assembly language program will have global
    scope. So another solution is necessary.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: HLA's solution is to put most of the library names in a `namespace` declaration
    section. A `namespace` declaration encapsulates all declarations and exposes only
    a single name (the `namespace` identifier) at the global level. You access the
    names within the namespace by using the familiar dot notation (see the discussion
    of namespaces in [4.34 Namespaces](ch04s34.html "4.34 Namespaces")). This reduces
    the effect of namespace pollution from many dozens or hundreds of names down to
    a single name.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: Of course, one disadvantage of using a `namespace` declaration is that you have
    to type a longer name in order to reference a particular identifier in that namespace
    (that is, you have to type the `namespace` identifier, a period, and then the
    specific identifier you wish to use). For a few identifiers you use frequently,
    you might elect to leave those identifiers outside of any `namespace` declaration.
    For example, the HLA Standard Library does not define the symbol `nl` within a
    namespace. However, you want to minimize such declarations in your libraries to
    avoid conflicts with names in your own programs. Often, you can choose a `namespace`
    identifier to complement your routine names. For example, the HLA Standard Library's
    string copy routine was named after the equivalent C Standard Library function,
    `strcpy`. HLA's version is `str.cpy`. The actual function name is `cpy`; it happens
    to be a member of the `str namespace`, hence the full name `str.cpy`, which is
    very similar to the comparable C function. The HLA Standard Library contains several
    examples of this convention. The `arg.c` and `arg.v` functions are another pair
    of such identifiers (corresponding to the C identifiers `argc` and `argv`).
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a `namespace` in a header file is no different than using a `namespace`
    in a `program` or `unit`, though you do not normally put actual procedure bodies
    in a `namespace`. Here''s an example of a typical header file containing a `namespace`
    declaration:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Typically, you would compile each of the functions (`func1..func3`) as separate
    units (so each has its own object file and linking in one function doesn''t link
    them all). Here''s a sample `unit` declaration for one of these functions:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: You should notice two important things about this unit. First, you do not put
    the actual `func1` procedure code within a `namespace` declaration block. By using
    the identifier `myLib.func1` as the procedure's name, HLA automatically realizes
    that this procedure declaration belongs in a namespace. The second thing to note
    is that you do not preface `func1` with `myLib.` after the `begin` and `end` clauses
    in the procedure. HLA automatically associates the `begin` and `end` identifiers
    with the `procedure` declaration, so it knows that these identifiers are part
    of the `myLib` namespace and it doesn't make you type the whole name again.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note: When you declare external names within a namespace, as was
    done in `func1Unit` previously, HLA uses only the function name (`func1` in this
    example) as the external name. This creates a namespace pollution problem in the
    external namespace. For example, if you have two different namespaces, `myLib`
    and `yourLib`, and they both define a `func1` procedure, the linker will complain
    about a duplicate definition for `func1` if you attempt to use functions from
    both these library modules. There is an easy workaround to this problem: Use the
    extended form of the `external` directive to explicitly supply an external name
    for all external identifiers appearing in a `namespace` declaration. For example,
    you could solve this problem with the following simple modification to the *myHeader.hhf*
    file above:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'This example demonstrates an excellent convention you should adopt: When exporting
    names from a namespace, always supply an explicit external name and construct
    that name by concatenating the `namespace` identifier with an underscore and the
    object''s internal name.'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: The use of `namespace` declarations does not completely eliminate the problems
    of namespace pollution (after all, the namespace identifier is still a global
    object, as anyone who has included *stdlib.hhf* and attempted to define a `cs`
    variable can attest), but `namespace` declarations come pretty close to eliminating
    this problem. Therefore, you should use `namespace` everywhere practical when
    creating your own libraries.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: 5.26 For More Information
  id: totrans-678
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The electronic edition of this book found at [http://www.artofasm.com/](http://www.artofasm.com/)
    or [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) contains a whole "volume"
    on advanced and intermediate procedures. The information in this chapter was taken
    from the introductory and intermediate chapters in the electronic edition. While
    the information appearing in this chapter covers 99 percent of the material assembly
    programmers typically use, there is additional information on procedures and parameters
    that you may find interesting. In particular, the electronic edition covers additional
    parameter-passing mechanisms (pass by value/result, pass by result, pass by name,
    and pass by lazy evaluation) and goes into greater detail about the places you
    can pass parameters. The electronic version of this text also covers iterators,
    thunks, and other advanced procedure types. You should also check out the HLA
    documentation for more details on HLA's procedure facilities. Finally, a good
    compiler construction textbook will cover additional details about runtime support
    for procedures.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discussed only 32-bit near procedures (appropriate for operating
    systems like Windows, Mac OS X, FreeBSD, and Linux). For information about procedures
    in 16-bit code (including near and far procedures), check out the 16-bit edition
    of this book, also found at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/).
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: HLA supports the ability to nest procedures; that is, you can declare a procedure
    in the declaration section of some other procedure and use *displays* and *static
    links* to access automatic variables in the enclosing procedures. HLA also supports
    advanced parameter-pointer facilities. This text does not discuss these features
    because they're somewhat advanced and very few assembly language programmers take
    advantage of these facilities in their programs. However, these features are very
    handy in certain situations. Once you're comfortable with procedures and assembly
    language programming in general, you should read about HLA's facilities for nested
    procedures in the HLA documentation and in the chapters on intermediate and advanced
    procedures in the electronic version of this book found at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/).
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the examples given for the code that HLA generates when passing parameters
    using the high-level syntax are incomplete. Over time, HLA has improved the quality
    of the code it generates when passing parameters on the stack. If you would like
    to see the type of code HLA generates for a particular parameter call sequence,
    you should supply the `-sourcemode`, `-h`, and `-s` command-line parameters to
    HLA and view the corresponding assembly language file that HLA emits (which will
    be a pseudo-HLA source file showing you the low-level code that HLA produces).
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
