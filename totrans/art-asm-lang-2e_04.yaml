- en: Chapter 5. PROCEDURES AND UNITS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![PROCEDURES AND UNITS](tagoreillycom20100401nostarchimages577853.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In a procedural programming language, the basic unit of code is the *procedure*.
    A procedure is a set of instructions that compute some value or take some action
    (such as printing or reading a character value). This chapter discusses how HLA
    implements procedures. It begins by discussing HLA's high-level syntax for procedure
    declarations and invocations, but it also describes the low-level implementation
    of procedures at the machine level. At this point, you should be getting comfortable
    with assembly language programming, so it's time to start presenting "pure" assembly
    language rather than continuing to rely on HLA's high-level syntax as a crutch.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 Procedures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most procedural programming languages implement procedures using the call/return
    mechanism. That is, some code calls a procedure, the procedure does its thing,
    and then the procedure returns to the caller. The call and return instructions
    provide the 80x86's *procedure invocation mechanism*. The calling code calls a
    procedure with the `call` instruction and the procedure returns to the caller
    with the `ret` instruction. For example, the following 80x86 instruction calls
    the HLA Standard Library `stdout.newln` routine:^([[70](#ftn.CHP-5-FN-1)])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `stdout.newln` procedure prints a newline sequence to the console device
    and returns control to the instruction immediately following the `call stdout.newln;`
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alas, the HLA Standard Library does not supply all the routines you will ever
    need. Most of the time you''ll have to write your own procedures. To do this,
    you will use HLA''s procedure-declaration facilities. A basic HLA procedure declaration
    takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Procedure declarations appear in the declaration section of your program. That
    is, anywhere you can put a `static`, `const`, `type`, or other declaration section,
    you may place a procedure declaration. In the syntax example above, *`ProcName`*
    represents the name of the procedure you wish to define. This can be any valid
    (and unique) HLA identifier. Whatever identifier follows the `procedure` reserved
    word must also follow the `begin` and `end` reserved words in the procedure. As
    you've probably noticed, a procedure declaration looks a whole lot like an HLA
    program. In fact, the only difference (so far) is the use of the `procedure` reserved
    word rather than the `program` reserved word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a concrete example of an HLA procedure declaration. This procedure
    stores zeros into the 256 double words that EBX points at upon entry into the
    procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can use the 80x86 `call` instruction to call this procedure. When, during
    program execution, the code falls into the `end zeroBytes;` statement, the procedure
    returns to whoever called it and begins executing the first instruction beyond
    the `call` instruction. The program in [Example 5-1](ch05.html#example_of_a_simple_procedure
    "Example 5-1. Example of a simple procedure") provides an example of a call to
    the `zeroBytes` routine.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-1. Example of a simple procedure
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may have noticed when calling HLA Standard Library procedures, you don''t
    have to use the `call` instruction to call HLA procedures. There is nothing special
    about the HLA Standard Library procedures versus your own procedures. Although
    the formal 80x86 mechanism for calling procedures is to use the `call` instruction,
    HLA provides a high-level extension that lets you call a procedure by simply specifying
    the procedure''s name followed by an empty set of parentheses.^([[71](#ftn.CHP-5-FN-2)])
    For example, either of the following statements will call the HLA Standard Library
    `stdout.newln` procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, either of the following statements will call the `zeroBytes` procedure
    in [Example 5-1](ch05.html#example_of_a_simple_procedure "Example 5-1. Example
    of a simple procedure"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The choice of calling mechanism is strictly up to you. Most people, however,
    find the high-level syntax easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[70](#CHP-5-FN-1)]) Normally you would call `newln` using the high-level
    `newln()`; syntax, but the `call` instruction works as well.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[71](#CHP-5-FN-2)]) This assumes that the procedure does not have any parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 Saving the State of the Machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take a look at the program in [Example 5-2](ch05s02.html#program_with_an_unintended_infinite_loop
    "Example 5-2. Program with an unintended infinite loop"). This section of code
    attempts to print 20 lines of 40 spaces and an asterisk. Unfortunately, there
    is a subtle bug that creates an infinite loop. The main program uses the `repeat..until`
    loop to call `PrintSpaces` 20 times. `PrintSpaces` uses ECX to count off the 40
    spaces it prints. `PrintSpaces` returns with ECX containing 0\. The main program
    then prints an asterisk and a newline, decrements ECX, and then repeats because
    ECX isn't 0 (it will always contain $FFFF_FFFF at this point).
  prefs: []
  type: TYPE_NORMAL
- en: The problem here is that the `PrintSpaces` subroutine doesn't preserve the ECX
    register. Preserving a register means you save it upon entry into the subroutine
    and restore it before leaving. Had the `PrintSpaces` subroutine preserved the
    contents of the ECX register, the program in [Example 5-2](ch05s02.html#program_with_an_unintended_infinite_loop
    "Example 5-2. Program with an unintended infinite loop") would have functioned
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-2. Program with an unintended infinite loop
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the 80x86''s `push` and `pop` instructions to preserve register
    values while you need to use them for something else. Consider the following code
    for `PrintSpaces`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that `PrintSpaces` saves and restores EAX and ECX (because this procedure
    modifies these registers). Also, note that this code pops the registers off the
    stack in the reverse order that it pushed them. The last-in, first-out operation
    of the stack imposes this ordering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Either the caller (the code containing the `call` instruction) or the callee
    (the subroutine) can take responsibility for preserving the registers. In the
    example above, the callee preserved the registers. The example in [Example 5-3](ch05s02.html#demonstration_of_caller_register_preserv
    "Example 5-3. Demonstration of caller register preservation") shows what this
    code might look like if the caller preserves the registers:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-3. Demonstration of caller register preservation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two advantages to callee preservation: space and maintainability.
    If the callee (the procedure) preserves all affected registers, then there is
    only one copy of the `push` and `pop` instructions, those the procedure contains.
    If the caller saves the values in the registers, the program needs a set of `push`
    and `pop` instructions around every call. Not only does this make your programs
    longer, it also makes them harder to maintain. Remembering which registers to
    push and pop on each procedure call is not easily done.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a subroutine may unnecessarily preserve some registers if
    it preserves all the registers it modifies. In the examples above, the code needn't
    save EAX. Although `PrintSpaces` changes AL, this won't affect the program's operation.
    If the caller is preserving the registers, it doesn't have to save registers it
    doesn't care about (see the program in [Example 5-4](ch05s02.html#demonstrating_that_caller_preservation_n
    "Example 5-4. Demonstrating that caller preservation need not save all registers")).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-4. Demonstrating that caller preservation need not save all registers
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This example in [Example 5-4](ch05s02.html#demonstrating_that_caller_preservation_n
    "Example 5-4. Demonstrating that caller preservation need not save all registers")
    provides three different cases. The first loop (`repeat..until`) preserves only
    the ECX register. Modifying the AL register won't affect the operation of this
    loop. Immediately after the first loop, this code calls `PrintSpaces` again in
    the `while` loop. However, this code doesn't save EAX or ECX because it doesn't
    care if `PrintSpaces` changes them.
  prefs: []
  type: TYPE_NORMAL
- en: One big problem with having the caller preserve registers is that your program
    may change over time. You may modify the calling code or the procedure to use
    additional registers. Such changes, of course, may change the set of registers
    that you must preserve. Worse still, if the modification is in the subroutine
    itself, you will need to locate *every* call to the routine and verify that the
    subroutine does not change any registers the calling code uses.
  prefs: []
  type: TYPE_NORMAL
- en: Preserving registers isn't all there is to preserving the environment. You can
    also push and pop variables and other values that a subroutine might change. Because
    the 80x86 allows you to push and pop memory locations, you can easily preserve
    these values as well.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 Prematurely Returning from a Procedure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HLA `exit` and `exitif` statements let you return from a procedure without
    having to fall into the corresponding `end` statement in the procedure. These
    statements behave a whole lot like the `break` and `breakif` statements for loops,
    except that they transfer control to the bottom of the procedure rather than out
    of the current loop. These statements are quite useful in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for these two statements is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The *`procedurename`* operand is the name of the procedure you wish to exit.
    If you specify the name of your main program, the `exit` and `exitif` statements
    will terminate program execution (even if you're currently inside a procedure
    rather than the body of the main program).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `exit` statement immediately transfers control out of the specified procedure
    or program. The conditional `exitif` statement first tests the boolean expression
    and exits if the result is true. It is semantically equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Although the `exit` and `exitif` statements are invaluable in many cases, you
    should avoid using them without careful consideration. If a simple `if` statement
    will let you skip the rest of the code in your procedure, then by all means use
    the `if` statement. Procedures that contain a lot of `exit` and `exitif` statements
    will be harder to read, understand, and maintain than procedures without these
    statements (after all, the `exit` and `exitif` statements are really nothing more
    than `goto` statements, and you've probably heard already about the problems with
    `goto`s). `exit` and `exitif` are convenient when you have to return from a procedure
    inside a sequence of nested control structures, and slapping an `if..endif` around
    the remaining code in the procedure is impractical.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 Local Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HLA procedures, like procedures and functions in most high-level languages,
    let you declare *local variables*. Local variables are generally accessible only
    within the procedure; they are not accessible by the code that calls the procedure.
    Local variable declarations are identical to variable declarations in your main
    program except, of course, you declare the variables in the procedure's declaration
    section rather than the main program's declaration section. Actually, you may
    declare anything in the procedure's declaration section that is legal in the main
    program's declaration section, including constants, types, and even other procedures.^([[72](#ftn.CHP-5-FN-3)])
    In this section, however, we'll concentrate on local variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Local variables have two important attributes that differentiate them from
    the variables in your main program (that is, *global* variables): *lexical scope*
    and *lifetime*. Lexical scope, or just *scope*, determines where an identifier
    is usable in your program. Lifetime determines when a variable has memory associated
    with it and is capable of storing data. Because these two concepts differentiate
    local and global variables, it is wise to spend some time discussing them.'
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the best place to start when discussing the scope and lifetimes of local
    variables is with the scope and lifetimes of global variables—those variables
    you declare in your main program. Until now, the only rule you've had to follow
    concerning the declaration of your variables has been "you must declare all variables
    that you use in your programs." The position of the HLA declaration section with
    respect to the program statements automatically enforces the other major rule,
    which is "you must declare all variables before their first use." With the introduction
    of procedures, it is now possible to violate this rule because (1) procedures
    may access global variables, and (2) procedure declarations may appear anywhere
    in a declaration section, even before some variable declarations. The program
    in [Example 5-5](ch05s04.html#demonstration_of_global_scope "Example 5-5. Demonstration
    of global scope") demonstrates this source code organization.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-5. Demonstration of global scope
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates that a procedure can access global variables in the
    main program as long as you declare those global variables before the procedure.
    In this example, the `aProc` procedure cannot access the `InaccessibleInProc`
    variable because its declaration appears after the procedure declaration. However,
    `aProc` may reference `AccessibleInProc` because its declaration appears before
    the `aProc` procedure.
  prefs: []
  type: TYPE_NORMAL
- en: A procedure can access any `static`, `storage`, or `readonly` object exactly
    the same way the main program accesses such variables—by referencing the name.
    Although a procedure may access global `var` objects, a different syntax is necessary,
    and you need to learn a little more before you will understand the purpose of
    the additional syntax (for more details, please consult the HLA reference manual).
  prefs: []
  type: TYPE_NORMAL
- en: Accessing global objects is convenient and easy. Unfortunately, as you've probably
    learned when studying high-level language programming, accessing global objects
    makes your programs harder to read, understand, and maintain. Like most introductory
    programming texts, this book discourages the use of global variables within procedures.
    Accessing global variables within a procedure is sometimes the best solution to
    a given problem. However, such (legitimate) access typically occurs only in advanced
    programs involving multiple threads of execution or in other complex systems.
    Because it is unlikely you would be writing such code at this point, it is equally
    unlikely that you will absolutely need to access global variables in your procedures,
    so you should carefully consider your options before doing so.^([[73](#ftn.CHP-5-FN-4)])
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring local variables in your procedures is very easy; you use the same
    declaration sections as the main program: `static`, `readonly`, `storage`, and
    `var`. The same rules and syntax for the declaration sections and the access of
    variables you declare in these sections apply in your procedure. The example code
    in [Example 5-6](ch05s04.html#example_of_a_local_variable_in_a_procedu "Example 5-6. Example
    of a local variable in a procedure") demonstrates the declaration of a local variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-6. Example of a local variable in a procedure
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Local variables in a procedure are accessible only within that procedure.^([[74](#ftn.CHP-5-FN-5)])
    Therefore, the variable `i` in procedure `CntTo10` in [Example 5-6](ch05s04.html#example_of_a_local_variable_in_a_procedu
    "Example 5-6. Example of a local variable in a procedure") is not accessible in
    the main program.
  prefs: []
  type: TYPE_NORMAL
- en: For local variables, HLA relaxes the rule that identifiers must be unique in
    a program. In an HLA program, all identifiers must be unique within a given *scope*.
    Therefore, all global names must be unique with respect to one another. Similarly,
    all local variables within a given procedure must have unique names *but only
    with respect to other local symbols in that same procedure*. In particular, a
    local name may be the same as a global name. When this occurs, HLA creates two
    separate variables. Within the scope of the procedure, any reference to the common
    name accesses the local variable; outside that procedure, any reference to the
    common name references the global identifier. Although the quality of the resultant
    code is questionable, it is perfectly legal to have a global identifier named
    `MyVar` with the same local name in two or more different procedures. The procedures
    each have their own local variant of the object, which is independent of `MyVar`
    in the main program. [Example 5-7](ch05s04.html#local_variables_need_not_have_globally_u
    "Example 5-7. Local variables need not have globally unique names.") provides
    an example of an HLA program that demonstrates this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-7. Local variables need not have globally unique names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There are good and bad points to be made about reusing global names within a
    procedure. On the one hand, there is the potential for confusion. If you use a
    name like `ProfitsThisYear` as a global symbol and you reuse that name within
    a procedure, someone reading the procedure might think that the procedure refers
    to the global symbol rather than the local symbol. On the other hand, simple names
    like `i`, `j`, and `k` are nearly meaningless (almost everyone expects the program
    to use them as loop-control variables or for other local uses), so reusing these
    names as local objects is probably a good idea. From a software engineering perspective,
    it is probably a good idea to keep all variables names that have a very specific
    meaning (like `ProfitsThisYear`) unique throughout your program. General names
    that have a nebulous meaning (like `index` and `counter` and names like `i`, `j`,
    or `k`) will probably be okay to reuse as global variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one last point to make about the scope of identifiers in an HLA program:
    variables in separate procedures are separate, even if they have the same name.
    The `First` and `Second` procedures in [Example 5-7](ch05s04.html#local_variables_need_not_have_globally_u
    "Example 5-7. Local variables need not have globally unique names."), for example,
    share the same name (`i`) for a local variable. However, the `i` in `First` is
    a completely different variable from the `i` in `Second`.'
  prefs: []
  type: TYPE_NORMAL
- en: The second major attribute that differentiates local variables from global variables
    is *lifetime*. The lifetime of a variable spans from the point when the program
    first allocates storage for a variable to the point when the program deallocates
    the storage for that variable. Note that lifetime is a dynamic attribute (controlled
    at runtime), whereas scope is a static attribute (controlled at compile time).
    In particular, a variable can actually have several lifetimes if the program repeatedly
    allocates and then deallocates the storage for that variable.
  prefs: []
  type: TYPE_NORMAL
- en: Global variables always have a single lifetime that spans from the moment when
    the main program first begins execution to the point when the main program terminates.
    Likewise, all static objects have a single lifetime that spans the execution of
    the program (remember, static objects are those you declare in the `static`, `readonly`,
    or `storage` sections). This is true even within procedures. So there is no difference
    between the lifetime of a local static object and the lifetime of a global static
    object. Variables you declare in the `var` section, however, are a different matter.
    HLA's `var` objects use *automatic storage allocation*. Automatic storage allocation
    means that the procedure automatically allocates storage for a local variable
    upon entry into a procedure. Similarly, the program deallocates storage for automatic
    objects when the procedure returns to its caller. Therefore, the lifetime of an
    automatic object is from the point of the execution of the first statement in
    a procedure to the point when it returns to its caller.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most important thing to note about automatic variables is that you
    cannot expect them to maintain their values between calls to the procedure. Once
    the procedure returns to its caller, the storage for the automatic variable is
    lost and, therefore, the value is lost as well. Thus, *you must always assume
    that a local* *`var`* *object is uninitialized upon entry into a procedure*, even
    if you know you've called the procedure before and the previous procedure invocation
    initialized that variable. Whatever value the last call stored into the variable
    was lost when the procedure returned to its caller. If you need to maintain the
    value of a variable between calls to a procedure, you should use one of the static
    variable declaration types.
  prefs: []
  type: TYPE_NORMAL
- en: Given that automatic variables cannot maintain their values across procedure
    calls, you might wonder why you would want to use them at all. However, there
    are several benefits to automatic variables that static variables do not have.
    The biggest disadvantage to static variables is that they consume memory even
    when the (only) procedure that references them is not running. Automatic variables,
    on the other hand, consume storage only while their associated procedure is executing.
    Upon return, the procedure returns any automatic storage it allocated back to
    the system for reuse by other procedures. You'll see some additional advantages
    to automatic variables later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[72](#CHP-5-FN-3)]) Strictly speaking, this is not true. You may not declare
    external objects within a procedure. External objects are the subject of [5.24
    Units and the external Directive](ch05s24.html "5.24 Units and the external Directive").
  prefs: []
  type: TYPE_NORMAL
- en: ^([[73](#CHP-5-FN-4)]) Note that this argument against accessing global variables
    does not apply to other global symbols. It is perfectly reasonable to access global
    constants, types, procedures, and other objects in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[74](#CHP-5-FN-5)]) Strictly speaking, this is not true. However, accessing
    nonlocal `var` objects is beyond the scope of this text. See the HLA documentation
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5 Other Local and Global Symbol Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the previous section notes, HLA procedures let you declare constants, values,
    types, and almost everything else legal in the main program's declaration section.
    The same rules for scope apply to these identifiers. Therefore, you can reuse
    constant names, procedure names, type names, and the like in local declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing global constants, values, and types does not present the same software
    engineering problems that occur when you reference global variables. The problem
    with referencing global variables is that a procedure can change the value of
    a global variable in a nonobvious way. This makes programs more difficult to read,
    understand, and maintain because you can't often tell that a procedure is modifying
    memory by looking only at the call to that procedure. Constants, values, types,
    and other nonvariable objects don't suffer from this problem because you cannot
    change them at runtime. Therefore, the pressure to avoid global objects at nearly
    all costs doesn't apply to nonvariable objects.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that it's okay to access global constants, types, and so on, it's
    also worth pointing out that you should declare these objects locally within a
    procedure if the only place your program references such objects is within that
    procedure. Doing so will make your programs a little easier to read because the
    person reading your code won't have to search all over the place for the symbol's
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6 Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although many procedures are totally self-contained, most procedures require
    some input data and return some data to the caller. Parameters are values that
    you pass to and from a procedure. In straight assembly language, passing parameters
    can be a real chore. Fortunately, HLA provides a high-level-language-like syntax
    for procedure declarations and for procedure calls involving parameters. This
    section presents HLA's high-level parameter syntax. Later sections in this chapter
    deal with the low-level mechanisms for passing parameters in pure assembly code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to consider when discussing parameters is *how* we pass them
    to a procedure. If you are familiar with Pascal or C/C++, you''ve probably seen
    two ways to pass parameters: pass by value and pass by reference. HLA certainly
    supports these two parameter-passing mechanisms. However, HLA also supports pass
    by value/result, pass by result, pass by name, and pass by lazy evaluation. Of
    course, HLA is assembly language, so it is possible to pass parameters in HLA
    using any scheme you can dream up (at least, any scheme that is possible at all
    on the CPU). However, HLA provides special high-level syntax for pass by value,
    reference, value/result, result, name, and lazy evaluation.'
  prefs: []
  type: TYPE_NORMAL
- en: Because pass by value/result, result, name, and lazy evaluation are somewhat
    advanced, this book will not deal with those parameter-passing mechanisms. If
    you're interested in learning more about these parameter-passing schemes, see
    the HLA reference manual or check out the electronic versions of this text at
    [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) or [http://www.artofasm.com/](http://www.artofasm.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Another concern you will face when dealing with parameters is *where* you pass
    them. There are many different places to pass parameters; in this section we'll
    pass procedure parameters on the stack. You don't really need to concern yourself
    with the details because HLA abstracts them away for you; however, do keep in
    mind that procedure calls and procedure parameters make use of the stack. Therefore,
    whatever you push on the stack immediately before a procedure call is not going
    to be on the top of the stack upon entry into the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.1 Pass by Value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A parameter passed by value is just that—the caller passes a value to the procedure.
    Pass-by-value parameters are input-only parameters. That is, you can pass them
    to a procedure, but the procedure cannot return values through them. Given the
    HLA procedure call
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: if you pass `I` by value, then `CallProc` does not change the value of `I`,
    regardless of what happens to the parameter inside `CallProc`.
  prefs: []
  type: TYPE_NORMAL
- en: Because you must pass a copy of the data to the procedure, you should use this
    method only for passing small objects like bytes, words, and double words. Passing
    large arrays and records by value is very inefficient (because you must create
    and pass a copy of the object to the procedure).
  prefs: []
  type: TYPE_NORMAL
- en: HLA, like Pascal and C/C++, passes parameters by value unless you specify otherwise.
    The following is what a typical function looks like with a single pass-by-value
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The parameter `N` in `PrintNSpaces` is known as a *formal parameter*. Anywhere
    the name `N` appears in the body of the procedure, the program references the
    value passed through `N` by the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The calling sequence for `PrintNSpaces` can be any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some concrete examples of calls to `PrintNSpaces`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The parameter in the calls to `PrintNSpaces` is known as an *actual parameter*.
    In the examples above, `40`, `eax`, and `SpacesToPrint` are the actual parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Note that pass-by-value parameters behave exactly like local variables you declare
    in the `var` section with the single exception that the procedure's caller initializes
    these local variables before it passes control to the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA uses positional parameter notation just as most high-level languages do.
    Therefore, if you need to pass more than one parameter, HLA will associate the
    actual parameters with the formal parameters by their position in the parameter
    list. The following `PrintNChars` procedure demonstrates a simple procedure that
    has two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an invocation of the `PrintNChars` procedure that will print
    20 asterisk characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that HLA uses semicolons to separate the formal parameters in the procedure
    declaration, and it uses commas to separate the actual parameters in the procedure
    invocation (Pascal programmers should be comfortable with this notation). Also
    note that each HLA formal parameter declaration takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In particular, note that the parameter type has to be an identifier. None of
    the following are legal parameter declarations because the data type is not a
    single identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'However, don''t get the impression that you cannot pass pointer, array, record,
    or dynamic array variables as parameters. The trick is to declare a data type
    for each of these types in the `type` section. Then you can use a single identifier
    as the type in the parameter declaration. The following code fragment demonstrates
    how to do this with the four data types above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, HLA assumes that you intend to pass a parameter by value. HLA also
    lets you explicitly state that a parameter is a value parameter by prefacing the
    formal parameter declaration with the `val` keyword. The following is a version
    of the `PrintNSpaces` procedure that explicitly states that `N` is a pass-by-value
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Explicitly stating that a parameter is a pass-by-value parameter is a good idea
    if you have multiple parameters in the same procedure declaration that use different
    passing mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: When you pass a parameter by value and call the procedure using the HLA high-level
    language syntax, HLA will automatically generate code that will make a copy of
    the actual parameter's value and copy this data into the local storage for that
    parameter (that is, the formal parameter). For small objects, pass by value is
    probably the most efficient way to pass a parameter. For large objects, however,
    HLA must generate code that copies each and every byte of the actual parameter
    into the formal parameter. For large arrays and records, this can be a very expensive
    operation.^([[75](#ftn.CHP-5-FN-6)]) Unless you have specific semantic concerns
    that require you to pass a large array or record by value, you should use pass
    by reference or some other parameter-passing mechanism for arrays and records.
  prefs: []
  type: TYPE_NORMAL
- en: When passing parameters to a procedure, HLA checks the type of each actual parameter
    and compares this type to the corresponding formal parameter. If the types do
    not agree, HLA then checks to see if either the actual or the formal parameter
    is a byte, word, or double-word object and the other parameter is 1, 2, or 4 bytes
    in length (respectively). If the actual parameter does not satisfy either of these
    conditions, HLA reports a parameter-type mismatch error. If, for some reason,
    you need to pass a parameter to a procedure using a different type than the procedure
    calls for, you can always use the HLA type-coercion operator to override the type
    of the actual parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.2 Pass by Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To pass a parameter by reference, you must pass the address of a variable rather
    than its value. In other words, you must pass a pointer to the data. The procedure
    must dereference this pointer to access the data. Passing parameters by reference
    is useful when you must modify the actual parameter or when you pass large data
    structures between procedures.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a pass-by-reference parameter, you must preface the formal parameter
    declaration with the `var` keyword. The following code fragment demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling a procedure with a pass-by-reference parameter uses the same syntax
    as pass by value except that the parameter has to be a memory location; it cannot
    be a constant or a register. Furthermore, the type of the memory location must
    exactly match the type of the formal parameter. The following are legal calls
    to the procedure above (assuming `i32` is an `int32` variable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are all illegal `UsePassbyReference` invocations (assuming `charVar`
    is of type `char`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the high-level languages Pascal and C++, HLA does not completely hide
    the fact that you are passing a pointer rather than a value. In a procedure invocation,
    HLA will automatically compute the address of a variable and pass that address
    to the procedure. Within the procedure itself, however, you cannot treat the variable
    like a value parameter (as you could in most high-level languages). Instead, you
    treat the parameter as a double-word variable containing a pointer to the specified
    data. You must explicitly dereference this pointer when accessing the parameter's
    value. The example appearing in [Example 5-8](ch05s06.html#accessing_pass-by-reference_parameters
    "Example 5-8. Accessing pass-by-reference parameters") provides a simple demonstration
    of this.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-8. Accessing pass-by-reference parameters
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing parameters by reference can produce some peculiar results in some rare
    circumstances. Consider the `pbr` procedure in [Example 5-8](ch05s06.html#accessing_pass-by-reference_parameters
    "Example 5-8. Accessing pass-by-reference parameters"). Were you to modify the
    call in the main program to be `pbr(i,i)` rather than `pbr(i,j)`;, the program
    would produce the following nonintuitive output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The reason this code displays `a+b=−4` rather than the expected `a+b=−3` is
    because the `pbr(i,i);` call passes the same actual parameter for `a` and `b`.
    As a result, the `a` and `b` reference parameters both contain a pointer to the
    same memory location—that of the variable `i`. In this case, `a` and `b` are *aliases*
    of one another. Therefore, when the code stores −2 at the location pointed at
    by `b`, it overwrites the −1 stored earlier at the location pointed at by `a`.
    When the program fetches the value pointed at by `a` and `b` to compute their
    sum, both `a` and `b` point at the same value, which is −2\. Summing −2 + −2 produces
    the −4 result that the program displays. This nonintuitive behavior is possible
    anytime you encounter aliases in a program. Passing the same variable as two different
    reference parameters probably isn't very common. But you could also create an
    alias if a procedure references a global variable and you pass that same global
    variable by reference to the procedure (this is a good example of yet one more
    reason why you should avoid referencing global variables in a procedure).
  prefs: []
  type: TYPE_NORMAL
- en: Pass by reference is usually less efficient than pass by value. You must dereference
    all pass-by-reference parameters on each access; this is slower than simply using
    a value because it typically requires at least two instructions. However, when
    passing a large data structure, pass by reference is faster because you do not
    have to copy the large data structure before calling the procedure. Of course,
    you'd probably need to access elements of that large data structure (for example,
    an array) using a pointer, so very little efficiency is lost when you pass large
    arrays by reference.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '^([[75](#CHP-5-FN-6)]) Note to C/C++ programmers: HLA does not automatically
    pass arrays by reference. If you specify an array type as a formal parameter,
    HLA will emit code that makes a copy of each and every byte of that array when
    you call the associated procedure.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.7 Functions and Function Results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are procedures that return some result to the caller. In assembly
    language, there are very few syntactical differences between a procedure and a
    function, which is why HLA doesn't provide a specific declaration for a function.
    Nevertheless, although there is very little *syntactical* difference between assembly
    procedures and functions, there are some *semantic* differences. That is, although
    you can declare them the same way in HLA, you use them differently.
  prefs: []
  type: TYPE_NORMAL
- en: Procedures are a sequence of machine instructions that fulfill some task. The
    end result of the execution of a procedure is the accomplishment of that activity.
    Functions, on the other hand, execute a sequence of machine instructions specifically
    to compute some value to return to the caller. Of course, a function can perform
    some activity as well and procedures can undoubtedly compute some values, but
    the main difference is that the purpose of a function is to return some computed
    result; procedures don't have this requirement.
  prefs: []
  type: TYPE_NORMAL
- en: A good example of a procedure is the `stdout.puti32` procedure. This procedure
    requires a single `int32` parameter. The purpose of this procedure is to print
    the decimal conversion of this integer value to the standard output device. Note
    that `stdout.puti32` doesn't return any kind of value that is usable by the calling
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example of a function is the `cs.member` function. This function expects
    two parameters: The first is a character value and the second is a character set
    value. This function returns true (1) in EAX if the character is a member of the
    specified character set. It returns false if the character parameter is not a
    member of the character set.'
  prefs: []
  type: TYPE_NORMAL
- en: Logically, the fact that `cs.member` returns a usable value to the calling code
    (in EAX) while `stdout.puti32` does not is a good example of the main difference
    between a function and a procedure. So, in general, a procedure becomes a function
    by virtue of the fact that you explicitly decide to return a value somewhere upon
    procedure return. No special syntax is needed to declare and use a function. You
    still write the code as a procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 5.7.1 Returning Function Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The 80x86's registers are the most common place to return function results.
    The `cs.member` routine in the HLA Standard Library is a good example of a function
    that returns a value in one of the CPU's registers. It returns true (1) or false
    (0) in the EAX register. By convention, programmers try to return 8-, 16-, and
    32-bit (nonreal) results in the AL, AX, and EAX registers, respectively.^([[76](#ftn.CHP-5-FN-7)])
    This is where most high-level languages return these types of results.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there is nothing particularly sacred about the AL/AX/EAX register.
    You could return function results in any register if it is more convenient to
    do so. However, if you don't have a good reason for not using AL/AX/EAX, then
    you should follow the convention. Doing so will help others understand your code
    better because they will generally assume that your functions return small results
    in the AL/AX/EAX register set.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to return a function result that is larger than 32 bits, you obviously
    must return it somewhere other than in EAX (which can hold only 32-bit values).
    For values slightly larger than 32 bits (e.g., 64 bits or maybe even as many as
    128 bits), you can split the result into pieces and return those parts in two
    or more registers. It is common to see programs returning 64-bit values in the
    EDX:EAX register pair (for example, the HLA Standard Library `stdin.geti64` function
    returns a 64-bit integer in the EDX:EAX register pair).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to return a large object as a function result, say an array of
    1,000 elements, you obviously are not going to be able to return the function
    result in the registers. There are two common ways to deal with large function
    return results: Either pass the return value as a reference parameter or allocate
    storage on the heap (using `mem.alloc`) for the object and return a pointer to
    it in a 32-bit register. Of course, if you return a pointer to storage you''ve
    allocated on the heap, the calling program must free this storage when it has
    finished with it.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.7.2 Instruction Composition in HLA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several HLA Standard Library functions allow you to call them as operands of
    other instructions. For example, consider the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As your high-level language experience (and HLA experience) should suggest,
    this code calls the `cs.member` function to check to see if the character in AL
    is a lowercase alphabetic character. If the `cs.member` function returns true,
    then this code fragment executes the `then` section of the `if` statement; however,
    if `cs.member` returns false, this code fragment skips the `if..then` body. There
    is nothing spectacular here except for the fact that HLA doesn't support function
    calls as boolean expressions in the `if` statement (look back at [Chapter 1](ch01.html
    "Chapter 1. HELLO, WORLD OF ASSEMBLY LANGUAGE") to see the complete set of allowable
    expressions). How then, does this program compile and run, producing the intuitive
    results?
  prefs: []
  type: TYPE_NORMAL
- en: The next section describes how you can tell HLA that you want to use a function
    call in a boolean expression. However, to understand how this works, you need
    to first learn about *instruction composition* in HLA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instruction composition lets you use one instruction as the operand of another.
    For example, consider the `mov` instruction. It has two operands: a source operand
    and a destination operand. Instruction composition lets you substitute a valid
    80x86 machine instruction for either (or both) operands. The following is a simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the immediate question is, "What does this mean?" To understand
    what is going on, you must first realize that most instructions "return" a value
    to the compiler while they are being compiled. For most instructions, the value
    they "return" is their destination operand. Therefore, `mov( 0, eax );` returns
    the string `eax` to the compiler during compilation because EAX is the destination
    operand. Most of the time, specifically when an instruction appears on a line
    by itself, the compiler ignores the returned string result. However, HLA uses
    this string result whenever you supply an instruction in place of some operand;
    specifically, HLA uses that string as the operand in place of the instruction.
    Therefore, the `mov` instruction above is equivalent to the following two-instruction
    sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When processing composed instructions (that is, instruction sequences that
    have other instructions as operands), HLA always works in a "left-to-right then
    depth-first (inside-out)" manner. To make sense of this, consider the following
    instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To interpret what is happening here, begin with the source operand. It consists
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The source operand for this instruction is `mov( i, eax` ) and this instruction
    does not have any composition, so HLA emits this instruction and returns its destination
    operand (`eax`) for use as the source to the `sub` instruction. This effectively
    gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now HLA compiles the instruction that appears as the destination operand (`mov(
    j, ebx )`) and returns its destination operand (`ebx`) to substitute for this
    `mov` in the `sub` instruction. This yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is a complete instruction, without composition, that HLA can compile. So
    it compiles this instruction and returns its destination operand (`ebx`) as the
    string result to substitute for the `sub` in the original `add` instruction. So
    the original `add` instruction now becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: HLA next compiles the `mov` instruction appearing in the destination operand.
    It returns its destination operand as a string that HLA substitutes for the `mov`,
    finally yielding the simple instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The compilation of the original `add` instruction, therefore, yields the following
    instruction sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Whew! It's rather difficult to look at the original instruction and easily see
    that this sequence is the result. As you can see in this example, *overzealous
    use of instruction composition can produce nearly unreadable programs*. You should
    be very careful about using instruction composition in your programs. With only
    a few exceptions, writing a composed instruction sequence makes your program harder
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the excessive use of instruction composition may make errors in your
    program difficult to decipher. Consider the following HLA statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This instruction composition yields the following 80x86 instruction sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the compiler will complain that you''re attempting to add one memory
    location to another. However, the instruction composition effectively masks this
    fact and makes it difficult to comprehend the cause of the error message. Moral
    of the story: Avoid using instruction composition unless it really makes your
    program easier to read. The few examples in this section demonstrate how *not*
    to use instruction composition.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two main areas where using instruction composition can help make your
    programs more readable. The first is in HLA's high-level language control structures.
    The other is in procedure parameters. Although instruction composition is useful
    in these two cases (and probably a few others as well), this doesn't give you
    a license to use extremely convoluted instructions like the `add` instruction
    in the previous example. Instead, most of the time you will use a single instruction
    or a function call in place of a single operand in a high-level language boolean
    expression or in a procedure/function parameter.
  prefs: []
  type: TYPE_NORMAL
- en: While we're on the subject, exactly what does a procedure call return as the
    string that HLA substitutes for the call in an instruction composition? For that
    matter, what do statements like `if..endif` return? How about instructions that
    don't have a destination operand? Well, function return results are the subject
    of the next section, so you'll read about that in a few moments. As for all the
    other statements and instructions, you should check out the HLA reference manual.
    It lists each instruction and its returns value. The returns value is the string
    that HLA will substitute for the instruction when it appears as the operand to
    another instruction. Note that many HLA statements and instructions return the
    empty string as their returns value (by default, so do procedure calls). If an
    instruction returns the empty string as its composition value, then HLA will report
    an error if you attempt to use it as the operand of another instruction. For example,
    the `if..then..endif` statement returns the empty string as its returns value,
    so you may not bury an `if..then..endif` inside another instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 5.7.3 The HLA @returns Option in Procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HLA procedure declarations allow a special option that specifies the string
    to use when a procedure invocation appears as the operand of another instruction:
    the `@returns` option. The syntax for a procedure declaration with the `@returns`
    option is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If the `@returns` option is not present, HLA assigns the empty string to the
    `@returns` value for the procedure. This effectively makes it illegal to use that
    procedure invocation as the operand to another instruction.
  prefs: []
  type: TYPE_NORMAL
- en: The `@returns` option requires a single-string expression surrounded by parentheses.
    HLA will substitute this string constant for the procedure call if it ever appears
    as the operand of another instruction. Typically this string constant is a register
    name; however, any text that would be legal as an instruction operand is okay
    here. For example, you could specify memory addresses or constants. For purposes
    of clarity, you should always specify the location of a function's return value
    in the `@returns` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider the following boolean function that returns true or
    false in the EAX register if the single-character parameter is an alphabetic character:^([[77](#ftn.CHP-5-FN-8)])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you tack the `@returns` option on the end of this procedure declaration,
    you can legally use a call to `IsAlphabeticChar` as an operand to other HLA statements
    and instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The last example above demonstrates that, via the `@returns` option, you can
    embed calls to your own functions in the boolean expression field of various HLA
    statements. Note that the code above is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Not all HLA high-level language statements expand composed instructions before
    the statement. For example, consider the following `while` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does not expand to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Instead, the call to `IsAlphabeticChar` expands inside the `while`'s boolean
    expression so that the program calls this function on each iteration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: You should exercise caution when entering the `@returns` parameter. HLA does
    not check the syntax of the string parameter when it is compiling the procedure
    declaration (other than to verify that it is a string constant). Instead, HLA
    checks the syntax when it replaces the function call with the `@returns` string.
    So if you had specified `eaz` instead of `eax` as the `@returns` parameter for
    `IsAlphabeticChar` in the previous examples, HLA would not have reported an error
    until you actually used `IsAlphabeticChar` as an operand. Then of course, HLA
    would complain about the illegal operand, and it's not at all clear what the problem
    is by looking at the `IsAlphabeticChar` invocation. So take special care not to
    introduce typographical errors into the `@returns` string; figuring out such errors
    later can be very difficult.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[76](#CHP-5-FN-7)]) In [Chapter 6](ch06.html "Chapter 6. ARITHMETIC") you'll
    see where most programmers return real results.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[77](#CHP-5-FN-8)]) Before you run off and actually use this function in
    your own programs, note that the HLA Standard Library provides the `char.isAlpha`
    function that provides this test. See the HLA documentation for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 5.8 Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Recursion* occurs when a procedure calls itself. The following, for example,
    is a recursive procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the CPU will never return from this procedure. Upon entry into `Recursive`,
    this procedure will immediately call itself again, and control will never pass
    to the end of the procedure. In this particular case, runaway recursion results
    in an infinite loop.^([[78](#ftn.CHP-5-FN-9)])
  prefs: []
  type: TYPE_NORMAL
- en: 'Like a looping structure, recursion requires a termination condition in order
    to stop infinite recursion. `Recursive` could be rewritten with a termination
    condition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This modification to the routine causes `Recursive` to call itself the number
    of times appearing in the EAX register. On each call, `Recursive` decrements the
    EAX register by 1 and then calls itself again. Eventually, `Recursive` decrements
    EAX to 0 and returns from each call until it returns to the original caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, however, there hasn''t been a real need for recursion. After all, you
    could efficiently code this procedure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Both examples would repeat the body of the procedure the number of times passed
    in the EAX register.^([[79](#ftn.CHP-5-FN-10)]) As it turns out, there are only
    a few recursive algorithms that you cannot implement in an iterative fashion.
    However, many recursively implemented algorithms are more efficient than their
    iterative counterparts, and most of the time the recursive form of the algorithm
    is much easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The quicksort algorithm is probably the most famous algorithm that usually appears
    in recursive form. An HLA implementation of this algorithm appears in [Example 5-9](ch05s08.html#recursive_quicksort_program
    "Example 5-9. Recursive quicksort program").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-9. Recursive quicksort program
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note that this quicksort procedure uses registers for all nonparameter local
    variables. Also note how quicksort uses `text` constant definitions to provide
    more readable names for the registers. This technique can often make an algorithm
    easier to read; however, one must take care when using this trick not to forget
    that those registers are being used.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[78](#CHP-5-FN-9)]) Well, not really infinite. The stack will overflow and
    Windows, Mac OS X, FreeBSD, or Linux will raise an exception at that point.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[79](#CHP-5-FN-10)]) The latter version will do it considerably faster because
    it doesn't have the overhead of the `call`/`ret` instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 5.9 Forward Procedures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a general rule, HLA requires that you declare all symbols before their first
    use in a program.^([[80](#ftn.CHP-5-FN-11)]) Therefore, you must define all procedures
    before their first call. There are two reasons this isn''t always practical: mutual
    recursion (two procedures call each other) and source code organization (you prefer
    to place a procedure in your code after the point where you''ve first called it).
    Fortunately, HLA lets you use a *forward procedure definition* to declare a procedure
    *prototype*. Forward declarations let you define a procedure before you actually
    supply the code for that procedure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A forward procedure declaration is a familiar procedure declaration that uses
    the reserved word `forward` in place of the procedure''s declaration section and
    body. The following is a forward declaration for the quicksort procedure appearing
    in the last section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: A forward declaration in an HLA program is a promise to the compiler that the
    actual procedure declaration will appear, exactly as stated in the forward declaration,
    at a later point in the source code.^([[81](#ftn.CHP-5-FN-12)]) The forward declaration
    must have the same parameters, they must be passed the same way, and they must
    all have the same types as the formal parameters in the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Routines that are mutually recursive (that is, procedure `A` calls procedure
    `B` and procedure `B` calls procedure `A`) require at least one forward declaration,
    because you may declare only one of procedure `A` or `B` before the other. In
    practice, however, mutual recursion (direct or indirect) doesn't occur very frequently,
    so you'll rarely forward declarations for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: In the absence of mutual recursion, it is always possible to organize your source
    code so that each procedure declaration appears before its first invocation. What's
    possible and what's desired are two different things, however. You might want
    to group a related set of procedures at the beginning of your source code and
    a different set of procedures toward the end of your source code. This logical
    grouping, by function rather than by invocation, may make your programs much easier
    to read and understand. However, this organization may also yield code that attempts
    to call a procedure before its declaration. No sweat; just use a forward procedure
    definition to resolve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'One major difference between the forward definition and the actual procedure
    declaration has to do with the procedure options. Some options, like `@returns`,
    may appear only in the forward declaration (if a `forward` declaration is present).
    Other options may appear only in the actual procedure declaration (we haven''t
    covered any of the other procedure options, so don''t worry about them just yet).
    If your procedure requires an `@returns` option, the `@returns` option must appear
    before the `forward` reserved word. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `@returns` option must not also appear in the actual procedure declaration
    later in your source file.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[80](#CHP-5-FN-11)]) There are a few minor exceptions to this rule, but it
    is certainly true for procedure calls.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[81](#CHP-5-FN-12)]) Actually, `exactly` is too strong a word. You will see
    some exceptions in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 5.10 HLA v2.0 Procedure Declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HLA v2.0 and later support an alternate procedure declaration syntax that is
    similar to constant, type, and variable declarations. Though this book tends to
    prefer the original procedure declaration syntax (which HLA v2.0 and later still
    support), you will see examples of the new syntax in code that exists out in the
    real world; therefore, this section provides a brief discussion of the new procedure
    declaration syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new HLA v2.0 procedure declaration syntax uses the `proc` keyword to begin
    a procedure declaration section (similar to `var` or `static` beginning a variable
    declaration section). Within a `proc` section, procedure declarations take one
    of these forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Please see the HLA v2.0 (or later) reference manual for more details concerning
    this alternate procedure declaration syntax. Just be aware of its existence in
    case you come across it while reading example HLA code you've gotten from some
    other source.
  prefs: []
  type: TYPE_NORMAL
- en: 5.11 Low-Level Procedures and the call Instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The 80x86 `call` instruction does two things. First, it pushes the address of
    the instruction immediately following the `call` onto the stack; then it transfers
    control to the address of the specified procedure. The value that `call` pushes
    onto the stack is known as the *return address*. When the procedure wants to return
    to the caller and continue execution with the first statement following the `call`
    instruction, the procedure simply pops the return address off the stack and jumps
    (indirectly) to that address. Most procedures return to their caller by executing
    a `ret` (return) instruction. The `ret` instruction pops a return address off
    the stack and transfers control indirectly to the address it pops off the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the HLA compiler automatically places a `ret` instruction (along
    with a few other instructions) at the end of each HLA procedure you write. This
    is why you haven''t had to explicitly use the `ret` instruction up to this point.
    To disable the default code generation in an HLA procedure, specify the following
    options when declaring your procedures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `@noframe` and `@nodisplay` clauses are examples of procedure *options*.
    HLA procedures support several such options, including `@returns`, `@noframe`,
    `@nodisplay`, and `@noalignstack`. You'll see the purpose of `@noalignstack` and
    a couple of other procedure options in Section 5.14\. These procedure options
    may appear in any order following the procedure name (and parameters, if any).
    Note that `@noframe` and `@nodisplay` (as well as `@noalignstack`) may appear
    only in an actual procedure declaration. You cannot specify these options in a
    forward declaration.
  prefs: []
  type: TYPE_NORMAL
- en: The `@noframe` option tells HLA that you don't want the compiler to automatically
    generate entry and exit code for the procedure. This tells HLA not to automatically
    generate the `ret` instruction (along with several other instructions).
  prefs: []
  type: TYPE_NORMAL
- en: The `@nodisplay` option tells HLA that it should not allocate storage in procedure's
    local variable area for a *display*. The display is a mechanism you use to access
    nonlocal `var` objects in a procedure. Therefore, a display is necessary only
    if you nest procedures in your programs. This book will not consider the display
    or nested procedures; for more details on the display and nested procedures see
    the appropriate chapter in the electronic edition appearing at [http://www.artofasm.com/](http://www.artofasm.com/)
    or [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/), or check out the
    HLA reference manual. Until then, you can safely specify the `@nodisplay` option
    on all your procedures. Indeed, for all of the procedures appearing in this chapter
    up to this point, specifying the `@nodisplay` option makes a lot of sense because
    none of those procedures actually use the display. Procedures that have the `@nodisplay`
    option are a tiny bit faster and a tiny bit shorter than those procedures that
    do not specify this option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the minimal procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: If you call this procedure with the `call` instruction, `minimal` will simply
    pop the return address off the stack and return back to the caller. You should
    note that a `ret` instruction is absolutely necessary when you specify the `@noframe`
    procedure option.^([[82](#ftn.CHP-5-FN-13)]) If you fail to put the `ret` instruction
    in the procedure, the program will not return to the caller upon encountering
    the `end minimal;` statement. Instead, the program will fall through to whatever
    code happens to follow the procedure in memory. The example program in [Example 5-10](ch05s11.html#effect_of_a_missing_ret_instruction_in_a
    "Example 5-10. Effect of a missing ret instruction in a procedure") demonstrates
    this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-10. Effect of a missing `ret` instruction in a procedure
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Although this behavior might be desirable in certain rare circumstances, it
    usually represents a defect in most programs. Therefore, if you specify the `@noframe`
    option, always remember to explicitly return from the procedure using the `ret`
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[82](#CHP-5-FN-13)]) Strictly speaking, this isn't true. But some mechanism
    that pops the return address off the stack and jumps to the return address is
    necessary in the procedure's body.
  prefs: []
  type: TYPE_NORMAL
- en: 5.12 Procedures and the Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because procedures use the stack to hold the return address, you must exercise
    caution when pushing and popping data within a procedure. Consider the following
    simple (and defective) procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: At the point the program encounters the `ret` instruction, the 80x86 stack takes
    the form shown in [Figure 5-1](ch05s12.html#stack_contents_before_ret_in_messedup_pr
    "Figure 5-1. Stack contents before ret in MessedUp procedure").
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack contents before ret in MessedUp procedure](tagoreillycom20100401nostarchimages578001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1. Stack contents before `ret` in `MessedUp` procedure
  prefs: []
  type: TYPE_NORMAL
- en: The `ret` instruction isn't aware that the value on the top of stack is not
    a valid address. It simply pops whatever value is on the top of the stack and
    jumps to that location. In this example, the top of stack contains the saved EAX
    value. Because it is very unlikely that EAX contains the proper return address
    (indeed, there is about a one in four billion chance it is correct), this program
    will probably crash or exhibit some other undefined behavior. Therefore, you must
    take care when pushing data onto the stack within a procedure that you properly
    pop that data prior to returning from the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you do not specify the `@noframe` option when writing a procedure, HLA automatically
    generates code at the beginning of the procedure that pushes some data onto the
    stack. Therefore, unless you understand exactly what is going on and you've taken
    care of this data HLA pushes on the stack, you should never execute the bare `ret`
    instruction inside a procedure that does not have the `@noframe` option. Doing
    so will attempt to return to the location specified by this data (which is not
    a return address) rather than properly returning to the caller. In procedures
    that do not have the `@noframe` option, use the `exit` or `exitif` statement to
    return from the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Popping extra data off the stack prior to executing the `ret` statement can
    also create havoc in your programs. Consider the following defective procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Upon reaching the `ret` instruction in this procedure, the 80x86 stack looks
    something like that shown in [Figure 5-2](ch05s12.html#stack_contents_before_ret_in_messeduptoo
    "Figure 5-2. Stack contents before ret in messedUpToo").
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack contents before ret in messedUpToo](tagoreillycom20100401nostarchimages578003.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2. Stack contents before `ret` in `messedUpToo`
  prefs: []
  type: TYPE_NORMAL
- en: Once again, the `ret` instruction blindly pops whatever data happens to be on
    the top of the stack and attempts to return to that address. Unlike the previous
    example, where it was very unlikely that the top of stack contained a valid return
    address (because it contained the value in EAX), there is a small possibility
    that the top of stack in this example actually *does* contain a return address.
    However, this will not be the proper return address for the `messedUpToo` procedure;
    instead, it will be the return address for the procedure that called `messedUpToo`.
    To understand the effect of this code, consider the program in [Example 5-11](ch05s12.html#effect_of_popping_too_much_data_off_the
    "Example 5-11. Effect of popping too much data off the stack").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-11. Effect of popping too much data off the stack
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Because a valid return address is sitting on the top of the stack, you might
    think that this program will actually work (properly). However, note that when
    returning from the `messedUpToo` procedure, this code returns directly to the
    main program rather than to the proper return address in the `callsMU2` procedure.
    Therefore, all code in the `callsMU2` procedure that follows the call to `messedUpToo`
    does not execute. When reading the source code, it may be very difficult to figure
    out why those statements are not executing because they immediately follow the
    call to the `messedUpToo` procedure. It isn't clear, unless you look very closely,
    that the program is popping an extra return address off the stack and therefore
    doesn't return to `callsMU2` but rather returns directly to whoever calls `callsMU2`.
    Of course, in this example it's fairly easy to see what is going on (because this
    example is a demonstration of this problem). In real programs, however, determining
    that a procedure has accidentally popped too much data off the stack can be much
    more difficult. Therefore, you should always be careful about pushing and popping
    data in a procedure. You should always verify that there is a one-to-one relationship
    between the pushes in your procedures and the corresponding pops.
  prefs: []
  type: TYPE_NORMAL
- en: 5.13 Activation Records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you call a procedure, there is certain information the program associates
    with that procedure call. The return address is a good example of some information
    the program maintains for a specific procedure call. Parameters and automatic
    local variables (that is, those you declare in the `var` section) are additional
    examples of information the program maintains for each procedure call. *Activation
    record* is the term we'll use to describe the information the program associates
    with a specific call to a procedure.^([[83](#ftn.CHP-5-FN-14)])
  prefs: []
  type: TYPE_NORMAL
- en: Activation record is an appropriate name for this data structure. The program
    creates an activation record when calling (activating) a procedure and the data
    in the structure is organized in a manner identical to records. Perhaps the only
    thing unusual about an activation record (when comparing it to a standard record)
    is that the base address of the record is in the middle of the data structure,
    so you must access fields of the record at positive and negative offsets.
  prefs: []
  type: TYPE_NORMAL
- en: Construction of an activation record begins in the code that calls a procedure.
    The caller pushes the parameter data (if any) onto the stack. Then the execution
    of the `call` instruction pushes the return address onto the stack. At this point,
    construction of the activation record continues within the procedure itself. The
    procedure pushes registers and other important state information and then makes
    room in the activation record for local variables. The procedure must also update
    the EBP register so that it points at the base address of the activation record.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what a typical activation record looks like, consider the following
    HLA procedure declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Whenever an HLA program calls this `ARDemo` procedure, it begins by pushing
    the data for the parameters onto the stack. The calling code will push the parameters
    onto the stack in the order they appear in the parameter list, from left to right.
    Therefore, the calling code first pushes the value for the `i` parameter, then
    it pushes the value for the `j` parameter, and it finally pushes the data for
    the `k` parameter. After pushing the parameters, the program calls the `ARDemo`
    procedure. Immediately upon entry into the `ARDemo` procedure, the stack contains
    these four items arranged as shown in [Figure 5-3](ch05s13.html#stack_organization_immediately_upon_entr
    "Figure 5-3. Stack organization immediately upon entry into ARDemo").
  prefs: []
  type: TYPE_NORMAL
- en: The first few instructions in `ARDemo` (note that it does not have the `@noframe`
    option) will push the current value of EBP onto the stack and then copy the value
    of ESP into EBP. Next, the code drops the stack pointer down in memory to make
    room for the local variables. This produces the stack organization shown in [Figure 5-4](ch05s13.html#activation_record_for_ardemo
    "Figure 5-4. Activation record for ARDemo").
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack organization immediately upon entry into ARDemo](tagoreillycom20100401nostarchimages578005.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3. Stack organization immediately upon entry into `ARDemo`
  prefs: []
  type: TYPE_NORMAL
- en: '![Activation record for ARDemo](tagoreillycom20100401nostarchimages578007.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-4. Activation record for `ARDemo`
  prefs: []
  type: TYPE_NORMAL
- en: To access objects in the activation record you must use offsets from the EBP
    register to the desired object. The two items of immediate interest to you are
    the parameters and the local variables. You can access the parameters at positive
    offsets from the EBP register; you can access the local variables at negative
    offsets from the EBP register, as [Figure 5-5](ch05s13.html#offsets_of_objects_in_the_ardemo_activat
    "Figure 5-5. Offsets of objects in the ARDemo activation record") shows.
  prefs: []
  type: TYPE_NORMAL
- en: Intel specifically reserves the EBP (Extended Base Pointer) register for use
    as a pointer to the base of the activation record. This is why you should never
    use the EBP register for general calculations. If you arbitrarily change the value
    in the EBP register, you will lose access to the current procedure's parameters
    and local variables.
  prefs: []
  type: TYPE_NORMAL
- en: '![Offsets of objects in the ARDemo activation record](tagoreillycom20100401nostarchimages578009.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-5. Offsets of objects in the `ARDemo` activation record
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[83](#CHP-5-FN-14)]) *Stack frame* is another term many people use to describe
    the activation record.
  prefs: []
  type: TYPE_NORMAL
- en: 5.14 The Standard Entry Sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The caller of a procedure is responsible for pushing the parameters onto the
    stack. Of course, the `call` instruction pushes the return address onto the stack.
    It is the procedure''s responsibility to construct the rest of the activation
    record. You can accomplish this by using the following "standard entry sequence"
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: If the procedure doesn't have any local variables, the third instruction above,
    `sub(` *`NumVars`*`, esp );`, isn't necessary. *`NumVars`* represents the number
    of *bytes* of local variables needed by the procedure. This is a constant that
    should be a multiple of 4 (so the ESP register remains aligned on a double-word
    boundary). If the number of bytes of local variables in the procedure is not a
    multiple of 4, you should round the value up to the next higher multiple of 4
    before subtracting this constant from ESP. Doing so will slightly increase the
    amount of storage the procedure uses for local variables but will not otherwise
    affect the operation of the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the `NumVars` constant is not a multiple of 4, subtracting this value from
    ESP (which, presumably, contains a double-word-aligned pointer) will virtually
    guarantee that all future stack accesses are misaligned because the program almost
    always pushes and pops double-word values. This will have a very negative performance
    impact on the program. Worse still, many OS API calls will fail if the stack is
    not double-word aligned upon entry into the operating system. Therefore, you must
    always ensure that your local variable allocation value is a multiple of 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of the problems with a misaligned stack, by default HLA will also emit
    a fourth instruction as part of the standard entry sequence. The HLA compiler
    actually emits the following standard entry sequence for the `ARDemo` procedure
    defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `and` instruction at the end of this sequence forces the stack to be aligned
    on a 4-byte boundary (it reduces the value in the stack pointer by 1, 2, or 3
    if the value in ESP is not a multiple of 4). Although the `ARDemo` entry code
    correctly subtracts 12 from ESP for the local variables (12 is both a multiple
    of 4 and the number of bytes of local variables), this leaves ESP double-word
    aligned only if it was double-word aligned immediately upon entry into the procedure.
    Had the caller messed with the stack and left ESP containing a value that was
    not a multiple of 4, subtracting 12 from ESP would leave ESP containing an unaligned
    value. The `and` instruction in the sequence above, however, guarantees that ESP
    is dword aligned regardless of ESP's value upon entry into the procedure. The
    few bytes and CPU cycles needed to execute this instruction would pay off handsomely
    if ESP was not double-word aligned.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is always safe to execute the `and` instruction in the standard
    entry sequence, it might not be necessary. If you always ensure that ESP contains
    a double-word-aligned value, the `and` instruction in the standard entry sequence
    above is unnecessary. Therefore, if you've specified the `@noframe` procedure
    option, you don't have to include that instruction as part of the entry sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t specified the `@noframe` option (that is, you''re letting HLA
    emit the instructions to construct the standard entry sequence for you), you can
    still tell HLA not to emit the extra `and` instruction if you''re sure the stack
    will be double-word aligned whenever someone calls the procedure. To do this,
    use the `@noalignstack` procedure option. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'HLA emits the following entry sequence for the procedure above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 5.15 The Standard Exit Sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before a procedure returns to its caller, it needs to clean up the activation
    record. Although it is possible to share the cleanup duties between the procedure
    and the procedure's caller, Intel has included some features in the instruction
    set that allows the procedure to efficiently handle all the cleanup chores itself.
    Standard HLA procedures and procedure calls, therefore, assume that it is the
    procedure's responsibility to clean up the activation record (including the parameters)
    when the procedure returns to its caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a procedure does not have any parameters, the exit sequence is very simple.
    It requires only three instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If the procedure has some parameters, then a slight modification to the standard
    exit sequence is necessary in order to remove the parameter data from the stack.
    Procedures with parameters use the following standard exit sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The *`ParmBytes`* operand of the `ret` instruction is a constant that specifies
    the number of bytes of parameter data to remove from the stack after the return
    instruction pops the return address. For example, the `ARDemo` example code in
    the previous sections has three double-word parameters. Therefore, the standard
    exit sequence would take the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''ve declared your parameters using HLA syntax (that is, a parameter
    list follows the procedure declaration), then HLA automatically creates a local
    constant in the procedure, `_parms_`, that is equal to the number of bytes of
    parameters in that procedure. Therefore, rather than counting the number of parameter
    bytes yourself, you can use the following standard exit sequence for any procedure
    that has parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you do not specify a byte constant operand to the `ret` instruction,
    the 80x86 will not pop the parameters off the stack upon return. Those parameters
    will still be sitting on the stack when you execute the first instruction following
    the `call` to the procedure. Similarly, if you specify a value that is too small,
    some of the parameters will be left on the stack upon return from the procedure.
    If the `ret` operand you specify is too large, the `ret` instruction will actually
    pop some of the caller's data off the stack, usually with disastrous consequences.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to return early from a procedure that doesn't have the `@noframe`
    option, and you don't particularly want to use the `exit` or `exitif` statement,
    you must execute the standard exit sequence to return to the caller. A simple
    `ret` instruction is insufficient because local variables and the old EBP value
    are probably sitting on the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 5.16 Low-Level Implementation of Automatic (Local) Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your program accesses local variables in a procedure using negative offsets
    from the activation record base address (EBP). Consider the following HLA procedure
    (which admittedly doesn''t do much other than demonstrate the use of local variables):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The activation record for `LocalVars` appears in [Figure 5-6](ch05s16.html#activation_record_for_the_localvars_proc
    "Figure 5-6. Activation record for the LocalVars procedure").
  prefs: []
  type: TYPE_NORMAL
- en: '![Activation record for the LocalVars procedure](tagoreillycom20100401nostarchimages578011.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-6. Activation record for the `LocalVars` procedure
  prefs: []
  type: TYPE_NORMAL
- en: The HLA compiler emits code that is roughly equivalent to the following for
    the body of this procedure:^([[84](#ftn.CHP-5-FN-15)])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: You could actually type these statements into the procedure yourself and they
    would work. Of course, using memory references like `[ebp-4]` and `[ebp-8]` rather
    than `a` or `b` makes your programs very difficult to read and understand. Therefore,
    you should always declare and use HLA symbolic names rather than offsets from
    EBP.
  prefs: []
  type: TYPE_NORMAL
- en: The standard entry sequence for this `LocalVars` procedure will be:^([[85](#ftn.CHP-5-FN-16)])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This code subtracts 8 from the stack pointer because there are 8 bytes of local
    variables (two double-word objects) in this procedure. Unfortunately, as the number
    of local variables increases, especially if those variables have different types,
    computing the number of bytes of local variables becomes rather tedious. Fortunately,
    for those who wish to write the standard entry sequence themselves, HLA automatically
    computes this value for you and creates a constant, `_vars_`, that specifies the
    number of bytes of local variables.^([[86](#ftn.CHP-5-FN-17)]) Therefore, if you
    intend to write the standard entry sequence yourself, you should use the `_vars_`
    constant in the `sub` instruction when allocating storage for the local variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Now that you've seen how assembly language allocates and deallocates storage
    for local variables, it's easy to understand why automatic (`var`) variables do
    not maintain their values between two calls to the same procedure. Because the
    memory associated with these automatic variables is on the stack, when a procedure
    returns to its caller the caller can push other data onto the stack, obliterating
    the values previously held on the stack. Furthermore, intervening calls to other
    procedures (with their own local variables) may wipe out the values on the stack.
    Also, upon reentry into a procedure, the procedure's local variables may correspond
    to different physical memory locations; hence the values of the local variables
    would not be in their proper locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'One big advantage to automatic storage is that it efficiently shares a fixed
    pool of memory among several procedures. For example, if you call three procedures
    in a row, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: the first procedure (`ProcA` in the code above) allocates its local variables
    on the stack. Upon return, `ProcA` deallocates that stack storage. Upon entry
    into `ProcB`, the program allocates storage for `ProcB`'s local variables *using
    the same memory locations just freed by* `ProcA`. Likewise, when `ProcB` returns
    and the program calls `ProcC`, `ProcC` uses the same stack space for its local
    variables that `ProcB` recently freed up. This memory reuse makes efficient use
    of the system resources and is probably the greatest advantage to using automatic
    (`var`) variables.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[84](#CHP-5-FN-15)]) This ignores the code associated with the standard entry
    and exit sequences.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[85](#CHP-5-FN-16)]) This code assumes that ESP is dword aligned upon entry
    so the `and( $FFFF_FFFC, esp );` instruction is unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[86](#CHP-5-FN-17)]) HLA even rounds this constant up to the next even multiple
    of 4 so you don't have to worry about stack alignment.
  prefs: []
  type: TYPE_NORMAL
- en: 5.17 Low-Level Parameter Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier, when discussing HLA''s high-level parameter passing mechanism, there
    were several questions concerning parameters. Some important questions are:'
  prefs: []
  type: TYPE_NORMAL
- en: Where is the data coming from?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What mechanism do you use to pass and return data?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much data are you passing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section we will take another look at the two most common parameter-passing
    mechanisms: pass by value and pass by reference. We will discuss three popular
    places to pass parameters by reference or by value: in the registers, on the stack,
    and in the code stream. The amount of parameter data has a direct bearing on where
    and how to pass it. The following sections take up these issues.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.17.1 Passing Parameters in Registers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having touched on *how* to pass parameters to a procedure in Section 5.6, the
    next thing to discuss is *where* to pass parameters. Where you pass parameters
    depends on the size and number of those parameters. If you are passing a small
    number of bytes to a procedure, then the registers are an excellent place to pass
    parameters to a procedure. If you are passing a single parameter to a procedure,
    you should use the following registers for the accompanying data types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This is not a hard-and-fast rule. If you find it more convenient to pass 16-bit
    values in the SI or BX register, then do so. However, most programmers use the
    registers above to pass parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are passing several parameters to a procedure in the 80x86''s registers,
    you should probably use up the registers in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In general, you should avoid using the EBP register. If you need more than six
    double words, perhaps you should pass your values elsewhere. This choice of priorities
    is not completely arbitrary. Many high-level languages will attempt to pass parameters
    in the EAX, EDX, and ECX registers (generally in that order). Furthermore, the
    Intel ABI (application binary interface) allows high-level language procedures
    to use EAX, EDX, and ECX without preserving their values. Hence, these three registers
    are a great place to pass parameters because a lot of code assumes their values
    are modified across procedure calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the following `strfill( s,c )`; procedure that copies
    the character `c` (passed by value in AL) to each character position in `s` (passed
    by reference in EDI) up to a zero-terminating byte:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: To call the `strfill` procedure you would load the address of the string data
    into EDI and the character value into AL prior to the call. The following code
    fragment demonstrates a typical call to `strfill`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget that HLA string variables are pointers. This example assumes that
    `s` is an HLA string variable and therefore contains a pointer to a zero-terminated
    string. Thus, the `mov( s, edi );` instruction loads the address of the zero-terminated
    string into the EDI register (hence this code passes the address of the string
    data to `strfill`, that is, it passes the string by reference).
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to pass parameters in the registers is to simply load them with the
    appropriate values prior to a call and then reference those registers within the
    procedure. This is the traditional mechanism for passing parameters in registers
    in an assembly language program. HLA, being somewhat more high-level than traditional
    assembly language, provides a formal parameter declaration syntax that lets you
    tell HLA you''re passing certain parameters in the general-purpose registers.
    This declaration syntax is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Where *`parmName`* is the parameter''s name, *`parmType`* is the type of the
    object, and *`reg`* is one of the 80x86''s general-purpose 8-, 16-, or 32-bit
    registers. The size of the parameter''s type must be equal to the size of the
    register or HLA will report an error. Here is a concrete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'One nice feature to this syntax is that you can call a procedure that has register
    parameters exactly like any other procedure in HLA using the high-level syntax.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: If you specify the same register as an actual parameter that you've declared
    for the formal parameter, HLA does not emit any extra code; it assumes that the
    parameter's value is already in the appropriate register. For example, in the
    call above, the first actual parameter is the value in ECX; because the procedure's
    declaration specifies that first parameter is in ECX, HLA will not emit any code.
    On the other hand, the second actual parameter is in BL, but the procedure will
    expect this parameter value in AL. Therefore, HLA will emit a `mov( bl, al );`
    instruction prior to calling the procedure so that the value is in the proper
    register upon entry to the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also pass parameters by reference in a register. Consider the following
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'A call to this procedure always requires some memory operand as the actual
    parameter. HLA will emit the code to load the address of that memory object into
    the parameter''s register (EDI in this case). Note that when passing reference
    parameters, the register must be a 32-bit general-purpose register because addresses
    are 32 bits long. Here''s an example of a call to `HasRefRegParm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: HLA will emit either a `mov( &x, edi);` or `lea( edi, x);` instruction to load
    the address of `x` into the EDI registers prior to the `call` instruction.^([[87](#ftn.CHP-5-FN-18)])
  prefs: []
  type: TYPE_NORMAL
- en: If you pass an anonymous memory object (for example, `[edi]` or `[ecx]`) as
    a parameter to `HasRefRegParm`, HLA will not emit any code if the memory reference
    uses the same register that you declare for the parameter (i.e., `[edi]`). It
    will use a simple `mov` instruction to copy the actual address into EDI if you
    specify an indirect addressing mode using a register other than EDI (e.g., `[ecx]`).
    It will use a `lea` instruction to compute the effective address of the anonymous
    memory operand if you use a more complex addressing mode like `[edi+ecx*4+2]`.
  prefs: []
  type: TYPE_NORMAL
- en: Within the procedure's code, HLA creates text equates for those register parameters
    that map their names to the appropriate register. In the `HasRegParms` example,
    any time you reference the `count` parameter, HLA substitutes `ecx` for `count`.
    Likewise, HLA substitutes `al` for `charVal` throughout the procedure's body.
    Because these names are aliases for the registers, you should take care to always
    remember that you cannot use ECX and AL independently of these parameters. It
    would be a good idea to place a comment next to each use of these parameters to
    remind the reader that `count` is equivalent to ECX and `charVal` is equivalent
    to AL.
  prefs: []
  type: TYPE_NORMAL
- en: 5.17.2 Passing Parameters in the Code Stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another place where you can pass parameters is in the code stream immediately
    after the `call` instruction. Consider the following `print` routine that prints
    a literal string constant to the standard output device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Normally, a subroutine returns control to the first instruction immediately
    following the `call` instruction. Were that to happen here, the 80x86 would attempt
    to interpret the ASCII codes for "This . . . ." as an instruction. This would
    produce undesirable results. Fortunately, you can skip over this string when returning
    from the subroutine.
  prefs: []
  type: TYPE_NORMAL
- en: So how do you gain access to these parameters? Easy. The return address on the
    stack points at them. Consider the implementation of `print` appearing in [Example 5-12](ch05s17.html#print_procedure_implementation_open_pare
    "Example 5-12. Print procedure implementation (using code stream parameters)").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-12. Print procedure implementation (using code stream parameters)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides showing how to pass parameters in the code stream, the `print` routine
    also exhibits another concept: *variable-length parameters*. The string following
    the `call` can be any practical length. The zero terminating byte marks the end
    of the parameter list. There are two easy ways to handle variable-length parameters:
    Either use some special terminating value (like 0) or pass a special length value
    that tells the subroutine how many parameters you are passing. Both methods have
    their advantages and disadvantages. Using a special value to terminate a parameter
    list requires that you choose a value that never appears in the list. For example,
    `print` uses 0 as the terminating value, so it cannot print the NUL character
    (whose ASCII code is 0). Sometimes this isn''t a limitation. Specifying a special-length
    parameter is another mechanism you can use to pass a variable-length parameter
    list. While this doesn''t require any special codes or limit the range of possible
    values that can be passed to a subroutine, setting up the length parameter and
    maintaining the resulting code can be a real nightmare.^([[88](#ftn.CHP-5-FN-19)])'
  prefs: []
  type: TYPE_NORMAL
- en: Despite the convenience afforded by passing parameters in the code stream, there
    are some disadvantages to passing parameters there. First, if you fail to provide
    the exact number of parameters the procedure requires, the subroutine will get
    confused. Consider the `print` example. It prints a string of characters up to
    a zero-terminating byte and then returns control to the first instruction following
    the zero-terminating byte. If you leave off the zero-terminating byte, the `print`
    routine happily prints the following opcode bytes as ASCII characters until it
    finds a zero byte. Because zero bytes often appear in the middle of an instruction,
    the `print` routine might return control into the middle of some other instruction.
    This will probably crash the machine. Inserting an extra 0, which occurs more
    often than you might think, is another problem programmers have with the `print`
    routine. In such a case, the `print` routine would return upon encountering the
    first zero byte and attempt to execute the following ASCII characters as machine
    code. Once again, this usually crashes the machine. These are the some of the
    reasons why the HLA `stdout.put` code does *not* pass its parameters in the code
    stream. Problems notwithstanding, however, the code stream is an efficient place
    to pass parameters whose values do not change.
  prefs: []
  type: TYPE_NORMAL
- en: 5.17.3 Passing Parameters on the Stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most high-level languages use the stack to pass parameters because this method
    is fairly efficient. By default, HLA also passes parameters on the stack. Although
    passing parameters on the stack is slightly less efficient than passing those
    parameters in registers, the register set is very limited and you can pass only
    a few value or reference parameters through registers. The stack, on the other
    hand, allows you to pass a large amount of parameter data without any difficulty.
    This is the principal reason that most programs pass their parameters on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA typically passes parameters you specify using the high-level procedure
    call syntax on the stack. For example, suppose you define `strfill` from earlier
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Calls of the form `strfill( s, ' ' );` will pass the value of `s` (which is
    an address) and a space character on the 80x86 stack. When you specify a call
    to `strfill` in this manner, HLA automatically pushes the parameters for you,
    so you don't have to push them onto the stack yourself. Of course, if you choose
    to do so, HLA will let you manually push the parameters onto the stack prior to
    the call.
  prefs: []
  type: TYPE_NORMAL
- en: 'To manually pass parameters on the stack, push them immediately before calling
    the subroutine. The subroutine then reads this data from the stack memory and
    operates on it appropriately. Consider the following HLA procedure call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'HLA pushes parameters onto the stack in the order that they appear in the parameter
    list.^([[89](#ftn.CHP-5-FN-20)]) Therefore, the 80x86 code that HLA emits for
    this subroutine call (assuming you''re passing the parameters by value) is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Upon entry into `CallProc`, the 80x86's stack looks like that shown in [Figure 5-7](ch05s17.html#stack_layout_upon_entry_into_callproc
    "Figure 5-7. Stack layout upon entry into CallProc").
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack layout upon entry into CallProc](tagoreillycom20100401nostarchimages578013.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-7. Stack layout upon entry into `CallProc`
  prefs: []
  type: TYPE_NORMAL
- en: 'You could gain access to the parameters passed on the stack by removing the
    data from the stack, as the following code fragment demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this code, it first pops the return address off the stack
    and into the `RtnAdrs` variable; then it pops (in reverse order) the values of
    the `p1`, `p2`, and `p3` parameters; finally, it pushes the return address back
    onto the stack (so the `ret` instruction will operate properly). Within the `CallProc`
    procedure, you may access the `p1Parm`, `p2Parm`, and `p3Parm` variables to use
    the `p1`, `p2`, and `p3` parameter values.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, a better way to access procedure parameters. If your procedure
    includes the standard entry and exit sequences, then you may directly access the
    parameter values in the activation record by indexing off the EBP register. Consider
    the layout of the activation record for `CallProc` that uses the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at the stack immediately after the execution of `mov( esp, ebp );`
    in `CallProc`. Assuming you've pushed three double-word parameters onto the stack,
    it should look something like that shown in [Figure 5-8](ch05s17.html#activation_record_for_callproc_after_sta
    "Figure 5-8. Activation record for CallProc after standard entry sequence execution").
  prefs: []
  type: TYPE_NORMAL
- en: '![Activation record for CallProc after standard entry sequence execution](tagoreillycom20100401nostarchimages578015.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-8. Activation record for `CallProc` after standard entry sequence execution
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can access the parameters by indexing off the EBP register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Of course, as with local variables, you'd never really access the parameters
    in this way. You can use the formal parameter names (`p1`, `p2`, and `p3`), and
    HLA will substitute a suitable `[ebp+displacement]` memory address. Even though
    you shouldn't actually access parameters using address expressions like `[ebp+12]`,
    it's important to understand their relationship to the parameters in your procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Other items that often appear in the activation record are register values that
    your procedure preserves. The most rational place to preserve registers in a procedure
    is in the code immediately following the standard entry sequence. In a standard
    HLA procedure (one where you do not specify the `@noframe` option), this simply
    means that the code that preserves the registers should appear first in the procedure's
    body. Likewise, the code to restore those register values should appear immediately
    before the `end` clause for the procedure.^([[90](#ftn.CHP-5-FN-21)])
  prefs: []
  type: TYPE_NORMAL
- en: 5.17.3.1 Accessing Value Parameters on the Stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Accessing parameters passed by value is no different from accessing a local
    `var` object. As long as you've declared the parameter in a formal parameter list
    and the procedure executes the standard entry sequence upon entry into the program,
    all you need do is specify the parameter's name to reference the value of that
    parameter. [Example 5-13](ch05s17.html#demonstration_of_value_parameters "Example 5-13. Demonstration
    of value parameters") provides an example program whose procedure accesses a parameter
    the main program passes to it by value.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-13. Demonstration of value parameters
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Although you could access the value of `theParameter` using the anonymous address
    `[EBP+8]` within your code, there is absolutely no good reason for doing so. If
    you declare the parameter list using the HLA high-level language syntax, you can
    access the value parameter by specifying its name within the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 5.17.3.2 Passing Value Parameters on the Stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As [Example 5-13](ch05s17.html#demonstration_of_value_parameters "Example 5-13. Demonstration
    of value parameters") demonstrates, passing a value parameter to a procedure is
    very easy. Just specify the value in the actual parameter list as you would for
    a high-level language call. Actually, the situation is a little more complicated
    than this. Passing value parameters is easy if you're passing constant, register,
    or variable values. It gets a little more complex if you need to pass the result
    of some expression. This section deals with the different ways you can pass a
    parameter by value to a procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you do not have to use the HLA high-level syntax to pass value parameters
    to a procedure. You can push these values on the stack yourself. Because many
    times it is more convenient or more efficient to manually pass the parameters,
    describing how to do this is a good place to start.
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier in this chapter, when passing parameters on the stack you push
    the objects in the order they appear in the formal parameter list (from left to
    right). When passing parameters by value, you should push the values of the actual
    parameters onto the stack. The program in [Example 5-14](ch05s17.html#manually_passing_parameters_on_the_stack
    "Example 5-14. Manually passing parameters on the stack") demonstrates how to
    do this.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-14. Manually passing parameters on the stack
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you manually push the parameters onto the stack as this example
    does, you must use the `call` instruction to call the procedure. If you attempt
    to use a procedure invocation of the form `ThreeValueParms();`, then HLA will
    complain about a mismatched parameter list. HLA won't realize that you've manually
    pushed the parameters (as far as HLA is concerned, those pushes appear to preserve
    some other data).
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, there is little reason to manually push a parameter onto the stack
    if the actual parameter is a constant, a register value, or a variable. HLA''s
    high-level syntax handles most such parameters for you. There are several instances,
    however, where HLA''s high-level syntax won''t work. The first such example is
    passing the result of an arithmetic expression as a value parameter. Because runtime
    arithmetic expressions don''t exist in HLA, you will have to manually compute
    the result of the expression and pass that value yourself. There are two possible
    ways to do this: calculate the result of the expression and manually push that
    result onto the stack, or compute the result of the expression into a register
    and pass the register as a parameter to the procedure. The program in [Example 5-15](ch05s17.html#passing_the_result_of_some_arithmetic_ex
    "Example 5-15. Passing the result of some arithmetic expression as a parameter")
    demonstrates these two mechanisms.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-15. Passing the result of some arithmetic expression as a parameter
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The examples up to this point in this section have made an important assumption:
    that the parameter you are passing is a double-word value. The calling sequence
    changes somewhat if you''re passing parameters that are not 4-byte objects. Because
    HLA can generate relatively inefficient code when passing objects that are not
    4 bytes long, manually passing such objects is a good idea if you want to have
    the fastest possible code.'
  prefs: []
  type: TYPE_NORMAL
- en: HLA requires that all value parameters be a multiple of 4 bytes long.^([[91](#ftn.CHP-5-FN-22)])
    If you pass an object that is less than 4 bytes long, HLA requires that you *pad*
    the parameter data with extra bytes so that you always pass an object that is
    at least 4 bytes in length. For parameters that are larger than 4 bytes, you must
    ensure that you pass a multiple of 4 bytes as the parameter value, adding extra
    bytes at the high-order end of the object to pad it, as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following procedure prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The activation record for this procedure appears in [Figure 5-9](ch05s17.html#onebyteparm_activation_record
    "Figure 5-9. OneByteParm activation record").
  prefs: []
  type: TYPE_NORMAL
- en: '![OneByteParm activation record](tagoreillycom20100401nostarchimages578017.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-9. `OneByteParm` activation record
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are 4 bytes on the stack associated with the `b` parameter,
    but only 1 of the 4 bytes contains valid data (the L.O. byte). The remaining 3
    bytes are just padding, and the procedure should ignore these bytes. In particular,
    you should never assume that these extra bytes contain 0s or some other consistent
    value. Depending on the type of parameter you pass, HLA's automatic code generation
    may or may not push 0 bytes as the extra data on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'When passing a byte parameter to a procedure, HLA will automatically emit code
    that pushes 4 bytes onto the stack. Because HLA''s parameter-passing mechanism
    guarantees not to disturb any register or other values, HLA sometimes generates
    more code than is actually needed to pass a byte parameter. For example, if you
    decide to pass the AL register as the byte parameter, HLA will emit code that
    pushes the EAX register onto the stack. This single push instruction is a very
    efficient way to pass AL as a 4-byte parameter object. On the other hand, if you
    decide to pass the AH register as the byte parameter, pushing EAX won''t work
    because this would leave the value in AH at offset EBP+9 in the activation record
    shown in [Figure 5-9](ch05s17.html#onebyteparm_activation_record "Figure 5-9. OneByteParm
    activation record"). Unfortunately, the procedure expects this value at offset
    EBP+8, so simply pushing EAX won''t do the job. If you pass AH, BH, CH, or DH
    as a byte parameter, HLA emits code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: As you can clearly see, passing one of the H registers as a byte parameter is
    less efficient than passing one of the L registers. So you should attempt to use
    the L registers whenever possible if passing an 8-bit register as a parameter.^([[92](#ftn.CHP-5-FN-23)])
    Note, by the way, that there is very little you can do about the efficiency issue,
    even if you manually pass the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the byte parameter you decide to pass is a variable rather than a register,
    HLA generates decidedly worse code. For example, suppose you call `OneByteParm`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'For this call, HLA will emit code similar to the following to push this single-byte
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: As you can plainly see, this is a lot of code to pass a single byte onto the
    stack! HLA emits this much code because (1) it guarantees not to disturb any registers,
    and (2) it doesn't know whether *`uns8Var`* is the last variable in allocated
    memory. You can generate much better code if you don't have to enforce either
    of these two constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a spare 32-bit register lying around (especially one of EAX, EBX,
    ECX, or EDX), then you can pass a byte parameter onto the stack using only two
    instructions. Move (or move with zero/sign extension) the byte value into the
    register and then push the register onto the stack. For the current call to `OneByteParm`,
    the calling sequence would look like the following if EAX is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'If only ESI or EDI is available, you could use code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Another trick you can use to pass the parameter with only a single `push` instruction
    is to coerce the byte variable to a double-word object. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This last example is very efficient. Note that it pushes the first 3 bytes of
    whatever value happens to follow *`uns8Var`* in memory as the padding bytes. HLA
    doesn't use this technique because there is a (very tiny) chance that using this
    scheme will cause the program to fail. If it turns out that the *`uns8Var`* object
    is the last byte of a given page in memory and the next page of memory is unreadable,
    the `push` instruction will cause a memory access exception. To be on the safe
    side, the HLA compiler does not use this scheme. However, if you always ensure
    that the actual parameter you pass in this fashion is not the last variable you
    declare in a `static` section, then you can get away with code that uses this
    technique. Because it is nearly impossible for the byte object to appear at the
    last accessible address on the stack, it is probably safe to use this technique
    with `var` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'When passing word parameters on the stack, you must also ensure that you include
    padding bytes so that each parameter consumes a multiple of 4 bytes. You can use
    the same techniques we use to pass bytes, except, of course, there are two valid
    bytes of data to pass instead of one. For example, you could use either of the
    following two schemes to pass a word object `w` to a `OneWordParm` procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: When passing large objects by value on the stack (e.g., records and arrays),
    you do not have to ensure that each element or field of the object consumes a
    multiple of 4 bytes; all you need to do is ensure that the entire data structure
    consumes a multiple of 4 bytes on the stack. For example, if you have an array
    of ten 3-byte elements, the entire array will need 2 bytes of padding (10 * 3
    is 30 bytes, which is not divisible by 4, but 10 * 3 + 2 is 32, which is divisible
    by 4). HLA does a fairly good job of passing large data objects by value to a
    procedure. For larger objects, you should use the HLA high-level language procedure
    invocation syntax unless you have some special requirements. Of course, if you
    want efficient operation, you should try to avoid passing large data structures
    by value.
  prefs: []
  type: TYPE_NORMAL
- en: By default, HLA guarantees that it won't disturb the values of any registers
    when it emits code to pass parameters to a procedure. Sometimes this guarantee
    isn't necessary. For example, if you are returning a function result in EAX and
    you are not passing a parameter to a procedure in EAX, there really is no reason
    to preserve EAX upon entry into the procedure. Rather than generating some crazy
    code like the following to pass a byte parameter,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: HLA could generate much better code if it knows that it can use EAX (or some
    other register) as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `@use` procedure option to tell HLA that it can modify a register''s
    value if doing so would improve the code it generates when passing parameters.
    The syntax for this option is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The *`reg32`* operand can be EAX, EBX, ECX, EDX, ESI, or EDI. You'll obtain
    the best results if this register is one of EAX, EBX, ECX, or EDX. You should
    note that you cannot specify EBP or ESP here (because the procedure already uses
    those registers).
  prefs: []
  type: TYPE_NORMAL
- en: The `@use` procedure option tells HLA that it's okay to modify the value of
    the register you specify as an operand. Therefore, if HLA can generate better
    code by not preserving that register's value, it will do so. For example, when
    the `@use eax;` option is provided for the `OneByteParm` procedure given earlier,
    HLA will only emit the two instructions immediately above rather than the five-instruction
    sequence that preserves EAX.
  prefs: []
  type: TYPE_NORMAL
- en: You must exercise care when specifying the `@use` procedure option. In particular,
    you should not be passing any parameters in the same register you specify in the
    `@use` option (because HLA may inadvertently scramble the parameter's value if
    you do this). Likewise, you must ensure that it's really okay for the procedure
    to change the register's value. As noted above, the best choice for an `@use`
    register is EAX when the procedure is returning a function result in EAX (because,
    clearly, the caller will not expect the procedure to preserve EAX).
  prefs: []
  type: TYPE_NORMAL
- en: If your procedure has a `forward` or `external` declaration (see [5.24 Units
    and the external Directive](ch05s24.html "5.24 Units and the external Directive")),
    the `@use` option must appear only in the `forward` or `external` definition,
    not in the actual procedure declaration. If no such procedure prototype appears,
    then you must attach the `@use` option to the procedure declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'This call to `OneByteParm` emits the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 5.17.3.3 Accessing Reference Parameters on the Stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because HLA passes the address for reference parameters, accessing the reference
    parameters within a procedure is slightly more difficult than accessing value
    parameters because you have to dereference the pointers to the reference parameters.
    Unfortunately, HLA's high-level syntax for procedure declarations and invocations
    does not (and cannot) abstract this detail away for you. You will have to manually
    dereference these pointers yourself. This section reviews how you do this.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 5-16](ch05s17.html#accessing_a_reference_parameter "Example 5-16. Accessing
    a reference parameter") the `RefParm` procedure has a single pass-by-reference
    parameter. A pass-by-reference parameter is always a pointer to an object of the
    type specified by the parameter's declaration. Therefore, `theParameter` is actually
    an object of type `pointer to uns32` rather than an `uns32` value. In order to
    access the value associated with `theParameter`, this code has to load that double-word
    address into a 32-bit register and access the data indirectly. The `mov( theParameter,
    eax );` instruction in [Example 5-16](ch05s17.html#accessing_a_reference_parameter
    "Example 5-16. Accessing a reference parameter") fetches this pointer into the
    EAX register, and then procedure `RefParm` uses the `[eax]` addressing mode to
    access the actual value of `theParameter`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-16. Accessing a reference parameter
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Because this procedure accesses the data of the actual parameter, adding 2 to
    this data affects the values of the variables passed to the `RefParm` procedure
    from the main program. Of course, this should come as no surprise because these
    are the standard semantics for pass-by-reference parameters.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, accessing (small) pass-by-reference parameters is a little less
    efficient than accessing value parameters because you need an extra instruction
    to load the address into a 32-bit pointer register (not to mention you have to
    reserve a 32-bit register for this purpose). If you access reference parameters
    frequently, these extra instructions can really begin to add up, reducing the
    efficiency of your program. Furthermore, it's easy to forget to dereference a
    reference parameter and use the address of the value in your calculations (this
    is especially true when passing double-word parameters, like the `uns32` parameter
    in the example above, to your procedures). Therefore, unless you really need to
    affect the value of the actual parameter, you should use pass by value to pass
    small objects to a procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Passing large objects, like arrays and records, is where using reference parameters
    becomes efficient. When passing these objects by value, the calling code has to
    make a copy of the actual parameter; if the actual parameter is a large object,
    the copy process can be very inefficient. Because computing the address of a large
    object is just as efficient as computing the address of a small scalar object,
    there is no efficiency loss when passing large objects by reference. Within the
    procedure, you must still dereference the pointer to access the object, but the
    efficiency loss due to indirection is minimal when you contrast this with the
    cost of copying that large object. The program in [Example 5-17](ch05s17.html#passing_an_array_of_records_by_referenci
    "Example 5-17. Passing an array of records by referencing") demonstrates how to
    use pass by reference to initialize an array of records.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-17. Passing an array of records by referencing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this example, passing large objects by reference is relatively
    efficient. Other than tying up the EDX register throughout the `RefArrayParm`
    procedure, plus a single instruction to load EDX with the address of the reference
    parameter, the `RefArrayParm` procedure doesn't require many more instructions
    than the same procedure where you would pass the parameter by value.
  prefs: []
  type: TYPE_NORMAL
- en: 5.17.3.4 Passing Reference Parameters on the Stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HLA's high-level syntax often makes passing reference parameters a breeze. All
    you need to do is specify the name of the actual parameter you wish to pass in
    the procedure's parameter list. HLA will automatically emit some code that will
    compute the address of the specified actual parameter and push this address onto
    the stack. However, like the code HLA emits for value parameters, the code HLA
    generates to pass the address of the actual parameter on the stack may not be
    the most efficient possible. Therefore, if you want to write fast code, you may
    want to manually write the code to pass reference parameters to a procedure. This
    section discusses how to do exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever you pass a static object as a reference parameter, HLA generates very
    efficient code to pass the address of that parameter to the procedure. As an example,
    consider the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'For the call to the `HasRefParm` procedure, HLA emits the following instruction
    sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: You really aren't going to be able to do substantially better than this if you
    are passing your reference parameters on the stack. So if you're passing static
    objects as reference parameters, HLA generates fairly good code, and you should
    stick with the high-level syntax for the procedure call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, when passing automatic (`var`) objects or indexed variables
    as reference parameters, HLA needs to compute the address of the object at runtime.
    This may require the use of the `lea` instruction. Unfortunately, the `lea` instruction
    requires a 32-bit register, and HLA promises not to disturb the values in any
    registers when it automatically generates code for you.^([[93](#ftn.CHP-5-FN-24)])
    Therefore, HLA needs to preserve the value in whatever register it uses when it
    computes an address via `lea` to pass a parameter by reference. The following
    example shows you the code that HLA actually emits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is quite a bit of code, especially if you have a 32-bit
    register available and you don't need to preserve that register's value. The following
    is a better code sequence given the availability of EAX.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, when passing an actual parameter by reference, you must compute the
    address of that object and push the address onto the stack. For simple static
    objects you can use the address-of operator (`&`) to easily compute the address
    of the object and push it onto the stack; however, for indexed and automatic objects,
    you will probably need to use the `lea` instruction to compute the address of
    the object. Here are some examples that demonstrate this using the `HasRefParm`
    procedure from the previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have an extra register to spare, you can tell HLA to use that register
    when computing the address-of reference parameters (without emitting the code
    to preserve that register''s value). The `@use` option will tell HLA that it''s
    okay to use the specified register without preserving its value. As noted in the
    section on value parameters, the syntax for this procedure option is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: where *`reg32`* may be any of EAX, EBX, ECX, EDX, ESI, or EDI. Because reference
    parameters always pass a 32-bit value, all of these registers are equivalent as
    far as HLA is concerned (unlike value parameters that may prefer the EAX, EBX,
    ECX, or EDX register). Your best choice would be EAX if the procedure is not passing
    a parameter in the EAX register and the procedure is returning a function result
    in EAX; otherwise, any currently unused register will work fine.
  prefs: []
  type: TYPE_NORMAL
- en: With the `@use eax`; option, HLA emits the shorter code given in the previous
    examples. It does not emit all the extra instructions needed to preserve EAX's
    value. This makes your code much more efficient, especially when passing several
    parameters by reference or when calling procedures with reference parameters several
    times.
  prefs: []
  type: TYPE_NORMAL
- en: 5.17.3.5 Passing Formal Parameters as Actual Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The examples in the previous two sections show how to pass static and automatic
    variables as parameters to a procedure, either by value or by reference. There
    is one situation that these examples don''t handle properly: the case when you
    are passing a formal parameter in one procedure as an actual parameter to another
    procedure. The following simple example demonstrates the different cases that
    can occur for pass-by-value and pass-by-reference parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: In the statement labeled `(1)` above, procedure `p2` calls procedure `p1` and
    passes its two formal parameters as parameters to `p1`. Note that this code passes
    the first parameter of both procedures by value, and it passes the second parameter
    of both procedures by reference. Therefore, in statement `(1)`, the program passes
    the `v2` parameter into `p2` by value and passes it on to `p1` by value; likewise,
    the program passes `r2` in by reference and it passes the value onto `p1` by reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `p2`''s caller passes `v2` in by value and `p2` passes this parameter
    to `p1` by value, all the code needs to do is make a copy of `v2`''s value and
    pass this on to `p1`. The code to do this is nothing more than a single `push`
    instruction. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this code is identical to passing an automatic variable by value.
    Indeed, it turns out that the code you need to write to pass a value parameter
    to another procedure is identical to the code you would write to pass a local
    automatic variable to that other procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing `r2` in statement `(1)` above requires a little more thought. You do
    not take the address of `r2` using the `lea` instruction as you would a value
    parameter or an automatic variable. When passing `r2` on through to `p1`, the
    author of this code probably expects the `r` formal parameter to contain the address
    of the variable whose address `p2`''s caller passed into `p2`. In plain English,
    this means that `p2` must pass the address of `r2`''s actual parameter on through
    to `p1`. Because the `r2` parameter is a double-word value containing the address
    of the corresponding actual parameter, this means that the code must pass the
    double-word value of `r2` on to `p1`. The complete code for statement `(1)` above
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The important thing to note in this example is that passing a formal reference
    parameter (`r2`) as an actual reference parameter (`r`) does not involve taking
    the address of the formal parameter (`r2`). `p2`'s caller has already done this;
    `p2` simply passes this address on through to `p1`.
  prefs: []
  type: TYPE_NORMAL
- en: In the second call to `p1` in the example above (`2`), the code swaps the actual
    parameters so that the call to `p1` passes `r2` by value and `v2` by reference.
    Specifically, `p1` expects `p2` to pass it the value of the double-word object
    associated with `r2`; likewise, it expects `p2` to pass it the address of the
    value associated with `v2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pass the value of the object associated with `r2`, your code must dereference
    the pointer associated with `r2` and directly pass the value. Here is the code
    HLA automatically generates to pass `r2` as the first parameter to `p1` in statement
    `(2)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, HLA generates a little more code than may be necessary because it
    won''t destroy the value in the EAX register (you may use the `@use` procedure
    option to tell HLA that it''s okay to use EAX''s value, thereby reducing the code
    it generates). You can write more efficient code if a register is available to
    use in this sequence. If EAX is unused, you could trim this down to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Because you can treat value parameters exactly like local (automatic) variables,
    you use the same code to pass `v2` by reference to `p1` as you would to pass a
    local variable in `p2` to `p1`. Specifically, you use the `lea` instruction to
    compute the address of the value in the `v2`. The code HLA automatically emits
    for statement `(2)` above preserves all registers and takes the following form
    (same as passing an automatic variable by reference):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, if you have a register available, you can improve on this code.
    Here''s the complete code that corresponds to statement `(2)` above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 5.17.3.6 HLA Hybrid Parameter-Passing Facilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like control structures, HLA provides a high-level language syntax for procedure
    calls that is convenient to use and easy to read. However, this high-level language
    syntax is sometimes inefficient and may not provide the capabilities you need
    (for example, you cannot specify an arithmetic expression as a value parameter
    as you can in high-level languages). HLA lets you overcome these limitations by
    writing low-level ("pure") assembly language code. Unfortunately, low-level code
    is harder to read and maintain than procedure calls that use high-level syntax.
    Furthermore, it's quite possible that HLA generates perfectly fine code for certain
    parameters, while only one or two parameters present a problem. Fortunately, HLA
    provides a hybrid syntax for procedure calls that allows you to use both high-level
    and low-level syntax as appropriate for a given actual parameter. This lets you
    use high-level syntax where appropriate and then drop down into pure assembly
    language to pass those special parameters that HLA's high-level language syntax
    cannot handle efficiently (if at all).
  prefs: []
  type: TYPE_NORMAL
- en: 'Within an actual parameter list (using the high-level language syntax), if
    HLA encounters `#{` followed by a sequence of statements and a closing `}#`, HLA
    will substitute the instructions between the braces in place of the code it would
    normally generate for that parameter. For example, consider the following code
    fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The call to `HybridCall` immediately above is equivalent to the following "pure"
    assembly language code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'As a second example, consider the example from the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: HLA generates exceedingly mediocre code for the second call to `p1` in this
    example. If efficiency is important in the context of this procedure call, and
    you have a free register available, you might want to rewrite this code as follows:^([[94](#ftn.CHP-5-FN-25)])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Note that specifying the `@use reg;` option tells HLA that the register is always
    available for use wherever you call a procedure. If there is one case where the
    procedure's invocation must preserve the specified register, then you cannot use
    the `@use` option to generate better code. However, you may use the hybrid parameter-passing
    mechanism on a case-by-base basis to improve the performance of those particular
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: 5.17.3.7 Mixing Register and Stack-Based Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can mix register parameters and standard (stack-based) parameters in the
    same high-level procedure declaration. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: When constructing the activation record, HLA ignores the parameters you pass
    in registers and processes only those parameters you pass on the stack. Therefore,
    a call to the `HasBothRegAndStack` procedure will push only a single parameter
    onto the stack (`count`). It will pass the `dest` parameter in the EDI register.
    When this procedure returns to its caller, it will remove only 4 bytes of parameter
    data from the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Note that when you pass a parameter in a register, you should avoid specifying
    that same register in the `@use` procedure option. In the example above, HLA might
    not generate any code whatsoever at all for the `dest` parameter (because the
    value is already in EDI). Had you specified `@use edi;` and HLA decided it was
    okay to disturb EDI's value, this would destroy the parameter value in EDI; that
    won't actually happen in this particular example (because HLA never uses a register
    to pass a double-word value parameter like `count`), but keep this issue in mind.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[87](#CHP-5-FN-18)]) The choice of instructions is dictated by whether `x`
    is a static variable (`mov` for static objects, `lea` for other objects).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[88](#CHP-5-FN-19)]) This is especially true if the parameter list changes
    frequently.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[89](#CHP-5-FN-20)]) This assumes, of course, that you don't instruct HLA
    otherwise. It is possible to tell HLA to reverse the order of the parameters on
    the stack. See the electronic edition for more details.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[90](#CHP-5-FN-21)]) Note that if you use the `exit` statement to exit a
    procedure, you must duplicate the code to pop the register values and place this
    code immediately before the `exit` clause. This is a good example of a maintenance
    nightmare and is also a good reason why you should have only one exit point in
    your program.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[91](#CHP-5-FN-22)]) This applies only if you use the HLA high-level-language
    syntax to declare and access parameters in your procedures. Of course, if you
    manually push the parameters yourself and you access the parameters inside the
    procedure using an addressing mode like `[ebp+8]`, then you can pass any size
    object you choose. Of course, keep in mind that most operating systems expect
    the stack to be dword aligned, so parameters you push should be a multiple of
    4 bytes long.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[92](#CHP-5-FN-23)]) Or better yet, pass the parameter directly in the register
    if you are writing the procedure yourself.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[93](#CHP-5-FN-24)]) This isn't entirely true. You'll see the exception in
    [Chapter 12](ch12.html "Chapter 12. CLASSES AND OBJECTS"). Also, using the @use
    procedure option tells HLA that it's okay to modify the value in one of the registers.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[94](#CHP-5-FN-25)]) Of course, you could also use the `@use eax`; procedure
    option to achieve the same effect in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 5.18 Procedure Pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The 80x86 `call` instruction allows three basic forms: direct calls (via a
    procedure name), indirect calls through a 32-bit general-purpose register, and
    indirect calls through a double-word pointer variable. The `call` instruction
    supports the following (low-level) syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: The first form we've been using throughout this chapter, so there is little
    need to discuss it here. The second form, the register indirect call, calls the
    procedure whose address is held in the specified 32-bit register. The address
    of a procedure is the byte address of the first instruction to execute within
    that procedure. Remember, on a Von Neumann architecture machine (like the 80x86),
    the system stores machine instructions in memory along with other data. The CPU
    fetches the instruction opcode values from memory prior to executing them. When
    you execute the register indirect `call` instruction, the 80x86 first pushes the
    return address onto the stack and then begins fetching the next opcode byte (instruction)
    from the address specified by the register's value.
  prefs: []
  type: TYPE_NORMAL
- en: The third form of the call instruction above fetches the address of some procedure's
    first instruction from a double-word variable in memory. Although this instruction
    suggests that the call uses the displacement-only addressing mode, you should
    realize that any legal memory addressing mode is legal here; for example, `call(
    procPtrTable[ebx*4] );` is perfectly legitimate; this statement fetches the double
    word from the array of double words (`procPtrTable`) and calls the procedure whose
    address is the value contained within that double word.
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA treats procedure names like static objects. Therefore, you can compute
    the address of a procedure by using the address-of (`&`) operator along with the
    procedure''s name or by using the `lea` instruction. For example, `&Procname`
    is the address of the very first instruction of the `Procname` procedure. So all
    three of the following code sequences wind up calling the `Procname` procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the address of a procedure fits in a 32-bit object, you can store such
    an address into a double-word variable; in fact, you can initialize a double-word
    variable with the address of a procedure using code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the use of procedure pointers occurs frequently in assembly language
    programs, HLA provides a special syntax for declaring procedure pointer variables
    and for calling procedures indirectly through such pointer variables. To declare
    a procedure pointer in an HLA program, you can use a variable declaration like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this syntax uses the keyword `procedure` as a data type. It follows
    the variable name and a colon in one of the variable declaration sections (`static`,
    `readonly`, `storage`, or `var`). This sets aside exactly 4 bytes of storage for
    the *`procPtr`* variable. To call the procedure whose address is held by *`procPtr`*,
    you can use either of the following two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Note that the high-level syntax for an indirect procedure call is identical
    to the high-level syntax for a direct procedure call. HLA can figure out whether
    to use a direct call or an indirect call by the type of the identifier. If you've
    specified a variable name, HLA assumes it needs to use an indirect call; if you
    specify a procedure name, HLA uses a direct call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like all pointer objects, you should not attempt to indirectly call a procedure
    through a pointer variable unless you''ve initialized that variable with an appropriate
    address. There are two ways to initialize a procedure pointer variable: `static`
    and `readonly` objects allow an initializer, or you can compute the address of
    a routine (as a 32-bit value) and store that 32-bit address directly into the
    procedure pointer at runtime. The following code fragment demonstrates both ways
    you can initialize a procedure pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Procedure pointer variable declarations also allow the declaration of parameters.
    To declare a procedure pointer with parameters, you must use a declaration like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'This declaration states that `p` is a 32-bit pointer that contains the address
    of a procedure requiring two parameters. If desired, you could also initialize
    this variable `p` with the address of some procedure by using a static initializer.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that *`SomeProcedure`* must be a procedure whose parameter list exactly
    matches `p`''s parameter list (i.e., two value parameters, the first is an `int32`
    parameter and the second is a `char` parameter). To indirectly call this procedure,
    you could use either of the following sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: The high-level language syntax has the same features and restrictions as the
    high-level syntax for a direct procedure call. The only difference is the actual
    `call` instruction HLA emits at the end of the calling sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although all the examples in this section use `static` variable declarations,
    don''t get the idea that you can declare simple procedure pointers only in the
    `static` or other variable declaration sections. You can also declare procedure
    pointer types in the `type` section, and you can declare procedure pointers as
    fields of a `record` or a `union`. Assuming you create a type name for a procedure
    pointer in the `type` section, you can even create arrays of procedure pointers.
    The following code fragments demonstrate some of the possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: One very important thing to keep in mind when using procedure pointers is that
    HLA does not (and cannot) enforce strict type checking on the pointer values you
    assign to a procedure pointer variable. In particular, if the parameter lists
    do not agree between the declarations of the pointer variable and the procedure
    whose address you assign to the pointer variable, the program will probably crash
    when you attempt to call the mismatched procedure indirectly through the pointer
    using the high-level syntax. Like the low-level "pure" procedure calls, it is
    your responsibility to ensure that the proper number and types of parameters are
    on the stack prior to the call.
  prefs: []
  type: TYPE_NORMAL
- en: 5.19 Procedural Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One place where procedure pointers are quite invaluable is in parameter lists.
    Selecting one of several procedures to call by passing the address of some procedure
    is a common operation. Therefore, HLA lets you declare procedure pointers as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is nothing special about a procedure parameter declaration. It looks
    exactly like a procedure variable declaration except it appears within a parameter
    list rather than within a variable declaration section. The following are some
    typical procedure prototypes that demonstrate how to declare such parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The last example above is identical to the first. It does point out, though,
    that you generally pass procedural parameters by value. This may seem counterintuitive
    because procedure pointers are addresses and you will need to pass an address
    as the actual parameter; however, a pass-by-reference procedure parameter means
    something else entirely. Consider the following (legal!) declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: This declaration tells HLA that you are passing a procedure *variable* by reference
    to `p4`. The address HLA expects must be the address of a procedure pointer variable,
    not a procedure.
  prefs: []
  type: TYPE_NORMAL
- en: When passing a procedure pointer by value, you may specify either a procedure
    variable (whose value HLA passes to the actual procedure) or a procedure pointer
    constant. A procedure pointer constant consists of the address-of operator (`&`)
    immediately followed by a procedure name. Passing procedure constants is probably
    the most convenient way to pass procedural parameters. For example, the following
    calls to the `Plot` routine might plot out the function passed as a parameter
    from −2 to +2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you cannot pass a procedure as a parameter by simply specifying the
    procedure''s name. That is, `Plot( sineFunc )`; will not work. Simply specifying
    the procedure name doesn''t work because HLA will attempt to directly call the
    procedure whose name you specify (remember, a procedure name inside a parameter
    list invokes instruction composition). If you did not specify a parameter list—or
    at least an empty pair of parentheses—after the parameter/procedure''s name, HLA
    would generate a syntax error message. Moral of the story: Don''t forget to preface
    procedure parameter constant names with the address-of operator (`&`).'
  prefs: []
  type: TYPE_NORMAL
- en: 5.20 Untyped Reference Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you will want to write a procedure to which you pass a generic memory
    object by reference without regard to the type of that memory object. A classic
    example is a procedure that zeros out some data structure. Such a procedure might
    have the following prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'This procedure would zero out `count` bytes starting at the address the first
    parameter specifies. The problem with this procedure prototype is that HLA will
    complain if you attempt to pass anything other than a byte object as the first
    parameter. Of course, you can overcome this problem using type coercion like the
    following, but if you call this procedure several times with a lot of different
    data types, then the following coercion operator is rather tedious to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you can always use hybrid parameter passing or manually push the
    parameters yourself, but these solutions are even more tedious than using the
    type coercion operation. Fortunately, HLA provides a convenient solution: untyped
    reference parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Untyped reference parameters are exactly that—pass-by-reference parameters
    for which HLA doesn''t bother to compare the type of the actual parameter against
    the type of the formal parameter. With an untyped reference parameter, the call
    to `ZeroMem` above would take the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '`MyDataObject` could be any type, and multiple calls to `ZeroMem` could pass
    different typed objects without any objections from HLA.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare an untyped reference parameter, you specify the parameter using
    the normal syntax except that you use the reserved word `var` in place of the
    parameter''s type. This `var` keyword tells HLA that any variable object is legal
    for that parameter. Note that you must pass untyped reference parameters by reference,
    so the `var` keyword must precede the parameter''s declaration as well. Here''s
    the correct declaration for the `ZeroMem` procedure using an untyped reference
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: With this declaration, HLA will compute the address of whatever memory object
    you pass as an actual parameter to `ZeroMem` and pass this on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 5.21 Managing Large Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most assembly language source files are not standalone programs. In general,
    you will call various standard library or other routines that are not defined
    in your main program. For example, you've probably noticed by now that the 80x86
    doesn't provide any machine instructions like `read`, `write`, or `put` for doing
    I/O operations. Of course, you can write your own procedures to accomplish this.
    Unfortunately, writing such routines is a complex task, and beginning assembly
    language programmers are not ready for such tasks. That's where the HLA Standard
    Library comes in. This is a package of procedures you can call to perform simple
    I/O operations like `stdout.put`.
  prefs: []
  type: TYPE_NORMAL
- en: The HLA Standard Library contains hundreds of thousands of lines of source code.
    Imagine how difficult programming would be if you had to merge these hundreds
    of thousands of lines of code into your simple programs! Imagine how slow compiling
    your programs would be if you had to compile those hundreds of thousands of lines
    with each program you write. Fortunately, you don't have to do this.
  prefs: []
  type: TYPE_NORMAL
- en: For small programs, working with a single source file is fine. For large programs,
    this gets very cumbersome (consider the example above of having to include the
    entire HLA Standard Library into each of your programs). Furthermore, once you've
    debugged and tested a large section of your code, continuing to assemble that
    same code when you make a small change to some other part of your program is a
    waste of time. The HLA Standard Library, for example, takes several minutes to
    assemble, even on a fast machine. Imagine having to wait 20 or 30 minutes on a
    fast PC to assemble a program to which you've made a one-line change!
  prefs: []
  type: TYPE_NORMAL
- en: As for high-level languages, the solution is *separate compilation*. First,
    you break up your large source files into manageable chunks. Then you compile
    the separate files into object code modules. Finally, you link the object modules
    together to form a complete program. If you need to make a small change to one
    of the modules, you only need to reassemble that one module; you do not need to
    reassemble the entire program.
  prefs: []
  type: TYPE_NORMAL
- en: The HLA Standard Library works in precisely this way. The Standard Library is
    already compiled and ready to use. You simply call routines in the Standard Library
    and link your code with the Standard Library using a *linker* program. This saves
    considerable time when developing a program that uses the Standard Library code.
    Of course, you can easily create your own object modules and link them together
    with your code. You could even add new routines to the Standard Library so they
    will be available for use in future programs you write.
  prefs: []
  type: TYPE_NORMAL
- en: '"Programming in the large" is the term software engineers have coined to describe
    the processes, methodologies, and tools for handling the development of large
    software projects. While everyone has their own idea of what "large" is, separate
    compilation is one of the more popular techniques that support "programming in
    the large." The following sections describe the tools HLA provides for separate
    compilation and how to effectively employ these tools in your programs.'
  prefs: []
  type: TYPE_NORMAL
- en: '5.22 The #include Directive'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `#include` directive, when encountered in a source file, switches program
    input from the current file to the file specified in the parameter list of the
    `#include` directive. This allows you to construct text files containing common
    constants, types, source code, and other HLA items and include such files into
    the assembly of several separate programs. The syntax for the `#include` directive
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '*`Filename`* must be a valid filename. HLA merges the specified file into the
    compilation at the point of the `#include` directive. Note that you can nest `#include`
    statements inside files you include. That is, a file being included into another
    file during assembly may itself include a third file. In fact, the *stdlib.hhf*
    header file you see in most example programs is really nothing more than a bunch
    of `#include` statements (see [Example 5-18](ch05s22.html#the_original_stdlib.hhf_header_file
    "Example 5-18. The original stdlib.hhf header file") for the original *stdlib.hhf*
    source code; note that this file is considerably different today, but the concept
    is still the same).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-18. The original *stdlib.hhf* header file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: By including *stdlib.hhf* in your source code, you automatically include all
    the HLA library modules. It's often more efficient (in terms of compile time and
    size of code generated) to provide only those `#include` statements for the modules
    you actually need in your program. However, including *stdlib.hhf* is extremely
    convenient and takes up less space in this text, which is why most programs appearing
    in this text use *stdlib.hhf*.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `#include` directive does not need to end with a semicolon. If
    you put a semicolon after the `#include`, that semicolon becomes part of the source
    file and is the first character following the included source during compilation.
    HLA generally allows spare semicolons in various parts of the program, so you
    will sometimes see an `#include` statement ending with a semicolon. In general,
    though, you should not get in the habit of putting semicolons after `#include`
    statements because there is the slight possibility this could create a syntax
    error in certain circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `#include` directive by itself does not provide separate compilation.
    You *could* use the `#include` directive to break up a large source file into
    separate modules and join these modules together when you compile your file. The
    following example would include the `printf.hla` and `putc.hla` files during the
    compilation of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Now your program `will` benefit from the modularity gained by this approach.
    Alas, you will not save any development time. The `#include` directive inserts
    the source file at the point of the `#include` during compilation, exactly as
    though you had typed that code yourself. HLA still has to compile the code, and
    that takes time. Were you to include all the files for the Standard Library routines
    in this manner, your compilations would take *forever*.
  prefs: []
  type: TYPE_NORMAL
- en: In general, you should *not* use the `#include` directive to include source
    code as shown above.^([[95](#ftn.CHP-5-FN-26)]) Instead, you should use the `#include`
    directive to insert a common set of constants, types, external procedure declarations,
    and other such items into a program. Typically an assembly language include file
    does *not* contain any machine code (outside of a macro; see [Chapter 9](ch09.html
    "Chapter 9. MACROS AND THE HLA COMPILE-TIME LANGUAGE") for details). The purpose
    of using `#include` files in this manner will become clearer after you see how
    the external declarations work.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[95](#CHP-5-FN-26)]) There is nothing wrong with this, other than the fact
    that it does not take advantage of separate compilation.
  prefs: []
  type: TYPE_NORMAL
- en: '5.23 Ignoring Duplicate #include Operations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you begin to develop sophisticated modules and libraries, you eventually
    discover a big problem: Some header files will need to include other header files
    (e.g., the *stdlib.hhf* header file includes all the other Standard Library header
    files). Well, this isn''t actually a big problem, but a problem will occur when
    one header file includes another, and that second header file includes another,
    and that third header file includes another, and . . . that last header file includes
    the first header file. Now *this* is a big problem.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two problems with a header file indirectly including itself. First,
    this creates an infinite loop in the compiler. The compiler will happily go on
    about its business including all these files over and over again until it runs
    out of memory or some other error occurs. Clearly this is not a good thing. The
    second problem that occurs (usually before the first problem) is that the second
    time HLA includes a header file, it starts complaining bitterly about duplicate
    symbol definitions. After all, the first time it reads the header file it processes
    all the declarations in that file; the second time around it views all those symbols
    as duplicate symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA provides a special include directive that eliminates this problem: `#includeonce`.
    You use this directive exactly like you use the `#include` directive. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: If *myHeaderFile.hhf* directly or indirectly includes itself (with a `#includeonce`
    directive), then HLA will ignore the new request to include the file. Note, however,
    that if you use the `#include` directive, rather than `#includeonce`, HLA will
    include the file a second time. This was done in case you really do need to include
    a header file twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom line is this: You should always use the `#includeonce` directive
    to include header files you''ve created. In fact, you should get in the habit
    of always using `#includeonce`, even for header files created by others (the HLA
    Standard Library already has provisions to prevent recursive includes, so you
    don''t have to worry about using `#includeonce` with the Standard Library header
    files).'
  prefs: []
  type: TYPE_NORMAL
- en: There is another technique you can use to prevent recursive includes—using conditional
    compilation. [Chapter 9](ch09.html "Chapter 9. MACROS AND THE HLA COMPILE-TIME
    LANGUAGE"), the chapter on macros and the HLA Compile-Time Language, discusses
    this option.
  prefs: []
  type: TYPE_NORMAL
- en: 5.24 Units and the external Directive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Technically, the `#include` directive provides you with all the facilities
    you need to create modular programs. You can create several modules, each containing
    some specific routine, and include those modules, as necessary, in your assembly
    language programs using `#include`. However, HLA provides a better way: external
    and public symbols.'
  prefs: []
  type: TYPE_NORMAL
- en: One major problem with the `#include` mechanism is that once you've debugged
    a routine, including it into a compilation still wastes time because HLA must
    recompile bug-free code every time you assemble the main program. A much better
    solution would be to preassemble the debugged modules and link the object code
    modules together. This is what the `external` directive allows you to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `external` facilities, you must create at least two source files.
    One file contains a set of variables and procedures used by the second. The second
    file uses those variables and procedures without knowing how they''re implemented.
    The only problem is that if you create two separate HLA programs, the linker will
    get confused when you try to combine them. This is because both HLA programs have
    their own main program. Which main program does the OS run when it loads the program
    into memory? To resolve this problem, HLA uses a different type of compilation
    module, the `unit`, to compile programs without a main program. The syntax for
    an HLA `unit` is actually simpler than that for an HLA program; it takes the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: With one exception (the `var` section), anything that can go in the declaration
    section of an HLA `program` can go into the declaration section of an HLA `unit`.
    Notice that a `unit` does not have a `begin` clause and there are no program statements
    in the unit;^([[96](#ftn.CHP-5-FN-27)]) a unit contains only declarations.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the fact that a unit does not contain a main program section,
    there is one other difference between units and programs. Units cannot have a
    `var` section. This is because the `var` section declares automatic variables
    that are local to the main program's source code. Because there is no "main program"
    associated with a unit, `var` sections are illegal.^([[97](#ftn.CHP-5-FN-28)])
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate, consider the two modules in [Example 5-19](ch05s24.html#example_of_a_simple_hla_unit
    "Example 5-19. Example of a simple HLA unit") and [Example 5-20](ch05s24.html#main_program_that_references_external_ob
    "Example 5-20. Main program that references external objects").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-19. Example of a simple HLA unit
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Example 5-20. Main program that references external objects
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: The main program references `Var1`, `Var2`, and `Add1and2`, yet these symbols
    are external to this program (they appear in unit `Number1`). If you attempt to
    compile the main program as it stands, HLA will complain that these three symbols
    are undefined.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, you must declare them external with the `external` option. An external
    procedure declaration looks just like a forward declaration except you use the
    reserved word `external` rather than `forward`. To declare external static variables,
    simply follow those variables' declarations with the reserved word `external`.
    The program in [Example 5-21](ch05s24.html#modified_main_program_with_external_decl
    "Example 5-21. Modified main program with external declarations") is a modification
    to the program in [Example 5-20](ch05s24.html#main_program_that_references_external_ob
    "Example 5-20. Main program that references external objects") that includes the
    external declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-21. Modified main program with external declarations
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: If you attempt to compile this second version of `main` using the typical HLA
    compilation command `HLA main2.hla`, you will be somewhat disappointed. This program
    will actually compile without error. However, when HLA attempts to link this code
    it will report that the symbols `Var1`, `Var2`, and `Add1and2` are undefined.
    This happens because you haven't compiled and linked in the associated unit with
    this main program. Before you try that and discover that it still doesn't work,
    you should know that all symbols in a unit, by default, are *private* to that
    unit. This means that those symbols are inaccessible in code outside that unit
    unless you explicitly declare those symbols as *public* symbols. To declare symbols
    as public, you simply put external declarations for those symbols in the unit
    before the actual symbol declarations. If an external declaration appears in the
    same source file as the actual declaration of a symbol, HLA assumes that the name
    is needed externally and makes that symbol a public (rather than private) symbol.
    The unit in [Example 5-22](ch05s24.html#correct_number1_unit_with_external_decla
    "Example 5-22. Correct Number1 unit with external declarations") is a correction
    to the `Number1` unit that properly declares the external objects.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-22. Correct `Number1` unit with external declarations
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: It may seem redundant declaring these symbols twice as occurs in [Example 5-21](ch05s24.html#modified_main_program_with_external_decl
    "Example 5-21. Modified main program with external declarations") and [Example 5-22](ch05s24.html#correct_number1_unit_with_external_decla
    "Example 5-22. Correct Number1 unit with external declarations"), but you'll soon
    see that you don't normally write the code this way.
  prefs: []
  type: TYPE_NORMAL
- en: If you attempt to compile the `main` program or the `Number1` unit using the
    typical HLA statement, that is,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'you''ll quickly discover that the linker still returns errors. It returns an
    error on the compilation of *main2.hla* because you still haven''t told HLA to
    link in the object code associated with *unit2.hla*. Likewise, the linker complains
    if you attempt to compile `unit2.hla` by itself because it can''t find a main
    program. The simple solution is to compile both of these modules together with
    the following single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: This command will properly compile both modules and link together their object
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the command above defeats one of the major benefits of separate
    compilation. When you issue this command it will compile both `main2` and `unit2`
    prior to linking them together. Remember, a major reason for separate compilation
    is to reduce compilation time on large projects. While the above command is convenient,
    it doesn't achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'To separately compile the two modules you must run HLA separately on them.
    Of course, you saw earlier that attempting to compile these modules separately
    produced linker errors. To get around this problem, you need to compile the modules
    without linking them. The `-c` (compile-only) HLA command-line option achieves
    this. To compile the two source files without running the linker, you would use
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces two object code files, `main2.obj` and `unit2.obj`, that you
    can link together to produce a single executable. You could run the linker program
    directly, but an easier way is to use the HLA compiler to link the object modules
    together for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Under Windows, this command produces an executable file named *main2.exe*;^([[98](#ftn.CHP-5-FN-29)])
    under Linux, Mac OS X, and FreeBSD this command produces a file named *main2*.
    You could also type the following command to compile the main program and link
    it with a previously compiled *unit2* object module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, HLA looks at the suffixes of the filenames following the HLA commands.
    If the filename doesn''t have a suffix, HLA assumes it to be *.HLA*. If the filename
    has a suffix, then HLA will do the following with the file:'
  prefs: []
  type: TYPE_NORMAL
- en: If the suffix is *.HLA*, HLA will compile the file with the HLA compiler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the suffix is *.ASM*, HLA will assemble the file with MASM (or some other
    default assembler such as FASM, NASM, or TASM under Windows) or Gas (Linux/Mac
    OS X/FreeBSD).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the suffix is .*OBJ* or .*LIB* (Windows), or .*o* or .*a* (Linux/Mac OS X/FreeBSD),
    then HLA will link that module with the rest of the compilation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.24.1 Behavior of the external Directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whenever you declare a symbol using the `external` directive, keep in mind
    several limitations of `external` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Only one `external` declaration of an object may appear in a given source file.
    That is, you cannot define the same symbol twice as an `external` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only `procedure`, `static`, `readonly`, and `storage` variable objects can be
    external. `var`, `type`, `const`, and parameter objects cannot be external.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`external` objects must appear at the global declaration level. You cannot
    declare `external` objects within a procedure or other nested structure.^([[99](#ftn.CHP-5-FN-30)])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`external` objects publish their name globally. Therefore, you must carefully
    choose the names of your `external` objects so they do not conflict with other
    symbols.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This last point is especially important to keep in mind. HLA links your modules
    using a linker. At each step in this process, your choice of external names could
    create problems for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following HLA external/public declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: When you compile a program containing these declarations, HLA automatically
    generates a "munged" name for the `localObject` variable that probably won't ever
    have any conflicts with system-global external symbols.^([[100](#ftn.CHP-5-FN-31)])
    Whenever you declare an external symbol, however, HLA uses the object's name as
    the default external name. This can create some problems if you inadvertently
    use some global name as your variable name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get around the problem of conflicting external names, HLA supports an additional
    syntax for the `external` option that lets you explicitly specify the external
    name. The following example demonstrates this extended syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: If you follow the `external` keyword with a string constant enclosed by parentheses,
    HLA will continue to use the declared name (`c` in this example) as the identifier
    within your HLA source code. Externally (i.e., in the assembly code) HLA will
    substitute the name `var_c` whenever you reference `c`. This feature helps you
    avoid problems with the misuse of assembler reserved words, or other global symbols,
    in your HLA programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should also note that this feature of the `external` option lets you create
    *aliases*. For example, you may want to refer to an object by the name `StudentCount`
    in one module while referring to the object as `PersonCount` in another module
    (you might do this because you have a general library module that deals with counting
    people and you want to use the object in a program that deals only with students).
    Using a declaration like the following lets you do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you've already seen some of the problems you might encounter when
    you start creating aliases. So you should use this capability sparingly in your
    programs. Perhaps a more reasonable use of this feature is to simplify certain
    OS APIs. For example, the Win32 API uses some really long names for certain procedure
    calls. You can use the `external` directive to provide a more meaningful name
    than the standard one the operating system specifies.
  prefs: []
  type: TYPE_NORMAL
- en: 5.24.2 Header Files in HLA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HLA's technique of using the same `external` declaration to define public as
    well as external symbols may seem somewhat counterintuitive. Why not use a `public`
    reserved word for public symbols and the `external` keyword for external definitions?
    Well, as counterintuitive as HLA's external declarations may seem, they are founded
    on decades of solid experience with the C/C++ programming language that uses a
    similar approach to public and external symbols.^([[101](#ftn.CHP-5-FN-32)]) Combined
    with a *header file*, HLA's external declarations make large-program maintenance
    a breeze.
  prefs: []
  type: TYPE_NORMAL
- en: An important benefit of the `external` directive (versus separate `public` and
    `external` directives) is that it lets you minimize duplication of effort in your
    source files. Suppose, for example, you want to create a module with a bunch of
    support routines and variables for use in several different programs (e.g., the
    HLA Standard Library). In addition to sharing some routines and some variables,
    suppose you want to share constants, types, and other items as well.
  prefs: []
  type: TYPE_NORMAL
- en: The `#include` file mechanism provides a perfect way to handle this. You simply
    create a `#include` file containing the constants, macros, and `external` definitions
    and include this file in the module that implements your routines and in the modules
    that use those routines (see [Figure 5-10](ch05s24.html#using_header_files_in_hla_programs
    "Figure 5-10. Using header files in HLA programs")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Using header files in HLA programs](tagoreillycom20100401nostarchimages578019.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-10. Using header files in HLA programs
  prefs: []
  type: TYPE_NORMAL
- en: A typical header file contains only `const`, `val`, `type`, `static`, `readonly`,
    `storage`, and procedure prototypes (plus a few others we haven't look at yet,
    like macros). Objects in the `static`, `readonly`, and `storage` sections, as
    well as all procedure declarations, are always `external` objects. In particular,
    you should not put any `var` objects in a header file, nor should you put any
    nonexternal variables or procedure bodies in a header file. If you do, HLA will
    make duplicate copies of these objects in the different source files that include
    the header file. Not only will this make your programs larger, but it will cause
    them to fail under certain circumstances. For example, you generally put a variable
    in a header file so you can share the value of that variable among several different
    modules. However, if you fail to declare that symbol as external in the header
    file and just put a standard variable declaration there, each module that includes
    the source file will get its own separate variable—the modules will not share
    a common variable.
  prefs: []
  type: TYPE_NORMAL
- en: If you create a standard header file, containing `const`, `val`, and `type`
    declarations and external objects, you should always be sure to include that file
    in the declaration section of all modules that need the definitions in the header
    file. Generally, HLA programs include all their header files in the first few
    statements after the `program` or `unit` header.
  prefs: []
  type: TYPE_NORMAL
- en: This text adopts the HLA Standard Library convention of using an *.hhf* suffix
    for HLA header files (*hhf* stands for *HLA header file*).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[96](#CHP-5-FN-27)]) Of course, units may contain procedures and those procedures
    may have statements, but the unit itself does not have any executable instructions
    associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[97](#CHP-5-FN-28)]) Procedures in the unit may have their own `var` sections,
    but the procedure's declaration section is separate from the unit's declaration
    section.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[98](#CHP-5-FN-29)]) If you want to explicitly specify the name of the output
    file, HLA provides a command-line option to achieve this. You can get a menu of
    all legal command-line options by entering the command `HLA -?`.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[99](#CHP-5-FN-30)]) There are a few exceptions, but you cannot declare external
    procedures or variables except at the global level.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[100](#CHP-5-FN-31)]) Typically, HLA creates a name like *001A_localObject*
    out of *localObject*. This is a legal MASM identifier, but it is not likely it
    will conflict with any other global symbols when HLA compiles the program with
    MASM.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[101](#CHP-5-FN-32)]) Actually, C/C++ is a little different. All global symbols
    in a module are assumed to be public unless explicitly declared private. HLA's
    approach (forcing the declaration of public items via `external`) is a little
    safer.
  prefs: []
  type: TYPE_NORMAL
- en: 5.25 Namespace Pollution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One problem with creating libraries with a lot of different modules is namespace
    pollution. A typical library module will have a `#include` file associated with
    it that provides external definitions for all the routines, constants, variables,
    and other symbols provided in the library. Whenever you want to use some routines
    or other objects from the library, you would typically `#include` the library''s
    header file in your project. As your libraries get larger and you add declarations
    in the header file, it becomes likely that the names you''ve chosen for your library''s
    identifiers will conflict with names you want to use in your current project.
    This is known as *namespace pollution*: library header files pollute the namespace
    with names you typically don''t need in order to gain easy access to the few routines
    in the library you actually use. Most of the time those names don''t harm anything—unless
    you want to use those names for your own purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: HLA requires that you declare all external symbols at the global (`program/unit`)
    level. You cannot, therefore, include a header file with external declarations
    within a procedure. Thus, there will be no naming conflicts between external library
    symbols and symbols you declare locally within a procedure; the conflicts will
    occur only between the external symbols and your global symbols. While this is
    a good argument for avoiding global symbols as much as possible in your program,
    the fact remains that most symbols in an assembly language program will have global
    scope. So another solution is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: HLA's solution is to put most of the library names in a `namespace` declaration
    section. A `namespace` declaration encapsulates all declarations and exposes only
    a single name (the `namespace` identifier) at the global level. You access the
    names within the namespace by using the familiar dot notation (see the discussion
    of namespaces in [4.34 Namespaces](ch04s34.html "4.34 Namespaces")). This reduces
    the effect of namespace pollution from many dozens or hundreds of names down to
    a single name.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, one disadvantage of using a `namespace` declaration is that you have
    to type a longer name in order to reference a particular identifier in that namespace
    (that is, you have to type the `namespace` identifier, a period, and then the
    specific identifier you wish to use). For a few identifiers you use frequently,
    you might elect to leave those identifiers outside of any `namespace` declaration.
    For example, the HLA Standard Library does not define the symbol `nl` within a
    namespace. However, you want to minimize such declarations in your libraries to
    avoid conflicts with names in your own programs. Often, you can choose a `namespace`
    identifier to complement your routine names. For example, the HLA Standard Library's
    string copy routine was named after the equivalent C Standard Library function,
    `strcpy`. HLA's version is `str.cpy`. The actual function name is `cpy`; it happens
    to be a member of the `str namespace`, hence the full name `str.cpy`, which is
    very similar to the comparable C function. The HLA Standard Library contains several
    examples of this convention. The `arg.c` and `arg.v` functions are another pair
    of such identifiers (corresponding to the C identifiers `argc` and `argv`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a `namespace` in a header file is no different than using a `namespace`
    in a `program` or `unit`, though you do not normally put actual procedure bodies
    in a `namespace`. Here''s an example of a typical header file containing a `namespace`
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically, you would compile each of the functions (`func1..func3`) as separate
    units (so each has its own object file and linking in one function doesn''t link
    them all). Here''s a sample `unit` declaration for one of these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: You should notice two important things about this unit. First, you do not put
    the actual `func1` procedure code within a `namespace` declaration block. By using
    the identifier `myLib.func1` as the procedure's name, HLA automatically realizes
    that this procedure declaration belongs in a namespace. The second thing to note
    is that you do not preface `func1` with `myLib.` after the `begin` and `end` clauses
    in the procedure. HLA automatically associates the `begin` and `end` identifiers
    with the `procedure` declaration, so it knows that these identifiers are part
    of the `myLib` namespace and it doesn't make you type the whole name again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note: When you declare external names within a namespace, as was
    done in `func1Unit` previously, HLA uses only the function name (`func1` in this
    example) as the external name. This creates a namespace pollution problem in the
    external namespace. For example, if you have two different namespaces, `myLib`
    and `yourLib`, and they both define a `func1` procedure, the linker will complain
    about a duplicate definition for `func1` if you attempt to use functions from
    both these library modules. There is an easy workaround to this problem: Use the
    extended form of the `external` directive to explicitly supply an external name
    for all external identifiers appearing in a `namespace` declaration. For example,
    you could solve this problem with the following simple modification to the *myHeader.hhf*
    file above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'This example demonstrates an excellent convention you should adopt: When exporting
    names from a namespace, always supply an explicit external name and construct
    that name by concatenating the `namespace` identifier with an underscore and the
    object''s internal name.'
  prefs: []
  type: TYPE_NORMAL
- en: The use of `namespace` declarations does not completely eliminate the problems
    of namespace pollution (after all, the namespace identifier is still a global
    object, as anyone who has included *stdlib.hhf* and attempted to define a `cs`
    variable can attest), but `namespace` declarations come pretty close to eliminating
    this problem. Therefore, you should use `namespace` everywhere practical when
    creating your own libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 5.26 For More Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The electronic edition of this book found at [http://www.artofasm.com/](http://www.artofasm.com/)
    or [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) contains a whole "volume"
    on advanced and intermediate procedures. The information in this chapter was taken
    from the introductory and intermediate chapters in the electronic edition. While
    the information appearing in this chapter covers 99 percent of the material assembly
    programmers typically use, there is additional information on procedures and parameters
    that you may find interesting. In particular, the electronic edition covers additional
    parameter-passing mechanisms (pass by value/result, pass by result, pass by name,
    and pass by lazy evaluation) and goes into greater detail about the places you
    can pass parameters. The electronic version of this text also covers iterators,
    thunks, and other advanced procedure types. You should also check out the HLA
    documentation for more details on HLA's procedure facilities. Finally, a good
    compiler construction textbook will cover additional details about runtime support
    for procedures.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discussed only 32-bit near procedures (appropriate for operating
    systems like Windows, Mac OS X, FreeBSD, and Linux). For information about procedures
    in 16-bit code (including near and far procedures), check out the 16-bit edition
    of this book, also found at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/).
  prefs: []
  type: TYPE_NORMAL
- en: HLA supports the ability to nest procedures; that is, you can declare a procedure
    in the declaration section of some other procedure and use *displays* and *static
    links* to access automatic variables in the enclosing procedures. HLA also supports
    advanced parameter-pointer facilities. This text does not discuss these features
    because they're somewhat advanced and very few assembly language programmers take
    advantage of these facilities in their programs. However, these features are very
    handy in certain situations. Once you're comfortable with procedures and assembly
    language programming in general, you should read about HLA's facilities for nested
    procedures in the HLA documentation and in the chapters on intermediate and advanced
    procedures in the electronic version of this book found at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the examples given for the code that HLA generates when passing parameters
    using the high-level syntax are incomplete. Over time, HLA has improved the quality
    of the code it generates when passing parameters on the stack. If you would like
    to see the type of code HLA generates for a particular parameter call sequence,
    you should supply the `-sourcemode`, `-h`, and `-s` command-line parameters to
    HLA and view the corresponding assembly language file that HLA emits (which will
    be a pseudo-HLA source file showing you the low-level code that HLA produces).
  prefs: []
  type: TYPE_NORMAL
