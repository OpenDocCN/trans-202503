<html><head></head><body><div id="sbo-rt-content"><div class="imagec"><span epub:type="pagebreak" id="page_37"/><img src="Images/f037-01.jpg" alt="Image" width="250" height="254"/></div>&#13;
<h2 class="h2" id="ch02"><span class="big">2</span><br/>Weird Bug Chowdown: Collecting Items and Avoiding Obstacles</h2>&#13;
<p class="noindent">Let’s take the little leaf game we’ve made and turn it into <em>Weird Bug Chowdown</em>, which has more of a story arc. Instead of making a game about a bug just munching a leaf forever, this game will start easy, get harder, and eventually reach an ending. We’ll talk about some of the most common elements in video games—collecting and avoiding things! We’ll also explore time pressure, one of the most fundamental features of real-time games.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_38"/>You’ll also learn a few more Scratch features, such as the following:</p>&#13;
<ul>&#13;
<li class="noindent">Using clones to create more sprites</li>&#13;
<li class="noindent">Creating and keeping track of your own variables</li>&#13;
<li class="noindent">Creating your own events and using them to send messages between different sprites</li>&#13;
<li class="noindent">Using a little bit of animation</li>&#13;
</ul>&#13;
<p class="indent">You can play <em>Weird Bug Chowdown</em> at <em><a href="https://scratch.mit.edu/projects/117389078/">https://scratch.mit.edu/projects/117389078/</a></em>.</p>&#13;
<div class="image"><img src="Images/f038-01.jpg" alt="Image" width="894" height="671"/></div>&#13;
<p class="caption"><em>Preview of</em> Weird Bug Chowdown</p>&#13;
<p class="indent">This weird bug wants to get as big as possible by eating all the berries! But berries go bad if the bug doesn’t eat them fast enough. Also, every time the bug eats a berry, it leaves something stinky behind that you probably want to avoid. Can you reach the end of the game? (It’s kind of hard, so if you can’t get to the end, try making your version easier.)</p>&#13;
<p class="indent">When you’ve played enough, let’s dive in and start making the game!</p>&#13;
<h3 class="h3" id="ch02lev1sec1"><span epub:type="pagebreak" id="page_39"/>Copying a Project and Changing It</h3>&#13;
<p class="noindent">This time, let’s not start from . . . scratch (you know what I mean). Instead, let’s build on our previous project by copying it to a new project. Open <em>Leaf Me Alone</em> by clicking <strong>See inside</strong> either on the My Stuff page or on the game’s Project Page.</p>&#13;
<p class="indent">If you haven’t created your own version of <em>Leaf Me Alone</em> yet, find the game at <em><a href="https://scratch.mit.edu/projects/117199134/">https://scratch.mit.edu/projects/117199134/</a></em>, and then click the <strong>Remix</strong> button in the upper right to get your own copy to work with.</p>&#13;
<div class="image"><img src="Images/f039-01.jpg" alt="Image" width="1032" height="636"/></div>&#13;
<p class="caption"><em>Creating a copy of</em> Leaf Me Alone</p>&#13;
<p class="indent">Once you have a version of <em>Leaf Me Alone</em> saved as a remix, click <strong>File <span class="ent">▸</span> Save as a copy</strong> to create a copy of the game to work on. Its new name should look something like “Leaf Me Alone copy.” Click the name to change it to <strong>Weird Bug Chowdown</strong> (or an even better name).</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_40"/><img src="Images/f040-01.jpg" alt="Image" width="497" height="395"/></div>&#13;
<p class="caption"><em>Saving a copy of</em> Leaf Me Alone</p>&#13;
<p class="indent">Because we’re starting with an existing project, we already have a loop that moves our bug forward and events that let the player turn left and right. We’ll tweak these for the new game we’ll make.</p>&#13;
<p class="indent"><em>Weird Bug Chowdown</em> requires some bug maneuvering skills where the player chases tiny berries while avoiding hazards at the same time. To make the bug a little easier to maneuver initially, let’s change its move speed to 3. Now it should move 3 steps during its loop instead of 5.</p>&#13;
<h3 class="h3" id="ch02lev1sec2">Tidying Up Your Code</h3>&#13;
<p class="noindent">Because we don’t need the leaf-crunch noises, we’ll remove that whole stack from the Scripts area. Click the <span class="codestrong">when green flag clicked</span> block at the very top to select all the other blocks in that stack, and then drag it out of the Scripts area. (Make sure you get rid of the shorter stack that makes chomping noises, not the one that moves the bug!)</p>&#13;
<p class="indent">We’ll also take the left and right turning branches out and make them their own <span class="literal">when green flag clicked</span> stack, as shown on the next page.</p>&#13;
<p class="indent">Making two stacks of code is an optional step to prevent the stack with our main loop from getting so long that it won’t fit on the screen. Don’t forget to give the new stack its own <span class="literal">forever</span> loop, too. Sometimes, this kind of tidying up can help you keep track of your code. Now you’ll know whether each stack of code is for the setup and main game loop or for pressing buttons and turning.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_41"/><img src="Images/f041-01.jpg" alt="Image" width="1089" height="834"/></div>&#13;
<p class="caption"><em>Reorganizing our existing stack</em></p>&#13;
<p class="indent">Before we start working on our new game, let’s make one more small change to the code that we have.</p>&#13;
<h3 class="h3" id="ch02lev1sec3">Leaving a Rainbow Trail</h3>&#13;
<p class="noindent">For this game, let’s use the pen for a neat rainbow effect instead of leaf eating. Then our bug will leave a rainbow trail behind it wherever it goes. Because this game is all about wiggly bug movement, it would be cool to see exactly where your bug has been while playing it.</p>&#13;
<p class="indent">Let’s modify the main loop so the bug draws a little differently.</p>&#13;
<p class="indent">First, we delete the <span class="literal">set pen color to</span> block. Because we’ll cycle through all of the colors of the rainbow, it doesn’t matter what color we start with.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_42"/>Then we add a <span class="literal">set pen saturation to 50</span> block to make the colors more saturated because we want the rainbow super light and pastel. If you set the saturation to 100 instead, you would get a super dark rainbow. Setting it to 0 makes it all white.</p>&#13;
<div class="image"><img src="Images/f042-01.jpg" alt="Image" width="448" height="834"/></div>&#13;
<p class="caption"><em>Code to leave a rainbow trail</em></p>&#13;
<p class="indent">The final and most important change is getting rid of the <span class="literal">set pen size</span> block inside the loop (the one that creates the random hole bite effect) and replacing it with a <span class="literal">change pen color by 10</span> block. This block produces the rainbow effect.</p>&#13;
<p class="indent">In Scratch, the pen color, like the x- or y-coordinates, is just a number. By adding to or subtracting from this number, we can change the color the bug is drawing with. By using a bigger or smaller number, we can change how quickly the rainbow cycles through the colors. We use 10 here, but experiment to find the one you like best.</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_43"/><img src="Images/f043-01.jpg" alt="Image" width="300" height="289"/></div>&#13;
<p class="indent">We also got rid of the leaf in the background by creating a new backdrop image and deleting the old one. (You can do this from the Backdrops tab after clicking on the Stage.) Use a solid background color for the rainbow to show up against. If you’re feeling ambitious, you could draw a whole new background. But the rainbow effect will make the background interesting to look at on its own so it doesn’t really need anything extra. Everyone loves rainbows! What could be better?</p>&#13;
<div class="image"><img src="Images/f043-02.jpg" alt="Image" width="892" height="667"/></div>&#13;
<p class="caption"><em>Testing the rainbow trail</em></p>&#13;
<h3 class="h3" id="ch02lev1sec4"><span epub:type="pagebreak" id="page_44"/>Making Bug Food</h3>&#13;
<p class="noindent">Now let’s make some berries for our bug to eat. Click the <strong>Paint</strong> button that looks like a paintbrush on the sprite menu.</p>&#13;
<p class="indent">Draw a berry and make it a little red circle right on top of the + that’s not much bigger than the bug. You can add a little leaf on top and a little white spot to show where the light is shining on it.</p>&#13;
<p class="indent">When you’re done, click the <strong>Sprite</strong> box in the bottom-right corner (it’ll be called <span class="literal">Empty</span>) and change its value to <span class="codestrong">Berry</span>. Change the value of the costume name (in the upper-left corner, by the undo buttons) to <span class="codestrong">costume1</span>. Now what do we want our berry to do?</p>&#13;
<div class="image"><img src="Images/f044-01.jpg" alt="Image" width="792" height="679"/></div>&#13;
<p class="caption"><em>Drawing a berry</em></p>&#13;
<p class="indent">Let’s think for a moment about the role of objects like this in games. Many games have coins, rings, gems, or other things the player is supposed to collect in tricky-to-reach places. But what do they actually <em>do</em> in those games?</p>&#13;
<p class="indent">In <em>Weird Bug Chowdown</em>, the berries give the player something to <em>do</em> with the ability to control the bug’s movement. Objects like berries can motivate players to understand how the bug moves and challenge them to get better at controlling it.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_45"/>We’ll have the berries pop up at random places on the screen so the player can try to move the bug to them. How do we make multiple berries? The most obvious way is to make multiple berry sprites. But even if we made, say, five of them, and they were all identical, we’d still only have five of them. Plus, if we ever wanted to change the code in one of them, we’d have to change it <em>in all five of them</em>. That’s way too much work. Instead, we’ll make just <em>one</em> berry sprite that can <em>clone</em> itself.</p>&#13;
<h4 class="h4" id="ch02lev2sec1">Making a Sprite Clone Itself</h4>&#13;
<p class="noindent">A clone is just a copy of a sprite that the sprite produces while the game is running. Any sprite can make a clone of itself at any time if it’s programmed to do so. Clones are not individual objects with their own code. We code them by coding the original sprite, and then telling it what to do when it’s cloned using a few special blocks made just for clones. Note that clones disappear when the game is over.</p>&#13;
<p class="indent">First, we’ll program the berry sprite to teleport to a random position on the screen and then clone itself. The cloned berry will sit and wait for the player to try to eat it. Then the original berry will wait a few seconds, teleport again, and make <em>another</em> clone, and so on. The original berry will just teleport around and produce clones, and the clones will be the berries the player eats. Let’s see what this looks like in code.</p>&#13;
<div class="image"><img src="Images/f045-01.jpg" alt="Image" width="958" height="608"/></div>&#13;
<p class="caption"><em>Code for making self-cloning berries</em></p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_46"/><img src="Images/f046-01.jpg" alt="Image" width="300" height="279"/></div>&#13;
<p class="indent">First, the berry <em>hides</em> because this original berry is only here to make clones. The player should only be able to see the clone berries. (The <span class="literal">hide</span> block is under <strong>Looks</strong>.) When it becomes invisible, it starts its loop. It moves to a random position on the screen, plays <em>pop</em> (the sound effect every sprite starts with), and clones itself. It pauses three seconds between each cloning and then starts the loop again, producing a new clone at a random position. (All of the clone-related blocks are under <strong>Control</strong>.)</p>&#13;
<h4 class="h4" id="ch02lev2sec2">Using Negative Numbers</h4>&#13;
<p class="noindent">The <span class="literal">go to x: y:</span> block sets <span class="literal">x</span> to a random number between –220 and 220 and <span class="literal">y</span> to a random number between –160 and 160. These numbers come from the coordinate system talked about in <a href="ch01.xhtml#ch01">Chapter 1</a>.</p>&#13;
<p class="indent">When you move your mouse around the game area and watch the x- and y-coordinates in the corner, the numbers get smaller toward the middle. The center point of the screen is point 0, 0. If you move to the right, the x number gets bigger up to 240. If you move to the left, the numbers get lower. Numbers less than 0 are <em>negative numbers</em>.</p>&#13;
<p class="indent">Negative numbers are like a mirror image of the regular numbers, so if you subtract 1 from 0, you get –1, and if you subtract 100 from 0, you get –100. Like normal numbers, the further they get from 0, the bigger the number gets. The furthest left x position is at –240, which is the mirror of 240 on the right. The y position goes from 180 at the top of the screen to –180 at the bottom.</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_47"/><img src="Images/f047-01.jpg" alt="Image" width="614" height="407"/></div>&#13;
<h4 class="h4" id="ch02lev2sec3">Creating a Berry-Free Zone</h4>&#13;
<p class="noindent">If we set <span class="literal">x</span> to <span class="literal">pick random -240 to 240</span> and <span class="literal">y</span> to <span class="literal">pick random -180 to 180</span>, we’d cover every possible position on the screen. So why use –220 to 220 and –160 to 160 instead? Because the bug bounces off the edges of the screen, we don’t want the berries to appear too close to an edge, making them unfairly difficult to collect. To avoid that, we create a comfy buffer of 20 berry-free coordinates around the edge of the screen by subtracting 20 from 240 and 180 to get 220 and 160.</p>&#13;
<p class="indent">Try running the game now. You probably won’t see anything, but you should hear a popping sound every three seconds. This is because the clones are all invisible right now. Because the original berry <em>hides</em> before it clones itself, the clones also start as invisible berries!</p>&#13;
<p class="indent">Because the berry’s clones are created <em>after</em> you click the green flag to start the game, they don’t have the <span class="literal">when green flag clicked</span> event. That’s a good thing because otherwise they would be teleporting around and cloning themselves like the original berry, and soon the screen would be covered with berries. When you’re working with clones, it’s best to use the <span class="literal">when green flag clicked</span> event for only stuff you want the <em>original</em> sprite (not the clones) to do. We’ll use a special event to write code for things we want <em>only clones</em> to do.</p>&#13;
<div class="note">&#13;
<p class="notep"><strong><span class="notes">NOTE:</span></strong> Remember that clones disappear when the game stops running, so don’t worry about invisible berries clogging your game.</p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_48"/>It’s time to give those clones something to do. They can begin by making themselves visible again.</p>&#13;
<h4 class="h4" id="ch02lev2sec4">Telling a Cloned Berry What to Do</h4>&#13;
<p class="noindent">We’ll use the <span class="literal">when I start as a clone</span> event to tell the clones what to do. Even though it’s an event, you’ll find it under <strong>Control</strong> with all the other clone-related blocks. The event <span class="literal">when I start as a clone</span> lets you write code exclusively for clones. The original sprite will never see this event. Whatever comes first inside the <span class="literal">when I start as a clone</span> block will be the first action the clone takes after it’s created.</p>&#13;
<p class="indent">The first thing our berry clone does should be to make itself visible with the <span class="literal">show</span> block, which is in the <strong>Looks</strong> category.</p>&#13;
<div class="image"><img src="Images/f048-01.jpg" alt="Image" width="465" height="490"/></div>&#13;
<p class="caption"><em>Telling clones what to do as soon as they’re created</em></p>&#13;
<p class="indent">Because we can create as many clones as we want, we can also get rid of them. This ability is useful; otherwise, clones could get out of hand! To get rid of clone berries after a bug has eaten them, we use a conditional to first check whether the berry is touching the bug. If it’s touching the bug, we delete it to show that the bug has eaten the berry. Make sure this check happens inside a <span class="literal">forever</span> loop so the berry can keep checking for the condition.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_49"/><img src="Images/f049-01.jpg" alt="Image" width="892" height="668"/></div>&#13;
<p class="caption"><em>Testing whether berries pop up</em></p>&#13;
<p class="indent">Try running the program! Every three seconds, a new berry should appear on the screen and disappear when the bug touches it. How quickly can you eat the berries?</p>&#13;
<h4 class="h4" id="ch02lev2sec5">Broadcasting Messages</h4>&#13;
<p class="noindent">Having the berries just disappear when the bug eats them is a little anticlimactic. Instead, let’s make the bug grow a little bigger every time it eats one. To do that, we’ll need a way for the berry to send a message to the bug, telling it that the bug has eaten the berry. When the bug gets the message, it’ll run a special event that tells it to grow bigger.</p>&#13;
<p class="indent">In Scratch, this is called broadcasting and receiving messages. When a sprite <em>broadcasts</em> a message, that message is sent to every other sprite in the game simultaneously. Any sprite with a <span class="literal">when I receive</span> event for that message will run whatever code is attached to that event after receiving the message. Sprites without an event for that message will ignore it. It’s like when you post a picture on Instagram. You’re sending it out to the entire world, but only the people who are following you on Instagram will see it.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_50"/>You can find all the blocks related to broadcasting and receiving messages under <strong>Events</strong>, as shown here.</p>&#13;
<div class="image"><img src="Images/f050-01.jpg" alt="Image" width="483" height="583"/></div>&#13;
<p class="caption"><em>Broadcast drop-down menu</em></p>&#13;
<p class="indent">Drag the <span class="literal">broadcast message1</span> block into your <span class="literal">if touching bug</span> branch, right above <span class="literal">delete this clone</span>. We want the berry to check whether it’s touching the bug, send the bug a message, and then disappear. The default message is <span class="literal">message1</span>, but you can change which message the berry sends by clicking the triangle on the <span class="literal">broadcast</span> block. Click <span class="codestrong">New message</span> to create a new message called <span class="literal">yum</span>.</p>&#13;
<p class="indent">Now click the bug and give it a new stack that starts with the <span class="literal">when I receive yum</span> event. You might have to click the triangle on the <span class="literal">when I receive yum</span> block and change the message to <span class="literal">yum</span>.</p>&#13;
<div class="image"><img src="Images/f050-02.jpg" alt="Image" width="410" height="356"/></div>&#13;
<p class="caption"><em>Creating the <span class="codeitalic">when I receive yum</span> block</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_51"/>Now when the bug gets the <span class="literal">yum</span> message, it can play its chomp sound effect and grow a little bigger. Let’s also make the pen size bigger, so the bug’s rainbow trail gets larger as the bug gets larger.</p>&#13;
<p class="indent">Make sure you also add a <span class="literal">set size to 100%</span> block to the bug’s setup code (in the <span class="literal">when green flag clicked</span> stack) so it resets its size when you restart the game! Otherwise, the bug will keep getting bigger and bigger forever (100% is a sprite’s original size).</p>&#13;
<p class="indent">Now try eating some berries and watch your bug and its rainbow trail grow! <em>Nom nom nom.</em></p>&#13;
<div class="image"><img src="Images/f051-01.jpg" alt="Image" width="894" height="669"/></div>&#13;
<p class="caption"><em>Watch your bug grow!</em></p>&#13;
<h3 class="h3" id="ch02lev1sec5">Adding Time Pressure</h3>&#13;
<p class="noindent">From the moment the player clicks the green flag, time is ticking in our game. As game designers, we should think about how we make use of time. For example, we can decide how much time the player should spend in a level, how much time should pass before the monster starts chasing the player, or how much time the player has to grab a winged <span epub:type="pagebreak" id="page_52"/>ball before it flutters out of reach. Time is an amazing tool when we use it deliberately.</p>&#13;
<p class="indent">When the timing is too slow, players could get bored because they don’t feel much urgency. When the game moves too fast, players feel like they can’t possibly keep up. In either case, they disengage because nothing they do feels like it has consequence.</p>&#13;
<p class="indent">But if we use time thoughtfully, we can keep the energy of the game moving by keeping up the momentum. For example, in <em>Weird Bug Chowdown</em>, berries appear every three seconds. Players need to use the right <em>timing</em> to turn the bug at just the right moment to gobble up a berry. But they have as much time as they want to collect a berry, and the berries stick around forever.</p>&#13;
<div class="imagec"><img src="Images/f052-01.jpg" alt="Image" width="300" height="267"/></div>&#13;
<p class="indent">Right now, players have all the time in the world to collect berries, so there’s not much forward momentum in this game. But what if we added <em>time pressure</em> by making berries turn bad if the bug didn’t get them in time, like a fruit going bad after being left on the counter for a week? Then the player would have a reason to try to grab them as soon as they appear.</p>&#13;
<p class="indent">We could also make the bad berries reverse the player’s progress, turning the bad berries into obstacles the bug would have to avoid. This would create pressure to eat the berries quickly and consequences when the player isn’t able to do so.</p>&#13;
<p class="indent">Let’s talk about how to make a good berry go bad.</p>&#13;
<h4 class="h4" id="ch02lev2sec6"><span epub:type="pagebreak" id="page_53"/>Using Animation to Make Bad Berries</h4>&#13;
<p class="noindent">To make the player understand the berries are going bad, we need a way to show it to them. We also need to show how close a berry is to going bad to give players time to react. Visuals are a great way to communicate information about the state of the game.</p>&#13;
<p class="indent">We’ll make different costumes for the berry so the player can watch it change color as it gets closer to becoming a bad berry. Then we’ll flip through the different stages of berry ripeness, creating a little animation.</p>&#13;
<h5 class="h5" id="ch02lev3sec1">Drawing Costumes</h5>&#13;
<p class="noindent">Open the berry’s <strong>Costumes</strong> tab. Right now, the berry has a single costume (give it the name <span class="literal">costume1</span> by typing the name into the box next to the undo arrows). Right-click that costume and choose <strong>duplicate</strong> to make a copy of that costume called <span class="literal">costume2</span>. Don’t change <span class="literal">costume1</span>. We’ll draw some big purple spots on <span class="literal">costume2</span>, making it look like it’s halfway through the process of turning from red to rotten purple.</p>&#13;
<p class="indent">Right-click <span class="codestrong">costume2</span> to make another duplicate, which is <span class="literal">costume3</span>. Use the paint bucket tool to add more purple spots in the remaining red on <span class="literal">costume3</span>. Now the berry is completely purple.</p>&#13;
<p class="indent">Duplicate <span class="literal">costume3</span> to make <span class="literal">costume4</span>, and draw some blue spots on it for a blueish purple berry. Then make <span class="literal">costume5</span> completely blue to make a berry that is going bad.</p>&#13;
<div class="image"><img src="Images/f053-01.jpg" alt="Image" width="656" height="569"/></div>&#13;
<p class="caption"><em>Drawing costumes for your berry</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_54"/>We want a visible transition from color to color as the berry grows closer and closer to its final, rotten form. Here, we drew seven costumes, starting at solid red before turning purple, then blue, and eventually blue with big gross green splotches in <span class="literal">costume7</span>, which shows the kind of berry you wouldn’t want to eat.</p>&#13;
<p class="indent">By looking at the color of the berry’s costume at each stage, the player should know how close the berry is to being inedible. Red is perfect, purple is halfway to going bad, and blue is getting nasty. Green and splotchy is rotten.</p>&#13;
<h5 class="h5" id="ch02lev3sec2">Coding the Animation</h5>&#13;
<p class="noindent">Let’s look at how we tell the berry clones to cycle through all the costumes.</p>&#13;
<p class="indent">We need two separate events using <span class="literal">when I start as a clone</span> for each. One checks for contact with the bug. The other event handles all the visuals, like making the berry visible, resetting its appearance to <span class="literal">costume1</span>, and then animating it.</p>&#13;
<p class="indent">Because these stacks involve different timing (one uses a <span class="literal">forever</span> loop, and the other uses <span class="literal">wait</span> and <span class="literal">repeat</span>), they can’t be in the same stack. Whenever two pieces of code have different timing like this, we must put them in separate events, even when both events start at the same time. Then they won’t get in each other’s way.</p>&#13;
<div class="image"><img src="Images/f054-01.jpg" alt="Image" width="838" height="631"/></div>&#13;
<p class="caption"><em>Animating how your berry goes bad</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_55"/>In the visual stack, we use a <span class="literal">repeat 6</span> loop to advance through the costumes with one second between each costume change. The <span class="literal">repeat</span> block is like the <span class="literal">forever</span> block, except instead of repeating the branch inside it forever, it just repeats it the number of times you specify. We use <span class="literal">repeat 6</span> here because there are only six frames until the final frame that shows the gross splotchy berry (<span class="literal">costume7</span>).</p>&#13;
<p class="indent">After the <span class="literal">repeat</span> block runs the specified number of times, Scratch exits the branch and moves on to whatever code is below it. In this case, that code waits another five seconds and then deletes the clone. That way, rotted berries stick around long enough to be an obstacle, but don’t hang around forever. Otherwise, the game would get too hard.</p>&#13;
<p class="indent">Run the game and watch your berries go bad.</p>&#13;
<div class="image"><img src="Images/f055-01.jpg" alt="Image" width="950" height="712"/></div>&#13;
<p class="caption"><em>Testing to see how the berries go bad</em></p>&#13;
<p class="indent">When a berry pops up, the player has six seconds to eat it before it goes bad. That’s just enough time to reach a berry from anywhere on the screen. Then it stays bad for another five seconds until it finally vanishes. But right now, you can still eat berries after they go bad with no consequences. We haven’t made them do anything different when they go bad. Let’s do that next.</p>&#13;
<h4 class="h4" id="ch02lev2sec7"><span epub:type="pagebreak" id="page_56"/>Branching with if and else</h4>&#13;
<p class="noindent">We used <span class="literal">if () then</span> blocks to check whether the bug was touching the leaf or a berry. Now we’ll use <span class="literal">if / else</span> blocks to decide whether the berry is good or bad when the bug touches it. The <span class="literal">if / else</span> block (under <strong>Control</strong>) has two branches: one for the <span class="literal">if</span> and one for the <span class="literal">else</span>. If the condition is true, the code in the first branch runs, and if it’s not true, the code in the second (<span class="literal">else</span>) branch runs.</p>&#13;
<div class="image"><img src="Images/f056-01.jpg" alt="Image" width="635" height="729"/></div>&#13;
<p class="caption"><em>Checking whether a berry is good for eating</em></p>&#13;
<p class="indent">Let’s unpack this stack to understand it. The first outermost block is a <span class="literal">forever</span> loop, because we want this berry to continually check whether the bug is touching the berry. Nestled inside the <span class="literal">forever</span> loop is the <span class="literal">if touching bug</span> block that performs the check. First, we check that the bug is actually touching the berry, and only <em>then</em> check what kind of berry it is.</p>&#13;
<p class="indent">The next level down is the <span class="literal">if / else</span> block: <span class="literal">if costume number &lt; 7 then broadcast yum, else broadcast yuck</span>. The <span class="literal">costume number</span> (under <strong>Looks</strong>) just shows the costume number the sprite currently appears as. The <span class="literal">&lt;</span> symbol means “is less than,” which checks whether the costume number is less than 7. You can find the <span class="literal">&lt;</span> block under <strong>Operators</strong>. <span epub:type="pagebreak" id="page_57"/>The bad berry costume is <span class="literal">costume7</span>. We want the bug to take one action if the berry’s costume number is 7 and another action if it’s less than 7.</p>&#13;
<p class="indent"><em>If</em> the costume number is between 1 and 6, the berry is still good to eat, and we broadcast the <span class="literal">yum</span> message. Or <em>else</em> if the costume number is 7 and the berry is bad, we transmit the <span class="literal">yuck</span> message by clicking the triangle and then <strong>New message</strong>.</p>&#13;
<p class="indent">Regardless of whether the berry is good or bad, we need to <em>delete this clone</em>. Removing the berry is not part of the <span class="literal">if / else</span> block and happens after that block is evaluated. We want the berry to disappear whether it’s healthy or not.</p>&#13;
<p class="indent">That’s it for the berry.</p>&#13;
<h4 class="h4" id="ch02lev2sec8">Recording the yuck Message</h4>&#13;
<p class="noindent">To make the bug receive the <span class="literal">yuck</span> message and react accordingly, we’ll record a new sound by saying “eww” into the microphone. When the bug receives the <span class="literal">yuck</span> message, the game plays that sound and then the bug gets smaller.</p>&#13;
<p class="indent">When the bug eats a good berry, it gets bigger by 10, so we’ll shrink the bug by 10 as well. We can shrink the bug by telling it to get bigger by –10, which is the same as saying it gets smaller by 10. We also make the pen smaller, to match the bug’s new size.</p>&#13;
<div class="image"><img src="Images/f057-01.jpg" alt="Image" width="418" height="467"/></div>&#13;
<p class="caption"><em>Making the bug say “eww” when it receives the <span class="codeitalic">yuck</span> message</em></p>&#13;
<p class="indent">We add the conditional <span class="literal">if size &gt; 100%</span> before the size change to make sure the bug can’t get any smaller than its starting size. (Keep in mind that 100% is a sprite’s starting size.) If we don’t set this conditional, the bug could shrink out of existence just by eating too many bad berries!</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_58"/>Let’s test our game. Try to make the bug get bigger, and then shrink it back to its original size. Check that the bug can’t get any smaller than its starting size.</p>&#13;
<h3 class="h3" id="ch02lev1sec6">Poop Obstacles</h3>&#13;
<p class="noindent">Now our game has obstacles for our bug to avoid. More importantly, the bug knows what to do when it collides with an obstacle. When it receives the <span class="literal">yuck</span> message, it follows the code in its <span class="literal">yuck</span> stack. We can use the <span class="literal">yuck</span> stack to add other obstacles, too. All we have to do is make new obstacle objects broadcast <span class="literal">yuck</span> messages when the bug touches them.</p>&#13;
<p class="indent">I have the perfect object in mind for a new obstacle: poop! Hear me out: bugs poop when they eat, right? My professional background is not in insect digestive systems, but bugs most likely poop sometimes. Using poop would be a fun way to tie all of the existing game elements together: the bug, the berries, and the consumption of said berries.</p>&#13;
<p class="indent">When the bug eats a berry, it’ll digest the snack for a second, and then a little poop will appear behind it. This poop works just like a bad berry does. If the bug touches its poop, it broadcasts a <span class="literal">yuck</span> message and the bug gets smaller. Avoid the poops!</p>&#13;
<div class="imagec"><img src="Images/f058-01.jpg" alt="Image" width="300" height="306"/></div>&#13;
<h4 class="h4" id="ch02lev2sec9"><span epub:type="pagebreak" id="page_59"/>Why Poop Obstacles Work</h4>&#13;
<p class="noindent">The poop obstacle will never appear <em>in front of</em> the bug. The berries pop up at random positions and sometimes appear right in front of the bug where the player can’t possibly avoid them. But the player <em>wants</em> to collect berries, so that’s like a free bonus. If poop obstacles appear in front of the bug, that would be unfair.</p>&#13;
<p class="indent">Because the bug’s poop always appears behind the bug, it helps the game’s forward momentum. The bug is continuously moving forward, so the poops give the player a reason to avoid retracing their path, pushing them to always explore other parts of the screen.</p>&#13;
<p class="indent">Another selling point for creating poop as an obstacle is that everyone playing your game already understands how it works. Everybody poops and instinctively knows to avoid it.</p>&#13;
<h4 class="h4" id="ch02lev2sec10">Making Poop by Having Sprites Clone Other Sprites</h4>&#13;
<p class="noindent">To create our poop obstacle, hover over the <strong>Choose a Sprite</strong> menu, click the <strong>Paint</strong> button, draw something gross, and rename the sprite <span class="literal">poop</span>. If poop grosses you out, you can make your bug lay weird bug eggs instead or leave chewed-up little berries behind it, like tiny apple cores. No one wants to touch those!</p>&#13;
<div class="image"><img src="Images/f059-01.jpg" alt="Image" width="639" height="558"/></div>&#13;
<p class="caption"><em>Drawing bug poop</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_60"/>Here are some tips for drawing good poop: click the little rainbow-looking box next to the palette below the drawing zone to get more colors to choose from. The slider to the right of this new rainbow palette lets you make colors brighter or darker. If you darken the palette a little, you should be able to pick a nice poopy brown. To make it look even grosser, set your drawing size to very small and draw some tiny black specks on the poop. There. Magnificent!</p>&#13;
<h4 class="h4" id="ch02lev2sec11">Coding the Poop Obstacles</h4>&#13;
<p class="noindent">Unlike with the berry, we won’t have the poop clone itself. Poops don’t appear on their own; they appear from the bug after it eats a berry. So we’ll tell the bug to make the poop clones using the <span class="literal">create clone of myself</span> block. Click the triangle next to <span class="literal">myself</span> and change it to <span class="literal">poop</span>.</p>&#13;
<div class="image"><img src="Images/f060-01.jpg" alt="Image" width="361" height="513"/></div>&#13;
<p class="caption"><em>Cloning poop</em></p>&#13;
<p class="indent">The bug makes a clone of the poop as part of the <span class="literal">when I receive yum</span> event. Add a <span class="literal">wait 1 secs</span> block and a <span class="literal">play sound</span> block and then set the sound to <span class="literal">fart</span>. Now, when the bug eats a berry, it’ll change its size as instructed, digest for one second, play a farting sound, and produce a poop clone. (You can record the farting sound by blowing a raspberry into the microphone.)</p>&#13;
<div class="note"><p class="notep"><span epub:type="pagebreak" id="page_61"/><strong><span class="notes">NOTE:</span></strong> If the bug eats another berry while waiting a second to clone a poop, the <span class="literal">when I receive yum</span> event starts over from the beginning, as does the <span class="literal">wait</span>. This means only one poop might appear when a bug eats multiple berries very quickly.</p>&#13;
</div>&#13;
<p class="indent">Now let’s use <span class="literal">when I start as a clone</span> events to tell the poop clones what to do after they appear.</p>&#13;
<div class="image"><img src="Images/f061-01.jpg" alt="Image" width="880" height="800"/></div>&#13;
<p class="caption"><em>Code that tells poop clones what to do</em></p>&#13;
<p class="indent">The poop code is split into three stacks. The reason is that the timing of the <span class="literal">forever</span> loop and the <span class="literal">wait 10 seconds</span> block need to run in their own stacks. Also, the <span class="literal">when green flag clicked, hide</span> stack should only run when a new game is started. Here is what each stack does:</p>&#13;
<p class="hang"><strong>Hides original poop</strong> The first stack makes the original <span class="literal">poop</span> sprite disappear, because we only want poop to show up in clone form.</p>&#13;
<p class="hang"><span epub:type="pagebreak" id="page_62"/><strong>Makes poop appear behind the bug</strong> The <span class="literal">when I start as a clone</span> stack in the lower left makes the poop start at the same x and y position, just like the bug. (You can find the <span class="literal">x position</span> block under <strong>Sensing</strong>.) Without this teleportation block, the new poop would appear wherever the original <span class="literal">poop</span> sprite was hidden instead of appearing in the bug’s trail. Then we tell the <span class="literal">poop</span> clone to <em>show</em> itself, wait 10 seconds, and then delete itself. Poop, like all things in life, is temporary. If it wasn’t, the game would get way too hard.</p>&#13;
<p class="hang"><strong>Checks for poop contact</strong> The <span class="literal">when I start as a clone</span> stack on the right checks for a <span class="literal">poop</span> clone’s contact with the bug. When the bug touches the <span class="literal">poop</span>, the <span class="literal">poop</span> broadcasts <span class="literal">yuck</span> and deletes itself. This is pretty much the same as with a bad berry. But notice that it waits one second before it starts checking for contact with the bug. That’s because each <span class="literal">poop</span> starts at the same position as the bug. If it didn’t wait a second before checking, the bug would smash into it as soon as it appears. <em>Gross</em>.</p>&#13;
<p class="indent">Run your game. Check that the poops appear, that they go away, <em>and</em> that they work as obstacles when the bug bumps into them. Poops galore.</p>&#13;
<div class="image"><img src="Images/f062-01.jpg" alt="Image" width="937" height="703"/></div>&#13;
<p class="caption"><em>Testing the game with poop</em></p>&#13;
<h3 class="h3" id="ch02lev1sec7"><span epub:type="pagebreak" id="page_63"/>Raising the Stakes</h3>&#13;
<p class="noindent">Now our game is full of exciting objects. The bug has items to collect and obstacles to avoid, like bad berries and poop. But maybe our game would seem more complete if it had more of a story and if there was escalating tension as it went on? For example, what if the better the player did, the harder the game became? Right now, the bug gets bigger as it eats, which makes it a little bit harder to avoid obstacles as the game progresses. But it doesn’t make the game that much different to play. What if the bigger the bug was, <em>the faster it moved</em>?</p>&#13;
<p class="indent">That way, the better the player is doing, the trickier the game gets. If it gets too hard and the bug hits some obstacles, it’ll shrink and the game will get slower and easier again. Adding this game play allows the game to meet the player’s skill level.</p>&#13;
<h4 class="h4" id="ch02lev2sec12">Creating Our Own Variables</h4>&#13;
<p class="noindent">To keep track of the bug’s speed while it’s moving, we’ll need to use a variable. We’ve already used variables: when we tell a sprite to <span class="literal">go to x 100</span>, we’re changing its <span class="literal">x</span> variable. When we change the color of a sprite’s pen, we’re changing a color variable. We can also create our own variables and use them to keep track of whatever we want, like the bug’s speed.</p>&#13;
<p class="indent">Click the <strong>Variables</strong> category in the Code tab, and then click <strong>Make a Variable</strong>.</p>&#13;
<div class="image"><img src="Images/f063-01.jpg" alt="Image" width="415" height="332"/></div>&#13;
<p class="caption"><em>Creating a new variable for speed</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_64"/>Name your variable <strong>speed</strong> and set it to <strong>For this sprite only</strong>. That just makes it easier to keep track of, because only the bug needs to know what speed it’s going.</p>&#13;
<p class="indent">After you name and create your variable, Scratch generates some new blocks to help you work with it.</p>&#13;
<p class="indent">The first new block is a round <span class="literal">value</span> block, which you can put into any slot in a block that wants a value. In this case, we’ll use the bug’s current speed as the value. There are blocks to set a variable to a specific number or change it by adding a number as you would for any other sprite property, like direction or costume number. Then there are blocks that show and hide the variable. What do those do exactly?</p>&#13;
<div class="image"><img src="Images/f064-01.jpg" alt="Image" width="457" height="712"/></div>&#13;
<p class="caption"><em>Blocks for your new variable</em></p>&#13;
<p class="indent">You should see a check mark box next to the <span class="literal">speed</span> value block. If that’s checked, you should see a little display in the corner of your game that shows the value of the <span class="literal">speed</span> variable while you play.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_65"/><img src="Images/f065-01.jpg" alt="Image" width="845" height="630"/></div>&#13;
<p class="caption"><em>Showing a speed display</em></p>&#13;
<p class="indent">This display can be useful while testing your game. You can see your variable’s value at any given time, so you can make sure it’s working as expected. When you uncheck the box, this display goes away. You’ll probably want to uncheck the variable before sharing the game. But sometimes you might want to leave a variable visible in a finished game. For example, if the display shows information you want the player to know, like their current score or the number of cupcakes they’ve collected, you’ll keep it visible.</p>&#13;
<p class="indent">Let’s use the <span class="literal">speed</span> variable blocks to change the bug’s speed as the game goes on.</p>&#13;
<h4 class="h4" id="ch02lev2sec13">Changing Speed</h4>&#13;
<p class="noindent">Using the <span class="literal">speed</span> variable is pretty simple. First, make sure the bug’s speed is set to 0 in its setup phase, before the main loop starts.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_66"/><img src="Images/f066-01.jpg" alt="Image" width="396" height="484"/></div>&#13;
<p class="caption"><em>Changing your bug’s speed</em></p>&#13;
<p class="indent">Then let’s change how far the bug moves after every run through the loop. To move our bug by <span class="literal">3 + speed</span> steps, you’ll need to grab the addition block, <span class="literal">+</span>, from <strong>Operators</strong> and drag the <span class="literal">speed</span> value block into the second slot of the <span class="literal">+</span> block. The minimum speed will be 3, which is the bug’s current speed. The <span class="literal">speed</span> variable, which starts at 0, keeps track of how much speed the bug gains on top of its starting speed.</p>&#13;
<p class="indent">Now we have a starting point from which to increase the bug’s speed every time it eats a berry and decrease when it hits an obstacle. We’ll do that using the <span class="literal">change speed by</span> block.</p>&#13;
<div class="image"><img src="Images/f066-02.jpg" alt="Image" width="786" height="593"/></div>&#13;
<p class="caption"><em>Using the <span class="codeitalic">change speed by</span> block</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_67"/>A good increment is 0.5 seconds, which is half of 1, or five-tenths of a second. If the increment was 1, the bug would speed up too quickly. Try different numbers. Check the speed display in the corner to make sure that eating berries makes the bug faster and hitting obstacles slows it back down again.</p>&#13;
<h3 class="h3" id="ch02lev1sec8">Ending the Game</h3>&#13;
<p class="noindent">The bug in <em>Weird Bug Chowdown</em> gets bigger and faster the more berries it eats. But right now, there’s no real limit to how big it can grow or how fast it can go. The bug would just keep growing and growing. We can pick a point in the bug’s growth and say, that’s enough! We can make something happen when the bug gets to a certain size or is moving at a certain speed. For example, when the bug is really huge, instead of getting any bigger, it could turn into a butterfly.</p>&#13;
<p class="indent">How do you decide what the endpoint is? How fast is too fast? Turn on the speed display and play the game for a bit. Try to find the point where it’s fast, difficult, and intense, but not <em>too</em> fast, difficult, and intense. Find the point <em>right before</em> the game would get too hard, and remember the speed variable number. For me, 7.5 feels like a good top speed.</p>&#13;
<p class="indent">We want the game ending to be big and splashy. When the player reaches the game’s end, they should know it and feel rewarded. But before we code it, let’s pick a new costume to represent the bug’s evolved form and add a little music to play during its transformation.</p>&#13;
<h4 class="h4" id="ch02lev2sec14">Choosing the Butterfly Costume</h4>&#13;
<p class="noindent">Go to the bug’s <strong>Costumes</strong> tab. You can draw your own new costume for the bug if you want, such as a multicolored butterfly that is way bigger than the original bug (but still facing to the right!). For this example, I’ll pick a butterfly costume from Scratch’s built-in library.</p>&#13;
<p class="indent">Hover over the costume menu and click the <strong>Choose a Costume</strong> button to bring up a menu of pictures. This should look similar to the Sound Library we picked the chomp effect from. Again, you can click the <strong>Animals</strong> category to make it easier to find the butterflies. I like <span class="literal">Butterfly2-b</span> because it’s the most colorful yet still weird looking. A weird bug would grow up into a weird butterfly, wouldn’t it?</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_68"/><img src="Images/f068-01.jpg" alt="Image" width="951" height="698"/></div>&#13;
<p class="caption"><em>Choosing a butterfly costume</em></p>&#13;
<p class="indent">Let’s pick some music to accompany the transformation. Again, we’ll dig up something from the Sound Library. Check out the <strong>Loops</strong> category to find a bunch of short music pieces. We’ll use the one called <span class="literal">dance magic</span>. It sounds like music you might hear while transforming into a butterfly.</p>&#13;
<h4 class="h4" id="ch02lev2sec15">Coding the Metamorphosis</h4>&#13;
<p class="noindent">Using simple branching, we’ll code the transformation. When the bug eats a berry, we use a conditional to check whether the bug is fast and big enough to transform. If the bug hasn’t reached its size and speed limit yet, the game continues and the bug just gets bigger and faster. (We’ll use speed 7.5 to check whether it’s moving at that speed.) If it’s fast enough, we’ll broadcast the new message <span class="literal">evolve</span>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_69"/><img src="Images/f069-01.jpg" alt="Image" width="811" height="811"/></div>&#13;
<p class="caption"><em>Turning your bug into a butterfly</em></p>&#13;
<p class="indent">As you can see, we made a <span class="literal">when I receive evolve</span> event to handle the actual transformation. Yes, this means that sprites can receive messages that they can also broadcast! We can use a broadcast to make a sprite run an event in the middle of another event. This <span class="literal">evolve</span> event changes the bug to the <span class="literal">butterfly</span> costume and sets its size back to <span class="literal">100%</span>. Otherwise, it would be super huge, because the bug is over double its starting size at this point!</p>&#13;
<p class="indent">Then the event sends the butterfly to the front. “Sending it to the front” means bringing it closer to the screen than the other objects. Think of a pile of photos sitting on your kitchen table. We want the butterfly to be in front of all the other sprites so it can soar over them on its majestic wings. If we don’t send it to the front, the clone berries and poops would look like they were in front of the butterfly, which would be odd.</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_70"/><img src="Images/f070-01.jpg" alt="Image" width="300" height="303"/></div>&#13;
<p class="indent">Then the event changes the bug’s speed back to 0 (so it drifts gracefully instead of zooming superfast), sets a new variable called <span class="literal">evolved</span> to 1, and plays the <span class="literal">dance magic</span> tune.</p>&#13;
<p class="indent">The variable <span class="literal">evolved</span> keeps track of whether the game has been won. When you create the <span class="literal">evolved</span> variable, be sure it’s a <span class="literal">For all sprites</span> variable. We want every sprite in the game to be able to tell whether the game is over.</p>&#13;
<div class="image"><img src="Images/f070-02.jpg" alt="Image" width="399" height="319"/></div>&#13;
<p class="caption"><em>Creating the <span class="codeitalic">evolved</span> variable</em></p>&#13;
<p class="indent">We can also use the <span class="literal">evolved</span> variable to give the butterfly a cool color-changing effect. Under <strong>Looks</strong>, the <span class="literal">change color effect by</span> block changes how the sprite looks. You can set this block to do a bunch of different effects, like whirl, pixelate, and ghost, which makes a sprite see-through.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_71"/>To create a colorful butterfly, we’ll use the color option. This option changes all the colors of the sprite to other colors, similar to how we created the rainbow effect by cycling through the pen’s color.</p>&#13;
<div class="image"><img src="Images/f071-01.jpg" alt="Image" width="479" height="682"/></div>&#13;
<p class="caption"><em>Changing the butterfly’s color</em></p>&#13;
<p class="indent">In the bug’s main loop, use a conditional to check whether the <span class="literal">evolved</span> variable is equal to 1. If it is, run the color effect. Normal movement, drawing, and bouncing off the edge of the screen should still happen, so we don’t want to change that.</p>&#13;
<p class="indent">It’s important to make sure your bug changes its costume back to its original, weird bug form during its setup phase. Add the <span class="literal">switch costume to costume1</span> block and the <span class="literal">set evolved to 0</span> block to the <span class="literal">when flag clicked</span> event. Both blocks will reset the variables that are changed in the butterfly ending. Otherwise, you could start the game as a butterfly when you restart the game!</p>&#13;
<p class="indent">All right, try your game to see if it works. Can you get to your game’s ending and turn the bug into a butterfly?</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_72"/><img src="Images/f072-01.jpg" alt="Image" width="928" height="696"/></div>&#13;
<p class="caption"><em>Transformation complete!</em></p>&#13;
<h3 class="h3" id="ch02lev1sec9">Changing the Butterfly’s Behavior</h3>&#13;
<p class="noindent">If you’re able to turn your bug into a butterfly, you’ll notice that the butterfly can still eat berries, poop, and get bigger or smaller. The butterfly is supposed to be the bug’s final form that transcends a bug’s mortal limitations. It’s also supposed to be flying in the air where it should no longer have to worry about poop or bad berries.</p>&#13;
<p class="indent">Because we made <span class="literal">evolve</span> a <em>universal variable</em>, which is a variable that all objects can see, we can just add conditionals to berries and poop to prevent them from checking for collision with the bug after it has evolved. Here’s what the conditional looks like for the <span class="literal">poop</span> sprite.</p>&#13;
<p class="indent">We check whether the <span class="literal">evolved</span> variable is equal to <span class="literal">0</span>, which means that the bug has not yet evolved into a butterfly. Only <em>then</em> do we check for contact with the bug.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_73"/><img src="Images/f073-01.jpg" alt="Image" width="509" height="722"/></div>&#13;
<p class="caption"><em>Checking whether the bug has turned into a butterfly</em></p>&#13;
<p class="indent">You can use the same conditional on the berry: use one conditional to keep the original berry from making clones after the player has won. Use another conditional to keep clones from checking for contact with the bug after it has turned into a butterfly. Just make sure your blocks are nested correctly.</p>&#13;
<p class="indent">Most importantly, be sure that everything that should only happen before the bug has evolved is <em>inside</em> the branch instead of outside it.</p>&#13;
<h3 class="h3" id="ch02lev1sec10">Adding a Starting Message</h3>&#13;
<p class="noindent">Now our game has an ending. But to <em>really</em> make it complete, let’s put something at the beginning, too. We’ll add a little message to let the player know what they should be doing, which is chowing down on those berries!</p>&#13;
<p class="indent">Under <strong>Looks</strong>, you’ll find blocks that let our sprites say things in tiny word bubbles. Use one to give the player an introductory message when the flag is first clicked.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_74"/><img src="Images/f074-01.jpg" alt="Image" width="574" height="192"/></div>&#13;
<p class="caption"><em>Adding a starting message</em></p>&#13;
<p class="indent">Again, because of timing, we’ll put this message in its own stack. If it was in the same stack as the main loop, the main loop wouldn’t start until the word bubble disappeared. The bug would just freeze until the message was gone instead of talking and moving at the same time, like a real hungry bug would.</p>&#13;
<div class="image"><img src="Images/f074-02.jpg" alt="Image" width="826" height="619"/></div>&#13;
<p class="caption"><em>What the starting message looks like</em></p>&#13;
<h3 class="h3" id="ch02lev1sec11">Optional Things to Try</h3>&#13;
<p class="noindent">Here are some ideas for additional modifications to <em>Weird Bug Chowdown</em> if you want a challenge. All of them can be done using the skills you’ve learned so far. If you need a hint, open my version of the game in your web browser and click <strong>See inside</strong> to see the game’s inner workings. Click <strong>Remix</strong> to create and save your own copy that you can tinker with.</p>&#13;
<p class="noindente"><span epub:type="pagebreak" id="page_75"/><strong>Exercise 1: Animate the berries, and poops’ appearances and disappearances.</strong></p>&#13;
<p class="noindent">Instead of suddenly appearing and disappearing, objects can appear gradually, shrink out of sight, or fade away. Instead of using costumes, try graphical effects, like the ghost effect or size changing. You could make a berry look like it’s warping in by having it start a few sizes larger than usual and then using a <span class="literal">repeat</span> block to make it smaller until it’s the normal size. (Recall that a sprite’s original size is always 100 percent.) A poop could disappear by shrinking until it’s gone. Be creative!</p>&#13;
<p class="noindente"><strong>Exercise 2: Show a message the first time the bug eats a bad berry, warning the player about them.</strong></p>&#13;
<p class="noindent">Add a message like “Yuck! Green berries have gone bad!” The trick is to have the message appear <em>only the first time</em> the bug eats a bad berry. Make sure the warning only happens on a bad berry, not on a poop! For style, you want the word balloon to come from the bug, not from the berry. You’ll probably want to use a variable to track whether the message has appeared yet and a broadcast message to tell the bug to produce the word balloon.</p>&#13;
<h3 class="h3" id="ch02lev1sec12">What You Learned</h3>&#13;
<p class="noindent">In this chapter, we covered some more advanced ideas. You learned how to make your own variables to keep track of stuff. You programmed your sprites to clone themselves so you could have multiple copies of the same sprite. By broadcasting messages, you gave sprites a way to communicate with each other. You also learned about time pressure and how to use it to make a game more exciting.</p>&#13;
<p class="indent">In the next chapter, we’ll talk about how to make larger games in Scratch, games with multiple levels and scenes. We’ll explore what those levels could look like.</p>&#13;
<p class="indent">Scratch is a great way to learn how to program. The more you learn about Scratch, the more prepared you’ll be for a “Serious Adult” programming language. But the basic ideas are the same. If you’re just interested in making cool games, Scratch is an excellent choice for doing that. Now let’s make some more neat Scratch games. See you in <a href="ch03.xhtml#ch03">Chapter 3</a>!<span epub:type="pagebreak" id="page_76"/></p>&#13;
</div>



  </body></html>