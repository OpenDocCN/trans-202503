- en: Chapter 9. Password Attacks
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章 密码攻击
- en: Passwords are often the path of least resistance on pentesting engagements.
    A client with a strong security program can fix missing Windows patches and out-of-date
    software, but the users themselves can’t be patched. We’ll look at attacking users
    when we discuss
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 密码通常是渗透测试中最容易突破的部分。一家拥有强大安全计划的客户可以修复缺失的Windows补丁和过时的软件，但用户自身是无法通过补丁修复的。我们将在讨论[第11章](ch11.xhtml
    "第11章 社会工程学")中的社交工程时，深入探讨如何攻击用户。
- en: social engineering in [Chapter 11](ch11.xhtml "Chapter 11. Social Engineering"),
    but if we can correctly guess or calculate a user’s password, we may be able to
    avoid involving the user in the attack at all. In this chapter we’ll look at how
    to use tools to automate running services on our targets and sending usernames
    and passwords. Additionally, we’ll study cracking the password hashes we gained
    access to in [Chapter 8](ch08.xhtml "Chapter 8. Exploitation").
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](ch11.xhtml "第11章 社会工程学")中，我们将探讨社交工程，但如果我们能够正确猜测或计算出用户的密码，我们可能完全不需要涉及用户进行攻击。在本章中，我们将探讨如何使用工具自动化运行目标上的服务，并发送用户名和密码。此外，我们还将学习如何破解我们在[第8章](ch08.xhtml
    "第8章 利用")中获得的密码哈希值。
- en: Password Management
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码管理
- en: Companies are waking up to the inherent risks of password-based authentication;
    brute-force attacks and educated guesses are both serious risks to weak passwords.
    Many organizations use biometric (fingerprint or retinal scan-based) or two-factor
    authentication to mitigate these risks. Even web services such as Gmail and Dropbox
    offer two-factor authentication in which the user provides a password as well
    as a second value, such as the digits on an electronic token. If two-factor authentication
    is not available, using strong passwords is imperative for account security because
    all that stands between the attacker and sensitive data may come down to a simple
    string. Strong passwords are long, use characters from multiple complexity classes,
    and are not based on a dictionary word.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 公司开始意识到基于密码的身份验证固有的风险；暴力破解攻击和有针对性的猜测都对弱密码构成严重威胁。许多组织使用生物识别技术（如指纹或视网膜扫描）或双重身份验证来减轻这些风险。甚至像Gmail和Dropbox这样的在线服务也提供双重身份验证，用户除了输入密码，还需要提供第二个值，如电子令牌上的数字。如果没有双重身份验证，那么使用强密码对于账户安全至关重要，因为在攻击者和敏感数据之间，可能仅有一串简单的字符。强密码应该长，包含来自多个复杂度类别的字符，并且不应基于词典中的单词。
- en: The passwords we use in this book are deliberately terrible, but unfortunately,
    many users don’t behave much better when it comes to passwords. Organizations
    can force users to create strong passwords, but as passwords become more complex,
    they become harder to remember. Users are likely to leave a password that they
    can’t remember in a file on their computer, in their smartphone, or even on a
    Post-it note, because it’s just easier to keep of track them that way. Of course,
    passwords that can be discovered lying around in plaintext undermine the security
    of using a strong password.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中使用的密码故意设计得非常糟糕，但不幸的是，许多用户在密码管理方面的行为也好不到哪里去。组织可以强制用户创建强密码，但随着密码变得越来越复杂，记忆它们变得更加困难。用户可能会把自己记不住的密码放在电脑文件、智能手机里，甚至是便签纸上，因为这样更容易管理。当然，密码如果以明文形式放在周围被发现，就会破坏使用强密码的安全性。
- en: Another cardinal sin of good password management is using the same password
    on many sites. In a worst-case scenario, the CEO’s weak password for a compromised
    web forum might just be the very same one for his or her corporate access to financial
    documents. Password reuse is something to bear in mind while performing password
    attacks; you may find the same passwords work on multiple systems and sites.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个密码管理的重大错误是将相同的密码用于多个网站。在最坏的情况下，CEO为一个受损的论坛使用的弱密码，可能恰好也是他或她访问财务文件的公司密码。密码重用是进行密码攻击时需要考虑的一个因素；你可能会发现相同的密码在多个系统和网站上都能使用。
- en: Password management presents a difficult problem for IT staff and will likely
    continue to be a fruitful avenue for attackers unless or until password-based
    authentication is phased out entirely in favor of another model.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 密码管理对于IT工作人员来说是一个棘手的问题，并且除非完全废除基于密码的身份验证，转而采用其他身份验证模型，否则它可能会继续成为攻击者的一个有效途径。
- en: Online Password Attacks
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在线密码攻击
- en: Just as we used automated scans to find vulnerabilities, we can use scripts
    to automatically attempt to log in to services and find valid credentials. We’ll
    use tools designed for automating online password attacks or guessing passwords
    until the server responds with a successful login. These tools use a technique
    called *brute forcing*. Tools that use brute forcing try every possible username
    and password combination, and given enough time, they *will* find valid credentials.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们使用自动扫描来寻找漏洞一样，我们可以使用脚本自动尝试登录服务并找到有效的凭证。我们将使用专门设计用于自动化在线密码攻击的工具，或者通过猜测密码直到服务器响应成功登录。这些工具使用一种叫做*暴力破解*的技术。使用暴力破解的工具会尝试每一种可能的用户名和密码组合，只要有足够的时间，它们*会*找到有效的凭证。
- en: The trouble with brute forcing is that as stronger passwords are used, the time
    it takes to brute-force them moves from hours to years and even beyond your natural
    lifetime. We can probably find working credentials more easily by feeding educated
    guesses about the correct passwords into an automated login tool. Dictionary words
    are easy to remember, so despite the security warnings, many users incorporate
    them into passwords. Slightly more security-conscious users might put some numbers
    at the end of their password or maybe even an exclamation point.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 暴力破解的麻烦在于，随着密码强度的增加，破解密码所需的时间从几小时延长到几年，甚至超出你的自然寿命。通过将一些对正确密码的有根据的猜测输入到自动化登录工具中，我们可能更容易找到有效的凭证。字典词汇容易记住，因此尽管有安全警告，许多用户还是会把它们作为密码的一部分。稍微有点安全意识的用户可能会在密码末尾加上一些数字，甚至是一个感叹号。
- en: Wordlists
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典文件
- en: Before you can use a tool to guess passwords, you need a list of credentials
    to try. If you don’t know the name of the user account you want to crack, or you
    just want to crack as many accounts as possible, you can provide a username list
    for the password-guessing tool to iterate through.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以使用工具来猜测密码之前，你需要一个凭证列表进行尝试。如果你不知道要破解的用户账户的名称，或者你只是想破解尽可能多的账户，你可以为密码猜测工具提供一个用户名列表，供其逐一尝试。
- en: User Lists
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用户列表
- en: When creating a user list, first try to determine the client’s username scheme.
    For instance, if we’re trying to break into employee email accounts, figure out
    the pattern the email addresses follow. Are they *firstname.lastname*, just a
    first name, or something else?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建用户列表时，首先尝试确定客户的用户名方案。例如，如果我们试图突破员工的电子邮件账户，弄清楚电子邮件地址的模式是非常重要的。它们是*firstname.lastname*格式，只有名字，还是其他的格式？
- en: You can look for good username candidates on lists of common first or last names.
    Of course, the guesses will be even more likely to succeed if you can find the
    names of your target’s actual employees. If a company uses a first initial followed
    by a last name for the username scheme, and they have an employee named John Smith,
    *jsmith* is likely a valid username. [Example 9-1](ch09.xhtml#sample_user_list
    "Example 9-1. Sample user list") shows a very short sample user list. You’d probably
    want a larger list of users in an actual engagement.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在常见的名字列表中寻找合适的用户名候选者。当然，如果你能够找到目标实际员工的名字，猜测成功的可能性会更高。如果一个公司使用名字首字母加姓氏作为用户名方案，且该公司有一位名叫John
    Smith的员工，那么*jsmith*很可能是一个有效的用户名。[示例 9-1](ch09.xhtml#sample_user_list "示例 9-1.
    用户列表")展示了一个非常简短的示例用户列表。在实际的渗透测试中，你可能需要一个更大的用户列表。
- en: Example 9-1. Sample user list
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-1. 用户列表示例
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once you’ve created your list, save the sample usernames in a text file in Kali
    Linux, as shown in [Example 9-1](ch09.xhtml#sample_user_list "Example 9-1. Sample
    user list"). You’ll use this list to perform online password attacks in [Guessing
    Usernames and Passwords with Hydra](ch09.xhtml#guessing_usernames_and_passwords_with_hy
    "Guessing Usernames and Passwords with Hydra").
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了列表，将示例用户名保存到Kali Linux中的一个文本文件中，如[示例 9-1](ch09.xhtml#sample_user_list
    "示例 9-1. 用户列表")所示。你将使用这个列表在[使用Hydra猜测用户名和密码](ch09.xhtml#guessing_usernames_and_passwords_with_hy
    "使用Hydra猜测用户名和密码")中执行在线密码攻击。
- en: Password Lists
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 密码列表
- en: In addition to a list of possible users, we’ll also need a password list, as
    shown in [Example 9-2](ch09.xhtml#sample_password_list "Example 9-2. Sample password
    list").
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可能的用户列表，我们还需要一个密码列表，如[示例 9-2](ch09.xhtml#sample_password_list "示例 9-2. 密码列表")所示。
- en: Example 9-2. Sample password list
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-2. 密码列表示例
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Like our username list, this password list is just a very short example (and
    one that, hopefully, wouldn’t find the correct passwords for too many accounts
    in the real world). On a real engagement, you should use a much longer wordlist.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 像我们的用户名列表一样，这个密码列表只是一个非常简短的示例（希望它不会在现实中找到太多账户的正确密码）。在实际的工作中，你应该使用更长的字典列表。
- en: There are many good password lists available on the Internet. Good places to
    look for wordlists include *[http://packetstormsecurity.com/Crackers/wordlists/](http://packetstormsecurity.com/Crackers/wordlists/)*
    and *[http://www.openwall.com/wordlists/](http://www.openwall.com/wordlists/)*.
    A few password lists are also built into Kali Linux. For example, the */usr/share/wordlists*
    directory contains a file called *rockyou.txt.gz*. This is a compressed wordlist.
    If you unzip the file with the gunzip Linux utility, you’ll have about 140 MB
    of possible passwords, which should give you a pretty good start. Also, some of
    the password-cracking tools in Kali come with sample wordlists. For example, the
    John the Ripper tool (which we’ll use in [Offline Password Attacks](ch09.xhtml#offline_password_attacks
    "Offline Password Attacks")) includes a wordlist at */usr/share/john/password.lst*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有许多优秀的密码列表。查找字典列表的好地方包括 *[http://packetstormsecurity.com/Crackers/wordlists/](http://packetstormsecurity.com/Crackers/wordlists/)*
    和 *[http://www.openwall.com/wordlists/](http://www.openwall.com/wordlists/)*。一些密码列表也内置在
    Kali Linux 中。例如，*/usr/share/wordlists* 目录包含一个名为 *rockyou.txt.gz* 的文件。这是一个压缩的字典列表。如果你使用
    gunzip Linux 工具解压这个文件，你将得到大约 140 MB 的可能密码，这应该能给你一个不错的开端。此外，Kali 中的一些密码破解工具自带示例字典列表。例如，John
    the Ripper 工具（我们将在[离线密码攻击](ch09.xhtml#offline_password_attacks "离线密码攻击")中使用）包含一个位于
    */usr/share/john/password.lst* 的字典列表。
- en: For better results, customize your wordlists for a particular target by including
    additional words. You can make educated guesses based on information you gather
    about employees online. Information about spouses, children, pets, and hobbies
    may put you on the right track. For example, if your target’s CEO is a huge Taylor
    Swift fan on social media, consider adding keywords related to her albums, her
    music, or her boyfriends. If your target’s password is *TaylorSwift13!*, you should
    be able to confirm it using password guessing long before you have to run a whole
    precompiled wordlist or a brute-force attempt. Another thing to keep in mind is
    the language(s) used by your target. Many of your pentesting targets may be global.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更好的结果，可以通过添加额外的单词来定制你的字典列表，以针对特定的目标。你可以根据你在网上收集到的关于员工的信息进行合理猜测。关于配偶、孩子、宠物和爱好的信息可能会帮助你走在正确的道路上。例如，如果你的目标的
    CEO 是社交媒体上的泰勒·斯威夫特大粉丝，可以考虑添加与她的专辑、音乐或男朋友相关的关键词。如果你的目标密码是 *TaylorSwift13!*，你应该能在运行整个预编译字典列表或进行暴力破解尝试之前，通过密码猜测确认它。另一个需要记住的事情是你的目标使用的语言。你的许多渗透测试目标可能是全球性的。
- en: In addition to making educated guesses based on information you gather while
    performing reconnaissance, a tool like the ceWL custom wordlist generator will
    search a company website for words to add to your wordlist. [Example 9-3](ch09.xhtml#using_cewl_to_build_custom_wordlists
    "Example 9-3. Using ceWL to build custom wordlists") shows how you might use ceWL
    to create a wordlist based on the contents of *[www.bulbsecurity.com](http://www.bulbsecurity.com)*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了根据你在侦察过程中收集到的信息进行合理猜测外，像 ceWL 这样的自定义字典生成工具将会搜索公司网站，收集可以添加到字典列表中的单词。[示例 9-3](ch09.xhtml#using_cewl_to_build_custom_wordlists
    "示例 9-3. 使用 ceWL 构建自定义字典") 展示了你如何使用 ceWL 根据 *[www.bulbsecurity.com](http://www.bulbsecurity.com)*
    网站的内容创建字典列表。
- en: Example 9-3. Using ceWL to build custom wordlists
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-3. 使用 ceWL 构建自定义字典列表
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The command `ceWL --help` lists ceWL’s usage instructions. Use the `-d` (depth)
    option ❶ to specify how many links ceWL should follow on the target website. If
    you think that your target has a minimum password-size requirement, you might
    specify a minimum word length to match with the `-m` option ❷. Once you’ve made
    your choices, output ceWL’s results to a file with the `-w` option ❸. For example,
    to search *[www.bulbsecurity.com](http://www.bulbsecurity.com)* to depth `1` with
    minimum word length of `5` characters and output the words found to the file *bulbwords.txt*,
    you would use the command shown at ❹. The resulting file would include all words
    found on the site that meet your specifications.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 `ceWL --help` 列出了 ceWL 的使用说明。使用 `-d`（深度）选项 ❶ 来指定 ceWL 应该在目标网站上跟踪多少个链接。如果你认为目标有最低密码长度要求，你可以使用
    `-m` 选项 ❷ 来指定最小单词长度。一旦做出选择，使用 `-w` 选项 ❸ 将 ceWL 的结果输出到文件。例如，要在深度为 `1` 的情况下搜索 *[www.bulbsecurity.com](http://www.bulbsecurity.com)*，并设置最小单词长度为
    `5` 个字符，将发现的单词输出到文件 *bulbwords.txt*，你可以使用 ❹ 处显示的命令。生成的文件将包含网站上符合你要求的所有单词。
- en: Another method for creating wordlists is producing a list of every possible
    combination of a given set of characters, or a list of every combination of characters
    for a specified number of characters. The tool Crunch in Kali will generate these
    character sets for you. Of course, the more possibilities, the more disk space
    is required for storage. A very simple example of using Crunch is shown in [Example 9-4](ch09.xhtml#brute-forcing_a_keyspace_with_crunch
    "Example 9-4. Brute-forcing a keyspace with Crunch").
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种创建字典的方法是生成一个包含给定字符集所有可能组合的列表，或者生成一个包含指定字符数的所有可能字符组合的列表。Kali 中的工具 Crunch 可以为你生成这些字符集。当然，可能性越多，所需的磁盘空间就越大。使用
    Crunch 的一个非常简单的示例见 [示例 9-4](ch09.xhtml#brute-forcing_a_keyspace_with_crunch "示例
    9-4. 使用 Crunch 进行密钥空间暴力破解")。
- en: Example 9-4. Brute-forcing a keyspace with Crunch
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-4. 使用 Crunch 进行密钥空间暴力破解
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This example generates a list of all the possible seven-character combinations
    of just the characters *A* and *B*. A more useful, but much, much larger example
    would be entering `crunch 7 8`, which would generate a list of all the possible
    combinations of characters for a string between seven and eight characters in
    length, using the default Crunch character set of lowercase letters. This technique
    is known as *keyspace brute-forcing*. While it is not feasible to try every possible
    combination of characters for a password in the span of your natural life, it
    is possible to try specific subsets; for instance, if you knew the client’s password
    policy requires passwords to be at least seven characters long, trying all seven-
    and eight-character passwords would probably result in cracking success—even among
    the rare users who did not base their passwords on a dictionary word.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例生成了仅由字符 *A* 和 *B* 组成的所有可能七字符组合的列表。一个更有用但更大的示例是输入 `crunch 7 8`，这将生成一个包含长度在七到八个字符之间的所有可能字符组合的列表，使用默认的
    Crunch 字符集，即小写字母。这种技术被称为 *密钥空间暴力破解*。虽然在你的一生中尝试每一种可能的密码组合是不现实的，但可以尝试特定的子集；例如，如果你知道客户的密码策略要求密码至少七个字符长，那么尝试所有七字符和八字符密码可能会导致破解成功——即使是那些没有根据字典单词设置密码的稀有用户。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Developing a solid wordlist or set of wordlists is a constantly evolving process.
    For the exercises in this chapter, you can use the short sample wordlist we created
    in [Example 9-2](ch09.xhtml#sample_password_list "Example 9-2. Sample password
    list"), but as you gain experience in the field, you’ll develop more complex lists
    that work well on client engagements.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个完善的字典或字典集是一个不断发展的过程。在本章的练习中，你可以使用我们在 [示例 9-2](ch09.xhtml#sample_password_list
    "示例 9-2. 样本密码列表") 中创建的简短样本字典，但随着你在这一领域积累经验，你将会开发出更复杂、更适用于客户任务的字典。
- en: Now let’s see how to use our wordlist to guess passwords for services running
    on our targets.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用我们的字典来猜测目标服务上的密码。
- en: Guessing Usernames and Passwords with Hydra
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Hydra 猜测用户名和密码
- en: If you have a set of credentials that you’d like to try against a running service
    that requires a login, you can input them manually one by one or use a tool to
    automate the process. Hydra is an online password-guessing tool that can be used
    to test usernames and passwords for running services. (Following the tradition
    of naming security tools after the victims of Heracles’s labors, Hydra is named
    for the mythical Greek serpent with many heads.) [Example 9-5](ch09.xhtml#using_hydra_to_guess_pop3_usernames_and
    "Example 9-5. Using Hydra to guess POP3 usernames and passwords") shows an example
    of using Hydra for online password guessing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一组凭证，想要尝试在需要登录的运行中的服务上使用，你可以手动一个一个输入，或者使用工具来自动化这个过程。Hydra 是一个在线密码猜测工具，可以用来测试运行服务的用户名和密码。（遵循将安全工具命名为赫拉克勒斯十二项劳绩中受害者的传统，Hydra
    被命名为希腊神话中有多个头的蛇怪。）[示例 9-5](ch09.xhtml#using_hydra_to_guess_pop3_usernames_and
    "示例 9-5。使用 Hydra 猜测 POP3 用户名和密码") 展示了如何使用 Hydra 进行在线密码猜测的示例。
- en: Example 9-5. Using Hydra to guess POP3 usernames and passwords
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-5。使用 Hydra 猜测 POP3 用户名和密码
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Example 9-5](ch09.xhtml#using_hydra_to_guess_pop3_usernames_and "Example 9-5. Using
    Hydra to guess POP3 usernames and passwords") shows how to use Hydra to guess
    usernames and passwords by running through our username and password files to
    search for valid POP3 credentials on our Windows XP target. This command uses
    the `-L` flag to specify the username file, the `-``P` for the password list file,
    and specifies the protocol `pop3`. Hydra finds that user *georgia*’s password
    is `password` at ❶. (Shame on *georgia* for using such an insecure password!)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-5](ch09.xhtml#using_hydra_to_guess_pop3_usernames_and "示例 9-5。使用 Hydra
    猜测 POP3 用户名和密码") 展示了如何通过运行用户名和密码文件来使用 Hydra 猜测 POP3 凭证，针对我们的 Windows XP 目标进行查找。此命令使用
    `-L` 标志指定用户名文件，使用 `-P` 指定密码列表文件，并指定 `pop3` 协议。Hydra 发现 *georgia* 用户的密码是 `password`
    ❶。（*georgia* 使用如此不安全的密码，真该羞愧！）'
- en: Sometimes you’ll know that a specific username exists on a server, and you just
    need a valid password to go with it. For example, we used the `SMTP VRFY` verb
    to find valid usernames on the SLMail server on the Windows XP target in [Chapter 6](ch06.xhtml
    "Chapter 6. Finding Vulnerabilities"). As you can see in [Example 9-6](ch09.xhtml#using_a_specific_username_with_hydra
    "Example 9-6. Using a specific username with Hydra"), we can use the *`-`*`l`
    flag instead of *`-`*`L` to specify one particular username. Knowing that, let’s
    look for a valid password for user *georgia* on the `pop3` server.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会知道某个特定的用户名在服务器上存在，你只需要一个有效的密码来配合它。例如，我们在[第 6 章](ch06.xhtml "第 6 章。寻找漏洞")中使用了
    `SMTP VRFY` 命令来查找 Windows XP 目标上的 SLMail 服务器上的有效用户名。正如你在[示例 9-6](ch09.xhtml#using_a_specific_username_with_hydra
    "示例 9-6。使用特定用户名与 Hydra")中看到的，我们可以使用*`-`*`l` 标志代替 *`-`*`L` 来指定一个特定的用户名。知道这一点后，让我们来寻找
    `pop3` 服务器上 *georgia* 用户的有效密码。
- en: Example 9-6. Using a specific username with Hydra
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-6。使用特定用户名与 Hydra
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Hydra found *georgia*’s password to be *password* ❶.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Hydra 找到了 *georgia* 的密码是 *password* ❶。
- en: Now, in [Example 9-7](ch09.xhtml#using_netcat_to_log_in_with_guessed_cred "Example 9-7. Using
    Netcat to log in with guessed credentials"), we’ll use our credentials to read
    *georgia*’s email.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在[示例 9-7](ch09.xhtml#using_netcat_to_log_in_with_guessed_cred "示例 9-7。使用
    Netcat 通过猜测的凭证登录")中，我们将使用我们的凭证来读取*georgia*的邮件。
- en: Example 9-7. Using Netcat to log in with guessed credentials
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-7。使用 Netcat 通过猜测的凭证登录
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Specify the `pop3` protocol, and provide the username and password when prompted.
    (Unfortunately, there are no love letters in this particular inbox.) Hydra can
    perform online password guessing against a range of services. (See its manual
    page for a complete list.) For example, here we use the credentials we found with
    Hydra to log in with Netcat.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 指定 `pop3` 协议，并在提示时提供用户名和密码。（不幸的是，这个收件箱里没有情书。）Hydra 可以对多种服务执行在线密码猜测。（有关完整列表，请查看其手册页面。）例如，在这里我们使用通过
    Hydra 找到的凭证来使用 Netcat 登录。
- en: 'Keep in mind that most services can be configured to lock out accounts after
    a certain number of failed login attempts. There are few better ways to get noticed
    by a client’s IT staff than suddenly locking out several user accounts. Logins
    in rapid succession can also tip off firewalls and intrusion-prevention systems,
    which will get your IP address blocked at the perimeter. Slowing down and randomizing
    scans can help with this, but there is, of course, a tradeoff: Slower scans will
    take longer to produce results.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，大多数服务都可以配置为在一定次数的登录失败后锁定账户。没有什么比突然锁定多个用户账户更能引起客户 IT 团队注意的了。快速连续的登录尝试也可能会引起防火墙和入侵防御系统的警觉，这样你的
    IP 地址会在边界被屏蔽。减慢并随机化扫描速度有助于避免这种情况，但这当然是有权衡的：扫描变慢意味着需要更长的时间才能得到结果。
- en: One way to avoid having your login attempts noticed is to try to guess a password
    before trying to log in, as you’ll learn in the next section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 避免让登录尝试被察觉的一种方法是，在尝试登录之前先猜测密码，正如你将在下一节中学到的那样。
- en: Offline Password Attacks
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 离线密码攻击
- en: 'Another way to crack passwords (without being discovered) is to get a copy
    of the password hashes and attempt to reverse them back to plaintext passwords.
    This is easier said than done because hashes are designed to be the product of
    a one-way hash function: Given an input, you can calculate the output using the
    hash function, but given the output, there is no way to reliably determine the
    input. Thus, if a hash is compromised, there should be no way to calculate the
    plaintext password. We can, however, guess a password, hash it with the one-way
    hash function, and compare the results to the known hash. If the two hashes are
    the same, we’ve found the correct password.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 破解密码的另一种方法（而不被发现）是获取密码哈希并尝试将它们逆向恢复为明文密码。这说起来容易做起来难，因为哈希是设计为单向哈希函数的产物：给定一个输入，你可以通过哈希函数计算出输出，但给定输出，你无法可靠地确定输入。因此，如果哈希值被泄露，应该无法计算出明文密码。然而，我们可以猜测密码，将其用单向哈希函数进行哈希，然后将结果与已知的哈希进行比较。如果两个哈希值相同，那么我们就找到了正确的密码。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As you’ll learn in [LM vs. NTLM Hashing Algorithms](ch09.xhtml#lm_vsdot_ntlm_hashing_algorithms
    "LM vs. NTLM Hashing Algorithms"), not all password hashing systems have stood
    the test of time. Some have been cracked and are no longer considered secure.
    In these cases, regardless of the strength of the password chosen, an attacker
    with access to the hashes will be able to recover the plaintext password in a
    reasonable amount of time.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[LM 与 NTLM 哈希算法](ch09.xhtml#lm_vsdot_ntlm_hashing_algorithms "LM vs. NTLM
    Hashing Algorithms")一节中所学到的，并非所有密码哈希系统都经得起时间的考验。有些已经被破解，且不再被认为是安全的。在这些情况下，无论选择什么强度的密码，攻击者只要能够访问到哈希值，就能在合理的时间内恢复出明文密码。
- en: Of course, it’s even better if you can get access to passwords in plaintext
    and save yourself the trouble of trying to reverse the cryptography, but often
    the passwords you encounter will be hashed in some way. In this section we’ll
    focus on finding and reversing password hashes. If you stumble upon a program
    configuration file, database, or other file that stores passwords in plaintext,
    all the better.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你能直接获取明文密码，那就更好了，这样就能省去逆向破解加密的麻烦，但你遇到的密码通常会以某种方式被哈希处理。在这一节中，我们将重点讨论如何查找和破解密码哈希。如果你偶然发现一个存储明文密码的程序配置文件、数据库或其他文件，那就更好了。
- en: But before we can try to crack password hashes, we have to find them. We all
    hope that the services that store our passwords do a good job of protecting them,
    but that’s never a given. It only takes one exploitable flaw or a user who falls
    victim to a social-engineering attack (discussed in [Chapter 11](ch11.xhtml "Chapter 11. Social
    Engineering")) to bring down the whole house of cards. You’ll find plenty of password
    hashes lying around sites like Pastebin, remnants from past security breaches.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们尝试破解密码哈希之前，必须先找到它们。我们都希望存储我们密码的服务能够做好保护工作，但这并非理所当然。只需要一个可利用的漏洞或一个成为社交工程攻击受害者的用户（这在[第11章](ch11.xhtml
    "Chapter 11. Social Engineering")中有讨论），就能导致整个系统崩溃。你会在像 Pastebin 这样的网站上发现大量的密码哈希，这些哈希是过去安全漏洞的遗留物。
- en: In [Chapter 8](ch08.xhtml "Chapter 8. Exploitation"), we gained access to some
    password hashes on the Linux and Windows XP targets. Having gained a Meterpreter
    session with system privileges on the Windows XP system via the *windows/smb/ms08_067_netapi*
    Metasploit module, we can use the `hashdump` Meterpreter command to print the
    hashed Windows passwords, as shown in [Example 9-8](ch09.xhtml#dumping_password_hashes_in_meterpreter
    "Example 9-8. Dumping password hashes in Meterpreter").
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](ch08.xhtml "第 8 章. 利用")中，我们获得了 Linux 和 Windows XP 目标机上的一些密码哈希。通过 *windows/smb/ms08_067_netapi*
    Metasploit 模块，我们获得了 Windows XP 系统上的带有系统权限的 Meterpreter 会话，可以使用 `hashdump` Meterpreter
    命令打印出已哈希的 Windows 密码，如 [示例 9-8](ch09.xhtml#dumping_password_hashes_in_meterpreter
    "示例 9-8. 在 Meterpreter 中导出密码哈希") 所示。
- en: Example 9-8. Dumping password hashes in Meterpreter
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-8. 在 Meterpreter 中导出密码哈希
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Save the output of the hashdump to a file called *xphashes.txt*, which we will
    use in [John the Ripper](ch09.xhtml#john_the_ripper "John the Ripper").
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将哈希导出的输出保存到名为 *xphashes.txt* 的文件中，稍后我们将使用这个文件在 [John the Ripper](ch09.xhtml#john_the_ripper
    "John the Ripper") 中进行破解。
- en: In [Chapter 8](ch08.xhtml "Chapter 8. Exploitation") we also downloaded backups
    of the SAM and SYSTEM hives using the local file inclusion issue in Zervit 0.4
    on the Windows XP system. We used this same issue to download the configuration
    file for the FileZilla FTP server, which contained passwords hashed with the MD5
    algorithm. On the Linux target, the Vsftpd smiley-face backdoor gave us root privileges,
    and thus we can access to the file */etc/shadow*, which stores Linux password
    hashes. We saved the password for user *georgia* to the file *linuxpasswords.txt*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](ch08.xhtml "第 8 章. 利用")中，我们通过 Zervit 0.4 中的本地文件包含漏洞下载了 Windows XP
    系统的 SAM 和 SYSTEM 注册表文件备份。我们还通过相同的漏洞下载了 FileZilla FTP 服务器的配置文件，该文件包含了使用 MD5 算法哈希的密码。在
    Linux 目标机上，Vsftpd 的笑脸后门让我们获得了 root 权限，因此我们可以访问文件 */etc/shadow*，该文件存储着 Linux 密码哈希值。我们将用户
    *georgia* 的密码保存到了 *linuxpasswords.txt* 文件中。
- en: Recovering Password Hashes from a Windows SAM File
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Windows SAM 文件中恢复密码哈希
- en: The SAM file stores hashed Windows passwords. Though we were able to use Meterpreter
    to dump the password hashes from the Windows XP system (as shown previously),
    sometimes you’ll be able to get only the SAM file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: SAM 文件存储的是 Windows 的哈希密码。虽然我们可以通过 Meterpreter 从 Windows XP 系统中导出密码哈希（如前所示），但有时你只能获取到
    SAM 文件。
- en: We weren’t able to get access to the primary SAM file through the Zervit 0.4
    vulnerability, but we were able to download a backup copy from the *C:\Windows\repair*
    directory using a local file-inclusion vulnerability. But when we try to read
    the SAM file (as shown in [Example 9-9](ch09.xhtml#viewing_the_sam_file "Example 9-9. Viewing
    the SAM file")), we don’t see any password hashes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们未能通过 Zervit 0.4 漏洞访问到主 SAM 文件，但我们成功地从 *C:\Windows\repair* 目录中下载了一个备份副本，利用的是本地文件包含漏洞。但是当我们尝试读取
    SAM 文件时（如 [示例 9-9](ch09.xhtml#viewing_the_sam_file "示例 9-9. 查看 SAM 文件") 所示），我们没有看到任何密码哈希。
- en: Example 9-9. Viewing the SAM file
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-9. 查看 SAM 文件
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The SAM file is obfuscated because the Windows Syskey utility encrypts the password
    hashes inside the SAM file with 128-bit Rivest Cipher 4 (RC4) to provide additional
    security. Even if an attacker or pentester can gain access to the SAM file, there’s
    a bit more work to do before we can recover the password hashes. Specifically,
    we need a key to reverse the encrypted hashes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: SAM 文件经过了混淆，因为 Windows Syskey 工具使用 128 位的 Rivest Cipher 4 (RC4) 算法加密 SAM 文件中的密码哈希值，以提供额外的安全性。即使攻击者或渗透测试人员能够访问
    SAM 文件，仍需要做一些工作才能恢复密码哈希。具体来说，我们需要一个密钥来反向解密这些加密的哈希值。
- en: The encryption key for the Syskey utility is called the *bootkey*, and it’s
    stored in the Windows SYSTEM file. You’ll find a copy of the SYSTEM file in the
    *C:\Windows\repair* directory where we found the backup SAM file. We can use a
    tool in Kali called Bkhive to extract the Syskey utility’s bootkey from the SYSTEM
    file so we can decrypt the hashes, as shown in [Example 9-10](ch09.xhtml#using_bkhive_to_extract_the_bootkey
    "Example 9-10. Using Bkhive to extract the bootkey").
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Syskey 工具的加密密钥叫做 *bootkey*，并存储在 Windows SYSTEM 文件中。你可以在 *C:\Windows\repair*
    目录下找到 SYSTEM 文件的副本，这个目录也是我们找到备份 SAM 文件的地方。我们可以使用 Kali 中的 Bkhive 工具从 SYSTEM 文件中提取
    Syskey 工具的 bootkey，这样我们就能解密哈希值，具体操作请参考 [示例 9-10](ch09.xhtml#using_bkhive_to_extract_the_bootkey
    "示例 9-10. 使用 Bkhive 提取 bootkey")。
- en: Example 9-10. Using Bkhive to extract the bootkey
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-10. 使用 Bkhive 提取 bootkey
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we use Bkhive to extract the bootkey by passing in the SYSTEM file *system*
    (the file we downloaded from the repair directory using the Zervit 0.4 directory
    traversal) as the first argument and extracting the file to *xpkey.txt*. Once
    we have the bootkey, we can use Samdump2 to retrieve the password hashes from
    the SAM file, as shown in [Example 9-11](ch09.xhtml#using_samdump2_to_recover_windows_hashes
    "Example 9-11. Using Samdump2 to recover Windows hashes"). Pass Samdump2 the location
    of the SAM file and the bootkey from Bkhive as arguments, and it will use the
    bootkey to decrypt the hashes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 Bkhive 通过将 SYSTEM 文件*system*（即我们通过 Zervit 0.4 目录遍历从修复目录下载的文件）作为第一个参数并将文件提取到*xpkey.txt*来提取启动密钥。一旦获得启动密钥，我们就可以使用
    Samdump2 从 SAM 文件中检索密码哈希，如[示例 9-11](ch09.xhtml#using_samdump2_to_recover_windows_hashes
    "示例 9-11. 使用 Samdump2 恢复 Windows 哈希")所示。将 SAM 文件的位置和 Bkhive 提取的启动密钥传递给 Samdump2，Samdump2
    将使用启动密钥解密哈希。
- en: Example 9-11. Using Samdump2 to recover Windows hashes
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-11. 使用 Samdump2 恢复 Windows 哈希
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now compare these hashes to those found with the `hashdump` command in an active
    Meterpreter session from [Example 9-8](ch09.xhtml#dumping_password_hashes_in_meterpreter
    "Example 9-8. Dumping password hashes in Meterpreter"). (A Meterpreter session
    with sufficient privileges can dump password hashes on the fly without requiring
    us to download the SAM and SYSTEM files.) Notice that our hash list in [Example 9-11](ch09.xhtml#using_samdump2_to_recover_windows_hashes
    "Example 9-11. Using Samdump2 to recover Windows hashes") lacks entries for the
    users *georgia* or *secret*. What happened?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将这些哈希与在[示例 9-8](ch09.xhtml#dumping_password_hashes_in_meterpreter "示例 9-8.
    在 Meterpreter 中转储密码哈希")的活动 Meterpreter 会话中使用`hashdump`命令找到的哈希进行比较。（具有足够权限的 Meterpreter
    会话可以实时转储密码哈希，无需我们下载 SAM 和 SYSTEM 文件。）注意，在[示例 9-11](ch09.xhtml#using_samdump2_to_recover_windows_hashes
    "示例 9-11. 使用 Samdump2 恢复 Windows 哈希")中，我们的哈希列表没有用户*georgia*或*secret*的条目。发生了什么？
- en: When using the Zervit directory traversal, we weren’t able to access the main
    SAM file at *C:\Windows\System32\config* and instead downloaded a backup from
    *C:\Windows\repair\sam*. These users must have been created after the SAM file
    backup was created. We do have a password hash for the *Administrator* user, though.
    Though not complete or fully up-to-date, we may still be able to use cracked hashes
    from this backup SAM to log in to the systems.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Zervit 目录遍历时，我们无法访问位于*C:\Windows\System32\config*的主 SAM 文件，而是从*C:\Windows\repair\sam*下载了一个备份。这些用户一定是在
    SAM 文件备份创建之后才创建的。不过，我们确实拥有*Administrator*用户的密码哈希。尽管这个哈希不是完整的或完全最新的，我们仍然可以利用从这个备份的
    SAM 文件破解得到的哈希登录系统。
- en: Now let’s look at another way to access password hashes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下另一种访问密码哈希的方式。
- en: Dumping Password Hashes with Physical Access
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用物理访问转储密码哈希
- en: On some engagements, you’ll actually have physical access to user machines,
    with so-called physical attacks in scope. While having physical access may not
    appear very useful at first, you may be able to access the password hashes by
    restarting a system using a Linux Live CD to bypass security controls. (We’ll
    use a Kali ISO image, though other Linux Live CDs such as Helix or Ubuntu will
    work. We used a prebuilt Kali virtual machine in [Chapter 1](ch01.xhtml "Chapter 1. Setting
    Up Your Virtual Lab"). To get a standalone ISO of Kali, go to *[http://www.kali.org](http://www.kali.org)*.)
    When you boot a machine with a Live CD, you can mount the internal hard disk and
    gain access to all files, including the SAM and SYSTEM files. (When Windows boots,
    there are certain security controls in place to stop users from accessing the
    SAM file and dumping password hashes, but these aren’t active when the filesystem
    is loaded in Linux.)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些任务中，你实际上可以获得用户机器的物理访问权限，所谓的物理攻击也在范围内。虽然初看起来物理访问似乎并不是很有用，但你可能能够通过使用 Linux
    Live CD 重启系统来绕过安全控制，从而访问密码哈希。（我们将使用 Kali ISO 镜像，尽管其他 Linux Live CD 如 Helix 或 Ubuntu
    也可以工作。我们在[第 1 章](ch01.xhtml "第 1 章. 设置你的虚拟实验室")中使用了一个预构建的 Kali 虚拟机。要获取 Kali 的独立
    ISO 镜像，请访问*[http://www.kali.org](http://www.kali.org)*。）当你使用 Live CD 启动一台机器时，可以挂载内部硬盘并访问所有文件，包括
    SAM 和 SYSTEM 文件。（当 Windows 启动时，会有一些安全控制阻止用户访问 SAM 文件并转储密码哈希，但当文件系统在 Linux 中加载时，这些控制并不会生效。）
- en: Our Windows 7 virtual machine, with its solid external security posture, has
    been a bit neglected in these last few chapters. Let’s dump its hashes using a
    physical attack. First, we’ll point our virtual machine’s optical drive to a Kali
    ISO file, as shown in [Figure 9-1](ch09.xhtml#setting_our_windows_7_virtual_machine_to
    "Figure 9-1. Setting our Windows 7 virtual machine to boot from the Kali ISO file")
    (for VMware Fusion). In VMware Player, highlight your Windows 7 virtual machine,
    right-click it and choose **Settings**, then choose **CD/DVD (SATA)** and point
    to the ISO in the Use ISO Image field on the right side of the page.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Windows 7虚拟机，尽管在外部安全方面表现坚固，但在过去几章中有些被忽视。让我们通过物理攻击来获取其哈希值。首先，我们将虚拟机的光驱指向Kali
    ISO文件，如[图9-1](ch09.xhtml#setting_our_windows_7_virtual_machine_to "图9-1. 设置我们的Windows
    7虚拟机从Kali ISO文件启动")所示（适用于VMware Fusion）。在VMware Player中，选择你的Windows 7虚拟机，右键点击并选择**设置**，然后选择**CD/DVD
    (SATA)**，并在页面右侧的“使用ISO映像”字段中指向ISO文件。
- en: '![Setting our Windows 7 virtual machine to boot from the Kali ISO file](httpatomoreillycomsourcenostarchimages2030394.png.jpg)Figure 9-1. Setting
    our Windows 7 virtual machine to boot from the Kali ISO file'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![设置我们的Windows 7虚拟机从Kali ISO文件启动](httpatomoreillycomsourcenostarchimages2030394.png.jpg)图9-1.
    设置我们的Windows 7虚拟机从Kali ISO文件启动'
- en: By default, VMware will boot up the virtual machine so quickly that it will
    be difficult to change the BIOS settings to boot from the CD/DVD drive instead
    of the hard disk. To fix this, we’ll add a line to the VMware configuration file
    (*.vmx*) to delay the boot process at the BIOS screen for a few seconds.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，VMware启动虚拟机的速度非常快，以至于很难在BIOS设置中更改启动顺序，不能从CD/DVD驱动器启动，而是从硬盘启动。为了解决这个问题，我们将在VMware配置文件(*.vmx*)中添加一行，以在BIOS屏幕上延迟启动几秒钟。
- en: On your host machine, browse to where you saved your virtual machines. Then,
    in the folder for the Windows 7 target, find the *.vmx* configuration file, and
    open it in a text editor. The configuration file should look similar to [Example 9-12](ch09.xhtml#vmware_configuration_file_left_parenthes
    "Example 9-12. VMware configuration file (.vmx)").
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的主机上，浏览到你保存虚拟机的文件夹。然后，在Windows 7目标机的文件夹中，找到*.vmx*配置文件，并在文本编辑器中打开它。配置文件应该与[示例
    9-12](ch09.xhtml#vmware_configuration_file_left_parenthes "示例 9-12. VMware配置文件(.vmx)")类似。
- en: Example 9-12. VMware configuration file (.vmx)
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例 9-12. VMware配置文件(.vmx)
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Add the line **`bios.bootdelay = 3000`** anywhere in the file. This tells the
    virtual machine to delay booting for 3000 ms, or three seconds, enough time for
    us to change the boot options.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中任何地方添加行**`bios.bootdelay = 3000`**。这将告诉虚拟机在启动时延迟3000毫秒，或者三秒钟，足够的时间让我们更改启动选项。
- en: Save the *.vmx* file, and restart the Windows 7 target. Once you can access
    the BIOS, choose to boot from the CD drive. The virtual machine should start the
    Kali ISO. Even though we’re booted into Kali, we can mount the Windows hard disk
    and access files, bypassing the security features of the Windows operating system.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存*.vmx*文件，然后重启Windows 7目标机。一旦可以访问BIOS，选择从CD驱动器启动。虚拟机应当启动Kali ISO。尽管我们已经进入Kali系统，我们仍然可以挂载Windows硬盘并访问文件，从而绕过Windows操作系统的安全特性。
- en: '[Example 9-13](ch09.xhtml#dumping_windows_hashes_with_a_linux_live "Example 9-13. Dumping
    Windows hashes with a Linux Live CD") shows how to mount the file system and dump
    the password hashes.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-13](ch09.xhtml#dumping_windows_hashes_with_a_linux_live "示例 9-13. 使用Linux
    Live CD提取Windows哈希值")展示了如何挂载文件系统并提取密码哈希值。'
- en: Example 9-13. Dumping Windows hashes with a Linux Live CD
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-13. 使用Linux Live CD提取Windows哈希值
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We create a directory where we can mount our Windows filesystem with the `mkdir`
    command at ❶. Next, we use `mount` ❷ to mount the Windows filesystem (*/dev/sda1*)
    in the newly created directory (*/mnt/sda1*), which means that the target’s C
    drive is effectively at */mnt/sda1*. The SAM and SYSTEM files in Windows are in
    the *C:\Windows\System32\config* directory, so we change directories to */mnt/sda1/Windows/System32/config*
    to access these files using `cd` ❸, at which point we can use Samdump2 and Bkhive
    against the SAM and SYSTEM files without first saving these files and moving them
    to our Kali system.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在❶处使用`mkdir`命令创建一个目录，用于挂载Windows文件系统。接下来，我们使用`mount`❷将Windows文件系统（*/dev/sda1*）挂载到新创建的目录（*/mnt/sda1*）中，这意味着目标机的C盘实际上位于*/mnt/sda1*。Windows中的SAM和SYSTEM文件位于*C:\Windows\System32\config*目录中，因此我们使用`cd`命令切换到*/mnt/sda1/Windows/System32/config*目录来访问这些文件❸，此时我们可以使用Samdump2和Bkhive工具对SAM和SYSTEM文件进行操作，而无需先保存这些文件并将其移动到我们的Kali系统。
- en: Once again we’ve managed to get access to password hashes. We now have hashes
    for our Windows XP target, our Windows 7 target, our Linux target, and the FileZilla
    FTP server on the Windows XP target.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次成功获取了密码哈希。现在我们有了 Windows XP 目标、Windows 7 目标、Linux 目标以及 Windows XP 目标上的 FileZilla
    FTP 服务器的哈希值。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: In [Chapter 13](ch13.xhtml "Chapter 13. Post Exploitation"), we’ll explore some
    tricks for using password hashes to authenticate without the need for access to
    the plaintext passwords, but usually, in order to use these hashes, we’ll need
    to reverse the cryptographic hash algorithms and get the plaintext passwords.
    The difficulty of this depends on the password-hashing algorithm used as well
    as the strength of the password used.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 13 章](ch13.xhtml "第 13 章. 后期利用")中，我们将探讨一些使用密码哈希进行身份验证的技巧，而无需访问明文密码，但通常，要使用这些哈希，我们需要逆向密码哈希算法并获取明文密码。这一过程的难度取决于所使用的密码哈希算法以及密码的强度。
- en: LM vs. NTLM Hashing Algorithms
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LM 与 NTLM 哈希算法
- en: '[Example 9-14](ch09.xhtml#dumping_windows_hashes_with_a_li-id00026 "Example 9-14. Dumping
    Windows hashes with a Linux Live CD") compares the two password hash entries.
    The first one belongs to the *Administrator* account on Windows XP, which we found
    with `hashdump` in Meterpreter, and the second is Georgia Weidman’s account from
    Windows 7, which we found with physical access in the previous section.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-14](ch09.xhtml#dumping_windows_hashes_with_a_li-id00026 "示例 9-14. 使用
    Linux Live CD 导出 Windows 哈希值")对比了两个密码哈希条目。第一个属于 Windows XP 上的*Administrator*账户，这是我们通过
    Meterpreter 中的`hashdump`发现的，第二个是 Windows 7 上 Georgia Weidman 的账户，这是我们在上一节中通过物理访问发现的。'
- en: Example 9-14. Dumping Windows hashes with a Linux Live CD
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-14. 使用 Linux Live CD 导出 Windows 哈希值
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first field in the hashes is the username ❶; the second is the user ID ❷;
    the third is the password hash in LAN Manager (LM) format ❸; and the fourth is
    the NT LAN Manager (NTLM) hash ❹. LM Hash was the primary way to hash passwords
    on Microsoft Windows up to Windows NT, but it’s a cryptographically unsound method
    that makes it possible to discover the correct plaintext password for an LM hash,
    regardless of a password’s length and complexity. Microsoft introduced NTLM hashing
    to replace LM hash, but on Windows XP, passwords are stored in both LM and NTLM
    formats by default. (Windows 7 opts exclusively for the more secure NTLM hash.)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希中的第一个字段是用户名❶；第二个是用户 ID ❷；第三个是 LAN Manager (LM) 格式的密码哈希 ❸；第四个是 NT LAN Manager
    (NTLM) 哈希 ❹。LM 哈希是直到 Windows NT 之前在 Microsoft Windows 上用于哈希密码的主要方式，但它是一种密码学上不安全的方法，使得无论密码的长度和复杂性如何，都能发现
    LM 哈希的正确明文密码。Microsoft 引入了 NTLM 哈希来替代 LM 哈希，但在 Windows XP 中，密码默认以 LM 和 NTLM 格式存储。（Windows
    7 仅使用更安全的 NTLM 哈希。）
- en: In the hashes in [Example 9-14](ch09.xhtml#dumping_windows_hashes_with_a_li-id00026
    "Example 9-14. Dumping Windows hashes with a Linux Live CD"), because both passwords
    are the string *password*, the NTLM hash entries for each account are identical,
    but the LM hash fields are different. The first entry has the value `e52cac67419a9a224a3b108f3fa6cb6d`,
    whereas the Windows 7 entry has `aad3b435b51404eeaad3b435b51404ee`, which is LM
    hash-speak for empty. The inclusion of the LM hash entry will make cracking the
    hashes much simpler. In fact, any LM-hashed password can be brute-forced in minutes
    to hours. In contrast, our ability to crack the NTLM hashes will depend on both
    our ability to guess and the length and complexity of the password. If the hashing
    function is cryptographically sound, it could take years, decades, or more than
    your lifetime to try every possible password.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 9-14](ch09.xhtml#dumping_windows_hashes_with_a_li-id00026 "示例 9-14. 使用
    Linux Live CD 导出 Windows 哈希值")中的哈希值中，由于两个密码都是字符串*password*，每个账户的 NTLM 哈希条目是相同的，但
    LM 哈希字段不同。第一个条目的值是`e52cac67419a9a224a3b108f3fa6cb6d`，而 Windows 7 条目的值是`aad3b435b51404eeaad3b435b51404ee`，这在
    LM 哈希中表示为空。包含 LM 哈希条目将使破解哈希变得更加简单。事实上，任何 LM 哈希的密码都可以在几分钟到几个小时内进行暴力破解。相对而言，我们破解
    NTLM 哈希的能力将取决于我们猜测的能力以及密码的长度和复杂性。如果哈希函数在密码学上是安全的，破解每个可能的密码可能需要数年、数十年，甚至超过你的一生。
- en: The Trouble with LM Password Hashes
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LM 密码哈希的问题
- en: When you see LM hashes on a pentest, you can be sure that the plaintext password
    is recoverable from the password hash. However, one-way hash functions can’t be
    reversed. Complex math is used to develop algorithms that make it impossible to
    discover the original plaintext password value that was hashed, given the password
    hash. But we *can* run a plaintext password guess through the cryptographic hashing
    function and compare the results to the hash we’re trying to crack; if they’re
    the same, we’ve found the correct password.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在渗透测试中看到LM哈希时，你可以确定从密码哈希中恢复出明文密码是可能的。然而，单向哈希函数是不可逆的。复杂的数学方法用于开发算法，使得无法根据密码哈希发现被哈希的原始明文密码。但是我们*可以*通过密码明文猜测并运行加密哈希函数，然后将结果与我们尝试破解的哈希值进行比较；如果它们相同，我们就找到了正确的密码。
- en: 'The following issues contribute to the insecurity of LM hashes:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题导致了LM哈希的不安全性：
- en: Passwords are truncated at 14 characters.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码会被截断为14个字符。
- en: Passwords are converted to all uppercase.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码会被转换为全大写字母。
- en: Passwords of fewer than 14 characters are null-padded to 14 characters.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 少于14个字符的密码会用零填充至14个字符。
- en: The 14-character password is broken into two seven-character passwords that
    are hashed separately.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 14个字符的密码会被分成两个七个字符的密码单独进行哈希处理。
- en: 'Why are these characteristics so significant? Say we start with a complex,
    strong password like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这些特征如此重要？假设我们从一个复杂且强大的密码开始，比如这样：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This password has 15 characters from four classes, including lowercase letters,
    uppercase letters, numbers, and symbols, and it’s not based on a dictionary word.
    However, in the LM hash algorithm, the password is truncated to 14 characters
    like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个密码由四个类别的15个字符组成，包括小写字母、大写字母、数字和符号，并且它不是基于字典中的单词。然而，在LM哈希算法中，密码会被截断为14个字符，如下所示：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then the lowercase letters are changed to uppercase:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后小写字母会被转换为大写字母：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, the password is split into two seven-character parts. The two parts are
    then used as keys to encrypt the static string `KGS!@#$%` using the Data Encryption
    Standard (DES) encryption algorithm:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，密码被分成两个七个字符的部分。然后这两个部分作为密钥，使用数据加密标准（DES）加密算法加密静态字符串`KGS!@#$%`：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The resulting eight-character ciphertexts from the encryption are then concatenated
    to make the LM hash.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 加密得到的八个字符的密文会被连接在一起，形成LM哈希。
- en: To crack an LM hash, we just need to find seven characters, all uppercase, with
    perhaps some numbers and symbols. Modern computing hardware can try every possible
    one- to seven-character combination, encrypt the string `KGS!@#$%`, and compare
    the resulting hash to a given value in a matter of minutes to hours.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要破解一个LM哈希，我们只需要找到七个字符，全部为大写字母，可能还会包含一些数字和符号。现代计算硬件可以在几分钟到几小时内尝试每一种可能的1到7个字符的组合，使用`KGS!@#$%`进行加密，并将得到的哈希值与给定值进行比较。
- en: John the Ripper
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: John the Ripper
- en: One of the more popular tools for cracking passwords is John the Ripper. The
    default mode for John the Ripper is brute forcing. Because the set of possible
    plaintext passwords in LM hash is so limited, brute forcing is a viable method
    for cracking any LM hash in a reasonable amount of time, even with our Kali virtual
    machine, which has limited CPU power and memory.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: John the Ripper是破解密码的流行工具之一。John the Ripper的默认模式是暴力破解。由于LM哈希中的可能明文密码集合非常有限，暴力破解在合理时间内是破解任何LM哈希的可行方法，即使是在我们的Kali虚拟机上，它的CPU性能和内存有限。
- en: For example, if we save the Windows XP hashes we gathered earlier in this chapter
    to a file called *xphashes.txt*, then feed them to John the Ripper like this,
    we find that John the Ripper can run through the entire set of possible passwords
    and come up with the correct answer, as shown in [Example 9-15](ch09.xhtml#cracking_lm_hashes_with_john_the_ripper
    "Example 9-15. Cracking LM hashes with John the Ripper").
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们将本章前面收集到的Windows XP哈希保存到名为*xphashes.txt*的文件中，然后将它们提供给John the Ripper进行处理，我们会发现John
    the Ripper可以运行所有可能的密码组合，并得出正确的答案，如[示例9-15](ch09.xhtml#cracking_lm_hashes_with_john_the_ripper
    "示例9-15. 使用John the Ripper破解LM哈希")所示。
- en: Example 9-15. Cracking LM hashes with John the Ripper
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 示例9-15. 使用John the Ripper破解LM哈希
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: John the Ripper cracks the seven-character password hashes. In [Example 9-15](ch09.xhtml#cracking_lm_hashes_with_john_the_ripper
    "Example 9-15. Cracking LM hashes with John the Ripper"), we see that *PASSWOR*
    is the first half of the user *secret*’s password. Likewise, it’s the first half
    of the password for *georgia* and *Administrator*. The second half of *secret*’s
    password is *D123*, and *georgia* and *Administrator*’s are *D*. Thus, the complete
    plaintext of the LM-hashed passwords are *PASSWORD* for *georgia* and *Administrator*
    and *PASSWORD123* for *secret*. The LM hash doesn’t tell us the correct case for
    a password, and if you try logging in to the Windows XP machine as *Administrator*
    or *georgia* with the password *PASSWORD* or the account *secret* with *PASSWORD123*,
    you will get a login error because LM hash does not take into account the correct
    case of the letters in the password.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: John the Ripper 破解七字符密码哈希值。在[示例 9-15](ch09.xhtml#cracking_lm_hashes_with_john_the_ripper
    "示例 9-15. 使用 John the Ripper 破解 LM 哈希")中，我们看到*PASSWOR*是用户*secret*密码的前半部分。同样，*georgia*和*Administrator*的密码前半部分也是*PASSWOR*。*secret*密码的后半部分是*D123*，而*georgia*和*Administrator*的密码后半部分是*D*。因此，LM
    哈希密码的完整明文分别是*georgia*和*Administrator*的*PASSWORD*，以及*secret*的*PASSWORD123*。LM 哈希无法告诉我们密码的正确大小写，如果你尝试以*Administrator*或*georgia*的身份用密码*PASSWORD*登录，或者以*secret*的身份用*PASSWORD123*登录
    Windows XP 机器，你将遇到登录错误，因为 LM 哈希没有考虑密码中字母的正确大小写。
- en: To find out the correct case of the password, we need to look at the fourth
    field of the NTLM hash. John the Ripper noted in the example in [Example 9-15](ch09.xhtml#cracking_lm_hashes_with_john_the_ripper
    "Example 9-15. Cracking LM hashes with John the Ripper") that NTLM hashes were
    also present, and you can use the flag `--format=nt` to force John the Ripper
    to use those hashes (we don’t have LM hashes for Windows 7, so we will have to
    crack Windows 7 passwords with a wordlist since brute forcing the NTLM hashes
    would likely take too long).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出密码的正确大小写，我们需要查看 NTLM 哈希的第四个字段。在[示例 9-15](ch09.xhtml#cracking_lm_hashes_with_john_the_ripper
    "示例 9-15. 使用 John the Ripper 破解 LM 哈希")中的示例中，John the Ripper 提到 NTLM 哈希也存在，你可以使用标志`--format=nt`强制
    John the Ripper 使用这些哈希（由于 Windows 7 没有 LM 哈希，因此我们必须使用字典列表来破解 Windows 7 密码，因为暴力破解
    NTLM 哈希可能会花费太长时间）。
- en: Cracking Windows NTLM hashes is nowhere near as easy as cracking LM ones. Although
    a five-character NTLM password that uses only lowercase letters and no other complexity
    could be brute-forced as quickly as an LM hash, a 30-character NTLM password with
    lots of complexity could take many years to crack. Trying every possible character
    combination of any length, hashing it, and comparing it to a value could go on
    forever until we happened to stumble upon the correct value (only to find out
    that the user has since changed his or her password).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 破解 Windows NTLM 哈希远没有破解 LM 哈希那么容易。虽然一个仅使用小写字母且没有其他复杂性的五字符 NTLM 密码可以像破解 LM 哈希一样快速通过暴力破解，但一个具有大量复杂性的
    30 字符 NTLM 密码可能需要许多年才能破解。尝试每个可能的字符组合，不论长度，进行哈希计算并与某个值进行比较，可能会一直持续下去，直到我们偶然找到正确的值（结果发现用户已经更改了密码）。
- en: Instead of attempting to brute-force passwords, we can use wordlists containing
    known passwords, common passwords, dictionary words, combinations of dictionary
    words padded with numbers and symbols at the end, and so on. (We’ll see an example
    of using a wordlist with John the Ripper in [Cracking Linux Passwords](ch09.xhtml#cracking_linux_passwords
    "Cracking Linux Passwords")).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与其尝试暴力破解密码，不如使用包含已知密码、常见密码、字典词、加上数字和符号的字典词组合等内容的字典列表。（我们将在[破解 Linux 密码](ch09.xhtml#cracking_linux_passwords
    "破解 Linux 密码")中看到使用字典列表与 John the Ripper 的例子）。
- en: A Real-World Example
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个真实世界的例子
- en: 'Legacy password hashing once made all the difference on one of my pentests.
    The domain controller was Windows Server 2008, with a strong security posture.
    The workstations throughout the enterprise were reasonably secure, too, having
    recently been upgraded to fully patched Windows 7 systems. There was, however,
    one promising light in the dark: a Windows 2000 box that was missing several security
    patches. I was able to quickly gain system privileges on the machine using Metasploit.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的密码哈希算法曾在我的一次渗透测试中起到了决定性作用。域控制器是 Windows Server 2008，具有强大的安全性。企业中的工作站也相当安全，最近已升级为完全补丁的
    Windows 7 系统。然而，黑暗中的一线希望是：一台缺少多个安全补丁的 Windows 2000 计算机。我利用 Metasploit 很快获得了该机器的系统权限。
- en: The trouble was that, while on paper, the penetration test was now a success,
    compromising the machine had gained me next to nothing. The system contained no
    sensitive files, and it was the only machine on this particular network, isolated
    from the new, updated Windows domain. It had all the trappings of a domain controller,
    except it had no clients. All of the other machines in the environment were members
    of the new Windows 2008 domain controller’s domain. Though technically I was now
    a domain administrator, I was no further along on the pentest than I was before
    I found the Windows 2000 machine.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，虽然从表面上看，渗透测试已经成功，但攻破机器并没有让我获得多少信息。该系统没有敏感文件，而且它是该特定网络中的唯一一台机器，且与新的、更新的Windows域相隔离。它具备所有域控制器的特征，除了没有客户端。环境中的其他所有机器都是新Windows
    2008域控制器域的成员。虽然从技术上讲，我现在是域管理员，但在渗透测试中，我并没有比发现Windows 2000机器之前更进一步。
- en: Since this was the domain controller, the domain user password hashes were included
    locally. Windows 2000, like Windows XP, stored the LM hashes of passwords. The
    client’s old domain administrator password was strong; it had about 14 characters;
    included uppercase letters, lowercase letters, numbers, and symbols; and was not
    based on a dictionary word. Fortunately, because it was LM hashed, I was able
    to get the password back in a matter of minutes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是域控制器，域用户的密码哈希是本地存储的。Windows 2000像Windows XP一样，存储了密码的LM哈希。客户端的旧域管理员密码很强，约有14个字符，包含大写字母、小写字母、数字和符号，并且不基于字典单词。幸运的是，由于它是LM哈希的，我能够在几分钟内找回密码。
- en: What do you think the domain administrator’s password was on the new domain?
    You guessed it. It was the same as the domain administrator’s password on the
    old domain. The Windows 2000 box had not been used in over six months, but it
    was still running, and it used an insecure hashing algorithm. Also, the client
    wasn’t changing their passwords regularly. These two things combined to bring
    down what was otherwise a strong security posture. I was able to access every
    system in the environment just by logging in with the domain administrator password
    I found on the compromised Windows 2000 system.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你猜新域的域管理员密码是什么？没错，跟旧域的域管理员密码一样。虽然Windows 2000机器已经有六个月没有使用，但它依然在运行，并且使用了不安全的哈希算法。而且，客户没有定期更换密码。这两件事加起来破坏了原本强大的安全性。我仅凭在被攻破的Windows
    2000系统上找到的域管理员密码，就能够访问环境中的所有系统。
- en: Cracking Linux Passwords
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 破解Linux密码
- en: We can also use John the Ripper against the Linux password hashes we dumped
    after exploiting the Vsftpd server backdoor in [Chapter 8](ch08.xhtml "Chapter 8. Exploitation"),
    as shown in [Example 9-16](ch09.xhtml#cracking_linux_hashes_with_john_the_ripp
    "Example 9-16. Cracking Linux hashes with John the Ripper").
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用John the Ripper来破解我们在[第8章](ch08.xhtml "第8章：利用")中，通过利用Vsftpd服务器后门提取的Linux密码哈希，正如[示例9-16](ch09.xhtml#cracking_linux_hashes_with_john_the_ripp
    "示例9-16. 使用John the Ripper破解Linux哈希")所示。
- en: Example 9-16. Cracking Linux hashes with John the Ripper
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 示例9-16. 使用John the Ripper破解Linux哈希
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: User *georgia* has an MD5 hash (we can tell from the `$1$` at the beginning
    of the password hash). MD5 can’t be brute-forced in a reasonable amount of time.
    Instead, we use a wordlist with the `--wordlist` option in John the Ripper. John
    the Ripper’s success at cracking the password depends on the inclusion of the
    correct password in our wordlist.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 用户*georgia*的密码是MD5哈希（我们可以从密码哈希开头的`$1$`判断）。MD5无法在合理的时间内进行暴力破解。相反，我们可以使用John the
    Ripper的`--wordlist`选项，并利用词典进行破解。John the Ripper成功破解密码的关键在于我们的词典中包含了正确的密码。
- en: Mangling Wordlists with John the Ripper
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用John the Ripper破解密码词典
- en: When required by a password policy to include a number and/or a symbol in a
    password, many users will just tack them on to the end of a dictionary word. Using
    John the Ripper’s rules functionality, we can catch this and other common mutations
    that may slip by a simple wordlist. Open the John the Ripper configuration file
    at */etc/john/john.conf* in an editor and search for *List.Rules:Wordlist*. Beneath
    this heading, you can add mangling rules for the wordlist. For example, the rule
    `$[0-9]$[0-9]$[0-9]` will add three numbers to the end of each word in the wordlist.
    You can enable rules in John the Ripper by using the flag `--rules` at the command
    line. More information on writing your own rules can be found at *[http://www.openwall.com/john/doc/RULES.shtml](http://www.openwall.com/john/doc/RULES.shtml)*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当密码策略要求密码中包含数字和/或符号时，许多用户只是将它们添加到字典单词的末尾。通过使用John the Ripper的规则功能，我们可以捕捉到这种以及其他常见的变种，这些变种可能会绕过简单的字典列表。打开John
    the Ripper配置文件*/etc/john/john.conf*，在编辑器中查找*List.Rules:Wordlist*。在这个标题下，你可以为字典列表添加变形规则。例如，规则`$[0-9]$[0-9]$[0-9]`会在字典列表中的每个单词末尾添加三个数字。你可以通过在命令行使用`--rules`标志来启用John
    the Ripper中的规则。关于编写自定义规则的更多信息，请访问*[http://www.openwall.com/john/doc/RULES.shtml](http://www.openwall.com/john/doc/RULES.shtml)*。
- en: Cracking Configuration File Passwords
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 破解配置文件密码
- en: Finally, let’s try to crack the MD5 hashed passwords we found in the FileZilla
    FTP server configuration file we downloaded with the Zervit 0.4 file inclusion
    vulnerability. As you’ll see, sometimes we don’t even need to crack a password
    hash. For example, try entering the hash for the user *georgia*, *5f4dcc3b5aa765d61d8327deb882cf99*,
    into a search engine. The first few hits confirm that *georgia*’s password is
    *password*. Additionally, searching tells us that the account *newuser* is created
    when a FileZilla FTP server is installed with the password *wampp*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们尝试破解我们在通过Zervit 0.4文件包含漏洞下载的FileZilla FTP服务器配置文件中找到的MD5哈希密码。正如你所看到的，有时候我们甚至不需要破解密码哈希。例如，尝试将用户*georgia*的哈希值*5f4dcc3b5aa765d61d8327deb882cf99*输入到搜索引擎中。前几条结果确认*georgia*的密码是*password*。此外，搜索还告诉我们，当安装FileZilla
    FTP服务器时，账户*newuser*会被创建，密码为*wampp*。
- en: Now try logging in to the Windows XP target’s FTP server with these credentials.
    Sure enough, login is successful. The administrator of this system forgot to change
    the default password for the built-in FTP account. If we were not able to recover
    the plaintext passwords this easily, we could again use John the Ripper with a
    wordlist, as discussed previously.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用这些凭证登录Windows XP目标的FTP服务器。果然，登录成功了。该系统的管理员忘记更改内置FTP账户的默认密码。如果我们无法如此轻松地恢复明文密码，我们可以再次使用John
    the Ripper配合字典列表，如前所述。
- en: Rainbow Tables
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 彩虹表
- en: Rather than taking a wordlist, hashing each entry with the relevant algorithm,
    and comparing the resulting hash to the value to be cracked, we can speed up this
    process considerably by having our wordlist prehashed. This, of course, will take
    storage space—more with longer hash lists, and approaching infinity as we try
    to store every possible password hash value for brute forcing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用字典列表、对每个条目应用相关算法进行哈希，然后将结果哈希与待破解的值进行比较，我们可以通过预先哈希字典列表来显著加速这个过程。当然，这需要一定的存储空间——随着哈希列表变长，所需存储空间也会增大，当我们尝试存储所有可能的密码哈希值进行暴力破解时，这个空间将接近无限。
- en: A set of precomputed hashes is known as a *rainbow table*. Rainbow tables typically
    hold every possible hash entry for a given algorithm up to a certain length with
    a limited character set. For example, you may have a rainbow table for MD5 hashes
    that contains all entries that are all lowercase letters and numbers with lengths
    between one and nine. This table is about 80 GB—not so bad with today’s price
    of storage, but keep in mind this is only a very limited amount of the possible
    keyspace for MD5.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一组预计算的哈希值被称为*彩虹表*。彩虹表通常包含给定算法所有可能的哈希条目，直到某个特定长度，并且字符集是有限的。例如，你可能有一个针对MD5哈希的彩虹表，包含所有由小写字母和数字组成、长度介于1到9之间的条目。这个表大约为80GB——在今天存储价格的情况下不算太糟糕，但请记住，这仅仅是MD5可能的密钥空间中的一小部分。
- en: Given its limited keyspace (discussed previously), an LM hash appears to be
    an ideal candidate for using rainbow tables. A full set of LM hash rainbow tables
    is about 32 GB.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于其有限的密钥空间（前面讨论过），LM哈希看起来是使用彩虹表的理想候选。完整的LM哈希彩虹表大约为32GB。
- en: You can download pregenerated sets of hashes from *[http://project-rainbowcrack.com/table.htm](http://project-rainbowcrack.com/table.htm)*.
    The tool Rcrack in Kali can be used to sift through the rainbow tables for the
    correct plaintext.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 *[http://project-rainbowcrack.com/table.htm](http://project-rainbowcrack.com/table.htm)*
    下载预生成的哈希集。Kali中的工具Rcrack可以用来从彩虹表中筛选出正确的明文密码。
- en: Online Password-Cracking Services
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在线密码破解服务
- en: The current hip thing to do in IT is to move things to the cloud, and password
    cracking is no different. By leveraging multiple high-spec machines, you can get
    faster, more comprehensive results than you could with just a virtual machine
    on your laptop. You can, of course, set up up your own high-powered machines in
    the cloud, create your own wordlists, and so on, but there are also online services
    that will take care of this for you for a fee. For example, *[https://www.cloudcracker.com/](https://www.cloudcracker.com/)*
    can crack NTLM Windows hashes, SHA-512 for Linux, WPA2 handshakes for wireless,
    and more. You simply upload your password hash file, and the cracker does the
    rest.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在IT领域流行的做法是将数据迁移到云端，密码破解也不例外。通过利用多台高性能机器，你可以获得比仅在笔记本虚拟机上操作更快、更全面的结果。当然，你可以在云端设置自己的高性能机器，创建自己的字典等，但也有一些在线服务可以为你处理这些工作，前提是你支付费用。例如，*
    [https://www.cloudcracker.com/](https://www.cloudcracker.com/) * 可以破解NTLM Windows哈希、Linux的SHA-512、无线网络的WPA2握手等。你只需要上传密码哈希文件，破解程序会完成其余的工作。
- en: Dumping Plaintext Passwords from Memory with Windows Credential Editor
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Windows凭证编辑器从内存中提取明文密码
- en: Why bother cracking password hashes if we can get access to plaintext passwords?
    If we have access to a Windows system, in some cases we can pull plaintext passwords
    directly from memory. One tool with this functionality is the Windows Credential
    Editor (WCE). We can upload this tool to an exploited target system, and it will
    pull plaintext passwords from the Local Security Authority Subsystem Service (LSASS)
    process in charge of enforcing the system’s security policy. You can download
    the latest version of WCE from *[http://www.ampliasecurity.com/research/wcefaq.html](http://www.ampliasecurity.com/research/wcefaq.html)*.
    An example of running WCE is shown in [Example 9-17](ch09.xhtml#running_wce "Example 9-17. Running
    WCE").
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以直接获取明文密码，为什么还要去破解密码哈希呢？如果我们能够访问Windows系统，在某些情况下，我们可以直接从内存中提取明文密码。具有此功能的一个工具是Windows凭证编辑器（WCE）。我们可以将这个工具上传到被利用的目标系统，它会从负责强制执行系统安全策略的本地安全机构子系统服务（LSASS）进程中提取明文密码。你可以从
    *[http://www.ampliasecurity.com/research/wcefaq.html](http://www.ampliasecurity.com/research/wcefaq.html)*
    下载WCE的最新版本。运行WCE的示例见[示例 9-17](ch09.xhtml#running_wce "示例 9-17. 运行WCE")。
- en: Example 9-17. Running WCE
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-17. 运行WCE
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here WCE found the plaintext of the user *georgia*’s password. The downside
    to this attack is that it requires a logged-in user for the password to be stored
    in memory. Even if you were able to get a plaintext password or two with this
    method, it is still worth dumping and attempting to crack any password hashes
    you can access.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，WCE找到了用户*georgia*的明文密码。这个攻击的缺点是，它需要有一个已登录的用户，才能在内存中存储密码。即使你能够通过这种方法获取一个或两个明文密码，仍然值得提取并尝试破解你能访问的任何密码哈希。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Reversing password hashes is an exciting field, and as the speed of hardware
    increases, it becomes possible to crack stronger hashes faster. Using multiple
    CPUs and even the graphics processing units (GPUs) on video cards, password crackers
    can try many hashes very quickly. Our virtual machines don’t have much processing
    power, but even your average modern laptop is much faster than the machines that
    were used for password cracking just a few short years ago. The cutting edge of
    password cracking these days is taking to the cloud and harnessing multiple top-spec
    cloud servers for cracking. You’ll even find some cloud-based password-cracking
    services.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 反向破解密码哈希是一个令人兴奋的领域，随着硬件速度的提升，破解更强的哈希也变得越来越快速。使用多个CPU，甚至显卡上的图形处理单元（GPU），密码破解工具可以非常快速地尝试大量哈希。我们的虚拟机处理能力有限，但即便是你普通的现代笔记本电脑，也比几年前用于密码破解的机器快得多。如今，密码破解的前沿技术是利用云端，并借助多个顶级配置的云服务器进行破解。你甚至可以找到一些基于云的密码破解服务。
- en: As you’ve seen in this chapter, using information gathered from successful exploits
    in [Chapter 8](ch08.xhtml "Chapter 8. Exploitation"), we’ve managed to reverse
    password hashes to recover plaintext passwords for some services and the systems
    themselves. Having managed to get a foothold on the systems, let’s look at some
    advanced attack methods that can help us if we can’t find anything vulnerable
    when listening on the network. We still have the Windows 7 machine to exploit,
    after all.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章所示，利用在[第8章](ch08.xhtml "第8章. 利用")中收集到的成功攻击案例信息，我们已成功逆向密码哈希，恢复出一些服务和系统本身的明文密码。在成功入侵系统后，让我们来看看一些先进的攻击方法，这些方法可以在我们监听网络时找不到任何漏洞的情况下提供帮助。毕竟，我们还有一台Windows
    7机器可以利用。
