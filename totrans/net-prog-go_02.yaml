- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: An Overview of Networked Systems
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络系统概述
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In the digital age, an increasing number of devices communicate over computer
    networks. A *computer network* is a connection between two or more devices, or
    *nodes*, that allows each node to share data. These connections aren’t inherently
    reliable or secure. Thankfully, Go’s standard library and its rich ecosystem are
    well suited for writing secure, reliable network applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字时代，越来越多的设备通过计算机网络进行通信。*计算机网络*是两个或更多设备（或*节点*）之间的连接，使每个节点能够共享数据。这些连接本身并不可靠或安全。幸运的是，Go
    的标准库及其丰富的生态系统非常适合编写安全、可靠的网络应用程序。
- en: This chapter will give you the foundational knowledge needed for this book’s
    exercises. You’ll learn about the structure of networks and how networks use protocols
    to communicate.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为你提供本书练习所需的基础知识。你将学习网络的结构以及网络如何使用协议进行通信。
- en: Choosing a Network Topology
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择网络拓扑
- en: 'The organization of nodes in a network is called its *topology.* A network’s
    topology can be as simple as a single connection between two nodes or as complex
    as a layout of nodes that don’t share a direct connection but are nonetheless
    able to exchange data. That’s generally the case for connections between your
    computer and nodes on the internet. Topology types fall into six basic categories:
    point-to-point, daisy chain, bus, ring, star, and mesh.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中节点的组织结构被称为其*拓扑*。网络的拓扑可以简单到两个节点之间的单一连接，也可以复杂到节点之间没有直接连接但仍能交换数据的布局。通常，这种情况适用于你计算机与互联网节点之间的连接。拓扑类型分为六大类：点对点、菊花链、总线、环形、星形和网状。
- en: In the simplest network, *point-to-point*, two nodes share a single connection
    ([Figure 1-1](#figure1-1)). This type of network connection is uncommon, though
    it is useful when direct communication is required between two nodes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的网络中，*点对点*，两个节点共享一个连接（[图 1-1](#figure1-1)）。这种类型的网络连接并不常见，但在需要两个节点之间直接通信时非常有用。
- en: '![f01001](image_fi/500884c01/f01001.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![f01001](image_fi/500884c01/f01001.png)'
- en: 'Figure 1-1: A direct connection between two nodes'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-1：两个节点之间的直接连接
- en: A series of point-to-point connections creates a *daisy chain*. In the daisy
    chain in [Figure 1-2](#figure1-2), traffic from node C, destined for node F, must
    traverse nodes D and E. Intermediate nodes between an origin node and a destination
    node are commonly known as *hops*. You are unlikely to encounter this topology
    in a modern network.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列点对点连接形成了*菊花链*。在 [图 1-2](#figure1-2) 中的菊花链中，来自节点 C 的流量如果要传递到节点 F，必须经过节点 D
    和 E。源节点和目标节点之间的中间节点通常称为*跳点*。在现代网络中，你不太可能遇到这种拓扑结构。
- en: '![f01002](image_fi/500884c01/f01002.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![f01002](image_fi/500884c01/f01002.png)'
- en: 'Figure 1-2: Point-to-point segments joined in a daisy chain'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-2：通过菊花链连接的点对点段
- en: '*Bus* topology nodes share a common network link. Wired bus networks aren’t
    common, but this type of topology drives wireless networks. The nodes on a wired
    network see all the traffic and selectively ignore or accept it, depending on
    whether the traffic is intended for them. When node H sends traffic to node L
    in the bus diagram in [Figure 1-3](#figure1-3), nodes I, J, K, and M receive the
    traffic but ignore it. Only node L accepts the data because it’s the intended
    recipient. Although wireless clients can see each other’s traffic, traffic is
    usually encrypted.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*总线*拓扑节点共享一个公共的网络链接。虽然有线总线网络不常见，但这种拓扑类型驱动了无线网络。处于有线网络中的节点可以看到所有的流量，并根据流量是否为它们所接收的内容，选择性地忽略或接受流量。当节点
    H 在总线图 [图 1-3](#figure1-3) 中向节点 L 发送流量时，节点 I、J、K 和 M 会接收到流量，但会忽略它。只有节点 L 会接受数据，因为它是预定的接收方。尽管无线客户端可以看到彼此的流量，但流量通常是加密的。'
- en: '![f01003](image_fi/500884c01/f01003.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![f01003](image_fi/500884c01/f01003.png)'
- en: 'Figure 1-3: Nodes connected in a bus topology'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-3：总线拓扑中连接的节点
- en: A *ring* topology, which was used in some fiber-optic network deployments, is
    a closed loop in which data travels in a single direction. In [Figure 1-4](#figure1-4),
    for example, node N could send a message destined for node R by way of nodes O,
    P, and Q. Nodes O, P, and Q retransmit the message until it reaches node R. If
    node P fails to retransmit the message, it will never reach its destination. Because
    of this design, the slowest node can limit the speed at which data travels. Assuming
    traffic travels clockwise and node Q is the slowest, node Q slows traffic sent
    from node O to node N. However, traffic sent from node N to node O is not limited
    by node Q’s slow speed since that traffic does not traverse node Q.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*环形*拓扑曾在一些光纤网络部署中使用，它是一个封闭的环路，其中数据朝一个方向流动。例如，在[图1-4](#figure1-4)中，节点N可以通过节点O、P和Q将信息发送到目标节点R。节点O、P和Q会转发信息，直到它到达节点R。如果节点P未能转发信息，它将永远无法到达目标。由于这种设计，最慢的节点会限制数据传输的速度。假设流量是顺时针流动的，而节点Q是最慢的，节点Q会减缓从节点O到节点N的数据流量。然而，从节点N到节点O的流量不受节点Q的慢速影响，因为这些流量并不经过节点Q。'
- en: '![f01004](image_fi/500884c01/f01004.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![f01004](image_fi/500884c01/f01004.png)'
- en: 'Figure 1-4: Nodes arranged in a ring, with traffic traveling in a single direction'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-4：按环形排列的节点，数据朝一个方向流动
- en: In a *star* topology, a central node has individual point-to-point connections
    to all other nodes. You will likely encounter this network topology in wired networks.
    The central node, as shown in [Figure 1-5](#figure1-5), is often a *network switch*,
    which is a device that accepts data from the origin nodes and retransmits data
    to the destination nodes, like a postal service. Adding nodes is a simple matter
    of connecting them to the switch. Data can traverse only a single hop within this
    topology.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在*星型*拓扑中，一个中央节点与所有其他节点建立了单独的点对点连接。你可能会在有线网络中遇到这种拓扑。中央节点，如[图1-5](#figure1-5)所示，通常是一个*网络交换机*，它接收来自源节点的数据，并将数据重新传输到目标节点，类似于邮政服务。增加节点只需将它们连接到交换机。数据在这种拓扑中只能进行一次跳跃。
- en: '![f01005](image_fi/500884c01/f01005.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![f01005](image_fi/500884c01/f01005.png)'
- en: 'Figure 1-5: Nodes connected to a central node, which handles traffic between
    nodes'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-5：与中央节点连接的节点，中央节点处理节点间的流量
- en: Every node in a fully connected *mesh* network has a direct connection to every
    other node ([Figure 1-6](#figure1-6)). This topology eliminates single points
    of failure because the failure of a single node doesn’t affect traffic between
    any other nodes on the network. On the other hand, costs and complexity increase
    as the number of nodes increases, making this topology untenable for large-scale
    networks. This is another topology you may encounter only in larger wireless networks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个完全连接的*网状*网络中的节点都与其他所有节点直接连接（[图1-6](#figure1-6)）。这种拓扑消除了单点故障的风险，因为单个节点的故障不会影响网络中其他节点之间的流量。另一方面，随着节点数量的增加，成本和复杂性也会增加，使得这种拓扑在大规模网络中不可行。这是另一种你可能只在较大无线网络中遇到的拓扑。
- en: '![f01006](image_fi/500884c01/f01006.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![f01006](image_fi/500884c01/f01006.png)'
- en: 'Figure 1-6: Interconnected nodes in a mesh network'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-6：网状网络中相互连接的节点
- en: You can also create a hybrid network topology by combining two or more basic
    topologies. Real-world networks are rarely composed of just one network topology.
    Rather, you are likely to encounter hybrid topologies. [Figure 1-7](#figure1-7)
    shows two examples. The *star-ring* hybrid network is a series of ring networks
    connected to a central node. The *star-bus* hybrid network is a hierarchical topology
    formed by the combination of bus and star network topologies.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过将两种或更多基本拓扑结合起来创建混合网络拓扑。现实中的网络很少只由一种拓扑组成。相反，你很可能会遇到混合拓扑。[图1-7](#figure1-7)展示了两个例子。*星型环形*混合网络是多个环形网络与一个中央节点相连。*星型总线*混合网络是通过结合总线和星型网络拓扑形成的分层拓扑。
- en: '![f01007](image_fi/500884c01/f01007.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![f01007](image_fi/500884c01/f01007.png)'
- en: 'Figure 1-7: The star-ring and star-bus hybrid topologies'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-7：星型环形与星型总线混合拓扑
- en: Hybrid topologies are meant to improve reliability, scalability, and flexibility
    by taking advantage of each topology’s strengths and by limiting the disadvantages
    of each topology to individual network segments.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 混合拓扑旨在通过利用每种拓扑的优势，同时将每种拓扑的缺点限制在单独的网络段内，从而提高可靠性、可扩展性和灵活性。
- en: For example, the failure of the central node in the *star-ring* hybrid in [Figure
    1-7](#figure1-7) would affect inter-ring communication only. Each ring network
    would continue to function normally despite its isolation from the other rings.
    The failure of a single node in a ring would be much easier to diagnose in a star-ring
    hybrid network than in a single large ring network. Also, the outage would affect
    only a subset of the overall network.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[图1-7](#figure1-7)中*星环*混合网络中中央节点的故障只会影响环间通信。每个环形网络将继续正常运行，尽管它们与其他环形网络隔离。环形网络中单个节点的故障，在星环混合网络中的诊断要比单一大型环形网络更为容易。此外，故障只会影响整体网络的一个子集。
- en: Bandwidth vs. Latency
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带宽与延迟
- en: Network *bandwidth* is the amount of data we can send over a network connection
    in an interval of time. If your internet connection is advertised as *100Mbps
    download*, that means your internet connection should theoretically be able to
    transfer up to 100 megabits every second from your internet service provider (ISP)
    to your modem.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 网络*带宽*是指我们在一段时间内能够通过网络连接发送的数据量。如果您的互联网连接被宣传为*100Mbps下载*，这意味着理论上您的互联网连接应该能够每秒从互联网服务提供商（ISP）向调制解调器传输最多100兆位的数据。
- en: 'ISPs inundate us with advertisements about the amount of bandwidth they offer,
    so much so that it’s easy for us to fixate on bandwidth and equate it with the
    speed of the connection. However, faster doesn’t always mean greater performance.
    It may seem counterintuitive, but a lower-bandwidth network connection may seem
    to have better performance than a higher-bandwidth network connection because
    of one characteristic: latency.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ISP通过大量广告向我们宣传他们提供的带宽，以至于我们很容易将带宽与连接速度等同起来。然而，速度更快并不总是意味着性能更好。尽管这似乎违背直觉，但低带宽的网络连接可能表现得比高带宽连接更好，原因在于一个特性：延迟。
- en: Network *latency* is a measure of the time that passes between sending a network
    resource request and receiving a response. An example of latency is the delay
    that occurs between clicking a link on a website and the site’s rendering the
    resulting page. You’ve probably experienced the frustration of clicking a link
    that fails to load before your web browser gives up on ever receiving a reply
    from the server. This happens when the latency is greater than the maximum amount
    of time your browser will wait for a reply.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 网络*延迟*是指发送网络资源请求与接收响应之间的时间间隔。延迟的一个例子是点击网站上的链接和网站呈现结果页面之间的延迟。你可能曾经历过点击链接后页面无法加载，直到你的浏览器放弃等待服务器的回复。这种情况发生在延迟大于浏览器等待回复的最大时间时。
- en: High latency can negatively impact the user experience, lead to attacks that
    make your service inaccessible to its users, and drive users away from your software
    or service. The importance of managing latency in network software is often underappreciated
    by software developers. Don’t fall into the trap of thinking that bandwidth is
    all that matters for optimal network performance.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 高延迟会对用户体验产生负面影响，导致攻击使您的服务无法被用户访问，并驱使用户远离您的软件或服务。网络软件中延迟管理的重要性常常被软件开发人员低估。不要陷入认为带宽是优化网络性能的唯一因素的陷阱。
- en: 'A website’s latency comes from several sources: the network latency between
    the client and server, the time it takes to retrieve data from a data store, the
    time it takes to compile dynamic content on the server side, and the time it takes
    for the web browser to render the page. If a user clicks a link and the page takes
    too long to render, the user likely won’t stick around for the results, and the
    latency will drive traffic away from your application. Keeping latency to a minimum
    while writing network software, be it web applications or application-programming
    interfaces, will pay dividends by improving the user experience and your application’s
    ranking in popular search engines.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 网站的延迟来源于多个方面：客户端与服务器之间的网络延迟、从数据存储中获取数据所需的时间、在服务器端编译动态内容的时间，以及网页渲染所需的时间。如果用户点击了一个链接，而页面渲染的时间过长，用户很可能不会等待结果，延迟将导致流量流失。保持最低的延迟，同时编写网络软件，无论是Web应用程序还是应用程序接口，都将通过改善用户体验和提高应用程序在热门搜索引擎中的排名带来回报。
- en: You can address the most common sources of latency in several ways. First, you
    can reduce both the distance and the number of hops between users and your service
    by using a content delivery network (CDN) or cloud infrastructure to locate your
    service near your users. Optimizing the request and response sizes will further
    reduce latency. Incorporating a caching strategy in your network applications
    can have dramatic effects on performance. Finally, taking advantage of Go’s concurrency
    to minimize server-side blocking of the response can help. We’ll focus on this
    in the later chapters of this book.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过几种方式解决常见的延迟问题。首先，你可以通过使用内容分发网络（CDN）或云基础设施，将你的服务放置在离用户更近的地方，从而减少用户和服务之间的距离和跳数。优化请求和响应的大小将进一步减少延迟。在网络应用程序中引入缓存策略能显著提高性能。最后，利用Go的并发性来最小化服务器端的响应阻塞也有帮助。我们将在本书的后续章节中重点讨论这一点。
- en: The Open Systems Interconnection Reference Model
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放系统互联参考模型
- en: In the 1970s, as computer networks became increasingly complex, researchers
    created the *Open Systems Interconnection (OSI) reference model* to standardize
    networking. The OSI reference model serves as a framework for the development
    of and communication about protocols. *Protocols* are rules and procedures that
    determine the format and order of data sent over a network. For example, communication
    using the *Transmission Control Protocol**(TCP)* requires the recipient of a message
    to reply with an acknowledgment of receipt. Otherwise, TCP may retransmit the
    message.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在1970年代，随着计算机网络日益复杂，研究人员创建了*开放系统互联（OSI）参考模型*，以标准化网络通信。OSI参考模型作为协议开发和沟通的框架。*协议*是确定网络中数据传输格式和顺序的规则和程序。例如，使用*传输控制协议（TCP）*的通信要求消息接收方回复确认收到消息。否则，TCP可能会重新传输该消息。
- en: Although OSI is less relevant today than it once was, it’s still important to
    be familiar with it so you’ll understand common concepts, such as lower-level
    networking and routing, especially with respect to the involved hardware.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管OSI如今不再像以前那样重要，但熟悉它仍然很有价值，因为它能帮助你理解常见的概念，比如低层次的网络和路由，尤其是在硬件相关的内容上。
- en: The Hierarchal Layers of the OSI Reference Model
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OSI参考模型的分层结构
- en: The OSI reference model divides all network activities into a strict hierarchy
    composed of seven layers. Visual representations of the OSI reference model, like
    the one in [Figure 1-8](#figure1-8), arrange the layers into a stack, with Layer
    7 at the top and Layer 1 at the bottom.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: OSI参考模型将所有网络活动分为一个严格的层级结构，由七层组成。OSI参考模型的可视化表示，如[图1-8](#figure1-8)所示，将这些层排列成一个堆栈，第7层位于顶部，第1层位于底部。
- en: '![f01008](image_fi/500884c01/f01008.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![f01008](image_fi/500884c01/f01008.png)'
- en: 'Figure 1-8: Seven layers of the OSI reference model'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-8：OSI参考模型的七层
- en: 'It’s easy to interpret these layer designations as independent units of code.
    Rather, they describe abstractions we ascribe to parts of our software. For example,
    there is no *Layer 7* library you can incorporate into your software. But you
    can say that the software you wrote implements a service at Layer 7\. The seven
    layers of the OSI model are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易将这些层的名称解读为独立的代码单元。实际上，它们描述的是我们归属给软件部分的抽象。例如，你无法将*第7层*库直接集成到软件中。但你可以说你编写的软件实现了一个第7层的服务。OSI模型的七层如下：
- en: Layer 7—application layer Your network applications and libraries most often
    interact with the application layer, which is responsible for identifying hosts
    and retrieving resources. Web browsers, Skype, and bit torrent clients are examples
    of Layer 7 applications.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第7层——应用层 你的网络应用程序和库最常与应用层交互，应用层负责识别主机并获取资源。Web浏览器、Skype和BT客户端是应用层的例子。
- en: Layer 6—presentation layer The presentation layer prepares data for the network
    layer when that data is moving down the stack, and it presents data to the application
    layer when that data moves up the stack. Encryption, decryption, and data encoding
    are examples of Layer 6 functions.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第6层——表示层 表示层在数据下行时为网络层准备数据，在数据上行时为应用层提供数据。加密、解密和数据编码是第6层功能的例子。
- en: Layer 5—session layer The session layer manages the connection life cycle between
    nodes on a network. It’s responsible for establishing the connection, managing
    connection time-outs, coordinating the mode of operation, and terminating the
    connection. Some Layer 7 protocols rely on services provided by Layer 5.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第五层—会话层 会话层管理网络中节点之间连接的生命周期。它负责建立连接、管理连接超时、协调操作模式并终止连接。某些第七层协议依赖于第5层提供的服务。
- en: Layer 4—transport layer The transport layer controls and coordinates the transfer
    of data between two nodes while maintaining the reliability of the transfer. Maintaining
    the reliability of the transfer includes correcting errors, controlling the speed
    of data transfer, chunking or segmenting the data, retransmitting missing data,
    and acknowledging received data. Often protocols in this layer might retransmit
    data if the recipient doesn’t acknowledge receipt of the data.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四层—传输层 传输层控制并协调两个节点之间的数据传输，同时保持传输的可靠性。保持传输可靠性包括纠正错误、控制数据传输速度、分块或分段数据、重传丢失的数据以及确认接收到的数据。如果接收方没有确认接收到数据，本层协议通常会重传数据。
- en: Layer 3—network layer The network layer is responsible for transmitting data
    between nodes. It allows you to send data to a network address without having
    a direct point-to-point connection to the remote node. OSI does not require protocols
    in this layer to provide reliable transport or report transmission errors to the
    sender. The network layer is home to network management protocols involved in
    routing, addressing, multicasting, and traffic control. The next chapter covers
    these topics.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三层—网络层 网络层负责在节点之间传输数据。它允许你将数据发送到一个网络地址，而不需要与远程节点建立直接的点对点连接。OSI 并不要求这一层的协议提供可靠的传输或报告传输错误给发送方。网络层包含了涉及路由、寻址、多播和流量控制的网络管理协议。下一章将讨论这些内容。
- en: Layer 2—data link layer The data link layer handles data transfers between two
    directly connected nodes. For example, the data link layer facilitates data transfer
    from a computer to a switch and from the switch to another computer. Protocols
    in this layer identify and attempt to correct errors on the physical layer.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二层—数据链路层 数据链路层处理两个直接连接的节点之间的数据传输。例如，数据链路层促进了计算机到交换机的传输，以及交换机到另一台计算机的传输。本层的协议会识别并尝试纠正物理层上的错误。
- en: The data link layer’s retransmission and flow control functions are dependent
    on the underlying physical medium. For example, Ethernet does not retransmit incorrect
    data, whereas wireless does. This is because bit errors on Ethernet networks are
    infrequent, whereas they’re common over wireless. Protocols further up the network
    protocol stack can ensure that the data transmission is reliable if this layer
    doesn’t do so, though generally with less efficiency.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据链路层的重传和流量控制功能取决于底层的物理介质。例如，以太网不会重传错误数据，而无线网络会重传。这是因为以太网网络上的比特错误较少，而无线网络中则较为常见。如果该层无法保证数据传输的可靠性，网络协议栈中更高层的协议通常可以确保传输的可靠性，尽管效率较低。
- en: Layer 1—physical layer The physical layer converts bits from the network stack
    to electrical, optic, or radio signals suitable for the underlying physical medium
    and from the physical medium back into bits. This layer controls the bit rate.
    The bit rate is the data speed limit. A gigabit per second bit rate means data
    can travel at a maximum of 1 billion bits per second between the origin and destination.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一层—物理层 物理层将网络栈中的比特转换为适合底层物理介质的电信号、光信号或无线电信号，并将物理介质中的信号转换回比特。此层控制比特率。比特率是数据传输的速度限制。一千兆比特每秒的比特率意味着数据可以在源和目的地之间以每秒最多10亿比特的速度传输。
- en: A common confusion when discussing network transmission rates is using bytes
    per second instead of bits per second. We count the number of zeros and ones,
    or *bits*, we can transfer per second. Therefore, network transmission rates are
    measured in bits per second. We use bytes per second when discussing the amount
    of data transferred.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论网络传输速率时，一个常见的误解是使用每秒字节数而不是每秒比特数。我们计算每秒可以传输的零和一，或者说是*比特*的数量。因此，网络传输速率是以每秒比特数来衡量的。讨论传输的数据量时，我们使用每秒字节数。
- en: If your ISP advertises a 100Mbps download rate, that doesn’t mean you can download
    a 100MB file in one second. Rather, it may take closer to eight seconds under
    ideal network conditions. It’s appropriate to say we can transfer a maximum of
    12.5MB per second over the 100Mbps connection.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 ISP 宣传的下载速度是 100Mbps，这并不意味着你能在一秒钟内下载一个 100MB 的文件。实际上，在理想的网络条件下，可能需要接近八秒的时间。可以说，我们在
    100Mbps 的连接上最多可以每秒传输 12.5MB。
- en: Sending Traffic by Using Data Encapsulation
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用数据封装发送流量
- en: '*Encapsulation* is a method of hiding implementation details or making only
    relevant details available to the recipient. Think of encapsulation as being like
    a package you send through the postal service. We could say that the envelope
    encapsulates its contents. In doing so, it may include the destination address
    or other crucial details used by the next leg of its journey. The actual contents
    of your package are irrelevant; only the details on the package are important
    for transport.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*封装*是一种隐藏实现细节或仅向接收方提供相关细节的方法。可以把封装想象成像通过邮政服务发送的包裹。我们可以说信封封装了其内容。在这个过程中，信封可能会包括目的地址或其他关键细节，这些信息会被用于包裹的下一段旅程。包裹的实际内容并不重要；只有包裹上的细节对于运输才是重要的。'
- en: As data travels down the stack, it’s encapsulated by the layer below. We typically
    call the data traveling down the stack a *payload*, although you might see it
    referred to as a *message body*. The literature uses the term *service data unit**(SDU)*.
    For example, the transport layer encapsulates payloads from the session layer,
    which in turn encapsulates payloads from the presentation layer. When the payload
    moves up the stack, each layer strips the header information from the previous
    stack.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据向下移动堆栈时，它会被下层封装。我们通常称沿着堆栈向下移动的数据为 *有效负载*，虽然你可能会看到它被称为 *消息体*。文献中使用的术语是 *服务数据单元*（SDU）。例如，传输层封装了来自会话层的有效负载，而会话层又封装了来自表示层的有效负载。当有效负载向上移动堆栈时，每一层都会去除来自上一层堆栈的头部信息。
- en: Even protocols that operate in a single OSI layer use data encapsulation. Take
    version 1 of the *HyperText Transfer Protocol**(HTTP/1)*, for example, a Layer
    7 protocol that both the client and the server use to exchange web content. HTTP
    defines a complete message, including header information, that the client sends
    from its Layer 7 to the server’s Layer 7; the network stack delivers the client’s
    request to the HTTP server application. The HTTP server application initiates
    a response to its network stack, which creates a Layer 7 payload and sends it
    back to the client’s Layer 7 application ([Figure 1-9](#figure1-9)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是在单一 OSI 层中运行的协议也使用数据封装。例如，以 *超文本传输协议*（HTTP/1）第1版为例，这是一个第7层协议，客户端和服务器都使用它来交换网页内容。HTTP
    定义了一个完整的消息，包括客户端从其第7层发送到服务器第7层的头部信息；网络堆栈将客户端的请求传递到 HTTP 服务器应用程序。HTTP 服务器应用程序发起响应，返回其网络堆栈，后者创建一个第7层有效负载并将其发送回客户端的第7层应用程序（[图
    1-9](#figure1-9)）。
- en: Communication between the client and the server on the same layer is called
    *horizontal communication,* a term that makes it sound like a single-layer protocol
    on the client directly communicates with its counterpart on the server. In fact,
    in horizontal communication, data must travel all the way down the client’s stack,
    then back up the server’s stack.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端与服务器之间同一层的通信被称为 *水平通信*，这一术语让人感觉像是客户端上的单层协议直接与服务器上的对应层进行通信。实际上，在水平通信中，数据必须从客户端的堆栈一路向下，再返回服务器的堆栈。
- en: For example, [Figure 1-10](#figure1-10) shows how an HTTP request traverses
    the stack.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[图 1-10](#figure1-10)展示了一个 HTTP 请求如何遍历堆栈。
- en: 'Generally, a payload travels down the client’s network stack, over physical
    media to the server, and up the server’s network stack to its corresponding layer.
    The result is that data sent from one layer at the origin node arrives at the
    same layer on the destination node. The server’s response takes the same path
    in the opposite direction. On the client’s side, Layer 6 receives Layer 7’s payload,
    then encapsulates the payload with a header to create Layer 6’s payload. Layer
    5 receives Layer 6’s payload, adds its own header, and sends its payload on to
    Layer 4, where we’re introduced to our first transmission protocol: TCP.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个有效负载会从客户端的网络栈向下传输，通过物理介质到达服务器，然后再向上传送至服务器的网络栈中的相应层。结果是，从源节点的某一层发送的数据最终到达目标节点的同一层。服务器的响应会沿相同的路径朝相反方向传输。在客户端一侧，第六层接收第七层的有效负载，然后使用头部封装有效负载，形成第六层的有效负载。第五层接收第六层的有效负载，添加自己的头部，并将其有效负载传递给第四层，在这里我们会介绍第一个传输协议：TCP。
- en: '![f01009](image_fi/500884c01/f01009.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![f01009](image_fi/500884c01/f01009.png)'
- en: 'Figure 1-9: Horizontal communication from the client to the server and back'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-9：客户端与服务器之间的横向通信
- en: '![f01010](image_fi/500884c01/f01010.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![f01010](image_fi/500884c01/f01010.png)'
- en: 'Figure 1-10: An HTTP request traveling from Layer 7 on the client to Layer
    7 on the server'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-10：HTTP 请求从客户端的第七层到达服务器的第七层
- en: TCP is a Layer 4 protocol whose payloads are also known as *segments* or *datagrams*.
    TCP accepts Layer 5’s payload and adds its header before sending the segment on
    to Layer 3\. The *Internet Protocol**(IP)* at Layer 3 receives the TCP segment
    and encapsulates it with a header to create Layer 3’s payload, which is known
    as a *packet*. Layer 2 accepts the packet and adds a header and a footer, creating
    its payload, called a *frame*. Layer 2’s header translates the recipient’s IP
    address into a *media access control**(MAC)* address, which is a unique identifier
    assigned to the node’s network interface. Its footer contains a *frame check sequence**(FCS)*,
    which is a checksum to facilitate error detection. Layer 1 receives Layer 2’s
    payload in the form of bits and sends the bits to the server.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 是一个第四层协议，其有效负载也称为 *段* 或 *数据报*。TCP 接受第五层的有效负载，在发送段到第三层之前，会在其前面添加一个头部。第三层的
    *互联网协议**(IP)* 接收到 TCP 段，并将其封装上一个头部，形成第三层的有效负载，即 *数据包*。第二层接收数据包，添加头部和尾部，生成其有效负载，称为
    *帧*。第二层的头部将接收方的 IP 地址转换为 *媒体访问控制**(MAC)* 地址，这是分配给节点网络接口的唯一标识符。其尾部包含 *帧校验序列**(FCS)*，这是一个校验和，用于辅助错误检测。第一层接收第二层的有效负载（以比特流的形式），并将比特流发送到服务器。
- en: The server’s Layer 1 receives the bits, converts them to a frame, and sends
    the frame up to Layer 2\. Layer 2 strips its header and footer from the frame
    and passes the packet up to Layer 3\. The process of reversing each layer’s encapsulation
    continues up the stack until the payload reaches Layer 7\. Finally, the HTTP server
    receives the client’s request from the network stack.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的第一层接收比特流，将其转换为帧，并将帧发送到第二层。第二层去除帧的头部和尾部，将数据包传递给第三层。每一层的封装逆向过程一直持续到有效负载到达第七层。最后，HTTP
    服务器从网络栈接收客户端的请求。
- en: The TCP/IP Model
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP/IP 模型
- en: Around the same time as researchers were developing the OSI reference model,
    the Defense Advanced Research Projects Agency (DARPA), an agency of the US Department
    of Defense, spearheaded a parallel effort to develop protocols. This effort resulted
    in a set of protocols we now call the *TCP/IP model*. The project’s impact on
    the US military, and subsequently the world’s communications, was profound. The
    TCP/IP model reached critical mass when Microsoft incorporated it into Windows
    95 in the early 1990s. Today, TCP/IP is ubiquitous in computer networking, and
    it’s the protocol stack we’ll use in this book.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，正当研究人员在开发 OSI 参考模型时，美国国防部的国防高级研究计划局（DARPA）也在推动一项平行的工作，旨在开发协议。这一努力最终产生了一组我们现在称之为
    *TCP/IP 模型* 的协议。该项目对美国军方，以及随后对全球通信的影响深远。TCP/IP 模型在 1990 年代初，微软将其纳入 Windows 95
    时达到了关键的转折点。今天，TCP/IP 已在计算机网络中无处不在，它也是本书中我们将使用的协议栈。
- en: TCP/IP—named for the Transmission Control Protocol and the Internet Protocol—facilitated
    networks designed using the *end-to-end principle*, whereby each network segment
    includes only enough functionality to properly transmit and route bits; all other
    functionality belongs to the endpoints, or the sender and receiver’s network stacks.
    Contrast this with modern cellular networks, where more of the network functionality
    must be provided by the network between cell phones to allow for a cell phone
    connection to jump from tower to tower without disconnecting its phone call. The
    TCP/IP specification recommends that implementations be robust; they should send
    well-formed packets yet accept any packet whose intention is clear, regardless
    of whether the packet adheres to technical specifications.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP——得名于传输控制协议（Transmission Control Protocol）和互联网协议（Internet Protocol）——促进了基于*端到端原则*设计的网络，其中每个网络段只包含足够的功能来正确传输和路由比特；所有其他功能都属于端点，即发送方和接收方的网络堆栈。与此相对的是现代蜂窝网络，在这些网络中，更多的网络功能必须由基站之间提供，以允许手机连接在基站之间跳转而不切断电话通话。TCP/IP规范建议实现应具有鲁棒性；它们应发送格式良好的数据包，但应接受任何意图明确的数据包，无论该数据包是否遵循技术规范。
- en: 'Like the OSI reference model, TCP/IP relies on layer encapsulation to abstract
    functionality. It consists of four named layers: the application, transport, internet,
    and link layers. TCP/IP’s application and link layers generalize their OSI counterparts,
    as shown in [Figure 1-11](#figure1-11).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与OSI参考模型类似，TCP/IP依赖于层封装来抽象功能。它由四个命名层组成：应用层、传输层、互联网层和链路层。TCP/IP的应用层和链路层概括了它们在OSI中的对应层，如[图1-11](#figure1-11)所示。
- en: '![f01011](image_fi/500884c01/f01011.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![f01011](image_fi/500884c01/f01011.png)'
- en: 'Figure 1-11: The four-layer TCP/IP model compared to the seven-layer OSI reference
    model'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-11：四层TCP/IP模型与七层OSI参考模型的比较
- en: The TCP/IP model simplifies OSI’s application, presentation, and session layers
    into a single application layer, primarily because TCP/IP’s protocols frequently
    cross boundaries of OSI Layers 5 through 7\. Likewise, OSI’s data link and physical
    layers correspond to TCP/IP’s link layer. TCP/IP’s and OSI’s transport and network
    layers share a one-to-one relationship.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP模型将OSI的应用层、表示层和会话层简化为单一的应用层，主要因为TCP/IP的协议经常跨越OSI第5层到第7层的边界。同样，OSI的数据链路层和物理层对应于TCP/IP的链路层。TCP/IP和OSI的传输层及网络层有一一对应的关系。
- en: This simplification exists because researchers developed prototype implementations
    first and then formally standardized their final implementation, resulting in
    a model geared toward practical use. On the other hand, committees spent considerable
    time devising the OSI reference model to address a wide range of requirements
    before anyone created an implementation, leading to the model’s increased complexity.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简化的出现是因为研究人员首先开发了原型实现，然后正式标准化了最终的实现，导致了一个面向实际应用的模型。另一方面，委员会花费了大量时间制定OSI参考模型，以应对广泛的需求，然后才有人创建实现，这使得该模型的复杂性增加。
- en: The Application Layer
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用层
- en: Like OSI’s application layer, the TCP/IP model’s *application layer* interacts
    directly with software applications. Most of the software we write uses protocols
    in this layer, and when your web browser retrieves a web page, it reads from this
    layer of the stack.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与OSI的应用层类似，TCP/IP模型的*应用层*直接与软件应用程序交互。我们编写的大多数软件都使用这一层的协议，当你的网页浏览器检索网页时，它会读取堆栈中的这一层。
- en: You’ll notice that the TCP/IP application layer encompasses three OSI layers.
    This is because TCP/IP doesn’t define specific presentation or session functions.
    Instead, the specific application protocol implementations concern themselves
    with those details. As you’ll see, some TCP/IP application layer protocols would
    be hard-pressed to fit neatly into a single upper layer of the OSI model, because
    they have functionality that spans more than one OSI layer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，TCP/IP的应用层涵盖了三个OSI层。这是因为TCP/IP没有定义具体的表示层或会话层功能。相反，具体的应用协议实现关注这些细节。如你所见，一些TCP/IP应用层协议很难完全符合OSI模型中的单一上层，因为它们具有跨越多个OSI层的功能。
- en: Common TCP/IP application layer protocols include HTTP, the *File Transfer Protocol**(FTP)*
    for file transfers between nodes, and the *Simple Mail Transfer Protocol**(SMTP)*
    for sending email to mail servers. The *Dynamic Host Configuration Protocol**(DHCP)*
    and the *Domain Name System**(DNS)* also function in the application layer. DHCP
    and DNS provide the addressing and name resolution services, respectively, that
    allow other application layer protocols to operate. HTTP, FTP, and SMTP are examples
    of protocol implementations that provide the presentation or session functionality
    in TCP/IP’s application layer. We’ll discuss these protocols in later chapters.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的 TCP/IP 应用层协议包括 HTTP、*文件传输协议 (FTP)* 用于节点之间的文件传输，以及 *简单邮件传输协议 (SMTP)* 用于向邮件服务器发送电子邮件。*动态主机配置协议
    (DHCP)* 和 *域名系统 (DNS)* 也在应用层中运行。DHCP 和 DNS 分别提供地址分配和名称解析服务，使其他应用层协议能够运行。HTTP、FTP
    和 SMTP 是提供 TCP/IP 应用层中表示或会话功能的协议实现示例。我们将在后续章节中讨论这些协议。
- en: The Transport Layer
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输层
- en: '*Transport layer* protocols handle the transfer of data between two nodes,
    like OSI’s Layer 4\. These protocols can help ensure *data integrity* by making
    sure that all data sent from the origin completely and correctly makes its way
    to the destination. Keep in mind that data integrity doesn’t mean the destination
    will receive all segments we send through the transport layer. There are just
    too many causes of packet loss over a network. It does mean that TCP specifically
    will make sure the data received by the destination is in the correct order, without
    duplicate data or missing data.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*传输层* 协议处理两个节点之间的数据传输，类似于 OSI 的第 4 层。这些协议可以通过确保从源节点发送的所有数据完全且正确地到达目的地来帮助确保
    *数据完整性*。请记住，数据完整性并不意味着目的地会收到我们通过传输层发送的所有分段。由于网络中丢包的原因太多，不能保证每个分段都会到达目的地。但这意味着
    TCP 会特别确保目的地收到的数据是按正确顺序排列的，不会有重复数据或丢失数据。'
- en: The primary transport layer protocols you’ll use in this book are TCP and the
    *User Datagram Protocol (UDP)*. As mentioned in “Sending Traffic by Using Data
    Encapsulation” on page 10, this layer handles segments, or datagrams.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中你将使用的主要传输层协议是 TCP 和 *用户数据报协议 (UDP)*。正如在第 10 页的《使用数据封装发送流量》一节中提到的，这一层处理的是分段或数据报。
- en: Most of our network applications rely on the transport layer protocols to handle
    the error correction, flow control, retransmission, and transport acknowledgment
    of each segment. However, the TCP/IP model doesn’t require every transport layer
    protocol to fulfill each of those elements. UDP is one such example. If your application
    requires the use of UDP for maximal throughput, the onus is on you to implement
    some sort of error checking or session management, since UDP provides neither.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大多数网络应用程序依赖于传输层协议来处理每个分段的错误校正、流量控制、重传和传输确认。然而，TCP/IP 模型并不要求每个传输层协议都必须满足所有这些元素。UDP
    就是一个例子。如果你的应用需要使用 UDP 以实现最大吞吐量，那么责任在你自己，必须实现某种错误检查或会话管理，因为 UDP 本身不提供这些功能。
- en: The Internet Layer
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 互联网层
- en: The *internet layer* is responsible for routing packets of data from the upper
    layers between the origin node and the destination node, often over multiple networks
    with heterogeneous physical media. It has the same functions as OSI’s Layer 3
    network layer. (Some sources may refer to TCP/IP’s internet layer as the *network
    layer*.)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*互联网层* 负责将上层数据包路由从源节点传递到目的节点，通常跨越多个物理介质异构的网络。它的功能与 OSI 的第 3 层网络层相同。（有些资料可能将
    TCP/IP 的互联网层称为 *网络层*。）'
- en: '*Internet Protocol version 4 (IPv4)*, *Internet Protocol version 6 (IPv6)*,
    *Border Gateway Protocol**(BGP)*, *Internet Control Message Protocol**(ICMP)*,
    *Internet Group Management Protocol (IGMP)*, and the *Internet Protocol Security**(IPsec)*
    suite, among others, provide host identification and routing to TCP/IP’s internet
    layer. We will cover these protocols in the next chapter, when we discuss host
    addressing and routing. For now, know that this layer plays an integral role in
    ensuring that the data we send reaches its destination, no matter the complexity
    between the origin and destination.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*互联网协议版本 4 (IPv4)*、*互联网协议版本 6 (IPv6)*、*边界网关协议 (BGP)*、*互联网控制消息协议 (ICMP)*、*互联网组管理协议
    (IGMP)* 和 *互联网协议安全 (IPsec)* 套件等，提供主机标识和路由功能，作用于 TCP/IP 的互联网层。我们将在下一章讨论这些协议，届时我们将涉及主机寻址和路由。现在，请了解这一层在确保我们发送的数据能够到达目的地时起着至关重要的作用，不论源头和目的地之间的复杂性如何。'
- en: The Link Layer
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链路层
- en: The *link layer*, which corresponds to Layers 1 and 2 of the OSI reference model,
    is the interface between the core TCP/IP protocols and the physical media.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*链路层*对应于 OSI 参考模型的第 1 层和第 2 层，是核心 TCP/IP 协议与物理媒体之间的接口。'
- en: The link layer’s *Address Resolution Protocol**(ARP)* translates a node’s IP
    address to the MAC address of its network interface. The link layer embeds the
    MAC address in each frame’s header before passing the frame on to the physical
    network. We’ll discuss MAC addresses and their routing significance in the next
    chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 链路层的*地址解析协议**(ARP)*将节点的 IP 地址转换为其网络接口的 MAC 地址。链路层在将数据帧传递到物理网络之前，会将 MAC 地址嵌入每个数据帧的头部。我们将在下一章讨论
    MAC 地址及其路由意义。
- en: Not all TCP/IP implementations include link layer protocols. Older readers may
    remember the joys of connecting to the internet over phone lines using analog
    modems. Analog modems made serial connections to ISPs. These serial connections
    didn’t include link layer support via the serial driver or modem. Instead, they
    required the use of link layer protocols, such as the *Serial Line Internet Protocol**(SLIP)*
    or the *Point-to-Point Protocol**(PPP)*, to fill the void. Those that do not implement
    a link layer typically rely on the underlying network hardware and device drivers
    to pick up the slack. The TCP/IP implementations over Ethernet, wireless, and
    fiber-optic networks we’ll use in this book rely on device drivers or network
    hardware to fulfill the link layer portion of their TCP/IP stack.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的 TCP/IP 实现都包括链路层协议。年长的读者可能还记得通过模拟调制解调器使用电话线路连接互联网的乐趣。模拟调制解调器通过串行连接到 ISP（互联网服务提供商）。这些串行连接并没有通过串行驱动程序或调制解调器实现链路层支持。相反，它们需要使用链路层协议，如*串行线路互联网协议**(SLIP)*或*点对点协议**(PPP)*，来填补这一空白。不实现链路层的通常依赖于底层的网络硬件和设备驱动程序来承担这部分任务。本书中将使用的以以太网、无线网络和光纤网络为基础的
    TCP/IP 实现依赖于设备驱动程序或网络硬件来完成 TCP/IP 协议栈中的链路层部分。
- en: What You’ve Learned
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你所学到的
- en: In this chapter, you learned about common network topologies and how to combine
    those topologies to maximize their advantages and minimize their disadvantages.
    You also learned about the OSI and TCP/IP reference models, their layering, and
    data encapsulation. You should feel comfortable with the order of each layer and
    how data moves from one layer to the next. Finally, you learned about each layer’s
    function and the role it plays in sending and receiving data between nodes on
    a network.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了常见的网络拓扑结构以及如何结合这些拓扑以最大化它们的优势并最小化它们的劣势。你还了解了 OSI 和 TCP/IP 参考模型、它们的层次结构以及数据封装。你应该已经能够熟练掌握每一层的顺序以及数据如何从一层传递到另一层。最后，你了解了每一层的功能以及它在网络节点之间发送和接收数据时所扮演的角色。
- en: This chapter’s goal was to give you enough networking knowledge to make sense
    of the next chapter. However, it’s important that you explore these topics in
    greater depth, because comprehensive knowledge of networking principles and architectures
    can help you devise better algorithms. I’ll suggest additional reading for each
    of the major topics covered in this chapter to get you started. I also recommend
    you revisit this chapter after working through some of the examples in this book.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是让你掌握足够的网络知识，以便理解下一章的内容。然而，深入探讨这些主题非常重要，因为对网络原理和架构的全面了解有助于你设计更好的算法。我将在本章涵盖的每个主要主题后推荐一些额外的阅读材料，以帮助你入门。我还建议在完成本书中的一些例子后，重新回顾本章内容。
- en: 'The OSI reference model is available for reading online at [https://www.itu.int/rec/T-REC-X.200-199407-I/en/](https://www.itu.int/rec/T-REC-X.200-199407-I/en/).
    Two Requests for Comments (RFCs)—detailed publications meant to describe internet
    technologies—outline the TCP/IP reference model: RFC 1122 and RFC 1123 ([https://tools.ietf.org/html/rfc1122/](https://tools.ietf.org/html/rfc1122/)
    and [https://tools.ietf.org/html/rfc1123/](https://tools.ietf.org/html/rfc1123/)).
    RFC 1122 covers the lower three layers of the TCP/IP model, whereas RFC 1123 describes
    the application layer and support protocols, such as DNS. If you’d like a more
    comprehensive reference for the TCP/IP model, you’d be hard-pressed to do better
    than *The TCP/IP Guide* by Charles M. Kozierok (No Starch Press, 2005).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: OSI参考模型可以在线阅读，链接地址为[https://www.itu.int/rec/T-REC-X.200-199407-I/en/](https://www.itu.int/rec/T-REC-X.200-199407-I/en/)。有两篇《请求评论》（RFC）文献—旨在描述互联网技术的详细出版物—概述了TCP/IP参考模型：RFC
    1122和RFC 1123（[https://tools.ietf.org/html/rfc1122/](https://tools.ietf.org/html/rfc1122/)
    和 [https://tools.ietf.org/html/rfc1123/](https://tools.ietf.org/html/rfc1123/)）。RFC
    1122涵盖了TCP/IP模型的前三层，而RFC 1123描述了应用层及支持协议，如DNS。如果你想要更全面的TCP/IP模型参考，*查尔斯·M·科泽罗克（Charles
    M. Kozierok）*的《TCP/IP指南》（No Starch Press，2005年）无疑是一个不错的选择。
- en: Network latency has plagued countless network applications and spawned an industry.
    Some CDN providers write prolifically on the topic of latency and interesting
    issues they’ve encountered while improving their offerings. CDN blogs that provide
    insightful posts include the Cloudflare Blog ([https://blog.cloudflare.com/](https://blog.cloudflare.com/)),
    the KeyCDN Blog ([https://www.keycdn.com/blog/](https://www.keycdn.com/blog/)),
    and the Fastly Blog ([https://www.fastly.com/blog/](https://www.fastly.com/blog/)).
    If you’re purely interested in learning more about latency and its sources, consider
    “Latency (engineering)” on Wikipedia ([https://en.wikipedia.org/wiki/Latency_(engineering)](https://en.wikipedia.org/wiki/Latency_(engineering)))
    and Cloudflare’s glossary ([https://www.cloudflare.com/learning/performance/glossary/what-is-latency/](https://www.cloudflare.com/learning/performance/glossary/what-is-latency/))
    as starting points.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 网络延迟困扰了无数网络应用，并催生了一个行业。一些CDN提供商在延迟话题以及改进服务时遇到的有趣问题上写了大量文章。提供有见地的CDN博客包括Cloudflare博客（[https://blog.cloudflare.com/](https://blog.cloudflare.com/)）、KeyCDN博客（[https://www.keycdn.com/blog/](https://www.keycdn.com/blog/)）和Fastly博客（[https://www.fastly.com/blog/](https://www.fastly.com/blog/)）。如果你纯粹是想了解更多关于延迟及其来源的信息，可以从维基百科上的“延迟（工程学）”（[https://en.wikipedia.org/wiki/Latency_(engineering)](https://en.wikipedia.org/wiki/Latency_(engineering)））和Cloudflare的术语表（[https://www.cloudflare.com/learning/performance/glossary/what-is-latency/](https://www.cloudflare.com/learning/performance/glossary/what-is-latency/)）开始。
