<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch14">&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch14">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_215" aria-label=" Page 215. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">BUILDING THE FRONTEND</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/Drop-image.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">In this chapter, you’ll build the frontend using React components and Next.js pages, discussed in <span class="chapterintro_Xref"><a href="chapter4.xhtml">Chapters 4</a></span> and <span class="chapterintro_Xref"><a href="chapter5.xhtml">5</a></span>. By the end, you’ll have an initial version of the app to which you can add OAuth authentication.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1"><span id="sec1"/><span id="h1-81"/><samp class="SANS_Futura_Std_Bold_B_11">Overview of the User Interface</samp></h3>&#13;
<p class="TNI">Our application will consist of three Next.js pages. The <i>start page</i> will show the list of locations retrieved from the database. Each item in the list will link to its respective <i>location detail page</i>, whose URL we’ll construct using the location’s ID, like this: <i>/location/:location_id</i>. The third page is the user’s <i>wish list page</i>. It resembles the start page and follows the same dynamic URL pattern as the location detail page, except it supplies the user’s ID instead of the location’s. This page shows only the locations already added to the wish list.</p>&#13;
<p class="TX">We must also consider what rendering strategy to use for each page. Because the content of the start page never changes, we’ll use static site generation (SSG) to render the HTML on build time. Because the detail <span role="doc-pagebreak" epub:type="pagebreak" id="pg_216" aria-label=" Page 216. "/>page and wish list page will change based on the user’s actions, we’ll use static site rendering (SSR) to regenerate them upon every request.</p>&#13;
<p class="TX">Lastly, all three pages should have headers containing the logo and a link to the start page. When we add the OAuth data in the next chapter, we’ll show the user’s name, a link to the user’s wish list, and the sign-in/sign-out button in the header as well.</p>&#13;
<p class="TX">To achieve this, we need to create the following React components:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">The locations list component, which will use the locations list item component to render the list of locations on the start page. Later, we’ll use these same components to implement the list of locations on a user’s wish list page.</li>&#13;
<li class="ListBullet">The overall layout component, header component, and logo component, which define the global layout of each page.</li>&#13;
<li class="ListBullet">The authentication element component, which lets users log in or out in the header.</li>&#13;
<li class="ListBullet">A universal button component we’ll use for different tasks.</li>&#13;
</ul>&#13;
<p class="TX">Let’s begin with the components necessary for the start page.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H1"><span id="sec2"/><span id="h1-82"/><samp class="SANS_Futura_Std_Bold_B_11">The Start Page</samp></h3>&#13;
<p class="TNI">We’ll begin by crafting the smallest parts of the user interface and then use these to build the more complex components and pages. On the start page, we need the layout component, the locations list component, and the locations list item component, which is the smallest building block, so we’ll start there.</p>&#13;
<p class="TX">Create the <i>components</i> folder in the application’s root directory, next to the <i>middleware</i> folder. This is where we’ll place all our React components, in their own folders.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h4 class="H2"><span id="sec3"/><span id="h2-159"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The List Item</samp></h4>&#13;
<p class="TNI">The locations list item component represents a single item in a list of locations. Create the <i>locations-list-item</i> folder and add two files, <i>index.tsx</i> and <i>index.module.css</i>, following the pattern we discussed in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>. Then add the code in <a href="chapter14.xhtml#Lis14-1">Listing 14-1</a> to <i>index.module.css</i>. We’ll use this CSS to style the component.</p>&#13;
<span id="Lis14-1"/>&#13;
<pre class="pre-236"><code>.root {&#13;
    background-color: #fff;&#13;
    border-radius: 5px;&#13;
    color: #1d1f21;&#13;
    cursor: pointer;&#13;
    list-style: none;&#13;
    margin: 0.5rem 0;&#13;
    padding: 0.5rem;&#13;
    transition: background-color 0.25s ease-in, color 0.25s ease-in;&#13;
    will-change: background-color, color;&#13;
}&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_217" aria-label=" Page 217. "/>.root:hover {&#13;
    background-color: rgba(0, 118, 255, 0.9);&#13;
    color: #fff;&#13;
}&#13;
&#13;
.root h2 {&#13;
    margin: 0;&#13;
    padding: 0;&#13;
}&#13;
&#13;
.root small {&#13;
    font-weight: 300;&#13;
    padding: 0 1rem;&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 14-1: The</span> <span class="Futura_Std_Book_11">components/locations-list-item/index.module.css</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">The CSS module uses dark letters on a white background. In addition, it adds a simple hover effect, causing the background to turn blue and the font color white when a user hovers over it. We remove the list marker and set the margin and padding accordingly.</p>&#13;
<p class="TX">Now add the code from <a href="chapter14.xhtml#Lis14-2">Listing 14-2</a> to the <i>index.tsx</i> file.</p>&#13;
<span id="Lis14-2"/>&#13;
<pre class="pre-237"><code>import Link from "next/link";&#13;
import styles from "./index.module.css";&#13;
import {LocationType} from "mongoose/locations/schema";&#13;
&#13;
interface PropsInterface {&#13;
    location: LocationType;&#13;
}&#13;
&#13;
const LocationsListItem = (props: PropsInterface): JSX.Element =&gt; {&#13;
    const location = props.location;&#13;
    return (&#13;
        &lt;&gt;&#13;
            {location &amp;&amp; (&#13;
                &lt;li className={styles.root}&gt;&#13;
                    &lt;Link href={`/location/${location.location_id}`}&gt;&#13;
                        &lt;h2&gt;&#13;
                            {location.name}&#13;
                            &lt;small className={styles.details}&gt;&#13;
                                {location.cuisine} in {location.borough}&#13;
                            &lt;/small&gt;&#13;
                        &lt;/h2&gt;&#13;
                    &lt;/Link&gt;&#13;
                &lt;/li&gt;&#13;
            )}&#13;
        &lt;/&gt;&#13;
    );&#13;
};&#13;
&#13;
export default LocationsListItem;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 14-2: The</span> <span class="Futura_Std_Book_11">components/locations-list-item/index.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_218" aria-label=" Page 218. "/>You should be familiar with this file’s structure from <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>. First we import the <i>next/link</i> component, which we need to create a link to the detail page, the styles we just added, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationType</samp> from the Mongoose schema.</p>&#13;
<p class="TX">We then define the <samp class="SANS_TheSansMonoCd_W5Regular_11">PropsInterface</samp>, a private interface used for the component’s properties object. The component has the usual <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> parameter whose structure defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">PropsInterface</samp> and returns a JSX element. These props hold the data in the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp> property, which we pass to the component through its <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp> attribute. Finally, we define the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationsListItem</samp> component and store it in a constant that we export at the end of the file.</p>&#13;
<p class="TX">In the component itself, we have a list item that contains a Next.js <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> element linking to the location’s detail page. These links use a dynamic URL pattern that incorporates the respective location’s ID, so we create the link target to match <i>/location/:location_id</i>. In addition, we render the location’s <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">cuisine</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">borough</samp> values to the component. Keep in mind that until we create the page for the route <i>/location/:location_id</i>, clicking those links will result in a <i>404</i> error page.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h4 class="H2"><span id="sec4"/><span id="h2-160"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Locations List</samp></h4>&#13;
<p class="TNI">Using the list item component, we’ll build the locations list. This component will loop through an array of locations and display them on the start page and wish list page. Create the <i>components/locations-list</i> folder and then add the files <i>index.tsx</i> and <i>index.module.css</i> to them. Copy the code in <a href="chapter14.xhtml#Lis14-3">Listing 14-3</a> to the <i>index.module.css</i> file.</p>&#13;
<span id="Lis14-3"/>&#13;
<pre class="pre-238"><code>.root {&#13;
    margin: 0;&#13;
    padding: 0;&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 14-3: The</span> <span class="Futura_Std_Book_11">components/locations-list/index.module.css</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">The styles for the locations list component are simple; we remove the margin and padding from the component’s root element. We create the component itself in <a href="chapter14.xhtml#Lis14-4">Listing 14-4</a>, which you should copy to <i>index.tsx</i>.</p>&#13;
<span id="Lis14-4"/>&#13;
<pre class="pre-239"><code>import LocationsListItem from "components/locations-list-item";&#13;
import styles from "./index.module.css";&#13;
import {LocationType} from "mongoose/locations/schema";&#13;
&#13;
interface PropsInterface {&#13;
    locations: LocationType[];&#13;
}&#13;
&#13;
const LocationsList = (props: PropsInterface): JSX.Element =&gt; {&#13;
    return (&#13;
        &lt;ul className={styles.root}&gt;&#13;
            {props.locations.map((location) =&gt; {&#13;
                return (&#13;
                    &lt;LocationsListItem&#13;
                        location={location}&#13;
                        key={location.location_id}&#13;
                    /&gt;&#13;
                );&#13;
            })}&#13;
        &lt;/ul&gt;&#13;
    );&#13;
};&#13;
&#13;
export default LocationsList;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 14-4: The</span> <span class="Futura_Std_Book_11">components/locations-list/index.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationsListItem</samp> we just implemented, along with the module’s styles and the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationType</samp> from Mongoose’s schema. We then define the component’s <samp class="SANS_TheSansMonoCd_W5Regular_11">PropsInterface</samp> to describe the component’s <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> object. In the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationsList</samp> component, we use the array <samp class="SANS_TheSansMonoCd_W5Regular_11">map</samp> function to iterate over the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp> objects, rendering a <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationsListItem</samp> component for each array item and using the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp> attribute to pass the location details to the components. React requires that each item rendered in a loop have a unique ID. We use the location IDs for this purpose.</p>&#13;
<p class="TX">We can now create the start page and pass all available locations to this component. Later, we’ll use the same component for the wish list page to return the locations on the user’s wish list.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h4 class="H2"><span id="sec5"/><span id="h2-161"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Page</samp></h4>&#13;
<p class="TNI">At this point, we have the components we need for the start page, which is a basic Next.js page. Save this page’s global styles in <i>styles/globals.css</i> and its code in <i>pages/index.tsx</i>. <a href="chapter14.xhtml#Lis14-5">Listing 14-5</a> contains the styles. Delete all other files from the <i>styles</i> directory. Those are default styles we don’t need for the application.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_219" aria-label=" Page 219. "/>&#13;
<span id="Lis14-5"/>&#13;
<pre class="pre-240"><code>html,&#13;
body {&#13;
    font-family: -apple-system, Segoe UI, Roboto, sans-serif;&#13;
    margin: 0;&#13;
    padding: 0;&#13;
}&#13;
&#13;
* {&#13;
    box-sizing: border-box;&#13;
}&#13;
&#13;
h1 {&#13;
    font-size: 3rem;&#13;
}&#13;
&#13;
a {&#13;
    color: inherit;&#13;
    text-decoration: none;&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 14-5: The</span> <span class="Futura_Std_Book_11">styles/globals.css</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_220" aria-label=" Page 220. "/>We set a few global styles, such as the default font family, and change the box model to the more intuitive <samp class="SANS_TheSansMonoCd_W5Regular_11">border-box</samp> for all elements. By using a <samp class="SANS_TheSansMonoCd_W5Regular_11">border-box</samp> instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">content-box</samp>, an element adopts whatever width we assign to it with the <samp class="SANS_TheSansMonoCd_W5Regular_11">width</samp> property. Otherwise, the <samp class="SANS_TheSansMonoCd_W5Regular_11">width</samp> property would define only the width of the content, and we’d need to add the border and padding to calculate the actual dimensions of the element on the page. We set the font families to the defaults for each operating system to ensure readability.</p>&#13;
<p class="TX">Now replace the existing content of the <i>pages/index.tsx</i> file with the code in <a href="chapter14.xhtml#Lis14-6">Listing 14-6</a>.</p>&#13;
<span id="Lis14-6"/>&#13;
<pre class="pre-241"><code>import Head from "next/head";&#13;
import type {GetStaticProps, InferGetStaticPropsType, NextPage} from "next";&#13;
&#13;
import LocationsList from "components/locations-list";&#13;
import dbConnect from "middleware/db-connect";&#13;
import {findAllLocations} from "mongoose/locations/services";&#13;
import {LocationType} from "mongoose/locations/schema";&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> const Home: NextPage = (&#13;
    props: InferGetStaticPropsType&lt;typeof getStaticProps&gt;&#13;
) =&gt; {&#13;
&#13;
  <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> const locations: LocationType[] = JSON.parse(props.data?.locations);&#13;
    let title = `The Food Finder - Home`;&#13;
&#13;
    return (&#13;
        &lt;div&gt;&#13;
            &lt;Head&gt;&#13;
                &lt;title&gt;{title}&lt;/title&gt;&#13;
                &lt;meta name="description" content="The Food Finder - Home" /&gt;&#13;
            &lt;/Head&gt;&#13;
&#13;
            &lt;h1&gt;Welcome to the Food Finder!&lt;/h1&gt;&#13;
            &lt;LocationsList locations={locations} /&gt;&#13;
        &lt;/div&gt;&#13;
    );&#13;
};&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">❸</span> export const getStaticProps: GetStaticProps = async () =&gt; {&#13;
    let locations: LocationType[] | [];&#13;
    try {&#13;
        await dbConnect();&#13;
      <span class="CodeAnnotationCode" aria-label="annotation4">❹</span> locations = await findAllLocations();&#13;
    } catch (err: any) {&#13;
        return {notFound: true};&#13;
    }&#13;
  <span class="CodeAnnotationCode" aria-label="annotation5">❺</span> return {&#13;
        props: {&#13;
            data: {locations: JSON.stringify(locations)},&#13;
        },&#13;
    };&#13;
};&#13;
&#13;
export default Home;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 14-6: The</span> <span class="Futura_Std_Book_11">pages/index.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">We implemented the Next.js page, similar to the structure discussed in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>. First we import all dependencies; then we create the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp> and store it in a constant that we export at the end of the file <span class="AnnotationCode" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">The Next.js page’s <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> object, the page properties, contains the data we return from the <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp> function <span class="AnnotationCode" aria-label="annotation5">❺</span>, discussed in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>. In this asynchronous function, we connect to the database <span class="AnnotationCode" aria-label="annotation3">❸</span>. As soon as the connection is ready, we call the service method to retrieve all locations <span class="AnnotationCode" aria-label="annotation4">❹</span> and then pass them as a JSON string to the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">data.locations</samp> property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> object. Next.js calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp> function on build time and generates the HTML for this page only once. We can use this rendering method because the list of available locations never changes; it is static.</p>&#13;
<p class="TX">Then we retrieve the locations from the page properties <span class="AnnotationCode" aria-label="annotation2">❷</span>, parse the JSON string back to an array, and store the page title in a variable. We type the <samp class="SANS_TheSansMonoCd_W5Regular_11">locations</samp> constant explicitly because TSC cannot easily infer the type. Then we construct the JSX. In the first step, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/head</samp> component to set the page-specific metadata. Then we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationList</samp> component we previously implemented with the <samp class="SANS_TheSansMonoCd_W5Regular_11">locations</samp> array in the <samp class="SANS_TheSansMonoCd_W5Regular_11">locations</samp> attribute. By doing so, the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationList</samp> component renders all locations as an overview list.</p>&#13;
<p class="TX">As soon as you save the file, you should see, in the Docker command line, that Next.js recompiles the application. Open the web application at <i>http://localhost:3000</i> in your browser to see a list of locations similar to <a href="chapter14.xhtml#fig14-1">Figure 14-1</a>.</p>&#13;
&#13;
<figure class="IMG"><img class="img1" id="fig14-1" src="../images/Figure14-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 14-1: The start page showing all available locations</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_222" aria-label=" Page 222. "/>Now we’ll move on to styling the frontend and adding basic global components, such as the application’s header with the Food Finder logo.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H1"><span id="sec6"/><span id="h1-83"/><samp class="SANS_Futura_Std_Bold_B_11">The Global Layout Components</samp></h3>&#13;
<p class="TNI">Now it’s time to create the three global components. These include the overall layout component, which we’ll use to format the start and wish list page content, a <i>sticky</i> header (which is always visible, “sticking” to the browser’s upper edge), and the Food Finder logo to go in the header. Again, we’ll start with the smallest units and then use those as building blocks for the overall components.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h4 class="H2"><span id="sec7"/><span id="h2-162"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Logo</samp></h4>&#13;
<p class="TNI">The smallest component, the logo, is nothing more than a <samp class="SANS_TheSansMonoCd_W5Regular_11">next/image</samp> component wrapped in a <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp> element; when users click the logo image, they’ll be redirected to the start page. Add a <i>header</i> folder to the <i>components</i> folder, then add a <i>logo</i> folder to the <i>header</i> folder and create two files there, <i>index.tsx</i> and <i>index.module.css</i>, into which you should paste the code in <a href="chapter14.xhtml#Lis14-7">Listing 14-7</a>.</p>&#13;
<span id="Lis14-7"/>&#13;
<pre class="pre-242"><code>.root {&#13;
    display: inline-block;&#13;
    height: 35px;&#13;
    position: relative;&#13;
    width: 119px;&#13;
}&#13;
&#13;
@media (min-width: 600px) {&#13;
    .root {&#13;
        height: 50px;&#13;
        width: 169px;&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 14-7: The</span> <span class="Futura_Std_Book_11">components/header/logo/index.module.css</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">These basic styles for the component’s <samp class="SANS_TheSansMonoCd_W5Regular_11">root</samp> element set the image’s dimensions. We use a <i>mobile-first design pattern</i> by initially defining the styles to use on smaller screens and then, using a standard CSS media query, modifying them for screens bigger than 600px. We’ll use a bigger image on bigger screens.</p>&#13;
<p class="TX">Now let’s create the logo component. Create an <i>assets</i> subfolder in the Next.js <i>public</i> folder and place the <i>logo.svg</i> file extracted from <i>assets.zip</i> into it. Then add the code in <a href="chapter14.xhtml#Lis14-8">Listing 14-8</a> to the logo’s <i>index.tsx</i> file.</p>&#13;
<span id="Lis14-8"/>&#13;
<pre class="pre-243"><code>import Image from "next/image";&#13;
import Link from "next/link";&#13;
import logo from "/public/assets/logo.svg";&#13;
import styles from "./index.module.css";&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_223" aria-label=" Page 223. "/>const Logo = (): JSX.Element =&gt; {&#13;
    return (&#13;
        &lt;Link href="/" passHref className={styles.root}&gt;&#13;
            &lt;Image&#13;
                src={logo}&#13;
                alt="Logo: Food Finder"&#13;
                sizes="100vw"&#13;
                fill&#13;
                priority&#13;
            /&gt;&#13;
        &lt;/Link&gt;&#13;
    );&#13;
};&#13;
&#13;
export default Logo;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 14-8: The</span> <span class="Futura_Std_Book_11">components/header/logo/index.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">As usual, we import the dependencies and then create an exported constant that contains the JSX code. We don’t pass any data to it through attributes or child elements; hence, we don’t need to define the component’s <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> object here.</p>&#13;
<p class="TX">We use a basic <samp class="SANS_TheSansMonoCd_W5Regular_11">next/image</samp> inside a <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp> element to link back to the start page and set the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/image</samp>’s attributes to fill the available space defined in the CSS file.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h4 class="H2"><span id="sec8"/><span id="h2-163"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Header</samp></h4>&#13;
<p class="TNI">The header component will wrap the logo component we just created. Create the <i>index.tsx</i> file and <i>index.module.css</i> file in the <i>header</i> folder, then add the code in <a href="chapter14.xhtml#Lis14-9">Listing 14-9</a> to the CSS file.</p>&#13;
<span id="Lis14-9"/>&#13;
<pre class="pre-244"><code>.root {&#13;
    background: white;&#13;
    border-bottom: 1px solid #eaeaea;&#13;
    padding: 1rem 0;&#13;
    position: sticky;&#13;
    top: 0;&#13;
    width: 100%;&#13;
    z-index: 1;&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 14-9: The</span> <span class="Futura_Std_Book_11">components/header/index.module.css</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">We use the CSS definitions <samp class="SANS_TheSansMonoCd_W5Regular_11">position: sticky</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">top: 0</samp> to stick the header to the upper edge of the browser. Now the header will automatically stay there even when users scroll down the page; the page’s content should scroll below the header because we set the header’s <samp class="SANS_TheSansMonoCd_W5Regular_11">z-index</samp>, placing the header in front of the other elements. You can think of the <samp class="SANS_TheSansMonoCd_W5Regular_11">z-index</samp> as determining which floor of a building an element is on.</p>&#13;
<p class="TX"><a href="chapter14.xhtml#Lis14-10">Listing 14-10</a> shows the code for the header component. Copy it into the component’s <i>index.tsx</i> file.</p>&#13;
<span id="Lis14-10"/>&#13;
<pre class="pre-245"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_224" aria-label=" Page 224. "/>import styles from "./index.module.css";&#13;
import Logo from "components/header/logo";&#13;
&#13;
const Header = (): JSX.Element =&gt; {&#13;
    return (&#13;
        &lt;header className={styles.root}&gt;&#13;
            &lt;div className="layout-grid"&gt;&#13;
                &lt;Logo /&gt;&#13;
            &lt;/div&gt;&#13;
        &lt;/header&gt;&#13;
    );&#13;
};&#13;
&#13;
export default Header;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 14-10: The</span> <span class="Futura_Std_Book_11">components/header/index.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">We define a basic component that displays the logo. Then we wrap the imported <samp class="SANS_TheSansMonoCd_W5Regular_11">Logo</samp> component in an element with a global <samp class="SANS_TheSansMonoCd_W5Regular_11">layout-grid</samp> class, which we’ll define in the next section.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h4 class="H2"><span id="sec9"/><span id="h2-164"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Layout</samp></h4>&#13;
<p class="TNI">Currently, we have one Next.js page (the start page) and a header component. The easiest way to add the header to the page would be to import it into the Next.js page and place it directly into the JSX. However, we’ll add two more pages to the app, the wish list page and the location detail page, so we want to avoid importing the header three times.</p>&#13;
<p class="TX">To streamline the overall app design, Next.js provides the concept of a <i>layout</i>, which is really just another component, and we can use it to add the header component as a sibling element to a page’s content. Let’s create a new layout component. First, to create this component’s CSS file, add <i>layout.css</i> to the <i>styles</i> folder and paste the code in <a href="chapter14.xhtml#Lis14-11">Listing 14-11</a> into it.</p>&#13;
<span id="Lis14-11"/>&#13;
<pre class="pre-246"><code>.layout-grid {&#13;
    align-items: center;&#13;
    display: flex;&#13;
    flex-direction: column;&#13;
    justify-content: space-between;&#13;
    margin: 0 auto;&#13;
    max-width: 800px;&#13;
    padding: 0 1rem;&#13;
    width: 100%;&#13;
}&#13;
&#13;
@media (min-width: 600px) {&#13;
    .layout-grid {&#13;
        flex-direction: row;&#13;
        padding: 0 2rem;&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 14-11: The</span> <span class="Futura_Std_Book_11">styles/layout.css</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_225" aria-label=" Page 225. "/>We use the mobile-first pattern once again to define a basic grid wrapper, setting the global padding and maximum width for the content area. We set the wrapper’s left and right <samp class="SANS_TheSansMonoCd_W5Regular_11">margin</samp>s to <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>, which centers the container, because the margins take up all available space between the fixed-width wrapper and the window’s edges.</p>&#13;
<p class="TX">We use <samp class="SANS_TheSansMonoCd_W5Regular_11">flexbox</samp> to set the direction of the wrapper’s direct child elements to <samp class="SANS_TheSansMonoCd_W5Regular_11">column</samp>, displaying them one on top of the next. Because the logo and all other upcoming header elements are direct children of an element with the <samp class="SANS_TheSansMonoCd_W5Regular_11">layout-grid</samp> class, they are affected by the <samp class="SANS_TheSansMonoCd_W5Regular_11">flexbox</samp> layout. In contrast, the location items aren’t direct siblings. Hence, they won’t change their direction when switching between screen sizes.</p>&#13;
<p class="TX">Then we use a media query to adjust the styles for screens whose width is greater than 600px. Here we increase the padding and change the layout order of the direct child elements. Instead of using <samp class="SANS_TheSansMonoCd_W5Regular_11">column</samp>, we set it to <samp class="SANS_TheSansMonoCd_W5Regular_11">row</samp>, and immediately we display the elements next to one another.</p>&#13;
<p class="TX">Because this is a global styles file and not a CSS module, Next.js won’t automatically scope the class names. Hence, we prefix them with <samp class="SANS_TheSansMonoCd_W5Regular_11">layout-</samp> and don’t import the styles into the component before using them.</p>&#13;
<p class="TX">Now create a <i>layout</i> folder inside the <i>components</i> folder and add the <i>index.tsx</i> file to it with the component code in <a href="chapter14.xhtml#Lis14-12">Listing 14-12</a>.</p>&#13;
<span id="Lis14-12"/>&#13;
<pre class="pre-247"><code>import Header from "components/header";&#13;
&#13;
interface PropsInterface {&#13;
    children: React.ReactNode;&#13;
}&#13;
&#13;
const Layout = (props: PropsInterface): JSX.Element =&gt; {&#13;
    return (&#13;
        &lt;&gt;&#13;
            &lt;Header /&gt;&#13;
            &lt;main className="layout-grid"&gt;&#13;
                {props.children}&#13;
            &lt;/main&gt;&#13;
        &lt;/&gt;&#13;
    );&#13;
};&#13;
export default Layout;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 14-12: The</span> <span class="Futura_Std_Book_11">components/layout/index.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">In the layout component, we define a private interface and the component with the usual structure. Inside the component, we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">Header</samp> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> element that uses the global layout styles and acts as a wrapper for the <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp> elements we’ll pass to this component in the <i>_app.tsx</i> file.</p>&#13;
<p class="TX">Open the <i>_app.tsx</i> file and modify it as shown in <a href="chapter14.xhtml#Lis14-13">Listing 14-13</a>.</p>&#13;
<span id="Lis14-13"/>&#13;
<pre class="pre-248"><code>import "../styles/globals.css";&#13;
<b>import "../styles/layout.css";</b>&#13;
import type {AppProps} from "next/app";&#13;
<b>import Layout from "components/layout";</b>&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_226" aria-label=" Page 226. "/>export default function App({Component, pageProps}: AppProps) {&#13;
    return (&#13;
<b>        &lt;Layout&gt;</b>&#13;
            &lt;Component {...pageProps} /&gt;&#13;
<b>        &lt;</b><b>/Layout&gt;</b>&#13;
    );&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 14-13: The</span> <span class="Futura_Std_Book_11">pages/_app.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">First we add <i>layout.css</i> as a global style. As for the layout, we have only one <samp class="SANS_TheSansMonoCd_W5Regular_11">layout</samp> component we’ll use for all pages, and we import it here. Then we wrap our application, the pages, with the layout and pass the current page in the component’s <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp> property.</p>&#13;
<p class="TX">Now all our Next.js pages will follow the same structure: they’ll have the <samp class="SANS_TheSansMonoCd_W5Regular_11">Header</samp> component next to the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> element containing the page’s content. One advantage of following this pattern is that the component’s state will be preserved across page changes and React component re-rendering.</p>&#13;
<p class="TX">Once Next.js has recompiled the application, try reloading the application at <i>http://localhost:3000</i> in your browser. It should look like <a href="chapter14.xhtml#fig14-2">Figure 14-2</a>.</p>&#13;
&#13;
<figure class="IMG"><img class="img1" id="fig14-2" src="../images/Figure14-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 14-2: The start page with the header and layout component</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You should now see the header, and the new layout component centers the content.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h3 class="H1"><span id="sec10"/><span id="h1-84"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_227" aria-label=" Page 227. "/><samp class="SANS_Futura_Std_Bold_B_11">The Location Details Page</samp></h3>&#13;
<p class="TNI">Our application now has a start page with a header and a list of all available locations. The list items link to their particular location’s detail page because we added a <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp> component to them, but those pages don’t exist yet. If you click one of the links, you’ll get a <i>404</i> error. To display the location details pages, we first need to implement the component that lists a particular location’s details and then create a new Next.js page.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h4 class="H2"><span id="sec11"/><span id="h2-165"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Component</samp></h4>&#13;
<p class="TNI">Let’s start with the details component. Create the <i>location-details</i> folder in the <i>components</i> directory and add the <i>index.module.css</i> and <i>index.tsx</i> files to it. Then add the code from <a href="chapter14.xhtml#Lis14-14">Listing 14-14</a> to the CSS module.</p>&#13;
<span id="Lis14-14"/>&#13;
<pre class="pre-249"><code>.root {&#13;
    margin: 0 0 2rem 0;&#13;
    padding: 0;&#13;
}&#13;
.root li {&#13;
    list-style: none;&#13;
    margin: 0 0 0.5rem 0;&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 14-14: The</span> <span class="Futura_Std_Book_11">components/locations-details/index.module.css</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">The styles for the component are basic. We remove the default margin and padding, as well as the list styles, and then add a custom margin at the end of each list item and root element.</p>&#13;
<p class="TX">To implement the location details component, add the code from <a href="chapter14.xhtml#Lis14-15">Listing 14-15</a> to the <i>index.tsx</i> file in the <i>components/locations-details</i> folder.</p>&#13;
<span id="Lis14-15"/>&#13;
<pre class="pre-250"><code>import {LocationType} from "mongoose/locations/schema";&#13;
import styles from "./index.module.css";&#13;
&#13;
interface PropsInterface {&#13;
    location: LocationType;&#13;
}&#13;
&#13;
const LocationDetail = (props: PropsInterface): JSX.Element =&gt; {&#13;
    let location = props.location;&#13;
    return (&#13;
        &lt;div&gt;&#13;
            {location &amp;&amp; (&#13;
                &lt;ul className={styles.root}&gt;&#13;
                    &lt;li&gt;&#13;
                        &lt;b&gt;Address: &lt;/b&gt;&#13;
                        {location.address}&#13;
                    &lt;/li&gt;&#13;
                    &lt;li&gt;&#13;
                        &lt;b&gt;Zipcode: &lt;/b&gt;&#13;
                        {location.zipcode}&#13;
                    &lt;/li&gt;&#13;
                    &lt;li&gt;&#13;
                        &lt;b&gt;Borough: &lt;/b&gt;&#13;
                        {location.borough}&#13;
                    &lt;/li&gt;&#13;
                    &lt;li&gt;&#13;
                        &lt;b&gt;Cuisine: &lt;/b&gt;&#13;
                        {location.cuisine}&#13;
                    &lt;/li&gt;&#13;
                    &lt;li&gt;&#13;
                        &lt;b&gt;Grade: &lt;/b&gt;&#13;
                        {location.grade}&#13;
                    &lt;/li&gt;&#13;
                &lt;/ul&gt;&#13;
            )}&#13;
        &lt;/div&gt;&#13;
    );&#13;
};&#13;
export default LocationDetail;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 14-15: The</span> <span class="Futura_Std_Book_11">components/locations-details/index.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">The locations detail component is structurally similar to the locations list item. Both take an object containing the location’s data and add a specific set of properties to the returned JSX element. The main difference is in the JSX structure we create. Otherwise, we follow the known pattern, importing the required styles and type, defining the component’s <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> interface using the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationType</samp>, and then returning a JSX element with the location details.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h4 class="H2"><span id="sec12"/><span id="h2-166"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Page</samp></h4>&#13;
<p class="TNI">We mentioned in <span class="Xref">“Overview of the User Interface” on page 215</span> that a location’s detail page should be available at the dynamic URL <i>location/:location"ePub-I"&gt;location</i> folder in the <i>pages</i> directory and add the <i>[locationId].tsx</i> file containing the code in <a href="chapter14.xhtml#Lis14-16">Listing 14-16</a>.</p>&#13;
<span id="Lis14-16"/>&#13;
<pre class="pre-251"><code>import Head from "next/head";&#13;
import type {&#13;
    GetServerSideProps,&#13;
    GetServerSidePropsContext,&#13;
    InferGetServerSidePropsType,&#13;
    PreviewData,&#13;
    NextPage,&#13;
} from "next";&#13;
import LocationDetail from "components/location-details";&#13;
import dbConnect from "middleware/db-connect";&#13;
import {findLocationsById} from "mongoose/locations/services";&#13;
import {LocationType} from "mongoose/locations/schema";&#13;
import {ParsedUrlQuery} from "querystring";&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_229" aria-label=" Page 229. "/>const Location: NextPage = (&#13;
    props: InferGetServerSidePropsType&lt;typeof getServerSideProps&gt;&#13;
) =&gt; {&#13;
    let location: LocationType = JSON.parse(props.data?.location);&#13;
  <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> let title = `The Food Finder - Details for ${location?.name}`;&#13;
    return (&#13;
        &lt;div&gt;&#13;
            &lt;Head&gt;&#13;
                &lt;title&gt;{title}&lt;/title&gt;&#13;
                &lt;meta&#13;
                    name="description"&#13;
                    content={`The Food Finder. &#13;
                        Details for ${location?.name}`}&#13;
                /&gt;&#13;
            &lt;/Head&gt;&#13;
            &lt;h1&gt;{location?.name}&lt;/h1&gt;&#13;
          <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> &lt;LocationDetail location={location} /&gt;&#13;
        &lt;/div&gt;&#13;
    );&#13;
};&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">❸</span> export const getServerSideProps: GetServerSideProps = async (&#13;
    context: GetServerSidePropsContext&lt;ParsedUrlQuery, PreviewData&gt;&#13;
) =&gt; {&#13;
     let locations: LocationType[] | [];&#13;
  <span class="CodeAnnotationCode" aria-label="annotation4">❹</span> let {locationId} = context.query;&#13;
     try {&#13;
        await dbConnect();&#13;
        locations = await findLocationsById([locationId as string]);&#13;
      <span class="CodeAnnotationCode" aria-label="annotation5">❺</span> if (!locations.length) {&#13;
            throw new Error(`Locations ${locationId} not found`);&#13;
        }&#13;
    } catch (err: any) {&#13;
        return {&#13;
            notFound: true,&#13;
        };&#13;
    }&#13;
    return {&#13;
      <span class="CodeAnnotationCode" aria-label="annotation6">❻</span> props: {data: {location: JSON.stringify(locations.pop())}},&#13;
    };&#13;
};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 14-16: The</span> <span class="Futura_Std_Book_11">pages/location/[locationId].tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">The start page and location detail page look fairly similar. The only visual difference is the page’s title, which we construct with the location’s name <span class="AnnotationCode" aria-label="annotation1">❶</span>, and instead of the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationsList</samp> component, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationDetail</samp> component with a single location object <span class="AnnotationCode" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">From a functional perspective, however, the pages are not similar. Unlike the start page, which uses SSG, the location detail page uses SSR with <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProp</samp> <span class="AnnotationCode" aria-label="annotation3">❸</span>. This is because as soon as we add the wish list functionality and implement the Add To/Remove button, the page’s <span role="doc-pagebreak" epub:type="pagebreak" id="pg_230" aria-label=" Page 230. "/>content should change along with a user’s action. Hence, we need to regenerate the HTML on each request. We discussed the differences between SSR and SSG in depth in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>.</p>&#13;
<p class="TX">We use the page’s <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp> and its <samp class="SANS_TheSansMonoCd_W5Regular_11">query</samp> property to get the location ID from the dynamic URL <span class="AnnotationCode" aria-label="annotation4">❹</span>. Then we use the ID to get the matching location from the database. As before, we use the service directly instead of calling the publicly exposed API, as Next.js runs both <samp class="SANS_TheSansMonoCd_W5Regular_11">get...Prop</samp> functions on the server side and can directly access the services in our application’s middleware.</p>&#13;
<p class="TX">We also implement two exit scenarios. First, if there is no result, we throw an error to step into the <samp class="SANS_TheSansMonoCd_W5Regular_11">catch</samp> block <span class="AnnotationCode" aria-label="annotation5">❺</span>, and by doing so, redirect the user to the <i>404 Not Found</i> error page. Otherwise, we store the first location from the results in the location property <span class="AnnotationCode" aria-label="annotation6">❻</span> and pass it to the Next.js page function we export in the last line.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h3 class="H1"><span id="sec13"/><span id="h1-85"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">We’ve successfully built the frontend for the Food Finder application. At this point, you’ve implemented a full-stack web application that reads data from a MongoDB database and renders the results as React user interface components in Next.js. Next, we’ll add an OAuth authentication flow with GitHub so that users can log in with their GitHub account and store a personalized wish list.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>