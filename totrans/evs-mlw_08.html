<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch6">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_103" aria-label="103"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch6">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">ENUMERATING HARDWARE AND NETWORK CONFIGURATIONS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="TNI2">Hardware information, such as CPU speed and RAM allotment, and networking configurations, such as the MAC and IP addresses of the host’s network interfaces, can indicate to malware that it’s operating in a lab environment. Additionally, malware can use these pieces of information to establish context within its operating environment. In this chapter, we’ll discuss the techniques that malware might use to gather this information and evade detection.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-74"/><samp class="SANS_Futura_Std_Bold_B_11">Hardware and Device Configurations</samp></h3>&#13;
<p class="TNI1">System hardware configurations can provide valuable information to a malware sample that it can use to determine whether it’s running in a VM or <span role="doc-pagebreak" epub:type="pagebreak" id="pg_104" aria-label="104"/>sandbox. VMs use emulated hardware that can easily be differentiated from real hardware, and they are often configured much differently from physical systems. The malware can also enumerate hardware information, like the number of processors, the amount of RAM installed in the system, the hard drive storage capacity, and more. In this section, we’ll explore each of these areas in turn.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h-75"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">CPU</samp></h4>&#13;
<p class="TNI1">Because virtualized CPUs look a bit different from their physical counterparts, malware will often check the host’s processor to determine the context in which it’s running. There are a few ways the malware can retrieve CPU hardware information. One of the more common approaches is calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetSystemInfo</samp> function to get the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwNumberOfProcessors</samp> value, which represents how many processors the system has. Modern computer systems almost always have more than one processor and processor core. To determine whether it’s running on a virtual machine, the malware might check whether the host has fewer than two processor cores, like so:</p>&#13;
<pre class="pre-30"><code>SYSTEM_INFO systemInfo;&#13;
GetSystemInfo(systemInfo);&#13;
int numProcessors = systemInfo.dwNumberOfProcessors;&#13;
if numProcessors &lt; 2 {&#13;
  KillSelf()&#13;
}</code></pre>&#13;
<p class="TX">In this pseudocode, the sample defines a struct (<samp class="SANS_TheSansMonoCd_W5Regular_11">systemInfo</samp>), then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetSystemInfo</samp>. A <i>struct</i>, short for structure, is a data type that allows for grouping of other data under a single name. All of the information returned from the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetSystemInfo</samp> function will be stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">systemInfo</samp> struct. The malware then inspects the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwNumberOfProcessors</samp> value in the struct and, if the <samp class="SANS_TheSansMonoCd_W5Regular_11">numProcessors</samp> value is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, will terminate itself.</p>&#13;
<p class="TX">Similarly, a malware sample can call the following functions to return information it can use to infer the environment it’s running in:</p>&#13;
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">GetLogicalProcessorInformation</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11"> </samp>Returns processor core information.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">GetNativeSystemInfo </samp>Returns similar information as <samp class="SANS_TheSansMonoCd_W5Regular_11">GetSystemInfo</samp>, but is normally invoked by 64-bit applications.</p>&#13;
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">IsProcessorFeaturePresent </samp>Returns the status of various processor features. If it returns true for <samp class="SANS_TheSansMonoCd_W5Regular_11">PF_VIRT_FIRMWARE_ENABLED</samp>, the system is using virtual firmware, an obvious clue that the system is likely virtualized.</p>&#13;
<p class="TX">The Process Environment Block can also be used for CPU enumeration. To recap from <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, the PEB structure consists of pointers to other structures in memory that contain information about the currently running process. The following code shows how malware can search the PEB to retrieve CPU information:</p>&#13;
<pre class="pre-31"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_105" aria-label="105"/>mov eax, dword ptr fs:[0x30]&#13;
mov edx, dword ptr ds:[eax+0x64]&#13;
cmp edx, 1&#13;
je terminate_process</code></pre>&#13;
<p class="TX">The sample moves the address of the PEB (stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">fs:[0x30]</samp>) into the <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> register, then puts the specific offset of the PEB in which the malware is interested (<samp class="SANS_TheSansMonoCd_W5Regular_11">[eax+0x64]</samp>) in the <samp class="SANS_TheSansMonoCd_W5Regular_11">edx</samp> register. Offset 0x64 in the PEB structure stores the number of processor cores configured on the system. If the number of processor cores is <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, the malware terminates itself by jumping to the <samp class="SANS_TheSansMonoCd_W5Regular_11">terminate_process</samp> function.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>For 64-bit processes, the address of the PEB will be in the gs register at <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">gs:[0x60]</samp>, so be on the lookout for malware referencing this address as well.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h-76"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">RAM</samp></h4>&#13;
<p class="TNI1">Modern computers typically have a minimum of 4GB of RAM, but some malware analysis environments and sandboxes may not have this amount. If the installed RAM is below the 4GB threshold (or similar), the malware might assume it is running in a virtual environment. To check this, the malware calls the Windows function <samp class="SANS_TheSansMonoCd_W5Regular_11">GetPhysicallyInstalledSystemMemory</samp> to return the amount of system memory, like so:</p>&#13;
<pre class="pre-32"><code>lea ecx, [ebp+TotalMemoryInKilobytes]&#13;
call GetPhysicallyInstalledSystemMemory&#13;
cmp ecx, 4194302&#13;
jl  terminate_process</code></pre>&#13;
<p class="TX">Here the malware sample calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetPhysicallyInstalledSystemMemory</samp> function with <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalMemoryInKilobytes</samp> as a parameter, which will store the total system memory value returned from the function. After the function call, the malware compares the <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalMemoryInKilobytes</samp> value with <samp class="SANS_TheSansMonoCd_W5Regular_11">4194302</samp>, which is 4,194,302 kilobytes, or 4GB. If the amount of system RAM is lower than 4GB, the malware sample will jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">terminate_process</samp> and delete itself.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h-77"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hard Disks</samp></h4>&#13;
<p class="TNI1">Most modern computers are allotted hundreds of gigabytes of storage space. Malware can query the storage capacity of the hard disks, and if that value is below a certain threshold, it might determine that it’s running in a virtual environment. This threshold is typically 40GB, 60GB, or 80GB, but this number may increase as average storage capacity grows.</p>&#13;
<p class="TX">The most common Windows functions used for gathering hard disk and capacity information are <samp class="SANS_TheSansMonoCd_W5Regular_11">GetDiskFreeSpace</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetDiskFreeSpaceEx</samp>. Other than evasion, there are limited reasons why malware would be querying the hard disk space, so these functions should raise a red flag for you. An easy <span role="doc-pagebreak" epub:type="pagebreak" id="pg_106" aria-label="106"/>way to bypass this evasion tactic is to increase the size of your VM disks to more than 40GB or, even better, 80GB.</p>&#13;
<p class="TX">Windows contains many API functions that are not well known and are less commonly used. One example is the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsNativeVhdBoot</samp> function:</p>&#13;
<pre class="pre-33"><code>call IsNativeVhdBoot&#13;
test eax, 0&#13;
jne loc_403DDD</code></pre>&#13;
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">IsNativeVhdBoot</samp> doesn’t return <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, the system was booted from a virtual hard disk, which indicates a VM. Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsNativeVhdBoot</samp> function is effective only on Windows 8 and above.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h-78"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Monitor Configurations</samp></h4>&#13;
<p class="TNI1">A typical modern computer setup will likely have a high-resolution monitor and sometimes more than one, whereas (most) VMs and sandboxes will not. Some malware specifically looks for the number of monitors in use, and if it detects, say, only one monitor, it might infer that it’s in an analysis environment. To accomplish this, it can call the Windows API function <samp class="SANS_TheSansMonoCd_W5Regular_11">GetSystemMetrics</samp>, which returns a specific variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">SM_CMONITORS</samp> representing the number of monitors in use. Another option is to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumDisplayMonitors</samp> function, which doesn’t return the total number directly but instead executes a callback function for each monitor. A <i>callback function</i> is simply a way of performing tasks for each object—in this case, a monitor—that invokes it.</p>&#13;
<p class="TX">Malware can also check screen resolution using the same functions. The typical resolution for a non-virtualized end-user system is quite high, such as 1,600 × 900. If the display resolution of your analysis machine is lower (say, 1,152 × 864), malware might note this.</p>&#13;
<aside class="box" aria-label="box-5">&#13;
<p class="BoxTitle" id="box-5"><samp class="SANS_Dogma_OT_Bold_B_11">THE GETSYSTEMMETRICS FUNCTION</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_TheSansMonoCd_W5Regular_11">GetSystemMetrics</samp> <samp class="SANS_Futura_Std_Book_11">returns a lot of useful information that malware can take advantage of, both for VM and sandbox detection and for general system enumeration. Here’s just a sampling of information it returns:</samp></p>&#13;
<p class="BoxRunInPara"><span class="BoxRunInHead"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SM_CMONITORS </samp><samp class="SANS_Futura_Std_Book_11">The number of display monitors configured</samp></span></p>&#13;
<p class="BoxRunInPara"><span class="BoxRunInHead"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SM_CMOUSEBUTTONS </samp></span><samp class="SANS_Futura_Std_Book_11">The number of mouse buttons (returns 0 if no mouse is installed)</samp></p>&#13;
<p class="BoxRunInPara"><span class="BoxRunInHead"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SM_CXSCREEN </samp><samp class="SANS_Futura_Std_Book_11">The pixel width of the screen</samp></span></p>&#13;
<p class="BoxRunInPara"><span class="BoxRunInHead"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SM_CYSCREEN </samp><samp class="SANS_Futura_Std_Book_11">The pixel height of the screen</samp></span></p>&#13;
<p class="BoxRunInPara"><span class="BoxRunInHead"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SM_MIDEASTENABLED</samp></span><samp class="SANS_Futura_Std_Book_11"> Middle Eastern language configuration (returns a nonzero value if the system is configured for Hebrew or Arabic)</samp></p>&#13;
<p class="BoxRunInPara"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_107" aria-label="107"/><span class="BoxRunInHead"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SM_MOUSEPRESENT </samp></span><samp class="SANS_Futura_Std_Book_11">The presence of a mouse (returns 0 if one isn’t installed)</samp></p>&#13;
<p class="BoxRunInPara"><span class="BoxRunInHead"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SM_NETWORK </samp></span> <samp class="SANS_Futura_Std_Book_11">The presence of a network (if present, the least significant bit is set; if not, bits are cleared)</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h-79"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">USB Controllers</samp></h4>&#13;
<p class="TNI1">Many VMs are configured to use either an older USB protocol version (V1.1 or V2.0, for example) or no USB controller device at all. Because most modern non-virtualized systems have at least one USB controller with an up-to-date USB device version, this can be a good clue for malware.</p>&#13;
<p class="TX">Windows provides a helpful API just for enumeration of USB devices and settings: <i>Winusb.dll</i>. If you spot malware attempting to import this DLL and use its functions, it’s a strong indicator that something fishy is going on.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h-80"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Firmware Tables</samp></h4>&#13;
<p class="TNI1">Most system hardware is accompanied by low-level software known as <i>firmware</i>. Firmware breathes life into the hardware; without it, the hardware couldn’t interface with the OS or any other programs. Windows keeps track of firmware in <i>firmware tables</i> that also contain the make and model of the associated hardware, which malware can exploit to identify any hypervisor-related information.</p>&#13;
<p class="TX">Let’s take a look at a firmware table. <a href="chapter6.xhtml#fig6-1">Figure 6-1</a> shows the output on my VM of Nirsoft’s free tool FirmwareTablesView.</p>&#13;
<figure class="IMG"><img class="img100" id="fig6-1" src="../images/fig6-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: Firmware tables displayed in FirmwareTablesView</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You can likely already spot the anomalies that a malware sample could take advantage of. There are multiple references to <i>VBOX</i>, which is the standard prefix for VirtualBox hypervisor firmware.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_108" aria-label="108"/>In the Firmware column, you can see the type of each firmware table, also called the <i>provider signature</i>: ACPI, SMBIOS, or Raw. Some functions, like <samp class="SANS_TheSansMonoCd_W5Regular_11">GetSystemFirmwareTable</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumSystemFirmwareTables</samp>, require a provider signature to retrieve firmware tables. The following code shows a piece of malware calling <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumSystemFirmwareTables</samp> to inspect the ACPI tables:</p>&#13;
<pre class="pre-34"><code>loc_10001300:&#13;
push  [esp+38h+BufferSize] ; BufferSize&#13;
push  esi                  ; pFirmwareTableEnumBuffer&#13;
push  'ACPI'               ; FirmwareTableProviderSignature&#13;
call  EnumSystemFirmwareTables&#13;
cmp   [esp+38h+BufferSize], eax</code></pre>&#13;
<p class="TX">Later, this malware will search the buffer storing the firmware tables for hypervisor-related strings like <samp class="SANS_TheSansMonoCd_W5Regular_11">Oracle</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Vbox</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualBox</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">VMware</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">VMware, Inc</samp>.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp> function also returns a lot of different system information, for both malicious and legitimate reasons. Malware can use this function to enumerate firmware tables. Here’s what this might look like:</p>&#13;
<pre class="pre-35"><code>push  [ebp+Length]  ; SystemInformationLength&#13;
push  eax           ; SystemFirmwareTableInformation&#13;
push  76            ; SystemInformationClass&#13;
call  NtQuerySystemInformation</code></pre>&#13;
<p class="TX">The malware calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp> function with a few important parameters. The first parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemInformationLength</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">[ebp+Length]</samp>), is the size of the buffer that will receive the data returned from the function call. The second parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemFirmwareTableInformation</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>), is a pointer to that buffer. The third parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">76</samp>, represents the system information class that this malware is interested in, <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemFirmwareTableInformation</samp>. After the malware calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp> function and the firmware table structure is stored in the buffer, it can enumerate the buffer for hypervisor-related information.</p>&#13;
<p class="TX">Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemFirmwareTableInformation</samp> data class is undocumented by Microsoft, so there isn’t much public information about it. Microsoft keeps certain functionalities internal, likely so that they can’t be easily abused, but malware authors and researchers will inevitably find them. Conix Cybers<span class="accent">é</span>curit<span class="accent">é</span> has compiled a complete list of the data classes that <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp> can return at <a href="https://github.com/conix-security/zer0m0n/blob/master/src/driver/include/nt/structures/SYSTEM_INFORMATION_CLASS.h"><i>https://<wbr/>github<wbr/>.com<wbr/>/conix<wbr/>-security<wbr/>/zer0m0n<wbr/>/blob<wbr/>/master<wbr/>/src<wbr/>/driver<wbr/>/include<wbr/>/nt<wbr/>/structures<wbr/>/SYSTEM<wbr/>_INFORMATION<wbr/>_CLASS<wbr/>.h</i></a>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h-81"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Other Hardware Devices</samp></h4>&#13;
<p class="TNI1">Examples of other hardware configurations that malware might use to obtain information about its environment are CD or DVD drives, sound cards and audio configurations, attached printers (or the lack thereof), and serial ports. We’ll go over some more of these settings in <span class="Xref"><a href="appendix-A.xhtml">Appendix A</a></span>, but because malware could enumerate any and all hardware configurations on the victim system, it’s impossible to include all of them in this book.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_109" aria-label="109"/>Next, we’ll turn our attention to the networking-related information that malware might use to suss out a VM or sandbox environment.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1" id="sec9"><span id="h-82"/><samp class="SANS_Futura_Std_Bold_B_11">Networking-Related Artifacts</samp></h3>&#13;
<p class="TNI1">Networking-related artifacts such as IP address configurations, currently established connections, open service ports, and even the domain that the victim system is joined to can help malware detect its operating environment. In this section, you’ll learn how.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h-83"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">IP Address Configurations</samp></h4>&#13;
<p class="TNI1">Malware may want to get the host’s IP address for a number of reasons, most notably to detect if the host is running in a sandbox or malware analysis lab. The default IP address range for internal VirtualBox networks is 192.168.56.<i>X</i>. The default IP range for VMware Workstation is 192.168.<i>X.X</i>, with the last two octets being randomized (such as 192.168.5.100, or 192.168.187.101). The range depends on what version of the hypervisor software the system is running. If the victim system has an IP address in these ranges, the malware might either determine it’s a VM or further scrutinize the system.</p>&#13;
<p class="TX">Retrieving the IP address of the host is as simple as leveraging the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAdaptersAddresses</samp> function:</p>&#13;
<pre class="pre-36"><code>push edx ; AdapterAddresses structure&#13;
push 0   ; Reserved parameter&#13;
push 0   ; Flags parameter&#13;
push 2   ; Family parameter&#13;
call GetAdaptersAddresses&#13;
<var>--snip--</var>&#13;
mov eax, [ebp+AdapterAddresses.FirstUnicastAddress]&#13;
mov edx, [ebp+bad_ip_address]&#13;
cmp eax, edx&#13;
jnz terminate_process</code></pre>&#13;
<p class="TX">Like many Windows API functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAdaptersAddresses</samp> takes a series of parameters. In this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">push edx</samp> pushes to the stack the address of the buffer <samp class="SANS_TheSansMonoCd_W5Regular_11">AdapterAddresses</samp>, which will hold all the address data returned from the function call. The next three instructions push the <samp class="SANS_TheSansMonoCd_W5Regular_11">reserved</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">flags</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">family</samp> parameters. The most important is the <samp class="SANS_TheSansMonoCd_W5Regular_11">family</samp> parameter, which contains a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, telling <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAdaptersAddresses</samp> to return only IPv4 information. <a href="chapter6.xhtml#tab6-1">Table 6-1</a> lists the definitions of each <samp class="SANS_TheSansMonoCd_W5Regular_11">family</samp> parameter value.</p>&#13;
<p class="TT" id="tab6-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 6-1:</samp></span> <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAdaptersAddresses family</samp> <samp class="SANS_Futura_Std_Book_11">Parameter Values</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">ASCII value</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Numerical value</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Definition</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">AF_UNSPEC</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Returns both IPv4 and IPv6 addresses</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">AF_INET</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Returns only IPv4 addresses</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">AF_INET6</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">23</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Returns only IPv6 addresses</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_110" aria-label="110"/>Next, the malware calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAdaptersAddresses</samp> function. Later in the code, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">AdapterAddresses.FirstUnicastAddress</samp> is moved into <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>, and the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">bad_ip_address</samp> is moved into <samp class="SANS_TheSansMonoCd_W5Regular_11">edx</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">FirstUnicastAddress</samp> variable is part of <samp class="SANS_TheSansMonoCd_W5Regular_11">AdapterAddresses</samp> and contains the first IP address in the structure. The <samp class="SANS_TheSansMonoCd_W5Regular_11">bad_ip_address</samp> variable contains the IP address that the malware is checking against. Let’s assume this value is <samp class="SANS_TheSansMonoCd_W5Regular_11">192.168.56.2</samp>, indicating a VirtualBox network. The malware compares the <samp class="SANS_TheSansMonoCd_W5Regular_11">FirstUnicastAddress</samp> value with the <samp class="SANS_TheSansMonoCd_W5Regular_11">bad_ip_address</samp> using <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp eax, edx</samp> to see if the victim system has the IP address <samp class="SANS_TheSansMonoCd_W5Regular_11">192.168.56.2</samp>. If this IP exists in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AdapterAddresses</samp> structure, the malware jumps to the <samp class="SANS_TheSansMonoCd_W5Regular_11">terminate_process</samp> function to terminate itself.</p>&#13;
<p class="TX">Keep in mind that there are many ways to enumerate the IP addresses on a system. Some functions involve querying the interface information directly, while others use a more back-channel method, such as listing the IP network tables. IP address information can also be queried using Windows tools such as WMI, PowerShell, and the Windows command line. You should be suspicious of any malware looking for the host’s internal IP address, as it could be using a detection technique.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h-84"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Domain Configurations</samp></h4>&#13;
<p class="TNI1">Malware may attempt to enumerate the victim host’s domain to ensure the target is within a certain company or network, or to weed out malware analysis environments. In this case, a <i>domain</i> is simply a logical grouping of systems on a network. The computer you use for work is likely part of a domain whose name relates to your company name. This domain is also typically part of your system’s <i>hostname</i>, or the name of your device on the network. If you work at Evil Corp, for example, your domain name might be <i>evil.corp</i> and your hostname might be <i>your.computer.evil.corp</i>.</p>&#13;
<p class="TX">Domain enumeration can be a great evasive tactic for malware. For example, if the victim system isn’t associated with a domain, or if the domain it’s attached to doesn’t match the malware’s primary target, the malware may terminate itself to avoid analysis or change its behavior. Common Windows API functions for enumerating a host’s domain are <samp class="SANS_TheSansMonoCd_W5Regular_11">GetComputerName</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">DsGetDcName</samp>.</p>&#13;
<p class="TX">In addition to Windows API functions, malware may query these registry keys, which may contain the domain of the system:</p>&#13;
<ul class="ul">&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKCU\Volatile Environment</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM\System\CurrentControlSet\Services\Tcpip\Parameters</samp></li>&#13;
</ul>&#13;
<p class="TX">To thwart this tactic, join your VMs and sandboxes to a domain. Even if the domain is fake, it can still trick malware into executing. We’ll discuss more about faking domains and network connectivity in <span class="Xref"><a href="appendix-A.xhtml">Appendix A</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h-85"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">MAC Address Configurations</samp></h4>&#13;
<p class="TNI1">A <i>media access control (MAC) address</i> is a unique identifier applied to all computer network hardware. The MAC address consists of digits (3 bytes) that represent the device manufacturer, followed by another series of digits (3 additional bytes) specific to the host’s hardware devices (see <a href="chapter6.xhtml#fig6-2">Figure 6-2</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_111" aria-label="111"/>&#13;
<figure class="IMG"><img class="img100" id="fig6-2" src="../images/fig6-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-2: MAC address structure</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In <a href="chapter6.xhtml#fig6-2">Figure 6-2</a>, the example MAC address is 00:50:56:62:9A:12. The first 3 bytes (00:50:56) represent the manufacturer’s identifier (in this case, VMware), and the last 3 bytes represent this specific adapter.</p>&#13;
<p class="TX">Malware can query the host’s MAC addresses to see if the host is using a specific manufacturer’s network hardware. Each piece of network hardware has its own dedicated MAC address as well, so malware can also use this information to target its victims. An example of this is the now well-known supply chain attack dubbed “ShadowHammer,” which occurred in 2019. The attackers used a list of preselected MAC addresses to target and infect specific computers.</p>&#13;
<p class="TX">To obtain a list of MAC addresses on the host, malware can call the Windows API function <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAdaptersAddresses</samp>. It then compares that list to a hardcoded list of MAC addresses, infecting the system only if it finds a network device with a matching MAC address. After the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAdaptersAddresses</samp> (using the same technique I outlined in <span class="Xref">“IP Address Configurations”</span> on <span class="Xref"><a href="chapter6.xhtml#pg_109">page 109</a></span>), it checks the <samp class="SANS_TheSansMonoCd_W5Regular_11">PhysicalAddress</samp> value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">AdapterAddresses</samp> structure, which contains the host’s MAC addresses, like so:</p>&#13;
<pre class="pre-37"><code>call GetAdaptersAddresses&#13;
<var>--snip--</var>&#13;
mov eax, [ebp+AdapterAddresses.PhysicalAddress]&#13;
<var>--snip--</var>&#13;
mov [ebp+var_38], 0B203B000h ; MAC address data&#13;
mov [ebp+var_34], 0F6DDB6CAh ; MAC address data&#13;
mov [ebp+var_30], 1D3CA6CDh  ; MAC address data&#13;
mov [ebp+var_2C], 287E2CDBh  ; MAC address data</code></pre>&#13;
<p class="TX">Later, the malware moves data onto the stack with instructions like <samp class="SANS_TheSansMonoCd_W5Regular_11">mov [ebp+var_38], 0B203B000h</samp>. This data represents part of the MAC address that the malware will compare to the victim’s MAC addresses.</p>&#13;
<p class="TX">VM-related MAC addresses can also be enumerated this way. The presence of one of the following MAC address prefixes would indicate to the malware that it’s running in a VM environment and possibly being analyzed:</p>&#13;
<p class="ListHead"><b>VMware Workstation</b></p>&#13;
<ul class="ul">&#13;
<li class="BL">00:50:56 ...</li>&#13;
<li class="BL">00:0C:29 ...</li>&#13;
<li class="BL">00:05:69 ...</li>&#13;
</ul>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_112" aria-label="112"/><b>VirtualBox</b></p>&#13;
<ul class="ul">&#13;
<li class="BL">08:00:27 ...</li>&#13;
</ul>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>To bypass this detection technique, change the MAC addresses of your VMs and sandboxes.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h-86"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">External IP Address and Internet Connectivity</samp></h4>&#13;
<p class="TNI1">One evasion technique that has seen increasing use is obtaining the potential victim’s external IP address. Malware might want this information for two reasons. First, malware can use it to determine the potential victim’s location. Some malware may target victims only in a certain area of the world, or it might want to exclude certain geographical regions. Not only does this help the malware stay on target, but it also aids in anti-analysis and evasion; if the potential victim isn’t within the malware’s regional scope, the malware will terminate itself or modify its behavior, likely fooling sandboxes and malware analysts.</p>&#13;
<p class="TX">Second, malware can use the host’s external IP address information or internet connection status to detect an analysis environment. For example, if the external IP is a popular virtual private network (VPN) gateway (such as NordVPN or ExpressVPN) or a TOR exit node, then the malware may infer that it’s being analyzed. (After all, if someone is using TOR or a VPN, they <i>must</i> be a malware analyst, right?) In addition, it’s often the case that sandboxes and analysis environments are intentionally offline, so if the host has no external IP address at all, the malware might assume it’s running in a lab environment.</p>&#13;
<p class="TX">This technique can be executed in a number of ways, but perhaps the most common is simply sending a web request to an IP lookup service, such as <i>WhatIsMyIP.com</i> or <i>IPLocation.net</i>. These are legitimate services that report back the external IP and geolocation information of a calling host. If you detonate malware in an analysis sandbox or lab and you see HTTP requests to sites like these, it’s a signal that the malware might be attempting to look up the host’s external IP address or location. Here’s how that might look:</p>&#13;
<pre class="pre-38"><code><span class="CodeAnnotationHang">1</span> mov   ecx, [ebp+lpszServerName] ; "icanhazip.com"&#13;
push  0    ; dwContext&#13;
push  0    ; dwFlags&#13;
push  3    ; dwService&#13;
push  0    ; lpszPassword&#13;
push  0    ; lpszUserName&#13;
<span class="CodeAnnotationHang">2</span> push  80   ; nServerPort&#13;
<span class="CodeAnnotationHang">3</span> push  ecx  ; lpszServerName&#13;
push  ebx  ; hInternet&#13;
<span class="CodeAnnotationHang">4</span> call  ds:InternetConnectA</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_113" aria-label="113"/>First, the malware sample moves the value <samp class="SANS_TheSansMonoCd_W5Regular_11">lpszServerName</samp>, which contains the domain <i>icanhazip.com</i>, into the <samp class="SANS_TheSansMonoCd_W5Regular_11">ecx</samp> register for later use <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetConnectA</samp> function takes a lot of parameters, but the important ones are <samp class="SANS_TheSansMonoCd_W5Regular_11">nServerPort</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, which indicates the port on which this malware sample will contact the domain (port <samp class="SANS_TheSansMonoCd_W5Regular_11">80</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP</samp>), and the domain itself, now stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">ecx</samp> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Finally, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetConnectA</samp> <span class="CodeAnnotation" aria-label="annotation4">❹</span>. This sample’s code is essentially contacting the <i>icanhazip.com</i> domain over HTTP to obtain the host’s external IP address.</p>&#13;
<p class="TX">A related method is to simply send a DNS or HTTP request to an online service provider. Any service provider will do, but <i>Google.com</i> is a common one. If the malware sample sends a request to a web server and receives no data (or incorrect data), it might deduce that it’s being analyzed. The following sample attempts to contact <i>Google.com</i> and then checks the response to ensure it matches the normal response from the server:</p>&#13;
<pre class="pre-39"><code>push  ecx    ; lpszServerName ("google.com")&#13;
push  ebx    ; hInternet&#13;
call  InternetConnectA&#13;
<var>--snip--</var>&#13;
push  eax    ; lpdwNumberOfBytesRead&#13;
<span class="CodeAnnotationHang">1</span> push  9      ; dwNumberOfBytesToRead&#13;
lea   ecx,   [ebp+lpBuffer]&#13;
<span class="CodeAnnotationHang">2</span> push  ecx    ; lpBuffer&#13;
push  edi    ; hFile&#13;
<span class="CodeAnnotationHang">3</span> call  InternetReadFile&#13;
test  eax, eax&#13;
jz    short loc_ 4021B6&#13;
<var>--snip--</var>&#13;
loc_404194:&#13;
<span class="CodeAnnotationHang">4</span> mov   eax, offset first_bytes ; "&lt;!doctype"&#13;
test  eax, [ebp+lpBuffer]</code></pre>&#13;
<p class="TX">After attempting to contact <i>Google.com</i> (using <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetConnectA</samp>), the sample pushes parameters for the <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetReadFile</samp> function, including <samp class="SANS_TheSansMonoCd_W5Regular_11">dwNumberOfBytesToRead</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which contains the number of bytes to be read from the web server response (<samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp>), and <samp class="SANS_TheSansMonoCd_W5Regular_11">lpBuffer</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, which is a pointer to the data <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetReadFile</samp> will return. Next, the malware sample calls <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetReadFile</samp> <span class="CodeAnnotation" aria-label="annotation3">❸</span>, which reads the first 9 bytes from Google’s response (which should be <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;!doctype</samp>). Finally, the code compares the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;!doctype</samp> value to the actual response stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">lpBuffer</samp> <span class="CodeAnnotation" aria-label="annotation4">❹</span>. If the responses are different, this malware sample might conclude that the system isn’t connected to the internet or is perhaps being analyzed in a sandbox.</p>&#13;
<p class="TX">It’s not uncommon to see this external IP validation technique in modern malware, so be on the lookout for it. If you’re analyzing a malware sample and see outbound HTTP or DNS requests to websites such as <i>WhatIsMyIP.com</i> or to service providers such as <i>Google.com</i> or <i>AWS.Amazon.com</i>, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_114" aria-label="114"/>there’s a chance the malware is using this VM detection technique. Here are some other websites to keep an eye out for:</p>&#13;
<ul class="ul">&#13;
<li class="BL"><i>api.ipify.org</i></li>&#13;
<li class="BL"><i>checkip.amazonaws.com</i></li>&#13;
<li class="BL"><i>checkip.dyndns.com</i></li>&#13;
<li class="BL"><i>icanhazip.com</i></li>&#13;
<li class="BL"><i>ip-api.com</i></li>&#13;
<li class="BL"><i>ip.anysrc.net</i></li>&#13;
<li class="BL"><i>ipecho.net</i></li>&#13;
<li class="BL"><i>ipinfo.io</i></li>&#13;
<li class="BL"><i>iplocation.net</i></li>&#13;
<li class="BL"><i>myexternalip.com</i></li>&#13;
<li class="BL"><i>myipaddress.com</i></li>&#13;
<li class="BL"><i>showipaddress.com</i></li>&#13;
<li class="BL"><i>whatismyip.com</i></li>&#13;
<li class="BL"><i>whatismyipaddress.com</i></li>&#13;
<li class="BL"><i>wtfismyip.com</i></li>&#13;
</ul>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h-87"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">TCP Connection States</samp></h4>&#13;
<p class="TNI1">In the previous section, I mentioned that malware analysts often configure their analysis machines and sandboxes to be completely offline or connected to a fake network. Malware can take advantage of this behavior by enumerating the outgoing TCP connections and trying to determine if they’re valid. A legitimate end-user system or server will likely have many outgoing TCP connections to various external IP addresses and ports. A malware analysis machine or sandbox, unless connected to a real network like the internet, may have only a few connections or none at all.</p>&#13;
<p class="TX">This tactic involves using the Windows API <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTcpTable</samp> function, which returns a table listing the current status of the latest TCP connections on the system, similar to the result of running <i>netstat.exe</i> on the host. This table might look something like <a href="chapter6.xhtml#tab6-2">Table 6-2</a>.</p>&#13;
<p class="TT" id="tab6-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 6-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Sample TCP Connections</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Local address</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Local port</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Remote address</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Remote port</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">State</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">127.0.0.1</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">2869</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">local-machine</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">49202</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">TIME_WAIT</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">127.0.0.1</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">2869</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">local-machine</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">49203</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">ESTABLISHED</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">192.168.1.2</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">49157</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">91.184.220.29</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">80</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ESTABLISHED</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">192.168.1.2</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">49158</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">64.233.160.15</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">443</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ESTABLISHED</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">An offline malware analysis machine or sandbox likely won’t have any established remote TCP connections like the third and fourth rows in <a href="chapter6.xhtml#tab6-2">Table 6-2</a>.</p>&#13;
<p class="TX">Malware can also, of course, leverage native Windows tools for this, such as the aforementioned <i>netstat.exe</i>. When inspecting malware, watch for attempts to enumerate TCP state information via Windows functions or native Windows tools.</p>&#13;
<aside class="box" aria-label="box-6">&#13;
<p class="BoxTitle" id="box-6"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_115" aria-label="115"/><samp class="SANS_Dogma_OT_Bold_B_11">OPEN PORTS</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Certain sandboxes have open ports that are typically used for communication between the hypervisor and the VM that detonates the malware. For example, the open source sandbox Cuckoo opens TCP port 8000 by default for communication.</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">In order to enumerate these open ports, malware can call the functions described previously, such as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTcpTable</samp><samp class="SANS_Futura_Std_Book_11">. If the malware sees that port 8000 is in a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">LISTENING</samp> <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">ESTABLISHED</samp> <samp class="SANS_Futura_Std_Book_11">state, the malware might assume it’s running in a Cuckoo sandbox environment. More advanced malware may even choose to send data to an open port to see how it behaves, much like a pentester would do to probe a target. Depending on the response from the open port, the malware sample will either continue normally or take evasive actions.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1" id="sec15"><span id="h-88"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI1">In this chapter, we covered many of the hardware and network configuration enumeration techniques that malware might use to determine its operating environment. As you’ve seen, understanding its environment and establishing context are key to malware’s ability to detect VMs and sandboxes, evade analysts, or otherwise stay on target. In the next chapter, we’ll explore how malware exposes the malware analysis environment by inspecting runtime anomalies, monitoring performance, and abusing virtual processor instructions.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>