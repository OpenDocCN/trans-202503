<html><head></head><body><div class="chapter" title="Chapter&#xA0;13.&#xA0;System Updates and Root Access"><div class="titlepage"><div><div><h1 class="title"><a id="system_updates_and_root_access"/>Chapter 13. System Updates and Root Access</h1></div></div></div><p><a id="iddle2903" class="indexterm"/>In the preceding chapters, we introduced Android’s security model and discussed how integrating SELinux into Android has reinforced it. In this chapter, we take a bit of a right turn and introduce methods that can be used to circumvent Android’s security model.</p><p>In order to perform a full OS update or to restore the device to its factory state, it’s necessary to escape the security sandbox and gain full access to a device, because even the most privileged Android components are not given complete access to all system partitions and storage devices. Additionally, while having full administrative (root) access at runtime is clearly against Android’s security design, executing with root privileges can be useful in order to implement functionality not offered by Android, such as the addition of custom firewall rules or full (including system partitions) device backup. Indeed, the wide availability of custom Android builds (often called <span class="emphasis"><em>ROMs</em></span>) and apps that allow users to extend or replace OS functionality using root access (commonly known as <span class="emphasis"><em>root apps</em></span>) has been one of the reasons for Android’s success.</p><p>In this chapter, we explore the design of Android’s bootloader and recovery OS, and show how they can be used to replace the system software <a id="iddle1091" class="indexterm"/><a id="iddle1290" class="indexterm"/><a id="iddle1296" class="indexterm"/><a id="iddle2904" class="indexterm"/><a id="iddle2906" class="indexterm"/>of a device. We then show how root access is implemented on engineering builds and how Android production builds can be modified to allow executing code with superuser privileges by installing a “superuser” application. Finally, we discuss how custom Android distributions implement and control root access.</p><div class="sect1" title="Bootloader"><div class="titlepage"><div><div><h1 class="title"><a id="bootloader-id00031"/>Bootloader</h1></div></div></div><p>A <span class="emphasis"><em>bootloader</em></span> is a low-level program that is executed when a device is powered. Its main purpose is to initialize the hardware and find and start the main operating system.</p><p>As briefly discussed in <a class="xref" href="ch10.html" title="Chapter 10. Device Security">Chapter 10</a>, Android bootloaders are usually locked and only allow booting or installing an operating system image that has been signed by the device manufacturer. This is an important step in establishing a verified boot path, because it ensures that only trusted and unmodified system software can be installed on a device. However, while most users are not interested in modifying the core OS of their devices, installing a third-party Android build is a valid user choice and may even be the only way to run a recent version of Android on devices that have stopped receiving OS updates from their manufacturer. That is why most recent devices provide a way to unlock the bootloader and install third-party Android builds.</p><div class="note" title="Note"><h3 class="title"><a id="ch13note01"/>Note</h3><p><span class="emphasis"><em>While Android bootloaders are typically closed source, the bootloaders of most ARM devices based on Qualcomm SoCs are derived from the Little Kernel (LK) bootloader,</em></span><sup>[<a id="ch13fn01" href="#ftn.ch13fn01" class="footnote">137</a>]</sup> <span class="emphasis"><em>which is open source.</em></span><sup>[<a id="ch13fn02" href="#ftn.ch13fn02" class="footnote">138</a>]</sup></p></div><p>In the following sections, we’ll look at how to interact with Android bootloaders and how the bootloader can be unlocked on Nexus devices. We then describe the fastboot protocol used to update devices via the bootloader.</p><div class="sect2" title="Unlocking the Bootloader"><div class="titlepage"><div><div><h2 class="title"><a id="unlocking_the_bootloader"/>Unlocking the Bootloader</h2></div></div></div><p>The bootloaders of Nexus devices are unlocked by issuing the <code class="literal">oem unlock</code> command when the device is in fastboot mode (discussed in the next section). Therefore, in order to unlock a device, it must first be started in fastboot mode, either by issuing the <code class="literal">adb reboot bootloader</code> command (if the device already allows ADB access), or by pressing a special key combination while the device is booting. For example, holding down the Volume down, Volume up, and Power buttons simultaneously on a powered-down Nexus 5 interrupts the normal boot process and brings up the fastboot screen shown in <a class="xref" href="ch13.html#nexus_5_bootloader_screen" title="Figure 13-1. Nexus 5 bootloader screen">Figure 13-1</a>.</p><p><a id="iddle1802" class="indexterm"/><a id="iddle1803" class="indexterm"/>The bootloader has a simple UI that can be driven by the Volume up/down and Power buttons. It allows users to continue the boot process, restart the device in fastboot or recovery mode, and power down the device.</p><p>Connecting the device to a host machine via a USB cable allows additional commands to be sent to the device using the <code class="literal">fastboot</code> command-line tool (part of the Android SDK). Issuing the <code class="literal">fastboot oem unlock</code> command brings up the confirmation screen shown in <a class="xref" href="ch13.html#nexus_5_bootloader_unlock_screen" title="Figure 13-2. Nexus 5 bootloader unlock screen">Figure 13-2</a>.</p><div class="figure"><a id="nexus_5_bootloader_screen"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00072"/><img src="figs/web/13fig01.png.jpg" alt="Nexus 5 bootloader screen"/></div></div><p class="title">Figure 13-1. Nexus 5 bootloader screen</p></div><div class="figure"><a id="nexus_5_bootloader_unlock_screen"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00073"/><img src="figs/web/13fig02.png.jpg" alt="Nexus 5 bootloader unlock screen"/></div></div><p class="title">Figure 13-2. Nexus 5 bootloader unlock screen</p></div><p>The confirmation screen warns that unlocking the bootloader allows installation of untested third-party OS builds and clears all user data. Because a third-party OS build might not follow Android’s security model and might allow unrestricted access to data, clearing all user data is an important security measure; it ensures that existing user data cannot be extracted after the bootloader is unlocked.</p><p>The bootloader can be locked again by issuing the <code class="literal">fastboot oem lock</code> command. Relocking the bootloader returns it to its original state, and loading or booting third-party OS images is no longer possible. However, besides a locked/unlocked flag, some bootloaders keep an additional, “tampered” flag that is set when the bootloader is first unlocked. This flag allows the bootloader to detect if it has ever been locked and disallow some operations or show a warning even if it is in a locked state.</p></div><div class="sect2" title="Fastboot Mode"><div class="titlepage"><div><div><h2 class="title"><a id="fastboot_mode"/>Fastboot Mode</h2></div></div></div><p><a id="iddle1291" class="indexterm"/><a id="iddle1293" class="indexterm"/><a id="iddle1798" class="indexterm"/><a id="iddle1800" class="indexterm"/><a id="iddle2905" class="indexterm"/>While the <code class="literal">fastboot</code> command and protocol can be used to unlock the boot-loader, their original purpose was to make it easy to clear or overwrite device partitions by sending partition images to the bootloader, which are then written to the specified block device. This is particularly useful when porting Android to a new device (referred to as “device bring-up”) or restoring a device to factory state using partition images provided by the device manufacturer.</p><div class="sect3" title="Android Partition Layout"><div class="titlepage"><div><div><h3 class="title"><a id="android_partition_layout"/>Android Partition Layout</h3></div></div></div><p>Android devices typically have several partitions, which fastboot refers to by name (rather than by the corresponding Linux device file). A list of partitions and their names can be obtained by listing the files in the <span class="emphasis"><em>by-name/</em></span> directory corresponding to the device’s SoC in <span class="emphasis"><em>/dev/block/platform/</em></span>. For example, because the Nexus 5 is based on Qualcomm SoC, which includes a Mobile Station Modem (MSM) baseband processor, the corresponding directory is called <span class="emphasis"><em>msm_sdcc.1/</em></span> as shown in <a class="xref" href="ch13.html#list_of_partitions_on_a_nexus_5" title="Example 13-1. List of partitions on a Nexus 5">Example 13-1</a> (timestamps omitted).</p><div class="example"><a id="list_of_partitions_on_a_nexus_5"/><p class="title">Example 13-1. List of partitions on a Nexus 5</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>ls -l /dev/block/platform/msm_sdcc.1/by-name</strong></span>
lrwxrwxrwx root     root              DDR -&gt; /dev/block/mmcblk0p24
lrwxrwxrwx root     root              aboot -&gt; /dev/block/mmcblk0p6➊
lrwxrwxrwx root     root              abootb -&gt; /dev/block/mmcblk0p11
lrwxrwxrwx root     root              boot -&gt; /dev/block/mmcblk0p19➋
lrwxrwxrwx root     root              cache -&gt; /dev/block/mmcblk0p27➌
lrwxrwxrwx root     root              crypto -&gt; /dev/block/mmcblk0p26
lrwxrwxrwx root     root              fsc -&gt; /dev/block/mmcblk0p22
lrwxrwxrwx root     root              fsg -&gt; /dev/block/mmcblk0p21
lrwxrwxrwx root     root              grow -&gt; /dev/block/mmcblk0p29
lrwxrwxrwx root     root              imgdata -&gt; /dev/block/mmcblk0p17
lrwxrwxrwx root     root              laf -&gt; /dev/block/mmcblk0p18
lrwxrwxrwx root     root              metadata -&gt; /dev/block/mmcblk0p14
lrwxrwxrwx root     root              misc -&gt; /dev/block/mmcblk0p15➍
lrwxrwxrwx root     root              modem -&gt; /dev/block/mmcblk0p1➎
lrwxrwxrwx root     root              modemst1 -&gt; /dev/block/mmcblk0p12
lrwxrwxrwx root     root              modemst2 -&gt; /dev/block/mmcblk0p13
lrwxrwxrwx root     root              pad -&gt; /dev/block/mmcblk0p7
lrwxrwxrwx root     root              persist -&gt; /dev/block/mmcblk0p16
lrwxrwxrwx root     root              recovery -&gt; /dev/block/mmcblk0p20➏
lrwxrwxrwx root     root              rpm -&gt; /dev/block/mmcblk0p3
lrwxrwxrwx root     root              rpmb -&gt; /dev/block/mmcblk0p10
lrwxrwxrwx root     root              sbl1 -&gt; /dev/block/mmcblk0p2➐
lrwxrwxrwx root     root              sbl1b -&gt; /dev/block/mmcblk0p8
lrwxrwxrwx root     root              sdi -&gt; /dev/block/mmcblk0p5
lrwxrwxrwx root     root              ssd -&gt; /dev/block/mmcblk0p23
lrwxrwxrwx root     root              system -&gt; /dev/block/mmcblk0p25➑
lrwxrwxrwx root     root              tz -&gt; /dev/block/mmcblk0p4
lrwxrwxrwx root     root              tzb -&gt; /dev/block/mmcblk0p9
lrwxrwxrwx root     root              userdata -&gt; /dev/block/mmcblk0p28➒</pre></div></div><p><a id="iddle1292" class="indexterm"/><a id="iddle1294" class="indexterm"/><a id="iddle1789" class="indexterm"/><a id="iddle1791" class="indexterm"/><a id="iddle1792" class="indexterm"/><a id="iddle1793" class="indexterm"/><a id="iddle1794" class="indexterm"/><a id="iddle1796" class="indexterm"/><a id="iddle1799" class="indexterm"/><a id="iddle1801" class="indexterm"/><a id="iddle1804" class="indexterm"/><a id="iddle1805" class="indexterm"/><a id="iddle1888" class="indexterm"/><a id="iddle3160" class="indexterm"/>As you can see, the Nexus 5 has 29 partitions, most of which store device-specific and proprietary data, such as the Android bootloader in <span class="emphasis"><em>aboot</em></span> ➊, the baseband software in <span class="emphasis"><em>modem</em></span> ➎, and the second stage bootloader in <span class="emphasis"><em>sbl1</em></span> ➐. The Android OS is hosted in the <span class="emphasis"><em>boot</em></span> ➋ partition, which stores the kernel and the <span class="emphasis"><em>rootfs</em></span> RAM disk image, and the <span class="emphasis"><em>system</em></span> partition ➑, which stores all other system files. User files are stored in the <span class="emphasis"><em>userdata</em></span> partition ➒, and temporary files, such as downloaded OTA images and recovery OS commands and logs, are stored in the <span class="emphasis"><em>cache</em></span> partition ➌. Finally, the recovery OS image resides in the <span class="emphasis"><em>recovery</em></span> partition ➏.</p></div><div class="sect3" title="The Fastboot Protocol"><div class="titlepage"><div><div><h3 class="title"><a id="fastboot_protocol"/>The Fastboot Protocol</h3></div></div></div><p>The fastboot protocol works over USB and is driven by the host. That is, communication is initiated by the host, which uses USB bulk transfers to send text-based commands and data to the bootloader. The USB client (boot-loader) responds with a status string such as <span class="emphasis"><em>OKAY</em></span> or <span class="emphasis"><em>FAIL</em></span>; an information message starting with <span class="emphasis"><em>INFO</em></span>; or <span class="emphasis"><em>DATA</em></span>, which signifies that the bootloader is ready to accept data from the host. When all data is received, the boot-loader responds with one of the <span class="emphasis"><em>OKAY</em></span>, <span class="emphasis"><em>FAIL</em></span>, or <span class="emphasis"><em>INFO</em></span> messages describing the final status of the command.</p></div><div class="sect3" title="Fastboot Commands"><div class="titlepage"><div><div><h3 class="title"><a id="fastboot_commands"/>Fastboot Commands</h3></div></div></div><p>The <code class="literal">fastboot</code> command-line utility implements the fastboot protocol, and allows you to get a list of connected devices that support fastboot (using the <code class="literal">devices</code> command), obtain information about the bootloader (with the <code class="literal">getvar</code> command), reboot the device in various modes (with <code class="literal">continue</code>, <code class="literal">reboot</code>, <code class="literal">reboot-bootloader</code>), and <code class="literal">erase</code> or <code class="literal">format</code> a partition.</p><p>The <code class="literal">fastboot</code> command supports various ways to write a disk image to a partition. A single named partition can be flashed using the <code class="literal">flash</code> <span class="emphasis"><em><code class="literal">partition image-filename</code></em></span> command, and multiple partition images contained in a ZIP file can be flashed at once using the <code class="literal">update</code> <span class="emphasis"><em><code class="literal">ZIP-filename</code></em></span> command.</p><p>The <code class="literal">flashall</code> command automatically flashes the contents of the <span class="emphasis"><em>boot.img</em></span>, <span class="emphasis"><em>system.img</em></span>, and <span class="emphasis"><em>recovery.img</em></span> files in its working directory to the <span class="emphasis"><em>boot</em></span>, <span class="emphasis"><em>system</em></span>, and <span class="emphasis"><em>recovery</em></span> partitions of the device, respectively. Finally, the <code class="literal">flash:raw boot</code> <span class="emphasis"><em><code class="literal">kernel ramdisk</code></em></span> command automatically creates a boot image from the specified kernel and RAM disk and flashes it to the <span class="emphasis"><em>boot</em></span> partition. In addition to flashing partition images, <code class="literal">fastboot</code> can also be used to boot an image without writing it to the device when invoked with the <code class="literal">boot</code> <span class="emphasis"><em><code class="literal">boot-image</code></em></span> or <code class="literal">boot</code> <span class="emphasis"><em><code class="literal">kernel ramdisk</code></em></span> commands.</p><p>Commands that modify device partitions, such as the various <code class="literal">flash</code> variations, and commands that boot custom kernels, such as the <code class="literal">boot</code> command, are not allowed when the bootloader is locked.</p><p><a id="iddle1092" class="indexterm"/><a id="iddle2297" class="indexterm"/><a id="iddle2574" class="indexterm"/><a id="iddle2576" class="indexterm"/><a id="iddle2907" class="indexterm"/><a id="iddle2909" class="indexterm"/><a class="xref" href="ch13.html#example_fastboot_session" title="Example 13-2. Example fastboot session">Example 13-2</a> shows an example <code class="literal">fastboot</code> session.</p><div class="example"><a id="example_fastboot_session"/><p class="title">Example 13-2. Example <code class="literal">fastboot</code> session</p><div class="example-contents"><pre class="programlisting"><span class="strong"><strong>$ fastboot devices➊</strong></span>
004fcac161ca52c5 fastboot
<span class="strong"><strong>$ fastboot getvar version-bootloader➋</strong></span>
version-bootloader: MAKOZ10o
finished. total time: 0.001s
<span class="strong"><strong>$ fastboot getvar version-baseband➌</strong></span>
version-baseband: M9615A-CEFWMAZM-2.0.1700.98
finished. total time: 0.001s
<span class="strong"><strong>$ fastboot boot custom-recovery.img➍</strong></span>
downloading 'boot.img'...
OKAY [ 0.577s]
booting...
FAILED (remote: not supported in locked device)
finished. total time: 0.579s</pre></div></div><p>Here, the first command ➊ lists the serial numbers of devices connected to the host, which are currently in fastboot mode. The commands at ➋ and ➌ obtain the bootloader and baseband version strings, respectively. Finally, the command at ➍ tries to boot a custom recovery image but fails because the bootloader is currently locked.</p></div></div></div><div class="sect1" title="Recovery"><div class="titlepage"><div><div><h1 class="title"><a id="recovery-id00032"/>Recovery</h1></div></div></div><p>The <span class="emphasis"><em>recovery OS</em></span>—also called <span class="emphasis"><em>recovery console</em></span> or simply, <span class="emphasis"><em>recovery</em></span>—is a minimal OS that is used for tasks that cannot be executed directly from Android, such as factory reset (erasing the <span class="emphasis"><em>userdata</em></span> partition) or applying OTA updates.</p><p>Like the bootloader’s fastboot mode, the recovery OS can be started either by pressing a specific key combination while the device boots, or via ADB by using the <code class="literal">adb reboot recovery</code> command. Some bootloaders also provide a menu interface (see <a class="xref" href="ch13.html#nexus_5_bootloader_screen" title="Figure 13-1. Nexus 5 bootloader screen">Figure 13-1</a>) that can be used to start the recovery. In the following sections, we take a look at the “stock” Android recovery that ships with Nexus devices and is included in AOSP, and then introduce custom recoveries, which offer much richer functionality but require an unlocked bootloader in order to be installed or booted.</p><div class="sect2" title="Stock Recovery"><div class="titlepage"><div><div><h2 class="title"><a id="stock_recovery"/>Stock Recovery</h2></div></div></div><p>Android’s stock recovery implements the minimal functionality needed to satisfy the “Updatable Software” section of the <span class="emphasis"><em>Android Compatibility Definition Document (CDD)</em></span>, which requires that “device implementations MUST include a mechanism to replace the entirety of the system software...” and that “the update mechanism used MUST support updates without wiping user data.”<sup>[<a id="ch13fn03" href="#ftn.ch13fn03" class="footnote">139</a>]</sup></p><p><a id="iddle2370" class="indexterm"/>That said, the CDD doesn’t specify the concrete update mechanism that should be used, so different approaches to system updates are possible and the stock recovery implements both OTA updates and tethered updates. For OTA updates, the main OS downloads the update file and then instructs the recovery to apply it. In the case of tethered updates, users download the update package on their PC and push it to the recovery using the <code class="literal">adb sideload</code> <span class="emphasis"><em><code class="literal">otafile.zip</code></em></span> command. The actual update process for both approaches is the same; only the method of obtaining the OTA package differs.</p><p>The stock recovery has a simple menu interface (shown in <a class="xref" href="ch13.html#stock_recovery_menu" title="Figure 13-3. Stock recovery menu">Figure 13-3</a>) that is operated using the device’s hardware buttons, usually the Power button and Volume up/down. However, the menu is hidden by default and needs to be activated by pressing a dedicated key combination. On Nexus devices, the recovery menu can usually be displayed by holding down the Power and Volume down buttons simultaneously for a few seconds.</p><p>The system recovery menu has four options: <span class="emphasis"><em>reboot</em></span>, <span class="emphasis"><em>apply update from ADB</em></span>, <span class="emphasis"><em>factory reset</em></span>, and <span class="emphasis"><em>wipe cache partition</em></span>. The <span class="emphasis"><em><span class="strong"><strong>apply update from ADB</strong></span></em></span> option starts the ADB server on the device and enables the tethered update (side-load) mode. However, as you can see, there is no option for applying an OTA update because once the user chooses to apply an OTA update from the main OS (see <a class="xref" href="ch13.html#applying_a_system_update_from_the_main_o" title="Figure 13-4. Applying a system update from the main OS">Figure 13-4</a>), it is applied automatically, without further user interaction. Android accomplishes this by sending control commands to the recovery, which are automatically executed when the recovery starts. (We discuss the mechanisms used to control the recovery in the next section.)</p><div class="figure"><a id="stock_recovery_menu"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00074"/><img src="figs/web/13fig03.png.jpg" alt="Stock recovery menu"/></div></div><p class="title">Figure 13-3. Stock recovery menu</p></div><div class="figure"><a id="applying_a_system_update_from_the_main_o"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00075"/><img src="figs/web/13fig04.png.jpg" alt="Applying a system update from the main OS"/></div></div><p class="title">Figure 13-4. Applying a system update from the main OS</p></div><div class="sect3" title="Controlling the Recovery"><div class="titlepage"><div><div><h3 class="title"><a id="controlling_the_recovery"/>Controlling the Recovery</h3></div></div></div><p><a id="iddle1261" class="indexterm"/><a id="iddle1288" class="indexterm"/><a id="iddle2055" class="indexterm"/><a id="iddle2147" class="indexterm"/><a id="iddle2371" class="indexterm"/><a id="iddle2572" class="indexterm"/><a id="iddle2578" class="indexterm"/><a id="iddle2758" class="indexterm"/><a id="iddle2818" class="indexterm"/><a id="iddle2868" class="indexterm"/><a id="iddle2984" class="indexterm"/><a id="iddle3123" class="indexterm"/><a id="iddle3127" class="indexterm"/>The main OS controls the recovery via the <code class="literal">android.os.RecoverySystem</code> API, which communicates with the recovery by writing option strings, each on a new line, to the <span class="emphasis"><em>/cache/recovery/command</em></span> file. The contents of the <span class="emphasis"><em>command</em></span> file are read by the <code class="literal">recovery</code> binary (located at <span class="emphasis"><em>/sbin/recovery</em></span> in the recovery OS), which is automatically started from <span class="emphasis"><em>init.rc</em></span> when the recovery boots. The options modify the behavior of the <code class="literal">recovery</code> binary and cause it to wipe the specified partition, apply an OTA update, or simply reboot. <a class="xref" href="ch13.html#options_for_the_stock_recovery_binary" title="Table 13-1. Options for the Stock recovery Binary">Table 13-1</a> shows the options supported by the stock <code class="literal">recovery</code> binary.</p><div class="table"><a id="options_for_the_stock_recovery_binary"/><p class="title">Table 13-1. Options for the Stock recovery Binary</p><div class="table-contents"><table summary="Options for the Stock recovery Binary" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>recovery Option</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">--send_intent=&lt;string&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Save and communicate the specified intent action back to the main OS when finished</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">--update_package=&lt;OTA package path&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Verify and install the specified OTA package</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">--wipe_data</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Erase the <span class="emphasis"><em>userdata</em></span> and <span class="emphasis"><em>cache</em></span> partitions, then reboot</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">--wipe_cache</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Erase the <span class="emphasis"><em>cache</em></span> partition, then reboot</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">--show_text</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Message to display</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">--just_exit</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Exit and reboot</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">--locale</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Locale to use for recovery messages and UI</p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">--stages</code></p></td><td style="" valign="top"><p>Set the current stage of the recovery process</p></td></tr></tbody></table></div></div><p>In order to ensure that the specified command(s) are always completed, the <code class="literal">recovery</code> binary copies its arguments to the bootloader control block (BCB), which is hosted on the <span class="emphasis"><em>misc</em></span> partition (➍ in <a class="xref" href="ch13.html#list_of_partitions_on_a_nexus_5" title="Example 13-1. List of partitions on a Nexus 5">Example 13-1</a>). The BCB is used to communicate the current state of the recovery process to the bootloader. The format of the BCB is specified in the <code class="literal">bootloader_message</code> structure, shown in <a class="xref" href="ch13.html#bcb_format_structure_definition" title="Example 13-3. BCB format structure definition">Example 13-3</a>.</p><div class="example"><a id="bcb_format_structure_definition"/><p class="title">Example 13-3. BCB format structure definition</p><div class="example-contents"><pre class="programlisting">struct bootloader_message {
    char command[32];➊
    char status[32];➋
    char recovery[768];➌
    char stage[32];➍
    char reserved[224];➎
};</pre></div></div><p>If a device is rebooted or powered down in the middle of the recovery process, the next time it is started the bootloader inspects the BCB and starts the recovery again if the BCB contains the <span class="emphasis"><em>boot-recovery</em></span> command. If the recovery process completes successfully, the <code class="literal">recovery</code> binary clears the BCB before exiting (sets all bytes to zero), and on the next reboot the boot-loader starts the main Android OS.</p><p><a id="iddle1095" class="indexterm"/><a id="iddle2365" class="indexterm"/><a id="iddle2366" class="indexterm"/><a id="iddle2581" class="indexterm"/><a id="iddle2583" class="indexterm"/><a id="iddle2586" class="indexterm"/><a id="iddle2641" class="indexterm"/><a id="iddle3066" class="indexterm"/><a id="iddle3151" class="indexterm"/>In <a class="xref" href="ch13.html#bcb_format_structure_definition" title="Example 13-3. BCB format structure definition">Example 13-3</a>, the command at ➊ is the command to the bootloader (usually <span class="emphasis"><em>boot-recovery</em></span>); ➋ is a status file written by the bootloader after performing a platform-specific action; ➌ contains the options for the <code class="literal">recovery</code> binary (<code class="literal">--update_package</code>, <code class="literal">--wipe-data</code>, and so on); and ➍ is a string describing the install stage of OTA packages that require multiple restarts, for example <span class="emphasis"><em>2/3</em></span> if the installation requires three reboots. The last field ➎ is reserved and not used as of this writing.</p></div><div class="sect3" title="Sideloading an OTA Package"><div class="titlepage"><div><div><h3 class="title"><a id="sideloading_an_ota_package"/>Sideloading an OTA Package</h3></div></div></div><p>Besides being downloaded by the main OS, an OTA package can be directly passed to the recovery from a host PC. In order to enable this update mode, the user must choose the <span class="emphasis"><em>apply update from ADB</em></span> option from the recovery menu first. This starts a trimmed down version of the standard ADB daemon, which supports only the <code class="literal">sideload</code> command. Executing <code class="literal">adb sideload</code> <span class="emphasis"><em><code class="literal">OTA-package-file</code></em></span> on the host transfers the OTA file to <span class="emphasis"><em>/tmp/update.zip</em></span> on the device and installs it (see “<a class="xref" href="ch13.html#applying_the_update" title="Applying the Update">Applying the Update</a>”).</p></div><div class="sect3" title="OTA Signature Verification"><div class="titlepage"><div><div><h3 class="title"><a id="ota_signature_verification"/>OTA Signature Verification</h3></div></div></div><p>As we learned in <a class="xref" href="ch03.html" title="Chapter 3. Package Management">Chapter 3</a>, OTA packages are code signed, with the signature applied over the whole file (unlike JAR and APK files, which include a separate signature for each file in the archive). When the OTA process is started from the main Android OS, the OTA package (ZIP file) is first verified using the <code class="literal">verifyPackage()</code> method of the <code class="literal">RecoverySystem</code> class. This method receives both the path to the OTA package and a ZIP file containing a list of X.509 certificates that are allowed to sign OTA updates as parameters. If the OTA package is signed with the private key corresponding to any of the certificates in the ZIP file, the OTA is considered valid and the system reboots into recovery in order to apply it. If no certificate ZIP file is specified, the system default, <span class="emphasis"><em>/system/etc/security/otacerts.zip</em></span>, is used.</p><p>The recovery verifies the OTA package that it is instructed to apply independently of the main OS in order to ensure that the OTA package has not been replaced before starting the recovery. The verification is performed with a set of public keys built into the recovery image. When building the recovery, these keys are extracted from the specified set of OTA signing certificates, converted to mincrypt format using the <code class="literal">DumpPublicKey</code> tool, and written to the <span class="emphasis"><em>/res/keys</em></span> file. When RSA is used as the signature algorithm, the keys are mincrypt’s <code class="literal">RSAPublicKey</code> structures, serialized as C literals (as they would appear in a C source file), optionally preceded by a version identifier that specifies the hash used when signing the OTA package and the RSA key public exponent of the key. The <span class="emphasis"><em>keys</em></span> file may look like <a class="xref" href="ch13.html#contents_of_the_solidusressoliduskeys_fi" title="Example 13-4. Contents of the /res/keys file in the recovery OS">Example 13-4</a>.</p><div class="example"><a id="contents_of_the_solidusressoliduskeys_fi"/><p class="title">Example 13-4. Contents of the <span class="roman">/res/keys</span> file in the recovery OS</p><div class="example-contents"><pre class="programlisting">{64,0xc926ad21,{1795090719,...,3599964420},{3437017481,...,1175080310}},➊
v2 {64,0x8d5069fb,{393856717,...,2415439245},{197742251,...,1715989778}},➋
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p><a id="iddle2372" class="indexterm"/><a id="iddle2584" class="indexterm"/><a id="iddle2800" class="indexterm"/><a id="iddle2810" class="indexterm"/>Here, the first line ➊ is a serialized version 1 key (implicit if a version identifier is not specified), which has a public exponent <span class="emphasis"><em>e=3</em></span> and can be used to verify signatures created using SHA-1; the second line ➋ contains a version 2 key that has a public exponent <span class="emphasis"><em>e=65537</em></span> and is also used with SHA-1 signatures. The currently supported signature algorithms are 2048-bit RSA with SHA-1 (key versions 1 and 2) or SHA-256 (key versions 3 and 4), and ECDSA with SHA-256 (key version 5, available in AOSP’s mater branch) and 256-bit EC keys using the NIST P-256 curve.</p></div><div class="sect3" title="Starting the System Update Process"><div class="titlepage"><div><div><h3 class="title"><a id="starting_the_system_update_process"/>Starting the System Update Process</h3></div></div></div><p>If the signature of the OTA package verifies, the recovery applies the system update by executing the update command included in the OTA file. The update command is saved in the <span class="emphasis"><em>META-INF/com/google/android/</em></span> directory of the recovery image as <code class="literal">update-binary</code> ➊, as shown in <a class="xref" href="ch13.html#contents_of_a_system_update_ota_package" title="Example 13-5. Contents of a system update OTA package">Example 13-5</a>.</p><div class="example"><a id="contents_of_a_system_update_ota_package"/><p class="title">Example 13-5. Contents of a system update OTA package</p><div class="example-contents"><pre class="programlisting">.
|-- META-INF/
|   |-- CERT.RSA
|   |-- CERT.SF
|   |-- com/
|   |   |-- android/
|   |   |   |-- metadata
|   |   |   `-- otacert
|   |   `-- google/
|   |       `-- android/
|   |           |-- update-binary➊
|   |           `-- updater-script➋
|   `-- MANIFEST.MF
|-- patch/
|   |-- boot.img.p
|   `-- system/
|-- radio.img.p
|-- recovery/
|   |-- etc/
|   | `-- install-recovery.sh
|   `-- recovery-from-boot.p
`-- system/
    |-- etc/
    |   |-- permissions/
    |   |   `-- com.google.android.ble.xml
    |   `-- security/
    |       `-- cacerts/
    |-- framework/
    `-- lib/</pre></div></div><p>The recovery extracts <code class="literal">update-binary</code> from the OTA file to <span class="emphasis"><em>/tmp/update_binary</em></span> and starts it, passing it three parameters: the recovery API version (version 3 as of this writing); the file descriptor of a pipe that <code class="literal">update-binary</code> uses to communicate progress and messages back to the recovery; and the path to the OTA package. The <span class="emphasis"><em>update-binary</em></span> process in turn extracts the updater script,<a id="iddle1003" class="indexterm"/><a id="iddle1178" class="indexterm"/><a id="iddle1181" class="indexterm"/><a id="iddle1233" class="indexterm"/><a id="iddle1535" class="indexterm"/><a id="iddle1537" class="indexterm"/><a id="iddle1698" class="indexterm"/><a id="iddle1809" class="indexterm"/><a id="iddle1827" class="indexterm"/><a id="iddle1883" class="indexterm"/><a id="iddle2224" class="indexterm"/><a id="iddle2378" class="indexterm"/><a id="iddle2379" class="indexterm"/><a id="iddle2577" class="indexterm"/><a id="iddle2643" class="indexterm"/><a id="iddle2782" class="indexterm"/><a id="iddle2783" class="indexterm"/><a id="iddle2817" class="indexterm"/><a id="iddle2887" class="indexterm"/><a id="iddle2968" class="indexterm"/><a id="iddle2969" class="indexterm"/><a id="iddle3140" class="indexterm"/> included as <span class="emphasis"><em>META-INF/com/google/android/updater-script</em></span> ➋ in the OTA package, and evaluates it. The updater script is written in a dedicated scripting language called <span class="emphasis"><em>edify</em></span> (since version 1.6; previous versions used an older variant called <span class="emphasis"><em>amend</em></span>). The edify language supports simple control structures such as <code class="literal">if</code> and <code class="literal">else</code>, and is extensible via functions, which can also act as control structures (by deciding which of their arguments to evaluate). The updater script includes a sequence of function calls that trigger the operations necessary to apply the update.</p></div><div class="sect3" title="Applying the Update"><div class="titlepage"><div><div><h3 class="title"><a id="applying_the_update"/>Applying the Update</h3></div></div></div><p>The edify implementation defines and registers various functions that are used for copying, deleting, and patching files; formatting and mounting volumes; setting file permissions and SELinux labels; and more. <a class="xref" href="ch13.html#summary_of_important_edify_functions" title="Table 13-2. Summary of Important edify Functions">Table 13-2</a> shows a summary of the most often used edify functions.</p><div class="table"><a id="summary_of_important_edify_functions"/><p class="title">Table 13-2. Summary of Important edify Functions</p><div class="table-contents"><table summary="Summary of Important edify Functions" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Function Name</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">abort</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Aborts the install process with an error message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">apply_patch</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Safely applies a binary patch. Ensures that the patched file has the expected hash value, before replacing the original. Can also patch disk partitions.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">apply_patch_check</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Checks if a file has the specified hash value.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">assert</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Checks if a condition is true.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">delete/delete_recursive</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Deletes a file/all files in a directory.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">file_getprop</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Gets a system property from the specified property file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">format</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Formats a volume with the specified filesystem.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">getprop</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Gets a system property.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">mount</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Mounts a volume at the specified path.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">package_extract_dir</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Extracts the specified ZIP directory to a path on the filesystem.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">package_extract_file</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Extracts the specified ZIP file to a path on the filesystem or returns it as a blob.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">run_program</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Executes the specified program in a subprocess and waits for it to finish.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">set_metadata/set_metadata_recursive</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Sets the owner, group, permission bits, file capabilities, and SELinux label on file/all files in a directory.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">show_progress</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Reports back progress to the parent process.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">symlink</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Creates a symbolic link(s) to a target, deleting existing symbolic link files first.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">ui_print</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Sends a message back to the parent process.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">umount</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Unmounts a mounted volume.</p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">write_raw_image</code></p></td><td style="" valign="top"><p>Writes a raw image to the specified disk partition.</p></td></tr></tbody></table></div></div><p><a class="xref" href="ch13.html#contents_of_updater-script_in_a_full_sys" title="Example 13-6. Contents of updater-script in a full system update OTA package">Example 13-6</a> shows the (abbreviated) contents of a typical system update edify script.</p><div class="example"><a id="contents_of_updater-script_in_a_full_sys"/><p class="title">Example 13-6. Contents of <span class="roman">updater-script</span> in a full system update OTA package</p><div class="example-contents"><pre class="programlisting">mount("ext4", "EMMC", "/dev/block/platform/msm_sdcc.1/by-name/system", "/system");
file_getprop("/system/build.prop", "ro.build.fingerprint") == "google/...:user/release-keys" ||
    file_getprop("/system/build.prop", "ro.build.fingerprint") == "google/...:user/release-keys" ||
    abort("Package expects build fingerprint of google/...:user/release-keys; this device has " +
    getprop("ro.build.fingerprint") + ".");
getprop("ro.product.device") == "hammerhead" ||
    abort("This package is for \"hammerhead\" devices; this is a \"" +
    getprop("ro.product.device") + "\".");➊
--<span class="emphasis"><em>snip</em></span>--
apply_patch_check("/system/app/BasicDreams.apk", "f687...", "fdc5...") ||
    abort("\"/system/app/BasicDreams.apk\" has unexpected contents.");➋
set_progress(0.000063);
--<span class="emphasis"><em>snip</em></span>--
apply_patch_check("EMMC:/dev/block/platform/msm_sdcc.1/by-name/boot:8835072:21...:8908800:a3...")
|| abort("\"EMMC:/dev/block/...\" has unexpected contents.");➌
--<span class="emphasis"><em>snip</em></span>--
ui_print("Removing unneeded files...");
delete("/system/etc/permissions/com.google.android.ble.xml",
       --<span class="emphasis"><em>snip</em></span>--
       "/system/recovery.img");➍
ui_print("Patching system files...");
apply_patch("/system/app/BasicDreams.apk", "-",
            f69d..., 32445,
            fdc5..., package_extract_file("patch/system/app/BasicDreams.apk.p"));➎
--<span class="emphasis"><em>snip</em></span>--
ui_print("Patching boot image...");
apply_patch("EMMC:/dev/block/platform/msm_sdcc.1/by-name/boot:8835072:2109...:8908800:a3bd...",
            "-", a3bd..., 8908800,
            2109..., package_extract_file("patch/boot.img.p"));➏
--<span class="emphasis"><em>snip</em></span>--
delete("/system/recovery-from-boot.p",
       "/system/etc/install-recovery.sh");
ui_print("Unpacking new recovery...");
package_extract_dir("recovery", "/system");➐
ui_print("Symlinks and permissions...");
set_metadata_recursive("/system", "uid", 0, "gid", 0, "dmode", 0755, "fmode", 0644,
                       "capabilities", 0x0, "selabel", "u:object_r:system_file:s0");➑
--<span class="emphasis"><em>snip</em></span>--
ui_print("Patching radio...");
apply_patch("EMMC:/dev/block/platform/msm_sdcc.1/by-name/modem:43058688:7493...:46499328:52a...",
            "-", 52a5..., 46499328,
            7493..., package_extract_file("radio.img.p"));➒
--<span class="emphasis"><em>snip</em></span>--
unmount("/system");➓</pre></div></div></div><div class="sect3" title="Copying and Patching Files"><div class="titlepage"><div><div><h3 class="title"><a id="copying_and_patching_files"/>Copying and Patching Files</h3></div></div></div><p><a id="iddle1179" class="indexterm"/><a id="iddle2579" class="indexterm"/><a id="iddle2580" class="indexterm"/><a id="iddle2582" class="indexterm"/><a id="iddle2784" class="indexterm"/><a id="iddle3124" class="indexterm"/>The updater script first mounts the <span class="emphasis"><em>system</em></span> partition, then checks to see if the device model and its current build are what it expects ➊. This check is required because trying to install a system update over an incompatible build can leave a device in an unusable state. (This is often called a “soft brick,” because it can usually be recovered by reflashing all partitions with a working build; a “hard brick” cannot be recovered.)</p><p>Because an OTA update usually does not contain complete system files, only binary patches against the previous version of each changed file (produced using <code class="literal">bsdiff</code>),<sup>[<a id="ch13fn04" href="#ftn.ch13fn04" class="footnote">140</a>]</sup> applying an update can succeed only if each file-to-be-patched is the same as the one used to produce the respective patch. To ensure this, the updater script checks that the hash value of each file-to-be-patched is one it expects using the <code class="literal">apply_patch_check</code> function ➋.</p><p>In addition to system files, the update process also patches partitions that don’t contain a filesystem, such as the <span class="emphasis"><em>boot</em></span> and <span class="emphasis"><em>modem</em></span> partitions. To guarantee that patching such partitions will succeed, the updater script checks the contents of target partitions as well and aborts if they are not in the expected state ➌. When all system files and partitions have been verified, the updater script deletes unnecessary files, as well as files that will be replaced completely instead of being patched ➍. The script then goes on to patch all system files ➎ and partitions ➏. It then removes any previous recovery patches and unpacks the new recovery in <span class="emphasis"><em>/system/</em></span> ➐.</p></div><div class="sect3" title="Setting File Ownership, Permissions, and Security Labels"><div class="titlepage"><div><div><h3 class="title"><a id="setting_file_ownershipcomma_permissionsc"/>Setting File Ownership, Permissions, and Security Labels</h3></div></div></div><p>The next step is to set the user, owner, permissions, and file capabilities of all created or patched files and directories using the <code class="literal">set_metadata_recursive</code> function ➑. As of version 4.3, Android supports SELinux (see <a class="xref" href="ch12.html" title="Chapter 12. Selinux">Chapter 12</a>), so all files must be properly labeled in order for access rules to be effective. That is why the <code class="literal">set_metadata_recursive</code> function has been extended to set the SELinux security label (the last parameter, <span class="emphasis"><em>u:object_r:system_file:s0</em></span> in ➑) of files and directories.</p></div><div class="sect3" title="Finishing the Update"><div class="titlepage"><div><div><h3 class="title"><a id="finishing_the_update"/>Finishing the Update</h3></div></div></div><p>Next, the updater script patches the device’s baseband software ➒, which is typically stored in the <span class="emphasis"><em>modem</em></span> partition. The final step of the script is to unmount the system partition➓.</p><p>After the <span class="emphasis"><em>update-binary</em></span> process exits, the recovery wipes the cache partition if it was started with the <code class="literal">–wipe_cache</code> option and copies the execution logs to <span class="emphasis"><em>/cache/recovery/</em></span> so that they are accessible from the main OS. Finally, if no errors are reported, the recovery clears the BCB and reboots into the main OS.</p><p><a id="iddle1180" class="indexterm"/><a id="iddle2585" class="indexterm"/>If the update process is aborted due to an error, the recovery reports this to the user, and prompts them to reboot the device in order to try again. Because the BCB has not been cleared, the device automatically reboots in recovery mode, and the update process is started from scratch.</p></div><div class="sect3" title="Updating the Recovery"><div class="titlepage"><div><div><h3 class="title"><a id="updating_the_recovery"/>Updating the Recovery</h3></div></div></div><p>If you examine the entire updater script in <a class="xref" href="ch13.html#contents_of_updater-script_in_a_full_sys" title="Example 13-6. Contents of updater-script in a full system update OTA package">Example 13-6</a> in detail, you’ll notice that while it patches the <span class="emphasis"><em>boot</em></span> ➏ and <span class="emphasis"><em>modem</em></span> ➒ partitions and unpacks a patch for the <span class="emphasis"><em>recovery</em></span> partition ➐ (which hosts the recovery OS), it does not apply the unpacked patch. This is by design. Because an update can be interrupted at any moment, the update process needs to be restarted from the same state the next time the device is powered on. If, for example, power is interrupted while writing to the <span class="emphasis"><em>recovery</em></span> partition, updating the recovery OS would change that initial state and might leave the system in an unusable condition. Therefore, the recovery OS is updated from the main OS only when the main OS update has completed and the main OS boots successfully.</p><p>The update is triggered by the <span class="emphasis"><em>flash_recovery</em></span> service in Android’s <span class="emphasis"><em>init.rc</em></span> file, as shown in <a class="xref" href="ch13.html#definition_of_the_flashunderscorerecover" title="Example 13-7. Definition of the flash_recovery service in init.rc">Example 13-7</a>.</p><div class="example"><a id="definition_of_the_flashunderscorerecover"/><p class="title">Example 13-7. Definition of the <span class="roman">flash_recovery</span> <span class="emphasis"><em>service in</em></span> <span class="roman">init.rc</span></p><div class="example-contents"><pre class="programlisting">--<span class="emphasis"><em>snip</em></span>--
service flash_recovery /system/etc/install-recovery.sh➊
    class main
    oneshot
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>As you can see, this service simply starts the <span class="emphasis"><em>/system/etc/install-recovery.sh</em></span> shell script ➊. The shell script, along with a patch file for the recovery partition, is copied by the OTA updater script (➐ in <a class="xref" href="ch13.html#contents_of_updater-script_in_a_full_sys" title="Example 13-6. Contents of updater-script in a full system update OTA package">Example 13-6</a>) if the recovery requires an update. The contents of <span class="emphasis"><em>install-recovery.sh</em></span> might look like <a class="xref" href="ch13.html#contents_of_install-recoverydotsh" title="Example 13-8. Contents of install-recovery.sh">Example 13-8</a>.</p><div class="example"><a id="contents_of_install-recoverydotsh"/><p class="title">Example 13-8. Contents of <span class="roman">install-recovery.sh</span></p><div class="example-contents"><pre class="programlisting">#!/system/bin/sh
if ! applypatch -c EMMC:/dev/block/platform/msm_sdcc.1/by-name/recovery:9506816:3e90...; then➊
  log -t recovery "Installing new recovery image"
  applypatch -b /system/etc/recovery-resource.dat \
      EMMC:/dev/block/platform/msm_sdcc.1/by-name/boot:8908800:a3bd... \
      EMMC:/dev/block/platform/msm_sdcc.1/by-name/recovery \
      3e90... 9506816 a3bd...:/system/recovery-from-boot.p➋
else
  log -t recovery "Recovery image already installed"➌
fi</pre></div></div><p>The script uses the <code class="literal">applypatch</code> command to check whether the recovery OS needs to be patched by checking the hash value of the <span class="emphasis"><em>recovery</em></span> partition ➊. If the hash of the device’s <span class="emphasis"><em>recovery</em></span> partition matches the hash of the version <a id="iddle1790" class="indexterm"/><a id="iddle1795" class="indexterm"/><a id="iddle2575" class="indexterm"/><a id="iddle2908" class="indexterm"/><a id="iddle2913" class="indexterm"/><a id="iddle2945" class="indexterm"/>against which the patch was created, the script applies the patch ➋. If the recovery has already been updated or has an unknown hash, the script logs a message and exits ➌.</p></div></div><div class="sect2" title="Custom Recoveries"><div class="titlepage"><div><div><h2 class="title"><a id="custom_recoveries"/>Custom Recoveries</h2></div></div></div><p>A custom recovery is a recovery OS build created by a third party (not the device manufacturer). Because it is created by a third party, a custom recovery is not signed with the manufacturer’s keys, and therefore a device’s bootloader needs to be unlocked in order to boot or flash it.</p><p>A custom recovery can be booted without installing it on the device with the <code class="literal">fastboot boot</code> <span class="emphasis"><em><code class="literal">custom-recovery.img</code></em></span> command, or it may be permanently flashed using the <code class="literal">fastboot flash recovery</code> <span class="emphasis"><em><code class="literal">custom-recovery.img</code></em></span> command.</p><p>A custom recovery provides advanced functionality that is typically not available in stock recoveries, such as full partition backup and restore, a root shell with a full set of device management utilities, support for mounting external USB devices, and so on. A custom recovery can also disable OTA package signature checking, which allows for installing third-party OS builds or modification, such as framework or theme customizations.</p><p>Various custom recoveries are available, but as of this writing, by far the most full-featured and actively maintained is the Team Win Recovery Project (TWRP).<sup>[<a id="ch13fn05" href="#ftn.ch13fn05" class="footnote">141</a>]</sup> It is based on the AOSP stock recovery and is also an open source project.<sup>[<a id="ch13fn06" href="#ftn.ch13fn06" class="footnote">142</a>]</sup> TWRP has a theme-able, touch screen interface that is very similar to the native Android UI. It supports encrypted partition backups, installing system updates from USB devices, and backup and restore to/from external devices, and it has an integrated file manager. The startup screen of TWRP version 2.7 is shown in <a class="xref" href="ch13.html#twrp_recovery_startup_screen" title="Figure 13-5. TWRP recovery startup screen">Figure 13-5</a>.</p><div class="figure"><a id="twrp_recovery_startup_screen"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00076"/><img src="figs/web/13fig05.png.jpg" alt="TWRP recovery startup screen"/></div></div><p class="title">Figure 13-5. TWRP recovery startup screen</p></div><p>Like the stock AOSP recovery, custom recoveries can be controlled from the main OS. In addition to passing parameters via the <span class="emphasis"><em>/cache/recovery/ command</em></span> file, custom recoveries usually allow some (or all) of their extended features to be triggered from the main OS. For example, TWRP supports a minimal scripting language, which <a id="iddle1511" class="indexterm"/><a id="iddle1636" class="indexterm"/><a id="iddle2624" class="indexterm"/>describes what recovery actions should be executed upon booting the recovery. This allows Android apps to queue recovery commands via a convenient GUI interface. For example, requesting a compressed backup of the <span class="emphasis"><em>boot</em></span>, <span class="emphasis"><em>userdata</em></span>, and <span class="emphasis"><em>system</em></span> partitions generates the script shown in <a class="xref" href="ch13.html#twrp_backup_script_example" title="Example 13-9. TWRP backup script example">Example 13-9</a>.</p><div class="example"><a id="twrp_backup_script_example"/><p class="title">Example 13-9. TWRP backup script example</p><div class="example-contents"><pre class="programlisting">#<span class="strong"><strong>cat /cache/recovery/openrecoveryscript</strong></span>
backup DSBOM 2014-12-14--01-54-59</pre></div></div><div class="warning" title="Warning"><h3 class="title"><a id="ch13note02"/>Warning</h3><p><span class="emphasis"><em>Permanently flashing a custom recovery that has an option to ignore OTA package signatures might allow the system software of your device to be replaced and back-doored given brief physical access to the devices. Therefore, it is not recommended to flash a custom recovery on a device you use daily and which stores personal or sensitive information.</em></span></p></div></div></div><div class="sect1" title="Root Access"><div class="titlepage"><div><div><h1 class="title"><a id="root_access"/>Root Access</h1></div></div></div><p>Android’s security model applies the principle of least privilege and strives to isolate system and app processes from each other by running each process as a dedicated user. However, Android is also based on a Linux kernel, which implements a standard Unix-style DAC (unless SELinux is enabled; see <a class="xref" href="ch12.html" title="Chapter 12. Selinux">Chapter 12</a>).</p><p>One of the greatest shortcomings of this DAC security model is that a certain system user, typically called <span class="emphasis"><em>root</em></span> (UID=0), also known as the <span class="emphasis"><em>superuser</em></span>, is given absolute power over the system. Root can read, write, and change the permission bits of any file or directory; kill any process; mount and unmount volumes; and so on. While such unconstrained permissions are necessary for managing a traditional Linux system, having superuser access on an Android device allows one to effectively bypass Android’s sandbox, and read or write the private files of any application.</p><p>Root access also allows changing the system configuration by modifying partitions that are designed to be read-only, starting or stopping system services at will, and removing or disabling core system applications. This can adversely affect the stability of a device, or even render it unusable, which is why root access is typically not allowed on production devices.</p><p>Furthermore, Android tries to limit the number of system processes that execute as root, because a programming error in any such process can open the doors to privilege escalation attacks, which could result in third-party applications gaining root access. With the deployment of SELinux in enforcing mode, processes are limited by the global security policy, and therefore compromising a root process does not necessarily grant unrestricted access to a device but could still allow access to sensitive data or allow modifying system behavior. Additionally, even a process constrained by SELinux could exploit a kernel vulnerability in order to circumvent the security policy or otherwise obtain unrestricted root access.</p><p><a id="iddle1080" class="indexterm"/><a id="iddle1319" class="indexterm"/><a id="iddle1320" class="indexterm"/><a id="iddle2625" class="indexterm"/><a id="iddle2626" class="indexterm"/>With all that said, root access could be very convenient for debugging or reverse engineering applications on development devices. Additionally, while allowing root access to third-party applications does compromise Android’s security model, it also allows various system customizations that are typically not available on production devices to be performed.</p><p>Because one of Android’s biggest selling points has always been its ease of customization, the demand for ever greater flexibility via modifying the core OS (also called <span class="emphasis"><em>modding</em></span>), has always been high, especially during Android’s early years. Besides customizing the system, having root access on an Android device allows for the implementation of applications that are not possible without modifying the framework and adding system services, such as firewalls, full device backup, network sharing, and so on.</p><p>In the following sections, we describe how root access is implemented in development (engineering) Android builds and custom Android builds (ROMs), and how it can be added to production builds. We then show how apps that require superuser access (typically called <span class="emphasis"><em>root apps</em></span>) can request and use root privileges in order to execute processes as root.</p><div class="sect2" title="Root Access on Engineering Builds"><div class="titlepage"><div><div><h2 class="title"><a id="root_access_on_engineering_builds"/>Root Access on Engineering Builds</h2></div></div></div><p>Android’s build system can produce several build variants for a particular device that differ by the number of applications and utilities included, as well as by the values of several key system properties that modify system behavior. Some of these build variants allow root access from the Android shell, as we’ll show in the following sections.</p><div class="sect3" title="Starting ADB as Root"><div class="titlepage"><div><div><h3 class="title"><a id="starting_adb_as_root"/>Starting ADB as Root</h3></div></div></div><p>Commercial devices use the <span class="emphasis"><em>user</em></span> build variant (the current build variant is set as the value of the <span class="emphasis"><em>ro.build.type</em></span> system property), which doesn’t include diagnostics and development tools, disables the ADB daemon by default, disallows debugging of applications that don’t explicitly set the <code class="literal">debuggable</code> attribute to <code class="literal">true</code> in their manifests, and disallows root access via the shell. The <span class="emphasis"><em>userdebug</em></span> build variant is very close to <span class="emphasis"><em>user</em></span>, but it also includes some additional modules (those with the <span class="emphasis"><em>debug</em></span> module tag), allows debugging of all apps, and enables ADB by default.</p><p>Engineering, or <span class="emphasis"><em>eng</em></span>, builds include most available modules, allow debugging, enable ADB by default, and set the <span class="emphasis"><em>ro.secure</em></span> system property to 0, which changes the behavior of the ADB daemon running on a device. When set to 1 (secure mode), the <span class="emphasis"><em>adbd</em></span> process, which initially runs as root, drops all capabilities from its capability bounding set with the exception of <code class="literal">CAP_SETUID</code> and <code class="literal">CAP_SETGID</code> (which are required to implement the <code class="literal">run-as</code> utility). It then adds several supplementary GIDs that are required to access network interfaces, external storage, and system logs, and finally changes its UID and GID to <code class="literal">AID_SHELL</code> (UID=2000). On the other hand, when <span class="emphasis"><em>ro.secure</em></span> is set to 0 (the default for engineering builds), the <span class="emphasis"><em>adbd</em></span> daemon continues to run as root and has the full capability bounding set. <a class="xref" href="ch13.html#adbd_process_details_on_a_user_build" title="Example 13-10. adbd process details on a user build">Example 13-10</a> shows the process IDs and capabilities for the <span class="emphasis"><em>adbd</em></span> process on a <span class="emphasis"><em>user</em></span> build.</p><div class="example"><a id="adbd_process_details_on_a_user_build"/><p class="title">Example 13-10. <span class="roman">adbd</span> process details on a <span class="roman">user</span> build</p><div class="example-contents"><pre class="programlisting"><span class="strong"><strong>$ getprop ro.build.type</strong></span>
user
<span class="strong"><strong>$ getprop ro.secure</strong></span>
1
<span class="strong"><strong>$ ps|grep adb</strong></span>
shell     200   1      4588   220    ffffffff 00000000 S /sbin/adbd
<span class="strong"><strong>$ cat /proc/200/status</strong></span>
Name: adbd
State:      S (sleeping)
Tgid: 200
Pid:  200
Ppid: 1
TracerPid: 0
Uid:  2000  2000 2000 2000➊
Gid:  2000  2000 2000 2000➋
FDSize:     32
Groups:     1003 1004 1007 1011 1015 1028 3001 3002 3003 3006➌
--<span class="emphasis"><em>snip</em></span>--
CapInh:     0000000000000000
CapPrm:     0000000000000000
CapEff:     0000000000000000
CapBnd:     fffffff0000000c0➍
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>As you can see, the process’s UID ➊ and GID ➋ are both set to 2000 (<code class="literal">AID_SHELL</code>), and the <span class="emphasis"><em>adbd</em></span> process has a number of supplementary GIDs added ➌. Finally, the process’s capability bounding set, which determines what capabilities child processes are allowed, is set to 0x0000000c0 (<code class="literal">CAP_SETUID|CAP_SETGID</code>) ➍. This capability setting guarantees that, on <span class="emphasis"><em>user</em></span> builds, processes started from Android’s shell are limited to the <code class="literal">CAP_SETUID</code> and <code class="literal">CAP_SETGID</code> capabilities, even if the executed binary has the SUID bit set, or its file capabilities permit additional privileges.</p><p>In contrast, on an <span class="emphasis"><em>eng</em></span> or <span class="emphasis"><em>userdebug</em></span> build, the ADB daemon can execute as root, as shown in <a class="xref" href="ch13.html#adbd_process_details_on_an_eng_build" title="Example 13-11. adbd process details on an eng build">Example 13-11</a>.</p><div class="example"><a id="adbd_process_details_on_an_eng_build"/><p class="title">Example 13-11. <span class="roman">adbd</span> process details on an <span class="roman">eng</span> build</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>getprop ro.build.type</strong></span>
userdebug➊
# <span class="strong"><strong>getprop ro.secure</strong></span>
1➋
# <span class="strong"><strong>ps|grep adb</strong></span>
root      19979 1     4656   264   ffffffff 0001fd1c S /sbin/adbd
root@maguro:/ # cat /proc/19979/status
Name: adbd
State:      S (sleeping)
Tgid: 19979
Pid:  19979
Ppid: 1
TracerPid:  0
Uid:  0     0     0    0➌
Gid:  0     0     0    0➍
FDSize:     256
Groups:➎
--<span class="emphasis"><em>snip</em></span>--
CapInh:     0000000000000000
CapPrm:     ffffffffffffffff➏
CapEff:     ffffffffffffffff➐
CapBnd:     ffffffffffffffff➑
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p><a id="iddle2627" class="indexterm"/><a id="iddle2877" class="indexterm"/>Here, the <span class="emphasis"><em>adbd</em></span> process runs with UID ➌ and GID ➍ 0 (root), has no supplementary groups ➎, and has the full set of Linux capabilities (➏, ➐, and ➑). However, as you can see at ➋, the <span class="emphasis"><em>ro.secure</em></span> system property is set to 1, which suggests that <span class="emphasis"><em>adbd</em></span> should not be running as root.</p><p>While the ADB daemon does drop its root privileges on <span class="emphasis"><em>userdebug</em></span> builds (as in this example, ➊), it can be manually restarted in insecure mode by issuing the <code class="literal">adb root</code> command from a host, as shown in <a class="xref" href="ch13.html#restarting_adbd_as_root_on_userdebug_bui" title="Example 13-12. Restarting adbd as root on userdebug builds">Example 13-12</a>.</p><div class="example"><a id="restarting_adbd_as_root_on_userdebug_bui"/><p class="title">Example 13-12. Restarting adbd <span class="emphasis"><em>as root on</em></span> userdebug <span class="emphasis"><em>builds</em></span></p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>adb shell id</strong></span>
uid=2000(shell) gid=2000(shell)➊ groups=1003(graphics),1004(input),1007
(log),1009(mount),1011(adb),1015(sdcard_rw),1028(sdcard_r),3001(net_bt_
admin),3002(net_bt),3003(inet),3006(net_bw_stats) context=u:r:shell:s0
$ <span class="strong"><strong>adb root</strong></span>➋
restarting adbd as root $
<span class="strong"><strong>$ adb shell ps|grep adb</strong></span>
root      2734  1     4644  216    ffffffff 0001fbec R /sbin/adbd➌
<span class="strong"><strong>$ adb shell id</strong></span>
uid=0(root) gid=0(root) context=u:r:shell:s0➍</pre></div></div><p>Here, the <span class="emphasis"><em>adbd</em></span> daemon is initially running as <span class="emphasis"><em>shell</em></span> (UID=2000), and any shells started from the host also have UID=2000 and GID=2000 ➊. Issuing the <code class="literal">adb root</code> command ➋ (which internally sets the <span class="emphasis"><em>service.adb.root</em></span> system property to 1) restarts the ADB daemon as root ➌, and any subsequently started shells have UID and GUID=0 ➍.</p><div class="note" title="Note"><h3 class="title"><a id="ch13note03"/>Note</h3><p><span class="emphasis"><em>Because this particular device has SELinux enabled, even though the UID and GID of the shell change, its security context (security label) stays the same:</em></span> u:r:shell:s0 <span class="emphasis"><em>in both</em></span> ➊ <span class="emphasis"><em>and</em></span> ➍<span class="emphasis"><em>. Therefore, even after obtaining a root shell via ADB, all processes started from the shell are still bound by the permissions granted to the</em></span> shell <span class="emphasis"><em>domain (unless allowed to transition to another domain by the MAC policy; see <a class="xref" href="ch12.html" title="Chapter 12. Selinux">Chapter 12</a> for details). In practice, as of Android 4.4, the</em></span> shell <span class="emphasis"><em>domain is unconfined, so when running as root, processes in this domain are allowed almost full control over the device.</em></span></p></div></div><div class="sect3" title="Using the su Command"><div class="titlepage"><div><div><h3 class="title"><a id="using_the_su_command"/>Using the su Command</h3></div></div></div><p>On <span class="emphasis"><em>userdebug</em></span> builds, root access can also be obtained without restarting ADB as root. This can be accomplished using the <code class="literal">su</code> (short for <span class="emphasis"><em>substitute user</em></span>, also referred to as <span class="emphasis"><em>switch user</em></span> and <span class="emphasis"><em>superuser</em></span>) command, which is installed with the SUID bit set, thus allowing calling processes to obtain a root <a id="iddle1081" class="indexterm"/><a id="iddle2628" class="indexterm"/>shell or execute a command as the specified UID (including UID=0). The default <code class="literal">su</code> implementation is very basic and only allows the <span class="emphasis"><em>root</em></span> and <span class="emphasis"><em>shell</em></span> users to use it, as shown in <a class="xref" href="ch13.html#default_su_implementation_for_userdebug" title="Example 13-13. Default su implementation for userdebug builds">Example 13-13</a>.</p><div class="example"><a id="default_su_implementation_for_userdebug"/><p class="title">Example 13-13. Default <span class="emphasis"><em><code class="literal">su</code> implementation for</em></span> userdebug <span class="emphasis"><em>builds</em></span></p><div class="example-contents"><pre class="programlisting">int main(int argc, char **argv)
{
    --<span class="emphasis"><em>snip</em></span>--
    myuid = getuid();
    if (myuid != AID_ROOT &amp;&amp; myuid != AID_SHELL) {➊
        fprintf(stderr,"su: uid %d not allowed to su\n", myuid);
        return 1;
    }

    if(argc &lt; 2) {
        uid = gid = 0;➋

    } else {
       --<span class="emphasis"><em>snip</em></span>--
    }
    if(setgid(gid) || setuid(uid)) {➌
        fprintf(stderr,"su: permission denied\n");
        return 1;
    }

    --<span class="emphasis"><em>snip</em></span>--

    execlp("/system/bin/sh", "sh", NULL);➍

    fprintf(stderr, "su: exec failed\n");
    return 1;
}</pre></div></div><p>The main function first checks whether the calling UID is <code class="literal">AID_ROOT</code> (0) or <code class="literal">AID_SHELL</code> (2000) ➊, and exits if called by a user with a different UID. It then sets the process UID and GID to 0 (➋ and ➌), and finally starts the Android shell ➍. Any commands executed from this shell inherit its privileges by default, thus allowing superuser access to the device.</p></div></div></div><div class="sect1" title="Root Access on Production Builds"><div class="titlepage"><div><div><h1 class="title"><a id="root_access_on_production_builds"/>Root Access on Production Builds</h1></div></div></div><p>As we learned in “<a class="xref" href="ch13.html#root_access_on_engineering_builds" title="Root Access on Engineering Builds">Root Access on Engineering Builds</a>”, commercial Android devices are usually based on the <span class="emphasis"><em>user</em></span> build variant. This means that the ADB daemon is running as the <span class="emphasis"><em>shell</em></span> user, and no <code class="literal">su</code> command is installed on the device.</p><p>This is a secure configuration, and most users should be able to achieve their device configuration and customization tasks with the tools provided by the platform, or with third-party applications such as custom launchers, <a id="iddle2325" class="indexterm"/><a id="iddle2623" class="indexterm"/><a id="iddle2629" class="indexterm"/><a id="iddle2633" class="indexterm"/>keyboards, or VPN clients. However, operations that modify the look and feel or core configuration of Android are not possible, and neither is low-level access to the underlying Linux OS. Such operations can only be performed by running certain commands with root privileges, which is why many power users seek to enable root access on their devices.</p><p>Obtaining root access on an Android device is commonly known as <span class="emphasis"><em>rooting</em></span> and can be fairly simple on devices that have an unlockable bootloader or nearly impossible on devices that don’t allow bootloader unlocking and take additional measures to prevent system partition modifications. In the next sections, we describe the typical rooting process and introduce some of the most popular “superuser” apps that enable and manage root access.</p><div class="sect2" title="Rooting by Changing the boot or system Image"><div class="titlepage"><div><div><h2 class="title"><a id="rooting_by_changing_the_boot_or_system_i"/>Rooting by Changing the boot or system Image</h2></div></div></div><p>On some Android devices, given an unlocked bootloader, a <span class="emphasis"><em>user</em></span> build can easily be turned into an engineering or <span class="emphasis"><em>userdebug</em></span> build by simply flashing a new boot image (often called a <span class="emphasis"><em>kernel</em></span>, or <span class="emphasis"><em>custom kernel</em></span>), which changes the values of the <span class="emphasis"><em>ro.secure</em></span> and <span class="emphasis"><em>ro.debuggable</em></span> system properties. Changing these properties allows the ADB daemon to execute as root and enables root access via the Android shell, as described in“<a class="xref" href="ch13.html#root_access_on_engineering_builds" title="Root Access on Engineering Builds">Root Access on Engineering Builds</a>”. However, most current Android <span class="emphasis"><em>user</em></span> builds disable this behavior at compile time (by not defining the <code class="literal">ALLOW_ADBD_ROOT</code> macro) and the values of the <span class="emphasis"><em>ro.secure</em></span> and <span class="emphasis"><em>ro.debuggable</em></span> system properties are ignored by the <span class="emphasis"><em>adbd</em></span> daemon.</p><p>Another way to enable root access is to unpack the system image, add a SUID <code class="literal">su</code> binary or a similar utility, and overwrite the <span class="emphasis"><em>system</em></span> partition with the new system image. This would typically allow root access not only from the shell, but from third-party applications as well. However, several security enhancements in Android 4.3<sup>[<a id="ch13fn07" href="#ftn.ch13fn07" class="footnote">143</a>]</sup> and later versions disallow apps from executing SUID programs by dropping all capabilities from the bounding set of Zygote-spawned processes, and mounting the <span class="emphasis"><em>system</em></span> partition with the <code class="literal">nosetuid</code> flag.</p><p>Additionally, on Android versions that set SELinux to enforcing mode, executing a process with root privileges does not typically change its security context, and such a process is still limited by the MAC policy. For these reasons, enabling root access on a recent Android version may not be as simple as changing a few system properties or copying a SUID binary to the device. Of course, replacing the <span class="emphasis"><em>boot</em></span> or <span class="emphasis"><em>system</em></span> image allows SELinux to be disabled and any security mitigation to be reverted, thus relaxing the device’s security level and enabling root access. However, such a radical approach is not unlike replacing the whole OS and may prevent the device from receiving system updates from the device manufacturer. This is undesirable in most cases, and several root methods that try to coexist with the stock OS of the device have been developed.</p></div><div class="sect2" title="Rooting by Flashing an OTA Package"><div class="titlepage"><div><div><h2 class="title"><a id="rooting_by_flashing_an_ota_package"/>Rooting by Flashing an OTA Package</h2></div></div></div><p><a id="iddle2364" class="indexterm"/><a id="iddle2630" class="indexterm"/><a id="iddle2880" class="indexterm"/>An OTA package can add or modify system files, without replacing the whole OS image, and is therefore a good candidate for adding root access to a device. Most popular superuser apps are distributed as a combination of an OTA package, which needs to be installed once, and a companion manager application, which can be updated online.</p><div class="sect3" title="SuperSU"><div class="titlepage"><div><div><h3 class="title"><a id="supersu"/>SuperSU</h3></div></div></div><p>We’ll use the SuperSU OTA package <sup>[<a id="ch13fn08" href="#ftn.ch13fn08" class="footnote">144</a>]</sup> and app <sup>[<a id="ch13fn09" href="#ftn.ch13fn09" class="footnote">145</a>]</sup> (developed by Jorrit “Chainfire” Jongma) to demonstrate how this approach works. SuperSU is currently the most popular superuser application and is actively maintained, keeping in step with the latest modifications to the Android platform. The SuperSU OTA package is similar in structure to a full system update package but contains only a small number of files, as shown in <a class="xref" href="ch13.html#contents_of_the_supersu_ota_package" title="Example 13-14. Contents of the SuperSU OTA package">Example 13-14</a>.</p><div class="example"><a id="contents_of_the_supersu_ota_package"/><p class="title">Example 13-14. Contents of the SuperSU OTA package</p><div class="example-contents"><pre class="programlisting">.
|-- arm/➊
|   |-- chattr
|   |-- chattr.pie
|   `-- su
|-- common/
|   |-- 99SuperSUDaemon➋
|   |-- install-recovery.sh➌
|   `-- Superuser.apk➍
|-- META-INF/
|   |-- CERT.RSA
|   |-- CERT.SF
|   |-- com/
|   |   `-- google/
|   |       `-- android/
|   |           |-- update-binary➎
|   |           `-- updater-script➏
|   `-- MANIFEST.MF
`-- x86/➐
    |-- chattr
    |-- chattr.pie
    `-- su</pre></div></div><p>The package contains a few native binaries compiled for the ARM ➊ and x86 ➐ platforms, scripts for starting and installing the SuperSU daemon (➋ and ➌), the APK file of the management GUI application ➍, and two updater scripts (➎ and ➏) that apply the OTA package.</p><p>In order to understand how SuperSU enables root access, we need to first examine its install process. To do so, let’s analyze the contents of the <code class="literal">update-binary</code> script ➎, shown in <a class="xref" href="ch13.html#supersu_ota_install_script" title="Example 13-15. SuperSU OTA install script">Example 13-15</a>. (SuperSU uses a regular shell script instead of a native binary, so <code class="literal">updater-script</code> is simply a placeholder.)</p><div class="example"><a id="supersu_ota_install_script"/><p class="title">Example 13-15. SuperSU OTA install script</p><div class="example-contents"><pre class="programlisting">#!/sbin/sh
--<span class="emphasis"><em>snip</em></span>--
ui_print "- Mounting /system, /data and rootfs"➊
mount /system
mount /data
mount -o rw,remount /system
--<span class="emphasis"><em>snip</em></span>--
mount -o rw,remount /
--<span class="emphasis"><em>snip</em></span>--
ui_print "- Extracting files"➋
cd /tmp
mkdir supersu
cd supersu
unzip -o "$ZIP"
--<span class="emphasis"><em>snip</em></span>--
ui_print "- Placing files"
mkdir /system/bin/.ext
cp $BIN/su /system/xbin/daemonsu➌
cp $BIN/su /system/xbin/su
--<span class="emphasis"><em>snip</em></span>--
cp $COM/Superuser.apk /system/app/Superuser.apk➍
cp $COM/install-recovery.sh /system/etc/install-recovery.sh➎
cp $COM/99SuperSUDaemon /system/etc/init.d/99SuperSUDaemon
echo 1 &gt; /system/etc/.installed_su_daemon
--<span class="emphasis"><em>snip</em></span>--
ui_print "- Setting permissions"
set_perm 0 0 0777 /system/bin/.ext➏
set_perm 0 0 $SUMOD /system/bin/.ext/.su
set_perm 0 0 $SUMOD /system/xbin/su
--<span class="emphasis"><em>snip</em></span>--
set_perm 0 0 0755 /system/xbin/daemonsu
--<span class="emphasis"><em>snip</em></span>--
ch_con /system/bin/.ext/.su➐
ch_con /system/xbin/su
--<span class="emphasis"><em>snip</em></span>--
ch_con /system/xbin/daemonsu
--<span class="emphasis"><em>snip</em></span>--
ui_print "- Post-installation script"
/system/xbin/su --install➑

ui_print "- Unmounting /system and /data"➒
umount /system
umount /data

ui_print "- Done !"
exit 0</pre></div></div><p><a id="iddle1514" class="indexterm"/><a id="iddle2878" class="indexterm"/><a id="iddle2881" class="indexterm"/>The update script first mounts the <span class="emphasis"><em>rootfs</em></span> filesystem and the <span class="emphasis"><em>system</em></span> and <span class="emphasis"><em>userdata</em></span> partitions in read-write mode ➊, and then it extracts ➋ and copies the included files to their intended locations on the filesystem. The <code class="literal">su</code> and <code class="literal">daemonsu</code> native binaries ➌ are copied to <span class="emphasis"><em>/system/xbin/</em></span>, which is the usual location of extra native binaries (binaries that are not necessary for running the Android OS). The root access management application is copied to <span class="emphasis"><em>/system/app/</em></span> ➍ and is automatically installed by the package manager when the device reboots. Next, the update script copies the <span class="emphasis"><em>install-recovery.sh</em></span> script to <span class="emphasis"><em>/system/etc/</em></span> ➎.</p><div class="note" title="Note"><h3 class="title"><a id="ch13note04"/>Note</h3><p><span class="emphasis"><em>As discussed in “<a class="xref" href="ch13.html#updating_the_recovery" title="Updating the Recovery">Updating the Recovery</a>”, this script is typically used to update the recovery image from the main OS, so you might be wondering why the SuperSU install is trying to update the recovery of the device. SuperSU uses this script to start some of its components at boot time, which we’ll discuss shortly.</em></span></p></div><p>The next step of the OTA package install process is to set the permissions ➏ and SELinux security labels ➐ of the installed binaries (<code class="literal">ch_con</code> is a shell function that calls the <code class="literal">chcon</code> SELinux utility and sets the <span class="emphasis"><em>u:object_r:system_file:s0</em></span> label). Finally, the script calls the <code class="literal">su</code> command with the <code class="literal">--install</code> option ➑ in order to perform some post-install initialization, and then unmounts <span class="emphasis"><em>/system</em></span> and <span class="emphasis"><em>/data</em></span> ➒. When the script exits successfully, the recovery reboots the device into the main Android OS.</p></div><div class="sect3" title="How SuperSU Is Initialized"><div class="titlepage"><div><div><h3 class="title"><a id="how_supersu_is_initialized"/>How SuperSU Is Initialized</h3></div></div></div><p>To understand how SuperSU is initialized, let’s look at the contents of the <span class="emphasis"><em>install-recovery.sh</em></span> script (see <a class="xref" href="ch13.html#contents_of_supersuapostrophes_install-r" title="Example 13-16. Contents of SuperSU’s install-recovery.sh script">Example 13-16</a>, with comments omitted), which is automatically executed by <code class="literal">init</code> on boot.</p><div class="example"><a id="contents_of_supersuapostrophes_install-r"/><p class="title">Example 13-16. Contents of SuperSU’s <span class="roman">install-recovery.sh</span> <span class="emphasis"><em>script</em></span></p><div class="example-contents"><pre class="programlisting">#!/system/bin/sh
/system/xbin/daemonsu --auto-daemon &amp;➊

/system/etc/install-recovery-2.sh➋</pre></div></div><p>The script first executes the <code class="literal">daemonsu</code> binary ➊, which starts a daemon process with root privileges. The next step executes the <span class="emphasis"><em>install-recovery-2.sh</em></span> script ➋, which may be used to perform additional initialization, necessary for other root apps. Using a daemon in order to allow apps to execute code with root privileges is required in Android 4.3 and later, because all apps (which are forked from <span class="emphasis"><em>zygote</em></span>) have their capability bounding set zeroed out, thus preventing them from executing privileged operations, even if they manage to start a process as root. Additionally, as of Android 4.4, SELinux is in enforcing mode, so any processes started by an application inherit its security context (typically <span class="emphasis"><em>untrusted_app</em></span>), and therefore are subject to the same MAC restrictions as the app itself.</p><p>SuperSU gets around these security restrictions by having apps use the <code class="literal">su</code> binary to execute commands as root, which in turn pipes those commands via a Unix domain socket to the <span class="emphasis"><em>daemonsu</em></span> daemon, which <a id="iddle1425" class="indexterm"/>ultimately executes the received commands as root within the <span class="emphasis"><em>u:r:init:s0</em></span> SELinux context. The processes in play are illustrated in <a class="xref" href="ch13.html#processes_started_when_an_app_requests_r" title="Example 13-17. Processes started when an app requests root access via SuperSU">Example 13-17</a>.</p><div class="example"><a id="processes_started_when_an_app_requests_r"/><p class="title">Example 13-17. Processes started when an app requests root access via SuperSU</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>ps -Z</strong></span>
LABEL                   USER    PID    PPID   NAME
u:r:init:s0             root    1      0      /init➊
--<span class="emphasis"><em>snip</em></span>--
u:r:zygote:s0           root    187    1      zygote➋
--<span class="emphasis"><em>snip</em></span>--
u:r:init:s0             root    209    1      daemonsu:mount:master➌
u:r:init:s0             root    210    209    daemonsu:master➍
--<span class="emphasis"><em>snip</em></span>--
u:r:init:s0             root    3969   210    daemonsu:10292➎
--<span class="emphasis"><em>snip</em></span>--
u:r:untrusted_app:s0    u0_a292 13637  187    com.example.app➏
u:r:untrusted_app:s0    u0_a209 15256  187    eu.chainfire.supersu➐
--<span class="emphasis"><em>snip</em></span>--
u:r:untrusted_app:s0    u0_a292 16831  13637  su➑
u:r:init:s0             root    16835  3969   /system/bin/sleep➒</pre></div></div><p>Here, the <code class="literal">com.example.app</code> app ➏ (whose parent process is <span class="emphasis"><em>zygote</em></span> ➋) requests root access by passing a command to the <code class="literal">su</code> binary using its <code class="literal">-c</code> option. As you can see, the <code class="literal">su</code> process ➑ executes as the same user (<span class="emphasis"><em>u0_a292</em></span>, UID=10292) and in the same SELinux domain (<span class="emphasis"><em>untrusted_app</em></span>) as the requesting app. However, the process ➒ of the command the app requested to be executed as root (<code class="literal">sleep</code> in this example) indeed executes as root in the <span class="emphasis"><em>init</em></span> SELinux domain (security context <span class="emphasis"><em>u:r:init:s0</em></span>). If we trace its parent PID (PPID, in the fourth column), we find that the <span class="emphasis"><em>sleep</em></span> process is started by the <span class="emphasis"><em>daemonsu:10292</em></span> process ➎, which is a <span class="emphasis"><em>daemonsu</em></span> instance dedicated to our example app (with UID=10292). The <span class="emphasis"><em>daemonsu:10292</em></span> process ➎ inherits its <span class="emphasis"><em>init</em></span> SELinux domain from the <span class="emphasis"><em>daemonsu:master</em></span> instance ➍, which is in turn started by the first <span class="emphasis"><em>daemonsu</em></span> instance ➌. This is the instance started via the <span class="emphasis"><em>install-recovery.sh</em></span> script (see <a class="xref" href="ch13.html#contents_of_supersuapostrophes_install-r" title="Example 13-16. Contents of SuperSU’s install-recovery.sh script">Example 13-16</a>), and it runs within the domain of its parent—the <span class="emphasis"><em>init</em></span> process ➊ (PID=1).</p><p>The <span class="emphasis"><em>eu.chainfire.supersu</em></span> process ➐ belongs to the SuperSU management application, which shows the root access grant dialog shown in <a class="xref" href="ch13.html#supersu_root_access_request_grant_dialog" title="Figure 13-6. SuperSU root access request grant dialog">Figure 13-6</a>.</p><div class="figure"><a id="supersu_root_access_request_grant_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00077"/><img src="figs/web/13fig06.png.jpg" alt="SuperSU root access request grant dialog"/></div></div><p class="title">Figure 13-6. SuperSU root access request grant dialog</p></div><p><a id="iddle1508" class="indexterm"/>Superuser access can be granted one time only, for a certain period of time, or permanently. SuperSU keeps an internal whitelist of apps that have been granted root access and does not show the grant dialog if the requesting app is already in the whitelist.</p><div class="note" title="Note"><h3 class="title"><a id="ch13note05"/>Note</h3><p><span class="emphasis"><em>SuperSU has a companion library,</em></span> libsuperuser,<sup>[<a id="ch13fn10" href="#ftn.ch13fn10" class="footnote">146</a>]</sup> <span class="emphasis"><em>which makes it easier to write root apps by providing Java wrappers for the different patterns of calling the <code class="literal">su</code> binary. The author of SuperSU also provides a comprehensive guide to writing root apps called</em></span> How-To SU.<sup>[<a id="ch13fn11" href="#ftn.ch13fn11" class="footnote">147</a>]</sup></p></div></div><div class="sect3" title="Root Access on Custom ROMs"><div class="titlepage"><div><div><h3 class="title"><a id="root_access_on_custom_roms"/>Root Access on Custom ROMs</h3></div></div></div><p>Custom ROMs that provide root access don’t have to go through <span class="emphasis"><em>install-recovery.sh</em></span> in order to start their superuser daemon (equivalent to SuperSU’s <span class="emphasis"><em>daemonsu</em></span>) because they can customize the startup process at will. For example, the popular CyanogenMod open source Android distribution starts its <span class="emphasis"><em>su</em></span> daemon from <span class="emphasis"><em>init.superuser.rc</em></span>, as shown in <a class="xref" href="ch13.html#startup_script_for_the_su_daemon_in_cyan" title="Example 13-18. Startup script for the su daemon in CyanogenMod">Example 13-18</a>.</p><div class="example"><a id="startup_script_for_the_su_daemon_in_cyan"/><p class="title">Example 13-18. Startup script for the <span class="roman">su</span> <span class="emphasis"><em>daemon in CyanogenMod</em></span></p><div class="example-contents"><pre class="programlisting">service su_daemon /system/xbin/su --daemon➊
    oneshot

on property:persist.sys.root_access=0➋
    stop su_daemon

on property:persist.sys.root_access=2➌
    stop su_daemon

on property:persist.sys.root_access=1➍
    start su_daemon

on property:persist.sys.root_access=3➎
    start su_daemon</pre></div></div><p>This <span class="emphasis"><em>init</em></span> script defines the <span class="emphasis"><em>su_daemon</em></span> service ➊, which can be started or stopped by changing the value of the <span class="emphasis"><em>persist.sys.root_access</em></span> persistent system property (➋ through ➎). The value of this property also determines whether root access should be granted only to apps, ADB shells, or both. Root access is disabled by default and can be configured via CyanogenMod’s Development options, as shown in <a class="xref" href="ch13.html#cyanogenmod_root_access_options" title="Figure 13-7. CyanogenMod root access options">Figure 13-7</a>.</p><div class="warning" title="Warning"><h3 class="title"><a id="ch13note06"/>Warning</h3><p><span class="emphasis"><em>While SuperSU and custom ROMs that allow root access take certain measures to regulate what apps are allowed to execute commands as root (usually by adding them to a whitelist), an implementation flaw could allow apps to bypass these measures and obtain root access without user confirmation. Therefore, root access should be disabled on everyday-use devices and used only when necessary for development or debugging.</em></span></p></div><div class="figure"><a id="cyanogenmod_root_access_options"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00078"/><img src="figs/web/13fig07.png.jpg" alt="CyanogenMod root access options"/></div></div><p class="title">Figure 13-7. CyanogenMod root access options</p></div></div></div><div class="sect2" title="Rooting via Exploits"><div class="titlepage"><div><div><h2 class="title"><a id="rooting_via_exploits"/>Rooting via Exploits</h2></div></div></div><p><a id="iddle2631" class="indexterm"/><a id="iddle2924" class="indexterm"/>On production devices that don’t have an unlockable bootloader, root access can be obtained by exploiting a privilege escalation vulnerability, which allows an app or shell process to start a root shell (also called <span class="emphasis"><em>soft root</em></span>) and modify the system. The exploits are typically packaged into “one-click” apps or scripts, which try to persist root access by installing a <code class="literal">su</code> binary or modifying system configuration. For example, the so-called towelroot exploit (which is distributed as an Android app) takes advantage of a vulnerability in the Linux kernel (CVE-2014-3153) to obtain root access and installs SuperSU in order to persist it. (Root access can also be persisted by overwriting the <span class="emphasis"><em>recovery</em></span> partition with a custom recovery, thus allowing the installation of arbitrary software, including superuser applications. However, some devices have additional protections that prevent modifications to the <span class="emphasis"><em>boot</em></span>, <span class="emphasis"><em>system</em></span>, and <span class="emphasis"><em>recovery</em></span> partitions, so permanent root access might not be possible.)</p><div class="note" title="Note"><h3 class="title"><a id="ch13note07"/>Note</h3><p><span class="emphasis"><em>See <a class="xref" href="ch03.html" title="Chapter 3. Package Management">Chapter 3</a> of the</em></span> Android Hacker’s Handbook <span class="emphasis"><em>(Wiley, 2014) for a detailed description of the major privilege-escalation vulnerabilities that have been used to obtain root access in various Android versions. <a class="xref" href="ch12.html" title="Chapter 12. Selinux">Chapter 12</a> of the same book introduces the main exploit-mitigation techniques that have been implemented in Android in order to prevent privilege-escalation attacks and generally harden the system.</em></span></p></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00033"/>Summary</h1></div></div></div><p>In order to allow for updating the system software or returning a device to its factory state, Android devices allow unrestricted, low-level access to their storage via the bootloader. The bootloader typically implements a management protocol, usually fastboot, that allows for transferring and flashing partition images from a host machine. Bootloaders on production devices are usually locked and allow flashing only of signed images. However, most bootloaders can be unlocked, thus allowing flashing images from third parties.</p><p>Android uses a dedicated partition to store a second, minimal OS, called a recovery, which is used to apply OTA update packages or clear all data on the device. Like bootloaders, recoveries on production devices typically allow applying only those OTA packages signed by the device manufacturer. If the bootloader is unlocked, a custom recovery, which allows installing updates signed by third parties or completely forgoes signature verification, can be booted or permanently installed.</p><p>Engineering or debug builds of Android allow root access via the Android shell, but root access is typically disabled on production devices. Root access on such devices can be enabled by installing a third-party OTA package that includes a “superuser” daemon and a companion application that allow controlled root access to applications. Third-party Android builds (ROMs) typically allow root access out of the box, although it can also be disabled via the system settings interface.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch13fn01" href="#ch13fn01" class="para">137</a>] </sup>Code Aurora Forum, “(L)ittle (K)ernel based Android bootloader,” <span class="emphasis"><em><a class="ulink" href="https://www.codeaurora.org/blogs/little-kernel-based-android-bootloader/">https://www.codeaurora.org/blogs/little-kernel-based-android-bootloader/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch13fn02" href="#ch13fn02" class="para">138</a>] </sup>Code Aurora Forum, <span class="emphasis"><em><a class="ulink" href="https://www.codeaurora.org/cgit/quic/la/kernel/lk/">https://www.codeaurora.org/cgit/quic/la/kernel/lk/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch13fn03" href="#ch13fn03" class="para">139</a>] </sup>Google, <span class="emphasis"><em>Android Compatibility Definition</em></span>, <span class="emphasis"><em><a class="ulink" href="https://static.googleusercontent.com/media/source.android.com/en//compatibility/android-cdd.pdf">https://static.googleusercontent.com/media/source.android.com/en//compatibility/android-cdd.pdf</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch13fn04" href="#ch13fn04" class="para">140</a>] </sup>Colin Percival, “Binary diff/patch utility,” <span class="emphasis"><em><a class="ulink" href="http://www.daemonology.net/bsdiff/">http://www.daemonology.net/bsdiff/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch13fn05" href="#ch13fn05" class="para">141</a>] </sup>TeamWin, “TWRP 2.7,” <span class="emphasis"><em><a class="ulink" href="http://teamw.in/project/twrp2/">http://teamw.in/project/twrp2/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch13fn06" href="#ch13fn06" class="para">142</a>] </sup>TeamWin, “Team Win Recovery Project (TWRP),” <span class="emphasis"><em><a class="ulink" href="https://github.com/TeamWin/Team-Win-Recovery-Project/">https://github.com/TeamWin/Team-Win-Recovery-Project/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch13fn07" href="#ch13fn07" class="para">143</a>] </sup>Google, “Security Enhancements in Android 4.3,” <span class="emphasis"><em><a class="ulink" href="http://source.android.com/devices/tech/security/enhancements43.html">http://source.android.com/devices/tech/security/enhancements43.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch13fn08" href="#ch13fn08" class="para">144</a>] </sup>Jorrit “Chainfire” Jongma, “CF-Root download page,” <span class="emphasis"><em><a class="ulink" href="http://download.chainfire.eu/supersu/">http://download.chainfire.eu/supersu/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch13fn09" href="#ch13fn09" class="para">145</a>] </sup>Jorrit “Chainfire” Jongma, “Google Play Apps: SuperSU,” <span class="emphasis"><em><a class="ulink" href="https://play.google.com/store/apps/details?id=eu.chainfire.supersu&amp;hl=en">https://play.google.com/store/apps/details?id=eu.chainfire.supersu&amp;hl=en</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch13fn10" href="#ch13fn10" class="para">146</a>] </sup>Jorrit “Chainfire” Jongma, libsuperuser, <span class="emphasis"><em><a class="ulink" href="https://github.com/Chainfire/libsuperuser/">https://github.com/Chainfire/libsuperuser/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch13fn11" href="#ch13fn11" class="para">147</a>] </sup>Jorrit “Chainfire” Jongma, “How-To SU Guidelines for problem-free su usage,” <span class="emphasis"><em><a class="ulink" href="http://su.chainfire.eu/">http://su.chainfire.eu/</a></em></span></p></div></div></div></body></html>