<html><head></head><body>
<div id="sbo-rt-content">
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch14">
<hgroup>
<h2 class="CHAPTER" id="ch14">
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_427" aria-label=" Page 427. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">NEO-NAZIS AND THEIR CHATROOMS</samp></span>
</h2>
</hgroup>
<p class="COS">In early August 2017, hundreds of white supremacists assembled in the city of Charlottesville, Virginia, for the Unite the Right rally. The protesters—hailing from groups like Vanguard America, Identity Evropa, League of the South, and the Ku Klux Klan—flew Nazi and Confederate battle flags, wore red “Make America Great Again” hats, and chanted slogans like “Jews will not replace us!”</p>

<p class="TX">On August 12, James Alex Fields Jr., described by his high school history teacher as “deeply into Adolf Hitler and white supremacy,” drove a car into a group of counterprotesters, murdering 32-year-old Heather Heyer and injuring 19 other people. Earlier in the event, Fields was seen marching with a Vanguard America shield. That same day, a group of six white men followed 20-year-old Black special ed assistant teacher DeAndre Harris into a parking garage and beat him with poles and metal pipes, an attack that was caught on film and posted to the internet. In response to the racist <span role="doc-pagebreak" epub:type="pagebreak" id="pg_428" aria-label=" Page 428. "/>violence, Trump famously said that there were “very fine people on both sides.”</p>

<p class="TX">The Unite the Right rally, like much of the American fascist movement’s activism during the 2017–2021 Trump presidency, was largely organized online using Discord, a group chat platform designed for gamers. In Discord, users join <i>servers</i>, a group of chatrooms, or a <i>channel</i>, a single chatroom. Each channel covers different topics. Fascists created Discord servers for their regional hate groups, as well as for projects like organizing Unite the Right.</p>

<p class="TX">An antifascist infiltrator gained access to the server used to organize Unite the Right, called Charlottesville 2.0, as well as many other servers used by fascists at the time. They then leaked the chat logs to Chris Schiano and Dan Feidt, journalists working with the independent nonprofit news collective Unicorn Riot. The leak took the form of screenshots from the Discord app, large JSON files containing thousands of messages, and audio recordings from voice meetings.</p>

<p class="TX">In this chapter, I describe how the JSON chat log files were structured and how I went about analyzing them, using techniques covered in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>. I’ll describe the custom app that I wrote to investigate this dataset and explain how I used it to investigate a Discord server called Pony Power, whose members doxed their political enemies. You’ll also learn the inside story of DiscordLeaks, Unicorn Riot’s public searchable archive based on my app, which contains millions of chat messages from far-right Discord servers. Finally, I discuss a major hack of the American neo-Nazi organization Patriot Front that took place four and a half years after the Charlottesville rally. This hack included chat logs from RocketChat, a self-hosted system that Unicorn Riot also hosts in DiscordLeaks.</p>

<p class="TX">Like my reporting on the AFLDS dataset, this case study is an example of journalism with real-world impact. My work, along with that of Unicorn Riot, antifascist infiltrators, and other anonymous developers, helped lead to a court settlement against the most notorious American white supremacist leaders and organizations, resulting in over $25 million worth of damages. I hope that this case study will inspire your own work on datasets of structured chat logs, should you obtain them in the future. With the rise of remote work and the increasing popularity of chat platforms like Discord, Slack, and RocketChat, this type of leak is only getting more common.</p>

<p class="TX">I’ll start with a brief description of how these chat logs were leaked.</p>

<section epub:type="division" aria-labelledby="sec1">
<h3 class="H1" id="sec1"><span id="h-343"/><samp class="SANS_Futura_Std_Bold_B_11">How Antifascists Infiltrated Neo-Nazi Discord Servers</samp></h3>

<p class="TNI">Unicorn Riot reporters covered the Unite the Right gathering on the ground in Charlottesville. In the following days, the collective announced that it had received anonymously leaked chat logs from the far-right groups that took part in the rally, and particularly from the Charlottesville 2.0 Discord server. It began publishing articles based on these leaks, showing evidence of premeditated plans for violence, memes about hitting protesters with cars, and posts made after the event celebrating Heather Heyer’s <span role="doc-pagebreak" epub:type="pagebreak" id="pg_429" aria-label=" Page 429. "/>murder. It also published ZIP files containing thousands of screenshots from the infiltrated Discord servers. Researchers, both amateur and professional, immediately began correlating breadcrumbs from these chat logs with photos and videos of the event that were posted to social media to identify specific fascist activists.</p>

<p class="TX">Alongside Charlottesville 2.0, other leaked fascist Discord servers had names like Vibrant Diversity, Ethnoserver, Safe Space 3, and 4th Reich. Some servers only had a few dozen users, while others had over a thousand. The most active server at the time, Vibrant Diversity, included a channel called #problematic_oven, where users shared racist memes. The 4th Reich server included a #rare_hitlers channel, where users shared vintage propaganda from Nazi Germany.</p>

<p class="TX">Once the reporting of Unicorn Riot and others had made it clear to Discord that Nazis were relying on its service, the chat platform shut down many far-right chat servers and accounts. “Discord’s mission is to bring people together around gaming. We’re about positivity and inclusivity. Not hate. Not violence,” the company said in a statement. “We will continue to take action against white supremacy, nazi ideology, and all forms of hate.” Shutting down individual servers and accounts didn’t work, though; fascists simply created new accounts and set up new chat servers. Just as quickly, antifascists infiltrated those new servers and continued to leak chat logs to Unicorn Riot.</p>

<p class="TX">Fascists started spreading conspiracy theories that there were no infiltrators but that Discord itself was selling their chat logs to the Southern Poverty Law Center, a nonprofit that monitors hate groups. “The Charlottesville planning server was leaked, even though it was highly secure and no one could figure out who could have leaked it,” Andrew Anglin, founder of the notorious neo-Nazi website the Daily Stormer, wrote in an April 2018 blog post. “Since then, servers have been repeatedly leaked. People have been doxed without being able to figure out how they were doxed. Repeatedly and consistently, I have been given reason to believe that these are not Discord ‘leaks,’ but data being bought by our enemies.” This wasn’t true, of course. Anglin provided no evidence for the claim, Discord’s privacy policy promises that it doesn’t sell user data, and we know exactly how the data was leaked: antifascists were invited into the group by pretending to be racists.</p>

<p class="TX">A few weeks after Unite the Right, I got a hold of some of these chat logs myself and began to analyze them.</p>
</section>

<section epub:type="division" aria-labelledby="sec2">
<h3 class="H1" id="sec2"><span id="h-344"/><samp class="SANS_Futura_Std_Bold_B_11">Analyzing Leaked Chat Logs</samp></h3>

<p class="TNI">In late August of 2017, after Unicorn Riot had started publishing articles based on leaked chats, someone from the collective asked me if I’d like to cover the fascist chat logs for The Intercept. While journalism can be competitive, with each newsroom racing to publish breaking news first without getting scooped, the opposite is often true when it comes to complicated datasets. When it’s clear that there’s no way that a single newsroom has the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_430" aria-label=" Page 430. "/>resources to discover all of the revelations in a dataset, it only makes sense to bring in other newsrooms and share access to the data. This sort of collaboration helps everyone because different newsrooms have different audiences, and it makes real-world impact from the reporting more likely.</p>

<p class="TX">My Unicorn Riot contact sent me a ZIP file full of JSON files and screenshots of Discord chats that covered several Discord servers. The JSON files contained more complete logs of everything posted to these chatrooms, while the screenshots captured only specific conversations. While screenshots are initially simpler to use because you don’t need to write any code or use special tools to read them, having the chat logs in a structured data format like JSON is much more useful in the long run. The best way to peruse screenshots of chats is to open individual images, read them one at a time, take note of the filenames that contain interesting content, and refer back to them as needed. This quickly becomes unwieldy when you’re dealing with thousands of screenshots.</p>

<p class="TX">I started digging into the JSON files to see what I was dealing with. Specifically, I used the handy command line tool <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> to figure out exactly how this data was structured in order to find the lists of users and channels and read the messages in each channel.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>Besides manually reading screenshots and taking notes, another option would have been to index the screenshots in software like Aleph, which you used in <a href="chapter5.xhtml">Chapter 5</a>. Aleph would then perform OCR on the images, extracting their text and enabling me to search them for keywords. This might be helpful in locating specific messages, but in the end, it’s still not as useful as structured data. If I were dealing with this data today and only had screenshots without access to JSON data, I would definitely rely on Aleph.</i></p>

<section epub:type="division" aria-labelledby="sec3">
<h4 class="H2" id="sec3"><span id="h-345"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Making JSON Files Readable</samp></h4>
<p class="TNI">Each JSON file within the ZIP file sent by my source contained the entire archive of chat logs from a given Discord server. For example, one 29MB JSON file was called <i>VibrantDiversityComplete-Sept5at327PM</i>. For the purposes of this book, I’ve renamed it <i>VibrantDiversity.json</i> to make the following examples easier to read.</p>

<p class="TX">When I opened this file in a text editor, its contents looked like this:</p>

<pre id="pre-577"><code>{"meta":{"users":{"231148326249037824":{"name":"D'Marcus Liebowitz"},"232213403974893569":{"nam
e":"northern_confederate"},"279620004641767424":{"name":"☇Unlimited Power☇"},"23338059623405977
6":{"name":"OrwellHuxley"},"289851780521787392":{"name":"badtanman"},"337421867700715524":{"nam
e":"spadegunner"},"315936522656546818":{"name":"erz1871"},"122932975724789761":{"name":"Archer"
},"201547638129164290":{"name":"SLUG2_"},"288899711929286667":{"name":"million plus"},"25019824
<var>--snip--</var></code></pre>
<p class="TX">This block of data is not very human-readable. As you learned in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>, it’s much easier to read JSON data that’s been reformatted using line breaks, indentation, and syntax highlighting. Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> command, I formatted it and added syntax highlighting in my terminal like so:</p>
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_431" aria-label=" Page 431. "/>
<pre id="pre-578"><code>micah@trapdoor Discord-JSON-Scrapes % <b>cat VibrantDiversity.json | jq</b>
{
  "meta": {
    "users": {
      "231148326249037824": {
        "name": "D'Marcus Liebowitz"
      },
      "232213403974893569": {
        "name": "northern_confederate"
      },
      "279620004641767424": {
        "name": "☇Unlimited Power☇"
      },
<var>--snip--</var></code></pre>
<p class="TX">Running this command added formatting and syntax highlighting to the file’s contents, but still resulted in 29MB of text madly scrolling through my terminal. To understand the data better, I needed to run more specific commands that would reveal its overall structure.</p>
</section>

<section epub:type="division" aria-labelledby="sec4">
<h4 class="H2" id="sec4"><span id="h-346"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring Objects, Keys, and Values with jq</samp></h4>
<p class="TNI">I could tell by looking at the beginning of the JSON data that the whole file was one large JSON object, and one of that object’s keys was <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>. I ran the following <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> command to see what other keys there were:</p>

<pre id="pre-579"><code><b>cat VibrantDiversity.json | jq 'keys'</b></code></pre>
<p class="TX">The output told me that the data for each Discord server includes two parts, <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>:</p>

<pre id="pre-580"><code>[
  "data",
  "meta"
]</code></pre>
<p class="TX">Guessing that <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> included the metadata for the server, I ran the following command to determine the keys of the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> object:</p>

<pre id="pre-581"><code><b>cat VibrantDiversity.json | jq '.meta | keys'</b></code></pre>
<p class="TX">This command piped the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">cat VibrantDiversity.json</samp> as input into the <samp class="SANS_TheSansMonoCd_W5Regular_11">jq '.meta | keys'</samp> command. It looks like there’s a second pipe there, but there’s not. The string <samp class="SANS_TheSansMonoCd_W5Regular_11">'.meta | keys'</samp> is actually just a single argument into <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>. The pipe character is how you chain multiple <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> filters together so that the output of one gets piped into the output of the next; in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta</samp> outputs the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> key and pipes it into <samp class="SANS_TheSansMonoCd_W5Regular_11">keys</samp>, which outputs the keys from that value.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_432" aria-label=" Page 432. "/>The output showed me that the metadata included information about channels, servers, and users:</p>

<pre id="pre-582"><code>[
  "channels",
  "servers",
  "userindex",
  "users"
]</code></pre>
<p class="TX">So far, I had only looked at the keys of JSON objects. It was time to look at some of the content, starting with the servers. By running <samp class="SANS_TheSansMonoCd_W5Regular_11">jq '.meta .servers'</samp>, I could look at the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp> key inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> object:</p>

<pre id="pre-583"><code><b>cat VibrantDiversity.json | jq '.meta.servers'</b></code></pre>
<p class="TX">The output in <a href="#list14-1">Listing 14-1</a> showed that <i>VibrantDiversity.json</i> lists a single server in the metadata sections, Vibrant Diversity, just as I expected.</p>

<pre id="pre-584"><code>[
  {
    "name": "Vibrant Diversity",
    "type": "SERVER"
  }
]</code></pre>
<p class="CodeListingCaption" id="list14-1"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-1: The list of servers in</samp> <samp class="SANS_Futura_Std_Book_11">VibrantDiversity.json</samp></p>

<p class="TX">I could tell that this output was an array, since it was a list of items surrounded by brackets ([and]).</p>

<p class="TX">Next, I wanted to see what channels this server had, so I ran the following command to view the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">channels</samp> key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> object:</p>

<pre id="pre-585"><code><b>cat VibrantDiversity.json | jq '.meta.channels'</b></code></pre>
<p class="TX"><a href="#list14-2">Listing 14-2</a> shows the output of this command.</p>

<pre id="pre-586"><code>{
  "274024266435919872": {
    "server": 0,
    "name": "rules"
  },
  "274262571367006208": {
    "server": 0,
    "name": "general"
  },
  "292812979555139589": {
    "server": 0,
    "name": "effortposting"
  },
  "288508006990348299": {
    "server": 0,
    "name": "problematic_oven"<span role="doc-pagebreak" epub:type="pagebreak" id="pg_433" aria-label=" Page 433. "/>
  },
  "274055625988898816": {
    "server": 0,
    "name": "music"
  },
  "343979974241550337": {
    "server": 0,
    "name": "gun-posting-goes-here"
  },
  "328841016352440320": {
    "server": 0,
    "name": "food-posting"
  },
  "274025126641795074": {
    "server": 0,
    "name": "share_contact_info"
  },
  "288901961313550336": {
    "server": 0,
    "name": "recruiting"
  }
}</code></pre>
<p class="CodeListingCaption" id="list14-2"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-2: The list of channels in the Vibrant Diversity server</samp></p>

<p class="TX">Whereas the output in <a href="#list14-1">Listing 14-1</a> was an array, the output for <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta.channels</samp> was a JSON object, as indicated by the braces (<samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>and}) surrounding it.</p>

<p class="TX">The keys for this object are long numbers, presumably the ID of the channel, and their values are objects that contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> keys. For example, the channel with key <samp class="SANS_TheSansMonoCd_W5Regular_11">288508006990348299</samp> has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">{"server": 0, "name": "problematic_oven"}</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp> value for all of these channels is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. I guessed that this was the index of the servers array from <a href="#list14-1">Listing 14-1</a>. Since there was only one server in this JSON file, the index for all of the channels is the first item in the list, <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> value was <samp class="SANS_TheSansMonoCd_W5Regular_11">problematic_oven</samp>. When I later read the chats in this channel, it was full of antisemitic posts and Nazi memes, and the word <i>oven</i> was clearly a reference to the Holocaust. This was definitely a neo-Nazi chat server.</p>

<p class="TX">I wanted to see a list of this server’s users, so I ran the following command to view the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">users</samp> key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> object:</p>

<pre id="pre-587"><code><b>cat VibrantDiversity.json | jq '.meta.users'</b></code></pre>
<p class="TX"><a href="#list14-3">Listing 14-3</a> shows my output.</p>

<pre id="pre-588"><code>{
  "231148326249037824": {
    "name": "D'Marcus Liebowitz"
  },
  "232213403974893569": {
    "name": "northern_confederate"
  },
  "279620004641767424": {<span role="doc-pagebreak" epub:type="pagebreak" id="pg_434" aria-label=" Page 434. "/>
    "name": "☇Unlimited Power☇"
  },
<var>--snip--</var></code></pre>
<p class="CodeListingCaption" id="list14-3"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-3: The list of users in the Vibrant Diversity server</samp></p>

<p class="TX">Just like the list of channels in <a href="#list14-2">Listing 14-2</a>, the output for <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta.users</samp> in <a href="#list14-3">Listing 14-3</a> is a JSON object. The keys are long numbers, presumably the ID of the user, and the values are objects with just a single key, the user’s name.</p>

<p class="TX">So far, I had explored the metadata keys <samp class="SANS_TheSansMonoCd_W5Regular_11">channels</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">users</samp>, but there was one left: the <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp> key. I ran the following command to view the <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp> key’s value:</p>

<pre id="pre-589"><code><b>cat VibrantDiversity.json | jq '.meta.userindex'</b></code></pre>
<p class="TX"><a href="#list14-4">Listing 14-4</a> shows my output.</p>

<pre id="pre-590"><code>[
  "231148326249037824",
  "232213403974893569",
  "279620004641767424",
<var>--snip--</var></code></pre>
<p class="CodeListingCaption" id="list14-4"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-4: The list of user IDs for each user in the Vibrant Diversity server</samp></p>

<p class="TX">The output for the <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta.userlist</samp> command was a JSON array rather than an object, and each item in the array was a string that looks like a Discord ID. Sure enough, the first item, <samp class="SANS_TheSansMonoCd_W5Regular_11">231148326249037824</samp>, turned out to be the ID of the first user from <a href="#list14-3">Listing 14-3</a>, D’Marcus Liebowitz. At this point I didn’t fully understand the purpose of <samp class="SANS_TheSansMonoCd_W5Regular_11">userlist</samp>, but it soon became clear, as you’ll see later in this section.</p>

<p class="TX">Armed with a basic understanding of the server’s metadata, I ran the following command to find the keys for the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> object:</p>

<pre id="pre-591"><code><b>cat VibrantDiversity.json | jq '.data | keys'</b></code></pre>
<p class="TX"><a href="#list14-5">Listing 14-5</a> shows my output.</p>

<pre id="pre-592"><code>[
  "274024266435919872",
  "274025126641795074",
  "274055625988898816",
  "274262571367006208",
  "288508006990348299",
  "288901961313550336",
  "292812979555139589",
  "328841016352440320",
  "343979974241550337"
]</code></pre>
<p class="CodeListingCaption" id="list14-5"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-5: The keys to the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">data</samp> object in the Vibrant Diversity server</samp></p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_435" aria-label=" Page 435. "/>These keys are the same channel IDs from <a href="#list14-2">Listing 14-2</a>, so I guessed that the values of each key contained the actual messages in those chat channels. Because I needed to start somewhere, I decided to view the chat messages from the #problematic_oven channel, so I ran the following command:</p>

<pre id="pre-593"><code><b>cat VibrantDiversity.json | jq '.data."288508006990348299"'</b></code></pre>
<p class="TX">The full argument for this <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> command is surrounded by single quotes. The <samp class="SANS_TheSansMonoCd_W5Regular_11">.data</samp> part of the filter looks in the key <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">."288508006990348299"</samp> part of the filter looks in the key <samp class="SANS_TheSansMonoCd_W5Regular_11">288508006990348299</samp>, which is the ID of the #problematic_oven channel. I put the ID in quotes so that <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> would know that this key was a string and not a number.</p>

<p class="TX">As with the first time I used <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> to read this JSON file, the output of this command scrolled through a large block of text, though considerably less than before. In this case, the output showed chat messages from only a single channel, rather than showing all of the data in the JSON file. <a href="#list14-6">Listing 14-6</a> shows just a few chat messages from the middle of the output.</p>

<pre id="pre-594"><code>micah@trapdoor Discord-JSON-Scrapes % <b>cat VibrantDiversity.json | jq</b> '.data
."288508006990348299"'
{
<var>--snip--</var>
  "352992491282366485": {
    "u": 4,
    "t": 1504230368205,
    "m": "we need more white girls with nice asses"
  },
  "352992512752746496": {
    "u": 4,
    "t": 1504230373324,
    "m": "no more gay jew shit"
  },
  "352992579949690890": {
    "u": 1,
    "t": 1504230389345,
    "m": "you're not allowed to oogle anyone whiter than med"
  },
  "352992652687441920": {
    "u": 1,
    "t": 1504230406687,
    "m": "if i catch you looking at anglo/celtic/nordic girls you're banned"
  },
<var>--snip--</var></code></pre>
<p class="CodeListingCaption" id="list14-6"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-6: Chat messages from the #problematic_oven channel in the Vibrant Diversity server</samp></p>

<p class="TX">Just like the channels in <a href="#list14-2">Listing 14-2</a>, this output is a JSON object with keys that contain long numbers. In this case, these keys appeared to be message IDs, and the values appeared to be details about that specific chat message. In each message, the <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> field represented the user and the <samp class="SANS_TheSansMonoCd_W5Regular_11">m</samp> field <span role="doc-pagebreak" epub:type="pagebreak" id="pg_436" aria-label=" Page 436. "/>contained the message content. The <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> field was a Unix timestamp, the number of seconds or sometimes milliseconds since January 1, 1970, a common way to represent specific dates and times in computer science. These particular timestamps were in milliseconds.</p>

<p class="TX">At this point, I knew that I was looking at a conversation between two neo-Nazis. The top two messages in <a href="#list14-6">Listing 14-6</a> are from a user with the ID of <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, and the bottom two messages are from a user with the ID of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. Because the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> gets bigger with each message, these appear to be displayed in chronological order. I decided to take a closer look at the message <samp class="SANS_TheSansMonoCd_W5Regular_11">352992512752746496</samp>, from user <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, with the timestamp <samp class="SANS_TheSansMonoCd_W5Regular_11">1504230373324</samp>.</p>
</section>

<section epub:type="division" aria-labelledby="sec5">
<h4 class="H2" id="sec5"><span id="h-347"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Timestamps</samp></h4>
<p class="TNI">Unix timestamps are a useful way for computers to store an entire date—the year, month, day, and time of day—in a single number. I needed to convert the timestamp associated with that message into human-readable format to find out the date and time when the message was posted.</p>

<p class="TX">I used the following lines of code in the Python interpreter to convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">1504230373324</samp> timestamp into a more human-readable Python <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp> object:</p>

<pre id="pre-595"><code>&gt;&gt;&gt; <b>from datetime import datetime</b>
&gt;&gt;&gt; <b>timestamp = datetime.fromtimestamp(1504230373324 / 1000)</b>
&gt;&gt;&gt; <b>print(timestamp)</b></code></pre>
<p class="TX">The syntax in this code is similar to the code you used to import modules in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>. Rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">module</samp>, this code takes the syntax <samp class="SANS_TheSansMonoCd_W5Regular_11">from</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">module</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">resource_name</samp>, loading a single <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp> resource from the <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp> module. Next, the code defines a variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">timestamp</samp> and sets its value to the return value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime.fromtimestamp()</samp> function. This function takes the number of seconds since January 1, 1970, as an argument. Because the Discord logs are in milliseconds rather than seconds, this code first divides the Discord timestamp by 1,000 to convert it to seconds before passing it into the function. The function returns a Python <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp> object.</p>

<p class="TX">When I displayed the <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp> object with <samp class="SANS_TheSansMonoCd_W5Regular_11">print(timestamp)</samp>, I could see that this chat message was posted on August 31, 2017, at 6:46 <small>PM</small>:</p>

<pre id="pre-596"><code>2017-08-31 18:46:13.324000</code></pre>
<p class="TX">I now had an idea of the timeframe in which this chat exchange took place. Next, I wanted to see which users were involved.</p>
</section>

<section epub:type="division" aria-labelledby="sec6">
<h4 class="H2" id="sec6"><span id="h-348"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Usernames</samp></h4>
<p class="TNI">I wanted to find the username for person who’d posted the <samp class="SANS_TheSansMonoCd_W5Regular_11">352992512752746496</samp> message in <a href="#list14-6">Listing 14-6</a>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> value for this message was <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, so I checked to see if <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> was a valid user ID from the output in <a href="#list14-3">Listing 14-3</a> but found that it wasn’t there; all of the user IDs in that JSON object are 18 digits long. I <span role="doc-pagebreak" epub:type="pagebreak" id="pg_437" aria-label=" Page 437. "/>turned to the output in <a href="#list14-4">Listing 14-4</a> that shows the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> object. The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp> is an array of strings, each an 18-digit user ID.</p>

<p class="TX">As described in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>, JSON arrays are lists of items in a specific order. Objects, on the other hand, don’t have any order. You select values from arrays using their numerical indices, starting from index 0 for the first item. Because objects don’t have numerical indices, there’s no concept of the first, second, or third item in the object; you could edit a JSON file to rearrange the object’s items, and it would still be the same object. For this reason, I guessed that the <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> value was actually an index of the <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp> array.</p>

<p class="TX">To determine which user ID corresponded to the user whose <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> value was <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, I looked for the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp> at index <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> by running the following command:</p>

<pre id="pre-597"><code><b>cat VibrantDiversity.json | jq '.meta.userindex[4]'</b></code></pre>
<p class="TX">This command is similar to the one in <a href="#list14-4">Listing 14-4</a>, but because it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta.userindex[4]</samp>, it selects the value at index <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> of the <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta.userindex</samp> array and just displays that result. My output showed that this value was the string <samp class="SANS_TheSansMonoCd_W5Regular_11">289851780521787392</samp>, an 18-digit user ID:</p>

<pre id="pre-598"><code>"289851780521787392"</code></pre>
<p class="TX">Now that I had a user ID, I used it in the following command to find the matching username:</p>

<pre id="pre-599"><code><b>cat VibrantDiversity.json | jq '.meta.users."289851780521787392"'</b></code></pre>
<p class="TX">Like the previous command, this command selects just one value to output. In this case, it selects the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> key, then the <samp class="SANS_TheSansMonoCd_W5Regular_11">users</samp> key, then the <samp class="SANS_TheSansMonoCd_W5Regular_11">289851780521787392</samp> key. The result is an object that includes a <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> key:</p>

<pre id="pre-600"><code>{
  "name": "badtanman"
}</code></pre>
<p class="BodyContinued">The name <i>badtanman</i> was the username I was looking for.</p>

<p class="TX">In the chat logs quoted in <a href="#list14-6">Listing 14-6</a>, the user <i>badtanman</i> is talking to someone with the <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. To find that person’s username, I ran the same commands, substituting the appropriate ID numbers:</p>

<pre id="pre-601"><code>micah@trapdoor Discord-JSON-Scrapes % <b>cat VibrantDiversity.json | jq '.meta.userindex[1]'</b>
"232213403974893569"
micah@trapdoor Discord-JSON-Scrapes % <b>cat VibrantDiversity.json | jq '.meta.users."232213403974</b>
<b>893569"'</b>
{
  "name": "northern_confederate"
}</code></pre>
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_438" aria-label=" Page 438. "/>I’d found that the snippet of chat messages in <a href="#list14-6">Listing 14-6</a> was a conversation between <i>badtanman</i> and <i>northern_confederate</i> on the night of August 31, 2017.</p>

<p class="TX">Running all of these <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> commands, along with running code in the Python interpreter to convert timestamps, is tedious. If confronted with a large volume of chat logs, you don’t want to research every group of messages this way. But when you’re exploring an unfamiliar dataset for the first time, you need to manually explore it like this until you better understand how the data is structured. After doing this preliminary analysis, I could use my new understanding of the chat logs to write Python scripts or even a full custom app (like I ended up developing for this dataset) to aid my research.</p>

<p class="TX">Before I actually started writing Python code to more easily parse these chat logs, though, I noticed a file that I’d missed before in the Unicorn Riot ZIP file that might make researching this dataset a lot easier.</p>
</section>

</section>

<section epub:type="division" aria-labelledby="sec7">
<h3 class="H1" id="sec7"><span id="h-349"/><samp class="SANS_Futura_Std_Bold_B_11">The Discord History Tracker</samp></h3>

<p class="TNI">The ZIP file from my Unicorn Riot contact had dozens of files in it, most of them JSON files and PNG screenshots, along with a few folders containing other JSON files. I’d immediately zeroed in on the JSON files to analyze their data structure, but until now I hadn’t noticed the file <i>logviewer.html</i>. This was an HTML and JavaScript file that, when opened in a web browser, would allow me to load JSON chat log files and read through them.</p>

<p class="TX">After talking with my Unicorn Riot contact, I learned that this local HTML file is part of a piece of open source software called Discord History Tracker. This software, not affiliated with Discord, lets users save an offline copy of everything they have access to in a given Discord server in JSON format. Antifascist activists used this software to exfiltrate chat logs from Vibrant Diversity, Charlottesville 2.0, and other fascist-run Discord servers.</p>

<p class="TX">Discord History Tracker included two components. The main component was in charge of actually creating a backup of a Discord server. The user would load the Discord server in their web browser, open their developer tools, and copy and paste the Discord History Tracker JavaScript code into their browser’s console. This would then scrape all of the data in the Discord server and save a backup file in JSON format. The second component of Discord History Tracker was the <i>logviewer.html</i> file, which contained offline HTML software for viewing those backup files.</p>

<p class="TX"><a href="#fig14-1">Figure 14-1</a> shows <i>logviewer.html</i> loaded in a web browser. In the screenshot, I’ve scrolled to the aforementioned messages between <i>badtanman</i> and <i>northern_confederate</i> from the #problematic_oven channel.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>The screenshot in <a href="#fig14-1">Figure 14-1</a> shows software from 2017. The Discord History Tracker interface has changed considerably since then. Among other changes, it now saves the data in SQLite databases, rather than as JSON files, and you can view the logs in a desktop app instead of using the</i> <span class="note_Italic">logviewer.html</span> <i>file. You can learn more about the software at</i> <a href="https://dht.chylex.com"><span class="note_LinkURL_I">https://dht.chylex.com</span></a><i>.</i></p>
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_439" aria-label=" Page 439. "/>
<figure class="IMG"><img class="img100" id="fig14-1" src="Images/Figure14-1.png" alt="A screenshot of the Discord log viewer web application, showing the chat logs from the #problematic_oven channel in the Vibrant Diversity Discord server." width="696" height="578"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: The August 31, 2017, chat between</samp> <samp class="SANS_Futura_Std_Book_11">badtanman</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_11">northern_confederate</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">, viewed in the Discord Offline History web app</samp></p></figcaption>
</figure>
<p class="TX">This offline HTML viewer software made it considerably easier to navigate and read the contents of the JSON files. I could click through the channels on the left, and then read through a page of chats at a time. However, it also lacked some features that would be important for my ongoing investigation:</p>
<ul class="BL">
<li class="BL">There was no simple way to search for individual messages. For example, suppose I wanted to search for mentions of Berkeley, the city I lived in at the time. I would have to click a channel like #general, use my web browser’s search feature to search for <i>Berkeley</i>, and then find which messages appeared in the #general channel. I would also need to change the settings to display all messages per page so I could search them all at once, rather than displaying just 1,000 messages at a time, as shown in <a href="#fig14-1">Figure 14-1</a>. I would then have to replicate this search for every other channel in the server, and if I wanted to search other Discord servers as well, I’d have to replicate it for each channel in each server.</li>
<li class="BL">The offline viewer only supported looking at one server at a time, but I wanted to be able to search multiple servers at once and also track a single user’s messages across different servers.</li>
<li class="BL"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_440" aria-label=" Page 440. "/>There was no way to generate hyperlinks leading to individual messages. When you’re taking notes for a story based on chat logs like this, it’s helpful to track the messages of interest. Without links, you’ll regularly have to go back and search for specific messages all over again.</li>
</ul>
<p class="TX">I decided to build my own web application to add these missing features. I already had all of the chat logs in a structured format, which is by far the biggest requirement to build a custom app, as you learned in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>’s discussion of BlueLeaks Explorer. If I’d had only screenshots of the Discord servers, a custom app with these features wouldn’t have been possible. Screenshots aren’t structured data, and there’s no easy way to write software that allows you to browse the chat messages they contain.</p>
</section>

<section epub:type="division" aria-labelledby="sec8">
<h3 class="H1" id="sec8"><span id="h-350"/><samp class="SANS_Futura_Std_Bold_B_11">A Script to Search the JSON Files</samp></h3>

<p class="TNI">As you’ve learned throughout this book, understanding how the data is structured is a prerequisite to writing code that works with it. Therefore, I decided to use the knowledge I’d gained from manually investigating the JSON files with <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> to build a simple Python script that let me search one of the JSON files for keywords. Initially I thought I might be able to use this script to do all of the analysis I needed, but that turned out to be wrong; I ended up writing a complete custom app to investigate this dataset as well. Even so, this first (considerably simpler) script allowed me to use Python code to express the structure of the dataset that I’d already gleaned, which simplified the process of programming the full web app. In this section I go over exactly how my initial Discord JSON search script worked.</p>

<p class="TX">For example, I knew my script needed to be able to display chat messages based on what I searched for. Let’s say I wanted my code to display the following chat message from <a href="#list14-6">Listing 14-6</a>:</p>

<pre id="pre-602"><code>"352992491282366485": {
  "u": 4,
  "t": 1504230368205,
  "m": "we need more white girls with nice asses"
}</code></pre>
<p class="TX">The value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> key is <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, but now I knew how to find the actual username of the person who posted this message. First, my code needed to look in the JSON’s <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> object and select the fourth item in the <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp> array, which is the user ID <samp class="SANS_TheSansMonoCd_W5Regular_11">289851780521787392</samp>. My code then would look again in the JSON’s <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> object, this time for the <samp class="SANS_TheSansMonoCd_W5Regular_11">users</samp> key, and use that user ID as the key to get this user object:</p>

<pre id="pre-603"><code>{
  "name": "badtanman"
}</code></pre>
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_441" aria-label=" Page 441. "/>My code would select the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> string from that object to get the username of the message poster, <samp class="SANS_TheSansMonoCd_W5Regular_11">badtanman</samp>, and then replicate the whole process to display the correct username for every message.</p>

<p class="TX">I opened my text editor and started writing a Python script, <i>discord-json -search.py</i>, to search one of the JSON files for keywords. Here’s my completed source code (you can also find it at <a href="https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-14/discord-analysis/discord-json-search.py"><i>https://<wbr/>github<wbr/>.com<wbr/>/micahflee<wbr/>/hacks<wbr/>-leaks<wbr/>-and<wbr/>-revelations<wbr/>/blob<wbr/>/main<wbr/>/chapter<wbr/>-14<wbr/>/discord<wbr/>-analysis<wbr/>/discord<wbr/>-json<wbr/>-search<wbr/>.py</i></a>):</p>

<pre id="pre-604"><code>#!/usr/bin/python3
import sys
import json
import click
from datetime import datetime

def highlight(message, query): <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span>
    new_message = ""
    index = 0
    while True:
        new_index = message.lower().find(query.lower(), index)
        if new_index &gt; 0:
            # Found
            new_message += message[index:new_index]
            new_message += click.style(
                message[new_index : new_index + len(query)], underline=True
            )
            index = new_index + len(query)
        else:
            # Not found
            new_message += message[index:]
            break

    return new_message

def display(channel_name, server_name, user_name, timestamp, message, query): <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span>
    click.echo(
        "{} {}".format(
            click.style("#{}".format(channel_name), fg="bright_magenta"),
            click.style("[server: {}]".format(server_name), fg="bright_black"),
        )
    )
    click.echo(
        "{} {}".format(
            click.style(user_name, bold=True),
            click.style(timestamp.strftime("%c"), fg="bright_black"),
        )
    )
    click.echo(highlight(message, query))
    click.echo("")

def search(data, query): <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span>
    # Loop through each channel
    for channel_id in data["data"]: <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span>
        # Get the channel name and server name
        channel_name = data["meta"]["channels"][channel_id]["name"] <span class="CodeAnnotationCode-1" aria-label="annotation5">❺</span><span role="doc-pagebreak" epub:type="pagebreak" id="pg_442" aria-label=" Page 442. "/>
        server_name = data["meta"]["servers"][
            data["meta"]["channels"][channel_id]["server"]
        ]["name"]

        for message_id in data["data"][channel_id]: <span class="CodeAnnotationCode-1" aria-label="annotation6">❻</span>
            # Pull the user data, timestamp, and message body from the message
            user_index = data["data"][channel_id][message_id]["u"]
            user_id = data["meta"]["userindex"][user_index]
            user_name = data["meta"]["users"][user_id]["name"]
            timestamp = datetime.fromtimestamp(
                data["data"][channel_id][message_id]["t"] / 1000
            )
            message = data["data"][channel_id][message_id]["m"]

            # Is the query in the message?
            if query.lower() in message.lower(): <span class="CodeAnnotationCode-1" aria-label="annotation7">❼</span>
                display(channel_name, server_name, user_name, timestamp, message, query) 

@click.command()
@click.argument("filename", type=click.Path(exists=True))
@click.argument("query")
def main(filename, query): <span class="CodeAnnotationCode-1" aria-label="annotation8">❽</span>
    # Load the JSON file
    try:
        with open(filename) as f:
            data = json.loads(f.read())
    except:
        print("Failed to load JSON file")
        sys.exit()

    # Search
    search(data, query)


if __name__ == "__main__":
    main()</code></pre>
<p class="TX">It’s simplest to explain how this script worked from bottom to top, since that’s how it executed and also how I programmed it. The <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function <span class="CodeAnnotation" aria-label="annotation8">❽</span> is a Click command that takes two arguments: the filename for a JSON file with Discord chat logs called <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>, and a search term called <samp class="SANS_TheSansMonoCd_W5Regular_11">query</samp>. The code opened the filename that was passed in and parsed it using <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp> to turn it into a JSON object. Then it called the <samp class="SANS_TheSansMonoCd_W5Regular_11">search()</samp> function, passing in the data from the JSON file and the search query.</p>

<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">search()</samp> function <span class="CodeAnnotation" aria-label="annotation3">❸</span> is where all the magic happened. I knew from my previous analysis that these Discord JSON objects had two keys: the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> key, which contained the messages in each channel, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> key, which contained metadata about these messages. My script started by looping through every channel in <samp class="SANS_TheSansMonoCd_W5Regular_11">data['data']</samp> <span class="CodeAnnotation" aria-label="annotation4">❹</span>, then using its <samp class="SANS_TheSansMonoCd_W5Regular_11">channel_id</samp> to look up that channel’s name and server in the metadata <span class="CodeAnnotation" aria-label="annotation5">❺</span>. It then looped through <span role="doc-pagebreak" epub:type="pagebreak" id="pg_443" aria-label=" Page 443. "/>every message in that channel <span class="CodeAnnotation" aria-label="annotation6">❻</span> and stored the message’s username, timestamp, and the message itself in variables.</p>

<p class="TX">The code then checked to see if the search query that was passed into the script as a CLI argument (stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">query</samp>) existed in the message (stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>) <span class="CodeAnnotation" aria-label="annotation7">❼</span>. As described in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, it converted both strings to lowercase using the <samp class="SANS_TheSansMonoCd_W5Regular_11">lower()</samp> method to make the search case insensitive. If the lowercase version of the message contained the lowercase version of the search term, the script then passed all of the relevant variables into the <samp class="SANS_TheSansMonoCd_W5Regular_11">display()</samp> function to display the message in the terminal.</p>

<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">display()</samp> function <span class="CodeAnnotation" aria-label="annotation2">❷</span> took arguments for metadata about a message, the message text itself, and the search term and used those to display the message. This code used <samp class="SANS_TheSansMonoCd_W5Regular_11">click.echo()</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> to display text to the terminal, and it used <samp class="SANS_TheSansMonoCd_W5Regular_11">click.style()</samp> to apply different colors and formatting. (You could do all of this just with the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function, but the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp> module makes it simpler to style terminal output.) After displaying two lines of metadata for the message, the script then displayed the output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">highlight()</samp> function, which returned the message itself in color with the search term underlined.</p>

<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">highlight()</samp> function <span class="CodeAnnotation" aria-label="annotation1">❶</span> created an empty string called <samp class="SANS_TheSansMonoCd_W5Regular_11">new_message</samp> and then made it a copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>, the original message it displayed, except with all instances of the search term underlined using <samp class="SANS_TheSansMonoCd_W5Regular_11">click.style()</samp>. It then returned <samp class="SANS_TheSansMonoCd_W5Regular_11">new_message</samp> and displayed it to the terminal in the <samp class="SANS_TheSansMonoCd_W5Regular_11">display()</samp> function.</p>

<p class="TX">For example, if I wanted to search <i>VibrantDiversity.json</i> for the term <i>berkeley</i>, I could run:</p>

<pre id="pre-605"><code><b>python3 discord-json-search.py ~/datasets/Discord-JSON-Scrapes/VibrantDiversity.json "berkeley"</b></code></pre>
<p class="TX">The output listed over a hundred chat messages that mentioned Berkeley. Each message showed the name of the channel, the name of the Discord server, the user who posted it and when, and the content of the message. Here’s the first snippet of output, which highlighted the search term in the message with an underline:</p>

<pre id="pre-606"><code>#general [server: Vibrant Diversity]
Hector Sun Sep  3 20:19:11 2017
Look at how many antifa were at Boston and <u>Berkeley</u>.  We need numbers.  We can't have rallies with less than a thousand people now.  Even that's a low number.
<var>--snip--</var></code></pre>
<p class="TX">The first message that mentioned Berkeley was a post from the user <i>Hector</i> in the #general channel on September 3, 2017. This user was complaining about the relatively small number of fascists that showed up to their rallies in Boston and Berkeley, compared to the “antifa” counterprotesters.</p>

<p class="TX">This script allowed me to search a full Discord server for keywords, but it still lacked several of the features that I wanted: it could work with only <span role="doc-pagebreak" epub:type="pagebreak" id="pg_444" aria-label=" Page 444. "/>one Discord leak at a time, and there was no easy way to browse through and read the data sequentially or to save links to specific interesting messages. I started building out a web application to help me perform these missing tasks.</p>
</section>

<section epub:type="division" aria-labelledby="sec9">
<h3 class="H1" id="sec9"><span id="h-351"/><samp class="SANS_Futura_Std_Bold_B_11">My Discord Analysis Code</samp></h3>

<p class="TNI">I’ve found that after obtaining a large dataset full of structured data, building a custom web application to explore it, as I did with BlueLeaks Explorer, makes it much easier to find its hidden revelations. After writing <i>discord-json -search.py</i>, I spent about a week creating Discord Analysis, a custom web app to analyze leaked Discord chat logs.</p>

<p class="TX">Since I wanted to be able to search multiple Discord servers at once, I decided that the best solution would be to convert all of the data from JSON files into a SQL database. I used a Python tech stack that I was already familiar with, Flask (discussed briefly in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>), for the web app and SQLAlchemy for communicating with the SQL database.</p>

<p class="TX">SQLAlchemy is an <i>Object Relational Mapping (ORM)</i> Python module that’s useful for making code that works with SQL databases simpler to write and more secure. ORMs allow you to work with SQL databases in such a way that you don’t have to directly write any SQL code yourself, which means your projects won’t be vulnerable to SQL injection. This web app used Flask-SQLAlchemy, a Flask extension that adds SQLAlchemy support to Flask apps.</p>

<p class="TX">While developing my Discord Analysis web app, I was actively using it to research the leaked neo-Nazi chat logs. If I had new questions about the data (like what other messages a user posted) or found that I needed new features (like limiting my search to a single server), I would program them in as I went along. This is typically how I build research tools: I start using them long before they’re complete, and I let the direction of my research guide which features I add next.</p>

<p class="TX">In this section, I explain how I went about developing the different components of the app: designing a SQL database, importing chat logs from the Discord JSON files into that database, and building the web interface to research the chat logs. You’ll learn how I used SQLAlchemy to define database tables, insert rows into them, and select rows from them. You’ll also learn how I used Flask to build this web app, including how to make Jinja templates and how to define routes—skills you’ll need if you build your own Flask web apps in the future.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>Fully explaining how to build a Flask and SQLAlchemy web app is outside the scope of this book. Instead, I go over how I went about building this app in broad strokes, which should still be useful if you ever decide to build a similar one yourself. The best way to learn how to make your own Flask app is by exploring Flask’s excellent documentation at</i> <a href="https://flask.palletsprojects.com"><span class="note_LinkURL_I">https://flask.palletsprojects.com</span></a><i>;</i> <i>that’s how I learned. The Flask documentation includes a tutorial that walks you through every step of developing</i> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_445" aria-label=" Page 445. "/><i>a simple web app. The Python skills you’ve learned from <a href="chapter7.xhtml">Chapters 7</a> and <a href="chapter8.xhtml">8</a> are more than enough for you to follow along with the tutorial. You can also find docs for SQLAlchemy at</i> <a href="https://www.sqlalchemy.org"><span class="note_LinkURL_I">https://<wbr/>www<wbr/>.sqlalchemy<wbr/>.org</span></a> <i>and for Flask’s SQLAlchemy extension at</i> <a href="https://flask-sqlalchemy.palletsprojects.com"><span class="note_LinkURL_I">https://flask-sqlalchemy.palletsprojects.com</span></a><i>.</i></p>

<p class="TX">The code for Discord Analysis, which has quietly been public on my GitHub account for years, hasn’t been updated much since 2017, with the exception of some small changes I made when preparing it for this book. I don’t plan on maintaining it. Still, you should be able to get it running locally if you’d like to explore it further, and you can use it as inspiration for your own future projects that use a similar tech stack. Read through this section to see how it works, and then if you’re curious, try getting it running locally yourself.</p>

<p class="TX">As I explain the app, I’ll quote sections of the source code. It’s too long to include all of it here, but you can find the full code online in the book’s GitHub repository at <a href="https://github.com/micahflee/hacks-leaks-and-revelations/tree/main/chapter-14/discord-analysis"><i>https://<wbr/>github<wbr/>.com<wbr/>/micahflee<wbr/>/hacks<wbr/>-leaks<wbr/>-and<wbr/>-revelations<wbr/>/tree<wbr/>/main<wbr/>/chapter<wbr/>-14<wbr/>/discord<wbr/>-analysis</i></a>. I recommend that you pull up the full source code for each file as I describe how it works.</p>

<section epub:type="division" aria-labelledby="sec10">
<h4 class="H2" id="sec10"><span id="h-352"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Designing the SQL Database</samp></h4>
<p class="TNI">I started my web app with a Python script called <i>app.py</i>. You can find the full source code for this file at <a href="https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-14/discord-analysis/app.py"><i>https://<wbr/>github<wbr/>.com<wbr/>/micahflee<wbr/>/hacks<wbr/>-leaks<wbr/>-and<wbr/>-revelations<wbr/>/blob<wbr/>/main<wbr/>/chapter<wbr/>-14<wbr/>/discord<wbr/>-analysis<wbr/>/app<wbr/>.py</i></a>. First, my code imported the appropriate Flask and SQLAlchemy modules, created a new Flask app object called <samp class="SANS_TheSansMonoCd_W5Regular_11">app</samp>, and created a new Flask-SQLAlchemy object called <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>:</p>

<pre id="pre-607"><code>from flask import Flask, render_template, request, escape, flash, redirect
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///database.sqlite3"
app.config["DEBUG"] = True

db = SQLAlchemy(app)</code></pre>
<p class="TX">I started by importing several items from the <samp class="SANS_TheSansMonoCd_W5Regular_11">flask</samp> module, like <samp class="SANS_TheSansMonoCd_W5Regular_11">Flask</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">render_template</samp>, that I knew I’d need later in the program. In the next line, I also imported <samp class="SANS_TheSansMonoCd_W5Regular_11">SQLAlchemy</samp> from the <samp class="SANS_TheSansMonoCd_W5Regular_11">flask_sqlalchemy</samp> module.</p>

<p class="TX">Using the newly imported <samp class="SANS_TheSansMonoCd_W5Regular_11">Flask</samp>, I then created a Flask object called <samp class="SANS_TheSansMonoCd_W5Regular_11">app</samp>. Every Flask web app includes such an object (and usually by that name) to define exactly how the app will work. I modified the <samp class="SANS_TheSansMonoCd_W5Regular_11">app.config</samp> dict to set some configuration settings, telling it that I wanted to use a SQLite3 database stored in the file <i>database.sqlite3</i>, and I wanted to turn debug mode on, which is useful while you’re actively developing a web app. Finally, I created the SQLAlchemy object called <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>, passing in <samp class="SANS_TheSansMonoCd_W5Regular_11">app</samp>.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_446" aria-label=" Page 446. "/>For the next bit of code, I’ll introduce you to a new Python concept that I didn’t explicitly cover in <span class="Xref"><a href="part3.xhtml">Part III</a></span> but that you’ve technically been using all along: classes. In Python, a <i>class</i> is a template for creating new objects that can store data (using variables called <i>attributes</i>) and perform actions (using functions called <i>methods</i>). For example, strings are technically classes. When you run the code <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">"example"</samp>, the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> is an instance of the string class, the data it stores is the string <samp class="SANS_TheSansMonoCd_W5Regular_11">example</samp>, and it has a bunch of methods you can call on it, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">s.upper()</samp>, which returns an uppercase version of the string. When you write SQLAlchemy code, you define a class for each database table. This way, you can write code that works with Python objects without needing to write the SQL queries yourself.</p>

<p class="TX">I started writing code to define the SQL tables that would store Discord data for servers, users, channels, and messages. For example, the following code defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> class, which represents the SQL table to store data about servers:</p>

<pre id="pre-608"><code>class Server(db.Model):
    id = db.Column(db.Integer, autoincrement=True, primary_key=True)
    name = db.Column(db.String(128), unique=True, nullable=False)

    channels = db.relationship("Channel", back_populates="server")
    messages = db.relationship("Message", back_populates="server")

    def __init__(self, name):
        self.name = name</code></pre>
<p class="TX">Using SQLAlchemy requires that you define your own classes. You can think of this <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> class as a description of a new type of Python object that represents a row in the server SQL table. Because I defined it as <samp class="SANS_TheSansMonoCd_W5Regular_11">Server(db .Model)</samp>, this class inherited all of the functionality of the <samp class="SANS_TheSansMonoCd_W5Regular_11">db.Model</samp> class, which is part of SQLAlchemy. Inside the class definition, I defined the table’s columns: <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp> (an auto-incrementing number) and <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> (a string). Next, I defined this table’s relationships to other tables, in this case relating <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">channels</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">messages</samp>—both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp> table and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Message</samp> table have a <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp> column.</p>

<p class="TX">Finally, I defined the <samp class="SANS_TheSansMonoCd_W5Regular_11">__init__()</samp> method. When you define a class, you must call the first argument of every method <samp class="SANS_TheSansMonoCd_W5Regular_11">self</samp> to represent this Python object itself. You can optionally include other arguments, too. The <samp class="SANS_TheSansMonoCd_W5Regular_11">__init__()</samp> method is a type of method called a <i>constructor</i>, which runs as soon as you create the object. This constructor sets the value of the object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> attribute (which you access within the class as <samp class="SANS_TheSansMonoCd_W5Regular_11">self.name</samp>) to the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>, which is a variable passed into the <samp class="SANS_TheSansMonoCd_W5Regular_11">__init__()</samp> method as an argument.</p>

<p class="TX">For example, to add a row to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> table in the SQL database for the Vibrant Diversity Discord server, I could run the code in <a href="#list14-7">Listing 14-7</a>. (My Discord Analysis app doesn’t actually use this code—it loads the servers from the JSON data—but I’m including this example to help you understand how to use SQLAlchemy classes to interact with databases without needing to write SQL queries.)</p>
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_447" aria-label=" Page 447. "/>
<pre id="pre-609"><code>server = Server("Vibrant Diversity")
db.session.add(server)
db.session.commit()</code></pre>
<p class="CodeListingCaption" id="list14-7"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-7: Using SQLAlchemy to insert data into a SQL database</samp></p>

<p class="TX">The first line of code creates a <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> object by running <samp class="SANS_TheSansMonoCd_W5Regular_11">Server("Vibrant Diversity")</samp>. This would run the constructor method, passing in the string <samp class="SANS_TheSansMonoCd_W5Regular_11">Vibrant Diversity</samp> as <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>. The constructor would then set the value of its <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> attribute to the name that was passed in. When the constructor finishes running, the code would save this newly created Python object in the <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp> variable. The next two lines of code use the SQLAlchemy object <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp> to run the <samp class="SANS_TheSansMonoCd_W5Regular_11">INSERT</samp> query in the SQL database and insert this row. The <samp class="SANS_TheSansMonoCd_W5Regular_11">db.session .add()</samp> method collects a list of SQL queries, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">db.session.commit()</samp> method runs those SQL queries on the database. In SQL, sometimes it’s more efficient to run several queries and then commit them all at once rather than one at a time.</p>

<p class="TX">In other words, the code in <a href="#list14-7">Listing 14-7</a> is basically the same as running the SQL query <samp class="SANS_TheSansMonoCd_W5Regular_11">INSERT INTO server SET name='Vibrant Diversity';</samp>, except this way all you need to do is interact with Python objects, not write any SQL yourself. After creating the server object, I could then access that object’s ID attribute with <samp class="SANS_TheSansMonoCd_W5Regular_11">server.id</samp> or the object’s name attribute with <samp class="SANS_TheSansMonoCd_W5Regular_11">server.name</samp>.</p>

<p class="TX">In addition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> table I just described, I also created the following tables, which you can view in detail in the <i>app.py</i> file at <a href="https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-14/discord-analysis/app.py"><i>https://<wbr/>github<wbr/>.com<wbr/>/micahflee<wbr/>/hacks<wbr/>-leaks<wbr/>-and<wbr/>-revelations<wbr/>/blob<wbr/>/main<wbr/>/chapter<wbr/>-14<wbr/>/discord<wbr/>-analysis<wbr/>/app<wbr/>.py</i></a>:</p>

<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">User</samp> A Discord user. I included the columns <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">discord_id</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp> column is an auto-incrementing number, and <samp class="SANS_TheSansMonoCd_W5Regular_11">discord_id</samp> is the original ID that Discord itself used. This is useful for identifying the same user across servers.</p>

<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Channel</samp> A channel in a Discord server. The columns are <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">discord_id</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp> column forms a relationship with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> table, since each server has a set of channels. Every Discord server JSON file contains a list of channels. Adding this relationship means that the SQL database I was designing would match the data structure in the JSON files.</p>

<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Message</samp> A Discord message. The columns are <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">discord_id</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">timestamp</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">attachments_json</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">user_id</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">channel_id</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">attachments _json</samp> column contains extra data from messages with attachments, like when someone posts an image to Discord. The <samp class="SANS_TheSansMonoCd_W5Regular_11">user_id</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">channel_id</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp> columns form relationships with the <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> tables. These also would match the structure found in the JSON files.</p>

<p class="TX"><a href="#fig14-2">Figure 14-2</a> shows the relationship between these four tables. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp> table includes a <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp> column, so it’s related to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> table. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_448" aria-label=" Page 448. "/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">Message</samp> table includes columns for <samp class="SANS_TheSansMonoCd_W5Regular_11">channel_id</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">user_id</samp>, so it’s related to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp> tables.</p>
<figure class="IMG"><img class="img40" id="fig14-2" src="Images/Figure14-2.png" alt="A chart showing four table names, clockwise from top left: Server, User, Message, and Channel. Channel points to Server, and Message points to Channel, Server, and User." width="289" height="100"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-2: Relationships between the SQL tables in the Discord Analysis app</samp></p></figcaption>
</figure>
<p class="TX">My goal for this web app would be to build an interface that allows me to explore the data stored in these SQL tables. I wanted to be able to search all of the messages at once, including from multiple servers, to see which users posted in multiple servers and to be able to generate links to individual messages that I could store in my notes. Before building the web interface, though, I needed to load the database with data from the JSON files.</p>
</section>

<section epub:type="division" aria-labelledby="sec11">
<h4 class="H2" id="sec11"><span id="h-353"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Importing Chat Logs into the SQL Database</samp></h4>
<p class="TNI">I wrote a separate script, <i>admin.py</i>, that I used to import data into the SQL database. This script took a command as its first argument. If I passed in <samp class="SANS_TheSansMonoCd_W5Regular_11">create-db</samp>, it would use SQLAlchemy to create the SQL tables that I had defined in <i>app.py</i>. When I passed in <samp class="SANS_TheSansMonoCd_W5Regular_11">import-json</samp>, followed by the filename of a JSON file, the code would import Discord data from that JSON file into the SQL database. I also eventually added the <samp class="SANS_TheSansMonoCd_W5Regular_11">user-stats</samp> command, which displayed how many messages each user in the whole database posted, and on which servers.</p>

<p class="TX">This <i>admin,py</i> file is too long to include in this chapter in its entirety, but as with <i>app.py</i>, you can find a copy of the complete code in the book’s GitHub repo at <a href="https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-14/discord-analysis/admin.py"><i>https://<wbr/>github<wbr/>.com<wbr/>/micahflee<wbr/>/hacks<wbr/>-leaks<wbr/>-and<wbr/>-revelations<wbr/>/blob<wbr/>/main<wbr/>/chapter<wbr/>-14<wbr/>/discord<wbr/>-analysis<wbr/>/admin<wbr/>.py</i></a>.</p>

<p class="TX">In this section, I’ll explain how I built the <samp class="SANS_TheSansMonoCd_W5Regular_11">import-json</samp> command (specifically, the <samp class="SANS_TheSansMonoCd_W5Regular_11">import_json()</samp> function, which is what gets called when you run <samp class="SANS_TheSansMonoCd_W5Regular_11">import-json</samp>), the most interesting part of the script. This is the code that opens up the JSON files containing Discord server leaks, loops through all the data, and then inserts it into the SQL database. As with the <i>discord-json -search.py</i> script, I relied on my previous manual analysis of the Discord JSON files to write this code. Basically, this is the part that requires an understanding of the structure of the original data.</p>

<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">import_json()</samp> function is too long to display it all here, so instead I’ll display snippets that explain the general idea of how it works. The function takes the filename for a JSON file containing Discord leaks as an argument. It opens this file, loads it into a variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>, and then uses the information in <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> to add servers, users, channels, and messages to the SQL database. I’ll show the code that adds users, channels, and messages soon, but first, <a href="#list14-8">Listing 14-8</a> shows the code that adds servers.</p>
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_449" aria-label=" Page 449. "/>
<pre id="pre-610"><code>print("Adding servers: ", end="", flush=True)
for item in data["meta"]["servers"]:
    name = item["name"]

    try:
        server = Server(name)
        db.session.add(server)
        db.session.commit()
        print("+", end="", flush=True)
    except sqlalchemy.exc.IntegrityError:
        db.session.rollback()
        print(".", end="", flush=True)
print("")</code></pre>
<p class="CodeListingCaption" id="list14-8"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-8: Code from</samp> <samp class="SANS_Futura_Std_Book_11">admin.py</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to add servers to the database</samp></p>

<p class="TX">This code looped through all of the servers it found in <samp class="SANS_TheSansMonoCd_W5Regular_11">data["meta"]["servers"]</samp>, adding a row to the database for each server that it found. For example, in <a href="#list14-1">Listing 14-1</a>, I used <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> to view this list of servers for <i>VibrantDiversity.json</i> and found that it contained only a single server. <a href="#list14-8">Listing 14-8</a> uses Python code to find that same list of servers from the same part of the target leaked JSON file.</p>

<p class="TX">For each server it found, the code stored the server’s name in the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> variable, then tried to add that server to the database. This code used Python exception handling, which you learned about in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>. In the <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp> block, the code created a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> object (this represents a row in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> table in SQLAlchemy), added that row to the database using <samp class="SANS_TheSansMonoCd_W5Regular_11">db.session</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.add(server)</samp>, and finally committed the database changes with <samp class="SANS_TheSansMonoCd_W5Regular_11">db.session.commit()</samp>, just like in the SQLAlchemy code in <a href="#list14-7">Listing 14-7</a>. After the server was successfully inserted into the database, the program displayed a plus sign (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>) and moved on to the next loop.</p>

<p class="TX">When I defined the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> table in <i>app.py</i>, I specified that the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> column should be unique, meaning that there could be no two rows with the same <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> column. If SQLAlchemy threw the <samp class="SANS_TheSansMonoCd_W5Regular_11">sqlalchemy.exc.IntegrityError</samp> exception while the script was trying to add the row to the database, that meant a server with that name already existed in the database, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp> block should run instead. If this happened, then the code rolled back the change that it was about to make and displayed a dot (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>) instead of a plus sign.</p>

<p class="TX">Why did I worry about catching these exceptions to begin with instead of just adding rows to the database? As with the programming exercises that you completed in previous chapters, I didn’t write the whole script perfectly the first time and then run it. Instead, I wrote small bits of code at a time and ran them to make sure my script was working so far. This exception handling allowed me to rerun an import on the same JSON file over and over while starting where I left off. If my script showed a plus sign, I knew it had added a new row to the database. If it showed a dot, that meant the row already existed and the script moved on.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_450" aria-label=" Page 450. "/>You might also notice that the familiar <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function calls look odd in <a href="#list14-8">Listing 14-8</a>: my code passed in the <samp class="SANS_TheSansMonoCd_W5Regular_11">end=""</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">flush=True</samp> keyword arguments. By default, <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> displays the string the user passes in as an argument, then adds a newline character (<samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>) to the end. The <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp> argument replaces that newline with something else (in this case, an empty string). In other words, this is how I could print a string without moving on to the next line. The <samp class="SANS_TheSansMonoCd_W5Regular_11">flush=True</samp> argument makes sure that the output gets displayed to the screen immediately; without it, the output would still get displayed, but not right after the function call. This allowed me to watch the progress of an import.</p>

<p class="TX">After adding servers, the script added users, as shown in <a href="#list14-9">Listing 14-9</a>.</p>

<pre id="pre-611"><code>print("Adding users: ", end="", flush=True)
for user_discord_id in data["meta"]["users"]:
    name = data["meta"]["users"][user_discord_id]["name"]

    try:
        user = User(user_discord_id, name)
        db.session.add(user)
        db.session.commit()
        print("+", end="", flush=True)
    except sqlalchemy.exc.IntegrityError:
        db.session.rollback()
        print(".", end="", flush=True)
print("")</code></pre>
<p class="CodeListingCaption" id="list14-9"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-9: Code from</samp> <samp class="SANS_Futura_Std_Book_11">admin.py</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to add users to the database</samp></p>

<p class="TX">This code is very similar to <a href="#list14-8">Listing 14-8</a>, but instead of looping through the list <samp class="SANS_TheSansMonoCd_W5Regular_11">data["meta"]["servers"]</samp>, it looped through the dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">data["meta"]["users"]</samp>. <a href="#list14-3">Listing 14-3</a> shows this JSON object of users from <i>VibrantDiversity .json</i>. As described in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>, when you loop through a dictionary, you’re actually looping through the dictionary’s keys. In this case, the script stored each key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">user_discord_id</samp> variable. Armed with the user’s Discord ID, it then looked up that user’s name in the metadata.</p>

<p class="TX">In the <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp> block, the script then created a new <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp> object, this time with both the user’s Discord ID and name, and tried adding it to the database. When I defined the <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp> table in <i>app.py</i>, I specified that <samp class="SANS_TheSansMonoCd_W5Regular_11">user_discord_id</samp> should be unique in order to prevent duplicate users. Like <a href="#list14-8">Listing 14-8</a>, the code displayed a plus sign when adding the user to the database and a dot if it hit an error. This error-handling code would be important when I started importing multiple servers: if a Discord user was already in the database because they were a member of a previous server, the code wouldn’t create a duplicate user for them.</p>

<p class="TX">After adding servers and users, the script then added channels, using the code in <a href="#list14-10">Listing 14-10</a>.</p>

<pre id="pre-612"><code>print("Adding channels: ", end="", flush=True)
for channel_discord_id in data["meta"]["channels"]:
    name = data["meta"]["channels"][channel_discord_id]["name"]<span role="doc-pagebreak" epub:type="pagebreak" id="pg_451" aria-label=" Page 451. "/>
    server_id = data["meta"]["channels"][channel_discord_id]["server"]
 <span class="CodeAnnotation" aria-label="annotation1">❶</span> server = Server.query.filter_by(
        name=data["meta"]["servers"][server_id]["name"]
    ).first()

    try:
        channel = Channel(server, channel_discord_id, name)
        db.session.add(channel)
        db.session.commit()
        print("+", end="", flush=True)
    except sqlalchemy.exc.IntegrityError:
        db.session.rollback()
        print(".", end="", flush=True)
print("")</code></pre>
<p class="CodeListingCaption" id="list14-10"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-10: Code from</samp> <samp class="SANS_Futura_Std_Book_11">admin.py</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to add channels to the database</samp></p>

<p class="TX">This code is also similar to Listings 14-8 and 14-9. This time however, it looped through the keys of the <samp class="SANS_TheSansMonoCd_W5Regular_11">data["meta"]["channels"]</samp> dictionary, storing each key as <samp class="SANS_TheSansMonoCd_W5Regular_11">channel_discord_id</samp>.</p>

<p class="TX"><a href="#list14-2">Listing 14-2</a> showed this JSON object of channels from <i>VibrantDiversity .json</i>, which you can revisit to remind yourself what this dictionary looks like. For each channel, the code in <a href="#list14-8">Listing 14-8</a> stored the name of the channel in <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> and that channel’s server index in <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp>. It then queried the SQL database itself to get the server row in <a href="#list14-10">Listing 14-10</a> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which should have been added earlier by the code in <a href="#list14-9">Listing 14-9</a>, and stored this value in <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp>. The SQL query that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server.query.filter_by()</samp> function call ran was similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">SELECT * FROM servers WHERE name='</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">name</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">';</samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">name</samp> is the server name.</p>

<p class="TX">In the <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp> block, the code then created a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp> object, this time telling it the server, the channel’s Discord ID, and the channel name. As with the previous listings, it tried adding this channel to the database, displaying a plus sign on success and a dot if the channel already existed.</p>

<p class="TX">Finally, after adding servers, users, and channels, the code added all of the messages, as shown in <a href="#list14-11">Listing 14-11</a>.</p>

<pre id="pre-613"><code>for channel_discord_id in data["data"]:
    # Get the channel
    channel = Channel.query.filter_by(discord_id=channel_discord_id).one() <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span>

    # Loop through each message in this channel
    print(f"Adding messages from {channel.server.name}, #{channel.name}: ", end="", flush=True)
    for message_discord_id in data["data"][channel_discord_id]:
        try:
            timestamp = data["data"][channel_discord_id][message_discord_id]["t"]
            message = data["data"][channel_discord_id][message_discord_id]["m"]

            user_index = data["data"][channel_discord_id][message_discord_id]["u"]
            user_discord_id = data["meta"]["userindex"][user_index]
            user = User.query.filter_by(discord_id=user_discord_id).first() <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span>
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_452" aria-label=" Page 452. "/>
            if "a" in data["data"][channel_discord_id][message_discord_id]:
                attachments_json = json.dumps(
                    data["data"][channel_discord_id][message_discord_id]["a"]
                  )
            else:
                attachments_json = None

            message = Message(
                channel.server,
                message_discord_id,
                timestamp,
                message,
                user,
                channel,
                attachments_json,
            )
            db.session.add(message)
            db.session.commit()
            print("+", end="", flush=True)
        except sqlalchemy.exc.IntegrityError:
            db.session.rollback()
            print(".", end="", flush=True)
    print("")</code></pre>
<p class="CodeListingCaption" id="list14-11"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-11: Code from</samp> <samp class="SANS_Futura_Std_Book_11">admin.py</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to add messages to the database</samp></p>

<p class="TX">This time, this code looped through all of the keys of the <samp class="SANS_TheSansMonoCd_W5Regular_11">data["data"]</samp> dictionary. As you learned in <a href="#list14-5">Listing 14-5</a>, this dictionary’s keys are the Discord IDs of channels. My code stored each ID in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">channel _discord_id</samp>. I then used SQLAlchemy to query the database to load this actual channel row <span class="CodeAnnotation" aria-label="annotation1">❶</span> (the SQL query that this command ran was similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">SELECT * FROM channel WHERE channel_discord_id=</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel_discord_id</samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel_discord_id</samp> is the channel ID). After learning what channel it was dealing with, the code then looped through all of that channel’s messages to add them to the database, storing each message’s Discord ID as <samp class="SANS_TheSansMonoCd_W5Regular_11">message_discord_id</samp>.</p>

<p class="TX">The rest of the code in <a href="#list14-11">Listing 14-11</a> is also similar to Listings 14-8 through 14-10. In the <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp> block, for each message, the code stored the timestamp and message in the <samp class="SANS_TheSansMonoCd_W5Regular_11">timestamp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp> variables. It then looked up the user Discord ID from the metadata and queried the SQL database for the <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp> object <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and, if the message included an attachment, it also created a string called <samp class="SANS_TheSansMonoCd_W5Regular_11">attachments_json</samp>. Finally, it created a <samp class="SANS_TheSansMonoCd_W5Regular_11">Message</samp> object and inserted this message into the database. As before, the code displayed a plus sign if it successfully inserted a message or a dot if that message was already in the database.</p>

<p class="TX">Since exception handling ensured <i>admin.py</i> wouldn’t import duplicate rows, I could use this script to import newer versions of JSON files from the same Discord server. For example, if Unicorn Riot’s infiltrator used Discord History Tracker to save another offline copy of everything in Vibrant Diversity a month later, and I imported that new JSON file, it would import only the new messages.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_453" aria-label=" Page 453. "/>Once this code was written, I used it to import all of the JSON Discord files that I had received from Unicorn Riot. To import data from the Vibrant Diversity channel, I would run this command:</p>

<pre id="pre-614"><code><b>python3 admin.py import-json ~/datasets/Discord-JSON-Scrapes/VibrantDiversity.json</b></code></pre>
<p class="BodyContinued">And here is the output:</p>

<pre id="pre-615"><code>Adding servers: +
Adding users: +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<var>--snip--</var>
Adding channels: +++++++++
Adding messages from Vibrant Diversity, #rules: +++++++++++++++
Adding messages from Vibrant Diversity, #general: +++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<var>--snip--</var>
Adding messages from Vibrant Diversity, #recruiting: ++++++++++++++++++++++++++++++++++++++++++
+++++++++
Import complete</code></pre>
<p class="TX">Each plus sign in this output represents a different row of data inserted into the database. The <i>VibrantDiversity.json</i> file added 1 server, 530 users, 9 channels, and a total of 255,349 messages, importing a message at a time.</p>

<p class="TX">I then used <i>admin.py</i> to import the rest of the Discord JSON files I had, including chat logs from Anticom, 4th Reich, Ethnoserver, and other leaked servers. For example, next I imported one of the smaller servers called Pony Power, which I’ll discuss further later in this chapter, like so:</p>

<pre id="pre-616"><code><b>python3 admin.py import-json ~/datasets/Discord-JSON-Scrapes/PonyPowerComplete-Sept5at155PM.txt</b></code></pre>
<p class="TX">And here is the output from that command (in this case, I’d already imported the Vibrant Diversity data, and these two Discord channels had some overlapping users, so my script skipped importing some of the users):</p>

<pre id="pre-617"><code>Importing: /Users/micah/datasets/Discord-JSON-Scrapes/PonyPowerComplete-Sept5at155PM.txt
Adding servers: +
Adding users: .++++..+++++.+++++..++++.++.+++++++++++..+.+......
Adding channels: ++++
Adding messages from Pony Power, #general-chat: +++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<var>--snip--</var></code></pre>
<p class="TX">This JSON file included 50 users. The code skipped 17 of them (displaying dots instead of plus signs) because they were already in the database from Vibrant Diversity, and it added 33 new users.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_454" aria-label=" Page 454. "/>My database was now full of neo-Nazi chat logs, preparing me to build a web interface to explore them. When you’re building a web app to investigate data, you need some data to explore to make sure your app is actually working as intended. If I hadn’t imported the actual data first, I would have had to make up and import some test data so I’d have something to troubleshoot with while building the web app. But I decided to import the real data first because I knew I’d need to write that code eventually anyway.</p>
</section>

<section epub:type="division" aria-labelledby="sec12">
<h4 class="H2" id="sec12"><span id="h-354"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building the Web Interface</samp></h4>
<p class="TNI">When you build web apps, it’s often useful to split your web pages into reusable components, like headers, footers, and sidebars. Individual pages may have their own reusable components, too. For example, the page that lists chat messages might repeat the same message component for each message on the page. You define these components in <i>templates</i>, HTML files that can contain variables and logic, like <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements or <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops. You can render a template (convert it into HTML) by passing the template file along with variables into a <i>templating engine</i>, or code that converts a template into HTML.</p>

<p class="TX">Flask comes with a popular templating engine called Jinja. To build the web interface to explore the chat logs I’d just imported, I started by creating the layout template in Jinja. In short, I wrote the HTML code that would make up the layout of all of the pages in my web app, but also included Python variables and loops. <a href="#list14-12">Listing 14-12</a> shows the code for <i>layout.html</i>, my layout template.</p>

<pre id="pre-618"><code>&lt;!doctype html&gt;
&lt;html&gt;

&lt;head&gt;
  &lt;title&gt;Discord Analysis&lt;/title&gt;
  &lt;link rel=stylesheet type=text/css href="{{url_for('static', filename='style.css')}}"&gt; <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span>
&lt;/head&gt;

&lt;body&gt;
  &lt;div class="wrapper"&gt;
    &lt;div class="sidebar"&gt;
      {% for server in servers %} <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span>
      &lt;div class="server"&gt;
        &lt;p&gt;&lt;strong&gt;{{server.name}}&lt;/strong&gt;&lt;/p&gt;
        &lt;ul&gt;
          {% for c in server.channels %} <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span>
          &lt;li{% if channel %}{% if c.id==channel.id %} class="active" {% endif %}{% endif %}&gt;&lt;a
              href="{{c.permalink()}}"&gt;#{{c.name}}&lt;/a&gt; &lt;span class="message-count"&gt;[{{
              "{0:,}".format(c.message_count() | int)}}]&lt;/span&gt;&lt;/li&gt;
            {% endfor %}
        &lt;/ul&gt;
      &lt;/div&gt;
      {% endfor %}
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_455" aria-label=" Page 455. "/>
      &lt;p&gt;&lt;a href="/users"&gt;Users&lt;/a&gt;&lt;/p&gt;
    &lt;/div&gt;

    &lt;div class="content"&gt;
      &lt;div class="search"&gt;
        &lt;form method="get" action="/search"&gt;
          &lt;input type="text" name="q" class="q" placeholder="Search query" {% if q %}
            value="{{q}}" {% endif %} /&gt; <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span>
          &lt;select name="s"&gt;
            &lt;option value=""&gt;[all servers]&lt;/option&gt;
            {% for server in servers %} <span class="CodeAnnotationCode-1" aria-label="annotation5">❺</span>
            &lt;option value="{{server.id}}" {% if server.id==s %} selected="selected" {% endif
              %}&gt;
              {{server.name}}
            &lt;/option&gt;
            {% endfor %}
          &lt;/select&gt;
            &lt;input type="submit" value="Search" /&gt;
        &lt;/form&gt;
      &lt;/div&gt;

      &lt;div class="messages"&gt;
        {% for message in get_flashed_messages() %} <span class="CodeAnnotationCode-1" aria-label="annotation6">❻</span>
        &lt;div class=flash&gt;{{message}}&lt;/div&gt;
        {% endfor %}
      &lt;/div&gt;

      {% block content %}{% endblock %} <span class="CodeAnnotationCode-1" aria-label="annotation7">❼</span>
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
<p class="CodeListingCaption" id="list14-12"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-12: The</samp> <samp class="SANS_Futura_Std_Book_11">layout.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">layout template</samp></p>

<p class="TX">The code in <a href="#list14-12">Listing 14-12</a> looks like HTML at a glance, but if you look closely you’ll see that it’s actually a Jinja template. For example, look at the code that adds the <i>CSS (Cascading Style Sheets)</i> file—which defines the page’s style—to the page <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The HTML syntax for adding a stylesheet is</p>

<pre id="pre-619"><code>&lt;link rel=stylesheet type=text/css href="<var>style.css</var>"&gt;</code></pre>
<p class="BodyContinued">where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">style.css</samp> is the path or URL of a CSS file. Instead of an actual filename, the code in <a href="#list14-12">Listing 14-12</a> uses this:</p>

<pre id="pre-620"><code>{{url_for('static', filename='style.css')}}</code></pre>
<p class="BodyContinued">In a Jinja template, putting a Python expression between <samp class="SANS_TheSansMonoCd_W5Regular_11">{{</samp>and}<samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp> means Python will evaluate this expression when the template is rendered. In this case, <a href="#list14-12">Listing 14-12</a> rendered that line as <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;link rel=stylesheet type=text/css href="/static/style.css"&gt;</samp> because the <samp class="SANS_TheSansMonoCd_W5Regular_11">url_for()</samp> function, which is part of Flask, returned the <samp class="SANS_TheSansMonoCd_W5Regular_11">/static/style.css</samp> string.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_456" aria-label=" Page 456. "/>The template in <a href="#list14-12">Listing 14-12</a> also included some <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops. In Jinja, you start a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop with the code <samp class="SANS_TheSansMonoCd_W5Regular_11">{% for</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">item</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">list</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">%}</samp> and end it with <samp class="SANS_TheSansMonoCd_W5Regular_11">{% endfor %}</samp>. In the left sidebar of the layout, the template listed all of the Discord servers in the databases <span class="CodeAnnotation" aria-label="annotation2">❷</span>, looping through the items in the <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp> list one at a time. (For this template to render properly, I’d need to make sure to pass <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp> into the template as a variable when I render it in the Flask code.) For each server, after displaying the server name, it looped through all of the channels in that server <span class="CodeAnnotation" aria-label="annotation3">❸</span>, getting the list of channels from <samp class="SANS_TheSansMonoCd_W5Regular_11">server.channels</samp>. For each channel, the code displayed a link to view messages in that channel followed by the number of messages it contains.</p>

<p class="TX">The template also included a search bar at the top of the page <span class="CodeAnnotation" aria-label="annotation4">❹</span>, as well as a drop-down menu with options to search a specific server or to search them all <span class="CodeAnnotation" aria-label="annotation5">❺</span>. It also included a list of notification messages <span class="CodeAnnotation" aria-label="annotation6">❻</span> I could use if I wanted to display an error message—for example, if I tried loading a link to view messages in a channel that didn’t exist in the database. Finally, the template displayed the content block for that particular page <span class="CodeAnnotation" aria-label="annotation7">❼</span>. While all pages shared this template, the content block differed for each page.</p>

<p class="TX">After starting on my templates, I wrote code for a handful of <i>routes</i>, which let the web app know which page the user’s web browser was trying to view. In web development, you can think of a route as a path for a web page, except it can include placeholders. For example, if the web app is hosted at <i>http://<wbr/>localhost:5000</i>, and the Python code defines the route <samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp> for the search page, users can view that route with the URL <i>http://<wbr/>localhost:5000<wbr/>/search</i>.</p>

<p class="TX">The home page route (<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>), shown in <a href="#list14-13">Listing 14-13</a>, was by far the simplest one in my web app. This page displayed the message “This is a web app that will let you research the alt-right chatroom leak, published by Unicorn Riot.”</p>

<pre id="pre-621"><code>@app.route("/")
def index():
    servers = Server.query.all()
    return render_template("index.html", servers=servers)</code></pre>
<p class="CodeListingCaption" id="list14-13"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-13: The home page route (</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">/)</samp></p>

<p class="TX">In Flask, each route is a function that returns the HTML for that web page. The <samp class="SANS_TheSansMonoCd_W5Regular_11">index()</samp> function starts with the <samp class="SANS_TheSansMonoCd_W5Regular_11">@app.route("/")</samp> decorator, which is how Flask knows that the <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp> route should call this function. This function first runs a SQL query to get all of the servers in the database, stored in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp>. It then calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">render_template()</samp> function, rendering the <i>index.html</i> template, passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp> variable into the template, and returning the HTML it receives.</p>

<p class="TX"><a href="#list14-14">Listing 14-14</a> shows the code for the <i>index.html</i> Jinja template that was rendered.</p>
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_457" aria-label=" Page 457. "/>
<pre id="pre-622"><code>{% extends "layout.html" %}
{% block content %}
&lt;h2&gt;Alt-right chatroom research&lt;/h2&gt;
&lt;p&gt;This is a web app that will let you research the alt-right chatroom leak,
    published by Unicorn Riot.&lt;/p&gt;
&lt;p&gt;Click on channel names to browse them. Search for keywords. Viewing
    individual messages will show you the whole conversation from an hour
    before and after that message.&lt;/p&gt;
{% endblock %}</code></pre>
<p class="CodeListingCaption" id="list14-14"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-14: The</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">template</samp></p>

<p class="TX">The first line of code in this template means that Jinja should render the <i>layout.html</i> template but replace <samp class="SANS_TheSansMonoCd_W5Regular_11">{% block content %}{% endblock %}</samp> with the content block defined here—some text that says, “Alt-right chatroom research” and a brief description of the web app. Also notice that in <a href="#list14-13">Listing 14-13</a>, I passed the <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp> variable into the template; the <i>layout.html</i> template in <a href="#list14-11">Listing 14-11</a> used this variable to make the list of servers in the sidebar.</p>

<p class="TX"><a href="#fig14-3">Figure 14-3</a> shows what the app’s home page looked like at this point, with the home page text as defined in <i>index.html</i> and with the servers on the left and the search bar at the top as defined in <i>layout.html</i>.</p>
<figure class="IMG"><img class="img100" id="fig14-3" src="Images/Figure14-3.png" alt="A screenshot of my Discord Analysis web app with the header “Alt-right chatroom research.” The sidebar lists all of the Discord servers and channels imported in the database." width="696" height="296"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-3: The home page of my Discord Analysis web app</samp></p></figcaption>
</figure>
<p class="TX">Let’s look at one more route that does a bit more than the <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp> route, the <samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp> route, which will help explain how one of the web app’s core features—searching the chat logs—works. Here’s the Python code:</p>

<pre id="pre-623"><code>@app.route("/search")
def search():
    q = request.args.get("q")
    s = request.args.get("s", 0)
    if s == "":
        s = 0
    page, per_page = get_pagination_args()<span role="doc-pagebreak" epub:type="pagebreak" id="pg_458" aria-label=" Page 458. "/>

    server = Server.query.filter_by(id=s).first()

    messages = Message.query
    if server:
        messages = messages.filter_by(server=server)
    pagination = (
        messages.filter(Message.message.like(f"%{q}%"))
        .order_by(Message.timestamp)
        .paginate(page=page, per_page=per_page)
    )

    if server:
        description = f"Search {server.name}: {q}"
    else:
        description = f"Search: {q}"

    servers = Server.query.all()
    pagination_link = f"/search?q={q}&amp;s={s}"
    return render_template(
        "results.html",
        q=q,
        s=int(s),
        servers=servers,
        pagination=pagination,
        pagination_link=pagination_link,
        description=description,
    )</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">search()</samp> function starts with the decorator <samp class="SANS_TheSansMonoCd_W5Regular_11">@app.route("/search")</samp>, so Flask knows that the <samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp> route should call this function. At the beginning of the function, I defined the <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">page</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">per_page</samp> variables as the values from the URL’s query string. For example, if the URL ends in <i>/search?q</i><span class="symbol_Italic">=</span><i>berkeley</i>, then this code would set the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> to the <samp class="SANS_TheSansMonoCd_W5Regular_11">berkeley</samp>.</p>

<p class="TX">I got this query string information from the Flask variable <samp class="SANS_TheSansMonoCd_W5Regular_11">request.args</samp>, which is a dictionary containing all of the values after the <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> in the URL. The code got the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> key in this dictionary by evaluating <samp class="SANS_TheSansMonoCd_W5Regular_11">request.args.get("q")</samp>, but <samp class="SANS_TheSansMonoCd_W5Regular_11">request.args["q"]</samp> would work just the same. When using the <samp class="SANS_TheSansMonoCd_W5Regular_11">.get()</samp> method on dictionaries, you can choose default values, as I did in the following line. The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">request.args.get("s", 0)</samp> looks through <samp class="SANS_TheSansMonoCd_W5Regular_11">request.args</samp> for the key <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> and returns it if it finds it. If the expression doesn’t find <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.</p>

<p class="TX">On the search page, <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> is the search query and <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> is the ID of the server to search (if <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, this means I want to search all servers). The <samp class="SANS_TheSansMonoCd_W5Regular_11">page</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">per_page</samp> variables are used for <i>pagination</i>, which determines how an app displays a limited number of results per page. The <samp class="SANS_TheSansMonoCd_W5Regular_11">page</samp> variable is the page number, and <samp class="SANS_TheSansMonoCd_W5Regular_11">per_page</samp> is the number of results per page.</p>

<p class="TX">Since three of the routes in my app used pagination (<samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">/channel</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">/user</samp>), I wrote the code to find the <samp class="SANS_TheSansMonoCd_W5Regular_11">page</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">per_page</samp> query strings in the function <samp class="SANS_TheSansMonoCd_W5Regular_11">get_pagination_args()</samp>, which allowed me to just call that function instead of repeating the same code in multiple places.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_459" aria-label=" Page 459. "/>I then queried the SQL database for the server with the ID stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>, saving the result as <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp> variable is used to optionally search a single Discord server, rather than all of them. If the SQL database doesn’t have any servers with that ID, then <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp> is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>, which means the app should search all servers. I then started building the SQL query to search for all of the messages, storing the results in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">messages</samp>. If this search was limited to a specific server (that is, if there’s a value for <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>), the code modified <samp class="SANS_TheSansMonoCd_W5Regular_11">messages</samp> to filter just by messages from that server. Finally, I used the SQLAlchemy pagination feature to run the SQL query, making sure to select the correct page of results, storing the search results in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">pagination</samp>. Part of the SQLAlchemy query included <samp class="SANS_TheSansMonoCd_W5Regular_11">Message.message.like(f"%{q}%")</samp> to ultimately run a SQL query that used SQL’s <samp class="SANS_TheSansMonoCd_W5Regular_11">LIKE</samp> operator, which did a case-insensitive search for any messages containing the string <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>, as described in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>.</p>

<p class="TX">In the following <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, my code defined the <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp> variable as a description of the search, showing either just the search query or both it and the name of the server being searched. It then loaded all of the servers with <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Server.query.all()</samp>, which the <i>layout.html</i> layout template needs to render the sidebar. Finally, the code rendered the <i>results.html</i> Jinja template, passing in all of the appropriate variables, resulting in the search results page.</p>

<p class="TX">In addition to the home page route (<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>) and the search route (<samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp>), I created these other routes for my web app:</p>

<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">/view/</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">message_id</samp> The hyperlink to a specific Discord message</p>

<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">/channel/</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">channel_id</samp> The hyperlink to a specific channel in a Discord server</p>

<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">/users</samp> A page that listed all Discord users in the database, along with how many messages each has posted</p>

<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">/users/</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">user_id</samp> A page that listed the messages that each Discord user has posted, spanned across all servers and channels that they posted in</p>

<p class="TX">As you can see in <a href="#fig14-3">Figure 14-3</a>, the Discord servers that I imported while developing the app are all listed in the left sidebar, along with each server’s channels. To start my research, I could search for keywords (using the <samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp> route), or I could click a channel name on the left and read its chat logs (using the <samp class="SANS_TheSansMonoCd_W5Regular_11">/channel/</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel_id</samp> route).</p>

<p class="TX">You can view the code for all of these routes in <i>app.py</i> at <a href="https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-14/discord-analysis/app.py"><i>https://<wbr/>github<wbr/>.com<wbr/>/micahflee<wbr/>/hacks<wbr/>-leaks<wbr/>-and<wbr/>-revelations<wbr/>/blob<wbr/>/main<wbr/>/chapter<wbr/>-14<wbr/>/discord<wbr/>-analysis<wbr/>/app<wbr/>.py</i></a>.</p>

<p class="TX">Now that you know how the Discord Analysis web app works, let’s look at how I went about using it to analyze the Discord leaks.</p>
</section>

<section epub:type="division" aria-labelledby="sec13">
<h4 class="H2" id="sec13"><span id="h-355"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Discord Analysis to Find Revelations</samp></h4>
<p class="TNI">After I had built enough of the Discord Analysis web app that I could start using it for actual research, I started by reading a cross section of all of the Discord leaks I had imported and taking notes on what might make <span role="doc-pagebreak" epub:type="pagebreak" id="pg_460" aria-label=" Page 460. "/>good articles—all the while fixing bugs as I discovered them, and adding features as I felt I needed them. I went one Discord server at a time, trying to understand the gist of what was discussed in each channel. I searched for terms like <i>WikiLeaks</i> to see what the fascists were saying about it, since it had recently played a role in Trump’s 2016 election victory. I stumbled upon various conversations about digital security advice and which encrypted messaging apps to trust, all of it mixed up with numerous conspiracy theories, racist diatribes, and selfies of people holding guns.</p>

<p class="TX">Here’s how the process of using Discord Analysis on my computer actually worked. When I wanted to run my web app to test it during development or to start researching neo-Nazi chats, I’d run <samp class="SANS_TheSansMonoCd_W5Regular_11">python3 app.py</samp>. It showed this output, which is the typical output you see every time you start a Flask web app:</p>

<pre id="pre-624"><code> * Serving Flask app 'app'
 * Debug mode: on
WARNING: This is a development server. Do not use it in a production
deployment. Use a production WSGI server instead.
 * Running on http://127.0.0.1:5000
Press CTRL+C to quit
 * Restarting with stat
 * Debugger is active!
 * Debugger PIN: 654-228-939</code></pre>
<p class="TX">The output said that the Flask web server started and was running at the URL <i>http://<wbr/>127<wbr/>.0<wbr/>.0<wbr/>.1:5000</i>. The web server continued to run until I was ready to quit it by pressing <small>CTRL</small>-C. I loaded that URL in my web browser to view the web app. As I made web requests, my terminal output showed me web service logs. For example, when I loaded the home page, my app produced these logs:</p>

<pre id="pre-625"><code>127.0.0.1 - - [14/Jan/2023 11:58:30] "GET / HTTP/1.1" 200 -
127.0.0.1 - - [14/Jan/2023 11:58:30] "GET /static/style.css HTTP/1.1" 200 -
127.0.0.1 - - [14/Jan/2023 11:58:30] "GET /favicon.ico HTTP/1.1" 404 -</code></pre>
<p class="TX">The left column is the IP address (<samp class="SANS_TheSansMonoCd_W5Regular_11">127.0.0.1</samp>) of the web browser that loaded each route; in this case, I loaded routes from my own computer. It also shows the timestamp the route was loaded, which route was loaded, and other information. The first route that I loaded was the home page (you can tell because the first log line says <samp class="SANS_TheSansMonoCd_W5Regular_11">GET /</samp>), and it responded with the HTTP code <samp class="SANS_TheSansMonoCd_W5Regular_11">200</samp>, which means it loaded successfully. Immediately after that, my browser loaded the CSS stylesheet at <samp class="SANS_TheSansMonoCd_W5Regular_11">/static/style.css</samp>, which successfully loaded too, and tried to load the favicon (the icon in the corner of a web browser tab) at <samp class="SANS_TheSansMonoCd_W5Regular_11">/favicon.ico</samp>. However, the server replied with the HTTP code <samp class="SANS_TheSansMonoCd_W5Regular_11">404</samp>, “File not found,” because I hadn’t bothered creating a favicon for my app.</p>

<p class="TX">At the top of each page in the web app was a search bar, next to which was the drop-down menu that let me choose to search all servers or just one. For example, I tried searching all Discord servers from which I had <span role="doc-pagebreak" epub:type="pagebreak" id="pg_461" aria-label=" Page 461. "/>imported data for the string <samp class="SANS_TheSansMonoCd_W5Regular_11">berkeley</samp>. Back in my terminal, I could see that my browser had loaded the <samp class="SANS_TheSansMonoCd_W5Regular_11">/search?q=berkeley&amp;s=</samp> route:</p>

<pre id="pre-626"><code>127.0.0.1 - - [14/Jan/2023 11:58:57] "GET /search?q=berkeley&amp;s= HTTP/1.1" 200 -
127.0.0.1 - - [14/Jan/2023 11:58:57] "GET /static/style.css HTTP/1.1" 304 -</code></pre>
<p class="TX">The search page loaded the CSS stylesheet at <samp class="SANS_TheSansMonoCd_W5Regular_11">/static/style.css</samp> as well, but this time it returned with the HTTP code <samp class="SANS_TheSansMonoCd_W5Regular_11">304</samp>, which means that the stylesheet hadn’t been modified since the last time my browser made that request.</p>

<p class="TX"><a href="#fig14-4">Figure 14-4</a> shows the Discord Analysis web app showing these search results. You can see that the page has the URL <i>http://127.0.0.1:5000/search?q</i><span class="symbol_Italic">=</span><i>berkeley&amp;s</i><span class="symbol_Italic">=</span> and lists search results from all servers for the string <samp class="SANS_TheSansMonoCd_W5Regular_11">berkeley</samp>.</p>
<figure class="IMG"><img class="img100" id="fig14-4" src="Images/Figure14-4.png" alt="A screenshot of my Discord Analysis web app showing search results for the search term “berkeley.” The sidebar lists all of the Discord servers and channels imported in the database. There are 417 messages that include the word “berkeley,” and these messages are displayed with the search term highlighted." width="696" height="470"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-4: Searching for the string berkeley in my Discord Analysis web app</samp></p></figcaption>
</figure>
<p class="TX">My search found 417 messages that contained the string <samp class="SANS_TheSansMonoCd_W5Regular_11">berkeley</samp>, along with information on who posted each message, in what channel, in what server, at what time, and the content of the message, with the search term itself highlighted. If I clicked on the user’s name, which linked to the <samp class="SANS_TheSansMonoCd_W5Regular_11">/users/</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">user_id</samp> route, I’d see all of the posts from that user, including those on multiple Discord servers.</p>

<p class="TX">Each message also had a view link, which led to the <samp class="SANS_TheSansMonoCd_W5Regular_11">/view/</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">message_id</samp> route and pulled up a page displaying that individual message. This allowed me to store links to individual messages in my notes. When I clicked on a view link I’d saved, the web app would show me not only that message but also the 20 messages before and after it, so I could easily see the rest of the conversation.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_462" aria-label=" Page 462. "/>The app also allowed me to explore the leaked chats by manually reading through each channel. I could select individual channels by clicking the links in the left sidebar. For example, <a href="#fig14-5">Figure 14-5</a> shows the #general channel in the Pony Power server. In this case, the URL was <i>http://<wbr/>127<wbr/>.0<wbr/>.0<wbr/>.1:5000<wbr/>/channel<wbr/>/10</i>, meaning the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel_id</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">/channel/</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel_id</samp> route was <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>. The ID field in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp> table auto-increments, so the first row starts at 1, then 2, then 3, and so on. I imported the Vibrant Diversity JSON file first, which created channels with IDs 1 through 9, then imported the Pony Power JSON file, which created channels with IDs 10 through 13.</p>
<figure class="IMG"><img class="img100" id="fig14-5" src="Images/Figure14-5.png" alt="A screenshot of my Discord Analysis web app. The #general-chat channel in the Pony Power server is highlighted on the left, and you can see the messages in this server themselves on the right." width="695" height="389"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-5: Viewing chat logs for the #general-chat channel in the Pony Power server in my Discord Analysis web app</samp></p></figcaption>
</figure>
<p class="TX">With this case study as inspiration, I hope that you’ll feel confident building similar custom apps for your future investigations when you get your hands on large structured datasets like these.</p>

<p class="TX">After spending a few days splitting my time between writing code and reading some of the worst stuff on the internet, I ultimately decided to write about Pony Power, a server set up for the sole purpose of harassing and doxing people.</p>
</section>

</section>

<section epub:type="division" aria-labelledby="sec14">
<h3 class="H1" id="sec14"><span id="h-356"/><samp class="SANS_Futura_Std_Bold_B_11">The Pony Power Discord Server</samp></h3>

<p class="TNI">Pony Power was one of the smaller servers, with only 50 users and just over 1,000 messages posted over the course of just 10 days. More than any other server, it was full of PII for perceived members of antifa. I decided to focus my reporting on this server because this harassment campaign was clearly newsworthy, and because the server was small enough that I could read through all of the messages and write about the highlights. As a single reporter, it would have taken me considerably longer to do the same for larger servers, like Vibrant Diversity.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_463" aria-label=" Page 463. "/>In the Pony Power chat logs, I found private data from over 50 people from 14 states across the country, from California to Florida. The information often included users’ photographs, social media profiles, home addresses, phone numbers, email addresses, dates of birth, driver’s license numbers, vehicle information, places of employment, and in one instance, a Social Security number. As I read through the Pony Power chat logs, from the beginning to the end, I built up a spreadsheet listing each person who was doxed to help me keep track of them, as well as Discord Analysis links to the messages where the doxing happened. The server’s #faces-of-rainbow-ponies channel contained nearly all of the PII.</p>

<p class="TX">The Pony Power fascists weren’t very selective about their targets. Anyone they considered to be a member of antifa or an antifa sympathizer was fair game, as were journalists they disagreed with, professors from liberal universities, or anyone who spoke out against racism.</p>

<p class="TX">Eight times in 2017, fascists traveled to Berkeley to hold protests. They came prepared with racist and antisemitic signs and armed with weapons for street fighting. One of these protests, a Say No to Marxism rally, was scheduled for late August. In response, antifascists began preparing a counterprotest. “So who is going to be there to stand up against Antifa? This is a good chance to dox them so we can have an idea who they are,” one of the Pony Power members posted in the chat. “We should go onto their [Facebook] page if they have an active one and dox all the ones who plan on being there and who liked the post.”</p>

<p class="TX">Another Pony Power user posted a link to a website for “white people striving to be allies in the fight for Black Liberation” and said, “These white allies need doxing.” Another wanted to dox members of the Democratic Socialists of America and the Southern Poverty Law Center. Some members of the group disagreed about the strategy of doxing everyone they didn’t like, though. “Fuck these random ass people to be honest,” another user posted. “We need to dox journalists and leadership of activist groups.” A person going by the name <i>Klaus Albricht</i> suggested, “It’s time we start mapping out the liberal teachers of universities.”</p>

<p class="TX"><i>Albricht</i> decided to dox a 22-year-old college student because her Facebook cover photo showed her wearing a shirt reading “Punch more Nazis,” a reference to Richard Spencer, a white supremacist best known for the viral video in which he is punched in the face while being interviewed. <i>Albricht</i> outlined a plan to trick her into clicking a malicious link so he could learn her IP address. He also said that he would dox people who liked her shirt. Less than 20 minutes later, he posted her home address, what she was studying at college, and links to all her social media accounts.</p>

<p class="TX">While writing my story, I reached out to the woman who was doxed. She told me, “I never clicked the link because it seemed hella sketch.” She also said that she hadn’t gone out to protest fascists and that she was annoyed that they had doxed her just because she hurt their feelings. She was “terrified” that they had her address because “it’s not just myself who’s at risk, but now also my parents who live here as well.”</p>

<p class="TX">In the 10 days’ worth of Pony Power chat logs I had at my disposal, I also found the fascists doxing Emily Gorcenski, an antifascist data scientist <span role="doc-pagebreak" epub:type="pagebreak" id="pg_464" aria-label=" Page 464. "/>from Charlottesville who had witnessed Fields’s car plow into protesters. She’s a trans woman, and the fascists posted her deadname (the name she went by before she transitioned) and her home address. She has since moved to Germany.</p>

<p class="TX">Fascists also doxed 10 alleged members of an antifa group from Gainesville, Florida. A user who went by the name <i>adolphus (not hitler)</i> posted, “I lost my job because of these [homophobic slur]s,” later posting again that he lost his job because he attended the Unite the Right rally in Charlottesville, so “I’ve got some scores to settle with my local antifa.” I searched the internet for terms like <i>Gainesville Charlottesville fired</i> and quickly found news articles about a Gainesville man who was fired from his job after marching in Charlottesville with neo-Nazis. He was a member of the pro-slavery hate group League of the South, and he had gotten arrested in Charlottesville for carrying a concealed handgun. I tracked down a court document related to his arrest and found one that included his phone number. Because I decided to name him in the article, I called him to give him a chance to provide his side of the story, per the journalistic practices described in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>. To keep my actual phone number private from him and the League of the South, I used a new virtual phone number I had created just for this purpose (today, I have a public phone number that I use solely for communicating with sources like this). I left messages, but he never responded.</p>
<aside class="box" aria-labelledby="box-10">
<h4 class="BH" id="box-10"><samp class="SANS_Dogma_OT_Bold_B_11">MENTAL HEALTH AND EXTREMISM RESEARCH</samp></h4>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">While building Discord Analysis and developing a story based on the chat logs from my Unicorn Riot contact, I spent several hours a day for two weeks reading racist, antisemitic, misogynistic, and outright genocidal rants by neo-Nazis speaking to one another online. Among these, one message in particular stuck out to me. It was written by a man, probably in his 50s, well past midnight, and it was a rant about the Jews who he believed were secretly controlling the media and the banks. It was clear to me that he was expressing deeply held beliefs rather than just trying to post something edgy, like a lot of the younger fascists seemed to be doing. While writing this chapter, I searched my Discord Analysis app for the term</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">jew</samp> <samp class="SANS_Futura_Std_Book_11">to see if I could find that specific message, but it came back with over 11,000 results, all of them full of hate. I decided it wasn’t worth tracking it down after all.</samp></p>

<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">I knew about antisemitism, of course. I’d experienced antisemitic microaggressions myself. But reading through these neo-Nazi chat logs was the first time that I realized how many people—including thousands of Americans, many of whom lived in my city—really wished that we were all dead.</samp></p>

<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">After reading through a massive amount of this content, I had many ideas for articles I wanted to write, but I ended up writing only a single one, about the Pony Power server. After publishing the first article, I didn’t want to spend</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_465" aria-label=" Page 465. "/><samp class="SANS_Futura_Std_Book_11">more time reading these chats. I found it much better for my mental health to instead focus on writing code to improve my Discord search tool so that others could do the research. As I describe in the following section, this code eventually became a collaboration with Unicorn Riot called DiscordLeaks.</samp></p>

<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Reading through chat logs like this is an experience that no one should have to go through. But unfortunately, it’s necessary for extremism researchers. If you’re doing this sort of work, make sure to prioritize your own mental health. Take breaks and find people to talk to about the terrible things you’re seeing so you don’t keep it all inside. However you go about it, it’s important to have a plan for making this work sustainable, because it will definitely affect you.</samp></p>
</aside>
<p class="TX">Pony Power members also went after Michael Novick, at the time a 70-year-old retired teacher from Los Angeles who had been an antifascist activist for over 50 years. In the late 1980s, Novick helped found a group called Anti-Racist Action, and he’s been dealing with threats from neo-Nazis ever since. Because Novick’s name appeared on antiracist websites, Pony Power users decided that he must be an antifa leader. “Michael is behind what we know as the power structure,” <i>Albricht</i> posted. The Pony Power users then hit what they believed to be a gold mine: they discovered a video of Novick speaking at the 2011 Los Angeles Housing &amp; Hunger Crisis Conference in which he said, “I’m of Jewish descent.” “HE ADMITS HE IS JEWISH! I KNEW IT!” <i>Albricht</i> exclaimed. “We have our link. Antifa is a Jewish organization!” He added, “Now let’s tear these [antisemitic slur]s apart!” and began inventing an antifa organization chart that placed Novick on top. “This man we know for a fact is the leader of Antifa. […] All other branches report to him.”</p>

<p class="TX">Novick told me it’s no secret that he’s Jewish. “My father came to the US in the early ’30s as a teenager from Poland, and most of his family (many aunts, uncles, and cousins) were wiped out by the Nazis either in Bialystok during a ghetto rebellion or in the camps,” he said. He also told me that there’s no antifa “command structure” or “organization chart.” He added, “Some antifa are Jewish. Hardly surprising, given the level of antisemitism displayed by the fascists and neo-Nazis.”</p>

<p class="TX">According to a story by Unicorn Riot reporter Chris Schiano, the Pony Power server was started by Dan Kleve. At the time, Kleve was a biochemistry major at the University of Nebraska–Lincoln and a member of the neo-Nazi group Vanguard America. After Klein was outed as one of the fascists who marched in Charlottesville, people began calling the head of his department to demand that he be expelled. Schiano wrote that Kleve created the Pony Power server, in apparent retaliation against those demanding his expulsion, “to seek revenge by maliciously publishing the personal information of alleged antifascists and encouraging others to harass them and bring them harm.”</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_466" aria-label=" Page 466. "/>You can read my full reporting on the Pony Power Discord chat logs at <a href="https://theintercept.com/2017/09/06/how-right-wing-extremists-stalk-dox-and-harass-their-enemies/"><i>https://<wbr/>theintercept<wbr/>.com<wbr/>/2017<wbr/>/09<wbr/>/06<wbr/>/how<wbr/>-right<wbr/>-wing<wbr/>-extremists<wbr/>-stalk<wbr/>-dox<wbr/>-and<wbr/>-harass<wbr/>-their<wbr/>-enemies<wbr/>/</i></a>.</p>
</section>

<section epub:type="division" aria-labelledby="sec15">
<h3 class="H1" id="sec15"><span id="h-357"/><samp class="SANS_Futura_Std_Bold_B_11">The Launch of DiscordLeaks</samp></h3>

<p class="TNI">After publishing my Pony Power article, I was sure that there were many more revelations spread throughout the hundreds of thousands of messages in the leaked chat logs, but I decided I needed a break from Nazis. I wanted to make it possible for others to analyze the rest of the Discord servers, though, and I knew from my own experience with these datasets that there were technical challenges to analyzing them, which is why I developed Discord Analysis to begin with. I spoke with the journalists from Unicorn Riot and showed them the Discord Analysis web app I had used to write my article. We decided that Unicorn Riot would run a public version of this app for researchers, journalists, and members of the public to use. This is how DiscordLeaks was born.</p>

<p class="TX">DiscordLeaks (<a href="https://discordleaks.unicornriot.ninja"><i>https://<wbr/>discordleaks<wbr/>.unicornriot<wbr/>.ninja</i></a>) is a searchable public database designed to make it easy for anyone to access the massive corpus of fascist chat logs from hundreds of Discord servers infiltrated by antifascists. I and a small team of anonymous developers worked in our spare time to add new features to the app and handle the scaling issues that come with hosting a public website that gets lots of traffic. We kept the modified source code for DiscordLeaks private, but it’s based on the Discord Analysis source code that I just described. By late 2017, DiscordLeaks was live, and by early 2018 it was full of chat logs from several Discord servers uploaded by Unicorn Riot journalists, including the one used to organize Unite the Right. The only redactions to the chat logs on DiscordLeaks are the PII for victims of doxing and harassment by far-right extremists; the rest of the data is fully public.</p>

<p class="TX">Over the years, Unicorn Riot has obtained a steady stream of leaked Discord chat logs from fascist groups and continued to index them into DiscordLeaks. I eventually stopped contributing to the project myself. In the time I’ve been away, it’s matured: the infrastructure is now running in Docker containers, and the speed of search has greatly improved thanks to the addition of an Elasticsearch database (both technologies were discussed in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>). Today, DiscordLeaks contains millions of messages from nearly 300 Discord servers used by the far right, available for the public to research. It also contains chat logs from RocketChat servers, which I discuss in the next section.</p>
</section>

<section epub:type="division" aria-labelledby="sec16">
<h3 class="H1" id="sec16"><span id="h-358"/><samp class="SANS_Futura_Std_Bold_B_11">The Aftermath</samp></h3>

<p class="TNI">By 2019, I had stopped writing code for DiscordLeaks myself, but I still kept in touch with the developers and promoted the website. I was proud of my role in developing this important tool for extremism research, but at the time I still had no idea how much positive impact it would ultimately have.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_467" aria-label=" Page 467. "/>In this section I’ll discuss two major developments in the DiscordLeaks project since I wrote the initial code back in 2017. In 2021, survivors of the Charlottesville terrorist attack won a $25 million settlement against the organizers of Unite the Right in a lawsuit made possible, in part, by evidence published on DiscordLeaks. DiscordLeaks continues to be a vital tool for extremism researchers: in 2022, DiscordLeaks’ anonymous developers updated it to include another major leak of neo-Nazi chat logs, this time from the group Patriot Front.</p>

<section epub:type="division" aria-labelledby="sec17">
<h4 class="H2" id="sec17"><span id="h-359"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Lawsuit Against Unite the Right</samp></h4>
<p class="TNI">In 1871, in response to the wave of racist terrorism against Black people that swept the South after the end of the Civil War, the US Congress passed the Ku Klux Klan Act. This law allows victims of racist violence to sue the perpetrators in civil court. If the victims can prove there was a conspiracy to deprive them of their civil rights, they can force the racists to pay monetary damages. This is exactly what nine survivors from Charlottesville did.</p>

<p class="TX">The plaintiffs in these cases were all Charlottesville residents, some of whom were severely injured that day—one suffered a fractured skull, another a broken leg and ankle. They filed the Sines v. Kessler lawsuit in October 2017 against 14 individuals and 10 organizations, with the goal of bankrupting the American fascist movement. The individual defendants included Jason Kessler, the primary organizer of Unite the Right; James Alex Fields Jr., the neo-Nazi terrorist serving a prison sentence for Heather Heyer’s murder; Richard Spencer; and leaders of the fascist groups that organized Unite the Right. Defendants also included fascist groups themselves like Vanguard America, Traditionalist Worker Party, various branches of the Ku Klux Klan, and the National Socialist Movement.</p>

<p class="TX">The Charlottesville survivors’ lawsuit was organized and funded by a legal nonprofit called Integrity First for America (IFA). The mission of the organization, founded in response to the violence of Unite the Right, was “defending democratic norms and ensuring equal rights for every American.” Using over 5TB of evidence in the form of phone records, text messages, videos from Unite the Right, email messages, social media posts, and private messages and chat logs, the plaintiffs successfully made their case. IFA made all of the evidence used in the lawsuit available to the public at <a href="https://www.integrityfirstforamerica.org/exhibits"><i>https://<wbr/>www<wbr/>.integrityfirstforamerica<wbr/>.org<wbr/>/exhibits</i></a>.</p>

<p class="TX">On its blog, IFA explained that while its lawyers did eventually get copies of the neo-Nazi chat logs directly from Discord as part of the lawsuit’s discovery process, DiscordLeaks provided “an immense amount” of detail before the lawsuit was filed. In the chat logs published by Unicorn Riot, Unite the Right attendees discussed whether they could hit protesters with cars and then claim self-defense, which is what happened. This evidence “provided crucial early information that made the speed and breadth of the initial complaint possible.”</p>

<p class="TX">In November 2021, the court found the fascist organizers guilty and ordered them to pay over $25 million in damages. In late 2022, IFA wound down its operations.</p>
</section>

<section epub:type="division" aria-labelledby="sec18">
<h4 class="H2" id="sec18"><span id="h-360"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_468" aria-label=" Page 468. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Patriot Front Chat Logs</samp></h4>
<p class="TNI">In the aftermath of the violent Unite the Right protests in Charlottesville, one of the neo-Nazi groups in attendance, Vanguard America, broke apart due to infighting. Out of the ashes of Vanguard America, a new fascist group called Patriot Front was born. Patriot Front, based out of Texas, is known for requiring members to do weekly “activism” involving vandalizing property with racist messages and posting Patriot Front propaganda, like stickers, all over the place. According to the Anti-Defamation League, Patriot Front was responsible for 82 percent of all reported incidents in 2021 involving the distribution of racist, antisemitic, and other hateful propaganda in the US.</p>

<p class="TX">In January 2022, someone hacked Patriot Front and leaked 400GB of data to Unicorn Riot, including thousands of messages posted to the group’s internal RocketChat server, an open source chat platform that anyone can host themselves. Unicorn Riot collaborated with DDoSecrets to publish the 400GB Patriot Front dataset, which you can find at <a href="https://ddosecrets.com/wiki/Patriot_Front"><i>https://<wbr/>ddosecrets<wbr/>.com<wbr/>/wiki<wbr/>/Patriot<wbr/>_Front</i></a>. In response to this leak, the DiscordLeaks developers also updated the app to include support for RocketChat, and they imported over 12,000 new messages into it from two Patriot Front chat servers. You can find Patriot Front’s chat logs at <a href="https://discordleaks.unicornriot.ninja/rocket-chat/"><i>https://<wbr/>discordleaks<wbr/>.unicornriot<wbr/>.ninja<wbr/>/rocket<wbr/>-chat<wbr/>/</i></a>.</p>

<p class="TX"><a href="#fig14-6">Figure 14-6</a> shows a still from a video in the Patriot Front dataset of members reading their manifesto and chanting “Life, liberty, victory!” The video includes a few seconds at the end where one of the neo-Nazis, apparently thinking the recording was over, yells, “Seig fucking Heil!”</p>
<figure class="IMG"><img class="img100" id="fig14-6" src="Images/Figure14-6.jpg" alt="A screenshot from a Patriot Front video. It shows five men wearing identical uniforms that include hats, sunglasses, and face masks. Four of the men are standing in front of fascist flags, and one is sitting at a table reading a statement." width="695" height="392"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-6: Patriot Front members, from a video in the hacked dataset</samp></p></figcaption>
</figure>
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_469" aria-label=" Page 469. "/>Unfortunately, the American fascist movement has steadily grown since the election of Donald Trump in 2016. But there’s a wealth of public datasets about this movement, just waiting for researchers like you to dig in and expose it.</p>
</section>

</section>

<section epub:type="division" aria-labelledby="sec19">
<h3 class="H1" id="sec19"><span id="h-361"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>

<p class="TNI">In this chapter, you’ve learned how antifascists infiltrated the Discord servers used by the American fascist movement, including organizers of the deadly Unite the Right rally in 2017, and leaked millions of chat logs to Unicorn Riot in JSON format. You saw how I went about analyzing these JSON files to understand their structure, how the custom Flask and SQLAlchemy web app I built worked under the hood, and how the app ultimately became DiscordLeaks. I also described my own investigation into the Pony Power server that fascists used to dox their enemies. Finally, you read about the amazing results from the Sines v. Kessler lawsuit and the continued success of DiscordLeaks tools.</p>
</section>

</section>

</div></body></html>