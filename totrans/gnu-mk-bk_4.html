<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Pitfalls and Problems"><div class="titlepage"><div><div><h1 class="title"><a id="pitfalls_and_problems"/>Chapter 4. Pitfalls and Problems</h1></div></div></div><p>In this chapter, you’ll learn how to deal with problems faced by makefile maintainers as projects get considerably larger. Tasks that seem easy with small makefiles become more difficult with large, sometimes recursive, <code class="literal">make</code> processes. As makefiles become more complex, it’s easy to run into problems with edge cases or sometimes poorly understood behavior of GNU <code class="literal">make</code>.</p><p>Here you’ll see a complete solution to the “recursive <code class="literal">make</code> problem,” how to overcome GNU <code class="literal">make</code>’s problems handling filenames that contain spaces, how to deal with cross-platform file paths, and more.</p><div class="sect1" title="GNU make Gotcha: ifndef and ?="><div class="titlepage"><div><div><h1 class="title"><a id="gnu_make_gotcha_ifndef_and_question_mark"/>GNU make Gotcha: ifndef and ?=</h1></div></div></div><p><a id="iddle1035" class="indexterm"/><a id="iddle1036" class="indexterm"/><a id="iddle1420" class="indexterm"/>It’s easy to get tripped up by the two ways of checking whether a variable is defined, <code class="literal">ifndef</code> and <code class="literal">?=</code>, because they do similar things, yet one has a deceptive name. <code class="literal">ifndef</code> doesn’t really test whether a variable is defined; it only checks that the variable is not empty, whereas <code class="literal">?=</code> does make its decision based on whether the variable is defined or not.</p><p>Compare these two ways of conditionally setting the variable <code class="literal">FOO</code> in a makefile:</p><a id="pro_id00292"/><pre class="programlisting">ifndef FOO
FOO=New Value
endif</pre><p>and</p><a id="pro_id00293"/><pre class="programlisting">FOO ?= New Value</pre><p>They look like they should do the same thing, and they do, well, almost.</p><div class="sect2" title="What ?= Does"><div class="titlepage"><div><div><h2 class="title"><a id="what_question_markequals_does"/>What ?= Does</h2></div></div></div><p>The <code class="literal">?=</code> operator in GNU <code class="literal">make</code> sets the variable mentioned on its left side to the value on the right side if the left side is not defined. For example:</p><a id="pro_id00294"/><pre class="programlisting">FOO ?= New Value</pre><p>This makefile sets <code class="literal">FOO</code> to <code class="literal">New Value</code>.</p><p>But the following one does not:</p><a id="pro_id00295"/><pre class="programlisting">FOO=Old Value
FOO ?= New Value</pre><p>Neither does this one (even though <code class="literal">FOO</code> was initially empty):</p><a id="pro_id00296"/><pre class="programlisting">FOO=
FOO ?= New Value</pre><p>In fact, <code class="literal">?=</code> is the same as the following makefile, which uses the GNU <code class="literal">make $(origin)</code> function to determine whether a variable is undefined:</p><a id="pro_id00297"/><pre class="programlisting">ifeq ($(origin FOO),undefined)
FOO = New Value
endif</pre><p><code class="literal">$(origin FOO)</code> will return a string that shows whether and how <code class="literal">FOO</code> is defined. If <code class="literal">FOO</code> is undefined, then <code class="literal">$(origin FOO)</code> is the string <code class="literal">undefined</code>.</p><p>Note that variables defined with <code class="literal">?=</code> are expanded, just like variables defined with the <code class="literal">=</code> operator. They are expanded when used but not when defined, just like a normal GNU <code class="literal">make</code> variable.</p></div><div class="sect2" title="What ifndef Does"><div class="titlepage"><div><div><h2 class="title"><a id="what_ifndef_does"/>What ifndef Does</h2></div></div></div><p><a id="iddle1008" class="indexterm"/><a id="iddle1165" class="indexterm"/><a id="iddle1202" class="indexterm"/><a id="iddle1729" class="indexterm"/><a id="iddle1907" class="indexterm"/>As mentioned earlier, <code class="literal">ifndef</code> tests whether a variable is empty but does not check to see whether the variable is defined. <code class="literal">ifndef</code> means <span class="emphasis"><em>if the variable is undefined or is defined but is empty</em></span>. Thus, this:</p><a id="pro_id00298"/><pre class="programlisting">ifndef FOO
FOO=New Value
endif</pre><p>will set <code class="literal">FOO</code> to the <code class="literal">New Value</code> if <code class="literal">FOO</code> is undefined or <code class="literal">FOO</code> is empty. So <code class="literal">ifndef</code> can be rewritten as such:</p><a id="pro_id00299"/><pre class="programlisting">ifeq ($(FOO),)
FOO=New Value
endif</pre><p>because an undefined variable is always treated as having an empty value when read.</p></div></div><div class="sect1" title="$(shell) and := Go Together"><div class="titlepage"><div><div><h1 class="title"><a id="dollarleft_parenthesisshellright-id00005"/>$(shell) and := Go Together</h1></div></div></div><p>The suggestion in this section often speeds up makefiles with just the addition of a suitably placed colon. To understand how a single colon can make such a difference, you need to understand GNU <code class="literal">make</code>’s <code class="literal">$(shell)</code> function and the difference between <code class="literal">=</code> and <code class="literal">:=</code>.</p><div class="sect2" title="$(shell) Explained"><div class="titlepage"><div><div><h2 class="title"><a id="dollarleft_parenthesisshellright-id00006"/>$(shell) Explained</h2></div></div></div><p><code class="literal">$(shell)</code> is GNU <code class="literal">make</code>’s equivalent of the backtick (<code class="literal">`</code>) operator in the shell. It executes a command, flattens the result (turns all whitespace, including new lines, into spaces), and returns the resulting string.</p><p>For example, if you want to get the output of the <code class="literal">date</code> command into a variable called <code class="literal">NOW</code>, you write:</p><a id="pro_id00300"/><pre class="programlisting">NOW = $(shell date)</pre><p>If you want to count the number of files in the current directory and get that number into <code class="literal">FILE_COUNT</code>, do this:</p><a id="pro_id00301"/><pre class="programlisting">FILE_COUNT = $(shell ls | wc -l )</pre><p>Because <code class="literal">$(shell)</code> flattens output to get the names of all the files in the current directory into a variable, the following works:</p><a id="pro_id00302"/><pre class="programlisting">FILES = $(shell ls)</pre><p>The newline between files is replaced with a single space, making <code class="literal">FILES</code> a space-separated list of filenames.</p><p><a id="iddle1009" class="indexterm"/><a id="iddle1020" class="indexterm"/><a id="iddle1252" class="indexterm"/><a id="iddle1652" class="indexterm"/><a id="iddle1673" class="indexterm"/><a id="iddle1688" class="indexterm"/><a id="iddle1867" class="indexterm"/><a id="iddle1880" class="indexterm"/><a id="iddle1891" class="indexterm"/>It’s common to see an execution of the <code class="literal">pwd</code> command to get the current working directory into a variable (in this case <code class="literal">CWD</code>):</p><a id="pro_id00303"/><pre class="programlisting">CWD = $(shell pwd)</pre><p>We’ll look at the <code class="literal">pwd</code> command later when considering how to optimize an example makefile that wastes time getting the working directory over and over again.</p></div><div class="sect2" title="The Difference Between = and :="><div class="titlepage"><div><div><h2 class="title"><a id="difference_between_equals_and_equals"/>The Difference Between = and :=</h2></div></div></div><p>Ninety-nine percent of the time, you’ll see variable definitions in makefiles that use the <code class="literal">=</code> form, like this:</p><a id="pro_id00304"/><pre class="programlisting">   FOO = foo
   BAR = bar
   FOOBAR = $(FOO) $(BAR)

   all: $(FOOBAR)
➊ $(FOOBAR):
   →  @echo $@ $(FOOBAR)

   FOO = fooey
   BAR = barney</pre><p>Here, variables <code class="literal">FOO</code>, <code class="literal">BAR</code>, and <code class="literal">FOOBAR</code> are <span class="emphasis"><em>recursively expanded</em></span> variables. That means that when the value of a variable is needed, any variables that it references are expanded at that point. For example, if the value of <code class="literal">$(FOOBAR)</code> is needed, GNU <code class="literal">make</code> gets the value of <code class="literal">$(FOO)</code> and <code class="literal">$(BAR)</code>, puts them together with the space in between, and returns <code class="literal">foo bar</code>. Expansion through as many levels of variables as necessary is done when the variable is used.</p><p>In this makefile <code class="literal">FOOBAR</code> has two different values. Running it prints out:</p><a id="pro_id00305"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
foo fooey barney
bar fooey barney</pre><p>The value of <code class="literal">FOOBAR</code> is used to define the list of prerequisites to the <code class="literal">all</code> rule and is expanded as <code class="literal">foo bar</code>; the same thing happens for the next rule ➊, which defines rules for <code class="literal">foo</code> and <code class="literal">bar</code>.</p><p>But when the rules are <span class="emphasis"><em>run</em></span>, the value of <code class="literal">FOOBAR</code> as used in the <code class="literal">echo</code> produces <code class="literal">fooey barney</code>. (You can verify that the value of <code class="literal">FOOBAR</code> was <code class="literal">foo bar</code> when the rules were defined by looking at the value of <code class="literal">$@</code>, the target being built, when the rules are run).</p><p>Keep in mind the following two cases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>When a rule is being defined in a makefile, variables will evaluate to their value <span class="emphasis"><em>at that point</em></span> in the makefile.</p></li><li class="listitem"><p>Variables used in recipes (that is, in the commands) have the final value: whatever value the variable had at the end of the makefile.</p></li></ul></div><p><a id="iddle1021" class="indexterm"/><a id="iddle1253" class="indexterm"/><a id="iddle1751" class="indexterm"/><a id="iddle1885" class="indexterm"/>If the definition of <code class="literal">FOOBAR</code> is changed to use a <code class="literal">:=</code> instead of <code class="literal">=</code>, running the makefile produces a very different result:</p><a id="pro_id00306"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
foo foo bar
bar foo bar</pre><p>Now <code class="literal">FOOBAR</code> has the same value everywhere. This is because <code class="literal">:=</code> forces the right side of the definition to be expanded at that moment during makefile parsing. Rather than storing <code class="literal">$(FOO) $(BAR)</code> as the definition of <code class="literal">FOOBAR</code>, GNU <code class="literal">make</code> stores the expansion of <code class="literal">$(FOO) $(BAR)</code>, which at that point is <code class="literal">foo bar</code>. The fact that <code class="literal">FOO</code> and <code class="literal">BAR</code> are redefined later in the makefile is irrelevant; <code class="literal">FOOBAR</code> has already been expanded and set to a fixed string. GNU <code class="literal">make</code> refers to variables defined in this way as <span class="emphasis"><em>simply expanded</em></span>.</p><p>Once a variable has become simply expanded, it remains that way unless it is redefined using the <code class="literal">=</code> operator. This means that when text is appended to a simply expanded variable, it is expanded before being added to the variable.</p><p>For example, this:</p><a id="pro_id00307"/><pre class="programlisting">FOO=foo
BAR=bar
BAZ=baz
FOOBAR := $(FOO) $(BAR)
FOOBAR += $(BAZ)
BAZ=bazzy</pre><p>results in <code class="literal">FOOBAR</code> being <code class="literal">foo bar baz</code>. If <code class="literal">=</code> had been used instead of <code class="literal">:=</code>, when <code class="literal">$(BAZ)</code> was appended, it would not have been expanded and the resulting <code class="literal">FOOBAR</code> would have been <code class="literal">foo baz bazzy</code>.</p></div><div class="sect2" title="The Hidden Cost of ="><div class="titlepage"><div><div><h2 class="title"><a id="hidden_cost_of_equals"/>The Hidden Cost of =</h2></div></div></div><p>Take a look at this example makefile:</p><a id="pro_id00308"/><pre class="programlisting">CWD = $(shell pwd)
SRC_DIR=$(CWD)/src/
OBJ_DIR=$(CWD)/obj/
OBJS = $(OBJ_DIR)foo.o $(OBJ_DIR)bar.o $(OBJ_DIR)baz.o

$(OBJ_DIR)%.o: $(SRC_DIR)%.c ; @echo Make $@ from $&lt;

all: $(OBJS)
→  @echo $? $(OBJS)</pre><p>It gets the current working directory into <code class="literal">CWD</code>, defines a source and object directory as subdirectories of the <code class="literal">CWD</code>, defines a set of objects (<code class="literal">foo.o</code>, <code class="literal">bar.o</code>, and <code class="literal">baz.o</code>) to be built in the <code class="literal">OBJ_DIR</code>, sets up a pattern rule showing how to build a <code class="literal">.o</code> from a <code class="literal">.c</code>, and finally states that by default the makefile <a id="iddle1732" class="indexterm"/><a id="iddle1780" class="indexterm"/><a id="iddle1877" class="indexterm"/><a id="iddle1928" class="indexterm"/>should build all the objects and print out a list of those that were out of date (<code class="literal">$?</code> is the list of prerequisites of a rule that were out of date) as well as a full list of objects.</p><p>You might be surprised to learn that this makefile ends up making eight shell invocations just to get the <code class="literal">CWD</code> value. Imagine how many times GNU <code class="literal">make</code> would make costly calls to the shell in a real makefile with hundreds or thousands of objects!</p><p>So many calls to <code class="literal">$(shell)</code> are made because the makefile uses recursively expanded variables: variables whose value is determined when the variable is used but not at definition time. <code class="literal">OBJS</code> references <code class="literal">OBJ_DIR</code> three times, which references <code class="literal">CWD</code> each time; every time <code class="literal">OBJS</code> is referenced, three calls are made to <code class="literal">$(shell pwd)</code>. Any other reference to <code class="literal">SRC_DIR</code> or <code class="literal">OBJ_DIR</code> (for example, the pattern rule definition) results in another <code class="literal">$(shell pwd)</code>.</p><p>But a quick fix for this is just to change the definition of <code class="literal">CWD</code> to simply expand by inserting a <code class="literal">:</code> to turn <code class="literal">=</code> into <code class="literal">:=</code>. Because the working directory doesn’t change during the <code class="literal">make</code>, we can safely get it once:</p><a id="pro_id00309"/><pre class="programlisting">CWD := $(shell pwd)</pre><p>Now, a single call out to the shell is made to get the working directory. In a real makefile this could be a huge time-saver.</p><p>Because it can be difficult to follow through a makefile to see everywhere a variable is used, you can use a simple trick that will cause <code class="literal">make</code> to print out the exact line at which a variable is expanded. Insert <code class="literal">$(warning Call to shell)</code> in the definition of <code class="literal">CWD</code> so that its definition becomes this:</p><a id="pro_id00310"/><pre class="programlisting">CWD = <span class="strong"><strong>$(warning Call to shell)</strong></span>$(shell pwd)</pre><p>Then you get the following output when you run <code class="literal">make</code>:</p><a id="pro_id00311"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
makefile:8: Call to shell
makefile:8: Call to shell
makefile:10: Call to shell
makefile:10: Call to shell
makefile:10: Call to shell
Make /somedir/obj/foo.o from /somedir/src/foo.c
Make /somedir/obj/bar.o from /somedir/src/bar.c
Make /somedir/obj/baz.o from /somedir/src/baz.c
makefile:11: Call to shell
makefile:11: Call to shell
makefile:11: Call to shell
/somedir/obj/foo.o /somedir/obj/bar.o /somedir/obj/baz.o /somedir/obj/foo.o
/somedir/obj/bar.o /somedir/obj/baz.o</pre><p>The <code class="literal">$(warning)</code> doesn’t change the value of <code class="literal">CWD</code>, but it does output a message to <code class="literal">STDERR</code>. From the output you can see the eight calls to the shell and which lines in the makefile caused them.</p><p><a id="iddle1266" class="indexterm"/><a id="iddle1873" class="indexterm"/>If <code class="literal">CWD</code> is defined using <code class="literal">:=</code>, the <code class="literal">$(warning)</code> trick verifies that <code class="literal">CWD</code> is expanded only once:</p><a id="pro_id00312"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
makefile:1: Call to shell
Make /somedir/obj/foo.o from /somedir/src/foo.c
Make /somedir/obj/bar.o from /somedir/src/bar.c
Make /somedir/obj/baz.o from /somedir/src/baz.c
/somedir/obj/foo.o /somedir/obj/bar.o /somedir/obj/baz.o /somedir/obj/foo.o
/somedir/obj/bar.o /somedir/obj/baz.o</pre><p>A quick way to determine if a makefile uses the expensive combination of <code class="literal">=</code> and <code class="literal">$(shell)</code> is to run the command:</p><a id="pro_id00313"/><pre class="programlisting">grep -n \$\(shell makefile | grep -v :=</pre><p>This prints out the line number and details of every line in the makefile that contains a <code class="literal">$(shell)</code> and doesn’t contain a <code class="literal">:=</code>.</p></div></div><div class="sect1" title="$(eval) and Variable Caching"><div class="titlepage"><div><div><h1 class="title"><a id="dollarleft_parenthesisevalright_parenthe"/>$(eval) and Variable Caching</h1></div></div></div><p>In the previous section, you learned how to use <code class="literal">:=</code> to speed up makefiles by not repeatedly performing a <code class="literal">$(shell)</code>. Unfortunately, it can be problematic to rework makefiles to use <code class="literal">:=</code> because they may rely on being able to define variables in any order.</p><p>In this section, you’ll learn how to use GNU <code class="literal">make</code>’s <code class="literal">$(eval)</code> function to get the benefits of recursively expanded variables using <code class="literal">=</code> while getting the sort of speedup that’s possible with <code class="literal">:=</code>.</p><div class="sect2" title="About $(eval)"><div class="titlepage"><div><div><h2 class="title"><a id="about_dollarleft_parenthesisevalright_pa"/>About $(eval)</h2></div></div></div><p><code class="literal">$(eval)</code>’s argument is expanded and then parsed as if it were typed in as part of a makefile. As a result, within a <code class="literal">$(eval)</code> (which could be inside a variable definition) you can programmatically define variables, create rules (explicit or pattern), include other makefiles, and so on. It’s a powerful function.</p><p>Here’s an example:</p><a id="pro_id00314"/><pre class="programlisting">set = $(eval $1 := $2)

$(call set,FOO,BAR)
$(call set,A,B)</pre><p>This results in <code class="literal">FOO</code> having the value <code class="literal">BAR</code> and <code class="literal">A</code> having the value <code class="literal">B</code>. Obviously, this example could have been achieved without <code class="literal">$(eval)</code>, but it’s easy to see how you can use <code class="literal">$(eval)</code> to make programmatic changes to the definitions in a makefile.</p></div><div class="sect2" title="An $(eval) Side Effect"><div class="titlepage"><div><div><h2 class="title"><a id="dollarleft_parenthesisevalright-id00007"/>An $(eval) Side Effect</h2></div></div></div><p><a id="iddle1011" class="indexterm"/><a id="iddle1099" class="indexterm"/><a id="iddle1157" class="indexterm"/><a id="iddle1265" class="indexterm"/><a id="iddle1861" class="indexterm"/>One use of <code class="literal">$(eval)</code> is to create side effects. For example, here’s a variable that is actually an auto-incrementing counter (it uses the arithmetic functions from the GMSL):</p><a id="pro_id00315"/><pre class="programlisting">include gmsl

c-value := 0
counter = $(c-value)$(eval c-value := $(call plus,$(c-value),1))</pre><p>Every time <code class="literal">counter</code> is used, its value is incremented by one. For example, the following sequence of <code class="literal">$(info)</code> functions outputs numbers in sequence starting from <code class="literal">0</code>:</p><a id="pro_id00316"/><pre class="programlisting">$(info Starts at $(counter))
$(info Then it's $(counter))
$(info And then it's $(counter))</pre><p>Here’s the output:</p><a id="pro_id00317"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
Starts at 0
Then it's 1
And then it's 2</pre><p>You could use a simple side effect like this to find out how often a particular variable is reevaluated by GNU <code class="literal">make</code>. You might be surprised at the result. For example, when building GNU <code class="literal">make</code>, the variable <code class="literal">srcdir</code> from its makefile is accessed 48 times; <code class="literal">OBJEXT</code> is accessed 189 times, and that’s in a very small project.</p><p>GNU <code class="literal">make</code> wastes time accessing an unchanging variable by looking at the same string repeatedly. If the variable being accessed is long (such as a long path) or contains calls to <code class="literal">$(shell)</code> or complex GNU <code class="literal">make</code> functions, the performance of variable handling could affect the overall runtime of a <code class="literal">make</code>.</p><p>That’s especially important if you are trying to minimize build time by parallelizing the <code class="literal">make</code> or if a developer is running an incremental build requiring just a few files to be rebuilt. In both cases a long startup time by GNU <code class="literal">make</code> could be very inefficient.</p></div><div class="sect2" title="Caching Variable Values"><div class="titlepage"><div><div><h2 class="title"><a id="caching_variable_values"/>Caching Variable Values</h2></div></div></div><p>GNU <code class="literal">make</code> does provide a solution to the problem of reevaluating a variable over and over again: use <code class="literal">:=</code> instead of <code class="literal">=</code>. A variable defined using <code class="literal">:=</code> gets its value set once and for all, the right side is evaluated once, and the resulting value is set in the variable. Using := can cause a makefile to be parsed more quickly because the right side is evaluated only once. But it does <a id="iddle1098" class="indexterm"/><a id="iddle1674" class="indexterm"/><a id="iddle1772" class="indexterm"/>introduce limitations, so it is rarely used. One limitation is that it requires variable definitions to be ordered a certain way. For example, if ordered this way:</p><a id="pro_id00318"/><pre class="programlisting">FOO := $(BAR)
BAR := bar</pre><p>the result in <code class="literal">FOO</code> would have a totally different value than if it was ordered this way:</p><a id="pro_id00319"/><pre class="programlisting">BAR := bar
FOO := $(BAR)</pre><p>In the first snippet <code class="literal">FOO</code> is empty, and in the second <code class="literal">FOO</code> is <code class="literal">bar</code>.</p><p>Contrast that with the simplicity of the following:</p><a id="pro_id00320"/><pre class="programlisting">FOO = $(BAR)
BAR = bar</pre><p>Here, <code class="literal">FOO</code> is <code class="literal">bar</code>. Most makefiles are written in this style, and only very conscientious (and speed conscious) makefile authors use <code class="literal">:=</code>.</p><p>On the other hand, almost all of these recursively defined variables only ever have one value when used. The long evaluation time for a complex recursively defined variable is a convenience for the makefile author.</p><p>An ideal solution would be to cache variable values so the flexibility of the <code class="literal">=</code> style is preserved, but the variables are only evaluated once for speed. Clearly, this would cause a minor loss of flexibility, because a variable can’t take two different values (which is sometimes handy in a makefile). But for most uses, it would provide a significant speed boost.</p></div><div class="sect2" title="Speed Improvements with Caching"><div class="titlepage"><div><div><h2 class="title"><a id="speed_improvements_with_caching"/>Speed Improvements with Caching</h2></div></div></div><p>Consider the example makefile in <a class="xref" href="ch04.html#in_this_makefilecomma_foo_and_c_are_usel" title="Example 4-1. In this makefile, FOO and C are uselessly evaluated over and over again.">Example 4-1</a>:</p><div class="example"><a id="in_this_makefilecomma_foo_and_c_are_usel"/><p class="title">Example 4-1. In this makefile, <code class="literal">FOO</code> and <code class="literal">C</code> are uselessly evaluated over and over again.</p><div class="example-contents"><pre class="programlisting">C := 1234567890 ABCDEFGHIJKLMNOPQRSTUVWXYZ
C += $C
C += $C
C += $C
C += $C
C += $C
C += $C
C += $C
C += $C
C += $C
C += $C
C += $C

FOO = $(subst 9,NINE,$C)$(subst 8,EIGHT,$C)$(subst 7,SEVEN,$C) \
$(subst 6,SIX,$C)$(subst 5,FIVE,$C)$(subst 4,FOUR,$C)          \
$(subst 3,THREE,$C)$(subst 2,TWO,$C)$(subst 1,ONE,$C)
_DUMMY := $(FOO)
--<span class="emphasis"><em>snip</em></span>--

.PHONY: all
all:</pre></div></div><p><a id="iddle1096" class="indexterm"/>It defines a variable <code class="literal">C</code>, which is a long string (it’s actually <code class="literal">1234567890</code> repeated 2,048 times followed by the alphabet repeated 2,048 times plus spaces for a total of 77,824 characters). Here <code class="literal">:=</code> is used so that <code class="literal">C</code> is created quickly. <code class="literal">C</code> is designed to emulate the sort of long strings that are generated within makefiles (for example, long lists of source files with paths).</p><p>Then a variable <code class="literal">FOO</code> is defined that manipulates <code class="literal">C</code> using the built-in <code class="literal">$(subst)</code> function. <code class="literal">FOO</code> emulates the sort of manipulation that occurs within makefiles (such as changing filename extensions from <code class="literal">.c</code> to <code class="literal">.o</code>).</p><p>Finally, <code class="literal">$(FOO)</code> is evaluated 200 times to emulate the use of <code class="literal">FOO</code> in a small but realistically sized makefile. The makefile does nothing; there’s a dummy, empty <code class="literal">all</code> rule at the end.</p><p>On my laptop, using GNU <code class="literal">make</code> 3.81, this makefile takes about 3.1 seconds to run. That’s a long time spent repeatedly manipulating <code class="literal">C</code> and <code class="literal">FOO</code> but not doing any actual building.</p><p>Using the <code class="literal">counter</code> trick from <a class="xref" href="ch04.html#dollarleft_parenthesisevalright-id00007" title="An $(eval) Side Effect">An $(eval) Side Effect</a>, you can figure out how many times <code class="literal">FOO</code> and <code class="literal">C</code> are evaluated in this makefile. <code class="literal">FOO</code> was evaluated 200 times and <code class="literal">C</code> 1600 times. It’s amazing how fast these evaluations can add up.</p><p>But the values of <code class="literal">C</code> and <code class="literal">FOO</code> need to be calculated only once, because they don’t change. Let’s say you alter the definition of <code class="literal">FOO</code> to use <code class="literal">:=</code>:</p><a id="pro_id00321"/><pre class="programlisting">FOO := $(subst 9,NINE,$C)$(subst 8,EIGHT,$C)$(subst 7,SEVEN,$C) \
$(subst 6,SIX,$C)$(subst 5,FIVE,$C)$(subst 4,FOUR,$C)           \
$(subst 3,THREE,$C)$(subst 2,TWO,$C)$(subst 1,ONE,$C)</pre><p>This drops the runtime to 1.8 seconds, <code class="literal">C</code> is evaluated nine times, and <code class="literal">FOO</code> is evaluated just once. But, of course, that requires using <code class="literal">:=</code> with all its problems.</p></div><div class="sect2" title="A Caching Function"><div class="titlepage"><div><div><h2 class="title"><a id="caching_function"/>A Caching Function</h2></div></div></div><p>An alternative caching function is this simple caching scheme:</p><a id="pro_id00322"/><pre class="programlisting">cache = $(if $(cached-$1),,$(eval cached-$1 := 1)$(eval cache-$1 := $($1)))$(cache-$1)</pre><p>First, a function called <code class="literal">cache</code> is defined, which automatically caches a variable’s value the first time it is evaluated and retrieves it from the cache for each subsequent attempt to retrieve it.</p><p><code class="literal">cache</code> uses two variables to store the cached value of a variable (when caching variable <code class="literal">A</code>, the cached value is stored in <code class="literal">cache-A</code>) and whether the variable has been cached (when caching variable <code class="literal">A</code>, the <span class="emphasis"><em>has been cached flag</em></span> is <code class="literal">cached-A</code>).</p><p><a id="iddle1862" class="indexterm"/>First, it checks to see whether the variable has been cached; if it has, the <code class="literal">$(if)</code> does nothing. If it hasn’t, the cached flag is set for that variable in the first <code class="literal">$(eval)</code> and then the value of the variable is expanded (notice the <code class="literal">$($1)</code>, which gets the name of the variable and then gets its value) and cached. Finally, <code class="literal">cache</code> returns the value from cache.</p><p>To update the makefile, simply turn any reference to a variable into a call to the <code class="literal">cache</code> function. For example, you can modify the makefile from <a class="xref" href="ch04.html#in_this_makefilecomma_foo_and_c_are_usel" title="Example 4-1. In this makefile, FOO and C are uselessly evaluated over and over again.">Example 4-1</a> by changing all occurrences of <code class="literal">$(FOO)</code> to <code class="literal">$(call cache,FOO)</code> using a simple find and replace. The result is shown in <a class="xref" href="ch04.html#modified_version_of_listing_4-1_that_use" title="Example 4-2. A modified version of Example 4-1 that uses the cache function">Example 4-2</a>.</p><div class="example"><a id="modified_version_of_listing_4-1_that_use"/><p class="title">Example 4-2. A modified version of <a class="xref" href="ch04.html#in_this_makefilecomma_foo_and_c_are_usel" title="Example 4-1. In this makefile, FOO and C are uselessly evaluated over and over again.">Example 4-1</a> that uses the <code class="literal">cache function</code></p><div class="example-contents"><pre class="programlisting">C := 1234567890 ABCDEFGHIJKLMNOPQRSTUVWXYZ
C += $C
C += $C
C += $C
C += $C
C += $C
C += $C
C += $C
C += $C
C += $C
C += $C
C += $C

FOO = $(subst 9,NINE,$C)$(subst 8,EIGHT,$C)$(subst 7,SEVEN,$C) \
$(subst 6,SIX,$C)$(subst 5,FIVE,$C)$(subst 4,FOUR,$C)          \
$(subst 3,THREE,$C)$(subst 2,TWO,$C)$(subst 1,ONE,$C)

_DUMMY := $(call cache,FOO)
--<span class="emphasis"><em>snip</em></span>--

.PHONY: all
all:</pre></div></div><p>Running this on my machine shows that there’s now one access of <code class="literal">FOO</code>, the same nine accesses of <code class="literal">C</code>, and a runtime of 2.4 seconds. It’s not as fast as the <code class="literal">:=</code> version (which took 1.8 seconds), but it’s still 24 percent faster. On a big makefile, this technique could make a real difference.</p></div><div class="sect2" title="Wrapping Up"><div class="titlepage"><div><div><h2 class="title"><a id="wrapping_up"/>Wrapping Up</h2></div></div></div><p>The fastest way to handle variables is to use <code class="literal">:=</code> whenever you can, but it requires care and attention, and is probably best done only in a new makefile (just imagine trying to go back and reengineer an existing makefile to use <code class="literal">:=</code>).</p><p>If you’re stuck with <code class="literal">=</code>, the <code class="literal">cache</code> function presented here can give you a speed boost that developers doing incremental short builds will especially appreciate.</p><p><a id="iddle1409" class="indexterm"/><a id="iddle1816" class="indexterm"/>If it’s only necessary to change a single variable definition, it’s possible to eliminate the <code class="literal">cache</code> function. For example, here’s the definition of <code class="literal">FOO</code> changed to magically switch from being recursively defined to a simple definition:</p><a id="pro_id00323"/><pre class="programlisting">FOO = $(eval FOO := $(subst 9,NINE,$C)$(subst 8,EIGHT,$C)$(subst 7,SEVEN,$C) \
$(subst 6,SIX,$C)$(subst 5,FIVE,$C)$(subst 4,FOUR,$C)$(subst 3,THREE,$C)     \
$(subst 2,TWO,$C)$(subst 1,ONE,$C))$(value FOO)</pre><p>The first time <code class="literal">$(FOO)</code> is referenced, the <code class="literal">$(eval)</code> happens, turning <code class="literal">FOO</code> from a recursively defined variable to a simple definition (using <code class="literal">:=</code>). The <code class="literal">$(value FOO)</code> at the end returns the value stored in <code class="literal">FOO</code>, making this process transparent.</p></div></div><div class="sect1" title="The Trouble with Hidden Targets"><div class="titlepage"><div><div><h1 class="title"><a id="trouble_with_hidden_targets"/>The Trouble with Hidden Targets</h1></div></div></div><p>Take a look at the makefile in <a class="xref" href="ch04.html#in_this_makefilecomma_the_rule_to_make_f" title="Example 4-3. In this makefile, the rule to make foo also makes foo.c.">Example 4-3</a>:</p><div class="example"><a id="in_this_makefilecomma_the_rule_to_make_f"/><p class="title">Example 4-3. In this makefile, the rule to make <code class="literal">foo</code> also makes <code class="literal">foo.c</code>.</p><div class="example-contents"><pre class="programlisting">.PHONY: all
all: foo foo.o foo.c

foo:
→  touch $@ foo.c

%.o: %.c
→  touch $@</pre></div></div><p>It contains a nasty trap for the unwary that can cause <code class="literal">make</code> to report odd errors, stop the <code class="literal">-n</code> option from working, and prevent a speedy parallel <code class="literal">make</code>. It can even cause GNU <code class="literal">make</code> to do the wrong work and update an up-to-date file.</p><p>On the face of it this makefile looks pretty simple. If you run it through GNU <code class="literal">make</code>, it’ll build <code class="literal">foo</code> (which creates the files <code class="literal">foo</code> and <code class="literal">foo.c</code>) and then use the pattern at the bottom to make <code class="literal">foo.o</code> from <code class="literal">foo.c</code>. It ends up running the following commands:</p><a id="pro_id00324"/><pre class="programlisting">touch foo foo.c
touch foo.o</pre><p>But there’s a fatal flaw. Nowhere does this makefile mention that the rule to make <code class="literal">foo</code> actually also makes <code class="literal">foo.c</code>. So <code class="literal">foo.c</code> is a <span class="emphasis"><em>hidden target</em></span>, a file that was built but that GNU <code class="literal">make</code> is unaware of, and hidden targets cause an endless number of problems.</p><p>GNU <code class="literal">make</code> is very good at keeping track of targets, files that need to be built, and the dependencies between targets. But the <code class="literal">make</code> program is only as good as its inputs. If you don’t tell <code class="literal">make</code> about a relationship between <a id="iddle1131" class="indexterm"/><a id="iddle1136" class="indexterm"/><a id="iddle1255" class="indexterm"/><a id="iddle1596" class="indexterm"/>two files, it won’t discover it on its own and it’ll make mistakes because it assumes it has perfect knowledge about the files and their relationships.</p><p>In this example, <code class="literal">make</code> only works because it builds the prerequisites of <code class="literal">all</code> from left to right. First it encounters <code class="literal">foo</code>, which it builds, creating <code class="literal">foo.c</code> as a side effect, and then it builds <code class="literal">foo.o</code> using the pattern. If you change the order of the prerequisites of <code class="literal">all</code> so that it doesn’t build <code class="literal">foo</code> first, the build will fail.</p><p>There are (at least!) five nasty side effects of hidden targets.</p><div class="sect2" title="An Unexpected Error if the Hidden Target Is Missing"><div class="titlepage"><div><div><h2 class="title"><a id="unexpected_error_if_the_hidden_target_is"/>An Unexpected Error if the Hidden Target Is Missing</h2></div></div></div><p>Suppose that <code class="literal">foo</code> exists, but <code class="literal">foo.c</code> and <code class="literal">foo.o</code> are missing:</p><a id="pro_id00325"/><pre class="programlisting">$ <span class="strong"><strong>rm -f foo.c foo.o</strong></span>
$ <span class="strong"><strong>touch foo</strong></span>
$ <span class="strong"><strong>make</strong></span>
No rule to make target `foo.c', needed by `foo.o'.</pre><p><code class="literal">make</code> tries to update <code class="literal">foo.o</code>, but because it doesn’t know how to make <code class="literal">foo.c</code> (because it’s not mentioned as the target of any rule), invoking GNU <code class="literal">make</code> results in an error.</p></div><div class="sect2" title="The -n Option Fails"><div class="titlepage"><div><div><h2 class="title"><a id="n_option_fails"/>The -n Option Fails</h2></div></div></div><p>The helpful <code class="literal">-n</code> debugging option in GNU <code class="literal">make</code> tells it to print out the commands that it would run to perform the build without actually running them:</p><a id="pro_id00326"/><pre class="programlisting">$ <span class="strong"><strong>make -n</strong></span> 
touch foo foo.c
No rule to make target `foo.c', needed by `foo.o'.</pre><p>You’ve seen that <code class="literal">make</code> would actually perform two <code class="literal">touch</code> commands (<code class="literal">touch foo foo.c</code> followed by <code class="literal">touch foo.o</code>), but doing a <code class="literal">make -n</code> (with no <code class="literal">foo*</code> files present) results in an error. <code class="literal">make</code> doesn’t know that the rule for <code class="literal">foo</code> makes <code class="literal">foo.c</code>, and because it hasn’t actually run the <code class="literal">touch</code> command, <code class="literal">foo.c</code> is missing. Thus, the <code class="literal">-n</code> doesn’t represent the actual commands that <code class="literal">make</code> would run, making it useless for debugging.</p></div><div class="sect2" title="You Can’t Parallelize make"><div class="titlepage"><div><div><h2 class="title"><a id="you_canapostrophet_parallelize_make"/>You Can’t Parallelize make</h2></div></div></div><p>GNU <code class="literal">make</code> provides a handy feature that allows it to run multiple jobs at once. If you have many compiles in a build, specifying the <code class="literal">-j</code> option (followed by a number indicating the number of jobs to run at the same time) can maximize CPU utilization and shorten the build.</p><p>Unfortunately, a hidden target spoils that plan. Here’s the output from <code class="literal">make -j3</code> running three jobs at once on our example makefile from <a class="xref" href="ch04.html#in_this_makefilecomma_the_rule_to_make_f" title="Example 4-3. In this makefile, the rule to make foo also makes foo.c.">Example 4-3</a>:</p><a id="pro_id00327"/><pre class="programlisting">$ <span class="strong"><strong>make -j3</strong></span>
touch foo foo.c
No rule to make target `foo.c', needed by `foo.o'.
Waiting for unfinished jobs....</pre><p><a id="iddle1260" class="indexterm"/><a id="iddle1689" class="indexterm"/><a id="iddle1770" class="indexterm"/><a id="iddle1807" class="indexterm"/>GNU <code class="literal">make</code> tried to build <code class="literal">foo</code>, <code class="literal">foo.o</code>, and <code class="literal">foo.c</code> at the same time, and discovered that it didn’t know how to build <code class="literal">foo.c</code> because it had no way of knowing that it should wait for <code class="literal">foo</code> to be made.</p></div><div class="sect2" title="make Does the Wrong Work if the Hidden Target Is Updated"><div class="titlepage"><div><div><h2 class="title"><a id="make_does_the_wrong_work_if_the_hidden_t"/>make Does the Wrong Work if the Hidden Target Is Updated</h2></div></div></div><p>Suppose the file <code class="literal">foo.c</code> already exists when <code class="literal">make</code> is run. Because <code class="literal">make</code> doesn’t know that the rule for <code class="literal">foo</code> will mess with <code class="literal">foo.c</code>, it’ll get updated even though it’s up-to-date. In <a class="xref" href="ch04.html#modified_version_of_listing_4-1_that_use" title="Example 4-2. A modified version of Example 4-1 that uses the cache function">Example 4-2</a>, <code class="literal">foo.c</code> is altered by a benign <code class="literal">touch</code> operation that only alters the file’s timestamp, but a different operation could destroy or overwrite the contents of the file:</p><a id="pro_id00328"/><pre class="programlisting">$ <span class="strong"><strong>touch foo.c</strong></span>
$ <span class="strong"><strong>rm -f foo foo.o</strong></span>
$ <span class="strong"><strong>make</strong></span>
touch foo foo.c
touch foo.o</pre><p><code class="literal">make</code> rebuilds <code class="literal">foo</code> because it’s missing and updates <code class="literal">foo.c</code> at the same time, even though it was apparently up-to-date.</p></div><div class="sect2" title="You Can’t Direct make to Build foo.o"><div class="titlepage"><div><div><h2 class="title"><a id="you_canapostrophet_direct_make_to_build"/>You Can’t Direct make to Build foo.o</h2></div></div></div><p>You’d hope that typing <code class="literal">make foo.o</code> would result in GNU <code class="literal">make</code> building <code class="literal">foo.o</code> from <code class="literal">foo.c</code> and, if necessary, building <code class="literal">foo.c</code>. But <code class="literal">make</code> doesn’t know how to build <code class="literal">foo.c</code>. That just happens by accident when building <code class="literal">foo</code>:</p><a id="pro_id00329"/><pre class="programlisting">$ <span class="strong"><strong>rm -f foo.c</strong></span>
$ <span class="strong"><strong>make foo.o</strong></span>
No rule to make target `foo.c', needed by `foo.o'.</pre><p>So if <code class="literal">foo.c</code> is missing, <code class="literal">make foo.o</code> results in an error.</p><p>Hopefully, you’re now convinced that hidden targets are a bad idea and can lead to all sorts of build problems.</p></div></div><div class="sect1" title="GNU make’s Escaping Rules"><div class="titlepage"><div><div><h1 class="title"><a id="gnu_makeapostrophes_escaping_rules"/>GNU make’s Escaping Rules</h1></div></div></div><p>Sometimes you’ll need to insert a special character in a makefile. Perhaps you need a newline inside an <code class="literal">$(error)</code> message, a space character in a <code class="literal">$(subst)</code>, or a comma as the argument to a GNU <code class="literal">make</code> function. Those three simple tasks can be frustratingly difficult to do in GNU <code class="literal">make</code>; this section takes you through simple syntax that eliminates the frustration.</p><p>GNU <code class="literal">make</code>’s use of the tab character at the start of any line containing commands is a notorious language feature, but some other special characters can also trip you up. The ways GNU <code class="literal">make</code> handles <code class="literal">$</code>, <code class="literal">%</code>, <code class="literal">?</code>, <code class="literal">*</code>, <code class="literal">[</code>, <code class="literal">~</code>, <code class="literal">\</code>, and <code class="literal">#</code> are all special.</p><div class="sect2" title="Dealing with $"><div class="titlepage"><div><div><h2 class="title"><a id="dealing_with_dollar"/>Dealing with $</h2></div></div></div><p><a id="iddle1004" class="indexterm"/><a id="iddle1012" class="indexterm"/><a id="iddle1016" class="indexterm"/><a id="iddle1027" class="indexterm"/><a id="iddle1033" class="indexterm"/><a id="iddle1078" class="indexterm"/><a id="iddle1137" class="indexterm"/><a id="iddle1223" class="indexterm"/><a id="iddle1314" class="indexterm"/><a id="iddle1610" class="indexterm"/><a id="iddle1618" class="indexterm"/><a id="iddle1657" class="indexterm"/><a id="iddle1871" class="indexterm"/><a id="iddle1912" class="indexterm"/>Every GNU <code class="literal">make</code> user is familiar with <code class="literal">$</code> for starting a variable reference. It’s possible to write <code class="literal">$(variable)</code> (with parentheses) or <code class="literal">${variable}</code> (with curly brackets) to get the value of <code class="literal">variable</code>, and if the variable name is a single character (such as <code class="literal">a</code>), you can drop the parentheses and just use <code class="literal">$a</code>.</p><p>To get a literal <code class="literal">$</code>, you write <code class="literal">$$</code>. So to define a variable containing a single <code class="literal">$</code> symbol you’d write: <code class="literal">dollar := $$</code>.</p></div><div class="sect2" title="Playing with %"><div class="titlepage"><div><div><h2 class="title"><a id="playing_with_percent"/>Playing with %</h2></div></div></div><p>Escaping <code class="literal">%</code> is not as simple as <code class="literal">$</code>, but it needs to be done in only three situations, and the same rules apply for each: in the <code class="literal">vpath</code> directive, in a <code class="literal">$(patsubst)</code>, and in a pattern or static-pattern rule.</p><p>The three rules for <code class="literal">%</code> escaping are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>You can escape <code class="literal">%</code> with a single <code class="literal">\</code> character (that is, <code class="literal">\%</code> becomes a literal <code class="literal">%</code>).</p></li><li class="listitem"><p>If you need to put a literal <code class="literal">\</code> in front of a <code class="literal">%</code> (that is, you want the <code class="literal">\</code> to not escape the <code class="literal">%</code>), escape it with <code class="literal">\</code> (in other words, <code class="literal">\\%</code> becomes a literal <code class="literal">\</code> followed by a <code class="literal">%</code> character that <span class="emphasis"><em>will</em></span> be used for the pattern match).</p></li><li class="listitem"><p>Don’t worry about escaping <code class="literal">\</code> anywhere else in a pattern. It will be treated as a literal. For example, <code class="literal">\hello</code> is <code class="literal">\hello</code>.</p></li></ul></div></div><div class="sect2" title="Wildcards and Paths"><div class="titlepage"><div><div><h2 class="title"><a id="wildcards_and_paths"/>Wildcards and Paths</h2></div></div></div><p>The symbols <code class="literal">?</code>, <code class="literal">*</code>, <code class="literal">[</code>, and <code class="literal">]</code> get treated specially when they appear in a filename. A makefile that has</p><a id="pro_id00330"/><pre class="programlisting">*.c:
→  @command</pre><p>will actually search for all <code class="literal">.c</code> files in the current directory and define a rule for each. The targets (along with prerequisites and files mentioned in the <code class="literal">include</code> directive) are globbed (the filesystem is searched and filenames matched against the wildcard characters) if they contain a wildcard character. The globbing characters have the same meaning as in the Bourne shell.</p><p>The <code class="literal">~</code> character is also handled specially in filenames and is expanded to the home directory of the current user.</p><p>All of those special filename characters can be escaped with a <code class="literal">\</code>. For example:</p><a id="pro_id00331"/><pre class="programlisting">\*.c:
→  @command</pre><p>This makefile defines a rule for the file named (literally) <code class="literal">*.c</code>.</p></div><div class="sect2" title="Continuations"><div class="titlepage"><div><div><h2 class="title"><a id="continuations"/>Continuations</h2></div></div></div><p><a id="iddle1002" class="indexterm"/><a id="iddle1026" class="indexterm"/><a id="iddle1076" class="indexterm"/><a id="iddle1149" class="indexterm"/><a id="iddle1156" class="indexterm"/><a id="iddle1186" class="indexterm"/><a id="iddle1404" class="indexterm"/><a id="iddle1558" class="indexterm"/>Other than the escaping function, you can also use the <code class="literal">\</code> as a continuation character at the end of a line:</p><a id="pro_id00332"/><pre class="programlisting">all:         \
prerequisite \
something else
→  @command</pre><p>Here, the rule for <code class="literal">all</code> has three prerequisites: <code class="literal">prerequisite</code>, <code class="literal">something</code>, and <code class="literal">else</code>.</p></div><div class="sect2" title="Comments"><div class="titlepage"><div><div><h2 class="title"><a id="comments"/>Comments</h2></div></div></div><p>You can use the <code class="literal">#</code> character to start a comment, and you can make it a literal with a <code class="literal">\</code> escape:</p><a id="pro_id00333"/><pre class="programlisting">pound := \#</pre><p>Here, <code class="literal">$(pound)</code> is a single character: <code class="literal">#</code>.</p></div><div class="sect2" title="I Just Want a Newline!"><div class="titlepage"><div><div><h2 class="title"><a id="i_just_want_a_newlineexclamation_mark"/>I Just Want a Newline!</h2></div></div></div><p>GNU <code class="literal">make</code> does its best to insulate you from the newline character. You can’t escape a newline—there’s no syntax for special characters (for example, you can’t write <code class="literal">\n</code>), and even the <code class="literal">$(shell)</code> function strips newlines from the returned value.</p><p>But you can define a variable that contains a newline using the <code class="literal">define</code> syntax:</p><a id="pro_id00334"/><pre class="programlisting">define newline


endef</pre><p>Note that this definition contains two blank lines, but using <code class="literal">$(newline)</code> will expand into only one newline, which can be useful for formatting error messages nicely:</p><a id="pro_id00335"/><pre class="programlisting">$(error This is an error message$(newline)with two lines)</pre><p>Because of GNU <code class="literal">make</code>’s rather liberal variable naming rules, it’s possible to define a variable called <code class="literal">\n</code>. So if you like to maintain a familiar look, you can do this:</p><a id="pro_id00336"/><pre class="programlisting">define \n


endef

$(error This is an error message $(\n)with two lines)</pre><p><a id="iddle1148" class="indexterm"/><a id="iddle1301" class="indexterm"/><a id="iddle1764" class="indexterm"/><a id="iddle1767" class="indexterm"/><a id="iddle1769" class="indexterm"/><a id="iddle1866" class="indexterm"/><a id="iddle1904" class="indexterm"/>We’ll look more at special variable names in the next section.</p></div><div class="sect2" title="Function Arguments: Spaces and Commas"><div class="titlepage"><div><div><h2 class="title"><a id="function_arguments_spaces_and_commas"/>Function Arguments: Spaces and Commas</h2></div></div></div><p>A problem that many GNU <code class="literal">make</code> users run into is the handling of spaces and commas in GNU <code class="literal">make</code> function arguments. Consider the following use of <code class="literal">$(subst)</code>:</p><a id="pro_id00337"/><pre class="programlisting">spaces-to-commas = $(subst ,,,$1)</pre><p>This takes three arguments separated by commas: the <code class="literal">from</code> text, the <code class="literal">to</code> text, and the string to change.</p><p>It defines a function called <code class="literal">spaces-to-commas</code> to convert all spaces in its argument to commas (which might be handy for making a CSV file for example). Unfortunately, it doesn’t work for two reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The first argument of the <code class="literal">$(subst)</code> is a space. GNU <code class="literal">make</code> strips all leading and trailing whitespace around function arguments. In this case, the first argument is interpreted as an empty string.</p></li><li class="listitem"><p>The second argument is a comma. GNU <code class="literal">make</code> cannot distinguish between the commas used for argument separators and the comma as an argument. In addition, there’s no way to escape the comma.</p></li></ul></div><p>You can work around both issues if you know that GNU <code class="literal">make</code> does the whitespace stripping and separation of arguments before it does any expansion of the arguments. So if we can define a variable containing a space and a variable containing a comma, we can write the following to get the desired effect:</p><a id="pro_id00338"/><pre class="programlisting">spaces-to-commas = $(subst $(space),$(comma),$1)</pre><p>Defining a variable containing a comma is easy, as shown here:</p><a id="pro_id00339"/><pre class="programlisting">comma := ,</pre><p>But space is a bit harder. You can define a space in a couple of ways. One way is to use the fact that whenever you append to a variable (using <code class="literal">+=</code>), a space is inserted before the appended text:</p><a id="pro_id00340"/><pre class="programlisting">space :=
space +=</pre><p>Another way is to first define a variable that contains nothing, and then use it to surround the space so that it doesn’t get stripped by GNU <code class="literal">make</code>:</p><a id="pro_id00341"/><pre class="programlisting">blank :=
space := $(blank) $(blank)</pre><p><a id="iddle1771" class="indexterm"/><a id="iddle1798" class="indexterm"/>You can also use this technique to get a literal tab character into a variable:</p><a id="pro_id00342"/><pre class="programlisting">blank :=
tab := $(blank)→$(blank)</pre><p>Much in the way that <code class="literal">$(\n)</code> was defined in the previous section, it’s possible to define specially named space and comma variables. GNU <code class="literal">make</code>’s rules are liberal enough to allow us to do this:</p><a id="pro_id00343"/><pre class="programlisting">, := ,

blank :=
space := $(blank) $(blank)
$(space) := $(space)</pre><p>The first line defines a variable called <code class="literal">,</code> (which can be used as <code class="literal">$(,)</code> or even <code class="literal">$,</code>) containing a comma.</p><p>The last three lines define a variable called <code class="literal">space</code> containing a space character and then use it to define a variable named (that’s right, its name is a space character) containing a space.</p><p>With that definition it’s possible to write <code class="literal">$( )</code> or even <code class="literal">$</code> (there’s a space after that <code class="literal">$</code>) to get a space character. Note that doing this might cause problems in the future as <code class="literal">make</code> is updated, so playing tricks like this can be dangerous. If you’re averse to risks, just use the variable named <code class="literal">space</code> and avoid <code class="literal">$( )</code>. Because whitespace is special in GNU <code class="literal">make</code>, pushing <code class="literal">make</code>’s parser to the limit with tricks like <code class="literal">$( )</code> might lead to breakages.</p><p>Using those definitions, the <code class="literal">spaces-to-commas</code> function can be written as:</p><a id="pro_id00344"/><pre class="programlisting">spaces-to-commas = $(subst $( ),$(,),$1)</pre><p>This strange-looking definition replaces spaces with commas using <code class="literal">subst</code>. It works because the <code class="literal">$( )</code> will get expanded by <code class="literal">subst</code> and will itself be a space. That space will then be the first parameter (the string that will be replaced). The second parameter is <code class="literal">$(,)</code>, which, when expanded, becomes a <code class="literal">,</code>. The result is that <code class="literal">spaces-to-commas</code> turns spaces into commas without confusing GNU <code class="literal">make</code> with the actual space and comma characters.</p></div><div class="sect2" title="The Twilight Zone"><div class="titlepage"><div><div><h2 class="title"><a id="twilight_zone"/>The Twilight Zone</h2></div></div></div><p>It’s possible to take definitions like <code class="literal">$( )</code> and <code class="literal">$(\n)</code> and go much further, defining variables with names like <code class="literal">=</code>, <code class="literal">#</code> or <code class="literal">:</code>. Here are other interesting variable definitions:</p><a id="pro_id00345"/><pre class="programlisting"># Define the $= or $(=) variable which has the value =
equals := =
$(equals) := =
# Define the $# or $(#) variable which has the value #
hash := \#
$(hash) := \#
# Define the $: or $(:) variable which has the value :
colon := :
$(colon) := :

# Define the $($$) variable which has the value $
dollar := $$
$(dollar) := $$</pre><p><a id="iddle1280" class="indexterm"/><a id="iddle1315" class="indexterm"/><a id="iddle1416" class="indexterm"/><a id="iddle1915" class="indexterm"/>These definitions probably aren’t useful, but if you want to push GNU <code class="literal">make</code> syntax to its limits, try this:</p><a id="pro_id00346"/><pre class="programlisting">+:=+</pre><p>Yes, that defines a variable called <code class="literal">+</code> containing a <code class="literal">+</code>.</p></div></div><div class="sect1" title="The Trouble with $(wildcard)"><div class="titlepage"><div><div><h1 class="title"><a id="trouble_with_dollarleft_parenthesiswildc"/>The Trouble with $(wildcard)</h1></div></div></div><p>The function <code class="literal">$(wildcard)</code> is GNU <code class="literal">make</code>’s globbing function. It’s a useful way of getting a list of files inside a makefile, but it can behave in unexpected ways. It doesn’t always provide the same answer as running <code class="literal">ls</code>. Read on to find out why and what to do about it.</p><div class="sect2" title="$(wildcard) Explained"><div class="titlepage"><div><div><h2 class="title"><a id="dollarleft_parenthesiswildcardright_pare"/>$(wildcard) Explained</h2></div></div></div><p>You can use <code class="literal">$(wildcard)</code> anywhere in a makefile or rule to get a list of files that match one or more <span class="emphasis"><em>glob</em></span> style patterns. For example, <code class="literal">$(wildcard *.foo)</code> returns a list of files ending in <code class="literal">.foo</code>. Recall that a list is a string where list elements are separated by spaces, so <code class="literal">$(wildcard *.foo)</code> might return <code class="literal">a.foo b.foo c.foo</code>. (If a filename contains a space, the returned list may appear incorrect because there’s no way to spot the difference between the list separator—a space—and the space in a filename.)</p><p>You can also call <code class="literal">$(wildcard)</code> with a list of patterns, so <code class="literal">$(wildcard *.foo *.bar)</code> returns all the files ending in <code class="literal">.foo</code> or <code class="literal">.bar</code>. The <code class="literal">$(wildcard)</code> function supports the following globbing operators: <code class="literal">*</code> (match 0 or more characters), <code class="literal">?</code> (match 1 character), and <code class="literal">[...]</code> (matches characters, <code class="literal">[123]</code>, or a range of characters, <code class="literal">[a-z]</code>).</p><p>Another useful feature of <code class="literal">$(wildcard)</code> is that if the filename passed to it does not contain a pattern, that file is simply checked for existence. If the file exists, its name is returned; otherwise, <code class="literal">$(wildcard)</code> returns an empty string. Thus, <code class="literal">$(wildcard)</code> can be combined with <code class="literal">$(if)</code> to create an <code class="literal">if-exists</code> function:</p><a id="pro_id00347"/><pre class="programlisting">if-exists = $(if ($wildcard $1),$2,$3)</pre><p><code class="literal">if-exists</code> has three parameters: the name of the filename to check for, what to do if the file exists, and what to do if it does not. Here’s a simple example of its use:</p><a id="pro_id00348"/><pre class="programlisting">$(info a.foo is $(call if-exists,a.foo,there,not there))</pre><p>This will print <code class="literal">a.foo is there</code> if <code class="literal">a.foo</code> exists, or it will print <code class="literal">a.foo is not there</code> if not.</p></div><div class="sect2" title="Unexpected Results"><div class="titlepage"><div><div><h2 class="title"><a id="unexpected_results"/>Unexpected Results</h2></div></div></div><p>Each of the following examples uses two variables to obtain a list of files ending in <code class="literal">.foo</code> in a particular directory: <code class="literal">WILDCARD_LIST</code> and <code class="literal">LS_LIST</code> each return the list of files ending in <code class="literal">.foo</code> by calling <code class="literal">$(wildcard)</code> and <code class="literal">$(shell ls)</code>, respectively. The variable <code class="literal">DIRECTORY</code> holds the directory in which the examples look for files; for the current directory, <code class="literal">DIRECTORY</code> is left empty.</p><p>The starting makefile looks like this:</p><a id="pro_id00349"/><pre class="programlisting">WILDCARD_LIST = wildcard returned \'$(wildcard $(DIRECTORY)*.foo)\'
LS_LIST = ls returned \'$(shell ls $(DIRECTORY)*.foo)\'

.PHONY: all
all:
→  @echo $(WILDCARD_LIST)
→  @echo $(LS_LIST)</pre><p>With a single file <code class="literal">a.foo</code> in the current directory, running GNU <code class="literal">make</code> results in this:</p><a id="pro_id00350"/><pre class="programlisting">$ <span class="strong"><strong>touch a.foo</strong></span>
$ <span class="strong"><strong>make</strong></span>
wildcard returned 'a.foo'
ls returned 'a.foo'</pre><p>Now extend the makefile so it makes a file called <code class="literal">b.foo</code> using <code class="literal">touch</code>. The makefile should look like <a class="xref" href="ch04.html#when_you_run_this_makefilecomma_ls_and_d" title="Example 4-4. When you run this makefile, ls and $(wildcard) return different results.">Example 4-4</a>:</p><div class="example"><a id="when_you_run_this_makefilecomma_ls_and_d"/><p class="title">Example 4-4. When you run this makefile, <code class="literal">ls</code> and <code class="literal">$(wildcard)</code> return different results.</p><div class="example-contents"><pre class="programlisting">WILDCARD_LIST = wildcard returned \'$(wildcard $(DIRECTORY)*.foo)\'
LS_LIST = ls returned \'$(shell ls $(DIRECTORY)*.foo)\'

.PHONY: all
all: b.foo
→ @echo $(WILDCARD_LIST)
→ @echo $(LS_LIST)

b.foo:
→ @touch $@</pre></div></div><p><a id="iddle1490" class="indexterm"/>Running this makefile through GNU <code class="literal">make</code> (with just the preexisting <code class="literal">a.foo</code> file) results in the following surprising output:</p><a id="pro_id00351"/><pre class="programlisting">$ <span class="strong"><strong>touch a.foo</strong></span>
$ <span class="strong"><strong>make</strong></span>
wildcard returned 'a.foo'
ls returned 'a.foo b.foo'</pre><p>The <code class="literal">ls</code> returns the correct list (because <code class="literal">b.foo</code> has been created by the time the <code class="literal">all</code> rule runs), but <code class="literal">$(wildcard)</code> does not; <code class="literal">$(wildcard)</code> appears to be showing the state before <code class="literal">b.foo</code> was created.</p><p>Working with the <code class="literal">.foo</code> files in a subdirectory (not in the current working directory) results in different output, as shown in <a class="xref" href="ch04.html#this_timecomma_ls_and_dollarleft_parenth" title="Example 4-5. This time, ls and $(wildcard) return the same results.">Example 4-5</a>.</p><div class="example"><a id="this_timecomma_ls_and_dollarleft_parenth"/><p class="title">Example 4-5. This time, <code class="literal">ls</code> and <code class="literal">$(wildcard)</code> return the same results.</p><div class="example-contents"><pre class="programlisting">DIRECTORY=subdir/

.PHONY: all
all: $(DIRECTORY)b.foo
→  @echo $(WILDCARD_LIST)
→  @echo $(LS_LIST)

$(DIRECTORY)b.foo:
→  @touch $@</pre></div></div><p>Here, the makefile is updated so that it uses the <code class="literal">DIRECTORY</code> variable to specify the subdirectory <code class="literal">subdir</code>. There’s a single preexisting file <code class="literal">subdir/a.foo</code>, and the makefile will create <code class="literal">subdir/b.foo</code>.</p><p>Running this makefile results in:</p><a id="pro_id00352"/><pre class="programlisting">$ <span class="strong"><strong>touch subdir/a.foo</strong></span>
$ <span class="strong"><strong>make</strong></span>
wildcard returned 'subdir/a.foo subdir/b.foo'
ls returned 'subdir/a.foo subdir/b.foo'</pre><p>Here, both <code class="literal">$(wildcard)</code> and <code class="literal">ls</code> return the same results, and both show the presence of the two <code class="literal">.foo</code> files: <code class="literal">subdir/a.foo</code>, which existed before <code class="literal">make</code> was run, and <code class="literal">subdir/b.foo</code>, which was created by the makefile.</p><p>Let’s look at one final makefile (<a class="xref" href="ch04.html#small_change_makes_ls_and_dollarleft_par" title="Example 4-6. A small change makes ls and $(wildcard) return different results.">Example 4-6</a>) before I explain what’s happening:</p><div class="example"><a id="small_change_makes_ls_and_dollarleft_par"/><p class="title">Example 4-6. A small change makes <code class="literal">ls</code> and <code class="literal">$(wildcard)</code> return different results.</p><div class="example-contents"><pre class="programlisting">DIRECTORY=subdir/

$(warning Preexisting file: $(WILDCARD_LIST))

.PHONY: all
all: $(DIRECTORY)b.foo
→  @echo $(WILDCARD_LIST)
→  @echo $(LS_LIST)
$(DIRECTORY)b.foo:
→  @touch $@</pre></div></div><p><a id="iddle1097" class="indexterm"/><a id="iddle1213" class="indexterm"/><a id="iddle1281" class="indexterm"/><a id="iddle1918" class="indexterm"/>In this makefile, <code class="literal">$(warning)</code> is used to print out a list of the <code class="literal">.foo</code> files that already exist in the subdirectory.</p><p>Here’s the output:</p><a id="pro_id00353"/><pre class="programlisting">$ <span class="strong"><strong>touch subdir/a.foo</strong></span>
$ <span class="strong"><strong>make</strong></span>
makefile:6: Preexisting file: wildcard returned 'subdir/a.foo'
wildcard returned 'subdir/a.foo'
ls returned 'subdir/a.foo subdir/b.foo'</pre><p>Notice now that GNU <code class="literal">make</code> appears to be behaving like it does in <a class="xref" href="ch04.html#when_you_run_this_makefilecomma_ls_and_d" title="Example 4-4. When you run this makefile, ls and $(wildcard) return different results.">Example 4-4</a>; the <code class="literal">subdir/b.foo</code> file that was made by the makefile is invisible to <code class="literal">$(wildcard)</code> and doesn’t appear, even though it was created and <code class="literal">ls</code> found it.</p></div><div class="sect2" title="Unexpected Results Explained"><div class="titlepage"><div><div><h2 class="title"><a id="unexpected_results_explained"/>Unexpected Results Explained</h2></div></div></div><p>We get unexpected, and apparently inconsistent, results because GNU <code class="literal">make</code> contains its own cache of directory entries. <code class="literal">$(wildcard)</code> reads from that cache (not directly from disk like <code class="literal">ls</code>) to get its results. Knowing when that cache is filled is vital to understanding the results the <code class="literal">$(wildcard)</code> will return.</p><p>GNU <code class="literal">make</code> fills the cache only when it is forced to (for example, when it needs to read the directory entries to satisfy a <code class="literal">$(wildcard)</code> or other globbing request). If you know that GNU <code class="literal">make</code> fills the cache only when needed, then it’s possible to explain the results.</p><p>In <a class="xref" href="ch04.html#when_you_run_this_makefilecomma_ls_and_d" title="Example 4-4. When you run this makefile, ls and $(wildcard) return different results.">Example 4-4</a>, GNU <code class="literal">make</code> fills the cache for the current working directory when it starts. So the file <code class="literal">b.foo</code> doesn’t appear in the output of <code class="literal">$(wildcard)</code> because it wasn’t present when the cache was filled.</p><p>In <a class="xref" href="ch04.html#this_timecomma_ls_and_dollarleft_parenth" title="Example 4-5. This time, ls and $(wildcard) return the same results.">Example 4-5</a>, GNU <code class="literal">make</code> didn’t fill the cache with entries from <code class="literal">subdir</code> until they were needed. The entries were first needed for the <code class="literal">$(wildcard)</code>, which is performed after <code class="literal">subdir/b.foo</code> is created; hence, <code class="literal">subdir/b.foo</code> does appear in the <code class="literal">$(wildcard)</code> output.</p><p>In <a class="xref" href="ch04.html#small_change_makes_ls_and_dollarleft_par" title="Example 4-6. A small change makes ls and $(wildcard) return different results.">Example 4-6</a>, the <code class="literal">$(warning)</code> happens at the start of the makefile and fills the cache (because it did a <code class="literal">$(wildcard)</code>); hence, <code class="literal">subdir/b.foo</code> was missing from the output of <code class="literal">$(wildcard)</code> for the duration of that <code class="literal">make</code>.</p><p>Predicting when the cache will be filled is very difficult. <code class="literal">$(wildcard)</code> will fill the cache, but so will use of a globbing operator like <code class="literal">*</code> in the target or prerequisite list of a rule. <a class="xref" href="ch04.html#when_gnu_make_fillscomma_the_dollarleft" title="Example 4-7. When GNU make fills, the $(wildcard) cache can be difficult to understand.">Example 4-7</a> is a makefile that builds two files (<code class="literal">subdir/b.foo</code> and <code class="literal">subdir/c.foo</code>) and does a couple of <code class="literal">$(wildcard)</code>s:</p><div class="example"><a id="when_gnu_make_fillscomma_the_dollarleft"/><p class="title">Example 4-7. When GNU <code class="literal">make</code> fills, the <code class="literal">$(wildcard)</code> cache can be difficult to understand.</p><div class="example-contents"><pre class="programlisting">DIRECTORY=subdir/

.PHONY: all
all: $(DIRECTORY)b.foo
→  @echo $(WILDCARD_LIST)
→  @echo $(LS_LIST)
$(DIRECTORY)b.foo: $(DIRECTORY)c.foo
→  @touch $@
→  @echo $(WILDCARD_LIST)
→  @echo $(LS_LIST)

$(DIRECTORY)c.foo:
→  @touch $@</pre></div></div><p><a id="iddle1200" class="indexterm"/>The output may surprise you:</p><a id="pro_id00354"/><pre class="programlisting">   $ <span class="strong"><strong>make</strong></span>
   wildcard returned 'subdir/a.foo subdir/c.foo'
   ls returned 'subdir/a.foo subdir/c.foo'
➊ wildcard returned 'subdir/a.foo subdir/c.foo'
   ls returned 'subdir/a.foo subdir/b.foo subdir/c.foo'</pre><p>Even though the first <code class="literal">$(wildcard)</code> is being done in the rule that makes <code class="literal">subdir/b.foo</code> and after the <code class="literal">touch</code> that created <code class="literal">subdir/b.foo</code>, there’s no mention of <code class="literal">subdir/b.foo</code> in the output of <code class="literal">$(wildcard)</code> ➊. Nor is there mention of <code class="literal">subdir/b.foo</code> in the output of the <code class="literal">ls</code>.</p><p>The reason is that the complete block of commands is expanded into its final form before any of the lines in the rule are run. So the <code class="literal">$(wildcard)</code> and <code class="literal">$(shell ls)</code> are done before the <code class="literal">touch</code> has run.</p><p>The output of <code class="literal">$(wildcard)</code> is even more unpredictable if the <code class="literal">make</code> is run in parallel with the <code class="literal">-j</code> switch. In that case, the exact order in which the rules are run is not predictable, so the output of <code class="literal">$(wildcard)</code> can be even less predictable.</p><p>Here’s what I recommend: don’t use <code class="literal">$(wildcard)</code> in a rule; use <code class="literal">$(wildcard)</code> in the makefile only at parsing time (before any rules start running). If you restrict the use of <code class="literal">$(wildcard)</code> to parsing time, you can be assured of consistent results: <code class="literal">$(wildcard)</code> will show the state of the filesystem before GNU <code class="literal">make</code> was run.</p></div></div><div class="sect1" title="Making Directories"><div class="titlepage"><div><div><h1 class="title"><a id="making_directories"/>Making Directories</h1></div></div></div><p>One common problem faced by real-world makefile hackers is the need to build a hierarchy of directories before the build, or at least before commands that use those directories can run. The most common case is that the makefile hacker wants to ensure that the directories where object files will be created exist, and they want that to happen automatically. This section looks at a variety of ways to achieve directory creation in GNU <code class="literal">make</code> and points out a common trap for the unwary.</p><div class="sect2" title="An Example Makefile"><div class="titlepage"><div><div><h2 class="title"><a id="example_makefile-id00008"/>An Example Makefile</h2></div></div></div><p><a id="iddle1153" class="indexterm"/><a id="iddle1542" class="indexterm"/>The following makefile builds an object file <code class="literal">/out/foo.o</code> from <code class="literal">foo.c</code> using the GNU <code class="literal">make</code> built-in variable <code class="literal">COMPILE.C</code> to make a <code class="literal">.o</code> file from a <code class="literal">.c</code> by running the compiler.</p><p><code class="literal">foo.c</code> is in the same directory as the makefile, but <code class="literal">foo.o</code> is placed in <code class="literal">/out/</code>:</p><a id="pro_id00355"/><pre class="programlisting">.PHONY: all
all: /out/foo.o

/out/foo.o: foo.c
→  @$(COMPILE.C) -o $@ $&lt;</pre><p>This example works fine as long as <code class="literal">/out/</code> exists. But if it does not, you’ll get an error from the compiler along the lines of:</p><a id="pro_id00356"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
Assembler messages:
FATAL: can't create /out/foo.o: No such file or directory
make: *** [/out/foo.o] Error 1</pre><p>Obviously, what you want is for the makefile to automatically create <code class="literal">/out/</code> if it is missing.</p></div><div class="sect2" title="What Not to Do"><div class="titlepage"><div><div><h2 class="title"><a id="what_not_to_do-id00009"/>What Not to Do</h2></div></div></div><p>Because GNU <code class="literal">make</code> excels at making things that don’t exist, it seems obvious to make <code class="literal">/out/</code> a prerequisite of <code class="literal">/out/foo.o</code> and have a rule to make the directory. That way if we need to build <code class="literal">/out/foo.o</code>, the directory will get created.</p><p><a class="xref" href="ch04.html#this_makefile_can_end_up_doing_unnecessa" title="Example 4-8. This makefile can end up doing unnecessary work.">Example 4-8</a> shows the reworked makefile with the directory as a prerequisite and a rule to build the directory using <code class="literal">mkdir</code>.</p><div class="example"><a id="this_makefile_can_end_up_doing_unnecessa"/><p class="title">Example 4-8. This makefile can end up doing unnecessary work.</p><div class="example-contents"><pre class="programlisting">OUT = /out

.PHONY: all
all: $(OUT)/foo.o

$(OUT)/foo.o: foo.c $(OUT)/
→  @$(COMPILE.C) -o $@ $&lt;

$(OUT)/:
→  mkdir -p $@</pre></div></div><p><a id="iddle1210" class="indexterm"/><a id="iddle1211" class="indexterm"/><a id="iddle1575" class="indexterm"/><a id="iddle1730" class="indexterm"/><a id="iddle1825" class="indexterm"/>For simplification, the name of the output directory is stored in a variable called <code class="literal">OUT</code>, and the <code class="literal">-p</code> option on the <code class="literal">mkdir</code> command is used so that it will build all the necessary parent directories. In this case the path is simple: it’s just <code class="literal">/out/</code>, but <code class="literal">-p</code> means that <code class="literal">mkdir</code> could make a long chain of directories in one go.</p><p>This works well for this basic example, but there’s a major problem. Because the timestamp on a directory is typically updated when the directory is updated (for example, when a file is created, deleted, or renamed), this makefile can end up doing too much work.</p><p>For example, just creating another file inside <code class="literal">/out/</code> forces a rebuild of <code class="literal">/out/foo.o</code>. In a complex example, this could mean that many object files are rebuilt for no good reason, just because other files were rebuilt in the same directory.</p></div><div class="sect2" title="Solution 1: Build the Directory When the Makefile Is Parsed"><div class="titlepage"><div><div><h2 class="title"><a id="solution_1_build_the_directory_when_the"/>Solution 1: Build the Directory When the Makefile Is Parsed</h2></div></div></div><p>A simple solution to the problem in <a class="xref" href="ch04.html#this_makefile_can_end_up_doing_unnecessa" title="Example 4-8. This makefile can end up doing unnecessary work.">Example 4-8</a> is to just create the directory when the makefile is parsed. A quick call to <code class="literal">$(shell)</code> can achieve that:</p><a id="pro_id00357"/><pre class="programlisting">OUT = /out

.PHONY: all
all: $(OUT)/foo.o

$(OUT)/foo.o: foo.c
→  @$(COMPILE.C) -o $@ $&lt;

$(shell mkdir -p $(OUT))</pre><p>Before any targets are created or commands run, the makefile is read and parsed. If you put <code class="literal">$(shell mkdir -p $(OUT))</code> somewhere in the makefile, GNU <code class="literal">make</code> will run the <code class="literal">mkdir</code> every time the makefile is loaded.</p><p>One possible disadvantage is that if many directories need to be created, this process could be slow. And GNU <code class="literal">make</code> is doing unnecessary work, because it will attempt to build the directories every time you type <code class="literal">make</code>. Some users also don’t like this method because it creates all the directories, even if they’re not actually used by the rules in the makefile.</p><p>A small improvement can be made by first testing to see whether the directory exists:</p><a id="pro_id00358"/><pre class="programlisting">ifeq ($(wildcard $(OUT)/.),)
$(shell mkdir -p $(OUT))
endif</pre><p>Here, <code class="literal">$(wildcard)</code> is used with a <code class="literal">/.</code> appended to check for the presence of a directory. If the directory is missing, <code class="literal">$(wildcard)</code> will return an empty string and the <code class="literal">$(shell)</code> will be executed.</p></div><div class="sect2" title="Solution 2: Build the Directory When all Is Built"><div class="titlepage"><div><div><h2 class="title"><a id="solution_2_build_the_directory_when_all"/>Solution 2: Build the Directory When all Is Built</h2></div></div></div><p><a id="iddle1214" class="indexterm"/>A related solution is to build the directory only when <code class="literal">all</code> is being built. This means that the directories won’t get created every time the makefile is parsed (which could avoid unnecessary work when you type <code class="literal">make clean</code> or <code class="literal">make depend</code>):</p><a id="pro_id00359"/><pre class="programlisting">OUT = /out

.PHONY: all
all: make_directories $(OUT)/foo.o

$(OUT)/foo.o: foo.c
→  @$(COMPILE.C) -o $@ $&lt;

.PHONY: make_directories
make_directories: $(OUT)/

$(OUT)/:
→  mkdir -p $@</pre><p>This solution is messy because you must specify <code class="literal">make_directories</code> as a prerequisite of any target that the user might specify after <code class="literal">make</code>. If you don’t, you could run into the situation in which the directories have not been built. You should avoid this technique, especially because it will completely break parallel builds.</p></div><div class="sect2" title="Solution 3: Use a Directory Marker File"><div class="titlepage"><div><div><h2 class="title"><a id="solution_3_use_a_directory_marker_file"/>Solution 3: Use a Directory Marker File</h2></div></div></div><p>If you look back at <a class="xref" href="ch04.html#this_makefile_can_end_up_doing_unnecessa" title="Example 4-8. This makefile can end up doing unnecessary work.">Example 4-8</a>, you’ll notice one rather nice feature: it builds only the directory needed for a specific target. In a more complex example (where there were many such directories to be built) it would be nice to be able to use something like that solution while avoiding the problem of constant rebuilds as the timestamp on the directory changes.</p><p>To do that, you can store a special empty file, which I call a <span class="emphasis"><em>marker</em></span> file, in the directory and use that as the prerequisite. Because it’s a normal file, normal GNU <code class="literal">make</code> rebuilding rules apply and its timestamp is not affected by changes in its directory.</p><p>If you add a rule to build the marker file (and to ensure that its directory exists), you can specify a directory as a prerequisite by specifying the marker file as a proxy for the directory.</p><a id="pro_id00360"/><pre class="programlisting">OUT = /out
.PHONY: all
all: $(OUT)/foo.o

$(OUT)/foo.o: foo.c $(OUT)/.f
→  @$(COMPILE.C) -o $@ $&lt;
$(OUT)/.f:
→  mkdir -p $(dir $@)
→  touch $@</pre><p><a id="iddle1207" class="indexterm"/><a id="iddle1585" class="indexterm"/>Notice how the rule to build <code class="literal">$(OUT)/.f</code> creates the directory, if necessary, and touches the <code class="literal">.f</code> file. Because the target is a file (<code class="literal">.f</code>), it can safely be used as a prerequisite in the <code class="literal">$(OUT)/foo.o</code> rule.</p><p>The <code class="literal">$(OUT)/.f</code> rule uses the GNU <code class="literal">make</code> function <code class="literal">$(dir FILE)</code> to extract the directory portion of the target (which is the path to the <code class="literal">.f</code> file) and passes that directory to <code class="literal">mkdir</code>.</p><p>The only disadvantage here is that it’s necessary to specify the <code class="literal">.f</code> files for every rule that builds a target in a directory that might need to be created.</p><p>To make this easy to use, you can create functions that automatically make the rule to create a directory and that calculate the correct name for <code class="literal">.f</code> files:</p><a id="pro_id00361"/><pre class="programlisting">marker = $1.f
make_dir = $(eval $1.f: ; @mkdir -p $$(dir $$@) ; touch $$@)

OUT = /out
.PHONY: all
all: $(OUT)/foo.o

$(OUT)/foo.o: foo.c $(call marker,$(OUT))
→  @$(COMPILE.C) -o $@ $&lt;

$(call make-dir,$(OUT))</pre><p>Here, <code class="literal">marker</code> and <code class="literal">make-dir</code> are used to simplify the makefile.</p></div><div class="sect2" title="Solution 4: Use an Order-Only Prerequisite to Build the Directory"><div class="titlepage"><div><div><h2 class="title"><a id="solution_4_use_an_order-only_prerequisit"/>Solution 4: Use an Order-Only Prerequisite to Build the Directory</h2></div></div></div><p>In GNU <code class="literal">make</code> 3.80 and later, another solution is to use an <span class="emphasis"><em>order-only</em></span> prerequisite. An order-only prerequisite is built before the target as normal but does not cause the target to be rebuilt when the prerequisite is changed. Usually, when a prerequisite is rebuilt, the target will also be rebuilt because GNU <code class="literal">make</code> assumes that the target depends on the prerequisite. Order-only prerequisites are different: they get built before the target, but the target isn’t updated just because an order-only prerequisite was built.</p><p>This is exactly what we would’ve liked in the original broken example in <a class="xref" href="ch04.html#this_makefile_can_end_up_doing_unnecessa" title="Example 4-8. This makefile can end up doing unnecessary work.">Example 4-8</a>—to make sure that the directory gets rebuilt as needed but doesn’t rebuild the <code class="literal">.o</code> file every time the directory’s timestamp changes.</p><p>Order-only prerequisites are any prerequisites that come after the bar symbol <code class="literal">|</code> and must be placed after any normal prerequisites.</p><p>In fact, just adding this single character to the broken example in <a class="xref" href="ch04.html#this_makefile_can_end_up_doing_unnecessa" title="Example 4-8. This makefile can end up doing unnecessary work.">Example 4-8</a> can make it work correctly:</p><a id="pro_id00362"/><pre class="programlisting">   OUT = /out

   .PHONY: all
   all: $(OUT)/foo.o
   $(OUT)/foo.o: foo.c | $(OUT)/
   →  @$(COMPILE.C) -o $@ $&lt;

➊ $(OUT)/:
   →  mkdir -p $@</pre><p><a id="iddle1072" class="indexterm"/><a id="iddle1613" class="indexterm"/><a id="iddle1633" class="indexterm"/><a id="iddle1697" class="indexterm"/><a id="iddle1700" class="indexterm"/><a id="iddle1820" class="indexterm"/>The rule for <code class="literal">$(OUT)/</code> ➊ will be run if the directory is missing, but changes to the directory will not cause <code class="literal">$(OUT)/foo.o</code> to be rebuilt.</p></div><div class="sect2" title="Solution 5: Use Pattern Rules, Second Expansion, and a Marker File"><div class="titlepage"><div><div><h2 class="title"><a id="solution_5_use_pattern_rulescomma_second"/>Solution 5: Use Pattern Rules, Second Expansion, and a Marker File</h2></div></div></div><p>In a typical makefile (not simple examples in books like this), targets are usually built using pattern rules, like so:</p><a id="pro_id00363"/><pre class="programlisting">OUT = /out
.PHONY: all
all: $(OUT)/foo.o

$(OUT)/%.o: %.c
→  @$(COMPILE.C) -o $@ $&lt;</pre><p>But we can change this pattern rule to build directories automatically using marker files.</p><p>In GNU <code class="literal">make</code> 3.81 and later, there is an exciting feature called <span class="emphasis"><em>second expansion</em></span> (which is enabled by specifying the <code class="literal">.SECONDEXPANSION</code> target in the makefile). With second expansion, the prerequisite list of any rule undergoes a second expansion (the first expansion happens when the makefile is read) just before the rule is used. By escaping any <code class="literal">$</code> signs with a second <code class="literal">$</code>, it’s possible to use GNU <code class="literal">make</code> automatic variables (such as <code class="literal">$@</code>) in the prerequisite list.</p><p>Using a marker file for each directory and second expansion, you can create a makefile that automatically creates directories only when necessary with a simple addition to the prerequisite list of any rule:</p><a id="pro_id00364"/><pre class="programlisting">OUT = /tmp/out

.SECONDEXPANSION:

all: $(OUT)/foo.o

$(OUT)/%.o: %.c $$(@D)/.f
→  @$(COMPILE.C) -o $@ $&lt;

%/.f:
→  mkdir -p $(dir $@)
→  touch $@

.PRECIOUS: %/.f</pre><p><a id="iddle1277" class="indexterm"/><a id="iddle1431" class="indexterm"/><a id="iddle1574" class="indexterm"/><a id="iddle1631" class="indexterm"/><a id="iddle1766" class="indexterm"/><a id="iddle1768" class="indexterm"/>The pattern rule used to make <code class="literal">.o</code> files has a special prerequisite <code class="literal">$$(@D)/.f</code>, which uses the second expansion feature to obtain the directory in which the target is to be built. It does this by applying the <code class="literal">D</code> modifier to <code class="literal">$@</code>, which gets the directory of the target (while <code class="literal">$@</code> on its own obtains the name of the target).</p><p>That directory will be built by the <code class="literal">%/.f</code> pattern rule in the process of building a <code class="literal">.f</code> file. Notice that the <code class="literal">.f</code> files are marked as <span class="emphasis"><em>precious</em></span> so that GNU <code class="literal">make</code> will not delete them. Without this line, the <code class="literal">.f</code> files are considered to be useless intermediate files and would be cleaned up by GNU <code class="literal">make</code> on exit.</p></div><div class="sect2" title="Solution 6: Make the Directory in Line"><div class="titlepage"><div><div><h2 class="title"><a id="solution_6_make_the_directory_in_line"/>Solution 6: Make the Directory in Line</h2></div></div></div><p>It’s also possible to make directories inside the rules that need them; this is called making directories <span class="emphasis"><em>in line</em></span>. For example:</p><a id="pro_id00365"/><pre class="programlisting">OUT = /out

.PHONY: all
all: $(OUT)/foo.o

$(OUT)/foo.o: foo.c
→  mkdir -p $(@D)
→  @$(COMPILE.C) -o $@ $&lt;</pre><p>Here I’ve modified the <code class="literal">$(OUT)/foo.o</code> rule so that it makes the directory using <code class="literal">-p</code> each time. This only works if a small number of rules need to create directories. Updating every rule to add the <code class="literal">mkdir</code> is laborious and likely to result in some rules being missed.</p></div></div><div class="sect1" title="GNU make Meets Filenames with Spaces"><div class="titlepage"><div><div><h1 class="title"><a id="gnu_make_meets_filenames_with_spaces"/>GNU make Meets Filenames with Spaces</h1></div></div></div><p>GNU <code class="literal">make</code> treats the space character as a list separator; any string containing spaces can be thought of as a list of space-delimited words. This is fundamental to GNU <code class="literal">make</code>, and space-separated lists abound. Unfortunately, that presents a problem when filenames contain spaces. This section looks at how to work around the “spaces in filenames problem.”</p><div class="sect2" title="An Example Makefile"><div class="titlepage"><div><div><h2 class="title"><a id="example_makefile-id00010"/>An Example Makefile</h2></div></div></div><p>Suppose you are faced with creating a makefile that needs to deal with two files named <code class="literal">foo bar</code> and <code class="literal">bar baz</code>, with <code class="literal">foo bar</code> built from <code class="literal">bar baz</code>. Filenames that include spaces can be tricky to work with.</p><p>A naive way to write this in a makefile would be:</p><a id="pro_id00366"/><pre class="programlisting">foo bar: bar baz
→ @echo Making $@ from $&lt;</pre><p><a id="iddle1005" class="indexterm"/><a id="iddle1079" class="indexterm"/><a id="iddle1765" class="indexterm"/><a id="iddle1917" class="indexterm"/>But that doesn’t work. GNU <code class="literal">make</code> can’t differentiate between cases where spaces are part of the filename and cases where they’re not. In fact, the naively written makefile is exactly the same as:</p><a id="pro_id00367"/><pre class="programlisting">foo: bar baz
→ @echo Making $@ from $&lt;
bar: bar baz
→ @echo Making $@ from $&lt;</pre><p>Placing quotations marks around the filenames doesn’t work either. If you try this:</p><a id="pro_id00368"/><pre class="programlisting">"foo bar": "bar baz"
→ @echo Making $@ from $&lt;</pre><p>GNU <code class="literal">make</code> thinks you’re talking about four files called <code class="literal">"foo</code>, <code class="literal">bar"</code>, <code class="literal">"bar</code>, and <code class="literal">baz"</code>. GNU <code class="literal">make</code> ignores the double quotes and splits the list by spaces as it normally would.</p></div><div class="sect2" title="Escape Spaces with \"><div class="titlepage"><div><div><h2 class="title"><a id="escape_spaces_with_slash"/>Escape Spaces with \</h2></div></div></div><p>One way to deal with the spaces problem is to use GNU <code class="literal">make</code>’s escaping operator, <code class="literal">\</code>, which you can use to escape sensitive characters (such as a literal <code class="literal">#</code> so that it doesn’t start a comment or a literal <code class="literal">%</code> so that it isn’t used as a wildcard).</p><p>Thus, use <code class="literal">\</code> to escape spaces in rules for filenames with spaces. Our example makefile can then be rewritten as follows:</p><a id="pro_id00369"/><pre class="programlisting">foo\ bar: bar\ baz
→ @echo Making $@ from $&lt;</pre><p>and it will work correctly. The <code class="literal">\</code> is removed during the parsing of the makefile, so the actual target and prerequisite names correctly contain spaces. This will be reflected in the automatic variables (such as <code class="literal">$@</code>).</p><p>When <code class="literal">foo bar</code> needs updating, the simple makefile will output:</p><a id="pro_id00370"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
Making foo bar from bar baz</pre><p>You can also use the same escaping mechanism inside GNU <code class="literal">make</code>’s <code class="literal">$(wildcard)</code> function. To check for the existence of <code class="literal">foo bar</code>, you can use <code class="literal">$(wildcard foo\ bar)</code> and GNU <code class="literal">make</code> will treat <code class="literal">foo bar</code> as a single filename to look for in the filesystem.</p><p>Unfortunately, GNU <code class="literal">make</code>’s other functions that deal with space-separated lists do not respect the escaping of spaces. The output of <code class="literal">$(sort foo\ bar)</code> for example, is the list <code class="literal">bar foo\</code>, not <code class="literal">foo\ bar</code> as you might expect. In fact, <code class="literal">$(wildcard)</code> is the only GNU <code class="literal">make</code> function that respects the <code class="literal">\</code> character to escape a space.</p><p><a id="iddle1073" class="indexterm"/>This leads to a problem if you have to deal with the automatic variables that contain lists of targets. Consider this slightly more complicated example:</p><a id="pro_id00371"/><pre class="programlisting">foo\ bar: bar\ baz a\ b
→ @echo Making $@ from $&lt;</pre><p>Now <code class="literal">foo bar</code> has two prerequisites <code class="literal">bar baz</code> and <code class="literal">a b</code>. What’s the value of <code class="literal">$^</code> (the list of all prerequisites) in this case? It’s <code class="literal">bar baz a b</code>: the escaping is gone, and even if it weren’t gone, the fact that only <code class="literal">$(wildcard)</code> respects the <code class="literal">\</code> means that it would be useless. <code class="literal">$^</code> is, from GNU <code class="literal">make</code>’s perspective, a list with four elements.</p><p>Looking at the definitions of the automatic variables tells us which are safe to use in the presence of spaces in filenames. <a class="xref" href="ch04.html#safety_of_automatic_variables" title="Table 4-1. Safety of Automatic Variables">Table 4-1</a> shows each automatic variable and whether it is safe.</p><div class="table"><a id="safety_of_automatic_variables"/><p class="title">Table 4-1. Safety of Automatic Variables</p><div class="table-contents"><table summary="Safety of Automatic Variables" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Automatic variable</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>Is it safe?</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">$@</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Yes</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">$&lt;</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Yes</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">$%</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Yes</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">$*</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Yes</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">$?</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>No</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">$^</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>No</p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">$+</code></p></td><td style="" valign="top"><p>No</p></td></tr></tbody></table></div></div><p>Those that are inherently lists (<code class="literal">$?</code>, <code class="literal">$^</code>, and <code class="literal">$+</code>) are not safe because GNU <code class="literal">make</code> lists are separated by spaces; the others are safe.</p><p>And it gets a little worse. Even though the first four automatic variables in the table are safe to use, their modified versions with <code class="literal">D</code> and <code class="literal">F</code> suffixes (which extract the directory and filename portions of the corresponding automatic variable) are not. This is because they are defined in terms of the <code class="literal">dir</code> and <code class="literal">notdir</code> functions.</p><p>Consider this example makefile:</p><a id="pro_id00372"/><pre class="programlisting">/tmp/foo\ bar/baz: bar\ baz a\ b
→  @echo Making $@ from $&lt;</pre><p>The value of <code class="literal">$@</code> is <code class="literal">/tmp/foo bar/baz</code> as expected, but the value of <code class="literal">$(@D)</code> is <code class="literal">/tmp bar</code> (as opposed to <code class="literal">/tmp/foo bar</code>) and the value of <code class="literal">$(@F)</code> is <code class="literal">foo baz</code> (instead of just <code class="literal">baz</code>).</p></div><div class="sect2" title="Turn Spaces into Question Marks"><div class="titlepage"><div><div><h2 class="title"><a id="turn_spaces_into_question_marks"/>Turn Spaces into Question Marks</h2></div></div></div><p><a id="iddle1032" class="indexterm"/><a id="iddle1040" class="indexterm"/><a id="iddle1531" class="indexterm"/><a id="iddle1655" class="indexterm"/><a id="iddle1656" class="indexterm"/><a id="iddle1763" class="indexterm"/><a id="iddle1777" class="indexterm"/><a id="iddle1921" class="indexterm"/>Another way to deal with the spaces problem is to turn spaces into question marks. Here’s the original makefile transformed:</p><a id="pro_id00373"/><pre class="programlisting">foo?bar: bar?baz
→  @echo Making $@ from $&lt;</pre><p>Because GNU <code class="literal">make</code> does globbing of target and prerequisite names (and respects any spaces found), this will work. But the results are inconsistent.</p><p>If <code class="literal">foo bar</code> exists when this makefile runs, the pattern <code class="literal">foo?bar</code> will get turned into <code class="literal">foo bar</code> and that value will be used for <code class="literal">$@</code>. If that file were missing when the makefile is parsed, the pattern (and hence <code class="literal">$@</code>) remains as <code class="literal">foo?bar</code>.</p><p>Another problem also exists: <code class="literal">?</code> could match something other than a space. If there’s a file called <code class="literal">foombar</code> on the system, for example, the makefile may end up working on the wrong file.</p><p>To get around this problem, Robert Mecklenburg defines two functions to add and remove spaces automatically in <span class="emphasis"><em>Managing Projects with GNU Make, 3rd edition</em></span> (O’Reilly, 2004). The <code class="literal">sq</code> function turns every space into a question mark (<code class="literal">sq</code> means space to question mark); the <code class="literal">qs</code> function does the opposite (it turns every question mark into a space). Here’s the updated makefile using two functions (<code class="literal">sq</code> and <code class="literal">qs</code>) to add and remove question marks. This works unless any filename contains a question mark but requires wrapping all uses of the filenames in calls to <code class="literal">sq</code> and <code class="literal">qs</code>.</p><a id="pro_id00374"/><pre class="programlisting">sp :=
sp +=
qs = $(subst ?,$(sp),$1)
sq = $(subst $(sp),?,$1)

$(call sq,foo bar): $(call sq,bar baz)
→ @echo Making $(call qs,$@) from $(call qs,$&lt;)</pre><p>Either way, because we still can’t be sure whether automatic variables will have question marks in them, using the list-based automatic variables or any GNU <code class="literal">make</code> list functions is still impossible.</p></div><div class="sect2" title="My Advice"><div class="titlepage"><div><div><h2 class="title"><a id="my_advice"/>My Advice</h2></div></div></div><p>Given that GNU <code class="literal">make</code> has difficulty with spaces in filenames, what can you do? Here’s my advice:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Rename your files to avoid spaces if possible.</strong></span></span></dt><dd><p>However, this is impossible for many people because the spaces in filenames may have been added by a third party.</p></dd><dt><span class="term"><span class="strong"><strong>Use 8.3 filenames.</strong></span></span></dt><dd><p>If you are working with Windows, it may be possible to use short, 8.3 filenames, which allows you to still have spaces on disk but avoid them in the makefile.</p></dd><dt><span class="term"><span class="strong"><strong>Use <code class="literal">\</code> for escaping.</strong></span></span></dt><dd><p><a id="iddle1029" class="indexterm"/><a id="iddle1031" class="indexterm"/><a id="iddle1603" class="indexterm"/><a id="iddle1624" class="indexterm"/><a id="iddle1726" class="indexterm"/>If you need the spaces, escape them with <code class="literal">\</code>, which does give consistent results. Just be sure to avoid the automatic variables listed as not safe in <a class="xref" href="ch04.html#safety_of_automatic_variables" title="Table 4-1. Safety of Automatic Variables">Table 4-1</a>.</p></dd></dl></div><p>If you use <code class="literal">\</code> for escaping and you need to manipulate lists of filenames that contain spaces, the best thing to do is substitute spaces with some other character and then change them back again.</p><p>For example, the <code class="literal">s+</code> and <code class="literal">+s</code> functions in the following code change escaped spaces to <code class="literal">+</code> signs and back again. Then you can safely manipulate lists of filenames using all the GNU <code class="literal">make</code> functions. Just be sure to remove the <code class="literal">+</code> signs before using these names in a rule.</p><a id="pro_id00375"/><pre class="programlisting">space :=
space +=

s+ = $(subst \$(space),+,$1)
+s = $(subst +,\$(space),$1)</pre><p>Here’s an example using them to transform a list of source files with escaped spaces into a list of object files, which are then used to define the prerequisites of an <code class="literal">all</code> rule:</p><a id="pro_id00376"/><pre class="programlisting">SRCS := a\ b.c c\ d.c e\ f.c
SRCS := $(call s+,$(SRCS))

OBJS := $(SRCS:.c=.o)

all: $(call +s,$(OBJS))</pre><p>The source files are stored in <code class="literal">SRCS</code> with spaces in filenames escaped. So <code class="literal">SRCS</code> contains three files named <code class="literal">a b.c</code>, <code class="literal">c d.c</code>, and <code class="literal">e f.c</code>. GNU <code class="literal">make</code>’s <code class="literal">\</code> escaping is used to preserve the escaped spaces in each name. Transforming <code class="literal">SRCS</code> into a list of objects in <code class="literal">OBJS</code> is done in the usual manner using <code class="literal">.c=.o</code> to replace each <code class="literal">.c</code> extension with <code class="literal">.o</code>, but first <code class="literal">SRCS</code> is altered using the <code class="literal">s+</code> function so the escaped spaces become <code class="literal">+</code> signs. As a result, GNU <code class="literal">make</code> will see <code class="literal">SRCS</code> as a list of three elements, <code class="literal">a+b.c</code>, <code class="literal">c+d.c</code>, and <code class="literal">e+f.c</code>, and changing the extension will work correctly. When <code class="literal">OBJS</code> is used later in the makefile, the <code class="literal">+</code> signs are turned back into escaped spaces using a call to the function <code class="literal">+s</code>.</p></div></div><div class="sect1" title="Path Handling"><div class="titlepage"><div><div><h1 class="title"><a id="path_handling"/>Path Handling</h1></div></div></div><p>Makefile creators often have to manipulate filesystem paths, but GNU <code class="literal">make</code> provides few functions for path manipulation. And cross-platform <code class="literal">make</code> is difficult due to differences in path syntax. This section explains ways to manipulate paths in GNU <code class="literal">make</code> and navigate through the cross-platform minefield.</p><div class="sect2" title="Target Name Matching"><div class="titlepage"><div><div><h2 class="title"><a id="target_name_matching"/>Target Name Matching</h2></div></div></div><p><a id="iddle1608" class="indexterm"/><a id="iddle1818" class="indexterm"/>Look at the following example makefile and suppose that <code class="literal">../foo</code> is missing. Does the makefile manage to create it?</p><a id="pro_id00377"/><pre class="programlisting">.PHONY: all
all: ../foo

.././foo:
→ touch $@</pre><p>If you run that makefile with GNU <code class="literal">make</code>, you might be surprised to see the following error:</p><a id="pro_id00378"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
make: *** No rule to make target `../foo', needed by `all'. Stop.</pre><p>If you change the makefile to this:</p><a id="pro_id00379"/><pre class="programlisting">.PHONY: all
all: ../foo

./../foo:
→ touch $@</pre><p>you’ll find that it works as expected and performs a <code class="literal">touch ../foo</code>.</p><p>The first makefile fails because GNU <code class="literal">make</code> doesn’t do path manipulation on target names, so it sees two different targets called <code class="literal">../foo</code> and <code class="literal">.././foo</code>, and fails to make the connection between the two. The second makefile works because I lied in the preceding sentence. GNU <code class="literal">make</code> does do a tiny bit of path manipulation: it will strip leading <code class="literal">./</code> from target names. So in the second makefile both targets are <code class="literal">../foo</code>, and it works as expected.</p><p>The general rule with GNU <code class="literal">make</code> targets is that they are treated as literal strings without interpreting them in any way. Therefore, it’s essential that when you’re referring to a target in a makefile, you always ensure that the same string is used.</p></div><div class="sect2" title="Working with Path Lists"><div class="titlepage"><div><div><h2 class="title"><a id="working_with_path_lists"/>Working with Path Lists</h2></div></div></div><p>It bears repeating that GNU <code class="literal">make</code> lists are just strings in which any whitespace is considered a list separator. Consequently, paths with spaces in them are not recommended because it makes using many of GNU <code class="literal">make</code>’s built-in functions impossible, and spaces in paths cause problems with targets.</p><p>For example, suppose a target is <code class="literal">/tmp/sub directory/target</code>, and we write a rule for it like this:</p><a id="pro_id00380"/><pre class="programlisting">/tmp/sub directory/target:
→ @do stuff</pre><p><a id="iddle1628" class="indexterm"/><a id="iddle1762" class="indexterm"/><a id="iddle1896" class="indexterm"/><a id="iddle1920" class="indexterm"/>GNU <code class="literal">make</code> will actually interpret that as two rules, one for <code class="literal">/tmp/sub</code> and one for <code class="literal">directory/target</code>, just as if you’d written this:</p><a id="pro_id00381"/><pre class="programlisting">/tmp/sub:
→ @do stuff
directory/target:
→ @do stuff</pre><p>You can work around that problem by escaping the space with <code class="literal">\</code>, but that escape is poorly respected by GNU <code class="literal">make</code> (it works only in target names and the <code class="literal">$(wildcard</code>) function).</p><p>Unless you must use them, avoid spaces in target names.</p></div><div class="sect2" title="Lists of Paths in VPATH and vpath"><div class="titlepage"><div><div><h2 class="title"><a id="lists_of_paths_in_vpath_and_vpath"/>Lists of Paths in VPATH and vpath</h2></div></div></div><p>Another place that lists of paths appear in GNU <code class="literal">make</code> is when specifying the <code class="literal">VPATH</code> or in a <code class="literal">vpath</code> directive used to specify where GNU <code class="literal">make</code> finds prerequisites. For example, it’s possible to set the <code class="literal">VPATH</code> to search for source files in a list of <code class="literal">:</code> or whitespace separated paths:</p><a id="pro_id00382"/><pre class="programlisting">VPATH = ../src:../thirdparty/src /src

vpath %c ../src:../thirdparty/src /src</pre><p>GNU <code class="literal">make</code> will split that path correctly at either colons or whitespace. On Windows systems, the native builds of GNU <code class="literal">make</code> use <code class="literal">;</code> as the path separator for <code class="literal">VPATH</code> (and <code class="literal">vpath</code>) because <code class="literal">:</code> is needed for drive letters. On Windows, GNU <code class="literal">make</code> actually tries to be smart and splits paths on colons unless it looks like a drive letter (one letter followed by a colon). This drive letter intelligence actually creates a problem if you have a directory in the path whose name is a single letter: in that case you must use <code class="literal">;</code> as the path separator. Otherwise, GNU <code class="literal">make</code> will think it’s a drive:</p><a id="pro_id00383"/><pre class="programlisting">VPATH = ../src;../thirdparty/src /src

vpath %c ../src;../thirdparty/src /src</pre><p>On both POSIX and Windows systems, a space in a path is a separator in a <code class="literal">VPATH</code> and <code class="literal">vpath</code>. So using spaces is the best bet for cross-platform makefiles.</p></div><div class="sect2" title="Using / or \"><div class="titlepage"><div><div><h2 class="title"><a id="using_solidus_or_slash"/>Using / or \</h2></div></div></div><p>On POSIX systems <code class="literal">/</code> is the path separator, and on Windows systems it’s <code class="literal">\</code>. It’s common to see paths being built up in makefiles like this:</p><a id="pro_id00384"/><pre class="programlisting">SRCDIR := src
MODULE_DIR := module_1

MODULE_SRCS := $(SRCDIR)/$(MODULE_DIR)</pre><p><a id="iddle1003" class="indexterm"/><a id="iddle1039" class="indexterm"/><a id="iddle1077" class="indexterm"/><a id="iddle1629" class="indexterm"/><a id="iddle1754" class="indexterm"/><a id="iddle1792" class="indexterm"/><a id="iddle1922" class="indexterm"/>It would be ideal to remove the POSIX-only <code class="literal">/</code> there and replace it with something that would work with a different separator. One way to do that is to define a variable called <code class="literal">/</code> (GNU <code class="literal">make</code> lets you get away with using almost anything as a variable name) and use it in place of <code class="literal">/</code>:</p><a id="pro_id00385"/><pre class="programlisting">/ := /

SRCDIR := src
MODULE_DIR := module_1

MODULE_SRCS := $(SRCDIR)$/$(MODULE_DIR)</pre><p>If that makes you uncomfortable, just call it <code class="literal">SEP</code>:</p><a id="pro_id00386"/><pre class="programlisting">SEP := /

SRCDIR := src
MODULE_DIR := module_1

MODULE_SRCS := $(SRCDIR)$(SEP)$(MODULE_DIR)</pre><p>Now when you switch to Windows, you can just redefine <code class="literal">/</code> (or <code class="literal">SEP</code>) to <code class="literal">\</code>. It’s difficult to assign a literal <code class="literal">\</code> on its own as a variable value (because GNU <code class="literal">make</code> interprets it as a line continuation and it can’t be escaped), so it’s defined here using <code class="literal">$(strip)</code>.</p><a id="pro_id00387"/><pre class="programlisting">/ := $(strip \)

SRCDIR := src
MODULE_DIR := module_1

MODULE_SRCS := $(SRCDIR)$/$(MODULE_DIR)</pre><p>However, note that the Windows builds of GNU <code class="literal">make</code> will also accept <code class="literal">/</code> as a path separator, so weird paths like <code class="literal">c:/src</code> are legal. Using those paths will simplify the makefile, but be careful when passing them to a native Windows tool that expects \ separated paths. If that’s necessary, use this instead:</p><a id="pro_id00388"/><pre class="programlisting">forward-to-backward = $(subst /,\,$1)</pre><p>This simple function will convert a forward slash path to a backslash path.</p></div><div class="sect2" title="Windows Oddity: Case Insensitive but Case Preserving"><div class="titlepage"><div><div><h2 class="title"><a id="windows_oddity_case_insensitive_but_case"/>Windows Oddity: Case Insensitive but Case Preserving</h2></div></div></div><p>On POSIX systems filenames are case sensitive; on Windows they are not. On Windows the files <code class="literal">File</code>, <code class="literal">file</code>, and <code class="literal">FILE</code> are all the same file. But an oddity with Windows is that the first time a file is accessed, the specific <a id="iddle1080" class="indexterm"/><a id="iddle1105" class="indexterm"/><a id="iddle1160" class="indexterm"/><a id="iddle1162" class="indexterm"/><a id="iddle1203" class="indexterm"/><a id="iddle1205" class="indexterm"/><a id="iddle1215" class="indexterm"/><a id="iddle1512" class="indexterm"/><a id="iddle1565" class="indexterm"/><a id="iddle1567" class="indexterm"/><a id="iddle1604" class="indexterm"/><a id="iddle1607" class="indexterm"/><a id="iddle1653" class="indexterm"/><a id="iddle1776" class="indexterm"/><a id="iddle1805" class="indexterm"/>case used is recorded and preserved. Thus, if we <code class="literal">touch File</code>, it will appear as <code class="literal">File</code> in the filesystem (but can be accessed as <code class="literal">FILE</code>, <code class="literal">file</code>, or any other case combination).</p><p>By default, GNU <code class="literal">make</code> does case-sensitive target comparisons, so the following makefile does not do what you might expect:</p><a id="pro_id00389"/><pre class="programlisting">.PHONY: all
all: File

file:
→ @touch $@</pre><p>As is, this file causes an error, but you can compile GNU <code class="literal">make</code> on Windows to do case-insensitive comparisons instead (with the build <code class="literal">HAVE_CASE_INSENSITIVE_FS</code> option).</p><p>This oddity is more likely to arise when a target specified in a makefile is also found in a wildcard search because the operating system may return a different case than the case used in the makefile. The target names may differ in case, and that may cause an unexpected <code class="literal">No rule to make</code> error.</p></div><div class="sect2" title="Built-in Path Functions and Variables"><div class="titlepage"><div><div><h2 class="title"><a id="built-in_path_functions_and_variables"/>Built-in Path Functions and Variables</h2></div></div></div><p>You can determine the current working directory in GNU <code class="literal">make</code> using the built-in <code class="literal">CURDIR</code>. Note that <code class="literal">CURDIR</code> will follow symlinks. If you are in <code class="literal">/foo</code> but <code class="literal">/foo</code> is actually a symlink to <code class="literal">/somewhere/foo</code>, <code class="literal">CURDIR</code> will report the directory as <code class="literal">/somewhere/foo</code>. If you need the non-symlink-followed directory name, use the value of the environment variable <code class="literal">PWD</code>:</p><a id="pro_id00390"/><pre class="programlisting">CURRENT_DIRECTORY := $(PWD)</pre><p>But be sure to grab its value before any other part of the makefile has changed <code class="literal">PWD</code>: it can be altered, just like any other variable imported from the environment.</p><p>You can also find the directory in which the current makefile is stored using the <code class="literal">MAKEFILE_LIST</code> variable that was introduced in GNU <code class="literal">make</code> 3.80. At the start of a makefile, it’s possible to extract its directory as follows:</p><a id="pro_id00391"/><pre class="programlisting">CURRENT_MAKEFILE := $(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))
MAKEFILE_DIRECTORY := $(dir $(CURRENT_MAKEFILE))</pre><p>GNU <code class="literal">make</code> has functions for splitting paths into components: <code class="literal">dir</code>, <code class="literal">notdir</code>, <code class="literal">basename</code>, and <code class="literal">suffix</code>.</p><p>Consider the filename <code class="literal">/foo/bar/source.c</code> stored in the variable <code class="literal">FILE</code>. You can use the functions <code class="literal">dir</code>, <code class="literal">notdir</code>, <code class="literal">basename</code>, and <code class="literal">suffix</code> to extract the directory, filename, and suffix. So to get the directory, for example, use <code class="literal">$(dir $(FILE))</code>. <a class="xref" href="ch04.html#results_of_dircomma_notdircomma_basename" title="Table 4-2. Results of dir, notdir, basename, and suffix">Table 4-2</a> shows each of these functions and its result.</p><div class="table"><a id="results_of_dircomma_notdircomma_basename"/><p class="title">Table 4-2. Results of <code class="literal">dir</code>, <code class="literal">notdir</code>, <code class="literal">basename</code>, and <code class="literal">suffix</code></p><div class="table-contents"><table summary="Results of dir, notdir, basename, and suffix" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><a id="iddle1042" class="indexterm"/><a id="iddle1163" class="indexterm"/><a id="iddle1204" class="indexterm"/><a id="iddle1347" class="indexterm"/><a id="iddle1496" class="indexterm"/><a id="iddle1661" class="indexterm"/>Function</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>Result</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">dir</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">/foo/bar/</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">notdir</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">source.c</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">basename</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">source</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">suffix</code></p></td><td style="" valign="top"><p><code class="literal">.c</code></p></td></tr></tbody></table></div></div><p>You can see that the directory, the non-directory part, the suffix (or extension), and the non-directory part without the suffix have been extracted. These four functions make filename manipulation easy. If no directory was specified, GNU <code class="literal">make</code> uses the current directory (<code class="literal">./</code>). For example, suppose that <code class="literal">FILE</code> was just <code class="literal">source.c</code>. <a class="xref" href="ch04.html#results_of_dircomma_notdircomma-id00011" title="Table 4-3. Results of dir, notdir, basename, and suffix with No Directory Specified">Table 4-3</a> shows the result for each function.</p><div class="table"><a id="results_of_dircomma_notdircomma-id00011"/><p class="title">Table 4-3. Results of <code class="literal">dir</code>, <code class="literal">notdir</code>, <code class="literal">basename</code>, and <code class="literal">suffix</code> with No Directory Specified</p><div class="table-contents"><table summary="Results of dir, notdir, basename, and suffix with No Directory Specified" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Function</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>Result</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">dir</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">./</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">notdir</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">source.c</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">basename</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">source</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">suffix</code></p></td><td style="" valign="top"><p><code class="literal">.c</code></p></td></tr></tbody></table></div></div><p>Because these functions are commonly used in conjunction with GNU <code class="literal">make</code>’s automatic variables (like <code class="literal">$@</code>), GNU <code class="literal">make</code> provides a modifier syntax. Appending <code class="literal">D</code> or <code class="literal">F</code> to any automatic variable is equivalent to calling <code class="literal">$(dir)</code> or <code class="literal">$(notdir)</code> on it. For example, <code class="literal">$(@D)</code> is equivalent to <code class="literal">$(dir $@)</code> and <code class="literal">$(@F)</code> is the same as <code class="literal">$(notdir $@)</code>.</p></div><div class="sect2" title="Useful Functions in 3.81: abspath and realpath"><div class="titlepage"><div><div><h2 class="title"><a id="useful_functions_in_3dot81_abspath_and_r"/>Useful Functions in 3.81: abspath and realpath</h2></div></div></div><p><code class="literal">realpath</code> is a GNU <code class="literal">make</code> wrapper for the C library <code class="literal">realpath</code> function, which removes <code class="literal">./</code>, resolves <code class="literal">../</code>, removes duplicated <code class="literal">/</code>, and follows symlinks. The argument to <code class="literal">realpath</code> must exist in the filesystem. The path returned by <code class="literal">realpath</code> is absolute. If the path does not exist, the function returns an empty string.</p><p>For example, you could find the full path of the current directory like this: <code class="literal">current := $(realpath ./)</code>.</p><p><code class="literal">abspath</code> is similar but does not follow symlinks, and its argument does not have to refer to an existing file or directory.</p></div></div><div class="sect1" title="Usman’s Law"><div class="titlepage"><div><div><h1 class="title"><a id="usmanapostrophes_law"/>Usman’s Law</h1></div></div></div><p><a id="iddle1116" class="indexterm"/><a id="iddle1276" class="indexterm"/><a id="iddle1498" class="indexterm"/><a id="iddle1823" class="indexterm"/><a id="iddle1857" class="indexterm"/><code class="literal">make clean</code> doesn’t make clean. That’s Usman’s law (named after a smart coworker of mine who spent months working with real-world makefiles). <code class="literal">make clean</code> is intended to return to a state in which everything will be rebuilt from scratch. Often it doesn’t. Read on to find out why.</p><div class="sect2" title="The Human Factor"><div class="titlepage"><div><div><h2 class="title"><a id="human_factor"/>The Human Factor</h2></div></div></div><p>The <code class="literal">clean</code> rule from the OpenSSL makefile looks like this:</p><a id="pro_id00392"/><pre class="programlisting">clean:
→  rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff $(EXE)</pre><p>Notice how it’s a long list of clearly human-maintained directories, patterns, and filenames that need to be deleted to get back to a clean state. Human maintenance means human error. Suppose someone adds a rule that creates a temporary file with a fixed name. That temporary file should be added to the <code class="literal">clean</code> rule, but it most likely won’t be.</p><p>Usman’s law strikes.</p></div><div class="sect2" title="Poor Naming"><div class="titlepage"><div><div><h2 class="title"><a id="poor_naming"/>Poor Naming</h2></div></div></div><p>Here’s a snippet found in many automatically generated makefiles:</p><a id="pro_id00393"/><pre class="programlisting">mostlyclean::
→ rm -f *.o

clean:: mostlyclean
→ -$(LIBTOOL) --mode=clean rm -f $(program) $(programs)
→ rm -f $(library).a squeeze *.bad *.dvi *.lj

extraclean::
→ rm -f *.aux *.bak *.bbl *.blg *.dvi *.log *.pl *.tfm *.vf *.vpl
→ rm -f *.*pk *.*gf *.mpx *.i *.s *~ *.orig *.rej *\#*
→ rm -f CONTENTS.tex a.out core mfput.* texput.* mpout.*</pre><p>In this example, three sorts of <code class="literal">clean</code> appear to have different degrees of cleanliness: <code class="literal">mostlyclean</code>, <code class="literal">clean</code>, and <code class="literal">extraclean</code>.</p><p><code class="literal">mostlyclean</code> just deletes the object files compiled from source. <code class="literal">clean</code> does that plus deletes the generated library and a few other files. You’d think that <code class="literal">extraclean</code> would delete more than the other two, but it actually deletes a different set of files. And I’ve seen makefiles with <code class="literal">reallyclean</code>, <code class="literal">veryclean</code>, <code class="literal">deepclean</code>, and even <code class="literal">partiallyclean</code> rules!</p><p>When you can’t tell from the naming what does what, it can easily lead to potential problems down the line.</p><p>Usman’s law strikes again.</p></div><div class="sect2" title="Silent Failure"><div class="titlepage"><div><div><h2 class="title"><a id="silent_failure"/>Silent Failure</h2></div></div></div><p><a id="iddle1117" class="indexterm"/><a id="iddle1118" class="indexterm"/><a id="iddle1597" class="indexterm"/><a id="iddle1666" class="indexterm"/>Here’s another makefile snippet that works some of the time:</p><a id="pro_id00394"/><pre class="programlisting">clean:
→ @-rm *.o &amp;&gt; /dev/null</pre><p>The <code class="literal">@</code> means that the command isn’t echoed. The <code class="literal">-</code> means that any error returned is ignored and all output is redirected with <code class="literal">&amp;&gt;</code> to <code class="literal">/dev/null</code>, making it invisible. Because no <code class="literal">-f</code> is on the <code class="literal">rm</code> command, any failure (from say, permissions problems) will go totally unnoticed.</p><p>Usman’s law strikes again.</p></div><div class="sect2" title="Recursive Clean"><div class="titlepage"><div><div><h2 class="title"><a id="recursive_clean"/>Recursive Clean</h2></div></div></div><p>Many makefiles are recursive, and <code class="literal">make clean</code> must be recursive too, so you see the following pattern:</p><a id="pro_id00395"/><pre class="programlisting">SUBDIRS = library executable

.PHONY: clean
clean:
→ for dir in $(SUBDIRS); do \
→ $(MAKE) -C $$dir clean; \
→ done</pre><p>The problem with this is that it means <code class="literal">make clean</code> has to work correctly in every directory in <code class="literal">SUBDIR</code>, leading to more opportunity for error.</p><p>Usman’s law strikes again.</p></div></div><div class="sect1" title="Pitfalls and Benefits of GNU make Parallelization"><div class="titlepage"><div><div><h1 class="title"><a id="pitfalls_and_benefits_of_gnu_make_parall"/>Pitfalls and Benefits of GNU make Parallelization</h1></div></div></div><p>Many build processes run for hours, so build managers commonly type <code class="literal">make</code> and go home for the night. GNU <code class="literal">make</code>’s solution to this problem is parallel execution: a simple command line option that causes GNU <code class="literal">make</code> to run jobs in parallel using the dependency information in the makefile to run them in the correct order.</p><p>In practice, however, GNU <code class="literal">make</code> parallel execution is severely limited by the fact that almost all makefiles are written with the assumption that their rules will run in series. Rarely do makefile authors <span class="emphasis"><em>think in parallel</em></span> when writing their makefiles. That leads to hidden traps that either cause the build to fail with a fatal error or, worse, build “successfully” but result in incorrect binaries when GNU <code class="literal">make</code> is run in parallel mode.</p><p>This section looks at GNU <code class="literal">make</code>’s parallel pitfalls and how to work around them to get maximum parallelism.</p><div class="sect2" title="Using -j (or -jobs)"><div class="titlepage"><div><div><h2 class="title"><a id="using_-j_left_parenthesisor_-jobsright_p"/>Using -j (or -jobs)</h2></div></div></div><p><a id="iddle1047" class="indexterm"/><a id="iddle1132" class="indexterm"/><a id="iddle1448" class="indexterm"/><a id="iddle1599" class="indexterm"/>To start GNU <code class="literal">make</code> in parallel mode, you can specify either the <code class="literal">-j</code> or <code class="literal">--jobs</code> option on the command line. The argument to the option is the maximum number of processes that GNU <code class="literal">make</code> will run in parallel.</p><p>For example, typing <code class="literal">make --jobs=4</code> allows GNU <code class="literal">make</code> to run up to four subprocesses in parallel, which would give a theoretical maximum speedup of 4×. However, the theoretical time is severely limited by restrictions in the makefile. To calculate the maximum actual speedup, you use Amdahl’s law (which is covered in <a class="xref" href="ch04.html#amdahlapostrophes_law_and_the_limits_of" title="Amdahl’s Law and the Limits of Parallelization">Amdahl’s Law and the Limits of Parallelization</a>).</p><p>One simple but annoying problem found in parallel GNU <code class="literal">make</code> is that because the jobs are no longer run serially (and the order depends on the timing of jobs), the output from GNU <code class="literal">make</code> will be sorted randomly depending on the actual order of job execution.</p><p>Fortunately, that problem has been addressed in GNU <code class="literal">make</code> 4.0 with the <code class="literal">--output-sync</code> option described in <a class="xref" href="ch01.html" title="Chapter 1. The Basics Revisited">Chapter 1</a>.</p><p>Consider the example in <a class="xref" href="ch04.html#simple_makefile_to_illustrate_parallel_m" title="Example 4-9. A simple makefile to illustrate parallel making">Example 4-9</a>:</p><div class="example"><a id="simple_makefile_to_illustrate_parallel_m"/><p class="title">Example 4-9. A simple makefile to illustrate parallel making</p><div class="example-contents"><pre class="programlisting">.PHONY: all
all: t5 t4 t1
→ @echo Making $@

t1: t3 t2
→ touch $@

t2:
→ cp t3 $@

t3:
→ touch $@

t4:
→ touch $@

t5:
→ touch $@</pre></div></div><p>It builds five targets: <code class="literal">t1</code>, <code class="literal">t2</code>, <code class="literal">t3</code>, <code class="literal">t4</code>, and <code class="literal">t5</code>. All are simply touched except for <code class="literal">t2</code>, which is copied from <code class="literal">t3</code>.</p><p>Running <a class="xref" href="ch04.html#simple_makefile_to_illustrate_parallel_m" title="Example 4-9. A simple makefile to illustrate parallel making">Example 4-9</a> through standard GNU <code class="literal">make</code> without a parallel option gives the output:</p><a id="pro_id00396"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
touch t5
touch t4
touch t3
cp t3 t2
touch t1
Making all</pre><p><a id="iddle1195" class="indexterm"/>The order of execution will be the same each time because GNU <code class="literal">make</code> will follow the prerequisites depth first and from left to right. Note that the left-to-right execution (in the <code class="literal">all</code> rule for example, <code class="literal">t5</code> is built before <code class="literal">t4</code>, which is built before <code class="literal">t1</code>) is part of the POSIX <code class="literal">make</code> standard.</p><p>Now if <code class="literal">make</code> is run in parallel mode, it’s clear that <code class="literal">t5</code>, <code class="literal">t4</code>, and <code class="literal">t1</code> can be run at the same time because there are no dependencies between them. Similarly, <code class="literal">t3</code> and <code class="literal">t2</code> do not depend on each other, so they can be run in parallel.</p><p>The output of a parallel run of <a class="xref" href="ch04.html#simple_makefile_to_illustrate_parallel_m" title="Example 4-9. A simple makefile to illustrate parallel making">Example 4-9</a> might be:</p><a id="pro_id00397"/><pre class="programlisting">$ <span class="strong"><strong>make --jobs=16</strong></span>
touch t4
touch t5
touch t3
cp t3 t2
touch t1
Making all</pre><p>Or even:</p><a id="pro_id00398"/><pre class="programlisting">$ <span class="strong"><strong>make --jobs=16</strong></span>
touch t3
cp t3 t2
touch t4
touch t1
touch t5
Making all</pre><p>This makes any process that examines log files to check for build problems (such as diffing log files) difficult. Unfortunately, there’s no easy solution for this in GNU <code class="literal">make</code> without the <code class="literal">--output-sync</code> option, so you’ll just have to live with it unless you upgrade to GNU <code class="literal">make</code> 4.0.</p></div><div class="sect2" title="Missing Dependencies"><div class="titlepage"><div><div><h2 class="title"><a id="missing_dependencies"/>Missing Dependencies</h2></div></div></div><p>The example in <a class="xref" href="ch04.html#simple_makefile_to_illustrate_parallel_m" title="Example 4-9. A simple makefile to illustrate parallel making">Example 4-9</a> has an additional problem. The author fell into the classic left-to-right trap when writing the makefile, so when it’s run in parallel, it’s possible for the following to happen:</p><a id="pro_id00399"/><pre class="programlisting">$ <span class="strong"><strong>make --jobs=16</strong></span>
touch t5
touch t4
cp t3 t2
cp: cannot stat `t3': No such file or directory
make: *** [t2] Error 1</pre><p>The reason is that when run in parallel, the rule to build <code class="literal">t2</code> can occur before the rule to build <code class="literal">t3</code>, and <code class="literal">t2</code> needs <code class="literal">t3</code> to have already been built. This didn’t happen in the serial case because of the left-to-right assumption: the rule to build <code class="literal">t1</code> is <code class="literal">t1: t3 t2</code>, which implies that <code class="literal">t3</code> will be built before <code class="literal">t2</code>.</p><p><a id="iddle1410" class="indexterm"/><a id="iddle1824" class="indexterm"/>But no actual dependency exists in the makefile that states that <code class="literal">t3</code> must be built before <code class="literal">t2</code>. The fix is simple: just add <code class="literal">t2: t3</code> to the makefile.</p><p>This is a simple example of the real problem of missing or implicit (left-to-right) dependencies that plagues makefiles when run in parallel. If a makefile breaks when run in parallel, it’s worth looking for missing dependencies straightaway because they are very common.</p></div><div class="sect2" title="The Hidden Temporary File Problem"><div class="titlepage"><div><div><h2 class="title"><a id="hidden_temporary_file_problem"/>The Hidden Temporary File Problem</h2></div></div></div><p>Another way GNU <code class="literal">make</code> can break when running in parallel is if multiple rules use the same temporary file. Consider the example makefile in <a class="xref" href="ch04.html#hidden_temporary_file_that_breaks_parall" title="Example 4-10. A hidden temporary file that breaks parallel builds">Example 4-10</a>:</p><div class="example"><a id="hidden_temporary_file_that_breaks_parall"/><p class="title">Example 4-10. A hidden temporary file that breaks parallel builds</p><div class="example-contents"><pre class="programlisting">TMP_FILE := /tmp/scratch_file

.PHONY: all
all: t

t: t1 t2
→ cat t1 t2 &gt; $@

t1:
→ echo Output from $@ &gt; $(TMP_FILE)
→ cat $(TMP_FILE) &gt; $@

t2:
→ echo Output from $@ &gt; $(TMP_FILE)
→ cat $(TMP_FILE) &gt; $@</pre></div></div><p>Run without a parallel option, GNU <code class="literal">make</code> produces the following output:</p><a id="pro_id00400"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
echo Output from t1 &gt; /tmp/scratch_file
cat /tmp/scratch_file &gt; t1
echo Output from t2 &gt; /tmp/scratch_file
cat /tmp/scratch_file &gt; t2
cat t1 t2 &gt; t</pre><p>and the <code class="literal">t</code> file contains:</p><a id="pro_id00401"/><pre class="programlisting">Output from t1
Output from t2</pre><p>But run in parallel, <a class="xref" href="ch04.html#hidden_temporary_file_that_breaks_parall" title="Example 4-10. A hidden temporary file that breaks parallel builds">Example 4-10</a> gives the following output:</p><a id="pro_id00402"/><pre class="programlisting">$ make --jobs=2
echo Output from t1 &gt; /tmp/scratch_file
echo Output from t2 &gt; /tmp/scratch_file
cat /tmp/scratch_file &gt; t1
cat /tmp/scratch_file &gt; t2
cat t1 t2 &gt; t</pre><p><a id="iddle1727" class="indexterm"/>Now <code class="literal">t</code> contains:</p><a id="pro_id00403"/><pre class="programlisting">Output from t2
Output from t2</pre><p>This occurs because no dependency exists between <code class="literal">t1</code> and <code class="literal">t2</code> (because neither requires the output of the other), so they can run in parallel. In the output, you can see that they are running in parallel but that the output from the two rules is interleaved. Because the two <code class="literal">echo</code> statements ran first, <code class="literal">t2</code> overwrote the output of <code class="literal">t1</code>, so the temporary file (shared by both rules) had the wrong value when it was finally <code class="literal">cat</code>ed to <code class="literal">t1</code>, resulting in the wrong value for <code class="literal">t</code>.</p><p>This example may seem contrived, but the same thing happens in real makefiles when run in parallel, resulting in either broken builds or the wrong binary being built. The <code class="literal">yacc</code> program for example, produces temporary files called <code class="literal">y.tab.c</code> and <code class="literal">y.tab.h</code>. If more than one <code class="literal">yacc</code> is run in the same directory at the same time, the wrong files could be used by the wrong process.</p><p>A simple solution for the makefile in <a class="xref" href="ch04.html#hidden_temporary_file_that_breaks_parall" title="Example 4-10. A hidden temporary file that breaks parallel builds">Example 4-10</a> is to change the definition of <code class="literal">TMP_FILE</code> to <code class="literal">TMP_FILE = /tmp/scratch_file.$@</code>, so its name will depend on the target being built. Now a parallel run would look like this:</p><a id="pro_id00404"/><pre class="programlisting">$ <span class="strong"><strong>make --jobs=2</strong></span>
echo Output from t1 &gt; /tmp/scratch_file.t1
echo Output from t2 &gt; /tmp/scratch_file.t2
cat /tmp/scratch_file.t1 &gt; t1
cat /tmp/scratch_file.t2 &gt; t2
cat t1 t2 &gt; t</pre><p>A related problem occurs when multiple jobs in the makefile write to a shared file. Even if they never read the file (for example, they might write to a log file), locking the file for write access can cause competing jobs to stall, reducing the overall performance of the parallel build.</p><p>Consider the example makefile in <a class="xref" href="ch04.html#locking_on_shared_files_can_lock_a_paral" title="Example 4-11. Locking on shared files can lock a parallel build and make it run serially.">Example 4-11</a> that uses the <code class="literal">lockfile</code> command to lock a file and simulate write locking. Although the file is locked, each job waits for a number of seconds:</p><div class="example"><a id="locking_on_shared_files_can_lock_a_paral"/><p class="title">Example 4-11. Locking on shared files can lock a parallel build and make it run serially.</p><div class="example-contents"><pre class="programlisting">LOCK_FILE := lock.me

.PHONY: all
all: t1 t2
→ @echo done.

t1:
→ @lockfile $(LOCK_FILE)
→ @sleep 10
→ @rm -f $(LOCK_FILE)
→ @echo Finished $@
t2:
→ @lockfile $(LOCK_FILE)
→ @sleep 20
→ @rm -f $(LOCK_FILE)
→ @echo Finished $@</pre></div></div><p><a id="iddle1052" class="indexterm"/><a id="iddle1571" class="indexterm"/><a id="iddle1672" class="indexterm"/><a id="iddle1795" class="indexterm"/>Running <a class="xref" href="ch04.html#locking_on_shared_files_can_lock_a_paral" title="Example 4-11. Locking on shared files can lock a parallel build and make it run serially.">Example 4-11</a> in a serial build takes about 30 seconds:</p><a id="pro_id00405"/><pre class="programlisting">$ <span class="strong"><strong>time make</strong></span>
Finished t1
Finished t2
done.
make 0.01s user 0.01s system 0% cpu 30.034 total</pre><p>But it isn’t any faster in parallel, even though <code class="literal">t1</code> and <code class="literal">t2</code> should be able to run in parallel:</p><a id="pro_id00406"/><pre class="programlisting">$ <span class="strong"><strong>time make -j4</strong></span>
Finished t1
Finished t2
done.
make -j4 0.01s user 0.02s system 0% cpu 36.812 total</pre><p>It’s actually slower because of the way <code class="literal">lockfile</code> detects lock availability. As you can imagine, write locking a file could cause similar delays in otherwise parallel-friendly makefiles.</p><p>Related to the file locking problem is a danger concerning archive (<code class="literal">ar</code>) files. If multiple <code class="literal">ar</code> processes were to run simultaneously on the same archive file, the archive could be corrupted. Locking around archive updates is necessary in a parallel build; otherwise, you’ll need to prevent your dependencies from running multiple <code class="literal">ar</code> commands on the same file at the same time.</p><p>One way to prevent parallelism problems is to specify <code class="literal">.NOTPARALLEL</code> in a makefile. If this is seen, the entire <code class="literal">make</code> execution will be run in series and the <code class="literal">-j</code> or <code class="literal">--jobs</code> command line option will be ignored. <code class="literal">.NOTPARALLEL</code> is a very blunt tool because it affects an entire invocation of GNU <code class="literal">make</code>, but it could be handy in a recursive <code class="literal">make</code> situation with, for example, a third-party makefile that is not parallel safe.</p></div><div class="sect2" title="The Right Way to Do Recursive make"><div class="titlepage"><div><div><h2 class="title"><a id="right_way_to_do_recursive_make"/>The Right Way to Do Recursive make</h2></div></div></div><p>GNU <code class="literal">make</code> is smart enough to share parallelism across sub-makes if a makefile using <code class="literal">$(MAKE)</code> is careful about how it calls sub-makes. GNU <code class="literal">make</code> has a message passing mechanism that works across most platforms (Windows support was added in GNU <code class="literal">make</code> 4.0) and enables sub-makes to use all the available jobs specified through <code class="literal">-j</code> or <code class="literal">--jobs</code> by passing tokens across pipes between the <code class="literal">make</code> processes.</p><p><a id="iddle1048" class="indexterm"/><a id="iddle1208" class="indexterm"/><a id="iddle1598" class="indexterm"/>The only serious gotcha is that you must write your makefile in a way that actually allows your sub-makes to run in parallel. The classic recursive <code class="literal">make</code> style that uses a shell <code class="literal">for</code> loop to process each sub-make doesn’t allow for more than one sub-make to run at once. For example:</p><a id="pro_id00407"/><pre class="programlisting">SUBDIRS := foo bar baz

.PHONY: all
all:
→ for d in $(SUBDIRS);     \
→ do                       \
→ $(MAKE) –directory=$$d;  \
→ done</pre><p>This code has a big problem: if sub-make fails, the <code class="literal">make</code> will look like it has succeeded. It’s possible to fix that, but the fixes become more and more complicated: other approaches are better.</p><p>When run in parallel mode, the <code class="literal">all</code> rule walks through each subdirectory and waits for its <code class="literal">$(MAKE)</code> to complete. Even though each of those sub-makes will be able to run in parallel, the overall <code class="literal">make</code> does not, meaning a less than ideal speedup. For example, if the <code class="literal">make</code> in the <code class="literal">bar</code> directory is capable of running only four jobs at once, then running on a 16-core machine won’t make the build any faster than on one with just 4 cores.</p><p>The solution is to remove the <code class="literal">for</code> loop and replace it with a single rule for each directory:</p><a id="pro_id00408"/><pre class="programlisting">SUBDIRS := foo bar baz

.PHONY: all $(SUBDIRS)
all: $(SUBDIRS)

$(SUBDIRS):
→ $(MAKE) --directory=$@</pre><p>Each directory is considered to be a phony target, because the directory doesn’t actually get built.</p><p>Now each directory can run while the others are running, and parallelism is maximized; it’s even possible to have dependencies between directories causing some sub-makes to run before others. Directory dependencies can be handy when it’s important that one sub-make runs before another.</p></div><div class="sect2" title="Amdahl’s Law and the Limits of Parallelization"><div class="titlepage"><div><div><h2 class="title"><a id="amdahlapostrophes_law_and_the_limits_of"/>Amdahl’s Law and the Limits of Parallelization</h2></div></div></div><p>Additionally, there are real limits to the amount of parallelization that is possible in a project. Look at <a class="xref" href="ch04.html#makefile_with_sleep_used_to_simulate_job" title="Example 4-12. A makefile with sleep used to simulate jobs that take time to complete">Example 4-12</a>:</p><div class="example"><a id="makefile_with_sleep_used_to_simulate_job"/><p class="title">Example 4-12. A makefile with <code class="literal">sleep</code> used to simulate jobs that take time to complete</p><div class="example-contents"><pre class="programlisting">.PHONY: all
all: t
→ @echo done
t: t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12
→ @sleep 10
→ @echo Made $@

t1:
→ @sleep 11
→ @echo Made $@

t2:
→ @sleep 4
→ @echo Made $@

t3: t5
→ @sleep 7
→ @echo Made $@

t4:
→ @sleep 9
→ @echo Made $@

t5: t8
→ @sleep 10
→ @echo Made $@

t6:
→ @sleep 2
→ @echo Made $@

t7:
→ @sleep 12
→ @echo Made $@

t8:
→ @sleep 3
→ @echo Made $@

t9: t10
→ @sleep 4
→ @echo Made $@

t10:
→ @sleep 6
→ @echo Made $@

t11: t12
→ @sleep 1
→ @echo Made $@

t12:
→ @sleep 9
→ @echo Made $@</pre></div></div><p><a id="iddle1647" class="indexterm"/>When run in series, it takes about 88 seconds to complete:</p><a id="pro_id00409"/><pre class="programlisting">$ <span class="strong"><strong>time make</strong></span>
Made t1
Made t2
Made t8
Made t5
Made t3
Made t4
Made t6
Made t7
Made t10
Made t9
Made t12
Made t11
Made t
done
make 0.04s user 0.03s system 0% cpu 1:28.68 total</pre><p>What’s the maximum speedup possible, assuming as many CPUs are available as desired? Working through the makefile step by step, you’ll see that <code class="literal">t</code> takes 10 seconds to build and everything else must be built before that. <code class="literal">t1</code>, <code class="literal">t2</code>, <code class="literal">t4</code>, <code class="literal">t6</code>, and <code class="literal">t7</code> are all independent, and the longest of them takes 12 seconds. <code class="literal">t3</code> waits for <code class="literal">t5</code>, which needs <code class="literal">t8</code>: that chain takes a total of 20 seconds. <code class="literal">t9</code> needs <code class="literal">t10</code> for a total of 10 seconds, and <code class="literal">t11</code> needs <code class="literal">t12</code> for another 10 seconds.</p><p>So the longest serial part of this build is the sequence <code class="literal">t</code>, <code class="literal">t3</code>, <code class="literal">t5</code>, <code class="literal">t8</code>, which takes a total of 30 seconds. This build can never go faster than 30 seconds (or 2.93 times faster than the serial 88 second time). How many processors are needed to achieve that speedup?</p><p>In general, the maximum speedup achievable is governed by Amdahl’s law: if <code class="literal">F</code> is the fraction of the build that cannot be parallelized and <code class="literal">N</code> is the number of available processors, then the maximum speedup achievable is <code class="literal">1 / ( F + ( 1 - F ) / N )</code>.</p><p>In the <a class="xref" href="ch04.html#makefile_with_sleep_used_to_simulate_job" title="Example 4-12. A makefile with sleep used to simulate jobs that take time to complete">Example 4-12</a> example, 34 percent of the build can’t be parallelized. <a class="xref" href="ch04.html#maximum_speedup_based_on_number_of_proce" title="Table 4-4. Maximum Speedup Based on Number of Processors">Table 4-4</a> shows the results of applying Amdahl’s law:</p><div class="table"><a id="maximum_speedup_based_on_number_of_proce"/><p class="title">Table 4-4. Maximum Speedup Based on Number of Processors</p><div class="table-contents"><table summary="Maximum Speedup Based on Number of Processors" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Number of processors</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>Maximum speedup</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>2</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>1.49x</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>3</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>1.79x</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>4</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>1.98x</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>5</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>2.12x</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>6</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>2.22x</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>7</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>2.30x</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>8</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>2.37x</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>9</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>2.42x<a id="iddle1919" class="indexterm"/></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>10</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>2.46x</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>11</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>2.50x</p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p>12</p></td><td style="" valign="top"><p>2.53x</p></td></tr></tbody></table></div></div><p>For this small build, the maximum speedup Amdahl’s law predicts has a plateau starting at around eight processors. The actual plateau is further limited by the fact that only 13 possible jobs are in the build.</p><p>Looking at the structure of the build, we can see that eight processors is the maximum because five jobs can run in parallel without any dependencies: <code class="literal">t1</code>, <code class="literal">t2</code>, <code class="literal">t4</code>, <code class="literal">t6</code>, and <code class="literal">t7</code>. Then three small chains of jobs can each use one processor at a time: <code class="literal">t3</code>, <code class="literal">t5</code>, and <code class="literal">t8</code>; <code class="literal">t9</code> and <code class="literal">t10</code>; and <code class="literal">t11</code> and <code class="literal">t12</code>. Building <code class="literal">t</code> can reuse one of the eight processors because they’ll all be idle at that point.</p><p>A real-world instance of Amdahl’s law significantly impacting build times occurs with languages that have a linking step, such as C and C++. Typically, all the objects files are built before the link step and then a single (often huge) link process has to run. That link process is often not parallelizable and becomes the limiting factor on build parallelization.</p></div></div><div class="sect1" title="Making $(wildcard) Recursive"><div class="titlepage"><div><div><h1 class="title"><a id="making_dollarleft_parenthesiswildcardrig"/>Making $(wildcard) Recursive</h1></div></div></div><p>The built-in <code class="literal">$(wildcard)</code> function is not recursive: it only searches for files in a single directory. You can have multiple globbing patterns in a <code class="literal">$(wildcard)</code> and use that to look in subdirectories. For example, <code class="literal">$(wildcard */*.c)</code> finds all the <code class="literal">.c</code> files in all subdirectories of the current directory. But if you need to search an arbitrary tree of directories, there’s no built-in way to do it.</p><p>Fortunately, it’s pretty easy to make a recursive version of <code class="literal">$(wildcard)</code>, like this:</p><a id="pro_id00410"/><pre class="programlisting">rwildcard=$(foreach d,$(wildcard $1*),$(call rwildcard,$d/,$2) $(filter $(subst *,%,$2),$d))</pre><p>The function <code class="literal">rwildcard</code> takes two parameters: the first is the directory from which to start searching (this parameter can be left empty to start from the current directory), and the second is the glob pattern for the files to find in each directory.</p><p>For example, to find all <code class="literal">.c</code> files in the current directory (along with its subdirectories), use this:</p><a id="pro_id00411"/><pre class="programlisting">$(call rwildcard,,*.c)</pre><p>Or to find all <code class="literal">.c</code> files in <code class="literal">/tmp</code>, use this:</p><a id="pro_id00412"/><pre class="programlisting">$(call rwildcard,/tmp/,*.c)</pre><p><a id="iddle1161" class="indexterm"/><a id="iddle1513" class="indexterm"/><a id="iddle1549" class="indexterm"/><a id="iddle1605" class="indexterm"/><code class="literal">rwildcard</code> also supports multiple patterns. For example:</p><a id="pro_id00413"/><pre class="programlisting">$(call rwildcard,/src/,*.c *.h)</pre><p>This finds all <code class="literal">.c</code> and <code class="literal">.h</code> files under <code class="literal">/src/</code>.</p></div><div class="sect1" title="Which Makefile Am I In?"><div class="titlepage"><div><div><h1 class="title"><a id="which_makefile_am_i_inquestion_mark"/>Which Makefile Am I In?</h1></div></div></div><p>A common request is: Is there a way to find the name and path of the current makefile? By <span class="emphasis"><em>current</em></span>, people usually mean the makefile that GNU <code class="literal">make</code> is currently parsing. There’s no built-in way to quickly get the answer, but there is a way using the GNU <code class="literal">make</code> variable <code class="literal">MAKEFILE_LIST</code>.</p><p><code class="literal">MAKEFILE_LIST</code> is the list of makefiles currently loaded or <code class="literal">include</code>d. Each time a makefile is loaded or <code class="literal">include</code>d, the <code class="literal">MAKEFILE_LIST</code> is appended with its path and name. The paths and names in the variable are relative to the current working directory (where GNU <code class="literal">make</code> was started or where it moved to with the <code class="literal">-C</code> or <code class="literal">--directory</code> option), but you can access the current directory from the <code class="literal">CURDIR</code> variable.</p><p>So using that, you can define a GNU <code class="literal">make</code> function (let’s call it <code class="literal">where-am-i</code>) that will return the current makefile (it uses <code class="literal">$(word)</code> to get the last makefile name from the list):</p><a id="pro_id00414"/><pre class="programlisting">where-am-i = $(CURDIR)/$(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))</pre><p>Then, whenever you want to find the full path to the current makefile, write the following at the top of the makefile:</p><a id="pro_id00415"/><pre class="programlisting">THIS_MAKEFILE := $(call where-am-i)</pre><p>It’s important that this line goes at the top because any <code class="literal">include</code> statement in the makefile will change the value of <code class="literal">MAKEFILE_LIST</code>, so you want to grab the location of the current makefile before that happens.</p><p><a class="xref" href="ch04.html#makefile_that_can_determine_where_it_is" title="Example 4-13. A makefile that can determine where it is located on the filesystem">Example 4-13</a> shows an example makefile that uses <code class="literal">where-am-i</code> and includes another makefile from the <code class="literal">foo/</code> subdirectory, which, in turn, includes a makefile from the <code class="literal">foo/bar/</code> directory.</p><div class="example"><a id="makefile_that_can_determine_where_it_is"/><p class="title">Example 4-13. A makefile that can determine where it is located on the filesystem</p><div class="example-contents"><pre class="programlisting">where-am-i = $(CURDIR)/$(word ($words $(MAKEFILE_LIST)),$(MAKEFILE_LIST)

include foo/makefile</pre></div></div><p>The contents of <code class="literal">foo/makefile</code> is shown in <a class="xref" href="ch04.html#makefile_included_by_listing_4-13" title="Example 4-14. A makefile included by Example 4-13">Example 4-14</a>.</p><div class="example"><a id="makefile_included_by_listing_4-13"/><p class="title">Example 4-14. A makefile included by <a class="xref" href="ch04.html#makefile_that_can_determine_where_it_is" title="Example 4-13. A makefile that can determine where it is located on the filesystem">Example 4-13</a></p><div class="example-contents"><pre class="programlisting">THIS_MAKEFILE := $(call where-am-i)
$(warning $(THIS_MAKEFILE))

include foo/bar/makefile</pre></div></div><p>The contents of <code class="literal">foo/bar/makefile</code> is shown in <a class="xref" href="ch04.html#makefile_included_by_listing_4-14" title="Example 4-15. A makefile included by Example 4-14">Example 4-15</a>.</p><div class="example"><a id="makefile_included_by_listing_4-14"/><p class="title">Example 4-15. A makefile included by <a class="xref" href="ch04.html#makefile_included_by_listing_4-13" title="Example 4-14. A makefile included by Example 4-13">Example 4-14</a></p><div class="example-contents"><pre class="programlisting">THIS_MAKEFILE := $(call where-am-i)
$(warning $(THIS_MAKEFILE))</pre></div></div><p>Putting the three makefiles in <a class="xref" href="ch04.html#makefile_that_can_determine_where_it_is" title="Example 4-13. A makefile that can determine where it is located on the filesystem">Example 4-13</a>, <a class="xref" href="ch04.html#makefile_included_by_listing_4-13" title="Example 4-14. A makefile included by Example 4-13">Example 4-14</a> and <a class="xref" href="ch04.html#makefile_included_by_listing_4-14" title="Example 4-15. A makefile included by Example 4-14">Example 4-15</a> in <code class="literal">/tmp</code> (and subdirectories) and running GNU <code class="literal">make</code> gives the output:</p><a id="pro_id00416"/><pre class="programlisting">foo/makefile:2: /tmp/foo/makefile
foo/bar/makefile:2: /tmp/foo/bar/makefile</pre><p>In this chapter, we’ve looked at common problems that makefile creators and maintainers run into when working on real makefiles. In any sizable project that uses <code class="literal">make</code>, you are likely to run into one or more (perhaps even all!) of them.</p></div></div></body></html>