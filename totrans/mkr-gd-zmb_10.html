<html><head></head><body>
<h2 class="h2" id="ch10"><a id="page_181"/><strong>10</strong></h2>
<p class="h2a"><strong>COMMUNICATING WITH OTHER SURVIVORS</strong></p>
<div class="image1"><img src="graphics/f0001-01.jpg" alt="image"/></div>
<p class="noindent">In <a href="ch01.html#ch01">Chapter 1</a>, we discussed the pros and cons of teaming up with other humans when zombies walk the Earth. Associating with other people can certainly be worthwhile: you can protect each other, share knowledge, pool resources, and so on. Of course, they can also take your stuff and put you between themselves and the oncoming zombies. If you decide to take the risk and reach out to your fellow life forms, then build the projects in this chapter.</p>
<p class="indent">First, we’ll build a beacon to broadcast a voice signal that can be heard on an FM radio, so any survivors scanning the airwaves can hear your message, whether that’s “Stay away!” or “Help, I’m trapped on the roof of a shopping mall!” After that, you’ll also build a Morse code flasher that will blink out any message you care to translate into dots and dashes.</p>
<p class="indent"><a id="page_182"/>Of course, if you want to be the one scanning frequency bands, this chapter also explains how to hack a radio receiver to search for a signal. Then, you can lurk silently while you decide whether what’s out there is worth broadcasting to (see <a href="ch10.html#ch10fig1">Figure 10-1</a>).</p>
<div class="image"><img src="graphics/f10-01.jpg" alt="image"/></div>
<p class="figuret"><a id="ch10fig1">Figure 10-1:</a> Zombies like the radio too.</p>
<h3 class="h3" id="ch00lev1sec179"><strong>PROJECT 17: A RASPBERRY PI RADIO TRANSMITTER BEACON</strong></h3>
<p class="noindent">The Raspberry Pi is a versatile device that can, given the right software, act as an FM radio transmitter. The only extra hardware you’ll need is a length of wire to act as an antenna.</p>
<h4 class="h4" id="ch00lev1sec180"><strong>WHAT YOU WILL NEED</strong></h4>
<p class="noindent">This is another Raspberry Pi project, so you will need to have a working Raspberry Pi system complete with keyboard, mouse, and screen as described in <a href="ch05.html#ch05">Chapter 5</a>. Once the program that transmits the radio signal is up and running, you can turn off the screen to save power if you wish.</p>
<div class="sidebar">
<p class="sidebart"><a id="page_183"/><strong>RADIO TRANSMITTER LEGALITY</strong></p>
<p class="noindent">If you’re reading this after the zombie apocalypse, there will be no legal problems with building a transmitter because there won’t be any government to enforce the regulations. If, however, you are building in preparation, then the legality of the transmitter in this project is covered by the same legislation as FM transmitters designed to be connected to an MP3 player for car audio.</p>
<p class="indent">These transmitters are legal in the United States if the effective range is 200 feet (60 m) or less. If you use a full-length antenna, this transmitter will have a longer range than that, so to stay within the law, use a small antenna of about 3 or 4 inches (7 to 10 cm).</p>
<p class="indent">Regulation of the airwaves is necessary so the frequencies used by emergency services stay clear, but this transmitter uses only the public broadcast FM wave band. The worst that can happen is one of your neighbors receives your broadcast instead of their favorite radio station.</p>
</div>
<p class="indentb">To build this radio transmitter, you’ll need the following parts:</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="100%">
<thead>
<tr>
<th valign="top" class="table_th"><p class="table1"><strong>ITEMS</strong></p></th>
<th valign="top" class="table_th"><p class="table1"><strong>NOTES</strong></p></th>
<th valign="top" class="table_th"><p class="table1"><strong>SOURCE</strong></p></th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Raspberry Pi</p></td>
<td valign="top" class="table"><p class="table">Raspberry Pi 2, Model B or B+</p></td>
<td valign="top" class="table"><p class="table">Adafruit (2358), Fry’s (8258726)</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Jumper wire</p></td>
<td valign="top" class="table"><p class="table">Female-to-female jumper wire</p></td>
<td valign="top" class="table"><p class="table">Adafruit (826)</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Wire for the antenna</p></td>
<td valign="top" class="table"><p class="table">About 3 feet (1 m) of wire</p></td>
<td valign="top" class="table"><p class="table"> </p></td>
</tr>
</tbody>
</table>
<p class="indent">Any wire will do for the transmitter; just check your box of scavenged hookup wire for something that will fit into the end of the female-to-female jumper wire.</p>
<p class="indent">You could add the radio transmitter to your existing Raspberry Pi setup. However, for maximum transmission range, you’ll want to put the transmitter somewhere high up, so I recommend getting a second Pi.</p>
<p class="indent">The length of the jumper wire doesn’t matter; it just allows an easy connection between the Raspberry Pi GPIO pin and the antenna wire. The wire to use for the rest of the antenna should be the right size to poke into one end of the female-to-female jumper wire and stay there. You might need to put a kink in the antenna wire so that it stays in place.</p>
<h4 class="h4" id="ch00lev1sec181"><a id="page_184"/><strong>CONSTRUCTION</strong></h4>
<p class="noindent">To build your transmitter, all you need to do is plug one end of the jumper wire onto GPIO pin 4 of the Raspberry Pi (<a href="ch10.html#ch10fig2">Figure 10-2</a>), then plug the antenna wire into the other end of the jumper wire and fix the other end of the antenna to a high spot so that the antenna is pulled up vertically.</p>
<div class="image"><img src="graphics/f10-02.jpg" alt="image"/></div>
<p class="figuret"><a id="ch10fig2">Figure 10-2:</a> Attaching the antenna</p>
<p class="indent">You will get the longest transmission range if you place the whole Raspberry Pi up high. If you have a watchtower, this would be ideal.</p>
<p class="indent">It does not matter if the antenna wire is not very straight. You may find that some electrical tape wrapped around the junction of the antenna wire and the jumper wire will prevent the antenna from becoming detached. Once you’ve strengthened the antenna, you’ve built your radio transmitter beacon!</p>
<h4 class="h4" id="ch00lev1sec182"><strong>SOFTWARE</strong></h4>
<p class="noindent">I wish I could claim credit for the wonderful piece of software you’ll use in this project, but as it was developed by those clever folk at the Imperial College Robotics Society, I can’t. You can find out all about their project at <em><a href="http://www.icrobotics.co.uk/wiki/index.php/Turning_the_Raspberry_Pi_Into_an_FM_Transmitter">http://www.icrobotics.co.uk/wiki/index.php/Turning_the_Raspberry_Pi_Into_an_FM_Transmitter</a>.</em></p>
<p class="indent"><a id="page_185"/>The software uses a sound file to oscillate GPIO pin 4 in just the right way to generate an FM carrier wave and signal (see the box on frequency modulation).</p>
<p class="indent">To install the software, start an LXTerminal session on your Raspberry Pi and type the following commands:</p>
<p class="programsb">$ <span class="codestrong">mkdir pifm</span><br/>$ <span class="codestrong">cd pifm</span><br/>$ <span class="codestrong">wget http://www.icrobotics.co.uk/wiki/images/c/c3/Pifm.tar.gz</span><br/>$ <span class="codestrong">tar -xzf Pifm.tar.gz</span></p>
<p class="indent">These commands create a directory ready to install the software, download the software using the <span class="literal">wget</span> utility, and then uncompress the downloaded file into the newly created directory.</p>
<h4 class="h4" id="ch00lev1sec183"><strong>USING THE FM TRANSMITTER</strong></h4>
<p class="noindent">To test out the FM transmitter, you need an FM receiver (see “<a href="ch10.html#ch00lev1sec186">Project 18: Arduino FM Radio Frequency Hopper</a>” on <a href="ch10.html#page_188">page 188</a>). You also need to find an unused frequency, or at least a frequency with only a faint signal. Of course, this won’t be a problem following the apocalypse, but it’s more of a challenge with the crowded preapocalypse airwaves. Use your FM receiver to find a quiet part of the spectrum and make a note of the frequency.</p>
<p class="indent">The software you installed includes a sound sample of the <em>Star Wars</em> theme for testing the transmitter before you record your own, more appropriate message—although the music is not completely inappropriate to accompany humanity’s great battle to save itself.</p>
<p class="indent">In the LXTerminal, issue the following command to play the tune over your transmitter:</p>
<p class="programsb">$ <span class="codestrong">sudo ./pifm sound.wav <span class="codeitalic">103.0</span></span></p>
<p class="indent">In place of <em>103.0</em>, substitute the frequency that your radio receiver is tuned to.</p>
<h5 class="h5" id="ch00lev1sec184"><strong>RECORDING A MESSAGE</strong></h5>
<p class="noindent">To record a message, you’ll need a laptop and some sound-recording or editing software. I recommend Audacity, which is available free for Windows, OS X, and Linux from <em><a href="http://audacityteam.org/">http://audacityteam.org/</a></em>.</p>
<p class="indent">Fiction and history both tell us that when law and order disintegrate, bad behavior often follows. So think long and hard about what you want to say in your message. Who knows what gun-toting, supply-stealing outlaws <a id="page_186"/>are lurking around the corner? You’ll probably want to direct new arrivals somewhere you can observe them before lowering your defenses, so bear this in mind when recording your broadcast.</p>
<p class="indent">The pifm software requires you to record your message with the sample rate set at 16 bit 44.1kHz and then export the message as a WAV file. In the software, change <span class="literal">sound.wav</span> to the name of your new sound file, say <em>my</em>_<em>message.wav</em>.</p>
<div class="sidebar">
<p class="sidebart"><strong>FREQUENCY MODULATION</strong></p>
<p class="noindent">Frequency modulation, or FM as it is nearly always called, is a way of encoding a signal (in this case a low-frequency sound signal) on a much higher carrier frequency. The sound signal nudges the carrier frequency higher or lower than the carrier frequency, depending on the level of your message signal’s waveform.</p>
<p class="indent"><a href="ch10.html#ch10fig3">Figure 10-3</a> shows two cycles of the message signal (solid line) superimposed on the much higher frequency carrier to create the broadcast signal (dotted line), whose frequency changes as your message signal changes.</p>
<div class="image"><img src="graphics/f10-03.jpg" alt="image"/></div>
<p class="figuret"><a id="ch10fig3">Figure 10-3:</a> Frequency modulation</p>
<p class="indent">When the signal is at its maximum, the peaks of the dotted broadcast signal are closest together. That means the frequency is higher than average. At the bottom of the waveform, when the signal has its minimum value, the broadcast signal peaks are farthest apart (the frequency is lower than average).</p>
<p class="indent">In this way, the low-frequency sound wave is encoded onto the high-frequency carrier wave. When this signal gets to an FM radio receiver, the circuitry in the receiver extracts the original low-frequency audio from the carrier signal.</p>
</div>
<h5 class="h5" id="ch00lev1sec185"><a id="page_187"/><strong>RUNNING THE TRANSMITTER AUTOMATICALLY</strong></h5>
<p class="noindent">To maximize the chance of other survivors discovering your message, repeat this broadcast around the clock. You can configure the Raspberry Pi to do this for you automatically using a Linux tool called <span class="literal">crontab</span>. The <span class="literal">crontab</span> utility lets you schedule programs to run at certain times of day.</p>
<p class="indent">Enter the following command into the LXTerminal:</p>
<p class="programsb">$ <span class="codestrong">sudo crontab -e</span></p>
<p class="indent">This will open a configuration file with the nano editor, as shown in <a href="ch10.html#ch10fig4">Figure 10-4</a>.</p>
<div class="image"><img src="graphics/f10-04.jpg" alt="image"/></div>
<p class="figuret"><a id="ch10fig4">Figure 10-4:</a> scheduling your broadcasts</p>
<p class="indent">Scroll down to the end of the file and add the following line:</p>
<p class="programsb"><span class="codestrong"><span class="codeitalic">*/3</span> * * * * /home/pi/pifm/pifm /home/pi/pifm/<span class="codeitalic">sound.wav 101.0</span></span></p>
<p class="indent">The first part of the line (<span class="literal">*/3</span>) schedules the transmission to run every 3 minutes, 24 hours a day, 7 days a week. If you use a different sound file or frequency, you need to replace <span class="literal">sound.wav</span> with your filename and enter your chosen frequency. If your message is longer than 3 minutes, change <span class="literal">*/3</span> to the number of minutes you need it to be.</p>
<p class="indent">You only need to do this configuration once; the settings will stick even if the Pi is rebooted.</p>
<h3 class="h3" id="ch00lev1sec186"><a id="page_188"/><strong>PROJECT 18: ARDUINO FM RADIO FREQUENCY HOPPER</strong></h3>
<p class="noindent">After the zombie apocalypse strikes, your chances of survival will be increased by group living—that is, assuming no bite victims come inside and turn into zombies. Always be sure that everyone gets checked for zombie-infected wounds before you grant entry!</p>
<p class="indent">You’ll inevitably need to sleep or go on supply runs, and without someone to watch your back you’ll be vulnerable. (Not to mention the slow descent into insanity you’ll suffer from lack of human contact—and you thought zombies were crazy.) Therefore, you’ll likely benefit from having a few companions around. Other groups of survivors may already be trying to make contact by broadcasting their own radio messages, as we now are. In fact, another group might have bought or salvaged this book and made the FM transmitter of Project 17. To find them, you just need to be able to pick up their transmission.</p>
<p class="indent">This project (<a href="ch10.html#ch10fig5">Figure 10-5</a>) takes a cheap FM receiver and hacks it so that it automatically scans the FM band for the next station. If someone has started transmitting on FM, creating a station instead of the hiss of empty airwaves, you will hear their broadcast. An Arduino simulates the pressing of the tune button on the radio receiver.</p>
<div class="image"><img src="graphics/f10-05.jpg" alt="image"/></div>
<p class="figuret"><a id="ch10fig5">Figure 10-5:</a> FM radio frequency hopper</p>
<h4 class="h4" id="ch00lev1sec187"><a id="page_189"/><strong>WHAT YOU WILL NEED</strong></h4>
<p class="noindentb">To make this project, you will need the following parts:</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="100%">
<thead>
<tr>
<th valign="top" class="table_th"><p class="table1"><strong>ITEMS</strong></p></th>
<th valign="top" class="table_th"><p class="table1"><strong>NOTES</strong></p></th>
<th valign="top" class="table_th"><p class="table1"><strong>SOURCE</strong></p></th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Arduino</p></td>
<td valign="top" class="table"><p class="table">Arduino Uno R3</p></td>
<td valign="top" class="table"><p class="table">Adafruit, Fry’s (7224833), Sparkfun</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> FM radio</p></td>
<td valign="top" class="table"><p class="table">Simple low-cost FM headphone radio</p></td>
<td valign="top" class="table"><p class="table">Dollar Store (or equivalently named establishment in your country’s currency)</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Powered speaker</p></td>
<td valign="top" class="table"><p class="table"> </p></td>
<td valign="top" class="table"><p class="table">Electronics store</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Audio lead (aux lead)</p></td>
<td valign="top" class="table"><p class="table">To connect the radio to the powered speaker</p></td>
<td valign="top" class="table"><p class="table"> </p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Red LEDs</p></td>
<td valign="top" class="table"><p class="table">2 red LEDs</p></td>
<td valign="top" class="table"><p class="table">Adafruit (297)</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Barrel jack plug</p></td>
<td valign="top" class="table"><p class="table">DC power jack with flying leads, 12V cigarette lighter adapter, or 5V USB adaptor and lead</p></td>
<td valign="top" class="table"><p class="table">Adafruit (80), eBay</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Right-angle header pins</p></td>
<td valign="top" class="table"><p class="table">12-way right-angle header pins</p></td>
<td valign="top" class="table"><p class="table">eBay</p></td>
</tr>
</tbody>
</table>
<p class="indent">We are using right-angle pins rather than straight header pins as right-angle pins make it a little easier to solder wires and component leads to this project.</p>
<p class="indent">Look for an FM radio that has a Tune button that moves from one station to the next and a Reset button that starts from the beginning of the FM wave band. The radio I used cost less than $2, including in-ear headphones.</p>
<p class="indent">The Arduino and speakers both require power. Although I have suggested using the barrel jack, you could just as easily use the USB port to power the Arduino. By now, you should be used to figuring out the most convenient way to power low-voltage devices from a 12V battery.</p>
<h4 class="h4" id="ch00lev1sec188"><strong>CONSTRUCTION</strong></h4>
<p class="noindent">This project assumes the radio uses an SC1088 integrated circuit. This extremely low-cost chip is used in most very cheap radios, which seem to use the reference design specified in the datasheet for the chip. (Just search for “SC1088 datasheet” online; you should turn up a PDF in the first few results.) The wiring diagram is shown in <a href="ch10.html#ch10fig6">Figure 10-6</a>. It shows the Arduino being powered from the DC jack, but it could equally well be powered by the USB port.</p>
<div class="image"><a id="page_190"/><img src="graphics/f10-06.jpg" alt="image"/></div>
<p class="figuret"><a id="ch10fig6">Figure 10-6:</a> Radio scanner wiring diagram. The numbers 15 and 16 on the SC1088 radio indicate pin numbers of the chip.</p>
<p class="indent">The “tune” and “reset” pins of the SC1088 IC are designed to be connected to momentary pushbuttons that short these pins to the chip’s 3V supply rail. You can see this configuration in the datasheet’s reference schematic. When pushbuttons are not shorting the input pins to the supply rail, they are pulled down to ground by variable resistances that are set inside the chip. We can emulate the functionality of the pushbutton by connecting these pins to ~3V when we want to simulate a button push, and by leaving the pin <em>floating</em> (not being driven high or low) when we want to simulate a button waiting to be pressed. To make the pin float, we can set the Arduino pin that is driving it to an input. When acting as an input, an I/O pin is said to be <em>high impedance</em>, meaning that the pin looks like an open circuit to anything that is attached to it.</p>
<p class="indent">To convert the 5V of the Arduino output pins to 3V, we place red LEDs between the Arduino pin and the SC1088. These drop the 5V to about 3.3V, the same level as supplied to the chip. The LEDs will also glow very slightly when activated, letting you know when the project is in operation.</p>
<h5 class="h5" id="ch00lev1sec189"><a id="page_191"/><strong>STEP 1: DISASSEMBLE THE RADIO</strong></h5>
<p class="noindent">First, take the radio apart. How to do this will depend on how your radio is put together. For mine, I just undid two screws and the whole thing came apart. <a href="ch10.html#ch10fig7">Figure 10-7</a>a shows the radio in its original state and 10-7b after removal of the case.</p>
<div class="image"><img src="graphics/f10-07.jpg" alt="image"/></div>
<p class="figuret"><a id="ch10fig7">Figure 10-7:</a> taking the radio apart</p>
<p class="indent">Take the button cell battery out because we are going to use the Arduino to supply power to the radio.</p>
<h5 class="h5" id="ch00lev1sec190"><strong>STEP 2: IDENTIFY THE CONNECTION POINTS</strong></h5>
<p class="noindent">Now we need to identify the points where we need to attach wires and LED leads. <a href="ch10.html#ch10fig8">Figure 10-8</a> shows the underside of the radio’s circuit board.</p>
<p class="indent">Start by identifying the location of the Scan and Reset switches. The pins for these will form a rectangle. The pins are connected in pairs, so both of the solder points labeled <em>A</em> are actually connected, as are the pair of points labeled <em>B</em>.</p>
<div class="image"><a id="page_192"/><img src="graphics/f10-08.jpg" alt="image"/></div>
<p class="figuret"><a id="ch10fig8">Figure 10-8:</a> The radio PCB</p>
<p class="indent">The A connections are for the Reset button. If you follow the track on the PCB, you will see that one of the A pins connects to pin 16 of the SC1088 (IC pins are numbered 1 to 16 counterclockwise, with a little dot on the IC package next to pin 1).</p>
<p class="indent">Following the track from B, you can see that one pin connects to pin 15 of the SC1088. This is the connection that we will use to scan for the next station.</p>
<p class="indent">If you’re finding it hard to see where the tracks run, use your multimeter set to continuity mode to identify the pins. Press one probe to the IC pin you want to find a connection for (15 or 16) and then try the different likely connections on the switches with the other probe until the buzzer on the multimeter sounds.</p>
<p class="indent">Next, find the two connections needed to power the radio from the Arduino, which correspond to the battery holder connections on the PCB. The 3V batteries the radio takes have a negative central connection (C) and positive connections to the outside frame of the battery holder (D).</p>
<h5 class="h5" id="ch00lev1sec191"><a id="page_193"/><strong>STEP 3: ATTACH THE HEADER STRIP</strong></h5>
<p class="noindent">I have suggested a right-angle header strip here, because it’s easier to solder the wires to, but regular header pins work almost as well. Break off a length of 12 pins and attach them to the Arduino pins 3.3V through to A5 (<a href="ch10.html#ch10fig9">Figure 10-9</a>). One pin will sit between the two header sockets, unconnected to anything.</p>
<div class="image"><img src="graphics/f10-09.jpg" alt="image"/></div>
<p class="figuret"><a id="ch10fig9">Figure 10-9:</a> The Arduino header pins</p>
<h5 class="h5" id="ch00lev1sec192"><strong>STEP 4: LINK THE RADIO TO THE ARDUINO</strong></h5>
<p class="noindent"><a href="ch10.html#ch10fig10">Figure 10-10</a> shows the radio connected to the Arduino. Use short wires to connect the 3.3V Arduino pin to the positive battery connection, point D, that you identified earlier. Connect an Arduino GND connection (it doesn’t matter which one) to point C, the negative battery connection. Connect the positive (longer) lead of one LED to Arduino pin A0 and the negative lead of that same LED to point B. Do the same with another LED to Arduino pin A1 and point A on the radio PCB.</p>
<div class="image"><a id="page_194"/><img src="graphics/f10-10.jpg" alt="image"/></div>
<p class="figuret"><a id="ch10fig10">Figure 10-10:</a> The Arduino connected to the radio</p>
<h5 class="h5" id="ch00lev1sec193"><strong>STEP 5: CONNECT EVERYTHING TOGETHER</strong></h5>
<p class="noindent">Finally, plug the powered speakers into the radio’s audio jack. You can test this using the headphones first. The radio uses headphones or an audio lead as an antenna, so you may get better results with a longer lead of a few feet than with a very short lead.</p>
<h4 class="h4" id="ch00lev1sec194"><strong>SOFTWARE</strong></h4>
<p class="noindent">All the source code for this book is available from <em><a href="http://www.nostarch.com/zombies/">http://www.nostarch.com/zombies/</a></em>. See <a href="app03.html#app03">Appendix C</a> for instructions on installing the Arduino sketch.</p>
<p class="indent">The Arduino sketch for this project is called <em>Project_18_Scanner</em>, and I’ll walk you through it now.</p>
<p class="indent">The sketch starts by defining several constants:</p>
<p class="programs">const int scanPin = A0;<br/>const int resetPin = A1;const int pulseLength = 1000;<br/>const int period = 5000;<br/>const int numStations = 5;</p>
<p class="indent"><a id="page_195"/>The <span class="literal">scanPin</span> and <span class="literal">resetPin</span> constants define the two Arduino pins we’ll use, and <span class="literal">pulseLength</span> defines the length of the simulated button press. The scan buttons needs to be pressed for a full 1,000 milliseconds (1 second) for the radio to scan for the next station rather than simply move the frequency up a step, though this can vary depending on your radio.</p>
<p class="indent">The constant <span class="literal">period</span> tells the Arduino an amount of time, in milliseconds, to pause so you have time to register whether you are hearing a transmission or just white noise.</p>
<p class="indent">Next, we define a single global variable:</p>
<p class="programs">int count = 0;</p>
<p class="indent">This variable, called <span class="literal">count</span>, is used to keep track of the number of scans to make before resetting to the start of the FM band again.</p>
<p class="indent">The <span class="literal">setup</span> function initializes both pins as inputs (although as we shall see, this sketch is unusual in that it changes the pin mode of the pins after their first initialization).</p>
<p class="programs">void setup()<br/>{<br/>  pinMode(scanPin, INPUT);<br/>  pinMode(resetPin, INPUT);<br/>}</p>
<p class="indent">The <span class="literal">loop</span> function is where we actually scan for frequencies:</p>
<p class="programs">void loop()<br/>{<br/>  delay(period);<br/>  pinMode(scanPin, OUTPUT);<br/>  digitalWrite(scanPin, HIGH);<br/>  delay(pulseLength);<br/>  pinMode(scanPin, INPUT);<br/>  count ++;<br/>  if (count == numStations)<br/>  {<br/>    count = 0;<br/>    pinMode(resetPin, OUTPUT);<br/>    digitalWrite(resetPin, HIGH);<br/>    delay(pulseLength);<br/>    pinMode(resetPin, INPUT);<br/>  }<br/>}</p>
<p class="indent">First of all, the loop delays by the time specified in <span class="literal">period</span>. The function then sends a pulse to the scan pin to begin scanning. When the pulse has finished, the pin is set back as an input.</p>
<p class="indent"><a id="page_196"/>The <span class="literal">count</span> variable then increments, and when it has reached the maximum specified in <span class="literal">numStations</span>, a pulse is sent to the reset pin to start scanning from the beginning of the FM band again. During testing, setting <span class="literal">numStations</span> to 5 will allow you to check whether the project is working and finding different stations. However, after a zombie apocalypse, the airwaves should be pretty empty, so you may want to reduce this number to just 1, as any signal you happen across is bound to be transmitted by survivors (or perhaps smart zombies). If you discover any automated transmissions you want to ignore, like a distress beacon from your former boss or the murmurings of zombies inexplicably learning the rudiments of human language, change <span class="literal">numStations</span> to a value of one more than the number of stations you want to ignore.</p>
<h4 class="h4" id="ch00lev1sec195"><strong>USING THE RADIO SCANNER</strong></h4>
<p class="noindent">When you first turn everything on, you should hear static. After five seconds or so, the scan LED will glow very dimly, and the radio will scan for its first station. After five more seconds, it will move on to the next station, and so on, until you identify a human friend. Remember: safety in numbers—not hordes.</p>
<h3 class="h3" id="ch00lev1sec196"><strong>PROJECT 19: ARDUINO MORSE CODE BEACON</strong></h3>
<p class="noindentb">Morse code is a 19th-century invention that allows you to send messages using a series of long or short pulses of light or sound. Each letter of the alphabet is made up of dots and dashes, where a dot is a short pulse and a dash is a long pulse (three times longer than a dot). For example, the letter <em>z</em> is represented as this:</p>
<p class="programs1b"><span class="codestrong">z<br/><br/>--..</span></p>
<p class="noindenttb">And the word <em>zombie</em> would be this:</p>
<p class="programs1b"><span class="codestrong">zombie<br/><br/>--.. --- -- -...   .. .</span></p>
<p class="indentt">Morse code uses shorter sequences of dashes and dots for the more commonly used letters, so <em>e</em>, as the most common letter used in the English language, is just a single dot. If you are interested, you can search online for the complete Morse code, though the software in this project will translate your message into Morse code for you. Take a look at the code for a table of Morse codes.</p>
<p class="indent"><a id="page_197"/>This Arduino-based project uses 12V LED lamps, like those you used back in “<a href="ch03.html#ch00lev1sec56">Project 3: LED Lighting</a>” on <a href="ch03.html#page_49">page 49</a>, to flash a message to any other survivors in visual range. It’s especially effective at night. <a href="ch10.html#ch10fig11">Figure 10-11</a> shows the finished project.</p>
<div class="image"><img src="graphics/f10-11.jpg" alt="image"/></div>
<p class="figuret"><a id="ch10fig11">Figure 10-11:</a> A Morse code beacon</p>
<h4 class="h4" id="ch00lev1sec197"><strong>WHAT YOU WILL NEED</strong></h4>
<p class="noindentb">To make this project, you will need the following parts:</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="100%">
<thead>
<tr>
<th valign="top" class="table_th"><p class="table1"><strong>ITEMS</strong></p></th>
<th valign="top" class="table_th"><p class="table1"><strong>NOTES</strong></p></th>
<th valign="top" class="table_th"><p class="table1"><strong>SOURCE</strong></p></th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Arduino</p></td>
<td valign="top" class="table"><p class="table">Arduino Uno R3</p></td>
<td valign="top" class="table"><p class="table">Adafruit, Fry’s (7224833), Sparkfun</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Screwshield</p></td>
<td valign="top" class="table"><p class="table"> </p></td>
<td valign="top" class="table"><p class="table">Adafruit (196)</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> 1 kΩ resistor</p></td>
<td valign="top" class="table"><p class="table"> </p></td>
<td valign="top" class="table"><p class="table">Mouser (293-1k-RC)</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> MOSFET</p></td>
<td valign="top" class="table"><p class="table">FQP33N10 MOSFET</p></td>
<td valign="top" class="table"><p class="table">Adafruit (355)</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> MR16 LED lamps</p></td>
<td valign="top" class="table"><p class="table">12V 3W</p></td>
<td valign="top" class="table"><p class="table">Hardware store</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> MR16 lamp sockets</p></td>
<td valign="top" class="table"><p class="table">Sockets with trailing leads</p></td>
<td valign="top" class="table"><p class="table">Hardware store</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Terminal block</p></td>
<td valign="top" class="table"><p class="table">2-way terminal block</p></td>
<td valign="top" class="table"><p class="table">Home Depot, Lowe’s, Menards</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> 9V Arduino battery lead</p></td>
<td valign="top" class="table"><p class="table">DC power jack with flying leads or 12V cigarette lighter adapter</p></td>
<td valign="top" class="table"><p class="table">DC power supply</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Wire</p></td>
<td valign="top" class="table"><p class="table">Bell cable (or other cable)</p></td>
<td valign="top" class="table"><p class="table"> </p></td>
</tr>
</tbody>
</table>
<p class="indent"><a id="page_198"/>It is best to use a fresh Arduino and screwshield for this project, both because it will be situated away from your main setup and because your screwshield from previous projects is probably pretty full by now. This project will be powered by its own solar power supply and battery (refer to “<a href="ch02.html#ch00lev1sec33">Project 1: Solar Recharging</a>” on <a href="ch02.html#page_26">page 26</a>).</p>
<p class="indent">I used three LED lights, but if you want more lamps, just add more in parallel. The transistor used to switch the lights is capable of switching up to 20W of lighting but only with a heatsink, so your combined wattage should be kept below 10W. If you made “<a href="ch03.html#ch00lev1sec56">Project 3: LED Lighting</a>” on <a href="ch03.html#page_49">page 49</a>, I would just use the same LEDs.</p>
<h4 class="h4" id="ch00lev1sec198"><strong>CONSTRUCTION</strong></h4>
<p class="noindent">The layout for the screwshield and wiring schematic are shown in <a href="ch10.html#ch10fig12">Figure 10-12</a>.</p>
<div class="image"><img src="graphics/f10-12.jpg" alt="image"/></div>
<p class="figuret"><a id="ch10fig12">Figure 10-12:</a> Screwshield layout and wiring schematic for the Morse code beacon</p>
<h5 class="h5" id="ch00lev1sec199"><a id="page_199"/><strong>STEP 1: ASSEMBLE THE SCREWSHIELD</strong></h5>
<p class="noindent">Assemble the screwshield following the instructions in “<a href="app03.html#ch00lev1sec254">Assembling a Screwshield</a>” on <a href="app03.html#page_259">page 259</a>.</p>
<h5 class="h5" id="ch00lev1sec200"><strong>STEP 2: SOLDER THE COMPONENTS ONTO THE SCREWSHIELD</strong></h5>
<p class="noindent">You only need to solder two components for this project: a resistor and metal oxide semiconductor field effect transistor (MOSFET). MOSFETs are great for switching fairly high-power loads quickly.</p>
<p class="indent">Solder the resistor and transistor in place according to the circuit schematic. When soldering the transistor, make sure you place it so that the metal tab faces to the right (<a href="ch10.html#ch10fig12">Figure 10-12</a>). When the components are soldered into place, the assembly should like <a href="ch10.html#ch10fig13">Figure 10-13</a>.</p>
<div class="image"><img src="graphics/f10-13.jpg" alt="image"/></div>
<p class="figuret"><a id="ch10fig13">Figure 10-13:</a> The top of the screwshield</p>
<h5 class="h5" id="ch00lev1sec201"><strong>STEP 3: WIRE THE UNDERSIDE OF THE SCREWSHIELD</strong></h5>
<p class="noindent">Once the components are secured in place, use their excess leads to make the connections on the underside (<a href="ch10.html#ch10fig14">Figure 10-14</a>). Before soldering the resistor lead that connects to pin 13 on the Arduino, add some insulation to avoid causing short circuits with the 5V and GND tracks it crosses over.</p>
<div class="image"><a id="page_200"/><img src="graphics/f10-14.jpg" alt="image"/></div>
<p class="figuret"><a id="ch10fig14">Figure 10-14:</a> The underside of the screwshield</p>
<h5 class="h5" id="ch00lev1sec202"><strong>STEP 4: CONNECT THE LAMPS</strong></h5>
<p class="noindent">If you want to keep this simple, you can just use a single LED lamp. For a wider range of visibility, however, connect a few LED lamps and point them in different directions (<a href="ch10.html#ch10fig15">Figure 10-15</a>).</p>
<div class="image"><img src="graphics/f10-15.jpg" alt="image"/></div>
<p class="figuret"><a id="ch10fig15">Figure 10-15:</a> The lamp assembly</p>
<p class="indent"><a id="page_201"/>In <a href="ch10.html#ch10fig15">Figure 10-15</a>, I’ve fixed three lamp sockets to a bit of wood and connected all three 12V LED lamps to the terminal block. Lamps of this type usually include a circuit that allows the wires to be connected any way around, but if your modules have a polarity marked on them with a + and –, you need to make sure all the + connections are connected to one terminal of the terminal block and the – connections go to the other. The lamp holders will have holes allowing them to be attached to the wood with screws.</p>
<h5 class="h5" id="ch00lev1sec203"><strong>STEP 5: FINAL WIRING</strong></h5>
<p class="noindent">Use some bell cable or other wire to connect the lamp assembly to the <em>X</em> and <em>V<sub>in</sub></em> terminals on the screwshield. Stranded wire is best, as it’s less liable to break. Make this wire as long as you need it (but above 50 ft, or 15 m, there might be some reduction in brightness): you may want to site the lamp assembly high up outside, to make it easier for people to see your message, while leaving the Arduino in the safety of your bunker. Remember to waterproof the lamp assembly—sealing it in a transparent plastic bag will do the trick.</p>
<p class="indent">To connect power to the Arduino, use either a cigarette lighter adapter or a custom lead using alligator clips and a barrel jack plug with flying leads to connect the Arduino to a 12V solar power supply or battery. Note that this project requires 12V for the lamps, so you cannot use a 5V USB lead to power the Arduino.</p>
<h4 class="h4" id="ch00lev1sec204"><strong>SOFTWARE</strong></h4>
<p class="noindent">All the source code for this book is available via <em><a href="http://www.nostarch.com/zombies/">http://www.nostarch.com/zombies/</a></em>. See <a href="app03.html#app03">Appendix C</a> for instructions on installing the Arduino sketch. The Arduino sketch for this project is called <em>Project_19_Morse_Beacon</em>.</p>
<p class="indent">The sketch uses the Ardiuno’s built-in <em>EEPROM</em> library. The Morse code message is stored in EEPROM memory every time a change is made, meaning that the beacon can remember the message even if power to the Arduino is interrupted. The sketch also makes use of a library from the Arduino community called <em>EEPROMAnything</em>, which makes saving to and reading from EEPROM easier. The code for EEPROMAnything is included in the download for this project, so there is nothing to download separately.</p>
<p class="indent">First, we load both the official Arduino EEPROM library and EEPROMAnything:</p>
<p class="programs">#include &lt;EEPROM.h&gt;<br/>#include "EEPROMAnything.h"</p>
<p class="indent"><a id="page_202"/>A number of constants are used to control the project:</p>
<p class="programs">const int ledPin = 13;<br/>const int dotDelay = 100; // milliseconds<br/>const int gapBetweenRepeats = 10; // seconds<br/>const int maxMessageLen = 255;</p>
<p class="indent">The pin that controls the LEDs is specified in <span class="literal">ledPin</span>. The constant <span class="literal">dotDelay</span> defines in milliseconds the duration of a dot flash. Dashes are always three times the duration of a dot.</p>
<p class="indent">The constant <span class="literal">gapBetweenRepeats</span> specifies in seconds the time that will elapse between each repetition of the message, and <span class="literal">maxMessageLen</span> specifies the maximum length, in letters rather than dots and dashes, of the message. A maximum size is specified because in Arduino code, you have to declare the size of arrays.</p>
<p class="indent">Two global variables are used:</p>
<p class="programs">char message[maxMessageLen];<br/>long lastFlashTime = 0;</p>
<p class="indent">The <span class="literal">message</span> variable will contain the text of the message to be flashed, and <span class="literal">lastFlashTime</span> keeps track of when the message was last flashed, to allow a break between the repeats.</p>
<p class="indent">Two global <span class="literal">char</span> arrays are used to contain the dot and dash sequences for Morse code. The program will only flash characters that it knows how to send, that is letters, digits, or a space character. All other characters in the message are ignored.</p>
<p class="programs">char* letters[] = {<br/>  ".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..",   // A-I<br/>  ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", // J-R<br/>  "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."         // S-Z<br/>};<br/><br/>char* numbers[] = {"-----", ".----", "..---", "...--", "....-", ".....",<br/>"-....", "--...", "---..", "----."};</p>
<p class="indent">The <span class="literal">setup</span> function sets the <span class="literal">ledPin</span> as an output and then starts serial communication at <span class="literal">Serial.begin</span>:</p>
<p class="programs">void setup()<br/>{<br/>  pinMode(ledPin, OUTPUT);<br/>  Serial.begin(9600);<br/>  Serial.println("Ready");<br/>  EEPROM_readAnything(0, message);<br/><a id="page_203"/><br/>  if (! isalnum(message[0]))<br/>  {<br/>    strcpy(message, "SOS");<br/>  }<br/>  flashMessage();<br/>}</p>
<p class="indent">Serial communication is used to set a new message, either using the serial monitor of the Arduino IDE or, as you will see in “<a href="ch10.html#ch00lev1sec205">Using the Morse Beacon</a>” on <a href="ch10.html#page_205">page 205</a>, a terminal program running on a Raspberry Pi.</p>
<p class="indent">Every time the message is changed, it is saved in EEPROM, so during the setup process, the sketch reads any stored message from EEPROM. If no message has been set, the <span class="literal">if</span> statement in <span class="literal">setup</span> sets the default message to “SOS.” Finally, at <span class="literal">flashmessage</span>, the setup function flashes the message for the first time.</p>
<p class="indent">The <span class="literal">loop</span> function first checks whether a new message has been sent over the serial connection:</p>
<p class="programs">void loop()<br/>{<br/>  if (Serial.available())      // Is there anything to be read from USB?<br/>  {<br/>    int n = Serial.readBytesUntil('\n', message, maxMessageLen-1);<br/>    message[n] = '\0';<br/>    EEPROM_writeAnything(0, message);<br/>    Serial.println(message);<br/>    flashMessage();<br/>  }<br/>  if (millis() &gt; lastFlashTime + gapBetweenRepeats * 1000L)<br/>  {<br/>    flashMessage();<br/>  }<br/>}</p>
<p class="indent">Any new message is read into the <span class="literal">message</span> character array until the newline character (<span class="literal">\n</span>) is read. The null character <span class="literal">’\0’</span> is added to the end of the message. This is the Arduino’s way of indicating the end of a string of characters. Once the whole message has been read through, it is saved into EEPROM (<span class="literal">EEPROM_writeAnything</span>), and then the new message begins flashing immediately.</p>
<p class="indent">The remainder of the <span class="literal">loop</span> function checks whether enough time has passed before it can repeat the message. This could be done more simply using <span class="literal">delay</span>, but we would be unable to interrupt the loop if a new message arrived during the <span class="literal">delay</span>.</p>
<p class="indent"><a id="page_204"/>The <span class="literal">flashMessage</span> function is the most complex function in the sketch.</p>
<p class="programs">void flashMessage()<br/>{<br/>  Serial.print("Sending: ");<br/>  Serial.println(message);<br/>  int i = 0;<br/>  while (message[i] != '\0' &amp;&amp; i &lt; maxMessageLen)<br/>  {<br/>    if (Serial.available()) return; // new message <br/>    char ch = message[i];<br/>    i++;<br/>    if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z')<br/>    {<br/>      flashSequence(letters[ch - 'a']);<br/>    }<br/>    else if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z')<br/>    {<br/>      flashSequence(letters[ch - 'A']);<br/>    }<br/>    else if (ch &gt;= '0' &amp;&amp; ch &lt;= '9')<br/>    {<br/>      flashSequence(numbers[ch - '0']);<br/>    }<br/>    else if (ch == ' ')<br/>    {<br/>     delay(dotDelay * 4);      // gap between words <br/>    }<br/>  }<br/>  lastFlashTime = millis();<br/>}</p>
<p class="indent">The <span class="literal">flashMessage</span> function starts by echoing the message it is about to send to reassure you that it is sending what you want it to. It then loops over every character in the message. Before each character, it uses <span class="literal">Serial.available</span> to check for a new message. If a new message has come in, the function stops sending its message in order to receive the new message from your computer or Raspberry Pi; then it begins sending the new message instead.</p>
<p class="indent">The <span class="literal">flashMessage</span> function determines whether the character is an uppercase letter, a lowercase letter, a number, or the space character and then takes the appropriate action.</p>
<p class="indent">If the character is a lowercase letter, the index position of the sequence of dots and dashes held in the letters array is provided as a parameter to the <span class="literal">flashSequence</span> function, which then flashes those dots and dashes. The other options are handled in the same way.</p>
<p class="indent">Finally, when the whole message has been sent, the <span class="literal">lastFlashTime</span> variable is set to the current time so the loop function can work out when it is time to start flashing the message again.</p>
<p class="indent"><a id="page_205"/>The work of flashing the sequence of dots and dashes for a particular character is handled by the <span class="literal">flashSequence</span> function:</p>
<p class="programs">void flashSequence(char* sequence)<br/>{<br/>   int i = 0;<br/>   while (sequence[i] != NULL)<br/>   {<br/>       flashDotOrDash(sequence[i]);<br/>       i++;<br/>   }<br/>   delay(dotDelay * 3);    // gap between letters<br/>}</p>
<p class="indent">This loops over each dot or dash, calling <span class="literal">flashDotOrDash</span>:</p>
<p class="programs">void flashDotOrDash(char dotOrDash)<br/>{<br/>  digitalWrite(ledPin, HIGH);<br/>  if (dotOrDash == '.')<br/>  {<br/>    delay(dotDelay); <br/>  }<br/>  else // must be a -<br/>  {<br/>    delay(dotDelay * 3); <br/>  }<br/>  digitalWrite(ledPin, LOW); <br/>  delay(dotDelay); // gap between flashes<br/>}</p>
<p class="indent">The <span class="literal">flashDotOrDash</span> function uses the appropriate delay period to flash a dot or dash.</p>
<h4 class="h4" id="ch00lev1sec205"><strong>USING THE MORSE BEACON</strong></h4>
<p class="noindent">Upload the sketch to your Arduino and power up the project. The default message should start to flash. If it doesn’t, go back and check over all your wiring. To change the message, attach your Arduino to your computer, open the serial monitor on the Arduino IDE, and type in a new message (<a href="ch10.html#ch10fig16">Figure 10-16</a>).</p>
<div class="image"><img src="graphics/f10-16.jpg" alt="image"/></div>
<p class="figuret"><a id="ch10fig16">Figure 10-16:</a> Changing the message using the serial monitor</p>
<p class="indent"><a id="page_206"/>Here, the current message, “There are survivors here,” should change to “Watch out zombies about” when the Send button is pressed.</p>
<p class="indent">If you prefer to use your Raspberry Pi to change the message, install the terminal program <span class="literal">screen</span> (your Raspberry Pi will need an Internet connection):</p>
<p class="programsb">$ <span class="codestrong">sudo apt-get install screen</span></p>
<p class="indent">Once <span class="literal">screen</span> is installed, connect the USB lead between your Raspberry Pi and the Arduino and then enter the following command on your Raspberry Pi:</p>
<p class="programsb">$ <span class="codestrong">screen /dev/ttyACM0 9600</span></p>
<p class="indent">At this point, anything you type should be sent to the Arduino, and any messages coming from the Arduino should be displayed. <a href="ch10.html#ch10fig17">Figure 10-17</a> shows the message being changed using <span class="literal">screen</span>. Note that the message will not appear on the screen as you type it but only after you press <span class="literal">ENTER</span>.</p>
<div class="image"><img src="graphics/f10-17.jpg" alt="image"/></div>
<p class="figuret"><a id="ch10fig17">Figure 10-17:</a> Changing the message using the <span class="codestrong">screen</span> command</p>
<p class="indent">Once the message has been changed, the Arduino will remember it, so you can unplug the Arduino to get ready for installation. Unplugging the Arduino will quit the <span class="literal">screen</span> command by closing the serial connection to the Raspberry Pi.</p>
<p class="indent">Now just attach your project to your desired location, preferably one with 360-degree visibility, and start blinking your message. <a href="ch10.html#ch10fig18">Figure 10-18</a> shows the project fixed to my zombie-proof shed.</p>
<div class="image"><a id="page_207"/><img src="graphics/f10-18.jpg" alt="image"/></div>
<p class="figuret"><a id="ch10fig18">Figure 10-18:</a> Installing the Morse beacon</p>
<p class="indent">If you want to conserve power, only use your beacon at night, when it is most likely to be spotted. But beware: popular culture gives us mixed messages on whether zombies are attracted to flashing lights. You may want to reinforce your stronghold before sending out messages, just in case.</p>
<p class="indent">In <a href="ch11.html#ch11">Chapter 11</a>, we will continue with the theme of communication. For the final project of this book, we’ll build a pair of haptic communication devices that will allow you and a fellow survivor to communicate silently, without alerting zombies to your presence.<a id="page_208"/></p>
</body></html>