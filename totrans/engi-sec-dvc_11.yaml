- en: '**8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SECURE BOOT AND SYSTEM INTEGRITY**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'During the boot process of embedded systems, the initialization of basic hardware
    as well as the startup of an OS take place. Many of these steps involve firmware
    stored in flash memory since that provides device engineers with the possibility
    to update. However, this replaceability comes at a price: attackers are able to
    tamper with that data for their own advantage.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll explain the complexity of boot processes and various protection
    concepts. After introducing the classic secure boot chain concept, I’ll discuss
    practical considerations like the impact of secure boot process on development
    and production processes. As usual, theory and practice are not one and the same,
    so I’ll include a case study on implementing secure boot on the STM32MP157F platform.
  prefs: []
  type: TYPE_NORMAL
- en: Based on boot process integrity, you might wonder whether device integrity can
    be taken further, so this chapter also describes how to achieve integrity protections
    for filesystems and more. Finally, I’ll look at a low-cost firmware integrity
    solution for microcontroller-based systems that don’t rely on external flash memory
    and a complex boot process.
  prefs: []
  type: TYPE_NORMAL
- en: '**System Boot Complexity**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many modern microchips for embedded systems contain a variety of submodules
    and are therefore called *system-on-chips (SoCs)*. In addition to the availability
    of multiple CPU cores, GPUs, real-time cores, and similar supporting coprocessors
    contribute to a system’s complexity. Also, SoCs that include an FPGA continue
    to gain popularity and add bitstream handling to the equation.
  prefs: []
  type: TYPE_NORMAL
- en: Further, some SoCs provide a *trusted execution environment (TEE)*, which is
    used to separate the execution of critical software logically or physically—on
    a dedicated processing unit—from the ordinary firmware. In ARM-based SoCs, you’ll
    come across the terms *ARM TrustZone* and *ARM Trusted Firmware* that represent
    ARM’s TEE. The initialization of such an environment often takes place during
    the boot process. And, although those features aim for higher security, it can’t
    be denied that these technologies also lead to even more complexity—the natural
    enemy of intelligibility and security.
  prefs: []
  type: TYPE_NORMAL
- en: SoC devices also usually require further components on the PCB—for example,
    volatile double data rate (DDR) memory and nonvolatile storage, such as an embedded
    MultiMediaCard (eMMC) or similar flash memories. Initialization of necessary on-chip
    controllers and their parameters are further crucial parts of modern boot processes.
    [Figure 8-1](ch08.xhtml#ch08fig01) gives an overview of typical software and hardware
    components of an SoC involved in its boot process.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: The components of a typical SoC boot process*'
  prefs: []
  type: TYPE_NORMAL
- en: After power up, the boot procedure is initiated in hardware based on a boot
    read-only memory (ROM) ➊ that initializes internal structures and loads a minimalist
    first-stage bootloader (FSBL) like U-Boot SPL that’s copied to internal SRAM memory
    ➋. This piece of software initializes the external DDR memory and places a fully-fledged
    second-stage bootloader (SSBL) there ➌. The SSBL is able to provide several convenience
    features like boot medium selection, debugging, console access, and more. Afterward,
    the OS kernel, which in the embedded system context is often Linux, is started
    ➍. At this point, the boot process is “officially” over, and the device is in
    its runtime state.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-2](ch08.xhtml#ch08fig02) shows the necessary steps for booting in
    temporal order.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-2: The steps of a typical boot process*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one basic property to highlight at this point: subsequent stages in
    a boot process always “trust” their predecessors. That means, for example, without
    external monitoring measures, an OS can’t tell a malicious boot-loader from the
    original one; it just relies on every configuration set and the parameters passed
    to it. Therefore, optimal boot-process protection has to start at its very beginning:
    in hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Boot Protection Concepts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From the perspective of a customer or a device user, integrity is usually a
    desired protection goal for a device’s firmware and software. One relevant risk
    scenario is that cybercriminals try to persist malicious software in firmware
    to survive a reboot of the system—for example, to enable long-lasting backdoor
    access. Also, the manipulation of low-level configuration parameters and OS settings
    wouldn’t be possible with verification routines running at boot time. Even attacks
    that modify a device’s software during delivery, as reported to be performed by
    intelligence services, would render a product nonfunctional if solid integrity
    protection is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: The authors of IEC 62443 (Part 4-2) also seem to have these scenarios in mind.
    The embedded device requirement (EDR) 3.14 for security level (SL) 1 or higher
    aims for integrity of the boot process. It requests that a device must be able
    to perform integrity verification of the firmware, software, and configuration
    data used in the device’s boot and runtime processes prior to their execution.
    Starting at SL 2, the standard even requires authenticity of all replaceable parts
    of the boot process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Device manufacturers usually agree on the importance of integrity and authenticity
    of firmware and software because that also prevents attackers from installing
    custom software for reverse-engineering purposes. However, they have another risk
    to consider: loss of intellectual property. Even at early boot stages, such know-how
    might be cast in software, like optimized algorithms, proprietary protocols, and
    secrets. Therefore, in some cases, vendors would like to encrypt all firmware,
    software, and configuration data used during the boot process in order to protect
    their confidentiality.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third stakeholder in this game is the chip-manufacturing industry that
    provides several protection measures advertised by associated marketing terms.
    The following list provides an overview of typical keywords, but of course, it
    might not capture all future marketing creativity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Secure boot**    This generic term is the “classic” and most popular one.
    It usually stands for the step-by-step verification of integrity and authenticity
    of software components used throughout the boot process. From a cryptographic
    point of view, the verification is based on digital signatures and asymmetric
    algorithms like RSA or ECDSA. Whenever a signature verification fails, the boot
    process stops. Its details are explained in “Classic Secure Boot Chain” on [page
    145](ch08.xhtml#ch00lev1_65).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Verified boot**    Similar to secure boot, this term stresses the cryptographic
    verification of the software parts executed in the boot chain. Intel uses this
    term, among others, as part of its Boot Guard technology, and Google utilizes
    it for Android and Chrome OSs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**High-assurance boot**    NXP works with this label to highlight boot-process
    protection for i.MX devices. Among other protections, this approach also uses
    digital signatures to verify integrity and authenticity as described by secure
    boot.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authenticated boot**    This term might seem to express the authentication
    of firmware and other software components. However, the Trusted Computing Group
    (TCG) uses this term to describe a boot process that allows for reporting “an
    accurate record of the way that the platform booted.” That means pieces of software
    are hashed during the boot process and written to a TPM. The startup procedure
    is not interrupted if manipulated software is to be executed, but the later state,
    be it original or altered, can be reported to an external party or used by the
    TPM to grant or deny access to stored secrets.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Measured boot**    Microsoft uses this term in the context of TPM-based boot
    protection in which software is *measured*, or hashed, during the boot process.
    It’s similar to TCG’s authenticated boot.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trusted boot**    This is sometimes found in close relation to TPM-protected
    boot processes. However, Microsoft also uses it to describe the verification of
    the Windows kernel and OS components.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encrypted boot**    In contrast to all other listed forms of boot protection,
    this concept aims for confidentiality. In this case, firmware and related software
    are stored in an encrypted way, usually based on symmetric encryption algorithms.
    The decryption happens on the fly during boot and is usually supported by hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Be careful whenever it comes to marketing terms for boot process protection.
    They can be misleading and sometimes implement only part of what you expect!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Classic Secure Boot Chain**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For embedded devices, the most important variant of boot-process protection
    is the classic secure boot chain in which every component involved in the boot
    process verifies the next before handing over execution. Therefore, integrity
    and authenticity of all the software parts in a boot process can be achieved,
    which are often desirable requirements for several stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-3](ch08.xhtml#ch08fig03) shows a linear secure boot process from
    power up in hardware up to the point when the OS is running.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-3: The steps in a classic secure boot process*'
  prefs: []
  type: TYPE_NORMAL
- en: In comparison to [Figure 8-2](ch08.xhtml#ch08fig02), notice the set of additional
    keys at every stage. These are public keys based on asymmetric crypto like RSA
    or ECDSA, which means they don’t carry any secret but are necessary to verify
    the signature of the subsequent boot stage. For example, the DDR bootloader has
    to carry the public key related to the signature of the OS kernel executed in
    the following boot step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although these keys aren’t required to stay confidential, they have a very
    important protection goal to fulfill: integrity. The reason for that is simple.
    If an attacker is able to replace a public key, a self-generated one can be stored
    instead. By changing a verification key, it becomes possible to correctly verify
    a forged, self-generated signature of a manipulated piece of software, which would
    break the secure boot chain.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-4](ch08.xhtml#ch08fig04) shows how the involved public keys are stored
    in various places within an SoC. Most obviously, some of them are usually stored
    in flash memory, which is easy for attackers to manipulate.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-4: The SoC components involved in a secure boot process*'
  prefs: []
  type: TYPE_NORMAL
- en: The “trick” for handling this issue is that the integrity of the secure boot
    chain can be reduced to the integrity of the first verification key. If this initial
    key is stored in flash memory, the guarantees of the secure boot process hold
    only as long as an attacker is not able to alter this memory content.
  prefs: []
  type: TYPE_NORMAL
- en: Microchips supporting secure boot usually provide OTP memory to physically burn
    the first public key or its hash into the device. This key is then used during
    boot ROM execution ➊ to verify the FSBL. The key for SSBL verification is included
    in the FSBL ➋, and the SSBL carries the public key to verify the OS kernel ➌,
    reaching the integrity goal for the whole boot chain. This verification chain
    might even be extended to kernel modules or application software by integrating
    further public keys into the OS kernel ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Keep in mind that only a secure boot chain starting in ROM within an SoC is
    a robust protection against boot software manipulation, because all protection
    guarantees can be traced back to the beginning of the boot chain.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Considerations for Implementing Secure Boot**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unfortunately, the implementation of secure boot is not like activating a single
    option in a configuration menu, which is probably why secure boot on embedded
    systems is still uncommon in the market. However, the following details aren’t
    meant to scare developers away, but rather to serve as a list of tasks to keep
    in mind if you decide to take on secure boot.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hardware and Software Requirements***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, it’s important to understand that a consistent secure boot chain requires
    every part of that chain to support signature verification based on asymmetric
    crypto. Of course, that includes the chosen microcontroller running all software.
    If secure boot was not a requirement during chip purchase, integrating it afterward
    might not be possible.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to make secure boot a requirement during device architecture discussions.
    If the central microchip doesn’t support it, you’re forced to postpone the secure
    boot feature to the next device generation.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, if software components don’t support signature verification, as
    might be the case for certain bootloaders, and you can’t integrate the functionality
    yourself, you’ll need to start the possibly tedious process of finding and implementing
    suitable replacements.
  prefs: []
  type: TYPE_NORMAL
- en: At the far end of the boot process, verifying the operating system kernel as
    a final step might be enough. However, on Linux, for example, you might also want
    to verify integrity and authenticity of kernel modules, or even extend the verification
    process to filesystems and applications as discussed in “Integrity Protection
    Beyond the Boot Process” on [page 154](ch08.xhtml#ch00lev1_69).
  prefs: []
  type: TYPE_NORMAL
- en: But even if all your software already supports digital signature verification,
    several changes are necessary to incorporate secure boot, from hardware initialization
    to bootloader settings and maybe even OS kernel configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '***Development Process***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On the development side, the signature generation process (for example, within
    a CI pipeline), has to be established. Depending on the hardware and software
    used within the device, integrating vendor-specific tools, such as for signing
    and final image generation, might be necessary. If you’re lucky, the use of the
    `openssl` command line tool will be sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The image-signing process is crucial for secure boot implementation. However,
    it involves private keys that have a strong need for confidentiality protection.
    If they become compromised, authenticity and integrity for device software can
    no longer be guaranteed.*'
  prefs: []
  type: TYPE_NORMAL
- en: A common obstacle to overcome during development of devices protected by secure
    boot is the handling of test images and devices. Various approaches exist, all
    valid on their own for specific situations. On the one hand, you might want to
    perform early testing without any secure boot restrictions on completely open
    devices. However, you wouldn’t be able to discover issues related to secure boot.
    On the other hand, you might want to use one or more test signing keys on test
    devices to authenticate images meant for testing only. However, this bears the
    risk of unintentionally locking test devices with incorrect configurations or
    keys, which might turn them into electronic bricks.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, be careful when using different key pairs for testing and production
    use cases. If they get mixed up, test images (with additional tools or fewer restrictions)
    might verify correctly and run on devices in the field.
  prefs: []
  type: TYPE_NORMAL
- en: '***Production and Lifetime***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another area relevant for secure boot implementations is the production of devices.
    Since configuration data and keys have to be burned into OTP memory, the production
    process has to be adapted to enable secure boot. In-production testing of secure
    boot can also be a reasonable extension. Just imagine if all the previous steps
    were taken with great care and effort, but then the devices leave production with
    an incorrectly activated secure boot process that can be circumvented easily in
    the field. At best, that would be a motivational disaster for all security engineers,
    probably worse.
  prefs: []
  type: TYPE_NORMAL
- en: As if the task isn’t already complicated enough, secure boot implementations
    are also an attractive target for attackers and researchers. Therefore, the signing
    keys could get compromised in your development infrastructure, or vulnerabilities
    in hardware or firmware affecting boot process security could be found by external
    parties. Both cases lead to the necessity of replacing parts of the firmware with
    updated versions, maybe including a newly generated public verification key. A
    secure update functionality, as described in [Chapter 9](ch09.xhtml#ch09), as
    well as a solid key- and firmware-management process, are essential to handle
    these circumstances professionally.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Implementation of secure boot requires developers, IT environment administrators,
    and production engineers to work together. Make sure that device security is considered
    a common goal for all people involved.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Open Source Licenses vs. Secure Boot**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The possibility to nail down a specific software version to hardware is valuable
    for device manufacturers, but this game has another player: the free and open
    source software community.'
  prefs: []
  type: TYPE_NORMAL
- en: Around the year 2000, a company named TiVo developed a digital video recorder
    (DVR) that prevented the execution of modified software by users. TiVo not only
    was a secure boot pioneer but also attracted the attention of Richard Stallman
    and the Free Software Foundation (FSF). The DVR device was running software licensed
    under the GNU General Public License version 2 (GPLv2), like Linux, which was
    meant to enable users to run their own customized software. Since then, the term
    *tivoization* has been used to describe mechanisms that restrict or prohibit the
    execution of custom open source software on a device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this conflict, the FSF developed GPLv3, a license that makes the
    implicit claims of GPLv2 explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: The Corresponding Source conveyed under this section must be accompanied by
    the Installation Information. [. . .] Installation Information [. . .] means any
    methods, [. . .] authorization keys, [. . .] required to install and execute modified
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: While the Linux kernel and the popular embedded system bootloader U-Boot are
    available under GPLv2, other software like the GNU Grand Unified Bootloader (GRUB)
    is subject to GPLv3 and might lead to legal conflicts when implemented in a secure
    boot scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Clarifying the opposing goals of open source software licenses and secure boot
    protection for your individual case is absolutely necessary before going to market
    in order to save you quite some trouble.
  prefs: []
  type: TYPE_NORMAL
- en: 'It might seem not worth thinking about, but in some cases, developers seek
    a solution that satisfies both requirements: boot-process protection and the possibility
    to install modified software. One way to achieve such a compromise is to implement
    an unlock feature within the boot process. This feature allows the deactivation
    of secure boot verification in order to enable execution of custom (boot) software,
    but at the same time, the device has to ensure that all sensitive data, such as
    decryption keys, authenticators, and proprietary knowledge, are wiped from memory.
    This approach is already used by a variety of Android mobile phone vendors.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Case Study: Secure Boot Process on an STM32MP157F Device**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, I take a look at the specific boot-process protection measures
    of the STM32MP157F device and its corresponding software packages. However, keep
    in mind that this is a broad overview and not a step-by-step tutorial. A comprehensive
    secure boot implementation requires substantial efforts and a lot of fine-tuning.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Boot Process***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The microcontroller at hand exhibits a common boot-process complexity, as shown
    in [Figure 8-5](ch08.xhtml#ch08fig05).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-5: The boot chain of STM32MP157F devices*'
  prefs: []
  type: TYPE_NORMAL
- en: After power-up, the ROM code performs basic initialization of the platform,
    loads the FSBL to internal RAM, and hands over execution to the FSBL. In this
    case, the FSBL is the Boot Loader stage 2 (BL2) part of the Trusted Firmware-A
    (TF-A) provided by ARM. In a simple setup, this BL2 initializes the DDR memory
    of the device, loads the SSBL into it, and executes the SSBL. However, if use
    of ARM TrustZone is desired, the FSBL loads not only the SSBL but also the runtime
    software for the secure world, and then jumps to the SSBL afterward.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the STM32MP157F platform uses the popular embedded system bootloader
    U-Boot as the SSBL. U-Boot comes with a variety of features and is commonly used
    to boot embedded Linux kernels. Next, Linux takes over control, launches its kernel
    modules, services, and user-space applications, and concludes the boot process.
  prefs: []
  type: TYPE_NORMAL
- en: Another feature of STM32MP157F devices, also increasingly seen for other microcontroller
    products and manufacturers, is the availability of a coprocessor. Here, an additional
    ARM Cortex-M4 microcontroller with dedicated RAM is integrated to allow for the
    robust execution of real-time tasks, as discussed in [Chapter 10](ch10.xhtml#ch10).
    Loading firmware to this additional controller might also be part of the boot
    process. This can be initiated either directly by an SSBL like U-Boot or later,
    out of the running Linux OS.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers would stop here, use the platform as described, and be happy
    if the boot process “just works.” However, until now, no protection against modification
    of any firmware parts has been considered.
  prefs: []
  type: TYPE_NORMAL
- en: '***Secure Boot Starts in Hardware***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Robust secure boot concepts have to start in hardware. For this purpose, the
    ROM code needs to provide a verification routine that can be used to authenticate
    the FSBL image. Luckily, STM32MP157F devices have an integrated feature for that
    purpose. [Figure 8-6](ch08.xhtml#ch08fig06) shows an overview of the related key
    generation, signing, and authentication process.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-6: The firmware signing and provisioning process for STM32MP157F
    devices*'
  prefs: []
  type: TYPE_NORMAL
- en: The chip at hand utilizes the ECDSA algorithm to achieve integrity and authenticity
    of firmware images. In comparison to RSA, this enables faster signing and shorter
    keys, but the verification at boot time might take a bit longer. On the developers’
    side, the ECC key pair has to be generated by the STM32MP Key Generator tool,
    which results in a private key, a corresponding public key, and the SHA-256 hash
    of the public key. The latter is useful because it requires less OTP memory in
    the chip compared to storing the whole public key.
  prefs: []
  type: TYPE_NORMAL
- en: To prepare the device for secure boot, the public-key hash has to be burned
    into its fuse memory. This can be achieved in various ways. You can use the ST-provided
    STM32 Cube Programmer or the U-Boot `stm32key` command. Also, the secure secret
    provisioning (SSP) feature might be of interest to you because it establishes
    a protected channel between a programmer and the STM32MP157F device, making it
    especially useful for secure production purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The STM32MP157F device can be locked after writing the public-key hash to
    its OTP memory. This is mandatory for production but should be considered with
    caution during development.*'
  prefs: []
  type: TYPE_NORMAL
- en: After key provisioning in the device, the image has to be prepared for authenticated
    execution. Again, specific software, the STM32MP Signing Tool, is provided that
    processes the pre-generated ECDSA private key and the SHA-256 hash of the FSBL
    image in order to obtain the corresponding digital signature for this firmware
    part. The resulting image also contains the ECDSA public key and can be placed
    in the nonvolatile memory of the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'At boot time, the ROM code verifies the integrity and authenticity of the presented
    FSBL image. First, the provided public key is verified by comparing its hash to
    the one stored in OTP memory. If correct, the key is used to verify the validity
    of the stored signature and the hash of the provided image. If successful, the
    FSBL payload is executed, and `NOTICE: Bootrom authentication succeeded` is output
    to the console. In any other case, the boot process halts.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Secure Boot Based on BL2 TF-A***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the FSBL, STM32MP157F devices rely on ARM’s BL2 TF-A that also provides
    secure boot support. However, it’s disabled by default and has to be activated
    by setting the `TRUSTED_BOARD_BOOT=1` build flag. Afterward, the digital signatures
    of binaries loaded by BL2 are verified for integrity and authenticity based on
    asymmetric cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: The BL2 TF-A requires a firmware image package (FIP) that can be generated with
    the `fiptool` application. It contains all binaries to be loaded and executed
    and the cryptographic data necessary to verify these binaries. The binaries include,
    for example, an SSBL and a TEE implementation like OP-TEE that runs in the ARM
    TrustZone. The TEE is denoted as BL32, and the SSBL is known as BL33 in the TF-A
    taxonomy.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the first step is the generation of key pairs (X.509 certificates in
    this case) that can be used for signing and verification of firmware parts. For
    this task, ST provides the `cert_create` tool.
  prefs: []
  type: TYPE_NORMAL
- en: The TF-A requires all certificates to be part of a chain of trust (CoT). By
    default, the public key stored in the STM32MP157F’s OTP memory is taken as the
    root key, so the corresponding private key is a mandatory input for the `cert_create`
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: After all the binaries and corresponding certificates are finalized, the FIP
    can be generated, and the result can be deployed to the device. During the boot
    process, the BL2 TF-A will use Mbed TLS for certificate parsing and the STM32MP
    Crypto Lib for signature verification in order to use the hardware hashing module.
  prefs: []
  type: TYPE_NORMAL
- en: The order of binary loading and execution is as follows. First, BL2 loads BL32
    (OP-TEE) to memory and verifies its signature. Afterward, the same happens for
    BL33 (U-Boot). Only after successful verification, the execution of BL32 is started,
    which, in turn, calls BL33 after its own completion.
  prefs: []
  type: TYPE_NORMAL
- en: '***U-Boot’s Secure Boot Feature***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After the ROM code and the BL2 TF-A, the third implementation involved in the
    device’s secure boot is U-Boot’s image-authentication procedure. In 2013, the
    groundwork for U-Boot’s secure boot support was laid by introducing RSA-based
    signature verification for Flattened Image Tree (FIT) images.
  prefs: []
  type: TYPE_NORMAL
- en: To activate these features, several configuration options also have to be enabled—for
    example, RSA crypto functionality (`CONFIG_RSA`), FIT support (`CONFIG_FIT`),
    and signature handling in FIT images (`CONFIG_FIT_SIGNATURE`).
  prefs: []
  type: TYPE_NORMAL
- en: Again, key generation is a fundamental step. However, since U-Boot is an open
    source project, key generation is also possible with open source tools such as
    the `openssl` command line tool. At the time of writing, U-Boot supports digital
    signatures based on RSA-2048, RSA-3072, RSA-4096, and ECDSA with a 256-bit curve.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-1](ch08.xhtml#ch08list01) shows the two commands that generate a
    typical 2,048-bit RSA key and a corresponding X.509 certificate. Both are required
    for the later signing and image-generation process.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-1: The key generation for U-Boot’s image verification*'
  prefs: []
  type: TYPE_NORMAL
- en: To generate a correctly signed FIT image, an Image Tree Source (ITS) file has
    to be created. [Listing 8-2](ch08.xhtml#ch08list02) shows an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-2: An example of a FIT image source*'
  prefs: []
  type: TYPE_NORMAL
- en: This FIT image source example assumes the Linux kernel is available as `zImage`
    ➊ and its device tree blob (DTB) for the STM32MP157F-DK2 board is stored as *stm32mp157f-dk2.dtb*
    ➋. Both are hashed by SHA-256 ➌, but U-Boot would also support SHA-384 and SHA-512.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the kernel and DTB are combined only in the `configurations` section
    ➍ of the ITS file. This thwarts mix-and-match attacks that would try to boot and
    misuse unwanted pairs of kernels and DTBs. Using an RSA-2048 signature ➎ generated
    by the key *dev.key* ➏ on the configuration consisting of a specific kernel and
    a specific DTB grants only the execution of this explicit combination.
  prefs: []
  type: TYPE_NORMAL
- en: After processing the ITS file with the `mkimage` tool, the last firmware part
    is signed and ready to be stored on the STM32MP157F device’s memory card. On successful
    verification during U-Boot’s boot procedure, you’ll see a message in the serial
    console output similar to the one shown in [Listing 8-3](ch08.xhtml#ch08list03).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-3: A successful kernel and DTB verification by U-Boot*'
  prefs: []
  type: TYPE_NORMAL
- en: Subsequently, the execution of the verified Linux kernel is the worthy reward
    for your hard work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if the whole verification chain “works” up to this point, you still have
    two important tasks to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Perform comprehensive testing**    Confirm that every modification of a firmware
    part is actually detected and that the boot process is stopped accordingly. It
    might well be that, by mistake, a small part of the created image is not protected
    by a corresponding signature, which could open the door for manipulations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Check hardware for known weaknesses**    Vulnerabilities in hardware components
    relevant for your boot process might break the security of the whole verification
    chain. Just as an example, CVE-2017-7932 and CVE-2017-7936 describe such hardware
    issues that can’t be fixed after production.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integrity Protection Beyond the Boot Process**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The classic secure boot chain usually terminates at the point where the OS takes
    over control. However, device architects might quite rightly want to extend integrity
    and authenticity protection beyond that stage.
  prefs: []
  type: TYPE_NORMAL
- en: '***Kernel Module Verification***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Loadable Linux kernel modules enable a modular and dynamic way of extending
    kernel functionality. However, modification of such a loadable module paves the
    way for malicious code execution with kernel rights by attackers. Therefore, verifying
    integrity and authenticity of these modules during the loading process is desirable.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux kernel already provides support for this security feature. There,
    RSA-based signatures of kernel modules can be verified upon loading a certain
    kernel module, but this functionality is disabled by default. It has to be activated
    in the `Enable Loadable Module Support` section of the kernel’s configuration
    (`CONFIG_MODULE_SIG`).
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, kernel-module signature verification runs in *permissive* mode:
    modules without signatures or corresponding public keys are marked as tainted
    but are still loaded. To enforce valid module signatures, the `CONFIG _MODULE_SIG_FORCE`
    option has to be enabled.'
  prefs: []
  type: TYPE_NORMAL
- en: With standard settings for module signing, the kernel build process automatically
    generates signing keys and associated X.509 certificates at compile time by using
    OpenSSL. The created private keys are used to sign compiled kernel modules and
    might be discarded afterward. Of course, the certificates containing the public
    verification keys have to be integrated into the Linux kernel to enable successful
    verification at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '***Filesystem Integrity***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As part of the Linux startup process, the kernel usually will mount one or more
    filesystems. These may contain application binaries, configuration data, trusted
    certificates, and public keys, all prone to tampering by adversaries. Standard
    filesystems like ext3 and ext4 incorporate mechanisms to deal with accidental
    data corruption but don’t provide integrity protection from a security point of
    view.
  prefs: []
  type: TYPE_NORMAL
- en: When looking at integrity protection for filesystem data, it’s important to
    distinguish between protecting data at rest (for example, in the power-off state)
    and protecting against data manipulation at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAC-Based Filesystem Protection**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Stacked filesystems like EncFS and gocryptfs, mentioned for confidentiality
    protection in [Chapter 5](ch05.xhtml#ch05), can additionally provide integrity
    protection in the form of HMACs or authenticated encryption. These mechanisms
    target data-at-rest protection because changing data at runtime is desired and,
    of course, possible. They generate cryptographic checksums whenever files are
    written and verify them upon reading.
  prefs: []
  type: TYPE_NORMAL
- en: Further, integrity protection can also be achieved at the block device level.
    The popular `dm-crypt` crypto target for the Linux device mapper infrastructure
    can use `dm-integrity` (`CONFIG_DM_INTEGRITY`) that generates authentication tags
    when writing and verifies them when data is read. Also, `dm-crypt` supports authenticated
    encryption ciphers like AES-GCM and ChaCha20-Poly1305\. However, if only integrity
    protection is desired, `dm-integrity` can also be used standalone. Again, these
    measures aim for integrity protection against attackers modifying data in nonvolatile
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**Read-Only Filesystems**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’re concerned about filesystem modifications at runtime, an even simpler
    solution exists. Read-only filesystems like CramFS and SquashFS don’t implement
    write access for files, which means there’s simply no way to alter disk data at
    runtime, even if a system is compromised. A further nonsecurity advantage is the
    compressed storage of these filesystems, decreasing the demand for nonvolatile
    memory. However, attackers with offline access to the mass storage media can replace
    the filesystem at will.
  prefs: []
  type: TYPE_NORMAL
- en: '**Comprehensive Integrity Protection**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Finally, one solution provides integrity protection against both offline and
    runtime attacks: the `dm-verity` module (`CONFIG_DM_VERITY`). Originating from
    the Chrome OS community, it’s meant as a direct extension of secure boot to filesystem
    integrity. Also, Android 4.4 introduced support for it in 2013, and it was strictly
    enforced in 2016, beginning with Android 7.0.'
  prefs: []
  type: TYPE_NORMAL
- en: From a technical point of view, `dm-verity` uses a hash tree in which each data
    block in a given block device is hashed. Then, sets of hash values are hashed
    to obtain next-level hashes, and so on, until a single root hash remains. If this
    root-hash value is incorporated into the secure boot verification process, the
    integrity of all data within the block device can be guaranteed. At runtime, for
    each file access, the hash tree is verified up to the root hash. This, of course,
    leads to a read-only filesystem. The initialization process of such a volume is
    supported by the `veritysetup` user-space tool after filesystem image creation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Write Protection as a Low-Cost Solution**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For some microcontrollers, especially low-cost and low-performance variants,
    secure boot is not available. However, that’s not a valid excuse for missing firmware
    protection.
  prefs: []
  type: TYPE_NORMAL
- en: The boot process of these platforms is usually much simpler because they use
    an RTOS or even just run bare-metal software. Further, their software and data
    are considerably smaller and often reside at least partially in *internal* flash
    memory. But still, the goals of integrity and authenticity can be important to
    protect devices from malicious modifications.
  prefs: []
  type: TYPE_NORMAL
- en: A simple yet powerful feature in this context is the activation of write protection
    for internal flash memory. The firmware is written to the device and the memory
    is “locked” afterward. Also, debugging interfaces like Joint Test Action Group
    (JTAG) should be deactivated. Following the principle of defense in depth, it
    makes sense to implement verification functions within such firmware that check
    whether lock-bits and other anti-debugging measures are set properly. Then, even
    if write-protection mechanisms are circumvented—for example, by physical attacks—an
    adversary still has to invest a substantial amount of reverse engineering to completely
    break the firmware integrity protection.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this internal, integrity-protected software might implement cryptographic
    signature verification and become the starting point of a verification chain that
    transfers the internal protection goals to data stored in external memories.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Processor hardware and its manufacturers play an important role in the implementation
    of secure boot processes for embedded systems. Proprietary architectures, heterogeneous
    multicore complexity, and a conglomeration of marketing terms contribute to the
    high barrier that device architects and developers have to climb when aiming for
    a protected boot process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic principle is simple: an immutable hardware component verifies the
    first software component to be loaded for integrity and authenticity. If successful,
    execution is handed over to that software, which again might verify the next piece
    of software, and so on. However, in practice, as shown in this chapter’s case
    study, every stage of the boot process is different and requires product-specific
    knowledge and often vendor-specific tools. In addition, a series of cryptographic
    keys has to be managed, and device production processes even have to be prepared
    for secure boot support. The promising gain of this protection measure for the
    overall device security exacts its toll.'
  prefs: []
  type: TYPE_NORMAL
- en: A robust secure boot implementation is a strong foundation for further security
    measures like kernel-module verification, filesystem integrity protection, and
    a variety of runtime integrity measures. It even has a positive impact on reverse-engineering
    protection and the secure data storage approaches described in [Chapter 5](ch05.xhtml#ch05),
    because it prevents attackers from executing custom code on your product and thereby
    exploring its internals.
  prefs: []
  type: TYPE_NORMAL
