<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Network Security and PKI"><div class="titlepage"><div><div><h1 class="title"><a id="network_security_and_pki"/>Chapter 6. Network Security and PKI</h1></div></div></div><p><a id="iddle2920" class="indexterm"/><a id="iddle2929" class="indexterm"/>As discussed in the previous chapter, Android includes various cryptographic providers that implement most modern cryptographic primitives: hashing, symmetric and asymmetric encryption, and message authentication codes. Those primitives can be combined to implement secure communication, but even a subtle mistake can result in serious vulnerabilities, so the preferred way to implement secure communication is to use standard protocols that are designed to protect the privacy and integrity of data transferred across a network.</p><p>The most widely used secure protocols are Secure Sockets Layer (SSL) and Transport Layer Security (TLS). Android supports these protocols by providing an implementation of the standard Java Secure Socket Extension (JSSE). In this chapter, we’ll briefly discuss the JSSE architecture and then provide some details about Android’s JSSE implementation. Our description of Android’s SSL stack is focused on certificate validation and trust anchor management, which are tightly integrated into the platform and are one of the biggest differences that set it apart from other JSSE implementations.</p><div class="note" title="Note"><h3 class="title"><a id="ch06note01"/>Note</h3><p><a id="iddle1351" class="indexterm"/><a id="iddle1387" class="indexterm"/><a id="iddle1401" class="indexterm"/><a id="iddle1406" class="indexterm"/><a id="iddle1652" class="indexterm"/><a id="iddle1660" class="indexterm"/><a id="iddle2291" class="indexterm"/><a id="iddle2491" class="indexterm"/><a id="iddle2542" class="indexterm"/><a id="iddle2863" class="indexterm"/><a id="iddle3150" class="indexterm"/><span class="emphasis"><em>While TLS and SSL are technically different protocols, we will usually use the more common term</em></span> SSL <span class="emphasis"><em>to refer to both, and will only distinguish between SSL and TLS when discussing protocol differences.</em></span></p></div><div class="sect1" title="PKI and SSL Overview"><div class="titlepage"><div><div><h1 class="title"><a id="pki_and_ssl_overview"/>PKI and SSL Overview</h1></div></div></div><p>TLS<sup>[<a id="ch06fn01" href="#ftn.ch06fn01" class="footnote">58</a>]</sup> and SSL<sup>[<a id="ch06fn02" href="#ftn.ch06fn02" class="footnote">59</a>]</sup> (its predecessor) are secure point-to-point communication protocols designed to provide (optional) authentication, message confidentiality, and message integrity between two parties communicating over TCP/IP. They use a combination of symmetric and asymmetric encryption to implement message confidentiality and integrity, and rely heavily on public key certificates to implement authentication.</p><p>To start a secure SSL channel, a client contacts a server and sends the SSL protocol version it supports, as well as a list of suggested cipher suites. A <span class="emphasis"><em>cipher suite</em></span> is a set of algorithms and key sizes used for authentication, key agreement, encryption, and integrity. In order to establish a secure channel, the server and client negotiate a commonly supported cipher suite, and then verify each other’s identity based on their certificates. Finally, the communicating parties agree on a symmetric encryption algorithm and compute a shared symmetric key that is used to encrypt all subsequent communication. Typically, only the server’s identity is verified (<span class="emphasis"><em>server authentication</em></span>) and not the client’s. The SSL protocol supports verifying client identity as well (<span class="emphasis"><em>client authentication</em></span>), but it is used much more rarely.</p><div class="note" title="Note"><h3 class="title"><a id="ch06note02"/>Note</h3><p><span class="emphasis"><em>While anonymous (unauthenticated) cipher suites such as</em></span> TLS_DH_anon_WITH_AES_128_CBC_SHA <span class="emphasis"><em>are defined in SSL specifications, they are vulnerable to manin-the-middle (MITM) attacks and are typically only employed when SSL is used as part of a more complex protocol that has other means to ensure authentication.</em></span></p></div><div class="sect2" title="Public Key Certificates"><div class="titlepage"><div><div><h2 class="title"><a id="public_key_certificates"/>Public Key Certificates</h2></div></div></div><p>As mentioned in the previous section, SSL relies on public key certificates to implement authentication. A public key certificate is a construct that binds an identity to a public key. For <span class="emphasis"><em>X.509 certificates</em></span>, which are used in SSL communication, the “identity” is a set of attributes typically including a common name (CN), organization, and location that form the entity’s distinguished name (DN). Other major attributes of X.509 certificates are the issuer DN, validity period, and a set of extensions, which may be additional entity attributes or pertain to the certificate itself (for example, intended key usage).</p><p>The binding is formed by applying a digital signature over the entity’s public key and all additional attributes to produce a digital certificate. The <a id="iddle1306" class="indexterm"/><a id="iddle1332" class="indexterm"/>signing key used may be the certified entity’s own private key, in which case the certificate is referred to as <span class="emphasis"><em>self-signed</em></span>, or it may belong to a trusted third party called a <span class="emphasis"><em>certificate authority (CA)</em></span>.</p><p>The contents of a typical X.509 server certificate as parsed by the OpenSSL <code class="literal">x509</code> command are shown in <a class="xref" href="ch06.html#xdot509_certificate_contentscomma_as_par" title="Example 6-1. X.509 certificate contents, as parsed by OpenSSL">Example 6-1</a>. This particular certificate binds the <span class="emphasis"><em>C=US, ST=California, L=Mountain View, O=Google Inc, CN=*.googlecode.com</em></span> DN ➋ and a set of alternative DNS names ➍ to the server’s 2048-bit RSA key ➌ and is signed with the private key of the Google Internet Authority G2 CA ➊.</p><div class="example"><a id="xdot509_certificate_contentscomma_as_par"/><p class="title">Example 6-1. X.509 certificate contents, as parsed by OpenSSL</p><div class="example-contents"><pre class="programlisting">Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            09:49:24:fd:15:cf:1f:2e
    Signature Algorithm: sha1WithRSAEncryption
        Issuer: C=US, O=Google Inc, CN=Google Internet Authority G2➊
        Validity
            Not Before: Oct 9 10:33:36 2013 GMT
            Not After : Oct 9 10:33:36 2014 GMT
        Subject: C=US, ST=California, L=Mountain View, O=Google Inc, CN=*.googlecode.com➋
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)➌
                Modulus:
                    00:9b:58:02:90:d6:50:03:0a:7c:79:06:99:5b:7a:
                    --<span class="emphasis"><em>snip</em></span>--
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Extended Key Usage:
                TLS Web Server Authentication, TLS Web Client Authentication
            X509v3 Subject Alternative Name:
                DNS:*.googlecode.com, DNS:*.cloud.google.com, DNS:*.code.google.com,➍
                --<span class="emphasis"><em>snip</em></span>--
            Authority Information Access:
                CA Issuers - URI:http://pki.google.com/GIAG2.crt
                OCSP - URI:http://clients1.google.com/ocsp

            X509v3 Subject Key Identifier:
                65:10:15:1B:C4:26:13:DA:50:3F:84:4E:44:1A:C5:13:B0:98:4F:7B
            X509v3 Basic Constraints: critical
                CA:FALSE
            X509v3 Authority Key Identifier:
                keyid:4A:DD:06:16:1B:BC:F6:68:B5:76:F5:81:B6:BB:62:1A:BA:5A:81:2F
            X509v3 Certificate Policies:
                Policy: 1.3.6.1.4.1.11129.2.5.1
            X509v3 CRL Distribution Points:
                Full Name:
                  URI:http://pki.google.com/GIAG2.crl
    Signature Algorithm: sha1WithRSAEncryption
         3f:38:94:1b:f5:0a:49:e7:6f:9b:7b:90:de:b8:05:f8:41:32:
         --<span class="emphasis"><em>snip</em></span>--</pre></div></div></div><div class="sect2" title="Direct Trust and Private CAs"><div class="titlepage"><div><div><h2 class="title"><a id="direct_trust_and_private_cas"/>Direct Trust and Private CAs</h2></div></div></div><p><a id="iddle1309" class="indexterm"/><a id="iddle1343" class="indexterm"/><a id="iddle1350" class="indexterm"/><a id="iddle1764" class="indexterm"/><a id="iddle1769" class="indexterm"/><a id="iddle2278" class="indexterm"/><a id="iddle2290" class="indexterm"/><a id="iddle2489" class="indexterm"/><a id="iddle2490" class="indexterm"/><a id="iddle2512" class="indexterm"/><a id="iddle2861" class="indexterm"/><a id="iddle2862" class="indexterm"/><a id="iddle2930" class="indexterm"/>If an SSL client communicates with a limited number of servers, it can be preconfigured with a set of server certificates that it trusts (called <span class="emphasis"><em>trust anchors</em></span>), and deciding whether to trust a remote party becomes simply a matter of checking whether its certificate is in that set. This model allows for fine-grained control over whom clients trust, but makes it harder to rotate or upgrade server keys, which requires issuing a new self-signed certificate.</p><p>This problem can be solved by using a <span class="emphasis"><em>private CA</em></span> and configuring both clients and servers to use it as the single trust anchor. In this model, SSL parties do not check for a particular entity certificate, but trust any certificate issued by the private CA. This allows for transparent key and certificate upgrades, without the need to upgrade SSL clients and servers as long as the CA certificate is still valid. The downside is that at the same time, this single-CA model creates a single point of failure; if the CA key is compromised, whoever has obtained access to it can issue fraudulent certificates that all clients will trust (as we will see later, this is not limited to private CAs). Recovering from this situation requires updating all clients and replacing the CA certificate.</p><p>Another problem with this model is that it cannot be used for clients that do not know in advance what servers they will need to connect to— usually generic Internet clients such as web browsers, email applications, and messaging or VoIP clients. Such generic clients are typically configured with a set of trust anchors that includes well-known issuers, which we call <span class="emphasis"><em>public CAs</em></span>. While certain guidelines and requirements exist, the process of selecting public CAs to include as default trust anchors varies widely between browsers and OSes. For example, in order to include a CA certificate as a trust anchor in its products, Mozilla requires that the CA has a public <span class="emphasis"><em>Certificate Policy and Certification Practice Statement (CP/CPS)</em></span> document, enforces multi-factor authentication for operator accounts, and that the CA certificate does not issue end-entity certificates directly.<sup>[<a id="ch06fn03" href="#ftn.ch06fn03" class="footnote">60</a>]</sup> Other vendors can have less stringent requirements. Current versions of most OSes and browsers ship with more than 100 CA certificates included as trust anchors.</p></div><div class="sect2" title="Public Key Infrastructure"><div class="titlepage"><div><div><h2 class="title"><a id="public_key_infrastructure"/>Public Key Infrastructure</h2></div></div></div><p>When certificates are issued by public CAs, some sort of identity verification is performed before issuing the certificate. The verification process varies vastly between CAs and types of certificates issued, ranging from accepting automatic email address confirmation (for cheap server certificates) to requiring multiple forms of government-issued ID and company registration documents (for Extended Validation, or EV, certificates).</p><p>Public CAs depend on multiple people, systems, procedures, and policies in order to perform entity verification and to create, manage, and distribute <a id="iddle1700" class="indexterm"/><a id="iddle1726" class="indexterm"/><a id="iddle2556" class="indexterm"/><a id="iddle2589" class="indexterm"/>certificates. The set of those parties and systems is referred to as a <span class="emphasis"><em>Public Key Infrastructure (PKI)</em></span>. PKIs can be infinitely complex, but in the context of secure communication, and SSL in particular, the most important pieces are the CA certificates, which act as trust anchors and are used when validating the identity of communication parties. Therefore, managing trust anchors will be one of the key points in our discussion of Android’s SSL and PKI implementation. <a class="xref" href="ch06.html#pki_entities" title="Figure 6-1. PKI entities">Figure 6-1</a> shows a simplified representation of a typical PKI.</p><div class="figure"><a id="pki_entities"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00016"/><img src="figs/web/06fig01.png.jpg" alt="PKI entities"/></div></div><p class="title">Figure 6-1. PKI entities</p></div><p>Here, a person or server that holds a certificate is referred to as an <span class="emphasis"><em>end entity (EE)</em></span>. To obtain a certificate, an end entity sends a certificate request to a registration authority (RA). The RA obtains some proof of identity from the EE and verifies its identity according to the CA’s policy requirements. After the RA has established the identity of the EE, it checks that it matches the contents of the certificate request, and if so, forwards the request to the issuing CA. An issuing CA signs the EE certificate request in order to generate EE certificates and maintains revocation information (discussed in the next section) about the issued certificates. On the other hand, a root CA does not sign EE certificates directly but only signs <a id="iddle1337" class="indexterm"/><a id="iddle1352" class="indexterm"/><a id="iddle1452" class="indexterm"/><a id="iddle2276" class="indexterm"/><a id="iddle2488" class="indexterm"/><a id="iddle2544" class="indexterm"/><a id="iddle2699" class="indexterm"/><a id="iddle2860" class="indexterm"/>certificates for issuing CAs and revocation information concerning issuing CAs. A root CA is used very rarely and is usually kept offline in order to increase the security of its keys.</p><p>For the PKI sketched in <a class="xref" href="ch06.html#pki_entities" title="Figure 6-1. PKI entities">Figure 6-1</a>, an EE certificate is associated with two CA certificates: the issuing CA’s certificate, which signed it, and the root CA’s certificate, which signed the issuing CA’s certificate. The three certificates form a certificate chain (also called a certification path). The chain begins with the EE certificate and terminates with the root CA certificate. In order for an EE certificate to be trusted, its certification path needs to lead to a certificate the system trusts implicitly (trust anchor). While intermediate certificates can be used as trust anchors, this role is usually performed by root CA certificates.</p></div><div class="sect2" title="Certificate Revocation"><div class="titlepage"><div><div><h2 class="title"><a id="certificate_revocation"/>Certificate Revocation</h2></div></div></div><p>In addition to issuing certificates, CAs can mark a certificate as invalid by revoking it. <span class="emphasis"><em>Revoking</em></span> involves adding the certificate serial number and a revocation reason to a certificate revocation list (CRL) that the CA signs and periodically publishes. Entities validating a certificate can then check to see if it has been revoked by searching for its serial number (which is unique within a given CA) in the issuing CA’s current CRL. <a class="xref" href="ch06.html#crl_file_contents" title="Example 6-2. CRL file contents">Example 6-2</a> shows the contents of a sample CRL file, issued by the Google Internet Authority G2. In this example, certificates with the serial numbers <code class="literal">40BF8571DD53E3BB</code> ➊ and <code class="literal">0A9F21196A442E45</code> ➋ have been revoked.</p><div class="example"><a id="crl_file_contents"/><p class="title">Example 6-2. CRL file contents</p><div class="example-contents"><pre class="programlisting">Certificate Revocation List (CRL):
        Version 2 (0x1)
    Signature Algorithm: sha1WithRSAEncryption
        Issuer: /C=US/O=Google Inc/CN=Google Internet Authority G2
        Last Update: Jan 13 01:00:02 2014 GMT
        Next Update: Jan 23 01:00:02 2014 GMT
        CRL extensions:
            X509v3 Authority Key Identifier:
                keyid:4A:DD:06:16:1B:BC:F6:68:B5:76:F5:81:B6:BB:62:1A:BA:5A:81:2F
            X509v3 CRL Number:
                219
Revoked Certificates:
    Serial Number: 40BF8571DD53E3BB➊
        Revocation Date: Sep 10 15:19:22 2013 GMT
        CRL entry extensions:
            X509v3 CRL Reason Code:
                Affiliation Changed
--<span class="emphasis"><em>snip</em></span>--
    Serial Number: 0A9F21196A442E45➋
        Revocation Date: Jun 12 17:42:06 2013 GMT
        CRL entry extensions:
            X509v3 CRL Reason Code:
                Superseded
    Signature Algorithm: sha1WithRSAEncryption
         40:f6:05:7d:...</pre></div></div><p><a id="iddle1937" class="indexterm"/><a id="iddle1938" class="indexterm"/><a id="iddle2047" class="indexterm"/><a id="iddle2284" class="indexterm"/><a id="iddle2332" class="indexterm"/><a id="iddle2343" class="indexterm"/><a id="iddle2857" class="indexterm"/><a id="iddle2858" class="indexterm"/>Revocation status can also be checked without fetching the full list of all revoked certificates by using the Online Certificate Status Protocol (OCSP).<sup>[<a id="ch06fn04" href="#ftn.ch06fn04" class="footnote">61</a>]</sup> CRL and OCSP URIs are often included as extensions in certificates so that verifying parties do not need to know their location in advance. All public CAs maintain revocation information, but in practice a lot of SSL clients either do not check revocation at all or allow connections (possibly with a warning) even if the remote party’s certificate is revoked. The main reasons for this lenient behavior of SSL clients are the overhead associated with fetching current revocation information, and ensuring connectivity. While delta CRLs (CRLs that only contain the difference, or <span class="emphasis"><em>delta</em></span>, from the previous CRL version) and local caching alleviate the problem to some extent, CRLs for major CAs are typically huge and need to be downloaded before an SSL connection is established, which adds user-visible latency. OCSP improves this situation but still requires a connection to a different server, which again adds latency.</p><p>In either case, revocation information may simply be unavailable, due to a network or configuration problem in a CA’s infrastructure. For a major CA, a revocation database outage could disable a large number of secure sites, which translates directly to financial loss for their operators. Lastly, nobody likes connection errors and when faced with a revocation error, most users will simply find another, less strict SSL client that simply “works.”</p></div></div><div class="sect1" title="JSSE Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="jsse_introduction"/>JSSE Introduction</h1></div></div></div><p>We’ll briefly introduce the architecture and main components of JSSE here. (For complete coverage, see the official <span class="emphasis"><em>JSSE Reference Guide</em></span>.<sup>[<a id="ch06fn05" href="#ftn.ch06fn05" class="footnote">62</a>]</sup>)</p><p>The JSSE API lives in the <code class="literal">javax.net</code> and <code class="literal">javax.net.ssl</code> packages and provides classes that represent the following features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>SSL client and server sockets</p></li><li class="listitem"><p>An engine for producing and consuming SSL streams (<code class="literal">SSLEngine</code>)</p></li><li class="listitem"><p>Factories for creating sockets</p></li><li class="listitem"><p>A secure socket context class (<code class="literal">SSLContext</code>) that creates secure socket factories and engines</p></li><li class="listitem"><p>PKI-based key and trust managers and factories to create them</p></li><li class="listitem"><p>A class for HTTPS (HTTP over TLS, specified in <span class="emphasis"><em>RFC 2818</em></span><sup>[<a id="ch06fn06" href="#ftn.ch06fn06" class="footnote">63</a>]</sup>) URL connections (<code class="literal">HttpsURLConnection</code>)</p></li></ul></div><p>Just as with JCA cryptographic service providers, a JSSE provider supplies implementations for the engine classes defined in the API. Those implementation classes are responsible for creating the underlying sockets, <a id="iddle1007" class="indexterm"/><a id="iddle2048" class="indexterm"/><a id="iddle2050" class="indexterm"/><a id="iddle2109" class="indexterm"/><a id="iddle2122" class="indexterm"/><a id="iddle2285" class="indexterm"/><a id="iddle2286" class="indexterm"/><a id="iddle2437" class="indexterm"/><a id="iddle2493" class="indexterm"/><a id="iddle2865" class="indexterm"/><a id="iddle2866" class="indexterm"/><a id="iddle2937" class="indexterm"/><a id="iddle3144" class="indexterm"/>and key and trust managers required to establish a connection, but JSSE API users never directly interact with them, only with the respective engine classes. Let’s briefly review the key classes and interfaces in the JSSE API, as well as how they relate to each other.</p><div class="sect2" title="Secure Sockets"><div class="titlepage"><div><div><h2 class="title"><a id="secure_sockets"/>Secure Sockets</h2></div></div></div><p>JSSE supports both stream-based, blocking I/O using sockets and NIO (New I/O) channel-based, nonblocking I/O. The central class for stream-based communication is <code class="literal">javax.net.ssl.SSLSocket</code>, which is created either by an <code class="literal">SSLSocketFactory</code> or by calling the <code class="literal">accept()</code> method of the <code class="literal">SSLServerSocket</code> class. In turn, <code class="literal">SSLSocketFactory</code> and <code class="literal">SSLServerSocketFactory</code> instances are created by calling the appropriate factory methods of the <code class="literal">SSLContext</code> class. SSL socket factories encapsulate the details of creating and configuring SSL sockets, including authentication keys, peer certificate validation strategies, and enabled cipher suites. Those details are typically common for all SSL sockets that an application uses and are configured when initializing the application’s <code class="literal">SSLContext</code>. They are then passed to all SSL socket factories created by the shared <code class="literal">SSLContext</code> instance. If an <code class="literal">SSLContext</code> is not explicitly configured, it uses the system defaults for all SSL parameters.</p><p>Nonblocking SSL I/O is implemented in the <code class="literal">javax.net.ssl.SSLEngine</code> class. This class encapsulates an SSL state machine and operates on byte buffers supplied by its clients. While <code class="literal">SSLSocket</code> hides much of the complexity of SSL, in order to offer greater flexibility, <code class="literal">SSLEngine</code> leaves I/O and threading to the calling application. Therefore, <code class="literal">SSLEngine</code> clients are expected to have some understanding of the SSL protocol. <code class="literal">SSLEngine</code> instances are created directly from an <code class="literal">SSLContext</code> and inherit its SSL configuration, just like SSL socket factories.</p></div><div class="sect2" title="Peer Authentication"><div class="titlepage"><div><div><h2 class="title"><a id="peer_authentication"/>Peer Authentication</h2></div></div></div><p>Peer authentication is an integral part of the SSL protocol and relies on the availability of a set of trust anchors and authentication keys. In JSSE, peer authentication configuration is provided with the help of the <code class="literal">KeyStore</code>, <code class="literal">KeyManagerFactory</code>, and <code class="literal">TrustManagerFactory</code> engine classes. A <code class="literal">KeyStore</code> represents a storage facility for cryptographic keys and certificates and can be used to store both trust anchors certificates, and end entity keys along with their associated certificates. <code class="literal">KeyManagerFactory</code> and <code class="literal">TrustManagerFactory</code> create <code class="literal">KeyManager</code>s or <code class="literal">TrustManager</code>s, respectively, based on a specified authentication algorithm. While implementations based on different authentication strategies are possible, in practice SSL uses only a X.509-based PKI (PKIX)<sup>[<a id="ch06fn07" href="#ftn.ch06fn07" class="footnote">64</a>]</sup> for authentication, and the only algorithm supported by those factory classes is <span class="emphasis"><em>PKIX</em></span> (aliased to <span class="emphasis"><em>X.509</em></span>). An <code class="literal">SSLContext</code> can be initialized with a set of <a id="iddle1356" class="indexterm"/><a id="iddle1357" class="indexterm"/><a id="iddle2108" class="indexterm"/><a id="iddle2936" class="indexterm"/><a id="iddle3152" class="indexterm"/><a id="iddle3153" class="indexterm"/><a id="iddle3156" class="indexterm"/><code class="literal">KeyManager</code> and <code class="literal">TrustManager</code> instances by calling the following method. All parameters are optional, and if <code class="literal">null</code> is specified, the system default is used (see <a class="xref" href="ch06.html#sslcontext_initialization_method" title="Example 6-3. SSLContext initialization method">Example 6-3</a>).</p><div class="example"><a id="sslcontext_initialization_method"/><p class="title">Example 6-3. <code class="literal">SSLContext</code> initialization method</p><div class="example-contents"><pre class="programlisting">void init(KeyManager[] km, TrustManager[] tm, SecureRandom random);</pre></div></div><p>A <code class="literal">TrustManager</code> determines whether the presented peer authentication credentials should be trusted. If they are, the connection is established; if not, the connection is terminated. In the context of PKIX, this translates to validating the certificate chain of the presented peer certificate based on the configured trust anchors. This is also reflected in the <code class="literal">X509TrustManager</code> interface JSSE uses (see <a class="xref" href="ch06.html#x509trustmanager_interface_methods" title="Example 6-4. X509TrustManager interface methods">Example 6-4</a>):</p><div class="example"><a id="x509trustmanager_interface_methods"/><p class="title">Example 6-4. <code class="literal">X509TrustManager</code> interface methods</p><div class="example-contents"><pre class="programlisting">void checkClientTrusted(X509Certificate[] chain, String authType);
void checkServerTrusted(X509Certificate[] chain, String authType);
X509Certificate[] getAcceptedIssuers();</pre></div></div><p>Certificate chain validation is performed using the system Java Certification Path API (or CertPath API) implementation,<sup>[<a id="ch06fn08" href="#ftn.ch06fn08" class="footnote">65</a>]</sup> which is responsible for building and validating certificate chains. While the API has a somewhat algorithm-independent interface, in practice it’s closely related to PKIX and implements the chain building and validation algorithms defined in PKIX standards. The default PKIX <code class="literal">TrustManagerFactory</code> implementation can create an <code class="literal">X509TrustManager</code> instance that preconfigures the underlying CertPath API classes with the trust anchors stored in a <code class="literal">KeyStore</code> object.</p><p>The <code class="literal">KeyStore</code> object is typically initialized from a system keystore file referred to as a <span class="emphasis"><em>trust store</em></span>. When more fine-grained configuration is required, a <code class="literal">CertPathTrustManagerParameters</code> instance that contains detailed CertPath API parameters can be used to initialize the <code class="literal">TrustManagerFactory</code> as well. When the system <code class="literal">X509TrustManager</code> implementation cannot be configured as required using the provided APIs, a custom instance can be created by implementing the interface directly, possibly delegating base cases to the default implementation.</p><p>A <code class="literal">KeyManager</code> determines which authentication credentials to send to the remote host. In the context of PKIX, this means selecting the client authentication certificate to send to an SSL server. The default <code class="literal">KeyManagerFactory</code> can create a <code class="literal">KeyManager</code> instance that uses a <code class="literal">KeyStore</code> to search for client authentication keys and related certificates. Just as with <code class="literal">TrustManager</code>s, the concrete interfaces, <code class="literal">X509KeyManager</code> (shown in <a class="xref" href="ch06.html#x509keymanager_interface" title="Example 6-5. X509KeyManager interface">Example 6-5</a>) and <code class="literal">X509ExtendedKeyManager</code> <a id="iddle1933" class="indexterm"/><a id="iddle1934" class="indexterm"/><a id="iddle1939" class="indexterm"/><a id="iddle2046" class="indexterm"/><a id="iddle2283" class="indexterm"/><a id="iddle2773" class="indexterm"/><a id="iddle2792" class="indexterm"/><a id="iddle2867" class="indexterm"/><a id="iddle3065" class="indexterm"/>(which allows for connection-specific key selection), are PKIX-specific and select a client certificate based on the list of trusted issuers that the server has provided. If the default <code class="literal">KeyStore</code> -backed implementation is not sufficiently flexible, a custom implementation can be provided by extending the abstract <code class="literal">X509ExtendedKeyManager</code> class.</p><div class="example"><a id="x509keymanager_interface"/><p class="title">Example 6-5. <code class="literal">X509KeyManager</code> interface</p><div class="example-contents"><pre class="programlisting">String chooseClientAlias(String[] keyType, Principal[] issuers, Socket socket);
String chooseServerAlias(String keyType, Principal[] issuers, Socket socket);
X509Certificate[] getCertificateChain(String alias);
String[] getClientAliases(String keyType, Principal[] issuers);
PrivateKey getPrivateKey(String alias);
String[] getServerAliases(String keyType, Principal[] issuers);</pre></div></div><p>In addition to support for “raw” SSL sockets, JSSE also provides support for HTTPS with the <code class="literal">HttpsURLConnection</code> class. <code class="literal">HttpsURLConnection</code> uses the default <code class="literal">SSLSocketFactory</code> to create secure sockets when opening a connection to a web server. If additional SSL configuration such as specifying app-private trust anchors or authentication keys is required, the default <code class="literal">SSLSocketFactory</code> can be replaced for all <code class="literal">HttpsURLConnection</code> instances by calling the static <code class="literal">setDefaultSSLSocketFactory()</code> method. Alternatively, you can configure the socket factory for a particular instance by calling its <code class="literal">setSSLSocketFactory()</code> method.</p></div><div class="sect2" title="Hostname Verification"><div class="titlepage"><div><div><h2 class="title"><a id="hostname_verification"/>Hostname Verification</h2></div></div></div><p>While SSL verifies server identity by checking its certificate, the protocol does not mandate any hostname verification, and when using raw SSL sockets, the certificate subject is not matched against the server hostname. The HTTPS standard does mandate such a check however, and <code class="literal">HttpsURLConnection</code> performs one internally. The default hostname verification algorithm can be overridden by assigning a <code class="literal">HostnameVerifier</code> instance to the class or on a per-instance basis. The <code class="literal">verify()</code> callback it needs to implement is shown in <a class="xref" href="ch06.html#hostnameverifier_hostname_verification_c" title="Example 6-6. HostnameVerifier hostname verification callback">Example 6-6</a>. The <code class="literal">SSLSession</code> class used in the callback encapsulates details about the current SSL connection, including selected protocol and cipher suite, local and peer certificate chains, and peer hostname and connection port number.</p><div class="example"><a id="hostnameverifier_hostname_verification_c"/><p class="title">Example 6-6. <code class="literal">HostnameVerifier</code> hostname verification callback</p><div class="example-contents"><pre class="programlisting">boolean verify(String hostname, SSLSession session);</pre></div></div><p>We have discussed the major classes and interfaces that form the JSSE API and introduced how they related to each other. Their relationships can be visualized as shown in <a class="xref" href="ch06.html#jsse_classes_and_their_relationships" title="Figure 6-2. JSSE classes and their relationships">Figure 6-2</a>.</p><div class="figure"><a id="jsse_classes_and_their_relationships"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00017"/><img src="figs/web/06fig02.png.jpg" alt="JSSE classes and their relationships"/></div></div><p class="title">Figure 6-2. JSSE classes and their relationships</p></div></div></div><div class="sect1" title="Android JSSE Implementation"><div class="titlepage"><div><div><h1 class="title"><a id="android_jsse_implementation"/>Android JSSE Implementation</h1></div></div></div><p><a id="iddle2038" class="indexterm"/><a id="iddle2054" class="indexterm"/><a id="iddle2281" class="indexterm"/>Android comes with two JSSE providers: the Java-based HarmonyJSSE and the AndroidOpenSSL provider, which is implemented largely in native code bridged to the public Java API using JNI. HarmonyJSSE builds on Java sockets and JCA classes in order to implement SSL, while AndroidOpenSSL implements most of its functionality by using OpenSSL library calls. As discussed in <a class="xref" href="ch05.html" title="Chapter 5. Cryptographic Providers">Chapter 5</a>, AndroidOpenSSL is the preferred JCA provider in Android, and it also provides the default <code class="literal">SSLSocketFactory</code> and <code class="literal">SSLServerSocketFactory</code> implementations that are returned by <code class="literal">SSLSocketFactory.getDefault()</code> and <code class="literal">SSLServerSocketFactory.getDefault()</code>, respectively.</p><p><a id="iddle1150" class="indexterm"/><a id="iddle1348" class="indexterm"/><a id="iddle1940" class="indexterm"/><a id="iddle2044" class="indexterm"/><a id="iddle2288" class="indexterm"/><a id="iddle2761" class="indexterm"/><a id="iddle2849" class="indexterm"/><a id="iddle2900" class="indexterm"/><a id="iddle2941" class="indexterm"/>Both JSSE providers are part of the core Java library (found in <code class="literal">core.jar</code> and <code class="literal">libjavacore.so</code>), and the native part of the AndroidOpenSSL provider is compiled into <code class="literal">libjavacrypto.so</code>. HarmonyJSSE provides only SSLv3.0 and TLSv1.0 support, while AndroidOpenSSL supports TLSv1.1 and TLSv1.2 as well. While the SSL socket implementation is different, both providers share the same <code class="literal">TrustManager</code> and <code class="literal">KeyManager</code> code.</p><div class="note" title="Note"><h3 class="title"><a id="ch06note03"/>Note</h3><p><span class="emphasis"><em>The HarmonyJSSE provider is still available in Android 4.4, but it is considered deprecated and is not actively maintained. It may be removed in future Android versions.</em></span></p></div><p>In addition to current TLS protocol versions, the OpenSSL-based provider supports the <span class="emphasis"><em>Server Name Indication (SNI)</em></span> TLS extension (defined in <span class="emphasis"><em>RFC 3546</em></span><sup>[<a id="ch06fn09" href="#ftn.ch06fn09" class="footnote">66</a>]</sup>), which allows SSL clients to specify the intended hostname when connecting to servers hosting multiple virtual hosts. SNI is used by default when establishing a connection using the <code class="literal">HttpsURLConnection</code> class in Android 3.0 and later versions (version 2.3 has partial SNI support). However, SNI is not supported when using the Apache HTTP client library bundled with Android (in the <code class="literal">org.apache.http</code> package).</p><p>Before Android 4.2, the HTTP stack in Android’s core Java library, including <code class="literal">HttpsURLConnection</code>, was based on Apache Harmony code. In Android 4.2 and later, the original implementation is replaced with Square’s HTTP &amp; SPDY client library, <span class="emphasis"><em>OkHttp</em></span>.<sup>[<a id="ch06fn10" href="#ftn.ch06fn10" class="footnote">67</a>]</sup></p><div class="sect2" title="Certificate Management and Validation"><div class="titlepage"><div><div><h2 class="title"><a id="certificate_management_and_validation"/>Certificate Management and Validation</h2></div></div></div><p>Android’s JSSE implementations mostly conform to the JSSE API specification, but there are some notable differences as well. The biggest one is how Android handles the system trust store. In Java SE JSSE implementations, the system trust store is a single keystore file (typically called <span class="emphasis"><em>cacerts</em></span>) whose location can be set with the <code class="literal">javax.net.ssl.trustStore</code> system property, but Android follows a different strategy. Recent versions of Android also provide modern certificate validation features such as blacklisting and pinning that are not specified in the original JSSE architecture document. We will discuss Android’s trust store implementation and advanced certificate validation features in the next sections.</p><div class="sect3" title="System Trust Stores"><div class="titlepage"><div><div><h3 class="title"><a id="system_trust_stores"/>System Trust Stores</h3></div></div></div><p>As discussed in “<a class="xref" href="ch06.html#peer_authentication" title="Peer Authentication">Peer Authentication</a>”, JSSE implementations use a trust store to authenticate connection peers. While SSL does support encryption-only, non-authenticated connections, in practice raw SSL clients usually perform server authentication and it is mandatory for HTTPS. When a per-application trust store is not explicitly provided, JSSE <a id="iddle1346" class="indexterm"/><a id="iddle2042" class="indexterm"/><a id="iddle2280" class="indexterm"/><a id="iddle2898" class="indexterm"/><a id="iddle2933" class="indexterm"/><a id="iddle3154" class="indexterm"/>uses the system trust store to perform SSL peer authentication. The system trust store is especially important for generic Internet clients such as browsers, because they typically do not manage their own trust store on mobile devices (desktop versions of Mozilla clients do maintain private credential and certificate stores, but not on Android). Because system trust stores are central to the security of all applications that use JSSE, we will look into their implementation in detail.</p><p>Until Android 4.0, the OS trust store was hardwired into the system and users had no control over it whatsoever. Certificates bundled in the store were chosen solely by the device manufacturer or carrier. The only way to make changes was to root your device, repackage the trusted certificates file, and replace the original one—a procedure that’s obviously not too practical, and a major obstacle to using Android in enterprise PKIs. In the wake of the compromise of multiple major CAs, third-party tools that could change the system-trusted certificates were developed, but using them still required a rooted phone. Fortunately, Android 4.0 made managing the trust store much more flexible, and gave the much-needed control over who to trust to the user.</p></div><div class="sect3" title="Android 4.x System Trust Store"><div class="titlepage"><div><div><h3 class="title"><a id="android_4dotx_system_trust_store"/>Android 4.x System Trust Store</h3></div></div></div><p>Prior to Android 4.0, the system trust store was a single file: <span class="emphasis"><em>/system/etc/ security/cacerts.bks</em></span>, a Bouncy Castle (one of the cryptographic providers used in Android; see <a class="xref" href="ch05.html" title="Chapter 5. Cryptographic Providers">Chapter 5</a> for details) native keystore file. It contained all the CA certificates that Android trusts and was used both by system apps such as the email client and browser, and third-party apps. Because it resided on the read-only <span class="emphasis"><em>system</em></span> partition, it could not be changed even by system applications.</p><p>Android 4.0 introduced a new, more flexible <code class="literal">TrustedCertificateStore</code> class that allows for maintaining built-in trust anchors and adding new ones. It still reads system-trusted certificates from <span class="emphasis"><em>/system/etc/security/</em></span>, but adds two new, mutable locations to store CA certificates in <span class="emphasis"><em>/data/misc/ keychain/</em></span>: the <span class="emphasis"><em>cacerts-added/</em></span> and <span class="emphasis"><em>cacerts-removed/</em></span> directories. <a class="xref" href="ch06.html#contents_of_the_cacerts-addedsolidus_and" title="Example 6-7. Contents of the cacerts-added/ and cacerts-removed/ directories">Example 6-7</a> shows what their contents looks like:</p><div class="example"><a id="contents_of_the_cacerts-addedsolidus_and"/><p class="title">Example 6-7. Contents of the <span class="roman">cacerts-added/</span> and <span class="roman">cacerts-removed/</span> directories</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>ls -l /data/misc/keychain</strong></span>
drwxr-xr-x system   system            cacerts-added
drwxr-xr-x system   system            cacerts-removed
-rw-r--r-- system   system         81 pubkey_blacklist.txt
-rw-r--r-- system   system          7 serial_blacklist.txt
# <span class="strong"><strong>ls -l /data/misc/keychain/cacerts-added</strong></span>
-rw-r--r-- system   system        653 30ef493b.0➊
# <span class="strong"><strong>ls -l /data/misc/keychain/cacerts-removed</strong></span>
-rw-r--r-- system   system       1060 00673b5b.0➋</pre></div></div><p>Each file in these directories contains one CA certificate. The file names may look familiar: they are based on the MD5 hashes of the CA subject names (computed using OpenSSL’s <code class="literal">X509_NAME_hash_old()</code> function), <a id="iddle1349" class="indexterm"/><a id="iddle2045" class="indexterm"/><a id="iddle2123" class="indexterm"/><a id="iddle2289" class="indexterm"/><a id="iddle2901" class="indexterm"/>as used in <span class="emphasis"><em>mod_ssl</em></span> and other cryptographic software implemented using OpenSSL. This makes it easy to quickly find certificates without scanning the entire store by directly converting the DN to a filename.</p><p>Also note the permissions of the directories: <span class="emphasis"><em>0775 system system</em></span> guarantees that only the <span class="emphasis"><em>system</em></span> user is able to add or remove certificates, but anyone can read them. As expected, adding trusted CA certificates is implemented by storing the certificate in the <span class="emphasis"><em>cacerts-added/</em></span> directory under the appropriate file name. The certificate stored in the <span class="emphasis"><em>30ef493b.0</em></span> file (➊ in <a class="xref" href="ch06.html#contents_of_the_cacerts-addedsolidus_and" title="Example 6-7. Contents of the cacerts-added/ and cacerts-removed/ directories">Example 6-7</a>) will also be displayed in the User tab of the Trusted credentials system application (<span class="strong"><strong>Settings</strong></span>▸<span class="strong"><strong>Security</strong></span>▸<span class="strong"><strong>Trusted credentials</strong></span>).</p><p>But how are OS-trusted certificates disabled? Because preinstalled CA certificates are still stored in <span class="emphasis"><em>/system/etc/ security/</em></span> (which is mounted read-only), a CA is marked as not trusted by placing a copy of its certificate in the <span class="emphasis"><em>cacerts-removed/</em></span> directory. Re-enabling is performed by simply removing the file. In this particular case, <span class="emphasis"><em>00673b5b.0</em></span> (➋ in <a class="xref" href="ch06.html#contents_of_the_cacerts-addedsolidus_and" title="Example 6-7. Contents of the cacerts-added/ and cacerts-removed/ directories">Example 6-7</a>) is the <span class="emphasis"><em>thawte Primary Root CA</em></span>, shown as disabled in the System tab (see <a class="xref" href="ch06.html#preinstalled_ca_certificate_marked_as_un" title="Figure 6-3. Preinstalled CA certificate marked as untrusted">Figure 6-3</a>).</p></div><div class="sect3" title="Using the System Trust Store"><div class="titlepage"><div><div><h3 class="title"><a id="using_the_system_trust_store"/>Using the System Trust Store</h3></div></div></div><p><code class="literal">TrustedCertificateStore</code> is not part of the Android SDK, but it has a wrapper (<code class="literal">TrustedCertificateKeyStoreSpi</code>) accessible via the standard JCA <code class="literal">KeyStore</code> API that applications can use (see <a class="xref" href="ch06.html#listing_trusted_certificates_using_andro" title="Example 6-8. Listing trusted certificates using AndroidCAStore">Example 6-8</a>).</p><div class="example"><a id="listing_trusted_certificates_using_andro"/><p class="title">Example 6-8. Listing trusted certificates using <span class="roman">AndroidCAStore</span></p><div class="example-contents"><pre class="programlisting">KeyStore ks = KeyStore.getInstance("AndroidCAStore");➊
ks.load(null, null);➋
Enumeration&lt;String&gt; aliases = ks.aliases();➌
while (aliases.hasMoreElements()) {
    String alias = aliases.nextElement();
    Log.d(TAG, "Certificate alias: " + alias);
    X09Certificate cert = (X509Certificate) ks.getCertificate(alias);➍
    Log.d(TAG, "Subject DN: " + cert.getSubjectDN().getName());
    Log.d(TAG, "Issuer DN: " + cert.getIssuerDN().getName());
}</pre></div></div><div class="figure"><a id="preinstalled_ca_certificate_marked_as_un"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00018"/><img src="figs/web/06fig03.png.jpg" alt="Preinstalled CA certificate marked as untrusted"/></div></div><p class="title">Figure 6-3. Preinstalled CA certificate marked as untrusted</p></div><p><a id="iddle1936" class="indexterm"/><a id="iddle1941" class="indexterm"/><a id="iddle2938" class="indexterm"/>To get a list of the current trusted certificates, we:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Create a <code class="literal">KeyStore</code> instance by specifying <span class="emphasis"><em>AndroidCAStore</em></span> as the <code class="literal">type</code> parameter ➊.</p></li><li class="listitem"><p>Call its <code class="literal">load()</code> method and pass <code class="literal">null</code> for both parameters ➋.</p></li><li class="listitem"><p>Get a list of certificate aliases with the <code class="literal">aliases()</code> method ➌.</p></li><li class="listitem"><p>Pass each alias to the <code class="literal">getCertificate()</code> method to get the actual certificate object ➍.</p></li></ol></div><p>When you examine the output of this code, you’ll notice that certificate aliases start with either the <span class="emphasis"><em>user:</em></span> (for user-installed certificates) or <span class="emphasis"><em>system:</em></span> (for preinstalled ones) prefix, followed by the subject’s hash value.</p><p>The <span class="emphasis"><em>AndroidCAStore</em></span> <code class="literal">KeyStore</code> implementation lets us easily access the OS’s trusted certificates, but a real-world application would be more interested in whether it should trust a particular server certificate, not what the current trust anchors are. Android makes this very easy by integrating the <code class="literal">TrustedCertificateKeyStoreSpi</code> with its JSSE implementation. The default <code class="literal">TrustManagerFactory</code> uses it to get a list of trust anchors, and thus automatically validates server certificates against the system’s currently trusted certificates. Higher-level code that uses <code class="literal">HttpsURLConnection</code> or <code class="literal">HttpClient</code> (both built on top of JSSE) should thus work without needing to worry about creating and initializing a custom <code class="literal">SSLSocketFactory</code>.</p><p>In order to install our own CA certificate (such as one from a private enterprise CA) into the system trust store, we need to convert it to DER (binary) format and copy it to the device. On versions prior to Android 4.4.1, the certificate file needs to be copied to the root of external storage with a <span class="emphasis"><em>.crt</em></span> or <span class="emphasis"><em>.cer</em></span> extension. Android 4.4.1 and later uses the storage access framework introduced in Android 4.4 and allow you to select a certificate file from any storage backend that the device can access, including integrated cloud providers like Google Drive. We can then import the certificate using the system Settings app by selecting <span class="strong"><strong>Settings</strong></span>▸<span class="strong"><strong>Personal</strong></span>▸<span class="strong"><strong>Security</strong></span>▸<span class="strong"><strong>Credential storage</strong></span>▸<span class="strong"><strong>Install from storage</strong></span>. A list of available certificate files is displayed and tapping on a filename brings up the import dialog, as shown in <a class="xref" href="ch06.html#ca_certificate_import_dialog" title="Figure 6-4. CA certificate import dialog">Figure 6-4</a>.</p><p>The imported certificate will be displayed in the User tab of the Trusted credentials screen (see <a class="xref" href="ch06.html#user-imported_ca_certificates" title="Figure 6-5. User-imported CA certificates">Figure 6-5</a>). You can view certificate details by tapping the list entry, and remove it by scrolling down to the bottom of the details screen and tapping the Remove button.</p><div class="note" title="Note"><h3 class="title"><a id="ch06note04"/>Note</h3><p><span class="emphasis"><em>If the certificate is successfully imported, the certificate file in external storage file will be deleted on versions prior to Android 4.4.1.</em></span></p></div><div class="figure"><a id="ca_certificate_import_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00019"/><img src="figs/web/06fig04.png.jpg" alt="CA certificate import dialog"/></div></div><p class="title">Figure 6-4. CA certificate import dialog</p></div><div class="figure"><a id="user-imported_ca_certificates"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00020"/><img src="figs/web/06fig05.png.jpg" alt="User-imported CA certificates"/></div></div><p class="title">Figure 6-5. User-imported CA certificates</p></div><p>Beginning with Android 4.4, the system displays a notification that warns the user that network activity could be monitored if there are any user-installed trusted certificates. SSL connection monitoring can be accomplished by using an intercepting proxy server that returns automatically generated certificates for the sites that the user is trying to access. As long as those certificates are issued by a CA that Android trusts (such as the one manually installed in the trust store), most applications would not know the difference between a connection to the original host and the intercepting proxy (unless they are have pinned the target host; see “<a class="xref" href="ch06.html#certificate_pinning" title="Certificate Pinning">Certificate Pinning</a>” for details). A warning icon is shown in Quick Settings and next to the <span class="emphasis"><em>Security</em></span> preference entry in the system Settings. When tapped, the notification displays the warning message shown in <a class="xref" href="ch06.html#network_monitoring_warning_in_android_4d" title="Figure 6-6. Network monitoring warning in Android 4.4">Figure 6-6</a>.</p><div class="figure"><a id="network_monitoring_warning_in_android_4d"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00021"/><img src="figs/web/06fig06.png.jpg" alt="Network monitoring warning in Android 4.4"/></div></div><p class="title">Figure 6-6. Network monitoring warning in Android 4.4</p></div></div><div class="sect3" title="System Trust Store APIs"><div class="titlepage"><div><div><h3 class="title"><a id="system_trust_store_apis"/>System Trust Store APIs</h3></div></div></div><p><a id="iddle1347" class="indexterm"/><a id="iddle2043" class="indexterm"/><a id="iddle2182" class="indexterm"/><a id="iddle2287" class="indexterm"/><a id="iddle2899" class="indexterm"/>Third-party applications can prompt the user to import a needed certificate into the system trust store by using the <code class="literal">KeyChain</code> API, introduced in Android 4.0 as well. (We’ll discuss the <code class="literal">KeyChain</code> API in <a class="xref" href="ch07.html" title="Chapter 7. Credential Storage">Chapter 7</a>.) Beginning with Android 4.4, device administrator applications can silently install CA certificates in the system trust store if they hold the <span class="emphasis"><em>MANAGE_CA_CERTIFICATES</em></span> system permission. (We’ll introduce device administration and related APIs in <a class="xref" href="ch09.html" title="Chapter 9. Enterprise Security">Chapter 9</a>.)</p><p>Once a CA certificate is imported into the system trust store, we can use it to validate certificates using the JSSE <code class="literal">TrustManager</code> API as shown in <a class="xref" href="ch06.html#initializing_a_trustmanager_with_system" title="Example 6-9. Initializing a TrustManager with system trust anchors and validating a certificate">Example 6-9</a>.</p><div class="example"><a id="initializing_a_trustmanager_with_system"/><p class="title">Example 6-9. Initializing a <code class="literal">TrustManager</code> with system trust anchors and validating a certificate</p><div class="example-contents"><pre class="programlisting">// Certificate chain including the end entity (server) certificate
// and any intermediate issuers.
X509Certificate[] chain = { endEntityCert };
TrustManagerFactory tmf = TrustManagerFactory.getInstance("X509");➊
tmf.init((KeyStore) null);➋
TrustManager[] tms = tmf.getTrustManagers();
X509TrustManager xtm = (X509TrustManager) tms[0];➌
Log.d(TAG, "checking chain with " + xtm.getClass().getName());
xtm.checkServerTrusted(chain, "RSA");➍
Log.d(TAG, "chain is valid");</pre></div></div><p><a id="iddle1119" class="indexterm"/><a id="iddle1248" class="indexterm"/><a id="iddle1329" class="indexterm"/><a id="iddle1333" class="indexterm"/><a id="iddle1373" class="indexterm"/><a id="iddle1453" class="indexterm"/><a id="iddle2282" class="indexterm"/>To do so, we first get the system PKIX (aliased to <span class="emphasis"><em>X509</em></span>) <code class="literal">TrustManagerFactory</code> (➊ in <a class="xref" href="ch06.html#initializing_a_trustmanager_with_system" title="Example 6-9. Initializing a TrustManager with system trust anchors and validating a certificate">Example 6-9</a>); initialize it using the system trust store by passing <code class="literal">null</code> to its <code class="literal">init(KeyStore ks)</code> method ➋; then get the first <code class="literal">TrustManager</code> implementation for the specified algorithm (there is usually only one, but do check in production code) and cast it to the validation algorithm-specific <code class="literal">X509TrustManager</code> interface ➌. Finally, we pass the certificate chain and the key exchange algorithm used (<span class="emphasis"><em>RSA</em></span>, <span class="emphasis"><em>DHE_DSS</em></span>, and so on) to the <code class="literal">checkServerTrusted()</code> method ➍. If a chain leading to a trusted CA certificate can be built, validation passes and the method returns. If any of the certificates in the chain is expired or invalid, or if the chain does not lead to a system trust anchor, the method will throw a <code class="literal">java.security.cert.CertificateException</code> (or one of its subclasses). Connections established with <code class="literal">SSLSocket</code> and <code class="literal">HttpsURLConnection</code> perform similar validation automatically.</p><p>This works pretty well, but there is one major problem with this code: it does not check revocation. Android’s default <code class="literal">TrustManager</code> explicitly turns off revocation when validating the certificate chain. So even if the certificate had a CRL Distribution Point (CDP) extension, pointing to a valid CRL, or the OCSP responder URI was included in the Authority Information Access (AIA) extension, and the certificate was actually revoked, it would still validate in Android. What’s missing here is <span class="emphasis"><em>online revocation checking</em></span>: the ability to dynamically fetch, cache, and update revocation information as needed, based on information available in certificate extensions.</p></div></div><div class="sect2" title="Certificate Blacklisting"><div class="titlepage"><div><div><h2 class="title"><a id="certificate_blacklisting"/>Certificate Blacklisting</h2></div></div></div><p>Instead of using online revocation checks, Android relies on CA and end entity certificate blacklisting, which we will discuss in this section. <span class="emphasis"><em>Certificate blacklisting</em></span> refers to the explicit blocking of certain certificates by verifiers, regardless of their state in the PKI’s repository. Blacklisting is not part of the original PKI philosophy and is not defined in any of the related standards. So why is it necessary in practice?</p><p>In a perfect world, a working PKI takes care of issuing, distributing, and revoking certificates as necessary. All that a system needs to verify the identities of previously unknown machines and users are a few trust anchor certificates: any end entity certificates encountered will be issued by one of the trusted CAs, or one of their subordinate issuing CAs (sub-CA). In practice, though, there are a number of issues, mostly related to handling compromised keys. End entity certificates have a relatively short validity period (usually one year), which limits the time a compromised key can be exploited. However, CA certificates have very long validity (20 or more years <a id="iddle1281" class="indexterm"/><a id="iddle1282" class="indexterm"/><a id="iddle1307" class="indexterm"/><a id="iddle1339" class="indexterm"/><a id="iddle1340" class="indexterm"/><a id="iddle1701" class="indexterm"/><a id="iddle2040" class="indexterm"/><a id="iddle2041" class="indexterm"/>is typical) and because CAs are implicitly trusted, a key compromise may go undetected for quite some time. Recent breaches in top-level CAs have shown that CA key compromise is not a theoretical problem, and the consequences of a CA breach can be quite far-reaching.</p><div class="sect3" title="Handling CA Key Compromises"><div class="titlepage"><div><div><h3 class="title"><a id="handling_ca_key_compromises"/>Handling CA Key Compromises</h3></div></div></div><p>Probably the biggest PKI issue is that revocation of root certificates is not really supported. Most OSes and browsers come with a preconfigured set of trusted CA certificates (dozens of them!) and when a CA certificate is compromised, there are two main ways to handle it: tell users to remove it from the trust store, or issue an emergency update that removes the affected certificate. Expecting users to handle this is obviously unrealistic, so that leaves the second option.</p><p>Windows modifies OS trust anchors by distributing patches via Windows Update, and browser vendors simply release a new patch version. However, even if an update removes a CA certificate from the system trust store, a user can still install it again, especially when presented with a “do this, or you can’t access this site” ultimatum.</p><p>To make sure removed trust anchors are not brought back, the hashes of their public keys are added to a blacklist and the OS or browser rejects them even if they are in the user trust store. This approach effectively revokes CA certificates (within the scope of the OS or browser, of course) and addresses PKI’s inability to handle compromised trust anchors. However, it is not exactly ideal because even an emergency update takes some time to prepare, and after it’s released, some users won’t update right away no matter how often they’re nagged about it. (Fortunately, CA compromises are relatively rare and widely publicized, so it seems to work well in practice— for now, at least.) Other approaches have been proposed as well, but most are not widely used. We discuss some of the proposed solutions in “<a class="xref" href="ch06.html#radical_solutions" title="Radical Solutions">Radical Solutions</a>”.</p></div><div class="sect3" title="Handling End Entity Key Compromises"><div class="titlepage"><div><div><h3 class="title"><a id="handling_end_entity_key_compromises"/>Handling End Entity Key Compromises</h3></div></div></div><p>While CA breaches are fairly uncommon, end entity (EE) key compromise occurs much more often. Whether due to a server breach, stolen laptop, or a lost smart card, these compromises occur daily. Fortunately, modern PKI systems are designed with this in mind and CAs can revoke certificates and publish revocation information in the form of CRLs, or provide online revocation status using OCSP.</p><p>Unfortunately, this doesn’t work too well in the real world. Revocation checking generally requires network access to a machine different from the one we are trying to connect to, and as such has a fairly high failure rate. To mitigate this, most browsers try to fetch fresh revocation information, but if that effort fails for some reason, they simply ignore the error (soft-fail), or at best show some visual indication that revocation information is not available.</p><div class="note" title="Note"><h3 class="title"><a id="ch06note05"/>Note</h3><p><a id="iddle1280" class="indexterm"/><a id="iddle1338" class="indexterm"/><a id="iddle2039" class="indexterm"/><span class="emphasis"><em>To address this problem, Google Chrome disables online revocation checks</em></span><sup>[<a id="ch06fn11" href="#ftn.ch06fn11" class="footnote">68</a>]</sup> <span class="emphasis"><em>altogether, and now uses its update mechanism to proactively push revocation information to browsers, without requiring an application update or restart.</em></span><sup>[<a id="ch06fn12" href="#ftn.ch06fn12" class="footnote">69</a>]</sup> <span class="emphasis"><em>Thus Chrome can have an up-to-date local cache of revocation information, which makes certificate validation both faster and more reliable. This is can be considered yet another blacklist (Chrome calls it a</em></span> CRL set<span class="emphasis"><em>), this time based on information published by each CA. The browser vendor effectively managing revocation data on the user’s behalf is quite novel; not everyone thinks it’s a good idea, but it has worked well so far.</em></span></p></div><p>An alternative to directly pushing revocation information as part of browser updates is <span class="emphasis"><em>OCSP stapling</em></span>, formerly known as the TLS <span class="emphasis"><em>Certificate Status Request</em></span> extension.<sup>[<a id="ch06fn13" href="#ftn.ch06fn13" class="footnote">70</a>]</sup> Instead of requiring clients to issue an OCSP request for the server certificate, the relevant response is included (“stapled”) with the SSL handshake via the Certificate Status Request extension response. Because the response is signed by the CA, the client can trust it just as if it had fetched it directly from the CA’s OCSP server. If the server did not include an OCSP response in the SSL handshake, the client is expected to fetch one itself. OCSP stapling is supported by all major HTTP servers, but browser support is still patchy, especially on mobile versions where latency is an issue.</p></div><div class="sect3" title="Android Certificate Blacklisting"><div class="titlepage"><div><div><h3 class="title"><a id="android_certificate_blacklisting"/>Android Certificate Blacklisting</h3></div></div></div><p>As we learned in “<a class="xref" href="ch06.html#android_4dotx_system_trust_store" title="Android 4.x System Trust Store">Android 4.x System Trust Store</a>”, Android 4.0 added a management UI, as well as an SDK API, that allows for adding and removing trust anchors to the system trust store. This didn’t quite solve PKI’s number one problem, though: aside from the user manually disabling a compromised trust anchor, an OS update was still required to remove a compromised CA certificate. Additionally, because Android does not perform online revocation checks when validating certificate chains, there was no way to detect compromised end entity certificates, even if they have been revoked.</p><p>To solve this problem, Android 4.1 introduced certificate blacklists that can be modified without requiring an OS update. There are now two system blacklists:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A public key hash blacklist (to handle compromised CAs)</p></li><li class="listitem"><p>A serial number blacklist (to handle compromised EE certificates)</p></li></ul></div><p>The certificate chain validator component takes those two lists into consideration when verifying websites or user certificates. Let’s look at how this is implemented in a bit more detail.</p><p>Android uses a content provider to store OS settings in a system database. Some of those settings can be modified by third-party apps holding the necessary permissions, while some are reserved for the system and can only be changed in the system Settings, or by another system application. The settings reserved for the system are known as <span class="emphasis"><em>secure settings</em></span>. Android 4.1 adds two new secure settings under the following URIs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>content://settings/secure/pubkey_blacklist</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>content://settings/secure/serial_blacklist</em></span></p></li></ul></div><p>As the names imply, the first one stores public key hashes of compromised CAs and the second one a list of EE certificate serial numbers. Additionally, the system server now starts a <code class="literal">CertBlacklister</code> component that registers itself as a <code class="literal">ContentObserver</code> for the two blacklist URIs. Whenever a new value is written to any of the blacklist secure settings, the <code class="literal">CertBlacklister</code> is notified and writes the value to a file on disk. The files are comprised of a comma-delimited list of hex-encoded public key hashes or certificate serial numbers. The files are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Certificate blacklist: <span class="emphasis"><em>/data/misc/keychain/pubkey_blacklist.txt</em></span></p></li><li class="listitem"><p>Serial number blacklist: <span class="emphasis"><em>/data/misc/keychain/serial_blacklist.txt</em></span></p></li></ul></div><p>Why write the files to disk when they are already available in the settings database? Because the component that actually uses the blacklists is a standard Java CertPath API class that doesn’t know anything about Android and its system databases. The certificate path validator class, <code class="literal">PKIXCertPathValidatorSpi</code>, is part of the Bouncy Castle JCA provider modified to handle certificate blacklists, which are an Android-specific feature and not defined in the standard CertPath API. The PKIX certificate validation algorithm that the class implements is rather complex, but what Android 4.1 adds is fairly straightforward:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>When verifying an EE (leaf) certificate, check to see if its serial number is in the serial number blacklist. If so, return the same error (exception) as if the certificate has been revoked.</p></li><li class="listitem"><p>When verifying a CA certificate, check to see if the hash of its public key is in the public key blacklist. If so, return the same error as if the certificate has been revoked.</p></li></ul></div><div class="note" title="Note"><h3 class="title"><a id="ch06note06"/>Note</h3><p><span class="emphasis"><em>Using the unqualified serial number to index blacklisted EE certificates could be a problem if two or more certificates from different CAs happen to have the same serial number. In this case, blacklisting just one of the certificates will effectively blacklist all others with the same serial number. In practice, though, most public CAs use long and randomly generated serial numbers so the probability of collision is quite low.</em></span></p></div><p>The certificate path validator component is used throughout the whole system, so blacklists affect applications that use HTTP client classes, as well as the native Android browser and <code class="literal">WebView</code>. As mentioned above, modifying <a id="iddle1842" class="indexterm"/><a id="iddle1903" class="indexterm"/><a id="iddle2213" class="indexterm"/><a id="iddle2279" class="indexterm"/>the blacklists requires system permissions, so only core system apps can change it. There are no apps in the AOSP source that actually call those APIs, but a good candidate to manage blacklists are the Google services components, available on “Google Experience” devices (that is, devices with the Play Store client preinstalled). These manage Google accounts and access to Google services, and provide push-style notifications via Google Client Messaging (GCM). Because GCM allows for real-time server-initiated push notifications, it’s a safe bet that those will be used to trigger certificate blacklist updates.</p></div></div><div class="sect2" title="Reexamining the PKI Trust Model"><div class="titlepage"><div><div><h2 class="title"><a id="reexamining_the_pki_trust_model"/>Reexamining the PKI Trust Model</h2></div></div></div><p>Android has taken steps to make its trust store more flexible by allowing on-demand modification of both trust anchors and certificate blacklists without requiring a system update. While certificate blacklisting does make Android more resilient to some PKI-related attacks and vulnerabilities, it doesn’t quite solve all problems related to using certificates issued by public CAs. We present some of those problems and the proposed solutions next. We then conclude our discussion of PKI and SSL with a description of Android’s implementation of one of those solutions: certificate pinning.</p><div class="sect3" title="Trust Problems in Today’s PKI"><div class="titlepage"><div><div><h3 class="title"><a id="trust_problems_in_todayapostrophes_pki"/>Trust Problems in Today’s PKI</h3></div></div></div><p>In the highly unlikely case that you haven’t heard about it, the trustworthiness of the existing public CA model has been severely compromised in recent years. It has been suspect for a while, but recent high profile CA security breaches have brought this problem into the spotlight. Attackers have managed to issue certificates for a wide range of sites, including Windows Update servers and Gmail. Although not all were used (or at least they were not detected) in real attacks, the incidents have shown just how much of current Internet technology depends on certificates.</p><p>Fraudulent certificates can be used for anything from installing malware to spying on Internet communication, all while fooling users into thinking that they are using a secure channel or installing a trusted executable. Unfortunately, better security for CAs is not a solution because major CAs have willingly issued hundreds of certificates for unqualified names such as <span class="emphasis"><em>localhost</em></span>, <span class="emphasis"><em>webmail</em></span>, and <span class="emphasis"><em>exchange</em></span>.<sup>[<a id="ch06fn14" href="#ftn.ch06fn14" class="footnote">71</a>]</sup> Certificates issued for unqualified host names can be used to launch a MITM attack against clients that accesses internal servers using their unqualified name, thus making it easy to eavesdrop on internal corporate traffic. And, of course, there is also the matter of compelled certificate creation, where a government agency could compel a CA to issue a false certificate to be used for intercepting secure traffic.</p><p>Clearly the current PKI system, which is largely based on a preselected set of trusted CAs (whose certificates are preinstalled as trust anchors), is problematic, but what are some of the actual problems? There are different takes on this, but for starters, there are too many public CAs. The <a id="iddle1155" class="indexterm"/><a id="iddle1409" class="indexterm"/><a id="iddle1612" class="indexterm"/><a id="iddle1704" class="indexterm"/><a id="iddle2277" class="indexterm"/><a id="iddle2859" class="indexterm"/><a id="iddle2922" class="indexterm"/><a id="iddle2940" class="indexterm"/>Electronic Frontier Foundation’s SSL Observatory project<sup>[<a id="ch06fn15" href="#ftn.ch06fn15" class="footnote">72</a>]</sup> has shown that more than 650 public CAs are trusted by major browsers. Recent Android versions ship with more than 100 trusted CA certificates and until version 4.0, the only way to remove a trusted certificate was through a vendor-initiated OS update.</p><p>Additionally, there is generally no technical restriction on which certificates CAs can issue. As the Comodo and DigiNotar attacks, as well as the recent ANNSI<sup>[<a id="ch06fn16" href="#ftn.ch06fn16" class="footnote">73</a>]</sup> intermediate CA incident, have shown, anyone can issue a certificate for <span class="emphasis"><em>*.google.com</em></span> (name constraints don’t apply to root CAs and don’t really work for a public CA). Furthermore, because CAs don’t publicize the certificates they have issued, there is no way for site operators (in this case, Google) to know when someone issues a new, possibly fraudulent certificate for one of their sites and take appropriate action (certificate transparency standards<sup>[<a id="ch06fn17" href="#ftn.ch06fn17" class="footnote">74</a>]</sup> aim to address this). In short, with the current system, if any of the built-in trust anchors are compromised, an attacker could issue a certificate for any site, and neither users accessing it nor the site’s owner would notice.</p></div><div class="sect3" title="Radical Solutions"><div class="titlepage"><div><div><h3 class="title"><a id="radical_solutions"/>Radical Solutions</h3></div></div></div><p>Proposed solutions range from radical—scrap the whole PKI idea altogether and replace it with something new and better (DNSSEC is a usual favorite); to moderate—use the current infrastructure but do not implicitly trust CAs; to evolutionary—maintain compatibility with the current system but extend it in ways that limit the damage of CA compromise.</p><p>Unfortunately, DNSSEC is still not universally deployed, although the key TLD domains have already been signed. Additionally, it is inherently hierarchical—with country top-level domains controlled by the respective countries—and actually more rigid than PKI, so it doesn’t really fit the bill too well. Improving the current PKI situation is an area of active research, and other viable radical solutions have yet to emerge.</p><p>Moving toward the moderate side, the SSH model has also been suggested (sometimes called <span class="emphasis"><em>Trust on First Use</em></span>, or <span class="emphasis"><em>TOFU</em></span>). In this model, no sites or CAs are initially trusted, and users decide which site to trust on first access. Unlike SSH however, the number of sites that you access directly or indirectly (via CDNs, embedded content, and so on) is virtually unlimited, and user-managed trust is quite unrealistic.</p></div><div class="sect3" title="Convergence and Trust Agility"><div class="titlepage"><div><div><h3 class="title"><a id="convergence_and_trust_agility"/>Convergence and Trust Agility</h3></div></div></div><p>In a similar vein but much more practical is Convergence.<sup>[<a id="ch06fn18" href="#ftn.ch06fn18" class="footnote">75</a>]</sup> <span class="emphasis"><em>Convergence</em></span> is a system based on the idea of <span class="emphasis"><em>trust agility</em></span>, defined as “the ability to easily <a id="iddle1341" class="indexterm"/><a id="iddle2275" class="indexterm"/><a id="iddle2494" class="indexterm"/><a id="iddle2546" class="indexterm"/><a id="iddle2547" class="indexterm"/><a id="iddle2910" class="indexterm"/><a id="iddle2931" class="indexterm"/>choose who you trust and to revise that decision at any time.” It both abolishes the browser (or OS) preselected trust anchor set, and recognizes that users cannot be relied on to independently make trust decisions about all the sites they visit. Trust decisions are delegated to a set of notaries that can vouch for a site by confirming that the certificate you receive from a site is one they have seen before. If multiple notaries point out that the same certificate as correct, users can be reasonably sure that it is genuine and therefore trustworthy.</p><p>Convergence is not a formal standard, but a working implementation has been released, including a Firefox plugin (client) and server-side notary software. While this system is promising, the number of available notaries is currently limited, and Google has publicly stated that it won’t add it to Chrome. Additionally, it cannot currently be implemented as a browser extension, because Chrome does not allow third-party extensions to override the default certificate validation module.</p></div><div class="sect3" title="Certificate Pinning"><div class="titlepage"><div><div><h3 class="title"><a id="certificate_pinning"/>Certificate Pinning</h3></div></div></div><p>That leads us to the current evolutionary solutions, which have been deployed to a fairly large user base, mostly courtesy of the Chrome browser. One is certificate blacklisting, which we already discussed, and the other is certificate pinning.</p><p><span class="emphasis"><em>Certificate pinning</em></span> (or more accurately, <span class="emphasis"><em>public key pinning</em></span>) takes a converse to the blacklisting approach: it whitelists the keys that are trusted to sign certificates for a particular site. Pinning was introduced in Google Chrome version 13 in order to limit the CAs that can issue certificates for Google properties. It is implemented by maintaining a list of public keys that are trusted to issue certificates for a particular DNS name. The list is consulted when validating the certificate chain for a host, and if the chain doesn’t include at least one of the whitelisted keys, validation fails. In practice, the browser keeps a list of SHA-1 hashes of the <code class="literal">SubjectPublicKeyInfo</code> (SPKI) field of trusted certificates. Pinning the public keys instead of the actual certificates allows for updating host certificates without breaking validation and requiring pinning information updates.</p><p>However, a hardcoded pin list doesn’t really scale and a couple of new Internet standards have been proposed to help solve this scalability problem: Public Key Pinning Extension for HTTP (PKPE)<sup>[<a id="ch06fn19" href="#ftn.ch06fn19" class="footnote">76</a>]</sup> by Google and Trust Assertions for Certificate Keys (TACK)<sup>[<a id="ch06fn20" href="#ftn.ch06fn20" class="footnote">77</a>]</sup> by Moxie Marlinspike. The first one is simpler and proposes a new HTTP header (<code class="literal">Public-Key-Pin</code>, or <span class="emphasis"><em>PKP</em></span>) that holds pinning information about a host’s certificate. The header value can include public key hashes, pin lifetime, and a flag that specifies whether pinning should be applied to subdomains of the current host. Pinning information (or simply <span class="emphasis"><em>pins</em></span>) is cached by the browser and used when making trust decisions until it expires. Pins are required to be <a id="iddle1374" class="indexterm"/><a id="iddle2548" class="indexterm"/><a id="iddle3155" class="indexterm"/>delivered over a secure (SSL) connection, and the first connection that includes a PKP header is implicitly trusted (or optionally validated against pins built into the client). The protocol also supports an endpoint to report failed validations via the <code class="literal">report-uri</code> directive and allows for a non-enforcing mode (specified with the <code class="literal">Public-Key-Pins-Report-Only</code> header), where validation failures are reported but connections are still allowed. This makes it possible to notify host administrators about possible MITM attacks against their sites, so that they can take appropriate action.</p><p>The TACK proposal, on the other hand, is somewhat more complex and defines a new TLS extension (also called TACK) that carries pinning information signed with a dedicated <span class="emphasis"><em>TACK key</em></span>. TLS connections to a pinned hostname require the server to present a “tack” containing the pinned key and a corresponding signature over the TLS server’s public key. Thus, both pinning information exchange and validation are carried out at the TLS layer. In contrast, PKPE uses the HTTP layer (over TLS) to send pinning information to clients, but also requires validation to be performed at the TLS layer, dropping the connection if validation against the pins fails.</p><p>Now that we have an idea how pinning works, let’s see how it’s implemented on Android.</p></div><div class="sect3" title="Certificate Pinning in Android"><div class="titlepage"><div><div><h3 class="title"><a id="certificate_pinning_in_android"/>Certificate Pinning in Android</h3></div></div></div><p>Pinning is one of the many security enhancements introduced in Android 4.2. The OS doesn’t come with any built-in pins, but instead reads them from a file in the <span class="emphasis"><em>/data/misc/keychain/</em></span> directory (where user-added certificates and blacklists are stored). The file is simply called <span class="emphasis"><em>pins</em></span> and is in the following format (see <a class="xref" href="ch06.html#system_pins_file_format" title="Example 6-10. System pins file format">Example 6-10</a>):</p><div class="example"><a id="system_pins_file_format"/><p class="title">Example 6-10. System <span class="roman">pins</span> file format</p><div class="example-contents"><pre class="programlisting">hostname=enforcing|SPKI SHA512 hash, SPKI SHA512 hash,...</pre></div></div><p>Here, <code class="literal">enforcing</code> is either <code class="literal">true</code> or <code class="literal">false</code> and is followed by a list of SPKI SHA-512 hashes separated by commas. Note that there is no validity period, so pins are valid until deleted. The file is used not only by the browser, but system-wide by virtue of pinning being integrated in <span class="emphasis"><em>libcore</em></span>. In practice, this means that the default (and only) system <code class="literal">X509TrustManager</code> implementation (<code class="literal">TrustManagerImpl</code>) consults the pin list when validating certificate chains.</p><p>But there’s a twist: the standard <code class="literal">checkServerTrusted()</code> method doesn’t consult the pin list. Thus, any legacy libraries that do not know about certificate pinning would continue to function exactly as before, regardless of the contents of the pin list. This has probably been done for compatibility reasons and is something to be aware of: running on Android 4.2 or above doesn’t necessarily mean that you get the benefit of system-level certificate pins. The pinning functionality is exposed to third-party libraries and apps via the new <code class="literal">X509TrustManagerExtensions</code> SDK class. It has a single method, <code class="literal">checkServerTrusted()</code> (full signature shown in <a class="xref" href="ch06.html#x509trustmanagerextensions_certificate_v" title="Example 6-11. X509TrustManagerExtensions certificate validation method">Example 6-11</a>) that returns a validated chain on success or throws a <code class="literal">CertificateException</code> if validation fails.</p><div class="example"><a id="x509trustmanagerextensions_certificate_v"/><p class="title">Example 6-11. <code class="literal">X509TrustManagerExtensions</code> certificate validation method</p><div class="example-contents"><pre class="programlisting">List&lt;X509Certificate&gt; checkServerTrusted(X509Certificate[] chain, String authType, String host)</pre></div></div><p><a id="iddle1334" class="indexterm"/><a id="iddle2985" class="indexterm"/>The last parameter, <code class="literal">host</code>, is what the underlying implementation (<code class="literal">TrustManagerImpl</code>) uses to search the pin list for matching pins. If one is found, the public keys in the chain being validated will be checked against the hashes in the pin entry for that host. If none matches, validation will fail and you will get a <code class="literal">CertificateException</code>.</p><p>What part of the system uses the new pinning functionality then? The default SSL engine (JSSE provider), namely the client handshake (<code class="literal">ClientHandshakeImpl</code>), and SSL socket (<code class="literal">OpenSSLSocketImpl</code>) implementations check their underlying <code class="literal">X509TrustManager</code> and if it supports pinning, they perform additional validation against the pin list. If validation fails, the connection won’t be established, thus implementing pin validation on the TLS layer as required by the standards discussed in the previous section.</p><p>The <span class="emphasis"><em>pins</em></span> file is not written directly by the OS. Its updates are triggered by a broadcast (<code class="literal">android.intent.action.UPDATE_PINS</code>) that contains the new pins in its extras. The extras contain the path to the new pins file, its new version (stored in <span class="emphasis"><em>/data/misc/keychain/metadata/version/</em></span>), a hash of the current pins, and a <span class="emphasis"><em>SHA512withRSA</em></span> signature over all the above. The receiver of the broadcast (<code class="literal">CertPinInstallReceiver</code>) then verifies the version, hash, and signature, and if valid, atomically replaces the current pins file with new content (the same procedure is used for updating the premium SMS numbers list). Signing the new pins ensures that they can only by updated by whoever controls the private signing key. The corresponding public key used for validation is stored as a system secure setting under the <span class="emphasis"><em>config_update_certificate</em></span> key (usually in the secure table of the <span class="emphasis"><em>/data/data/com.android.providers.settings/ databases/settings.db</em></span>). (As of this writing, the <span class="emphasis"><em>pins</em></span> file on Nexus devices contains more than 40 pin entries, which cover most Google properties, including Gmail, YouTube, and Play Store servers.)</p></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00012"/>Summary</h1></div></div></div><p>Android builds on standard Java APIs such as JSSE and CertPath to implement SSL connections and the required authentication mechanisms. Most of the secure sockets functionality is provided by the largely native, OpenSSL-based JSSE implementation, while certificate validation and trust store management are implemented in Java. Android provides a shared system trust store that can be managed via the Settings UI or the <code class="literal">KeyStore</code> API. All applications that use SSL or certificate validation APIs inherit the system trust anchors, unless an app-specific trust store is explicitly specified. Certificate validation in Android does not use online revocation checking but relies on the system certificate blacklist to detect compromised CA or end entity certificates. Finally, recent versions of Android support system-level certificate pinning in order to be able to constrain the set of certificates that are allowed to issue a server certificate for a particular host.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch06fn01" href="#ch06fn01" class="para">58</a>] </sup>T. Dierks and E. Rescorla, <span class="emphasis"><em>The Transport Layer Security (TLS) Protocol Version 1.2</em></span>, August 2008, <span class="emphasis"><em><a class="ulink" href="http://tools.ietf.org/html/rfc5246">http://tools.ietf.org/html/rfc5246</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch06fn02" href="#ch06fn02" class="para">59</a>] </sup>A. Freier, P. Karlton, and P. Kocher, <span class="emphasis"><em>The Secure Sockets Layer (SSL) Protocol Version 3.0</em></span>, August 2011, <span class="emphasis"><em><a class="ulink" href="http://tools.ietf.org/html/rfc6101">http://tools.ietf.org/html/rfc6101</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch06fn03" href="#ch06fn03" class="para">60</a>] </sup>Mozilla, <span class="emphasis"><em>Mozilla CA Certificate Inclusion Policy (Version 2.2)</em></span>, <span class="emphasis"><em><a class="ulink" href="https://www.mozilla.org/en-US/about/governance/policies/security-group/certs/policy/inclusion/">https://www.mozilla.org/en-US/about/governance/policies/security-group/certs/policy/inclusion/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch06fn04" href="#ch06fn04" class="para">61</a>] </sup>S. Santesson et al., <span class="emphasis"><em>X.509 Internet Public Key Infrastructure Online Certificate Status Protocol -OCSP</em></span>, June 2013, <span class="emphasis"><em><a class="ulink" href="http://tools.ietf.org/html/rfc6960">http://tools.ietf.org/html/rfc6960</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch06fn05" href="#ch06fn05" class="para">62</a>] </sup>Oracle, <span class="emphasis"><em>Java™ Secure Socket Extension (JSSE) Reference Guide</em></span>, <span class="emphasis"><em><a class="ulink" href="http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html">http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch06fn06" href="#ch06fn06" class="para">63</a>] </sup>E. Rescorla, <span class="emphasis"><em>HTTP Over TLS</em></span>, May 2000, <span class="emphasis"><em><a class="ulink" href="http://tools.ietf.org/html/rfc2818">http://tools.ietf.org/html/rfc2818</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch06fn07" href="#ch06fn07" class="para">64</a>] </sup>D. Cooper et al., <span class="emphasis"><em>Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</em></span>, May 2008, <span class="emphasis"><em><a class="ulink" href="http://tools.ietf.org/html/rfc5280">http://tools.ietf.org/html/rfc5280</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch06fn08" href="#ch06fn08" class="para">65</a>] </sup>Oracle, <span class="emphasis"><em>Java™ PKI Programmer’s Guide, <a class="ulink" href="http://docs.oracle.com/javase/7/docs/technotes/guides/security/certpath/CertPathProgGuide.html">http://docs.oracle.com/javase/7/docs/technotes/guides/security/certpath/CertPathProgGuide.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch06fn09" href="#ch06fn09" class="para">66</a>] </sup>S. Blake-Wilson et al., <span class="emphasis"><em>Transport Layer Security (TLS) Extensions</em></span>, June 2003, <span class="emphasis"><em><a class="ulink" href="http://tools.ietf.org/html/rfc3546">http://tools.ietf.org/html/rfc3546</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch06fn10" href="#ch06fn10" class="para">67</a>] </sup>Square, Inc., <span class="emphasis"><em>OkHttp: An HTTP &amp; SPDY client for Android and Java applications</em></span>, <span class="emphasis"><em><a class="ulink" href="http://square.github.io/okhttp/">http://square.github.io/okhttp/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch06fn11" href="#ch06fn11" class="para">68</a>] </sup>Adam Langley, <span class="emphasis"><em>Revocation checking and Chrome’s CRL</em></span>, Feb 2012, <span class="emphasis"><em><a class="ulink" href="https://www.imperialviolet.org/2012/02/05/crlsets.html">https://www.imperialviolet.org/2012/02/05/crlsets.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch06fn12" href="#ch06fn12" class="para">69</a>] </sup>Online revocation checks can still be enabled by setting the <span class="emphasis"><em>EnableOnlineRevocationChecks</em></span> option to <span class="emphasis"><em>true</em></span> (default is <span class="emphasis"><em>false</em></span>).</p></div><div class="footnote"><p><sup>[<a id="ftn.ch06fn13" href="#ch06fn13" class="para">70</a>] </sup>D. Eastlake 3rd, <span class="emphasis"><em>Transport Layer Security (TLS) Extensions: Extension Definitions</em></span>, Section 8, January 2011, <span class="emphasis"><em><a class="ulink" href="http://tools.ietf.org/html/rfc6066#section-8">http://tools.ietf.org/html/rfc6066#section-8</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch06fn14" href="#ch06fn14" class="para">71</a>] </sup>Electronic Frontier Foundation, <span class="emphasis"><em>Unqualified Names in the SSL Observatory</em></span>, April 2011, <span class="emphasis"><em><a class="ulink" href="https://www.eff.org/deeplinks/2011/04/unqualified-names-ssl-observatory">https://www.eff.org/deeplinks/2011/04/unqualified-names-ssl-observatory</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch06fn15" href="#ch06fn15" class="para">72</a>] </sup>Electronic Frontier Foundation, <span class="emphasis"><em>The EFF SSL Observatory</em></span>, <span class="emphasis"><em><a class="ulink" href="https://www.eff.org/observatory">https://www.eff.org/observatory</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch06fn16" href="#ch06fn16" class="para">73</a>] </sup><span class="emphasis"><em>Agence nationale de la sécurité des systèmes d’information</em></span>, French Network and Information Security Agency</p></div><div class="footnote"><p><sup>[<a id="ftn.ch06fn17" href="#ch06fn17" class="para">74</a>] </sup>B. Laurie, A. Langley, and E. Kasper, <span class="emphasis"><em>Certificate Transparency</em></span>, June 2013, <span class="emphasis"><em><a class="ulink" href="http://tools.ietf.org/html/rfc6962">http://tools.ietf.org/html/rfc6962</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch06fn18" href="#ch06fn18" class="para">75</a>] </sup>Thoughtcrime Labs, <span class="emphasis"><em>Convergence</em></span>, <span class="emphasis"><em><a class="ulink" href="http://convergence.io/">http://convergence.io/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch06fn19" href="#ch06fn19" class="para">76</a>] </sup>C. Evans, C. Palmer, and R. Sleevi, <span class="emphasis"><em>Public Key Pinning Extension for HTTP</em></span>, August 7, 2014, <span class="emphasis"><em><a class="ulink" href="http://tools.ietf.org/html/draft-ietf-websec-key-pinning-20">http://tools.ietf.org/html/draft-ietf-websec-key-pinning-20</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch06fn20" href="#ch06fn20" class="para">77</a>] </sup>M. Marlinspike, <span class="emphasis"><em>Trust Assertions for Certificate Keys</em></span>, January 7, 2013, <span class="emphasis"><em><a class="ulink" href="http://tack.io/draft.html">http://tack.io/draft.html</a></em></span></p></div></div></div></body></html>