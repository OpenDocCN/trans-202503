<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_129"/><span class="big">10</span><br/>DESCRIBING MOTION IN THREE DIMENSIONS</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">In <a href="ch04.xhtml">Chapter 4</a>, we reviewed one-dimensional kinematics, describing quantities like velocity and acceleration with real numbers. In this chapter, we’ll look at three-dimensional kinematics, describing velocity and acceleration as vectors. Haskell does not have a built-in type for vectors, but it does have powerful facilities for making your own types, which we’ll use to create a <span class="literal">Vec</span> type for vectors. Before deciding how to implement the <span class="literal">Vec</span> type, we’ll take a careful look at the meaning and use of vectors in physics so we can produce an implementation that aligns well with how we think and write about vectors.</p>&#13;
<h3 class="h3" id="ch10lev1">Three-Dimensional Vectors</h3>&#13;
<p class="noindent">The notion of a three-dimensional vector is essential in physics. In physics, vectors are geometric objects used to describe quantities that have a <span epub:type="pagebreak" id="page_130"/>magnitude and a direction in space. They are best thought of as arrows in which the length of the arrow represents the magnitude and the arrow points in some direction. Living on the surface of the earth as we do, directions can sometimes be described briefly in words, such as “up,” “north,” and so on. We can only ever specify the direction of a vector relative to some object, such as the earth; there is no universal or absolute notion of direction.</p>&#13;
<p class="indent">When we discussed one-dimensional motion in <a href="ch04.xhtml">Chapter 4</a>, we did it in the context of an air track that came already marked in meters. The markings on the air track amount to a coordinate system in one dimension. A <em>coordinate system</em> is a method for describing position in terms of numbers.</p>&#13;
<p class="indent">Nature does not typically grant us a coordinate system to use; instead, we choose the coordinate system we want to use. In three dimensions, this amounts to choosing a location and orientation for a set of three mutually perpendicular directions. Along each direction (let’s call them <em>x</em>, <em>y</em>, and <em>z</em>), we make (real or imaginary) marks, in meters. The place where <em>x</em> = <em>y</em> = <em>z</em> = 0 is called the <em>origin</em> of the coordinate system. Once we have chosen a coordinate system, a position can be described by three numbers (<em>x</em>, <em>y</em>, and <em>z</em>), indicating the (positive or negative) distance from the origin in each direction.</p>&#13;
<p class="indent">To describe motion in three dimensions, we usually need to introduce a coordinate system. But the laws of physics shouldn’t depend on any particular coordinate system. They should work with whatever coordinate system we want to use. Vectors are geometric objects; along with the laws of physics, vectors have an existence apart from any coordinate system. Vectors allow various operations we can describe without a coordinate system. We’ll give geometric (coordinate-free) descriptions of the important properties and operations of vectors and then show how the same operations appear once we have introduced a coordinate system.</p>&#13;
<p class="indent">Before we get into the various vector operations, I want to write the code that must exist at the top of the source code file for this chapter:</p>&#13;
<pre>{-# OPTIONS -Wall #-}&#13;
&#13;
module SimpleVec where&#13;
&#13;
infixl 6 ^+^&#13;
infixl 6 ^-^&#13;
infixr 7 *^&#13;
infixl 7 ^*&#13;
infixr 7 ^/&#13;
infixr 7 &lt;.&gt;&#13;
infixl 7 &gt;&lt;</pre>&#13;
<p class="indent">The first line turns on compiler warnings, which is a good idea to help avoid some common mistakes that are legal code but may not mean what you think they mean. If there are warnings, you will see them when you load the file.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_131"/>The next line gives the code in this chapter a module name so that this code can be imported into another source code file later. The module name <span class="literal">SimpleVec</span> must match the name of the file that contains it, so the filename should be <em>SimpleVec.hs</em>. The remaining lines specify precedence levels and associativities for the operators we define later in the chapter. The precedence levels are numbers from 0 to 9, described in <a href="ch01.xhtml">Chapter 1</a>, that determine which operators act first in an expression with multiple operators. The keyword <span class="literal">infixl</span> is for an operator with left associativity, while <span class="literal">infixr</span> is for right associativity.</p>&#13;
<h4 class="h4" id="ch10lev2">Coordinate-Free Vectors</h4>&#13;
<p class="noindent">Now that we have this code at the top of our file and have a basic idea of what vectors are, let’s look some of their geometric properties. We’ll give the geometric definitions for vector addition, scalar multiplication, vector subtraction, the dot product, the cross product, and the derivative of a vector-valued function of a real number. If you’re interested, the book <em>Modern Classical Physics</em> [<strong><a href="bib.xhtml#bib6"><span class="green">6</span></a></strong>] by Kip Thorne and Roger Blandford gives an elegant motivation for the coordinate-free, geometric view of vectors.</p>&#13;
<h4 class="h4" id="ch10lev3">Geometric Definition of Vector Addition</h4>&#13;
<p class="noindent">We can combine two vectors using what we’ll call <em>vector addition</em>. Geometrically, we define the sum of two vectors to be the vector that points from the tail of the first to the tip of the second when the two vectors are placed tip-to-tail. You can see from <a href="ch10.xhtml#ch10fig1">Figure 10-1</a> that the order in which they are placed tip-to-tail does not matter; consequently, vector addition is commutative (<strong>A</strong> + <strong>B</strong> = <strong>B</strong> + <strong>A</strong>).</p>&#13;
<div class="imagel" id="ch10fig1"><img src="Images/131fig01.jpg" alt="Image" width="474" height="355"/></div>&#13;
<p class="figcap"><em>Figure 10-1: Vector addition. The vector <strong>A</strong> + <strong>B</strong> is the sum of vectors <strong>A</strong> and <strong>B</strong>.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_132"/>Physicists need to know whether a symbol stands for a number or a vector; thus, the theory of Newtonian mechanics (and most other theories in physics) invites us to think in terms of types. The mathematical notation that physicists typically use to indicate a vector is syntactic and identifies a vector by a boldface symbol. In Haskell, the distinction between numbers and vectors is not syntactic; names for each are simply identifiers that begin with a lowercase letter. In Haskell, the distinction between numbers and vectors is semantic and is captured by the type of the value: <span class="literal">R</span> for numbers and <span class="literal">Vec</span> for vectors.</p>&#13;
<p class="indent">In mathematical notation, we use the same + sign for vector addition that we use for addition of numbers, even though vectors and numbers are very different things and it makes no sense to add a vector to a number. In Haskell, we’ll use a different symbol (<span class="literal">^+^</span>) for vector addition than we do for number addition. If <span class="literal">a</span> and <span class="literal">b</span> are vectors (we write <span class="literal">a :: Vec</span> to say that <span class="literal">a</span> has type <span class="literal">Vec</span>), then <span class="literal">a ^+^ b</span> will be their vector sum. At the end of the chapter, we’ll show how to define the <span class="literal">Vec</span> type and the <span class="literal">^+^</span> operator.</p>&#13;
<div class="note">&#13;
<p class="note-title"><span class="bg1">NOTE</span></p>&#13;
<p class="note-para"><em>In this chapter, we introduce new operators for vector addition, subtraction, and scalar multiplication. An alternative path, which we do not follow, would be to expand the definitions of addition (<span class="literal">+</span>), subtraction (<span class="literal">-</span>), and multiplication (<span class="literal">*</span>) so they work for vectors as well as numbers. The Haskell language is certainly powerful enough to do this. The reason we don’t follow this course is that we prefer to have simple, concrete types for our vector operations, rather than types involving type classes. The names, such as <span class="literal">^+^</span>, that we use for the new operators are borrowed from Conal Elliott’s <span class="literal">vector-space</span> package [<strong><a href="bib.xhtml#bib7"><span class="green">7</span></a></strong>], a more sophisticated and general way of dealing with vectors than we present here.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch10lev4">Geometric Definition of Scaling a Vector</h4>&#13;
<p class="noindent">We define scaling a vector by a number (also called <em>scalar multiplication</em> or multiplying a number by a vector) as follows: if the number is positive, we multiply the magnitude of the vector by the number and leave the direction of the vector unchanged. If the number is negative, we multiply the magnitude of the vector by the absolute value of the number and flip the direction of the vector. If the number is 0, the result is the zero vector.</p>&#13;
<p class="indent">We define division of a vector <strong>A</strong> by a number <em>m</em> to be scalar multiplication of the vector by the reciprocal of <em>m</em>.</p>&#13;
<div class="imagec"><img src="Images/132equ01.jpg" alt="Image" width="100" height="43"/></div>&#13;
<p class="indent">In <a href="ch10.xhtml#ch10fig2">Figure 10-2</a>, we show the results of scaling a vector by 2, – 1, and – 1/2. Scaling by a positive number multiplies the length of the vector, keeping the direction the same. Scaling by a negative number multiples the vector’s length and flips its direction.</p>&#13;
<div class="imagel" id="ch10fig2"><img src="Images/133fig01.jpg" alt="Image" width="425" height="237"/></div>&#13;
<p class="figcap"><em>Figure 10-2: Scalar multiplication. Scaling <strong>A</strong> by 2, –1, and –1/2 results in 2 <strong>A</strong>, –<strong>A</strong>, and –<strong>A</strong>/2, respectively.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_133"/>In mathematical notation, we use the same juxtaposition of symbols (placing a number beside a vector) for scalar multiplication that we use for multiplication of numbers, even though the operation is different. Similarly, we use the same sign (/) for dividing a vector by a number, even though the operation is different.</p>&#13;
<p class="indent">In Haskell, we’ll use different symbols for scalar multiplication than we do for number multiplication, and a different symbol for division of a vector by a number than we use for division of a number by a number. If <span class="literal">m</span> is a number and <span class="literal">a</span> is a vector, then <span class="literal">m *^ a</span> and <span class="literal">a ^* m</span> each mean the scaling of <span class="literal">a</span> by <span class="literal">m</span>. Note that the caret sign is closer to the vector in each case. To divide <span class="literal">a</span> by <span class="literal">m</span>, we write <span class="literal">a ^/ m</span>.</p>&#13;
<h4 class="h4" id="ch10lev5">Geometric Definition of Vector Subtraction</h4>&#13;
<p class="noindent">Another way to combine two vectors is with what we’ll call <em>vector subtraction</em>. The difference of two vectors is defined to be the vector that points from the tip of the first to the tip of the second when the two vectors are placed tail-to-tail. <a href="ch10.xhtml#ch10fig3">Figure 10-3</a> shows that the difference of two vectors is equal to the sum of one vector and the opposite of the other vector. In symbols, <strong>B</strong> – <strong>A</strong> = <strong>B</strong> + (–<strong>A</strong>).</p>&#13;
<div class="imagel" id="ch10fig3"><img src="Images/133fig02.jpg" alt="Image" width="632" height="132"/></div>&#13;
<p class="figcap"><em>Figure 10-3: Vector subtraction. The vector <strong>B</strong> – <strong>A</strong> is the difference of vectors <strong>B</strong> and <strong>A</strong>.</em></p>&#13;
<p class="indent">In mathematical notation, we use the same sign (–) for vector subtraction that we use for subtraction of numbers, even though vectors and numbers are very different things. In Haskell, if <span class="literal">a</span> and <span class="literal">b</span> are vectors, we’ll define <span class="literal">a ^-^ b</span> to be their vector difference.</p>&#13;
<h4 class="h4" id="ch10lev6"><span epub:type="pagebreak" id="page_134"/>Geometric Definition of Dot Product</h4>&#13;
<p class="noindent">There are (at least) two important products of vectors in physics. One is the <em>dot product</em>, or <em>inner product</em>. The dot product of two vectors is a scalar, or number. Here’s the geometric definition:</p>&#13;
<div class="equationc"><strong>A · B</strong> = <em>AB</em> cos θ</div>&#13;
<p class="indent">In this equation, <em>θ</em> is the angle between the two vectors when they are placed tail-to-tail, and we use the standard notation of allowing an italic symbol to stand for the magnitude of the vector whose boldface symbol has the same letter. In other words, <em>A</em> = |<strong>A</strong>| and <em>B</em> = |<strong>B</strong>|.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10fig4">Figure 10-4</a> shows that the dot product of two vectors is the product of the magnitude of one vector (<em>B</em> or <em>A</em>) and the projection of the second vector onto the first (<em>A</em> cos <em>θ</em> or <em>B cos θ</em>, respectively). Note that the projection will be negative when <em>θ</em> &gt; 90<sup>∘</sup>.</p>&#13;
<div class="imagel" id="ch10fig4"><img src="Images/134fig01.jpg" alt="Image" width="492" height="232"/></div>&#13;
<p class="figcap"><em>Figure 10-4: The dot product of two vectors is the product of the magnitude of one vector and the projection of the second vector onto the first.</em></p>&#13;
<p class="indent">Notice that the dot product is commutative: <strong>A ⋅B = B ⋅A</strong>. Also, the dot product is related to the magnitude of a vector.</p>&#13;
<div class="equationc"><strong>A · A</strong> = |A|<sup>2</sup> cos (0) = |<strong>A</strong>|<sup>2</sup> = <em>A</em><sup>2</sup></div>&#13;
<p class="indent">Therefore,</p>&#13;
<div class="imagec"><img src="Images/134equ01.jpg" alt="Image" width="98" height="21"/></div>&#13;
<p class="indent">The dot product distributes over a vector sum.</p>&#13;
<div class="equationc"><strong>C · (A + B) = C · A + C · B</strong></div>&#13;
<p class="indent">In Haskell, if <span class="literal">a</span> and <span class="literal">b</span> are vectors, then <span class="literal">a &lt;.&gt; b</span> will be their dot product.</p>&#13;
<h4 class="h4" id="ch10lev7">Geometric Definition of Cross Product</h4>&#13;
<p class="noindent">The <em>cross product</em> of two vectors is the vector whose magnitude is given by</p>&#13;
<div class="equationc">|<strong>A</strong> × <strong>B</strong>| = <em>AB</em> sin θ</div>&#13;
<p class="noindent">and whose direction is perpendicular to both <strong>A</strong> and <strong>B</strong>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_135"/><a href="ch10.xhtml#ch10fig5">Figure 10-5</a> shows the plane containing vectors <strong>A</strong> and <strong>B</strong>. To find the direction of <strong>A</strong> × <strong>B</strong>, imagine rotating vector <strong>A</strong> about its tail through an angle less than 180<sup>∘</sup> until it aligns with vector <strong>B</strong>. If counterclockwise rotation is required to carry this out, the direction of <strong>A</strong> × <strong>B</strong> is out of the page. If instead clockwise rotation is required, the direction of <strong>A</strong> × <strong>B</strong> is into the page.</p>&#13;
<div class="imagel" id="ch10fig5"><img src="Images/135fig01.jpg" alt="Image" width="284" height="191"/></div>&#13;
<p class="figcap"><em>Figure 10-5: Cross product. The vector <strong><em>A</em></strong></em> × <em><strong><em>B</em></strong> points out of the page. The vector <strong>B</strong></em> × <em><strong><em>A</em></strong> points into the page.</em></p>&#13;
<p class="indent">For <strong>A</strong> and <strong>B</strong> in <a href="ch10.xhtml#ch10fig5">Figure 10-5</a>, the vector <strong>A</strong> × <strong>B</strong> points out of the page and the vector <strong>B</strong> × <strong>A</strong> points into the page. The cross product is anti-commutative: <strong>A</strong> × <strong>B</strong> = –<strong>B</strong> × <strong>A</strong>. Note also that the cross product of any vector with itself is 0. The magnitude of the cross product gives the area of the parallelogram formed by the two vectors when two additional parallel sides are added.</p>&#13;
<p class="indent">The cross product distributes over a vector sum:</p>&#13;
<div class="equationc"><strong>C</strong> × <strong>(A + B)</strong> = <strong>C</strong> × <strong>A</strong> + <strong>C</strong> × <strong>B</strong></div>&#13;
<p class="indent">In Haskell, if <span class="literal">a</span> and <span class="literal">b</span> are vectors, we’ll define <span class="literal">a &gt;&lt; b</span> to be their cross product. (The operator <span class="literal">&gt;&lt;</span> is supposed to look like a cross product.)</p>&#13;
<div class="note">&#13;
<p class="note-title"><span class="bg1">NOTE</span></p>&#13;
<p class="note-para"><em>If you are interested in mathematical innovations, the geometric product is more sophisticated than the dot and cross products, but it contains the essence of both. The book</em> Geometric Algebra for Physicists [<strong><a href="bib.xhtml#bib8"><span class="green">8</span></a></strong>] <em>by Chris Doran and Anthony Lasenby is a nice introduction. The book</em> Space-Time Algebra [<strong><a href="bib.xhtml#bib9"><span class="green">9</span></a></strong>] <em>by David Hestenes is another great resource.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch10lev8">Derivative of a Vector-Valued Function</h4>&#13;
<p class="noindent">Suppose <strong>V</strong> is a function that takes one real variable (such as time) as input and gives a vector (such as velocity) as output. Because we can subtract vectors, and because we can divide a vector by a number, we can define the derivative of a vector-valued function of a real number. In Haskell, the type of such a function is <span class="literal">R -&gt; Vec</span>.</p>&#13;
<p class="indent">The derivative of <strong>V</strong>, denoted <em>D</em><strong>V</strong>, <strong>V</strong>’, or <img class="inline" src="Images/v-dot.jpg" alt="Image" width="15" height="20"/>, is the function of one variable defined as follows:</p>&#13;
<div class="imagec"><img src="Images/135equ01.jpg" alt="Image" width="499" height="44"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_136"/>Notice that the leftmost minus sign is a subtraction of vectors. We are using the same <em>D</em> symbol for the derivative of a vector-valued function that we used for the derivative of a number-valued function.</p>&#13;
<p class="indent">The vector derivative takes a vector-valued function of one variable (a function with type <span class="literal">R -&gt; Vec</span>) as input and provides a vector-valued function of one variable as output.</p>&#13;
<pre>type VecDerivative = (R -&gt; Vec) -&gt; R -&gt; Vec</pre>&#13;
<p class="indent">The type <span class="literal">(R -&gt; Vec) -&gt; R -&gt; Vec</span> is the same as the type <span class="literal">(R -&gt; Vec) -&gt;</span> <span class="literal">(R -&gt; Vec)</span>. Here is a vector derivative in Haskell:</p>&#13;
<pre>vecDerivative :: R -&gt; VecDerivative&#13;
vecDerivative dt v t = (v (t + dt/2) ^-^ v (t - dt/2)) ^/ dt</pre>&#13;
<p class="indent">Like the function <span class="literal">derivative</span> from <a href="ch04.xhtml">Chapter 4</a>, this numerical derivative does not take a limit but instead uses a small interval <span class="literal">dt</span>, supplied by the user of the function.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10tab1">Table 10-1</a> shows a comparison of mathematical notation with Haskell notation for the vector operations we’ve introduced.</p>&#13;
<p class="tabcap" id="ch10tab1"><strong>Table 10-1:</strong> Comparison of Mathematical Notation with Haskell Notation for Vector Operations</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Math notation</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Haskell notation</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Haskell type</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><em>t</em></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">t</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">R</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>m</em></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">m</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">R</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><strong>A</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">a</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><strong>B</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><strong>V</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">v</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">R -&gt; Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><strong>V</strong>(<em>t</em>)</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">v t</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><strong>A</strong> + <strong>B</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">a ^+^ b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>m</em> <strong>A</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">m *^ a</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><strong>A</strong> <em>m</em></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">a ^* m</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><strong>A</strong>/<em>m</em></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">a ^/ m</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><strong>A</strong> – <strong>B</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">a ^-^ b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><strong>A</strong> ⋅ <strong>B</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">a &lt;.&gt; b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">R</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><strong>A</strong> × <strong>B</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">a &gt;&lt; b</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>D</em><strong>V</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">vecDerivative 0.01 v</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">R -&gt; Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><em>D</em><strong>V</strong>(<em>t</em>)</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">vecDerivative 0.01 v t</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><img class="inline" src="Images/e0136-01.jpg" alt="Image" width="33" height="28"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">vecDerivative 0.01 v t</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">Vec</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Let’s move on and see what happens with vectors when we introduce a coordinate system.</p>&#13;
<h3 class="h3" id="ch10lev9">Coordinate Systems</h3>&#13;
<p class="noindent">We choose a coordinate system by choosing a location and orientation for a set of three mutually perpendicular directions. We define <strong>î</strong> to be a vector <span epub:type="pagebreak" id="page_137"/>with magnitude 1 that points in the direction of increasing <em>x</em>. A vector with magnitude 1 is also known as a <em>unit vector</em>. Vectors augmented with a hat are unit vectors. <a href="ch10.xhtml#ch10fig6">Figure 10-6</a> shows a coordinate system along with coordinate unit vectors in each coordinate direction.</p>&#13;
<div class="imagel" id="ch10fig6"><img src="Images/137fig01.jpg" alt="Image" width="375" height="367"/></div>&#13;
<p class="figcap"><em>Figure 10-6: A right-handed coordinate system. The z-axis is to be imagined as coming out of the page.</em></p>&#13;
<p class="indent">Because <img class="inline" src="Images/icap.jpg" alt="Image" width="6" height="20"/> has magnitude 1, we know that <img class="inline" src="Images/e0137-02.jpg" alt="Image" width="68" height="21"/>. Similarly, we define <img class="inline" src="Images/jcap.jpg" alt="Image" width="9" height="26"/> to be a unit vector that points in the direction of increasing <em>y</em>, and we define <img class="inline" src="Images/kcap.jpg" alt="Image" width="11" height="20"/> to be a unit vector that points in the direction of increasing <em>z</em>. The reason they are called <img class="inline" src="Images/icap.jpg" alt="Image" width="6" height="20"/>, <img class="inline" src="Images/jcap.jpg" alt="Image" width="9" height="26"/>, and <img class="inline" src="Images/kcap.jpg" alt="Image" width="11" height="20"/> goes back to William Rowan Hamilton and his quaternions. (Search for the William Rowan Hamilton video by A Capella Science for a wonderful musical biography of this mathematical physicist, set to a tune written for a political figure with the same last name.) Because <img class="inline" src="Images/icap.jpg" alt="Image" width="6" height="20"/> and <img class="inline" src="Images/jcap.jpg" alt="Image" width="9" height="26"/> are perpendicular, we know that <img class="inline" src="Images/e0137-03.jpg" alt="Image" width="66" height="28"/>. By similar reasoning, we can find the dot products of all the coordinate unit vectors.</p>&#13;
<div class="imagec"><img src="Images/137equ01.jpg" alt="Image" width="570" height="97"/></div>&#13;
<p class="indent">Because the cross product of any vector with itself is 0, we know that <img class="inline" src="Images/e0137-04.jpg" alt="Image" width="72" height="21"/>. Because the three directions of our coordinate system are mutually perpendicular, we know that <img class="inline" src="Images/e0137-05.jpg" alt="Image" width="98" height="27"/>. To resolve the sign ambiguity, we usually agree to use a <em>right-handed coordinate system</em>, which means that <img class="inline" src="Images/e0137-06.jpg" alt="Image" width="67" height="27"/>. <a href="ch10.xhtml#ch10fig6">Figure 10-6</a> shows a right-handed coordinate system. By similar reasoning, we can find the cross products of all the coordinate unit vectors.</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_138"/><img src="Images/138equ01.jpg" alt="Image" width="583" height="98"/></div>&#13;
<p class="indent">Once we have a coordinate system and the coordinate unit vectors it gives rise to, we can “break a vector into components.” Any vector <strong>A</strong> can be expressed as a <em>linear combination</em> of <img class="inline" src="Images/icap.jpg" alt="Image" width="6" height="20"/>, <img class="inline" src="Images/jcap.jpg" alt="Image" width="9" height="26"/>, and <img class="inline" src="Images/kcap.jpg" alt="Image" width="11" height="20"/>. A linear combination of vectors means a number times the first, plus a number times the second, and so on.</p>&#13;
<div class="imagec"><img src="Images/138equ02.jpg" alt="Image" width="429" height="28"/></div>&#13;
<p class="indent">We call <em>A<sub>x</sub></em> the <em>x</em> component of <strong>A</strong>, and similarly for <em>y</em> and <em>z</em>. The collection of the three numbers <em>A<sub>x</sub></em>, <em>A<sub>y</sub></em>, and <em>A<sub>z</sub></em> is called the <em>components</em> of <strong>A</strong> with respect to the coordinate system. By dotting the equation above by <img class="inline" src="Images/icap.jpg" alt="Image" width="6" height="20"/>, we get an expression for <em>A<sub>x</sub></em> in terms of <img class="inline" src="Images/icap.jpg" alt="Image" width="6" height="20"/> and <strong>A</strong>. We can do the same for <em>A<sub>y</sub></em> and <em>A<sub>z</sub></em>.</p>&#13;
<div class="imagec"><img src="Images/138equ03.jpg" alt="Image" width="86" height="95"/></div>&#13;
<p class="indent">The Haskell code at the end of the chapter defines a default coordinate system you can use. The default coordinate system provides coordinate unit vectors <span class="literal">iHat</span>, <span class="literal">jHat</span>, and <span class="literal">kHat</span> that play the role of <img class="inline" src="Images/icap.jpg" alt="Image" width="6" height="20"/>, <img class="inline" src="Images/jcap.jpg" alt="Image" width="9" height="26"/>, and <img class="inline" src="Images/kcap.jpg" alt="Image" width="11" height="20"/>, respectively.</p>&#13;
<p class="indent">Let’s revisit the vector operations introduced above in a geometric way and see how they look with a coordinate system.</p>&#13;
<h4 class="h4" id="ch10lev10">Vector Addition with Coordinate Components</h4>&#13;
<p class="noindent">The components of a sum are the sums of the components. If <strong>C</strong> = <strong>A</strong> + <strong>B</strong>,</p>&#13;
<div class="imagec"><img src="Images/138equ04a.jpg" alt="Image" width="380" height="26"/></div>&#13;
<p class="noindent">and similarly for the y- and z-components. If <strong>C</strong> = <strong>A</strong> + <strong>B</strong>, then</p>&#13;
<div class="imagec"><img src="Images/138equ04.jpg" alt="Image" width="399" height="83"/></div>&#13;
<p class="indent">In Haskell, this is</p>&#13;
<pre>*SimpleVec&gt; <span class="codestrong1">vec 1 2 3 ^+^ vec 4 5 6</span>&#13;
vec 5.0 7.0 9.0</pre>&#13;
<p class="indent">You can think of the caret on each side of the plus sign as a reminder that there is a vector on the left and a vector on the right.</p>&#13;
<h4 class="h4" id="ch10lev11"><span epub:type="pagebreak" id="page_139"/>Vector Scaling with Coordinate Components</h4>&#13;
<p class="noindent">If <strong>C</strong> = <em>m</em><strong>A</strong>, then</p>&#13;
<div class="imagec"><img src="Images/139equ01.jpg" alt="Image" width="297" height="25"/></div>&#13;
<p class="noindent">and similarly for the y- and z-components. If <strong>C</strong> = <em>m</em><strong>A</strong>, then</p>&#13;
<div class="imagec"><img src="Images/139equ02.jpg" alt="Image" width="386" height="83"/></div>&#13;
<p class="indent">To scale a vector, we can use the <span class="literal">*^</span> operator.</p>&#13;
<pre>*SimpleVec&gt; <span class="codestrong1">5 *^ vec 1 2 3</span>&#13;
vec 5.0 10.0 15.0</pre>&#13;
<p class="indent">Notice that the caret goes on the right of the asterisk because the vector is on the right. You can multiply a <span class="literal">Vec</span> on the left by an <span class="literal">R</span> on the right with the <span class="literal">^*</span> operator.</p>&#13;
<pre>*SimpleVec&gt; <span class="codestrong1">vec 1 2 3 ^* 5</span>&#13;
vec 5.0 10.0 15.0</pre>&#13;
<p class="indent">Since the vector is on the left, the caret is on the left. Similarly, we can divide by an <span class="literal">R</span> with the <span class="literal">^/</span> operator.</p>&#13;
<pre>*SimpleVec&gt; <span class="codestrong1">vec 1 2 3 ^/ 5</span>&#13;
vec 0.2 0.4 0.6</pre>&#13;
<h4 class="h4" id="ch10lev12">Vector Subtraction with Coordinate Components</h4>&#13;
<p class="noindent">If <strong>C</strong> = <strong>A</strong> – <strong>B</strong>, then</p>&#13;
<div class="imagec"><img src="Images/139equ03.jpg" alt="Image" width="381" height="25"/></div>&#13;
<p class="noindent">and similarly for the <em>y</em> and <em>z</em> components. If <strong>C</strong> = <strong>A</strong> – <strong>B</strong>, then</p>&#13;
<div class="imagec"><img src="Images/139equ04.jpg" alt="Image" width="399" height="83"/></div>&#13;
<p class="indent">We say “the components of a difference are the differences of the components.” The first use of the word <em>difference</em> refers to vector difference, while the second use refers to number difference. If <span class="literal">a</span> and <span class="literal">b</span> are vectors, then <span class="literal">xComp (a ^-^ b)</span> and <span class="literal">xComp a - xComp b</span> evaluate to the same number.</p>&#13;
<p class="indent">Here is an example of vector subtraction:</p>&#13;
<pre>*SimpleVec&gt; <span class="codestrong1">vec 1 2 3 ^-^ vec 4 5 6</span>&#13;
vec (-3.0) (-3.0) (-3.0)</pre>&#13;
<h4 class="h4" id="ch10lev13"><span epub:type="pagebreak" id="page_140"/>Dot Product with Coordinate Components</h4>&#13;
<p class="noindent">Suppose <strong>A</strong> and <strong>B</strong> are vectors. Given a coordinate system, we can express each vector in components using Equation 10.4 and then use the distributive property of the dot product along with Equation 10.2 to simplify the result.</p>&#13;
<div class="imagec"><img src="Images/140equ01.jpg" alt="Image" width="527" height="62"/></div>&#13;
<p class="indent">If we know the components of two vectors <strong>A</strong> and <strong>B</strong>, Equation 10.8 gives a handy way to find their dot product.</p>&#13;
<p class="indent">You can take the dot product of two <span class="literal">Vec</span>s with the <span class="literal">&lt;.&gt;</span> operator.</p>&#13;
<pre>*SimpleVec&gt; <span class="codestrong1">vec 1 2 3 &lt;.&gt; vec 4 5 6</span>&#13;
32.0</pre>&#13;
<h4 class="h4" id="ch10lev14">Cross Product with Coordinate Components</h4>&#13;
<p class="noindent">Suppose <strong>A</strong> and <strong>B</strong> are vectors. Given a coordinate system, we can express each vector in components using Equation 10.4 and then use the distributive property of the cross product along with Equation 10.3 to simplify the result.</p>&#13;
<div class="imagec"><img src="Images/140equ02.jpg" alt="Image" width="620" height="64"/></div>&#13;
<p class="indent">If we know the components of two vectors <strong>A</strong> and <strong>B</strong>, Equation 10.9 gives a good way to find their cross product.</p>&#13;
<p class="indent">You can take the cross product of two <span class="literal">Vec</span>s with the <span class="literal">&gt;&lt;</span> operator.</p>&#13;
<pre>*SimpleVec&gt; <span class="codestrong1">vec 1 2 3 &gt;&lt; vec 4 5 6</span>&#13;
vec (-3.0) 6.0 (-3.0)</pre>&#13;
<p class="indent">If you need the components of a vector, you can get them with the <span class="literal">xComp</span> function.</p>&#13;
<pre>*SimpleVec&gt; <span class="codestrong1">xComp $ vec 1 2 3 &gt;&lt; vec 4 5 6</span>&#13;
-3.0</pre>&#13;
<p class="indent">There are also functions <span class="literal">yComp</span> and <span class="literal">zComp</span>.</p>&#13;
<p class="indent">The unary minus sign (<span class="literal">-</span>) will not work to negate a vector, but you can negate a vector with <span class="literal">negateV</span>.</p>&#13;
<pre>*SimpleVec&gt; <span class="codestrong1">negateV $ vec 1 2 3 &gt;&lt; vec 4 5 6</span>&#13;
vec 3.0 (-6.0) 3.0</pre>&#13;
<h4 class="h4" id="ch10lev15">Derivative with Coordinate Components</h4>&#13;
<p class="noindent">Suppose <strong>V</strong> is a vector-valued function of one real variable. If <strong>W</strong> = <em>D</em><strong>V</strong>, then</p>&#13;
<div class="imagec"><img src="Images/140equ03.jpg" alt="Image" width="419" height="25"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_141"/>and similarly for the y- and z-components. If <strong>W</strong> = <em>D</em><strong>V</strong>, then</p>&#13;
<div class="imagec"><img src="Images/141equ01.jpg" alt="Image" width="388" height="83"/></div>&#13;
<p class="indent">Here is an example of a vector-valued function:</p>&#13;
<pre>v1 :: R -&gt; Vec&#13;
v1 t = 2 *^ t**2 *^ iHat ^+^ 3 *^ t**3 *^ jHat ^+^ t**4 *^ kHat</pre>&#13;
<p class="indent">Note that we cannot write the x-component of this vector-valued function in the most obvious way, namely <span class="literal">xComp v1</span>. This would produce a type error because <span class="literal">xComp</span> takes a <span class="literal">Vec</span> as input, not a function <span class="literal">R -&gt; Vec</span>. What we really mean when we talk about the x-component of a vector-valued function is the scalar-valued function that takes an input <span class="literal">t</span>, applies the vector-valued function, and returns the x-component. In Haskell, the x-component of a vector-valued function can be written as follows:</p>&#13;
<pre>xCompFunc :: (R -&gt; Vec) -&gt; R -&gt; R&#13;
xCompFunc v t = xComp (v t)</pre>&#13;
<p class="indent">In words, Equation 10.10 says that the x-component of the derivative is the same as the derivative of the x-component. In Haskell, the same equations say that the x-component of the (vector) derivative</p>&#13;
<pre>xCompFunc . vecDerivative dt</pre>&#13;
<p class="noindent">is the same as the (scalar) derivative of the x-component:</p>&#13;
<pre>derivative dt . xCompFunc</pre>&#13;
<p class="indent">We can check this in GHCi for a particular vector-valued function evaluated at a particular value of the independent variable.</p>&#13;
<pre>*SimpleVec&gt;  <span class="codestrong1">(xCompFunc . vecDerivative 0.01) v1 3</span>&#13;
11.999999999999744&#13;
*SimpleVec&gt;  <span class="codestrong1">(derivative 0.01 . xCompFunc) v1 3</span>&#13;
11.999999999999744</pre>&#13;
<p class="indent">We defined the scalar derivative in <a href="ch04.xhtml">Chapter 4</a> and repeat it here for convenience.</p>&#13;
<pre>type Derivative = (R -&gt; R) -&gt; R -&gt; R&#13;
&#13;
derivative :: R -&gt; Derivative&#13;
derivative dt x t = (x (t + dt/2) - x (t - dt/2)) / dt</pre>&#13;
<p class="indent"><a href="ch10.xhtml#ch10tab2">Table 10-2</a> shows the types of the vector functions and expressions we’ve been working with.</p>&#13;
<span epub:type="pagebreak" id="page_142"/>&#13;
<p class="tabcap" id="ch10tab2"><strong>Table 10-2:</strong> Expressions and Functions for Working with Vectors</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Expression</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"> </p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">zeroV</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">iHat</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">(^+^)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Vec -&gt; Vec -&gt; Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">(^-^)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Vec -&gt; Vec -&gt; Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">(*^)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">R -&gt; Vec -&gt; Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">(^*)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Vec -&gt; R -&gt; Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">(^/)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Vec -&gt; R -&gt; Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">(&lt;.&gt;)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Vec -&gt; Vec -&gt; R</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">(&gt;&lt;)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Vec -&gt; Vec -&gt; Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">negateV</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Vec -&gt; Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">magnitude</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Vec -&gt; R</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">xComp</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Vec -&gt; R</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">vec</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">R -&gt; R -&gt; R -&gt; Vec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">sumV</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">[Vec] -&gt; Vec</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Now that we’ve seen some of the key properties of vectors in both geometric and coordinate settings, let’s take a look at how vectors get used to describe kinematics in three dimensions.</p>&#13;
<h3 class="h3" id="ch10lev16">Kinematics in 3D</h3>&#13;
<p class="noindent">The essential quantities of kinematics are time, position, velocity, and acceleration. Time will continue to be a real number, as it was in <a href="ch04.xhtml">Chapter 4</a>. Velocity and acceleration we’ll now treat as vectors, using the <span class="literal">Vec</span> type that we’ll define at the end of the chapter. What about position?</p>&#13;
<p class="indent">Position is really not a vector. It doesn’t make sense to add positions, nor does it make sense to scale a position by a number. However, subtracting positions does make sense, and it produces a displacement vector from one position to the other. In <a href="ch22.xhtml">Chapter 22</a>, we’ll create a proper type for position, which allows us to use Cartesian, cylindrical, and spherical coordinates to describe positions. However, our aims are more modest at the moment and simplicity suggests that we use the <span class="literal">Vec</span> type for position, even though we just gave some reasons not to. Displacement is certainly a vector, so we can think of a vector-valued position as a displacement from the origin of the default coordinate system.</p>&#13;
<p class="indent">We’ll use the following type synonyms in this chapter:</p>&#13;
<pre>type Time         = R&#13;
type PosVec       = Vec&#13;
type Velocity     = Vec&#13;
type Acceleration = Vec</pre>&#13;
<p class="indent">We use the type <span class="literal">PosVec</span> to denote the type of a position when position is being represented by a vector. This will keep us from confusing it with the <span class="literal">Position</span> type we’ll define in <a href="ch22.xhtml">Chapter 22</a>, which, again, is not a vector.</p>&#13;
<h4 class="h4" id="ch10lev17"><span epub:type="pagebreak" id="page_143"/>Defining Position, Velocity, and Acceleration</h4>&#13;
<p class="noindent">For a particular motion of an object, we define <strong>r</strong> to be the function that associates with each time <em>t</em> the position at which the object is located at time <em>t</em>. We say that <strong>r</strong>(<em>t</em>) is the position of the object at time <em>t</em>.</p>&#13;
<p class="indent">The velocity function for an object is the derivative of its position function.</p>&#13;
<div class="imagec"><img src="Images/143equ01.jpg" alt="Image" width="374" height="20"/></div>&#13;
<p class="indent">Note that Equation 10.11 is an equality of functions, the instantaneous velocity function on the left of the equality, and the derivative of the position function on the right. Equation 10.11 can be written in Haskell as the function <span class="literal">velFromPos</span>, which takes a small time step and position function to return a velocity function.</p>&#13;
<pre>velFromPos :: R                   -- dt&#13;
           -&gt; (Time -&gt; PosVec  )  -- position function&#13;
           -&gt; (Time -&gt; Velocity)  -- velocity function&#13;
velFromPos = vecDerivative</pre>&#13;
<p class="indent">As you can see from the definition, the function <span class="literal">velFromPos</span> is just the vector derivative we defined earlier in the chapter.</p>&#13;
<p class="indent">When two functions are equal, they give equal results for equal inputs, so we can also write</p>&#13;
<div class="imagec"><img src="Images/143equ02.jpg" alt="Image" width="394" height="20"/></div>&#13;
<p class="noindent">for any time <em>t</em>. The righthand side is the function <em>D</em><strong>r</strong> evaluated at time <em>t</em>. We can think of the derivative operator as taking the entire position function as input and returning the velocity function as output. It’s also common to see the notation</p>&#13;
<div class="imagec"><img src="Images/143equ03.jpg" alt="Image" width="395" height="44"/></div>&#13;
<p class="noindent">to define velocity.</p>&#13;
<p class="indent"><em>Speed</em> is the magnitude of the velocity vector. <em>Acceleration</em> is defined to be the rate at which velocity changes. We define <strong>a</strong> to be the function that associates with each time <em>t</em> the rate at which the velocity is changing at time <em>t</em>. In the language of calculus, we can write</p>&#13;
<div class="imagec"><img src="Images/143equ04.jpg" alt="Image" width="374" height="20"/></div>&#13;
<p class="noindent">or</p>&#13;
<div class="imagec"><img src="Images/143equ05.jpg" alt="Image" width="395" height="44"/></div>&#13;
<p class="noindent">to define acceleration. Equation 10.14 can be encoded in a function <span class="literal">accFrom</span> <span class="literal">Vel</span> that produces an acceleration function from a velocity function. Again, this function is just the vector derivative.</p>&#13;
<pre>accFromVel :: R                       -- dt&#13;
           -&gt; (Time -&gt; Velocity)      -- velocity function&#13;
           -&gt; (Time -&gt; Acceleration)  -- acceleration function&#13;
accFromVel = vecDerivative</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_144"/>If the velocity happens to be constant, say <strong>v<sub>0</sub></strong>, we can integrate both sides of Equation 10.11 to obtain</p>&#13;
<div class="equationc"><strong>v</strong><sub>0</sub><em>t</em> = <strong>r</strong>(<em>t</em>) – <em>r</em>(0)</div>&#13;
<p class="indent">If velocity is constant, position is a linear function of time.</p>&#13;
<div class="equationc"><strong>r</strong>(<em>t</em>) = <strong>v</strong><sub>0</sub><em>t</em> + <strong>r</strong>(0)</div>&#13;
<p class="indent">Here is the corresponding Haskell code:</p>&#13;
<pre>positionCV :: PosVec -&gt; Velocity -&gt; Time -&gt; PosVec&#13;
positionCV r0 v0 t = v0 ^* t ^+^ r0</pre>&#13;
<p class="indent">The CV at the end of the name is an abbreviation for constant velocity.</p>&#13;
<p class="indent">If the acceleration happens to be constant, say <strong>a</strong><sub>0</sub>, we can integrate both sides of Equation 10.14 or 10.15 to obtain</p>&#13;
<div class="equationc"><strong>a</strong><sub>0</sub><em>t</em> = <strong>v</strong>(<em>t</em>) – <strong>v</strong>(0)</div>&#13;
<p class="indent">If acceleration is constant, velocity is a linear function of time.</p>&#13;
<div class="imagec"><img src="Images/144equ01.jpg" alt="Image" width="413" height="20"/></div>&#13;
<p class="indent">I like to call Equation 10.16 the <em>velocity-time equation</em> for constant acceleration because it gives the velocity <strong>v</strong>(<em>t</em>) of an object at any time <em>t</em>, provided we know the constant acceleration <strong>a</strong><sub>0</sub> and initial velocity <strong>v</strong>(0). Here is the Haskell code for Equation 10.16:</p>&#13;
<pre>velocityCA :: Velocity -&gt; Acceleration -&gt; Time -&gt; Velocity&#13;
velocityCA v0 a0 t = a0 ^* t ^+^ v0</pre>&#13;
<p class="indent">The CA at the end of the name is an abbreviation for constant acceleration. We can integrate both sides of Equation 10.16 to obtain</p>&#13;
<div class="imagec"><img src="Images/144equ02.jpg" alt="Image" width="217" height="44"/></div>&#13;
<p class="indent">If acceleration is constant, position is a quadratic function of time.</p>&#13;
<div class="imagec"><img src="Images/144equ03.jpg" alt="Image" width="455" height="44"/></div>&#13;
<p class="indent">I like to call Equation 10.17 the <em>position-time equation</em> for constant acceleration because it gives the position <strong>r</strong>(<em>t</em>) of an object at any time <em>t</em>, provided we know the constant acceleration <strong>a</strong><sub>0</sub>, initial position <strong>r</strong>(0), and initial velocity <strong>v</strong>(0). Here is the Haskell code for Equation 10.17:</p>&#13;
<pre>positionCA :: PosVec -&gt; Velocity -&gt; Acceleration&#13;
           -&gt; Time -&gt; PosVec&#13;
positionCA r0 v0 a0 t = 0.5 *^ t**2 *^ a0 ^+^ v0 ^* t ^+^ r0</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_145"/>Equations 10.16 and 10.17 are known as <em>constant acceleration equations</em>. They are used over and over again in a typical introductory physics course. Later we’ll learn some techniques to deal with situations in which acceleration is not constant.</p>&#13;
<p class="indent">Having introduced the definitions of velocity and acceleration in the three-dimensional vector setting, we can now look at how acceleration is composed of two qualitatively different components.</p>&#13;
<h4 class="h4" id="ch10lev18">Two Components of Acceleration</h4>&#13;
<p class="noindent">If at any moment the velocity of an object is 0, any acceleration the object has serves to give the object some velocity in the direction of the acceleration. If, on the other hand, <strong>v</strong>(<em>t</em>)≠0, the relative directions of velocity and acceleration determine the qualitative motion of the object. In everyday speech, people often use the word <em>acceleration</em> to mean increase in speed. However, in physics, acceleration means change in velocity per unit tine, and velocity can change in either magnitude or direction. In physics, acceleration is responsible not only for increases in speed but for decreases in speed and changes in direction.</p>&#13;
<p class="indent">If <strong>v</strong>(<em>t</em>)≠0, we can decompose the acceleration into a component parallel to the velocity and a component perpendicular to the velocity.</p>&#13;
<div class="imagec"><img src="Images/145equ01.jpg" alt="Image" width="425" height="25"/></div>&#13;
<p class="indent">Since <strong>v</strong>(<em>t</em>)≠0, we can define a unit vector in the direction of the velocity.</p>&#13;
<div class="imagec"><img src="Images/145equ02.jpg" alt="Image" width="156" height="52"/></div>&#13;
<p class="indent">The parallel and perpendicular components of acceleration are given by the following equations:</p>&#13;
<div class="imagec"><img src="Images/145equ03.jpg" alt="Image" width="242" height="61"/></div>&#13;
<p class="indent">Here are Haskell functions that calculate the parallel and perpendicular components of acceleration:</p>&#13;
<pre>aParallel :: Vec -&gt; Vec -&gt; Vec&#13;
aParallel v a = let vHat = v ^/ magnitude v&#13;
                in (vHat &lt;.&gt; a) *^ vHat&#13;
&#13;
aPerp :: Vec -&gt; Vec -&gt; Vec&#13;
aPerp v a = a ^-^ aParallel v a</pre>&#13;
<p class="indent">The parallel component <strong>a</strong><sub>∥</sub>(<em>t</em>) is also called the <em>tangential component</em> of acceleration, and it’s responsible for the change in speed of the object. The perpendicular component <strong>a</strong><sub>⊥</sub>(<em>t</em>) is also called the <em>radial</em> or <em>transverse component</em> of acceleration, and it’s responsible for the change in direction of the object.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_146"/>The dot product of velocity and acceleration depends on the angle between them and thus contains useful information. Let’s take the time derivative of the square of the speed <em>v</em><sup>(<em>t</em>)2</sup> = <strong>v</strong>(<em>t</em>) ⋅<strong>v</strong>(<em>t</em>):</p>&#13;
<div class="imagec"><img src="Images/146equ01.jpg" alt="Image" width="600" height="44"/></div>&#13;
<p class="indent">We can see that the dot product of velocity and acceleration controls how the speed changes:</p>&#13;
<table class="all5">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Dot product</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Effect on speed</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><strong>v</strong>(<em>t</em>) ⋅<strong>a</strong>(<em>t</em>) &gt; 0</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Speed increases</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><strong>v</strong>(<em>t</em>) ⋅<strong>a</strong>(<em>t</em>) = 0</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Speed remains constant</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><strong>v</strong>(<em>t</em>) ⋅<strong>a</strong>(<em>t</em>) &lt; 0</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Speed decreases</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">In this chapter, <em>v</em> stands for the speed function, which is a different convention from <a href="ch04.xhtml">Chapter 4</a> where <em>v</em> was the one-dimensional velocity function. One-dimensional velocity can be negative, but speed can’t.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10fig7">Figure 10-7</a> shows how the relative direction of velocity and acceleration controls the qualitative behavior of an object’s motion.</p>&#13;
<div class="imagel" id="ch10fig7"><img src="Images/146equ02.jpg" alt="Image" width="561" height="667"/></div>&#13;
<p class="figcap"><em>Figure 10-7: The relative directions of velocity and acceleration determine the qualitative motion of an object.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_147"/>When acceleration has a component in the direction of velocity, an object speeds up. When acceleration has a component opposite the direction of velocity, an object slows down. When acceleration has only a component perpendicular to the velocity, an object maintains its speed. No coordinate system is necessary to make these conclusions; this aspect of the qualitative behavior of motion is purely geometric.</p>&#13;
<p class="indent">We’ve seen how the tangential component of acceleration is related to speeding up and slowing down. We can make an even stronger statement: the rate of change of speed is directly related to the tangential component.</p>&#13;
<div class="imagec"><img src="Images/147equ01.jpg" alt="Image" width="512" height="182"/></div>&#13;
<p class="indent">Here is the rate of change of speed as a Haskell function. Given the velocity and acceleration of an object, this function returns the rate at which speed is increasing, with a negative result meaning that speed is decreasing.</p>&#13;
<pre>speedRateChange :: Vec -&gt; Vec -&gt; R&#13;
speedRateChange v a = (v &lt;.&gt; a) / magnitude v</pre>&#13;
<p class="indent">The magnitude of the tangential component of acceleration equals the magnitude of the rate of change in speed.</p>&#13;
<div class="imagec"><img src="Images/147equ02.jpg" alt="Image" width="407" height="51"/></div>&#13;
<p class="indent">If there is a transverse component of acceleration, it causes the object to turn (in other words, to change direction). We can calculate a radius of curvature for this turning motion. <a href="ch10.xhtml#ch10fig8">Figure 10-8</a> shows the trajectory of a particle with speed <em>v</em>(<em>t</em>) and transverse acceleration <em>a</em><sub>⊥</sub>(<em>t</em>). Over a small interval of time <em>Δt</em>, the particle will move forward a distance <em>v</em>(<em>t</em>)Δ<em>t</em> and in a perpendicular direction a distance <em>a</em><sub>⊥</sub>(<em>t</em>)Δ<sup><em>t</em>2</sup>/2.</p>&#13;
<div class="imagel" id="ch10fig8"><img src="Images/147fig01.jpg" alt="Image" width="417" height="236"/></div>&#13;
<p class="figcap"><em>Figure 10-8: Determination of a radius of curvature from transverse acceleration</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_148"/><a href="ch10.xhtml#ch10fig8">Figure 10-8</a> gives a way to find an expression for the radius of curvature in terms of the speed and the transverse acceleration. Here we write down the Pythagorean theorem for the right triangle in the figure:</p>&#13;
<div class="imagec"><img src="Images/148equ01.jpg" alt="Image" width="301" height="55"/></div>&#13;
<p class="indent">Expanding this equation and taking the limit as Δ<em>t</em> → 0, which discards the term proportional to Δ<em>t</em><sup>4</sup>, we arrive at the following equation for the radius of curvature:</p>&#13;
<div class="imagec"><img src="Images/148equ02.jpg" alt="Image" width="395" height="52"/></div>&#13;
<p class="indent">Here is a Haskell function that computes the (instantaneous) radius of curvature of an object’s motion from the object’s velocity and acceleration:</p>&#13;
<pre>radiusOfCurvature :: Vec -&gt; Vec -&gt; R&#13;
radiusOfCurvature v a = (v &lt;.&gt; v) / magnitude (aPerp v a)</pre>&#13;
<p class="indent">If we wish, we can invert Equation 10.22 to give an expression for the transverse acceleration in terms of the radius of curvature <em>R</em>.</p>&#13;
<div class="imagec"><img src="Images/148equ03.jpg" alt="Image" width="409" height="48"/></div>&#13;
<p class="indent">As we see from Equations 10.21 and 10.23, the tangential component of acceleration controls the change in speed, and the radial component of acceleration controls the change in direction.</p>&#13;
<h4 class="h4" id="ch10lev19">Projectile Motion</h4>&#13;
<p class="noindent">One of the very first uses to which vectors are typically put in physics is the study of projectile motion. A projectile is any object thrown, launched, or shot near the surface of the earth. The problem is to predict its motion <em>after</em> the throwing, launching, or shooting force is gone; in fact, rather than speak of the launching force, we instead assume that the action of launching simply gives the projectile some initial velocity.</p>&#13;
<p class="indent">It is the presence of Earth’s gravity that makes projectile motion interesting. Physics offers four theories of gravity, three of which we will discuss in this book:</p>&#13;
<ol>&#13;
<li class="noindent">Gravity causes objects near Earth’s surface to accelerate. An object near Earth’s surface that is allowed to move or fall freely will accelerate toward the center of the earth at a rate of about 9.81 m/s<sup>2</sup>.</li>&#13;
<li class="noindent">Gravity is a force produced by the earth on objects near its surface. We engage with this view of gravity in <a href="ch15.xhtml">Chapters 15</a> and <a href="ch16.xhtml">16</a> after we’ve started mechanics and discussed the ideas of force, mass, and Newton’s second law. The Haskell function <span class="literal">earthSurfaceGravity</span> in <a href="ch16.xhtml">Chapter 16</a> describes this force of gravity.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_149"/>Gravity is a force between any two objects with mass. This is called Newton’s law of universal gravitation. We discuss it in <a href="ch16.xhtml">Chapters 16</a> and <a href="ch19.xhtml">19</a> and describe it with the Haskell function <span class="literal">universalGravity</span> after we have introduced Newton’s third law.</li>&#13;
<li class="noindent">Gravity is the curvature of spacetime. This is Einstein’s general theory of relativity. We will not get to it in this book. The book <span class="literal">Gravitation</span> [<strong><a href="bib.xhtml#bib10"><span class="green">10</span></a></strong>] by Charles Misner, Kip Thorne, and John Wheeler is an excellent introduction to general relativity. <em>Functional Differential Geometry</em> [<strong><a href="bib.xhtml#bib11"><span class="green">11</span></a></strong>] by Gerald Sussman and Jack Wisdom looks at general relativity from a computational point of view, describing it with the functional programming language Scheme. Other introductions to general relativity by Rindler [<strong><a href="bib.xhtml#bib12"><span class="green">12</span></a></strong>], Carroll [<strong><a href="bib.xhtml#bib13"><span class="green">13</span></a></strong>], and Schutz [<strong><a href="bib.xhtml#bib14"><span class="green">14</span></a></strong>] are also recommended.</li>&#13;
</ol>&#13;
<p class="indentt">Each theory in this list is more sophisticated than the previous theory. In that sense, the later theories are “more correct” than the earlier ones, although the earlier ones are often more useful since they are simpler and easier to apply. General relativity, in particular, while beautiful and accurate, is rather nontrivial to apply and to calculate with.</p>&#13;
<p class="indent">Some physicists may not agree that the first two theories on my list deserve to be called theories, arguing that they are instead approximations to Newton’s law of universal gravitation applicable to simple situations. It is not my concern to argue whether the first two deserve to be called theories; the important point is that they are different ways to incorporate gravity into our calculations.</p>&#13;
<p class="indent">The simplest way to approach projectile motion, and the one we’ll follow in this chapter, is based on theory 1. We assume the projectile accelerates only because of Earth’s gravitational attraction; therefore, the projectile’s acceleration is given by the acceleration of gravity, <strong>g</strong>, which is a vector pointing toward the center of the earth with magnitude 9.81 m/s<sup>2</sup>.</p>&#13;
<p class="indent">Because the acceleration of gravity is constant, we can use the position-time equation, Equation 10.17, to give an expression for position as a function of time for a projectile.</p>&#13;
<div class="imagec"><img src="Images/149equ01.jpg" alt="Image" width="450" height="45"/></div>&#13;
<p class="indent">If the z-direction is up and we use SI units, the following function returns position as a function of time, where <span class="literal">r0</span> is the initial position of the projectile and <span class="literal">v0</span> is the initial velocity:</p>&#13;
<pre>projectilePos :: PosVec -&gt; Velocity -&gt; Time -&gt; PosVec&#13;
projectilePos r0 v0 = positionCA r0 v0 (9.81 *^ negateV kHat)</pre>&#13;
<p class="indent">In Exercise 10.5, you are asked to write a function <span class="literal">projectileVel</span> that returns the velocity of a projectile as a function of time.</p>&#13;
<p class="indent">Projectile motion with air resistance requires theory 2 because we view air resistance and gravity on an equal footing by seeing them both as forces. To the extent that projectile motion occurs near Earth’s surface, it rarely <span epub:type="pagebreak" id="page_150"/>requires theories 3 or 4, which would produce only the slightest difference in results for a substantial increase in computation complexity. Theory 3 will have other uses, like satellite motion, that we’ll see in later chapters.</p>&#13;
<p class="indent">Having seen projectile motion as one early application of vectors, let’s turn to the project of creating the vector data type we have been using.</p>&#13;
<h3 class="h3" id="ch10lev20">Making Your Own Data Type</h3>&#13;
<p class="noindent">Haskell has a sophisticated and flexible type system. One of the language features that makes the type system so powerful is the ability to create your own types.</p>&#13;
<p class="indent">In discussing pattern matching in <a href="ch03.xhtml">Chapters 3</a> and <a href="ch05.xhtml">5</a>, we noted that each type has one or more data constructors to construct values of that type. In making our own data type, we must provide one or more brand new data constructors as ways of constructing values of our new data type.</p>&#13;
<p class="indent">We’ll first look at making a new data type with a single data constructor before turning to making a new data type with multiple data constructors.</p>&#13;
<h4 class="h4" id="ch10lev21">Single Data Constructor</h4>&#13;
<p class="noindent">In <a href="ch04.xhtml">Chapter 4</a>, we used the <span class="literal">type</span> keyword to make type synonyms. In a type synonym, such as</p>&#13;
<pre>type R = Double</pre>&#13;
<p class="noindent">the compiler regards the types <span class="literal">R</span> and <span class="literal">Double</span> as interchangeable. In <a href="ch04.xhtml">Chapter 4</a>, the types <span class="literal">Time</span>, <span class="literal">Velocity</span>, <span class="literal">R</span>, and <span class="literal">Double</span> were all interchangeable. This was convenient, but it does not empower the Haskell type checker to help the code writer avoid confusing a <span class="literal">Time</span> with a <span class="literal">Velocity</span> or using a <span class="literal">Velocity</span> where a <span class="literal">Time</span> was expected.</p>&#13;
<p class="indent">We use the <span class="literal">data</span> keyword to define new types that are not interchangeable with any existing types. Time and mass are each described by a real number in physics, but we should never provide a mass in an equation that calls for a time. Let’s define a new data type <span class="literal">Mass</span> that holds a real number but cannot be confused with <span class="literal">R</span> or any other existing data type.</p>&#13;
<pre>data Mass = Mass R&#13;
            deriving (Eq,Show)</pre>&#13;
<p class="indent">We use the <span class="literal">data</span> keyword to define a new data type. We give the name of the new data type, <span class="literal">Mass</span> in this case, after the <span class="literal">data</span> keyword, followed by an equal sign. To the right of the equal sign we give a data constructor, <span class="literal">Mass</span> in this case, followed by the information our new data type contains, in this case <span class="literal">R</span>. The name of the new data type and the name of the data constructor can be the same or different. In this case, they have the same name, but they are different things. In defining data types with a single constructor, it’s common to use the same name for the data constructor that we use for the type, but it’s not necessary.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_151"/>By default, a new data type is not an instance of any type classes. Since it’s common to want a new data type to be an instance of some of the standard type classes, such as <span class="literal">Eq</span> and <span class="literal">Show</span>, Haskell provides a <span class="literal">deriving</span> keyword that attempts to make the new type an instance of the type classes listed.</p>&#13;
<p class="indent">To construct a value with type <span class="literal">Mass</span>, we use the data constructor <span class="literal">Mass</span>.</p>&#13;
<pre>*SimpleVec&gt; <span class="codestrong1">Mass 9</span>&#13;
Mass 9.0</pre>&#13;
<p class="indent">If we ask for the type of this value, GHCi will tell us the following:</p>&#13;
<pre>*SimpleVec&gt;  <span class="codestrong1">:t Mass 9</span>&#13;
Mass 9 :: Mass</pre>&#13;
<p class="indent">In GHCi’s response, the <span class="literal">Mass</span> on the left of the double colon is the data constructor, and the <span class="literal">Mass</span> on the right of the double colon is the data type.</p>&#13;
<p class="indent">The data constructor itself has a function type. It takes an <span class="literal">R</span> as input and returns a <span class="literal">Mass</span> as output.</p>&#13;
<pre>*SimpleVec&gt; <span class="codestrong1">:t Mass</span>&#13;
Mass :: R -&gt; Mass</pre>&#13;
<p class="indent">We are asking GHCi for the type of the data constructor, not the type of the type, which wouldn’t make any sense. Again, the <span class="literal">Mass</span> on the left of the double colon is the data constructor, and the <span class="literal">Mass</span> on the right of the double colon is the data type.</p>&#13;
<p class="indent">If we now accidentally supply a <span class="literal">Mass</span> in a place where an <span class="literal">R</span> is called for, the type checker will give us a type error, helping us to identify our mistake rather than silently doing the wrong thing.</p>&#13;
<p class="indent">We can provide more than a single piece of information under the data constructor. In <a href="ch09.xhtml">Chapter 9</a> we used a list of pairs to hold grade information. Let’s define a new data type called <span class="literal">Grade</span> that holds a <span class="literal">String</span> and an <span class="literal">Int</span>, representing the name of a person and their grade on some assignment.</p>&#13;
<pre>data Grade = Grade String Int&#13;
             deriving (Eq,Show)</pre>&#13;
<p class="indent">We give the data constructor the same name as the type and simply list the types of information that are to be contained in the new data type.</p>&#13;
<p class="indent">Here is a list of grades for a few people:</p>&#13;
<pre>grades :: [Grade]&#13;
grades = [Grade "Albert Einstein" 89&#13;
         ,Grade "Isaac Newton"    95&#13;
         ,Grade "Alan Turing"    91&#13;
         ]</pre>&#13;
<p class="indent">To construct a value of type <span class="literal">Grade</span>, we use the data constructor <span class="literal">Grade</span>, followed by a <span class="literal">String</span> and an <span class="literal">Int</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_152"/>If we look at the type of the data constructor <span class="literal">Grade</span>,</p>&#13;
<pre>*SimpleVec&gt; <span class="codestrong1">:t Grade</span>&#13;
Grade :: String -&gt; Int -&gt; Grade</pre>&#13;
<p class="noindent">we see that it takes a <span class="literal">String</span> and an <span class="literal">Int</span> as input and returns a <span class="literal">Grade</span> as output. As before, the <span class="literal">Grade</span> on the left of the double colon is the data constructor, and the <span class="literal">Grade</span> on the right of the double colon is the data type.</p>&#13;
<p class="indent">There is an alternative syntax for defining a new data type, called <em>record syntax</em>, that gives names to each of the pieces of data under a constructor. Let’s define a new data type called <span class="literal">GradeRecord</span> that is essentially the same as the type <span class="literal">Grade</span> but uses record syntax for its definition.</p>&#13;
<pre>data GradeRecord = GradeRecord { name  :: String&#13;
                               , grade :: Int&#13;
                               } deriving (Eq,Show)</pre>&#13;
<p class="indent">To use record syntax, we enclose the names and types of each piece of information in curly braces after the data constructor. Use of record syntax automatically creates a new function for each named piece of information.</p>&#13;
<pre>*SimpleVec&gt; <span class="codestrong1">:t name</span>&#13;
name :: GradeRecord -&gt; String&#13;
*SimpleVec&gt; <span class="codestrong1">:t grade</span>&#13;
grade :: GradeRecord -&gt; Int</pre>&#13;
<p class="indent">The function <span class="literal">name</span> takes a <span class="literal">GradeRecord</span> as input and returns the <span class="literal">String</span> that holds the name in that <span class="literal">GradeRecord</span>. The function <span class="literal">grade</span> takes a <span class="literal">GradeRecord</span> as input and returns the <span class="literal">Int</span> that holds the grade in that <span class="literal">GradeRecord</span>. By default, the names <span class="literal">name</span> and <span class="literal">grade</span> are placed in the global namespace so they may not be reused as names for fields in another data type. This default behavior is simple but too constraining in some situations, so the language option <span class="literal">DuplicateRecordFields</span> is available to override this default behavior, although we will not explore it in this book.</p>&#13;
<p class="indent">If we use record syntax to define our new data type, there are two ways to construct a value of that type. First, we can use the same syntax we used for the type <span class="literal">Grade</span> above, simply giving the data constructor followed by a <span class="literal">String</span> and an <span class="literal">Int</span>.</p>&#13;
<pre>gradeRecords1 :: [GradeRecord]&#13;
gradeRecords1 = [GradeRecord "Albert Einstein" 89&#13;
                ,GradeRecord "Isaac Newton"    95&#13;
                ,GradeRecord "Alan Turing"    91&#13;
                ]</pre>&#13;
<p class="indent">Second, we can use record syntax to construct a value of type <span class="literal">GradeRecord</span>.</p>&#13;
<pre>gradeRecords2 :: [GradeRecord]&#13;
gradeRecords2 = [GradeRecord {name = "Albert Einstein", grade = 89}&#13;
                ,GradeRecord {name = "Isaac Newton"   , grade = 95}&#13;
                ,GradeRecord {name = "Alan Turing"    , grade = 91}&#13;
                ]</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_153"/>Here we use curly braces and give the pieces of information by name rather than by position.</p>&#13;
<p class="indent">The decision on whether to use record syntax should be based on the usefulness of having names to describe the pieces of data that the new type holds. If you don’t need the names, you should use the basic syntax. If the names seem useful, record syntax is a good choice.</p>&#13;
<p class="indent">We’ve seen how to define a new data type with a single data constructor. Now let’s look at data types with more than one data constructor.</p>&#13;
<h4 class="h4" id="ch10lev22">Multiple Data Constructors</h4>&#13;
<p class="noindent">The Prelude type <span class="literal">Bool</span> has two data constructors, <span class="literal">False</span> and <span class="literal">True</span>, as we saw when we did pattern matching on <span class="literal">Bool</span>. Neither of the data constructors contains any information beyond the name of the constructor itself.</p>&#13;
<p class="indent">Let’s define a new data type called <span class="literal">MyBool</span> that works the same way <span class="literal">Bool</span> does. We need a fresh name because <span class="literal">Bool</span> is already defined in the Prelude.</p>&#13;
<pre>data MyBool = MyFalse | MyTrue&#13;
              deriving (Eq,Show)</pre>&#13;
<p class="indent">We begin with the <span class="literal">data</span> keyword as before, followed by the name <span class="literal">MyBool</span> of our new data type. On the right of the equal sign, we give the first data constructor, which we call <span class="literal">MyFalse</span>, then a vertical bar, and then the second data constructor <span class="literal">MyTrue</span>. We need fresh names for the data constructors because the names <span class="literal">False</span> and <span class="literal">True</span> are already taken.</p>&#13;
<p class="indent">The vertical bar in the definition can be read as “or,” in the sense that a value of type <span class="literal">MyBool</span> is either <span class="literal">MyFalse</span> or <span class="literal">MyTrue</span>.</p>&#13;
<p class="indent">Having defined the new data type <span class="literal">MyBool</span>, we can ask about the type of <span class="literal">MyFalse</span>,</p>&#13;
<pre>*SimpleVec&gt; <span class="codestrong1">:t MyFalse</span>&#13;
MyFalse :: MyBool</pre>&#13;
<p class="noindent">and we are not surprised to find that it has type <span class="literal">MyBool</span>.</p>&#13;
<p class="indent">When we have multiple data constructors, they usually have different names from the data type itself.</p>&#13;
<p class="indent">Let’s define our own version of <span class="literal">Maybe</span>, called <span class="literal">MyMaybe</span>. Recall from <a href="ch09.xhtml">Chapter 9</a> that <span class="literal">Maybe</span> is a type constructor, which means that it takes a type as input to produce a new type.</p>&#13;
<pre>data MyMaybe a = MyNothing&#13;
               | MyJust a&#13;
               deriving (Eq,Show)</pre>&#13;
<p class="indent">The type variable <span class="literal">a</span> stands for any type. The fact that we are using a type variable after <span class="literal">MyMaybe</span> in this data type definition makes <span class="literal">MyMaybe</span> a type constructor rather than a type. Here we have two data constructors, but unlike <span epub:type="pagebreak" id="page_154"/>for the type <span class="literal">MyBool</span>, the data constructor <span class="literal">MyJust</span> contains some information, namely a value of type <span class="literal">a</span>. A value of type <span class="literal">MyMaybe a</span> is either <span class="literal">MyNothing</span> or <span class="literal">MyJust x</span> for some <span class="literal">x :: a</span>.</p>&#13;
<p class="indent">Let’s look at the types of the data constructors.</p>&#13;
<pre>*SimpleVec&gt; <span class="codestrong1">:t MyNothing</span>&#13;
MyNothing :: MyMaybe a&#13;
*SimpleVec&gt; <span class="codestrong1">:t MyJust</span>&#13;
MyJust :: a -&gt; MyMaybe a</pre>&#13;
<p class="indent">For comparison, we can look at the types of the Prelude data constructors for <span class="literal">Maybe</span>.</p>&#13;
<pre>*SimpleVec&gt; <span class="codestrong1">:t Nothing</span>&#13;
Nothing :: Maybe a&#13;
*SimpleVec&gt; <span class="codestrong1">:t Just</span>&#13;
Just :: a -&gt; Maybe a</pre>&#13;
<p class="indent">We see that <span class="literal">Nothing</span> is not even a function but just a value of type <span class="literal">Maybe a</span>. On the other hand, <span class="literal">Just</span> is a function that takes a value of type <span class="literal">a</span> and returns a value of type <span class="literal">Maybe a</span>.</p>&#13;
<p class="indent">In <a href="ch19.xhtml">Chapter 19</a>, when we’re talking about systems of particles, we’ll define a new data type called <span class="literal">Force</span> that has two constructors: one for an external force and one for an internal force.</p>&#13;
<p class="indent">Now that we’ve talked about how to define a new data type, let’s move on to define the <span class="literal">Vec</span> type we’ve been using in this chapter.</p>&#13;
<h3 class="h3" id="ch10lev23">Defining a New Data Type for 3D Vectors</h3>&#13;
<p class="noindent">Haskell does not come with a built-in type for vectors, so we have to define it ourselves. In the beginning of this chapter, we looked at how vectors are defined and used in physics. With this knowledge, we’ll turn to the question of how to implement three-dimensional vectors in Haskell. The new type must hold three real numbers, for the three components of a vector in some coordinate system, or something equivalent. We have several options.</p>&#13;
<h4 class="h4" id="ch10lev24">Possible Implementations</h4>&#13;
<p class="noindent">Let’s consider some possible implementations for the type <span class="literal">Vec</span> before making a final choice.</p>&#13;
<h5 class="h5" id="ch10lev25">Option 1: Use a List</h5>&#13;
<p class="noindent">We could use a list of real numbers to hold the three components of a vector. A type synonym for this definition would look like the following:</p>&#13;
<pre>type Vec = [R]  -- not our definition</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_155"/>This type of vector can hold all possible triples of real numbers. The trouble with this definition is that the type can also hold lists of real numbers that don’t have a length of three. This potential type doesn’t match our requirements as nicely as we would like; it’s a little too big, given that the empty list or a list of two real numbers would satisfy the type checker as a legitimate value of this type.</p>&#13;
<h5 class="h5" id="ch10lev26">Option 2: Use a Tuple</h5>&#13;
<p class="noindent">A better option would be to choose a triple of real numbers. A type synonym would look like the following:</p>&#13;
<pre>type Vec = (R,R,R)  -- not our definition</pre>&#13;
<p class="indent">This is a better match for our requirements because this type guarantees that there must be three components. The only downside to this option is the possible confusion of a triple representing the three components of a vector with a triple representing three other numbers, such as the spherical coordinates of a position. Since option 2 uses a type synonym, the type checker could not help us catch an accidental use of our new vector type in a place where some other triple of real numbers is called for.</p>&#13;
<h5 class="h5" id="ch10lev27">Option 3: Make a New Data Type</h5>&#13;
<p class="noindent">A third option is to define a new data type for <span class="literal">Vec</span> that cannot be confused with any other data type, even if the other data type is essentially a collection of three real numbers like <span class="literal">Vec</span>. We want a fundamental concept in physics, like the three-dimensional vector, to be reflected in the type system so the type system can help us keep things straight in a way that respects how we think about the subject. This is the option we’ll pursue next.</p>&#13;
<h4 class="h4" id="ch10lev28">Data Type Definition for Vec</h4>&#13;
<p class="noindent">Here is our data type definition:</p>&#13;
<pre>data Vec = Vec { xComp :: R  -- x component&#13;
               , yComp :: R  -- y component&#13;
               , zComp :: R  -- z component&#13;
               } deriving (Eq)</pre>&#13;
<p class="indent">We decide to use the same name <span class="literal">Vec</span> for the data constructor we used for the type. We use record syntax because that automatically produces functions <span class="literal">xComp</span>, <span class="literal">yComp</span>, and <span class="literal">zComp</span> for the three components of a vector. We ask the compiler, through the <span class="literal">deriving</span> keyword, to create an instance of <span class="literal">Eq</span> for the new <span class="literal">Vec</span> data type. However, we do not ask for an automatic instance of <span class="literal">Show</span> because we want to define that manually.</p>&#13;
<p class="indent">Next, we’ll show how to make the type <span class="literal">Vec</span> an instance of type class <span class="literal">Show</span>. The general way to make a type an instance of a type class is with the <span class="literal">instance</span> keyword.</p>&#13;
<span epub:type="pagebreak" id="page_156"/>&#13;
<pre>instance Show Vec where&#13;
    show (Vec x y z) = "vec " ++ showDouble x ++ " "&#13;
                              ++ showDouble y ++ " "&#13;
                              ++ showDouble z</pre>&#13;
<p class="indent">After the <span class="literal">instance</span> keyword, we give the type class, then the type to be an instance of that type class, and then the keyword <span class="literal">where</span>, before giving definitions for the functions owned by the type class.</p>&#13;
<p class="indent">Starting on the second line, we define the functions owned by the type class, and we say how they are supposed to work for the specific case of the type in question, <span class="literal">Vec</span> in this case. The only function that needs to be defined in an instance of <span class="literal">Show</span> is the function <span class="literal">show</span>, which describes how to turn a <span class="literal">Vec</span> into a <span class="literal">String</span> so it can be shown.</p>&#13;
<p class="indent">Our way of showing a vector begins with the string <span class="literal">"vec "</span>, followed by each of the three components in turn. The function <span class="literal">showDouble</span> does the work of turning each real number into a string.</p>&#13;
<p class="indent">The definition of the <span class="literal">show</span> function inside the instance definition must be indented with respect to the <span class="literal">instance</span> keyword. Any other functions that get defined inside the instance definition must be indented by the same amount.</p>&#13;
<p class="indent">There are actually two other functions owned by type class <span class="literal">Show</span>, called <span class="literal">showsPrec</span> and <span class="literal">showList</span>, but these will get default definitions if we don’t define them, which we didn’t earlier. Using <span class="literal">:i Show</span> in GHCi gives a list of the functions owned by type class <span class="literal">Show</span>, along with which functions <em>must</em> be defined in an instance definition.</p>&#13;
<p class="indent">Here is the function <span class="literal">showDouble</span>, used earlier in the function <span class="literal">show</span>:</p>&#13;
<pre>showDouble :: R -&gt; String&#13;
showDouble x&#13;
    | x &lt; 0      = "(" ++ show x ++ ")"&#13;
    | otherwise  = show x</pre>&#13;
<p class="indent">The type <span class="literal">Double</span> is already an instance of <span class="literal">Show</span>, as noted in <a href="ch08.xhtml">Chapter 8</a>, so the function <span class="literal">show</span> is already available to turn a <span class="literal">Double</span> into a <span class="literal">String</span>. Our function <span class="literal">showDouble</span> uses the function <span class="literal">show</span> and simply encloses negative numbers in parentheses. The reason for enclosing negative components in parentheses is so the way a <span class="literal">Vec</span> gets shown is a legitimate expression for the <span class="literal">Vec</span>, meaning it can be used as input wherever a <span class="literal">Vec</span> is called for. To carry out this plan for having an expression like <span class="literal">vec 3.1 (-4.2) 5.0</span> accepted as a legitimate value of type <span class="literal">Vec</span>, we need a <span class="literal">vec</span> function.</p>&#13;
<pre>-- Form a vector by giving its x, y, and z components.&#13;
vec :: R  -- x component&#13;
    -&gt; R  -- y component&#13;
    -&gt; R  -- z component&#13;
    -&gt; Vec&#13;
vec = Vec</pre>&#13;
<p class="indent">This <span class="literal">vec</span> function does the same thing that the data constructor <span class="literal">Vec</span> does.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_157"/>Why not just use the data constructor <span class="literal">Vec</span> to form and show our vectors, thus eliminating the need to define a <span class="literal">Show</span> instance for <span class="literal">Vec</span> and define the function <span class="literal">vec</span>? This is indeed a possibility, and not a bad one. The main reason I did not do it is that I wanted to use record syntax, and the automatically generated <span class="literal">Show</span> instance obtained by using the <span class="literal">deriving</span> keyword would have used record syntax to show the vector. This in itself is unproblematic, but when we get into lists of vectors, or lists of tuples of vectors, we will want a brief way to show our vectors.</p>&#13;
<p class="indent">Haskell has traditionally favored that what can be shown can also be read. The <span class="literal">Read</span> type class is for types that can be read from a <span class="literal">String</span>, and it serves as a sort of inverse to the <span class="literal">Show</span> type class for types that can be shown as a <span class="literal">String</span>. This is the reason why the <span class="literal">Show</span> instance looks just like the application of the <span class="literal">vec</span> function to three components.</p>&#13;
<h4 class="h4" id="ch10lev29">Vec Functions</h4>&#13;
<p class="noindent">Here are unit vectors in the x-, y-, and z-directions:</p>&#13;
<pre>iHat :: Vec&#13;
iHat = vec 1 0 0&#13;
&#13;
jHat :: Vec&#13;
jHat = vec 0 1 0&#13;
&#13;
kHat :: Vec&#13;
kHat = vec 0 0 1</pre>&#13;
<p class="indent">We give the zero vector the special name <span class="literal">zeroV</span>.</p>&#13;
<pre>zeroV :: Vec&#13;
zeroV = vec 0 0 0</pre>&#13;
<p class="indent">The unary minus sign will not work in front of a vector, so we define a function <span class="literal">negateV</span> that returns the additive inverse of a vector (the negative of the vector).</p>&#13;
<pre>negateV :: Vec -&gt; Vec&#13;
negateV (Vec ax ay az) = Vec (-ax) (-ay) (-az)</pre>&#13;
<p class="indent">Vector addition and subtraction are just the addition and subtraction of the corresponding Cartesian components.</p>&#13;
<pre>(^+^) :: Vec -&gt; Vec -&gt; Vec&#13;
Vec ax ay az ^+^ Vec bx by bz = Vec (ax+bx) (ay+by) (az+bz)&#13;
&#13;
(^-^) :: Vec -&gt; Vec -&gt; Vec&#13;
Vec ax ay az ^-^ Vec bx by bz = Vec (ax-bx) (ay-by) (az-bz)</pre>&#13;
<p class="indent">It’ll be useful to have a function that adds a whole list of vectors. We’ll use this function when we do numeric integrals of vector-valued functions.</p>&#13;
<span epub:type="pagebreak" id="page_158"/>&#13;
<pre>sumV :: [Vec] -&gt; Vec&#13;
sumV = foldr (^+^) zeroV</pre>&#13;
<p class="indent">The function foldr is defined in the Prelude. The definition of sumV is written in point-free style, which means it is short for <span class="literal">sumV vs = foldr (^+^)</span> <span class="literal">zeroV vs</span>. Roughly speaking, foldr takes a binary operator (<span class="literal">(^+^)</span> in this case), an initial value, and a list of values, and “folds” the initial value and an element from the list into an accumulated value, after which it continues to fold the accumulated value with the next element of the list to form a new accumulated value until the list is gone and the final accumulated value is returned. It’s a fairly powerful function, but here it’s used just to keep adding the members of the list until there are no more.</p>&#13;
<p class="indent">There are three ways to multiply three-dimensional vectors. The first is scalar multiplication, in which we multiply a number by a vector or a vector by a number. We use <span class="literal">(*^)</span> and <span class="literal">(^*)</span> for scalar multiplication. The first takes a number on the left and a vector on the right. The second takes a vector on the left and a number on the right. The vector always goes next to the caret symbol. The second vector multiplication method is the dot product. We use <span class="literal">(&lt;.&gt;)</span> for the dot product. The third vector multiplication method is the cross product. We use <span class="literal">(&gt;&lt;)</span> for the cross product.</p>&#13;
<p class="indent">Here are the definitions for the three vector multiplications:</p>&#13;
<pre>(*^)  :: R   -&gt; Vec -&gt; Vec&#13;
c *^ Vec ax ay az = Vec (c*ax) (c*ay) (c*az)&#13;
&#13;
(^*)  :: Vec -&gt; R   -&gt; Vec&#13;
Vec ax ay az ^* c = Vec (c*ax) (c*ay) (c*az)&#13;
&#13;
(&lt;.&gt;) :: Vec -&gt; Vec -&gt; R&#13;
Vec ax ay az &lt;.&gt; Vec bx by bz = ax*bx + ay*by + az*bz&#13;
&#13;
(&gt;&lt;)  :: Vec -&gt; Vec -&gt; Vec&#13;
Vec ax ay az &gt;&lt; Vec bx by bz&#13;
    = Vec (ay*bz - az*by) (az*bx - ax*bz) (ax*by - ay*bx)</pre>&#13;
<p class="indent">The first two definitions are for scalar multiplication. If the vector is to the right of the number, we use the operator with the caret on the right. If the vector is to the left of the number, we use the operator with the caret on the left. In either case, the definition says that scalar multiplication is carried out by multiplying each Cartesian component by the scaling number. The dot product is defined via Equation 10.8. The cross product is defined via Equation 10.9.</p>&#13;
<p class="indent">We can also divide a vector by a scalar.</p>&#13;
<pre>(^/) :: Vec -&gt; R -&gt; Vec&#13;
Vec ax ay az ^/ c = Vec (ax/c) (ay/c) (az/c)</pre>&#13;
<p class="indent">Finally, we define a <span class="literal">magnitude</span> function to take the magnitude of a vector.</p>&#13;
<span epub:type="pagebreak" id="page_159"/>&#13;
<pre>magnitude :: Vec -&gt; R&#13;
magnitude v = sqrt(v &lt;.&gt; v)</pre>&#13;
<p class="indent">This completes our data type definition for the new data type <span class="literal">Vec</span>, along with supporting functions that allow us to write about vectors in the way we think about them and use them in physics.</p>&#13;
<h3 class="h3" id="ch10lev30">Summary</h3>&#13;
<p class="noindent">This chapter discussed kinematics in three spatial dimensions. In three dimensions, time is represented by a real number while velocity and acceleration are represented by vectors. Position is not truly a vector, but in this chapter we keep it simple and regard position as the displacement vector from the origin of some preferred or default coordinate system.</p>&#13;
<p class="indent">Vectors are fundamentally geometric entities; to use numbers to describe the components of a vector, we must introduce a coordinate system. In any situation in which an object is moving, we can decompose the acceleration into a component parallel to the velocity and a component perpendicular to the velocity. This decomposition is coordinate independent.</p>&#13;
<p class="indent">With a system for vectors in place, we are now in a position to do all the projectile motion problems we ever wanted to do. We showed Haskell’s facility for defining our own data types, and we used that system to implement the <span class="literal">Vec</span> type for three-dimensional vectors.</p>&#13;
<h3 class="h3" id="ch10lev31">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 10.1.</strong> Translate the following mathematical definitions into Haskell definitions:</p>&#13;
<table class="all6">&#13;
<colgroup>&#13;
<col style="width:60%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">(a) <img class="inline" src="Images/e0159-01.jpg" alt="Image" width="71" height="25"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">(Use <span class="literal">v0</span> in Haskell for <span class="literal"><strong>v</strong><sub>0</sub></span>.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">(b) <img class="inline" src="Images/e0159-02.jpg" alt="Image" width="129" height="25"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">(Use <span class="literal">v1</span> for <span class="literal"><strong>v</strong><sub>1</sub></span>.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">(c) <img class="inline" src="Images/e0159-03.jpg" alt="Image" width="145" height="26"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">(Use <span class="literal">v</span> for <strong>v</strong>.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">(d) <img class="inline" src="Images/e0159-04.jpg" alt="Image" width="207" height="26"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">(Use <span class="literal">r</span> for <strong>r</strong>.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">(e) <img class="inline" src="Images/e0159-05.jpg" alt="Image" width="101" height="25"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">(Use <span class="literal">x</span> for <em>x</em>.)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">What are the Haskell types of v0, v1, v, r, and x?</p>&#13;
<p class="noindentts"><strong>Exercise 10.2.</strong> Write an integration function</p>&#13;
<pre>vecIntegral :: R          -- step size dt&#13;
            -&gt; (R -&gt; Vec) -- vector-valued function&#13;
            -&gt; R          -- lower limit&#13;
            -&gt; R          -- upper limit&#13;
            -&gt; Vec        -- result&#13;
vecIntegral = undefined</pre>&#13;
<p class="noindentts">for vector-valued functions of a real variable that is similar to the function</p>&#13;
<span epub:type="pagebreak" id="page_160"/>&#13;
<pre>integral :: R -&gt; (R -&gt; R) -&gt; R -&gt; R -&gt; R -- from <a href="ch06.xhtml">Chapter 6</a></pre>&#13;
<p class="noindentts">that we wrote in <a href="ch06.xhtml">Chapter 6</a>.</p>&#13;
<p class="noindentts"><strong>Exercise 10.3.</strong> Write a function</p>&#13;
<pre>maxHeight :: PosVec -&gt; Velocity -&gt; R&#13;
maxHeight = undefined</pre>&#13;
<p class="noindentts">that returns the maximum z-component for projectile motion in which the initial position and the initial velocity of an object are given. Assume gravity acts in the negative z-direction.</p>&#13;
<p class="noindentts"><strong>Exercise 10.4.</strong> Write a function</p>&#13;
<pre>speedCA :: Velocity -&gt; Acceleration -&gt; Time -&gt; R&#13;
speedCA = undefined</pre>&#13;
<p class="noindentts">that, given an initial velocity and a constant acceleration, returns a function giving speed as a function of time.</p>&#13;
<p class="noindentts"><strong>Exercise 10.5.</strong> In the spirit of the function <span class="literal">projectilePos</span>, write a type signature and function definition for a function <span class="literal">projectileVel</span> that computes the velocity of a projectile at a given time.</p>&#13;
<p class="noindentts"><strong>Exercise 10.6.</strong> Define a new type <span class="literal">Vec2D</span> for two-dimensional vectors. Then define functions</p>&#13;
<pre>magAngleFromVec2D :: Vec2D -&gt; (R,R)&#13;
magAngleFromVec2D = undefined&#13;
&#13;
vec2DFromMagAngle :: (R,R) -&gt; Vec2D&#13;
vec2DFromMagAngle = undefined</pre>&#13;
<p class="noindentts">that find the magnitude and angle of a two-dimensional vector and construct a two-dimensional vector from a magnitude and angle. You may want to use the <span class="literal">atan</span> or <span class="literal">atan2</span> functions, which we discussed in <a href="ch01.xhtml">Chapter 1</a>.</p>&#13;
<p class="noindentts"><strong>Exercise 10.7.</strong> Define a function</p>&#13;
<pre>xyProj :: Vec -&gt; Vec&#13;
xyProj = undefined</pre>&#13;
<p class="noindentts">that computes the projection of a vector into the xy plane. For example, <span class="literal">xyProj (vec 6 9 7)</span> should evaluate to <span class="literal">vec 6 9 0</span>.</p>&#13;
<p class="noindentts"><strong>Exercise 10.8.</strong> Define a function</p>&#13;
<pre>magAngles :: Vec -&gt; (R,R,R)&#13;
magAngles = undefined</pre>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_161"/>that returns a triple (<em>v</em>, <em>θ</em>, <em>ϕ</em>) for a vector <strong>v</strong> in which</p>&#13;
<div class="imagec"><img src="Images/161equ01.jpg" alt="Image" width="167" height="143"/></div>&#13;
<p class="indent">For example, <span class="literal">magAngles (vec (-1) (-2) (-3))</span> should evaluate to:</p>&#13;
<pre>(3.7416573867739413,2.5010703409103687,-2.0344439357957027)</pre>&#13;
<p class="noindentts"><strong>Exercise 10.9.</strong> The velocity and acceleration of a ball launched from the ground are</p>&#13;
<div class="imagec"><img src="Images/161equ02.jpg" alt="Image" width="168" height="76"/></div>&#13;
<p class="noindentts">where <strong>v</strong><sub>0</sub> is the initial velocity of the ball and <strong>g</strong> is the acceleration of gravity. Suppose a ball is launched from the ground with an initial speed of 25 m/s at an angle 52<sup>∘</sup> above horizontal. Choose a coordinate system and define a constant</p>&#13;
<pre>gEarth :: Vec&#13;
gEarth = undefined</pre>&#13;
<p class="noindentts">for the acceleration of gravity near Earth’s surface. It should be 9.8 m/s<sup>2</sup> toward the center of the earth. Next, define a function</p>&#13;
<pre>vBall :: R -&gt; Vec&#13;
vBall t = undefined t</pre>&#13;
<p class="noindentts">that gives the velocity of the ball as a function of time. Now define a function</p>&#13;
<pre>speedRateChangeBall :: R -&gt; R&#13;
speedRateChangeBall t = undefined t</pre>&#13;
<p class="noindentts">that gives the rate of change of the speed of the ball as a function of time. You may want to use <span class="literal">speedRateChange</span> for this. At what point in the ball’s motion is the rate of change of its speed equal to zero? Is its velocity zero at that point? Is its acceleration zero at that point? Use <span class="literal">plotFunc</span> from <a href="ch07.xhtml">Chapter 7</a> to make a graph of the rate of change of the speed of the ball as a function of time over the four seconds it is in the air.</p>&#13;
<p class="noindentts"><strong>Exercise 10.10.</strong> Consider a particle in uniform circular motion. If we choose our coordinate system so that the motion takes place in the xy-plane with the origin at the center of the circle, we can write the position of the particle as</p>&#13;
<div class="imagec"><img src="Images/161equ03.jpg" alt="Image" width="253" height="26"/></div>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_162"/>where <em>R</em> is the radius of the circle and <em>ω</em> is the angular velocity of the motion. The velocity of the particle can be found by taking the derivative of position with respect to time.</p>&#13;
<div class="imagec"><img src="Images/162equ01.jpg" alt="Image" width="281" height="27"/></div>&#13;
<p class="indent">The acceleration of the particle can be found by taking the derivative of velocity with respect to time.</p>&#13;
<div class="imagec"><img src="Images/162equ02.jpg" alt="Image" width="288" height="26"/></div>&#13;
<p class="indent">This particle in uniform circular motion has a speed <em>v</em><sub><em>UCM</em></sub> (<em>t</em>) = <em>ωR</em>, which does not depend on time. The constant speed is what we mean by the word “uniform.”</p>&#13;
<p class="indent">For a uniform circular motion with <em>R</em> = 2 m and <em>ω</em> = 6 rad/s, encode the position, velocity, and acceleration of the particle in Haskell. Use <span class="literal">aParallel</span> to confirm that the tangential component of acceleration is 0 at several different times. Use <span class="literal">aPerp</span> to confirm that the magnitude of the radial component of acceleration is [<em>v</em><sub>UCM</sub> (<em>t</em>)]<sup>2</sup>/<em>R</em> = <sup><em>ω</em>2</sup><em>R</em>, again at several different times.</p>&#13;
<p class="noindentts"><strong>Exercise 10.11.</strong> Consider a particle in nonuniform circular motion on a circle with radius <em>R</em>. If we choose our coordinate system so that the motion takes place in the xy-plane with the origin at the center of the circle, we can write the position of the particle as</p>&#13;
<div class="imagec"><img src="Images/162equ03.jpg" alt="Image" width="273" height="26"/></div>&#13;
<p class="noindentts">where <em>θ</em>(<em>t</em>) describes the angle the particle makes with the x-axis as a function of time. The velocity of the particle can be found by taking the derivative of position with respect to time.</p>&#13;
<div class="imagec"><img src="Images/162equ04.jpg" alt="Image" width="334" height="26"/></div>&#13;
<p class="indent">The acceleration of the particle can be found by taking the derivative of velocity with respect to time.</p>&#13;
<div class="imagec"><img src="Images/162equ05.jpg" alt="Image" width="625" height="27"/></div>&#13;
<p class="indent">This particle in circular motion has speed <em>v</em><sub>NCM</sub> (<em>t</em>) = <em>R</em> |<em>Dθ</em>(<em>t</em>)|, which will depend on time unless <em>Dθ</em>(<em>t</em>) is constant. The magnitude of the particle’s tangential acceleration is <em>R</em> |<sup><em>D</em>2</sup><em>θ</em>(<em>t</em>)| and the magnitude of its radial acceleration is [<em>v</em><sub>NCM</sub> (<em>t</em>)]<sup>2</sup>/<em>R</em> = <em>R</em>[<em>Dθ</em>(<em>t</em>)]<sup>2</sup>.</p>&#13;
<p class="indent">Write a function</p>&#13;
<pre>rNCM :: (R, R -&gt; R) -&gt; R -&gt; Vec&#13;
rNCM (radius, theta) t = undefined radius theta t</pre>&#13;
<p class="noindentts">that takes a radius <em>R</em>, a function <em>θ</em>, and a time <em>t</em> as input and returns a position vector as output.</p>&#13;
<p class="indent">The purpose of this exercise is to confirm that, even in nonuniform circular motion, the magnitude of a particle’s radial component of acceleration <span epub:type="pagebreak" id="page_163"/>is equal to the square of its speed divided by the radius of the circle. The following function finds the radial component of acceleration for any particle whose position can be given as function of time. Its first input is a small time interval to use for numerical derivatives. Its second input is the position function for the particle, and its third input is time.</p>&#13;
<pre>aPerpFromPosition :: R -&gt; (R -&gt; Vec) -&gt; R -&gt; Vec&#13;
aPerpFromPosition epsilon r t&#13;
    = let v = vecDerivative epsilon r&#13;
          a = vecDerivative epsilon v&#13;
      in aPerp (v t) (a t)</pre>&#13;
<p class="indent">For a radius <em>R</em> = 2 m and</p>&#13;
<div class="imagec"><img src="Images/163equ01.jpg" alt="Image" width="173" height="45"/></div>&#13;
<p class="noindentts">use <span class="literal">aPerpFromPosition</span> to find the radial component of acceleration at <em>t</em> = 2 seconds. Then find the speed of the particle at that time. Finally, show that the magnitude of the radial component is equal to the square of its speed divided by the radius of the circle.<span epub:type="pagebreak" id="page_164"/></p>&#13;
</div></body></html>