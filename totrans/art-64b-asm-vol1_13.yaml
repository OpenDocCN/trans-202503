- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SIMD Instructions
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: This chapter discusses the *vector instructions* on the x86-64\. This special
    class of instructions provides parallel processing, traditionally known as *single-instruction,
    multiple-data (**SIMD)* instructions because, quite literally, a single instruction
    operates on several pieces of data concurrently. As a result of this concurrency,
    SIMD instructions can often execute several times faster (in theory, as much as
    32 to 64 times faster) than the comparable *single-instruction, single-data (SISD),*
    or *scalar,* instructions that compose the standard x86-64 instruction set.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'The x86-64 actually provides three sets of vector instructions: the Multimedia
    Extensions (MMX) instruction set, the Streaming SIMD Extensions (SSE) instruction
    set, and the Advanced Vector Extensions (AVX) instruction set. This book does
    not consider the MMX instructions as they are obsolete (SSE equivalents exist
    for the MMX instructions).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The x86-64 vector instruction set (SSE/AVX) is almost as large as the scalar
    instruction set. A whole book could be written about SSE/AVX programming and algorithms.
    However, this is not that book; SIMD and parallel algorithms are an advanced subject
    beyond the scope of this book, so this chapter settles for introducing a fair
    number of SSE/AVX instructions and leaves it at that.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: This chapter begins with some prerequisite information. First, it begins with
    a discussion of the x86-64 vector architecture and streaming data types. Then,
    it discusses how to detect the presence of various vector instructions (which
    are not present on all x86-64 CPUs) by using the `cpuid` instruction. Because
    most vector instructions require special memory alignment for data operands, this
    chapter also discusses MASM segments.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 11.1 The SSE/AVX Architectures
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s begin by taking a quick look at the SSE and AVX features in the x64-86
    CPUs. The SSE and AVX instructions have several variants: the original SSE, plus
    SSE2, SSE3, SSE3, SSE4 (SSE4.1 and SSE4.2), AVX, AVX2 (AVX and AVX2 are sometimes
    called AVX-256), and AVX-512\. SSE3 was introduced along with the Pentium 4F (Prescott)
    CPU, Intel’s first 64-bit CPU. Therefore, you can assume that all Intel 64-bit
    CPUs support the SSE3 and earlier SIMD instructions.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'The SSE/AVX architectures have three main generations:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The SSE architecture, which (on 64-bit CPUs) provided sixteen 128-bit XMM registers
    supporting integer and floating-point data types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AVX/AVX2 architecture, which supported sixteen 256-bit YMM registers (also
    supporting integer and floating-point data types)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AVX-512 architecture, which supported up to thirty-two 512-bit ZMM registers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a general rule, this chapter sticks to AVX2 and earlier instructions in its
    examples. Please see the Intel and AMD CPU manuals for a discussion of the additional
    instruction set extensions such as AVX-512\. This chapter does not attempt to
    describe every SSE or AVX instruction. Most streaming instructions have very specialized
    purposes and aren’t particularly useful in generic applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 11.2 Streaming Data Types
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The SSE and AVX programming models support two basic data types: scalars and
    vectors. *Scalars* hold one single- or double-precision floating-point value.
    *Vectors* hold multiple floating-point or integer values (between 2 and 32 values,
    depending on the scalar data type of byte, word, dword, qword, single precision,
    or double precision, and the register and memory size of 128 or 256 bits).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The XMM registers (XMM0 to XMM15) can hold a single 32-bit floating-point value
    (a scalar) or four single-precision floating-point values (a vector). The YMM
    registers (YMM0 to YMM15) can hold eight single-precision (32-bit) floating-point
    values (a vector); see [Figure 11-1](#figure11-1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![f11001](image_fi/501089c11/f11001.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-1: Packed and scalar single-precision floating-point data type'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The XMM registers can hold a single double-precision scalar value or a vector
    containing a pair of double-precision values. The YMM registers can hold a vector
    containing four double-precision floating-point values, as shown in [Figure 11-2](#figure11-2).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![f11002](image_fi/501089c11/f11002.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-2: Packed and scalar double-precision floating-point type'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The XMM registers can hold 16 byte values (YMM registers can hold 32 byte values),
    allowing the CPU to perform 16 (32) byte-sized computations with one instruction
    ([Figure 11-3](#figure11-3)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![f11003](image_fi/501089c11/f11003.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-3: Packed byte data type'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The XMM registers can hold eight word values (YMM registers can hold sixteen
    word values), allowing the CPU to perform eight (sixteen) 16-bit word-sized integer
    computations with one instruction ([Figure 11-4](#figure11-4)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![f11004](image_fi/501089c11/f11004.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-4: Packed word data type'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The XMM registers can hold four dword values (YMM registers can hold eight dword
    values), allowing the CPU to perform four (eight) 32-bit dword-sized integer computations
    with one instruction ([Figure 11-5](#figure11-5)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![f11005](image_fi/501089c11/f11005.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-5: Packed double-word data type'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The XMM registers can hold two qword values (YMM registers can hold four qword
    values), allowing the CPU to perform two (four) 64-bit qword computations with
    one instruction ([Figure 11-6](#figure11-6)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![f11006](image_fi/501089c11/f11006.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-6: Packed quad-word data type'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Intel’s documentation calls the vector elements in an XMM and a YMM register
    *lanes*. For example, a 128-bit XMM register has 16 bytes. Bits 0 to 7 are lane
    0, bits 8 to 15 are lane 1, bits 16 to 23 are lane 2, . . . , and bits 120 to
    127 are lane 15\. A 256-bit YMM register has 32 byte-sized lanes, and a 512-bit
    ZMM register has 64 byte-sized lanes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, a 128-bit XMM register has eight word-sized lanes (lanes 0 to 7).
    A 256-bit YMM register has sixteen word-sized lanes (lanes 0 to 15). On AVX-512-capable
    CPUs, a ZMM register (512 bits) has thirty-two word-sized lanes, numbered 0 to
    31.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: An XMM register has four dword-sized lanes (lanes 0 to 3); it also has four
    single-precision (32-bit) floating-point lanes (also numbered 0 to 3). A YMM register
    has eight dword or single-precision lanes (lanes 0 to 7). An AVX2 ZMM register
    has sixteen dword or single-precision-sized lanes (numbers 0 to 15).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: XMM registers support two qword-sized lanes (or two double-precision lanes),
    numbered 0 to 1\. As expected, a YMM register has twice as many (four lanes, numbered
    0 to 3), and an AVX2 ZMM register has four times as many lanes (0 to 7).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Several SSE/AVX instructions refer to various lanes within these registers.
    In particular, the shuffle and unpack instructions allow you to move data between
    lanes in SSE and AVX operands. See “The Shuffle and Unpack Instructions” on page
    625 for examples of lane usage.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 11.3 Using cpuid to Differentiate Instruction Sets
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Intel introduced the 8086 (and shortly thereafter, the 8088) microprocessor
    in 1978\. With almost every succeeding CPU generation, Intel added new instructions
    to the instruction set. Until this chapter, this book has used instructions that
    are generally available on all x86-64 CPUs (Intel and AMD). This chapter presents
    instructions that are available only on later-model x86-64 CPUs. To allow programmers
    to determine which CPU their applications were using so they could dynamically
    avoid using newer instructions on older processors, Intel introduced the `cpuid`
    instruction.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The `cpuid` instruction expects a single parameter (called a *leaf* function)
    passed in the EAX register. It returns various pieces of information about the
    CPU in different 32-bit registers based on the value passed in EAX. An application
    can test the return information to see if certain CPU features are available.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: As Intel introduced new instructions, it changed the behavior of `cpuid` to
    reflect those changes. Specifically, Intel changed the range of values a program
    could legally pass in EAX to `cpuid`; this is known as the *highest function supported*.
    As a result, some 64-bit CPUs accept only values in the range 0h to 05h. The instructions
    this chapter discusses may require passing values in the range 0h to 07h. Therefore,
    the first thing you have to do when using `cpuid` is to verify that it accepts
    EAX = 07h as a valid parameter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: To determine the highest function supported, you load EAX with 0 or 8000_0000h
    and execute the `cpuid` instruction (all 64-bit CPUs support these two function
    values). The return value is the maximum you can pass to `cpuid` in EAX. The Intel
    and AMD documentation (also see [https://en.wikipedia.org/wiki/CPUID](https://en.wikipedia.org/wiki/CPUID))
    will list the values `cpuid` returns for various CPUs; for the purposes of this
    chapter, we need only verify that the highest function supported is 01h (which
    is true for all 64-bit CPUs) or 07h for certain instructions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to providing the highest function supported, the `cpuid` instruction
    with EAX = 0h (or 8000_0002h) also returns a 12-character vendor ID in the EBX,
    ECX, and EDX registers. For x86-64 chips, this will be either of the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: GenuineIntel (EBX is 756e_6547h, EDX is 4965_6e69h, and ECX is 6c65_746eh)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AuthenticAMD (EBX is 6874_7541h, EDX is 6974_6E65h, and ECX is 444D_4163h)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To determine if the CPU can execute most SSE and AVX instructions, you must
    execute `cpuid` with EAX = 01h and test various bits placed in the ECX register.
    For a few of the more advanced features (advanced bit-manipulation functions and
    AVX2 instructions), you’ll need to execute `cpuid` with EAX = 07h and check the
    results in the EBX register. The `cpuid` instruction (with EAX = 1) returns an
    interesting SSE/AVX feature flag in the following bits in ECX, as shown in [Table
    11-1](#table11-1); with EAX = 07h, it returns the bit manipulation or AVX2 flag
    in EBX, as shown in [Table 11-2](#table11-2). If the bit is set, the CPU supports
    the specific instruction(s).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-1: Intel `cpuid` Feature Flags (EAX = 1)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit** | **ECX** |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| 0 | SSE3 support |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| 1 | PCLMULQDQ support |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| 9 | SSSE3 support |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| 19 | CPU supports SSE4.1 instructions |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '| 20 | CPU supports SSE4.2 instructions |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| 28 | Advanced Vector Extensions |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: 'Table 11-2: Intel `cpuid` Extended Feature Flags (EAX = 7, ECX = 0)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit** | **EBX** |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| 3 | Bit Manipulation Instruction Set 1 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| 5 | Advanced Vector Extensions 2 (AVX2) |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| 8 | Bit Manipulation Instruction Set 2 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '[Listing 11-1](#listing11-1) queries the vendor ID and basic feature flags
    on a CPU.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 11-1: `cpuid` demonstration program'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'On an old MacBook Pro Retina with an Intel i7-3720QM CPU, running under Parallels,
    you get the following output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This CPU supports SSE3 instructions (bit 0 of ECX is 1), SSE4.1 and SSE4.2 instructions
    (bits 19 and 20 of ECX are 1), and the AVX instructions (bit 28 is 1). Those,
    largely, are the instructions this chapter describes. Most modern CPUs will support
    these instructions (the i7-3720QM was released by Intel in 2012). The processor
    doesn’t support some of the more interesting extended features on the Intel instruction
    set (the extended bit-manipulation instructions and the AVX2 instruction set).
    Programs using those instructions will not execute on this (ancient) MacBook Pro.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this on a more recent CPU (an iMac Pro 10-core Intel Xeon W-2150B)
    produces the following output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在一台较新的 CPU（iMac Pro 10 核 Intel Xeon W-2150B）上运行此程序，产生以下输出：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, looking at the extended feature bits, the newer Xeon CPU does
    support these additional instructions. The code fragment in [Listing 11-2](#listing11-2)
    provides a quick modification to [Listing 11-1](#listing11-1) that tests for the
    availability of the BMI1 and BMI2 bit-manipulation instruction sets (insert the
    following code right before the `allDone` label in [Listing 11-1](#listing11-1)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通过查看扩展特性位，较新的 Xeon CPU 确实支持这些额外的指令。列表 [11-2](#listing11-2) 中的代码片段提供了对 [列表
    11-1](#listing11-1) 的快速修改，用来测试 BMI1 和 BMI2 位操作指令集的可用性（将以下代码插入到 [列表 11-1](#listing11-1)
    中的 `allDone` 标签之前）。
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 11-2: Test for BMI1 and BMI2 instruction sets'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-2：测试 BMI1 和 BMI2 指令集
- en: 'Here’s the build command and program output on the Intel i7-3720QM CPU:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 Intel i7-3720QM CPU 上的构建命令和程序输出：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s the same program running on the iMac Pro (Intel Xeon W-2150B):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相同的程序在 iMac Pro（Intel Xeon W-2150B）上运行的情况：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 11.4 Full-Segment Syntax and Segment Alignment
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 完整段语法与段对齐
- en: As you will soon see, SSE and AVX memory data require alignment on 16-, 32-,
    and even 64-byte boundaries. Although you can use the `align` directive to align
    data (see “MASM Support for Data Alignment” in Chapter 3), it doesn’t work beyond
    16-byte alignment when using the simplified segment directives presented thus
    far in this book. If you need alignment beyond 16 bytes, you have to use MASM
    full-segment declarations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，SSE 和 AVX 内存数据需要在 16 字节、32 字节甚至 64 字节的边界上进行对齐。虽然你可以使用 `align` 指令来对齐数据（详见第
    3 章中的“MASM 对数据对齐的支持”），但在使用本书中介绍的简化段指令时，16 字节对齐以外的对齐将不起作用。如果需要超过 16 字节的对齐，则必须使用
    MASM 完整段声明。
- en: 'If you want to create a segment with complete control over segment attributes,
    you need to use the `segment` and `ends` directives.^([1](#c11-footnote-1)) The
    generic syntax for a segment declaration is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建一个可以完全控制段属性的段，则需要使用 `segment` 和 `ends` 指令。^([1](#c11-footnote-1)) 段声明的通用语法如下：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`segname` is an identifier. This is the name of the segment (which must also
    appear before the closing `ends` directive). It need not be unique; you can have
    several segment declarations that share the same name. MASM will combine segments
    with the same name when emitting code to the object file. Avoid the segment names
    `_TEXT`, `_DATA`, `_BSS`, and `_CONST`, as MASM uses these names for the `.code`,
    `.data`, `.data?`, and `.const` directives, respectively.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`segname` 是一个标识符。它是段的名称（也必须出现在 `ends` 指令之前）。它不需要是唯一的；你可以有多个段声明使用相同的名称。当 MASM
    输出代码到目标文件时，它会将具有相同名称的段合并。避免使用 `_TEXT`、`_DATA`、`_BSS` 和 `_CONST` 作为段名称，因为 MASM
    分别将这些名称用于 `.code`、`.data`、`.data?` 和 `.const` 指令。'
- en: The `readonly` option is either blank or the MASM-reserved word `readonly`.
    This is a hint to MASM that the segment will contain read-only (constant) data.
    If you attempt to (directly) store a value into a variable that you declare in
    a read-only segment, MASM will complain that you cannot modify a read-only segment.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`readonly` 选项可以为空或是 MASM 保留字 `readonly`。这提示 MASM 该段将包含只读（常量）数据。如果你试图（直接）将值存储到在只读段中声明的变量，MASM
    将会报错，指出不能修改只读段。'
- en: 'The `alignment` option is also optional and allows you to specify one of the
    following options:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`alignment` 选项是可选的，它允许你指定以下选项之一：'
- en: '`byte`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`'
- en: '`word`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`word`'
- en: '`dword`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dword`'
- en: '`para`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`para`'
- en: '`page`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page`'
- en: '`align(``n``)` (`n` is a constant that must be a power of 2)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`align(``n``)` （`n` 是一个常量，必须是 2 的幂）'
- en: The alignment options tell MASM that the first byte emitted for this particular
    segment must appear at an address that is a multiple of the alignment option.
    The `byte`, `word`, and `dword` reserved words specify 1-, 2-, or 4-byte alignments.
    The `para` alignment option specifies paragraph alignment (16 bytes). The `page`
    alignment option specifies an address alignment of 256 bytes. Finally, the `align(``n``)`
    alignment option lets you specify any address alignment that is a power of 2 (1,
    2, 4, 8, 16, 32, and so on).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐选项告诉 MASM，此特定段的第一个字节必须出现在对齐选项的倍数地址上。`byte`、`word` 和 `dword` 保留字指定 1 字节、2 字节或
    4 字节的对齐。`para` 对齐选项指定段落对齐（16 字节）。`page` 对齐选项指定 256 字节的地址对齐。最后，`align(``n``)` 对齐选项允许你指定任何
    2 的幂次方地址对齐（1、2、4、8、16、32 等等）。
- en: The default segment alignment, if you don’t explicitly specify one, is paragraph
    alignment (16 bytes). This is also the default alignment for the simplified segment
    directives (`.code`, `.data`, `.data?`, and `.const`).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have some (SSE/AVX) data objects that must start at an address that
    is a multiple of 32 or 64 bytes, then creating a new data segment with 64-byte
    alignment is what you want. Here’s an example of such a segment:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The optional `class` field is a string (delimited by apostrophes and single
    quotes) that is typically one of the following names: `CODE`, `DATA`, or `CONST`.
    Note that MASM and the Microsoft linker will combine segments that have the same
    class name even if their segment names are different.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: This chapter presents examples of these segment declarations as they are needed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 11.5 SSE, AVX, and AVX2 Memory Operand Alignment
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSE and AVX instructions typically allow access to a variety of memory operand
    sizes. The so-called scalar instructions, which operate on single data elements,
    can access byte-, word-, dword-, and qword-sized memory operands. In many respects,
    these types of memory accesses are similar to memory accesses by the non-SIMD
    instructions. The SSE, AVX, and AVX2 instruction set extensions also access *packed*
    or *vector* operands in memory. Unlike with the scalar memory operands, stringent
    rules limit the access of packed memory operands. This section discusses those
    rules.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The SSE instructions can access up to 128 bits of memory (16 bytes) with a single
    instruction. Most multi-operand SSE instructions can specify an XMM register or
    a 128-bit memory operand as their source (second) operand. As a general rule,
    these memory operands must appear on a 16-byte-aligned address in memory (that
    is, the LO 4 bits of the memory address must contain 0s).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Because segments have a default alignment of `para` (16 bytes), you can easily
    ensure that any 16-byte packed data objects are 16-byte-aligned by using the `align`
    directive:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: MASM will report an error if you attempt to use `align 16` in a segment you’ve
    defined with the `byte`, `word`, or `dword` alignment type. It will work properly
    with `para`, `page`, or any `align(``n``)` option where `n` is greater than or
    equal to 16.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using AVX instructions to access 256-bit (32-byte) memory operands,
    you must ensure that those memory operands begin on a 32-byte address boundary.
    Unfortunately, `align 32` won’t work, because the default segment alignment is
    `para` (16-byte) alignment, and the segment’s alignment must be greater than or
    equal to the operand field of any `align` directives appearing within that segment.
    Therefore, to be able to define 256-bit variables usable by AVX instructions,
    you must explicitly define a (data) segment that is aligned on a (minimum) 32-byte
    boundary, such as the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Though it’s somewhat redundant to say this, it’s so important it’s worth repeating:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Almost all AVX/AVX2 instructions will generate an alignment fault if you attempt
    to access a 256-bit object at an address that is not 32-byte-aligned. Always ensure
    that your AVX packed operands are properly aligned.
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 几乎所有 AVX/AVX2 指令，如果你尝试在一个不是 32 字节对齐的地址访问一个 256 位对象，都会引发对齐错误。始终确保你的 AVX 打包操作数正确对齐。
- en: 'If you are using the AVX2 extended instructions with 512-bit memory operands,
    you must ensure that those operands appear on an address in memory that is a multiple
    of 64 bytes. As for AVX instructions, you will have to define a segment that has
    an alignment greater than or equal to 64 bytes, such as this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 AVX2 扩展指令与 512 位内存操作数，你必须确保这些操作数出现在内存中一个是 64 字节的倍数的地址上。至于 AVX 指令，你必须定义一个具有大于或等于
    64 字节对齐的段，例如这样：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Forgive the redundancy, but it’s important to remember:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请原谅重复，但重要的是要记住：
- en: Almost all AVX-512 instructions will generate an alignment fault if you attempt
    to access a 512-bit object at an address that is not 64-byte-aligned. Always ensure
    that your AVX-512 packed operands are properly aligned.
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 几乎所有 AVX-512 指令，如果你尝试在一个不是 64 字节对齐的地址访问一个 512 位对象，都会引发对齐错误。始终确保你的 AVX-512 打包操作数正确对齐。
- en: 'If you’re using SSE, AVX, and AVX2 data types in the same application, you
    can create a single data segment to hold all these data values by using a 64-byte
    alignment option for the single section, instead of a segment for each data type
    size. Remember, the segment’s alignment has to be *greater than* or equal to the
    alignment required by the specific data type. Therefore, a 64-byte alignment will
    work fine for SSE and AVX/AVX2 variables, as well as AVX-512 variables:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在同一个应用程序中使用 SSE、AVX 和 AVX2 数据类型，你可以通过为单个段使用 64 字节对齐选项来创建一个单一的数据段来保存所有这些数据值，而不是为每种数据类型的大小创建单独的段。记住，段的对齐必须*大于或等于*特定数据类型所要求的对齐方式。因此，64
    字节对齐对于 SSE 和 AVX/AVX2 变量以及 AVX-512 变量都能很好地工作：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you specify an alignment option that is much larger than you need (such as
    256-byte `page` alignment), you might unnecessarily waste memory.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定的对齐选项远大于你需要的（例如 256 字节的 `page` 对齐），你可能会不必要地浪费内存。
- en: The `align` directive works well when your SSE, AVX, and AVX2 data values are
    static or global variables. What happens when you want to create local variables
    on the stack or dynamic variables on the heap? Even if your program adheres to
    the Microsoft ABI, you’re guaranteed only 16-byte alignment on the stack upon
    entry to your program (or to a procedure). Similarly, depending on your heap management
    functions, there is no guarantee that a `malloc` (or similar) function returns
    an address that is properly aligned for SSE, AVX, or AVX2 data objects.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的 SSE、AVX 和 AVX2 数据值是静态或全局变量时，`align` 指令表现良好。那么当你想要在栈上创建局部变量或在堆上创建动态变量时会发生什么呢？即使你的程序遵循微软的
    ABI，你在进入程序（或进入一个过程）时，栈上的对齐保证只有 16 字节对齐。同样，根据你的堆管理函数，`malloc`（或类似函数）返回的地址也无法保证适合
    SSE、AVX 或 AVX2 数据对象的对齐方式。
- en: 'Inside a procedure, you can allocate storage for a 16-, 32-, or 64-byte-aligned
    variable by over-allocating the storage, adding the size minus 1 of the object
    to the allocated address, and then using the `and` instruction to zero out LO
    bits of the address (4 bits for 16-byte-aligned objects, 5 bits for 32-byte-aligned
    objects, and 6 bits for 64-byte-aligned objects). Then you reference the object
    by using this pointer. The following sample code demonstrates how to do this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个过程内部，你可以通过过度分配存储、将对象的大小减去 1 添加到分配的地址，然后使用 `and` 指令将地址的低位清零（16 字节对齐对象清除 4
    位，32 字节对齐对象清除 5 位，64 字节对齐对象清除 6 位）来为 16 字节、32 字节或 64 字节对齐的变量分配存储空间。然后你可以通过使用这个指针来引用该对象。下面的示例代码演示了如何做到这一点：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For data you allocate on the heap, you do the same thing: allocate extra storage
    (up to twice as many bytes minus 1), add the size of the object minus 1 (15, 31,
    or 63) to the address, and then mask the newly formed address with –64, –32, or
    –16 to produce a 64-, 32-, or 16-byte-aligned object, respectively.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在堆上分配的数据，你可以做同样的事情：分配额外的存储（最多分配大小的两倍减去 1），将对象的大小减去 1（15、31 或 63）加到地址中，然后使用
    -64、-32 或 -16 来屏蔽新形成的地址，以分别产生 64 字节、32 字节或 16 字节对齐的对象。
- en: 11.6 SIMD Data Movement Instructions
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6 SIMD 数据移动指令
- en: The x86-64 CPUs provide a variety of data move instructions that copy data between
    (SSE/AVX) registers, load registers from memory, and store register values to
    memory. The following subsections describe each of these instructions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.1 The (v)movd and (v)movq Instructions
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the SSE instruction set, the `movd` (*move dword*) and `movq` (*move qword*)
    instructions copy the value from a 32- or 64-bit general-purpose register or memory
    location into the LO dword or qword of an XMM register:^([2](#c11-footnote-2))
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These instructions zero-extend the value to remaining HO bits in the XMM register,
    as shown in Figures 11-7 and 11-8.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![f11007](image_fi/501089c11/f11007.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-7: Moving a 32-bit value from memory to an XMM register (with zero
    extension)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![f11008](image_fi/501089c11/f11008.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-8: Moving a 64-bit value from memory to an XMM register (with zero
    extension)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'The following instructions store the LO 32 or 64 bits of an XMM register into
    a dword or qword memory location or general-purpose register:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `movq` instruction also allows you to copy data from the LO qword of one
    XMM register to another, but for whatever reason, the `movd` instruction does
    not allow two XMM register operands:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For the AVX instructions, you use the following instructions:^([3](#c11-footnote-3))
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The instructions with the XMM destination operands also zero-extend their values
    into the HO bits (up to bit 255, unlike the standard SSE instructions that do
    not modify the upper bits of the YMM registers).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Because the `movd` and `movq` instructions access 32- and 64-bit values in memory
    (rather than 128-, 256-, or 512-bit values), these instructions do not require
    their memory operands to be 16-, 32-, or 64-byte-aligned. Of course, the instructions
    may execute faster if their operands are dword (`movd`) or qword (`movq`) aligned
    in memory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.2 The (v)movaps, (v)movapd, and (v)movdqa Instructions
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `movaps` (*move aligned, packed single*), `movapd` (*move aligned, packed
    double*), and `movdqa` (*move double quad-word aligned*) instructions move 16
    bytes of data between memory and an XMM register or between two XMM registers.
    The AVX versions (with the `v` prefix) move 16 or 32 bytes between memory and
    an XMM or a YMM register or between two XMM or YMM registers (moves involving
    XMM registers zero out the HO bits of the corresponding YMM register). The memory
    locations must be aligned on a 16-byte or 32-byte boundary (respectively), or
    the CPU will generate an unaligned access fault.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: All three `mov*` instructions load 16 bytes into an XMM register and are, in
    theory, interchangeable. In practice, Intel may optimize the operations for the
    type of data they move (single-precision floating-point values, double-precision
    floating-point values, or integer values), so it’s always a good idea to choose
    the appropriate instruction for the data type you are using (see “Performance
    Issues and the SIMD Move Instructions” on page 622 for an explanation). Likewise,
    all three `vmov*` instructions load 16 or 32 bytes into an XMM or a YMM register
    and are interchangeable.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'These instructions take the following forms:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `mem`128 operand should be a vector (array) of four single-precision floating-point
    values for the `(v)movaps` instruction; it should be a vector of two double-precision
    floating-point values for the `(v)movapd` instruction; it should be a 16-byte
    value (16 bytes, 8 words, 4 dwords, or 2 qwords) when using the `(v)movdqa` instruction.
    If you cannot guarantee that the operands are aligned on a 16-byte boundary, use
    the `movups`, `movupd`, or `movdqu` instructions, instead (see the next section).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The `mem`256 operand should be a vector (array) of eight single-precision floating-point
    values for the `vmovaps` instruction; it should be a vector of four double-precision
    floating-point values for the `vmovapd` instruction; it should be a 32-byte value
    (32 bytes, 16 words, 8 dwords, or 4 qwords) when using the `vmovdqa` instruction.
    If you cannot guarantee that the operands are 32-byte-aligned, use the `vmovups`,
    `vmovupd`, or `vmovdqu` instructions instead.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the physical machine instructions themselves don’t particularly care
    about the data type of the memory operands, MASM’s assembly syntax certainly does
    care. You will need to use operand type coercion if the instruction doesn’t match
    one of the following types:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The `movaps` instruction allows `real4`, `dword`, and `oword` operands.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `movapd` instruction allows `real8`, `qword`, and `oword` operands.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `movdqa` instruction allows only `oword` operands.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `vmovaps` instruction allows `real4`, `dword`, and `ymmword ptr` operands
    (when using a YMM register).
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `vmovapd` instruction allows `real8`, `qword`, and `ymmword ptr` operands
    (when using a YMM register).
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `vmovdqa` instruction allows only `ymmword ptr` operands (when using a YMM
    register).
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often you will see `memcpy` (*memory copy*) functions use the `(v)movapd` instructions
    for very high-performance operations. See Agner Fog’s website at [https://www.agner.org/optimize/](https://www.agner.org/optimize/)
    for more details.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.3 The (v)movups, (v)movupd, and (v)movdqu Instructions
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you cannot guarantee that packed data memory operands lie on a 16- or 32-byte
    address boundary, you can use the `(v)movups` (*move unaligned packed single-precision*),
    `(v)movupd` (*move unaligned packed* *double-precision*), and `(v)movdqu` (*move
    double quad-word* *unaligned*) instructions to move data between XMM or YMM registers
    and memory.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the aligned moves, all the unaligned moves do the same thing: copying
    16 (32) bytes of data to and from memory. The convention for the various data
    types is the same as it is for the aligned data movement instructions.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.4 Performance of Aligned and Unaligned Moves
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Listings [11-3](#listing11-3) and [11-4](#listing11-4) provide sample programs
    that demonstrate the performance of the `mova*` and `movu*` instructions using
    aligned and unaligned memory accesses.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 11-3: Aligned memory-access timing code'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 11-4: Unaligned memory-access timing code'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 11-3](#listing11-3) took about 1 minute and 7 seconds to
    execute on a 3GHz Xeon W CPU. The code in [Listing 11-4](#listing11-4) took 1
    minute and 55 seconds to execute on the same processor. As you can see, there
    is sometimes an advantage to accessing SIMD data on an aligned address boundary.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.5 The (v)movlps and (v)movlpd Instructions
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `(v)movl*` instructions and `(v)movh*` instructions (from the next section)
    might look like normal move instructions. Their behavior is similar to many other
    SSE/AVX move instructions. However, they were designed to support packing and
    unpacking floating-point vectors. Specifically, these instructions allow you to
    merge two pairs of single-precision or a pair of double-precision floating-point
    operands from two different sources into a single XMM register.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'The `(v)movlps` instructions use the following syntax:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `movlps` `xmm`dest`,` `mem`64 form copies a pair of single-precision floating-point
    values into the two LO 32-bit lanes of a destination XMM register, as shown in
    [Figure 11-9](#figure11-9). This instruction leaves the HO 64 bits unchanged.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![f11009](image_fi/501089c11/f11009.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-9: `movlps` instruction'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The `movlps` `mem`64`,` `xmm`src form copies the LO 64 bits (the two LO single-precision
    lanes) from the XMM source register to the specified memory location. Functionally,
    this is equivalent to the `movq` or `movsd` instructions (as it copies 64 bits
    to memory), though this instruction might be slightly faster if the LO 64 bits
    of the XMM register actually contain two single-precision values (see “Performance
    Issues and the SIMD Move Instructions” on page 622 for an explanation).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vmovlps` instruction has three operands: a destination XMM register, a
    source XMM register, and a source (64-bit) memory location. This instruction copies
    the two single-precision values from the memory location into the LO 64 bits of
    the destination XMM register. It copies the HO 64 bits of the source register
    (which also hold two single-precision values) into the HO 64 bits of the destination
    register. [Figure 11-10](#figure11-10) shows the operation. Note that this instruction
    merges the pair of operands with a single instruction.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![f11010](image_fi/501089c11/f11010.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-10: `vmovlps` instruction'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Like `movsd`, the `movlpd` (*move low packed double*) instruction copies the
    LO 64 bits (a double-precision floating-point value) of the source operand to
    the LO 64 bits of the destination operand. The difference is that the `movlpd`
    instruction doesn’t zero-extend the value when moving data from memory into an
    XMM register, whereas the `movsd` instruction will zero-extend the value into
    the upper 64 bits of the destination XMM register. (Neither the `movsd` nor `movlpd`
    will zero-extend when copying data between XMM registers; of course, zero extension
    doesn’t apply when storing data to memory.)^([4](#c11-footnote-4))
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.6 The movhps and movhpd Instructions
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `movhps` and `movhpd` instructions move a 64-bit value (either two single-precision
    floats in the case of `movhps`, or a single double-precision value in the case
    of `movhpd`) into the HO quad word of a destination XMM register. [Figure 11-11](#figure11-11)
    shows the operation of the `movhps` instruction; [Figure 11-12](#figure11-12)
    shows the `movhpd` instruction.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![f11011](image_fi/501089c11/f11011.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-11: `movhps` instruction'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![f11012](image_fi/501089c11/f11012.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-12: `movhpd` instruction'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'The `movhps` and `movhpd` instructions can also store the HO quad word of an
    XMM register into memory. The allowable syntax is shown here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These instructions do not affect bits 128 to 255 of the YMM registers (if present
    on the CPU).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: You would normally use a `movlps` instruction followed by a `movhps` instruction
    to load four single-precision floating-point values into an XMM register, taking
    the floating-point values from two different data sources (similarly, you could
    use the `movlpd` and `movhpd` instructions to load a pair of double-precision
    values into a single XMM register from different sources). Conversely, you could
    also use this instruction to split a vector result in half and store the two halves
    in different data streams. This is probably the intended purpose of this instruction.
    Of course, if you can use it for other purposes, have at it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'MASM (version 14.15.26730.0, at least) seems to require `movhps` operands to
    be a 64-bit data type and does not allow `real4` operands.^([5](#c11-footnote-5))
    Therefore, you may have to explicitly coerce an array of two `real4` values with
    `qword ptr` when using this instruction:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 11.6.7 The vmovhps and vmovhpd Instructions
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although the AVX instruction extensions provide `vmovhps` and `vmovhpd` instructions,
    they are not a simple extension of the SSE `movhps` and `movhpd` instructions.
    The syntax for these instructions is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The instructions that store data into a 64-bit memory location behave similarly
    to the `movhps` and `movhpd` instructions. The instructions that load data into
    an XMM register have two source operands. They load a full 128 bits (four single-precision
    values or two double-precision values) into the destination XMM register. The
    HO 64 bits come from the memory operand; the LO 64 bits come from the LO quad
    word of the source XMM register, as [Figure 11-13](#figure11-13) shows. These
    instructions also zero-extend the value into the upper 128 bits of the (overlaid)
    YMM register.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![f11013](image_fi/501089c11/f11013.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-13: `vmovhpd` and `vmovhps` instructions'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike for the `movhps` instruction, MASM properly accepts `real4` source operands
    for the `vmovhps` instruction:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 11.6.8 The movlhps and vmovlhps Instructions
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `movlhps` instruction moves a pair of 32-bit single-precision floating-point
    values from the LO qword of the source XMM register into the HO 64 bits of a destination
    XMM register. It leaves the LO 64 bits of the destination register unchanged.
    If the destination register is on a CPU that supports 256-bit AVX registers, this
    instruction also leaves the HO 128 bits of the overlaid YMM register unchanged.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for these instructions is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You cannot use this instruction to move data between memory and an XMM register;
    it transfers data only between XMM registers. No double-precision version of this
    instruction exists.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vmovlhps` instruction is similar to `movlhps`, with the following differences:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '`vmovlhps` requires three operands: two source XMM registers and a destination
    XMM register.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vmovlhps` copies the LO quad word of the first source register into the LO
    quad word of the destination register.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vmovlhps` copies the LO quad word of the second source register into bits
    64 to 127 of the destination register.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vmovlhps` zero-extends the result into the upper 128 bits of the overlaid
    YMM register.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no `vmovlhpd` instruction.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.9 The movhlps and vmovhlps Instructions
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `movhlps` instruction has the following syntax:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `movhlps` instruction copies the pair of 32-bit single-precision floating-point
    values from the HO qword of the source operand to the LO qword of the destination
    register, leaving the HO 64 bits of the destination register unchanged (this is
    the converse of `movlhps`). This instruction copies data only between XMM registers;
    it does not allow a memory operand.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vmovhlps` instruction requires three XMM register operands; here is its
    syntax:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This instruction copies the HO 64 bits of the first source register into the
    HO 64 bits of the destination register, copies the HO 64 bits of the second source
    register into bits 0 to 63 of the destination register, and finally, zero-extends
    the result into the upper bits of the overlaid YMM register.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: There are no `movhlpd` or `vmovhlpd` instructions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.10 The (v)movshdup and (v)movsldup Instructions
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `movshdup` instruction moves the two odd-index single-precision floating-point
    values from the source operand (memory or XMM register) and duplicates each element
    into the destination XMM register, as shown in [Figure 11-14](#figure11-14).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![f11014](image_fi/501089c11/f11014.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-14: `movshdup` and `vmovshdup` instructions'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'This instruction ignores the single-precision floating-point values at even-lane
    indexes into the XMM register. The `vmovshdup` instruction works the same way
    but on YMM registers, copying four single-precision values rather than two (and,
    of course, zeroing the HO bits). The syntax for these instructions is shown here:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `movsldup` instruction works just like the `movshdup` instruction, except
    it copies and duplicates the two single-precision values at even indexes in the
    source XMM register to the destination XMM register. Likewise, the `vmovsldup`
    instruction copies and duplicates the four double-precision values in the source
    YMM register at even indexes, as shown in [Figure 11-15](#figure11-15).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![f11015](image_fi/501089c11/f11015.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-15: `movsldup` and `vmovsldup` instructions'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 11.6.11 The (v)movddup Instruction
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `movddup` instruction copies and duplicates a double-precision value from
    the LO 64 bits of an XMM register or a 64-bit memory location into the LO 64 bits
    of a destination XMM register; then it also duplicates this value into bits 64
    to 127 of that same destination register, as shown in [Figure 11-16](#figure11-16).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![f11016](image_fi/501089c11/f11016.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-16: `movddup` instruction behavior'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'This instruction does not disturb the HO 128 bits of a YMM register (if applicable).
    The syntax for this instruction is as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `vmovddup` instruction operates on an XMM or a YMM destination register
    and an XMM or a YMM source register or 128- or 256-bit memory location. The 128-bit
    version works just like the `movddup` instruction except it zeroes the HO bits
    of the destination YMM register. The 256-bit version copies a pair of double-precision
    values at even indexes (0 and 2) in the source value to their corresponding indexes
    in the destination YMM register and duplicates those values at the odd indexes
    in the destination, as [Figure 11-17](#figure11-17) shows.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![f11017](image_fi/501089c11/f11017.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-17: `vmovddup` instruction behavior'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the syntax for this instruction:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 11.6.12 The (v)lddqu Instruction
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `(v)lddqu` instruction is operationally identical to `(v)movdqu`. You can
    sometimes use this instruction to improve performance if the (memory) source operand
    is not aligned properly and crosses a cache line boundary in memory. For more
    details on this instruction and its performance limitations, refer to the Intel
    or AMD documentation (specifically, the optimization manuals).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'These instructions always take the following form:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 11.6.13 Performance Issues and the SIMD Move Instructions
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you look at the SSE/AVX instructions’ semantics at the programming model
    level, you might question why certain instructions appear in the instruction set.
    For example, the `movq`, `movsd`, and `movlps` instructions can all load 64 bits
    from a memory location into the LO 64 bits of an XMM register. Why bother doing
    this? Why not have a single instruction that copies the 64 bits from a quad word
    in memory to the LO 64 bits of an XMM register (be it a 64-bit integer, a pair
    of 32-bit integers, a 64-bit double-precision floating-point value, or a pair
    of 32-bit single-precision floating-point values)? The answer lies in the term
    *microarchitecture*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: The x86-64 *macroarchitecture* is the programming model that a software engineer
    sees. In the macroarchitecture, an XMM register is a 128-bit resource that, at
    any given time, could hold a 128-bit array of bits (or an integer), a pair of
    64-bit integer values, a pair of 64-bit double-precision floating-point values,
    a set of four single-precision floating-point values, a set of four double-word
    integers, eight words, or 16 bytes. All these data types overlay one another,
    just like the 8-, 16-, 32-, and 64-bit general-purpose registers overlay one another
    (this is known as *aliasing*). If you load two double-precision floating-point
    values into an XMM register and then modify the (integer) word at bit positions
    0 to 15, you’re also changing those same bits (0 to 15) in the double-precision
    value in the LO qword of the XMM register. The semantics of the x86-64 programming
    model require this.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: At the microarchitectural level, however, there is no requirement that the CPU
    use the same physical bits in the CPU for integer, single-precision, and double-precision
    values (even when they are aliased to the same register). The microarchitecture
    could set aside a separate set of bits to hold integers, single-precision, and
    double-precision values for a single register. So, for example, when you use the
    `movq` instruction to load 64 bits into an XMM register, that instruction might
    actually copy the bits into the underlying integer register (without affecting
    the single-precision or double-precision subregisters). Likewise, `movlps` would
    copy a pair of single-precision values into the single-precision register, and
    `movsd` would copy a double-precision value into the double-precision register
    ([Figure 11-18](#figure11-18)). These separate subregisters (integer, single-precision,
    and double-precision) could be connected directly to the arithmetic or logical
    unit that handles their specific data types, making arithmetic and logical operations
    on those subregisters more efficient. As long as the data is sitting in the appropriate
    subregister, everything works smoothly.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![f11018](image_fi/501089c11/f11018.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-18: Register aliasing at the microarchitectural level'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: However, what happens if you use `movq` to load a pair of single-precision floating-point
    values into an XMM register and then try to perform a single-precision vector
    operation on those two values? At the macroarchitectural level, the two single-precision
    values are sitting in the appropriate bit positions of the XMM register, so this
    has to be a legal operation. At the microarchitectural level, however, those two
    single-precision floating-point values are sitting in the integer subregister,
    not the single-precision subregister. The underlying microarchitecture has to
    note that the values are in the wrong subregister and move them to the appropriate
    (single-precision) subregister before performing the single-precision arithmetic
    or logical operation. This may introduce a slight delay (while the microarchitecture
    moves the data around), which is why you should always pick the appropriate move
    instructions for your data types.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.14 Some Final Comments on the SIMD Move Instructions
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SIMD data movement instructions are a confusing bunch. Their syntax is inconsistent,
    many instructions duplicate the actions of other instructions, and they have some
    perplexing irregularity issues. Someone new to the x86-64 instruction set might
    ask, “Why was the instruction set designed this way?” Why, indeed?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The answer to that question is historical. The SIMD instructions did not exist
    on the earliest x86 CPUs. Intel added the MMX instruction set to the Pentium-series
    CPUs. At that time (the early 1990s), current technology allowed Intel to add
    only a few additional instructions, and the MMX registers were limited to 64 bits
    in size. Furthermore, software engineers and computer systems designers were only
    beginning to explore the multimedia capabilities of modern computers, so it wasn’t
    entirely clear which instructions (and data types) were necessary to support the
    type of software we see several decades later. As a result, the earliest SIMD
    instructions and data types were limited in scope.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: As time passed, CPUs gained additional silicon resources, and software/systems
    engineers discovered new uses for computers (and new algorithms to run on those
    computers), so Intel (and AMD) responded by adding new SIMD instructions to support
    these more modern multimedia applications. The original MMX instructions, for
    example, supported only integer data types, so Intel added floating-point support
    in the SSE instruction set, because multimedia applications needed real data types.
    Then Intel extended the integer types from 64 bits to 128, 256, and even 512 bits.
    With each extension, Intel (and AMD) had to retain the older instruction set extensions
    in order to allow preexisting software to run on the new CPUs.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the newer instruction sets kept piling on new instructions that
    did the same work as the older ones (with some additional capabilities). This
    is why instructions like `movaps` and `vmovaps` have considerable overlap in their
    functionality. If the CPU resources had been available earlier (for example, to
    put 256-bit YMM registers on the CPU), there would have been almost no need for
    the `movaps` instruction—the `vmovaps` could have done all the work.^([6](#c11-footnote-6))
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'In theory, we could create an architecturally elegant variant of the x86-64
    by starting over from scratch and designing a minimal instruction set that handles
    all the activities of the current x86-64 without all the kruft and kludges present
    in the existing instruction set. However, such a CPU would lose the primary advantage
    of the x86-64: the ability to run decades of software written for the Intel architecture.
    The cost of being able to run all this old software is that assembly language
    programmers (and compiler writers) have to deal with all these irregularities
    in the instruction set.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 11.7 The Shuffle and Unpack Instructions
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SSE/AVX *shuffle and unpack instructions* are variants of the move instructions.
    In addition to moving data around, these instructions can also rearrange the data
    appearing in different lanes of the XMM and YMM registers.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.1 The (v)pshufb Instructions
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `pshufb` instruction was the first packed byte shuffle SIMD instruction
    (it first appeared with the MMX instruction set). Because of its origin, its syntax
    and behavior are a bit different from the other shuffle instructions in the instruction
    set. The syntax is the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first (destination) operand is an XMM register whose byte lanes `pshufb`
    will shuffle (rearrange). The second operand (either an XMM register or a 128-bit
    oword memory location) is an array of 16 byte values holding indexes that control
    the shuffle operation. If the second operand is a memory location, that oword
    value must be aligned on a 16-byte boundary.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Each byte (lane) in the second operand selects a value for the corresponding
    byte lane in the first operand, as shown in [Figure 11-19](#figure11-19).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![f11019](image_fi/501089c11/f11019.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-19: Lane index correspondence for `pshufb` instruction'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The 16-byte indexes in the second operand each take the form shown in [Figure
    11-20](#figure11-20).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '![f11020](image_fi/501089c11/f11020.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-20: `phsufb` byte index'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: The `pshufb` instruction ignores bits 4 to 6 in an index byte. Bit 7 is the
    clear bit; if this bit contains a 1, the `pshufb` instruction ignores the lane
    index bits and stores a 0 into the corresponding byte in XMM[dest]. If the clear
    bit contains a 0, the `pshufb` instruction does a shuffle operation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The `pshufb` shuffle operation takes place on a lane-by-lane basis. The instruction
    first makes a temporary copy of XMM[dest]. Then for each index byte (whose HO
    bit is 0), the `pshufb` copies the lane specified by the LO 4 bits of the index
    from the XMM[dest] lane that matches the index’s lane, as shown in [Figure 11-21](#figure11-21).
    In this example, the index appearing in lane 6 contains the value 00000011b. This
    selects the value in lane 3 of the temporary (original XMM[dest]) value and copies
    it to lane 6 of XMM[dest]. The `pshufb` instruction repeats this operation for
    all l6 lanes.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![f11021](image_fi/501089c11/f11021.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-21: Shuffle operation'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'The AVX instruction set extensions introduced the `vpshufb` instruction. Its
    syntax is the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The AVX variant adds a source register (rather than using XMM[dest] as both
    the source and destination registers), and, rather than creating a temporary copy
    of XMM[dest] prior to the operation and picking the values from that copy, the
    `vpshufb` instructions select the source bytes from the XMM[src] register. Other
    than that, and the fact that these instructions zero the HO bits of YMM[dest],
    the 128-bit variant operates identically to the SSE `pshufb` instruction.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The AVX instruction allows you to specify 256-bit YMM registers in addition
    to 128-bit XMM registers.^([7](#c11-footnote-7))
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.2 The (v)pshufd Instructions
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The SSE extensions first introduced the `pshufd` instruction. The AVX extensions
    added the `vpshufd` instruction. These instructions shuffle dwords in XMM and
    YMM registers (*not* double-precision values) similarly to the `(v)pshufb` instructions.
    However, the shuffle index is specified differently from `(v)pshufb`. The syntax
    for the `(v)pshufd` instructions is as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first operand (XMM[dest] or YMM[dest]) is the destination operand where
    the shuffled values will be stored. The second operand is the source from which
    the instruction will select the double words to place in the destination register;
    as usual, if this is a memory operand, you must align it on the appropriate (16-
    or 32-byte) boundary. The third operand is an 8-bit immediate value that specifies
    the indexes for the double words to select from the source operand.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: For the `(v)pshufd` instructions with an XMM[dest] operand, the imm[8] operand
    has the encoding shown in [Table 11-3](#table11-3). The value in bits 0 to 1 selects
    a particular dword from the source operand to place in dword 0 of the XMM[dest]
    operand. The value in bits 2 to 3 selects a dword from the source operand to place
    in dword 1 of the XMM[dest] operand. The value in bits 4 to 5 selects a dword
    from the source operand to place in dword 2 of the XMM[dest] operand. Finally,
    the value in bits 6 to 7 selects a dword from the source operand to place in dword
    3 of the XMM[dest] operand.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-3: `(v)pshufd` imm[8] Operand Values'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit positions** | **Destination lane** |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: '| 0 to 1 | 0 |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
- en: '| 2 to 3 | 1 |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: '| 4 to 5 | 2 |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '| 6 to 7 | 3 |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: The difference between the 128-bit `pshufd` and `vpshufd` instructions is that
    `pshufd` leaves the HO 128 bits of the underlying YMM register unchanged and `vpshufd`
    zeroes the HO 128 bits of the underlying YMM register.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: The 256-bit variant of `vpshufd` (when using YMM registers as the source and
    destination operands) still uses an 8-bit immediate operand as the index value.
    Each 2-bit index value manipulates two dword values in the YMM registers. Bits
    0 to 1 control dwords 0 and 4, bits 2 to 3 control dwords 1 and 5, bits 4 to 5
    control dwords 2 and 6, and bits 6 to 7 control dwords 3 and 7, as shown in [Table
    11-4](#table11-4).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-4: Double-Word Transfers for `vpshufd` YMM[dest], YMM[src]/mem[src],
    imm[8]'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '| **Index** | **YMM/mem[src] [index] copied into** | **YMM/mem[src] [index
    + 4] copied into** |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
- en: '| Bits 0 to 1 of imm[8] | YMM[dest][0] | YMM[dest][4] |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
- en: '| Bits 2 to 3 of imm[8] | YMM[dest][1] | YMM[dest][5] |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
- en: '| Bits 4 to 5 of imm[8] | YMM[dest][2] | YMM[dest][6] |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '| Bits 6 to 7 of imm[8] | YMM[dest][3] | YMM[dest][7] |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: The 256-bit version is slightly less flexible as it copies two dwords at a time,
    rather than one. It processes the LO 128 bits exactly the same way as the 128-bit
    version of the instruction; it also copies the corresponding lanes in the upper
    128 bits of the source to the YMM destination register by using the same shuffle
    pattern. Unfortunately, you can’t independently control the HO and LO halves of
    the YMM register by using the `vpshufd` instruction. If you really need to shuffle
    dwords independently, you can use `vshufb` with appropriate indexes that copy
    4 bytes (in place of a single dword).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.3 The (v)pshuflw and (v)pshufhw Instructions
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `pshuflw` and `vpshuflw` and the `pshufhw` and `vpshufhw` instructions
    provide support for 16-bit word shuffles within an XMM or a YMM register. The
    syntax for these instructions is the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The 128-bit `lw` variants copy the HO 64 bits of the source operand to the same
    positions in the XMM[dest] operand. Then they use the index (imm[8]) operand to
    select word lanes 0 to 3 in the LO qword of the XMM[src]/mem[128] operand to move
    to the LO 4 lanes of the destination operand. For example, if the LO 2 bits of
    imm[8] are 10b, then the `pshuflw` instruction copies lane 2 from the source into
    lane 0 of the destination operand ([Figure 11-22](#figure11-22)). Note that `pshuflw`
    does not modify the HO 128 bits of the overlaid YMM register, whereas `vpshuflw`
    zeroes those HO bits.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '![f11022](image_fi/501089c11/f11022.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-22: `(v)pshuflw` `xmm``,` `xmm``/``mem``,` `imm`8 operation'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: The 256-bit `vpshuflw` instruction (with a YMM destination register) copies
    two pairs of words at a time—one pair in the HO 128 bits and one pair in the LO
    128 bits of the YMM destination register and 256-bit source locations, as shown
    in [Figure 11-23](#figure11-23). The index (imm[8]) selection is the same for
    the LO and HO 128 bits.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![f11023](image_fi/501089c11/f11023.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-23: `vpshuflw` `ymm``,` `ymm``/``mem``,` `imm`8 operation'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: The 128-bit `hw` variants copy the LO 64 bits of the source operand to the same
    positions in the destination operand. Then they use the index operand to select
    words 4 to 7 (indexed as 0 to 3) in the 128-bit source operand to move to the
    HO four word lanes of the destination operand ([Figure 11-24](#figure11-24)).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '![f11024](image_fi/501089c11/f11024.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-24: `(v)pshufhw` operation'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: The 256-bit `vpshufhw` instruction (with a YMM destination register) copies
    two pairs of words at a time—one in the HO 128 bits and one in the LO 128 bits
    of the YMM destination register and 256-bit source locations, as shown in [Figure
    11-25](#figure11-25).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '![f11025](image_fi/501089c11/f11025.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-25: `vpshufhw` operation'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.4 The shufps and shufpd Instructions
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The shuffle instructions (`shufps` and `shufpd`) extract single- or double-precision
    values from the source operands and place them in specified positions in the destination
    operand. The third operand, an 8-bit immediate value, selects which values to
    extract from the source to move into the destination register. The syntax for
    these two instructions is as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For the `shufps` instruction, the second source operand is an 8-bit immediate
    value that is actually a four-element array of 2-bit values.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: imm[8] bits 0 and 1 select a single-precision value from one of the four lanes
    in the XMM[src1/dest] operand to store into lane 0 of the destination operation.
    Bits 2 and 3 select a single-precision value from one of the four lanes in the
    XMM[src1/dest] operand to store into lane 1 of the destination operation (the
    destination operand is also XMM[src1/dest]).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: imm[8] bits 4 and 5 select a single-precision value from one of the four lanes
    in the XMM[src2]/mem[src2] operand to store into lane 2 of the destination operation.
    Bits 6 and 7 select a single-precision value from one of the four lanes in the
    XMM[src2]/mem[src2] operand to store into lane 3 of the destination operation.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-26](#figure11-26) shows the operation of the `shufps` instruction.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '![f11026](image_fi/501089c11/f11026.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-26: `shufps` operation'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: For example, the instruction
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'loads XMM0 with the following single-precision values:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: XMM0[0 to 31] from XMM0[0 to 32]
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XMM0[32 to 63] from XMM0[32 to 63]
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XMM0[64 to 95] from XMM1[63 to 95]
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XMM0[96 to 127] from XMM1[96 to 127]
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the second operand (XMM[src2]/mem[src2]) is the same as the first operand
    (XMM[src1/dest]), it’s possible to rearrange the four single-precision values
    in the XMM[dest] register (which is probably the source of the instruction name
    *shuffle*).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: The `shufpd` instruction works similarly, shuffling double-precision values.
    As there are only two double-precision values in an XMM register, it takes only
    a single bit to choose between the values. Likewise, as there are only two double-precision
    values in the destination register, the instruction requires only two (single-bit)
    array elements to choose the destination. As a result, the third operand, the
    imm[8] value, is actually just a 2-bit value; the instruction ignores bits 2 to
    7 in the imm[8] operand. Bit 0 of the imm[8] operand selects either lane 0 and
    bits 0 to 63 (if it is 0) or lane 1 and bits 64 to 127 (if it is 1) from the XMM[src1/dest]
    operand to place into lane 0 and bits 0 to 63 of XMM[dest]. Bit 1 of the imm[8]
    operand selects either lane 0 and bits 0 to 63 (if it is 0) or lane 1 and bits
    64 to 127 (if it is 1) from the XMM[src]/mem[128] operand to place into lane 1
    and bits 64 to 127 of XMM[dest]. [Figure 11-27](#figure11-27) shows this operation.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '![f11027](image_fi/501089c11/f11027.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-27: `shufpd` operation'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.5 The vshufps and vshufpd Instructions
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `vshufps` and `vshufpd` instructions are similar to `shufps` and `shufpd`.
    They allow you to shuffle the values in 128-bit XMM registers or 256-bit YMM registers.^([8](#c11-footnote-8))
    The `vshufps` and `vshufpd` instructions have four operands: a destination XMM
    or YMM register, two source operands (src[1] must be an XMM or a YMM register,
    and src[2] can be an XMM or a YMM register or a 128- or 256-bit memory location),
    and an imm[8] operand. Their syntax is the following:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Whereas the SSE shuffle instructions use the destination register as an implicit
    source operand, the AVX shuffle instructions allow you to specify explicit destination
    and source operands (they can all be different, or all the same, or any combination
    thereof).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: For the 256-bit `vshufps` instructions, the imm[8] operand is an array of four
    2-bit values (bits 0:1, 2:3, 4:5, and 6:7). These 2-bit values select one of four
    single-precision values from the source locations, as described in [Table 11-5](#table11-5).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-5: `vshufps` Destination Selection'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Destination** | **imm[8] value** |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
- en: '| **imm[8] bits** |  | **00** | **01** | **10** | **11** |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
- en: '| 76 54 32 **10** | Dest[0 to 31] | Src[1][0 to 31] | Src[1][32 to 63] | Src[1][64
    to 95] | Src[1][96 to 127] |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: '|  | Dest[128 to 159] | Src[1][128 to 159] | Src[1][160 to 191] | Src[1][192
    to 223] | Src[1][224 to 255] |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
- en: '| 76 54 **32** 10 | Dest[32 to 63] | Src[1][0 to 31] | Src[1][32 to 63] | Src[1][64
    to 95] | Src[1][96 to 127] |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '|  | Dest[160 to 191] | Src[1][128 to 159] | Src[1][160 to 191] | Src[1][192
    to 223] | Src[1][224 to 255] |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: '| 76 **54** 32 10 | Dest[64 to 95] | Src[2][0 to 31] | Src[2][32 to 63] | Src[2][64
    to 95] | Src[2][96 to 127] |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: '|  | Dest[192 to 223] | Src[2][128 to 159] | Src[2][160 to 191] | Src[2][192
    to 223] | Src[2][224 to 255] |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
- en: '| **76** 54 32 10 | Dest[96 to 127] | Src[2][0 to 31] | Src[2][32 to 63] |
    Src[2][64 to 95] | Src[2][96 to 127] |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
- en: '|  | Dest[224 to 255] | Src[2][128 to 159] | Src[2][160 to 191] | Src[2][192
    to 223] | Src[2][224 to 255] |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
- en: If both source operands are the same, you can shuffle around the single-precision
    values in any order you choose (and if the destination and both source operands
    are the same, you can arbitrarily shuffle the dwords within that register).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: The `vshufps` instruction also allows you to specify XMM and 128-bit memory
    operands. In this form, it behaves quite similarly to the `shufps` instruction
    except that you get to specify two different 128-bit source operands (rather than
    only one 128-bit source operand), and it zeroes the HO 128 bits of the corresponding
    YMM register. If the destination operand is different from the first source operand,
    this can be useful. If the `vshufps`’s first source operand is the same XMM register
    as the destination operand, you should use the `shufps` instruction as its machine
    encoding is shorter.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: The `vshufpd` instruction is an extension of `shufpd` to 256 bits (plus the
    addition of a second source operand). As there are four double-precision values
    present in a 256-bit YMM register, `vshufpd` needs 4 bits to select the source
    indexes (rather than the 2 bits that `shufpd` requires). [Table 11-6](#table11-6)
    describes how `vshufpd` copies the data from the source operands to the destination
    operand.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-6: `vshufpd` Destination Selection'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Destination** | **imm[8] value** |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
- en: '| **imm[8] bits** |  | **0** | **1** |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
- en: '| 7654 3 2 1 **0** | Dest[0 to 63] | Src[1][0 to 63] | Src[1][64 to 127] |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
- en: '| 7654 3 2 **1** 0 | Dest[64 to 127] | Src[2][0 to 63] | Src[2][64 to 127]
    |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
- en: '| 7654 3 **2** 1 0 | Dest[128 to 191] | Src[1][128 to 191] | Src[1][192 to
    255] |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
- en: '| 7654 **3** 2 1 0 | Dest[192 to 255] | Src[2][128 to 191] | Src[2][192 to
    255] |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
- en: Like the `vshufps` instruction, `vshufpd` also allows you to specify XMM registers
    if you want a three-operand version of `shufpd`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.6 The (v)unpcklps, (v)unpckhps, (v)unpcklpd, and (v)unpckhpd Instructions
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The unpack (and merge) instructions are a simplified variant of the shuffle
    instructions. These instructions copy single- and double-precision values from
    fixed locations in their source operands and insert those values into fixed locations
    in the destination operand. They are, essentially, shuffle instructions without
    the imm[8] operand and with fixed shuffle patterns.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'The `unpcklps` and `unpckhps` instructions choose half their single-precision
    operands from one of two sources, merge these values (interleaving them), and
    then store the merged result into the destination operand (which is the same as
    the first source operand). The syntax for these two instructions is as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The XMM[dest] operand serves as both the first source operand and the destination
    operand. The XMM[src]/mem[128] operand is the second source operand.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the two is the way they select their source operands.
    The `unpcklps` instruction copies the two LO single-precision values from the
    source operand to bit positions 32 to 63 (dword 1) and 96 to 127 (dword 3). It
    leaves dword 0 in the destination operand alone and copies the value originally
    in dword 1 to dword 2 in the destination. [Figure 11-28](#figure11-28) diagrams
    this operation.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '![f11028](image_fi/501089c11/f11028.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-28: `unpcklps` instruction operation'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: The `unpckhps` instruction copies the two HO single-precision values from the
    two sources to the destination register, as shown in [Figure 11-29](#figure11-29).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '![f11029](image_fi/501089c11/f11029.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-29: `unpckhps` instruction operation'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: The `unpcklpd` and `unpckhpd` instructions do the same thing as `unpcklps` and
    `unpckhps` except, of course, they operate on double-precision values rather than
    single-precision values. Figures 11-30 and 11-31 show the operation of these two
    instructions.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '![f11030](image_fi/501089c11/f11030.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-30: `unpcklpd` instruction operation'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '![f11031](image_fi/501089c11/f11031.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-31: `unpckhpd` instruction operation'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vunpcklps`, `vunpckhps`, `vunpcklpd`, and `vunpckhpd` instructions have
    the following syntax:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'They work similarly to the non-`v` variants, with a couple of differences:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: The AVX variants support using the YMM registers as well as the XMM registers.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AVX variants require three operands. The first (destination) and second
    (source[1]) operands must be XMM or YMM registers. The third (source[2]) operand
    can be an XMM or a YMM register or a 128- or 256-bit memory location. The two-operand
    form is just a special case of the three-operand form, where the first and second
    operands specify the same register name.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 128-bit variants zero out the HO bits of the YMM register rather than leaving
    those bits unchanged.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course, the AVX instructions with the YMM registers interleave twice as
    many single- or double-precision values. The interleaving extension happens in
    the intuitive way, with `vunpcklps` ([Figure 11-32](#figure11-32)):'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: The single-precision values in source[1], bits 0 to 31, are first written to
    bits 0 to 31 of the destination.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-precision values in source[2], bits 0 to 31, are written to bits
    32 to 63 of the destination.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-precision values in source[1], bits 32 to 63, are written to bits
    64 to 95 of the destination.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-precision values in source[2], bits 32 to 63, are written to bits
    96 to 127 of the destination.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-precision values in source[1], bits 128 to 159, are first written
    to bits 128 to 159 of the destination.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-precision values in source[2], bits 128 to 159, are written to bits
    160 to 191 of the destination.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-precision values in source[1], bits 160 to 191, are written to bits
    192 to 223 of the destination.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-precision values in source[2], bits 160 to 191, are written to bits
    224 to 256 of the destination.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![f11032](image_fi/501089c11/f11032.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-32: `vunpcklps` instruction operation'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vunpckhps` instruction ([Figure 11-33](#figure11-33)) does the following:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: The single-precision values in source[1], bits 64 to 95, are first written to
    bits 0 to 31 of the destination.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-precision values in source[2], bits 64 to 95, are written to bits
    32 to 63 of the destination.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-precision values in source[1], bits 96 to 127, are written to bits
    64 to 95 of the destination.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-precision values in source[2], bits 96 to 127, are written to bits
    96 to 127 of the destination.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![f11033](image_fi/501089c11/f11033.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-33: `vunpckhps` instruction operation'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, `vunpcklpd` and `vunpckhpd` move double-precision values.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.7 The Integer Unpack Instructions
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `punpck*` instructions provide a set of integer unpack instructions to complement
    the floating-point variants. These instructions appear in [Table 11-7](#table11-7).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-7: Integer Unpack Instructions'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction | Description |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
- en: '| `punpcklbw` | Unpacks low bytes to words |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
- en: '| `punpckhbw` | Unpacks high bytes to words |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
- en: '| `punpcklwd` | Unpacks low words to dwords |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
- en: '| `punpckhwd` | Unpacks high words to dwords |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
- en: '| `punpckldq` | Unpacks low dwords to qwords |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
- en: '| `punpckhdq` | Unpacks high dwords to qwords |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
- en: '| `punpcklqdq` | Unpacks low qwords to owords (double qwords) |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
- en: '| `punpckhqdq` | Unpacks high qwords to owords (double qwords) |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
- en: 11.7.7.1 The punpck* Instructions
  id: totrans-413
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `punpck*` instructions extract half the bytes, words, dwords, or qwords
    from two different sources and merge these values into a destination SSE register.
    The syntax for these instructions is shown here:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Figures 11- 34 through 11-41 show the data transfers for each of these instructions.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '![f11034](image_fi/501089c11/f11034.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-34: `punpcklbw` instruction operation'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '![f11035](image_fi/501089c11/f11035.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-35: `punpckhbw` operation'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '![f11036](image_fi/501089c11/f11036.png)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-36: `punpcklwd` operation'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '![f11037](image_fi/501089c11/f11037.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-37: `punpckhwd` operation'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '![f11038](image_fi/501089c11/f11038.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-38: `punpckldq` operation'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '![f11039](image_fi/501089c11/f11039.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-39: `punpckhdq` operation'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '![f11040](image_fi/501089c11/f11040.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-40: `punpcklqdq` operation'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '![f11041](image_fi/501089c11/f11041.png)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-41: `punpckhqdq` operation'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.7.2 The vpunpck* SSE Instructions
  id: totrans-433
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The AVX `vpunpck*` instructions provide a set of AVX integer unpack instructions
    to complement the SSE variants. These instructions appear in [Table 11-8](#table11-8).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-8: AVX Integer Unpack Instructions'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Description** |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
- en: '| `vpunpcklbw` | Unpacks low bytes to words |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
- en: '| `vpunpckhbw` | Unpacks high bytes to words |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
- en: '| `vpunpcklwd` | Unpacks low words to dwords |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
- en: '| `vpunpckhwd` | Unpacks high words to dwords |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
- en: '| `vpunpckldq` | Unpacks low dwords to qwords |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
- en: '| `vpunpckhdq` | Unpacks high dwords to qwords |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
- en: '| `vpunpcklqdq` | Unpacks low qwords to owords (double qwords) |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
- en: '| `vpunpckhqdq` | Unpacks high qwords to owords (double qwords) |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
- en: 'The `vpunpck*` instructions extract half the bytes, words, dwords, or qwords
    from two different sources and merge these values into a destination AVX or SSE
    register. Here is the syntax for the SSE forms of these instructions:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Functionally, the only difference between these AVX instructions (`vunpck*`)
    and the SSE (`unpck*`) instructions is that the SSE variants leave the upper bits
    of the YMM AVX registers (bits 128 to 255) unchanged, whereas the AVX variants
    zero-extend the result to 256 bits. See Figures 11-34 through 11-41 for a description
    of the operation of these instructions.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.7.3 The vpunpck* AVX Instructions
  id: totrans-449
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The AVX `vunpck*` instructions also support the use of the AVX YMM registers,
    in which case the unpack and merge operation extends from 128 bits to 256 bits.
    The syntax for these instructions is as follows:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 11.7.8 The (v)pextrb, (v)pextrw, (v)pextrd, and (v)pextrq Instructions
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `(v)pextrb`, `(v)pextrw`, `(v)pextrd`, and `(v)pextrq` instructions extract
    a byte, word, dword, or qword from a 128-bit XMM register and copy this data to
    a general-purpose register or memory location. The syntax for these instructions
    is the following:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The byte and word instructions expect a 32- or 64-bit general-purpose register
    as their destination (first operand) or a memory location that is the same size
    as the instruction (that is, `pextrb` expects a byte-sized memory operand, `pextrw`
    expects a word-sized operand, and so on). The source (second) operand is a 128-bit
    XMM register. The index (third) operand is an 8-bit immediate value that specifies
    an index (lane number). These instructions fetch the byte, word, dword, or qword
    in the lane specified by the 8-bit immediate value and copy that value into the
    destination operand. The double-word and quad-word variants require a 32-bit or
    64-bit general-purpose register, respectively. If the destination operand is a
    32- or 64-bit general-purpose register, the instruction zero-extends the value
    to 32 or 64 bits, if necessary.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.9 The (v)pinsrb, (v)pinsrw, (v)pinsrd, and (v)pinsrq Instructions
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `(v)pinsr{b,w,d,q}` instructions take a byte, word, dword, or qword from
    a general-purpose register or memory location and store that data to a lane of
    an XMM register. The syntax for these instructions is the following:^([9](#c11-footnote-9))
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The destination (first) operand is a 128-bit XMM register. The `pinsr*` instructions
    expect a memory location or a 32-bit general-purpose register as their source
    (second) operand (except the `pinsrq` instructions, which require a 64-bit register).
    The index (third) operand is an 8-bit immediate value that specifies an index
    (lane number).
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: These instructions fetch a byte, word, dword, or qword from the general-purpose
    register or memory location and copy that to the lane in the XMM register specified
    by the 8-bit immediate value. The `pinsr{b,w,d,q}` instructions leave any HO bits
    in the underlying YMM register unchanged (if applicable).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: The `vpinsr{b,w,d,q}` instructions copy the data from the XMM source register
    into the destination register and then copy the byte, word, dword, or quad word
    to the specified location in the destination register. These instructions zero-extend
    the value throughout the HO bits of the underlying YMM register.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.10 The (v)extractps and (v)insertps Instructions
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `extractps` and `vextractps` instructions are functionally equivalent to
    `pextrd` and `vpextrd`. They extract a 32-bit (single-precision floating-point)
    value from an XMM register and move it into a 32-bit general-purpose register
    or a 32-bit memory location. The syntax for the `(v)extractps` instructions is
    shown here:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `insertps` and `vinsertps` instructions insert a 32-bit floating-point
    value into an XMM register and, optionally, zero out other lanes in the XMM register.
    The syntax for these instructions is as follows:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: For the `insertps` and `vinsertps` instructions, the imm[8] operand has the
    fields listed in [Table 11-9](#table11-9).
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-9: imm[8] Bit Fields for `insertps` and `vinsertps` Instructions'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit(s)** | **Meaning** |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
- en: '| 6 to 7 | (Only if the source operand is an XMM register): Selects the 32-bit
    lane from the source XMM register (0, 1, 2, or 3). If the source operand is a
    32-bit memory location, the instruction ignores this field and uses the full 32
    bits from memory. |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
- en: '| 4 to 5 | Specifies the lane in the destination XMM register in which to store
    the single-precision value. |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
- en: '| 3 | If set, zeroes lane 3 of XMM[dest]. |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
- en: '| 2 | If set, zeroes lane 2 of XMM[dest]. |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
- en: '| 1 | If set, zeroes lane 1 of XMM[dest]. |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
- en: '| 0 | If set, zeroes lane 0 of XMM[dest]. |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
- en: On CPUs with the AVX extensions, `insertps` does not modify the upper bits of
    the YMM registers; `vinsertps` zeroes the upper bits.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: The `vinsertps` instruction first copies the XMM[src1] register to XMM[dest]
    before performing the insertion operation. The HO bits of the corresponding YMM
    register are set to 0.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: The x86-64 does not provide `(v)extractpd` or `(v)insertpd` instructions.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 11.8 SIMD Arithmetic and Logical Operations
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SSE and AVX instruction set extensions provide a variety of scalar and vector
    arithmetic and logical operations.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: “SSE Floating-Point Arithmetic” in Chapter 6 has already covered floating-point
    arithmetic using the scalar SSE instruction set, so this section does not repeat
    that discussion. Instead, this section covers the *vector* (or *packed*) arithmetic
    and logical instructions.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: The vector instructions perform multiple operations in parallel on the different
    data lanes in an SSE or AVX register. Given two source operands, a typical SSE
    instruction will calculate two double-precision floating-point results, two quad-word
    integer calculations, four single-precision floating-point operations, four double-word
    integer calculations, eight word integer calculations, or sixteen byte calculations,
    simultaneously. The AVX registers (YMM) double the number of lanes and therefore
    double the number of concurrent calculations.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-42](#figure11-42) shows how the SSE and AVX instructions perform
    concurrent calculations; a value is taken from the same lane in two source locations,
    the calculation is performed, and the instruction stores the result to the same
    lane in the destination location. This process happens simultaneously for each
    lane in the source and destination operands. For example, if a pair of XMM registers
    contains four single-precision floating-point values, a SIMD packed floating-point
    addition instruction would add the single-precision values in the corresponding
    lanes of the source operands and store the single-precision sums into the corresponding
    lanes of the destination XMM register.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '![f11042](image_fi/501089c11/f11042.png)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-42: SIMD concurrent arithmetic and logical operations'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: Certain operations—for example, logical AND, ANDN (*and not*), OR, and XOR—don’t
    have to be broken into lanes, because those operations perform the same result
    regardless of the instruction size. The lane size is a single bit. Therefore,
    the corresponding SSE/AVX instructions operate on their entire operands without
    regard for a lane size.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: 11.9 The SIMD Logical (Bitwise) Instructions
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SSE and AVX instruction set extensions provide the logical operations shown
    in [Table 11-10](#table11-10) (using C/C++ bitwise operator syntax).
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-10: SSE/AVX Logical Instructions'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Description** |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
- en: '| `andpd` | dest = dest and source (128-bit operands) |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
- en: '| `vandpd` | dest = source1 and source2 (128-bit or 256-bit operands) |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
- en: '| `andnpd` | dest = dest and ~source (128-bit operands) |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
- en: '| `vandnpd` | dest = source1 and ~source2 (128-bit or 256-bit operands) |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
- en: '| `orpd` | dest = dest &#124; source (128-bit operands) |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
- en: '| `vorpd` | dest = source1 &#124; source2 (128-bit or 256-bit operands) |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
- en: '| `xorpd` | dest = dest ^ source (128-bit operands) |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
- en: '| `vxorpd` | dest = source1 ^ source2 (128-bit or 256-bit operands) |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
- en: 'The syntax for these instructions is the following:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The SSE instructions (without the `v` prefix) leave the HO bits of the underlying
    YMM register unchanged (if applicable). The AVX instructions (with the `v` prefix)
    that have 128-bit operands will zero-extend their result into the HO bits of the
    YMM register.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: If the (second) source operand is a memory location, it must be aligned on an
    appropriate boundary (for example, 16 bytes for mem[128] values and 32 bytes for
    mem[256] values). Failure to do so will result in a runtime memory alignment fault.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: 11.9.1 The (v)ptest Instructions
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ptest` instruction (*packed test*) is similar to the standard integer
    `test` instruction. The `ptest` instruction performs a logical AND between the
    two operands and sets the zero flag if the result is 0\. The `ptest` instruction
    sets the carry flag if the logical AND of the second operand with the inverted
    bits of the first operand produces 0\. The `ptest` instruction supports the following
    syntax:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 11.9.2 The Byte Shift Instructions
  id: totrans-508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The SSE and AVX instruction set extensions also support a set of logical and
    arithmetic shift instructions. The first two to consider are `pslldq` and `psrldq`.
    Although they begin with a `p`, suggesting they are packed (vector) instructions,
    these instructions really are just 128-bit logical shift-left and shift-right
    instructions. Their syntax is as follows:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `pslldq` instruction shifts its destination XMM register to the left by
    the number of *bytes* specified by the imm[8] operand. This instruction shifts
    0s into the vacated LO bytes.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: The `vpslldq` instruction takes the value in the source register (XMM or YMM),
    shifts that value to the left by imm[8] bytes, and then stores the result into
    the destination register. For the 128-bit variant, this instruction zero-extends
    the result into bits 128 to 255 of the underlying YMM register (on AVX-capable
    CPUs).
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: The `psrldq` and `vpsrldq` instructions operate similarly to `(v)pslldq` except,
    of course, they shift their operands to the right rather than to the left. These
    are logical shift-right operations, so they shift 0s into the HO bytes of their
    operand, and bits shifted out of bit 0 are lost.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: The `pslldq` and `psrldq` instructions shift *bytes* rather than bits. For example,
    many SSE instructions produce byte masks 0 or 0FFh, representing Boolean results.
    These instructions shift the equivalent of a bit in one of these byte masks by
    shifting whole bytes at a time.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: 11.9.3 The Bit Shift Instructions
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SSE/AVX instruction set extensions also provide vector bit shift operations
    that work on two or more integer lanes, concurrently. These instructions provide
    word, dword, and qword variants of the logical shift-left, logical shift-right,
    and arithmetic shift-right operations, using the syntax
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: where `shift` = `psllw`, `pslld`, `psllq`, `psrlw`, `psrld`, `psrlq`, `psraw`,
    or `psrad`, and `vshift` = `vpsllw`, `vpslld`, `vpsllq`, `vpsrlw`, `vpsrld`, `vpsrlq`,
    `vpsraw`, `vpsrad`, or `vpsraq`.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: The `(v)psl*` instructions shift their operands to the left; the `(v)psr*` instructions
    shift their operands to the right. The `(v)psll*` and `(v)psrl*` instructions
    are logical shift instructions and shift 0s into the bits vacated by the shift.
    Any bits shifted out of the operand are lost. The `(v)psra*` instructions are
    arithmetic shift-right instructions. They replicate the HO bit in each lane when
    shifting that lane’s bits to the right; all bits shifted out of the LO bit are
    lost.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: The SSE two-operand instructions treat their first operand as both the source
    and destination operand. The second operand specifies the number of bits to shift
    (which is either an 8-bit immediate constant or a value held in an XMM register
    or a 128-bit memory location). Regardless of the shift count’s size, only the
    LO 4, 5, or 6 bits of the count are meaningful (depending on the lane size).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: The AVX three-operand instructions specify a separate source and destination
    register for the shift operation. These instructions take the value from the source
    register, shift it the specified number of bits, and store the shifted result
    into the destination register. The source register remains unmodified (unless,
    of course, the instruction specifies the same register for the source and destination
    operands). For the AVX instructions, the source and destination registers can
    be XMM (128-bit) or YMM (256-bit) registers. The third operand is either an 8-bit
    immediate constant, an XMM register, or a 128-bit memory location. The third operand
    specifies the bit shift count (the same as the SSE instructions). You specify
    an XMM register for the count even when the source and destination registers are
    256-bit YMM registers.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: The `w` suffix instructions shift 16-bit operands (eight lanes for 128-bit destination
    operands, sixteen lanes for 256-bit destinations). The `d` suffix instructions
    shift 32-bit dword operands (four lanes for 128-bit destination operands, eight
    lanes for 256-bit destination operands). The `q` suffix instructions shift 64-bit
    operands (two lanes for 128-bit operands, four lanes for 256-bit operands).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: 11.10 The SIMD Integer Arithmetic Instructions
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SSE and AVX instruction set extensions deal mainly with floating-point calculations.
    They do, however, include a set of signed and unsigned integer arithmetic operations.
    This section describes the SSE/AVX integer arithmetic instructions.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.1 SIMD Integer Addition
  id: totrans-525
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SIMD integer addition instructions appear in [Table 11-11](#table11-11).
    These instructions do not affect any flags and thus do not indicate when an overflow
    (signed or unsigned) occurs during the execution of these instructions. The program
    itself must ensure that the source operands are all within the appropriate range
    before performing an addition. If carry occurs during an addition, the carry is
    lost.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-11: SIMD Integer Addition Instructions'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Operands** | **Description** |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
- en: '| `paddb` | `xmm`[dest], `xmm`/`mem`[128] | 16-lane byte addition |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
- en: '| `vpaddb` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 16-lane byte
    addition |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
- en: '| `vpaddb` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 32-lane byte
    addition |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
- en: '| `paddw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word addition |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
- en: '| `vpaddw` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 8-lane word
    addition |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
- en: '| `vpaddw` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 16-lane word
    addition |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
- en: '| `paddd` | `xmm`[dest], `xmm`/`mem`[128] | 4-lane dword addition |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
- en: '| `vpaddd` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 4-lane dword
    addition |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
- en: '| `vpaddd` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 8-lane dword
    addition |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
- en: '| `paddq` | `xmm`[dest], `xmm`/`mem`[128] | 2-lane qword addition |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
- en: '| `vpaddq` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 2-lane qword
    addition |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
- en: '| `vpaddq` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 4-lane qword
    addition |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
- en: These addition instructions are known as *vertical additions* because if we
    stack the two source operands on top of each other (on a printed page), the lane
    additions occur vertically (one source lane is directly above the second source
    lane for the corresponding addition operation).
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: The packed additions ignore any overflow from the addition operation, keeping
    only the LO byte, word, dword, or qword of each addition. As long as overflow
    is never possible, this is not an issue. However, for certain algorithms (especially
    audio and video, which commonly use packed addition), truncating away the overflow
    can produce bizarre results.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: A cleaner solution is to use *saturation arithmetic*. For unsigned addition,
    saturation arithmetic *clips* (or *saturates*) an overflow to the largest possible
    value that the instruction’s size can handle. For example, if the addition of
    two byte values exceeds 0FFh, saturation arithmetic produces 0FFh—the largest
    possible unsigned 8-bit value (likewise, saturation subtraction would produce
    0 if underflow occurs). For signed saturation arithmetic, clipping occurs at the
    largest positive and smallest negative values (for example, 7Fh/+127 for positive
    values and 80h/–128 for negative values).
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: The x86 SIMD instructions provide both signed and unsigned saturation arithmetic,
    though the operations are limited to 8- and 16-bit quantities.^([10](#c11-footnote-10))
    The instructions appear in [Table 11-12](#table11-12).
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-12: SIMD Integer Saturation Addition Instructions'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Operands** | **Description** |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
- en: '| `paddsb` | `xmm`[dest], `xmm`/`mem`[128] | 16-lane byte signed saturation
    addition |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
- en: '| `vpaddsb` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 16-lane byte
    signed saturation addition |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
- en: '| `vpaddsb` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 32-lane byte
    signed saturation addition |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
- en: '| `paddsw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word signed saturation
    addition |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
- en: '| `vpaddsw` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 8-lane word
    signed saturation addition |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
- en: '| `vpaddsw` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 16-lane word
    signed saturation addition |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
- en: '| `paddusb` | `xmm`[dest], `xmm`/`mem`[128] | 16-lane byte unsigned saturation
    addition |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
- en: '| `vpaddusb` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 16-lane byte
    unsigned saturation addition |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
- en: '| `vpaddusb` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 32-lane byte
    unsigned saturation addition |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
- en: '| `paddusw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word unsigned saturation
    addition |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
- en: '| `vpaddusw` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 8-lane word
    unsigned saturation addition |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
- en: '| `vpaddusw` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 16-lane word
    unsigned saturation addition |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
- en: As usual, both `padd*` and `vpadd*` instructions accept 128-bit XMM registers
    (sixteen 8-bit additions or eight 16-bit additions). The `padd*` instructions
    leave the HO bits of any corresponding YMM destination undisturbed; the `vpadd*`
    variants clear the HO bits. Also note that the `padd*` instructions have only
    two operands (the destination register is also a source), whereas the `vpadd*`
    instructions have two source operands and a single destination operand. The `vpadd*`
    instructions with the YMM register provide double the number of parallel additions.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.2 Horizontal Additions
  id: totrans-562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SSE/AVX instruction sets also support three *horizontal addition* instructions,
    listed in [Table 11-13](#table11-13).
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-13: Horizontal Addition Instructions'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Description** |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
- en: '| `(v)``phaddw` | 16-bit (word) horizontal add |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
- en: '| `(v)``phaddd` | 32-bit (dword) horizontal add |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
- en: '| `(v)``phaddsw` | 16-bit (word) horizontal add and saturate |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
- en: The horizontal addition instructions add adjacent words or dwords in their two
    source operands and store the sum of the result into a destination lane, as shown
    in [Figure 11-43](#figure11-43).
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '![f11043](image_fi/501089c11/f11043.png)'
  id: totrans-571
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-43: Horizontal addition operation'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: 'The `phaddw` instruction has the following syntax:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It computes the following:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As is the case with most SSE instructions, `phaddw` does not affect the HO bits
    of the corresponding YMM destination register, only the LO 128 bits.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: 'The 128-bit `vphaddw` instruction has the following syntax:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'It computes the following:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `vphaddw` instruction zeroes out the HO 128 bits of the corresponding YMM
    destination register.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: 'The 256-bit `vphaddw` instruction has the following syntax:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`vphaddw` does not simply extend the 128-bit version in the intuitive way.
    Instead, it mixes up computations as follows (where `SRC1` is YMM[src1] and `SRC2`
    is YMM[src2]/mem[256]):'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 11.10.3 Double-Word–Sized Horizontal Additions
  id: totrans-587
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `phaddd` instruction has the following syntax:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'It computes the following:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The 128-bit `vphaddd` instruction has this syntax:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It computes the following:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Like `vphaddw`, the 256-bit `vphaddd` instruction has the following syntax:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'It calculates the following:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If an overflow occurs during the horizontal addition, `(v)phaddw` and `(v)phaddd`
    simply ignore the overflow and store the LO 16 or 32 bits of the result into the
    destination location.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: 'The `(v)phaddsw` instructions take the following forms:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `(v)phaddsw` instruction (*horizontal signed integer add with saturate,
    word*) is a slightly different form of `(v)phaddw`: rather than storing only the
    LO bits into the result in the destination lane, this instruction saturates the
    result. *Saturation* means that any (positive) overflow results in the value 7FFFh,
    regardless of the actual result. Likewise, any negative underflow results in the
    value 8000h.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: Saturation arithmetic works well for audio and video processing. If you were
    using standard (wraparound/modulo) addition when adding two sound samples together,
    the result would be horrible clicking sounds. Saturation, on the other hand, simply
    produces a clipped audio signal. While this is not ideal, it sounds considerably
    better than the results from modulo arithmetic. Similarly, for video processing,
    saturation produces a washed-out (white) color versus the bizarre colors that
    result from modulo arithmetic.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, there is no horizontal add with saturation for double-word operands (for
    example, to handle 24-bit audio).
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.4 SIMD Integer Subtraction
  id: totrans-606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SIMD integer subtraction instructions appear in [Table 11-14](#table11-14).
    As for the SIMD addition instructions, they do not affect any flags; any carry,
    borrow, overflow, or underflow information is lost. These instructions subtract
    the second source operand from the first source operand (which is also the destination
    operand for the SSE-only instructions) and store the result into the destination
    operand.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-14: SIMD Integer Subtraction Instructions'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Operands** | **Description** |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
- en: '| `psubb` | `xmm`[dest], `xmm`/`mem`[128] | 16-lane byte subtraction |'
  id: totrans-611
  prefs: []
  type: TYPE_TB
- en: '| `vpsubb` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 16-lane byte subtraction
    |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
- en: '| `vpsubb` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 32-lane byte subtraction
    |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
- en: '| `psubw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word subtraction |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
- en: '| `vpsubw` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 8-lane word subtraction
    |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
- en: '| `vpsubw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16-lane word subtraction
    |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
- en: '| `psubd` | `xmm`[dest], `xmm`/`mem`[128] | 4-lane dword subtraction |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
- en: '| `vpsubd` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 4-lane dword subtraction
    |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
- en: '| `vpsubd` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 8-lane dword subtraction
    |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
- en: '| `psubq` | `xmm`[dest], `xmm`/`mem`[128] | 2-lane qword subtraction |'
  id: totrans-620
  prefs: []
  type: TYPE_TB
- en: '| `vpsubq` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 2-lane qword subtraction
    |'
  id: totrans-621
  prefs: []
  type: TYPE_TB
- en: '| `vpsubq` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 4-lane qword subtraction
    |'
  id: totrans-622
  prefs: []
  type: TYPE_TB
- en: The `(v)phsubw`, `(v)phsubd`, and `(v)phsubsw` horizontal subtraction instructions
    work just like the horizontal addition instructions, except (of course) they compute
    the difference of the two source operands rather than the sum. See the previous
    sections for details on the horizontal addition instructions.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, there is a set of signed and unsigned byte and word saturating subtraction
    instructions (see [Table 11-15](#table11-15)). For the signed instructions, the
    byte-sized instructions saturate positive overflow to 7Fh (+127) and negative
    underflow to 80h (–128). The word-sized instructions saturate to 7FFFh (+32,767)
    and 8000h (–32,768). The unsigned saturation instructions saturate to 0FFFFh (+65,535)
    and 0.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-15: SIMD Integer Saturating Subtraction Instructions'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Operands** | **Description** |'
  id: totrans-626
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
- en: '| `psubsb` | `xmm`[dest], `xmm`/`mem`[128] | 16-lane byte signed saturation
    subtraction |'
  id: totrans-628
  prefs: []
  type: TYPE_TB
- en: '| `vpsubsb` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 16-lane byte signed
    saturation subtraction |'
  id: totrans-629
  prefs: []
  type: TYPE_TB
- en: '| `vpsubsb` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 32-lane byte signed
    saturation subtraction |'
  id: totrans-630
  prefs: []
  type: TYPE_TB
- en: '| `psubsw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word signed saturation
    subtraction |'
  id: totrans-631
  prefs: []
  type: TYPE_TB
- en: '| `vpsubsw` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 8-lane word signed
    saturation subtraction |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
- en: '| `vpsubsw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16-lane word signed
    saturation subtraction |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
- en: '| `psubusb` | `xmm`[dest], `xmm`/`mem`[128] | 16-lane byte unsigned saturation
    subtraction |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
- en: '| `vpsubusb` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 16-lane byte unsigned
    saturation subtraction |'
  id: totrans-635
  prefs: []
  type: TYPE_TB
- en: '| `vpsubusb` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 32-lane byte unsigned
    saturation subtraction |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
- en: '| `psubusw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word unsigned saturation
    subtraction |'
  id: totrans-637
  prefs: []
  type: TYPE_TB
- en: '| `vpsubusw` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 8-lane word unsigned
    saturation subtraction |'
  id: totrans-638
  prefs: []
  type: TYPE_TB
- en: '| `vpsubusw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16-lane word unsigned
    saturation subtraction |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
- en: 11.10.5 SIMD Integer Multiplication
  id: totrans-640
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SSE/AVX instruction set extensions *somewhat* support multiplication. Lane-by-lane
    multiplication requires that the result of an operation on two *n*-bit values
    fits in *n* bits, but *n* × *n* multiplication can produce a 2×*n*-bit result.
    So a lane-by-lane multiplication operation creates problems as overflow is lost.
    The basic packed integer multiplication multiplies a pair of lanes and stores
    the LO bits of the result in the destination lane. For extended arithmetic, packed
    integer multiplication instructions produce the HO bits of the result.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: The instructions in [Table 11-16](#table11-16) handle 16-bit multiplication
    operations. The `(v)pmullw` instruction multiplies the 16-bit values appearing
    in the lanes of the source operand and stores the LO word of the result into the
    corresponding destination lane. This instruction is applicable to both signed
    and unsigned values. The `(v)pmulhw` instruction computes the product of two signed
    word values and stores the *HO word* of the result into the destination lanes.
    For unsigned operands, `(v)pmulhuw` performs the same task. By executing both
    `(v)pmullw` and `(v)pmulh(u)w` with the same operands, you can compute the full
    32-bit result of a 16×16-bit multiplication. (You can use the `punpck*` instructions
    to merge the results into 32-bit integers.)
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-16: SIMD 16-Bit Packed Integer Multiplication Instructions'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Operands** | **Description** |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
- en: '| `pmullw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word multiplication, producing
    the LO word of the product |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
- en: '| `vpmullw` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 8-lane word multiplication,
    producing the LO word of the product |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
- en: '| `vpmullw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16-lane word multiplication,
    producing the LO word of the product |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
- en: '| `pmulhuw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word unsigned multiplication,
    producing the HO word of the product |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
- en: '| `vpmulhuw` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 8-lane word unsigned
    multiplication, producing the HO word of the product |'
  id: totrans-650
  prefs: []
  type: TYPE_TB
- en: '| `vpmulhuw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16-lane word unsigned
    multiplication, producing the HO word of the product |'
  id: totrans-651
  prefs: []
  type: TYPE_TB
- en: '| `pmulhw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word signed multiplication,
    producing the HO word of the product |'
  id: totrans-652
  prefs: []
  type: TYPE_TB
- en: '| `vpmulhw` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 8-lane word signed
    multiplication, producing the HO word of the product |'
  id: totrans-653
  prefs: []
  type: TYPE_TB
- en: '| `vpmulhw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16-lane word signed
    multiplication, producing the HO word of the product |'
  id: totrans-654
  prefs: []
  type: TYPE_TB
- en: '[Table 11-17](#table11-17) lists the 32- and 64-bit versions of the packed
    multiplication instructions. There are no `(v)pmulhd` or `(v)pmulhq` instructions;
    see `(v)pmuludq` and `(v)pmuldq` to handle 32- and 64-bit packed multiplication.'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-17: SIMD 32- and 64-Bit Packed Integer Multiplication Instructions'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Operands** | **Description** |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
- en: '| `pmulld` | `xmm`[dest], `xmm`/`mem`[128] | 4-lane dword multiplication, producing
    the LO dword of the product |'
  id: totrans-659
  prefs: []
  type: TYPE_TB
- en: '| `vpmulld` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 4-lane dword multiplication,
    producing the LO dword of the product |'
  id: totrans-660
  prefs: []
  type: TYPE_TB
- en: '| `vpmulld` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 8-lane dword multiplication,
    producing the LO dword of the product |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
- en: '| `vpmullq` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 2-lane qword multiplication,
    producing the LO qword of the product |'
  id: totrans-662
  prefs: []
  type: TYPE_TB
- en: '| `vpmullq` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 4-lane qword multiplication,
    producing the LO qword of the product (available on only AVX-512 CPUs) |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
- en: 'At some point along the way, Intel introduced `(v)pmuldq` and `(v)pmuludq`
    to perform signed and unsigned 32×32-bit multiplications, producing a 64-bit result.
    The syntax for these instructions is as follows:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The 128-bit variants multiply the double words appearing in lanes 0 and 2 and
    store the 64-bit results into qword lanes 0 and 1 (dword lanes 0 and 1 and 2 and
    3). On CPUs with AVX registers,^([11](#c11-footnote-11)) `pmuldq` and `pmuludq`
    do not affect the HO 128 bits of the YMM register. The `vpmuldq` and `vpmuludq`
    instructions zero-extend the result to 256 bits. The 256-bit variants multiply
    the double words appearing in lanes 0, 2, 4, and 6, producing 64-bit results that
    they store in qword lanes 0, 1, 2, and 3 (dword lanes 0 and 1, 2 and 3, 4 and
    5, and 6 and 7 ).
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pclmulqdq` instruction provides the ability to multiply two qword values,
    producing a 128-bit result. Here is the syntax for this instruction:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: These instructions multiply a pair of qword values found in XMM[dest] and XMM[src]
    and leave the 128-bit result in XMM[dest]. The imm[8] operand specifies which
    qwords to use as the source operands. [Table 11-18](#table11-18) lists the possible
    combinations for `pclmulqdq`. [Table 11-19](#table11-19) lists the combinations
    for `vpclmulqdq`.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-18: imm[8] Operand Values for `pclmulqdq` Instruction'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '| **imm[8]** | **Result** |'
  id: totrans-671
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-672
  prefs: []
  type: TYPE_TB
- en: '| 00h | XMM[dest] = XMM[dest][0 to 63] * XMM/mem[128][0 to 63] |'
  id: totrans-673
  prefs: []
  type: TYPE_TB
- en: '| 01h | XMM[dest] = XMM[dest][64 to 127] * XMM/mem[128][0 to 63] |'
  id: totrans-674
  prefs: []
  type: TYPE_TB
- en: '| 10h | XMM[dest] = XMM[dest][0 to 63] * XMM/mem[128][64 to 127] |'
  id: totrans-675
  prefs: []
  type: TYPE_TB
- en: '| 11h | XMM[dest] = XMM[dest][64 to 127] * XMM/mem[128][64 to 127] |'
  id: totrans-676
  prefs: []
  type: TYPE_TB
- en: 'Table 11-19: imm[8] Operand Values for `vpclmulqdq` Instruction'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '| **imm[8]** | **Result** |'
  id: totrans-678
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-679
  prefs: []
  type: TYPE_TB
- en: '| 00h | XMM[dest] = XMM[src1][0 to 63] * XMM[src2]/mem[128][0 to 63] |'
  id: totrans-680
  prefs: []
  type: TYPE_TB
- en: '| 01h | XMM[dest] = XMM[src1][64 to 127] * XMM[src2]/mem[128][0 to 63] |'
  id: totrans-681
  prefs: []
  type: TYPE_TB
- en: '| 10h | XMM[dest] = XMM[src1][0 to 63] * XMM[src2]/mem[128][64 to 127] |'
  id: totrans-682
  prefs: []
  type: TYPE_TB
- en: '| 11h | XMM[dest] = XMM[src1][64 to 127] * XMM[src2]/mem[128][64 to 127] |'
  id: totrans-683
  prefs: []
  type: TYPE_TB
- en: As usual, `pclmulqdq` leaves the HO 128 bits of the corresponding YMM destination
    register unchanged, while `vpcmulqdq` zeroes those bits.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.6 SIMD Integer Averages
  id: totrans-685
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `(v)pavgb` and `(v)pavgw` instructions compute the average of two sets
    of bytes or words. These instructions sum the value in the byte or word lanes
    of their source and destination operands, divide the result by 2, round the results,
    and leave the averaged results sitting in the destination operand lanes. The syntax
    for these instructions is shown here:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The 128-bit `pavgb` and `vpavgb` instructions compute 16 byte-sized averages
    (for the 16 lanes in the source and destination operands). The 256-bit variant
    of the `vpavgb` instruction computes 32 byte-sized averages.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: The 128-bit `pavgw` and `vpavgw` instructions compute eight word-sized averages
    (for the eight lanes in the source and destination operands). The 256-bit variant
    of the `vpavgw` instruction computes 16 byte-sized averages.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: The `vpavgb` and `vpavgw` instructions compute the average of the first XMM
    or YMM source operand and the second XMM, YMM, or mem source operand, storing
    the average in the destination XMM or YMM register.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there are no `(v)pavgd` or `(v)pavgq` instructions. No doubt,
    these instructions were originally intended for mixing 8- and 16-bit audio or
    video streams (or photo manipulation), and the x86-64 CPU designers never felt
    the need to extend this beyond 16 bits (even though 24-bit audio is common among
    professional audio engineers).
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.7 SIMD Integer Minimum and Maximum
  id: totrans-692
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SSE4.1 instruction set extensions added eight packed integer *minimum* and
    *maximum* instructions, as shown in [Table 11-20](#table11-20). These instructions
    scan the lanes of a pair of 128- or 256-bit operands and copy the maximum or minimum
    value from that lane to the same lane in the destination operand.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-20: SIMD Minimum and Maximum Instructions'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Description** |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pmaxsb` | Destination byte lanes set to the maximum value of the two
    signed byte values found in the corresponding source lanes. |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pmaxsw` | Destination word lanes set to the maximum value of the two
    signed word values found in the corresponding source lanes. |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pmaxsd` | Destination dword lanes set to the maximum value of the two
    signed dword values found in the corresponding source lanes. |'
  id: totrans-699
  prefs: []
  type: TYPE_TB
- en: '| `v``pmaxsq` | Destination qword lanes set to the maximum value of the two
    signed qword values found in the corresponding source lanes. (AVX-512 required
    for this instruction.) |'
  id: totrans-700
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pmaxub` | Destination byte lanes set to the maximum value of the two
    unsigned byte values found in the corresponding source lanes. |'
  id: totrans-701
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pmaxuw` | Destination word lanes set to the maximum value of the two
    unsigned word values found in the corresponding source lanes. |'
  id: totrans-702
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pmaxud` | Destination dword lanes set to the maximum value of the two
    unsigned dword values found in the corresponding source lanes. |'
  id: totrans-703
  prefs: []
  type: TYPE_TB
- en: '| `v``pmaxuq` | Destination qword lanes set to the maximum value of the two
    unsigned qword values found in the corresponding source lanes. (AVX-512 required
    for this instruction.) |'
  id: totrans-704
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pminsb` | Destination byte lanes set to the minimum value of the two
    signed byte values found in the corresponding source lanes. |'
  id: totrans-705
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pminsw` | Destination word lanes set to the minimum value of the two
    signed word values found in the corresponding source lanes. |'
  id: totrans-706
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pminsd` | Destination dword lanes set to the minimum value of the two
    signed dword values found in the corresponding source lanes. |'
  id: totrans-707
  prefs: []
  type: TYPE_TB
- en: '| `v``pminsq` | Destination qword lanes set to the minimum value of the two
    signed qword values found in the corresponding source lanes. (AVX-512- required
    for this instruction.) |'
  id: totrans-708
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pminub` | Destination byte lanes set to the minimum value of the two
    unsigned byte values found in the corresponding source lanes. |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pminuw` | Destination word lanes set to the minimum value of the two
    unsigned word values found in the corresponding source lanes. |'
  id: totrans-710
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pminud` | Destination dword lanes set to the minimum value of the two
    unsigned dword values found in the corresponding source lanes. |'
  id: totrans-711
  prefs: []
  type: TYPE_TB
- en: '| `v``pminuq` | Destination qword lanes set to the minimum value of the two
    unsigned qword values found in the corresponding source lanes. (AVX-512 required
    for this instruction.) |'
  id: totrans-712
  prefs: []
  type: TYPE_TB
- en: The generic syntax for these instructions is as follows:^([12](#c11-footnote-12))
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The SSE instructions compute the minimum or maximum of the corresponding lanes
    in the source and destination operands and store the minimum or maximum result
    into the corresponding lanes in the destination register. The AVX instructions
    compute the minimum or maximum of the values in the same lanes of the two source
    operands and store the minimum or maximum result into the corresponding lanes
    of the destination register.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.8 SIMD Integer Absolute Value
  id: totrans-716
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The SSE/AVX instruction set extensions provide three sets of instructions for
    computing the absolute values of signed byte, word, and double-word integers:
    `(v)pabsb`, `(v)pabsw`, and `(v)pabsd`.^([13](#c11-footnote-13)) The syntax for
    these instructions is the following:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: When operating on a system that supports AVX registers, the SSE `pabsb`, `pabsw`,
    and `pabsd` instructions leave the upper bits of the YMM registers unmodified.
    The 128-bit versions of the AVX instructions (`vpabsb`, `vpabsw`, and `vpabsd`)
    zero-extend the result through the upper bits.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.9 SIMD Integer Sign Adjustment Instructions
  id: totrans-720
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `(v)psignb`, `(v)psignw`, and `(v)psignd` instructions apply the sign found
    in a source lane to the corresponding destination lane. The algorithm works as
    follows:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The syntax for these instructions is the following:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As usual, the 128-bit SSE instructions leave the upper bits of the YMM register
    unchanged (if applicable), and the 128-bit AVX instructions zero-extend the result
    into the upper bits of the YMM register.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.10 SIMD Integer Comparison Instructions
  id: totrans-726
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `(v)pcmpeqb`, `(v)pcmpeqw`, `(v)pcmpeqd`, `(v)pcmpeqq`, `(v)pcmpgtb`, `(v)pcmpgtw`,
    `(v)pcmpgtd`, and `(v)pcmpgtq` instructions provide packed signed integer comparisons.
    These instructions compare corresponding bytes, word, dwords, or qwords (depending
    on the instruction suffix) in the various lanes of their operands.^([14](#c11-footnote-14))
    They store the result of the comparison instruction in the corresponding destination
    lanes.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.10.1 SSE Compare-for-Equality Instructions
  id: totrans-728
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The syntax for the SSE *compare-for-equality* instructions (`pcmpeq*`) is shown
    here:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: These instructions compute
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: where `lane` varies from 0 to 15 for `pcmpeqb`, 0 to 7 for `pcmpeqw`, 0 to 3
    for `pcmpeqd`, and 0 to 1 for `pcmpeqq`. The `==` operator produces a value of
    all 1 bits if the two values in the same lane are equal; it produces all 0 bits
    if the values are not equal.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.10.2 SSE Compare-for-Greater-Than Instructions
  id: totrans-734
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following is the syntax for the SSE *compare-for-greater-than* instructions
    (`pcmpgt*`):'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: These instructions compute
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: where `lane` is the same as for the compare-for-equality instructions, and the
    `>` operator produces a value of all 1 bits if the signed integer in the XMM[dest]
    lane is greater than the signed value in the corresponding XMM[src]/MEM[128] lane.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: On AVX-capable CPUs, the SSE packed integer comparisons preserve the value in
    the upper bits of the underlying YMM register.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.10.3 AVX Comparison Instructions
  id: totrans-741
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The 128-bit variants of these instructions have the following syntax:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'These instructions compute as follows:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: These AVX instructions write 0s to the upper bits of the underlying YMM register.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: 'The 256-bit variants of these instructions have the following syntax:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'These instructions compute as follows:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Of course, the principal difference between the 256- and the 128-bit instructions
    is that the 256-bit variants support twice as many byte (32), word (16), dword
    (8), and qword (4) signed-integer lanes.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.10.4 Compare-for-Less-Than Instructions
  id: totrans-752
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are no packed *compare-for-less-than* instructions. You can synthesize
    a less-than comparison by reversing the operands and using a greater-than comparison.
    That is, if *x* < *y*, then it is also true that *y* > *x*. If both packed operands
    are sitting in XMM or YMM registers, swapping the registers is relatively easy
    (especially when using the three-operand AVX instructions). If the second operand
    is a memory operand, you must first load that operand into a register so you can
    reverse the operands (a memory operand must always be the second operand).
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.10.5 Using Packed Comparison Results
  id: totrans-754
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The question remains of what to do with the result you obtain from a packed
    comparison. SSE/AVX packed signed integer comparisons do not affect condition
    code flags (because they compare multiple values and only one of those comparisons
    could be moved into the flags). Instead, the packed comparisons simply produce
    Boolean results. You can use these results with the packed AND instructions (`pand`,
    `vpand`, `pandn`, and `vpandn`), the packed OR instructions (`por` and `vpor`),
    or the packed XOR instructions (`pxor` and `vpxor`) to mask or otherwise modify
    other packed data values. Of course, you could also extract the individual lane
    values and test them (via a conditional jump). The following section describes
    a straightforward way to achieve this.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.10.6 The (v)pmovmskb Instructions
  id: totrans-756
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `(v)pmovmskb` instruction extracts the HO bit from all the bytes in an XMM
    or YMM register and stores the 16 or 32 bits (respectively) into a general-purpose
    register. These instructions set all HO bits of the general-purpose register to
    0 (beyond those needed to hold the mask bits). The syntax is
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: where `reg` is any 32-bit or 64-bit general-purpose integer register. The semantics
    for the `pmovmskb` and `vpmovmskb` instructions with an XMM source register are
    the same, but the encoding of `pmovmskb` is more efficient.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: The `(v)pmovmskb` instruction copies the sign bits from each of the byte lanes
    into the corresponding bit position of the general-purpose register. It copies
    bit 7 from the XMM register (the sign bit for lane 0) into bit 0 of the destination
    register; it copies bit 15 from the XMM register (the sign bit for lane 1) into
    bit 1 of the destination register; it copies bit 23 from the XMM register (the
    sign bit for lane 2) into bit 2 of the destination register; and so on.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: The 128-bit instructions fill only bits 0 through 15 of the destination register
    (zeroing out all other bits). The 256-bit form of the `vpmovmskb` instruction
    fills bits 0 through 31 of the destination register (zeroing out HO bits if you
    specify a 64-bit register).
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `pmovmskb` instruction to extract a single bit from each byte
    lane in an XMM or a YMM register after a `(v)pcmpeqb` or `(v)pcmpgtb` instruction.
    Consider the following code sequence:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: After the execution of these two instructions, EAX bit 0 will be 1 or 0 if byte
    0 of XMM0 was equal, or not equal, to byte 0 of XMM1, respectively. Likewise,
    EAX bit 1 will contain the result of comparing byte 1 of XMM0 to XMM1, and so
    on for each of the following bytes (up to bit 15, which compares 16-byte values
    in XMM0 and XMM1).
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, there are no `pmovmskw`, `pmovmskd`, and `pmovmsq` instructions.
    You can achieve the same result as `pmovmskw` by using the following code sequence:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Because `pcmpeqw` produces a sequence of words (which contain either 0000h
    or 0FFFFh) and `pmovmskb` expects byte values, `pmovmskb` produces twice as many
    results as we expect, and every odd-numbered bit that `pmovmskb` produces is a
    duplicate of the preceding even-numbered bit (because the inputs are either 0000h
    or 0FFFFh). This code grabs every odd-numbered bit (starting with bit 15 and working
    down) and skips over the even-numbered bits. While this code is easy enough to
    follow, it is rather long and slow. If you’re willing to live with an 8-bit result
    for which the lane numbers don’t match the bit numbers, you can use more efficient
    code:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This interleaves the lanes in the bit positions as shown in [Figure 11-44](#figure11-44).
    Usually, it’s easy enough to work around this rearrangement in the software. Of
    course, you can also use a 256-entry lookup table (see Chapter 10) to rearrange
    the bits however you desire. Of course, if you’re just going to test the individual
    bits rather than use them as some sort of mask, you can directly test the bits
    that `pmovmskb` leaves in EAX; you don’t have to coalesce them into a single byte.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: '![f11044](image_fi/501089c11/f11044.png)'
  id: totrans-770
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-44: Merging bits from `pcmpeqw`'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: When using the double-word or quad-word packed comparisons, you could also use
    a scheme such as the one provided here for `pcmpeqw`. However, the floating-point
    mask move instructions (see “The (v)movmskps, (v)movmskpd Instructions” on page
    676) do the job more efficiently by breaking the rule about using SIMD instructions
    that are appropriate for the data type.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.11 Integer Conversions
  id: totrans-773
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SSE and AVX instruction set extensions provide various instructions that
    convert integer values from one form to another. There are zero- and sign-extension
    instructions that convert from a smaller value to a larger one. Other instructions
    convert larger values to smaller ones. This section covers these instructions.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.11.1 Packed Zero-Extension Instructions
  id: totrans-775
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *move with zero-extension* instructions perform the conversions appearing
    in [Table 11-21](#table11-21).
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-21: SSE4.1 and AVX Packed Zero-Extension Instructions'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: '| **Syntax** | **Description** |'
  id: totrans-778
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-779
  prefs: []
  type: TYPE_TB
- en: '| `pmovzxbw` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | Zero-extends a set of
    eight byte values in the LO 8 bytes of XMM[src]/mem[64] to word values in XMM[dest].
    |'
  id: totrans-780
  prefs: []
  type: TYPE_TB
- en: '| `pmovzxbd` `xmm`[dest]`,` `xmm`[src]`/``mem`[32] | Zero-extends a set of
    four byte values in the LO 4 bytes of XMM[src]/mem[32] to dword values in XMM[dest].
    |'
  id: totrans-781
  prefs: []
  type: TYPE_TB
- en: '| `pmovzxbq` `xmm`[dest]`,` `xmm`[src]`/``mem`[16] | Zero-extends a set of
    two byte values in the LO 2 bytes of XMM[src]/mem[16] to qword values in XMM[dest].
    |'
  id: totrans-782
  prefs: []
  type: TYPE_TB
- en: '| `pmovzxwd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | Zero-extends a set of
    four word values in the LO 8 bytes of XMM[src]/mem[64] to dword values in XMM[dest].
    |'
  id: totrans-783
  prefs: []
  type: TYPE_TB
- en: '| `pmovzxwq` `xmm`[dest]`,` `xmm`[src]`/``mem`[32] | Zero-extends a set of
    two word values in the LO 4 bytes of XMM[src]/mem[32] to qword values in XMM[dest].
    |'
  id: totrans-784
  prefs: []
  type: TYPE_TB
- en: '| `pmovzxdq` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | Zero-extends a set of
    two dword values in the LO 8 bytes of XMM[src]/mem[64] to qword values in XMM[dest].
    |'
  id: totrans-785
  prefs: []
  type: TYPE_TB
- en: A set of comparable AVX instructions also exists (same syntax, but with a `v`
    prefix on the instruction mnemonics). The difference, as usual, is that the SSE
    instructions leave the upper bits of the YMM register unchanged, whereas the AVX
    instructions store 0s into the upper bits of the YMM registers.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: The AVX2 instruction set extensions double the number of lanes by allowing the
    use of the YMM registers. They take similar operands to the SSE/AVX instructions
    (substituting YMM for the destination register and doubling the size of the memory
    locations) and process twice the number of lanes to produce sixteen words, eight
    dwords, or four qwords in a YMM destination register. See [Table 11-22](#table11-22)
    for details.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-22: AVX2 Packed Zero-Extension Instructions'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: '| **Syntax** | **Description** |'
  id: totrans-789
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-790
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovzxbw` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | Zero-extends a set
    of sixteen byte values in the LO 16 bytes of XMM[src]/mem[128] to word values
    in YMM[dest]. |'
  id: totrans-791
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovzxbd` `ymm`[dest]`,` `xmm`[src]`/``mem`[64] | Zero-extends a set
    of eight byte values in the LO 8 bytes of XMM[src]/mem[64] to dword values in
    YMM[dest]. |'
  id: totrans-792
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovzxbq` `ymm`[dest]`,` `xmm`[src]`/``mem`[32] | Zero-extends a set
    of four byte values in the LO 4 bytes of XMM[src]/mem[32] to qword values in YMM[dest].
    |'
  id: totrans-793
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovzxwd` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | Zero-extends a set
    of eight word values in the LO 16 bytes of XMM[src]/mem[128] to dword values in
    YMM[dest]. |'
  id: totrans-794
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovzxwq` `ymm`[dest]`,` `xmm`[src]`/``mem`[64] | Zero-extends a set
    of four word values in the LO 8 bytes of XMM[src]/mem[64] to qword values in YMM[dest].
    |'
  id: totrans-795
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovzxdq` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | Zero-extends a set
    of four dword values in the LO 16 bytes of XMM[src]/mem[128] to qword values in
    YMM[dest]. |'
  id: totrans-796
  prefs: []
  type: TYPE_TB
- en: 11.10.11.2 Packed Sign-Extension Instructions
  id: totrans-797
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The SSE/AVX/AVX2 instruction set extensions provide a comparable set of instructions
    that sign-extend byte, word, and dword values. [Table 11-23](#table11-23) lists
    the SSE packed sign-extension instructions.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-23: SSE Packed Sign-Extension Instructions'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: '| **Syntax** | **Description** |'
  id: totrans-800
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-801
  prefs: []
  type: TYPE_TB
- en: '| `pmovsxbw` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | Sign-extends a set of
    eight byte values in the LO 8 bytes of XMM[src]/mem[64] to word values in XMM[dest].
    |'
  id: totrans-802
  prefs: []
  type: TYPE_TB
- en: '| `pmovsxbd` `xmm`[dest]`,` `xmm`[src]`/``mem`[32] | Sign-extends a set of
    four byte values in the LO 4 bytes of XMM[src]/mem[32] to dword values in XMM[dest].
    |'
  id: totrans-803
  prefs: []
  type: TYPE_TB
- en: '| `pmovsxbq` `xmm`[dest]`,` `xmm`[src]`/``mem`[16] | Sign-extends a set of
    two byte values in the LO 2 bytes of XMM[src]/mem[16] to qword values in XMM[dest].
    |'
  id: totrans-804
  prefs: []
  type: TYPE_TB
- en: '| `pmovsxwd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | Sign-extends a set of
    four word values in the LO 8 bytes of XMM[src]/mem[64] to dword values in XMM[dest].
    |'
  id: totrans-805
  prefs: []
  type: TYPE_TB
- en: '| `pmovsxwq` `xmm`[dest]`,` `xmm`[src]`/``mem`[32] | Sign-extends a set of
    two word values in the LO 4 bytes of XMM[src]/mem[32] to qword values in XMM[dest].
    |'
  id: totrans-806
  prefs: []
  type: TYPE_TB
- en: '| `pmovsxdq` `xmm`[dest]`,` `xmm`[src]`/mem`[64] | Sign-extends a set of two
    dword values in the LO 8 bytes of XMM[src]/mem[64] to qword values in XMM[dest].
    |'
  id: totrans-807
  prefs: []
  type: TYPE_TB
- en: A set of corresponding AVX instructions also exists (whose mnemonics have the
    `v` prefix). As usual, the difference between the SSE and AVX instructions is
    that the SSE instructions leave the upper bits of the YMM register unchanged (if
    applicable), and the AVX instructions store 0s into those upper bits.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: AVX2-capable processors also allow a YMM[dest] destination register, which doubles
    the number of (output) values the instruction can handle; see [Table 11-24](#table11-24).
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-24: AVX Packed Sign-Extension Instructions'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: '| **Syntax** | **Description** |'
  id: totrans-811
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-812
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovsxbw` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | Sign-extends a set
    of sixteen byte values in the LO 16 bytes of XMM[src]/mem[128] to word values
    in YMM[dest]. |'
  id: totrans-813
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovsxbd` `ymm`[dest]`,` `xmm`[src]`/``mem`[64] | Sign-extends a set
    of eight byte values in the LO 8 bytes of XMM[src]/mem[64] to dword values in
    YMM[dest]. |'
  id: totrans-814
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovsxbq` `ymm`[dest]`,` `xmms`[rc]`/``mem`[32] | Sign-extends a set
    of four byte values in the LO 4 bytes of XMM[src]/mem[32] to qword values in YMM[dest].
    |'
  id: totrans-815
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovsxwd` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | Sign-extends a set
    of eight word values in the LO 16 bytes of XMM[src]/mem[128] to dword values in
    YMM[dest]. |'
  id: totrans-816
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovsxwq` `ymm`[dest]`,` `xmm`[src]`/``mem`[64] | Sign-extends a set
    of four word values in the LO 8 bytes of XMM[src]/mem[64] to qword values in YMM[dest].
    |'
  id: totrans-817
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovsxdq` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | Sign-extends a set
    of four dword values in the LO 16 bytes of XMM[src]/mem[128] to qword values in
    YMM[dest]. |'
  id: totrans-818
  prefs: []
  type: TYPE_TB
- en: 11.10.11.3 Packed Sign Extension with Saturation
  id: totrans-819
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to converting smaller signed or unsigned values to a larger format,
    the SSE/AVX/AVX2-capable CPUs have the ability to convert large values to smaller
    values via saturation; see [Table 11-25](#table11-25).
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-25: SSE Packed Sign-Extension with Saturation Instructions'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: '| **Syntax** | **Description** |'
  id: totrans-822
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-823
  prefs: []
  type: TYPE_TB
- en: '| `packsswb` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Packs sixteen signed
    word values (from two 128-bit sources) into sixteen byte lanes in a 128-bit destination
    register using signed saturation. |'
  id: totrans-824
  prefs: []
  type: TYPE_TB
- en: '| `packuswb` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Packs sixteen unsigned
    word values (from two 128-bit sources) into sixteen byte lanes in a 128-bit destination
    register using unsigned saturation. |'
  id: totrans-825
  prefs: []
  type: TYPE_TB
- en: '| `packssdw` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Packs eight signed dword
    values (from two 128-bit sources) into eight word values in a 128-bit destination
    register using signed saturation. |'
  id: totrans-826
  prefs: []
  type: TYPE_TB
- en: '| `packusdw` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Packs eight unsigned
    dword values (from two 128-bit sources) into eight word values in a 128-bit destination
    register using unsigned saturation. |'
  id: totrans-827
  prefs: []
  type: TYPE_TB
- en: The saturate operation checks its operand to see if the value exceeds the range
    of the result (–128 to +127 for signed bytes, 0 to 255 for unsigned bytes, –32,768
    to +32,767 for signed words, and 0 to 65,535 for unsigned words). When saturating
    to a byte, if the signed source value is less than –128, byte saturation sets
    the value to –128\. When saturating to a word, if the signed source value is less
    than –32,786, signed saturation sets the value to –32,768\. Similarly, if a signed
    byte or word value exceeds +127 or +32,767, then saturation replaces the value
    with +127 or +32,767, respectively. For unsigned operations, saturation limits
    the value to +255 (for bytes) or +65,535 (for words). Unsigned values are never
    less than 0, so unsigned saturation clips values to only +255 or +65,535.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: 'AVX-capable CPUs provide 128-bit variants of these instructions that support
    three operands: two source operands and an independent destination operand. These
    instructions (mnemonics the same as the SSE instructions, with a `v` prefix) have
    the following syntax:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: These instructions are roughly equivalent to the SSE variants, except that these
    instructions use XMM[src1] as the first source operand rather than XMM[dest] (which
    the SSE instructions use). Also, the SSE instructions do not modify the upper
    bits of the YMM register (if present on the CPU), whereas the AVX instructions
    store 0s into the upper YMM register bits.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: AVX2-capable CPUs also allow the use of the YMM registers (and 256-bit memory
    locations) to double the number of values the instruction can saturate (see [Table
    11-26](#table11-26)). Of course, don’t forget to check for AVX2 (and AVX) compatibility
    before using these instructions.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-26: AVX Packed Sign-Extension with Saturation Instructions'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: '| **Syntax** | **Description** |'
  id: totrans-834
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-835
  prefs: []
  type: TYPE_TB
- en: '| `v``packsswb` `ymm`[dest]`,` `ymm`[src1]`,` `ymm`[src2]`/``mem`[256] | Packs
    32 signed word values (from two 256-bit sources) into 32 byte lanes in a 256-bit
    destination register using signed saturation. |'
  id: totrans-836
  prefs: []
  type: TYPE_TB
- en: '| `v``packuswb` `ymm`[dest]`,` `ymm`[src1]`,` `ymm`[src2]`/``mem`[256] | Packs
    32 unsigned word values (from two 256-bit sources) into 32 byte lanes in a 256-bit
    destination register using unsigned saturation. |'
  id: totrans-837
  prefs: []
  type: TYPE_TB
- en: '| `v``packssdw` `ymm`[dest]`,` `ymm`[src1]`,` `ymm`[src2]`/``mem`[256] | Packs
    16 signed dword values (from two 256-bit sources) into 16 word values in a 256-bit
    destination register using signed saturation. |'
  id: totrans-838
  prefs: []
  type: TYPE_TB
- en: '| `v``packusdw` `ymm`[dest]`,` `ymm`[src1]`,` `ymm`[src2]`/``mem`[256] | Packs
    16 unsigned dword values (from two 256-bit sources) into 16 word values in a 256-bit
    destination register using unsigned saturation. |'
  id: totrans-839
  prefs: []
  type: TYPE_TB
- en: 11.11 SIMD Floating-Point Arithmetic Operations
  id: totrans-840
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SSE and AVX instruction set extensions provide packed arithmetic equivalents
    for all the scalar floating-point instructions in “SSE Floating-Point Arithmetic”
    in Chapter 6. This section does not repeat the discussion of the scalar floating-point
    operations; see Chapter 6 for more details.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: 'The 128-bit SSE packed floating-point instructions have the following generic
    syntax (where `instr` is one of the floating-point instructions in [Table 11-27](#table11-27)):'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The *packed single* (`*ps`) instructions perform four single-precision floating-point
    operations simultaneously. The *packed double* (`*pd`) instructions perform two
    double-precision floating-point operations simultaneously. As is typical for SSE
    instructions, these packed arithmetic instructions compute
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: where `lane` varies from 0 to 3 for packed single-precision instructions and
    from 0 to 1 for packed double-precision instructions. `op` represents the operation
    (such as addition or subtraction). When the SSE instructions are executed on a
    CPU that supports the AVX extensions, the SSE instructions leave the upper bits
    of the AVX register unmodified.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: The 128-bit AVX packed floating-point instructions have this syntax:^([15](#c11-footnote-15))
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: These instructions compute
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: where `op` corresponds to the operation associated with the specific instruction
    (for example, `vaddps` does a packed single-precision addition). These 128-bit
    AVX instructions clear the HO bits of the underlying YMM[dest] register.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: 'The 256-bit AVX packed floating-point instructions have this syntax:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: These instructions compute
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: where `op` corresponds to the operation associated with the specific instruction
    (for example, `vaddps` is a packed single-precision addition). Because these instructions
    operate on 256-bit operands, they compute twice as many lanes of data as the 128-bit
    instructions. Specifically, they simultaneously compute eight single-precision
    (the `v*ps` instructions) or four double-precision results (the `v*pd` instructions).
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 11-27](#table11-27) provides the list of SSE/AVX packed instructions.'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-27: Floating-Point Arithmetic Instructions'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Lanes** | **Description** |'
  id: totrans-859
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-860
  prefs: []
  type: TYPE_TB
- en: '| `addps` | 4 | Adds four single-precision floating-point values |'
  id: totrans-861
  prefs: []
  type: TYPE_TB
- en: '| `addpd` | 2 | Adds two double-precision floating-point values |'
  id: totrans-862
  prefs: []
  type: TYPE_TB
- en: '| `vaddps` | 4/8 | Adds four (128-bit/XMM operands) or eight (256-bit/YMM operands)
    single-precision values |'
  id: totrans-863
  prefs: []
  type: TYPE_TB
- en: '| `vaddpd` | 2/4 | Adds two (128-bit/XMM operands) or four (256-bit/YMM operands)
    double-precision values |'
  id: totrans-864
  prefs: []
  type: TYPE_TB
- en: '| `subps` | 4 | Subtracts four single-precision floating-point values |'
  id: totrans-865
  prefs: []
  type: TYPE_TB
- en: '| `subpd` | 2 | Subtracts two double-precision floating-point values |'
  id: totrans-866
  prefs: []
  type: TYPE_TB
- en: '| `vsubps` | 4/8 | Subtracts four (128-bit/XMM operands) or eight (256-bit/YMM
    operands) single-precision values |'
  id: totrans-867
  prefs: []
  type: TYPE_TB
- en: '| `vsubpd` | 2/4 | Subtracts two (128-bit/XMM operands) or four (256-bit/YMM
    operands) double-precision values |'
  id: totrans-868
  prefs: []
  type: TYPE_TB
- en: '| `mulps` | 4 | Multiplies four single-precision floating-point values |'
  id: totrans-869
  prefs: []
  type: TYPE_TB
- en: '| `mulpd` | 2 | Multiplies two double-precision floating-point values |'
  id: totrans-870
  prefs: []
  type: TYPE_TB
- en: '| `vmulps` | 4/8 | Multiplies four (128-bit/XMM operands) or eight (256-bit/YMM
    operands) single-precision values |'
  id: totrans-871
  prefs: []
  type: TYPE_TB
- en: '| `vmulpd` | 2/4 | Multiplies two (128-bit/XMM operands) or four (256-bit/YMM
    operands) double-precision values |'
  id: totrans-872
  prefs: []
  type: TYPE_TB
- en: '| `divps` | 4 | Divides four single-precision floating-point values |'
  id: totrans-873
  prefs: []
  type: TYPE_TB
- en: '| `divpd` | 2 | Divides two double-precision floating-point values |'
  id: totrans-874
  prefs: []
  type: TYPE_TB
- en: '| `vdivps` | 4/8 | Divides four (128-bit/XMM operands) or eight (256-bit/YMM
    operands) single-precision values |'
  id: totrans-875
  prefs: []
  type: TYPE_TB
- en: '| `vdivpd` | 2/4 | Divides two (128-bit/XMM operands) or four (256-bit/YMM
    operands) double-precision values |'
  id: totrans-876
  prefs: []
  type: TYPE_TB
- en: '| `maxps` | 4 | Computes the maximum of four pairs of single-precision floating-point
    values |'
  id: totrans-877
  prefs: []
  type: TYPE_TB
- en: '| `maxpd` | 2 | Computes the maximum of two pairs of double-precision floating-point
    values |'
  id: totrans-878
  prefs: []
  type: TYPE_TB
- en: '| `vmaxps` | 4/8 | Computes the maximum of four (128-bit/XMM operands) or eight
    (256-bit/YMM operands) pairs of single-precision values |'
  id: totrans-879
  prefs: []
  type: TYPE_TB
- en: '| `vmaxpd` | 2/4 | Computes the maximum of two (128-bit/XMM operands) or four
    (256-bit/YMM operands) pairs of double-precision values |'
  id: totrans-880
  prefs: []
  type: TYPE_TB
- en: '| `minps` | 4 | Computes the minimum of four pairs of single-precision floating-point
    values |'
  id: totrans-881
  prefs: []
  type: TYPE_TB
- en: '| `minpd` | 2 | Computes the minimum of two pairs of double-precision floating-point
    values |'
  id: totrans-882
  prefs: []
  type: TYPE_TB
- en: '| `vminps` | 4/8 | Computes the minimum of four (128-bit/XMM operands) or eight
    (256-bit/YMM operands) pairs of single-precision values |'
  id: totrans-883
  prefs: []
  type: TYPE_TB
- en: '| `vminpd` | 2/4 | Computes the minimum of two (128-bit/XMM operands) or four
    (256-bit/YMM operands) pairs of double-precision values |'
  id: totrans-884
  prefs: []
  type: TYPE_TB
- en: '| `sqrtps` | 4 | Computes the square root of four single-precision floating-point
    values |'
  id: totrans-885
  prefs: []
  type: TYPE_TB
- en: '| `sqrtpd` | 2 | Computes the square root of two double-precision floating-point
    values |'
  id: totrans-886
  prefs: []
  type: TYPE_TB
- en: '| `vsqrtps` | 4/8 | Computes the square root of four (128-bit/XMM operands)
    or eight (256-bit/YMM operands) single-precision values |'
  id: totrans-887
  prefs: []
  type: TYPE_TB
- en: '| `vsqrtpd` | 2/4 | Computes the square root of two (128-bit/XMM operands)
    or four (256-bit/YMM operands) double-precision values |'
  id: totrans-888
  prefs: []
  type: TYPE_TB
- en: '| `rsqrtps` | 4 | Computes the approximate reciprocal square root of four single-precision
    floating-point values^([*](#c11-footnote-16)) |'
  id: totrans-889
  prefs: []
  type: TYPE_TB
- en: '| `vrsqrtps` | 4/8 | Computes the approximate reciprocal square root of four
    (128-bit/XMM operands) or eight (256-bit/YMM operands) single-precision values
    |'
  id: totrans-890
  prefs: []
  type: TYPE_TB
- en: '| ^([*](#c11-footnoteref-16)) The relative error is ≤ 1.5 × 2^(-12). |'
  id: totrans-891
  prefs: []
  type: TYPE_TB
- en: 'The SSE/AVX instruction set extensions also include floating-point horizontal
    addition and subtraction instructions. The syntax for these instructions is as
    follows:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: As for the integer horizontal addition and subtraction instructions, these instructions
    add or subtract the values in adjacent lanes in the same register and store the
    result in the destination register (lane 2), as shown in [Figure 11-43](#figure11-43).
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: 11.12 SIMD Floating-Point Comparison Instructions
  id: totrans-895
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like the integer packed comparisons, the SSE/AVX floating-point comparisons
    compare two sets of floating-point values (either single- or double-precision,
    depending on the instruction’s syntax) and store a resulting Boolean value (all
    1 bits for true, all 0 bits for false) into the destination lane. However, the
    floating-point comparisons are far more comprehensive than those of their integer
    counterparts. Part of the reason is that floating-point arithmetic is more complex;
    however, an ever-increasing silicon budget for the CPU designers is also responsible
    for this.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: 11.12.1 SSE and AVX Comparisons
  id: totrans-897
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two sets of basic floating-point comparisons: `(v)cmpps`, which compares
    a set of packed single-precision values, and `(v)cmppd`, which compares a set
    of packed double-precision values. Instead of encoding the comparison type into
    the mnemonic, these instructions use an imm[8] operand whose value specifies the
    type of comparison. The generic syntax for these instructions is as follows:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The imm[8] operand specifies the type of the comparison. There are 32 possible
    comparisons, as listed in [Table 11-28](#table11-28).
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-28: imm[8] Values for `cmpps` and `cmppd` Instructions^([†](#c11-footnote-17))'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: '| **imm[8]** | **Description** | **Result** | **Signal** |'
  id: totrans-902
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-903
  prefs: []
  type: TYPE_TB
- en: '|  |  | **A < B** | **A = B** | **A > B** | **Unord** |  |'
  id: totrans-904
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-905
  prefs: []
  type: TYPE_TB
- en: '| 00h | EQ, ordered, quiet | 0 | 1 | 0 | 0 | No |'
  id: totrans-906
  prefs: []
  type: TYPE_TB
- en: '| 01h | LT, ordered, signaling | 1 | 0 | 0 | 0 | Yes |'
  id: totrans-907
  prefs: []
  type: TYPE_TB
- en: '| 02h | LE, ordered, signaling | 1 | 1 | 0 | 0 | Yes |'
  id: totrans-908
  prefs: []
  type: TYPE_TB
- en: '| 03h | Unordered, quiet | 0 | 0 | 0 | 1 | No |'
  id: totrans-909
  prefs: []
  type: TYPE_TB
- en: '| 04h | NE, unordered, quiet | 1 | 0 | 1 | 1 | No |'
  id: totrans-910
  prefs: []
  type: TYPE_TB
- en: '| 05h | NLT, unordered, signaling | 0 | 1 | 1 | 1 | Yes |'
  id: totrans-911
  prefs: []
  type: TYPE_TB
- en: '| 06h | NLE, unordered, signaling | 0 | 0 | 1 | 1 | Yes |'
  id: totrans-912
  prefs: []
  type: TYPE_TB
- en: '| 07h | Ordered, quiet | 1 | 1 | 1 | 0 | No |'
  id: totrans-913
  prefs: []
  type: TYPE_TB
- en: '| 08h | EQ, unordered, quiet | 0 | 1 | 0 | 1 | No |'
  id: totrans-914
  prefs: []
  type: TYPE_TB
- en: '| 09h | NGE, unordered, signaling | 1 | 0 | 0 | 1 | Yes |'
  id: totrans-915
  prefs: []
  type: TYPE_TB
- en: '| 0Ah | NGT, unordered, signaling | 1 | 1 | 0 | 1 | Yes |'
  id: totrans-916
  prefs: []
  type: TYPE_TB
- en: '| 0Bh | False, ordered, quiet | 0 | 0 | 0 | 0 | No |'
  id: totrans-917
  prefs: []
  type: TYPE_TB
- en: '| 0Ch | NE, ordered, quiet | 1 | 0 | 1 | 0 | No |'
  id: totrans-918
  prefs: []
  type: TYPE_TB
- en: '| 0Dh | GE, ordered, signaling | 0 | 1 | 1 | 0 | Yes |'
  id: totrans-919
  prefs: []
  type: TYPE_TB
- en: '| 0Eh | GT, ordered, signaling | 0 | 0 | 1 | 0 | Yes |'
  id: totrans-920
  prefs: []
  type: TYPE_TB
- en: '| 0Fh | True, unordered, quiet | 1 | 1 | 1 | 1 | No |'
  id: totrans-921
  prefs: []
  type: TYPE_TB
- en: '| 10h | EQ, ordered, signaling | 0 | 1 | 0 | 0 | Yes |'
  id: totrans-922
  prefs: []
  type: TYPE_TB
- en: '| 11h | LT, ordered, quiet | 1 | 0 | 0 | 0 | No |'
  id: totrans-923
  prefs: []
  type: TYPE_TB
- en: '| 12h | LE, ordered, quiet | 1 | 1 | 0 | 0 | No |'
  id: totrans-924
  prefs: []
  type: TYPE_TB
- en: '| 13h | Unordered, signaling | 0 | 0 | 0 | 1 | Yes |'
  id: totrans-925
  prefs: []
  type: TYPE_TB
- en: '| 14h | NE, unordered, signaling | 1 | 0 | 1 | 1 | Yes |'
  id: totrans-926
  prefs: []
  type: TYPE_TB
- en: '| 15h | NLT, unordered, quiet | 0 | 1 | 1 | 1 | No |'
  id: totrans-927
  prefs: []
  type: TYPE_TB
- en: '| 16h | NLE, unordered, quiet | 0 | 0 | 1 | 1 | No |'
  id: totrans-928
  prefs: []
  type: TYPE_TB
- en: '| 17h | Ordered, signaling | 1 | 1 | 1 | 0 | Yes |'
  id: totrans-929
  prefs: []
  type: TYPE_TB
- en: '| 18h | EQ, unordered, signaling | 0 | 1 | 0 | 1 | Yes |'
  id: totrans-930
  prefs: []
  type: TYPE_TB
- en: '| 19h | NGE, unordered, quiet | 1 | 0 | 0 | 1 | No |'
  id: totrans-931
  prefs: []
  type: TYPE_TB
- en: '| 1Ah | NGT, unordered, quiet | 1 | 1 | 0 | 1 | No |'
  id: totrans-932
  prefs: []
  type: TYPE_TB
- en: '| 1Bh | False, ordered, signaling | 0 | 0 | 0 | 0 | Yes |'
  id: totrans-933
  prefs: []
  type: TYPE_TB
- en: '| 1Ch | NE, ordered, signaling | 1 | 0 | 1 | 0 | Yes |'
  id: totrans-934
  prefs: []
  type: TYPE_TB
- en: '| 1Dh | GE, ordered, quiet | 0 | 1 | 1 | 0 | No |'
  id: totrans-935
  prefs: []
  type: TYPE_TB
- en: '| 1Eh | GT, ordered, quiet | 0 | 0 | 1 | 0 | No |'
  id: totrans-936
  prefs: []
  type: TYPE_TB
- en: '| 1Fh | True, unordered, signaling | 1 | 1 | 1 | 1 | Yes |'
  id: totrans-937
  prefs: []
  type: TYPE_TB
- en: '| ^([†](#c11-footnoteref-17)) The darker shaded entries are available only
    on CPUs that support AVX extensions. |'
  id: totrans-938
  prefs: []
  type: TYPE_TB
- en: The “true” and “false” comparisons always store true or false into the destination
    lanes. For the most part, these comparisons aren’t particularly useful. The `pxor`,
    `xorps`, `xorpd`, `vxorps`, and `vxorpd` instructions are probably better for
    setting an XMM or a YMM register to 0\. Prior to AVX2, using a true comparison
    was the shortest instruction that would set all bits in an XMM or a YMM register
    to 1, though `pcmpeqb` is commonly used as well (be aware of microarchitectural
    inefficiencies with this latter instruction).
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: Note that non-AVX CPUs do not implement the GT, GE, NGT, and NGE instructions.
    On these CPUs, use the inverse operation (for example, NLT for GE) or swap the
    operands and use the opposite condition (as was done for the packed integer comparisons).
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: 11.12.2 Unordered vs. Ordered Comparisons
  id: totrans-941
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The unordered relationship is true when at least one of the two source operands
    being compared is a NaN; the ordered relationship is true when neither source
    operand is a NaN. Having ordered and unordered comparisons allows you to pass
    error conditions through comparisons as false or true, depending on how you interpret
    the final Boolean results appearing in the lanes. Unordered results, as their
    name implies, are incomparable. When you compare two values, one of which is not
    a number, you must always treat the result as a failed comparison.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: To handle this situation, you use an ordered or unordered comparison to force
    the result to be false or true, the opposite of what you ultimately expect when
    using the comparison result. For example, suppose you are comparing a sequence
    of values and want the resulting masks to be true if all the comparisons are valid
    (for example, you’re testing to see if all the src[1] values are greater than
    the corresponding src[2] values). You would use an ordered comparison in this
    situation that would force a particular lane to false if one of the values being
    compared is NaN. On the other hand, if you’re checking to see if all the conditions
    are false after the comparison, you’d use an unordered comparison to force the
    result to true if any of the values are NaN.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: 11.12.3 Signaling and Quiet Comparisons
  id: totrans-944
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The signaling comparisons generate an invalid arithmetic operation exception
    (IA) when an operation produces a quiet NaN. The quiet comparisons do not throw
    an exception and reflect only the status in the MXCSR (see “SSE MXCSR Register”
    in Chapter 6). Note that you can also mask signaling exceptions in the MXCSR register;
    you must explicitly set the IM (*invalid operation mask*, bit 7) in the MXCSR
    to 0 if you want to allow exceptions.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: 11.12.4 Instruction Synonyms
  id: totrans-946
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MASM supports the use of certain synonyms so you don’t have to memorize the
    32 encodings. [Table 11-29](#table11-29) lists these synonyms. In this table,
    *x1* denotes the destination operand (XMM[*n*] or YMM[*n*]), and *x2* denotes
    the source operand (XMM[*n*]/mem[128] or YMM[*n*]/mem[256], as appropriate).
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-29: Synonyms for Common Packed Floating-Point Comparisons'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: '| **Synonym** | **Instruction** | **Synonym** | **Instruction** |'
  id: totrans-949
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-950
  prefs: []
  type: TYPE_TB
- en: '| `cmpeqps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 0` | `cmpeqpd` `x1``,` `x2`
    | `cmppd` `x1``,` `x2``, 0` |'
  id: totrans-951
  prefs: []
  type: TYPE_TB
- en: '| `cmpltps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 1` | `cmpltpd` `x1``,` `x2`
    | `cmppd` `x1``,` `x2``, 1` |'
  id: totrans-952
  prefs: []
  type: TYPE_TB
- en: '| `cmpleps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 2` | `cmplepd` `x1``,` `x2`
    | `cmppd` `x1``,` `x2``, 2` |'
  id: totrans-953
  prefs: []
  type: TYPE_TB
- en: '| `cmpunordps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 3` | `cmpunordpd` `x1``,`
    `x2` | `cmppd x1, x2, 3` |'
  id: totrans-954
  prefs: []
  type: TYPE_TB
- en: '| `cmpneqps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 4` | `cmpneqpd` `x1``,`
    `x2` | `cmppd` `x1``,` `x2``, 4` |'
  id: totrans-955
  prefs: []
  type: TYPE_TB
- en: '| `cmpnltps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 5` | `cmpnltpd` `x1``,`
    `x2` | `cmppd` `x1``,` `x2``, 5` |'
  id: totrans-956
  prefs: []
  type: TYPE_TB
- en: '| `cmpnleps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 6` | `cmpnlepd` `x1``,`
    `x2` | `cmppd` `x1``,` `x2``, 6` |'
  id: totrans-957
  prefs: []
  type: TYPE_TB
- en: '| `cmpordps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 7` | `cmpordpd` `x1``,`
    `x2` | `cmppd` `x1``,` `x2``, 7` |'
  id: totrans-958
  prefs: []
  type: TYPE_TB
- en: The synonyms allow you to write instructions such as
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: rather than
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Obviously, using the synonym makes the code much easier to read and understand.
    There aren’t synonyms for all the possible comparisons. To create readable synonyms
    for the instructions MASM doesn’t support, you can use a macro (or a more readable
    symbolic constant). For more information on macros, see Chapter 13.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: 11.12.5 AVX Extended Comparisons
  id: totrans-964
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The AVX versions of these instructions allow three register operands: a destination
    XMM or YMM register, a source XMM or YMM register, and a source XMM or YMM register
    or 128-bit or 256-bit memory location (followed by the imm[8] operand specifying
    the type of the comparison). The basic syntax is the following:'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The 128-bit `vcmpps` instruction compares the four single-precision floating-point
    values in each lane of the XMM[src1] register against the values in the corresponding
    XMM[src2]/mem[128] lanes and stores the true (all 1 bits) or false (all 0 bits)
    result into the corresponding lane of the XMM[dest] register. The 256-bit `vcmpps`
    instruction compares the eight single-precision floating-point values in each
    lane of the YMM[src1] register against the values in the corresponding YMM[src2]/mem[256]
    lanes and stores the true or false result into the corresponding lane of the YMM[dest]
    register.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: The `vcmppd` instructions compare the double-precision values in the two lanes
    (128-bit version) or four lanes (256-bit version) and store the result into the
    corresponding lane of the destination register.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: As for the SSE compare instructions, the AVX instructions provide synonyms that
    eliminate the need to memorize 32 imm[8] values. [Table 11-30](#table11-30) lists
    the 32 instruction synonyms.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-30: AVX Packed Compare Instructions'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: '| **imm[8]** | **Instruction** |'
  id: totrans-971
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-972
  prefs: []
  type: TYPE_TB
- en: '| 00h | `vcmpeqps` or `vcmpeqpd` |'
  id: totrans-973
  prefs: []
  type: TYPE_TB
- en: '| 01h | `vcmpltps` or `vcmpltpd` |'
  id: totrans-974
  prefs: []
  type: TYPE_TB
- en: '| 02h | `vcmpleps` or `vcmplepd` |'
  id: totrans-975
  prefs: []
  type: TYPE_TB
- en: '| 03h | `vcmpunordps` or `vcmpunordpd` |'
  id: totrans-976
  prefs: []
  type: TYPE_TB
- en: '| 04h | `vcmpneqps` or `vcmpneqpd` |'
  id: totrans-977
  prefs: []
  type: TYPE_TB
- en: '| 05h | `vcmpltps` or `vcmpltpd` |'
  id: totrans-978
  prefs: []
  type: TYPE_TB
- en: '| 06h | `vcmpleps` or `vcmplepd` |'
  id: totrans-979
  prefs: []
  type: TYPE_TB
- en: '| 07h | `vcmpordps` or `vcmpordpd` |'
  id: totrans-980
  prefs: []
  type: TYPE_TB
- en: '| 08h | `vcmpeq_uqps` or `vcmpeq_uqpd` |'
  id: totrans-981
  prefs: []
  type: TYPE_TB
- en: '| 09h | `vcmpngeps` or `vcmpngepd` |'
  id: totrans-982
  prefs: []
  type: TYPE_TB
- en: '| 0Ah | `vcmpngtps` or `vcmpngtpd` |'
  id: totrans-983
  prefs: []
  type: TYPE_TB
- en: '| 0Bh | `vcmpfalseps` or `vcmpfalsepd` |'
  id: totrans-984
  prefs: []
  type: TYPE_TB
- en: '| 0Ch | `vcmpneq_oqps` or `vcmpneq_oqpd` |'
  id: totrans-985
  prefs: []
  type: TYPE_TB
- en: '| 0Dh | `vcmpgeps` or `vcmpgepd` |'
  id: totrans-986
  prefs: []
  type: TYPE_TB
- en: '| 0Eh | `vcmpgtps` or `vcmpgtpd` |'
  id: totrans-987
  prefs: []
  type: TYPE_TB
- en: '| 0Fh | `vcmptrueps` or `vcmptruepd` |'
  id: totrans-988
  prefs: []
  type: TYPE_TB
- en: '| 10h | `vcmpeq_osps` or `vcmpeq_ospd` |'
  id: totrans-989
  prefs: []
  type: TYPE_TB
- en: '| 11h | `vcmplt_oqps` or `vcmplt_oqpd` |'
  id: totrans-990
  prefs: []
  type: TYPE_TB
- en: '| 12h | `vcmple_oqps` or `vcmple_oqpd` |'
  id: totrans-991
  prefs: []
  type: TYPE_TB
- en: '| 13h | `vcmpunord_sps` or `vcmpunord_spd` |'
  id: totrans-992
  prefs: []
  type: TYPE_TB
- en: '| 14h | `vcmpneq_usps` or `vcmpneq_uspd` |'
  id: totrans-993
  prefs: []
  type: TYPE_TB
- en: '| 15h | `vcmpnlt_uqps` or `vcmpnlt_uqpd` |'
  id: totrans-994
  prefs: []
  type: TYPE_TB
- en: '| 16h | `vcmpnle_uqps` or `vcmpnle_uqpd` |'
  id: totrans-995
  prefs: []
  type: TYPE_TB
- en: '| 17h | `vcmpord_sps` or `vcmpord_spd` |'
  id: totrans-996
  prefs: []
  type: TYPE_TB
- en: '| 18h | `vcmpeq_usps` or `vcmpeq_uspd` |'
  id: totrans-997
  prefs: []
  type: TYPE_TB
- en: '| 19h | `vcmpnge_uqps` or `vcmpnge_uqpd` |'
  id: totrans-998
  prefs: []
  type: TYPE_TB
- en: '| 1Ah | `vcmpngt_uqps` or `vcmpngt_uqpd` |'
  id: totrans-999
  prefs: []
  type: TYPE_TB
- en: '| 1Bh | `vcmpfalse_osps` or `vcmpfalse_ospd` |'
  id: totrans-1000
  prefs: []
  type: TYPE_TB
- en: '| 1Ch | `vcmpneq_osps` or `vcmpneq_ospd` |'
  id: totrans-1001
  prefs: []
  type: TYPE_TB
- en: '| 1Dh | vcmpge_oqps or `vcmpge_oqpd` |'
  id: totrans-1002
  prefs: []
  type: TYPE_TB
- en: '| 1Eh | `vcmpgt_oqps` or `vcmpgt_oqpd` |'
  id: totrans-1003
  prefs: []
  type: TYPE_TB
- en: '| 1Fh | `vcmptrue_usps` or `vcmptrue_uspd` |'
  id: totrans-1004
  prefs: []
  type: TYPE_TB
- en: 11.12.6 Using SIMD Comparison Instructions
  id: totrans-1005
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As for the integer comparisons (see “Using Packed Comparison Results” on page
    662), the floating-point comparison instructions produce a vector of Boolean results
    that you use to mask further operations on data lanes. You can use the packed
    logical instructions (`pand` and `vpand`, `pandn` and `vpandn`, `por` and `vpor`,
    and `pxor` and `vpxor`) to manipulate these results. You could extract the individual
    lane values and test them with a conditional jump, though this is definitely not
    the SIMD way of doing things; the following section describes one way to extract
    these masks.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: 11.12.7 The (v)movmskps, (v)movmskpd Instructions
  id: totrans-1007
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `movmskps` and `movmskpd` instructions extract the sign bits from their
    packed single- and double-precision floating-point source operands and store these
    bits into the LO 4 (or 8) bits of a general-purpose register. The syntax is
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: where `reg` is any 32-bit or 64-bit general-purpose integer register.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: The `movmskps` instruction extracts the sign bits from the four single-precision
    floating-point values in the XMM source register and copies these bits to the
    LO 4 bits of the destination register, as shown in [Figure 11-45](#figure11-45).
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
- en: The `movmskpd` instruction copies the sign bits from the two double-precision
    floating-point values in the source XMM register to bits 0 and 1 of the destination
    register, as [Figure 11-46](#figure11-46) shows.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: The `vmovmskps` instruction extracts the sign bits from the four and eight single-precision
    floating-point values in the XMM and YMM source register and copies these bits
    to the LO 4 and 8 bits of the destination register. [Figure 11-47](#figure11-47)
    shows this operation with a YMM source register.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: '![f11045](image_fi/501089c11/f11045.png)'
  id: totrans-1014
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-45: `movmskps` operation'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: '![f11046](image_fi/501089c11/f11046.png)'
  id: totrans-1016
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-46: `movmskpd` operation'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: '![f11047](image_fi/501089c11/f11047.png)'
  id: totrans-1018
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-47: `vmovmskps` operation'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: The `vmovmskpd` instruction copies the sign bits from the four double-precision
    floating-point values in the source YMM register to bits 0 to 3 of the destination
    register, as shown in [Figure 11-48](#figure11-48).
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: '![f11048](image_fi/501089c11/f11048.png)'
  id: totrans-1021
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-48: `vmovmskpd` operation'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: This instruction, with an XMM source register, will copy the sign bits from
    the two double-precision floating-point values into bits 0 and 1 of the destination
    register. In all cases, these instructions zero-extend the results into the upper
    bits of the general-purpose destination register. Note that these instructions
    do not allow memory operands.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: Although the stated data type for these instructions is packed single-precision
    and packed double-precision, you will also use these instructions on 32-bit integers
    (`movmskps` and `vmovmskps`) and 64-bit integers (`movmskpd` and `vmovmskpd`).
    Specifically, these instructions are perfect for extracting 1-bit Boolean values
    from the various lanes after one of the (dword or qword) packed integer comparisons
    as well as after the single- or double-precision floating-point comparisons (remember
    that although the packed floating-point comparisons compare floating-point values,
    their results are actually integer values).
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following instruction sequence:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Because `movmskpd` extracts 2 bits from XMM0 and stores them into RAX, this
    code can use RAX as an index into a jump table to select four different branch
    labels. The code at label `nene` executes if both comparisons produce not equal;
    label `neeq` is the target when the lane 0 values are equal but the lane 1 values
    are not equal. Label `eqne` is the target when the lane 0 values are not equal
    but the lane 1 values are equal. Finally, label `eqeq` is where this code branches
    when both sets of lanes contain equal values.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: 11.13 Floating-Point Conversion Instructions
  id: totrans-1028
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously, I described several instructions to convert data between various
    scalar floating-point and integer formats (see “SSE Floating-Point Conversions”
    in Chapter 6). Variants of these instructions also exist for packed data conversions.
    [Table 11-31](#table11-31) lists many of these instructions you will commonly
    use.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-31: SSE Conversion Instructions'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction syntax** | **Description** |'
  id: totrans-1031
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1032
  prefs: []
  type: TYPE_TB
- en: '| `cvtdq2pd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | Converts two packed signed
    double-word integers from XMM[src]/mem[64] to two packed double-precision floating-point
    values in XMM[dest]. If YMM register is present, this instruction leaves the HO
    bits unchanged. |'
  id: totrans-1033
  prefs: []
  type: TYPE_TB
- en: '| `vcvtdq2pd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | (AVX) Converts two packed
    signed double-word integers from XMM[src]/mem[64] to two packed double-precision
    floating-point values in XMM[dest]. This instruction stores 0s into the HO bits
    of the underlying YMM register. |'
  id: totrans-1034
  prefs: []
  type: TYPE_TB
- en: '| `vcvtdq2pd` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts four
    packed signed double-word integers from XMM[src]/mem[128] to four packed double-precision
    floating-point values in YMM[dest]. |'
  id: totrans-1035
  prefs: []
  type: TYPE_TB
- en: '| `cvtdq2ps` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Converts four packed
    signed double-word integers from XMM[src]/mem[128] to four packed single-precision
    floating-point values in XMM[dest]. If YMM register is present, this instruction
    leaves the HO bits unchanged. |'
  id: totrans-1036
  prefs: []
  type: TYPE_TB
- en: '| `vcvtdq2ps` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts four
    packed signed double-word integers from XMM[src]/mem[128] to four packed single-precision
    floating-point values in XMM[dest]. If YMM register is present, this instruction
    writes 0s to the HO bits. |'
  id: totrans-1037
  prefs: []
  type: TYPE_TB
- en: '| `vcvtdq2ps` `ymm`[dest]`,` `ymm`[src]`/``mem`[256] | (AVX) Converts eight
    packed signed double-word integers from YMM[src]/mem[256] to eight packed single-precision
    floating-point values in YMM[dest]. If YMM register is present, this instruction
    writes 0s to the HO bits. |'
  id: totrans-1038
  prefs: []
  type: TYPE_TB
- en: '| `cvtpd2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Converts two packed double-precision
    floating-point values from XMM[src]/mem[128] to two packed signed double-word
    integers in XMM[dest]. If YMM register is present, this instruction leaves the
    HO bits unchanged. The conversion from floating-point to integer uses the current
    SSE rounding mode. |'
  id: totrans-1039
  prefs: []
  type: TYPE_TB
- en: '| `vcvtpd2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts two packed
    double-precision floating-point values from XMM[src]/mem[128] to two packed signed
    double-word integers in XMM[dest]. This instruction stores 0s into the HO bits
    of the underlying YMM register. The conversion from floating-point to integer
    uses the current AVX rounding mode. |'
  id: totrans-1040
  prefs: []
  type: TYPE_TB
- en: '| `vcvtpd2dq` `xmm`[dest]`,` `ymm`[src]`/``mem`[256] | (AVX) Converts four
    packed double-precision floating-point values from YMM[src]/mem[256] to four packed
    signed double-word integers in XMM[dest]. The conversion of floating-point to
    integer uses the current AVX rounding mode. |'
  id: totrans-1041
  prefs: []
  type: TYPE_TB
- en: '| `cvtpd2ps` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Converts two packed double-precision
    floating-point values from XMM[src]/mem[128] to two packed single-precision floating-point
    values in XMM[dest]. If YMM register is present, this instruction leaves the HO
    bits unchanged. |'
  id: totrans-1042
  prefs: []
  type: TYPE_TB
- en: '| `vcvtpd2ps` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts two packed
    double-precision floating-point values from XMM[src]/mem[128] to two packed single-precision
    floating-point values in XMM[dest]. This instruction stores 0s into the HO bits
    of the underlying YMM register. |'
  id: totrans-1043
  prefs: []
  type: TYPE_TB
- en: '| `vcvtpd2ps` `xmm`[dest]`,` `ymm`[src]`/``mem`[256] | (AVX) Converts four
    packed double-precision floating-point values from YMM[src]/mem[256] to four packed
    single-precision floating-point values in YMM[dest]. |'
  id: totrans-1044
  prefs: []
  type: TYPE_TB
- en: '| `cvtps2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Converts four packed
    single-precision floating-point values from XMM[src]/mem[128] to four packed signed
    double-word integers in XMM[dest]. If YMM register is present, this instruction
    leaves the HO bits unchanged. The conversion of floating-point to integer uses
    the current SSE rounding mode. |'
  id: totrans-1045
  prefs: []
  type: TYPE_TB
- en: '| `vcvtps2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts four
    packed single-precision floating-point values from XMM[src]/mem[128] to four packed
    signed double-word integers in XMM[dest]. This instruction stores 0s into the
    HO bits of the underlying YMM register. The conversion of floating-point to integer
    uses the current AVX rounding mode. |'
  id: totrans-1046
  prefs: []
  type: TYPE_TB
- en: '| `vcvtps2dq` `ymm`[dest]`,` `ymm`[src]`/``mem`[256] | (AVX) Converts eight
    packed single-precision floating-point values from YMM[src]/mem[256] to eight
    packed signed double-word integers in YMM[dest]. The conversion of floating-point
    to integer uses the current AVX rounding mode. |'
  id: totrans-1047
  prefs: []
  type: TYPE_TB
- en: '| `cvtps2pd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | Converts two packed single-precision
    floating-point values from XMM[src]/mem[64] to two packed double-precision values
    in XMM[dest]. If YMM register is present, this instruction leaves the HO bits
    unchanged. |'
  id: totrans-1048
  prefs: []
  type: TYPE_TB
- en: '| `vcvtps2pd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | (AVX) Converts two packed
    single-precision floating-point values from XMM[src]/mem[64] to two packed double-precision
    values in XMM[dest]. This instruction stores 0s into the HO bits of the underlying
    YMM register. |'
  id: totrans-1049
  prefs: []
  type: TYPE_TB
- en: '| `vcvtps2pd` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts four
    packed single-precision floating-point values from XMM[src]/mem[128] to four packed
    double-precision values in YMM[dest]. |'
  id: totrans-1050
  prefs: []
  type: TYPE_TB
- en: '| `cvttpd2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Converts two packed
    double-precision floating-point values from XMM[src]/mem[128] to two packed signed
    double-word integers in XMM[dest] using truncation. If YMM register is present,
    this instruction leaves the HO bits unchanged. |'
  id: totrans-1051
  prefs: []
  type: TYPE_TB
- en: '| `vcvttpd2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts two
    packed double-precision floating-point values from XMM[src]/mem[128] to two packed
    signed double-word integers in XMM[dest] using truncation. This instruction stores
    0s into the HO bits of the underlying YMM register. |'
  id: totrans-1052
  prefs: []
  type: TYPE_TB
- en: '| `vcvttpd2dq` `xmm`[dest]`,` `ymm`[src]`/``mem`[256] | (AVX) Converts four
    packed double-precision floating-point values from YMM[src]/mem[256] to four packed
    signed double-word integers in XMM[dest] using truncation. |'
  id: totrans-1053
  prefs: []
  type: TYPE_TB
- en: '| `cvttps2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Converts four packed
    single-precision floating-point values from XMM[src]/mem[128] to four packed signed
    double-word integers in XMM[dest] using truncation. If YMM register is present,
    this instruction leaves the HO bits unchanged. |'
  id: totrans-1054
  prefs: []
  type: TYPE_TB
- en: '| `vcvttps2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts four
    packed single-precision floating-point values from XMM[src]/mem[128] to four packed
    signed double-word integers in XMM[dest] using truncation. This instruction stores
    0s into the HO bits of the underlying YMM register. |'
  id: totrans-1055
  prefs: []
  type: TYPE_TB
- en: '| `vcvttps2dq` `ymm`[dest]`,` `ymm`[src]`/``mem`[256] | (AVX) Converts eight
    packed single-precision floating-point values from YMM[src]/mem[256] to eight
    packed signed double-word integers in YMM[dest] using truncation. |'
  id: totrans-1056
  prefs: []
  type: TYPE_TB
- en: 11.14 Aligning SIMD Memory Accesses
  id: totrans-1057
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most SSE and AVX instructions require their memory operands to be on a 16-byte
    (SSE) or 32-byte (AVX) boundary, but this is not always possible. The easiest
    way to handle unaligned memory addresses is to use instructions that don’t require
    aligned memory operands, like `movdqu`, `movups`, and `movupd`. However, the performance
    hit of using unaligned data movement instructions often defeats the purpose of
    using SSE/AVX instructions in the first place.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, the trick to aligning data for use by SIMD instructions is to process
    the first few data items by using standard general-purpose registers until you
    reach an address that is aligned properly. For example, suppose you want to use
    the `pcmpeqb` instruction to compare blocks of 16 bytes in a large array of bytes.
    `pcmpeqb` requires its memory operands to be at 16-byte-aligned addresses, so
    if the memory operand is not already 16-byte-aligned, you can process the first
    1 to 15 bytes in the array by using standard (non-SSE) instructions until you
    reach an appropriate address for `pcmpeqb`; for example:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: ANDing RSI with 0Fh produces a 0 result (and sets the zero flag) if the LO 4
    bits of RSI contain 0\. If the LO 4 bits of RSI contain 0, the address it contains
    is aligned on a 16-byte boundary.^([16](#c11-footnote-18))
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: The only drawback to this approach is that you must process as many as 15 bytes
    individually until you get an appropriate address. That’s 6 × 15, or 90, machine
    instructions. However, for large blocks of data (say, more than about 48 or 64
    bytes), you amortize the cost of the single-byte comparisons, and this approach
    isn’t so bad.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: To improve the performance of this code, you can modify the initial address
    so that it begins at a 16-byte boundary. ANDing the value in RSI (in this particular
    example) with 0FFFFFFFFFFFFFFF0h (–16) modifies RSI so that it holds the address
    of the start of the 16-byte block containing the original address:^([17](#c11-footnote-19))
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'To avoid matching unintended bytes before the start of the data structure,
    we can create a mask to cover the extra bytes. For example, suppose that we’re
    using the following instruction sequence to rapidly compare 16 bytes at a time:'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-1066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'If we use the AND instruction to align the RSI register prior to the execution
    of this code, we might get false results when we compare the first 16 bytes. To
    solve this, we can create a mask that will eliminate any bits from unintended
    comparisons. To create this mask, we start with all 1 bits and zero out any bits
    corresponding to addresses from the beginning of the 16-byte block to the first
    actual data item we’re comparing. This mask can be calculated using the following
    expression:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This creates 0 bits in the locations before the data to compare and 1 bit thereafter
    (for the first 16 bytes). We can use this mask to zero out the undesired bit results
    from the `pmovmskb` instruction. The following code snippet demonstrates this
    technique:'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-1070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Suppose, for example, that the address is already aligned on a 16-byte boundary.
    ANDing that value with 0Fh produces 0\. Shifting –1 to the left zero positions
    produces –1 (all 1 bits). Later, when the code logically ANDs this with the mask
    obtained after the `pcmpeqb` and `pmovmskb` instructions, the result does not
    change. Therefore, the code tests all 16 bytes (as we would want if the original
    address is 16-byte-aligned).
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: When the address in RSI has the value 0001b in the LO 4 bits, the actual data
    starts at offset 1 into the 16-byte block. So, we want to ignore the first byte
    when comparing the values in XMM2 against the 16 bytes at [RSI]. In this case,
    the mask is 0FFFFFFFEh, which is all 1s except for a 0 in bit 0\. After the comparison,
    if bit 0 of EAX contains a 1 (meaning the bytes at offset 0 match), the AND operation
    eliminates this bit (replacing it with 0) so it doesn’t affect the comparison.
    Likewise, if the starting offset into the block is 2, 3, . . . , 15, the `shl`
    instruction modifies the bit mask in EBX to eliminate bytes at those offsets from
    consideration in the first compare operation. The result is that it takes only
    11 instructions to do the same work as (up to) 90+ instructions in the original
    (byte-by-byte comparison) example.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: 11.15 Aligning Word, Dword, and Qword Object Addresses
  id: totrans-1073
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When aligning non-byte-sized objects, you increment the pointer by the size
    of the object (in bytes) until you obtain an address that is 16- (or 32-) byte-aligned.
    However, this works only if the object size is 2, 4, or 8 (because any other value
    will likely miss addresses that are multiples of 16).
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can process the first several elements of an array of word
    objects (where the first element of the array appears at an even address in memory)
    on a word-by-word basis, incrementing the pointer by 2, until you obtain an address
    that is divisible by 16 (or 32). Note, though, that this scheme works only if
    the array of objects begins at an address that is a multiple of the element size.
    For example, if an array of word values begins at an odd address in memory, you
    will not be able to get an address that is divisible by 16 or 32 with a series
    of additions by 2, and you would not be able to use SSE/AVX instructions to process
    this data without first moving it to another location in memory that is properly
    aligned.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: 11.16 Filling an XMM Register with Several Copies of the Same Value
  id: totrans-1076
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For many SIMD algorithms, you will want multiple copies of the same value in
    an XMM or a YMM register. You can use the `(v)movddup`, `(v)movshdup`, `(v)pinsd`,
    `(v)pinsq`, and `(v)pshufd` instructions for single-precision and double-precision
    floating-point values. For example, if you have a single-precision floating-point
    value, `r4var`, in memory and you want to replicate it throughout XMM0, you could
    use the following code:'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-1078
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'To copy a pair of double-precision floating-point values from `r8var` into
    XMM0, you could use:'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-1080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Of course, `pshufd` is really intended for double-word integer operations, so
    additional latency (time) may be involved in using `pshufd` immediately after
    `movsd` or `movss`. Although `pshufd` allows a memory operand, that operand must
    be a 16-byte-aligned 128-bit-memory operand, so it’s not useful for directly copying
    a floating-point value through an XMM register.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: 'For double-precision floating-point values, you can use `movddup` to duplicate
    a single 64-bit float in the LO bits of an XMM register into the HO bits:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The `movddup` instruction allows unaligned 64-bit memory operands, so it’s probably
    the best choice for duplicating double-precision values.
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: 'To copy byte, word, dword, or qword integer values throughout an XMM register,
    the `pshufb`, `pshufw`, `pshufd`, or `pshufq` instructions are a good choice.
    For example, to replicate a single byte throughout XMM0, you could use the following
    sequence:'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-1086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The XMM1 operand is an array of bytes containing masks used to copy data from
    locations in XMM0 onto itself. The value 0 copies byte 0 in XMM0 throughout all
    the other bits in XMM0\. This same code can be used to copy words, dwords, and
    qwords by simply changing the mask value in XMM1\. Or you could use the `pshuflw`
    or `pshufd` instructions to do the job. Here’s another variant that replicates
    a byte throughout XMM0:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 11.17 Loading Some Common Constants Into XMM and YMM Registers
  id: totrans-1089
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No SSE/AVX instructions let you load an immediate constant into a register.
    However, you can use a couple of idioms (tricks) to load certain common constant
    values into an XMM or a YMM register. This section discusses some of these idioms.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading 0 into an SSE/AVX register uses the same idiom that general-purpose
    integer registers employ: exclusive-OR the register with itself. For example,
    to set all the bits in XMM0 to 0s, you would use the following instruction:'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-1092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'To set all the bits in an XMM or a YMM register to 1, you can use the `pcmpeqb`
    instruction, as follows:'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Because any given XMM or YMM register is equal to itself, this instruction stores
    0FFh in all the bytes of XMM0 (or whatever XMM or YMM register you specify).
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to load the 8-bit value 01h into all 16 bytes of an XMM register,
    you can use the following code (this comes from Intel):'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: You can substitute `psubw` or `psubd` for `psubb` in this example if you want
    to create 16- or 32-bit results (for example, four 32-bit dwords in XMM0, each
    containing the value 00000001h).
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like the 1 bit in a different bit position (rather than bit 0
    of each byte), you can use the `pslld` instruction after the preceding sequence
    to reposition the bits. For example, if you want to load the XMM0 register with
    8080808080808080h, you could use the following instruction sequence:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Of course, you can supply a different immediate constant to `pslld` to load
    each byte in the register with 02h, 04h, 08h, 10h, 20h, or 40h.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a neat trick you can use to load 2^(*n*) – 1 (all 1 bits up to the *n*th
    bit in a number) into all the lanes on an SSE/AVX register:^([18](#c11-footnote-20))
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-1103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'You can also load the inverse (NOT(2^(*n*) – 1), all 1 bits in bit position
    *n* through the end of the register) by shifting to the left rather than the right:'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-1105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Of course, you can also load a “constant” into an XMM or a YMM register by putting
    that constant into a memory location (preferably 16- or 32-byte-aligned) and then
    using a `movdqu` or `movdqa` instruction to load that value into a register. Do
    keep in mind, however, that such an operation can be relatively slow if the data
    in memory does not appear in cache. Another possibility, if the constant is small
    enough, is to load the constant into a 32- or 64-bit integer register and use
    `movd` or `movq` to copy that value into an XMM register.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: 11.18 Setting, Clearing, Inverting, and Testing a Single Bit in an SSE Register
  id: totrans-1107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s another set of tricks suggested by Raymond Chen ([https://blogs.msdn.microsoft.com/oldnewthing/20141222-00/?p=43333/](https://blogs.msdn.microsoft.com/oldnewthing/20141222-00/?p=43333/))
    to set, clear, or test an individual bit in an XMM register.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: 'To set an individual bit (bit *n*, assuming that *n* is a constant) with all
    other bits cleared, you can use the following macro:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Once you can fill an XMM register with a single set bit, you can use that register’s
    value to set, clear, invert, or test that bit in another XMM register. For example,
    to set bit *n* in XMM1, without affecting any of the other bits in XMM1, you could
    use the following code sequence:'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-1112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'To clear bit *n* in an XMM register, you use the same sequence but substitute
    the `vpandn` (AND NOT) instruction for the `por` instruction:'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-1114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'To invert a bit, simply substitute `pxor` for `por` or `vpandn`:'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-1116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'To test a bit to see if it is set, you have a couple of options. If your CPU
    supports the SSE4.1 instruction set extensions, you can use the `ptest` instruction:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'If you have an older CPU that doesn’t support the `ptest` instruction, you
    can use `pmovmskb` as follows:'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-1120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 11.19 Processing Two Vectors by Using a Single Incremented Index
  id: totrans-1121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes your code will need to process two blocks of data simultaneously,
    incrementing pointers into both blocks during the execution of the loop.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: 'One easy way to do this is to use the scaled-indexed addressing mode. If R8
    and R9 contain pointers to the data you want to process, you can walk along both
    blocks of data by using code such as the following:'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-1124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'This code marches along through the two dword arrays comparing values (to search
    for an equal value in the arrays at the same index). This loop uses four registers:
    EAX to compare the two values from the arrays, the two pointers to the arrays
    (R8 and R9), and then the RCX index register to step through the two arrays.'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to eliminate RCX from this loop by incrementing the R8 and R9
    registers in this loop (assuming it’s okay to modify the values in R8 and R9):'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: This scheme requires an extra `add` instruction in the loop. If the execution
    speed of this loop is critical, inserting this extra addition could be a deal
    breaker.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, a sneaky trick you can use so that you have to increment
    only a single register on each iteration of the loop:'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-1130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The comments are there because they explain the trick being used. At the beginning
    of the code, you subtract the value of R8 from R9 and leave the result in R9\.
    In the body of the loop, you compensate for this subtraction by using the `[r9][r8
    * 1]` scaled-indexed addressing mode (whose effective address is the sum of R8
    and R9, thus restoring R9 to its original value, at least on the first iteration
    of the loop). Now, because the `cmp` instruction’s memory address is the sum of
    R8 and R9, adding 4 to R8 also adds 4 to the effective address used by the `cmp`
    instruction. Therefore, on each iteration of the loop, the `mov` and `cmp` instructions
    look at successive elements of their respective arrays, yet the code has to increment
    only a single pointer.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: 'This scheme works especially well when processing SIMD arrays with SSE and
    AVX instructions because the XMM and YMM registers are 16 and 32 bytes each, so
    you can’t use normal scaling factors (1, 2, 4, or 8) to index into an array of
    packed data values. You wind up having to add 16 (or 32) to your pointers when
    stepping through the arrays, thus losing one of the benefits of the scaled-indexed
    addressing mode. For example:'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-1133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 11.20 Aligning Two Addresses to a Boundary
  id: totrans-1134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `vmovapd` and `vaddpd` instructions from the preceding example require
    their memory operands to be 32-byte-aligned or you will get a general protection
    fault (memory access violation). If you have control over the placement of the
    arrays in memory, you can specify an alignment for the arrays. If you have no
    control over the data’s placement in memory, you have two options: working with
    the unaligned data regardless of the performance loss, or moving the data to a
    location where it is properly aligned.'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: 'If you must work with unaligned data, you can substitute an unaligned move
    for an aligned move (for example, `vmovupd` for `vmovdqa`) or load the data into
    a YMM register by using an unaligned move and then operate on the data in that
    register by using your desired instruction. For example:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Sadly, the `vaddpd` instruction does not support unaligned access to memory,
    so you must load the value from the second array (pointed at by R9) into another
    register (YMM1) before the packed addition operation. This is the drawback to
    unaligned access: not only are unaligned moves slower, but you also may need to
    use additional registers and instructions to deal with unaligned data.'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: Moving the data to a memory location whose alignment you can control is an option
    when you have a data operand you will be using over and over again in the future.
    Moving data is an expensive operation; however, if you have a standard block of
    data you’re going to compare against many other blocks, you can amortize the cost
    of moving that block to a new location over all the operations you need to do.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: Moving the data is especially useful when one (or both) of the data arrays appears
    at an address that is not an integral multiple of the sub-elements’s size. For
    example, if you have an array of dwords that begin at an odd address, you will
    never be able to align a pointer to that array’s data to a 16-byte boundary without
    moving the data.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: 11.21 Working with Blocks of Data Whose Length Is Not a Multiple of the SSE/AVX
    Register Size
  id: totrans-1141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using SIMD instructions to march through a large data set processing 2, 4,
    8, 16, or 32 values at a time often allows a SIMD algorithm (a *vectorized* algorithm)
    to run an order of magnitude faster than the SISD (scalar) algorithm. However,
    two boundary conditions create problems: the start of the data set (when the starting
    address might not be properly aligned) and the end of the data set (when there
    might not be a sufficient number of array elements to completely fill an XMM or
    a YMM register). I’ve addressed the issues with the start of the data set (misaligned
    data) already. This section takes a look at the latter problem.'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: 'For the most part, when you run out of data at the end of the array (and the
    XMM and YMM registers need more for a packed operation), you can use the same
    technique given earlier for aligning a pointer: load more data than is necessary
    into the register and mask out the unneeded results. For example, if only 8 bytes
    are left to process in a byte array, you can load 16 bytes, do the operation,
    and ignore the results from the last 8 bytes. In the comparison loop examples
    I’ve been using through these past sections, you could do the following:'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-1144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: In most cases, accessing data beyond the end of the data structures (either
    the data pointed at by R8, R9, or both in this example) is harmless. However,
    as you saw in “Memory Access and 4K Memory Management Unit Pages” in Chapter 3,
    if that extra data happens to cross a memory management unit page, and that new
    page doesn’t allow read access, the CPU will generate a general protection fault
    (memory access or segmentation fault). Therefore, unless you know that valid data
    follows the array in memory (at least to the extent the instruction references),
    you shouldn’t access that memory area; doing so could crash your software.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: This problem has two solutions. First, you can align memory accesses on an address
    boundary that is the same size as the register (for example, 16-byte alignment
    for XMM registers). Accessing data beyond the end of the data structure with an
    SSE/AVX instruction will not cross a page boundary (because 16-byte accesses aligned
    on 16-byte boundaries will always fall within the same MMU page, and ditto for
    32-byte accesses on 32-byte boundaries).
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: The second solution is to examine the memory address prior to accessing memory.
    While you cannot access the new page without possibly triggering an access fault,^([19](#c11-footnote-21))
    you can check the address itself and see if accessing 16 (or 32) bytes at that
    address will access data in a new page. If it would, you can take some precautions
    before accessing the data on the next page. For example, rather than continuing
    to process the data in SIMD mode, you could drop down to SISD mode and finish
    processing the data to the end of the array by using standard scalar instructions.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: 'To test if a SIMD access will cross an MMU page boundary, supposing that R9
    contains the address at which you’re about to access 16 bytes in memory using
    an SSE instruction, use code like the following:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Each MMU page is 4KB long and is situated on a 4KB address boundary in memory.
    Therefore, the LO 12 bits of an address provide an index into the MMU page associated
    with that address. The preceding code checks whether the address has a page offset
    greater than 0FF0h (4080). If so, then accessing 16 bytes starting at that address
    will cross a page boundary. Check for a value of 0FE0h if you need to check for
    a 32-byte access.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: 11.22 Dynamically Testing for a CPU Feature
  id: totrans-1151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of this chapter, I mentioned that when testing the CPU feature
    set to determine which extensions it supports, the best solution is to dynamically
    select a set of functions based on the presence or absence of certain capabilities.
    To demonstrate dynamically testing for, and using (or avoiding), certain CPU features—specifically,
    testing for the presence of AVX extensions—I’ll modify (and expand) the `print`
    procedure that I’ve been using in examples up to this point.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: The `print` procedure I’ve been using is very convenient, but it doesn’t preserve
    any SSE or AVX registers that a call to `printf()` could (legally) modify. A generic
    version of `print` should preserve the volatile XMM and YMM registers as well
    as general-purpose registers.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that you cannot write a generic version of `print` that will
    run on all CPUs. If you preserve the XMM registers only, the code will run on
    any x86-64 CPU. However, if the CPU supports the AVX extensions and the program
    uses YMM0 to YMM5, the print routine will preserve only the LO 128 bits of those
    registers, as they are aliased to the corresponding XMM registers. If you save
    the volatile YMM registers, that code will crash on a CPU that doesn’t support
    the AVX extensions. So, the trick is to write code that will dynamically determine
    whether the CPU has the AVX registers and preserve them if they are present, and
    otherwise preserve only the SSE registers.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: 'The easy way to do this, and probably the most appropriate solution for the
    `print` function, is to simply stick the `cpuid` instruction inside `print` and
    test the results immediately before preserving (and restoring) the registers.
    Here’s a code fragment that demonstrates how this could be done:'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-1156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: At the end of the `print` function, when it’s time to restore everything, you
    could do another test to determine whether to restore XMM or YMM registers.^([20](#c11-footnote-22))
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: 'For other functions, when you might not want the expense of `cpuid` (and preserving
    all the registers it stomps on) incurred on every function call, the trick is
    to write *three* functions: one for SSE CPUs, one for AVX CPUs, and a special
    function (that you call only once) that selects which of these two you will call
    in the future. The bit of magic that makes this efficient is *indirection*. You
    won’t directly call any of these functions. Instead, you’ll initialize a pointer
    with the address of the function to call and indirectly call one of these three
    functions by using the pointer. For the current example, we’ll name this pointer
    `print` and initialize it with the address of the third function, `choosePrint`:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Here’s the code for `choosePrint`:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The `print_SSE` procedure runs on CPUs without AVX support, and the `print_AVX`
    procedure runs on CPUs with AVX support. The `choosePrint` procedure executes
    the `cpuid` instruction to determine whether the CPU supports the AVX extensions;
    if so, it initializes the `print` pointer with the address of the `print_AVX`
    procedure, and if not, it stores the address of `print_SSE` into the `print` variable.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: '`choosePrint` is not an explicit initialization procedure you must call prior
    to calling `print`. The `choosePrint` procedure executes only *once* (assuming
    you call it via the `print` pointer rather than calling it directly). After the
    first execution, the `print` pointer contains the address of the CPU-appropriate
    print function, and `choosePrint` no longer executes.'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: 'You call the `print` pointer just as you would make any other call to `print`;
    for example:'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-1165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: After setting up the `print` pointer, `choosePrint` must transfer control to
    the appropriate print procedure (`print_SSE` or `print_AVX`) to do the work the
    user is expecting. Because preserved register values are sitting on the stack,
    and the actual print routines expect only a return address, `choosePrint` will
    first restore all the (general-purpose) registers it saved and then jump to (not
    call) the appropriate print procedure. It does a jump, rather than a call, because
    the return address pointing to the format string is already sitting on the top
    of the stack. On return from the `print_SSE` or `print_AVX` procedure, control
    will return to whomever called `choosePrint` (via the `print` pointer).
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-5](#listing11-5) shows the complete `print` function, with `print_SSE`
    and `print_AVX`, and a simple main program that calls `print`. I’ve extended `print`
    to accept arguments in R10 and R11 as well as in RDX, R8, and R9 (this function
    reserves RCX to hold the address of the format string following the call to `print`).'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-1168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Listing 11-5: Dynamically selected print procedure'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and output for the program in [Listing 11-5](#listing11-5):'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-1171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 11.23 The MASM Include Directive
  id: totrans-1172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ve seen already, including the source code for the `print` procedure
    in every sample listing in this book wastes a lot of space. Including the new
    version from the previous section in every listing would be impractical. In Chapter
    15, I discuss include files, libraries, and other functionality you can use to
    break large projects into manageable pieces. In the meantime, however, it’s worthwhile
    to discuss the MASM `include` directive so this book can eliminate a lot of unnecessary
    code duplication in sample programs.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: 'The MASM `include` directive uses the following syntax:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: where `source_filename` is the name of a text file (generally in the same directory
    of the source file containing this `include` directive). MASM will take the source
    file and insert it into the assembly at the point of the `include` directive,
    exactly as though the text in that file had appeared in the source file being
    assembled.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, I have extracted all the source code associated with the new print
    procedure (the `choosePrint`, `print_AVX`, and `print_SSE` procedures, and the
    `print` qword variable), and I’ve inserted them into the *print.inc* source file.^([21](#c11-footnote-23))
    In listings that follow in this book, I’ll simply place the following directive
    in the code in place of the print function:'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-1178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: I’ve also put the `getTitle` procedure into its own header file (*getTitle.inc*)
    to be able to remove that common code from sample listings.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: 11.24 And a Whole Lot More
  id: totrans-1180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter doesn’t even begin to describe all the various SSE, AVX, AVX2,
    and AVX512 instructions. As already mentioned, most of the SIMD instructions have
    a specific purpose (such as interleaving or deinterleaving bytes associated with
    video or audio information) that aren’t very useful outside their particular problem
    domain. Other instructions (at least, as this book was being written) are sufficiently
    new that they won’t execute on many CPUs in use today. If you’re interested in
    learning about more of the SIMD instructions, check out the information in the
    next section.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: 11.25 For More Information
  id: totrans-1182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about the `cpuid` instruction on AMD CPUs, see the 2010
    AMD document “CPUID Specification” ([https://www.amd.com/system/files/TechDocs/25481.pdf](https://www.amd.com/system/files/TechDocs/25481.pdf)).
    For Intel CPUs, check out “Intel Architecture and Processor Identification with
    CPUID Model and Family Numbers” ([https://software.intel.com/en-us/articles/intel-architecture-and-processor-identification-with-cpuid-model-and-family-numbers/](https://software.intel.com/en-us/articles/intel-architecture-and-processor-identification-with-cpuid-model-and-family-numbers/)).
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft’s website (particularly the Visual Studio documentation) has additional
    information on the MASM `segment` directive and x86-64 segments. A search for
    *MASM Segment Directive* on the internet, for example, brought up the page [https://docs.microsoft.com/en-us/cpp/assembler/masm/segment?view=msvc-160/](https://docs.microsoft.com/en-us/cpp/assembler/masm/segment?view=msvc-160/).
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete discussion of all the SIMD instructions can be found in Intel’s
    documentation: *Intel® 64 and IA-32 Architectures Software Developer’s Manual,*
    Volume 2: *Instruction Set Reference*.'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily find this documentation online at Intel’s website; for example:'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: '*[https://software.intel.com/en-us/articles/intel-sdm/](https://software.intel.com/en-us/articles/intel-sdm/)*'
  id: totrans-1187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**   *[https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html](https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html)**'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: '**AMD’s variant can be found at [https://www.amd.com/system/files/TechDocs/40332.pdf](https://www.amd.com/system/files/TechDocs/40332.pdf).'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this chapter has presented many of the SSE/AVX/AVX2 instructions and
    what they do, it has not spent much time describing how you would use these instructions
    in a typical program. You can easily find lots of useful high-performance algorithms
    that use SSE and AVX instructions on the internet. The following URLs provide
    some examples:'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: '**Tutorials on SIMD programming**'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: SSE Arithmetic, by Stefano Tommesani, [https://tommesani.com/index.php/2010/04/24/sse-arithmetic/](https://tommesani.com/index.php/2010/04/24/sse-arithmetic/)
  id: totrans-1192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*x86/x64 SIMD Instruction List, [https://www.officedaytime.com/simd512e/](https://www.officedaytime.com/simd512e/)*'
  id: totrans-1193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**   *Basics of SIMD Programming, Sony Computer Entertainment, [http://ftp.cvut.cz/kernel/people/geoff/cell/ps3-linux-docs/CellProgrammingTutorial/BasicsOfSIMDProgramming.html](http://ftp.cvut.cz/kernel/people/geoff/cell/ps3-linux-docs/CellProgrammingTutorial/BasicsOfSIMDProgramming.html)**'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: '****Sorting algorithms**'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: “A Novel Hybrid Quicksort Algorithm Vectorized Using AVX-512 on Intel Skylake,”
    by Berenger Bramas, [https://arxiv.org/pdf/1704.08579.pdf](https://arxiv.org/pdf/1704.08579.pdf)
  id: totrans-1196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Register Level Sort Algorithm on Multi-Core SIMD Processors” by Tian Xiaochen
    et al., [http://olab.is.s.u-tokyo.ac.jp/~kamil.rocki/xiaochen_rocki_IA3_SC13.pdf](http://olab.is.s.u-tokyo.ac.jp/~kamil.rocki/xiaochen_rocki_IA3_SC13.pdf)
  id: totrans-1197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Fast Quicksort Implementation Using AVX Instructions” by Shay Gueron and Vlad
    Krasnov, [http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1009.7773&rep=rep1&type=pdf](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1009.7773&rep=rep1&type=pdf)
  id: totrans-1198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Search algorithms**'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: “SIMD-Friendly Algorithms for Substring Searching” by Wojciech Mula, [http://0x80.pl/articles/simd-strfind.html](http://0x80.pl/articles/simd-strfind.html)
  id: totrans-1200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Fast Multiple String Matching Using Streaming SIMD Extensions Technology” by
    Simone Faro and M. Oğuzhan Külekci, [https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1041.3831&rep=rep1&type=pdf](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1041.3831&rep=rep1&type=pdf)
  id: totrans-1201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “k-Ary Search on Modern Processors” by Benjamin Schlegel et al., [https://event.cwi.nl/damon2009/DaMoN09-KarySearch.pdf](https://event.cwi.nl/damon2009/DaMoN09-KarySearch.pdf)
  id: totrans-1202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.26 Test Yourself
  id: totrans-1203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How can you determine whether a particular SSE or AVX feature is available on
    the CPU?
  id: totrans-1204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important to check the manufacturer of the CPU?
  id: totrans-1205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What EAX setting do you use with `cpuid` to obtain the feature flags?
  id: totrans-1206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What feature flag bit tells you that the CPU supports SSE4.2 instructions?
  id: totrans-1207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name of the default segment used by the following directives?
  id: totrans-1208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.code`'
  id: totrans-1209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.data`'
  id: totrans-1210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.data?`'
  id: totrans-1211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.const`'
  id: totrans-1212
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the default segment alignment?
  id: totrans-1213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you create a data segment aligned on a 64-byte boundary?
  id: totrans-1214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which instruction set extensions support the YMM*x* registers?
  id: totrans-1215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a lane?
  id: totrans-1216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a scalar instruction and a vector instruction?
  id: totrans-1217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SSE memory operands (XMM) must usually be aligned on what memory boundary?
  id: totrans-1218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AVX memory operands (YMM) must usually be aligned on what memory boundary?
  id: totrans-1219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AVX-512 memory operands (ZMM) must usually be aligned on what memory boundary?
  id: totrans-1220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What instruction would you use to move the data from a 32-bit general-purpose
    integer register into the LO 32 bits of an XMM and a YMM register?
  id: totrans-1221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What instruction would you use to move the data from a 64-bit general-purpose
    integer register into the LO 64 bits of an XMM and a YMM register?
  id: totrans-1222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What three instructions would you use to load 16 bytes from an aligned memory
    location into an XMM register?
  id: totrans-1223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What three instructions would you use to load 16 bytes from an arbitrary memory
    address into an XMM register?
  id: totrans-1224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to move the HO 64 bits of an XMM register into the HO 64 bits of
    another XMM register without affecting the LO 64 bits of the destination, what
    instruction would you use?
  id: totrans-1225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to duplicate a double-precision value in the LO 64 bits of an XMM
    register in the two qwords (LO and HO) of another XMM register, what instruction
    would you use?
  id: totrans-1226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which instruction would you use to rearrange the bytes in an XMM register?
  id: totrans-1227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which instruction would you use to rearrange the dword lanes in an XMM register?
  id: totrans-1228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which instructions would you use to extract bytes, words, dwords, or qwords
    from an XMM register and move them into a general-purpose register?
  id: totrans-1229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which instructions would you use to take a byte, word, dword, or qword in a
    general-purpose register and insert it somewhere in an XMM register?
  id: totrans-1230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `andnpd` instruction do?
  id: totrans-1231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which instruction would you use to shift the bytes in an XMM register one byte
    position to the left (8 bits)?
  id: totrans-1232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which instruction would you use to shift the bytes in an XMM register one byte
    position to the right (8 bits)?
  id: totrans-1233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to shift the two qwords in an XMM register *n* bit positions to
    the left, what instruction would you use?
  id: totrans-1234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to shift the two qwords in an XMM register *n* bit positions to
    the right, what instruction would you use?
  id: totrans-1235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens in a `paddb` instruction when a sum will not fit into 8 bits?
  id: totrans-1236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a vertical addition and a horizontal addition?
  id: totrans-1237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where does the `pcmpeqb` instruction put the result of the comparison? How does
    it indicate the result is true?
  id: totrans-1238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no `pcmpltq` instruction. Explain how to compare lanes in a pair of
    XMM registers for the less-than condition.
  id: totrans-1239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `pmovmskb` instruction do?
  id: totrans-1240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many simultaneous additions are performed by the following?
  id: totrans-1241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`addps`'
  id: totrans-1242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`addpd`'
  id: totrans-1243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have a pointer to data in RAX and want to force that address to be aligned
    on a 16-byte boundary, what instruction would you use?
  id: totrans-1244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you set all the bits in the XMM0 register to 0?
  id: totrans-1245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you set all the bits in the XMM1 register to 1?
  id: totrans-1246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What directive do you use to insert the content of a source file into the current
    source file during assembly?****
  id: totrans-1247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
