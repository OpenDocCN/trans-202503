- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SIMD Instructions
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter discusses the *vector instructions* on the x86-64\. This special
    class of instructions provides parallel processing, traditionally known as *single-instruction,
    multiple-data (**SIMD)* instructions because, quite literally, a single instruction
    operates on several pieces of data concurrently. As a result of this concurrency,
    SIMD instructions can often execute several times faster (in theory, as much as
    32 to 64 times faster) than the comparable *single-instruction, single-data (SISD),*
    or *scalar,* instructions that compose the standard x86-64 instruction set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The x86-64 actually provides three sets of vector instructions: the Multimedia
    Extensions (MMX) instruction set, the Streaming SIMD Extensions (SSE) instruction
    set, and the Advanced Vector Extensions (AVX) instruction set. This book does
    not consider the MMX instructions as they are obsolete (SSE equivalents exist
    for the MMX instructions).'
  prefs: []
  type: TYPE_NORMAL
- en: The x86-64 vector instruction set (SSE/AVX) is almost as large as the scalar
    instruction set. A whole book could be written about SSE/AVX programming and algorithms.
    However, this is not that book; SIMD and parallel algorithms are an advanced subject
    beyond the scope of this book, so this chapter settles for introducing a fair
    number of SSE/AVX instructions and leaves it at that.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter begins with some prerequisite information. First, it begins with
    a discussion of the x86-64 vector architecture and streaming data types. Then,
    it discusses how to detect the presence of various vector instructions (which
    are not present on all x86-64 CPUs) by using the `cpuid` instruction. Because
    most vector instructions require special memory alignment for data operands, this
    chapter also discusses MASM segments.
  prefs: []
  type: TYPE_NORMAL
- en: 11.1 The SSE/AVX Architectures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s begin by taking a quick look at the SSE and AVX features in the x64-86
    CPUs. The SSE and AVX instructions have several variants: the original SSE, plus
    SSE2, SSE3, SSE3, SSE4 (SSE4.1 and SSE4.2), AVX, AVX2 (AVX and AVX2 are sometimes
    called AVX-256), and AVX-512\. SSE3 was introduced along with the Pentium 4F (Prescott)
    CPU, Intel’s first 64-bit CPU. Therefore, you can assume that all Intel 64-bit
    CPUs support the SSE3 and earlier SIMD instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SSE/AVX architectures have three main generations:'
  prefs: []
  type: TYPE_NORMAL
- en: The SSE architecture, which (on 64-bit CPUs) provided sixteen 128-bit XMM registers
    supporting integer and floating-point data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AVX/AVX2 architecture, which supported sixteen 256-bit YMM registers (also
    supporting integer and floating-point data types)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AVX-512 architecture, which supported up to thirty-two 512-bit ZMM registers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a general rule, this chapter sticks to AVX2 and earlier instructions in its
    examples. Please see the Intel and AMD CPU manuals for a discussion of the additional
    instruction set extensions such as AVX-512\. This chapter does not attempt to
    describe every SSE or AVX instruction. Most streaming instructions have very specialized
    purposes and aren’t particularly useful in generic applications.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2 Streaming Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The SSE and AVX programming models support two basic data types: scalars and
    vectors. *Scalars* hold one single- or double-precision floating-point value.
    *Vectors* hold multiple floating-point or integer values (between 2 and 32 values,
    depending on the scalar data type of byte, word, dword, qword, single precision,
    or double precision, and the register and memory size of 128 or 256 bits).'
  prefs: []
  type: TYPE_NORMAL
- en: The XMM registers (XMM0 to XMM15) can hold a single 32-bit floating-point value
    (a scalar) or four single-precision floating-point values (a vector). The YMM
    registers (YMM0 to YMM15) can hold eight single-precision (32-bit) floating-point
    values (a vector); see [Figure 11-1](#figure11-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11001](image_fi/501089c11/f11001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-1: Packed and scalar single-precision floating-point data type'
  prefs: []
  type: TYPE_NORMAL
- en: The XMM registers can hold a single double-precision scalar value or a vector
    containing a pair of double-precision values. The YMM registers can hold a vector
    containing four double-precision floating-point values, as shown in [Figure 11-2](#figure11-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11002](image_fi/501089c11/f11002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-2: Packed and scalar double-precision floating-point type'
  prefs: []
  type: TYPE_NORMAL
- en: The XMM registers can hold 16 byte values (YMM registers can hold 32 byte values),
    allowing the CPU to perform 16 (32) byte-sized computations with one instruction
    ([Figure 11-3](#figure11-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11003](image_fi/501089c11/f11003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-3: Packed byte data type'
  prefs: []
  type: TYPE_NORMAL
- en: The XMM registers can hold eight word values (YMM registers can hold sixteen
    word values), allowing the CPU to perform eight (sixteen) 16-bit word-sized integer
    computations with one instruction ([Figure 11-4](#figure11-4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11004](image_fi/501089c11/f11004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-4: Packed word data type'
  prefs: []
  type: TYPE_NORMAL
- en: The XMM registers can hold four dword values (YMM registers can hold eight dword
    values), allowing the CPU to perform four (eight) 32-bit dword-sized integer computations
    with one instruction ([Figure 11-5](#figure11-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11005](image_fi/501089c11/f11005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-5: Packed double-word data type'
  prefs: []
  type: TYPE_NORMAL
- en: The XMM registers can hold two qword values (YMM registers can hold four qword
    values), allowing the CPU to perform two (four) 64-bit qword computations with
    one instruction ([Figure 11-6](#figure11-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11006](image_fi/501089c11/f11006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-6: Packed quad-word data type'
  prefs: []
  type: TYPE_NORMAL
- en: Intel’s documentation calls the vector elements in an XMM and a YMM register
    *lanes*. For example, a 128-bit XMM register has 16 bytes. Bits 0 to 7 are lane
    0, bits 8 to 15 are lane 1, bits 16 to 23 are lane 2, . . . , and bits 120 to
    127 are lane 15\. A 256-bit YMM register has 32 byte-sized lanes, and a 512-bit
    ZMM register has 64 byte-sized lanes.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, a 128-bit XMM register has eight word-sized lanes (lanes 0 to 7).
    A 256-bit YMM register has sixteen word-sized lanes (lanes 0 to 15). On AVX-512-capable
    CPUs, a ZMM register (512 bits) has thirty-two word-sized lanes, numbered 0 to
    31.
  prefs: []
  type: TYPE_NORMAL
- en: An XMM register has four dword-sized lanes (lanes 0 to 3); it also has four
    single-precision (32-bit) floating-point lanes (also numbered 0 to 3). A YMM register
    has eight dword or single-precision lanes (lanes 0 to 7). An AVX2 ZMM register
    has sixteen dword or single-precision-sized lanes (numbers 0 to 15).
  prefs: []
  type: TYPE_NORMAL
- en: XMM registers support two qword-sized lanes (or two double-precision lanes),
    numbered 0 to 1\. As expected, a YMM register has twice as many (four lanes, numbered
    0 to 3), and an AVX2 ZMM register has four times as many lanes (0 to 7).
  prefs: []
  type: TYPE_NORMAL
- en: Several SSE/AVX instructions refer to various lanes within these registers.
    In particular, the shuffle and unpack instructions allow you to move data between
    lanes in SSE and AVX operands. See “The Shuffle and Unpack Instructions” on page
    625 for examples of lane usage.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3 Using cpuid to Differentiate Instruction Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Intel introduced the 8086 (and shortly thereafter, the 8088) microprocessor
    in 1978\. With almost every succeeding CPU generation, Intel added new instructions
    to the instruction set. Until this chapter, this book has used instructions that
    are generally available on all x86-64 CPUs (Intel and AMD). This chapter presents
    instructions that are available only on later-model x86-64 CPUs. To allow programmers
    to determine which CPU their applications were using so they could dynamically
    avoid using newer instructions on older processors, Intel introduced the `cpuid`
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: The `cpuid` instruction expects a single parameter (called a *leaf* function)
    passed in the EAX register. It returns various pieces of information about the
    CPU in different 32-bit registers based on the value passed in EAX. An application
    can test the return information to see if certain CPU features are available.
  prefs: []
  type: TYPE_NORMAL
- en: As Intel introduced new instructions, it changed the behavior of `cpuid` to
    reflect those changes. Specifically, Intel changed the range of values a program
    could legally pass in EAX to `cpuid`; this is known as the *highest function supported*.
    As a result, some 64-bit CPUs accept only values in the range 0h to 05h. The instructions
    this chapter discusses may require passing values in the range 0h to 07h. Therefore,
    the first thing you have to do when using `cpuid` is to verify that it accepts
    EAX = 07h as a valid parameter.
  prefs: []
  type: TYPE_NORMAL
- en: To determine the highest function supported, you load EAX with 0 or 8000_0000h
    and execute the `cpuid` instruction (all 64-bit CPUs support these two function
    values). The return value is the maximum you can pass to `cpuid` in EAX. The Intel
    and AMD documentation (also see [https://en.wikipedia.org/wiki/CPUID](https://en.wikipedia.org/wiki/CPUID))
    will list the values `cpuid` returns for various CPUs; for the purposes of this
    chapter, we need only verify that the highest function supported is 01h (which
    is true for all 64-bit CPUs) or 07h for certain instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to providing the highest function supported, the `cpuid` instruction
    with EAX = 0h (or 8000_0002h) also returns a 12-character vendor ID in the EBX,
    ECX, and EDX registers. For x86-64 chips, this will be either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: GenuineIntel (EBX is 756e_6547h, EDX is 4965_6e69h, and ECX is 6c65_746eh)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AuthenticAMD (EBX is 6874_7541h, EDX is 6974_6E65h, and ECX is 444D_4163h)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To determine if the CPU can execute most SSE and AVX instructions, you must
    execute `cpuid` with EAX = 01h and test various bits placed in the ECX register.
    For a few of the more advanced features (advanced bit-manipulation functions and
    AVX2 instructions), you’ll need to execute `cpuid` with EAX = 07h and check the
    results in the EBX register. The `cpuid` instruction (with EAX = 1) returns an
    interesting SSE/AVX feature flag in the following bits in ECX, as shown in [Table
    11-1](#table11-1); with EAX = 07h, it returns the bit manipulation or AVX2 flag
    in EBX, as shown in [Table 11-2](#table11-2). If the bit is set, the CPU supports
    the specific instruction(s).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-1: Intel `cpuid` Feature Flags (EAX = 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit** | **ECX** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | SSE3 support |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | PCLMULQDQ support |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | SSSE3 support |'
  prefs: []
  type: TYPE_TB
- en: '| 19 | CPU supports SSE4.1 instructions |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | CPU supports SSE4.2 instructions |'
  prefs: []
  type: TYPE_TB
- en: '| 28 | Advanced Vector Extensions |'
  prefs: []
  type: TYPE_TB
- en: 'Table 11-2: Intel `cpuid` Extended Feature Flags (EAX = 7, ECX = 0)'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit** | **EBX** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Bit Manipulation Instruction Set 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Advanced Vector Extensions 2 (AVX2) |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | Bit Manipulation Instruction Set 2 |'
  prefs: []
  type: TYPE_TB
- en: '[Listing 11-1](#listing11-1) queries the vendor ID and basic feature flags
    on a CPU.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-1: `cpuid` demonstration program'
  prefs: []
  type: TYPE_NORMAL
- en: 'On an old MacBook Pro Retina with an Intel i7-3720QM CPU, running under Parallels,
    you get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This CPU supports SSE3 instructions (bit 0 of ECX is 1), SSE4.1 and SSE4.2 instructions
    (bits 19 and 20 of ECX are 1), and the AVX instructions (bit 28 is 1). Those,
    largely, are the instructions this chapter describes. Most modern CPUs will support
    these instructions (the i7-3720QM was released by Intel in 2012). The processor
    doesn’t support some of the more interesting extended features on the Intel instruction
    set (the extended bit-manipulation instructions and the AVX2 instruction set).
    Programs using those instructions will not execute on this (ancient) MacBook Pro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this on a more recent CPU (an iMac Pro 10-core Intel Xeon W-2150B)
    produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, looking at the extended feature bits, the newer Xeon CPU does
    support these additional instructions. The code fragment in [Listing 11-2](#listing11-2)
    provides a quick modification to [Listing 11-1](#listing11-1) that tests for the
    availability of the BMI1 and BMI2 bit-manipulation instruction sets (insert the
    following code right before the `allDone` label in [Listing 11-1](#listing11-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-2: Test for BMI1 and BMI2 instruction sets'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and program output on the Intel i7-3720QM CPU:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the same program running on the iMac Pro (Intel Xeon W-2150B):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 11.4 Full-Segment Syntax and Segment Alignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you will soon see, SSE and AVX memory data require alignment on 16-, 32-,
    and even 64-byte boundaries. Although you can use the `align` directive to align
    data (see “MASM Support for Data Alignment” in Chapter 3), it doesn’t work beyond
    16-byte alignment when using the simplified segment directives presented thus
    far in this book. If you need alignment beyond 16 bytes, you have to use MASM
    full-segment declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to create a segment with complete control over segment attributes,
    you need to use the `segment` and `ends` directives.^([1](#c11-footnote-1)) The
    generic syntax for a segment declaration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`segname` is an identifier. This is the name of the segment (which must also
    appear before the closing `ends` directive). It need not be unique; you can have
    several segment declarations that share the same name. MASM will combine segments
    with the same name when emitting code to the object file. Avoid the segment names
    `_TEXT`, `_DATA`, `_BSS`, and `_CONST`, as MASM uses these names for the `.code`,
    `.data`, `.data?`, and `.const` directives, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: The `readonly` option is either blank or the MASM-reserved word `readonly`.
    This is a hint to MASM that the segment will contain read-only (constant) data.
    If you attempt to (directly) store a value into a variable that you declare in
    a read-only segment, MASM will complain that you cannot modify a read-only segment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `alignment` option is also optional and allows you to specify one of the
    following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`byte`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`word`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dword`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`para`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`align(``n``)` (`n` is a constant that must be a power of 2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The alignment options tell MASM that the first byte emitted for this particular
    segment must appear at an address that is a multiple of the alignment option.
    The `byte`, `word`, and `dword` reserved words specify 1-, 2-, or 4-byte alignments.
    The `para` alignment option specifies paragraph alignment (16 bytes). The `page`
    alignment option specifies an address alignment of 256 bytes. Finally, the `align(``n``)`
    alignment option lets you specify any address alignment that is a power of 2 (1,
    2, 4, 8, 16, 32, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: The default segment alignment, if you don’t explicitly specify one, is paragraph
    alignment (16 bytes). This is also the default alignment for the simplified segment
    directives (`.code`, `.data`, `.data?`, and `.const`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have some (SSE/AVX) data objects that must start at an address that
    is a multiple of 32 or 64 bytes, then creating a new data segment with 64-byte
    alignment is what you want. Here’s an example of such a segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The optional `class` field is a string (delimited by apostrophes and single
    quotes) that is typically one of the following names: `CODE`, `DATA`, or `CONST`.
    Note that MASM and the Microsoft linker will combine segments that have the same
    class name even if their segment names are different.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter presents examples of these segment declarations as they are needed.
  prefs: []
  type: TYPE_NORMAL
- en: 11.5 SSE, AVX, and AVX2 Memory Operand Alignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSE and AVX instructions typically allow access to a variety of memory operand
    sizes. The so-called scalar instructions, which operate on single data elements,
    can access byte-, word-, dword-, and qword-sized memory operands. In many respects,
    these types of memory accesses are similar to memory accesses by the non-SIMD
    instructions. The SSE, AVX, and AVX2 instruction set extensions also access *packed*
    or *vector* operands in memory. Unlike with the scalar memory operands, stringent
    rules limit the access of packed memory operands. This section discusses those
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: The SSE instructions can access up to 128 bits of memory (16 bytes) with a single
    instruction. Most multi-operand SSE instructions can specify an XMM register or
    a 128-bit memory operand as their source (second) operand. As a general rule,
    these memory operands must appear on a 16-byte-aligned address in memory (that
    is, the LO 4 bits of the memory address must contain 0s).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because segments have a default alignment of `para` (16 bytes), you can easily
    ensure that any 16-byte packed data objects are 16-byte-aligned by using the `align`
    directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: MASM will report an error if you attempt to use `align 16` in a segment you’ve
    defined with the `byte`, `word`, or `dword` alignment type. It will work properly
    with `para`, `page`, or any `align(``n``)` option where `n` is greater than or
    equal to 16.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using AVX instructions to access 256-bit (32-byte) memory operands,
    you must ensure that those memory operands begin on a 32-byte address boundary.
    Unfortunately, `align 32` won’t work, because the default segment alignment is
    `para` (16-byte) alignment, and the segment’s alignment must be greater than or
    equal to the operand field of any `align` directives appearing within that segment.
    Therefore, to be able to define 256-bit variables usable by AVX instructions,
    you must explicitly define a (data) segment that is aligned on a (minimum) 32-byte
    boundary, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Though it’s somewhat redundant to say this, it’s so important it’s worth repeating:'
  prefs: []
  type: TYPE_NORMAL
- en: Almost all AVX/AVX2 instructions will generate an alignment fault if you attempt
    to access a 256-bit object at an address that is not 32-byte-aligned. Always ensure
    that your AVX packed operands are properly aligned.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you are using the AVX2 extended instructions with 512-bit memory operands,
    you must ensure that those operands appear on an address in memory that is a multiple
    of 64 bytes. As for AVX instructions, you will have to define a segment that has
    an alignment greater than or equal to 64 bytes, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Forgive the redundancy, but it’s important to remember:'
  prefs: []
  type: TYPE_NORMAL
- en: Almost all AVX-512 instructions will generate an alignment fault if you attempt
    to access a 512-bit object at an address that is not 64-byte-aligned. Always ensure
    that your AVX-512 packed operands are properly aligned.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you’re using SSE, AVX, and AVX2 data types in the same application, you
    can create a single data segment to hold all these data values by using a 64-byte
    alignment option for the single section, instead of a segment for each data type
    size. Remember, the segment’s alignment has to be *greater than* or equal to the
    alignment required by the specific data type. Therefore, a 64-byte alignment will
    work fine for SSE and AVX/AVX2 variables, as well as AVX-512 variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you specify an alignment option that is much larger than you need (such as
    256-byte `page` alignment), you might unnecessarily waste memory.
  prefs: []
  type: TYPE_NORMAL
- en: The `align` directive works well when your SSE, AVX, and AVX2 data values are
    static or global variables. What happens when you want to create local variables
    on the stack or dynamic variables on the heap? Even if your program adheres to
    the Microsoft ABI, you’re guaranteed only 16-byte alignment on the stack upon
    entry to your program (or to a procedure). Similarly, depending on your heap management
    functions, there is no guarantee that a `malloc` (or similar) function returns
    an address that is properly aligned for SSE, AVX, or AVX2 data objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside a procedure, you can allocate storage for a 16-, 32-, or 64-byte-aligned
    variable by over-allocating the storage, adding the size minus 1 of the object
    to the allocated address, and then using the `and` instruction to zero out LO
    bits of the address (4 bits for 16-byte-aligned objects, 5 bits for 32-byte-aligned
    objects, and 6 bits for 64-byte-aligned objects). Then you reference the object
    by using this pointer. The following sample code demonstrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For data you allocate on the heap, you do the same thing: allocate extra storage
    (up to twice as many bytes minus 1), add the size of the object minus 1 (15, 31,
    or 63) to the address, and then mask the newly formed address with –64, –32, or
    –16 to produce a 64-, 32-, or 16-byte-aligned object, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 11.6 SIMD Data Movement Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The x86-64 CPUs provide a variety of data move instructions that copy data between
    (SSE/AVX) registers, load registers from memory, and store register values to
    memory. The following subsections describe each of these instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.1 The (v)movd and (v)movq Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the SSE instruction set, the `movd` (*move dword*) and `movq` (*move qword*)
    instructions copy the value from a 32- or 64-bit general-purpose register or memory
    location into the LO dword or qword of an XMM register:^([2](#c11-footnote-2))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: These instructions zero-extend the value to remaining HO bits in the XMM register,
    as shown in Figures 11-7 and 11-8.
  prefs: []
  type: TYPE_NORMAL
- en: '![f11007](image_fi/501089c11/f11007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-7: Moving a 32-bit value from memory to an XMM register (with zero
    extension)'
  prefs: []
  type: TYPE_NORMAL
- en: '![f11008](image_fi/501089c11/f11008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-8: Moving a 64-bit value from memory to an XMM register (with zero
    extension)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following instructions store the LO 32 or 64 bits of an XMM register into
    a dword or qword memory location or general-purpose register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `movq` instruction also allows you to copy data from the LO qword of one
    XMM register to another, but for whatever reason, the `movd` instruction does
    not allow two XMM register operands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For the AVX instructions, you use the following instructions:^([3](#c11-footnote-3))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The instructions with the XMM destination operands also zero-extend their values
    into the HO bits (up to bit 255, unlike the standard SSE instructions that do
    not modify the upper bits of the YMM registers).
  prefs: []
  type: TYPE_NORMAL
- en: Because the `movd` and `movq` instructions access 32- and 64-bit values in memory
    (rather than 128-, 256-, or 512-bit values), these instructions do not require
    their memory operands to be 16-, 32-, or 64-byte-aligned. Of course, the instructions
    may execute faster if their operands are dword (`movd`) or qword (`movq`) aligned
    in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.2 The (v)movaps, (v)movapd, and (v)movdqa Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `movaps` (*move aligned, packed single*), `movapd` (*move aligned, packed
    double*), and `movdqa` (*move double quad-word aligned*) instructions move 16
    bytes of data between memory and an XMM register or between two XMM registers.
    The AVX versions (with the `v` prefix) move 16 or 32 bytes between memory and
    an XMM or a YMM register or between two XMM or YMM registers (moves involving
    XMM registers zero out the HO bits of the corresponding YMM register). The memory
    locations must be aligned on a 16-byte or 32-byte boundary (respectively), or
    the CPU will generate an unaligned access fault.
  prefs: []
  type: TYPE_NORMAL
- en: All three `mov*` instructions load 16 bytes into an XMM register and are, in
    theory, interchangeable. In practice, Intel may optimize the operations for the
    type of data they move (single-precision floating-point values, double-precision
    floating-point values, or integer values), so it’s always a good idea to choose
    the appropriate instruction for the data type you are using (see “Performance
    Issues and the SIMD Move Instructions” on page 622 for an explanation). Likewise,
    all three `vmov*` instructions load 16 or 32 bytes into an XMM or a YMM register
    and are interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: 'These instructions take the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `mem`128 operand should be a vector (array) of four single-precision floating-point
    values for the `(v)movaps` instruction; it should be a vector of two double-precision
    floating-point values for the `(v)movapd` instruction; it should be a 16-byte
    value (16 bytes, 8 words, 4 dwords, or 2 qwords) when using the `(v)movdqa` instruction.
    If you cannot guarantee that the operands are aligned on a 16-byte boundary, use
    the `movups`, `movupd`, or `movdqu` instructions, instead (see the next section).
  prefs: []
  type: TYPE_NORMAL
- en: The `mem`256 operand should be a vector (array) of eight single-precision floating-point
    values for the `vmovaps` instruction; it should be a vector of four double-precision
    floating-point values for the `vmovapd` instruction; it should be a 32-byte value
    (32 bytes, 16 words, 8 dwords, or 4 qwords) when using the `vmovdqa` instruction.
    If you cannot guarantee that the operands are 32-byte-aligned, use the `vmovups`,
    `vmovupd`, or `vmovdqu` instructions instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the physical machine instructions themselves don’t particularly care
    about the data type of the memory operands, MASM’s assembly syntax certainly does
    care. You will need to use operand type coercion if the instruction doesn’t match
    one of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: The `movaps` instruction allows `real4`, `dword`, and `oword` operands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `movapd` instruction allows `real8`, `qword`, and `oword` operands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `movdqa` instruction allows only `oword` operands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `vmovaps` instruction allows `real4`, `dword`, and `ymmword ptr` operands
    (when using a YMM register).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `vmovapd` instruction allows `real8`, `qword`, and `ymmword ptr` operands
    (when using a YMM register).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `vmovdqa` instruction allows only `ymmword ptr` operands (when using a YMM
    register).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often you will see `memcpy` (*memory copy*) functions use the `(v)movapd` instructions
    for very high-performance operations. See Agner Fog’s website at [https://www.agner.org/optimize/](https://www.agner.org/optimize/)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.3 The (v)movups, (v)movupd, and (v)movdqu Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you cannot guarantee that packed data memory operands lie on a 16- or 32-byte
    address boundary, you can use the `(v)movups` (*move unaligned packed single-precision*),
    `(v)movupd` (*move unaligned packed* *double-precision*), and `(v)movdqu` (*move
    double quad-word* *unaligned*) instructions to move data between XMM or YMM registers
    and memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the aligned moves, all the unaligned moves do the same thing: copying
    16 (32) bytes of data to and from memory. The convention for the various data
    types is the same as it is for the aligned data movement instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.4 Performance of Aligned and Unaligned Moves
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Listings [11-3](#listing11-3) and [11-4](#listing11-4) provide sample programs
    that demonstrate the performance of the `mova*` and `movu*` instructions using
    aligned and unaligned memory accesses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-3: Aligned memory-access timing code'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-4: Unaligned memory-access timing code'
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 11-3](#listing11-3) took about 1 minute and 7 seconds to
    execute on a 3GHz Xeon W CPU. The code in [Listing 11-4](#listing11-4) took 1
    minute and 55 seconds to execute on the same processor. As you can see, there
    is sometimes an advantage to accessing SIMD data on an aligned address boundary.
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.5 The (v)movlps and (v)movlpd Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `(v)movl*` instructions and `(v)movh*` instructions (from the next section)
    might look like normal move instructions. Their behavior is similar to many other
    SSE/AVX move instructions. However, they were designed to support packing and
    unpacking floating-point vectors. Specifically, these instructions allow you to
    merge two pairs of single-precision or a pair of double-precision floating-point
    operands from two different sources into a single XMM register.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `(v)movlps` instructions use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `movlps` `xmm`dest`,` `mem`64 form copies a pair of single-precision floating-point
    values into the two LO 32-bit lanes of a destination XMM register, as shown in
    [Figure 11-9](#figure11-9). This instruction leaves the HO 64 bits unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '![f11009](image_fi/501089c11/f11009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-9: `movlps` instruction'
  prefs: []
  type: TYPE_NORMAL
- en: The `movlps` `mem`64`,` `xmm`src form copies the LO 64 bits (the two LO single-precision
    lanes) from the XMM source register to the specified memory location. Functionally,
    this is equivalent to the `movq` or `movsd` instructions (as it copies 64 bits
    to memory), though this instruction might be slightly faster if the LO 64 bits
    of the XMM register actually contain two single-precision values (see “Performance
    Issues and the SIMD Move Instructions” on page 622 for an explanation).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vmovlps` instruction has three operands: a destination XMM register, a
    source XMM register, and a source (64-bit) memory location. This instruction copies
    the two single-precision values from the memory location into the LO 64 bits of
    the destination XMM register. It copies the HO 64 bits of the source register
    (which also hold two single-precision values) into the HO 64 bits of the destination
    register. [Figure 11-10](#figure11-10) shows the operation. Note that this instruction
    merges the pair of operands with a single instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f11010](image_fi/501089c11/f11010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-10: `vmovlps` instruction'
  prefs: []
  type: TYPE_NORMAL
- en: Like `movsd`, the `movlpd` (*move low packed double*) instruction copies the
    LO 64 bits (a double-precision floating-point value) of the source operand to
    the LO 64 bits of the destination operand. The difference is that the `movlpd`
    instruction doesn’t zero-extend the value when moving data from memory into an
    XMM register, whereas the `movsd` instruction will zero-extend the value into
    the upper 64 bits of the destination XMM register. (Neither the `movsd` nor `movlpd`
    will zero-extend when copying data between XMM registers; of course, zero extension
    doesn’t apply when storing data to memory.)^([4](#c11-footnote-4))
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.6 The movhps and movhpd Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `movhps` and `movhpd` instructions move a 64-bit value (either two single-precision
    floats in the case of `movhps`, or a single double-precision value in the case
    of `movhpd`) into the HO quad word of a destination XMM register. [Figure 11-11](#figure11-11)
    shows the operation of the `movhps` instruction; [Figure 11-12](#figure11-12)
    shows the `movhpd` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '![f11011](image_fi/501089c11/f11011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-11: `movhps` instruction'
  prefs: []
  type: TYPE_NORMAL
- en: '![f11012](image_fi/501089c11/f11012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-12: `movhpd` instruction'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `movhps` and `movhpd` instructions can also store the HO quad word of an
    XMM register into memory. The allowable syntax is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: These instructions do not affect bits 128 to 255 of the YMM registers (if present
    on the CPU).
  prefs: []
  type: TYPE_NORMAL
- en: You would normally use a `movlps` instruction followed by a `movhps` instruction
    to load four single-precision floating-point values into an XMM register, taking
    the floating-point values from two different data sources (similarly, you could
    use the `movlpd` and `movhpd` instructions to load a pair of double-precision
    values into a single XMM register from different sources). Conversely, you could
    also use this instruction to split a vector result in half and store the two halves
    in different data streams. This is probably the intended purpose of this instruction.
    Of course, if you can use it for other purposes, have at it.
  prefs: []
  type: TYPE_NORMAL
- en: 'MASM (version 14.15.26730.0, at least) seems to require `movhps` operands to
    be a 64-bit data type and does not allow `real4` operands.^([5](#c11-footnote-5))
    Therefore, you may have to explicitly coerce an array of two `real4` values with
    `qword ptr` when using this instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 11.6.7 The vmovhps and vmovhpd Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although the AVX instruction extensions provide `vmovhps` and `vmovhpd` instructions,
    they are not a simple extension of the SSE `movhps` and `movhpd` instructions.
    The syntax for these instructions is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The instructions that store data into a 64-bit memory location behave similarly
    to the `movhps` and `movhpd` instructions. The instructions that load data into
    an XMM register have two source operands. They load a full 128 bits (four single-precision
    values or two double-precision values) into the destination XMM register. The
    HO 64 bits come from the memory operand; the LO 64 bits come from the LO quad
    word of the source XMM register, as [Figure 11-13](#figure11-13) shows. These
    instructions also zero-extend the value into the upper 128 bits of the (overlaid)
    YMM register.
  prefs: []
  type: TYPE_NORMAL
- en: '![f11013](image_fi/501089c11/f11013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-13: `vmovhpd` and `vmovhps` instructions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike for the `movhps` instruction, MASM properly accepts `real4` source operands
    for the `vmovhps` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 11.6.8 The movlhps and vmovlhps Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `movlhps` instruction moves a pair of 32-bit single-precision floating-point
    values from the LO qword of the source XMM register into the HO 64 bits of a destination
    XMM register. It leaves the LO 64 bits of the destination register unchanged.
    If the destination register is on a CPU that supports 256-bit AVX registers, this
    instruction also leaves the HO 128 bits of the overlaid YMM register unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for these instructions is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You cannot use this instruction to move data between memory and an XMM register;
    it transfers data only between XMM registers. No double-precision version of this
    instruction exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vmovlhps` instruction is similar to `movlhps`, with the following differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vmovlhps` requires three operands: two source XMM registers and a destination
    XMM register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vmovlhps` copies the LO quad word of the first source register into the LO
    quad word of the destination register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vmovlhps` copies the LO quad word of the second source register into bits
    64 to 127 of the destination register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vmovlhps` zero-extends the result into the upper 128 bits of the overlaid
    YMM register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no `vmovlhpd` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.9 The movhlps and vmovhlps Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `movhlps` instruction has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `movhlps` instruction copies the pair of 32-bit single-precision floating-point
    values from the HO qword of the source operand to the LO qword of the destination
    register, leaving the HO 64 bits of the destination register unchanged (this is
    the converse of `movlhps`). This instruction copies data only between XMM registers;
    it does not allow a memory operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vmovhlps` instruction requires three XMM register operands; here is its
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This instruction copies the HO 64 bits of the first source register into the
    HO 64 bits of the destination register, copies the HO 64 bits of the second source
    register into bits 0 to 63 of the destination register, and finally, zero-extends
    the result into the upper bits of the overlaid YMM register.
  prefs: []
  type: TYPE_NORMAL
- en: There are no `movhlpd` or `vmovhlpd` instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.10 The (v)movshdup and (v)movsldup Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `movshdup` instruction moves the two odd-index single-precision floating-point
    values from the source operand (memory or XMM register) and duplicates each element
    into the destination XMM register, as shown in [Figure 11-14](#figure11-14).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11014](image_fi/501089c11/f11014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-14: `movshdup` and `vmovshdup` instructions'
  prefs: []
  type: TYPE_NORMAL
- en: 'This instruction ignores the single-precision floating-point values at even-lane
    indexes into the XMM register. The `vmovshdup` instruction works the same way
    but on YMM registers, copying four single-precision values rather than two (and,
    of course, zeroing the HO bits). The syntax for these instructions is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `movsldup` instruction works just like the `movshdup` instruction, except
    it copies and duplicates the two single-precision values at even indexes in the
    source XMM register to the destination XMM register. Likewise, the `vmovsldup`
    instruction copies and duplicates the four double-precision values in the source
    YMM register at even indexes, as shown in [Figure 11-15](#figure11-15).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11015](image_fi/501089c11/f11015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-15: `movsldup` and `vmovsldup` instructions'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 11.6.11 The (v)movddup Instruction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `movddup` instruction copies and duplicates a double-precision value from
    the LO 64 bits of an XMM register or a 64-bit memory location into the LO 64 bits
    of a destination XMM register; then it also duplicates this value into bits 64
    to 127 of that same destination register, as shown in [Figure 11-16](#figure11-16).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11016](image_fi/501089c11/f11016.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-16: `movddup` instruction behavior'
  prefs: []
  type: TYPE_NORMAL
- en: 'This instruction does not disturb the HO 128 bits of a YMM register (if applicable).
    The syntax for this instruction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `vmovddup` instruction operates on an XMM or a YMM destination register
    and an XMM or a YMM source register or 128- or 256-bit memory location. The 128-bit
    version works just like the `movddup` instruction except it zeroes the HO bits
    of the destination YMM register. The 256-bit version copies a pair of double-precision
    values at even indexes (0 and 2) in the source value to their corresponding indexes
    in the destination YMM register and duplicates those values at the odd indexes
    in the destination, as [Figure 11-17](#figure11-17) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![f11017](image_fi/501089c11/f11017.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-17: `vmovddup` instruction behavior'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the syntax for this instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 11.6.12 The (v)lddqu Instruction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `(v)lddqu` instruction is operationally identical to `(v)movdqu`. You can
    sometimes use this instruction to improve performance if the (memory) source operand
    is not aligned properly and crosses a cache line boundary in memory. For more
    details on this instruction and its performance limitations, refer to the Intel
    or AMD documentation (specifically, the optimization manuals).
  prefs: []
  type: TYPE_NORMAL
- en: 'These instructions always take the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 11.6.13 Performance Issues and the SIMD Move Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you look at the SSE/AVX instructions’ semantics at the programming model
    level, you might question why certain instructions appear in the instruction set.
    For example, the `movq`, `movsd`, and `movlps` instructions can all load 64 bits
    from a memory location into the LO 64 bits of an XMM register. Why bother doing
    this? Why not have a single instruction that copies the 64 bits from a quad word
    in memory to the LO 64 bits of an XMM register (be it a 64-bit integer, a pair
    of 32-bit integers, a 64-bit double-precision floating-point value, or a pair
    of 32-bit single-precision floating-point values)? The answer lies in the term
    *microarchitecture*.
  prefs: []
  type: TYPE_NORMAL
- en: The x86-64 *macroarchitecture* is the programming model that a software engineer
    sees. In the macroarchitecture, an XMM register is a 128-bit resource that, at
    any given time, could hold a 128-bit array of bits (or an integer), a pair of
    64-bit integer values, a pair of 64-bit double-precision floating-point values,
    a set of four single-precision floating-point values, a set of four double-word
    integers, eight words, or 16 bytes. All these data types overlay one another,
    just like the 8-, 16-, 32-, and 64-bit general-purpose registers overlay one another
    (this is known as *aliasing*). If you load two double-precision floating-point
    values into an XMM register and then modify the (integer) word at bit positions
    0 to 15, you’re also changing those same bits (0 to 15) in the double-precision
    value in the LO qword of the XMM register. The semantics of the x86-64 programming
    model require this.
  prefs: []
  type: TYPE_NORMAL
- en: At the microarchitectural level, however, there is no requirement that the CPU
    use the same physical bits in the CPU for integer, single-precision, and double-precision
    values (even when they are aliased to the same register). The microarchitecture
    could set aside a separate set of bits to hold integers, single-precision, and
    double-precision values for a single register. So, for example, when you use the
    `movq` instruction to load 64 bits into an XMM register, that instruction might
    actually copy the bits into the underlying integer register (without affecting
    the single-precision or double-precision subregisters). Likewise, `movlps` would
    copy a pair of single-precision values into the single-precision register, and
    `movsd` would copy a double-precision value into the double-precision register
    ([Figure 11-18](#figure11-18)). These separate subregisters (integer, single-precision,
    and double-precision) could be connected directly to the arithmetic or logical
    unit that handles their specific data types, making arithmetic and logical operations
    on those subregisters more efficient. As long as the data is sitting in the appropriate
    subregister, everything works smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '![f11018](image_fi/501089c11/f11018.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-18: Register aliasing at the microarchitectural level'
  prefs: []
  type: TYPE_NORMAL
- en: However, what happens if you use `movq` to load a pair of single-precision floating-point
    values into an XMM register and then try to perform a single-precision vector
    operation on those two values? At the macroarchitectural level, the two single-precision
    values are sitting in the appropriate bit positions of the XMM register, so this
    has to be a legal operation. At the microarchitectural level, however, those two
    single-precision floating-point values are sitting in the integer subregister,
    not the single-precision subregister. The underlying microarchitecture has to
    note that the values are in the wrong subregister and move them to the appropriate
    (single-precision) subregister before performing the single-precision arithmetic
    or logical operation. This may introduce a slight delay (while the microarchitecture
    moves the data around), which is why you should always pick the appropriate move
    instructions for your data types.
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.14 Some Final Comments on the SIMD Move Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SIMD data movement instructions are a confusing bunch. Their syntax is inconsistent,
    many instructions duplicate the actions of other instructions, and they have some
    perplexing irregularity issues. Someone new to the x86-64 instruction set might
    ask, “Why was the instruction set designed this way?” Why, indeed?
  prefs: []
  type: TYPE_NORMAL
- en: The answer to that question is historical. The SIMD instructions did not exist
    on the earliest x86 CPUs. Intel added the MMX instruction set to the Pentium-series
    CPUs. At that time (the early 1990s), current technology allowed Intel to add
    only a few additional instructions, and the MMX registers were limited to 64 bits
    in size. Furthermore, software engineers and computer systems designers were only
    beginning to explore the multimedia capabilities of modern computers, so it wasn’t
    entirely clear which instructions (and data types) were necessary to support the
    type of software we see several decades later. As a result, the earliest SIMD
    instructions and data types were limited in scope.
  prefs: []
  type: TYPE_NORMAL
- en: As time passed, CPUs gained additional silicon resources, and software/systems
    engineers discovered new uses for computers (and new algorithms to run on those
    computers), so Intel (and AMD) responded by adding new SIMD instructions to support
    these more modern multimedia applications. The original MMX instructions, for
    example, supported only integer data types, so Intel added floating-point support
    in the SSE instruction set, because multimedia applications needed real data types.
    Then Intel extended the integer types from 64 bits to 128, 256, and even 512 bits.
    With each extension, Intel (and AMD) had to retain the older instruction set extensions
    in order to allow preexisting software to run on the new CPUs.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the newer instruction sets kept piling on new instructions that
    did the same work as the older ones (with some additional capabilities). This
    is why instructions like `movaps` and `vmovaps` have considerable overlap in their
    functionality. If the CPU resources had been available earlier (for example, to
    put 256-bit YMM registers on the CPU), there would have been almost no need for
    the `movaps` instruction—the `vmovaps` could have done all the work.^([6](#c11-footnote-6))
  prefs: []
  type: TYPE_NORMAL
- en: 'In theory, we could create an architecturally elegant variant of the x86-64
    by starting over from scratch and designing a minimal instruction set that handles
    all the activities of the current x86-64 without all the kruft and kludges present
    in the existing instruction set. However, such a CPU would lose the primary advantage
    of the x86-64: the ability to run decades of software written for the Intel architecture.
    The cost of being able to run all this old software is that assembly language
    programmers (and compiler writers) have to deal with all these irregularities
    in the instruction set.'
  prefs: []
  type: TYPE_NORMAL
- en: 11.7 The Shuffle and Unpack Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SSE/AVX *shuffle and unpack instructions* are variants of the move instructions.
    In addition to moving data around, these instructions can also rearrange the data
    appearing in different lanes of the XMM and YMM registers.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.1 The (v)pshufb Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `pshufb` instruction was the first packed byte shuffle SIMD instruction
    (it first appeared with the MMX instruction set). Because of its origin, its syntax
    and behavior are a bit different from the other shuffle instructions in the instruction
    set. The syntax is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first (destination) operand is an XMM register whose byte lanes `pshufb`
    will shuffle (rearrange). The second operand (either an XMM register or a 128-bit
    oword memory location) is an array of 16 byte values holding indexes that control
    the shuffle operation. If the second operand is a memory location, that oword
    value must be aligned on a 16-byte boundary.
  prefs: []
  type: TYPE_NORMAL
- en: Each byte (lane) in the second operand selects a value for the corresponding
    byte lane in the first operand, as shown in [Figure 11-19](#figure11-19).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11019](image_fi/501089c11/f11019.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-19: Lane index correspondence for `pshufb` instruction'
  prefs: []
  type: TYPE_NORMAL
- en: The 16-byte indexes in the second operand each take the form shown in [Figure
    11-20](#figure11-20).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11020](image_fi/501089c11/f11020.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-20: `phsufb` byte index'
  prefs: []
  type: TYPE_NORMAL
- en: The `pshufb` instruction ignores bits 4 to 6 in an index byte. Bit 7 is the
    clear bit; if this bit contains a 1, the `pshufb` instruction ignores the lane
    index bits and stores a 0 into the corresponding byte in XMM[dest]. If the clear
    bit contains a 0, the `pshufb` instruction does a shuffle operation.
  prefs: []
  type: TYPE_NORMAL
- en: The `pshufb` shuffle operation takes place on a lane-by-lane basis. The instruction
    first makes a temporary copy of XMM[dest]. Then for each index byte (whose HO
    bit is 0), the `pshufb` copies the lane specified by the LO 4 bits of the index
    from the XMM[dest] lane that matches the index’s lane, as shown in [Figure 11-21](#figure11-21).
    In this example, the index appearing in lane 6 contains the value 00000011b. This
    selects the value in lane 3 of the temporary (original XMM[dest]) value and copies
    it to lane 6 of XMM[dest]. The `pshufb` instruction repeats this operation for
    all l6 lanes.
  prefs: []
  type: TYPE_NORMAL
- en: '![f11021](image_fi/501089c11/f11021.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-21: Shuffle operation'
  prefs: []
  type: TYPE_NORMAL
- en: 'The AVX instruction set extensions introduced the `vpshufb` instruction. Its
    syntax is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The AVX variant adds a source register (rather than using XMM[dest] as both
    the source and destination registers), and, rather than creating a temporary copy
    of XMM[dest] prior to the operation and picking the values from that copy, the
    `vpshufb` instructions select the source bytes from the XMM[src] register. Other
    than that, and the fact that these instructions zero the HO bits of YMM[dest],
    the 128-bit variant operates identically to the SSE `pshufb` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: The AVX instruction allows you to specify 256-bit YMM registers in addition
    to 128-bit XMM registers.^([7](#c11-footnote-7))
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.2 The (v)pshufd Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The SSE extensions first introduced the `pshufd` instruction. The AVX extensions
    added the `vpshufd` instruction. These instructions shuffle dwords in XMM and
    YMM registers (*not* double-precision values) similarly to the `(v)pshufb` instructions.
    However, the shuffle index is specified differently from `(v)pshufb`. The syntax
    for the `(v)pshufd` instructions is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The first operand (XMM[dest] or YMM[dest]) is the destination operand where
    the shuffled values will be stored. The second operand is the source from which
    the instruction will select the double words to place in the destination register;
    as usual, if this is a memory operand, you must align it on the appropriate (16-
    or 32-byte) boundary. The third operand is an 8-bit immediate value that specifies
    the indexes for the double words to select from the source operand.
  prefs: []
  type: TYPE_NORMAL
- en: For the `(v)pshufd` instructions with an XMM[dest] operand, the imm[8] operand
    has the encoding shown in [Table 11-3](#table11-3). The value in bits 0 to 1 selects
    a particular dword from the source operand to place in dword 0 of the XMM[dest]
    operand. The value in bits 2 to 3 selects a dword from the source operand to place
    in dword 1 of the XMM[dest] operand. The value in bits 4 to 5 selects a dword
    from the source operand to place in dword 2 of the XMM[dest] operand. Finally,
    the value in bits 6 to 7 selects a dword from the source operand to place in dword
    3 of the XMM[dest] operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-3: `(v)pshufd` imm[8] Operand Values'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit positions** | **Destination lane** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 to 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 to 3 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 to 5 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 to 7 | 3 |'
  prefs: []
  type: TYPE_TB
- en: The difference between the 128-bit `pshufd` and `vpshufd` instructions is that
    `pshufd` leaves the HO 128 bits of the underlying YMM register unchanged and `vpshufd`
    zeroes the HO 128 bits of the underlying YMM register.
  prefs: []
  type: TYPE_NORMAL
- en: The 256-bit variant of `vpshufd` (when using YMM registers as the source and
    destination operands) still uses an 8-bit immediate operand as the index value.
    Each 2-bit index value manipulates two dword values in the YMM registers. Bits
    0 to 1 control dwords 0 and 4, bits 2 to 3 control dwords 1 and 5, bits 4 to 5
    control dwords 2 and 6, and bits 6 to 7 control dwords 3 and 7, as shown in [Table
    11-4](#table11-4).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-4: Double-Word Transfers for `vpshufd` YMM[dest], YMM[src]/mem[src],
    imm[8]'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Index** | **YMM/mem[src] [index] copied into** | **YMM/mem[src] [index
    + 4] copied into** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Bits 0 to 1 of imm[8] | YMM[dest][0] | YMM[dest][4] |'
  prefs: []
  type: TYPE_TB
- en: '| Bits 2 to 3 of imm[8] | YMM[dest][1] | YMM[dest][5] |'
  prefs: []
  type: TYPE_TB
- en: '| Bits 4 to 5 of imm[8] | YMM[dest][2] | YMM[dest][6] |'
  prefs: []
  type: TYPE_TB
- en: '| Bits 6 to 7 of imm[8] | YMM[dest][3] | YMM[dest][7] |'
  prefs: []
  type: TYPE_TB
- en: The 256-bit version is slightly less flexible as it copies two dwords at a time,
    rather than one. It processes the LO 128 bits exactly the same way as the 128-bit
    version of the instruction; it also copies the corresponding lanes in the upper
    128 bits of the source to the YMM destination register by using the same shuffle
    pattern. Unfortunately, you can’t independently control the HO and LO halves of
    the YMM register by using the `vpshufd` instruction. If you really need to shuffle
    dwords independently, you can use `vshufb` with appropriate indexes that copy
    4 bytes (in place of a single dword).
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.3 The (v)pshuflw and (v)pshufhw Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `pshuflw` and `vpshuflw` and the `pshufhw` and `vpshufhw` instructions
    provide support for 16-bit word shuffles within an XMM or a YMM register. The
    syntax for these instructions is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The 128-bit `lw` variants copy the HO 64 bits of the source operand to the same
    positions in the XMM[dest] operand. Then they use the index (imm[8]) operand to
    select word lanes 0 to 3 in the LO qword of the XMM[src]/mem[128] operand to move
    to the LO 4 lanes of the destination operand. For example, if the LO 2 bits of
    imm[8] are 10b, then the `pshuflw` instruction copies lane 2 from the source into
    lane 0 of the destination operand ([Figure 11-22](#figure11-22)). Note that `pshuflw`
    does not modify the HO 128 bits of the overlaid YMM register, whereas `vpshuflw`
    zeroes those HO bits.
  prefs: []
  type: TYPE_NORMAL
- en: '![f11022](image_fi/501089c11/f11022.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-22: `(v)pshuflw` `xmm``,` `xmm``/``mem``,` `imm`8 operation'
  prefs: []
  type: TYPE_NORMAL
- en: The 256-bit `vpshuflw` instruction (with a YMM destination register) copies
    two pairs of words at a time—one pair in the HO 128 bits and one pair in the LO
    128 bits of the YMM destination register and 256-bit source locations, as shown
    in [Figure 11-23](#figure11-23). The index (imm[8]) selection is the same for
    the LO and HO 128 bits.
  prefs: []
  type: TYPE_NORMAL
- en: '![f11023](image_fi/501089c11/f11023.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-23: `vpshuflw` `ymm``,` `ymm``/``mem``,` `imm`8 operation'
  prefs: []
  type: TYPE_NORMAL
- en: The 128-bit `hw` variants copy the LO 64 bits of the source operand to the same
    positions in the destination operand. Then they use the index operand to select
    words 4 to 7 (indexed as 0 to 3) in the 128-bit source operand to move to the
    HO four word lanes of the destination operand ([Figure 11-24](#figure11-24)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11024](image_fi/501089c11/f11024.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-24: `(v)pshufhw` operation'
  prefs: []
  type: TYPE_NORMAL
- en: The 256-bit `vpshufhw` instruction (with a YMM destination register) copies
    two pairs of words at a time—one in the HO 128 bits and one in the LO 128 bits
    of the YMM destination register and 256-bit source locations, as shown in [Figure
    11-25](#figure11-25).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11025](image_fi/501089c11/f11025.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-25: `vpshufhw` operation'
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.4 The shufps and shufpd Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The shuffle instructions (`shufps` and `shufpd`) extract single- or double-precision
    values from the source operands and place them in specified positions in the destination
    operand. The third operand, an 8-bit immediate value, selects which values to
    extract from the source to move into the destination register. The syntax for
    these two instructions is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: For the `shufps` instruction, the second source operand is an 8-bit immediate
    value that is actually a four-element array of 2-bit values.
  prefs: []
  type: TYPE_NORMAL
- en: imm[8] bits 0 and 1 select a single-precision value from one of the four lanes
    in the XMM[src1/dest] operand to store into lane 0 of the destination operation.
    Bits 2 and 3 select a single-precision value from one of the four lanes in the
    XMM[src1/dest] operand to store into lane 1 of the destination operation (the
    destination operand is also XMM[src1/dest]).
  prefs: []
  type: TYPE_NORMAL
- en: imm[8] bits 4 and 5 select a single-precision value from one of the four lanes
    in the XMM[src2]/mem[src2] operand to store into lane 2 of the destination operation.
    Bits 6 and 7 select a single-precision value from one of the four lanes in the
    XMM[src2]/mem[src2] operand to store into lane 3 of the destination operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-26](#figure11-26) shows the operation of the `shufps` instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f11026](image_fi/501089c11/f11026.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-26: `shufps` operation'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'loads XMM0 with the following single-precision values:'
  prefs: []
  type: TYPE_NORMAL
- en: XMM0[0 to 31] from XMM0[0 to 32]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XMM0[32 to 63] from XMM0[32 to 63]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XMM0[64 to 95] from XMM1[63 to 95]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XMM0[96 to 127] from XMM1[96 to 127]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the second operand (XMM[src2]/mem[src2]) is the same as the first operand
    (XMM[src1/dest]), it’s possible to rearrange the four single-precision values
    in the XMM[dest] register (which is probably the source of the instruction name
    *shuffle*).
  prefs: []
  type: TYPE_NORMAL
- en: The `shufpd` instruction works similarly, shuffling double-precision values.
    As there are only two double-precision values in an XMM register, it takes only
    a single bit to choose between the values. Likewise, as there are only two double-precision
    values in the destination register, the instruction requires only two (single-bit)
    array elements to choose the destination. As a result, the third operand, the
    imm[8] value, is actually just a 2-bit value; the instruction ignores bits 2 to
    7 in the imm[8] operand. Bit 0 of the imm[8] operand selects either lane 0 and
    bits 0 to 63 (if it is 0) or lane 1 and bits 64 to 127 (if it is 1) from the XMM[src1/dest]
    operand to place into lane 0 and bits 0 to 63 of XMM[dest]. Bit 1 of the imm[8]
    operand selects either lane 0 and bits 0 to 63 (if it is 0) or lane 1 and bits
    64 to 127 (if it is 1) from the XMM[src]/mem[128] operand to place into lane 1
    and bits 64 to 127 of XMM[dest]. [Figure 11-27](#figure11-27) shows this operation.
  prefs: []
  type: TYPE_NORMAL
- en: '![f11027](image_fi/501089c11/f11027.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-27: `shufpd` operation'
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.5 The vshufps and vshufpd Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `vshufps` and `vshufpd` instructions are similar to `shufps` and `shufpd`.
    They allow you to shuffle the values in 128-bit XMM registers or 256-bit YMM registers.^([8](#c11-footnote-8))
    The `vshufps` and `vshufpd` instructions have four operands: a destination XMM
    or YMM register, two source operands (src[1] must be an XMM or a YMM register,
    and src[2] can be an XMM or a YMM register or a 128- or 256-bit memory location),
    and an imm[8] operand. Their syntax is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Whereas the SSE shuffle instructions use the destination register as an implicit
    source operand, the AVX shuffle instructions allow you to specify explicit destination
    and source operands (they can all be different, or all the same, or any combination
    thereof).
  prefs: []
  type: TYPE_NORMAL
- en: For the 256-bit `vshufps` instructions, the imm[8] operand is an array of four
    2-bit values (bits 0:1, 2:3, 4:5, and 6:7). These 2-bit values select one of four
    single-precision values from the source locations, as described in [Table 11-5](#table11-5).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-5: `vshufps` Destination Selection'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Destination** | **imm[8] value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **imm[8] bits** |  | **00** | **01** | **10** | **11** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 76 54 32 **10** | Dest[0 to 31] | Src[1][0 to 31] | Src[1][32 to 63] | Src[1][64
    to 95] | Src[1][96 to 127] |'
  prefs: []
  type: TYPE_TB
- en: '|  | Dest[128 to 159] | Src[1][128 to 159] | Src[1][160 to 191] | Src[1][192
    to 223] | Src[1][224 to 255] |'
  prefs: []
  type: TYPE_TB
- en: '| 76 54 **32** 10 | Dest[32 to 63] | Src[1][0 to 31] | Src[1][32 to 63] | Src[1][64
    to 95] | Src[1][96 to 127] |'
  prefs: []
  type: TYPE_TB
- en: '|  | Dest[160 to 191] | Src[1][128 to 159] | Src[1][160 to 191] | Src[1][192
    to 223] | Src[1][224 to 255] |'
  prefs: []
  type: TYPE_TB
- en: '| 76 **54** 32 10 | Dest[64 to 95] | Src[2][0 to 31] | Src[2][32 to 63] | Src[2][64
    to 95] | Src[2][96 to 127] |'
  prefs: []
  type: TYPE_TB
- en: '|  | Dest[192 to 223] | Src[2][128 to 159] | Src[2][160 to 191] | Src[2][192
    to 223] | Src[2][224 to 255] |'
  prefs: []
  type: TYPE_TB
- en: '| **76** 54 32 10 | Dest[96 to 127] | Src[2][0 to 31] | Src[2][32 to 63] |
    Src[2][64 to 95] | Src[2][96 to 127] |'
  prefs: []
  type: TYPE_TB
- en: '|  | Dest[224 to 255] | Src[2][128 to 159] | Src[2][160 to 191] | Src[2][192
    to 223] | Src[2][224 to 255] |'
  prefs: []
  type: TYPE_TB
- en: If both source operands are the same, you can shuffle around the single-precision
    values in any order you choose (and if the destination and both source operands
    are the same, you can arbitrarily shuffle the dwords within that register).
  prefs: []
  type: TYPE_NORMAL
- en: The `vshufps` instruction also allows you to specify XMM and 128-bit memory
    operands. In this form, it behaves quite similarly to the `shufps` instruction
    except that you get to specify two different 128-bit source operands (rather than
    only one 128-bit source operand), and it zeroes the HO 128 bits of the corresponding
    YMM register. If the destination operand is different from the first source operand,
    this can be useful. If the `vshufps`’s first source operand is the same XMM register
    as the destination operand, you should use the `shufps` instruction as its machine
    encoding is shorter.
  prefs: []
  type: TYPE_NORMAL
- en: The `vshufpd` instruction is an extension of `shufpd` to 256 bits (plus the
    addition of a second source operand). As there are four double-precision values
    present in a 256-bit YMM register, `vshufpd` needs 4 bits to select the source
    indexes (rather than the 2 bits that `shufpd` requires). [Table 11-6](#table11-6)
    describes how `vshufpd` copies the data from the source operands to the destination
    operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-6: `vshufpd` Destination Selection'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Destination** | **imm[8] value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **imm[8] bits** |  | **0** | **1** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 7654 3 2 1 **0** | Dest[0 to 63] | Src[1][0 to 63] | Src[1][64 to 127] |'
  prefs: []
  type: TYPE_TB
- en: '| 7654 3 2 **1** 0 | Dest[64 to 127] | Src[2][0 to 63] | Src[2][64 to 127]
    |'
  prefs: []
  type: TYPE_TB
- en: '| 7654 3 **2** 1 0 | Dest[128 to 191] | Src[1][128 to 191] | Src[1][192 to
    255] |'
  prefs: []
  type: TYPE_TB
- en: '| 7654 **3** 2 1 0 | Dest[192 to 255] | Src[2][128 to 191] | Src[2][192 to
    255] |'
  prefs: []
  type: TYPE_TB
- en: Like the `vshufps` instruction, `vshufpd` also allows you to specify XMM registers
    if you want a three-operand version of `shufpd`.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.6 The (v)unpcklps, (v)unpckhps, (v)unpcklpd, and (v)unpckhpd Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The unpack (and merge) instructions are a simplified variant of the shuffle
    instructions. These instructions copy single- and double-precision values from
    fixed locations in their source operands and insert those values into fixed locations
    in the destination operand. They are, essentially, shuffle instructions without
    the imm[8] operand and with fixed shuffle patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `unpcklps` and `unpckhps` instructions choose half their single-precision
    operands from one of two sources, merge these values (interleaving them), and
    then store the merged result into the destination operand (which is the same as
    the first source operand). The syntax for these two instructions is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The XMM[dest] operand serves as both the first source operand and the destination
    operand. The XMM[src]/mem[128] operand is the second source operand.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the two is the way they select their source operands.
    The `unpcklps` instruction copies the two LO single-precision values from the
    source operand to bit positions 32 to 63 (dword 1) and 96 to 127 (dword 3). It
    leaves dword 0 in the destination operand alone and copies the value originally
    in dword 1 to dword 2 in the destination. [Figure 11-28](#figure11-28) diagrams
    this operation.
  prefs: []
  type: TYPE_NORMAL
- en: '![f11028](image_fi/501089c11/f11028.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-28: `unpcklps` instruction operation'
  prefs: []
  type: TYPE_NORMAL
- en: The `unpckhps` instruction copies the two HO single-precision values from the
    two sources to the destination register, as shown in [Figure 11-29](#figure11-29).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11029](image_fi/501089c11/f11029.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-29: `unpckhps` instruction operation'
  prefs: []
  type: TYPE_NORMAL
- en: The `unpcklpd` and `unpckhpd` instructions do the same thing as `unpcklps` and
    `unpckhps` except, of course, they operate on double-precision values rather than
    single-precision values. Figures 11-30 and 11-31 show the operation of these two
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '![f11030](image_fi/501089c11/f11030.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-30: `unpcklpd` instruction operation'
  prefs: []
  type: TYPE_NORMAL
- en: '![f11031](image_fi/501089c11/f11031.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-31: `unpckhpd` instruction operation'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vunpcklps`, `vunpckhps`, `vunpcklpd`, and `vunpckhpd` instructions have
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'They work similarly to the non-`v` variants, with a couple of differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The AVX variants support using the YMM registers as well as the XMM registers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AVX variants require three operands. The first (destination) and second
    (source[1]) operands must be XMM or YMM registers. The third (source[2]) operand
    can be an XMM or a YMM register or a 128- or 256-bit memory location. The two-operand
    form is just a special case of the three-operand form, where the first and second
    operands specify the same register name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 128-bit variants zero out the HO bits of the YMM register rather than leaving
    those bits unchanged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course, the AVX instructions with the YMM registers interleave twice as
    many single- or double-precision values. The interleaving extension happens in
    the intuitive way, with `vunpcklps` ([Figure 11-32](#figure11-32)):'
  prefs: []
  type: TYPE_NORMAL
- en: The single-precision values in source[1], bits 0 to 31, are first written to
    bits 0 to 31 of the destination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-precision values in source[2], bits 0 to 31, are written to bits
    32 to 63 of the destination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-precision values in source[1], bits 32 to 63, are written to bits
    64 to 95 of the destination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-precision values in source[2], bits 32 to 63, are written to bits
    96 to 127 of the destination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-precision values in source[1], bits 128 to 159, are first written
    to bits 128 to 159 of the destination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-precision values in source[2], bits 128 to 159, are written to bits
    160 to 191 of the destination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-precision values in source[1], bits 160 to 191, are written to bits
    192 to 223 of the destination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-precision values in source[2], bits 160 to 191, are written to bits
    224 to 256 of the destination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![f11032](image_fi/501089c11/f11032.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-32: `vunpcklps` instruction operation'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vunpckhps` instruction ([Figure 11-33](#figure11-33)) does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The single-precision values in source[1], bits 64 to 95, are first written to
    bits 0 to 31 of the destination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-precision values in source[2], bits 64 to 95, are written to bits
    32 to 63 of the destination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-precision values in source[1], bits 96 to 127, are written to bits
    64 to 95 of the destination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-precision values in source[2], bits 96 to 127, are written to bits
    96 to 127 of the destination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![f11033](image_fi/501089c11/f11033.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-33: `vunpckhps` instruction operation'
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, `vunpcklpd` and `vunpckhpd` move double-precision values.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.7 The Integer Unpack Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `punpck*` instructions provide a set of integer unpack instructions to complement
    the floating-point variants. These instructions appear in [Table 11-7](#table11-7).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-7: Integer Unpack Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `punpcklbw` | Unpacks low bytes to words |'
  prefs: []
  type: TYPE_TB
- en: '| `punpckhbw` | Unpacks high bytes to words |'
  prefs: []
  type: TYPE_TB
- en: '| `punpcklwd` | Unpacks low words to dwords |'
  prefs: []
  type: TYPE_TB
- en: '| `punpckhwd` | Unpacks high words to dwords |'
  prefs: []
  type: TYPE_TB
- en: '| `punpckldq` | Unpacks low dwords to qwords |'
  prefs: []
  type: TYPE_TB
- en: '| `punpckhdq` | Unpacks high dwords to qwords |'
  prefs: []
  type: TYPE_TB
- en: '| `punpcklqdq` | Unpacks low qwords to owords (double qwords) |'
  prefs: []
  type: TYPE_TB
- en: '| `punpckhqdq` | Unpacks high qwords to owords (double qwords) |'
  prefs: []
  type: TYPE_TB
- en: 11.7.7.1 The punpck* Instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `punpck*` instructions extract half the bytes, words, dwords, or qwords
    from two different sources and merge these values into a destination SSE register.
    The syntax for these instructions is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Figures 11- 34 through 11-41 show the data transfers for each of these instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '![f11034](image_fi/501089c11/f11034.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-34: `punpcklbw` instruction operation'
  prefs: []
  type: TYPE_NORMAL
- en: '![f11035](image_fi/501089c11/f11035.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-35: `punpckhbw` operation'
  prefs: []
  type: TYPE_NORMAL
- en: '![f11036](image_fi/501089c11/f11036.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-36: `punpcklwd` operation'
  prefs: []
  type: TYPE_NORMAL
- en: '![f11037](image_fi/501089c11/f11037.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-37: `punpckhwd` operation'
  prefs: []
  type: TYPE_NORMAL
- en: '![f11038](image_fi/501089c11/f11038.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-38: `punpckldq` operation'
  prefs: []
  type: TYPE_NORMAL
- en: '![f11039](image_fi/501089c11/f11039.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-39: `punpckhdq` operation'
  prefs: []
  type: TYPE_NORMAL
- en: '![f11040](image_fi/501089c11/f11040.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-40: `punpcklqdq` operation'
  prefs: []
  type: TYPE_NORMAL
- en: '![f11041](image_fi/501089c11/f11041.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-41: `punpckhqdq` operation'
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.7.2 The vpunpck* SSE Instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The AVX `vpunpck*` instructions provide a set of AVX integer unpack instructions
    to complement the SSE variants. These instructions appear in [Table 11-8](#table11-8).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-8: AVX Integer Unpack Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `vpunpcklbw` | Unpacks low bytes to words |'
  prefs: []
  type: TYPE_TB
- en: '| `vpunpckhbw` | Unpacks high bytes to words |'
  prefs: []
  type: TYPE_TB
- en: '| `vpunpcklwd` | Unpacks low words to dwords |'
  prefs: []
  type: TYPE_TB
- en: '| `vpunpckhwd` | Unpacks high words to dwords |'
  prefs: []
  type: TYPE_TB
- en: '| `vpunpckldq` | Unpacks low dwords to qwords |'
  prefs: []
  type: TYPE_TB
- en: '| `vpunpckhdq` | Unpacks high dwords to qwords |'
  prefs: []
  type: TYPE_TB
- en: '| `vpunpcklqdq` | Unpacks low qwords to owords (double qwords) |'
  prefs: []
  type: TYPE_TB
- en: '| `vpunpckhqdq` | Unpacks high qwords to owords (double qwords) |'
  prefs: []
  type: TYPE_TB
- en: 'The `vpunpck*` instructions extract half the bytes, words, dwords, or qwords
    from two different sources and merge these values into a destination AVX or SSE
    register. Here is the syntax for the SSE forms of these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Functionally, the only difference between these AVX instructions (`vunpck*`)
    and the SSE (`unpck*`) instructions is that the SSE variants leave the upper bits
    of the YMM AVX registers (bits 128 to 255) unchanged, whereas the AVX variants
    zero-extend the result to 256 bits. See Figures 11-34 through 11-41 for a description
    of the operation of these instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.7.3 The vpunpck* AVX Instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The AVX `vunpck*` instructions also support the use of the AVX YMM registers,
    in which case the unpack and merge operation extends from 128 bits to 256 bits.
    The syntax for these instructions is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 11.7.8 The (v)pextrb, (v)pextrw, (v)pextrd, and (v)pextrq Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `(v)pextrb`, `(v)pextrw`, `(v)pextrd`, and `(v)pextrq` instructions extract
    a byte, word, dword, or qword from a 128-bit XMM register and copy this data to
    a general-purpose register or memory location. The syntax for these instructions
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The byte and word instructions expect a 32- or 64-bit general-purpose register
    as their destination (first operand) or a memory location that is the same size
    as the instruction (that is, `pextrb` expects a byte-sized memory operand, `pextrw`
    expects a word-sized operand, and so on). The source (second) operand is a 128-bit
    XMM register. The index (third) operand is an 8-bit immediate value that specifies
    an index (lane number). These instructions fetch the byte, word, dword, or qword
    in the lane specified by the 8-bit immediate value and copy that value into the
    destination operand. The double-word and quad-word variants require a 32-bit or
    64-bit general-purpose register, respectively. If the destination operand is a
    32- or 64-bit general-purpose register, the instruction zero-extends the value
    to 32 or 64 bits, if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.9 The (v)pinsrb, (v)pinsrw, (v)pinsrd, and (v)pinsrq Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `(v)pinsr{b,w,d,q}` instructions take a byte, word, dword, or qword from
    a general-purpose register or memory location and store that data to a lane of
    an XMM register. The syntax for these instructions is the following:^([9](#c11-footnote-9))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The destination (first) operand is a 128-bit XMM register. The `pinsr*` instructions
    expect a memory location or a 32-bit general-purpose register as their source
    (second) operand (except the `pinsrq` instructions, which require a 64-bit register).
    The index (third) operand is an 8-bit immediate value that specifies an index
    (lane number).
  prefs: []
  type: TYPE_NORMAL
- en: These instructions fetch a byte, word, dword, or qword from the general-purpose
    register or memory location and copy that to the lane in the XMM register specified
    by the 8-bit immediate value. The `pinsr{b,w,d,q}` instructions leave any HO bits
    in the underlying YMM register unchanged (if applicable).
  prefs: []
  type: TYPE_NORMAL
- en: The `vpinsr{b,w,d,q}` instructions copy the data from the XMM source register
    into the destination register and then copy the byte, word, dword, or quad word
    to the specified location in the destination register. These instructions zero-extend
    the value throughout the HO bits of the underlying YMM register.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.10 The (v)extractps and (v)insertps Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `extractps` and `vextractps` instructions are functionally equivalent to
    `pextrd` and `vpextrd`. They extract a 32-bit (single-precision floating-point)
    value from an XMM register and move it into a 32-bit general-purpose register
    or a 32-bit memory location. The syntax for the `(v)extractps` instructions is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `insertps` and `vinsertps` instructions insert a 32-bit floating-point
    value into an XMM register and, optionally, zero out other lanes in the XMM register.
    The syntax for these instructions is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: For the `insertps` and `vinsertps` instructions, the imm[8] operand has the
    fields listed in [Table 11-9](#table11-9).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-9: imm[8] Bit Fields for `insertps` and `vinsertps` Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit(s)** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 6 to 7 | (Only if the source operand is an XMM register): Selects the 32-bit
    lane from the source XMM register (0, 1, 2, or 3). If the source operand is a
    32-bit memory location, the instruction ignores this field and uses the full 32
    bits from memory. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 to 5 | Specifies the lane in the destination XMM register in which to store
    the single-precision value. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | If set, zeroes lane 3 of XMM[dest]. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | If set, zeroes lane 2 of XMM[dest]. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | If set, zeroes lane 1 of XMM[dest]. |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | If set, zeroes lane 0 of XMM[dest]. |'
  prefs: []
  type: TYPE_TB
- en: On CPUs with the AVX extensions, `insertps` does not modify the upper bits of
    the YMM registers; `vinsertps` zeroes the upper bits.
  prefs: []
  type: TYPE_NORMAL
- en: The `vinsertps` instruction first copies the XMM[src1] register to XMM[dest]
    before performing the insertion operation. The HO bits of the corresponding YMM
    register are set to 0.
  prefs: []
  type: TYPE_NORMAL
- en: The x86-64 does not provide `(v)extractpd` or `(v)insertpd` instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 11.8 SIMD Arithmetic and Logical Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SSE and AVX instruction set extensions provide a variety of scalar and vector
    arithmetic and logical operations.
  prefs: []
  type: TYPE_NORMAL
- en: “SSE Floating-Point Arithmetic” in Chapter 6 has already covered floating-point
    arithmetic using the scalar SSE instruction set, so this section does not repeat
    that discussion. Instead, this section covers the *vector* (or *packed*) arithmetic
    and logical instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The vector instructions perform multiple operations in parallel on the different
    data lanes in an SSE or AVX register. Given two source operands, a typical SSE
    instruction will calculate two double-precision floating-point results, two quad-word
    integer calculations, four single-precision floating-point operations, four double-word
    integer calculations, eight word integer calculations, or sixteen byte calculations,
    simultaneously. The AVX registers (YMM) double the number of lanes and therefore
    double the number of concurrent calculations.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-42](#figure11-42) shows how the SSE and AVX instructions perform
    concurrent calculations; a value is taken from the same lane in two source locations,
    the calculation is performed, and the instruction stores the result to the same
    lane in the destination location. This process happens simultaneously for each
    lane in the source and destination operands. For example, if a pair of XMM registers
    contains four single-precision floating-point values, a SIMD packed floating-point
    addition instruction would add the single-precision values in the corresponding
    lanes of the source operands and store the single-precision sums into the corresponding
    lanes of the destination XMM register.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f11042](image_fi/501089c11/f11042.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-42: SIMD concurrent arithmetic and logical operations'
  prefs: []
  type: TYPE_NORMAL
- en: Certain operations—for example, logical AND, ANDN (*and not*), OR, and XOR—don’t
    have to be broken into lanes, because those operations perform the same result
    regardless of the instruction size. The lane size is a single bit. Therefore,
    the corresponding SSE/AVX instructions operate on their entire operands without
    regard for a lane size.
  prefs: []
  type: TYPE_NORMAL
- en: 11.9 The SIMD Logical (Bitwise) Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SSE and AVX instruction set extensions provide the logical operations shown
    in [Table 11-10](#table11-10) (using C/C++ bitwise operator syntax).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-10: SSE/AVX Logical Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `andpd` | dest = dest and source (128-bit operands) |'
  prefs: []
  type: TYPE_TB
- en: '| `vandpd` | dest = source1 and source2 (128-bit or 256-bit operands) |'
  prefs: []
  type: TYPE_TB
- en: '| `andnpd` | dest = dest and ~source (128-bit operands) |'
  prefs: []
  type: TYPE_TB
- en: '| `vandnpd` | dest = source1 and ~source2 (128-bit or 256-bit operands) |'
  prefs: []
  type: TYPE_TB
- en: '| `orpd` | dest = dest &#124; source (128-bit operands) |'
  prefs: []
  type: TYPE_TB
- en: '| `vorpd` | dest = source1 &#124; source2 (128-bit or 256-bit operands) |'
  prefs: []
  type: TYPE_TB
- en: '| `xorpd` | dest = dest ^ source (128-bit operands) |'
  prefs: []
  type: TYPE_TB
- en: '| `vxorpd` | dest = source1 ^ source2 (128-bit or 256-bit operands) |'
  prefs: []
  type: TYPE_TB
- en: 'The syntax for these instructions is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The SSE instructions (without the `v` prefix) leave the HO bits of the underlying
    YMM register unchanged (if applicable). The AVX instructions (with the `v` prefix)
    that have 128-bit operands will zero-extend their result into the HO bits of the
    YMM register.
  prefs: []
  type: TYPE_NORMAL
- en: If the (second) source operand is a memory location, it must be aligned on an
    appropriate boundary (for example, 16 bytes for mem[128] values and 32 bytes for
    mem[256] values). Failure to do so will result in a runtime memory alignment fault.
  prefs: []
  type: TYPE_NORMAL
- en: 11.9.1 The (v)ptest Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ptest` instruction (*packed test*) is similar to the standard integer
    `test` instruction. The `ptest` instruction performs a logical AND between the
    two operands and sets the zero flag if the result is 0\. The `ptest` instruction
    sets the carry flag if the logical AND of the second operand with the inverted
    bits of the first operand produces 0\. The `ptest` instruction supports the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 11.9.2 The Byte Shift Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The SSE and AVX instruction set extensions also support a set of logical and
    arithmetic shift instructions. The first two to consider are `pslldq` and `psrldq`.
    Although they begin with a `p`, suggesting they are packed (vector) instructions,
    these instructions really are just 128-bit logical shift-left and shift-right
    instructions. Their syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `pslldq` instruction shifts its destination XMM register to the left by
    the number of *bytes* specified by the imm[8] operand. This instruction shifts
    0s into the vacated LO bytes.
  prefs: []
  type: TYPE_NORMAL
- en: The `vpslldq` instruction takes the value in the source register (XMM or YMM),
    shifts that value to the left by imm[8] bytes, and then stores the result into
    the destination register. For the 128-bit variant, this instruction zero-extends
    the result into bits 128 to 255 of the underlying YMM register (on AVX-capable
    CPUs).
  prefs: []
  type: TYPE_NORMAL
- en: The `psrldq` and `vpsrldq` instructions operate similarly to `(v)pslldq` except,
    of course, they shift their operands to the right rather than to the left. These
    are logical shift-right operations, so they shift 0s into the HO bytes of their
    operand, and bits shifted out of bit 0 are lost.
  prefs: []
  type: TYPE_NORMAL
- en: The `pslldq` and `psrldq` instructions shift *bytes* rather than bits. For example,
    many SSE instructions produce byte masks 0 or 0FFh, representing Boolean results.
    These instructions shift the equivalent of a bit in one of these byte masks by
    shifting whole bytes at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 11.9.3 The Bit Shift Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SSE/AVX instruction set extensions also provide vector bit shift operations
    that work on two or more integer lanes, concurrently. These instructions provide
    word, dword, and qword variants of the logical shift-left, logical shift-right,
    and arithmetic shift-right operations, using the syntax
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: where `shift` = `psllw`, `pslld`, `psllq`, `psrlw`, `psrld`, `psrlq`, `psraw`,
    or `psrad`, and `vshift` = `vpsllw`, `vpslld`, `vpsllq`, `vpsrlw`, `vpsrld`, `vpsrlq`,
    `vpsraw`, `vpsrad`, or `vpsraq`.
  prefs: []
  type: TYPE_NORMAL
- en: The `(v)psl*` instructions shift their operands to the left; the `(v)psr*` instructions
    shift their operands to the right. The `(v)psll*` and `(v)psrl*` instructions
    are logical shift instructions and shift 0s into the bits vacated by the shift.
    Any bits shifted out of the operand are lost. The `(v)psra*` instructions are
    arithmetic shift-right instructions. They replicate the HO bit in each lane when
    shifting that lane’s bits to the right; all bits shifted out of the LO bit are
    lost.
  prefs: []
  type: TYPE_NORMAL
- en: The SSE two-operand instructions treat their first operand as both the source
    and destination operand. The second operand specifies the number of bits to shift
    (which is either an 8-bit immediate constant or a value held in an XMM register
    or a 128-bit memory location). Regardless of the shift count’s size, only the
    LO 4, 5, or 6 bits of the count are meaningful (depending on the lane size).
  prefs: []
  type: TYPE_NORMAL
- en: The AVX three-operand instructions specify a separate source and destination
    register for the shift operation. These instructions take the value from the source
    register, shift it the specified number of bits, and store the shifted result
    into the destination register. The source register remains unmodified (unless,
    of course, the instruction specifies the same register for the source and destination
    operands). For the AVX instructions, the source and destination registers can
    be XMM (128-bit) or YMM (256-bit) registers. The third operand is either an 8-bit
    immediate constant, an XMM register, or a 128-bit memory location. The third operand
    specifies the bit shift count (the same as the SSE instructions). You specify
    an XMM register for the count even when the source and destination registers are
    256-bit YMM registers.
  prefs: []
  type: TYPE_NORMAL
- en: The `w` suffix instructions shift 16-bit operands (eight lanes for 128-bit destination
    operands, sixteen lanes for 256-bit destinations). The `d` suffix instructions
    shift 32-bit dword operands (four lanes for 128-bit destination operands, eight
    lanes for 256-bit destination operands). The `q` suffix instructions shift 64-bit
    operands (two lanes for 128-bit operands, four lanes for 256-bit operands).
  prefs: []
  type: TYPE_NORMAL
- en: 11.10 The SIMD Integer Arithmetic Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SSE and AVX instruction set extensions deal mainly with floating-point calculations.
    They do, however, include a set of signed and unsigned integer arithmetic operations.
    This section describes the SSE/AVX integer arithmetic instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.1 SIMD Integer Addition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SIMD integer addition instructions appear in [Table 11-11](#table11-11).
    These instructions do not affect any flags and thus do not indicate when an overflow
    (signed or unsigned) occurs during the execution of these instructions. The program
    itself must ensure that the source operands are all within the appropriate range
    before performing an addition. If carry occurs during an addition, the carry is
    lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-11: SIMD Integer Addition Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Operands** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `paddb` | `xmm`[dest], `xmm`/`mem`[128] | 16-lane byte addition |'
  prefs: []
  type: TYPE_TB
- en: '| `vpaddb` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 16-lane byte
    addition |'
  prefs: []
  type: TYPE_TB
- en: '| `vpaddb` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 32-lane byte
    addition |'
  prefs: []
  type: TYPE_TB
- en: '| `paddw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word addition |'
  prefs: []
  type: TYPE_TB
- en: '| `vpaddw` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 8-lane word
    addition |'
  prefs: []
  type: TYPE_TB
- en: '| `vpaddw` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 16-lane word
    addition |'
  prefs: []
  type: TYPE_TB
- en: '| `paddd` | `xmm`[dest], `xmm`/`mem`[128] | 4-lane dword addition |'
  prefs: []
  type: TYPE_TB
- en: '| `vpaddd` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 4-lane dword
    addition |'
  prefs: []
  type: TYPE_TB
- en: '| `vpaddd` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 8-lane dword
    addition |'
  prefs: []
  type: TYPE_TB
- en: '| `paddq` | `xmm`[dest], `xmm`/`mem`[128] | 2-lane qword addition |'
  prefs: []
  type: TYPE_TB
- en: '| `vpaddq` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 2-lane qword
    addition |'
  prefs: []
  type: TYPE_TB
- en: '| `vpaddq` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 4-lane qword
    addition |'
  prefs: []
  type: TYPE_TB
- en: These addition instructions are known as *vertical additions* because if we
    stack the two source operands on top of each other (on a printed page), the lane
    additions occur vertically (one source lane is directly above the second source
    lane for the corresponding addition operation).
  prefs: []
  type: TYPE_NORMAL
- en: The packed additions ignore any overflow from the addition operation, keeping
    only the LO byte, word, dword, or qword of each addition. As long as overflow
    is never possible, this is not an issue. However, for certain algorithms (especially
    audio and video, which commonly use packed addition), truncating away the overflow
    can produce bizarre results.
  prefs: []
  type: TYPE_NORMAL
- en: A cleaner solution is to use *saturation arithmetic*. For unsigned addition,
    saturation arithmetic *clips* (or *saturates*) an overflow to the largest possible
    value that the instruction’s size can handle. For example, if the addition of
    two byte values exceeds 0FFh, saturation arithmetic produces 0FFh—the largest
    possible unsigned 8-bit value (likewise, saturation subtraction would produce
    0 if underflow occurs). For signed saturation arithmetic, clipping occurs at the
    largest positive and smallest negative values (for example, 7Fh/+127 for positive
    values and 80h/–128 for negative values).
  prefs: []
  type: TYPE_NORMAL
- en: The x86 SIMD instructions provide both signed and unsigned saturation arithmetic,
    though the operations are limited to 8- and 16-bit quantities.^([10](#c11-footnote-10))
    The instructions appear in [Table 11-12](#table11-12).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-12: SIMD Integer Saturation Addition Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Operands** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `paddsb` | `xmm`[dest], `xmm`/`mem`[128] | 16-lane byte signed saturation
    addition |'
  prefs: []
  type: TYPE_TB
- en: '| `vpaddsb` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 16-lane byte
    signed saturation addition |'
  prefs: []
  type: TYPE_TB
- en: '| `vpaddsb` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 32-lane byte
    signed saturation addition |'
  prefs: []
  type: TYPE_TB
- en: '| `paddsw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word signed saturation
    addition |'
  prefs: []
  type: TYPE_TB
- en: '| `vpaddsw` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 8-lane word
    signed saturation addition |'
  prefs: []
  type: TYPE_TB
- en: '| `vpaddsw` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 16-lane word
    signed saturation addition |'
  prefs: []
  type: TYPE_TB
- en: '| `paddusb` | `xmm`[dest], `xmm`/`mem`[128] | 16-lane byte unsigned saturation
    addition |'
  prefs: []
  type: TYPE_TB
- en: '| `vpaddusb` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 16-lane byte
    unsigned saturation addition |'
  prefs: []
  type: TYPE_TB
- en: '| `vpaddusb` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 32-lane byte
    unsigned saturation addition |'
  prefs: []
  type: TYPE_TB
- en: '| `paddusw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word unsigned saturation
    addition |'
  prefs: []
  type: TYPE_TB
- en: '| `vpaddusw` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 8-lane word
    unsigned saturation addition |'
  prefs: []
  type: TYPE_TB
- en: '| `vpaddusw` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 16-lane word
    unsigned saturation addition |'
  prefs: []
  type: TYPE_TB
- en: As usual, both `padd*` and `vpadd*` instructions accept 128-bit XMM registers
    (sixteen 8-bit additions or eight 16-bit additions). The `padd*` instructions
    leave the HO bits of any corresponding YMM destination undisturbed; the `vpadd*`
    variants clear the HO bits. Also note that the `padd*` instructions have only
    two operands (the destination register is also a source), whereas the `vpadd*`
    instructions have two source operands and a single destination operand. The `vpadd*`
    instructions with the YMM register provide double the number of parallel additions.
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.2 Horizontal Additions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SSE/AVX instruction sets also support three *horizontal addition* instructions,
    listed in [Table 11-13](#table11-13).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-13: Horizontal Addition Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `(v)``phaddw` | 16-bit (word) horizontal add |'
  prefs: []
  type: TYPE_TB
- en: '| `(v)``phaddd` | 32-bit (dword) horizontal add |'
  prefs: []
  type: TYPE_TB
- en: '| `(v)``phaddsw` | 16-bit (word) horizontal add and saturate |'
  prefs: []
  type: TYPE_TB
- en: The horizontal addition instructions add adjacent words or dwords in their two
    source operands and store the sum of the result into a destination lane, as shown
    in [Figure 11-43](#figure11-43).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11043](image_fi/501089c11/f11043.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-43: Horizontal addition operation'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `phaddw` instruction has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'It computes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As is the case with most SSE instructions, `phaddw` does not affect the HO bits
    of the corresponding YMM destination register, only the LO 128 bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 128-bit `vphaddw` instruction has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'It computes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `vphaddw` instruction zeroes out the HO 128 bits of the corresponding YMM
    destination register.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 256-bit `vphaddw` instruction has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`vphaddw` does not simply extend the 128-bit version in the intuitive way.
    Instead, it mixes up computations as follows (where `SRC1` is YMM[src1] and `SRC2`
    is YMM[src2]/mem[256]):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 11.10.3 Double-Word–Sized Horizontal Additions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `phaddd` instruction has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'It computes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The 128-bit `vphaddd` instruction has this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'It computes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Like `vphaddw`, the 256-bit `vphaddd` instruction has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'It calculates the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: If an overflow occurs during the horizontal addition, `(v)phaddw` and `(v)phaddd`
    simply ignore the overflow and store the LO 16 or 32 bits of the result into the
    destination location.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `(v)phaddsw` instructions take the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `(v)phaddsw` instruction (*horizontal signed integer add with saturate,
    word*) is a slightly different form of `(v)phaddw`: rather than storing only the
    LO bits into the result in the destination lane, this instruction saturates the
    result. *Saturation* means that any (positive) overflow results in the value 7FFFh,
    regardless of the actual result. Likewise, any negative underflow results in the
    value 8000h.'
  prefs: []
  type: TYPE_NORMAL
- en: Saturation arithmetic works well for audio and video processing. If you were
    using standard (wraparound/modulo) addition when adding two sound samples together,
    the result would be horrible clicking sounds. Saturation, on the other hand, simply
    produces a clipped audio signal. While this is not ideal, it sounds considerably
    better than the results from modulo arithmetic. Similarly, for video processing,
    saturation produces a washed-out (white) color versus the bizarre colors that
    result from modulo arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, there is no horizontal add with saturation for double-word operands (for
    example, to handle 24-bit audio).
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.4 SIMD Integer Subtraction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SIMD integer subtraction instructions appear in [Table 11-14](#table11-14).
    As for the SIMD addition instructions, they do not affect any flags; any carry,
    borrow, overflow, or underflow information is lost. These instructions subtract
    the second source operand from the first source operand (which is also the destination
    operand for the SSE-only instructions) and store the result into the destination
    operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-14: SIMD Integer Subtraction Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Operands** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `psubb` | `xmm`[dest], `xmm`/`mem`[128] | 16-lane byte subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| `vpsubb` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 16-lane byte subtraction
    |'
  prefs: []
  type: TYPE_TB
- en: '| `vpsubb` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 32-lane byte subtraction
    |'
  prefs: []
  type: TYPE_TB
- en: '| `psubw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| `vpsubw` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 8-lane word subtraction
    |'
  prefs: []
  type: TYPE_TB
- en: '| `vpsubw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16-lane word subtraction
    |'
  prefs: []
  type: TYPE_TB
- en: '| `psubd` | `xmm`[dest], `xmm`/`mem`[128] | 4-lane dword subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| `vpsubd` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 4-lane dword subtraction
    |'
  prefs: []
  type: TYPE_TB
- en: '| `vpsubd` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 8-lane dword subtraction
    |'
  prefs: []
  type: TYPE_TB
- en: '| `psubq` | `xmm`[dest], `xmm`/`mem`[128] | 2-lane qword subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| `vpsubq` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 2-lane qword subtraction
    |'
  prefs: []
  type: TYPE_TB
- en: '| `vpsubq` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 4-lane qword subtraction
    |'
  prefs: []
  type: TYPE_TB
- en: The `(v)phsubw`, `(v)phsubd`, and `(v)phsubsw` horizontal subtraction instructions
    work just like the horizontal addition instructions, except (of course) they compute
    the difference of the two source operands rather than the sum. See the previous
    sections for details on the horizontal addition instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, there is a set of signed and unsigned byte and word saturating subtraction
    instructions (see [Table 11-15](#table11-15)). For the signed instructions, the
    byte-sized instructions saturate positive overflow to 7Fh (+127) and negative
    underflow to 80h (–128). The word-sized instructions saturate to 7FFFh (+32,767)
    and 8000h (–32,768). The unsigned saturation instructions saturate to 0FFFFh (+65,535)
    and 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-15: SIMD Integer Saturating Subtraction Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Operands** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `psubsb` | `xmm`[dest], `xmm`/`mem`[128] | 16-lane byte signed saturation
    subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| `vpsubsb` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 16-lane byte signed
    saturation subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| `vpsubsb` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 32-lane byte signed
    saturation subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| `psubsw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word signed saturation
    subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| `vpsubsw` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 8-lane word signed
    saturation subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| `vpsubsw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16-lane word signed
    saturation subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| `psubusb` | `xmm`[dest], `xmm`/`mem`[128] | 16-lane byte unsigned saturation
    subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| `vpsubusb` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 16-lane byte unsigned
    saturation subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| `vpsubusb` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 32-lane byte unsigned
    saturation subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| `psubusw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word unsigned saturation
    subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| `vpsubusw` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 8-lane word unsigned
    saturation subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| `vpsubusw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16-lane word unsigned
    saturation subtraction |'
  prefs: []
  type: TYPE_TB
- en: 11.10.5 SIMD Integer Multiplication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SSE/AVX instruction set extensions *somewhat* support multiplication. Lane-by-lane
    multiplication requires that the result of an operation on two *n*-bit values
    fits in *n* bits, but *n* × *n* multiplication can produce a 2×*n*-bit result.
    So a lane-by-lane multiplication operation creates problems as overflow is lost.
    The basic packed integer multiplication multiplies a pair of lanes and stores
    the LO bits of the result in the destination lane. For extended arithmetic, packed
    integer multiplication instructions produce the HO bits of the result.
  prefs: []
  type: TYPE_NORMAL
- en: The instructions in [Table 11-16](#table11-16) handle 16-bit multiplication
    operations. The `(v)pmullw` instruction multiplies the 16-bit values appearing
    in the lanes of the source operand and stores the LO word of the result into the
    corresponding destination lane. This instruction is applicable to both signed
    and unsigned values. The `(v)pmulhw` instruction computes the product of two signed
    word values and stores the *HO word* of the result into the destination lanes.
    For unsigned operands, `(v)pmulhuw` performs the same task. By executing both
    `(v)pmullw` and `(v)pmulh(u)w` with the same operands, you can compute the full
    32-bit result of a 16×16-bit multiplication. (You can use the `punpck*` instructions
    to merge the results into 32-bit integers.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-16: SIMD 16-Bit Packed Integer Multiplication Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Operands** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `pmullw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word multiplication, producing
    the LO word of the product |'
  prefs: []
  type: TYPE_TB
- en: '| `vpmullw` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 8-lane word multiplication,
    producing the LO word of the product |'
  prefs: []
  type: TYPE_TB
- en: '| `vpmullw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16-lane word multiplication,
    producing the LO word of the product |'
  prefs: []
  type: TYPE_TB
- en: '| `pmulhuw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word unsigned multiplication,
    producing the HO word of the product |'
  prefs: []
  type: TYPE_TB
- en: '| `vpmulhuw` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 8-lane word unsigned
    multiplication, producing the HO word of the product |'
  prefs: []
  type: TYPE_TB
- en: '| `vpmulhuw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16-lane word unsigned
    multiplication, producing the HO word of the product |'
  prefs: []
  type: TYPE_TB
- en: '| `pmulhw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word signed multiplication,
    producing the HO word of the product |'
  prefs: []
  type: TYPE_TB
- en: '| `vpmulhw` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 8-lane word signed
    multiplication, producing the HO word of the product |'
  prefs: []
  type: TYPE_TB
- en: '| `vpmulhw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16-lane word signed
    multiplication, producing the HO word of the product |'
  prefs: []
  type: TYPE_TB
- en: '[Table 11-17](#table11-17) lists the 32- and 64-bit versions of the packed
    multiplication instructions. There are no `(v)pmulhd` or `(v)pmulhq` instructions;
    see `(v)pmuludq` and `(v)pmuldq` to handle 32- and 64-bit packed multiplication.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-17: SIMD 32- and 64-Bit Packed Integer Multiplication Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Operands** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `pmulld` | `xmm`[dest], `xmm`/`mem`[128] | 4-lane dword multiplication, producing
    the LO dword of the product |'
  prefs: []
  type: TYPE_TB
- en: '| `vpmulld` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 4-lane dword multiplication,
    producing the LO dword of the product |'
  prefs: []
  type: TYPE_TB
- en: '| `vpmulld` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 8-lane dword multiplication,
    producing the LO dword of the product |'
  prefs: []
  type: TYPE_TB
- en: '| `vpmullq` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 2-lane qword multiplication,
    producing the LO qword of the product |'
  prefs: []
  type: TYPE_TB
- en: '| `vpmullq` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 4-lane qword multiplication,
    producing the LO qword of the product (available on only AVX-512 CPUs) |'
  prefs: []
  type: TYPE_TB
- en: 'At some point along the way, Intel introduced `(v)pmuldq` and `(v)pmuludq`
    to perform signed and unsigned 32×32-bit multiplications, producing a 64-bit result.
    The syntax for these instructions is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The 128-bit variants multiply the double words appearing in lanes 0 and 2 and
    store the 64-bit results into qword lanes 0 and 1 (dword lanes 0 and 1 and 2 and
    3). On CPUs with AVX registers,^([11](#c11-footnote-11)) `pmuldq` and `pmuludq`
    do not affect the HO 128 bits of the YMM register. The `vpmuldq` and `vpmuludq`
    instructions zero-extend the result to 256 bits. The 256-bit variants multiply
    the double words appearing in lanes 0, 2, 4, and 6, producing 64-bit results that
    they store in qword lanes 0, 1, 2, and 3 (dword lanes 0 and 1, 2 and 3, 4 and
    5, and 6 and 7 ).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pclmulqdq` instruction provides the ability to multiply two qword values,
    producing a 128-bit result. Here is the syntax for this instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: These instructions multiply a pair of qword values found in XMM[dest] and XMM[src]
    and leave the 128-bit result in XMM[dest]. The imm[8] operand specifies which
    qwords to use as the source operands. [Table 11-18](#table11-18) lists the possible
    combinations for `pclmulqdq`. [Table 11-19](#table11-19) lists the combinations
    for `vpclmulqdq`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-18: imm[8] Operand Values for `pclmulqdq` Instruction'
  prefs: []
  type: TYPE_NORMAL
- en: '| **imm[8]** | **Result** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 00h | XMM[dest] = XMM[dest][0 to 63] * XMM/mem[128][0 to 63] |'
  prefs: []
  type: TYPE_TB
- en: '| 01h | XMM[dest] = XMM[dest][64 to 127] * XMM/mem[128][0 to 63] |'
  prefs: []
  type: TYPE_TB
- en: '| 10h | XMM[dest] = XMM[dest][0 to 63] * XMM/mem[128][64 to 127] |'
  prefs: []
  type: TYPE_TB
- en: '| 11h | XMM[dest] = XMM[dest][64 to 127] * XMM/mem[128][64 to 127] |'
  prefs: []
  type: TYPE_TB
- en: 'Table 11-19: imm[8] Operand Values for `vpclmulqdq` Instruction'
  prefs: []
  type: TYPE_NORMAL
- en: '| **imm[8]** | **Result** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 00h | XMM[dest] = XMM[src1][0 to 63] * XMM[src2]/mem[128][0 to 63] |'
  prefs: []
  type: TYPE_TB
- en: '| 01h | XMM[dest] = XMM[src1][64 to 127] * XMM[src2]/mem[128][0 to 63] |'
  prefs: []
  type: TYPE_TB
- en: '| 10h | XMM[dest] = XMM[src1][0 to 63] * XMM[src2]/mem[128][64 to 127] |'
  prefs: []
  type: TYPE_TB
- en: '| 11h | XMM[dest] = XMM[src1][64 to 127] * XMM[src2]/mem[128][64 to 127] |'
  prefs: []
  type: TYPE_TB
- en: As usual, `pclmulqdq` leaves the HO 128 bits of the corresponding YMM destination
    register unchanged, while `vpcmulqdq` zeroes those bits.
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.6 SIMD Integer Averages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `(v)pavgb` and `(v)pavgw` instructions compute the average of two sets
    of bytes or words. These instructions sum the value in the byte or word lanes
    of their source and destination operands, divide the result by 2, round the results,
    and leave the averaged results sitting in the destination operand lanes. The syntax
    for these instructions is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The 128-bit `pavgb` and `vpavgb` instructions compute 16 byte-sized averages
    (for the 16 lanes in the source and destination operands). The 256-bit variant
    of the `vpavgb` instruction computes 32 byte-sized averages.
  prefs: []
  type: TYPE_NORMAL
- en: The 128-bit `pavgw` and `vpavgw` instructions compute eight word-sized averages
    (for the eight lanes in the source and destination operands). The 256-bit variant
    of the `vpavgw` instruction computes 16 byte-sized averages.
  prefs: []
  type: TYPE_NORMAL
- en: The `vpavgb` and `vpavgw` instructions compute the average of the first XMM
    or YMM source operand and the second XMM, YMM, or mem source operand, storing
    the average in the destination XMM or YMM register.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there are no `(v)pavgd` or `(v)pavgq` instructions. No doubt,
    these instructions were originally intended for mixing 8- and 16-bit audio or
    video streams (or photo manipulation), and the x86-64 CPU designers never felt
    the need to extend this beyond 16 bits (even though 24-bit audio is common among
    professional audio engineers).
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.7 SIMD Integer Minimum and Maximum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SSE4.1 instruction set extensions added eight packed integer *minimum* and
    *maximum* instructions, as shown in [Table 11-20](#table11-20). These instructions
    scan the lanes of a pair of 128- or 256-bit operands and copy the maximum or minimum
    value from that lane to the same lane in the destination operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-20: SIMD Minimum and Maximum Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pmaxsb` | Destination byte lanes set to the maximum value of the two
    signed byte values found in the corresponding source lanes. |'
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pmaxsw` | Destination word lanes set to the maximum value of the two
    signed word values found in the corresponding source lanes. |'
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pmaxsd` | Destination dword lanes set to the maximum value of the two
    signed dword values found in the corresponding source lanes. |'
  prefs: []
  type: TYPE_TB
- en: '| `v``pmaxsq` | Destination qword lanes set to the maximum value of the two
    signed qword values found in the corresponding source lanes. (AVX-512 required
    for this instruction.) |'
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pmaxub` | Destination byte lanes set to the maximum value of the two
    unsigned byte values found in the corresponding source lanes. |'
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pmaxuw` | Destination word lanes set to the maximum value of the two
    unsigned word values found in the corresponding source lanes. |'
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pmaxud` | Destination dword lanes set to the maximum value of the two
    unsigned dword values found in the corresponding source lanes. |'
  prefs: []
  type: TYPE_TB
- en: '| `v``pmaxuq` | Destination qword lanes set to the maximum value of the two
    unsigned qword values found in the corresponding source lanes. (AVX-512 required
    for this instruction.) |'
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pminsb` | Destination byte lanes set to the minimum value of the two
    signed byte values found in the corresponding source lanes. |'
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pminsw` | Destination word lanes set to the minimum value of the two
    signed word values found in the corresponding source lanes. |'
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pminsd` | Destination dword lanes set to the minimum value of the two
    signed dword values found in the corresponding source lanes. |'
  prefs: []
  type: TYPE_TB
- en: '| `v``pminsq` | Destination qword lanes set to the minimum value of the two
    signed qword values found in the corresponding source lanes. (AVX-512- required
    for this instruction.) |'
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pminub` | Destination byte lanes set to the minimum value of the two
    unsigned byte values found in the corresponding source lanes. |'
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pminuw` | Destination word lanes set to the minimum value of the two
    unsigned word values found in the corresponding source lanes. |'
  prefs: []
  type: TYPE_TB
- en: '| `(v)``pminud` | Destination dword lanes set to the minimum value of the two
    unsigned dword values found in the corresponding source lanes. |'
  prefs: []
  type: TYPE_TB
- en: '| `v``pminuq` | Destination qword lanes set to the minimum value of the two
    unsigned qword values found in the corresponding source lanes. (AVX-512 required
    for this instruction.) |'
  prefs: []
  type: TYPE_TB
- en: The generic syntax for these instructions is as follows:^([12](#c11-footnote-12))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The SSE instructions compute the minimum or maximum of the corresponding lanes
    in the source and destination operands and store the minimum or maximum result
    into the corresponding lanes in the destination register. The AVX instructions
    compute the minimum or maximum of the values in the same lanes of the two source
    operands and store the minimum or maximum result into the corresponding lanes
    of the destination register.
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.8 SIMD Integer Absolute Value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The SSE/AVX instruction set extensions provide three sets of instructions for
    computing the absolute values of signed byte, word, and double-word integers:
    `(v)pabsb`, `(v)pabsw`, and `(v)pabsd`.^([13](#c11-footnote-13)) The syntax for
    these instructions is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: When operating on a system that supports AVX registers, the SSE `pabsb`, `pabsw`,
    and `pabsd` instructions leave the upper bits of the YMM registers unmodified.
    The 128-bit versions of the AVX instructions (`vpabsb`, `vpabsw`, and `vpabsd`)
    zero-extend the result through the upper bits.
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.9 SIMD Integer Sign Adjustment Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `(v)psignb`, `(v)psignw`, and `(v)psignd` instructions apply the sign found
    in a source lane to the corresponding destination lane. The algorithm works as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax for these instructions is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: As usual, the 128-bit SSE instructions leave the upper bits of the YMM register
    unchanged (if applicable), and the 128-bit AVX instructions zero-extend the result
    into the upper bits of the YMM register.
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.10 SIMD Integer Comparison Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `(v)pcmpeqb`, `(v)pcmpeqw`, `(v)pcmpeqd`, `(v)pcmpeqq`, `(v)pcmpgtb`, `(v)pcmpgtw`,
    `(v)pcmpgtd`, and `(v)pcmpgtq` instructions provide packed signed integer comparisons.
    These instructions compare corresponding bytes, word, dwords, or qwords (depending
    on the instruction suffix) in the various lanes of their operands.^([14](#c11-footnote-14))
    They store the result of the comparison instruction in the corresponding destination
    lanes.
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.10.1 SSE Compare-for-Equality Instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The syntax for the SSE *compare-for-equality* instructions (`pcmpeq*`) is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: These instructions compute
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: where `lane` varies from 0 to 15 for `pcmpeqb`, 0 to 7 for `pcmpeqw`, 0 to 3
    for `pcmpeqd`, and 0 to 1 for `pcmpeqq`. The `==` operator produces a value of
    all 1 bits if the two values in the same lane are equal; it produces all 0 bits
    if the values are not equal.
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.10.2 SSE Compare-for-Greater-Than Instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following is the syntax for the SSE *compare-for-greater-than* instructions
    (`pcmpgt*`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: These instructions compute
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: where `lane` is the same as for the compare-for-equality instructions, and the
    `>` operator produces a value of all 1 bits if the signed integer in the XMM[dest]
    lane is greater than the signed value in the corresponding XMM[src]/MEM[128] lane.
  prefs: []
  type: TYPE_NORMAL
- en: On AVX-capable CPUs, the SSE packed integer comparisons preserve the value in
    the upper bits of the underlying YMM register.
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.10.3 AVX Comparison Instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The 128-bit variants of these instructions have the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'These instructions compute as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: These AVX instructions write 0s to the upper bits of the underlying YMM register.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 256-bit variants of these instructions have the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'These instructions compute as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the principal difference between the 256- and the 128-bit instructions
    is that the 256-bit variants support twice as many byte (32), word (16), dword
    (8), and qword (4) signed-integer lanes.
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.10.4 Compare-for-Less-Than Instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are no packed *compare-for-less-than* instructions. You can synthesize
    a less-than comparison by reversing the operands and using a greater-than comparison.
    That is, if *x* < *y*, then it is also true that *y* > *x*. If both packed operands
    are sitting in XMM or YMM registers, swapping the registers is relatively easy
    (especially when using the three-operand AVX instructions). If the second operand
    is a memory operand, you must first load that operand into a register so you can
    reverse the operands (a memory operand must always be the second operand).
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.10.5 Using Packed Comparison Results
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The question remains of what to do with the result you obtain from a packed
    comparison. SSE/AVX packed signed integer comparisons do not affect condition
    code flags (because they compare multiple values and only one of those comparisons
    could be moved into the flags). Instead, the packed comparisons simply produce
    Boolean results. You can use these results with the packed AND instructions (`pand`,
    `vpand`, `pandn`, and `vpandn`), the packed OR instructions (`por` and `vpor`),
    or the packed XOR instructions (`pxor` and `vpxor`) to mask or otherwise modify
    other packed data values. Of course, you could also extract the individual lane
    values and test them (via a conditional jump). The following section describes
    a straightforward way to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.10.6 The (v)pmovmskb Instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `(v)pmovmskb` instruction extracts the HO bit from all the bytes in an XMM
    or YMM register and stores the 16 or 32 bits (respectively) into a general-purpose
    register. These instructions set all HO bits of the general-purpose register to
    0 (beyond those needed to hold the mask bits). The syntax is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: where `reg` is any 32-bit or 64-bit general-purpose integer register. The semantics
    for the `pmovmskb` and `vpmovmskb` instructions with an XMM source register are
    the same, but the encoding of `pmovmskb` is more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: The `(v)pmovmskb` instruction copies the sign bits from each of the byte lanes
    into the corresponding bit position of the general-purpose register. It copies
    bit 7 from the XMM register (the sign bit for lane 0) into bit 0 of the destination
    register; it copies bit 15 from the XMM register (the sign bit for lane 1) into
    bit 1 of the destination register; it copies bit 23 from the XMM register (the
    sign bit for lane 2) into bit 2 of the destination register; and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The 128-bit instructions fill only bits 0 through 15 of the destination register
    (zeroing out all other bits). The 256-bit form of the `vpmovmskb` instruction
    fills bits 0 through 31 of the destination register (zeroing out HO bits if you
    specify a 64-bit register).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `pmovmskb` instruction to extract a single bit from each byte
    lane in an XMM or a YMM register after a `(v)pcmpeqb` or `(v)pcmpgtb` instruction.
    Consider the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: After the execution of these two instructions, EAX bit 0 will be 1 or 0 if byte
    0 of XMM0 was equal, or not equal, to byte 0 of XMM1, respectively. Likewise,
    EAX bit 1 will contain the result of comparing byte 1 of XMM0 to XMM1, and so
    on for each of the following bytes (up to bit 15, which compares 16-byte values
    in XMM0 and XMM1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, there are no `pmovmskw`, `pmovmskd`, and `pmovmsq` instructions.
    You can achieve the same result as `pmovmskw` by using the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `pcmpeqw` produces a sequence of words (which contain either 0000h
    or 0FFFFh) and `pmovmskb` expects byte values, `pmovmskb` produces twice as many
    results as we expect, and every odd-numbered bit that `pmovmskb` produces is a
    duplicate of the preceding even-numbered bit (because the inputs are either 0000h
    or 0FFFFh). This code grabs every odd-numbered bit (starting with bit 15 and working
    down) and skips over the even-numbered bits. While this code is easy enough to
    follow, it is rather long and slow. If you’re willing to live with an 8-bit result
    for which the lane numbers don’t match the bit numbers, you can use more efficient
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This interleaves the lanes in the bit positions as shown in [Figure 11-44](#figure11-44).
    Usually, it’s easy enough to work around this rearrangement in the software. Of
    course, you can also use a 256-entry lookup table (see Chapter 10) to rearrange
    the bits however you desire. Of course, if you’re just going to test the individual
    bits rather than use them as some sort of mask, you can directly test the bits
    that `pmovmskb` leaves in EAX; you don’t have to coalesce them into a single byte.
  prefs: []
  type: TYPE_NORMAL
- en: '![f11044](image_fi/501089c11/f11044.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-44: Merging bits from `pcmpeqw`'
  prefs: []
  type: TYPE_NORMAL
- en: When using the double-word or quad-word packed comparisons, you could also use
    a scheme such as the one provided here for `pcmpeqw`. However, the floating-point
    mask move instructions (see “The (v)movmskps, (v)movmskpd Instructions” on page
    676) do the job more efficiently by breaking the rule about using SIMD instructions
    that are appropriate for the data type.
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.11 Integer Conversions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SSE and AVX instruction set extensions provide various instructions that
    convert integer values from one form to another. There are zero- and sign-extension
    instructions that convert from a smaller value to a larger one. Other instructions
    convert larger values to smaller ones. This section covers these instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 11.10.11.1 Packed Zero-Extension Instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *move with zero-extension* instructions perform the conversions appearing
    in [Table 11-21](#table11-21).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-21: SSE4.1 and AVX Packed Zero-Extension Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Syntax** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `pmovzxbw` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | Zero-extends a set of
    eight byte values in the LO 8 bytes of XMM[src]/mem[64] to word values in XMM[dest].
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pmovzxbd` `xmm`[dest]`,` `xmm`[src]`/``mem`[32] | Zero-extends a set of
    four byte values in the LO 4 bytes of XMM[src]/mem[32] to dword values in XMM[dest].
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pmovzxbq` `xmm`[dest]`,` `xmm`[src]`/``mem`[16] | Zero-extends a set of
    two byte values in the LO 2 bytes of XMM[src]/mem[16] to qword values in XMM[dest].
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pmovzxwd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | Zero-extends a set of
    four word values in the LO 8 bytes of XMM[src]/mem[64] to dword values in XMM[dest].
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pmovzxwq` `xmm`[dest]`,` `xmm`[src]`/``mem`[32] | Zero-extends a set of
    two word values in the LO 4 bytes of XMM[src]/mem[32] to qword values in XMM[dest].
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pmovzxdq` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | Zero-extends a set of
    two dword values in the LO 8 bytes of XMM[src]/mem[64] to qword values in XMM[dest].
    |'
  prefs: []
  type: TYPE_TB
- en: A set of comparable AVX instructions also exists (same syntax, but with a `v`
    prefix on the instruction mnemonics). The difference, as usual, is that the SSE
    instructions leave the upper bits of the YMM register unchanged, whereas the AVX
    instructions store 0s into the upper bits of the YMM registers.
  prefs: []
  type: TYPE_NORMAL
- en: The AVX2 instruction set extensions double the number of lanes by allowing the
    use of the YMM registers. They take similar operands to the SSE/AVX instructions
    (substituting YMM for the destination register and doubling the size of the memory
    locations) and process twice the number of lanes to produce sixteen words, eight
    dwords, or four qwords in a YMM destination register. See [Table 11-22](#table11-22)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-22: AVX2 Packed Zero-Extension Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Syntax** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovzxbw` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | Zero-extends a set
    of sixteen byte values in the LO 16 bytes of XMM[src]/mem[128] to word values
    in YMM[dest]. |'
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovzxbd` `ymm`[dest]`,` `xmm`[src]`/``mem`[64] | Zero-extends a set
    of eight byte values in the LO 8 bytes of XMM[src]/mem[64] to dword values in
    YMM[dest]. |'
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovzxbq` `ymm`[dest]`,` `xmm`[src]`/``mem`[32] | Zero-extends a set
    of four byte values in the LO 4 bytes of XMM[src]/mem[32] to qword values in YMM[dest].
    |'
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovzxwd` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | Zero-extends a set
    of eight word values in the LO 16 bytes of XMM[src]/mem[128] to dword values in
    YMM[dest]. |'
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovzxwq` `ymm`[dest]`,` `xmm`[src]`/``mem`[64] | Zero-extends a set
    of four word values in the LO 8 bytes of XMM[src]/mem[64] to qword values in YMM[dest].
    |'
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovzxdq` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | Zero-extends a set
    of four dword values in the LO 16 bytes of XMM[src]/mem[128] to qword values in
    YMM[dest]. |'
  prefs: []
  type: TYPE_TB
- en: 11.10.11.2 Packed Sign-Extension Instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The SSE/AVX/AVX2 instruction set extensions provide a comparable set of instructions
    that sign-extend byte, word, and dword values. [Table 11-23](#table11-23) lists
    the SSE packed sign-extension instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-23: SSE Packed Sign-Extension Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Syntax** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `pmovsxbw` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | Sign-extends a set of
    eight byte values in the LO 8 bytes of XMM[src]/mem[64] to word values in XMM[dest].
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pmovsxbd` `xmm`[dest]`,` `xmm`[src]`/``mem`[32] | Sign-extends a set of
    four byte values in the LO 4 bytes of XMM[src]/mem[32] to dword values in XMM[dest].
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pmovsxbq` `xmm`[dest]`,` `xmm`[src]`/``mem`[16] | Sign-extends a set of
    two byte values in the LO 2 bytes of XMM[src]/mem[16] to qword values in XMM[dest].
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pmovsxwd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | Sign-extends a set of
    four word values in the LO 8 bytes of XMM[src]/mem[64] to dword values in XMM[dest].
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pmovsxwq` `xmm`[dest]`,` `xmm`[src]`/``mem`[32] | Sign-extends a set of
    two word values in the LO 4 bytes of XMM[src]/mem[32] to qword values in XMM[dest].
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pmovsxdq` `xmm`[dest]`,` `xmm`[src]`/mem`[64] | Sign-extends a set of two
    dword values in the LO 8 bytes of XMM[src]/mem[64] to qword values in XMM[dest].
    |'
  prefs: []
  type: TYPE_TB
- en: A set of corresponding AVX instructions also exists (whose mnemonics have the
    `v` prefix). As usual, the difference between the SSE and AVX instructions is
    that the SSE instructions leave the upper bits of the YMM register unchanged (if
    applicable), and the AVX instructions store 0s into those upper bits.
  prefs: []
  type: TYPE_NORMAL
- en: AVX2-capable processors also allow a YMM[dest] destination register, which doubles
    the number of (output) values the instruction can handle; see [Table 11-24](#table11-24).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-24: AVX Packed Sign-Extension Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Syntax** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovsxbw` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | Sign-extends a set
    of sixteen byte values in the LO 16 bytes of XMM[src]/mem[128] to word values
    in YMM[dest]. |'
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovsxbd` `ymm`[dest]`,` `xmm`[src]`/``mem`[64] | Sign-extends a set
    of eight byte values in the LO 8 bytes of XMM[src]/mem[64] to dword values in
    YMM[dest]. |'
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovsxbq` `ymm`[dest]`,` `xmms`[rc]`/``mem`[32] | Sign-extends a set
    of four byte values in the LO 4 bytes of XMM[src]/mem[32] to qword values in YMM[dest].
    |'
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovsxwd` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | Sign-extends a set
    of eight word values in the LO 16 bytes of XMM[src]/mem[128] to dword values in
    YMM[dest]. |'
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovsxwq` `ymm`[dest]`,` `xmm`[src]`/``mem`[64] | Sign-extends a set
    of four word values in the LO 8 bytes of XMM[src]/mem[64] to qword values in YMM[dest].
    |'
  prefs: []
  type: TYPE_TB
- en: '| `v``pmovsxdq` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | Sign-extends a set
    of four dword values in the LO 16 bytes of XMM[src]/mem[128] to qword values in
    YMM[dest]. |'
  prefs: []
  type: TYPE_TB
- en: 11.10.11.3 Packed Sign Extension with Saturation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to converting smaller signed or unsigned values to a larger format,
    the SSE/AVX/AVX2-capable CPUs have the ability to convert large values to smaller
    values via saturation; see [Table 11-25](#table11-25).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-25: SSE Packed Sign-Extension with Saturation Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Syntax** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `packsswb` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Packs sixteen signed
    word values (from two 128-bit sources) into sixteen byte lanes in a 128-bit destination
    register using signed saturation. |'
  prefs: []
  type: TYPE_TB
- en: '| `packuswb` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Packs sixteen unsigned
    word values (from two 128-bit sources) into sixteen byte lanes in a 128-bit destination
    register using unsigned saturation. |'
  prefs: []
  type: TYPE_TB
- en: '| `packssdw` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Packs eight signed dword
    values (from two 128-bit sources) into eight word values in a 128-bit destination
    register using signed saturation. |'
  prefs: []
  type: TYPE_TB
- en: '| `packusdw` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Packs eight unsigned
    dword values (from two 128-bit sources) into eight word values in a 128-bit destination
    register using unsigned saturation. |'
  prefs: []
  type: TYPE_TB
- en: The saturate operation checks its operand to see if the value exceeds the range
    of the result (–128 to +127 for signed bytes, 0 to 255 for unsigned bytes, –32,768
    to +32,767 for signed words, and 0 to 65,535 for unsigned words). When saturating
    to a byte, if the signed source value is less than –128, byte saturation sets
    the value to –128\. When saturating to a word, if the signed source value is less
    than –32,786, signed saturation sets the value to –32,768\. Similarly, if a signed
    byte or word value exceeds +127 or +32,767, then saturation replaces the value
    with +127 or +32,767, respectively. For unsigned operations, saturation limits
    the value to +255 (for bytes) or +65,535 (for words). Unsigned values are never
    less than 0, so unsigned saturation clips values to only +255 or +65,535.
  prefs: []
  type: TYPE_NORMAL
- en: 'AVX-capable CPUs provide 128-bit variants of these instructions that support
    three operands: two source operands and an independent destination operand. These
    instructions (mnemonics the same as the SSE instructions, with a `v` prefix) have
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: These instructions are roughly equivalent to the SSE variants, except that these
    instructions use XMM[src1] as the first source operand rather than XMM[dest] (which
    the SSE instructions use). Also, the SSE instructions do not modify the upper
    bits of the YMM register (if present on the CPU), whereas the AVX instructions
    store 0s into the upper YMM register bits.
  prefs: []
  type: TYPE_NORMAL
- en: AVX2-capable CPUs also allow the use of the YMM registers (and 256-bit memory
    locations) to double the number of values the instruction can saturate (see [Table
    11-26](#table11-26)). Of course, don’t forget to check for AVX2 (and AVX) compatibility
    before using these instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-26: AVX Packed Sign-Extension with Saturation Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Syntax** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `v``packsswb` `ymm`[dest]`,` `ymm`[src1]`,` `ymm`[src2]`/``mem`[256] | Packs
    32 signed word values (from two 256-bit sources) into 32 byte lanes in a 256-bit
    destination register using signed saturation. |'
  prefs: []
  type: TYPE_TB
- en: '| `v``packuswb` `ymm`[dest]`,` `ymm`[src1]`,` `ymm`[src2]`/``mem`[256] | Packs
    32 unsigned word values (from two 256-bit sources) into 32 byte lanes in a 256-bit
    destination register using unsigned saturation. |'
  prefs: []
  type: TYPE_TB
- en: '| `v``packssdw` `ymm`[dest]`,` `ymm`[src1]`,` `ymm`[src2]`/``mem`[256] | Packs
    16 signed dword values (from two 256-bit sources) into 16 word values in a 256-bit
    destination register using signed saturation. |'
  prefs: []
  type: TYPE_TB
- en: '| `v``packusdw` `ymm`[dest]`,` `ymm`[src1]`,` `ymm`[src2]`/``mem`[256] | Packs
    16 unsigned dword values (from two 256-bit sources) into 16 word values in a 256-bit
    destination register using unsigned saturation. |'
  prefs: []
  type: TYPE_TB
- en: 11.11 SIMD Floating-Point Arithmetic Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SSE and AVX instruction set extensions provide packed arithmetic equivalents
    for all the scalar floating-point instructions in “SSE Floating-Point Arithmetic”
    in Chapter 6. This section does not repeat the discussion of the scalar floating-point
    operations; see Chapter 6 for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 128-bit SSE packed floating-point instructions have the following generic
    syntax (where `instr` is one of the floating-point instructions in [Table 11-27](#table11-27)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The *packed single* (`*ps`) instructions perform four single-precision floating-point
    operations simultaneously. The *packed double* (`*pd`) instructions perform two
    double-precision floating-point operations simultaneously. As is typical for SSE
    instructions, these packed arithmetic instructions compute
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: where `lane` varies from 0 to 3 for packed single-precision instructions and
    from 0 to 1 for packed double-precision instructions. `op` represents the operation
    (such as addition or subtraction). When the SSE instructions are executed on a
    CPU that supports the AVX extensions, the SSE instructions leave the upper bits
    of the AVX register unmodified.
  prefs: []
  type: TYPE_NORMAL
- en: The 128-bit AVX packed floating-point instructions have this syntax:^([15](#c11-footnote-15))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: These instructions compute
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: where `op` corresponds to the operation associated with the specific instruction
    (for example, `vaddps` does a packed single-precision addition). These 128-bit
    AVX instructions clear the HO bits of the underlying YMM[dest] register.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 256-bit AVX packed floating-point instructions have this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: These instructions compute
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: where `op` corresponds to the operation associated with the specific instruction
    (for example, `vaddps` is a packed single-precision addition). Because these instructions
    operate on 256-bit operands, they compute twice as many lanes of data as the 128-bit
    instructions. Specifically, they simultaneously compute eight single-precision
    (the `v*ps` instructions) or four double-precision results (the `v*pd` instructions).
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 11-27](#table11-27) provides the list of SSE/AVX packed instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-27: Floating-Point Arithmetic Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Lanes** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `addps` | 4 | Adds four single-precision floating-point values |'
  prefs: []
  type: TYPE_TB
- en: '| `addpd` | 2 | Adds two double-precision floating-point values |'
  prefs: []
  type: TYPE_TB
- en: '| `vaddps` | 4/8 | Adds four (128-bit/XMM operands) or eight (256-bit/YMM operands)
    single-precision values |'
  prefs: []
  type: TYPE_TB
- en: '| `vaddpd` | 2/4 | Adds two (128-bit/XMM operands) or four (256-bit/YMM operands)
    double-precision values |'
  prefs: []
  type: TYPE_TB
- en: '| `subps` | 4 | Subtracts four single-precision floating-point values |'
  prefs: []
  type: TYPE_TB
- en: '| `subpd` | 2 | Subtracts two double-precision floating-point values |'
  prefs: []
  type: TYPE_TB
- en: '| `vsubps` | 4/8 | Subtracts four (128-bit/XMM operands) or eight (256-bit/YMM
    operands) single-precision values |'
  prefs: []
  type: TYPE_TB
- en: '| `vsubpd` | 2/4 | Subtracts two (128-bit/XMM operands) or four (256-bit/YMM
    operands) double-precision values |'
  prefs: []
  type: TYPE_TB
- en: '| `mulps` | 4 | Multiplies four single-precision floating-point values |'
  prefs: []
  type: TYPE_TB
- en: '| `mulpd` | 2 | Multiplies two double-precision floating-point values |'
  prefs: []
  type: TYPE_TB
- en: '| `vmulps` | 4/8 | Multiplies four (128-bit/XMM operands) or eight (256-bit/YMM
    operands) single-precision values |'
  prefs: []
  type: TYPE_TB
- en: '| `vmulpd` | 2/4 | Multiplies two (128-bit/XMM operands) or four (256-bit/YMM
    operands) double-precision values |'
  prefs: []
  type: TYPE_TB
- en: '| `divps` | 4 | Divides four single-precision floating-point values |'
  prefs: []
  type: TYPE_TB
- en: '| `divpd` | 2 | Divides two double-precision floating-point values |'
  prefs: []
  type: TYPE_TB
- en: '| `vdivps` | 4/8 | Divides four (128-bit/XMM operands) or eight (256-bit/YMM
    operands) single-precision values |'
  prefs: []
  type: TYPE_TB
- en: '| `vdivpd` | 2/4 | Divides two (128-bit/XMM operands) or four (256-bit/YMM
    operands) double-precision values |'
  prefs: []
  type: TYPE_TB
- en: '| `maxps` | 4 | Computes the maximum of four pairs of single-precision floating-point
    values |'
  prefs: []
  type: TYPE_TB
- en: '| `maxpd` | 2 | Computes the maximum of two pairs of double-precision floating-point
    values |'
  prefs: []
  type: TYPE_TB
- en: '| `vmaxps` | 4/8 | Computes the maximum of four (128-bit/XMM operands) or eight
    (256-bit/YMM operands) pairs of single-precision values |'
  prefs: []
  type: TYPE_TB
- en: '| `vmaxpd` | 2/4 | Computes the maximum of two (128-bit/XMM operands) or four
    (256-bit/YMM operands) pairs of double-precision values |'
  prefs: []
  type: TYPE_TB
- en: '| `minps` | 4 | Computes the minimum of four pairs of single-precision floating-point
    values |'
  prefs: []
  type: TYPE_TB
- en: '| `minpd` | 2 | Computes the minimum of two pairs of double-precision floating-point
    values |'
  prefs: []
  type: TYPE_TB
- en: '| `vminps` | 4/8 | Computes the minimum of four (128-bit/XMM operands) or eight
    (256-bit/YMM operands) pairs of single-precision values |'
  prefs: []
  type: TYPE_TB
- en: '| `vminpd` | 2/4 | Computes the minimum of two (128-bit/XMM operands) or four
    (256-bit/YMM operands) pairs of double-precision values |'
  prefs: []
  type: TYPE_TB
- en: '| `sqrtps` | 4 | Computes the square root of four single-precision floating-point
    values |'
  prefs: []
  type: TYPE_TB
- en: '| `sqrtpd` | 2 | Computes the square root of two double-precision floating-point
    values |'
  prefs: []
  type: TYPE_TB
- en: '| `vsqrtps` | 4/8 | Computes the square root of four (128-bit/XMM operands)
    or eight (256-bit/YMM operands) single-precision values |'
  prefs: []
  type: TYPE_TB
- en: '| `vsqrtpd` | 2/4 | Computes the square root of two (128-bit/XMM operands)
    or four (256-bit/YMM operands) double-precision values |'
  prefs: []
  type: TYPE_TB
- en: '| `rsqrtps` | 4 | Computes the approximate reciprocal square root of four single-precision
    floating-point values^([*](#c11-footnote-16)) |'
  prefs: []
  type: TYPE_TB
- en: '| `vrsqrtps` | 4/8 | Computes the approximate reciprocal square root of four
    (128-bit/XMM operands) or eight (256-bit/YMM operands) single-precision values
    |'
  prefs: []
  type: TYPE_TB
- en: '| ^([*](#c11-footnoteref-16)) The relative error is ≤ 1.5 × 2^(-12). |'
  prefs: []
  type: TYPE_TB
- en: 'The SSE/AVX instruction set extensions also include floating-point horizontal
    addition and subtraction instructions. The syntax for these instructions is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: As for the integer horizontal addition and subtraction instructions, these instructions
    add or subtract the values in adjacent lanes in the same register and store the
    result in the destination register (lane 2), as shown in [Figure 11-43](#figure11-43).
  prefs: []
  type: TYPE_NORMAL
- en: 11.12 SIMD Floating-Point Comparison Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like the integer packed comparisons, the SSE/AVX floating-point comparisons
    compare two sets of floating-point values (either single- or double-precision,
    depending on the instruction’s syntax) and store a resulting Boolean value (all
    1 bits for true, all 0 bits for false) into the destination lane. However, the
    floating-point comparisons are far more comprehensive than those of their integer
    counterparts. Part of the reason is that floating-point arithmetic is more complex;
    however, an ever-increasing silicon budget for the CPU designers is also responsible
    for this.
  prefs: []
  type: TYPE_NORMAL
- en: 11.12.1 SSE and AVX Comparisons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two sets of basic floating-point comparisons: `(v)cmpps`, which compares
    a set of packed single-precision values, and `(v)cmppd`, which compares a set
    of packed double-precision values. Instead of encoding the comparison type into
    the mnemonic, these instructions use an imm[8] operand whose value specifies the
    type of comparison. The generic syntax for these instructions is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The imm[8] operand specifies the type of the comparison. There are 32 possible
    comparisons, as listed in [Table 11-28](#table11-28).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-28: imm[8] Values for `cmpps` and `cmppd` Instructions^([†](#c11-footnote-17))'
  prefs: []
  type: TYPE_NORMAL
- en: '| **imm[8]** | **Description** | **Result** | **Signal** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | **A < B** | **A = B** | **A > B** | **Unord** |  |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 00h | EQ, ordered, quiet | 0 | 1 | 0 | 0 | No |'
  prefs: []
  type: TYPE_TB
- en: '| 01h | LT, ordered, signaling | 1 | 0 | 0 | 0 | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 02h | LE, ordered, signaling | 1 | 1 | 0 | 0 | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 03h | Unordered, quiet | 0 | 0 | 0 | 1 | No |'
  prefs: []
  type: TYPE_TB
- en: '| 04h | NE, unordered, quiet | 1 | 0 | 1 | 1 | No |'
  prefs: []
  type: TYPE_TB
- en: '| 05h | NLT, unordered, signaling | 0 | 1 | 1 | 1 | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 06h | NLE, unordered, signaling | 0 | 0 | 1 | 1 | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 07h | Ordered, quiet | 1 | 1 | 1 | 0 | No |'
  prefs: []
  type: TYPE_TB
- en: '| 08h | EQ, unordered, quiet | 0 | 1 | 0 | 1 | No |'
  prefs: []
  type: TYPE_TB
- en: '| 09h | NGE, unordered, signaling | 1 | 0 | 0 | 1 | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 0Ah | NGT, unordered, signaling | 1 | 1 | 0 | 1 | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 0Bh | False, ordered, quiet | 0 | 0 | 0 | 0 | No |'
  prefs: []
  type: TYPE_TB
- en: '| 0Ch | NE, ordered, quiet | 1 | 0 | 1 | 0 | No |'
  prefs: []
  type: TYPE_TB
- en: '| 0Dh | GE, ordered, signaling | 0 | 1 | 1 | 0 | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 0Eh | GT, ordered, signaling | 0 | 0 | 1 | 0 | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 0Fh | True, unordered, quiet | 1 | 1 | 1 | 1 | No |'
  prefs: []
  type: TYPE_TB
- en: '| 10h | EQ, ordered, signaling | 0 | 1 | 0 | 0 | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 11h | LT, ordered, quiet | 1 | 0 | 0 | 0 | No |'
  prefs: []
  type: TYPE_TB
- en: '| 12h | LE, ordered, quiet | 1 | 1 | 0 | 0 | No |'
  prefs: []
  type: TYPE_TB
- en: '| 13h | Unordered, signaling | 0 | 0 | 0 | 1 | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 14h | NE, unordered, signaling | 1 | 0 | 1 | 1 | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 15h | NLT, unordered, quiet | 0 | 1 | 1 | 1 | No |'
  prefs: []
  type: TYPE_TB
- en: '| 16h | NLE, unordered, quiet | 0 | 0 | 1 | 1 | No |'
  prefs: []
  type: TYPE_TB
- en: '| 17h | Ordered, signaling | 1 | 1 | 1 | 0 | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 18h | EQ, unordered, signaling | 0 | 1 | 0 | 1 | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 19h | NGE, unordered, quiet | 1 | 0 | 0 | 1 | No |'
  prefs: []
  type: TYPE_TB
- en: '| 1Ah | NGT, unordered, quiet | 1 | 1 | 0 | 1 | No |'
  prefs: []
  type: TYPE_TB
- en: '| 1Bh | False, ordered, signaling | 0 | 0 | 0 | 0 | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 1Ch | NE, ordered, signaling | 1 | 0 | 1 | 0 | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 1Dh | GE, ordered, quiet | 0 | 1 | 1 | 0 | No |'
  prefs: []
  type: TYPE_TB
- en: '| 1Eh | GT, ordered, quiet | 0 | 0 | 1 | 0 | No |'
  prefs: []
  type: TYPE_TB
- en: '| 1Fh | True, unordered, signaling | 1 | 1 | 1 | 1 | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| ^([†](#c11-footnoteref-17)) The darker shaded entries are available only
    on CPUs that support AVX extensions. |'
  prefs: []
  type: TYPE_TB
- en: The “true” and “false” comparisons always store true or false into the destination
    lanes. For the most part, these comparisons aren’t particularly useful. The `pxor`,
    `xorps`, `xorpd`, `vxorps`, and `vxorpd` instructions are probably better for
    setting an XMM or a YMM register to 0\. Prior to AVX2, using a true comparison
    was the shortest instruction that would set all bits in an XMM or a YMM register
    to 1, though `pcmpeqb` is commonly used as well (be aware of microarchitectural
    inefficiencies with this latter instruction).
  prefs: []
  type: TYPE_NORMAL
- en: Note that non-AVX CPUs do not implement the GT, GE, NGT, and NGE instructions.
    On these CPUs, use the inverse operation (for example, NLT for GE) or swap the
    operands and use the opposite condition (as was done for the packed integer comparisons).
  prefs: []
  type: TYPE_NORMAL
- en: 11.12.2 Unordered vs. Ordered Comparisons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The unordered relationship is true when at least one of the two source operands
    being compared is a NaN; the ordered relationship is true when neither source
    operand is a NaN. Having ordered and unordered comparisons allows you to pass
    error conditions through comparisons as false or true, depending on how you interpret
    the final Boolean results appearing in the lanes. Unordered results, as their
    name implies, are incomparable. When you compare two values, one of which is not
    a number, you must always treat the result as a failed comparison.
  prefs: []
  type: TYPE_NORMAL
- en: To handle this situation, you use an ordered or unordered comparison to force
    the result to be false or true, the opposite of what you ultimately expect when
    using the comparison result. For example, suppose you are comparing a sequence
    of values and want the resulting masks to be true if all the comparisons are valid
    (for example, you’re testing to see if all the src[1] values are greater than
    the corresponding src[2] values). You would use an ordered comparison in this
    situation that would force a particular lane to false if one of the values being
    compared is NaN. On the other hand, if you’re checking to see if all the conditions
    are false after the comparison, you’d use an unordered comparison to force the
    result to true if any of the values are NaN.
  prefs: []
  type: TYPE_NORMAL
- en: 11.12.3 Signaling and Quiet Comparisons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The signaling comparisons generate an invalid arithmetic operation exception
    (IA) when an operation produces a quiet NaN. The quiet comparisons do not throw
    an exception and reflect only the status in the MXCSR (see “SSE MXCSR Register”
    in Chapter 6). Note that you can also mask signaling exceptions in the MXCSR register;
    you must explicitly set the IM (*invalid operation mask*, bit 7) in the MXCSR
    to 0 if you want to allow exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 11.12.4 Instruction Synonyms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MASM supports the use of certain synonyms so you don’t have to memorize the
    32 encodings. [Table 11-29](#table11-29) lists these synonyms. In this table,
    *x1* denotes the destination operand (XMM[*n*] or YMM[*n*]), and *x2* denotes
    the source operand (XMM[*n*]/mem[128] or YMM[*n*]/mem[256], as appropriate).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-29: Synonyms for Common Packed Floating-Point Comparisons'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Synonym** | **Instruction** | **Synonym** | **Instruction** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cmpeqps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 0` | `cmpeqpd` `x1``,` `x2`
    | `cmppd` `x1``,` `x2``, 0` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmpltps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 1` | `cmpltpd` `x1``,` `x2`
    | `cmppd` `x1``,` `x2``, 1` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmpleps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 2` | `cmplepd` `x1``,` `x2`
    | `cmppd` `x1``,` `x2``, 2` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmpunordps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 3` | `cmpunordpd` `x1``,`
    `x2` | `cmppd x1, x2, 3` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmpneqps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 4` | `cmpneqpd` `x1``,`
    `x2` | `cmppd` `x1``,` `x2``, 4` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmpnltps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 5` | `cmpnltpd` `x1``,`
    `x2` | `cmppd` `x1``,` `x2``, 5` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmpnleps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 6` | `cmpnlepd` `x1``,`
    `x2` | `cmppd` `x1``,` `x2``, 6` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmpordps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 7` | `cmpordpd` `x1``,`
    `x2` | `cmppd` `x1``,` `x2``, 7` |'
  prefs: []
  type: TYPE_TB
- en: The synonyms allow you to write instructions such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: rather than
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, using the synonym makes the code much easier to read and understand.
    There aren’t synonyms for all the possible comparisons. To create readable synonyms
    for the instructions MASM doesn’t support, you can use a macro (or a more readable
    symbolic constant). For more information on macros, see Chapter 13.
  prefs: []
  type: TYPE_NORMAL
- en: 11.12.5 AVX Extended Comparisons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The AVX versions of these instructions allow three register operands: a destination
    XMM or YMM register, a source XMM or YMM register, and a source XMM or YMM register
    or 128-bit or 256-bit memory location (followed by the imm[8] operand specifying
    the type of the comparison). The basic syntax is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The 128-bit `vcmpps` instruction compares the four single-precision floating-point
    values in each lane of the XMM[src1] register against the values in the corresponding
    XMM[src2]/mem[128] lanes and stores the true (all 1 bits) or false (all 0 bits)
    result into the corresponding lane of the XMM[dest] register. The 256-bit `vcmpps`
    instruction compares the eight single-precision floating-point values in each
    lane of the YMM[src1] register against the values in the corresponding YMM[src2]/mem[256]
    lanes and stores the true or false result into the corresponding lane of the YMM[dest]
    register.
  prefs: []
  type: TYPE_NORMAL
- en: The `vcmppd` instructions compare the double-precision values in the two lanes
    (128-bit version) or four lanes (256-bit version) and store the result into the
    corresponding lane of the destination register.
  prefs: []
  type: TYPE_NORMAL
- en: As for the SSE compare instructions, the AVX instructions provide synonyms that
    eliminate the need to memorize 32 imm[8] values. [Table 11-30](#table11-30) lists
    the 32 instruction synonyms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-30: AVX Packed Compare Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **imm[8]** | **Instruction** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 00h | `vcmpeqps` or `vcmpeqpd` |'
  prefs: []
  type: TYPE_TB
- en: '| 01h | `vcmpltps` or `vcmpltpd` |'
  prefs: []
  type: TYPE_TB
- en: '| 02h | `vcmpleps` or `vcmplepd` |'
  prefs: []
  type: TYPE_TB
- en: '| 03h | `vcmpunordps` or `vcmpunordpd` |'
  prefs: []
  type: TYPE_TB
- en: '| 04h | `vcmpneqps` or `vcmpneqpd` |'
  prefs: []
  type: TYPE_TB
- en: '| 05h | `vcmpltps` or `vcmpltpd` |'
  prefs: []
  type: TYPE_TB
- en: '| 06h | `vcmpleps` or `vcmplepd` |'
  prefs: []
  type: TYPE_TB
- en: '| 07h | `vcmpordps` or `vcmpordpd` |'
  prefs: []
  type: TYPE_TB
- en: '| 08h | `vcmpeq_uqps` or `vcmpeq_uqpd` |'
  prefs: []
  type: TYPE_TB
- en: '| 09h | `vcmpngeps` or `vcmpngepd` |'
  prefs: []
  type: TYPE_TB
- en: '| 0Ah | `vcmpngtps` or `vcmpngtpd` |'
  prefs: []
  type: TYPE_TB
- en: '| 0Bh | `vcmpfalseps` or `vcmpfalsepd` |'
  prefs: []
  type: TYPE_TB
- en: '| 0Ch | `vcmpneq_oqps` or `vcmpneq_oqpd` |'
  prefs: []
  type: TYPE_TB
- en: '| 0Dh | `vcmpgeps` or `vcmpgepd` |'
  prefs: []
  type: TYPE_TB
- en: '| 0Eh | `vcmpgtps` or `vcmpgtpd` |'
  prefs: []
  type: TYPE_TB
- en: '| 0Fh | `vcmptrueps` or `vcmptruepd` |'
  prefs: []
  type: TYPE_TB
- en: '| 10h | `vcmpeq_osps` or `vcmpeq_ospd` |'
  prefs: []
  type: TYPE_TB
- en: '| 11h | `vcmplt_oqps` or `vcmplt_oqpd` |'
  prefs: []
  type: TYPE_TB
- en: '| 12h | `vcmple_oqps` or `vcmple_oqpd` |'
  prefs: []
  type: TYPE_TB
- en: '| 13h | `vcmpunord_sps` or `vcmpunord_spd` |'
  prefs: []
  type: TYPE_TB
- en: '| 14h | `vcmpneq_usps` or `vcmpneq_uspd` |'
  prefs: []
  type: TYPE_TB
- en: '| 15h | `vcmpnlt_uqps` or `vcmpnlt_uqpd` |'
  prefs: []
  type: TYPE_TB
- en: '| 16h | `vcmpnle_uqps` or `vcmpnle_uqpd` |'
  prefs: []
  type: TYPE_TB
- en: '| 17h | `vcmpord_sps` or `vcmpord_spd` |'
  prefs: []
  type: TYPE_TB
- en: '| 18h | `vcmpeq_usps` or `vcmpeq_uspd` |'
  prefs: []
  type: TYPE_TB
- en: '| 19h | `vcmpnge_uqps` or `vcmpnge_uqpd` |'
  prefs: []
  type: TYPE_TB
- en: '| 1Ah | `vcmpngt_uqps` or `vcmpngt_uqpd` |'
  prefs: []
  type: TYPE_TB
- en: '| 1Bh | `vcmpfalse_osps` or `vcmpfalse_ospd` |'
  prefs: []
  type: TYPE_TB
- en: '| 1Ch | `vcmpneq_osps` or `vcmpneq_ospd` |'
  prefs: []
  type: TYPE_TB
- en: '| 1Dh | vcmpge_oqps or `vcmpge_oqpd` |'
  prefs: []
  type: TYPE_TB
- en: '| 1Eh | `vcmpgt_oqps` or `vcmpgt_oqpd` |'
  prefs: []
  type: TYPE_TB
- en: '| 1Fh | `vcmptrue_usps` or `vcmptrue_uspd` |'
  prefs: []
  type: TYPE_TB
- en: 11.12.6 Using SIMD Comparison Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As for the integer comparisons (see “Using Packed Comparison Results” on page
    662), the floating-point comparison instructions produce a vector of Boolean results
    that you use to mask further operations on data lanes. You can use the packed
    logical instructions (`pand` and `vpand`, `pandn` and `vpandn`, `por` and `vpor`,
    and `pxor` and `vpxor`) to manipulate these results. You could extract the individual
    lane values and test them with a conditional jump, though this is definitely not
    the SIMD way of doing things; the following section describes one way to extract
    these masks.
  prefs: []
  type: TYPE_NORMAL
- en: 11.12.7 The (v)movmskps, (v)movmskpd Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `movmskps` and `movmskpd` instructions extract the sign bits from their
    packed single- and double-precision floating-point source operands and store these
    bits into the LO 4 (or 8) bits of a general-purpose register. The syntax is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: where `reg` is any 32-bit or 64-bit general-purpose integer register.
  prefs: []
  type: TYPE_NORMAL
- en: The `movmskps` instruction extracts the sign bits from the four single-precision
    floating-point values in the XMM source register and copies these bits to the
    LO 4 bits of the destination register, as shown in [Figure 11-45](#figure11-45).
  prefs: []
  type: TYPE_NORMAL
- en: The `movmskpd` instruction copies the sign bits from the two double-precision
    floating-point values in the source XMM register to bits 0 and 1 of the destination
    register, as [Figure 11-46](#figure11-46) shows.
  prefs: []
  type: TYPE_NORMAL
- en: The `vmovmskps` instruction extracts the sign bits from the four and eight single-precision
    floating-point values in the XMM and YMM source register and copies these bits
    to the LO 4 and 8 bits of the destination register. [Figure 11-47](#figure11-47)
    shows this operation with a YMM source register.
  prefs: []
  type: TYPE_NORMAL
- en: '![f11045](image_fi/501089c11/f11045.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-45: `movmskps` operation'
  prefs: []
  type: TYPE_NORMAL
- en: '![f11046](image_fi/501089c11/f11046.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-46: `movmskpd` operation'
  prefs: []
  type: TYPE_NORMAL
- en: '![f11047](image_fi/501089c11/f11047.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-47: `vmovmskps` operation'
  prefs: []
  type: TYPE_NORMAL
- en: The `vmovmskpd` instruction copies the sign bits from the four double-precision
    floating-point values in the source YMM register to bits 0 to 3 of the destination
    register, as shown in [Figure 11-48](#figure11-48).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11048](image_fi/501089c11/f11048.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-48: `vmovmskpd` operation'
  prefs: []
  type: TYPE_NORMAL
- en: This instruction, with an XMM source register, will copy the sign bits from
    the two double-precision floating-point values into bits 0 and 1 of the destination
    register. In all cases, these instructions zero-extend the results into the upper
    bits of the general-purpose destination register. Note that these instructions
    do not allow memory operands.
  prefs: []
  type: TYPE_NORMAL
- en: Although the stated data type for these instructions is packed single-precision
    and packed double-precision, you will also use these instructions on 32-bit integers
    (`movmskps` and `vmovmskps`) and 64-bit integers (`movmskpd` and `vmovmskpd`).
    Specifically, these instructions are perfect for extracting 1-bit Boolean values
    from the various lanes after one of the (dword or qword) packed integer comparisons
    as well as after the single- or double-precision floating-point comparisons (remember
    that although the packed floating-point comparisons compare floating-point values,
    their results are actually integer values).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following instruction sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Because `movmskpd` extracts 2 bits from XMM0 and stores them into RAX, this
    code can use RAX as an index into a jump table to select four different branch
    labels. The code at label `nene` executes if both comparisons produce not equal;
    label `neeq` is the target when the lane 0 values are equal but the lane 1 values
    are not equal. Label `eqne` is the target when the lane 0 values are not equal
    but the lane 1 values are equal. Finally, label `eqeq` is where this code branches
    when both sets of lanes contain equal values.
  prefs: []
  type: TYPE_NORMAL
- en: 11.13 Floating-Point Conversion Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously, I described several instructions to convert data between various
    scalar floating-point and integer formats (see “SSE Floating-Point Conversions”
    in Chapter 6). Variants of these instructions also exist for packed data conversions.
    [Table 11-31](#table11-31) lists many of these instructions you will commonly
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-31: SSE Conversion Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction syntax** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cvtdq2pd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | Converts two packed signed
    double-word integers from XMM[src]/mem[64] to two packed double-precision floating-point
    values in XMM[dest]. If YMM register is present, this instruction leaves the HO
    bits unchanged. |'
  prefs: []
  type: TYPE_TB
- en: '| `vcvtdq2pd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | (AVX) Converts two packed
    signed double-word integers from XMM[src]/mem[64] to two packed double-precision
    floating-point values in XMM[dest]. This instruction stores 0s into the HO bits
    of the underlying YMM register. |'
  prefs: []
  type: TYPE_TB
- en: '| `vcvtdq2pd` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts four
    packed signed double-word integers from XMM[src]/mem[128] to four packed double-precision
    floating-point values in YMM[dest]. |'
  prefs: []
  type: TYPE_TB
- en: '| `cvtdq2ps` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Converts four packed
    signed double-word integers from XMM[src]/mem[128] to four packed single-precision
    floating-point values in XMM[dest]. If YMM register is present, this instruction
    leaves the HO bits unchanged. |'
  prefs: []
  type: TYPE_TB
- en: '| `vcvtdq2ps` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts four
    packed signed double-word integers from XMM[src]/mem[128] to four packed single-precision
    floating-point values in XMM[dest]. If YMM register is present, this instruction
    writes 0s to the HO bits. |'
  prefs: []
  type: TYPE_TB
- en: '| `vcvtdq2ps` `ymm`[dest]`,` `ymm`[src]`/``mem`[256] | (AVX) Converts eight
    packed signed double-word integers from YMM[src]/mem[256] to eight packed single-precision
    floating-point values in YMM[dest]. If YMM register is present, this instruction
    writes 0s to the HO bits. |'
  prefs: []
  type: TYPE_TB
- en: '| `cvtpd2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Converts two packed double-precision
    floating-point values from XMM[src]/mem[128] to two packed signed double-word
    integers in XMM[dest]. If YMM register is present, this instruction leaves the
    HO bits unchanged. The conversion from floating-point to integer uses the current
    SSE rounding mode. |'
  prefs: []
  type: TYPE_TB
- en: '| `vcvtpd2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts two packed
    double-precision floating-point values from XMM[src]/mem[128] to two packed signed
    double-word integers in XMM[dest]. This instruction stores 0s into the HO bits
    of the underlying YMM register. The conversion from floating-point to integer
    uses the current AVX rounding mode. |'
  prefs: []
  type: TYPE_TB
- en: '| `vcvtpd2dq` `xmm`[dest]`,` `ymm`[src]`/``mem`[256] | (AVX) Converts four
    packed double-precision floating-point values from YMM[src]/mem[256] to four packed
    signed double-word integers in XMM[dest]. The conversion of floating-point to
    integer uses the current AVX rounding mode. |'
  prefs: []
  type: TYPE_TB
- en: '| `cvtpd2ps` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Converts two packed double-precision
    floating-point values from XMM[src]/mem[128] to two packed single-precision floating-point
    values in XMM[dest]. If YMM register is present, this instruction leaves the HO
    bits unchanged. |'
  prefs: []
  type: TYPE_TB
- en: '| `vcvtpd2ps` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts two packed
    double-precision floating-point values from XMM[src]/mem[128] to two packed single-precision
    floating-point values in XMM[dest]. This instruction stores 0s into the HO bits
    of the underlying YMM register. |'
  prefs: []
  type: TYPE_TB
- en: '| `vcvtpd2ps` `xmm`[dest]`,` `ymm`[src]`/``mem`[256] | (AVX) Converts four
    packed double-precision floating-point values from YMM[src]/mem[256] to four packed
    single-precision floating-point values in YMM[dest]. |'
  prefs: []
  type: TYPE_TB
- en: '| `cvtps2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Converts four packed
    single-precision floating-point values from XMM[src]/mem[128] to four packed signed
    double-word integers in XMM[dest]. If YMM register is present, this instruction
    leaves the HO bits unchanged. The conversion of floating-point to integer uses
    the current SSE rounding mode. |'
  prefs: []
  type: TYPE_TB
- en: '| `vcvtps2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts four
    packed single-precision floating-point values from XMM[src]/mem[128] to four packed
    signed double-word integers in XMM[dest]. This instruction stores 0s into the
    HO bits of the underlying YMM register. The conversion of floating-point to integer
    uses the current AVX rounding mode. |'
  prefs: []
  type: TYPE_TB
- en: '| `vcvtps2dq` `ymm`[dest]`,` `ymm`[src]`/``mem`[256] | (AVX) Converts eight
    packed single-precision floating-point values from YMM[src]/mem[256] to eight
    packed signed double-word integers in YMM[dest]. The conversion of floating-point
    to integer uses the current AVX rounding mode. |'
  prefs: []
  type: TYPE_TB
- en: '| `cvtps2pd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | Converts two packed single-precision
    floating-point values from XMM[src]/mem[64] to two packed double-precision values
    in XMM[dest]. If YMM register is present, this instruction leaves the HO bits
    unchanged. |'
  prefs: []
  type: TYPE_TB
- en: '| `vcvtps2pd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | (AVX) Converts two packed
    single-precision floating-point values from XMM[src]/mem[64] to two packed double-precision
    values in XMM[dest]. This instruction stores 0s into the HO bits of the underlying
    YMM register. |'
  prefs: []
  type: TYPE_TB
- en: '| `vcvtps2pd` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts four
    packed single-precision floating-point values from XMM[src]/mem[128] to four packed
    double-precision values in YMM[dest]. |'
  prefs: []
  type: TYPE_TB
- en: '| `cvttpd2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Converts two packed
    double-precision floating-point values from XMM[src]/mem[128] to two packed signed
    double-word integers in XMM[dest] using truncation. If YMM register is present,
    this instruction leaves the HO bits unchanged. |'
  prefs: []
  type: TYPE_TB
- en: '| `vcvttpd2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts two
    packed double-precision floating-point values from XMM[src]/mem[128] to two packed
    signed double-word integers in XMM[dest] using truncation. This instruction stores
    0s into the HO bits of the underlying YMM register. |'
  prefs: []
  type: TYPE_TB
- en: '| `vcvttpd2dq` `xmm`[dest]`,` `ymm`[src]`/``mem`[256] | (AVX) Converts four
    packed double-precision floating-point values from YMM[src]/mem[256] to four packed
    signed double-word integers in XMM[dest] using truncation. |'
  prefs: []
  type: TYPE_TB
- en: '| `cvttps2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Converts four packed
    single-precision floating-point values from XMM[src]/mem[128] to four packed signed
    double-word integers in XMM[dest] using truncation. If YMM register is present,
    this instruction leaves the HO bits unchanged. |'
  prefs: []
  type: TYPE_TB
- en: '| `vcvttps2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts four
    packed single-precision floating-point values from XMM[src]/mem[128] to four packed
    signed double-word integers in XMM[dest] using truncation. This instruction stores
    0s into the HO bits of the underlying YMM register. |'
  prefs: []
  type: TYPE_TB
- en: '| `vcvttps2dq` `ymm`[dest]`,` `ymm`[src]`/``mem`[256] | (AVX) Converts eight
    packed single-precision floating-point values from YMM[src]/mem[256] to eight
    packed signed double-word integers in YMM[dest] using truncation. |'
  prefs: []
  type: TYPE_TB
- en: 11.14 Aligning SIMD Memory Accesses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most SSE and AVX instructions require their memory operands to be on a 16-byte
    (SSE) or 32-byte (AVX) boundary, but this is not always possible. The easiest
    way to handle unaligned memory addresses is to use instructions that don’t require
    aligned memory operands, like `movdqu`, `movups`, and `movupd`. However, the performance
    hit of using unaligned data movement instructions often defeats the purpose of
    using SSE/AVX instructions in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, the trick to aligning data for use by SIMD instructions is to process
    the first few data items by using standard general-purpose registers until you
    reach an address that is aligned properly. For example, suppose you want to use
    the `pcmpeqb` instruction to compare blocks of 16 bytes in a large array of bytes.
    `pcmpeqb` requires its memory operands to be at 16-byte-aligned addresses, so
    if the memory operand is not already 16-byte-aligned, you can process the first
    1 to 15 bytes in the array by using standard (non-SSE) instructions until you
    reach an appropriate address for `pcmpeqb`; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: ANDing RSI with 0Fh produces a 0 result (and sets the zero flag) if the LO 4
    bits of RSI contain 0\. If the LO 4 bits of RSI contain 0, the address it contains
    is aligned on a 16-byte boundary.^([16](#c11-footnote-18))
  prefs: []
  type: TYPE_NORMAL
- en: The only drawback to this approach is that you must process as many as 15 bytes
    individually until you get an appropriate address. That’s 6 × 15, or 90, machine
    instructions. However, for large blocks of data (say, more than about 48 or 64
    bytes), you amortize the cost of the single-byte comparisons, and this approach
    isn’t so bad.
  prefs: []
  type: TYPE_NORMAL
- en: To improve the performance of this code, you can modify the initial address
    so that it begins at a 16-byte boundary. ANDing the value in RSI (in this particular
    example) with 0FFFFFFFFFFFFFFF0h (–16) modifies RSI so that it holds the address
    of the start of the 16-byte block containing the original address:^([17](#c11-footnote-19))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid matching unintended bytes before the start of the data structure,
    we can create a mask to cover the extra bytes. For example, suppose that we’re
    using the following instruction sequence to rapidly compare 16 bytes at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use the AND instruction to align the RSI register prior to the execution
    of this code, we might get false results when we compare the first 16 bytes. To
    solve this, we can create a mask that will eliminate any bits from unintended
    comparisons. To create this mask, we start with all 1 bits and zero out any bits
    corresponding to addresses from the beginning of the 16-byte block to the first
    actual data item we’re comparing. This mask can be calculated using the following
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates 0 bits in the locations before the data to compare and 1 bit thereafter
    (for the first 16 bytes). We can use this mask to zero out the undesired bit results
    from the `pmovmskb` instruction. The following code snippet demonstrates this
    technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Suppose, for example, that the address is already aligned on a 16-byte boundary.
    ANDing that value with 0Fh produces 0\. Shifting –1 to the left zero positions
    produces –1 (all 1 bits). Later, when the code logically ANDs this with the mask
    obtained after the `pcmpeqb` and `pmovmskb` instructions, the result does not
    change. Therefore, the code tests all 16 bytes (as we would want if the original
    address is 16-byte-aligned).
  prefs: []
  type: TYPE_NORMAL
- en: When the address in RSI has the value 0001b in the LO 4 bits, the actual data
    starts at offset 1 into the 16-byte block. So, we want to ignore the first byte
    when comparing the values in XMM2 against the 16 bytes at [RSI]. In this case,
    the mask is 0FFFFFFFEh, which is all 1s except for a 0 in bit 0\. After the comparison,
    if bit 0 of EAX contains a 1 (meaning the bytes at offset 0 match), the AND operation
    eliminates this bit (replacing it with 0) so it doesn’t affect the comparison.
    Likewise, if the starting offset into the block is 2, 3, . . . , 15, the `shl`
    instruction modifies the bit mask in EBX to eliminate bytes at those offsets from
    consideration in the first compare operation. The result is that it takes only
    11 instructions to do the same work as (up to) 90+ instructions in the original
    (byte-by-byte comparison) example.
  prefs: []
  type: TYPE_NORMAL
- en: 11.15 Aligning Word, Dword, and Qword Object Addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When aligning non-byte-sized objects, you increment the pointer by the size
    of the object (in bytes) until you obtain an address that is 16- (or 32-) byte-aligned.
    However, this works only if the object size is 2, 4, or 8 (because any other value
    will likely miss addresses that are multiples of 16).
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can process the first several elements of an array of word
    objects (where the first element of the array appears at an even address in memory)
    on a word-by-word basis, incrementing the pointer by 2, until you obtain an address
    that is divisible by 16 (or 32). Note, though, that this scheme works only if
    the array of objects begins at an address that is a multiple of the element size.
    For example, if an array of word values begins at an odd address in memory, you
    will not be able to get an address that is divisible by 16 or 32 with a series
    of additions by 2, and you would not be able to use SSE/AVX instructions to process
    this data without first moving it to another location in memory that is properly
    aligned.
  prefs: []
  type: TYPE_NORMAL
- en: 11.16 Filling an XMM Register with Several Copies of the Same Value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For many SIMD algorithms, you will want multiple copies of the same value in
    an XMM or a YMM register. You can use the `(v)movddup`, `(v)movshdup`, `(v)pinsd`,
    `(v)pinsq`, and `(v)pshufd` instructions for single-precision and double-precision
    floating-point values. For example, if you have a single-precision floating-point
    value, `r4var`, in memory and you want to replicate it throughout XMM0, you could
    use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'To copy a pair of double-precision floating-point values from `r8var` into
    XMM0, you could use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Of course, `pshufd` is really intended for double-word integer operations, so
    additional latency (time) may be involved in using `pshufd` immediately after
    `movsd` or `movss`. Although `pshufd` allows a memory operand, that operand must
    be a 16-byte-aligned 128-bit-memory operand, so it’s not useful for directly copying
    a floating-point value through an XMM register.
  prefs: []
  type: TYPE_NORMAL
- en: 'For double-precision floating-point values, you can use `movddup` to duplicate
    a single 64-bit float in the LO bits of an XMM register into the HO bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: The `movddup` instruction allows unaligned 64-bit memory operands, so it’s probably
    the best choice for duplicating double-precision values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To copy byte, word, dword, or qword integer values throughout an XMM register,
    the `pshufb`, `pshufw`, `pshufd`, or `pshufq` instructions are a good choice.
    For example, to replicate a single byte throughout XMM0, you could use the following
    sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The XMM1 operand is an array of bytes containing masks used to copy data from
    locations in XMM0 onto itself. The value 0 copies byte 0 in XMM0 throughout all
    the other bits in XMM0\. This same code can be used to copy words, dwords, and
    qwords by simply changing the mask value in XMM1\. Or you could use the `pshuflw`
    or `pshufd` instructions to do the job. Here’s another variant that replicates
    a byte throughout XMM0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 11.17 Loading Some Common Constants Into XMM and YMM Registers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No SSE/AVX instructions let you load an immediate constant into a register.
    However, you can use a couple of idioms (tricks) to load certain common constant
    values into an XMM or a YMM register. This section discusses some of these idioms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading 0 into an SSE/AVX register uses the same idiom that general-purpose
    integer registers employ: exclusive-OR the register with itself. For example,
    to set all the bits in XMM0 to 0s, you would use the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'To set all the bits in an XMM or a YMM register to 1, you can use the `pcmpeqb`
    instruction, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Because any given XMM or YMM register is equal to itself, this instruction stores
    0FFh in all the bytes of XMM0 (or whatever XMM or YMM register you specify).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to load the 8-bit value 01h into all 16 bytes of an XMM register,
    you can use the following code (this comes from Intel):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: You can substitute `psubw` or `psubd` for `psubb` in this example if you want
    to create 16- or 32-bit results (for example, four 32-bit dwords in XMM0, each
    containing the value 00000001h).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like the 1 bit in a different bit position (rather than bit 0
    of each byte), you can use the `pslld` instruction after the preceding sequence
    to reposition the bits. For example, if you want to load the XMM0 register with
    8080808080808080h, you could use the following instruction sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you can supply a different immediate constant to `pslld` to load
    each byte in the register with 02h, 04h, 08h, 10h, 20h, or 40h.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a neat trick you can use to load 2^(*n*) – 1 (all 1 bits up to the *n*th
    bit in a number) into all the lanes on an SSE/AVX register:^([18](#c11-footnote-20))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also load the inverse (NOT(2^(*n*) – 1), all 1 bits in bit position
    *n* through the end of the register) by shifting to the left rather than the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you can also load a “constant” into an XMM or a YMM register by putting
    that constant into a memory location (preferably 16- or 32-byte-aligned) and then
    using a `movdqu` or `movdqa` instruction to load that value into a register. Do
    keep in mind, however, that such an operation can be relatively slow if the data
    in memory does not appear in cache. Another possibility, if the constant is small
    enough, is to load the constant into a 32- or 64-bit integer register and use
    `movd` or `movq` to copy that value into an XMM register.
  prefs: []
  type: TYPE_NORMAL
- en: 11.18 Setting, Clearing, Inverting, and Testing a Single Bit in an SSE Register
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s another set of tricks suggested by Raymond Chen ([https://blogs.msdn.microsoft.com/oldnewthing/20141222-00/?p=43333/](https://blogs.msdn.microsoft.com/oldnewthing/20141222-00/?p=43333/))
    to set, clear, or test an individual bit in an XMM register.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set an individual bit (bit *n*, assuming that *n* is a constant) with all
    other bits cleared, you can use the following macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you can fill an XMM register with a single set bit, you can use that register’s
    value to set, clear, invert, or test that bit in another XMM register. For example,
    to set bit *n* in XMM1, without affecting any of the other bits in XMM1, you could
    use the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'To clear bit *n* in an XMM register, you use the same sequence but substitute
    the `vpandn` (AND NOT) instruction for the `por` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'To invert a bit, simply substitute `pxor` for `por` or `vpandn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'To test a bit to see if it is set, you have a couple of options. If your CPU
    supports the SSE4.1 instruction set extensions, you can use the `ptest` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have an older CPU that doesn’t support the `ptest` instruction, you
    can use `pmovmskb` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 11.19 Processing Two Vectors by Using a Single Incremented Index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes your code will need to process two blocks of data simultaneously,
    incrementing pointers into both blocks during the execution of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'One easy way to do this is to use the scaled-indexed addressing mode. If R8
    and R9 contain pointers to the data you want to process, you can walk along both
    blocks of data by using code such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'This code marches along through the two dword arrays comparing values (to search
    for an equal value in the arrays at the same index). This loop uses four registers:
    EAX to compare the two values from the arrays, the two pointers to the arrays
    (R8 and R9), and then the RCX index register to step through the two arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to eliminate RCX from this loop by incrementing the R8 and R9
    registers in this loop (assuming it’s okay to modify the values in R8 and R9):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: This scheme requires an extra `add` instruction in the loop. If the execution
    speed of this loop is critical, inserting this extra addition could be a deal
    breaker.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, a sneaky trick you can use so that you have to increment
    only a single register on each iteration of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The comments are there because they explain the trick being used. At the beginning
    of the code, you subtract the value of R8 from R9 and leave the result in R9\.
    In the body of the loop, you compensate for this subtraction by using the `[r9][r8
    * 1]` scaled-indexed addressing mode (whose effective address is the sum of R8
    and R9, thus restoring R9 to its original value, at least on the first iteration
    of the loop). Now, because the `cmp` instruction’s memory address is the sum of
    R8 and R9, adding 4 to R8 also adds 4 to the effective address used by the `cmp`
    instruction. Therefore, on each iteration of the loop, the `mov` and `cmp` instructions
    look at successive elements of their respective arrays, yet the code has to increment
    only a single pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'This scheme works especially well when processing SIMD arrays with SSE and
    AVX instructions because the XMM and YMM registers are 16 and 32 bytes each, so
    you can’t use normal scaling factors (1, 2, 4, or 8) to index into an array of
    packed data values. You wind up having to add 16 (or 32) to your pointers when
    stepping through the arrays, thus losing one of the benefits of the scaled-indexed
    addressing mode. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 11.20 Aligning Two Addresses to a Boundary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `vmovapd` and `vaddpd` instructions from the preceding example require
    their memory operands to be 32-byte-aligned or you will get a general protection
    fault (memory access violation). If you have control over the placement of the
    arrays in memory, you can specify an alignment for the arrays. If you have no
    control over the data’s placement in memory, you have two options: working with
    the unaligned data regardless of the performance loss, or moving the data to a
    location where it is properly aligned.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you must work with unaligned data, you can substitute an unaligned move
    for an aligned move (for example, `vmovupd` for `vmovdqa`) or load the data into
    a YMM register by using an unaligned move and then operate on the data in that
    register by using your desired instruction. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Sadly, the `vaddpd` instruction does not support unaligned access to memory,
    so you must load the value from the second array (pointed at by R9) into another
    register (YMM1) before the packed addition operation. This is the drawback to
    unaligned access: not only are unaligned moves slower, but you also may need to
    use additional registers and instructions to deal with unaligned data.'
  prefs: []
  type: TYPE_NORMAL
- en: Moving the data to a memory location whose alignment you can control is an option
    when you have a data operand you will be using over and over again in the future.
    Moving data is an expensive operation; however, if you have a standard block of
    data you’re going to compare against many other blocks, you can amortize the cost
    of moving that block to a new location over all the operations you need to do.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the data is especially useful when one (or both) of the data arrays appears
    at an address that is not an integral multiple of the sub-elements’s size. For
    example, if you have an array of dwords that begin at an odd address, you will
    never be able to align a pointer to that array’s data to a 16-byte boundary without
    moving the data.
  prefs: []
  type: TYPE_NORMAL
- en: 11.21 Working with Blocks of Data Whose Length Is Not a Multiple of the SSE/AVX
    Register Size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using SIMD instructions to march through a large data set processing 2, 4,
    8, 16, or 32 values at a time often allows a SIMD algorithm (a *vectorized* algorithm)
    to run an order of magnitude faster than the SISD (scalar) algorithm. However,
    two boundary conditions create problems: the start of the data set (when the starting
    address might not be properly aligned) and the end of the data set (when there
    might not be a sufficient number of array elements to completely fill an XMM or
    a YMM register). I’ve addressed the issues with the start of the data set (misaligned
    data) already. This section takes a look at the latter problem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the most part, when you run out of data at the end of the array (and the
    XMM and YMM registers need more for a packed operation), you can use the same
    technique given earlier for aligning a pointer: load more data than is necessary
    into the register and mask out the unneeded results. For example, if only 8 bytes
    are left to process in a byte array, you can load 16 bytes, do the operation,
    and ignore the results from the last 8 bytes. In the comparison loop examples
    I’ve been using through these past sections, you could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: In most cases, accessing data beyond the end of the data structures (either
    the data pointed at by R8, R9, or both in this example) is harmless. However,
    as you saw in “Memory Access and 4K Memory Management Unit Pages” in Chapter 3,
    if that extra data happens to cross a memory management unit page, and that new
    page doesn’t allow read access, the CPU will generate a general protection fault
    (memory access or segmentation fault). Therefore, unless you know that valid data
    follows the array in memory (at least to the extent the instruction references),
    you shouldn’t access that memory area; doing so could crash your software.
  prefs: []
  type: TYPE_NORMAL
- en: This problem has two solutions. First, you can align memory accesses on an address
    boundary that is the same size as the register (for example, 16-byte alignment
    for XMM registers). Accessing data beyond the end of the data structure with an
    SSE/AVX instruction will not cross a page boundary (because 16-byte accesses aligned
    on 16-byte boundaries will always fall within the same MMU page, and ditto for
    32-byte accesses on 32-byte boundaries).
  prefs: []
  type: TYPE_NORMAL
- en: The second solution is to examine the memory address prior to accessing memory.
    While you cannot access the new page without possibly triggering an access fault,^([19](#c11-footnote-21))
    you can check the address itself and see if accessing 16 (or 32) bytes at that
    address will access data in a new page. If it would, you can take some precautions
    before accessing the data on the next page. For example, rather than continuing
    to process the data in SIMD mode, you could drop down to SISD mode and finish
    processing the data to the end of the array by using standard scalar instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test if a SIMD access will cross an MMU page boundary, supposing that R9
    contains the address at which you’re about to access 16 bytes in memory using
    an SSE instruction, use code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Each MMU page is 4KB long and is situated on a 4KB address boundary in memory.
    Therefore, the LO 12 bits of an address provide an index into the MMU page associated
    with that address. The preceding code checks whether the address has a page offset
    greater than 0FF0h (4080). If so, then accessing 16 bytes starting at that address
    will cross a page boundary. Check for a value of 0FE0h if you need to check for
    a 32-byte access.
  prefs: []
  type: TYPE_NORMAL
- en: 11.22 Dynamically Testing for a CPU Feature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of this chapter, I mentioned that when testing the CPU feature
    set to determine which extensions it supports, the best solution is to dynamically
    select a set of functions based on the presence or absence of certain capabilities.
    To demonstrate dynamically testing for, and using (or avoiding), certain CPU features—specifically,
    testing for the presence of AVX extensions—I’ll modify (and expand) the `print`
    procedure that I’ve been using in examples up to this point.
  prefs: []
  type: TYPE_NORMAL
- en: The `print` procedure I’ve been using is very convenient, but it doesn’t preserve
    any SSE or AVX registers that a call to `printf()` could (legally) modify. A generic
    version of `print` should preserve the volatile XMM and YMM registers as well
    as general-purpose registers.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that you cannot write a generic version of `print` that will
    run on all CPUs. If you preserve the XMM registers only, the code will run on
    any x86-64 CPU. However, if the CPU supports the AVX extensions and the program
    uses YMM0 to YMM5, the print routine will preserve only the LO 128 bits of those
    registers, as they are aliased to the corresponding XMM registers. If you save
    the volatile YMM registers, that code will crash on a CPU that doesn’t support
    the AVX extensions. So, the trick is to write code that will dynamically determine
    whether the CPU has the AVX registers and preserve them if they are present, and
    otherwise preserve only the SSE registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easy way to do this, and probably the most appropriate solution for the
    `print` function, is to simply stick the `cpuid` instruction inside `print` and
    test the results immediately before preserving (and restoring) the registers.
    Here’s a code fragment that demonstrates how this could be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: At the end of the `print` function, when it’s time to restore everything, you
    could do another test to determine whether to restore XMM or YMM registers.^([20](#c11-footnote-22))
  prefs: []
  type: TYPE_NORMAL
- en: 'For other functions, when you might not want the expense of `cpuid` (and preserving
    all the registers it stomps on) incurred on every function call, the trick is
    to write *three* functions: one for SSE CPUs, one for AVX CPUs, and a special
    function (that you call only once) that selects which of these two you will call
    in the future. The bit of magic that makes this efficient is *indirection*. You
    won’t directly call any of these functions. Instead, you’ll initialize a pointer
    with the address of the function to call and indirectly call one of these three
    functions by using the pointer. For the current example, we’ll name this pointer
    `print` and initialize it with the address of the third function, `choosePrint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the code for `choosePrint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: The `print_SSE` procedure runs on CPUs without AVX support, and the `print_AVX`
    procedure runs on CPUs with AVX support. The `choosePrint` procedure executes
    the `cpuid` instruction to determine whether the CPU supports the AVX extensions;
    if so, it initializes the `print` pointer with the address of the `print_AVX`
    procedure, and if not, it stores the address of `print_SSE` into the `print` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '`choosePrint` is not an explicit initialization procedure you must call prior
    to calling `print`. The `choosePrint` procedure executes only *once* (assuming
    you call it via the `print` pointer rather than calling it directly). After the
    first execution, the `print` pointer contains the address of the CPU-appropriate
    print function, and `choosePrint` no longer executes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You call the `print` pointer just as you would make any other call to `print`;
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: After setting up the `print` pointer, `choosePrint` must transfer control to
    the appropriate print procedure (`print_SSE` or `print_AVX`) to do the work the
    user is expecting. Because preserved register values are sitting on the stack,
    and the actual print routines expect only a return address, `choosePrint` will
    first restore all the (general-purpose) registers it saved and then jump to (not
    call) the appropriate print procedure. It does a jump, rather than a call, because
    the return address pointing to the format string is already sitting on the top
    of the stack. On return from the `print_SSE` or `print_AVX` procedure, control
    will return to whomever called `choosePrint` (via the `print` pointer).
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-5](#listing11-5) shows the complete `print` function, with `print_SSE`
    and `print_AVX`, and a simple main program that calls `print`. I’ve extended `print`
    to accept arguments in R10 and R11 as well as in RDX, R8, and R9 (this function
    reserves RCX to hold the address of the format string following the call to `print`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-5: Dynamically selected print procedure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and output for the program in [Listing 11-5](#listing11-5):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 11.23 The MASM Include Directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ve seen already, including the source code for the `print` procedure
    in every sample listing in this book wastes a lot of space. Including the new
    version from the previous section in every listing would be impractical. In Chapter
    15, I discuss include files, libraries, and other functionality you can use to
    break large projects into manageable pieces. In the meantime, however, it’s worthwhile
    to discuss the MASM `include` directive so this book can eliminate a lot of unnecessary
    code duplication in sample programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MASM `include` directive uses the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: where `source_filename` is the name of a text file (generally in the same directory
    of the source file containing this `include` directive). MASM will take the source
    file and insert it into the assembly at the point of the `include` directive,
    exactly as though the text in that file had appeared in the source file being
    assembled.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, I have extracted all the source code associated with the new print
    procedure (the `choosePrint`, `print_AVX`, and `print_SSE` procedures, and the
    `print` qword variable), and I’ve inserted them into the *print.inc* source file.^([21](#c11-footnote-23))
    In listings that follow in this book, I’ll simply place the following directive
    in the code in place of the print function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: I’ve also put the `getTitle` procedure into its own header file (*getTitle.inc*)
    to be able to remove that common code from sample listings.
  prefs: []
  type: TYPE_NORMAL
- en: 11.24 And a Whole Lot More
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter doesn’t even begin to describe all the various SSE, AVX, AVX2,
    and AVX512 instructions. As already mentioned, most of the SIMD instructions have
    a specific purpose (such as interleaving or deinterleaving bytes associated with
    video or audio information) that aren’t very useful outside their particular problem
    domain. Other instructions (at least, as this book was being written) are sufficiently
    new that they won’t execute on many CPUs in use today. If you’re interested in
    learning about more of the SIMD instructions, check out the information in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: 11.25 For More Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about the `cpuid` instruction on AMD CPUs, see the 2010
    AMD document “CPUID Specification” ([https://www.amd.com/system/files/TechDocs/25481.pdf](https://www.amd.com/system/files/TechDocs/25481.pdf)).
    For Intel CPUs, check out “Intel Architecture and Processor Identification with
    CPUID Model and Family Numbers” ([https://software.intel.com/en-us/articles/intel-architecture-and-processor-identification-with-cpuid-model-and-family-numbers/](https://software.intel.com/en-us/articles/intel-architecture-and-processor-identification-with-cpuid-model-and-family-numbers/)).
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft’s website (particularly the Visual Studio documentation) has additional
    information on the MASM `segment` directive and x86-64 segments. A search for
    *MASM Segment Directive* on the internet, for example, brought up the page [https://docs.microsoft.com/en-us/cpp/assembler/masm/segment?view=msvc-160/](https://docs.microsoft.com/en-us/cpp/assembler/masm/segment?view=msvc-160/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete discussion of all the SIMD instructions can be found in Intel’s
    documentation: *Intel® 64 and IA-32 Architectures Software Developer’s Manual,*
    Volume 2: *Instruction Set Reference*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily find this documentation online at Intel’s website; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*[https://software.intel.com/en-us/articles/intel-sdm/](https://software.intel.com/en-us/articles/intel-sdm/)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**   *[https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html](https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**AMD’s variant can be found at [https://www.amd.com/system/files/TechDocs/40332.pdf](https://www.amd.com/system/files/TechDocs/40332.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this chapter has presented many of the SSE/AVX/AVX2 instructions and
    what they do, it has not spent much time describing how you would use these instructions
    in a typical program. You can easily find lots of useful high-performance algorithms
    that use SSE and AVX instructions on the internet. The following URLs provide
    some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tutorials on SIMD programming**'
  prefs: []
  type: TYPE_NORMAL
- en: SSE Arithmetic, by Stefano Tommesani, [https://tommesani.com/index.php/2010/04/24/sse-arithmetic/](https://tommesani.com/index.php/2010/04/24/sse-arithmetic/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*x86/x64 SIMD Instruction List, [https://www.officedaytime.com/simd512e/](https://www.officedaytime.com/simd512e/)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**   *Basics of SIMD Programming, Sony Computer Entertainment, [http://ftp.cvut.cz/kernel/people/geoff/cell/ps3-linux-docs/CellProgrammingTutorial/BasicsOfSIMDProgramming.html](http://ftp.cvut.cz/kernel/people/geoff/cell/ps3-linux-docs/CellProgrammingTutorial/BasicsOfSIMDProgramming.html)**'
  prefs: []
  type: TYPE_NORMAL
- en: '****Sorting algorithms**'
  prefs: []
  type: TYPE_NORMAL
- en: “A Novel Hybrid Quicksort Algorithm Vectorized Using AVX-512 on Intel Skylake,”
    by Berenger Bramas, [https://arxiv.org/pdf/1704.08579.pdf](https://arxiv.org/pdf/1704.08579.pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Register Level Sort Algorithm on Multi-Core SIMD Processors” by Tian Xiaochen
    et al., [http://olab.is.s.u-tokyo.ac.jp/~kamil.rocki/xiaochen_rocki_IA3_SC13.pdf](http://olab.is.s.u-tokyo.ac.jp/~kamil.rocki/xiaochen_rocki_IA3_SC13.pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Fast Quicksort Implementation Using AVX Instructions” by Shay Gueron and Vlad
    Krasnov, [http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1009.7773&rep=rep1&type=pdf](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1009.7773&rep=rep1&type=pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Search algorithms**'
  prefs: []
  type: TYPE_NORMAL
- en: “SIMD-Friendly Algorithms for Substring Searching” by Wojciech Mula, [http://0x80.pl/articles/simd-strfind.html](http://0x80.pl/articles/simd-strfind.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Fast Multiple String Matching Using Streaming SIMD Extensions Technology” by
    Simone Faro and M. Oğuzhan Külekci, [https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1041.3831&rep=rep1&type=pdf](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1041.3831&rep=rep1&type=pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “k-Ary Search on Modern Processors” by Benjamin Schlegel et al., [https://event.cwi.nl/damon2009/DaMoN09-KarySearch.pdf](https://event.cwi.nl/damon2009/DaMoN09-KarySearch.pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.26 Test Yourself
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How can you determine whether a particular SSE or AVX feature is available on
    the CPU?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important to check the manufacturer of the CPU?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What EAX setting do you use with `cpuid` to obtain the feature flags?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What feature flag bit tells you that the CPU supports SSE4.2 instructions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name of the default segment used by the following directives?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.code`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.data`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.data?`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.const`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the default segment alignment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you create a data segment aligned on a 64-byte boundary?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which instruction set extensions support the YMM*x* registers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a lane?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a scalar instruction and a vector instruction?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SSE memory operands (XMM) must usually be aligned on what memory boundary?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AVX memory operands (YMM) must usually be aligned on what memory boundary?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AVX-512 memory operands (ZMM) must usually be aligned on what memory boundary?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What instruction would you use to move the data from a 32-bit general-purpose
    integer register into the LO 32 bits of an XMM and a YMM register?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What instruction would you use to move the data from a 64-bit general-purpose
    integer register into the LO 64 bits of an XMM and a YMM register?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What three instructions would you use to load 16 bytes from an aligned memory
    location into an XMM register?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What three instructions would you use to load 16 bytes from an arbitrary memory
    address into an XMM register?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to move the HO 64 bits of an XMM register into the HO 64 bits of
    another XMM register without affecting the LO 64 bits of the destination, what
    instruction would you use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to duplicate a double-precision value in the LO 64 bits of an XMM
    register in the two qwords (LO and HO) of another XMM register, what instruction
    would you use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which instruction would you use to rearrange the bytes in an XMM register?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which instruction would you use to rearrange the dword lanes in an XMM register?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which instructions would you use to extract bytes, words, dwords, or qwords
    from an XMM register and move them into a general-purpose register?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which instructions would you use to take a byte, word, dword, or qword in a
    general-purpose register and insert it somewhere in an XMM register?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `andnpd` instruction do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which instruction would you use to shift the bytes in an XMM register one byte
    position to the left (8 bits)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which instruction would you use to shift the bytes in an XMM register one byte
    position to the right (8 bits)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to shift the two qwords in an XMM register *n* bit positions to
    the left, what instruction would you use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to shift the two qwords in an XMM register *n* bit positions to
    the right, what instruction would you use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens in a `paddb` instruction when a sum will not fit into 8 bits?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a vertical addition and a horizontal addition?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where does the `pcmpeqb` instruction put the result of the comparison? How does
    it indicate the result is true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no `pcmpltq` instruction. Explain how to compare lanes in a pair of
    XMM registers for the less-than condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `pmovmskb` instruction do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many simultaneous additions are performed by the following?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`addps`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`addpd`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have a pointer to data in RAX and want to force that address to be aligned
    on a 16-byte boundary, what instruction would you use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you set all the bits in the XMM0 register to 0?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you set all the bits in the XMM1 register to 1?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What directive do you use to insert the content of a source file into the current
    source file during assembly?****
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
