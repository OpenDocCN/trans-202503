<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>JavaScript Crash Course</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:26ab05bf-a247-42ca-b08d-ede069333d2b" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch13" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="CHAPTER" id="ch13">
<span class="CN"><span aria-label=" Page 235. " epub:type="pagebreak" id="pg_235" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">WRITING</samp> <samp class="SANS_Dogma_OT_Bold_B_11">A</samp> <samp class="SANS_Dogma_OT_Bold_B_11">SONG</samp></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" src="../images/opener.png"/></figure>
<p class="INTROTNI2">You’ve now learned enough about the basics of Tone.js and sound synthesis to write a simple song. Our song is going to be made up of a few instruments: the drums we developed in the previous chapter, the trumpet sampler, two different synth bass parts, and some chords played on another synth.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="h1-77"/><samp class="SANS_Futura_Std_Bold_B_11">Getting Organized</samp></h3>
<p class="TNI1">Our song will reuse a lot of the code from the previous chapter, but we’ll reorganize it to make it easier to follow how the song is built. The <i>index.html</i> file will be exactly the same as in <a href="chapter12.xhtml">Chapter 12</a>, but we’ll start from scratch with a new <i>script.js</i> file, which we’ll organize into four logical sections:</p>
<p class="RunInPara1"><b>Instruments</b>    For instantiating and setting up the instruments</p>
<p class="RunInPara"><b>Sequencing</b>    For creating the looping sequences of notes to be played</p>
<p class="RunInPara"><span aria-label=" Page 236. " epub:type="pagebreak" id="pg_236" role="doc-pagebreak"/><b>Song</b>    For scheduling the start and end of each sequence</p>
<p class="RunInPara2"><b>Event Handling</b>    The code that handles the <span class="SANS_TheSansMonoCd_W5Regular_11">click</span> event that starts playing the song</p>
<p class="TX">We’ll set off each of these four sections with a multiline comment to make the <i>script.js</i> file easier to navigate. <a href="#Lis13-1">Listing 13-1</a> shows what these comments look like. You can add them to the file now, in this order.</p>
<span id="Lis13-1"/>
<pre><code>/////////////////
// Instruments //
/////////////////

////////////////
// Sequencing //
////////////////

//////////
// Song //
//////////

////////////////////
// Event Handling //
////////////////////
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-1: The comments delineating the main sections of</samp> <samp class="SANS_Futura_Std_Book_11">script.js</samp></p>
<p class="TX">Throughout the chapter, as we build up the song, I’ll tell you to add each new piece of code to the end of a particular section. These comments will enable you to quickly find exactly where the new code should go.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H1" id="sec2"><span id="h1-78"/><samp class="SANS_Futura_Std_Bold_B_11">Event Handling</samp></h3>
<p class="TNI1">Let’s start by writing the Event Handling section of <i>script.js</i>. This code is almost identical to the code we wrote at the beginning of the previous chapter: it creates a <span class="SANS_TheSansMonoCd_W5Regular_11">click</span> event listener that toggles the style of the Play button and “Playing” paragraph when the user clicks the button, and makes the Tone.js calls necessary to start playing the song. Enter the contents of <a href="#Lis13-2">Listing 13-2</a> in the Event Handling section of the code.</p>
<span id="Lis13-2"/>
<pre><code><var>--snip--</var>
<span class="gray">////////////////////</span>
<span class="gray">// Event Handling //</span>
<span class="gray">////////////////////</span>

let play = document.querySelector("#play");
let playing = document.querySelector("#playing");

play.addEventListener("click", () =&gt; {
  // Hide this button
  play.style = "display: none";
  playing.style = " ";

<span aria-label=" Page 237. " epub:type="pagebreak" id="pg_237" role="doc-pagebreak"/>  Tone.start();

  // Modify this to start playback at a different part of the song
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> Tone.Transport.position = "0:0:0";
  Tone.Transport.start();
});
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-2: The event handling code</samp></p>
<p class="TX">One important difference in this code compared to <a href="chapter12.xhtml#Lis12-2">Listing 12-2</a> is that we use <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Transport.position</span> to set the starting position of the transport before we call <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Transport.start</span> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Here we’ve set the starting position to <span class="SANS_TheSansMonoCd_W5Regular_11">"0:0:0"</span>, which is the default, so this call isn’t strictly necessary. However, including this line of code makes it easy to modify the starting position if you don’t want to have to listen to the whole song every time you add a new element to it. For example, if you wanted to skip the first 20 bars, you could change the value of <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Transport.position</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">"20:0:0"</span>.</p>
<p class="TX">Unlike in the previous chapter, all the code to create the instruments and sequences will live outside of the event handler. That code can all be executed before the user presses Play. Only the <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.start</span> call has to be inside the handler for the song to work correctly. We could even move the <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Transport</span> lines outside of the handler if we wanted, but it feels more natural to have those come after <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.start</span>.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="H1" id="sec3"><span id="h1-79"/><samp class="SANS_Futura_Std_Bold_B_11">Making the Drumbeat</samp></h3>
<p class="TNI1">Now let’s create the drumbeat to underlay the song. We’ll use the same hi-hat, snare, and kick sounds we created in the last chapter. First we’ll declare those instruments, as shown in <a href="#Lis13-3">Listing 13-3</a>. Add this code to the Instruments section of <i>script.js</i>.</p>
<span id="Lis13-3"/>
<pre><code><span class="gray">/////////////////</span>
<span class="gray">// Instruments //</span>
<span class="gray">/////////////////</span>

<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> function mkDrums() {
  let reverb = new Tone.Reverb({
    decay: 1,
    wet: 0.3
  }).toDestination();

  let hiHatFilter = new Tone.Filter(15000, "bandpass").connect(reverb);

  let hiHat = new Tone.NoiseSynth({
    envelope: {
      attack: 0.001, decay: 0.1, sustain: 0, release: 0
    },
    volume: -6
  }).connect(hiHatFilter);

<span aria-label=" Page 238. " epub:type="pagebreak" id="pg_238" role="doc-pagebreak"/>  class Snare {
    constructor() {
      this.noiseFilter = new Tone.Filter(5000, "bandpass").connect(reverb);
      this.noiseSynth = new Tone.NoiseSynth({
        envelope: {
          attack: 0.001, decay: 0.1, sustain: 0, release: 0
        },
        volume: -12
      }).connect(this.noiseFilter);

      this.synth = new Tone.Synth({
        envelope: {
          attack: 0.0001, decay: 0.1, sustain: 0, release: 0
        },
        oscillator: {type: "sine"},
        volume: -12
      }).connect(reverb);
    }

    triggerAttackRelease(duration, when) {
      this.noiseSynth.triggerAttackRelease(duration, when);
      this.synth.triggerAttackRelease("G3", duration, when);
    }
  }

  let snare = new Snare();

  let kick = new Tone.MembraneSynth({
    pitchDecay: 0.02,
    octaves: 6,
    volume: -9
  }).connect(reverb);

<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> return {hiHat, snare, kick};
}

let drums = mkDrums();
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-3: Declaring the drums</samp></p>
<p class="TX">This code is identical to the code we wrote in the previous chapter, but to keep it a little more organized I’ve moved all of the drum setup code, including the reverb effect, into a single function called <span class="SANS_TheSansMonoCd_W5Regular_11">mkDrums</span> (for “make drums”) <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This function returns an object with the three drums <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We’re using a new form of syntax for creating this object called <i>object literal shorthand syntax</i>. With this shorthand syntax, instead of typing out <span class="SANS_TheSansMonoCd_W5Regular_11">{hiHat: hiHat, snare: snare, kick: kick}</span>, we just type <span class="SANS_TheSansMonoCd_W5Regular_11">{hiHat, snare, kick}</span>. This works only if the property names are the same as the variable names.</p>
<p class="TX">Now that we’ve declared the drums, we’ll create the actual drumbeat pattern. We’ll use the same one-bar pattern that we developed in the <span aria-label=" Page 239. " epub:type="pagebreak" id="pg_239" role="doc-pagebreak"/>previous chapter, with hi-hats on every eighth note and kick and snare sounds alternating every quarter note. Add <a href="#Lis13-4">Listing 13-4</a> to the Sequencing section of the code.</p>
<span id="Lis13-4"/>
<pre><code><var>--snip--</var>
<span class="gray">////////////////</span>
<span class="gray">// Sequencing //</span>
<span class="gray">////////////////</span>

// Converts a string to an array of notes or nulls.
// Dots in the string become nulls in the array and are silent.
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> function mkSequence(pattern) {
  return pattern.split(" ").map(value =&gt; {
    if (value == ".") {
      return null;
    } else {
      return value;
    }
  });
}

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> let drumPattern = {
  kick:  "x…x…",
  snare: "..x…x.",
  hiHat: "xxxxxxxx",
};

let hiHatSequence = new Tone.Sequence(time =&gt; {
  drums.hiHat.triggerAttackRelease("16n", time);
}, mkSequence(drumPattern.hiHat), "8n");

let snareSequence = new Tone.Sequence(time =&gt; {
  drums.snare.triggerAttackRelease("16n", time);
}, mkSequence(drumPattern.snare), "8n");

let kickSequence = new Tone.Sequence(time =&gt; {
    drums.kick.triggerAttackRelease(50, "16n", time);
}, mkSequence(drumPattern.kick), "8n");
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-4: The drumbeat sequences</samp></p>
<p class="TX">Again, this is identical to code we wrote in <a href="chapter12.xhtml">Chapter 12</a>. We start with a helper function, <span class="SANS_TheSansMonoCd_W5Regular_11">mkSequence</span> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, that takes in a pattern of <span class="SANS_TheSansMonoCd_W5Regular_11">x</span>’s and dots and turns it into note information that <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sequence</span> can use. Then we store the patterns we want in a <span class="SANS_TheSansMonoCd_W5Regular_11">drumPattern</span> object <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> and generate the sequences for each instrument with <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sequence</span>.</p>
<p class="TX">All that’s left to do to create the drumbeat is to schedule the sequences to play on loop for most of the duration of the song, as shown in <a href="#Lis13-5">Listing 13-5</a>. Add this code to the Song section of the <i>script.js</i> file.</p>
<span id="Lis13-5"/>
<pre><code><span aria-label=" Page 240. " epub:type="pagebreak" id="pg_240" role="doc-pagebreak"/><var>--snip--</var>
<span class="gray">//////////</span>
<span class="gray">// Song //</span>
<span class="gray">//////////</span>

hiHatSequence.start("0:0:0").stop("44:0:0");
snareSequence.start("0:0:0").stop("44:0:0");
kickSequence.start("0:0:0").stop("44:0:0");
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-5: Scheduling the drumbeat sequences</samp></p>
<p class="TX">Here we tell the drums to start at the beginning of the song and keep playing for 44 bars. Load the page and click <b>Play,</b> and you should hear the same drums as before, but for much longer. When you get tired of listening, reload the page to stop the drums playing.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H1" id="sec4"><span id="h1-80"/><samp class="SANS_Futura_Std_Bold_B_11">Adding the Bass Lines</samp></h3>
<p class="TNI1">Next we’re going to add a couple of bass synths and have them play two separate bass lines. First we’ll create the synths, by adding the code in <a href="#Lis13-6">Listing 13-6</a> to the end of the Instruments section (just before the Sequencing section).</p>
<span id="Lis13-6"/>
<pre><code><var>--snip--</var>
let lowBass = new Tone.FMSynth({
  oscillator: {
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> type: "triangle"
  },
  envelope: {
    attack: 0.0001, decay: 0.5, sustain: 0.3, release: 0.1
  },
  volume: -3
}).toDestination();

let highBass = new Tone.FMSynth({
  oscillator: {
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> type: "square"
  },
  envelope: {
    attack: 0.0001, decay: 0.1, sustain: 0.3, release: 0.1
  },
  volume: -9
}).toDestination();
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-6: Creating the bass instruments</samp></p>
<p class="TX">Here we declare two bass instruments called <span class="SANS_TheSansMonoCd_W5Regular_11">lowBass</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">highBass</span>. Both use a synth we haven’t seen yet, called an <span class="SANS_TheSansMonoCd_W5Regular_11">FMSynth</span>. <i>FM</i> is short for <i>frequency modulation</i>, and <i>FM synthesis</i> involves using one oscillator to modulate, or modify, the frequency of another oscillator. This kind of synthesis yields a <span aria-label=" Page 241. " epub:type="pagebreak" id="pg_241" role="doc-pagebreak"/>richer sound than a plain oscillator, and it makes a good bass synth. There are a lot of parameters that can be modified in <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.FMSynth</span> (for example, the amount of modulation applied, the relationship between the frequencies of the two oscillators, the waveforms of the two oscillators, and so on), but we’ll mostly stick to the default values. All we’ll do is set the oscillator type (<span class="SANS_TheSansMonoCd_W5Regular_11">"triangle"</span> for <span class="SANS_TheSansMonoCd_W5Regular_11">"lowBass"</span> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">"square"</span> for <span class="SANS_TheSansMonoCd_W5Regular_11">highBass</span> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>), as well as the envelope and volume.</p>
<p class="TX">For generating the bass sequences, we’re going to use a slightly different technique from our current <span class="SANS_TheSansMonoCd_W5Regular_11">mkSequence</span> helper function. That helper is great for things like drums, where you need only a single character to determine whether a note is played or not, but it doesn’t work for a bass line where we want to provide note names, which have at least two characters (like <span class="SANS_TheSansMonoCd_W5Regular_11">C3</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">F#4</span>). One notation we might choose for writing out a sequence could be something like:</p>

<pre><code>"C3|  |  |C3|  |  |G2|B2"</code></pre>
<p class="BodyContinued">The vertical pipe characters are used as divisions, and between each pair of pipes is either a note we want to play or a blank space, which represents a silence. (The sequence written out here is the start of the bass line for Ben E. King’s “Stand by Me.”)</p>
<p class="TX"><a href="#Lis13-7">Listing 13-7</a> gives the definition of <span class="SANS_TheSansMonoCd_W5Regular_11">mkPipeSequence</span>, which we’ll use for sequencing our bass lines. It takes a string like the one for “Stand by Me” and converts it into an array of note names and <span class="SANS_TheSansMonoCd_W5Regular_11">null</span>s. Insert this function into the Sequencing section of <i>script.js</i>, just after the definition of <span class="SANS_TheSansMonoCd_W5Regular_11">mkSequence</span>.</p>
<span id="Lis13-7"/>
<pre><code><var>--snip--</var>
// Converts a string to an array of notes or nulls.
// Spaces between pipes in the string become nulls in the array and are silent.
function mkPipeSequence(pattern) {
  return pattern.split("|").map(value =&gt; {
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> if (value.trim() == " ") {
      return null;
    } else {
      return value;
    }
  });
}
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-7: The mkPipeSequence function</samp></p>
<p class="TX">This function uses <span class="SANS_TheSansMonoCd_W5Regular_11">split("|")</span> to split the string by the pipe character. Using the “Stand by Me” example, this would give the array <span class="SANS_TheSansMonoCd_W5Regular_11">["C3", " ", " ", "C3", " ", " ", "G2", "B2"]</span>. We then map over each of these values. The <span class="SANS_TheSansMonoCd_W5Regular_11">trim</span> method <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> removes any whitespace from the start or end of a string, so <span class="SANS_TheSansMonoCd_W5Regular_11">" ".trim()</span> results in <span class="SANS_TheSansMonoCd_W5Regular_11">" "</span>, an empty string. We replace any empty strings with <span class="SANS_TheSansMonoCd_W5Regular_11">null</span>s in the returned array and pass the note names through unchanged, resulting in a return value of <span class="SANS_TheSansMonoCd_W5Regular_11">["C3", null, null, "C3", null, null, "G2", "B2"]</span>.</p>
<p class="TX"><span aria-label=" Page 242. " epub:type="pagebreak" id="pg_242" role="doc-pagebreak"/>Next we want to create the actual sequences for the two bass lines (we won’t be borrowing from “Stand by Me” here). Add the code in <a href="#Lis13-8">Listing 13-8</a> to the end of the Sequencing section.</p>
<span id="Lis13-8"/>
<pre><code><var>--snip--</var>
let lowBassSequence = new Tone.Sequence((time, note) =&gt; {
  lowBass.triggerAttackRelease(note, "16n", time, 0.6);
}, mkPipeSequence("G2|  |  |G2|G2|  |  |  "), "8n");

let highBassSequence = new Tone.Sequence((time, note) =&gt; {
  highBass.triggerAttackRelease(note, "16n", time, 0.3);
}, mkPipeSequence("G3|F3|E3|D3|G2|D3|G3|D3"), "8n");
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-8: The bass sequences</samp></p>
<p class="TX">There are two bass parts here: the low one just plays three eighth notes per bar, while the high one plays eighth notes continuously.</p>
<p class="TX">Finally, we need to schedule these sequences against the transport, as shown in <a href="#Lis13-9">Listing 13-9</a>. This code should be added to the end of the Song section.</p>
<span id="Lis13-9"/>
<pre><code><var>--snip--</var>
lowBassSequence.start("0:0:0").stop("47:3:0");
highBassSequence.start("4:0:0").stop("47:3:0");
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-9: Scheduling the bass sequences</samp></p>
<p class="TX">The low sequence starts at the beginning, and the high sequence starts after four bars. Both continue looping until partway through the 48th bar. This way, the bass parts will continue for a few bars after the drums stop.</p>
<p class="TX">If you now refresh the page and hit Play, you’ll hear the beginnings of a song! Not only do we have drums and bass, but we have some very basic structure, with the second bass line coming in after four bars and the drums ending before the bass. That bass solo at the end is by far the most dramatic part of the song as it currently stands. To hear just that part, you can modify the value of <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Transport.Position</span> in the Event Handling section of the code. If you set it to <span class="SANS_TheSansMonoCd_W5Regular_11">"40:0:0"</span> and reload, you’ll skip to the last eight bars of the song.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H1" id="sec5"><span id="h1-81"/><samp class="SANS_Futura_Std_Bold_B_11">Adding Chords</samp></h3>
<p class="TNI1">Next we’ll fill out the song with some chords. This song will have two separate chord sequences, which we’ll schedule for different times in the song to give it some more structure and variety.</p>
<p class="TX">First we need to create the instrument that will play the chords. The code for this is in <a href="#Lis13-10">Listing 13-10</a>; insert this at the end of the Instruments section.</p>
<span id="Lis13-10"/>
<pre><code><span aria-label=" Page 243. " epub:type="pagebreak" id="pg_243" role="doc-pagebreak"/><var>--snip--</var>
let chordSynth = new Tone.PolySynth(Tone.Synth, {
  oscillator: {
    type: "triangle"
  },
  volume: -12
}).toDestination();
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-10: The chord synth</samp></p>
<p class="TX">We need a <span class="SANS_TheSansMonoCd_W5Regular_11">PolySynth</span> because the instrument will be playing more than one note at a time (that’s what a chord is). The <span class="SANS_TheSansMonoCd_W5Regular_11">PolySynth</span> is based on a regular <span class="SANS_TheSansMonoCd_W5Regular_11">Synth</span>, using the default amplitude envelope and a triangle wave oscillator.</p>
<p class="TX">Next we’ll create the sequencing code for the chords. Rather than writing a chord out manually each time we want to play it in a sequence, we’ll create some named chords, and then create sequences using those chord names. Insert the code in <a href="#Lis13-11">Listing 13-11</a> at the end of the Sequencing section.</p>
<span id="Lis13-11"/>
<pre><code><var>--snip--</var>
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> let chords = {
  1: ["D4", "G4"],
  2: ["E4", "G4"],
  3: ["C4", "E4", "G4"],
  4: ["B3", "F4", "G4"],
};

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> function playChord(time, chordName) {
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> let notes = chords[chordName];
  chordSynth.triggerAttackRelease(notes, "16n", time, 0.6);
}

<span aria-label="annotation4" class="CodeAnnotationHang">❹</span> let chordSequence1 = new Tone.Sequence((time, chordName) =&gt; {
  playChord(time, chordName);
}, mkSequence("1…2…3..4…31…2…3..4.343"), "8n");

<span aria-label="annotation5" class="CodeAnnotationHang">❺</span> let chordSequence2 = new Tone.Sequence((time, chordName) =&gt; {
  playChord(time, chordName);
}, mkSequence("3…2…4..1.213"), "8n"); 
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-11: Sequencing the chords</samp></p>
<p class="TX">The first thing we do is create an object called <span class="SANS_TheSansMonoCd_W5Regular_11">chords</span> with the four chords that we’ll be sequencing <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We could call them anything, but for simplicity I’m using the numbers <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">2</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">3</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">4</span> to refer to the chords (though note that because these are object keys, the numbers are interpreted as strings). Each chord number corresponds to an array of note names, which is the format our <span class="SANS_TheSansMonoCd_W5Regular_11">PolySynth</span> requires. The two chord sequences will just be various orderings of these four chords.</p>
<p class="TX"><span aria-label=" Page 244. " epub:type="pagebreak" id="pg_244" role="doc-pagebreak"/>Next comes a helper function for playing the chords <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. This <span class="SANS_TheSansMonoCd_W5Regular_11">playChord</span> function takes the time to play the chord and the name of the chord as a string (one of the numbers <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> through <span class="SANS_TheSansMonoCd_W5Regular_11">4</span>). Then it looks in the <span class="SANS_TheSansMonoCd_W5Regular_11">chords</span> object and retrieves the array of notes keyed by the given chord name <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The function ends by calling <span class="SANS_TheSansMonoCd_W5Regular_11">triggerAttackRelease</span> on the <span class="SANS_TheSansMonoCd_W5Regular_11">chordSynth</span>, passing the array of note names. Because it’s a <span class="SANS_TheSansMonoCd_W5Regular_11">PolySynth</span>, our <span class="SANS_TheSansMonoCd_W5Regular_11">chordSynth</span> instrument is able to play all the notes in the chord at once.</p>
<p class="TX">Finally, we make the two sequences, called <span class="SANS_TheSansMonoCd_W5Regular_11">chordSequence1</span> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">chordSequence2</span> <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. The callback for both of these sequences is our <span class="SANS_TheSansMonoCd_W5Regular_11">playChord</span> function. We’re also using the same <span class="SANS_TheSansMonoCd_W5Regular_11">mkSequence</span> helper we used for sequencing the drums earlier, but in this case the values in the string are either dots (silence) or chord names. Unlike with our bass lines, <span class="SANS_TheSansMonoCd_W5Regular_11">mkSequence</span> works here because each chord name is a single character, and we have our <span class="SANS_TheSansMonoCd_W5Regular_11">playChord</span> function to reinterpret the chord names as pitches. As with the drums, we’re passing <span class="SANS_TheSansMonoCd_W5Regular_11">"8n"</span> as the last argument to <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sequence</span>, meaning that each dot or chord name is an eighth note. The first sequence is 32 eighth notes long, or 4 bars. The second sequence is 16 eighth notes long, or 2 bars.</p>
<p class="TX">Now we’ll actually schedule the sequences against the transport. Add the code in <a href="#Lis13-12">Listing 13-12</a> to the end of the Song section.</p>
<span id="Lis13-12"/>
<pre><code><var>--snip--</var>
chordSequence1.start("8:0:0").stop("24:0:0");
chordSequence2.start("24:0:0").stop("32:0:0");
chordSequence1.start("32:0:0").stop("40:0:0");
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-12: Scheduling the chord sequences</samp></p>
<p class="TX">The first sequence starts playing after 8 bars and repeats through the end of bar 24, which is 16 bars, or four complete loops of the first sequence. Then the second sequence takes over and runs through bar 32; this is 8 bars, or four complete loops of the second sequence. Finally, the first sequence returns, playing through bar 40; this is also 8 bars, or two complete loops of the first sequence.</p>
<p class="TX">Try refreshing your browser and listening to the song again. Make sure to set <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Transport.position</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">"0:0:0"</span> in the event handler to play from the beginning. If you don’t want to wait eight bars for the chords to come in, set it to <span class="SANS_TheSansMonoCd_W5Regular_11">"8:0:0"</span> to start playing where the chords start.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="H1" id="sec6"><span id="h1-82"/><samp class="SANS_Futura_Std_Bold_B_11">Playing a Tune</samp></h3>
<p class="TNI1">Now that we have drums, bass, and chords, the only thing our song is missing is a tune. We’re going to use the trumpet sampler we created in the last chapter, and we’ll sequence the notes using <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Part</span>, which lets us easily schedule the timing of each note in the tune separately.</p>
<p class="TX">First we’ll create the sampler, like we did in <a href="chapter12.xhtml">Chapter 12</a>. Add the code in <a href="#Lis13-13">Listing 13-13</a> to the end of the Instruments section.</p>
<span id="Lis13-13"/>
<pre><code><span aria-label=" Page 245. " epub:type="pagebreak" id="pg_245" role="doc-pagebreak"/><var>--snip--</var>
// Samples from freesound.org:
// https://freesound.org/people/MTG/sounds/357432/
// https://freesound.org/people/MTG/sounds/357336/
// https://freesound.org/people/MTG/sounds/357546/
let sampler = new Tone.Sampler({
  urls: {
    "C5": "trumpet-c5.mp3", 
    "D5": "trumpet-d5.mp3", 
    "F5": "trumpet-f5.mp3" 
  },
  baseUrl: "https://skilldrick-jscc.s3.us-west-2.amazonaws.com/",
  attack: 0,
  release: 1,
  volume: -24
}).toDestination();
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-13: Declaring the trumpet sampler</samp></p>
<p class="TX">Here we’re creating a <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sampler</span> instrument with the same three samples as in the previous chapter. Note, however, that we’re no longer using the sampler’s <span class="SANS_TheSansMonoCd_W5Regular_11">onload</span> property to tell it what to do once the samples have been downloaded. This is a bit of a cheat, but I know that the trumpets aren’t going to play at the beginning of the song, and I’m banking on the fact that by the time they come in, the samples will have downloaded. The proper thing to do would be to hide the Play button until the samples have finished downloading, but that would add extra complexity to this project.</p>
<p class="TX"><a href="#Lis13-14">Listing 13-14</a> shows the code for sequencing the notes of the tune. Add this code to the end of the Sequencing section.</p>
<span id="Lis13-14"/>
<pre><code><var>--snip--</var>
let trumpetPart = new Tone.Part((time, note) =&gt; {
  sampler.triggerAttackRelease(note, "1n", time);
}, [
  ["0:0:0", "G5"],
  ["0:2:0", "C5"],
  ["1:0:0", "G5"],

  ["2:0:0", "D5"],
  ["2:2:0", "C5"],
  ["3:0:0", "B4"],

  ["4:0:0", "G5"],
  ["4:2:0", "C5"],
  ["5:0:0", "G5"],

  ["6:0:0", "D5"],
  ["6:2:0", "C5"],
  ["7:0:0", "B4"],
  ["7:2:0", "D5"],

  ["8:0:0", "C5"],
  ["8:2:0", "E5"],
<span aria-label=" Page 246. " epub:type="pagebreak" id="pg_246" role="doc-pagebreak"/>  ["9:0:0", "F5"],
  ["9:2:0", "D5"],

  ["10:0:0", "C5"],
  ["10:2:0", "E5"],
  ["11:0:0", "D5"],

  ["12:0:0", "C5"],
  ["12:2:0", "E5"],
  ["13:0:0", "F5"],
  ["13:2:0", "D5"],

  ["14:0:0", "C5"],
  ["14:2:0", "E5"],
  ["15:0:0", ["B4", "G5"]]
]);
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-14: Sequencing the tune</samp></p>
<p class="TX">As a reminder, the <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Part</span> constructor takes two arguments: a callback to play for each time/note pair, and a list of time/note pairs. Here, the callback plays a long note (<span class="SANS_TheSansMonoCd_W5Regular_11">"1n"</span>, or a whole bar) on the trumpet sampler for every time/note pair. The first note is played at <span class="SANS_TheSansMonoCd_W5Regular_11">"0:0:0"</span> and the second is played two beats later, at <span class="SANS_TheSansMonoCd_W5Regular_11">"0:2:0"</span>. Because the notes are about four beats long, they will overlap—I did this intentionally to add some interest to the tune.</p>
<p class="TX">The tune won’t play yet because we haven’t said <i>when</i> to play it. Even though each note has a time, these times are relative to when the part is scheduled to begin. To schedule the part, we just have to add some code to the end of the Song section, as shown in <a href="#Lis13-15">Listing 13-15</a>.</p>
<span id="Lis13-15"/>
<pre><code><var>--snip--</var>
trumpetPart.start("16:0:0");
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-15: Scheduling the trumpet part</samp></p>
<p class="TX">Unlike the sequences we scheduled so far, the part doesn’t loop, so it doesn’t need a stop time. We’re telling Tone.js to start the trumpet part after 16 bars, which means that all the times given in the part are relative to <span class="SANS_TheSansMonoCd_W5Regular_11">"16:0:0"</span>. We can add the two times together to get the actual time when each note is scheduled (for example, <span class="SANS_TheSansMonoCd_W5Regular_11">"4:2:0" + "16:0:0"</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">"20:2:0"</span>).</p>
<p class="TX">Now you can listen to the complete song! Don’t forget to reset <span class="SANS_TheSansMonoCd_W5Regular_11">Tone .Transport.position</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">"0:0:0"</span> before you refresh the page.</p>
<section aria-labelledby="sec7" epub:type="division">
<aside aria-label="box-42" class="box" id="sec7">
<h4 class="BH" id="box-42"><samp class="SANS_Dogma_OT_Bold_B_11">TRY IT YOURSELF</samp></h4>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">13-1.</samp><samp class="SANS_Futura_Std_Book_11">  Now that you’ve finished coding the song, try making it your own. Here are some ways you could modify it:</samp></p>
<ul class="ul">
<li class="BoxListBulletSub"><span aria-label=" Page 247. " epub:type="pagebreak" id="pg_247" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Book_11">Change the tempo (BPM) of the song by setting</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Transport.bpm .value</span> <samp class="SANS_Futura_Std_Book_11">to something other than</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">120</span><samp class="SANS_Futura_Std_Book_11">.</samp></li>
<li class="BoxListBulletSub"><samp class="SANS_Futura_Std_Book_11">Change the drum pattern.</samp></li>
<li class="BoxListBulletSub"><samp class="SANS_Futura_Std_Book_11">Modify the Song section and update when the sequences are scheduled.</samp></li>
<li class="BoxListBulletSub"><samp class="SANS_Futura_Std_Book_11">Change the chords without changing the chord pattern.</samp></li>
<li class="BoxListBulletSub"><samp class="SANS_Futura_Std_Book_11">Change the chord pattern without changing the chords.</samp></li>
</ul>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">13-2.</samp><samp class="SANS_Futura_Std_Book_11">  It’s a little awkward that you have to reload the page to stop the song. Try adding a Pause button that calls</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Transport.pause</span> <samp class="SANS_Futura_Std_Book_11">and a Stop button that calls</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Transport.stop</span><samp class="SANS_Futura_Std_Book_11">. You could also show the current position by displaying</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Transport.position</span> <samp class="SANS_Futura_Std_Book_11">on the page, using</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">setInterval</span> <samp class="SANS_Futura_Std_Book_11">to update it regularly.</samp></p>
</aside>
</section>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="H1" id="sec8"><span id="h1-83"/><samp class="SANS_Futura_Std_Bold_B_11">The Complete Code</samp></h3>
<p class="TNI1">We’ve been adding code all over the file, so just in case you got something mixed up, or if you just want to see how it should all look, <a href="#Lis13-16">Listing 13-16</a> gives the entire contents of <i>script.js</i>.</p>
<span id="Lis13-16"/>
<pre><code>/////////////////
// Instruments //
/////////////////

function mkDrums() {
  let reverb = new Tone.Reverb({
    decay: 1,
    wet: 0.3
  }).toDestination();

  let hiHatFilter = new Tone.Filter(15000, "bandpass").connect(reverb);

  let hiHat = new Tone.NoiseSynth({
    envelope: {
      attack: 0.001, decay: 0.1, sustain: 0, release: 0
    },
    volume: -6
  }).connect(hiHatFilter);

  class Snare {
    constructor() {
      this.noiseFilter = new Tone.Filter(5000, "bandpass").connect(reverb);
      this.noiseSynth = new Tone.NoiseSynth({
        envelope: {
          attack: 0.001, decay: 0.1, sustain: 0, release: 0
        },
        volume: -12
<span aria-label=" Page 248. " epub:type="pagebreak" id="pg_248" role="doc-pagebreak"/>      }).connect(this.noiseFilter);

      this.synth = new Tone.Synth({
        envelope: {
          attack: 0.0001, decay: 0.1, sustain: 0, release: 0
        },
        oscillator: {type: "sine"},
        volume: -12
      }).connect(reverb);
    }

    triggerAttackRelease(duration, when) {
      this.noiseSynth.triggerAttackRelease(duration, when);
      this.synth.triggerAttackRelease("G3", duration, when);
    }
  }

  let snare = new Snare();

  let kick = new Tone.MembraneSynth({
    pitchDecay: 0.02,
    octaves: 6,
    volume: -9
  }).connect(reverb);

  return {hiHat, snare, kick};
}

let drums = mkDrums();

let lowBass = new Tone.FMSynth({
  oscillator: {
    type: "triangle"
  },
  envelope: {
    attack: 0.0001, decay: 0.5, sustain: 0.3, release: 0.1
  },
  volume: -3
}).toDestination();

let highBass = new Tone.FMSynth({
  oscillator: {
    type: "square"
  },
  envelope: {
    attack: 0.0001, decay: 0.1, sustain: 0.3, release: 0.1
  },
  volume: -9
}).toDestination();

let chordSynth = new Tone.PolySynth(Tone.Synth, {
  oscillator: {
    type: "triangle"
  },
<span aria-label=" Page 249. " epub:type="pagebreak" id="pg_249" role="doc-pagebreak"/>  volume: -12
}).toDestination();

// Samples from freesound.org:
// https://freesound.org/people/MTG/sounds/357432/
// https://freesound.org/people/MTG/sounds/357336/
// https://freesound.org/people/MTG/sounds/357546/
let sampler = new Tone.Sampler({
  urls: {
    "C5": "trumpet-c5.mp3", 
    "D5": "trumpet-d5.mp3", 
    "F5": "trumpet-f5.mp3" 
  },
  baseUrl: "https://skilldrick-jscc.s3.us-west-2.amazonaws.com/",
  attack: 0,
  release: 1,
  volume: -24
}).toDestination();

////////////////
// Sequencing //
////////////////

// Converts a string to an array of notes or nulls.
// Dots in the string become nulls in the array and are silent.
function mkSequence(pattern) {
  return pattern.split(" ").map(value =&gt; {
    if (value == ".") {
      return null;
    } else {
      return value;
    }
  });
}

// Converts a string to an array of notes or nulls.
// Spaces between pipes in the string become nulls in the array and are silent.
function mkPipeSequence(pattern) {
  return pattern.split("|").map(value =&gt; {
    if (value.trim() == " ") {
      return null;
    } else {
      return value;
    }
  });
}

let drumPattern = {
  kick:  "x…x…",
  snare: "..x…x.",
  hiHat: "xxxxxxxx",
};

<span aria-label=" Page 250. " epub:type="pagebreak" id="pg_250" role="doc-pagebreak"/>let hiHatSequence = new Tone.Sequence(time =&gt; {
  drums.hiHat.triggerAttackRelease("16n", time);
}, mkSequence(drumPattern.hiHat), "8n");

let snareSequence = new Tone.Sequence(time =&gt; {
  drums.snare.triggerAttackRelease("16n", time);
}, mkSequence(drumPattern.snare), "8n");

let kickSequence = new Tone.Sequence(time =&gt; {
  drums.kick.triggerAttackRelease(50, "16n", time);
}, mkSequence(drumPattern.kick), "8n");

let lowBassSequence = new Tone.Sequence((time, note) =&gt; {
  lowBass.triggerAttackRelease(note, "16n", time, 0.6);
}, mkPipeSequence("G2|  |  |G2|G2|  |  |  "), "8n");

let highBassSequence = new Tone.Sequence((time, note) =&gt; {
  highBass.triggerAttackRelease(note, "16n", time, 0.3);
}, mkPipeSequence("G3|F3|E3|D3|G2|D3|G3|D3"), "8n");

let chords = {
  1: ["D4", "G4"],
  2: ["E4", "G4"],
  3: ["C4", "E4", "G4"],
  4: ["B3", "F4", "G4"],
};

function playChord(time, chordName) {
  let notes = chords[chordName];
  chordSynth.triggerAttackRelease(notes, "16n", time, 0.6);
}

let chordSequence1 = new Tone.Sequence((time, chordName) =&gt; {
  playChord(time, chordName);
}, mkSequence("1…2…3..4…31…2…3..4.343"), "8n");

let chordSequence2 = new Tone.Sequence((time, chordName) =&gt; {
  playChord(time, chordName);
}, mkSequence("3…2…4..1.213"), "8n");

let trumpetPart = new Tone.Part((time, note) =&gt; {
  sampler.triggerAttackRelease(note, "1n", time);
}, [
  ["0:0:0", "G5"],
  ["0:2:0", "C5"],
  ["1:0:0", "G5"],

  ["2:0:0", "D5"],
  ["2:2:0", "C5"],
  ["3:0:0", "B4"],

  ["4:0:0", "G5"],
  ["4:2:0", "C5"],
  ["5:0:0", "G5"],

<span aria-label=" Page 251. " epub:type="pagebreak" id="pg_251" role="doc-pagebreak"/>  ["6:0:0", "D5"],
  ["6:2:0", "C5"],
  ["7:0:0", "B4"],
  ["7:2:0", "D5"],

  ["8:0:0", "C5"],
  ["8:2:0", "E5"],
  ["9:0:0", "F5"],
  ["9:2:0", "D5"],

  ["10:0:0", "C5"],
  ["10:2:0", "E5"],
  ["11:0:0", "D5"],

  ["12:0:0", "C5"],
  ["12:2:0", "E5"],
  ["13:0:0", "F5"],
  ["13:2:0", "D5"],

  ["14:0:0", "C5"],
  ["14:2:0", "E5"],
  ["15:0:0", ["B4", "G5"]]
]);

//////////
// Song //
//////////

hiHatSequence.start("0:0:0").stop("44:0:0");
snareSequence.start("0:0:0").stop("44:0:0");
kickSequence.start("0:0:0").stop("44:0:0");

lowBassSequence.start("0:0:0").stop("47:3:0");
highBassSequence.start("4:0:0").stop("47:3:0");

chordSequence1.start("8:0:0").stop("24:0:0");
chordSequence2.start("24:0:0").stop("32:0:0");
chordSequence1.start("32:0:0").stop("40:0:0");

trumpetPart.start("16:0:0");

////////////////////
// Event Handling //
////////////////////

let play = document.querySelector("#play");
let playing = document.querySelector("#playing");

play.addEventListener("click", () =&gt; {
  // Hide this button
  play.style = "display: none";
  playing.style = " ";

  Tone.start();

<span aria-label=" Page 252. " epub:type="pagebreak" id="pg_252" role="doc-pagebreak"/>  // Modify this to start playback at a different part of the song
  Tone.Transport.position = "0:0:0";
  Tone.Transport.start();
});
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-16: The complete code</samp></p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="H1" id="sec9"><span id="h1-84"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>
<p class="TNI1">In this chapter, you coded a song in JavaScript! Now that you’re used to working with Tone.js, you can use it to make your own song. Another fun thing to try is algorithmic music, where instead of writing out a fixed song, you write code that semirandomly produces new music each time it runs. One simple way to try this out is to come up with a list of nice-sounding chords, and then randomly choose which one to play on any given beat (you could use <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Loop</span> to accomplish this, as we did in <a href="chapter12.xhtml#Lis12-12">Listing 12-12</a> in the previous chapter).</p>
</section>
</section>
</body>
</html>