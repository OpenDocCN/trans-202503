["```\n2\n16 6 63 16 82 25 2 43 5 17 10 56 85 38 15 32 91\n1 57\n```", "```\n6 63 16 82 25 2 43 5 17 10 56 85 38 15 32 91\n```", "```\n6 63 16 82 25 43 5 17 10 56 85 38 15 32\n```", "```\n6 63 16 82 25 43 5 17 10 56 85 38 15 32 57\n```", "```\n#define MAX_RECEIPTS 1000000\n#define MAX_COST 1000000\n\ntypedef struct receipt {\n  int cost;\n  int used;\n} receipt;\n```", "```\n int extract_max(receipt receipts[], int num_receipts) {\n   int max, max_index, i;\n❶ max = -1;\n   for (i = 0; i < num_receipts; i++)\n   ➋ if (!receipts[i].used && receipts[i].cost > max) {\n        max_index = i;\n        max = receipts[i].cost;\n      }\n➌ receipts[max_index].used = 1;\n   return max;\n}\n\nint extract_min(receipt receipts[], int num_receipts) {\n  int min, min_index, i;\n➍ min = MAX_COST + 1;\n   for (i = 0; i < num_receipts; i++)\n   ➎ if (!receipts[i].used && receipts[i].cost < min) {\n        min_index = i;\n        min = receipts[i].cost;\n     }\n➏ receipts[min_index].used = 1;\n   return min;\n}\n```", "```\n int main(void) {\n   static struct receipt receipts[MAX_RECEIPTS];\n   int num_days, num_receipts_today;\n   int num_receipts = 0;\n❶ long long total_prizes = 0;\n   int i, j, max, min;\n   scanf(\"%d\", &num_days);\n\n   for (i = 0; i < num_days; i++) {\n     scanf(\"%d\", &num_receipts_today);\n     for (j = 0; j < num_receipts_today; j++) {\n       scanf(\"%d\", &receipts[num_receipts].cost);\n       receipts[num_receipts].used = 0;\n       num_receipts++;\n }\n    max = extract_max(receipts, num_receipts);\n    min = extract_min(receipts, num_receipts);\n    total_prizes += max - min;\n  }\n  printf(\"%lld\\n\", total_prizes);\n  return 0;\n}\n```", "```\ntypedef struct node {\n  fields for receipts\n  struct node *left, *right, *parent;\n} node;\n```", "```\ntypedef struct heap_element {\n  int receipt_index;\n  int cost;\n} heap_element;\n```", "```\nvoid max_heap_insert(heap_element heap[], int *num_heap,\n                     int receipt_index, int cost) {\n  int i;\n  heap_element temp;\n❶ (*num_heap)++;\n➋ heap[*num_heap] = (heap_element){receipt_index, cost};\n➌ i = *num_heap;\n➍ while (i > 1 && heap[i].cost > heap[i / 2].cost) {\n     temp = heap[i];\n     heap[i] = heap[i / 2];\n     heap[i / 2] = temp;\n  ➎ i = i / 2;\n  }\n}\n```", "```\n heap_element max_heap_extract(heap_element heap[], int *num_heap) {\n   heap_element remove, temp;\n   int i, child;\n❶ remove = heap[1];\n➋ heap[1] = heap[*num_heap];\n➌ (*num_heap)--;\n➍ i = 1;\n➎ while (i * 2 <= *num_heap) {\n  ➏ child = i * 2;\n     if (child < *num_heap && heap[child + 1].cost > heap[child].cost)\n    ❼ child++;\n  ❽ if (heap[child].cost > heap[i].cost) {\n       temp = heap[i];\n       heap[i] = heap[child];\n       heap[child] = temp;\n    ❾ i = child;\n     } else\n       break;\n  }\n  return remove;\n}\n```", "```\nvoid min_heap_insert(heap_element heap[], int *num_heap,\n                     int receipt_index, int cost) {\n  int i;\n  heap_element temp;\n  (*num_heap)++;\n  heap[*num_heap] = (heap_element){receipt_index, cost};\n i = *num_heap;\n  while (i > 1 && heap[i].cost < heap[i / 2].cost) {\n    temp = heap[i];\n    heap[i] = heap[i / 2];\n    heap[i / 2] = temp;\n    i = i / 2;\n  }\n}\n```", "```\nheap_element min_heap_extract(heap_element heap[], int *num_heap) {\n  heap_element remove, temp;\n  int i, child;\n  remove = heap[1];\n  heap[1] = heap[*num_heap];\n  (*num_heap)--;\n  i = 1;\n  while (i * 2 <= *num_heap) {\n    child = i * 2;\n    if (child < *num_heap && heap[child + 1].cost < heap[child].cost)\n      child++;\n    if (heap[child].cost < heap[i].cost) {\n      temp = heap[i];\n      heap[i] = heap[child];\n      heap[child] = temp;\n      i = child;\n    } else\n      break;\n  }\n  return remove;\n}\n```", "```\nint main(void) {\n❶ static int used[MAX_RECEIPTS] = {0};\n➋ static heap_element max_heap[MAX_RECEIPTS + 1];\n   static heap_element min_heap[MAX_RECEIPTS + 1];\n   int num_days, receipt_index_today;\n   int receipt_index = 0;\n   long long total_prizes = 0;\n   int i, j, cost;\n   int max_num_heap = 0, min_num_heap = 0;\n   heap_element max_element, min_element;\n   scanf(\"%d\", &num_days);\n\n   for (i = 0; i < num_days; i++) {\n     scanf(\"%d\", &receipt_index_today);\n     for (j = 0; j < receipt_index_today; j++) {\n       scanf(\"%d\", &cost);\n     ➌ max_heap_insert(max_heap, &max_num_heap, receipt_index, cost);\n     ➍ min_heap_insert(min_heap, &min_num_heap, receipt_index, cost);\n       receipt_index++;\n    }\n\n ➎ max_element = max_heap_extract(max_heap, &max_num_heap);\n    while (used[max_element.receipt_index])\n      max_element = max_heap_extract(max_heap, &max_num_heap);\n    used[max_element.receipt_index] = 1;\n\n ➏ min_element = min_heap_extract(min_heap, &min_num_heap);\n    while (used[min_element.receipt_index])\n      min_element = min_heap_extract(min_heap, &min_num_heap);\n    used[min_element.receipt_index] = 1;\n    total_prizes += max_element.cost - min_element.cost;\n  }\n  printf(\"%lld\\n\", total_prizes);\n  return 0;\n}\n```", "```\n2\n2 6 7\n2 9 10\n```", "```\n#define N 10\n\nint main(void) {\n  static int values[N] = {96, 61, 36, 74, 45, 60, 47, 6, 95, 93};\n  static int min_heap[N + 1];\n  int i, min_num_heap = 0;\n\n  // Heapsort. 4 lines!\n  for (i = 0; i < N; i++)\n    min_heap_insert(min_heap, &min_num_heap, values[i]);\n  for (i = 0; i < N; i++)\n    values[i] = min_heap_extract(min_heap, &min_num_heap);\n\n  for (i = 0; i < N; i++)\n    printf(\"%d \", values[i]);\n  printf(\"\\n\");\n  return 0;\n}\n```", "```\n11 A/54 I/16 K/39 E/36 B/42 G/55 D/49 H/56 C/58 J/40 F/5\n0\n```", "```\n(<left_subtreap><L>/<P><right_subtreap>)\n```", "```\n((A/54(B/42))C/58(((D/49(E/36(F/5)))G/55)H/56((I/16)J/40(K/39))))\n```", "```\nA/54 I/16 K/39 E/36 B/42 G/55 D/49 H/56 C/58 J/40 F/5\n```", "```\nA/54 B/42\nI/16 K/39 E/36 G/55 D/49 H/56 J/40 F/5\n```", "```\n(A/54(B/42))\n```", "```\nC/58\n```", "```\n(((D/49(E/36(F/5)))G/55)H/56((I/16)J/40(K/39)))\n```", "```\nA/54 B/42 C/58 D/49 E/36 F/5 G/55 H/56 I/16 J/40 K/39\n```", "```\n#define MAX_NODES 50000\n#define LABEL_LENGTH 16\ntypedef struct treap_node {\n  char * label;\n  int priority;\n} treap_node;\n```", "```\nint main(void) {\n  static treap_node treap_nodes[MAX_NODES];\n  int num_nodes, i;\n  scanf(\"%d \", &num_nodes);\n  while (num_nodes > 0) {\n    for (i = 0; i < num_nodes; i++) {\n      treap_nodes[i].label = read_label(LABEL_LENGTH);\n      scanf(\"%d \", &treap_nodes[i].priority);\n    }\n    qsort(treap_nodes, num_nodes, sizeof(treap_node), compare);\n    solve(treap_nodes, 0, num_nodes - 1);\n    printf(\"\\n\");\n    scanf(\"%d \", &num_nodes);\n  }\n  return 0;\n}\n```", "```\n /* based on https://stackoverflow.com/questions/16870485 */\n char *read_label(int size) {\n   char *str;\n   int ch;\n   int len = 0;\n   str = malloc(size);\n   if (str == NULL) {\n     fprintf(stderr, \"malloc error\\n\");\n     exit(1);\n   }\n❶ while ((ch = getchar()) != EOF && (ch != '/')) {\n     str[len++] = ch;\n     if (len == size) {\n       size = size * 2;\n       str = realloc(str, size);\n       if (str == NULL) {\n         fprintf(stderr, \"realloc error\\n\");\n         exit(1);\n       }\n     }\n   }\n   str[len] = '\\0';\n   return str;\n}\n```", "```\nint compare(const void *v1, const void *v2) {\n  const treap_node *n1 = v1;\n  const treap_node *n2 = v2;\n  return strcmp(n1->label, n2->label);\n}\n```", "```\nint max_priority_index(treap_node treap_nodes[], int left, int right) {\n  int i;\n  int max_index = left;\n  for (i = left + 1; i <= right; i++)\n    if (treap_nodes[i].priority > treap_nodes[max_index].priority)\n      max_index = i;\n  return max_index;\n}\n```", "```\nvoid solve(treap_node treap_nodes[], int left, int right) {\n  int root_index;\n  treap_node root;\n❶ if (left > right)\n     return;\n➋ root_index = max_priority_index(treap_nodes, left, right);\n   root = treap_nodes[root_index];\n   printf(\"(\");\n➌ solve(treap_nodes, left, root_index - 1);\n   printf(\"%s/%d\", root.label, root.priority);\n➍ solve(treap_nodes, root_index + 1, right);\n   printf(\")\");\n}\n```", "```\nA/1 B/2 C/3 D/4 E/5 F/6 G/7\n```", "```\nA/1 B/2 C/3 D/4 E/5 F/6\n```", "```\n0-10\n0-5 6-10\n0-2 3-5 6-8 9-10\n0-1 2-2 3-4 5-5 6-7 8-8 9-9 10-10\n0-0 1-1 * * 3-3 4-4 * * 6-6 7-7 * * * * * *\n```", "```\ntypedef struct segtree_node {\n  int left, right;\n  int max_index;\n} segtree_node;\n```", "```\nvoid init_segtree(segtree_node segtree[], int node,\n                  int left, int right)\n```", "```\ninit_segtree(segtree, 1, 0, num_elements - 1);\n```", "```\nvoid init_segtree(segtree_node segtree[], int node,\n                  int left, int right) {\n  int mid;\n  segtree[node].left = left;\n  segtree[node].right = right;\n❶ if (left == right)\n     return;\n➋ mid = (left + right) / 2;\n➌ init_segtree(segtree, node * 2, left, mid);\n➍ init_segtree(segtree, node * 2 + 1, mid + 1, right);\n}\n```", "```\nint fill_segtree(segtree_node segtree[], int node,\n                 treap_node treap_nodes[]) {\n  int left_max, right_max;\n\n❶ if (segtree[node].left == segtree[node].right) {\n     segtree[node].max_index = segtree[node].left;\n  ➋ return segtree[node].max_index;\n  }\n➌ left_max = fill_segtree(segtree, node * 2, treap_nodes);\n➍ right_max = fill_segtree(segtree, node * 2 + 1, treap_nodes);\n\n➎ if (treap_nodes[left_max].priority > treap_nodes[right_max].priority)\n     segtree[node].max_index = left_max;\n   else\n     segtree[node].max_index = right_max;\n➏ return segtree[node].max_index;\n}\n```", "```\nint query_segtree(segtree_node segtree[], int node,\n                  treap_node treap_nodes[], int left, int right) {\n  int left_max, right_max;\n\n❶ if (right < segtree[node].left || left > segtree[node].right)\n     return -1;\n\n➋ if (left <= segtree[node].left && segtree[node].right <= right)\n     return segtree[node].max_index;\n\n➌ left_max = query_segtree(segtree, node * 2,\n                            treap_nodes, left, right);\n➍ right_max = query_segtree(segtree, node * 2 + 1,\n                             treap_nodes, left, right);\n\n   if (left_max == -1)\n     return right_max;\n   if (right_max == -1)\n     return left_max;\n➎ if (treap_nodes[left_max].priority > treap_nodes[right_max].priority)\n     return left_max;\n   return right_max;\n}\n```", "```\n int main(void) {\n   static treap_node treap_nodes[MAX_NODES];\n❶ static segtree_node segtree[MAX_NODES * 4 + 1];\n   int num_nodes, i;\n   scanf(\"%d \", &num_nodes);\n   while (num_nodes > 0) {\n     for (i = 0; i < num_nodes; i++) {\n       treap_nodes[i].label = read_label(LABEL_LENGTH);\n       scanf(\"%d \", &treap_nodes[i].priority);\n     }\n     qsort(treap_nodes, num_nodes, sizeof(treap_node), compare);\n  ➋ init_segtree(segtree, 1, 0, num_nodes - 1);\n  ➌ fill_segtree(segtree, 1, treap_nodes);\n  ➍ solve(treap_nodes, 0, num_nodes - 1, segtree);\n     printf(\"\\n\"); \n     scanf(\"%d \", &num_nodes);\n  }\n  return 0;\n}\n```", "```\nvoid solve(treap_node treap_nodes[], int left, int right,\n           segtree_node segtree[]) {\n  int root_index;\n  treap_node root;\n  if (left > right)\n    return;\n❶ root_index = query_segtree(segtree, 1, treap_nodes, left, right);\n   root = treap_nodes[root_index];\n   printf(\"(\");\n   solve(treap_nodes, left, root_index - 1, segtree);\n   printf(\"%s/%d\", root.label, root.priority);\n   solve(treap_nodes, root_index + 1, right, segtree);\n   printf(\")\");\n}\n```", "```\ntypedef struct segtree_node {\n  int left, right;\n  int max_sum, max_element;\n} segtree_node;\n```", "```\ntypedef struct node_info {\n  int max_sum, max_element;\n} node_info;\n```", "```\nint max(int v1, int v2) {\n  if (v1 > v2)\n    return v1;\n  else\n    return v2;\n}\n\nnode_info fill_segtree(segtree_node segtree[], int node,\n                       int seq[]) {\n  node_info left_info, right_info;\n\n❶ if (segtree[node].left == segtree[node].right) {\n     segtree[node].max_sum = -1;\n     segtree[node].max_element = seq[segtree[node].left];\n  ➋ return (node_info){segtree[node].max_sum, segtree[node].max_element};\n   }\n\n➌ left_info = fill_segtree(segtree, node * 2, seq);\n   right_info = fill_segtree(segtree, node * 2 + 1, seq);\n\n➍ segtree[node].max_element = max(left_info.max_element,\n                                   right_info.max_element);\n\n➎ if (left_info.max_sum == -1 && right_info.max_sum == -1)\n  ➏ segtree[node].max_sum = left_info.max_element +\n                             right_info.max_element;\n\n❼ else if (left_info.max_sum == -1)\n     segtree[node].max_sum = max(left_info.max_element +\n                                 right_info.max_element,\n                                 right_info.max_sum);\n\n❽ else if (right_info.max_sum == -1)\n     segtree[node].max_sum = max(left_info.max_element +\n                                 right_info.max_element,\n                                 left_info.max_sum);\n\n  else\n ❾ segtree[node].max_sum = max(left_info.max_element +\n                                right_info.max_element,\n                                max(left_info.max_sum, right_info.max_sum));\n  return (node_info){segtree[node].max_sum, segtree[node].max_element};\n}\n```", "```\nnode_info query_segtree(segtree_node segtree[], int node,\n                        int seq[], int left, int right) {\n  node_info left_info, right_info, ret_info;\n\n❶ if (right < segtree[node].left || left > segtree[node].right)\n     return (node_info){-1, -1};\n\n➋ if (left <= segtree[node].left && segtree[node].right <= right)\n     return (node_info) {segtree[node].max_sum, segtree[node].max_element};\n\n   left_info = query_segtree(segtree, node * 2, seq, left, right);\n   right_info = query_segtree(segtree, node * 2 + 1, seq, left, right);\n\n   if (left_info.max_element == -1)\n     return right_info;\n   if (right_info.max_element == -1)\n     return left_info;\n\n   ret_info.max_element = max(left_info.max_element, right_info.max_element);\n\n   if (left_info.max_sum == -1 && right_info.max_sum == -1) {\n     ret_info.max_sum = left_info.max_element + right_info.max_element;\n     return ret_info;\n   }\n\n   else if (left_info.max_sum == -1) {\n     ret_info.max_sum = max(left_info.max_element + right_info.max_element,\n                            right_info.max_sum);\n     return ret_info;\n   }\n\n   else if (right_info.max_sum == -1) {\n     ret_info.max_sum = max(left_info.max_element + right_info.max_element,\n                            left_info.max_sum);\n     return ret_info;\n   }\n\n   else {\n     ret_info.max_sum = max(left_info.max_element + right_info.max_element,\n                            max(left_info.max_sum, right_info.max_sum));\n     return ret_info;\n   }\n}\n```", "```\nnode_info update_segtree(segtree_node segtree[], int node,\n                         int seq[], int index) {\n  segtree_node left_node, right_node;\n  node_info left_info, right_info;\n\n❶ if (segtree[node].left == segtree[node].right) {\n     segtree[node].max_element = seq[index];\n     return (node_info) {segtree[node].max_sum, segtree[node].max_element};\n  }\n\n  left_node = segtree[node * 2];\n  right_node = segtree[node * 2 + 1];\n\n➋ if (index <= left_node.right ) {\n  ➌ left_info = update_segtree(segtree, node * 2, seq, index);\n➍ right_info = (node_info){right_node.max_sum, right_node.max_element};\n } else {\n   right_info = update_segtree(segtree, node * 2 + 1, seq, index);\n   left_info = (node_info){left_node.max_sum, left_node.max_element};\n }\n\n segtree[node].max_element = max(left_info.max_element,\n                                 right_info.max_element);\n\n if (left_info.max_sum == -1 && right_info.max_sum == -1)\n   segtree[node].max_sum = left_info.max_element +\n                           right_info.max_element;\n\n else if (left_info.max_sum == -1)\n   segtree[node].max_sum = max(left_info.max_element +\n                               right_info.max_element,\n                               right_info.max_sum);\n\n else if (right_info.max_sum == -1)\n   segtree[node].max_sum = max(left_info.max_element +\n                               right_info.max_element,\n                               left_info.max_sum);\n\n  else\n    segtree[node].max_sum = max(left_info.max_element +\n                                right_info.max_element,\n                                max(left_info.max_sum, right_info.max_sum));\n return (node_info) {segtree[node].max_sum, segtree[node].max_element};\n}\n```", "```\n#define MAX_SEQ 100000\n\nint main(void) {\n  static int seq[MAX_SEQ + 1];\n  static segtree_node segtree[MAX_SEQ * 4 + 1];\n  int num_seq, num_ops, i, op, x, y;\n  char c;\n  scanf(\"%d\", &num_seq);\n  for (i = 1; i <= num_seq; i++)\n    scanf(\"%d\", &seq[i]);\n  init_segtree(segtree, 1, 1, num_seq);\n  fill_segtree(segtree, 1, seq);\n  scanf(\"%d\", &num_ops);\n  for (op = 0; op < num_ops; op++) {\n    scanf(\" %c%d%d \", &c, &x, &y);\n\n ❶ if (c == 'U') {\n      seq[x] = y;\n      update_segtree(segtree, 1, seq, x);\n\n ➋ } else {\n     printf(\"%d\\n\", query_segtree(segtree, 1, seq, x, y).max_sum);\n    }\n  }\n  return 0;\n}\n```"]