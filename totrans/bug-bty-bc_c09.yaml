- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cross-Site Request Forgery
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Cross-site request forgery (**CSRF)* is a client-side technique used to attack
    other users of a web application. Using CSRF, attackers can send HTTP requests
    that pretend to come from the victim, carrying out unwanted actions on a victim’s
    behalf. For example, an attacker could change your password or transfer money
    from your bank account without your permission.'
  prefs: []
  type: TYPE_NORMAL
- en: CSRF attacks specifically target state-changing requests, like sending tweets
    and modifying user settings, instead of requests that reveal sensitive user info.
    This is because attackers won’t be able to read the response to the forged requests
    sent during a CSRF attack. Let’s get into how this attack works.
  prefs: []
  type: TYPE_NORMAL
- en: Mechanisms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember from Chapter 3 that most modern web applications authenticate their
    users and manage user sessions by using session cookies. When you first log in
    to a website, the web server establishes a new session: it sends your browser
    a session cookie associated with the session, and this cookie proves your identity
    to the server. Your browser stores the session cookies associated with that website
    and sends them along with every subsequent request you send to the site. This
    all happens automatically, without the user’s involvement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when you log into Twitter, the Twitter server sends your browser
    the session cookie via an HTTP response header called `Set-Cookie`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Your browser receives the session cookie, stores it, and sends it along via
    the `Cookie` HTTP request header in every one of your requests to Twitter. This
    is how the server knows your requests are legit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Armed with your session cookie, you can carry out authenticated actions like
    accessing confidential information, changing your password, or sending a private
    message without reentering your password. To get ahold of your own session cookies,
    intercept the requests your browsers send to the site after you’ve logged in.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s say there’s a Send a Tweet HTML form on Twitter’s web page. Users
    can enter their tweets by using this form and clicking the Submit button to send
    them ([Figure 9-1](#figure9-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f09001](image_fi/501546c09/f09001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-1: An example HTML form that allows users to send a tweet'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that Twitter doesn’t really use this form (and Twitter’s actual Send a
    Tweet functionality isn’t vulnerable to CSRF attacks). The source code of the
    example HTML form looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `<h1>` tags denote a first-level HTML heading 1, whereas the `<form>` tags
    define the beginning and end of an HTML form 2. The form has the method attribute
    `POST` and the action attribute `https://twitter.com/send_a_tweet`. This means
    that the form will submit a POST request to the *https://twitter.com/send_a_tweet*
    endpoint when the user clicks Submit. Next, an `<input>` tag defines a text input
    with the default value of `Hello world!`. When the form is submitted, any user
    input in this field will be sent as a POST parameter named `tweet_content` 3.
    A second input tag defines the `Submit` button 4. When users click this button,
    the form will be submitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click the Submit button on the page, your browser will send a POST
    request to *https://twitter.com/send_a_tweet*. The browser will include your Twitter
    session cookie with the request. You could see the request generated by the form
    in your proxy. It should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This functionality has a vulnerability: any site, and not just Twitter, can
    initiate this request. Imagine that an attacker hosts their own website that displays
    an HTML form like [Figure 9-2](#figure9-2).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f09002](image_fi/501546c09/f09002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-2: An example HTML form that an attacker uses to exploit a CSRF vulnerability'
  prefs: []
  type: TYPE_NORMAL
- en: 'The page’s source code is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When you click the Submit button on this page, your browser will send a POST
    request. Because the browser automatically includes your Twitter session cookies
    in requests to Twitter, Twitter will treat the request as valid, causing your
    account to tweet `Follow @vickieli7 on Twitter!` Here’s the corresponding request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Even though this request doesn’t come from Twitter, Twitter will recognize it
    as valid because it includes your real Twitter session cookie. This attack would
    make you send the tweet every time you click Submit on the malicious page.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s true that this attack page isn’t very useful: it requires the victim to
    click a button, which most users probably won’t do. How can attackers make the
    exploit more reliable? Realistically, a malicious CSRF page would look more like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This HTML places the form in an invisible iframe to hide it from the user’s
    view. Remember from Chapter 8 that an *iframe* is an HTML element that embeds
    another document within the current HTML document. This particular iframe’s style
    is set to `display:none`, meaning it won’t be displayed on the page, making the
    form invisible 1. Then, JavaScript code between the script tags 3 will submit
    the form with the ID `csrf-form` 2 without the need for user interaction. The
    code fetches the HTML form by referring to it by its ID, `csrf-form`. Then the
    code submits the form by calling the `submit()` method on it. With this new attack
    page, any victim who visits the malicious site will be forced to tweet.
  prefs: []
  type: TYPE_NORMAL
- en: What attackers can actually accomplish with a real CSRF vulnerability depends
    on where the vulnerability is found. For example, let’s say a request that empties
    a user’s online shopping cart has a CSRF vulnerability. When exploited in the
    wild, this vulnerability can at most cause annoyance to the site users. It doesn’t
    have the potential to cause any major financial harm or identity theft.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, some CSRFs can lead to much bigger issues. If a CSRF vulnerability
    is present on requests used to change a user’s password, for example, an attacker
    can change other users’ passwords against their will and take over their entire
    accounts! And when a CSRF appears in functionalities that handle user finances,
    like account balance transfers, attackers can potentially cause unauthorized balance
    transfers out of the victim’s bank account. You can also use CSRFs to trigger
    injection vulnerabilities such as XSS and command injections.
  prefs: []
  type: TYPE_NORMAL
- en: Prevention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to prevent CSRFs is to use *CSRF tokens*. Applications can embed
    these random and unpredictable strings in every form on their website, and browsers
    will send this string along with every state-changing request. When the request
    reaches the server, the server can validate the token to make sure the request
    indeed originated from its website. This CSRF token should be unique for each
    session and/or HTML form so attackers can’t guess the token’s value and embed
    it on their websites. Tokens should have sufficient entropy so that they cannot
    be deduced by analyzing tokens across sessions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server generates random CSRF tokens and embeds correct CSRF tokens in forms
    on the legitimate site. Notice the new input field used to specify a CSRF token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Twitter’s server can require that the browser send the correct value of the
    `csrf_token` POST parameter along with the request for it to be successful. If
    the value of `csrf_token` is missing or incorrect, the server should see the request
    as fake and reject it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the resulting POST request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Many frameworks have CSRF tokens built in, so often you can simply use your
    framework’s implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides implementing CSRF tokens to ensure the authenticity of requests, another
    way of protecting against CSRF is with `SameSite` cookies. The `Set-Cookie` header
    allows you to use several optional flags to protect your users’ cookies, one of
    which is the `SameSite` flag. When the `SameSite` flag on a cookie is set to `Strict`,
    the client’s browser won’t send the cookie during cross-site requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Another possible setting for the `SameSite` flag is `Lax`, which tells the
    client’s browser to send a cookie only in requests that cause top-level navigation
    (when users actively click a link and navigate to the site). This setting ensures
    that users still have access to the resources on your site if the cross-site request
    is intentional. For example, if you navigate to Facebook from a third-party site,
    your Facebook logins will be sent. But if a third-party site initiates a POST
    request to Facebook or tries to embed the contents of Facebook within an iframe,
    cookies won’t be sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Specifying the `SameSite` attribute is good protection against CSRF because
    both the `Strict` and `Lax` settings will prevent browsers from sending cookies
    on cross-site form POST or AJAX requests, and within iframes and image tags. This
    renders the classic CSRF hidden-form attack useless.
  prefs: []
  type: TYPE_NORMAL
- en: In 2020, Chrome and a few other browsers made `SameSite=Lax` the default cookie
    setting if it’s not explicitly set by the web application. Therefore, even if
    a web application doesn’t implement CSRF protection, attackers won’t be able to
    attack a victim who uses Chrome with POST CSRF. The efficacy of a classic CSRF
    attack will likely be greatly reduced, since Chrome has the largest web browser
    market share. On Firefox, the `SameSite` default setting is a feature that needs
    to be enabled. You can enable it by going to `about:config` and setting `network.cookie.sameSite.laxByDefault`
    to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even when browsers adopt the `SameSite-`by-default policy, CSRFs are still
    possible under some conditions. First, if the site allows state-changing requests
    with the GET HTTP method, third-party sites can attack users by creating CSRF
    with a GET request. For example, if the site allows you to change a password with
    a GET request, you could post a link like this to trick users into clicking it:
    *https://email.example.com/password_change?new_password=abc123*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since clicking this link will cause top-level navigation, the user’s session
    cookies will be included in the GET request, and the CSRF attack will succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In another scenario, sites manually set the `SameSite` attribute of a cookie
    to `None`. Some web applications have features that require third-party sites
    to send cross-site authenticated requests. In that case, you might explicitly
    set `SameSite` on a session cookie to `None`, allowing the sending of the cookie
    across origins, so traditional CSRF attacks would still work. Finally, if the
    victim is using a browser that doesn’t set the `SameSite` attribute to `Lax` by
    default (including Firefox, Internet Explorer, and Safari), traditional CSRF attacks
    will still work if the target application doesn’t implement diligent CSRF protection.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll explore other ways of bypassing CSRF protection later in this chapter.
    For now, just remember: when websites don’t implement `SameSite` cookies or other
    CSRF protection for every state-changing request, the request becomes vulnerable
    to CSRF if the user is not using a `SameSite`-by-default browser. CSRF protection
    is still the responsibility of the website despite the adoption of `SameSite`-by-default.'
  prefs: []
  type: TYPE_NORMAL
- en: Hunting for CSRFs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CSRFs are common and easy to exploit. To look for them, start by discovering
    state-changing requests that aren’t shielded by CSRF protections. Here’s a three-step
    process for doing so. Remember that because browsers like Chrome offer automatic
    CSRF protection, you need to test with another browser, such as Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Spot State-Changing Actions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Actions that alter the users’ data are called *state-changing actions*. For
    example, sending tweets and modifying user settings are both state-changing. The
    first step of spotting CSRFs is to log in to your target site and browse through
    it in search of any activity that alters data.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say you’re testing *email.example.com*, a subdomain of *example.com*
    that handles email. Go through all the app’s functionalities, clicking all the
    links. Intercept the generated requests with a proxy like Burp and write down
    their URL endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Record these endpoints one by one, in a list like the following, so you can
    revisit and test them later:'
  prefs: []
  type: TYPE_NORMAL
- en: '**State-changing requests on ***email.example.com*****'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change password: *email.example.com/password_change*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POST request
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Request parameters: `new_password`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Send email: *email.example.com/send_email*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POST request
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Request parameters: `draft_id`, `recipient_id`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Delete email: *email.example.com/delete_email*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POST request
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Request parameters: `email_id`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Step 2: Look for a Lack of CSRF Protections'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now visit these endpoints to test them for CSRFs. First, open up Burp Suite
    and start intercepting all the requests to your target site in the Proxy tab.
    Toggle the **Intercept** button until it reads **Intercept is on** ([Figure 9-3](#figure9-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f09003](image_fi/501546c09/f09003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-3: Set to Intercept is on to capture your browser’s traffic. Click
    the ***Forward*** button to forward the current request to the server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let Burp run in the background to record other traffic related to your target
    site while you’re actively hunting for CSRFs. Keep clicking the **Forward** button
    until you encounter the request associated with the state-changing action. For
    example, let’s say you’re testing whether the password-change function you discovered
    is vulnerable to CSRFs. You’ve intercepted the request in your Burp proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the intercepted request, look for signs of CSRF protection mechanisms. Use
    the search bar at the bottom of the window to look for the string `"csrf"` or
    `"state"`. CSRF tokens can come in many forms besides POST body parameters; they
    sometimes show up in request headers, cookies, and URL parameters as well. For
    example, they might show up like the cookie here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: But even if you find a CSRF protection present on the endpoint, you could try
    a variety of protection-bypass techniques. I’ll talk about them later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Confirm the Vulnerability'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After you’ve found a potentially vulnerable endpoint, you’ll need to confirm
    the vulnerability. You can do this by crafting a malicious HTML form that imitates
    the request sent by the legitimate site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Craft an HTML page like this in your text editor. Make sure to save it with
    an *.html* extension! This way, your computer will open the file with a browser
    by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `<form>` tag specifies that you’re defining an HTML form. An HTML form’s
    `method` attribute specifies the HTML method of the request generated by the form,
    and the `action` attribute specifies where the request will be sent to 1. The
    form generates a POST request to the endpoint *https://email.example.com/password_change*.
    Next are two input tags. The first one defines a POST parameter with the name
    `new_password` and the value `abc123` 2. The second one specifies a `Submit` button
    3. Finally, the `<script>` tag at the bottom of the page contains JavaScript code
    that submits the form automatically 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the HTML page in the browser that is signed into your target site. This
    form will generate a request like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Check if your password on *email.example.com* has been changed to `abc123`.
    In other words, check if the target server has accepted the request generated
    by your HTML page. The goal is to prove that a foreign site can carry out state-changing
    actions on a user’s behalf.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, some websites might be missing CSRF tokens but still protect against
    CSRF attacks by checking if the referer header of the request matches a legitimate
    URL. Checking the referer header protects against CSRF, because these headers
    help servers filter out requests that have originated from foreign sites. Confirming
    a CSRF vulnerability like this can help you rule out endpoints that have referer-based
    CSRF protection.
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s important for developers to remember that referer headers can
    be manipulated by attackers and aren’t a foolproof mitigation solution. Developers
    should implement a combination of CSRF tokens and `SameSite` session cookies for
    the best protection.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing CSRF Protection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modern websites are becoming more secure. These days, when you examine requests
    that deal with sensitive actions, they’ll often have some form of CSRF protection.
    However, the existence of protections doesn’t mean that the protection is comprehensive,
    well implemented, and impossible to bypass. If the protection is incomplete or
    faulty, you might still be able to achieve a CSRF attack with a few modifications
    to your payload. Let’s talk about techniques you can use to bypass CSRF protection
    implemented on websites.
  prefs: []
  type: TYPE_NORMAL
- en: Exploit Clickjacking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the endpoint uses CSRF tokens but the page itself is vulnerable to clickjacking,
    an attack discussed in Chapter 8, you can exploit clickjacking to achieve the
    same results as a CSRF.
  prefs: []
  type: TYPE_NORMAL
- en: This is because, in a clickjacking attack, an attacker uses an iframe to frame
    the page in a malicious site while having the state-changing request originate
    from the legitimate site. If the page where the vulnerable endpoint is located
    is vulnerable to clickjacking, you’ll be able to achieve the same results as a
    CSRF attack on the endpoint, albeit with a bit more effort and CSS skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check a page for clickjacking by using an HTML page like the following one.
    You can place a page in an iframe by specifying its URL as the `src` attribute
    of an `<iframe>` tag. Then, render the HTML page in your browser. If the page
    that the state-changing function is located in appears in your iframe, the page
    is vulnerable to clickjacking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Then you could use clickjacking to trick users into executing the state-changing
    action. Refer to Chapter 8 to learn how this attack works.
  prefs: []
  type: TYPE_NORMAL
- en: Change the Request Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another trick you can use to bypass CSRF protections is changing the request
    method. Sometimes sites will accept multiple request methods for the same endpoint,
    but protection might not be in place for each of those methods. By changing the
    request method, you might be able to get the action executed without encountering
    CSRF protection.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say the POST request of the password-change endpoint is protected
    by a CSRF token, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can try to send the same request as a GET request and see if you can get
    away with not providing a CSRF token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, your malicious HTML page could simply look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The HTML `<img>` tag loads images from external sources. It will send a GET
    request to the URL specified in its `src` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: If the password change occurs after you load this HTML page, you can confirm
    that the endpoint is vulnerable to CSRF via a GET request. On the other hand,
    if the original action normally uses a GET request, you can try converting it
    into a POST request instead.
  prefs: []
  type: TYPE_NORMAL
- en: Bypass CSRF Tokens Stored on the Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: But what if neither clickjacking nor changing the request method works? If the
    site implements CSRF protection via tokens, here are a few more things that you
    can try.
  prefs: []
  type: TYPE_NORMAL
- en: Just because a site uses CSRF tokens doesn’t mean it is validating them properly.
    If the site isn’t validating CSRF tokens in the right way, you can still achieve
    CSRF with a few modifications of your malicious HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, try deleting the token parameter or sending a blank token parameter.
    For example, this will send the request without a `csrf_token` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can generate this request with an HTML form like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This next request will send a blank `csrf_token` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can generate a payload like this by using an HTML form like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Deleting the token parameter or sending a blank token often works because of
    a common application logic mistake. Applications sometimes check the validity
    of the token only *if* the token exists, or if the token parameter is not blank.
    The code for an insecure application’s validation mechanism might look roughly
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This fragment of Python code first checks whether the CSRF token exists 1. If
    it exists, the code will proceed to validate the token. If the token is valid,
    the code will continue. If the token is invalid, the code will stop the execution
    and produce an error 2. On the other hand, if the token does not exist, the code
    will skip validation and jump to executing the action right away 3. In this case,
    sending a request without the token, or a blank value as the token, may mean the
    server won’t attempt to validate the token at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also try submitting the request with another session’s CSRF token.
    This works because some applications might check only whether the token is valid,
    without confirming that it belongs to the current user. Let’s say the victim’s
    token is `871caef0757a4ac9691aceb9aad8b65b`, and yours is `YOUR_TOKEN`. Even though
    it’s hard to get the victim’s token, you can obtain your own token easily, so
    try providing your own token in the place of the legitimate token. You can also
    create another test account to generate tokens if you don’t want to use your own
    tokens. For example, your exploit code might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The faulty application logic might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The Python code here first validates the CSRF token. If the token is in a list
    of current valid tokens 1, execution continues and the state-changing action is
    executed 2. Otherwise, an error is generated and execution halts. If this is the
    case, you can insert your own CSRF token into the malicious request!
  prefs: []
  type: TYPE_NORMAL
- en: Bypass Double-Submit CSRF Tokens
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sites also commonly use a *double-submit cookie* as a defense against CSRF.
    In this technique, the state-changing request contains the same random token as
    both a cookie and a request parameter, and the server checks whether the two values
    are equal. If the values match, the request is seen as legitimate. Otherwise,
    the application rejects it. For example, this request would be deemed valid, because
    the `csrf_token` in the user’s cookies matches the `csrf_token` in the POST request
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following one would fail. Notice that the `csrf_token` in the user’s
    cookies is different from the `csrf_token` in the POST request parameter. In a
    double-submit token validation system, it does not matter whether the tokens themselves
    are valid. The server checks only whether the token in the cookies is the same
    as the token in the request parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If the application uses double-submit cookies as its CSRF defense mechanism,
    it’s probably not keeping records of the valid token server-side. If the server
    were keeping records of the CSRF token server-side, it could simply validate the
    token when it was sent over, and the application would not need to use double-submit
    cookies in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server has no way of knowing if any token it receives is actually legitimate;
    it’s merely checking that the token in the cookie and the token in the request
    body is the same. In other words, this request, which enters the same bogus value
    as both the cookie and request parameter, would also be seen as legitimate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Generally, you shouldn’t have the power to change another user’s cookies. But
    if you can find a way to make the victim’s browser send along a fake cookie, you’ll
    be able to execute the CSRF.
  prefs: []
  type: TYPE_NORMAL
- en: 'The attack would then consist of two steps: first, you’d use a session-fixation
    technique to make the victim’s browser store whatever value you choose as the
    CSRF token cookie. *Session fixation* is an attack that allows attackers to select
    the session cookies of the victim. We do not cover session fixations in this book,
    but you can read about them on Wikipedia ([https://en.wikipedia.org/wiki/Session_fixation](https://en.wikipedia.org/wiki/Session_fixation)).
    Then, you’d execute the CSRF with the same CSRF token that you chose as the cookie.'
  prefs: []
  type: TYPE_NORMAL
- en: Bypass CSRF Referer Header Check
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What if your target site isn’t using CSRF tokens but checking the referer header
    instead? The server might verify that the referer header sent with the state-changing
    request is a part of the website’s allowlisted domains. If it is, the site would
    execute the request. Otherwise, it would deem the request to be fake and reject
    it. What can you do to bypass this type of protection?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you can try to remove the referer header. Like sending a blank token,
    sometimes all you need to do to bypass a referer check is to not send a referer
    at all. To remove the referer header, add a `<meta>` tag to the page hosting your
    request form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This particular `<meta>` tag tells the browser to not include a referer header
    in the resulting HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The faulty application logic might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Since the application validates the referer header only if it exists, you’ve
    successfully bypassed the website’s CSRF protection just by making the victim’s
    browser omit the referer header!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also try to bypass the logic check used to validate the referer URL.
    Let’s say the application looks for the string `"example.com"` in the referer
    URL, and if the referer URL contains that string, the application treats the request
    as legitimate. Otherwise, it rejects the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, you can bypass the referer check by placing the victim domain
    name in the referer URL as a subdomain. You can achieve this by creating a subdomain
    named after the victim’s domain, and then hosting the malicious HTML on that subdomain.
    Your request would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also try placing the victim domain name in the referer URL as a pathname.
    You can do so by creating a file with the name of the target’s domain and hosting
    your HTML page there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve uploaded your HTML page at the correct location, load that page
    and see if the state-changing action was executed.
  prefs: []
  type: TYPE_NORMAL
- en: Bypass CSRF Protection by Using XSS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition, as I mentioned in Chapter 6, any XSS vulnerability will defeat
    CSRF protections, because XSS will allow attackers to steal the legitimate CSRF
    token and then craft forged requests by using `XMLHttpRequest`. Often, attackers
    will find XSS as the starting point to launch CSRFs to take over admin accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Escalating the Attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After you’ve found a CSRF vulnerability, don’t just report it right away! Here
    are a few ways you can escalate CSRFs into severe security issues to maximize
    the impact of your report. Often, you need to use a combination of CSRF and other
    minor design flaws to discover these.
  prefs: []
  type: TYPE_NORMAL
- en: Leak User Information by Using CSRF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CSRF can sometimes cause information leaks as a side effect. Applications often
    send or disclose information according to user preferences. If you can change
    these settings via CSRF, you can pave the way for sensitive information disclosures.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say the *example.com* web application sends monthly billing
    emails to a user-designated email address. These emails contain the users’ billing
    information, including street addresses, phone numbers, and credit card information.
    The email address to which these billing emails are sent can be changed via the
    following request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the CSRF validation on this endpoint is broken, and the server
    accepts a blank token. The request would succeed even if the `csrf_token` field
    is left empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'An attacker could make a victim user send this request via CSRF to change the
    destination of their billing emails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: All future billing emails would then be sent to the attacker’s email address
    until the victim notices the unauthorized change. Once the billing email is sent
    to the attacker’s email address, the attacker can collect sensitive information,
    such as street addresses, phone numbers, and credit card information associated
    with the account.
  prefs: []
  type: TYPE_NORMAL
- en: Create Stored Self-XSS by Using CSRF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember from Chapter 6 that self-XSS is a kind of XSS attack that requires
    the victim to input the XSS payload. These vulnerabilities are almost always considered
    a nonissue because they’re too difficult to exploit; doing so requires a lot of
    action from the victim’s part, and thus you’re unlikely to succeed. However, when
    you combine CSRF with self-XSS, you can often turn the self-XSS into stored XSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say that *example.com*’s financial subdomain, *finance.example.com*,
    gives users the ability to create nicknames for each of their linked bank accounts.
    The account nickname field is vulnerable to self-XSS: there is no sanitization,
    validation, or escaping for user input on the field. However, only the user can
    edit and see this field, so there is no way for an attacker to trigger the XSS
    directly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the endpoint used to change the account nicknames is vulnerable to
    CSRF. The application doesn’t properly validate the existence of the CSRF token,
    so simply omitting the token parameter in the request will bypass CSRF protection.
    For example, this request would fail, because it contains the wrong token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'But this request, with no token at all, would succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This request will change the user’s account nickname and store the XSS payload
    there. The next time a user logs into the account and views their dashboard, they’ll
    trigger the XSS.
  prefs: []
  type: TYPE_NORMAL
- en: Take Over User Accounts by Using CSRF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes CSRF can even lead to account takeover. These situations aren’t uncommon,
    either; account takeover issues occur when a CSRF vulnerability exists in critical
    functionality, like the code that creates a password, changes the password, changes
    the email address, or resets the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say that in addition to signing up by using an email address
    and password, *example.com* also allows users to sign up via their social media
    accounts. If a user chooses this option, they’re not required to create a password,
    as they can simply log in via their linked account. But to give users another
    option, those who’ve signed up via social media can set a new password via the
    following request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Since the user signed up via their social media account, they don’t need to
    provide an old password to set the new password, so if CSRF protection fails on
    this endpoint, an attacker would have the ability to set a password for anyone
    who signed up via their social media account and hasn’t yet done so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say the application doesn’t validate the CSRF token properly and accepts
    an empty value. The following request will set a password for anyone who doesn’t
    already have one set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all an attacker has to do is to post a link to this HTML page on pages
    frequented by users of the site, and they can automatically assign the password
    of any user who visits the malicious page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: After that, the attacker is free to log in as any of the affected victims with
    the newly assigned password `this_account_is_now_mine`.
  prefs: []
  type: TYPE_NORMAL
- en: While the majority of CSRFs that I have encountered were low-severity issues,
    sometimes a CSRF on a critical endpoint can lead to severe consequences.
  prefs: []
  type: TYPE_NORMAL
- en: Delivering the CSRF Payload
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quite often in bug bounty reports, you’ll need to show companies that attackers
    can reliably deliver a CSRF payload. What options do attackers have to do so?
  prefs: []
  type: TYPE_NORMAL
- en: 'The first and simplest option of delivering a CSRF payload is to trick users
    into visiting an external malicious site. For example, let’s say *example.com*
    has a forum that users frequent. In this case, attackers can post a link like
    this on the forum to encourage users to visit their page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit this page to get a discount on your *example.com* subscription: *https://example.attacker.com*'
  prefs: []
  type: TYPE_NORMAL
- en: 'And on *example.attacker.com*, the attacker can host an auto-submitting form
    to execute the CSRF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'For CSRFs that you could execute via a GET request, attackers can often embed
    the request as an image directly—for example, as an image posted to a forum. This
    way, any user who views the forum page would be affected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, attackers can deliver a CSRF payload to a large audience by exploiting
    stored XSS. If the forum comment field suffers from this vulnerability, an attacker
    can submit a stored-XSS payload there to make any forum visitor execute the attacker’s
    malicious script. In the malicious script, the attacker can include code that
    sends the CSRF payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This piece of JavaScript code adds our exploit form to the user’s current page
    and then auto-submits that form.
  prefs: []
  type: TYPE_NORMAL
- en: Using these delivery methods, you can show companies how attackers can realistically
    attack many users and demonstrate the maximum impact of your CSRF vulnerability.
    If you have Burp Suite Pro, or use the ZAP proxy, you can also take advantage
    of their CSRF POC-generation functionality. For more information, search the tools’
    documentation for *CSRF POC generation*. You can also keep a POC script you wrote
    yourself and insert a target site’s URLs into the script every time you test a
    new target.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Your First CSRF!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Armed with this knowledge about CSRF bugs, bypassing CSRF protection, and escalating
    CSRF vulnerabilities, you’re now ready to look for your first CSRF vulnerability!
    Hop on a bug bounty program and find your first CSRF by following the steps covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Spot the state-changing actions on the application and keep a note on their
    locations and functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check these functionalities for CSRF protection. If you can’t spot any protections,
    you might have found a vulnerability!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If any CSRF protection mechanisms are present, try to bypass the protection
    by using the protection-bypass techniques mentioned in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm the vulnerability by crafting a malicious HTML page and visiting that
    page to see if the action has executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Think of strategies for delivering your payload to end users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draft your first CSRF report!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
