<html><head></head><body>
<h2 class="h2" id="ch01"><span epub:type="pagebreak" id="page_9"/><span class="big"><strong>1</strong></span><br/><strong>THE MISSING CODE LIBRARY</strong></h2>&#13;
<div class="imagec"><img src="../images/common4.jpg" alt="image"/></div>&#13;
<p class="noindent">One of Unix’s greatest strengths is that it lets you create new commands by combining old ones in novel ways. But even though Unix includes hundreds of commands and there are thousands of ways to combine them, you will still encounter situations where nothing does the job quite right. This chapter focuses on the stepping stones that allow you to create smarter and more sophisticated programs within the world of shell scripting.</p>&#13;
<p class="indent">There’s also something we should address up front: the shell script programming environment isn’t as sophisticated as a real programming environment. Perl, Python, Ruby, and even C have structures and libraries that offer extended capabilities, but shell scripts are more of a “roll your own” world. The scripts in this chapter will help you make your way in that world. They’re the building blocks that will help you write the wicked cool shell scripts that come later in the book.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_10"/>Much of the challenge of script writing also arises from subtle variations among different flavors of Unix and among the many different GNU/Linux distributions. While the IEEE POSIX standards supposedly provide a common base of functionality across Unix implementations, it can still be confusing to use an OS X system after a year in a Red Hat GNU/Linux environment. The commands are different, they’re in different locations, and they often have subtly different command flags. These variations can make writing shell scripts tricky, but we’ll learn a few tricks to keep these variations at bay.</p>&#13;
<h3 class="h3" id="ch01lev1sec01"><strong>What Is POSIX?</strong></h3>&#13;
<p class="noindenta">The early days of Unix were the Wild West, with companies innovating and taking the operating system in different directions while simultaneously assuring customers that all these new versions were compatible with each other and just like every other Unix. The Institute for Electrical and Electronic Engineers (IEEE) stepped in and, with tremendous effort from all the major Unix vendors, created a standard definition for Unix called the Portable Operating System Interface, or <em>POSIX</em> for short, against which all commercial and open source Unix implementations are measured. You can’t buy a POSIX operating system per se, but the Unix or GNU/Linux you run is generally POSIX compliant (though there’s some debate about whether we even need a POSIX standard at all, when GNU/Linux has become a de facto standard of its own).</p>&#13;
<p class="indent">At the same time, even POSIX-compliant Unix implementations can vary. One example addressed later in this chapter involves the <code>echo</code> command. Some versions of this command support an <code>-n</code> flag, which disables the trailing newline that’s a standard part of the command execution. Other versions of <code>echo</code> support the <code>\c</code> escape sequence as a special “don’t include a newline” notation, while still others have no way to avoid the newline at the end of the output. To make things even more interesting, some Unix systems have a command shell with a built-in <code>echo</code> function that ignores the <code>-n</code> and <code>\c</code> flags, as well as a stand-alone binary <code>/bin/echo</code> that understands these flags. This makes it tough to prompt for input in a shell script, because scripts should work identically on as many Unix systems as possible. So for functional scripts, it’s critical to normalize the <code>echo</code> command to work the same way across systems. Later in this chapter, in <a href="ch01.xhtml#ch01lev1sec09">Script #8</a> on <a href="ch01.xhtml#page_33">page 33</a>, we’ll see how to wrap <code>echo</code> inside a shell script to create just such a normalized version of the command.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>Some of the scripts in this book take advantage of bash-style features that may not be supported by all POSIX-compatible shells.</em></p>&#13;
</div>&#13;
<p class="indent">But enough backstory—let’s start looking at scripts to include in our shell script library!</p>&#13;
<h3 class="h3" id="ch01lev1sec02"><span epub:type="pagebreak" id="page_11"/><strong>#1 Finding Programs in the PATH</strong></h3>&#13;
<p class="noindenta">Shell scripts that use environment variables (like <code>MAILER</code> and <code>PAGER</code>) have a hidden danger: some of their settings may point to nonexistent programs. In case you haven’t bumped into these environment variables before, <code>MAILER</code> should be set to the email program you prefer (like <code>/usr/bin/mailx</code>), and <code>PAGER</code> should be set to the program that you use to view long documents one screenful (page) at a time. For example, if you decide to be flexible by using the <code>PAGER</code> setting to display script output instead of using the system’s default paging program (common values would be the <code>more</code> or <code>less</code> programs), how do you ensure that the <code>PAGER</code> environment value is set to a valid program?</p>&#13;
<p class="indent">This first script addresses how to test whether a given program can be found in the user’s <code>PATH</code>. It’s also a good demonstration of a number of different shell-scripting techniques, including script functions and variable slicing. <a href="ch01.xhtml#ch1ex1">Listing 1-1</a> shows how you can verify that paths are valid.</p>&#13;
<h4 class="h4" id="ch01lev2sec01"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # inpath--Verifies that a specified program is either valid as is&#13;
   #   or can be found in the PATH directory list&#13;
&#13;
   in_path()&#13;
   {&#13;
     # Given a command and the PATH, tries to find the command. Returns 0 if&#13;
     #   found and executable; 1 if not. Note that this temporarily modifies&#13;
     #   the IFS (internal field separator) but restores it upon completion.&#13;
&#13;
     cmd=$1        ourpath=$2         result=1&#13;
     oldIFS=$IFS   IFS=":"&#13;
&#13;
     for directory in "$ourpath"&#13;
     do&#13;
       if [ -x $directory/$cmd ] ; then&#13;
         result=0      # If we're here, we found the command.&#13;
       fi&#13;
     done&#13;
&#13;
     IFS=$oldIFS&#13;
     return $result&#13;
   }&#13;
&#13;
   checkForCmdInPath()&#13;
   {&#13;
     var=$1&#13;
&#13;
     if [ "$var" != "" ] ; then&#13;
<span class="ent">➊</span>     if [ "${var:0:1}" = "/" ] ; then&#13;
<span class="ent">➋</span>       if [ !  -x $var ] ; then&#13;
           return 1&#13;
         fi&#13;
<span class="ent">➌</span>     elif !  in_path $var "$PATH" ; then&#13;
         return 2&#13;
       fi&#13;
     fi&#13;
   }</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_12"/><a id="ch1ex1"/><em>Listing 1-1: The</em> <code><em>inpath</em></code> <em>shell script functions</em></p>&#13;
<p class="indent">As stated in <a href="ch00.xhtml#ch00">Chapter 0</a>, we recommend that you create a new directory called <em>scripts</em> in your home directory, and then add that fully qualified directory name to your <code>PATH</code> variable. Use <code>echo $PATH</code> to see your current <code>PATH</code> and edit the contents of your login script (<em>.login</em>, <em>.profile</em>, <em>.bashrc</em>, or <em>.bash_profile</em>, depending on the shell) to modify your <code>PATH</code> appropriately. See “<a href="ch00.xhtml#ch00lev1sec03">Configuring Your Login Script</a>” on <a href="ch00.xhtml#page_4">page 4</a> for more details.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>If you are listing files in the terminal with the</em> <code><em>ls</em></code> <em>command, some special files, like</em> .bashrc <em>or</em> .bash_profile<em>, may not show up at first. This is because files that start with a period, as</em> .bashrc <em>does, are considered “hidden” by the filesystem. (This turned out to be a bit of a bug-turned-feature very early on in Unix.) To list all the files in a directory, including the hidden ones, use the</em> <code><em>-a</em></code> <em>argument with</em> <code><em>ls</em></code>.</p>&#13;
</div>&#13;
<p class="indent">Definitely worth mentioning again is the assumption that you’re running bash as your shell for all these scripts. Note that this script explicitly sets the first line (called the <em>shebang</em>) to call <code>/bin/bash</code>. Many systems also support a <code>/usr/bin/env bash</code> shebang setting as the runtime for the script.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><strong>A NOTE ON COMMENTS</strong></p>&#13;
<p class="noindent">We wrestled with whether to include a detailed explanation of how each script works. In some cases, we’ll provide an explanation of a tricky coding segment after the code, but in general we’ll use code comments to explain, in context, what’s happening. Look for lines that begin with the <code>#</code> symbol or, sometimes, anything that appears after the <code>#</code> on a line of code.</p>&#13;
<p class="indent">Since you’ll doubtless find yourself reading other people’s scripts (other than ours, of course!), it’s useful to practice figuring out what the heck is going on in a script by reading the comments. Commenting is also an excellent habit to get into when writing scripts of your own, to help you define what you seek to accomplish in specific blocks of code.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch01lev2sec02"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The key to getting <code>checkForCmdInPath</code> to work is for it to be able to differentiate between variables that contain just the program name (like <code>echo</code>) and variables that contain a full directory path plus the filename (like <code>/bin/echo</code>). It <span epub:type="pagebreak" id="page_13"/>does this by examining the first character of the given value to see whether it’s a <code>/</code>; hence, we have the need to isolate the first character from the rest of the variable value.</p>&#13;
<p class="indent">Note that the variable-slicing syntax <code>${var:0:1}</code> at <span class="ent">➊</span> is a shorthand notation that lets you specify substrings in a string, starting from an offset and continuing up to the given length (returning the entire rest of the string if no length is provided). The expression <code>${var:10}</code>, for example, will return the remaining value of <code>$var</code> starting from the 10th character, while <code>${var:10:5}</code> constrains the substring to just the characters between positions 10 and 15, inclusive. You can see what we mean here:</p>&#13;
<pre class="programs">$ <span class="codestrong">var="something wicked this way comes..."</span>&#13;
$ <span class="codestrong">echo ${var:10}</span>&#13;
wicked this way comes...&#13;
$ <span class="codestrong">echo ${var:10:6}</span>&#13;
wicked&#13;
$</pre>&#13;
<p class="indent">In <a href="ch01.xhtml#ch1ex1">Listing 1-1</a>, the syntax is just used to see whether the specified path has a leading slash. Once we have determined whether the path passed to the script starts with a leading slash, we check if we can actually find the path on the filesystem. If the path begins with a <code>/</code>, we assume the path given is an absolute path and check whether it exists using the <code>-x</code> bash operator <span class="ent">➋</span>. Otherwise, we pass the value to our <code>inpath</code> function <span class="ent">➌</span> to see whether the value can be found in any of the directories set in our default <code>PATH</code>.</p>&#13;
<h4 class="h4" id="ch01lev2sec03"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">To run this script as a stand-alone program, we first need to append a short block of commands to the very end of the file. These commands will do the basic work of actually getting user input and passing it to the function we wrote, as shown here.</p>&#13;
<pre class="programs">if [ $# -ne 1 ] ; then&#13;
  echo "Usage: $0 command" &gt;&amp;2&#13;
  exit 1&#13;
fi&#13;
&#13;
checkForCmdInPath "$1"&#13;
case $? in&#13;
  0 ) echo "$1 found in PATH"                   ;;&#13;
  1 ) echo "$1 not found or not executable"     ;;&#13;
  2 ) echo "$1 not found in PATH"               ;;&#13;
esac&#13;
&#13;
exit 0</pre>&#13;
<p class="indent">Once you’ve added the code, you can invoke the script directly, as shown next in “The Results.” Make sure to remove or comment out this additional code when you’re done with the script, however, so it can be included as a library function later without messing things up.</p>&#13;
<h4 class="h4" id="ch01lev2sec04"><span epub:type="pagebreak" id="page_14"/><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">To test the script, let’s invoke <code>inpath</code> with the names of three programs: a program that exists, a program that exists but isn’t in the <code>PATH</code>, and a program that does not exist but that has a fully qualified filename and path. <a href="ch01.xhtml#ch1ex2">Listing 1-2</a> shows an example test of the script.</p>&#13;
<pre class="programs">$ <span class="codestrong">inpath echo</span>&#13;
echo found in PATH&#13;
$ <span class="codestrong">inpath MrEcho</span>&#13;
MrEcho not found in PATH&#13;
$ <span class="codestrong">inpath /usr/bin/MrEcho</span>&#13;
/usr/bin/MrEcho not found or not executable</pre>&#13;
<p class="listcap"><a id="ch1ex2"/><em>Listing 1-2: Testing the</em> <code><em>inpath</em></code> <em>script</em></p>&#13;
<p class="indent">The last block of code we added translates the results of the <code>in_path</code> function into something more readable, so now we can easily see that each of the three cases get handled as expected.</p>&#13;
<h4 class="h4" id="ch01lev2sec05"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">If you want to be a code ninja here on the very first script, switch the expression <code>${var:0:1}</code> to its more complicated cousin: <code>${var%${var#?}}</code>. This is the POSIX variable-slicing method. The apparent gobbledygook is really two nested string slices. The inner call of <code>${var#?}</code> extracts everything but the first character of <code>var</code>, where <code>#</code> is a call to delete the first instance of a given pattern and <code>?</code> is a regular expression that matches exactly one character.</p>&#13;
<p class="indent">Next, the call <code>${var%<em>pattern</em>}</code> produces a substring with everything left over once the specified pattern is removed from <code>var</code>. In this case, the pattern being removed is the result of the inner call, so what’s left is the first character of the string.</p>&#13;
<p class="indent">If this POSIX notation is too funky for you, most shells (including bash, ksh, and zsh) support the other method of variable slicing, <code>${<em>varname</em>:<em>start</em>:<em>size</em>}</code>, which was used in the script.</p>&#13;
<p class="indent">Of course, if you don’t like either of these techniques for extracting the first character, you can also use a system call: <code>$(echo $var | cut -c1)</code>. With bash programming, there will likely be multiple ways to solve a given problem, be it extracting, transforming, or loading data from the system in different ways. It’s important to realize and understand that this “many ways to skin a cat” approach doesn’t mean one way is better than another.</p>&#13;
<p class="indent">Also, if you want to create a version of this, or any script, that can differentiate between when it’s running as a stand-alone and when it’s invoked from another script, consider adding a conditional test near the beginning, as shown here:</p>&#13;
<pre class="programs">if [ "$BASH_SOURCE" = "$0" ]</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_15"/>We’ll leave it as an exercise for you, dear reader, to write the rest of the snippet after some experimentation!</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em><a href="ch06.xhtml#ch06lev1sec03">Script #47</a> on <a href="ch06.xhtml#page_150">page 150</a> is a useful script that’s closely related to this one. It validates both the directories in the</em> <code><em>PATH</em></code> <em>and the environment variables in the user’s login environment.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch01lev1sec03"><strong>#2 Validating Input: Alphanumeric Only</strong></h3>&#13;
<p class="noindenta">Users are constantly ignoring directions and entering data that is inconsistent, is incorrectly formatted, or uses incorrect syntax. As a shell script developer, you need to identify and flag these errors before they become problems.</p>&#13;
<p class="indent">A typical situation involves filenames or database keys. Your program prompts the user for a string that’s supposed to be <em>alphanumeric</em>, consisting exclusively of uppercase characters, lowercase characters, and digits—no punctuation, no special characters, no spaces. Did they enter a valid string? That’s what the script in <a href="ch01.xhtml#ch1ex3">Listing 1-3</a> tests.</p>&#13;
<h4 class="h4" id="ch01lev2sec06"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # validAlphaNum--Ensures that input consists only of alphabetical&#13;
   #   and numeric characters&#13;
&#13;
   validAlphaNum()&#13;
   {&#13;
     # Validate arg: returns 0 if all upper+lower+digits; 1 otherwise&#13;
&#13;
     # Remove all unacceptable chars.&#13;
<span class="ent">➊</span>   validchars="$(echo $1 | sed -e 's/[^[:alnum:]]//g')"&#13;
&#13;
<span class="ent">➋</span>   if [ "$validchars" = "$1" ] ; then&#13;
       return 0&#13;
     else&#13;
       return 1&#13;
     fi&#13;
   }&#13;
&#13;
   # BEGIN MAIN SCRIPT--DELETE OR COMMENT OUT EVERYTHING BELOW THIS LINE IF&#13;
   #   YOU WANT TO INCLUDE THIS IN OTHER SCRIPTS.&#13;
   # =================&#13;
   /bin/echo -n "Enter input: "&#13;
   read input&#13;
&#13;
   # Input validation&#13;
   if ! validAlphaNum "$input" ; then&#13;
     echo "Please enter only letters and numbers." &gt;&amp;2&#13;
     exit 1&#13;
   else&#13;
     echo "Input is valid."&#13;
   fi&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_16"/><a id="ch1ex3"/><em>Listing 1-3: The</em> <code><em>validalnum</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch01lev2sec07"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The logic of this script is straightforward. First, create a new version of the entered information with a <code>sed</code>-based transform that removes all invalid characters <span class="ent">➊</span>. Then, compare the new version with the original <span class="ent">➋</span>. If the two are the same, all is well. If not, the transformation lost data that wasn’t part of the acceptable (alphabetic plus numeric) character set, and the input is invalid.</p>&#13;
<p class="indent">This works because the <code>sed</code> substitution removes any characters not in the set <code>[:alnum:]</code>, which is the POSIX regular expression shorthand for all alphanumeric characters. If the value of this transformation doesn’t match the original input entered earlier, it reveals the presence of nonalphanumeric values in the input string, thus indicating the input is invalid. The function returns a nonzero result to indicate a problem. Keep in mind, we are expecting only ASCII text.</p>&#13;
<h4 class="h4" id="ch01lev2sec08"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script is self-contained. It prompts for input and then informs you whether the input is valid. A more typical use of this function, however, would be to copy and paste it at the top of another shell script or to reference it as part of a library as shown in <a href="ch01.xhtml#ch01lev1sec13">Script #12</a> on <a href="ch01.xhtml#page_42">page 42</a>.</p>&#13;
<p class="indent"><code>validalnum</code> is also a good example of a general shell script programming technique. Write your functions and then test them before you integrate them into larger, more complex scripts. By doing so, you’ll spare yourself lots of headaches.</p>&#13;
<h4 class="h4" id="ch01lev2sec09"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">The <code>validalnum</code> shell script is simple to use, asking the user to enter a string to validate. <a href="ch01.xhtml#ch1ex4">Listing 1-4</a> shows how the script handles valid and invalid input.</p>&#13;
<pre class="programs">$ <span class="codestrong">validalnum</span>&#13;
Enter input: <span class="codestrong">valid123SAMPLE</span>&#13;
Input is valid.&#13;
$ <span class="codestrong">validalnum</span>&#13;
Enter input: <span class="codestrong">this is most assuredly NOT valid, 12345</span>&#13;
Please enter only letters and numbers.</pre>&#13;
<p class="listcap"><a id="ch1ex4"/><em>Listing 1-4: Testing the</em> <code><em>validalnum</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch01lev2sec10"><span epub:type="pagebreak" id="page_17"/><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">This “remove the good characters and see what’s left” approach is nice because it’s flexible, particularly if you remember to wrap both your input variable and matching pattern (or no pattern at all) in double quotes to avoid empty input errors. Empty patterns are a constant problem with scripting because they turn a valid conditional test into a broken statement, producing an error message. It’s beneficial to always keep in mind that a zero-character quoted phrase is different from a blank phrase. Want to require uppercase letters but also allow spaces, commas, and periods? Simply change the substitution pattern at <span class="ent">➊</span> to the code shown here:</p>&#13;
<pre class="programs">sed 's/[^[:upper:] ,.]//g'</pre>&#13;
<p class="indent">You can also use a simple test like the following for validating phone number input (allowing integer values, spaces, parentheses, and dashes but not leading spaces or multiple spaces in sequence):</p>&#13;
<pre class="programs">sed 's/[^- [:digit:]\(\)]//g'</pre>&#13;
<p class="indent">But if you want to limit input to integer values only, you must beware of a pitfall. As an example, you might be tempted to try this:</p>&#13;
<pre class="programs">sed 's/[^[:digit:]]//g'</pre>&#13;
<p class="indent">This code works for positive numbers, but what if you want to permit entry of negative numbers? If you just add the minus sign to the valid character set, <code>-3-4</code> would be valid input, though it’s clearly not a legal integer. <a href="ch01.xhtml#ch01lev1sec06">Script #5</a> on <a href="ch01.xhtml#page_23">page 23</a> addresses how to handle negative numbers.</p>&#13;
<h3 class="h3" id="ch01lev1sec04"><strong>#3 Normalizing Date Formats</strong></h3>&#13;
<p class="noindenta">One issue with shell script development is the number of inconsistent data formats; normalizing them can range from a bit tricky to quite difficult. Date formats are some of the most challenging to work with because a date can be specified in so many different ways. Even if you prompt for a specific format, like month-day-year, you’ll likely be given inconsistent input: a month number instead of a month name, an abbreviation for a month name, or even a full name in all uppercase letters. For this reason, a function that normalizes dates, though rudimentary on its own, will prove a very helpful building block for subsequent script work, especially for <a href="ch01.xhtml#ch01lev1sec08">Script #7</a> on <a href="ch01.xhtml#page_29">page 29</a>.</p>&#13;
<h4 class="h4" id="ch01lev2sec11"><em><strong>The Code</strong></em></h4>&#13;
<p class="noindenta">The script in <a href="ch01.xhtml#ch1ex5">Listing 1-5</a> normalizes date formats that meet a relatively simple set of criteria: the month must be given either as a name or as a value between 1 and 12, and the year must be given as a four-digit value. <span epub:type="pagebreak" id="page_18"/>The normalized date consists of the month’s name (as a three-letter abbreviation), followed by the day, followed by the four-digit year.</p>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # normdate--Normalizes month field in date specification to three letters,&#13;
   #   first letter capitalized. A helper function for <a href="ch01.xhtml#ch01lev1sec08">Script #7</a>, valid-date.&#13;
   #   Exits with 0 if no error.&#13;
&#13;
   monthNumToName()&#13;
   {&#13;
     # Sets the 'month' variable to the appropriate value.&#13;
     case $1 in&#13;
       1 ) month="Jan"    ;;  2 ) month="Feb"    ;;&#13;
       3 ) month="Mar"    ;;  4 ) month="Apr"    ;;&#13;
       5 ) month="May"    ;;  6 ) month="Jun"    ;;&#13;
       7 ) month="Jul"    ;;  8 ) month="Aug"    ;;&#13;
       9 ) month="Sep"    ;;  10) month="Oct"    ;;&#13;
       11) month="Nov"    ;;  12) month="Dec"    ;;&#13;
       * ) echo "$0: Unknown month value $1" &gt;&amp;2&#13;
           exit 1&#13;
     esac&#13;
     return 0&#13;
   }&#13;
&#13;
   # BEGIN MAIN SCRIPT--DELETE OR COMMENT OUT EVERYTHING BELOW THIS LINE IF&#13;
   #   YOU WANT TO INCLUDE THIS IN OTHER SCRIPTS.&#13;
   # =================&#13;
   # Input validation&#13;
   if [ $# -ne 3 ] ; then&#13;
     echo "Usage: $0 month day year" &gt;&amp;2&#13;
     echo "Formats are August 3 1962 and 8 3 1962" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
   if [ $3 -le 99 ] ; then&#13;
     echo "$0: expected 4-digit year value." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   # Is the month input format a number?&#13;
<span class="ent">➊</span> if [ -z $(echo $1|sed 's/[[:digit:]]//g') ]; then&#13;
     monthNumToName $1&#13;
   else&#13;
   # Normalize to first 3 letters, first upper- and then lowercase.&#13;
<span class="ent">➋</span>   month="$(echo $1|cut -c1|tr '[:lower:]' '[:upper:]')"&#13;
<span class="ent">➌</span>   month="$month$(echo $1|cut -c2-3 | tr '[:upper:]' '[:lower:]')"&#13;
   fi&#13;
&#13;
   echo $month $2 $3&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch1ex5"/><em>Listing 1-5: The</em> <code><em>normdate</em></code> <em>shell script</em></p>&#13;
<h4 class="h4" id="ch01lev2sec12"><span epub:type="pagebreak" id="page_19"/><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">Notice the third conditional in this script at <span class="ent">➊</span>. It strips out all the digits from the first input field and then uses the <code>-z</code> test to see whether the result is blank. If the result is blank, that means the input is only digits, so we can map it directly to a month name with <code>monthNumToName</code>, which also validates whether the number represents a valid month. Otherwise, we assume the first input is a month string, and we normalize it with a complex sequence of <code>cut</code> and <code>tr</code> pipes using two subshell calls (that is, sequences surrounded by <code>$(</code> and <code>)</code>, where the enclosed commands get invoked and substituted with their output).</p>&#13;
<p class="indent">The first subshell sequence, at <span class="ent">➋</span>, extracts just the first character of the input and makes it uppercase with <code>tr</code> (though the sequence <code>echo $1|cut -c1</code> could also be written as <code>${1%${1#?}}</code> in the POSIX manner, as seen earlier). The second sequence, at <span class="ent">➌</span>, extracts the second and third characters and forces them to be lowercase, resulting in a capitalized three-letter abbreviation for <code>month</code>. Note that this string manipulation method doesn’t check whether the input is actually a valid month, unlike when a digit for the month is passed.</p>&#13;
<h4 class="h4" id="ch01lev2sec13"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">To ensure maximum flexibility with future scripts that incorporate the <code>normdate</code> functionality, this script was designed to accept input as three fields entered on the command line, as <a href="ch01.xhtml#ch1ex6">Listing 1-6</a> shows. If you expected to use this script only interactively, you’d prompt the user for the three fields, though that would make it more difficult to invoke <code>normdate</code> from other scripts.</p>&#13;
<h4 class="h4" id="ch01lev2sec14"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">normdate 8 3 62</span>&#13;
normdate: expected 4-digit year value.&#13;
$ <span class="codestrong">normdate 8 3 1962</span>&#13;
Aug 3 1962&#13;
$ <span class="codestrong">normdate AUGUST 03 1962</span>&#13;
Aug 03 1962</pre>&#13;
<p class="listcap"><a id="ch1ex6"/><em>Listing 1-6: Testing the</em> <code><em>normdate</em></code> <em>script</em></p>&#13;
<p class="indent">Notice that this script just normalizes month representations; day formats (such as those with leading zeros) and years remain untouched.</p>&#13;
<h4 class="h4" id="ch01lev2sec15"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">Before you get too excited about the many extensions you can add to this script to make it more sophisticated, check out <a href="ch01.xhtml#ch01lev1sec08">Script #7</a> on <a href="ch01.xhtml#page_29">page 29</a>, which uses <code>normdate</code> to validate input dates.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_20"/>One modification you could make, however, would be to allow the script to accept dates in the format MM/DD/YYYY or MM-DD-YYYY by adding the following code immediately before the first conditional.</p>&#13;
<pre class="programs">if [ $# -eq 1 ] ; then # To compensate for / or - formats&#13;
  set -- $(echo $1 | sed 's/[\/\-]/ /g')&#13;
fi</pre>&#13;
<p class="indent">With this modification, you can then enter and normalize the following common formats:</p>&#13;
<pre class="programs">$ <span class="codestrong">normdate 6-10-2000</span>&#13;
Jun 10 2000&#13;
$ <span class="codestrong">normdate March-11-1911</span>&#13;
Mar 11 1911&#13;
$ <span class="codestrong">normdate 8/3/1962</span>&#13;
Aug 3 1962</pre>&#13;
<p class="indent">If you read the code carefully, you’ll realize that it would be improved with a more sophisticated approach to validating the year in a specified date, not to mention taking into account various international date formats. We leave those to you as an exercise to explore!</p>&#13;
<h3 class="h3" id="ch01lev1sec05"><strong>#4 Presenting Large Numbers Attractively</strong></h3>&#13;
<p class="noindenta">A common mistake that programmers make is to present the results of calculations to the user without formatting them first. It’s difficult for users to ascertain whether <code>43245435</code> goes into the millions without counting from right to left and mentally inserting a comma every three digits. The script in <a href="ch01.xhtml#ch1ex7">Listing 1-7</a> formats your numbers nicely.</p>&#13;
<h4 class="h4" id="ch01lev2sec16"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # nicenumber--Given a number, shows it in comma-separated form. Expects DD&#13;
   #   (decimal point delimiter) and TD (thousands delimiter) to be instantiated.&#13;
   #   Instantiates nicenum or, if a second arg is specified, the output is&#13;
   #   echoed to stdout.&#13;
&#13;
   nicenumber()&#13;
   {&#13;
     # Note that we assume that '.' is the decimal separator in the INPUT value&#13;
     #   to this script. The decimal separator in the output value is '.' unless&#13;
     #   specified by the user with the -d flag.&#13;
&#13;
<span class="ent">➊</span>   integer=$(echo $1 | cut -d. -f1)        # Left of the decimal&#13;
<span class="ent">➋</span>   decimal=$(echo $1 | cut -d. -f2)        # Right of the decimal&#13;
     # Check if number has more than the integer part.&#13;
     if [ "$decimal" != "$1" ]; then&#13;
       # There's a fractional part, so let's include it.&#13;
       result="${DD:= '.'}$decimal"&#13;
     fi&#13;
&#13;
     thousands=$integer&#13;
&#13;
<span class="ent">➌</span>   while [ $thousands -gt 999 ]; do&#13;
<span class="ent">➍</span>     remainder=$(($thousands % 1000))    # Three least significant digits&#13;
&#13;
       # We need 'remainder' to be three digits. Do we need to add zeros?&#13;
       while [ ${#remainder} -lt 3 ] ; do  # Force leading zeros&#13;
         remainder="0$remainder"&#13;
       done&#13;
&#13;
<span class="ent">➎</span>     result="${TD:=","}${remainder}${result}"    # Builds right to left&#13;
<span class="ent">➏</span>     thousands=$(($thousands / 1000))    # To left of remainder, if any&#13;
     done&#13;
&#13;
     nicenum="${thousands}${result}"&#13;
     if [ ! -z $2 ] ; then&#13;
       echo $nicenum&#13;
     fi&#13;
   }&#13;
&#13;
   DD="."  # Decimal point delimiter, to separate whole and fractional values&#13;
   TD=","  # Thousands delimiter, to separate every three digits&#13;
&#13;
   # BEGIN MAIN SCRIPT&#13;
   # =================&#13;
&#13;
<span class="ent">➐</span> while getopts "d:t:" opt; do&#13;
     case $opt in&#13;
       d ) DD="$OPTARG"   ;;&#13;
       t ) TD="$OPTARG"   ;;&#13;
     esac&#13;
   done&#13;
   shift $(($OPTIND - 1))&#13;
&#13;
   # Input validation&#13;
   if [ $# -eq 0 ] ; then&#13;
     echo "Usage: $(basename $0) [-d c] [-t c] number"&#13;
     echo "  -d specifies the decimal point delimiter"&#13;
     echo "  -t specifies the thousands delimiter"&#13;
     exit 0&#13;
   fi&#13;
&#13;
<span class="ent">➑</span> nicenumber $1 1    # Second arg forces nicenumber to 'echo' output.&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_21"/><a id="ch1ex7"/><em>Listing 1-7: The</em> <code><em>nicenumber</em></code> <em>script formats long numbers to make them more readable.</em></p>&#13;
<h4 class="h4" id="ch01lev2sec17"><span epub:type="pagebreak" id="page_22"/><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The heart of this script is the <code>while</code> loop within the <code>nicenumber()</code> function <span class="ent">➌</span>, which iteratively keeps removing the three least significant digits from the numeric value stored in the variable <code>thousands</code> <span class="ent">➍</span> and attaches these digits to the pretty version of the number that it’s building up <span class="ent">➎</span>. The loop then reduces the number stored in thousands <span class="ent">➏</span> and feeds it through the loop again if necessary. Once the <code>nicenumber()</code> function is done, the main script logic starts. First it parses any options passed to the script with <code>getopts</code> <span class="ent">➐</span> and then finally it calls the <code>nicenumber()</code> function <span class="ent">➑</span> with the last argument the user specified.</p>&#13;
<h4 class="h4" id="ch01lev2sec18"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">To run this script, simply specify a very large numeric value. The script will add a decimal point and separators as needed, using either the default values or the characters specified through flags.</p>&#13;
<p class="indent">The result can be incorporated within an output message, as demonstrated here:</p>&#13;
<pre class="programs">echo "Do you really want to pay \$$(nicenumber $price)?"</pre>&#13;
<h4 class="h4" id="ch01lev2sec19"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">The <code>nicenumber</code> shell script is easy to use but can also take some advanced options. <a href="ch01.xhtml#ch1ex8">Listing 1-8</a> demonstrates using the script to format a few numbers.</p>&#13;
<pre class="programs">$ <span class="codestrong">nicenumber 5894625</span>&#13;
5,894,625&#13;
$ <span class="codestrong">nicenumber 589462532.433</span>&#13;
589,462,532.433&#13;
$ <span class="codestrong">nicenumber -d, -t. 589462532.433</span>&#13;
589.462.532,433</pre>&#13;
<p class="listcap"><a id="ch1ex8"/><em>Listing 1-8: Testing the</em> <code><em>nicenumber</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch01lev2sec20"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">Different countries use different characters for the thousands and decimal delimiters, so we can add flexible calling flags to this script. For example, Germans and Italians would use <code>-d "."</code> and <code>-t ","</code>, the French use <code>-d ","</code> and <code>-t " "</code>, and the Swiss, who have four national languages, use <code>-d "."</code> and <code>-t "'"</code>. This is a great example of a situation in which flexible is better than hardcoded so the tool is useful to the largest possible user community.</p>&#13;
<p class="indent">On the other hand, we did hardcode the <code>"."</code> as the decimal separator for input values, so if you are anticipating fractional input values using a different delimiter, you can change the two calls to <code>cut</code> at <span class="ent">➊</span> and <span class="ent">➋</span> that currently specify a <code>"."</code> as the decimal delimiter.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_23"/>The following code shows one solution:</p>&#13;
<pre class="programs">integer=$(echo $1 | cut "-d$DD" -f1)         # Left of the decimal&#13;
decimal=$(echo $1 | cut "-d$DD" -f2)         # Right of the decimal</pre>&#13;
<p class="indent">This code works, unless the decimal separator character in the input is different from the separator specified for the output, in which case the script breaks silently. A more sophisticated solution would include a test just before these two lines to ensure that the input decimal separator is the same as the one requested by the user. We could implement this test by using the same trick shown in <a href="ch01.xhtml#ch01lev1sec03">Script #2</a> on <a href="ch01.xhtml#page_15">page 15</a>: cut out all the digits and see what’s left, as in the following code.</p>&#13;
<pre class="programs">separator="$(echo $1 | sed 's/[[:digit:]]//g')"&#13;
if [ ! -z "$separator" -a "$separator" != "$DD" ] ; then&#13;
  echo "$0: Unknown decimal separator $separator encountered." &gt;&amp;2&#13;
  exit 1&#13;
fi</pre>&#13;
<h3 class="h3" id="ch01lev1sec06"><strong>#5 Validating Integer Input</strong></h3>&#13;
<p class="noindenta">As you saw in <a href="ch01.xhtml#ch01lev1sec03">Script #2</a> on <a href="ch01.xhtml#page_15">page 15</a>, validating integer input seems like a breeze, until you want to ensure that negative values are acceptable too. The problem is that each numeric value can have only one negative sign, which must come at the very beginning of the value. The validation routine in <a href="ch01.xhtml#ch1ex9">Listing 1-9</a> makes sure that negative numbers are correctly formatted, and, more generally useful, it can check whether values are within a range specified by the user.</p>&#13;
<h4 class="h4" id="ch01lev2sec21"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # validint--Validates integer input, allowing negative integers too&#13;
&#13;
   validint()&#13;
   {&#13;
     # Validate first field and test that value against min value $2 and/or&#13;
     #   max value $3 if they are supplied. If the value isn't within range&#13;
     #   or it's not composed of just digits, fail.&#13;
&#13;
     number="$1";      min="$2";      max="$3"&#13;
&#13;
<span class="ent">➊</span>   if [ -z $number ] ; then&#13;
       echo "You didn't enter anything. Please enter a number." &gt;&amp;2&#13;
       return 1&#13;
     fi&#13;
&#13;
     # Is the first character a '-' sign?&#13;
<span class="ent">➋</span>   if [ "${number%${number#?}}" = "-" ] ; then&#13;
       testvalue="${number#?}" # Grab all but the first character to test.&#13;
     else&#13;
       testvalue="$number"&#13;
     fi&#13;
&#13;
     # Create a version of the number that has no digits for testing.&#13;
<span class="ent">➌</span>   nodigits="$(echo $testvalue | sed 's/[[:digit:]]//g')"&#13;
&#13;
     # Check for nondigit characters.&#13;
     if [ ! -z $nodigits ] ; then&#13;
       echo "Invalid number format! Only digits, no commas, spaces, etc." &gt;&amp;2&#13;
       return 1&#13;
     fi&#13;
&#13;
<span class="ent">➍</span>   if [ ! -z $min ] ; then&#13;
       # Is the input less than the minimum value?&#13;
       if [ "$number" -lt "$min" ] ; then&#13;
         echo "Your value is too small: smallest acceptable value is $min." &gt;&amp;2&#13;
         return 1&#13;
       fi&#13;
     fi&#13;
     if [ ! -z $max ] ; then&#13;
       # Is the input greater than the maximum value?&#13;
       if [ "$number" -gt "$max" ] ; then&#13;
         echo "Your value is too big: largest acceptable value is $max." &gt;&amp;2&#13;
         return 1&#13;
       fi&#13;
     fi&#13;
     return 0&#13;
   }</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_24"/><a id="ch1ex9"/><em>Listing 1-9: The</em> <code><em>validint</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch01lev2sec22"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">Validating an integer is fairly straightforward because values are either just a series of digits (0 through 9) or, possibly, a leading minus sign that can only occur once. If the <code>validint()</code> function is invoked with a minimum or maximum value, or both, it also checks against those to ensure that the entered value is within bounds.</p>&#13;
<p class="indent">The function ensures at <span class="ent">➊</span> that the user hasn’t skipped entry entirely (here’s another place where it’s critical to anticipate the possibility of an empty string with the use of quotes to ensure that we don’t generate an error message). Then at <span class="ent">➋</span>, it looks for the minus sign and, at <span class="ent">➌</span>, creates a version of the entered value with all digits removed. If that value is not zero length, there’s a problem and the test fails.</p>&#13;
<p class="indent">If the value is valid, the user-entered number is compared against the min and max values <span class="ent">➍</span>. Finally, the function returns 1 upon error or 0 upon success.</p>&#13;
<h4 class="h4" id="ch01lev2sec23"><span epub:type="pagebreak" id="page_25"/><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This entire script is a function that can be copied into other shell scripts or included as a library file. To turn this into a command, simply append the code in <a href="ch01.xhtml#ch1ex10">Listing 1-10</a> to the bottom of the script.</p>&#13;
<pre class="programs"># Input validation&#13;
if validint "$1" "$2" "$3" ; then&#13;
  echo "Input is a valid integer within your constraints."&#13;
fi</pre>&#13;
<p class="listcap"><a id="ch1ex10"/><em>Listing 1-10: Adding support to</em> <code><em>validint</em></code> <em>to run it as a command</em></p>&#13;
<h4 class="h4" id="ch01lev2sec24"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">After placing <a href="ch01.xhtml#ch1ex10">Listing 1-10</a> in your script, you should be able to use it as <a href="ch01.xhtml#ch1ex11">Listing 1-11</a> shows:</p>&#13;
<pre class="programs">$ <span class="codestrong">validint 1234.3</span>&#13;
Invalid number format! Only digits, no commas, spaces, etc.&#13;
$ <span class="codestrong">validint 103 1 100</span>&#13;
Your value is too big: largest acceptable value is 100.&#13;
$ <span class="codestrong">validint -17 0 25</span>&#13;
Your value is too small: smallest acceptable value is 0.&#13;
$ <span class="codestrong">validint -17 -20 25</span>&#13;
Input is a valid integer within your constraints.</pre>&#13;
<p class="listcap"><a id="ch1ex11"/><em>Listing 1-11: Testing the</em> <code><em>validint</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch01lev2sec25"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">Notice the test at <span class="ent">➋</span> checks whether the number’s first character is a negative sign:</p>&#13;
<pre class="programs">if [ "${number%${number#?}}" = "-" ] ; then</pre>&#13;
<p class="indent">If the first character is a negative sign, <code>testvalue</code> is assigned the numeric portion of the integer value. This non-negative value is then stripped of digits and tested further.</p>&#13;
<p class="indent">You might be tempted to use a logical AND (<code>-a</code>) to connect expressions and shrink some of the nested <code>if</code> statements. For example, it seems as though this code should work:</p>&#13;
<pre class="programs">if [ ! -z $min -a "$number" -lt "$min" ] ; then&#13;
  echo "Your value is too small: smallest acceptable value is $min." &gt;&amp;2&#13;
  exit 1&#13;
fi</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_26"/>However, it doesn’t, because even if the first condition of an AND expression proves false, you can’t guarantee that the second condition won’t be tested as well (unlike in most other programming languages). That means you’re liable to experience all sorts of bugs from invalid or unexpected comparison values if you try this. It shouldn’t be the case, but that’s shell scripting for you.</p>&#13;
<h3 class="h3" id="ch01lev1sec07"><strong>#6 Validating Floating-Point Input</strong></h3>&#13;
<p class="noindenta">Upon first glance, the process of validating a floating-point (or “real”) value within the confines and capabilities of a shell script might seem daunting, but consider that a floating-point number is only two integers separated by a decimal point. Couple that insight with the ability to reference a different script inline (<code>validint</code>), and you’ll see that a floating-point validation test can be surprisingly short. The script in <a href="ch01.xhtml#ch1ex12">Listing 1-12</a> assumes it is being run from the same directory as the <code>validint</code> script.</p>&#13;
<h4 class="h4" id="ch01lev2sec26"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # validfloat--Tests whether a number is a valid floating-point value.&#13;
   #   Note that this script cannot accept scientific (1.304e5) notation.&#13;
&#13;
   # To test whether an entered value is a valid floating-point number,&#13;
   #   we need to split the value into two parts: the integer portion&#13;
   #   and the fractional portion. We test the first part to see whether&#13;
   #   it's a valid integer, and then we test whether the second part is a&#13;
   #   valid &gt;=0 integer. So -30.5 evaluates as valid, but -30.-8 doesn't.&#13;
&#13;
   # To include another shell script as part of this one, use the "." source&#13;
   #   notation. Easy enough.&#13;
&#13;
   . validint&#13;
&#13;
   validfloat()&#13;
   {&#13;
     fvalue="$1"&#13;
&#13;
     # Check whether the input number has a decimal point.&#13;
<span class="ent">➊</span>   if [ ! -z $(echo $fvalue | sed 's/[^.]//g') ] ; then&#13;
&#13;
       # Extract the part before the decimal point.&#13;
<span class="ent">➋</span>     decimalPart="$(echo $fvalue | cut -d. -f1)"&#13;
&#13;
       # Extract the digits after the decimal point.&#13;
<span class="ent">➌</span>     fractionalPart="${fvalue#*\.}"&#13;
&#13;
       # Start by testing the decimal part, which is everything&#13;
       #   to the left of the decimal point.&#13;
&#13;
<span class="ent">➍</span>     if [ ! -z $decimalPart ] ; then&#13;
         # "!" reverses test logic, so the following is&#13;
         #   "if NOT a valid integer"&#13;
         if ! validint "$decimalPart" "" "" ; then&#13;
           return 1&#13;
         fi&#13;
       fi&#13;
&#13;
       # Now let's test the fractional value.&#13;
&#13;
       # To start, you can't have a negative sign after the decimal point&#13;
       #   like 33.-11, so let's test for the '-' sign in the decimal.&#13;
<span class="ent">➎</span>     if [ "${fractionalPart%${fractionalPart#?}}" = "-" ] ; then&#13;
         echo "Invalid floating-point number: '-' not allowed \&#13;
           after decimal point." &gt;&amp;2&#13;
         return 1&#13;
       fi&#13;
       if [ "$fractionalPart" != "" ] ; then&#13;
         # If the fractional part is NOT a valid integer...&#13;
         if ! validint "$fractionalPart" "0" "" ; then&#13;
           return 1&#13;
         fi&#13;
       fi&#13;
&#13;
   else&#13;
     # If the entire value is just "-", that's not good either.&#13;
<span class="ent">➏</span>   if [ "$fvalue" = "-" ] ; then&#13;
       echo "Invalid floating-point format." &gt;&amp;2&#13;
       return 1&#13;
     fi&#13;
&#13;
     # Finally, check that the remaining digits are actually&#13;
     #   valid as integers.&#13;
     if ! validint "$fvalue" "" "" ; then&#13;
       return 1&#13;
     fi&#13;
   fi&#13;
&#13;
     return 0&#13;
   }</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_27"/><a id="ch1ex12"/><em>Listing 1-12: The</em> <code><em>validfloat</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch01lev2sec27"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The script first checks whether the input value includes a decimal point <span class="ent">➊</span>. If it doesn’t, it’s not a floating-point number. Next, the decimal <span class="ent">➋</span> and fractional <span class="ent">➌</span> portions of the value are chopped out for analysis. Then at <span class="ent">➍</span>, the script checks whether the decimal portion (the number to the <em>left</em> of the decimal point) is a valid integer. The next sequence is more complicated, because we need to check at <span class="ent">➎</span> that there’s no extra negative sign (to avoid weirdness like 17. –30) and then, again, ensure that the fractional part (the number to the <em>right</em> of the decimal point) is a valid integer.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_28"/>The last check, at <span class="ent">➏</span>, is whether the user specified just a minus sign and a decimal point (which would be pretty peculiar, you have to admit).</p>&#13;
<p class="indent">All good? Then the script returns 0, indicating that the user input a valid float.</p>&#13;
<h4 class="h4" id="ch01lev2sec28"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">If no error message is produced when the function is called, the return code is 0, and the number specified is a valid floating-point value. You can test this script by appending the following few lines to the end of the code:</p>&#13;
<pre class="programs">if validfloat $1 ; then&#13;
  echo "$1 is a valid floating-point value."&#13;
fi&#13;
&#13;
exit 0</pre>&#13;
<p class="indent">If <code>validint</code> is generating an error, make sure that you have it in your <code>PATH</code> as a separate function accessible to the script or just copy and paste it into the script file directly.</p>&#13;
<h4 class="h4" id="ch01lev2sec29"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">The <code>validfloat</code> shell script simply takes an argument to attempt to validate. <a href="ch01.xhtml#ch1ex13">Listing 1-13</a> uses the <code>validfloat</code> script to validate a few inputs.</p>&#13;
<pre class="programs">$ <span class="codestrong">validfloat 1234.56</span>&#13;
1234.56 is a valid floating-point value.&#13;
$ <span class="codestrong">validfloat -1234.56</span>&#13;
-1234.56 is a valid floating-point value.&#13;
$ <span class="codestrong">validfloat -.75</span>&#13;
-.75 is a valid floating-point value.&#13;
$ <span class="codestrong">validfloat -11.-12</span>&#13;
Invalid floating-point number: '-' not allowed after decimal point.&#13;
$ <span class="codestrong">validfloat 1.0344e22</span>&#13;
Invalid number format! Only digits, no commas, spaces, etc.</pre>&#13;
<p class="listcap"><a id="ch1ex13"/><em>Listing 1-13: Testing the</em> <code><em>validfloat</em></code> <em>script</em></p>&#13;
<p class="indent">If you see additional output at this point, it might be because you added a few lines to test out <code>validint</code> earlier but forgot to remove them when you moved on to this script. Simply go back to <a href="ch01.xhtml#ch01lev1sec06">Script #5</a> on <a href="ch01.xhtml#page_23">page 23</a> and ensure that the last few lines that let you run the function as a stand-alone are commented out or deleted.</p>&#13;
<h4 class="h4" id="ch01lev2sec30"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">A cool additional hack would be to extend this function to allow scientific notation, as demonstrated in the last example. It wouldn’t be too difficult. You’d test for the presence of <code>'e'</code> or <code>'E'</code> and then split the result into three <span epub:type="pagebreak" id="page_29"/>segments: the decimal portion (always a single digit), the fractional portion, and the power of 10. Then you’d just need to ensure that each is a <code>validint</code>.</p>&#13;
<p class="indent">If you don’t want to require a leading zero before the decimal point, you could also modify the conditional test at <span class="ent">➏</span> in <a href="ch01.xhtml#ch1ex12">Listing 1-12</a>. Be careful with odd formats, however.</p>&#13;
<h3 class="h3" id="ch01lev1sec08"><strong>#7 Validating Date Formats</strong></h3>&#13;
<p class="noindenta">One of the most challenging validation tasks, but one that’s crucial for shell scripts that work with dates, is to ensure that a specific date is actually possible on the calendar. If we ignore leap years, this task isn’t too bad, because the calendar is consistent every year. All we need in that case is a table with the maximum number of days per month against which to compare a specified date. To take leap years into account, you have to add some additional logic to the script, and that’s where it gets a bit more complicated.</p>&#13;
<p class="indentb">One set of rules for testing whether a given year is a leap year is as follows:</p>&#13;
<p class="bull">• Years not divisible by 4 are <em>not</em> leap years.</p>&#13;
<p class="bull">• Years divisible by 4 and by 400 <em>are</em> leap years.</p>&#13;
<p class="bull">• Years divisible by 4, not divisible by 400, but divisible by 100 are <em>not</em> leap years.</p>&#13;
<p class="bull">• All other years divisible by 4 <em>are</em> leap years.</p>&#13;
<p class="indentt">As you read through the source code in <a href="ch01.xhtml#ch1ex14">Listing 1-14</a>, notice how this script utilizes <code>normdate</code> to ensure a consistent date format before proceeding.</p>&#13;
<h4 class="h4" id="ch01lev2sec31"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # valid-date--Validates a date, taking into account leap year rules&#13;
&#13;
   normdate="<span class="codeitalic">whatever you called the normdate.sh script</span>"&#13;
&#13;
   exceedsDaysInMonth()&#13;
   {&#13;
     # Given a month name and day number in that month, this function will&#13;
     #   return 0 if the specified day value is less than or equal to the&#13;
     #   max days in the month; 1 otherwise.&#13;
&#13;
<span class="ent">➊</span>   case $(echo $1|tr '[:upper:]' '[:lower:]') in&#13;
       jan* ) days=31    ;;  feb* ) days=28    ;;&#13;
       mar* ) days=31    ;;  apr* ) days=30    ;;&#13;
       may* ) days=31    ;;  jun* ) days=30    ;;&#13;
<span epub:type="pagebreak" id="page_30"/>       jul* ) days=31    ;;  aug* ) days=31    ;;&#13;
       sep* ) days=30    ;;  oct* ) days=31    ;;&#13;
       nov* ) days=30    ;;  dec* ) days=31    ;;&#13;
          * ) echo "$0: Unknown month name $1" &gt;&amp;2&#13;
              exit 1&#13;
     esac&#13;
     if [ $2 -lt 1 -o $2 -gt $days ] ; then&#13;
       return 1&#13;
     else&#13;
       return 0   # The day number is valid.&#13;
     fi&#13;
   }&#13;
&#13;
   isLeapYear()&#13;
   {&#13;
     # This function returns 0 if the specified year is a leap year;&#13;
     #   1 otherwise.&#13;
     # The formula for checking whether a year is a leap year is:&#13;
     #   1. Years not divisible by 4 are not leap years.&#13;
     #   2. Years divisible by 4 and by 400 are leap years.&#13;
     #   3. Years divisible by 4, not divisible by 400, but divisible&#13;
     #      by 100 are not leap years.&#13;
     #   4. All other years divisible by 4 are leap years.&#13;
&#13;
     year=$1&#13;
<span class="ent">➋</span>   if [ "$((year % 4))" -ne 0 ] ; then&#13;
       return 1 # Nope, not a leap year.&#13;
     elif [ "$((year % 400))" -eq 0 ] ; then&#13;
       return 0 # Yes, it's a leap year.&#13;
     elif [ "$((year % 100))" -eq 0 ] ; then&#13;
       return 1&#13;
     else&#13;
       return 0&#13;
     fi&#13;
   }&#13;
&#13;
   # BEGIN MAIN SCRIPT&#13;
   # =================&#13;
&#13;
   if [ $# -ne 3 ] ; then&#13;
     echo "Usage: $0 month day year" &gt;&amp;2&#13;
     echo "Typical input formats are August 3 1962 and 8 3 1962" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   # Normalize date and store the return value to check for errors.&#13;
&#13;
<span class="ent">➌</span> newdate="$($normdate "$@")"&#13;
&#13;
   if [ $? -eq 1 ] ; then&#13;
     exit 1        # Error condition already reported by normdate&#13;
   fi&#13;
&#13;
   # Split the normalized date format, where&#13;
   #   first word = month, second word = day, third word = year.&#13;
   month="$(echo $newdate | cut -d\  -f1)"&#13;
   day="$(echo $newdate | cut -d\  -f2)"&#13;
   year="$(echo $newdate | cut -d\  -f3)"&#13;
&#13;
   # Now that we have a normalized date, let's check whether the&#13;
   #   day value is legal and valid (e.g., not Jan 36).&#13;
&#13;
   if ! exceedsDaysInMonth $month "$2" ; then&#13;
     if [ "$month" = "Feb" -a "$2" -eq "29" ] ; then&#13;
       if ! isLeapYear $3 ; then&#13;
<span class="ent">➍</span>       echo "$0: $3 is not a leap year, so Feb doesn't have 29 days." &gt;&amp;2&#13;
         exit 1&#13;
       fi&#13;
     else&#13;
       echo "$0: bad day value: $month doesn't have $2 days." &gt;&amp;2&#13;
       exit 1&#13;
     fi&#13;
   fi&#13;
&#13;
   echo "Valid date: $newdate"&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_31"/><a id="ch1ex14"/><em>Listing 1-14: The</em> <code><em>valid-date</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch01lev2sec32"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">This is a fun script to write because it requires a fair amount of smart conditional testing for days in month, leap years, and so on. The logic doesn’t just specify month = 1–12, day = 1–31, and so on. For the sake of organization, specific functions are used to make things easier to both write and understand.</p>&#13;
<p class="indent">To start, <code>exceedsDaysInMonth()</code> parses the user’s month specifier, being very loose in its analysis (meaning that the month name <code>JANUAR</code> would work just fine). This is done at <span class="ent">➊</span> with a <code>case</code> statement that translates its argument into lowercase and then compares values to ascertain the days in the month. This works, but it assumes that February always has 28 days.</p>&#13;
<p class="indent">To address leap years, the second function <code>isLeapYear()</code> uses some basic mathematical tests to ascertain whether the year specified had a February 29th <span class="ent">➋</span>.</p>&#13;
<p class="indent">In the main script, the input is passed to the previously presented script <code>normdate</code> to normalize the input format <span class="ent">➌</span> and then split into the three fields <code>$month</code>, <code>$day</code>, and <code>$year</code>. Then the function <code>exceedsDaysInMonth</code> is invoked to see whether the day is invalid for the specified month (such as Sept 31), with the special conditional triggered if the user specified February as the month and 29 as the day. That’s tested against the year with <code>isLeapYear</code>, and at <span class="ent">➍</span>, an error is generated as appropriate. If the user input survives all of these tests, it’s a valid date!</p>&#13;
<h4 class="h4" id="ch01lev2sec33"><span epub:type="pagebreak" id="page_32"/><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">To run the script (as <a href="ch01.xhtml#ch1ex15">Listing 1-15</a> shows), enter a date into the command line in month-day-year format. The month can be a three-letter abbreviation, a full word, or a numeric value; the year must be four digits.</p>&#13;
<h4 class="h4" id="ch01lev2sec34"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">valid-date august 3 1960</span>&#13;
Valid date: Aug 3 1960&#13;
$ <span class="codestrong">valid-date 9 31 2001</span>&#13;
valid-date: bad day value: Sep doesn't have 31 days.&#13;
$ <span class="codestrong">valid-date feb 29 2004</span>&#13;
Valid date: Feb 29 2004&#13;
$ <span class="codestrong">valid-date feb 29 2014</span>&#13;
valid-date: 2014 is not a leap year, so Feb doesn't have 29 days.</pre>&#13;
<p class="listcap"><a id="ch1ex15"/><em>Listing 1-15: Testing the</em> <code><em>valid-date</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch01lev2sec35"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">A similar approach to this script could validate time specifications, using either a 24-hour clock or an ante meridiem/post meridiem (<small>AM</small>/<small>PM</small>) suffix. Split the value at the colon, ensure that the minutes and seconds (if specified) are between 0 and 60, and then check that the first value is between 0 and 12 if allowing <small>AM</small>/<small>PM</small>, or between 0 and 24 if you prefer a 24-hour clock. Fortunately, while there are leap seconds and other tiny variations in time to help keep the calendar balanced, we can safely ignore them on a day-to-day basis, so there’s no need to fret over implementing such hairy time calculations.</p>&#13;
<p class="indent">A very different way to test for leap years is a possibility if you have access to GNU <code>date</code> on your Unix or GNU/Linux implementation. Test by specifying this command and seeing what result you get:</p>&#13;
<pre class="programs">$ <span class="codestrong">date -d 12/31/1996 +%j</span></pre>&#13;
<p class="indent">If you have the newer, better version of <code>date</code>, you’ll see <code>366</code>. In the older version, well, it’ll just complain about the input format. Now think about that result from the newer <code>date</code> command and see if you can figure out a two-line function that tests whether a given year is a leap year!</p>&#13;
<p class="indent">Finally, this script is quite permissive about month names; <code>febmama</code> works just fine since the <code>case</code> statement at <span class="ent">➊</span> checks only the first three letters of the specified word. This can be cleaned up and improved if you’d prefer by either testing for common abbreviations (like <code>feb</code>) along with the fully spelled out month name (<code>february</code>) and perhaps even common misspellings (<code>febuary</code>). All are easily done if you’re so motivated!</p>&#13;
<h3 class="h3" id="ch01lev1sec09"><span epub:type="pagebreak" id="page_33"/><strong>#8 Sidestepping Poor echo Implementations</strong></h3>&#13;
<p class="noindenta">As mentioned in ““<a href="ch01.xhtml#ch01lev1sec01">What Is POSIX?</a>” on <a href="ch01.xhtml#page_10">page 10</a>, while most modern Unix and GNU/Linux implementations have a version of the <code>echo</code> command that knows the <code>-n</code> flag should suppress trailing newlines on the output, not all implementations work that way. Some use <code>\c</code> as a special embedded character to defeat this default behavior, and others simply insist on including the trailing newline regardless.</p>&#13;
<p class="indent">Figuring out whether your particular <code>echo</code> is well implemented is easy: Simply enter these commands and see what happens:</p>&#13;
<pre class="programs">$ <span class="codestrong">echo -n "The rain in Spain"; echo " falls mainly on the Plain"</span></pre>&#13;
<p class="indent">If your <code>echo</code> works with the <code>-n</code> flag, you’ll see output like this:</p>&#13;
<pre class="programs">The rain in Spain falls mainly on the Plain</pre>&#13;
<p class="indent">If it doesn’t, you’ll see output like this:</p>&#13;
<pre class="programs">-n The rain in Spain&#13;
falls mainly on the Plain</pre>&#13;
<p class="indent">Ensuring that the script output is presented to the user as desired is important and will become increasingly important as our scripts become more interactive. To that end, we’ll write an alternate version of <code>echo</code>, called <code>echon</code>, that will always suppress the trailing newline. That way we’ll have something reliable to call every time we want the <code>echo -n</code> functionality.</p>&#13;
<h4 class="h4" id="ch01lev2sec36"><em><strong>The Code</strong></em></h4>&#13;
<p class="noindenta">There are as many ways to solve this quirky <code>echo</code> problem as there are pages in this book. One of our favorites is very succinct; it simply filters its input through the <code>awk printf</code> command, as <a href="ch01.xhtml#ch1ex16">Listing 1-16</a> shows.</p>&#13;
<pre class="programs">echon()&#13;
{&#13;
  echo "$*" | awk '{ printf "%s", $0 }'&#13;
}</pre>&#13;
<p class="listcap"><a id="ch1ex16"/><em>Listing 1-16: A simple</em> <code><em>echo</em></code> <em>alternative using the</em> <code><em>awk printf</em></code> <em>command</em></p>&#13;
<p class="indent">However, you may prefer to avoid the overhead incurred when calling the <code>awk</code> command. If you have a user-level <code>printf</code> command, you can write <code>echon</code> to filter input through that instead, as in <a href="ch01.xhtml#ch1ex17">Listing 1-17</a>.</p>&#13;
<pre class="programs">echon()&#13;
{&#13;
  printf "%s" "$*"&#13;
}</pre>&#13;
<p class="listcap"><a id="ch1ex17"/><em>Listing 1-17: An</em> <code><em>echo</em></code> <em>alternative using a simple</em> <code><em>printf</em></code> <em>command</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_34"/>What if you don’t have <code>printf</code> and you don’t want to call <code>awk</code>? Then use the <code>tr</code> command to chop off any final carriage return, just like in <a href="ch01.xhtml#ch1ex18">Listing 1-18</a>.</p>&#13;
<pre class="programs">echon()&#13;
{&#13;
  echo "$*" | tr -d '\n'&#13;
}</pre>&#13;
<p class="listcap"><a id="ch1ex18"/><em>Listing 1-18: A simple</em> <code><em>echo</em></code> <em>alternative using the</em> <code><em>tr</em></code> <em>utility</em></p>&#13;
<p class="indent">This method is simple and efficient, and it should be quite portable.</p>&#13;
<h4 class="h4" id="ch01lev2sec37"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">Simply add the script file to your <code>PATH</code>, and you’ll be able to replace any <code>echo -n</code> calls with <code>echon</code> to reliably leave the user’s cursor at the end of the line after a printout.</p>&#13;
<h4 class="h4" id="ch01lev2sec38"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">The <code>echon</code> shell script works by taking an argument and printing it and then reading some user input to demonstrate the <code>echon</code> function. <a href="ch01.xhtml#ch1ex19">Listing 1-19</a> shows the test script in use.</p>&#13;
<pre class="programs">$ <span class="codestrong">echon "Enter coordinates for satellite acquisition: "</span>&#13;
Enter coordinates for satellite acquisition: <span class="codestrong">12,34</span></pre>&#13;
<p class="listcap"><a id="ch1ex19"/><em>Listing 1-19: Testing the</em> <code><em>echon</em></code> <em>command</em></p>&#13;
<h4 class="h4" id="ch01lev2sec39"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">We won’t lie. The fact that some shells have an <code>echo</code> statement that knows the <code>-n</code> flag and others expect <code>\c</code> as the closing sequence, while others just don’t seem to have the ability to avoid adding the carriage return, is a huge pain for scripters. To address this inconsistency, you could create a function to automatically test the output of <code>echo</code> to determine which scenario was in force and then modify its invocation appropriately. For example, you might write something like <code>echo -n hi | wc -c</code> and then test whether the result was two characters (<code>hi</code>), three characters (<code>hi</code> plus a carriage return), four characters (<code>-n hi</code>), or five characters (<code>-n hi</code> plus a carriage return).</p>&#13;
<h3 class="h3" id="ch01lev1sec10"><strong>#9 An Arbitrary-Precision Floating-Point Calculator</strong></h3>&#13;
<p class="noindenta">One of the most commonly used sequences in script writing is <code>$(( ))</code>, which lets you perform calculations using various rudimentary mathematical functions. This sequence can be quite useful, facilitating common operations like incrementing counter variables. It supports addition, subtraction, <span epub:type="pagebreak" id="page_35"/>division, remainder (or modulo), and multiplication operations, though not with fractions or decimal values. Thus, the following command returns 0, not 0.5:</p>&#13;
<pre class="programs">echo $(( 1 / 2 ))</pre>&#13;
<p class="indent">So when calculating values that need better precision, you’ve got a challenge on your hands. There just aren’t many good calculator programs that work on the command line. The one exception is <code>bc</code>, an oddball program that few Unix people are taught. Billing itself as an arbitrary-precision calculator, the <code>bc</code> program harks back to the dawn of Unix, complete with cryptic error messages, exactly zero prompts, and the assumption that if you’re using it, you already know what you’re doing. But that’s okay. We can write a wrapper to make <code>bc</code> more user-friendly, as <a href="ch01.xhtml#ch1ex20">Listing 1-20</a> shows.</p>&#13;
<h4 class="h4" id="ch01lev2sec40"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # scriptbc--Wrapper for 'bc' that returns the result of a calculation&#13;
&#13;
<span class="ent">➊</span> if ["$1" = "-p" ] ; then&#13;
     precision=$2&#13;
     shift 2&#13;
   else&#13;
<span class="ent">➋</span>   precision=2           # Default&#13;
   fi&#13;
&#13;
<span class="ent">➌</span> bc -q -l &lt;&lt; EOF&#13;
     scale=$precision&#13;
     $*&#13;
     quit&#13;
   EOF&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch1ex20"/><em>Listing 1-20: The</em> <code><em>scriptbc</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch01lev2sec41"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The <code>&lt;&lt;</code> notation at <span class="ent">➌</span> allows you to include content from the script and treat it as if it were typed directly into the input stream, which in this case provides an easy mechanism for handing commands to the <code>bc</code> program. This is referred to as writing a <em>here document</em>. In this notation, whatever you put after the <code>&lt;&lt;</code> sequence is what it’ll then seek to match (on a line by itself) to denote the end of that input stream. In <a href="ch01.xhtml#ch1ex20">Listing 1-20</a>, it’s <code>EOF</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_36"/>This script also demonstrates how you can use arguments to make commands more flexible. Here, if the script is invoked with a <code>-p</code> flag <span class="ent">➊</span>, it allows you to specify the desired precision of the output number. If no precision is specified, the program defaults to <code>scale=2</code> <span class="ent">➋</span>.</p>&#13;
<p class="indent">When working with <code>bc</code>, it’s critical to understand the difference between <code>length</code> and <code>scale</code>. As far as <code>bc</code> is concerned, <code>length</code> refers to the total number of digits in the number, while <code>scale</code> is the total number of digits after the decimal point. Thus, 10.25 has a <code>length</code> of 4 and a <code>scale</code> of 2, while 3.14159 has a <code>length</code> of 6 and a <code>scale</code> of 5.</p>&#13;
<p class="indent">By default, <code>bc</code> has a variable value for <code>length</code>, but because it has a <code>scale</code> of zero, <code>bc</code> without any modifications works exactly as the <code>$(( ))</code> notation does. Fortunately, if you add a <code>scale</code> setting to <code>bc</code>, you find that there’s lots of hidden power under the hood, as shown in this example, which calculates how many weeks elapsed between 1962 and 2002 (excluding leap days):</p>&#13;
<pre class="programs">$ <span class="codestrong">bc</span>&#13;
bc 1.06.95&#13;
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation,&#13;
Inc.&#13;
This is free software with ABSOLUTELY NO WARRANTY.&#13;
For details type 'warranty'.&#13;
<span class="codestrong">scale=10</span>&#13;
<span class="codestrong">(2002-1962)*365</span>&#13;
14600&#13;
<span class="codestrong">14600/7</span>&#13;
2085.7142857142&#13;
<span class="codestrong">quit</span></pre>&#13;
<p class="indent">To allow access to the <code>bc</code> capabilities from the command line, a wrapper script has to silence the opening copyright information, if present—though most <code>bc</code> implementations already silence the header if their input isn’t the terminal (<code>stdin</code>). The wrapper also sets the <code>scale</code> to a reasonable value, feeds in the actual expression to the <code>bc</code> program, and then exits with a <code>quit</code> command.</p>&#13;
<h4 class="h4" id="ch01lev2sec42"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">To run this script, feed a mathematical expression to the program as an argument as <a href="ch01.xhtml#ch1ex21">Listing 1-21</a> shows.</p>&#13;
<h4 class="h4" id="ch01lev2sec43"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">scriptbc 14600/7</span>&#13;
2085.71&#13;
$ <span class="codestrong">scriptbc -p 10 14600/7</span>&#13;
2085.7142857142</pre>&#13;
<p class="listcap"><a id="ch1ex21"/><em>Listing 1-21: Testing the</em> <code><em>scriptbc</em></code> <em>script</em></p>&#13;
<h3 class="h3" id="ch01lev1sec11"><span epub:type="pagebreak" id="page_37"/><strong>#10 Locking Files</strong></h3>&#13;
<p class="noindenta">Any script that reads or appends to a shared file, such as a log file, needs a reliable way to lock files so that other instantiations of the script don’t accidentally overwrite data before it’s done being used. A common way to accomplish this is to create a separate <em>lock file</em> for each file being used. The existence of a lock file serves as a <em>semaphore</em>, an indicator that a file is being used by a different script and is not available. The requesting script then repeatedly waits and tries again until the semaphore lock file is removed, indicating that the file is free to edit.</p>&#13;
<p class="indent">Lock files are tricky, though, because many seemingly foolproof solutions don’t actually work. For example, the following code is a typical approach to solving this problem:</p>&#13;
<pre class="programs">while [ -f $lockfile ] ; do&#13;
  sleep 1&#13;
done&#13;
touch $lockfile</pre>&#13;
<p class="indent">Seems like it would work, doesn’t it? The code loops until the lock file doesn’t exist and then creates it to ensure that you own the lock and can therefore modify the base file safely. If another script with the same loop sees your lock, it will also spin until the lock file vanishes. However, this doesn’t work in practice. Imagine what would happen if, just after the <code>while</code> loop exited but before the <code>touch</code> was executed, this script was swapped out and put back in the processor queue, giving another script a chance to run.</p>&#13;
<p class="indent">In case you’re not sure what we’re referring to, remember that although your computer seems to be doing one thing at a time, it’s actually running multiple programs at the same time by doing a tiny bit with one, switching to another one, doing a tiny bit with that, and switching back. The problem here is that in the time between when your script finishes checking for a lock file and when it creates its own, the system might swap to another script, which could dutifully test for a lock file, find it absent, and create its own version. Then that script could swap out, and your script could swap back in to resume executing the <code>touch</code> command. The result would be that both scripts now think they have exclusive access to the lock file, which is exactly what we were trying to avoid.</p>&#13;
<p class="indent">Fortunately, Stephen van den Berg and Philip Guenther, authors of the <code>procmail</code> email-filtering program, also created a command line utility, <code>lockfile</code>, that lets you safely and reliably work with lock files in shell scripts.</p>&#13;
<p class="indent">Many Unix distributions, including GNU/Linux and OS X, have <code>lockfile</code> already installed. You can check whether your system has <code>lockfile</code> simply by entering <code>man 1 lockfile</code>. If you get a man page, you’re in luck! The script in <a href="ch01.xhtml#ch1ex22">Listing 1-22</a> assumes that you have the <code>lockfile</code> command, and subsequent scripts require the reliable locking mechanism of <a href="ch01.xhtml#ch01lev1sec11">Script #10</a> to function, so make sure the <code>lockfile</code> command is installed on your system.</p>&#13;
<h4 class="h4" id="ch01lev2sec44"><span epub:type="pagebreak" id="page_38"/><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # filelock--A flexible file-locking mechanism&#13;
&#13;
   retries="10"            # Default number of retries&#13;
   action="lock"           # Default action&#13;
   nullcmd="'which true'"  # Null command for lockfile&#13;
&#13;
<span class="ent">➊</span> while getopts "lur:" opt; do&#13;
     case $opt in&#13;
       l ) action="lock"      ;;&#13;
       u ) action="unlock"    ;;&#13;
       r ) retries="$OPTARG"  ;;&#13;
     esac&#13;
   done&#13;
<span class="ent">➋</span> shift $(($OPTIND - 1))&#13;
&#13;
   if [ $# -eq 0 ] ; then # Output a multiline error message to stdout.&#13;
     cat &lt;&lt; EOF &gt;&amp;2&#13;
   Usage: $0 [-l|-u] [-r retries] LOCKFILE&#13;
   Where -l requests a lock (the default), -u requests an unlock, -r X&#13;
   specifies a max number of retries before it fails (default = $retries).&#13;
     EOF&#13;
     exit 1&#13;
   fi&#13;
&#13;
   # Ascertain if we have the lockfile command.&#13;
&#13;
<span class="ent">➌</span> if [ -z "$(which lockfile | grep -v '^no ')" ] ; then&#13;
     echo "$0 failed: 'lockfile' utility not found in PATH." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
<span class="ent">➍</span> if [ "$action" = "lock" ] ; then&#13;
     if ! lockfile -1 -r $retries "$1" 2&gt; /dev/null; then&#13;
       echo "$0: Failed: Couldn't create lockfile in time." &gt;&amp;2&#13;
       exit 1&#13;
     fi&#13;
   else    # Action = unlock.&#13;
     if [ ! -f "$1" ] ; then&#13;
       echo "$0: Warning: lockfile $1 doesn't exist to unlock." &gt;&amp;2&#13;
       exit 1&#13;
     fi&#13;
     rm -f "$1"&#13;
   fi&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch1ex22"/><em>Listing 1-22: The</em> <code><em>filelock</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch01lev2sec45"><span epub:type="pagebreak" id="page_39"/><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">As is typical with a well-written shell script, half of <a href="ch01.xhtml#ch1ex22">Listing 1-22</a> is parsing input variables and checking for error conditions. Finally, it gets to the <code>if</code> statement, and then it tries to actually use the system <code>lockfile</code> command. If there is one, it invokes it with a specified number of retries, generating its own error message if it does not finally succeed. What if you requested an unlock (for example, removal of an existing lock) and there is none? That generates another error. Otherwise, the <code>lockfile</code> is removed and you’re done.</p>&#13;
<p class="indent">More specifically, the first block <span class="ent">➊</span> uses the powerful <code>getopts</code> function to parse all the possible user input flags (<code>-l</code>, <code>-u</code>, <code>-r</code>) with a <code>while</code> loop. This is a common way to utilize <code>getopts</code>, which will occur again and again in the book. Note the shift <code>$(($OPTIND - 1 ))</code> statement at <span class="ent">➋</span>: <code>OPTIND</code> is set by <code>getopts</code>, which lets the script keep shifting values down (so <code>$2</code> becomes <code>$1</code>, for example) until it is done processing those values with a leading dash.</p>&#13;
<p class="indent">Since this script utilizes the system <code>lockfile</code> utility, it’s good form to ensure the utility is in the user’s path before invoking it <span class="ent">➌</span>, failing with an error message if that’s not the case. Then there’s a simple conditional at <span class="ent">➍</span> to see whether we’re locking or unlocking and the appropriate invocation to the <code>lockfile</code> utility in each case.</p>&#13;
<h4 class="h4" id="ch01lev2sec46"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">While the <code>lockfile</code> script isn’t one you’d ordinarily use by itself, you can test it by having two terminal windows open. To create a lock, simply specify the name of the file you want to lock as an argument of <code>filelock</code>. To remove the lock, run the script again with the <code>-u</code> flag.</p>&#13;
<h4 class="h4" id="ch01lev2sec47"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">First, create a locked file as <a href="ch01.xhtml#ch1ex23">Listing 1-23</a> shows.</p>&#13;
<pre class="programs">$ <span class="codestrong">filelock /tmp/exclusive.lck</span>&#13;
$ <span class="codestrong">ls -l /tmp/exclusive.lck</span>&#13;
-r--r--r--  1 taylor  wheel  1 Mar 21 15:35 /tmp/exclusive.lck</pre>&#13;
<p class="listcap"><a id="ch1ex23"/><em>Listing 1-23: Creating a file lock with the</em> <code><em>filelock</em></code> <em>command</em></p>&#13;
<p class="indent">The second time you attempt to lock the file, <code>filelock</code> tries the default number of times (10) and then fails (shown in <a href="ch01.xhtml#ch1ex24">Listing 1-24</a>):</p>&#13;
<pre class="programs">$ <span class="codestrong">filelock /tmp/exclusive.lck</span>&#13;
filelock : Failed: Couldn't create lockfile in time.</pre>&#13;
<p class="listcap"><a id="ch1ex24"/><em>Listing 1-24: The</em> <code><em>filelock</em></code> <em>command failing to create a lock file</em></p>&#13;
<p class="indent">When the first process is done with the file, you can release the lock, as <a href="ch01.xhtml#ch1ex25">Listing 1-25</a> details.</p>&#13;
<pre class="programs"><span epub:type="pagebreak" id="page_40"/>$ <span class="codestrong">filelock -u /tmp/exclusive.lck</span></pre>&#13;
<p class="listcap"><a id="ch1ex25"/><em>Listing 1-25: Releasing a lock on a file with the</em> <code><em>filelock</em></code> <em>script</em></p>&#13;
<p class="indent">To see how the <code>filelock</code> script works with two terminals, run the unlock command in one window while the other is spinning, trying to establish its own exclusive lock.</p>&#13;
<h4 class="h4" id="ch01lev2sec48"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">Because this script relies on the existence of a lock file as proof that the lock is still enforced, it would be useful to have an additional parameter, say, the longest length of time for which a lock should be valid. If the <code>lockfile</code> routine times out, the last accessed time of the locked file could then be checked, and if the locked file is older than the value of this parameter, it can safely be deleted as a stray, perhaps with a warning message.</p>&#13;
<p class="indent">This is unlikely to affect you, but <code>lockfile</code> doesn’t work with network filesystem (NFS) mounted networked drives. In fact, a reliable file-locking mechanism on an NFS-mounted disk is quite complex. A better strategy that sidesteps the problem entirely is to create lock files only on local disks or to use a network-aware script that can manage locks across multiple systems.</p>&#13;
<h3 class="h3" id="ch01lev1sec12"><strong>#11 ANSI Color Sequences</strong></h3>&#13;
<p class="noindenta">Although you might not realize it, most terminal applications support different styles of presenting text. Quite a few variations are possible, whether you’d like to have certain words in your script displayed in boldface or even in red against a yellow background. However, working with <em>ANSI (American National Standards Institute)</em> sequences to represent these variations can be difficult because they’re quite user-unfriendly. To simplify them, <a href="ch01.xhtml#ch1ex26">Listing 1-26</a> creates a set of variables whose values represent the ANSI codes, which can be used to toggle various color and formatting options on and off.</p>&#13;
<h4 class="h4" id="ch01lev2sec49"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">#!/bin/bash&#13;
&#13;
# ANSI color--Use these variables to make output in different colors&#13;
#   and formats. Color names that end with 'f' are foreground colors,&#13;
#   and those ending with 'b' are background colors.&#13;
&#13;
initializeANSI()&#13;
{&#13;
  esc="\033"   # If this doesn't work, enter an ESC directly.&#13;
&#13;
  # Foreground colors&#13;
  blackf="${esc}[30m";   redf="${esc}[31m";    greenf="${esc}[32m"&#13;
  yellowf="${esc}[33m"   bluef="${esc}[34m";   purplef="${esc}[35m"&#13;
  cyanf="${esc}[36m";    whitef="${esc}[37m"&#13;
&#13;
  # Background colors&#13;
  blackb="${esc}[40m";   redb="${esc}[41m";    greenb="${esc}[42m"&#13;
  yellowb="${esc}[43m"   blueb="${esc}[44m";   purpleb="${esc}[45m"&#13;
  cyanb="${esc}[46m";    whiteb="${esc}[47m"&#13;
&#13;
  # Bold, italic, underline, and inverse style toggles&#13;
  boldon="${esc}[1m";    boldoff="${esc}[22m"&#13;
  italicson="${esc}[3m"; italicsoff="${esc}[23m"&#13;
  ulon="${esc}[4m";      uloff="${esc}[24m"&#13;
  invon="${esc}[7m";     invoff="${esc}[27m"&#13;
&#13;
  reset="${esc}[0m"&#13;
}</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_41"/><a id="ch1ex26"/><em>Listing 1-26: The</em> <code><em>initializeANSI</em></code> <em>script function</em></p>&#13;
<h4 class="h4" id="ch01lev2sec50"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">If you’re used to HTML, you might be baffled by the way these sequences work. In HTML, you open and close modifiers in opposite order, and you must close every modifier you open. Thus, to create an italicized passage within a sentence displayed in bold, you’d use the following HTML:</p>&#13;
<pre class="programs">&lt;b&gt;this is in bold and &lt;i&gt;this is italics&lt;/i&gt; within the bold&lt;/b&gt;</pre>&#13;
<p class="indent">Closing the bold tag without closing the italics wreaks havoc and can mess up some web browsers. But with the ANSI color sequences, some modifiers actually override the previous ones, and there is also a reset sequence that closes all modifiers. With ANSI sequences, you must make sure to output the reset sequence after using colors and to use the <code>off</code> feature for anything you turn <code>on</code>. Using the variable definitions in this script, you would rewrite the previous sequence like this:</p>&#13;
<pre class="programs">${boldon}this is in bold and ${italicson}this is&#13;
italics${italicsoff}within the bold${reset}</pre>&#13;
<h4 class="h4" id="ch01lev2sec51"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">To run this script, first call the initialization function and then output a few <code>echo</code> statements with different combinations of color and type effect:</p>&#13;
<pre class="programs">initializeANSI&#13;
&#13;
cat &lt;&lt; EOF&#13;
${yellowf}This is a phrase in yellow${redb} and red${reset}&#13;
${boldon}This is bold${ulon} this is italics${reset} bye-bye&#13;
${italicson}This is italics${italicsoff} and this is not&#13;
${ulon}This is ul${uloff} and this is not&#13;
${invon}This is inv${invoff} and this is not&#13;
${yellowf}${redb}Warning I ${yellowb}${redf}Warning II${reset}&#13;
EOF</pre>&#13;
<h4 class="h4" id="ch01lev2sec52"><span epub:type="pagebreak" id="page_42"/><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">The results in <a href="ch01.xhtml#ch1ex27">Listing 1-27</a> don’t look too thrilling in this book, but on a display that supports these color sequences, they definitely catch your attention.</p>&#13;
<pre class="programs">This is a phrase in <span class="mark">yellow and red</span>&#13;
This is bold this is italics bye-bye&#13;
This is italics and this is not&#13;
This is ul and this is not&#13;
This is inv and this is not&#13;
<span class="mark">Warning I</span> <span class="mark1">Warning II</span></pre>&#13;
<p class="listcap"><a id="ch1ex27"/><em>Listing 1-27: The text that would be printed if the script in <a href="ch01.xhtml#ch1ex26">Listing 1-26</a> were run</em></p>&#13;
<h4 class="h4" id="ch01lev2sec53"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">When using this script, you may see output like the following:</p>&#13;
<pre class="programs">\033[33m\033[41mWarning!\033[43m\033[31mWarning!\033[0m</pre>&#13;
<p class="indent">If you do, the problem might be that your terminal or window doesn’t support ANSI color sequences or that it doesn’t understand the <code>\033</code> notation for the all-important <code>esc</code> variable. To remedy the latter problem, open up the script in <code>vi</code> or your favorite terminal editor, delete the <code>\033</code> sequence, and replace it by entering a <code>^V</code> (<small>CTRL</small>-V) keystroke followed by an <small>ESC</small> key press, which should show up as <code>^[</code>. If the results on screen look like <code>esc="^["</code>, all should work fine.</p>&#13;
<p class="indent">If, on the other hand, your terminal or window doesn’t support ANSI sequences at all, you might want to upgrade so that you can add colorized and typeface-enhanced output to your other scripts. But before you ditch your current terminal, check your terminal’s preferences—some have a setting you can enable for full ANSI support.</p>&#13;
<h3 class="h3" id="ch01lev1sec13"><strong>#12 Building a Shell Script Library</strong></h3>&#13;
<p class="noindenta">Many of the scripts in this chapter have been written as functions rather than as stand-alone scripts so that they can be easily incorporated into other scripts without incurring the overhead of making system calls. While there’s no <code>#include</code> feature in a shell script as there is in C, there is a tremendously important capability called <em>sourcing</em> a file that serves the same purpose, allowing you to include other scripts as though they are library functions.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_43"/>To see why this is important, let’s consider the alternative. If you invoke a shell script within a shell, by default that script is run within its own subshell. You can see this experimentally here:</p>&#13;
<pre class="programs">$ <span class="codestrong">echo "test=2" &gt;&gt; tinyscript.sh</span>&#13;
$ <span class="codestrong">chmod +x tinyscript.sh</span>&#13;
$ <span class="codestrong">test=1</span>&#13;
$ <span class="codestrong">./tinyscript.sh</span>&#13;
$ <span class="codestrong">echo $test</span>&#13;
1</pre>&#13;
<p class="indent">The script <em>tinyscript.sh</em> changed the value of the variable <code>test</code>, but only within the subshell running the script, so the value of the existing <code>test</code> variable in our shell’s environment was not affected. If instead you run the script using the dot (<code>.</code>) notation to source the script, then it is handled as though each command in the script were typed directly into the current shell:</p>&#13;
<pre class="programs">$ <span class="codestrong">. tinyscript.sh</span>&#13;
$ <span class="codestrong">echo $test</span>&#13;
2</pre>&#13;
<p class="indent">As you might expect, if you source a script that has an <code>exit 0</code> command, it will exit the shell and log out of the window, because the <code>source</code> operation makes the sourced script the primary running process. If you had a script running in a subshell, it would exit without the main script stopping. That’s a major difference and one reason to opt for sourcing scripts with <code>.</code> or <code>source</code> or (as we’ll explain later) <code>exec</code>. The <code>.</code> notation is actually identical to the <code>source</code> command in bash; we’re using <code>.</code> because it’s more portable across different POSIX shells.</p>&#13;
<h4 class="h4" id="ch01lev2sec54"><em><strong>The Code</strong></em></h4>&#13;
<p class="noindenta">To turn the functions in this chapter into a library for use in other scripts, extract all the functions and any needed global variables or arrays (that is, values that are common across multiple functions) and concatenate them into one big file. If you call this file <em>library.sh</em>, you can use the following test script to access all the functions we’ve written in this chapter and see whether they’re working properly, as <a href="ch01.xhtml#ch1ex28">Listing 1-28</a> shows.</p>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # Library test script&#13;
&#13;
   # Start by sourcing (reading in) the library.sh file.&#13;
&#13;
<span class="ent">➊</span> . library.sh&#13;
&#13;
   initializeANSI  # Let's set up all those ANSI escape sequences.&#13;
   # Test validint functionality.&#13;
   echon "First off, do you have echo in your path? (1=yes, 2=no) "&#13;
   read answer&#13;
   while ! validint $answer 1 2 ; do&#13;
     echon "${boldon}Try again${boldoff}. Do you have echo "&#13;
     echon "in your path? (1=yes, 2=no) "&#13;
     read answer&#13;
   done&#13;
&#13;
   # Is the command that checks what's in the path working?&#13;
   if ! checkForCmdInPath "echo" ; then&#13;
     echo "Nope, can't find the echo command."&#13;
   else&#13;
     echo "The echo command is in the PATH."&#13;
   fi&#13;
&#13;
   echo ""&#13;
   echon "Enter a year you think might be a leap year: "&#13;
   read year&#13;
&#13;
   # Test to see if the year specified is between 1 and 9999 by&#13;
   #   using validint with a min and max value.&#13;
   while ! validint $year 1 9999 ; do&#13;
     echon "Please enter a year in the ${boldon}correct${boldoff} format: "&#13;
     read year&#13;
   done&#13;
&#13;
   # Now test whether it is indeed a leap year.&#13;
   if isLeapYear $year ; then&#13;
     echo "${greenf}You're right! $year is a leap year.${reset}"&#13;
   else&#13;
     echo "${redf}Nope, that's not a leap year.${reset}"&#13;
   fi&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_44"/><a id="ch1ex28"/><em>Listing 1-28: Sourcing the previously implemented functions as a single library and calling them</em></p>&#13;
<h4 class="h4" id="ch01lev2sec55"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">Notice that the library is incorporated and all functions are read and included in the runtime environment of the script, with the single line at <span class="ent">➊</span>.</p>&#13;
<p class="indent">This useful approach for working with many scripts in this book can be exploited again and again as needed. Just make sure that the library file you’re including is accessible from your <code>PATH</code> so that the <code>.</code> command can find it.</p>&#13;
<h4 class="h4" id="ch01lev2sec56"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">To run the test script, invoke it from the command line as you would any other, just like in <a href="ch01.xhtml#ch1ex29">Listing 1-29</a>.</p>&#13;
<h4 class="h4" id="ch01lev2sec57"><span epub:type="pagebreak" id="page_45"/><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">library-test</span>&#13;
First off, do you have echo in your PATH? (1=yes, 2=no) <span class="codestrong">1</span>&#13;
The echo command is in the PATH.&#13;
&#13;
Enter a year you think might be a leap year: <span class="codestrong">432423</span>&#13;
Your value is too big: largest acceptable value is 9999.&#13;
Please enter a year in the <span class="codestrong">correct</span> format: <span class="codestrong">432</span>&#13;
You're right! 432 is a leap year.</pre>&#13;
<p class="listcap"><a id="ch1ex29"/><em>Listing 1-29: Running the</em> <code><em>library-test</em></code> <em>script</em></p>&#13;
<p class="indent">On your screen, the error messages for a value that is too large will be in bold. Also, the correct guess of a leap year will be displayed in green.</p>&#13;
<p class="indent">Historically, 432 wasn’t a leap year because leap years didn’t start appearing in the calendar until 1752. But we’re talking about shell scripts, not calendar hacks, so we’ll let this slide.</p>&#13;
<h3 class="h3" id="ch01lev1sec14"><strong>#13 Debugging Shell Scripts</strong></h3>&#13;
<p class="noindenta">Although this section doesn’t contain a true script per se, we want to spend a few pages talking about some basics of debugging shell scripts, because it’s a sure bet that bugs are always going to creep in!</p>&#13;
<p class="indent">In our experience, the best debugging strategy is to build scripts incrementally. Some script programmers have a high degree of optimism that everything will work right the first time, but starting small can really help move things along. Additionally, you should make liberal use of <code>echo</code> statements to track variables and invoke your scripts explicitly using <code>bash -x</code> to display debugging output, like so:</p>&#13;
<pre class="programs">$ <span class="codestrong">bash -x myscript.sh</span></pre>&#13;
<p class="indent">Alternatively, you can run <code>set -x</code> beforehand to enable debugging and <code>set +x</code> afterward to stop it, as shown here:</p>&#13;
<pre class="programs">$ <span class="codestrong">set -x</span>&#13;
$ <span class="codestrong">./myscript.sh</span>&#13;
$ <span class="codestrong">set +x</span></pre>&#13;
<p class="indent">To see the <code>-x</code> and <code>+x</code> sequences in action, let’s debug a simple number-guessing game, shown in <a href="ch01.xhtml#ch1ex30">Listing 1-30</a>.</p>&#13;
<h4 class="h4" id="ch01lev2sec58"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # hilow--A simple number-guessing game&#13;
&#13;
   biggest=100                   # Maximum number possible&#13;
   guess=0                       # Guessed by player&#13;
   guesses=0                     # Number of guesses made&#13;
<span class="ent">➊</span> number=$(( $$ % $biggest )    # Random number, between 1 and $biggest&#13;
   echo "Guess a number between 1 and $biggest"&#13;
&#13;
   while [ "$guess" -ne $number ] ; do&#13;
<span class="ent">➋</span>   /bin/echo -n "Guess? " ; read answer&#13;
     if [ "$guess" -lt $number ] ; then&#13;
<span class="ent">➌</span>     echo "... bigger!"&#13;
     elif [ "$guess" -gt $number ] ; then&#13;
<span class="ent">➍</span>     echo "... smaller!&#13;
     fi&#13;
     guesses=$(( $guesses + 1 ))&#13;
   done&#13;
&#13;
   echo "Right!! Guessed $number in $guesses guesses."&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_46"/><a id="ch1ex30"/><em>Listing 1-30: The</em> <code><em>hilow</em></code> <em>script, which may contain a few errors in need of debugging ...</em></p>&#13;
<h4 class="h4" id="ch01lev2sec59"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">To understand how the random number portion at <span class="ent">➊</span> works, keep in mind that the sequence <code>$$</code> is the processor ID (PID) of the shell that runs the script, typically a 5- or 6-digit value. Each time you run the script, it gets a different PID. The <code>% $biggest</code> sequence then divides the PID value by the specified biggest acceptable value and returns the remainder. In other words, <code>5 % 4 = 1</code>, as does <code>41 % 4</code>. It’s an easy way to produce a semi-random number between 1 and <code>$biggest</code>.</p>&#13;
<h4 class="h4" id="ch01lev2sec60"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">The first step in debugging this game is to test and ensure that the number generated will be sufficiently random. To do this, we take the PID of the shell in which the script is run, using the <code>$$</code> notation, and reduce it to a usable range using the <code>%</code> mod function <span class="ent">➊</span>. To test the function, enter the commands into the shell directly, as shown here:</p>&#13;
<pre class="programs">$ <span class="codestrong">echo $(( $$ % 100 ))</span>&#13;
5&#13;
$ <span class="codestrong">echo $(( $$ % 100 ))</span>&#13;
5&#13;
$ <span class="codestrong">echo $(( $$ % 100 ))</span>&#13;
5</pre>&#13;
<p class="indent">This worked, but it’s not very random. A moment’s thought reveals why: when the command is run directly on the command line, the PID is always the same; but when run in a script, the command is in a different subshell each time, so the PID varies.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_47"/>Another way to generate a random number is by referencing the environment variable <code>$RANDOM</code>. It’s magic! Each time you reference it, you get a different value. To generate a number between 1 and <code>$biggest</code>, you’d use <code>$(( $RANDOM % $biggest + 1 ))</code> at <span class="ent">➊</span>.</p>&#13;
<p class="indent">The next step is to add the basic logic of the game. A random number between 1 and 100 is generated <span class="ent">➊</span>; the player makes guesses <span class="ent">➋</span>; and after each guess, the player is told whether the guess is too high <span class="ent">➌</span> or too low <span class="ent">➍</span>, until they finally guess the correct value. After entering all the basic code, it’s time to run the script and see how it goes. Here we use <a href="ch01.xhtml#ch1ex30">Listing 1-30</a>, warts and all:</p>&#13;
<pre class="programs">$ <span class="codestrong">hilow</span>&#13;
./013-hilow.sh: line 19: unexpected EOF while looking for matching '"'&#13;
./013-hilow.sh: line 22: syntax error: unexpected end of file</pre>&#13;
<p class="indent">Ugh, the bane of shell script developers: an unexpected end of file (EOF). Just because the message says the error is on line 19 doesn’t mean it’s actually there. In fact, line 19 is perfectly fine:</p>&#13;
<pre class="programs">$ <span class="codestrong">sed -n 19p hilow</span>&#13;
echo "Right!! Guessed $number in $guesses guesses."</pre>&#13;
<p class="indent">To understand what’s going on, remember that quoted passages can contain newlines. This means that when the shell hits a quoted passage that we haven’t closed properly, it will just keep reading down the script looking for matching quotes, only stopping when it hits the very last quote and realizes something is amiss.</p>&#13;
<p class="indent">The problem, therefore, must come earlier in the script. The only really useful thing about the error message from the shell is that it tells you which character is mismatched, so we can <code>grep</code> to try to extract all lines that have a quote and then filter out the ones that have two quotes, as shown here:</p>&#13;
<pre class="programs">$ <span class="codestrong">grep '"' 013-hilow.sh | egrep -v '.*".*".*'</span>&#13;
echo "... smaller!</pre>&#13;
<p class="indent">That’s it! The closing quote is missing on the line that tells the user they must guess a smaller number <span class="ent">➍</span>. We’ll add the missing quote at the end of the line and try again:</p>&#13;
<pre class="programs">$ <span class="codestrong">hilow</span>&#13;
./013-hilow.sh: line 7: unexpected EOF while looking for matching ')'&#13;
./013-hilow.sh: line 22: syntax error: unexpected end of file</pre>&#13;
<p class="indent">Nope. Another problem. Because there are so few parenthesized expressions in the script, we can just eyeball this problem and see that the closing parenthesis of the random number instantiation was mistakenly truncated:</p>&#13;
<pre class="programs">number=$(( $$ % $biggest )          # Random number between 1 and $biggest</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_48"/>We can fix this by adding the closing parenthesis to the end of the line but before the code comment. Does the game work now? Let’s find out:</p>&#13;
<pre class="programs">$ <span class="codestrong">hilow</span>&#13;
Guess? <span class="codestrong">33</span>&#13;
... bigger!&#13;
Guess? <span class="codestrong">66</span>&#13;
... bigger!&#13;
Guess? <span class="codestrong">99</span>&#13;
... bigger!&#13;
Guess? <span class="codestrong">100</span>&#13;
... bigger!&#13;
Guess? <span class="codestrong">^C</span></pre>&#13;
<p class="indent">Almost. But because 100 is the maximum possible value, there seems to be an error in the code’s logic. These errors are particularly tricky because there’s no fancy <code>grep</code> or <code>sed</code> invocation to identify the problem. Look back at the code and see if you can identify what’s going wrong.</p>&#13;
<p class="indent">To debug this, we can add a few <code>echo</code> statements to output the user’s chosen number and verify that what was entered is what’s being tested. The relevant section of code starts at <span class="ent">➋</span>, but we’ve reprinted the lines here for convenience:</p>&#13;
<pre class="programs">  /bin/echo -n "Guess? " ; read answer&#13;
  if [ "$guess" -lt $number ] ; then</pre>&#13;
<p class="indent">In fact, as we modified the <code>echo</code> statement and looked at these two lines, we realized the error: the variable being read is <code>answer</code>, but the variable being tested is called <code>guess</code>. A boneheaded error, but not an uncommon one (particularly if you have oddly spelled variable names). To fix this, we should change <code>read answer</code> to <code>read guess</code>.</p>&#13;
<h4 class="h4" id="ch01lev2sec61"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">Finally, it works as expected, shown in <a href="ch01.xhtml#ch1ex31">Listing 1-31</a>.</p>&#13;
<pre class="programs">$ <span class="codestrong">hilow</span>&#13;
Guess? <span class="codestrong">50</span>&#13;
... bigger!&#13;
Guess? <span class="codestrong">75</span>&#13;
... bigger!&#13;
Guess? <span class="codestrong">88</span>&#13;
... smaller!&#13;
Guess? <span class="codestrong">83</span>&#13;
... smaller!&#13;
Guess? <span class="codestrong">80</span>&#13;
... smaller!&#13;
Guess? <span class="codestrong">77</span>&#13;
... bigger!&#13;
Guess? <span class="codestrong">79</span>&#13;
Right!! Guessed 79 in 7 guesses.</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_49"/><a id="ch1ex31"/><em>Listing 1-31: The</em> <code><em>hilow</em></code> <em>shell script game working in all its glory</em></p>&#13;
<h4 class="h4" id="ch01lev2sec62"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">The most grievous bug lurking in this little script is that it doesn’t validate input. Enter anything at all other than an integer and the script sputters and fails. Including a rudimentary test could be as easy as adding the following lines of code inside the <code>while</code> loop:</p>&#13;
<pre class="programs">if [ -z "$guess" ] ; then&#13;
  echo "Please enter a number. Use ^C to quit"; continue;&#13;
fi</pre>&#13;
<p class="indent">Problem is, confirming that it’s a nonzero input doesn’t mean it’s a number, and you can generate errors from the test command with an input like <code>hi</code>. To fix the problem, add a call to the <code>validint</code> function from <a href="ch01.xhtml#ch01lev1sec06">Script #5</a> on <a href="ch01.xhtml#page_23">page 23</a>.<span epub:type="pagebreak" id="page_50"/></p>&#13;
</body></html>