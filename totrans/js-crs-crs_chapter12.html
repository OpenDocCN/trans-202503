<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>JavaScript Crash Course</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:26ab05bf-a247-42ca-b08d-ede069333d2b" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch12" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="CHAPTER" id="ch12">
<span class="CN"><span aria-label=" Page 205. " epub:type="pagebreak" id="pg_205" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">GENERATING SOUNDS</samp></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" src="../images/opener.png"/>
</figure>
<p class="INTROTNI2">Now it’s time for something completely different! In this next project, you’ll create a song using JavaScript and the Web Audio API. You’ll also learn some general tips about sound synthesis and how electronic music is made.</p>
<p class="TX">This chapter will introduce the Web Audio API and Tone.js, a JavaScript library built on top of it. This will be your first taste of the wide world of third-party JavaScript libraries, which are collections of prewritten code that you can harness to simplify complex tasks. Tone.js raises the level of abstraction compared with the Web Audio API, allowing you to think about and implement musical concepts in a more natural way. Once you’re familiar with how it works, in <a href="chapter13.xhtml">Chapter 13</a> you’ll put everything you’ve learned to use to make a song that you can customize or even rewrite.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="h1-71"/><span aria-label=" Page 206. " epub:type="pagebreak" id="pg_206" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">The Web Audio API</samp></h3>
<p class="TNI1">This section covers the basics of the Web Audio API, which provides a way to create and manipulate sounds in the browser using JavaScript. Google Chrome introduced the Web Audio API in 2011, and soon after that it was released as a W3C standard (the W3C, or World Wide Web Consortium, is an organization that develops standards for the web). To use it, you create <span class="text">nodes</span> and then connect them together. Each <i>node</i> represents some aspect of a sound—one node might generate a basic tone, a second node might set its volume, a third might apply an effect such as reverb or distortion to the tone, and so on. With this scheme, you can produce almost any kind of sound you might want.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="H2" id="sec2"><span id="h2-67"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting Up</samp></h4>
<p class="TNI1">As always, we’ll start with a simple HTML file. The file will give the user the ability to play a sound generated by the Web Audio API. Create a new directory called <i>music</i> and enter the content in <a href="#Lis12-1">Listing 12-1</a> into a new file called <i>index.html</i>.</p>
<span id="Lis12-1"/>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Music&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> &lt;button id="play"&gt;Play&lt;/button&gt;
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> &lt;p id="playing" style="display: none"&gt;Playing&lt;/p&gt;
    &lt;script src="script.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-1: An</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file for exploring the Web Audio API</samp></p>
<p class="TX">This listing creates two visual elements: a Play button <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and a paragraph containing the text “Playing” <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. The paragraph uses an inline <span class="SANS_TheSansMonoCd_W5Regular_11">style</span> attribute, which allows us to add CSS declarations directly to the element from the HTML file. In this case, we’re setting <span class="SANS_TheSansMonoCd_W5Regular_11">display</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">none</span>, which hides the element. Later, we’ll use JavaScript to remove the style and show the element when the audio is playing.</p>
<p class="TX">Next, we’ll start writing the JavaScript. In many browsers, including Google Chrome, the Web Audio API won’t play any sound until the user interacts with the page. We’re using the Play button as our interactive element, which will trigger our audio code. Because we only need the button to be clicked once, we’ll hide it after it’s been clicked.</p>
<p class="TX">Create <i>script.js</i> in the same directory as the HTML file and add the content shown in <a href="#Lis12-2">Listing 12-2</a>. This code hides the Play button and shows the “Playing” text when the user clicks the button. Note that we’re not doing any Web Audio API code yet—this is just setting up the button.</p>
<span id="Lis12-2"/>
<pre><code><span aria-label=" Page 207. " epub:type="pagebreak" id="pg_207" role="doc-pagebreak"/><span aria-label="annotation1" class="CodeAnnotationHang">❶</span> let play = document.querySelector("#play");
let playing = document.querySelector("#playing");
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> play.addEventListener("click", () =&gt; {
  // Hide this button
  play.style = "display: none";
  playing.style = " ";
});
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-2: Switching the visibility of the elements on a mouse click</samp></p>
<p class="TX">First, we get references to the two elements using the <span class="SANS_TheSansMonoCd_W5Regular_11">document.querySelector</span> method <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Then we add a <span class="SANS_TheSansMonoCd_W5Regular_11">click</span> event listener to the Play button <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. When the user clicks it, our event listener adds an inline <span class="SANS_TheSansMonoCd_W5Regular_11">style</span> attribute of <span class="SANS_TheSansMonoCd_W5Regular_11">display: none</span> to the button and sets the inline <span class="SANS_TheSansMonoCd_W5Regular_11">style</span> of the paragraph to an empty string, effectively removing the inline <span class="SANS_TheSansMonoCd_W5Regular_11">style</span> set as an attribute in the HTML file. The net effect of this code is that clicking the Play button will hide the button and show the paragraph. This has two purposes: it lets the user know that music should now be playing, and it removes the Play button so it can’t be clicked a second time.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="H2" id="sec3"><span id="h2-68"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generating a Tone with the Web Audio API</samp></h4>
<p class="TNI1">With our setup out of the way, we can now write some Web Audio API code. To get started, we’ll just generate a single tone, the audio equivalent of “Hello, world!” The code to generate the tone is shown in <a href="#Lis12-3">Listing 12-3</a>. As I mentioned earlier, the audio won’t play unless it’s triggered by a user event, such as a mouse click, so all the audio code lives inside the click handler.</p>
<span id="Lis12-3"/>
<pre><code><var>--snip--</var>
<span class="gray">play.addEventListener("click", () =&gt; {</span>
<span class="gray">  // Hide this button</span>
<span class="gray">  play.style = "display: none";</span>
<span class="gray">  playing.style = " ";</span>

<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> let audioCtx = new AudioContext();

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> let oscNode = audioCtx.createOscillator();
  oscNode.frequency.value = 440;

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> let gainNode = audioCtx.createGain();
  gainNode.gain.value = 0.5;

<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> oscNode.connect(gainNode);
  gainNode.connect(audioCtx.destination);

<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> oscNode.start(audioCtx.currentTime);
  oscNode.stop(audioCtx.currentTime + 2);
<span class="gray">});</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-3: Playing a single tone with the Web Audio API</samp></p>
<p class="TX">The first thing we do is create the <i>audio context</i> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This is the object through which we interact with the Web Audio API, similar to the drawing <span aria-label=" Page 208. " epub:type="pagebreak" id="pg_208" role="doc-pagebreak"/>context for the <span class="SANS_TheSansMonoCd_W5Regular_11">canvas</span> element. Next, we create our first node, an oscillator <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. In electronics and signal processing terms, an <i>oscillator</i> is a device that creates a signal that repeatedly goes up and down in a regular pattern. The default waveform a Web Audio API oscillator outputs is a sine wave, shown in <a href="chapter12.xhtml#fig12-1">Figure 12-1</a>. When the wave oscillates fast enough, and is connected to a speaker, it creates an audible tone. In this example, we’re setting the frequency to 440 Hertz (Hz), or 440 cycles per second. In other words, the oscillator is outputting a signal that transitions from 0 to 1 to –1 and back to 0 a total of 440 times every second. This means that one cycle of the wave lasts 1/440 of a second, or 2.27 ms. I used 440 Hz here because it’s the standard reference pitch for tuning musical instruments. The frequency corresponds to the note A above middle C.</p>
<figure class="IMG"><img alt="" class="img7" id="fig12-1" src="../images/Figure_12-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: One cycle of a sine wave</samp></p></figcaption>
</figure>
<p class="TX">Next, we create a gain node <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> and set its value to <span class="SANS_TheSansMonoCd_W5Regular_11">0.5</span>. In signal processing, <i>gain</i> refers to an increase or decrease in a signal’s amplitude, or its range of values. In practical terms, gain acts as a volume control. A gain of 2 doubles the amplitude, making the sound louder, a gain of 0.5 halves the amplitude, making the sound softer, and a gain of 1 (the default value of a gain node) has no effect on the amplitude. Applying a gain of 0.5 to the sine wave from <a href="chapter12.xhtml#fig12-1">Figure 12-1</a> would produce a sine wave with a maximum value of 0.5 and a minimum value of –0.5, as shown in <a href="chapter12.xhtml#fig12-2">Figure 12-2</a>.</p>
<figure class="IMG"><img alt="" class="img7" id="fig12-2" src="../images/Figure_12-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-2: The sine wave from <a href="chapter12.xhtml#fig12-1">Figure 12-1</a>, with a gain of 0.5 applied</samp></p></figcaption>
</figure>
<p class="TX">So far we have two nodes: an oscillator node and a gain node. To actually apply the gain to the oscillator’s signal, we need to connect the nodes together. We link the output of the oscillator node to the input of the gain node using the oscillator node’s <span class="SANS_TheSansMonoCd_W5Regular_11">connect</span> method <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. Then, to be able to hear the result, we connect the output of the gain node to the main output, which is available to us through the audio context as <span class="SANS_TheSansMonoCd_W5Regular_11">ctx.destination</span>. These <span aria-label=" Page 209. " epub:type="pagebreak" id="pg_209" role="doc-pagebreak"/>connections mean that the oscillator signal is passed through the gain node and then passed to the output, which will ultimately go to your headphones or speakers, if the sound is turned on. <a href="chapter12.xhtml#fig12-3">Figure 12-3</a> illustrates these connections.</p>
<figure class="IMG"><img alt="" class="img8" id="fig12-3" src="../images/Figure_12-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-3: The graph of nodes</samp></p></figcaption>
</figure>
<p class="TX">The oscillator node doesn’t actually create a signal until we tell it to. To do that, we call the <span class="SANS_TheSansMonoCd_W5Regular_11">start</span> method on the oscillator, passing <span class="SANS_TheSansMonoCd_W5Regular_11">audioCtx .currentTime</span> as an argument <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">currentTime</span> property corresponds to the amount of time in seconds that the audio context has been active. By passing <span class="SANS_TheSansMonoCd_W5Regular_11">audioCtx.currentTime</span> to the <span class="SANS_TheSansMonoCd_W5Regular_11">start</span> method, we’re telling the oscillator to start playing immediately. Then we call the <span class="SANS_TheSansMonoCd_W5Regular_11">stop</span> method, passing <span class="SANS_TheSansMonoCd_W5Regular_11">audioCtx .currentTime + 2</span>. This tells the oscillator to stop two seconds after it started.</p>
<p class="TX">The effect of all of this code is that when you load the <i>index.html</i> page in your browser and click the Play button, a tone of 440 Hz should play for two seconds. If you don’t hear anything, make sure sound is enabled on your computer and browser—for example, by playing a YouTube video. If it still doesn’t work, check the console to make sure there aren’t any errors.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<aside aria-label="box-37" class="box" id="sec4">
<h4 class="BH" id="box-37"><samp class="SANS_Dogma_OT_Bold_B_11">TRY IT YOURSELF</samp></h4>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">12-1.</samp><samp class="SANS_Futura_Std_Book_11">  Change the frequency, or pitch, of the tone by changing</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">oscNode.frequency.value</span><samp class="SANS_Futura_Std_Book_11">. Halving the frequency will lower the tone’s musical pitch by an octave, and doubling it will raise its pitch by an octave.</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">12-2.</samp><samp class="SANS_Futura_Std_Book_11">  Change the value of the gain node to alter the volume of the tone. For example, setting it to</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">0.25</span> <samp class="SANS_Futura_Std_Book_11">will make it half as loud.</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">12-3.</samp><samp class="SANS_Futura_Std_Book_11">  Change the duration of the tone by modifying the argument to the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">stop</span> <samp class="SANS_Futura_Std_Book_11">method. You can also add a delay between when the user clicks the Play button and when the tone starts by modifying the argument to the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">start</span> <samp class="SANS_Futura_Std_Book_11">method. For example,</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">oscNode.start(audioCtx.currentTime + 0.5)</span> <samp class="SANS_Futura_Std_Book_11">would start playing the tone half a second after the button click.</samp></p>
</aside>
<p class="TX">You might be thinking that you just had to write a lot of code for a very simple example, and you’d be right! The Web Audio API is quite powerful, but you have to work at a very low level with extremely basic building blocks. To simplify things, next we’re going to shift our focus to a popular, higher-level audio library called Tone.js.</p>
</section>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H1" id="sec5"><span id="h1-72"/><span aria-label=" Page 210. " epub:type="pagebreak" id="pg_210" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">The Tone.js Library</samp></h3>
<p class="TNI1">The Tone.js library is built on top of the Web Audio API. It’s designed to make it easier to create music using the API. For example, instead of having to fiddle with oscillators and gain nodes, Tone.js lets you use electronic instruments with volume controls. Instead of using frequencies, you can use the names of musical notes. And instead of using seconds for controlling when events happen, you can use bars and beats.</p>
<p class="TX">The Tone.js website, <a href="https://tonejs.github.io"><i>https://<wbr/>tonejs<wbr/>.github<wbr/>.io</i></a>, provides details on installing and using the library. The easiest option is to use a prebuilt file hosted on a content delivery network (CDN) like <a href="https://unpkg.com"><i>https://<wbr/>unpkg<wbr/>.com</i></a>, which is what we’ll do here. This way all you have to do to access the library is reference a URL directly from a <span class="SANS_TheSansMonoCd_W5Regular_11">script</span> element in your HTML file. There’s no need to download a copy of the library, as long as you have access to the internet while you’re working.</p>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="H2" id="sec6"><span id="h2-69"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generating a Tone with Tone.js</samp></h4>
<p class="TNI1">Let’s re-create our Web Audio API “Hello, world!” example using the Tone.js library instead. We can keep all the HTML the same, except for adding a new <span class="SANS_TheSansMonoCd_W5Regular_11">script</span> tag for the library, as shown in <a href="#Lis12-4">Listing 12-4</a>.</p>
<span id="Lis12-4"/>
<pre><code><var>--snip--</var>
<span class="gray">    &lt;p id="playing" style="display: none"&gt;Playing&lt;/p&gt;</span>
    &lt;script src="https://unpkg.com/tone@14.7.77/build/Tone.js"&gt;&lt;/script&gt;
<span class="gray">    &lt;script src</span><span class="gray">="script.js"&gt;&lt;/script&gt;</span>
<span class="gray">  &lt;/body&gt;</span>
<span class="gray">&lt;/html&gt;</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-4: Including Tone.js in the</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file</samp></p>
<p class="TX">We set the <span class="SANS_TheSansMonoCd_W5Regular_11">src</span> of the new <span class="SANS_TheSansMonoCd_W5Regular_11">script</span> element to an <i>unpkg.com</i> file containing the full Tone.js library as a single JavaScript file.</p>
<p class="TX">Next, we’ll write the JavaScript. Since Tone.js uses the Web Audio API underneath, we still have the limitation that user input is required to start playing the audio. We therefore still need the <span class="SANS_TheSansMonoCd_W5Regular_11">click</span> event handler, but everything else in <i>script.js</i> will change. <a href="#Lis12-5">Listing 12-5</a> shows the updated JavaScript file.</p>
<span id="Lis12-5"/>
<pre><code><var>--snip--</var>
<span class="gray">play.addEventListener("click", () =&gt; {</span>
<span class="gray">  // Hide this button</span>
<span class="gray">  play.style = "display: none";</span>
<span class="gray">  playing.style = " ";</span>

  Tone.start();

  let synth <span class="symbol">=</span> new Tone.Synth({
    oscillator: {type: "sine"},
    envelope: {attack: 0, decay: 0, sustain: 1, release: 0},
<span aria-label=" Page 211. " epub:type="pagebreak" id="pg_211" role="doc-pagebreak"/>    volume: -6 
 }).toDestination();

  synth.triggerAttackRelease("A4", 2, 0);
<span class="gray">});</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-5: Playing a single tone with Tone.js</samp></p>
<p class="TX">The first thing we need to do is call <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.start</span>. This triggers the Tone.js library to start inside the click handler, ensuring that the browser will allow it to play audio. Next, we create a new <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Synth</span> object. <i>Synth</i> is short for <i>synthesizer</i>, an electronic instrument, usually with a keyboard, that can generate (synthesize) all kinds of sounds. A <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Synth</span> is a simple code version of such an instrument.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Synth</span> constructor takes an object as its argument that allows us to configure various aspects of the synthesizer. In this case, we’re telling the synth to use an oscillator that generates sine waves. We’re also giving the synth a simple amplitude envelope and a volume of <span class="SANS_TheSansMonoCd_W5Regular_11">-6</span>. I’ll explain what these settings mean in the following section, but for now, this is what we need to match the Web Audio API oscillator from <a href="#Lis12-3">Listing 12-3</a>. After the constructor we chain the <span class="SANS_TheSansMonoCd_W5Regular_11">toDestination</span> method, which connects the output of the synth to the audio context’s output.</p>
<p class="TX">Finally, we tell the synth to play a single note using its <span class="SANS_TheSansMonoCd_W5Regular_11">triggerAttackRelease</span> method. This method takes the note’s name, the duration, and the time at which to play the note. We’re passing <span class="SANS_TheSansMonoCd_W5Regular_11">"A4"</span> for the note name, which is equivalent to 440 Hz, and telling it to play for two seconds, starting immediately. When you reload your browser and click the Play button, you should hear the same sound as when you ran <a href="#Lis12-3">Listing 12-3</a>.</p>
<p class="TX">As you can hopefully see, using the Tone.js library simplifies the process of making music with the Web Audio API. Instead of having to create separate nodes for different aspects of a sound (pitch, gain, and so on), everything is unified under one <span class="SANS_TheSansMonoCd_W5Regular_11">Synth</span> object. If you have any musical knowledge, you’ll also find that the library uses concepts much closer to your understanding than the API does, for example, by using note names instead of frequencies. As you learn more about Tone.js, you’ll see more examples of this.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h4 class="H2" id="sec7"><span id="h2-70"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding the Tone.Synth Options</samp></h4>
<p class="TNI1">Let’s take a closer look at the object we passed to the <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Synth</span> constructor in <a href="#Lis12-5">Listing 12-5</a>. The first property, <span class="SANS_TheSansMonoCd_W5Regular_11">oscillator</span>, defines the options for the oscillator generating the signal. In this case, we’re just setting the type of the oscillator to be a sine wave, using the <span class="SANS_TheSansMonoCd_W5Regular_11">type</span> property.</p>
<p class="TX">The next property defines the options for the <i>amplitude envelope</i>, which determines how the volume of a note changes over the course of its duration. Most synthesizers, hardware and software, allow you to configure amplitude envelopes. The most common type of envelope is an <i>ADSR envelope</i>, short for <i>attack, decay, sustain, release</i>. The <i>attack</i> is the amount of time between the note being triggered (for example, when you press a key on a <span aria-label=" Page 212. " epub:type="pagebreak" id="pg_212" role="doc-pagebreak"/>synthesizer) and the note reaching its maximum volume. The <i>decay</i> is the amount of time between the end of the attack and the sustain portion of the note. The <i>sustain</i> is a gain value that defines the volume the note will remain at after the attack and decay, for as long as the key is held down. Typically this is some fraction of the full volume achieved by the attack portion of the envelope. The <i>release</i> defines how long it will take for the note’s amplitude to get back down to zero after the key is released. <a href="chapter12.xhtml#fig12-4">Figure 12-4</a> shows these different values graphically.</p>
<figure class="IMG"><img alt="" class="img7" id="fig12-4" src="../images/Figure_12-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-4: The parts of an ADSR envelope</samp></p></figcaption>
</figure>
<p class="TX">ADSR envelopes are an approximation of how many real-world musical instruments work. For example, when you bow a violin, it takes some time for the note to get up to its full volume—that is, it has a long attack. By contrast, when you press a key on a piano, the attack is very short. Similarly, when you stop bowing a note on a violin it takes a little time for the string to stop vibrating, whereas the release of a piano note is more immediate. Synthetic ADSR envelopes are still pretty simplistic—they aren’t a perfect simulation of real-life instruments—but they add a lot of expressivity to what would otherwise just be a boring tone.</p>
<p class="TX">That said, the ADSR envelope we’ve used for our synth is as boring as they come. We’ve set the attack, decay, and release values to <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> and the sustain to <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>, meaning the tone is at full volume for its entire duration. This matches what we did with the simple Web Audio API oscillator from <a href="#Lis12-3">Listing 12-3</a>, and it’s part of why the resulting tone sounds so synthetic.</p>
<p class="TX">The final property of the synth options object, <span class="SANS_TheSansMonoCd_W5Regular_11">volume</span>, sets the overall volume of the synthesizer in decibels (dB). Decibels are an alternative way to talk about gain, and in some ways they match the way we think about gain better. A setting of 0 decibels is equivalent to a gain of 1 (no change to the volume), –6 decibels is equivalent to a gain of 0.5, or half the volume, –12 decibels corresponds to a gain of 0.25, or a quarter of the volume, and so on; every +6 decibels doubles the volume, and every –6 decibels halves it. Our ears are attuned to the relative volume between sounds, so every time the level is halved or doubled, it sounds to us like it’s going down or up by a fixed amount. This “fixed amount” is a fixed number of decibels that are added or subtracted, which is why decibels can be easier to use for setting <span aria-label=" Page 213. " epub:type="pagebreak" id="pg_213" role="doc-pagebreak"/>volume. In this case, we’re passing –6 dB to match the gain of 0.5 from <a href="#Lis12-3">Listing 12-3</a>.</p>
<p class="TX">Now that you know what the options are, let’s try playing with them! First, we’ll modify the type of the oscillator. Currently the oscillator is set to generate a sine wave, but we’re going to switch to a square wave instead. <a href="chapter12.xhtml#fig12-5">Figure 12-5</a> shows the waveform of a single cycle of a square wave.</p>
<figure class="IMG"><img alt="" class="img7" id="fig12-5" src="../images/Figure_12-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-5: A square wave</samp></p></figcaption>
</figure>
<p class="TX">Notice that a square wave has abrupt transitions between amplitude values, instead of the smooth curves of a sine wave. The code change to switch to a square wave oscillator is shown in <a href="#Lis12-6">Listing 12-6</a>.</p>
<span id="Lis12-6"/>
<pre><code><var>--snip--</var>
<span class="gray">  let synth = new Tone.Synth({</span>
    oscillator: {type: "square"},
<span class="gray">    envelope: {attack: 0, decay: 0, sustain: 1, release: 0},</span>
<span class="gray">    volume: -6 </span>
<span class="gray">  }).toDestination();</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-6: Changing the oscillator type to a square wave</samp></p>
<p class="TX">When you reload the code in your browser, you should hear a very different tone. The square wave is louder and brighter than the sine wave. Some other values you can try out for the oscillator type are <span class="SANS_TheSansMonoCd_W5Regular_11">"triangle"</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">"sawtooth"</span>. <a href="chapter12.xhtml#fig12-6">Figure 12-6</a> shows the waveforms of these two.</p>
<figure class="IMG"><img alt="" class="img1" id="fig12-6" src="../images/Figure_12-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-6: Sawtooth and triangle waves</samp></p></figcaption>
</figure>
<p class="TX">Think about how these other oscillator types differ from <span class="SANS_TheSansMonoCd_W5Regular_11">"sine"</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">"square"</span>. The distinctive sound of each oscillator is known as its <i>color</i>, or <i>timbre</i>.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<aside aria-label="box-38" class="box" id="sec8">
<h4 class="BH" id="box-38"><span aria-label=" Page 214. " epub:type="pagebreak" id="pg_214" role="doc-pagebreak"/><samp class="SANS_Dogma_OT_Bold_B_11">WHY DO DIFFERENT OSCILLATORS SOUND SO DIFFERENT?</samp></h4>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Did you know that when you play a note on an instrument like a violin or piano, the resulting sound doesn’t just contain the frequency of the note you’re playing? It actually contains many frequencies at once. That’s what the different oscillator types, like square, sawtooth, and triangle, are trying to simulate.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">A sine wave is the simplest waveform—it contains only a single frequency. Other oscillator waveforms are in effect made up of a combination of many individual sine waves of various frequencies, where each frequency is a whole-number multiple of the original frequency. These multiples of the base frequency are known as</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">harmonics</samp><samp class="SANS_Futura_Std_Book_11">, or</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">overtones</samp><samp class="SANS_Futura_Std_Book_11">, while the base frequency is known as the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">fundamental</samp><samp class="SANS_Futura_Std_Book_11">. For example, a tone with a fundamental of 200 Hz has possible harmonics at 400 Hz (200 ×</samp> <samp class="SANS_Futura_Std_Book_11">2), 600 Hz (200 × 3), 800 Hz (200 × 4), and so on. A sawtooth wave contains every harmonic (200, 400, 600, 800, …), while a square wave only contains every other harmonic (200, 600, 1000, …). However many harmonics a note has, the fundamental frequency is what we perceive as the note’s pitch. The other harmonics simply add color to the sound.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">With both square and sawtooth waveforms, the amplitude of the harmonics reduces the higher in frequency they get. A triangle wave has only every other harmonic, like a square wave, but the amplitude reduces more rapidly as the harmonics increase.</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The presence of different harmonics, and their relative amplitude levels, is what causes the difference in sound between different oscillator types. Along with variations in amplitude envelope, they’re also why a violin sounds different from a piano, for example. The triangle wave contains the same harmonics as the square wave, but the higher harmonics are quieter, which gives it a less harsh, more rounded sound. Because both of these waveforms contain only every other harmonic, they can sound a little hollow. By contrast, the sawtooth wave has all the harmonics, so it has a fuller sound.</samp></p>
</aside>
<p class="TX">Next, let’s try changing the envelope. We intentionally used a very basic envelope in <a href="#Lis12-5">Listing 12-5</a> to match the Web Audio API example from <a href="#Lis12-3">Listing 12-3</a>, which had no envelope. Now we’ll set those values to something that sounds a little more musical, as shown in <a href="#Lis12-7">Listing 12-7</a>.</p>
<span id="Lis12-7"/>
<pre><code><var>--snip--</var>
<span class="gray">  let synth = new Tone.Synth({</span>
<span class="gray">    oscillator: { type: "square" },</span>
    envelope: {attack: 0.8, decay: 0.3, sustain: 0.8, release: 1},
<span class="gray">    volume: -6 </span>
<span class="gray">  }).toDestination();</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-7: Changing the oscillator type to a square wave</samp></p>
<p class="TX"><span aria-label=" Page 215. " epub:type="pagebreak" id="pg_215" role="doc-pagebreak"/>The values of <span class="SANS_TheSansMonoCd_W5Regular_11">attack</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">decay</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">release</span> are all given in seconds, while <span class="SANS_TheSansMonoCd_W5Regular_11">sustain</span> is a number between 0 and 1 representing the amplitude level to be sustained at. Here we’re setting <span class="SANS_TheSansMonoCd_W5Regular_11">attack</span> to 0.8 seconds, <span class="SANS_TheSansMonoCd_W5Regular_11">decay</span> to 0.3 seconds, <span class="SANS_TheSansMonoCd_W5Regular_11">sustain</span> to 0.8, and <span class="SANS_TheSansMonoCd_W5Regular_11">release</span> to a whole second. When you reload the page and play the sound, you should hear the note slowly fade in to its max volume, then slightly reduce. After two seconds, the note is released and fades out over a second.</p>
<p class="TX">The final parameter to play with is the <span class="SANS_TheSansMonoCd_W5Regular_11">volume</span>. As I explained earlier, every time you subtract 6 dB, the level is halved, and when you add 6 dB, it’s doubled. Try out some different values here, for example, <span class="SANS_TheSansMonoCd_W5Regular_11">–12</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">–18</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">–24</span>. You can also go the other way, up to 0 dB.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="H2" id="sec9"><span id="h2-71"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Playing More Notes in Sequence</samp></h4>
<p class="TNI1">Our synthesizer is currently playing only a single note, but we can easily play more notes. Note frequencies in Tone.js can be given in Hz or with note names, like A4, as we did in <a href="#Lis12-5">Listing 12-5</a>. These note names correspond to keys on a keyboard, as shown in <a href="chapter12.xhtml#fig12-7">Figure 12-7</a>.</p>
<figure class="IMG"><img alt="" class="img7" id="fig12-7" src="../images/Figure_12-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-7: Note names on a keyboard</samp></p></figcaption>
</figure>
<p class="TX">C4 is known as <i>middle C</i> and is located near the middle of most piano keyboards. Each octave on the keyboard from each C to the B above is given a number. For example, the leftmost key in <a href="chapter12.xhtml#fig12-7">Figure 12-7</a> is C3, and an octave above that is C4. As mentioned previously, 440 Hz corresponds to A4, which is the A above C4. The black notes are known as <i>accidentals</i> and are a semitone higher than the key to their left, or a semitone lower than the key to their right. For example, the black key to the right of C4 can be called C<span class="code_symbol-alt1">♯</span>4 or D<span class="code_symbol-alt1">♭</span>4 (<span class="code_symbol-alt1">♯</span> is the symbol for <i>sharp</i>, meaning a semitone higher, while <span class="code_symbol-alt1">♭</span> is the symbol for <i>flat</i>, meaning a semitone lower). When writing note names in Tone.js, we use a hash mark (<span class="SANS_TheSansMonoCd_W5Regular_11">#</span>) for sharp and the letter <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> for flat.</p>
<blockquote>
<p class="NOTE"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>There are no black keys between B and C or E and F because these notes are only a semitone apart.</i></p>
<p class="TX">We’re going to play a major scale from A3 to A4, which consists of the notes A3, B3, C<span class="code_symbol-alt1">♯</span>4, D4, E4, F<span class="code_symbol-alt1">♯</span>4, G<span class="code_symbol-alt1">♯</span>4, and A4. Update your <i>script.js</i> to include the code in <a href="#Lis12-8">Listing 12-8</a> to implement this scale.</p>
<span id="Lis12-8"/>
<pre><code><var>--snip--</var>
<span class="gray">  let synth = new Tone.Synth({</span>
<span class="gray">    oscillator: {type: "square"},</span>
<span aria-label=" Page 216. " epub:type="pagebreak" id="pg_216" role="doc-pagebreak"/>  <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> envelope: { attack: 0.1, decay: 0.3, sustain: 0.8, release: 0.1 },
<span class="gray">    volume: -6</span>
<span class="gray">  }).toDestination();</span>

  synth.triggerAttackRelease("A3", 0.9, 0);
  synth.triggerAttackRelease("B3", 0.9, 1);
  synth.triggerAttackRelease("C#4", 0.9, 2);
  synth.triggerAttackRelease("D4", 0.9, 3);
  synth.triggerAttackRelease("E4", 0.9, 4);
  synth.triggerAttackRelease("F#4", 0.9, 5);
  synth.triggerAttackRelease("G#4", 0.9, 6);
  synth.triggerAttackRelease("A4", 0.9, 7);
<span class="gray">});</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-8: Playing a scale</samp></p>
<p class="TX">This is very similar to <a href="#Lis12-5">Listing 12-5</a>, except that we’re triggering multiple notes, one after the other. Notice we’ve updated the envelope to have a shorter attack and release <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The release, in particular, needs to be shorter so the end of each note doesn’t overlap with the start of the next.</p>
<p class="TX">As I mentioned earlier, the second argument to <span class="SANS_TheSansMonoCd_W5Regular_11">triggerAttackRelease</span> is the duration of the note in seconds, and the third argument is the time at which to play the note, also in seconds. The first note, A3, is played for 0.9 seconds, starting at time zero (that is, immediately). The 0.1-second release happens after the 0.9-second duration, so each note will play for 1 second in total. The next note, B3, has the same duration, but the third argument of <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> means it will start a second later than the first note. The third note is programmed to start two seconds later than the first note, and so on for the rest of the notes. Play this in your browser, and you should hear a single octave of an A major scale.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="H2" id="sec10"><span id="h2-72"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Playing Multiple Notes at Once</samp></h4>
<p class="TNI1">The synthesizer we’ve been using so far is a <i>monophonic synth</i>, meaning it can play only a single note at a time. To play multiple notes at once, we’ll need to create a <i>polyphonic synth</i> instead. In <a href="#Lis12-9">Listing 12-9</a>, we update the code to create a new polyphonic synth and play two or three notes at a time.</p>
<span id="Lis12-9"/>
<pre><code><var>--snip--</var>
<span class="gray">  Tone.start();</span>

  let synth = new Tone.PolySynth(
    Tone.Synth,
    {
      oscillator: { type: "square" },
      envelope: { attack: 0.1, decay: 0.3, sustain: 0.8, release: 0.1 },
      volume: -6
    }
  ).toDestination();

  synth.triggerAttackRelease(["A3", "C#4"], 0.9, 0);
  synth.triggerAttackRelease(["B3", "D4"], 0.9, 1);
<span aria-label=" Page 217. " epub:type="pagebreak" id="pg_217" role="doc-pagebreak"/>  synth.triggerAttackRelease(["C#4", "E4"], 0.9, 2);
  synth.triggerAttackRelease(["D4", "F#4"], 0.9, 3);
  synth.triggerAttackRelease(["E4", "G#4"], 0.9, 4);
  synth.triggerAttackRelease(["F#4", "A4"], 0.9, 5);
  synth.triggerAttackRelease(["G#4", "B4"], 0.9, 6);
  synth.triggerAttackRelease(["E4", "A4", "C#5"], 1.9, 7);
<span class="gray">});</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-9: Creating and playing a polyphonic synth</samp></p>
<p class="TX">Here we call <span class="SANS_TheSansMonoCd_W5Regular_11">new Tone.PolySynth</span> instead of <span class="SANS_TheSansMonoCd_W5Regular_11">new Tone.Synth</span> to create a polyphonic synth object. The <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.PolySynth</span> constructor takes two arguments: a monophonic synth (in this case, <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Synth</span>) and an object with the options that would normally be passed to that monophonic synth’s constructor (in this case, the same synth options we passed to the <span class="SANS_TheSansMonoCd_W5Regular_11">Tone .Synth</span> constructor in <a href="#Lis12-8">Listing 12-8</a>). The polysynth then creates multiple monophonic synths with the specified settings, effectively allowing it to play multiple notes at once.</p>
<p class="TX">Next, we play the same scale, but with additional simultaneous notes. This is achieved by passing an array of note names to the <span class="SANS_TheSansMonoCd_W5Regular_11">triggerAttackRelease</span> method instead of a single note name—for example, we pass the array <span class="SANS_TheSansMonoCd_W5Regular_11">["A3", "C#4"]</span> to play A3 and C<span class="code_symbol-alt1">♯</span>4 at the same time. By default, you can play a maximum of 32 notes with a polysynth.</p>
<p class="TX">When you play this example, you should hear a harmonized scale with a nice major chord at the end.</p>
</section>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h3 class="H1" id="sec11"><span id="h1-73"/><samp class="SANS_Futura_Std_Bold_B_11">The Tone.js Transport</samp></h3>
<p class="TNI1">Now that you’ve learned how to play notes, let’s look at how to make songs. Although you could program a whole song by specifying the timing of every single note, as you did to play a scale in the last few examples, this technique quickly gets tedious. Fortunately, Tone.js has a concept called the <i>transport</i> that makes writing songs much easier. The transport keeps track of the current position in the song, as measured in bars and beats. This lets you schedule notes to play at certain points in the song in a musically intuitive way. The transport also allows you to have looped sequences of notes that start playing at a certain point along the transport and repeat over and over until you tell them to stop.</p>
<p class="TX">Western music tends to be structured around bars and beats, and it’s most common to have four beats in a bar. The speed of the music is given in <i>beats per minute (BPM)</i>, and in our examples we’ll be using the default Tone.js BPM of 120, which means a beat every 0.5 seconds. Beats are also known as <i>quarter notes</i> (because when there are four beats in a bar, one beat is a quarter of a bar). <i>Eighth notes</i> are half the duration of a quarter note, and <i>sixteenth notes</i> are half the duration of an eighth note, so there are four sixteenth notes per quarter note.</p>
<p class="TX">Positions along the transport are given as strings of three numbers separated by colons, like <span class="SANS_TheSansMonoCd_W5Regular_11">"0:0:0"</span>. The three numbers correspond to the <span aria-label=" Page 218. " epub:type="pagebreak" id="pg_218" role="doc-pagebreak"/>current bar number, the current beat within that bar, and the current sixteenth note within that beat, respectively. Everything is zero-indexed. This means, for example, that <span class="SANS_TheSansMonoCd_W5Regular_11">"0:0:0"</span> represents the beginning of the first bar, <span class="SANS_TheSansMonoCd_W5Regular_11">"1:1:0"</span> represents the second beat of the second bar, and <span class="SANS_TheSansMonoCd_W5Regular_11">"6:3:2"</span> refers to the third sixteenth note of the fourth beat in the seventh bar. We refer to these strings as <i>bars:quarters:sixteenths notation</i>.</p>
<section aria-labelledby="sec12" epub:type="division">
<h4 class="H2" id="sec12"><span id="h2-73"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tone.Loop</samp></h4>
<p class="TNI1">The Tone.js transport gives us an easy way to define musical loops, including when they start and when they finish. The simplest of these, <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Loop</span>, defines a way to constantly produce new notes. Let’s try that out by playing a single note repeatedly every quarter note for four bars. Modify <i>script.js</i> with the code in <a href="#Lis12-10">Listing 12-10</a>.</p>
<span id="Lis12-10"/>
<pre><code><var>--snip--</var>
<span class="gray">  Tone.start();</span>

<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> let synth = new Tone.Synth().toDestination();

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> let loop = new Tone.Loop(time =&gt; {
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> synth.triggerAttackRelease("C4", "16n", time);
  }, "4n");

<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> loop.start("0:0:0");
  loop.stop("4:0:0");

  Tone.Transport.start();
<span class="gray">});</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-10: Looping</samp></p>
<p class="TX">We start by creating a simple synth <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Notice we aren’t passing an object to define the <span class="SANS_TheSansMonoCd_W5Regular_11">oscillator</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">envelope</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">volume</span> options, so the synth will be created using the library’s default settings. Next, we create a new instance of <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Loop</span> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, which has a constructor with two arguments. The first argument is some function that requires a time value, and the second argument is a duration indicating how often to call the function in the first argument. In this case, we pass the string <span class="SANS_TheSansMonoCd_W5Regular_11">"4n"</span> as the second argument, which is Tone.js’s notation for a quarter note (“4n” is short for “1/4 note”). This means the loop will repeat every beat.</p>
<blockquote>
<p class="NOTE"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>In our earlier listings we were passing numbers for durations, which give the duration in seconds. The advantage of using note length durations like <span class="SANS_TheSansMonoCd_W5Regular_11">"4n"</span> for a quarter note or <span class="SANS_TheSansMonoCd_W5Regular_11">"16n"</span> for a sixteenth note is that they will scale automatically if we change the BPM. For example, doubling the BPM will halve the duration of each quarter note.</i></p>
<p class="TX">The body of the callback function we pass to <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Loop</span> calls the <span class="SANS_TheSansMonoCd_W5Regular_11">triggerAttackRelease</span> method on the synth to play the note C4 with a sixteenth note duration <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The third argument of the <span class="SANS_TheSansMonoCd_W5Regular_11">triggerAttackRelease</span> method, <span class="SANS_TheSansMonoCd_W5Regular_11">time</span>, represents the time to play a note. The <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Loop</span> object will <span aria-label=" Page 219. " epub:type="pagebreak" id="pg_219" role="doc-pagebreak"/>provide a new <span class="SANS_TheSansMonoCd_W5Regular_11">time</span> value whenever it calls the callback function, filling it in with the appropriate location on the transport.</p>
<p class="TX">Finally, we call the <span class="SANS_TheSansMonoCd_W5Regular_11">start</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">stop</span> methods on the loop returned by the <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Loop</span> constructor <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, passing the time when we want this loop to start and when we want it to stop, followed by a call to <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Transport.start</span>, which starts the transport playing from the beginning. We start at <span class="SANS_TheSansMonoCd_W5Regular_11">"0:0:0"</span>, the beginning of the first bar, and stop at <span class="SANS_TheSansMonoCd_W5Regular_11">"4:0:0"</span>, the beginning of the fifth bar, meaning that this snippet will last four full bars with four beats each. Our loop repeats at every beat, playing one note each time, so we’ll play a total of 16 notes. Try reloading the page and see! You can use the musician’s trick of counting bars and beats like this: “<i>one</i> two three four, <i>two</i> two three four, <i>three</i> two three four, <i>four</i> two three four.” Notice that Tone.js doesn’t play a seventeenth note at time location <span class="SANS_TheSansMonoCd_W5Regular_11">"4:0:0"</span> because the end of the loop isn’t inclusive.</p>
<p class="TX"><a href="#Lis12-11">Listing 12-11</a> shows an alternative way of creating the same loop we wrote in <a href="#Lis12-10">Listing 12-10</a>. This time we chain the <span class="SANS_TheSansMonoCd_W5Regular_11">start</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">stop</span> methods directly to the <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Loop</span> constructor.</p>
<span id="Lis12-11"/>
<pre><code><var>--snip--</var>
<span class="gray">  let synth = new Tone.Synth().toDestination();</span>
 
  new Tone.Loop(time =&gt; {
    synth.triggerAttackRelease("C4", "16n", time);
  }, "4n").start("0:0:0").stop("4:0:0");
  
<span class="gray">  Tone.Transport.start();</span>
<span class="gray">});</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-11: Looping with fewer lines of code</samp></p>
<p class="TX">With this notation, we don’t need to create a variable to hold the <span class="SANS_TheSansMonoCd_W5Regular_11">Tone .Loop</span> object, and we save a few lines of code by chaining the <span class="SANS_TheSansMonoCd_W5Regular_11">start</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">stop</span> methods. We’ll be using this pattern in the rest of this section.</p>
<p class="TX"><span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Loop</span> is basic, but it’s also quite versatile. You can run any arbitrary code in the callback, so you can do more than play the same note over and over. For example, you could choose to play a new random note each time. <a href="#Lis12-12">Listing 12-12</a> shows how you could generate a short piece of music by randomly playing notes from a pentatonic, or five-note, scale (I chose a pentatonic scale here because any combination of notes in a pentatonic scale tends to sound pleasing).</p>
<span id="Lis12-12"/>
<pre><code><var>--snip--</var>
<span class="gray">  Tone.start();</span>

<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> let synth = new Tone.PolySynth(
    Tone.Synth,
    {
      oscillator: { type: "triangle" },
      volume: -9
    }
  ).toDestination();

<span aria-label=" Page 220. " epub:type="pagebreak" id="pg_220" role="doc-pagebreak"/><span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> let notes = ["C4", "D4", "E4", "G4", "A4", "C5"];

  new Tone.Loop(time =&gt; {
    for (let i = 0; i &lt; 3; i++) {
    <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> if (Math.random() &lt; 0.5) {
      <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> let note = notes[Math.floor(Math.random() * notes.length)];
         synth.triggerAttackRelease(note, "32n", time);
      }
    }
  }, "8n").start("0:0:0").stop("8:0:0");

<span class="gray">  Tone.Transport.start();</span>
<span class="gray">});</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-12: Using Tone.Loop to generate random music</samp></p>
<p class="TX">For this example, we’re switching to a polysynth <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> so we can play multiple notes at once. The <span class="SANS_TheSansMonoCd_W5Regular_11">notes</span> array contains one octave of a C major pentatonic scale, including the C from the next octave <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Inside the <span class="SANS_TheSansMonoCd_W5Regular_11">Tone .Loop</span> callback, we use a <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop to run some code three times. Each time around, we call <span class="SANS_TheSansMonoCd_W5Regular_11">Math.random()</span> <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, which returns a random number between 0 and 1, to determine whether to play a note or not. If the value is less than 0.5, we play a note. Otherwise, that note is skipped. The note name is determined by picking a random index into the <span class="SANS_TheSansMonoCd_W5Regular_11">notes</span> array, using the code <span class="SANS_TheSansMonoCd_W5Regular_11">Math .floor(Math.random() * notes.length)</span> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Loop</span> object calls this code every eighth note (<span class="SANS_TheSansMonoCd_W5Regular_11">"8n"</span>) for eight bars (<span class="SANS_TheSansMonoCd_W5Regular_11">"0:0:0"</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">"8:0:0"</span>). The effect of all this is that every eighth note, up to three notes from the array will be played (there’s no guarantee of uniqueness, so the same note could be played two or three times at once, causing that note to be louder). For each of the three notes, there’s a one in two chance it will be played, so overall there’s a one in eight chance that no notes will be played on any given eighth note.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<aside aria-label="box-39" class="box" id="sec13">
<h4 class="BH" id="box-39"><samp class="SANS_Dogma_OT_Bold_B_11">WEB AUDIO API TIME</samp></h4>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Time in the Web Audio API, and by extension in Tone.js, can be tricky, because we’re working with two independent clocks: the JavaScript clock and the Web Audio API clock. The JavaScript clock is what we use when we call a function like</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span> <samp class="SANS_Futura_Std_Book_11">and tell it to execute another function some number of milliseconds in the future. Unfortunately, this clock isn’t very accurate: if you call</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span> <samp class="SANS_Futura_Std_Book_11">with a 100 ms timeout, the function may actually be called after 95 ms or 105 ms, and it may be delayed if the browser is busy doing something else. The Web Audio API, by contrast, has its own precise internal clock that keeps track of the number of seconds since the audio context was created. The current value of this clock is accessible through the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">currentTime</span> <samp class="SANS_Futura_Std_Book_11">property.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Using the Web Audio API’s clock, you can schedule a sound to play at exactly 8 seconds (from the time when the context was created) and to stop</samp> <span aria-label=" Page 221. " epub:type="pagebreak" id="pg_221" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Book_11">playing at 10 seconds, and you know that it will be played for exactly 2 seconds. Instead of trying to execute a JavaScript callback at a specific time, we’re using JavaScript to schedule future audio events, such as “start playing this oscillator at 8 seconds” and “stop playing this oscillator at 10 seconds.” Once these events have been scheduled, there’s no straightforward way to deschedule them. (Technically it’s possible, but it would entail keeping a list of all the notes that have not been played yet and telling them not to play.)</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Now, imagine that you’re writing a song using Tone.js and it’s made up of hundreds of notes all starting and stopping at different times. If you scheduled all these notes up front, there’d be no way to pause the song, jump to a specific point in time, or modify the song’s BPM. To fix this, Tone.js aims to schedule notes</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">just in time</samp><samp class="SANS_Futura_Std_Book_11">. For example, if you wanted to play a note at 12 seconds, Tone.js might aim to run the code that schedules the note when</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">ctx.currentTime</span> <samp class="SANS_Futura_Std_Book_11">is 11.8 seconds. Running the code for scheduling a note at an arbitrary time requires using the JavaScript clock, because the Web Audio API clock can’t be used to schedule code, just audio events.</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The target amount of time between when something is scheduled and when it’s executed is called the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">lookahead</samp><samp class="SANS_Futura_Std_Book_11">. In our example, we have a lookahead of 0.2 seconds. If the lookahead time is too short, then delays to the scheduling code could mean that the scheduled time is already in the past by the time the library is ready to schedule the notes. If the lookahead time is too long, then jumping around in the song or changing the BPM will be laggy. For a more detailed description of this problem, see Chris Wilson’s “A Tale of Two Clocks” at</samp> <a href="https://web.dev/audio-scheduling/"><samp class="SANS_Futura_Std_Book_Oblique_I_11">https://web.dev/audio-scheduling/</samp><samp class="SANS_Futura_Std_Book_11">.</samp></a></p>
</aside>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h4 class="H2" id="sec14"><span id="h2-74"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tone.Sequence</samp></h4>
<p class="TNI1">In this section we’ll look at another Tone.js helper, called <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sequence</span>. This lets you provide a list of note names to be scheduled to play at regular intervals. You can repeat the whole sequence as many times as you want. As an example, we’ll create a repeating pattern of four notes: a G4 followed by three C4s. Update <i>script.js</i> with the code in <a href="#Lis12-13">Listing 12-13</a>.</p>
<span id="Lis12-13"/>
<pre><code><var>--snip--</var>
<span class="gray">  Tone.start();</span>
 
  let synth = new Tone.Synth().toDestination();
 
  new Tone.Sequence(<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> (time, note) =&gt; {
    synth.triggerAttackRelease(note, "16n", time);
  }, <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> ["G4", "C4", "C4", "C4"], <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> "4n").start("0:0:0").stop("4:0:0");

<span class="gray">  Tone.Transport.start();</span>
<span class="gray">});</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-13: Creating a repeating sequence with Tone.Sequence</samp></p>
<p class="TX"><span aria-label=" Page 222. " epub:type="pagebreak" id="pg_222" role="doc-pagebreak"/>This is very similar to our first <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Loop</span> example (<a href="#Lis12-10">Listing 12-10</a>), but with two important changes. First, the callback function takes two arguments, <span class="SANS_TheSansMonoCd_W5Regular_11">time</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">note</span> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, instead of a single <span class="SANS_TheSansMonoCd_W5Regular_11">time</span> argument. Second, there’s an extra argument after the callback, which contains a list of notes <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Each time the callback is called, the next note in this list is passed as the <span class="SANS_TheSansMonoCd_W5Regular_11">note</span> argument. It will keep cycling through the notes in the list over and over until it’s time to stop. The third argument to <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sequence</span> gives the duration between each callback <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. In this case we’ve used <span class="SANS_TheSansMonoCd_W5Regular_11">"4n"</span>, which means that a new note will be played every quarter note.</p>
<p class="TX">When you run this example, you should hear a pattern play for 4 bars, with 4 beats per bar, making 16 notes in total. If we wrote out all the calls to <span class="SANS_TheSansMonoCd_W5Regular_11">synth.triggerAttackRelease</span> manually, instead of relying on <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sequence</span> to automate them, they would look like this:</p>

<pre><code>synth.triggerAttackRelease("G4", "16n", "0:0:0");
synth.triggerAttackRelease("C4", "16n", "0:1:0");
synth.triggerAttackRelease("C4", "16n", "0:2:0");
synth.triggerAttackRelease("C4", "16n", "0:3:0");
synth.triggerAttackRelease("G4", "16n", "1:0:0");
synth.triggerAttackRelease("C4", "16n", "1:1:0");
<var>--snip--</var>
</code></pre>
<p class="TX">Here, I’ve just replaced the <span class="SANS_TheSansMonoCd_W5Regular_11">note</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">time</span> arguments with what they would actually be for the first six calls of the callback. Notice how the second number is incrementing in the bars:quarters:sixteenths notation because of the <span class="SANS_TheSansMonoCd_W5Regular_11">"4n"</span> we used as the duration between callbacks. (In practice, however, <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sequence</span> passes <span class="SANS_TheSansMonoCd_W5Regular_11">time</span> as a number of seconds rather than using bars:quarters:sixteenths notation.)</p>
<p class="TX">If you want a sequence with some silent gaps (<i>rests</i> in musical terms), you can use <span class="SANS_TheSansMonoCd_W5Regular_11">null</span> in place of a note name in the array of note names. Modify <i>script.js</i> with the code in <a href="#Lis12-14">Listing 12-14</a> to see this in action.</p>
<span id="Lis12-14"/>
<pre><code><var>--snip--</var>
<span class="gray">  new Tone.Sequence((time, note) =&gt; {</span>
<span class="gray">    synth.triggerAttackRelease(note, "16n", time);</span>
  }, ["C4", null, "B3", "C4", "G3", "A3", null, "B3"], "8n")
    .start("0:0:0")
    .stop("4:0:0");

<span class="gray">  Tone.Transport.start();</span>
<span class="gray">});</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-14: Adding rests with</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">null</samp></p>
<p class="TX">Now we have a longer sequence of notes, with some <span class="SANS_TheSansMonoCd_W5Regular_11">null</span>s interspersed to insert pauses into the sequence. We’ve also changed the duration from <span class="SANS_TheSansMonoCd_W5Regular_11">"4n"</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">"8n"</span>, which means the notes will play twice as fast as before. When you play this updated example, you should hear a more interesting sequence of notes, including some rests.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<aside aria-label="box-40" class="box" id="sec15">
<h4 class="BH" id="box-40"><span aria-label=" Page 223. " epub:type="pagebreak" id="pg_223" role="doc-pagebreak"/><samp class="SANS_Dogma_OT_Bold_B_11">TRY IT YOURSELF</samp></h4>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">12-4.</samp><samp class="SANS_Futura_Std_Book_11">  Try writing a melody by modifying <a href="#Lis12-14">Listing 12-14</a> with your own notes. For example, you can write the beginning of “Twinkle, Twinkle, Little Star” using the notes C4, G4, and A4.</samp></p>
</aside>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h4 class="H2" id="sec16"><span id="h2-75"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tone.Part</samp></h4>
<p class="TNI1">The last of the transport helpers we’ll be looking at is <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Part</span>. This is the most flexible of the helpers, as it allows us to specify the exact timing of every note played. With <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Part</span>, instead of passing an array of note names, we pass an array of time/note pairs. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">[["0:0:0", "C4"], ["0:1:0", "D4"], ["0:1:2", "E4"]]</span> would play the three notes C4, D4, and E4 at the three times specified. This way, unlike with <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Loop</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sequence</span>, the notes don’t have to be played at equal time intervals. Also, by default <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Part</span> doesn’t loop, so the sequence of notes in the array is played only once. See the code in <a href="#Lis12-15">Listing 12-15</a> for an example.</p>
<span id="Lis12-15"/>
<pre><code><var>--snip--</var>
<span class="gray">  Tone.start();</span>
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> let synth = new Tone.PolySynth(Tone.Synth).toDestination();

  new Tone.Part((time, note) =&gt; {
  synth.triggerAttackRelease(note, "16n", time);
  }, [
    ["0:0:0", <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> ["C3", "E4"]],
    ["0:0:3", "D4"],
    ["0:1:0", "C4"],
    ["0:1:2", "D4"],
    ["0:2:0", ["E3", "E4"]],
    ["0:2:2", "E4"],
    ["0:3:0", "E4"],
    ["1:0:0", ["G3", "D4"]],
    ["1:0:2", "D4"],
    ["1:1:0", "D4"],
    ["1:2:0", ["E3", "E4"]],
    ["1:2:2", "G4"],
    ["1:3:0", "G4"]
<span aria-label="annotation3" class="CodeAnnotationCode">❸</span>]).start("0:0:0");

<span class="gray">  Tone.Transport.start();</span>
<span class="gray">});</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-15: Playing a melody with Tone.Part</samp></p>
<p class="TX">The first change we’re making here is to the synth <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This time we’re back to using a polyphonic synth, so we can play multiple notes at the same time. Other than the synth being different, the body of the callback function is the same. We’re still calling <span class="SANS_TheSansMonoCd_W5Regular_11">synth.triggerAttackRelease</span> and passing the <span class="SANS_TheSansMonoCd_W5Regular_11">note</span> <span aria-label=" Page 224. " epub:type="pagebreak" id="pg_224" role="doc-pagebreak"/>and <span class="SANS_TheSansMonoCd_W5Regular_11">time</span> parameters, which <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Part</span> will fill in automatically. Next comes the array of time/note pairs. You may notice that some of the notes are arrays themselves; for example, the first “note” in the list is <span class="SANS_TheSansMonoCd_W5Regular_11">["C3", "E4"]</span> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. This pair of notes will be passed to the <span class="SANS_TheSansMonoCd_W5Regular_11">triggerAttackRelease</span> method unchanged and will have the effect of playing two notes at once, just like our other polyphonic synth examples.</p>
<p class="TX">Finally, we call <span class="SANS_TheSansMonoCd_W5Regular_11">.start("0:0:0")</span> <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, which has the effect of playing this part immediately. If we used <span class="SANS_TheSansMonoCd_W5Regular_11">.start("1:0:0")</span> instead, for example, then the melody would start after a bar’s pause. The times given for each time/note pair are relative to the time passed to the <span class="SANS_TheSansMonoCd_W5Regular_11">start</span> method.</p>
<p class="TX">When you play this example, you should hear the beginning of “Mary Had a Little Lamb.”</p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<aside aria-label="box-41" class="box" id="sec17">
<h4 class="BH" id="box-41"><samp class="SANS_Dogma_OT_Bold_B_11">TRY IT YOURSELF</samp></h4>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">12-5.</samp><samp class="SANS_Futura_Std_Book_11">  See if you can extend the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Part</span> <samp class="SANS_Futura_Std_Book_11">code to finish the “Mary Had a Little Lamb” melody. Hint: the next seven notes are the same as the first seven notes, but two bars later, so you can copy them and change the bar number in the time from a</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> <samp class="SANS_Futura_Std_Book_11">to a</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">2</span><samp class="SANS_Futura_Std_Book_11">. Just be sure to add a comma after the last time/note pair in <a href="#Lis12-15">Listing 12-15</a> before adding more notes.</samp></p>
</aside>
</section>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h3 class="H1" id="sec18"><span id="h1-74"/><samp class="SANS_Futura_Std_Bold_B_11">Making Drum Sounds</samp></h3>
<p class="TNI1">Most electronic music has some kind of drum beat. The drum sounds used to make the beat can come from audio files, or they can be synthesized. We’re going to be using the latter technique here. The core of a drum beat is built around three components: the kick drum (a “boom” sound), the snare drum (a “bah” sound), and the hi-hat (a “ti” sound). In this section, you’ll learn techniques for synthesizing those sounds.</p>
<section aria-labelledby="sec19" epub:type="division">
<h4 class="H2" id="sec19"><span id="h2-76"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Hi-Hat Synthesis</samp></h4>
<p class="TNI1">A real-world hi-hat is made up of two cymbals facing each other. The top cymbal is connected to a pedal so the drummer can make the cymbals touch or move apart. We’re going for a closed (cymbals touching) sound here. When you hit closed hi-hats with a drum stick, they make a high-pitched noise that quickly fades away.</p>
<p class="TX">We’ll approximate this by using a different kind of synth, a <span class="SANS_TheSansMonoCd_W5Regular_11">NoiseSynth</span>, to generate white noise instead of notes with pitches. In signal processing, <i>white noise</i> is a random signal that has equal-level components at all frequencies. We’ll give the <span class="SANS_TheSansMonoCd_W5Regular_11">NoiseSynth</span> an amplitude envelope that simulates the abrupt attacks of hitting the hi-hat with a stick. Finally, we’ll pass the noise through a <i>filter</i>—a device that allows through some frequencies while <span aria-label=" Page 225. " epub:type="pagebreak" id="pg_225" role="doc-pagebreak"/>reducing the level of others—to remove the low frequencies and make it sound higher and more cymbal-like.</p>
<p class="TX">First, we’ll set up the <span class="SANS_TheSansMonoCd_W5Regular_11">NoiseSynth</span> and envelope, and play the hi-hat sound in a loop. Update your <i>script.js</i> with the code in <a href="#Lis12-16">Listing 12-16</a>.</p>
<span id="Lis12-16"/>
<pre><code><var>--snip--</var>
<span class="gray">  Tone.start();</span>

<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> let hiHat = new Tone.NoiseSynth({
    envelope: {
      attack: 0.001, decay: 0.1, sustain: 0, release: 0
    },
    volume: -6
  }).toDestination();

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> new Tone.Loop(time =&gt; {
    hiHat.triggerAttackRelease("16n", time);
  }, "8n").start("0:0:0").stop("4:0:0");

<span class="gray">  Tone.Transport.start();</span>
<span class="gray">});</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-16: The beginnings of a hi-hat sound</samp></p>
<p class="TX">We create a new <span class="SANS_TheSansMonoCd_W5Regular_11">NoiseSynth</span> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, passing an amplitude envelope and a volume of –6 dB. The envelope has a very short attack (1/1000 of a second) and a longer decay (1/10 of a second), which is supposed to mimic the amplitude envelope of a hi-hat being struck. Because <span class="SANS_TheSansMonoCd_W5Regular_11">sustain</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">release</span> are both set to <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, the sound will be over immediately after the initial attack and decay periods (0.001 + 0.1 s). In particular, the <span class="SANS_TheSansMonoCd_W5Regular_11">sustain</span> of <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> means the sound will sustain at 0 percent of its full volume, so even if the duration of the note is longer, you won’t hear anything after the attack and decay.</p>
<p class="TX">Next, we use <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Loop</span> to play a continuous stream of eighth-note hi-hats for four bars <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Note that the <span class="SANS_TheSansMonoCd_W5Regular_11">triggerAttackRelease</span> method on <span class="SANS_TheSansMonoCd_W5Regular_11">NoiseSynth</span> doesn’t take a note name, because noise doesn’t have any particular pitch. You have to specify only the duration and the time when the note should be played.</p>
<p class="TX">When you play this example, you should hear a stream of hi-hat sounds. It doesn’t sound great yet, because we haven’t added the filter. We’ll do that in <a href="#Lis12-17">Listing 12-17</a>.</p>
<span id="Lis12-17"/>
<pre><code><var>--snip--</var>
<span class="gray">  Tone.start();</span>

<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> let hiHatFilter = new Tone.Filter(15000, "bandpass").toDestination();

<span class="gray">  let hiHat = new Tone.NoiseSynth({</span>
<span class="gray">    envelope: {</span>
<span class="gray">      attack: 0.001, decay: 0.1, sustain: 0, release: 0</span>
<span class="gray">    },</span>
<span aria-label=" Page 226. " epub:type="pagebreak" id="pg_226" role="doc-pagebreak"/><span class="gray">    volume: -6</span>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span>}).connect(hiHatFilter);

<span class="gray">  new Tone.Loop(time =&gt; {</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-17: Applying a filter to the hi-hat sound</samp></p>
<p class="TX">First, we use <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Filter</span> to create a <i>bandpass filter</i> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This kind of filter lets through (“passes”) only the frequencies at or around a frequency of your choice. In this case, we tell the filter to pass the band of frequencies around 15,000 Hz, or 15 kHz, while eliminating all others. The human range of hearing is roughly 20 Hz to 20 kHz, so our filter lets through only parts of the noise that are very high in pitch.</p>
<p class="TX">In <a href="#Lis12-16">Listing 12-16</a>, we used <span class="SANS_TheSansMonoCd_W5Regular_11">toDestination()</span> on the <span class="SANS_TheSansMonoCd_W5Regular_11">NoiseSynth</span> to connect it directly to the output. In <a href="#Lis12-17">Listing 12-17</a>, we’re instead connecting the filter to the output <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, and then connecting the synth to the filter <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. This means that the synth’s sound is run through the filter before being output through your speakers or headphones. As a result, when you play this example you should hear the same hi-hat sounds, but limited to high frequencies only, which sounds a bit more like a real hi-hat.</p>
</section>
<section aria-labelledby="sec20" epub:type="division">
<h4 class="H2" id="sec20"><span id="h2-77"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Snare Synthesis</samp></h4>
<p class="TNI1">In this section we’ll synthesize a snare drum. A snare drum has a series of wires (known as the <i>snare</i>) resting against the bottom drumhead that rattle against the drumhead when the drum is hit. This gives it a relatively complex sound, composed of some noise and some more pitched sound. To mimic this, we’ll use two separate sound sources: a noise synth and a regular synth with a fixed frequency. Both will have a short amplitude envelope to create a percussive feel, and we’ll also pass the noise component of the sound through a bandpass filter to make the snare lower than the hi-hat. We’ll create a new <span class="SANS_TheSansMonoCd_W5Regular_11">Snare</span> class to encapsulate these details, as shown in <a href="#Lis12-18">Listing 12-18</a>.</p>
<span id="Lis12-18"/>
<pre><code><var>--snip--</var>
<span class="gray">  new Tone.Loop(time =&gt; {</span>
<span class="gray">    hiHat.triggerAttackRelease("16n", time);</span>
<span class="gray">  }, "8n").start("0:0:0").stop("4:0:0");</span>

  class Snare {
    constructor() {
    <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> this.noiseFilter = new Tone.Filter(5000, "bandpass").toDestination();
    <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> this.noiseSynth = new Tone.NoiseSynth({
        envelope: {
          attack: 0.001, decay: 0.1, sustain: 0, release: 0
        },
        volume: -12
      }).connect(this.noiseFilter);

<span aria-label=" Page 227. " epub:type="pagebreak" id="pg_227" role="doc-pagebreak"/>    <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> this.synth = new Tone.Synth({
        envelope: {
          attack: 0.0001, decay: 0.1, sustain: 0, release: 0
        },
        oscillator: {type: "sine"},
        volume: -12
      }).toDestination();
    }

  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> triggerAttackRelease(duration, when) {
      this.noiseSynth.triggerAttackRelease(duration, when);
      this.synth.triggerAttackRelease("G3", duration, when);
     }
    }

<span aria-label="annotation5" class="CodeAnnotationCode">❺</span> let snare = new Snare();

<span aria-label="annotation6" class="CodeAnnotationCode">❻</span> new Tone.Loop(time =&gt; {
    snare.triggerAttackRelease("16n", time);
  }, "2n").start("0:1:0").stop("4:0:0");

<span class="gray">  Tone.Transport.start();</span>
<span class="gray">});</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-18: Synthesizing a snare drum</samp></p>
<p class="TX">At a high level, the <span class="SANS_TheSansMonoCd_W5Regular_11">Snare</span> class has two methods, <span class="SANS_TheSansMonoCd_W5Regular_11">constructor</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">trigger AttackRelease</span>. The constructor creates a filter and two synths. The <span class="SANS_TheSansMonoCd_W5Regular_11">trigger AttackRelease</span> method calls the <span class="SANS_TheSansMonoCd_W5Regular_11">triggerAttackRelease</span> methods on the two synths to play them simultaneously.</p>
<p class="TX">In the constructor, we start by creating the filter <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and noise synth <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. This is very similar to how we created the hi-hat, except we use a frequency of 5,000 Hz for the bandpass filter, to reflect the lower sound of a snare drum. Next, we create the pitched synth <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, which uses a similar amplitude envelope to the noise synth but with an even shorter attack to simulate the sound of a snare drum (in a real snare drum, the snares are triggered by the vibration of the drum skin, so they lag behind the sound of the drum slightly). The synth is configured with a sine wave oscillator. Since we’ll be playing the two synths simultaneously, we give each one a volume of <span class="SANS_TheSansMonoCd_W5Regular_11">–12</span>, which results in an overall volume similar to the hi-hat.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">triggerAttackRelease</span> method <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> takes just a <span class="SANS_TheSansMonoCd_W5Regular_11">duration</span> and a <span class="SANS_TheSansMonoCd_W5Regular_11">when</span> parameter. These are passed to the underlying synths’ <span class="SANS_TheSansMonoCd_W5Regular_11">triggerAttackRelease</span> methods. When we trigger the pitched synth, we give it a note name of <span class="SANS_TheSansMonoCd_W5Regular_11">"G3"</span>, which is the pitch I decided to tune the snare to. The inclusion of the pitched synth is subtle but makes the drum sound a bit more realistic.</p>
<p class="TX">Next, we instantiate the class <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>, and finally we create a new <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Loop</span> object <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. This loop is four times as long as the hi-hat loop (<span class="SANS_TheSansMonoCd_W5Regular_11">"2n"</span> instead of <span class="SANS_TheSansMonoCd_W5Regular_11">"8n"</span>, or a half note instead of an eighth note) and starts after one quarter note. This means there will be a snare hit on the second and fourth beats of every bar. When you play this example, you should hear the hi-hat every eighth note and the snare every two quarter notes.</p>
</section>
<section aria-labelledby="sec21" epub:type="division">
<h4 class="H2" id="sec21"><span id="h2-78"/><span aria-label=" Page 228. " epub:type="pagebreak" id="pg_228" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Kick Synthesis</samp></h4>
<p class="TNI1">The last drum sound to synthesize is the kick drum. A kick drum is much larger than a snare drum, and it doesn’t have the rattling snare to make it sound noisy. The sound of a kick drum is fairly complex, but luckily Tone.js has a synth called a <span class="SANS_TheSansMonoCd_W5Regular_11">MembraneSynth</span> that mimics it quite well. This synth takes a regular oscillator and lowers its frequency over a short period of time, which ends up sounding a lot like a kick drum when set up correctly. <a href="#Lis12-19">Listing 12-19</a> shows how this is done.</p>
<span id="Lis12-19"/>
<pre><code><var>--snip--</var>
<span class="gray">  new Tone.Loop(time =&gt; {</span>
<span class="gray">    snare.triggerAttackRelease("16n", time);</span>
<span class="gray">  }, "2n").start("0:1:0").stop("4:0:0");</span>

  let kick = new Tone.MembraneSynth({
  <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> pitchDecay: 0.02,
    octaves: 6,
    volume: -9
  }).toDestination();

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> new Tone.Loop(time =&gt; {
    kick.triggerAttackRelease(50, "16n", time);
  }, "2n").start("0:0:0").stop("4:0:0");

<span class="gray">  Tone.Transport.start();</span>
<span class="gray">});</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-19: Synthesizing a kick drum</samp></p>
<p class="TX">The options for the <span class="SANS_TheSansMonoCd_W5Regular_11">MembraneSynth</span> include <span class="SANS_TheSansMonoCd_W5Regular_11">pitchDecay</span> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, which specifies in seconds how quickly the frequency should change, and <span class="SANS_TheSansMonoCd_W5Regular_11">octaves</span>, which specifies how many octaves to drop the frequency in that time. In our loop <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, we trigger the synth with a frequency of 50 Hz. This loop has the same <span class="SANS_TheSansMonoCd_W5Regular_11">"2n"</span> duration as the snare loop, but starting at time zero, which means that the kick and snare sounds will alternate every quarter note, giving a classic rock drum beat. When you play this example, you might recognize it as the basic drum pattern of a lot of songs.</p>
</section>
<section aria-labelledby="sec22" epub:type="division">
<h4 class="H2" id="sec22"><span id="h2-79"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reverb</samp></h4>
<p class="TNI1"><i>Reverb</i> (short for <i>reverberation</i>) is an effect that makes music sound like it’s being played in a room or larger enclosed space. The random echoes that real-world sounds make as they bounce around the walls of a room are what give this reverb effect. Reverb makes each sound take a little time to die away, and it will make our drums sound a bit more realistic. We can add reverb with <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Reverb</span>, as you’ll see in <a href="#Lis12-20">Listing 12-20</a>.</p>
<span id="Lis12-20"/>
<pre><code><var>--snip--</var>
<span class="gray">  Tone.start();</span>

  let reverb = new Tone.Reverb({
    decay: 1,
<span aria-label=" Page 229. " epub:type="pagebreak" id="pg_229" role="doc-pagebreak"/>    wet: 0.3
  }).toDestination();

  let hiHatFilter <span class="symbol">=</span> new Tone.Filter(15000, "bandpass").connect(reverb);

<span class="gray">  let hiHat = new Tone.NoiseSynth({</span>
<span class="gray">    envelope: {</span>
<span class="gray">      attack: 0.001, decay: 0.1, sustain: 0, release: 0</span>
<span class="gray">    },</span>
<span class="gray">    volume: -6</span>
<span class="gray">  }).connect(hiHatFilter);</span>

<span class="gray">  new Tone.Loop(time =&gt; {</span>
<span class="gray">    hiHat.triggerAttackRelease("16n", time);</span>
<span class="gray">  }, "8n").start("0:0:0").stop("4:0:0");</span>

<span class="gray">  class Snare {</span>
<span class="gray">    constructor() {</span>
      this.noiseFilter <span class="symbol">=</span> new Tone.Filter(5000, "bandpass").connect(reverb);
<span class="gray">      this.noiseSynth =</span><span class="gray"> new Tone.NoiseSynth({</span>
<span class="gray">        envelope: {</span>
<span class="gray">          attack: 0.001, decay: 0.1, sustain: 0, release: 0</span>
<span class="gray">        },</span>
<span class="gray">        volume: -12</span>
<span class="gray">      }).connect(this.noiseFilter);</span>

<span class="gray">      this.synth = new Tone.Synth({</span>
<span class="gray">        envelope: {</span>
<span class="gray">          attack: 0.0001, decay: 0.1, sustain: 0, release: 0</span>
<span class="gray">        },</span>
<span class="gray">        oscillator: {type: "sine"},</span>
<span class="gray">        volume: -12</span>
      }).connect(reverb);
<span class="gray">    }</span>

<span class="gray">    triggerAttackRelease(duration, when) {</span>
<span class="gray">      this.noiseSynth.triggerAttackRelease(duration, when);</span>
<span class="gray">      this.synth.triggerAttackRelease("G3", duration, when);</span>
<span class="gray">    }</span>
<span class="gray">  }</span>

<span class="gray">  let snare =</span><span class="gray"> new Snare();</span>

<span class="gray">  new Tone.Loop(time =&gt; {</span>
<span class="gray">    snare.triggerAttackRelease("16n", time);</span>
<span class="gray">  }, "2n").start("0:1:0").stop("4:0:0");</span>

<span class="gray">  let kick = new Tone.MembraneSynth({</span>
<span class="gray">    pitchDecay: 0.02,</span>
<span class="gray">    octaves: 6,</span>
<span class="gray">    volume: -9</span>
  }).connect(reverb);

<span aria-label=" Page 230. " epub:type="pagebreak" id="pg_230" role="doc-pagebreak"/>  <span class="gray">new Tone.Loop(time =&gt; {</span>
<span class="gray">    kick.triggerAttackRelease(50, "16n", time);</span>
<span class="gray">  }, "2n").start("0:0:0").stop("4:0:0");</span>

<span class="gray">  Tone.Transport.start();</span>
<span class="gray">});</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-20: Adding reverb</samp></p>
<p class="TX">First we create our <span class="SANS_TheSansMonoCd_W5Regular_11">Reverb</span> effect. The <span class="SANS_TheSansMonoCd_W5Regular_11">decay</span> setting describes how long (in seconds) the reverberation will continue after the sound stops. The higher this number, the more echoey the effect. The <span class="SANS_TheSansMonoCd_W5Regular_11">wet</span> setting specifies how much of the reverb sound is passed through compared with the original sound. In this case, <span class="SANS_TheSansMonoCd_W5Regular_11">0.3</span> means that the output of this effect will be 30 percent reverb and 70 percent the original sound. The higher the <span class="SANS_TheSansMonoCd_W5Regular_11">wet</span> setting, the more prominent the reverb effect will be.</p>
<p class="TX">The rest of the changes in <a href="#Lis12-20">Listing 12-20</a> replace any instances of <span class="SANS_TheSansMonoCd_W5Regular_11">toDestination()</span> with <span class="SANS_TheSansMonoCd_W5Regular_11">connect(reverb)</span>. This way all the drum sounds are passed through the reverb effect before the reverb effect is sent to the output. When you play this example, the drums should sound more like they’re being played in a room. You can make the effect more pronounced by increasing the value of <span class="SANS_TheSansMonoCd_W5Regular_11">wet</span> (to <span class="SANS_TheSansMonoCd_W5Regular_11">0.6</span>, say) or by increasing the <span class="SANS_TheSansMonoCd_W5Regular_11">decay</span> in the <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Reverb</span> settings.</p>
</section>
<section aria-labelledby="sec23" epub:type="division">
<h4 class="H2" id="sec23"><span id="h2-80"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Drum Loop</samp></h4>
<p class="TNI1">Now that we have our drum sounds set up, it would be nice to have an easier way to trigger them. Ideally, we would want to create a drum pattern by writing something like this:</p>

<pre><code>kick:  x…x…
snare: ..x…x.
hiHat: xxxxxxxx
</code></pre>
<p class="BodyContinued">Then we can let JavaScript do the work of converting that notation into code that Tone.js can understand. Here, each <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> represents a note, each dot (<span class="SANS_TheSansMonoCd_W5Regular_11">.</span>) represents a silence, and each column represents an eighth note. For example, in the first eighth note the kick and hi-hat play, in the second only the hi-hat plays, in the third the snare and hi-hat play, and so on. The pattern shown here matches the drum beat we built up in the previous sections.</p>
<p class="TX">To accomplish this, we’ll make a helper function that will convert a string of <span class="SANS_TheSansMonoCd_W5Regular_11">x</span>’s and dots into an array of values that the <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sequence</span> transport helper can use. Recall that <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sequence</span> takes an array of note names and plays them repeatedly in sequence, with <span class="SANS_TheSansMonoCd_W5Regular_11">null</span> being used for rests. Our function should convert dots to <span class="SANS_TheSansMonoCd_W5Regular_11">null</span>s, while leaving <span class="SANS_TheSansMonoCd_W5Regular_11">x</span>’s the same.</p>
<blockquote>
<p class="NOTE"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>Since drum sounds don’t have note names, any string can actually represent a drum hit to <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sequence</span> (we’re just using x’s for convenience). All that matters is that it isn’t <span class="SANS_TheSansMonoCd_W5Regular_11">null</span>.</i></p>
<p class="TX"><span aria-label=" Page 231. " epub:type="pagebreak" id="pg_231" role="doc-pagebreak"/><a href="#Lis12-21">Listing 12-21</a> shows the definition of this function. Add it to your <i>script.js</i> file, before the current drum code.</p>
<span id="Lis12-21"/>
<pre><code><var>--snip--</var>
<span class="gray">  Tone.start();</span>

  // Converts a string to an array of notes or null.
  // Dots in the string become nulls in the array and are silent.
  function mkSequence(pattern) {
    return pattern.split(" ").map(value =&gt; {
      if (value == ".") {
        return null;
      } else {
        return value;
      }
    });
  }

<span class="gray">  let reverb = new Tone.Reverb({</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-21: The mkSequence helper function</samp></p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">mkSequence</span> function takes a string like <span class="SANS_TheSansMonoCd_W5Regular_11">"x…x…"</span> and converts it to an array of strings and <span class="SANS_TheSansMonoCd_W5Regular_11">null</span>s, like <span class="SANS_TheSansMonoCd_W5Regular_11">["x", null, null, null, "x", null, null, null]</span>, which is the format we need for <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sequence</span>. It splits the string into an array of individual characters using the <span class="SANS_TheSansMonoCd_W5Regular_11">split</span> method and uses the array <span class="SANS_TheSansMonoCd_W5Regular_11">map</span> method to create a new array by calling a function for each character. If the character is <span class="SANS_TheSansMonoCd_W5Regular_11">"."</span>, then it replaces it with a <span class="SANS_TheSansMonoCd_W5Regular_11">null</span> in the new array. Otherwise, it passes the character through unchanged.</p>
<p class="TX">Next, we’ll create the strings that will be passed into this function, as shown in <a href="#Lis12-22">Listing 12-22</a>. Add this code after the <span class="SANS_TheSansMonoCd_W5Regular_11">mkSequence</span> function definition.</p>
<span id="Lis12-22"/>
<pre><code><var>--snip--</var>
  }

  let drumPattern = {
    kick:  "x…x…",
    snare: "..x…x.",
    hiHat: "xxxxxxxx",
  };

  <span class="gray">let reverb = new Tone.Reverb({</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-22: Defining drumPattern</samp></p>
<p class="TX">We’re storing the three strings in an object called <span class="SANS_TheSansMonoCd_W5Regular_11">drumPattern</span> to keep them organized. I’ve added spaces to line up the strings so it’s easier to see the pattern.</p>
<p class="TX">Finally, we’ll use the helper and <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sequence</span> in place of our three existing calls to <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Loop</span>, as shown in <a href="#Lis12-23">Listing 12-23</a>.</p>
<span id="Lis12-23"/>
<pre><code><span aria-label=" Page 232. " epub:type="pagebreak" id="pg_232" role="doc-pagebreak"/>--<var>snip</var>--
<span class="gray">  }).connect(hiHatFilter);</span>

  new Tone.Sequence(time =&gt; {
    hiHat.triggerAttackRelease("16n", time);
  }, mkSequence(drumPattern.hiHat), "8n").start("0:0:0").stop("4:0:0");

  <span class="gray">class Snare {</span>
--<span class="TheSansMonoCd_W5Regular_Italic_I_11">snip</span>--
<span class="gray">  let snare = new Snare();</span>

   new Tone.Sequence(time =&gt; {
    snare.triggerAttackRelease("16n", time);
  }, mkSequence(drumPattern.snare), "8n").start("0:0:0").stop("4:0:0");

<span class="gray">  let kick = new Tone.MembraneSynth({</span>
<span class="gray">    pitchDecay: 0.02,</span>
<span class="gray">    octaves: 6,</span>
<span class="gray">    volume: -9</span>
<span class="gray">  }).connect(reverb);</span>

   new Tone.Sequence(time =&gt; {
    kick.triggerAttackRelease(50, "16n", time);
  }, mkSequence(drumPattern.kick), "8n").start("0:0:0").stop("4:0:0");

<span class="gray">  Tone.Transport.start();</span>
<span class="gray">});</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-23: Using mkSequence with Tone.Sequence</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in place of Tone.Loop</samp></p>
<p class="TX">Here, we replace each of the <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Loop</span> calls with the new <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sequence</span> calls. In each case we call <span class="SANS_TheSansMonoCd_W5Regular_11">mkSequence</span>, passing one of the strings from our <span class="SANS_TheSansMonoCd_W5Regular_11">drumPattern</span> object, which will create an array of <span class="SANS_TheSansMonoCd_W5Regular_11">x</span>’s and <span class="SANS_TheSansMonoCd_W5Regular_11">null</span>s. The result of this call is passed to the <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sequence</span> helper, which we use to trigger the appropriate drum sounds. Again, <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sequence</span> will interpret any string, such as <span class="SANS_TheSansMonoCd_W5Regular_11">"x"</span>, as an appropriate note name for a drum hit, while the <span class="SANS_TheSansMonoCd_W5Regular_11">null</span>s represent silences. The last argument to <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sequence</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">"8n"</span>, means that each dot or <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> in the drum pattern string represents an eighth note.</p>
<p class="TX">If you now reload the page, you should hear the same drum beat as before. This might seem like a lot of work to get the same output, but now we have a lot more flexibility to write different drum patterns, and we can easily modify them as we see fit. Try adding some extra snare or kick notes to the strings in <span class="SANS_TheSansMonoCd_W5Regular_11">drumPattern</span> to see how it sounds.</p>
</section>
</section>
<section aria-labelledby="sec24" epub:type="division">
<h3 class="H1" id="sec24"><span id="h1-75"/><samp class="SANS_Futura_Std_Bold_B_11">Working with Samples</samp></h3>
<p class="TNI1">An important part of electronic music is <i>sampling</i>: using snippets of existing audio to build up a new piece of music. One common technique is to modify the playback speed of the samples to change their pitch, so a single sample can be used for multiple notes. If you’ve ever sped up a recording of someone’s voice to make them sound high-pitched like a chipmunk, or slowed it down to make them sound low-pitched like a giant, it’s the same principle.</p>
<p class="TX"><span aria-label=" Page 233. " epub:type="pagebreak" id="pg_233" role="doc-pagebreak"/>Tone.js makes it easy to work with samples with the <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sampler</span> instrument. This instrument acts a lot like the synths we’ve seen so far, in that it has a <span class="SANS_TheSansMonoCd_W5Regular_11">triggerAttackRelease</span> method that lets you play a certain note at a certain time. The difference is that instead of using an oscillator or noise generator as a source, it plays a snippet of an audio file, possibly pitch-shifted to the requested pitch.</p>
<p class="TX">To avoid any issues of copyright, I’ve sourced some samples from a free online sample database, <a href="https://freesound.org"><i>https://<wbr/>freesound<wbr/>.org</i></a>. I’ve reuploaded them to Amazon S3 (Simple Storage Service) in such a way that you can access them directly from your code without having to download them (if you want to know the technical details, the files are in a public S3 bucket with CORS headers enabling access from any origin). The samples are of three different trumpet notes, and are found at the following URLs:</p>
<ul class="ul">
<li class="BL"><a href="https://skilldrick-jscc.s3.us-west-2.amazonaws.com/trumpet-c5.mp3"><i>https://<wbr/>skilldrick<wbr/>-jscc<wbr/>.s3<wbr/>.us<wbr/>-west<wbr/>-2<wbr/>.amazonaws<wbr/>.com<wbr/>/trumpet<wbr/>-c5<wbr/>.mp3</i></a></li>
<li class="BL"><a href="https://skilldrick-jscc.s3.us-west-2.amazonaws.com/trumpet-d5.mp3"><i>https://<wbr/>skilldrick<wbr/>-jscc<wbr/>.s3<wbr/>.us<wbr/>-west<wbr/>-2<wbr/>.amazonaws<wbr/>.com<wbr/>/trumpet<wbr/>-d5<wbr/>.mp3</i></a></li>
<li class="BL"><a href="https://skilldrick-jscc.s3.us-west-2.amazonaws.com/trumpet-f5.mp3"><i>https://<wbr/>skilldrick<wbr/>-jscc<wbr/>.s3<wbr/>.us<wbr/>-west<wbr/>-2<wbr/>.amazonaws<wbr/>.com<wbr/>/trumpet<wbr/>-f5<wbr/>.mp3</i></a></li>
</ul>
<p class="BodyContinued">If you enter any of these URLs into your web browser, the sample should play automatically.</p>
<p class="TX">Let’s see how to load these samples into a new <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sampler</span> object. Tone.js lets you load all your samples from external URLs, such as our three S3 URLs, which we do in <a href="#Lis12-24">Listing 12-24</a>. Insert the new sampler code at the end of <i>script.js</i>.</p>
<span id="Lis12-24"/>
<pre><code><var>--snip--</var>
<span class="gray">  new Tone.Sequence(time =&gt; {</span>
<span class="gray">    kick.triggerAttackRelease(50, "16n", time);</span>
<span class="gray">  }, mkSequence(drumPattern.kick), "8n").start("0:0:0").stop("4:0:0");</span>

  // Samples from freesound.org:
  // https://freesound.org/people/MTG/sounds/357432/
  // https://freesound.org/people/MTG/sounds/357336/
  // https://freesound.org/people/MTG/sounds/357546/
  const sampler = new Tone.Sampler({
    urls: {
      "C5": "trumpet-c5.mp3",
      "D5": "trumpet-d5.mp3",
      "F5": "trumpet-f5.mp3"
    },
    baseUrl: "https://skilldrick-jscc.s3.us-west-2.amazonaws.com/",
    attack: 0,
    release: 1,
    volume: -24,
    onload: () =&gt; {
      sampler.triggerAttackRelease(["C5", "E5", "G5"], "1n", 0);
    }
  }).toDestination();

<span class="gray">  Tone.Transport.start();</span>
<span class="gray">}); </span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-24: Creating a sampler</samp></p>
<p class="TX"><span aria-label=" Page 234. " epub:type="pagebreak" id="pg_234" role="doc-pagebreak"/>We create the sampler by passing a configuration object to the <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sampler</span> constructor. In this example, the configuration object contains five properties. The first property, <span class="SANS_TheSansMonoCd_W5Regular_11">urls</span>, contains an object mapping note names to filenames. For example, we’re saying that the note name C5 corresponds to the filename <i>trumpet-c5.mp3</i>. Next, <span class="SANS_TheSansMonoCd_W5Regular_11">baseUrl</span> defines the shared prefix of all the URLs, which saves us from having to write out the full URL for each sample. All the URLs are in the same S3 bucket, so we can use that as the base URL and then just provide the filenames in <span class="SANS_TheSansMonoCd_W5Regular_11">urls</span>.</p>
<p class="TX">The sampler instrument doesn’t apply a full ADSR envelope when it plays samples, but it does allow you to set the <span class="SANS_TheSansMonoCd_W5Regular_11">attack</span> (fade-in speed) and <span class="SANS_TheSansMonoCd_W5Regular_11">release</span> (fade-out speed). We use an instant attack (because the sample already has its own attack), and a long release of one second. We also set <span class="SANS_TheSansMonoCd_W5Regular_11">volume</span> to –24 dB so the sampler isn’t too loud. Finally, the <span class="SANS_TheSansMonoCd_W5Regular_11">onload</span> property allows us to specify what happens once all the samples have been downloaded. In this example, we call <span class="SANS_TheSansMonoCd_W5Regular_11">triggerAttackRelease</span> to play a three-note chord. Note that <span class="SANS_TheSansMonoCd_W5Regular_11">Tone.Sampler</span> is by default polyphonic, so it can play multiple samples at once.</p>
<p class="TX">When you play this example, you’ll still hear the drums. Once the samples load, you should also hear a C major chord played by the trumpet sampler. One interesting thing to note here is that although we provided a sample for the note C5, we didn’t provide one for E5 or G5, the other pitches in the C major chord. When we tell the sampler to play these notes, it picks the closest provided sample and shifts its pitch by changing the playback speed. For instance, the closest sample to G5 has a pitch of F5, so this sample will be sped up slightly to sound like G5 instead. As long as the note we’re trying to play isn’t too far away from one of the provided samples, it will sound fine. If we push it too far, however, the result won’t sound as realistic. For example, try raising the notes an octave by setting them to C6, E6, and G6 instead. They’ll start to sound a bit silly now. Also, because the samples are being played back twice as fast, they’re half the duration, so they won’t last the full bar they’re supposed to (the higher notes will finish earlier because they’re played back faster). You can also go the other way and set the notes to C4, E4, and G4. This time the duration won’t be a problem, since the samples are being played slower in order to shift them down in pitch, but the notes still won’t sound as realistic.</p>
</section>
<section aria-labelledby="sec25" epub:type="division">
<h3 class="H1" id="sec25"><span id="h1-76"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>
<p class="TNI1">In this chapter you learned about making sounds and music using the Web Audio API, and you saw how using a library like Tone.js can make your life much easier by hiding a lot of the lower-level details. You also learned a lot of tricks for sound synthesis and sampling using the Tone.js library. If some of the musical details went over your head, don’t worry. The most important thing here was getting used to working with a new JavaScript API and library. We’ll be putting all this to use in the next chapter, where we’ll write an actual song using the instruments created in this chapter!</p>
</section>
</section>
</body>
</html>