<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch00"><span epub:type="pagebreak" id="page_xxi"/><strong>INTRODUCTION</strong></h2>&#13;
<div class="image1"><img src="../images/pg23_Image_2.jpg" alt="Image" width="191" height="190"/></div>&#13;
<p class="noindentz">This book introduces the concepts of how computer hardware works from a programmer’s point of view. The hardware is controlled by a set of <em>machine instructions</em>. The way these instructions control the hardware is called the <em>instruction set architecture (ISA)</em>. A programmer’s job is to design a sequence of these instructions that causes the hardware to perform operations to solve a problem.</p>&#13;
<p class="indent">Nearly all computer programs are written in a high-level language. Some of these languages are general-purpose, and others are geared toward specific applications. But they are all intended to provide a programmer with a set of programming constructs more suitable for solving problems in human terms than working directly with the ISA and the details of the hardware.</p>&#13;
<h3 class="h3" id="ch00lev1sec1"><strong>Who This Book Is For</strong></h3>&#13;
<p class="noindent">Have you ever wondered what’s going on “under the hood” when you write a program in a high-level language? You know that computers can be programmed to make decisions, but how do they do that? You probably know that data is stored in bits, but what does that mean when storing a decimal <span epub:type="pagebreak" id="page_xxii"/>number? My goal in this book is to answer these and many other questions about how computers work. We’ll be looking at both the hardware components and the machine-level instructions used to control the hardware.</p>&#13;
<p class="indent">I’ll assume that you know the basics of how to program in a high-level language, but you don’t need to be an expert programmer. After discussing the hardware components, we’ll look at and write lots of programs in <em>assembly language</em>, the language that translates directly into machine instructions.</p>&#13;
<p class="indent">Writing in assembly language is a tedious, error-prone, time-consuming process, so it should be avoided whenever possible. The best language for most programming projects on a Raspberry Pi is Python, which is included with Raspberry Pi OS and has excellent support for electronics projects. Python is very good at isolating us from the tedium of writing in assembly language. However, our goal here is to study programming concepts, not to create applications, so we’ll mainly be using C as our high-level language.</p>&#13;
<h3 class="h3" id="ch00lev1sec2"><strong>About This Book</strong></h3>&#13;
<p class="noindent">The guidelines I followed in creating this book are:</p>&#13;
<ul>&#13;
<li class="noindent">Learning is easier if it builds on concepts you already know.</li>&#13;
<li class="noindent">Real-world hardware and software make a more interesting platform for learning theoretical concepts.</li>&#13;
<li class="noindent">The tools used for learning should be inexpensive and readily available.</li>&#13;
</ul>&#13;
<h4 class="h4" id="ch00lev2sec1"><em><strong>The Programming in the Book</strong></em></h4>&#13;
<p class="noindent">This book is based on the AArch64 architecture, which is the 64-bit version of the ARM architecture. It supports both the 64-bit A64 and 32-bit A32 instruction sets.</p>&#13;
<p class="indent">All the programming in the book was done using the GNU programming environment running under the 64-bit Raspberry Pi OS. All the programs have been tested on both my Raspberry Pi 3 and my Raspberry Pi 5. <a href="ch20.xhtml">Chapter 20</a> includes a section on assembly language programming of the general-purpose input/output (GPIO) pins on the Raspberry Pi 5, which differs significantly from earlier Raspberry Pi models.</p>&#13;
<p class="indent">Because Python is so good at isolating us from the computer’s ISA, we’re using C as our high-level language, with some C++ in <a href="ch18.xhtml">Chapter 18</a>. The GNU programming tools make it easy for us to see how C and C++ use the ISA. Don’t worry if you don’t know C/C++; all our C/C++ programming will be very simple, and I’ll explain what you need to know as we go.</p>&#13;
<p class="indent">An important issue arises when learning assembly language: using the keyboard and terminal screen in an application. Programming input from a keyboard and output to a screen is complex, well beyond the expertise of a beginner. The GNU programming environment includes the C standard library. In keeping with the “real-world” criterion of this book, we’ll use the <span epub:type="pagebreak" id="page_xxiii"/>functions in that library, which are easily called from assembly language, to use the keyboard and screen in our applications.</p>&#13;
<h4 class="h4" id="ch00lev2sec2"><em><strong>Why Read This Book?</strong></em></h4>&#13;
<p class="noindent">Given that there are many excellent high-level languages that allow you to write programs without being concerned with how machine instructions control the hardware, you may wonder why you should learn the material in this book. All high-level languages are ultimately translated into machine instructions that control the hardware. Understanding what the hardware does and how the instructions control it helps you understand the capabilities and limitations of the computer. I believe this understanding can make you a better programmer, even when you are working with a high-level language.</p>&#13;
<p class="indent">There are many other reasons to learn assembly language, though. If your interests take you into <em>systems programming</em>—writing parts of an operating system, writing a compiler, or even designing another higher-level language—these endeavors typically require an understanding at the assembly language level. And if your primary interest is in the hardware, I think it’s important to understand how a program will use that hardware.</p>&#13;
<p class="indent">There are also many challenging opportunities in programming <em>embedded systems</em>, or systems in which the computer has a dedicated task. These systems form integral parts of our daily lives: think cell phones, home appliances, automobiles, HVAC systems, medical devices, and more. Embedded systems are an essential component of Internet of Things (IoT) technologies. Programming them often requires an understanding of how the computer interacts with various hardware devices at the assembly language level.</p>&#13;
<p class="indent">Finally, if you already know assembly language for another processor, this book will serve as a primer for reading the ARM manuals.</p>&#13;
<h4 class="h4" id="ch00lev2sec3"><em><strong>Chapter Organization</strong></em></h4>&#13;
<p class="noindent">The book is roughly organized into three parts, focusing on mathematics and logic, hardware, and software. The mathematics and logic part is intended to give you the necessary language to discuss the concepts. The hardware part is an introduction to the components used to construct a computer.</p>&#13;
<p class="indent">These first two parts provide the background for discussing how software controls the hardware. We’ll look at each of the basic programming constructs in the C programming language, with some C++ toward the end of the book. Then we’ll look at how the compiler translates the C/C++ code into assembly language. I’ll also show you how a programmer might program the same constructs directly in assembly language.</p>&#13;
<p class="noindentin"><strong><a href="ch01.xhtml">Chapter 1: Setting the Stage</a></strong>   Describes the three fundamental subsystems of a computer and how they’re connected. This chapter also discusses setting up the programming tools used in the book.<span epub:type="pagebreak" id="page_xxiv"/></p>&#13;
<p class="noindentin"><strong><a href="ch02.xhtml">Chapter 2: Data Storage Formats</a></strong>   Shows how unsigned integers are stored using the binary and hexadecimal number systems and how characters are stored in ASCII code. In this chapter, we’ll write our first C program and use the <span class="literal">gdb</span> debugger to explore these concepts.</p>&#13;
<p class="noindentin"><strong><a href="ch03.xhtml">Chapter 3: Computer Arithmetic</a></strong>   Describes the addition and subtraction of unsigned and signed integers and explains the limits of using a fixed number of bits to represent integers.</p>&#13;
<p class="noindentin"><strong><a href="ch04.xhtml">Chapter 4: Boolean Algebra</a></strong>   Describes Boolean algebra operators and functions and discusses function minimization using algebraic tools and Karnaugh maps.</p>&#13;
<p class="noindentin"><strong><a href="ch05.xhtml">Chapter 5: Logic Gates</a></strong>   Begins with an introduction to electronics, then discusses logic gates and how they’re built using complementary metal-oxide semiconductor (CMOS) transistors.</p>&#13;
<p class="noindentin"><strong><a href="ch06.xhtml">Chapter 6: Combinational Logic Circuits</a></strong>   Discusses logic circuits that have no memory, including adders, decoders, multiplexers, and programmable logic devices.</p>&#13;
<p class="noindentin"><strong><a href="ch07.xhtml">Chapter 7: Sequential Logic Circuits</a></strong>   Discusses clocked and unclocked logic circuits that maintain a memory, as well as circuit design using state transition tables and state diagrams.</p>&#13;
<p class="noindentin"><strong><a href="ch08.xhtml">Chapter 8: Memory</a></strong>   Describes the memory hierarchy (cloud, mass storage, main memory, cache, and CPU registers) and discusses memory hardware designs for registers, SRAM, and DRAM.</p>&#13;
<p class="noindentin"><strong><a href="ch09.xhtml">Chapter 9: Central Processing Unit</a></strong>   Gives an overview of CPU subsystems. This chapter also explains the instruction execution cycle and the main A64 registers and shows how to view register contents in the <span class="literal">gdb</span> debugger.</p>&#13;
<p class="noindentin"><strong><a href="ch10.xhtml">Chapter 10: Programming in Assembly Language</a></strong>   Looks at the minimal C function, both as compiler-generated assembly language and as written directly in assembly language. This chapter covers assembler directives and first instructions. I give an example of using the text user interface of <span class="literal">gdb</span> as a learning tool.</p>&#13;
<p class="noindentin"><strong><a href="ch11.xhtml">Chapter 11: Inside the</a></strong>   <span class="codestrong">main</span> <strong>Function</strong>   Describes passing arguments in registers, position-independent code, and use of the call stack for passing the return address and automatic local variables.</p>&#13;
<p class="noindentin"><strong><a href="ch12.xhtml">Chapter 12: Instruction Details</a></strong>   Looks at how instructions are coded at the bit level. This chapter also discusses how addresses needed by instructions are computed, as well as algorithms of assembler and linker programs.</p>&#13;
<p class="noindentin"><strong><a href="ch13.xhtml">Chapter 13: Control Flow Constructs</a></strong>   Covers assembly language implementation of program flow control with <span class="literal">while</span>, <span class="literal">do-while</span>, <span class="literal">for</span>, <span class="literal">if-else</span>, and <span class="literal">switch</span> constructs.<span epub:type="pagebreak" id="page_xxv"/></p>&#13;
<p class="noindentin"><strong><a href="ch14.xhtml">Chapter 14: Inside Subfunctions</a></strong>   Describes how functions access external variables (global, pass by value, pass by pointer, and pass by reference) and summarizes the structure of the stack frame.</p>&#13;
<p class="noindentin"><strong><a href="ch15.xhtml">Chapter 15: Special Uses of Subfunctions</a></strong>   Shows how recursion works. This chapter discusses using assembly language to access CPU hardware features that are not directly accessible in high-level languages, using a separate function or inline assembly.</p>&#13;
<p class="noindentin"><strong><a href="ch16.xhtml">Chapter 16: Bitwise Logic, Multiplication, and Division Instructions</a></strong>   Describes bit masking, shifting bits, and the multiplication and division instructions.</p>&#13;
<p class="noindentin"><strong><a href="ch17.xhtml">Chapter 17: Data Structures</a></strong>   Explains how arrays and records (<span class="literal">struct</span>s) are implemented and accessed in a program at the assembly language level.</p>&#13;
<p class="noindentin"><strong><a href="ch18.xhtml">Chapter 18: Object-Oriented Programming</a></strong>   Shows how <span class="literal">struct</span>s are used as objects in C++.</p>&#13;
<p class="noindentin"><strong><a href="ch19.xhtml">Chapter 19: Fractional Numbers</a></strong>   Describes fixed-point and floating-point numbers, the IEEE 754 standard, and a few A64 floating-point instructions.</p>&#13;
<p class="noindentin"><strong><a href="ch20.xhtml">Chapter 20: Input/Output</a></strong>   Compares I/O with memory and bus timing, describes memory-mapped I/O, and shows how to program the GPIO on the Raspberry Pi, both in C and in assembly language. This chapter also gives a rough sketch of polled I/O programming and discusses interrupt-driven and direct memory access I/O.</p>&#13;
<p class="noindentin"><strong><a href="ch21.xhtml">Chapter 21: Exceptions and Interrupts</a></strong>   Briefly describes how AArch64 handles exceptions and interrupts. The chapter includes an example of using the <span class="literal">svc</span> instruction to do system calls without using the C runtime environment.</p>&#13;
<h3 class="h3" id="ch00lev1sec3"><strong>Efficient Use of This Book</strong></h3>&#13;
<p class="noindent">I’ve organized this book in such a way that you should be able to learn the material efficiently by following a few simple guidelines.</p>&#13;
<p class="indent">Many sections have “Your Turn” exercises at the end that give you the opportunity to practice working with the material presented in the main body of the section. These are intended as exercises, not tests. I have provided answers and my solutions to most of them online, at <em><a href="https://rgplantz.github.io">https://rgplantz.github.io</a></em>. If you are an instructor using this book, sorry, you will have to make up your own exam questions! Many of the exercises have fairly obvious extensions that instructors can use to create class assignments.<span epub:type="pagebreak" id="page_xxvi"/></p>&#13;
<p class="indent">To make efficient use of these exercises, I recommend an iterative process:</p>&#13;
<ol>&#13;
<li class="noindent">Try to solve the problem on your own. Spend some time on it, but don’t let yourself get stuck for too long.</li>&#13;
<li class="noindent">If the answer doesn’t come to you, peek at my solution. In some cases, I give a hint before providing the full solution.</li>&#13;
<li class="noindent">Return to step 1, armed with some knowledge of how an experienced assembly language programmer might approach the solution.</li>&#13;
</ol>&#13;
<p class="indent">One thing I strongly urge you to do is type the code in yourself. This physical activity will help you to learn the material faster. If nothing else, it forces you to read every character in the code. There is no advantage to copying and pasting code from my online solutions; frankly, none of the programs in this book have any real-world usefulness. The code is provided for your own exercising, so please use it in that spirit.</p>&#13;
<p class="indent">This hands-on approach also applies to the mathematics in the first few chapters, which includes converting numbers between several number bases. Any good calculator will do that easily, but the actual conversion is not the point. The point is to learn how data values can be represented in bit patterns, and using paper and pencil to work through the arithmetic will help you get a feel for these patterns.</p>&#13;
<p class="indent">We’ll start in <a href="ch01.xhtml">Chapter 1</a> by taking a high-level overview of the major subsystems of a computer. Then I’ll describe how I set up the programming environment on my two Raspberry Pis, a 3 and a 5, to create and run the programs in this book.</p>&#13;
</div>
</div>
</body></html>