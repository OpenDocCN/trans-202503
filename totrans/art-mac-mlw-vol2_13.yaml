- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 10 PERSISTENCE ENUMERATOR
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10 持久化枚举器
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'In early 2014, a close friend begged me for help disinfecting his Mac. When
    I plopped myself in front of his screen, I saw obvious signs of a rampant adware
    infection: flagrant browser pop-ups, as well as a hijacked home page. Even worse,
    resetting his browser didn’t work; it reverted to its infected state upon each
    reboot, suggesting the presence of a persistent component buried somewhere deep
    within the system.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 2014 年初，一位亲密的朋友请求我帮忙清除他 Mac 上的病毒。当我坐到他屏幕前时，我看到明显的广告软件感染迹象：大量的浏览器弹窗，以及被劫持的首页。更糟糕的是，重置浏览器并不起作用；每次重启后，浏览器都会恢复到感染状态，这表明系统中有一个持久化组件深藏其中。
- en: At the time, I was an experienced Windows malware analyst just beginning my
    foray into the world of macOS. Naively, I thought I could download a tool capable
    of enumerating all persistent software installed on the system to reveal the malicious
    component. Well-known security tools, such as Microsoft’s AutoRuns,^([1](#chapter10-1))
    provided such a capability for Windows systems, but I soon discovered nothing
    similar existed for Macs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当时，我是一名经验丰富的 Windows 恶意软件分析师，刚刚开始涉足 macOS 的世界。天真地，我以为可以下载一个能够列出系统中所有持久化软件的工具来揭示恶意组件。像微软的
    AutoRuns 这样的知名安全工具提供了类似功能，适用于 Windows 系统，但我很快发现，Mac 上并没有类似的工具。
- en: I returned home and spent the next few days putting together a Python script
    that, while embarrassingly ugly, was capable of enumerating several types of persistent
    software. Running the script revealed an unrecognized launch agent on my friend’s
    computer that turned out to be the core persistent component of the adware. Once
    I removed it, his Mac was as good as new.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我回到家后，花了几天时间编写了一个 Python 脚本，尽管它丑得令人尴尬，但却能够列出几种类型的持久化软件。运行脚本后，我发现了一个未被识别的启动代理，最终证明它是广告软件的核心持久化组件。一旦我将其移除，他的
    Mac 就恢复如新。
- en: Realizing that my script could benefit other Mac users, I cleaned it up and
    released it under the moniker KnockKnock.^([2](#chapter10-2)) (Why KnockKnock?
    Because it tells you who’s there!) Today, KnockKnock has evolved greatly from
    its beginnings as a humble command line script. Now distributed as a native macOS
    application, it’s capable of detecting a myriad of persistently installed items
    on any macOS system. Coupled with an intuitive user interface (UI), integration
    with VirusTotal, and the ability to export its findings for ingestion into security
    information and event management (SIEM), it’s the first tool I run on any Mac
    that I suspect is infected.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 意识到我的脚本可以帮助其他 Mac 用户，我整理了一下并发布了它，命名为 KnockKnock。^([2](#chapter10-2))（为什么叫 KnockKnock？因为它告诉你“谁在那儿！”）如今，KnockKnock
    从最初的简单命令行脚本发展到了一个功能强大的工具。现在作为原生 macOS 应用程序分发，它能够检测任何 macOS 系统上持久安装的各种项目。配合直观的用户界面（UI）、与
    VirusTotal 的集成以及将结果导出用于安全信息和事件管理（SIEM）的功能，它是我在怀疑 Mac 可能感染时首先运行的工具。
- en: In this chapter, I’ll walk through KnockKnock’s design and implemen- tation
    to give you an in-depth look at the tool and expand your understand-ing of the
    persistence methods that Mac malware often does (or could) abuse. In the process,
    we’ll go beyond the detection mechanism discussed in [Chapter 5](chapter5.xhtml),
    which focused solely upon the Background Task Management database, to look at
    other ways of persisting on macOS, including browser extensions and dynamic library
    hijacks. You can find the complete source code on Objective-See’s GitHub page
    in the KnockKnock repository at [*https://<wbr>github<wbr>.com<wbr>/Objective<wbr>-see<wbr>/KnockKnock*](https://github.com/Objective-see/KnockKnock).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍 KnockKnock 的设计和实现，带你深入了解这个工具，并扩展你对 macOS 恶意软件常用（或可能使用）的持久化方法的理解。在这个过程中，我们将超越[第5章](chapter5.xhtml)中讨论的仅关注背景任务管理数据库的检测机制，探索其他在
    macOS 上持久化的方式，包括浏览器扩展和动态库劫持。你可以在 Objective-See 的 GitHub 页面上的 KnockKnock 仓库中找到完整的源代码，链接地址是
    [*https://<wbr>github<wbr>.com<wbr>/Objective<wbr>-see<wbr>/KnockKnock*](https://github.com/Objective-see/KnockKnock)。
- en: Tool Design
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具设计
- en: KnockKnock is a standard UI-based application (as shown in [Figure 10-1](chapter10.xhtml#fig10-1)),
    but users can also execute it in the terminal as a command line tool.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: KnockKnock 是一个标准的基于 UI 的应用程序（如[图 10-1](chapter10.xhtml#fig10-1)所示），但用户也可以在终端中将其作为命令行工具执行。
- en: '![](../images/Figure10-1.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-1.jpg)'
- en: 'Figure 10-1: KnockKnock’s user interface'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-1：KnockKnock 的用户界面
- en: As this isn’t a book about writing UIs (thank goodness!), I won’t delve into
    the code related to KnockKnock’s UI. Instead, I focus mainly on its core components,
    such as its many plug-ins responsible for querying various aspects of the operating
    system to enumerate persistently installed items.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Command Line Options
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code for any Objective-C program starts at the standard main function, and
    KnockKnock is no exception. In its main function, KnockKnock begins by checking
    its program arguments to determine whether it should display its usage information
    or perform a command line scan ([Listing 10-1](chapter10.xhtml#Lis10-1)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 10-1: Parsing command line options'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be familiar with accessing a program’s command line arguments via
    the main function’s argv. Objective-C supports this approach, but we can also
    access the arguments via the arguments array of the processInfo property in the
    NSProcessInfo class. This technique has several advantages, most notably that
    it converts the arguments into Objective-C objects. This means, for example, that
    we can use the containsObject: method to easily determine whether the user has
    specified a certain command line argument regardless of the order of the arguments.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: To determine whether to run a command line scan, KnockKnock checks if the user
    specified the -whosthere command line option. If so, it invokes its cmdlineScan
    function to perform a scan of the system, printing out information about persistently
    installed items directly to the terminal.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Plug-ins
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because malware can persist on macOS in many ways and researchers discover new
    methods from time to time, KnockKnock’s design relies on the concept of what I’ll
    refer to as plug-ins. Each plug-in corresponds to one type of persistence and
    implements the logic to enumerate items of that persistence type. The plug-ins
    then call into other parts of KnockKnock to perform actions such as displaying
    each item in the UI. This modular approach provides a simple and efficient way
    to add support for new persistence techniques. For example, after the researcher
    Csaba Fitzl published the blog post “Beyond the Good Ol’ LaunchAgents -32- Dock
    Tile Plugins,” which detailed a new persistence strategy involving macOS Dock
    plug-ins,^([3](#chapter10-3)) I added a corresponding detection to KnockKnock
    via a new plug-in within the hour.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Each of KnockKnock’s plug-ins inherits from a custom plug-in base class named
    PluginBase, which declares properties common to all plug-ins, as well as base
    methods. Found in *PluginBase.h*, it includes plug-in metadata, such as a name
    and a description, and arrays that the plug-in populates as it encounters persisting
    items ([Listing 10-2](chapter10.xhtml#Lis10-2)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 10-2: The base plug-in class’s properties'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The class also declares various base methods ([Listing 10-3](chapter10.xhtml#Lis10-3)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 10-3: The base plug-in class’s methods'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Each plug-in must implement the scan method with logic to enumerate one type
    of persistent item. For example, the Background Task Management plug-in will parse
    the Background Task Management database to extract persistent items managed by
    the Background Task Management subsystem, while the Browser Extension plug-in
    will enumerate installed browsers and, for each, extract any installed browser
    extensions. If researchers uncover a new persistence mechanism, we can trivially
    add a new plug-in with a scan method capable of enumerating items that persist
    in this new way.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个插件必须实现一个扫描方法，逻辑是枚举一种持久项类型。例如，背景任务管理插件将解析背景任务管理数据库，以提取由背景任务管理子系统管理的持久项，而浏览器扩展插件将枚举已安装的浏览器，并为每个浏览器提取已安装的浏览器扩展。如果研究人员发现了一种新的持久性机制，我们可以轻松地添加一个新的插件，并提供一个能够枚举以这种新方式持久存在的项的扫描方法。
- en: The base class’s scan method throws an exception if called directly ([Listing
    10-4](chapter10.xhtml#Lis10-4)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果直接调用，基类的扫描方法将抛出异常（[列表 10-4](chapter10.xhtml#Lis10-4)）。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 10-4: The base scan method will throw an exception if called.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-4：如果调用，基础扫描方法将抛出异常。
- en: This design allows KnockKnock to easily invoke each plug-in’s scan method without
    having to know anything about how each plug-in actually enumerates persistent
    items of its specific type. The class provides base implementations for the other
    two methods, reset and processItem:, though plug-ins can override them if needed.
    (Otherwise, the plug-in will just call the base class’s implementation.)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计使得 KnockKnock 能够轻松调用每个插件的扫描方法，而无需了解每个插件如何实际枚举其特定类型的持久项。该类为其他两个方法（reset 和
    processItem:）提供了基础实现，尽管插件可以根据需要重写这些方法。（否则，插件将仅调用基类的实现。）
- en: 'Both methods affect the application’s UI. For example, when performing a UI
    scan, the reset method handles situations in which a user stops and then restarts
    a scan, while the processItem: method updates the UI as plug-ins uncover persistent
    items. During a command line scan, the processItem: method will still keep track
    of detected items and print each one to the terminal once the scan completes ([Listing
    10-5](chapter10.xhtml#Lis10-5)).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都会影响应用程序的用户界面。例如，在执行 UI 扫描时，重置方法处理用户暂停后重新启动扫描的情况，而`processItem:`方法会在插件发现持久项时更新
    UI。在命令行扫描过程中，`processItem:`方法仍会跟踪检测到的项，并在扫描完成后将每个项打印到终端（[列表 10-5](chapter10.xhtml#Lis10-5)）。
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 10-5: Updating a global list of persistent items'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-5：更新持久项的全局列表
- en: KnockKnock declares a static list of all plug-ins by their class name. Later,
    the code iterates over this list, instantiating each plug-in ([Listing 10-6](chapter10.xhtml#Lis10-6)).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: KnockKnock 声明了一个静态插件列表，按其类名排序。随后，代码会遍历此列表，为每个插件实例化一个对象（[列表 10-6](chapter10.xhtml#Lis10-6)）。
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 10-6: Initializing each plug-in by name'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-6：通过名称初始化每个插件
- en: 'For each plug-in class name, KnockKnock invokes the NSClassFromString API,
    which obtains a plug-in class based on the given name.^([4](#chapter10-4)) Then
    it invokes the class’s alloc method to allocate an instance of the class (in other
    words, to create an object). Next, it invokes the newly created object’s init
    method to allow the plug-in object to perform any initializations ❶. We’ll consider
    some initialization examples shortly. Although not shown here, KnockKnock will
    then invoke each of the plug-in’s scan methods.  #### Persistent Item Types'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个插件类名，KnockKnock 会调用 `NSClassFromString` API，根据给定的名称获取插件类。^([4](#chapter10-4))
    然后，它调用类的 `alloc` 方法来分配该类的实例（换句话说，就是创建一个对象）。接下来，它会调用新创建的对象的 `init` 方法，以允许插件对象执行任何初始化操作
    ❶。我们稍后将考虑一些初始化示例。虽然这里没有展示，但 KnockKnock 接着会调用每个插件的扫描方法。#### 持久项类型
- en: 'KnockKnock assigns one of three types to persistent items: file, command, or
    browser extension. Most persisted items are executable files, such as scripts
    or Mach-O binaries. However, as in the case of cron jobs, malware sometimes persists
    as a command; other times, it persists as a bundle of files and resources in the
    form of a browser extension. It’s important for KnockKnock to correctly classify
    items, as each type has unique characteristics. For example, a persistent file
    might have extractable code signing information to help us classify it. We can
    also hash such files to check for known malware.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The three item types are subclasses of a custom ItemBase class, shown in [Listing
    10-7](chapter10.xhtml#Lis10-7).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 10-7: The interface for the ItemBase class'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: This base class declares various properties, such as the plug-in that discovered
    the item, the item’s name, and its path. Not all item types set every property.
    For example, commands don’t have paths, whereas files and extensions do. The ItemBase
    class also implements base methods to initialize an item, return its path to show
    it in the Finder app, and convert it to JSON. Although objects that inherit from
    this base class can reimplement each method if they need to, the base class’s
    implementation may suffice.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Once a plug-in’s scan method completes, it stores any discovered items in a
    plug-in property called allItems. In a command line scan, KnockKnock converts
    each persistent item to JSON and appends it to a string that it prints out ([Listing
    10-8](chapter10.xhtml#Lis10-8)).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 10-8: Converting persistent items to JSON'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Each item type implements its own logic to convert the information collected
    about a persistent item to JSON. Let’s take a look at the implementation of the
    toJSON method for items whose type is File ([Listing 10-9](chapter10.xhtml#Lis10-9)).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 10-9: Converting File object properties to JSON'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the code makes use of the NSJSONSerialization class’s dataWithJSONObject:options:error:
    method to convert various dictionaries into JSON. These dictionaries include the
    item’s code signing information ❶ and hashes ❷. The method also converts numeric
    values from VirusTotal scan results ([Listing 10-10](chapter10.xhtml#Lis10-10)).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 10-10: Computing a detection ratio based on scan results from VirusTotal'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Technically, KnockKnock itself doesn’t include logic to detect malicious code;
    it merely enumerates persistently installed items. This is by design, as it allows
    KnockKnock to detect new persistent malware even with no direct a priori knowledge
    of it. However, KnockKnock’s integration with VirusTotal allows it to flag already
    known malware by submitting a POST request with a hash of each persistent item
    to a VirusTotal query API. This API returns basic detection information, such
    as how many antivirus engines scanned the items and how many of those engines
    flagged it as malicious. KnockKnock converts this data into a string ratio of
    the form *positive detections*/*antivirus engines* and then displays this result
    in the UI or command line output.^([5](#chapter10-5))
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，KnockKnock 本身不包含检测恶意代码的逻辑；它仅仅是枚举持久安装的项目。这是设计使然，因为它允许 KnockKnock 即使没有事先了解新恶意软件，也能检测到新的持久化恶意软件。然而，KnockKnock
    与 VirusTotal 的集成使它能够通过向 VirusTotal 查询 API 提交每个持久化项目的哈希值，标记已知的恶意软件。该 API 返回基本的检测信息，例如有多少病毒扫描引擎扫描了这些项目，并且有多少引擎将其标记为恶意。KnockKnock
    将这些数据转换为字符串比率，格式为 *正面检测*/*病毒扫描引擎*，然后将结果显示在用户界面或命令行输出中。^([5](#chapter10-5))
- en: The toJSON method finishes by building a single string object that combines
    the converted dictionaries, formatted numerical values, and all other properties
    of the item object ([Listing 10-11](chapter10.xhtml#Lis10-11)).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: toJSON 方法最终构建一个单一的字符串对象，将转换后的字典、格式化的数值以及项目对象的所有其他属性组合在一起（[列表 10-11](chapter10.xhtml#Lis10-11)）。
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 10-11: Building a JSON-ified string'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-11：构建一个 JSON 字符串
- en: 'It returns this string to the caller to print out. For example, on a system
    infected with the persistent DazzleSpy malware, KnockKnock would display the following
    JSON in the terminal:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它将这个字符串返回给调用者进行打印。例如，在一个被持久化的 DazzleSpy 恶意软件感染的系统上，KnockKnock 会在终端显示以下 JSON：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The output shows several red flags pointing to the fact that this item is likely
    malicious. For example, it’s running from a hidden directory (*.local*), and while
    it claims to be an Apple software updater, its signature status is -67062, which
    maps to the errSecCSUnsigned constant. What conclusively identifies this item
    as malware, though, is the VirusTotal detection ratio, which shows that roughly
    half of the antivirus engines on the site flagged it as malicious.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了几个红旗，表明这个项目很可能是恶意的。例如，它运行于一个隐藏的目录（*.local*），虽然它声称是一个 Apple 软件更新程序，但它的签名状态为
    -67062，这与 errSecCSUnsigned 常量对应。然而，最能确认为恶意软件的标志是 VirusTotal 的检测比率，显示大约一半的病毒扫描引擎将其标记为恶意。
- en: Exploring the Plug-ins
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索插件
- en: KnockKnock has approximately 20 plug-ins to detect a myriad of persistent items,
    including items stored in Background Task Management, browser extensions, cron
    jobs, dynamic library inserts and proxies, kernel extensions, launch items, login
    items, Spotlight importers, system extensions, and many more. Although I won’t
    cover every plug-in here, I’ll dive into a few of them and provide examples of
    the malware they can detect.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: KnockKnock 约有 20 个插件，用于检测各种持久化项目，包括存储在后台任务管理中的项目、浏览器扩展、cron 作业、动态库插入和代理、内核扩展、启动项、登录项、Spotlight
    导入器、系统扩展等。尽管我不会在这里覆盖每个插件，但我会深入探讨其中的一些，并提供它们能检测到的恶意软件示例。
- en: '#### Background Task Management'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 后台任务管理'
- en: In [Chapter 5](chapter5.xhtml), we explored the undocumented Background Task
    Manage-ment subsystem, which macOS leverages to govern and track persistent items
    such as launch agents, daemons, and login items. Through reverse engineering,
    I showed you how to deserialize the items managed by the subsystem, which could
    include persistently installed malware. We then created an open source library
    that I dubbed *DumpBTM*, which is available on GitHub ([*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/DumpBTM*](https://github.com/objective-see/DumpBTM)).
    To enumerate persistently installed launch and login items, KnockKnock leverages
    this library.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](chapter5.xhtml)中，我们探讨了未文档化的后台任务管理子系统，该子系统被 macOS 用于管理和跟踪持久化项目，如启动代理、守护进程和登录项。通过逆向工程，我向你展示了如何反序列化由该子系统管理的项目，这些项目可能包括持久安装的恶意软件。随后，我们创建了一个开源库，名为*DumpBTM*，它可以在
    GitHub 上找到（[*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/DumpBTM*](https://github.com/objective-see/DumpBTM)）。为了枚举持久安装的启动项和登录项，KnockKnock
    利用了这个库。
- en: NOTE
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*In Xcode, you can link in a library under your project’s Build Phases tab.
    There, expand Link Binary With Libraries, click* **+***, and then browse to the
    library.*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: After linking in the *DumpBTM* library, KnockKnock’s Background Task Management
    plug-in can directly invoke its exported APIs, such as its parseBTM function.
    The function takes a path to a Background Task Management file (or nil, to default
    to the system’s file) and returns a dictionary containing deserialized metadata
    about each persistent item managed by Background Task Management. [Listing 10-12](chapter10.xhtml#Lis10-12)
    shows a snippet of the code in the plug-in’s scan method.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 10-12: Calling into the DumpBTM library'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'This code makes use of the @available Objective-C keyword to ensure that the
    plug-in executes only on versions 13 and newer of macOS (as the Background Task
    Management subsystem doesn’t exist on earlier versions). KnockKnock then iterates
    over the metadata for each persistent item returned by the *DumpBTM* library’s
    parseBTM function and, for each, instantiates a File item object. It does this
    by invoking the File class’s initWithParams: method, which accepts a dictionary
    of values for the object, including a path and, for launch items, the property
    list.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Note that the code explicitly checks for a property list, as some persistent
    items in the Background Task Management database, such as login items, won’t contain
    one ([Listing 10-13](chapter10.xhtml#Lis10-13)). This is an important check, as
    inserting a nonexistent (nil) item into a dictionary will cause your program to
    crash.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 10-13: Creating a dictionary of parameters to initialize a File object'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'With an initialized File object in hand, KnockKnock’s Background Task Management
    plug-in can now invoke the base plug-in class’s processItem: method to trigger
    a refresh of the UI or, in a command line scan, add the item to the list of items
    persistently installed on the system.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the *DumpBTM* library, KnockKnock can easily enumerate all persistent
    items managed by the subsystem. In the following output, you can see the tool
    displaying details of the cyber-espionage implant WindTail, which persists an
    app named *Final_Presentation.app* as a login item:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Many antivirus engines on VirusTotal now flag the malware, and a check of its
    signature returns -2147409652, which maps to the “certificate revoked” constant,
    CSSMERR_TP_CERT_REVOKED. However, KnockKnock would have shown the presence of
    the persistent item even before the antivirus engines on VirusTotal developed
    signatures for it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, no external library can enumerate many of KnockKnock’s other
    classes of persistence, so we’ll have to write more code ourselves. One example
    is the browser extension plug-in, which we’ll look at now.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Browser Extension
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most macOS adware installs a malicious browser extension to hijack search results,
    display ads, or even intercept browser traffic. Common examples of such adware
    include Genieo, Yontoo, and Shlayer.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Because no macOS APIs can enumerate installed browser extensions, KnockKnock
    must do so itself. Worse, as each browser manages its extensions in its own way,
    KnockKnock must implement specific enumeration code for each. Currently, the tool
    supports extension enumeration for Safari, Chrome, Firefox, and Opera browsers.
    In this section, we’ll cover the code specific to Safari.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: To list the installed browsers, KnockKnock uses relatively unknown Launch Services
    APIs ([Listing 10-14](chapter10.xhtml#Lis10-14)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 10-14: Obtaining a list of installed browsers using Launch Services
    APIs'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: The code invokes the LSCopyAllHandlersForURLScheme API with the URL scheme https
    ❶, which returns an array containing the bundle IDs of applications capable of
    handling that scheme. The code then invokes the LSFindApplicationForInfo API to
    map each ID to an application path ❷, saving these into an array that it returns
    to the caller.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'In macOS 12, Apple added the URLsForApplicationsToOpenURL: method to the NSWorkspace
    class to return all applications capable of opening a specified URL. Invoking
    this method with a URL to a web page will return a list of all installed browsers.
    For newer versions of macOS, KnockKnock makes use of this API ([Listing 10-15](chapter10.xhtml#Lis10-15)).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 10-15: Obtaining a list of installed browsers with the URLsForApplicationsToOpenURL:
    method'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code to enumerate Safari browser extensions in the scanExtensionsSafari:
    method of KnockKnock’s browser extension plug-in. In [Listing 10-16](chapter10.xhtml#Lis10-16),
    the code invokes this method with Safari’s location, found using the previous
    code.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 10-16: Invoking Safari-specific logic to enumerate its extensions'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The location of Safari’s browser extensions has changed over the years; you
    could find them in the *~/Library/Safari/Extensions* directory until Apple decided
    to move them into the keychain. Older versions of KnockKnock tried to keep up
    with these changes, but now, it uses a simpler method: executing the macOS pluginkit
    utility ([Listing 10-17](chapter10.xhtml#Lis10-17)).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 10-17: Enumerating installed Safari extensions'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The -m argument finds all plug-ins that match the search criteria specified
    in the -p argument; the -A argument returns all versions of the installed plug-ins,
    rather than just the highest version; and -vv returns verbose output that includes
    the display name and parent bundle. For the -p argument, we first use com.apple.Safari.extension,
    then com.apple.Safari.content-blocker. This ensures that we enumerate both traditional
    extensions and content blocker extensions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'We execute pluginkit in a helper function we’ve named execTask (discussed in
    [Chapter 1](chapter1.xhtml)), which simply launches the specified program along
    with any specified arguments and returns the output to the caller. Try running
    pluginkit yourself to enumerate the Safari extensions installed on your Mac. In
    the following output, you can see that I’ve installed an ad blocker:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Leveraging this external binary has the downside of introducing a dependency
    and the need to parse its output, but it’s still the most reliable option. There
    are many ways to parse any output. In [Listing 10-18](chapter10.xhtml#Lis10-18),
    KnockKnock takes the approach of extracting each extension’s name, path, and UUID.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 10-18: Parsing output containing installed Safari extensions'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The parsing code separates the output line by line, then splits each line into
    key-value pairs using an equal sign (*=*) as a delimiter. This will, for example,
    split the line Path = /Applications/Adblock Plus.app/Contents/PlugIns/Adblock
    Plus Toolbar.appex into the key Path and a value containing the path to the installed
    ad blocker extension. The code then extracts key-value pairs of interest, such
    as the path, name, and UUID.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Using the path to the extension, we load its *Info.plist* file and extract a
    description of the extension from the NSHumanReadableDescription key ([Listing
    10-19](chapter10.xhtml#Lis10-19)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 10-19: Initializing an Extension object for each extension'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we create a KnockKnock browser Extension item object with the collected
    extension metadata.  #### Dynamic Library Insertion'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: A malware sample known as Flashback shattered the notion that Apple’s operating
    system was immune to malware.^([6](#chapter10-6)) Flashback exploited an unpatched
    vulnerability capable of automatically infecting users who browsed to a malicious
    website. Discovered in 2012, it amassed more than half a million victims, making
    it the most successful Mac malware at the time.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Flashback also persisted in a novel and stealthy manner. On an infected system,
    the malware gained user-assisted persistence by subverting Safari’s *Info.plist*
    file and inserting the following dictionary under a key named LSEnvironment:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The dictionary’s DYLD_INSERT_LIBRARIES key contains a string pointing to the
    malicious library *UnHackMeBuild*. Safari will load this library into the browser
    when launched, where the malware could stealthily execute.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Today, Apple has mostly mitigated dylib insertions via the DYLD_INSERT_LIBRARIES
    environment variable and other approaches. The dynamic loader now ignores these
    variables in a wide range of cases, such as for platform binaries or for applications
    compiled with the hardened runtime.^([7](#chapter10-7)) However, programs supporting
    third-party plug-ins, especially on older versions of macOS, may still be at risk.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: As such, KnockKnock contains a plug-in to detect this type of subversion. It
    scans launch items and applications, checking for the presence of a DYLD_INSERT_LIBRARIES
    entry. For launch items, this entry lives under the EnvironmentVariables key in
    their property list file, and for applications, you can find it under a key named
    LSEnvironment in the app’s *Info.plist* file, as we saw with Flashback. Because
    legitimate items rarely make use of persistent DYLD_INSERT_LIBRARIES insertions,
    you should closely examine any that you uncover.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Other plug-ins require a similar list of all launch items and applications,
    so KnockKnock produces this list in a global enumerator. Let’s briefly look at
    how KnockKnock tackles such enumeration, focusing on the case of installed apps,
    as there are multiple ways to list these items on a Mac. The least recommended
    is to manually enumerate bundles found in the common application directories (such
    as */Applications*), as you’d have to take into account subdirectories such as
    */Applications/Utilities/*, as well as user- specific applications. Plus, applications
    could be installed in other locations.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: A Stack Overflow post suggests better options.^([8](#chapter10-8)) These include
    leveraging the lsregister utility to list all applications that have been registered
    with Launch Services, using the mdfind utility or related Spotlight APIs to list
    all applications indexed by macOS, or making use of the macOS system_profiler
    utility to obtain a list of applications known to the operating system’s software
    configuration.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'KnockKnock opts for the system_profiler approach. The tool can output XML or
    JSON, which is easy to programmatically ingest and parse. Here is an example of
    XML output, along with the metadata for an instance of KnockKnock installed on
    my computer:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: KnockKnock executes system_profiler via the execTask helper function discussed
    earlier in this chapter ([Listing 10-20](chapter10.xhtml#Lis10-20)).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 10-20: Installed applications enumerated via system_profiler'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Once this helper function returns ❶, KnockKnock serializes the XML output into
    an Objective-C object ❷, then saves the list of applications found under the _items
    key into an instance variable aptly named applications ❸.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Now that KnockKnock’s global enumerator has obtained a list of applications
    (and launch items, although I didn’t show this logic here), the dylib insertion
    plug-in can scan each, looking for the addition of the DYLD_INSERT_LIBRARIES environment
    variable. [Listing 10-21](chapter10.xhtml#Lis10-21) shows this implementation
    in a method called scanApplications.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 10-21: Enumerating applications containing an inserted environment
    variable'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'The code iterates over all apps found by the global enumerator ❶. For each,
    it uses the application’s path to load the application’s bundle ❷, which has useful
    metadata about the application. This includes the contents of the app’s *Info.plist*
    file, which we can access through the bundle object’s infoDictionary property.
    After extracting the path to the *Info.plist* file ❸, it uses the key LSEnvironment
    to extract the dictionary containing specific environment variables ❹. Of course,
    most apps won’t set any environment variables, so the code skips these. However,
    for those that have the DYLD_INSERT_LIBRARIES key set, the code extracts its value:
    a path to the library inserted each time the application is run ❺. In Flashback,
    which subverted Safari, recall that the key-value pair looks like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, the code in the plug-in creates and processes a File item object representing
    the inserted library, saving it to the list of persistent items uncovered by KnockKnock
    to then print to the terminal or display in the UI.  #### Dynamic Library Proxying
    and Hijacking'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The last plug-in I’ll cover in this chapter detects two other persistence mechanisms
    that make use of dynamic libraries. *Dylib proxying* replaces a library on which
    a target process depends with a malicious library. Whenever the target application
    starts, the malicious dynamic library loads and runs as well. To keep the application
    from losing legitimate functionality, it proxies requests to and from the original
    library.^([9](#chapter10-9))
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Closely related to dylib proxying is *dylib hijacking*, which exploits the fact
    that the loader may look for dependencies in multiple locations. Malware could
    take advantage of this behavior by tricking the loader into using a malicious
    dependency instead of a legitimate one. Although malware doesn’t commonly abuse
    this technique, the post-exploitation agent EmPyre supports it as a persistence
    mechanism.^([10](#chapter10-10)) Dynamic libraries that perform such hijacking
    also proxy requests to keep from breaking legitimate functionality.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: To detect either technique, KnockKnock generates a list of dynamic libraries,
    then checks each for an LC_REEXPORT_DYLIB load command that loads and proxies
    requests to the original library. While this load command is legitimate, benign
    libraries rarely use it, so we should closely examine any that do.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there isn’t a simple way to list all dynamic libraries installed
    on a macOS system, so KnockKnock focuses on those that are currently open or loaded
    by running processes. This approach isn’t as comprehensive as a scan of the entire
    system, but then again, any persisted malware is probably running somewhere.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: To build a list of loaded libraries, KnockKnock runs the lsof utility to list
    all open files on the system, then filters out everything but executables. If
    a dynamic library has been loaded somewhere, there should be an open file handle
    to it, which lsof can enumerate.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'While getting a list of open files is fairly simple, determining whether a
    file is executable isn’t as easy as you might expect. You can’t just look for
    files whose extension is *.dylib* because that list wouldn’t include frameworks,
    which are technically libraries but don’t normally end in *.dylib*. For example,
    take a look at the *Electron* framework. The file command reports that it is indeed
    a dynamic library, though its extension isn’t *.dylib*:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Another strategy might be to check which of the open files are binaries by
    checking the file’s executable bit, but this would include scripts and other random
    files on macOS, such as certain archives (which, as we can see here, have the
    executable bit, x, set):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: While you could manually parse each file, looking for a universal or Mach-O
    magic value, it turns out an Apple-provided API can do this for you. The relatively
    unknown CFBundleCopyExecutableArchitecturesForURL API extracts the executable
    architecture of a file, returning NULL or an empty array for nonbinary files.^([11](#chapter10-11))
    KnockKnock, which makes use of this API, also checks for binaries of supported
    architectures ([Listing 10-22](chapter10.xhtml#Lis10-22)).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 10-22: Determining whether an item is a binary'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The isBinary function builds an array of architectures with values for both
    32 and 64 Intel in a dispatch_once to ensure that the initialization only occurs
    once, as we’ll invoke this function for every file any process has open ❶. Also,
    the code makes use of the @available Objective-C keyword to only add the ARM64
    architecture on versions of macOS that support it ❷.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we extract the executable architecture of the passed-in file ❸, using
    the firstObjectCommonWithArray: method to check for any of the supported architectures
    ❹. If we find them, we can be sure that the open file is indeed a binary capable
    of executing on the macOS system. We add these binaries to a list of dynamic libraries
    that KnockKnock will shortly check for proxying capabilities.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: KnockKnock also enumerates all running processes to extract the dependencies
    of the process’s main binary. Each of these dependencies is added to the list
    of libraries to check ([Listing 10-23](chapter10.xhtml#Lis10-23)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 10-23: Enumerating the dependencies of all running processes'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: To enumerate all running processes, the plug-in makes use of the proc _listallpids
    API discussed in [Chapter 1](chapter1.xhtml). Then, to extract each process’s
    dependencies, it invokes a method named enumLinkedDylibs, which iterates over
    each loaded process ❶, parses it using a Mach-O class I wrote based on code in
    [Chapter 2](chapter2.xhtml) ❷, and saves both strong and weak dependencies ❸.
    Finally, the function returns a list containing all dependencies found in all
    running processes ❹.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Next, we scan the list of libraries enumerated via lsof and via the running
    processes ([Listing 10-24](chapter10.xhtml#Lis10-24)).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 10-24: Checking whether a binary is a dynamic library that (likely)
    performs proxying'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: For each library to scan, the code snippet parses it via the Mach-O class ❶.
    Specifically, it checks the type of binary, ignoring any that aren’t explicitly
    dynamic libraries (identified by the MH_DYLIB type) ❷. For dynamic libraries,
    it checks and saves the library if it has a load command of type LC_REEXPORT_DYLIB
    ❸.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The method returns a list of any proxy libraries it finds so KnockKnock can
    display them to the user, either in the terminal or in the UI.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most Mac malware persists, so a tool that can enumerate persistently installed
    items can uncover even sophisticated or never-before-seen threats. In this chapter,
    we examined KnockKnock, a tool that provides this capability, leaving persistent
    Mac malware with almost no hope of remaining undetected. In the next chapter,
    we’ll explore persistence further and cover a tool capable of detecting persistent
    Mac malware in real time.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[  1](#chapter10_1).  See [*https://<wbr>learn<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/sysinternals<wbr>/downloads<wbr>/autoruns*](https://learn.microsoft.com/en-us/sysinternals/downloads/autoruns).'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  2](#chapter10_2).  See [*https://<wbr>web<wbr>.archive<wbr>.org<wbr>/web<wbr>/20180117193229<wbr>/https:<wbr>/<wbr>/github<wbr>.com<wbr>/synack<wbr>/knockknock*](https://web.archive.org/web/20180117193229/https://github.com/synack/knockknock).'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  3](#chapter10_3).  Csaba Fitzl, “Beyond the Good Ol’ LaunchAgents -32- Dock
    Tile Plugins,” *Theevilbit Blog*, September 28, 2023, [*https://<wbr>theevilbit<wbr>.github<wbr>.io<wbr>/beyond<wbr>/beyond<wbr>_0032<wbr>/*](https://theevilbit.github.io/beyond/beyond_0032/).'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  4](#chapter10_4).  “NSClassFromString(_:),” Apple Developer Documentation,
    [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/foundation<wbr>/1395135<wbr>-nsclassfromstring*](https://developer.apple.com/documentation/foundation/1395135-nsclassfromstring).'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  5](#chapter10_5).  You can read more about programmatic integration with
    VirusTotal in the service’s developer documentation at [*https://<wbr>docs<wbr>.virustotal<wbr>.com<wbr>/reference<wbr>/overview*](https://docs.virustotal.com/reference/overview).'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  6](#chapter10_6).  Patrick Wardle, “Methods of Malware Persistence on Mac
    OS X,” VirusBulletin, September 24, 2014, [*https://<wbr>www<wbr>.virusbulletin<wbr>.com<wbr>/uploads<wbr>/pdf<wbr>/conference<wbr>/vb2014<wbr>/VB2014<wbr>-Wardle<wbr>.pdf*](https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf).'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  7](#chapter10_7).  Patrick Wardle, *The Art of Mac Malware: The Guide to
    Analyzing Malicious Software*, Volume 1 (San Francisco: No Starch Press, 2022),
    36.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  8](#chapter10_8).  “Enumerate All Installed Applications on OS X,” Stack
    Overflow, [*https://<wbr>stackoverflow<wbr>.com<wbr>/questions<wbr>/15164132<wbr>/enumerate<wbr>-all<wbr>-installed<wbr>-applications<wbr>-on<wbr>-os<wbr>-x*](https://stackoverflow.com/questions/15164132/enumerate-all-installed-applications-on-os-x).'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  9](#chapter10_9).  Wardle, *The Art of Mac Malware*, 1:36–37.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[10](#chapter10_10).  See [*https://<wbr>github<wbr>.com<wbr>/EmpireProject<wbr>/EmPyre<wbr>/blob<wbr>/master<wbr>/lib<wbr>/modules<wbr>/persistence<wbr>/osx<wbr>/CreateHijacker<wbr>.py*](https://github.com/EmpireProject/EmPyre/blob/master/lib/modules/persistence/osx/CreateHijacker.py).'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[11](#chapter10_11).  “CFBundleCopyExecutableArchitecturesForURL,” Apple Developer
    Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/corefoundation<wbr>/1537108<wbr>-cfbundlecopyexecutablearchitectu<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/corefoundation/1537108-cfbundlecopyexecutablearchitectu?language=objc).'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
