- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 10 PERSISTENCE ENUMERATOR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In early 2014, a close friend begged me for help disinfecting his Mac. When
    I plopped myself in front of his screen, I saw obvious signs of a rampant adware
    infection: flagrant browser pop-ups, as well as a hijacked home page. Even worse,
    resetting his browser didn’t work; it reverted to its infected state upon each
    reboot, suggesting the presence of a persistent component buried somewhere deep
    within the system.'
  prefs: []
  type: TYPE_NORMAL
- en: At the time, I was an experienced Windows malware analyst just beginning my
    foray into the world of macOS. Naively, I thought I could download a tool capable
    of enumerating all persistent software installed on the system to reveal the malicious
    component. Well-known security tools, such as Microsoft’s AutoRuns,^([1](#chapter10-1))
    provided such a capability for Windows systems, but I soon discovered nothing
    similar existed for Macs.
  prefs: []
  type: TYPE_NORMAL
- en: I returned home and spent the next few days putting together a Python script
    that, while embarrassingly ugly, was capable of enumerating several types of persistent
    software. Running the script revealed an unrecognized launch agent on my friend’s
    computer that turned out to be the core persistent component of the adware. Once
    I removed it, his Mac was as good as new.
  prefs: []
  type: TYPE_NORMAL
- en: Realizing that my script could benefit other Mac users, I cleaned it up and
    released it under the moniker KnockKnock.^([2](#chapter10-2)) (Why KnockKnock?
    Because it tells you who’s there!) Today, KnockKnock has evolved greatly from
    its beginnings as a humble command line script. Now distributed as a native macOS
    application, it’s capable of detecting a myriad of persistently installed items
    on any macOS system. Coupled with an intuitive user interface (UI), integration
    with VirusTotal, and the ability to export its findings for ingestion into security
    information and event management (SIEM), it’s the first tool I run on any Mac
    that I suspect is infected.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll walk through KnockKnock’s design and implemen- tation
    to give you an in-depth look at the tool and expand your understand-ing of the
    persistence methods that Mac malware often does (or could) abuse. In the process,
    we’ll go beyond the detection mechanism discussed in [Chapter 5](chapter5.xhtml),
    which focused solely upon the Background Task Management database, to look at
    other ways of persisting on macOS, including browser extensions and dynamic library
    hijacks. You can find the complete source code on Objective-See’s GitHub page
    in the KnockKnock repository at [*https://<wbr>github<wbr>.com<wbr>/Objective<wbr>-see<wbr>/KnockKnock*](https://github.com/Objective-see/KnockKnock).
  prefs: []
  type: TYPE_NORMAL
- en: Tool Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: KnockKnock is a standard UI-based application (as shown in [Figure 10-1](chapter10.xhtml#fig10-1)),
    but users can also execute it in the terminal as a command line tool.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-1: KnockKnock’s user interface'
  prefs: []
  type: TYPE_NORMAL
- en: As this isn’t a book about writing UIs (thank goodness!), I won’t delve into
    the code related to KnockKnock’s UI. Instead, I focus mainly on its core components,
    such as its many plug-ins responsible for querying various aspects of the operating
    system to enumerate persistently installed items.
  prefs: []
  type: TYPE_NORMAL
- en: Command Line Options
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code for any Objective-C program starts at the standard main function, and
    KnockKnock is no exception. In its main function, KnockKnock begins by checking
    its program arguments to determine whether it should display its usage information
    or perform a command line scan ([Listing 10-1](chapter10.xhtml#Lis10-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-1: Parsing command line options'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be familiar with accessing a program’s command line arguments via
    the main function’s argv. Objective-C supports this approach, but we can also
    access the arguments via the arguments array of the processInfo property in the
    NSProcessInfo class. This technique has several advantages, most notably that
    it converts the arguments into Objective-C objects. This means, for example, that
    we can use the containsObject: method to easily determine whether the user has
    specified a certain command line argument regardless of the order of the arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: To determine whether to run a command line scan, KnockKnock checks if the user
    specified the -whosthere command line option. If so, it invokes its cmdlineScan
    function to perform a scan of the system, printing out information about persistently
    installed items directly to the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Plug-ins
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because malware can persist on macOS in many ways and researchers discover new
    methods from time to time, KnockKnock’s design relies on the concept of what I’ll
    refer to as plug-ins. Each plug-in corresponds to one type of persistence and
    implements the logic to enumerate items of that persistence type. The plug-ins
    then call into other parts of KnockKnock to perform actions such as displaying
    each item in the UI. This modular approach provides a simple and efficient way
    to add support for new persistence techniques. For example, after the researcher
    Csaba Fitzl published the blog post “Beyond the Good Ol’ LaunchAgents -32- Dock
    Tile Plugins,” which detailed a new persistence strategy involving macOS Dock
    plug-ins,^([3](#chapter10-3)) I added a corresponding detection to KnockKnock
    via a new plug-in within the hour.
  prefs: []
  type: TYPE_NORMAL
- en: Each of KnockKnock’s plug-ins inherits from a custom plug-in base class named
    PluginBase, which declares properties common to all plug-ins, as well as base
    methods. Found in *PluginBase.h*, it includes plug-in metadata, such as a name
    and a description, and arrays that the plug-in populates as it encounters persisting
    items ([Listing 10-2](chapter10.xhtml#Lis10-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-2: The base plug-in class’s properties'
  prefs: []
  type: TYPE_NORMAL
- en: The class also declares various base methods ([Listing 10-3](chapter10.xhtml#Lis10-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-3: The base plug-in class’s methods'
  prefs: []
  type: TYPE_NORMAL
- en: Each plug-in must implement the scan method with logic to enumerate one type
    of persistent item. For example, the Background Task Management plug-in will parse
    the Background Task Management database to extract persistent items managed by
    the Background Task Management subsystem, while the Browser Extension plug-in
    will enumerate installed browsers and, for each, extract any installed browser
    extensions. If researchers uncover a new persistence mechanism, we can trivially
    add a new plug-in with a scan method capable of enumerating items that persist
    in this new way.
  prefs: []
  type: TYPE_NORMAL
- en: The base class’s scan method throws an exception if called directly ([Listing
    10-4](chapter10.xhtml#Lis10-4)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-4: The base scan method will throw an exception if called.'
  prefs: []
  type: TYPE_NORMAL
- en: This design allows KnockKnock to easily invoke each plug-in’s scan method without
    having to know anything about how each plug-in actually enumerates persistent
    items of its specific type. The class provides base implementations for the other
    two methods, reset and processItem:, though plug-ins can override them if needed.
    (Otherwise, the plug-in will just call the base class’s implementation.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Both methods affect the application’s UI. For example, when performing a UI
    scan, the reset method handles situations in which a user stops and then restarts
    a scan, while the processItem: method updates the UI as plug-ins uncover persistent
    items. During a command line scan, the processItem: method will still keep track
    of detected items and print each one to the terminal once the scan completes ([Listing
    10-5](chapter10.xhtml#Lis10-5)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-5: Updating a global list of persistent items'
  prefs: []
  type: TYPE_NORMAL
- en: KnockKnock declares a static list of all plug-ins by their class name. Later,
    the code iterates over this list, instantiating each plug-in ([Listing 10-6](chapter10.xhtml#Lis10-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-6: Initializing each plug-in by name'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each plug-in class name, KnockKnock invokes the NSClassFromString API,
    which obtains a plug-in class based on the given name.^([4](#chapter10-4)) Then
    it invokes the class’s alloc method to allocate an instance of the class (in other
    words, to create an object). Next, it invokes the newly created object’s init
    method to allow the plug-in object to perform any initializations ❶. We’ll consider
    some initialization examples shortly. Although not shown here, KnockKnock will
    then invoke each of the plug-in’s scan methods.  #### Persistent Item Types'
  prefs: []
  type: TYPE_NORMAL
- en: 'KnockKnock assigns one of three types to persistent items: file, command, or
    browser extension. Most persisted items are executable files, such as scripts
    or Mach-O binaries. However, as in the case of cron jobs, malware sometimes persists
    as a command; other times, it persists as a bundle of files and resources in the
    form of a browser extension. It’s important for KnockKnock to correctly classify
    items, as each type has unique characteristics. For example, a persistent file
    might have extractable code signing information to help us classify it. We can
    also hash such files to check for known malware.'
  prefs: []
  type: TYPE_NORMAL
- en: The three item types are subclasses of a custom ItemBase class, shown in [Listing
    10-7](chapter10.xhtml#Lis10-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-7: The interface for the ItemBase class'
  prefs: []
  type: TYPE_NORMAL
- en: This base class declares various properties, such as the plug-in that discovered
    the item, the item’s name, and its path. Not all item types set every property.
    For example, commands don’t have paths, whereas files and extensions do. The ItemBase
    class also implements base methods to initialize an item, return its path to show
    it in the Finder app, and convert it to JSON. Although objects that inherit from
    this base class can reimplement each method if they need to, the base class’s
    implementation may suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Once a plug-in’s scan method completes, it stores any discovered items in a
    plug-in property called allItems. In a command line scan, KnockKnock converts
    each persistent item to JSON and appends it to a string that it prints out ([Listing
    10-8](chapter10.xhtml#Lis10-8)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-8: Converting persistent items to JSON'
  prefs: []
  type: TYPE_NORMAL
- en: Each item type implements its own logic to convert the information collected
    about a persistent item to JSON. Let’s take a look at the implementation of the
    toJSON method for items whose type is File ([Listing 10-9](chapter10.xhtml#Lis10-9)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-9: Converting File object properties to JSON'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the code makes use of the NSJSONSerialization class’s dataWithJSONObject:options:error:
    method to convert various dictionaries into JSON. These dictionaries include the
    item’s code signing information ❶ and hashes ❷. The method also converts numeric
    values from VirusTotal scan results ([Listing 10-10](chapter10.xhtml#Lis10-10)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-10: Computing a detection ratio based on scan results from VirusTotal'
  prefs: []
  type: TYPE_NORMAL
- en: Technically, KnockKnock itself doesn’t include logic to detect malicious code;
    it merely enumerates persistently installed items. This is by design, as it allows
    KnockKnock to detect new persistent malware even with no direct a priori knowledge
    of it. However, KnockKnock’s integration with VirusTotal allows it to flag already
    known malware by submitting a POST request with a hash of each persistent item
    to a VirusTotal query API. This API returns basic detection information, such
    as how many antivirus engines scanned the items and how many of those engines
    flagged it as malicious. KnockKnock converts this data into a string ratio of
    the form *positive detections*/*antivirus engines* and then displays this result
    in the UI or command line output.^([5](#chapter10-5))
  prefs: []
  type: TYPE_NORMAL
- en: The toJSON method finishes by building a single string object that combines
    the converted dictionaries, formatted numerical values, and all other properties
    of the item object ([Listing 10-11](chapter10.xhtml#Lis10-11)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-11: Building a JSON-ified string'
  prefs: []
  type: TYPE_NORMAL
- en: 'It returns this string to the caller to print out. For example, on a system
    infected with the persistent DazzleSpy malware, KnockKnock would display the following
    JSON in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The output shows several red flags pointing to the fact that this item is likely
    malicious. For example, it’s running from a hidden directory (*.local*), and while
    it claims to be an Apple software updater, its signature status is -67062, which
    maps to the errSecCSUnsigned constant. What conclusively identifies this item
    as malware, though, is the VirusTotal detection ratio, which shows that roughly
    half of the antivirus engines on the site flagged it as malicious.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Plug-ins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: KnockKnock has approximately 20 plug-ins to detect a myriad of persistent items,
    including items stored in Background Task Management, browser extensions, cron
    jobs, dynamic library inserts and proxies, kernel extensions, launch items, login
    items, Spotlight importers, system extensions, and many more. Although I won’t
    cover every plug-in here, I’ll dive into a few of them and provide examples of
    the malware they can detect.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Background Task Management'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](chapter5.xhtml), we explored the undocumented Background Task
    Manage-ment subsystem, which macOS leverages to govern and track persistent items
    such as launch agents, daemons, and login items. Through reverse engineering,
    I showed you how to deserialize the items managed by the subsystem, which could
    include persistently installed malware. We then created an open source library
    that I dubbed *DumpBTM*, which is available on GitHub ([*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/DumpBTM*](https://github.com/objective-see/DumpBTM)).
    To enumerate persistently installed launch and login items, KnockKnock leverages
    this library.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In Xcode, you can link in a library under your project’s Build Phases tab.
    There, expand Link Binary With Libraries, click* **+***, and then browse to the
    library.*'
  prefs: []
  type: TYPE_NORMAL
- en: After linking in the *DumpBTM* library, KnockKnock’s Background Task Management
    plug-in can directly invoke its exported APIs, such as its parseBTM function.
    The function takes a path to a Background Task Management file (or nil, to default
    to the system’s file) and returns a dictionary containing deserialized metadata
    about each persistent item managed by Background Task Management. [Listing 10-12](chapter10.xhtml#Lis10-12)
    shows a snippet of the code in the plug-in’s scan method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-12: Calling into the DumpBTM library'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code makes use of the @available Objective-C keyword to ensure that the
    plug-in executes only on versions 13 and newer of macOS (as the Background Task
    Management subsystem doesn’t exist on earlier versions). KnockKnock then iterates
    over the metadata for each persistent item returned by the *DumpBTM* library’s
    parseBTM function and, for each, instantiates a File item object. It does this
    by invoking the File class’s initWithParams: method, which accepts a dictionary
    of values for the object, including a path and, for launch items, the property
    list.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the code explicitly checks for a property list, as some persistent
    items in the Background Task Management database, such as login items, won’t contain
    one ([Listing 10-13](chapter10.xhtml#Lis10-13)). This is an important check, as
    inserting a nonexistent (nil) item into a dictionary will cause your program to
    crash.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-13: Creating a dictionary of parameters to initialize a File object'
  prefs: []
  type: TYPE_NORMAL
- en: 'With an initialized File object in hand, KnockKnock’s Background Task Management
    plug-in can now invoke the base plug-in class’s processItem: method to trigger
    a refresh of the UI or, in a command line scan, add the item to the list of items
    persistently installed on the system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the *DumpBTM* library, KnockKnock can easily enumerate all persistent
    items managed by the subsystem. In the following output, you can see the tool
    displaying details of the cyber-espionage implant WindTail, which persists an
    app named *Final_Presentation.app* as a login item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Many antivirus engines on VirusTotal now flag the malware, and a check of its
    signature returns -2147409652, which maps to the “certificate revoked” constant,
    CSSMERR_TP_CERT_REVOKED. However, KnockKnock would have shown the presence of
    the persistent item even before the antivirus engines on VirusTotal developed
    signatures for it.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, no external library can enumerate many of KnockKnock’s other
    classes of persistence, so we’ll have to write more code ourselves. One example
    is the browser extension plug-in, which we’ll look at now.
  prefs: []
  type: TYPE_NORMAL
- en: Browser Extension
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most macOS adware installs a malicious browser extension to hijack search results,
    display ads, or even intercept browser traffic. Common examples of such adware
    include Genieo, Yontoo, and Shlayer.
  prefs: []
  type: TYPE_NORMAL
- en: Because no macOS APIs can enumerate installed browser extensions, KnockKnock
    must do so itself. Worse, as each browser manages its extensions in its own way,
    KnockKnock must implement specific enumeration code for each. Currently, the tool
    supports extension enumeration for Safari, Chrome, Firefox, and Opera browsers.
    In this section, we’ll cover the code specific to Safari.
  prefs: []
  type: TYPE_NORMAL
- en: To list the installed browsers, KnockKnock uses relatively unknown Launch Services
    APIs ([Listing 10-14](chapter10.xhtml#Lis10-14)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-14: Obtaining a list of installed browsers using Launch Services
    APIs'
  prefs: []
  type: TYPE_NORMAL
- en: The code invokes the LSCopyAllHandlersForURLScheme API with the URL scheme https
    ❶, which returns an array containing the bundle IDs of applications capable of
    handling that scheme. The code then invokes the LSFindApplicationForInfo API to
    map each ID to an application path ❷, saving these into an array that it returns
    to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'In macOS 12, Apple added the URLsForApplicationsToOpenURL: method to the NSWorkspace
    class to return all applications capable of opening a specified URL. Invoking
    this method with a URL to a web page will return a list of all installed browsers.
    For newer versions of macOS, KnockKnock makes use of this API ([Listing 10-15](chapter10.xhtml#Lis10-15)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-15: Obtaining a list of installed browsers with the URLsForApplicationsToOpenURL:
    method'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code to enumerate Safari browser extensions in the scanExtensionsSafari:
    method of KnockKnock’s browser extension plug-in. In [Listing 10-16](chapter10.xhtml#Lis10-16),
    the code invokes this method with Safari’s location, found using the previous
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-16: Invoking Safari-specific logic to enumerate its extensions'
  prefs: []
  type: TYPE_NORMAL
- en: 'The location of Safari’s browser extensions has changed over the years; you
    could find them in the *~/Library/Safari/Extensions* directory until Apple decided
    to move them into the keychain. Older versions of KnockKnock tried to keep up
    with these changes, but now, it uses a simpler method: executing the macOS pluginkit
    utility ([Listing 10-17](chapter10.xhtml#Lis10-17)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-17: Enumerating installed Safari extensions'
  prefs: []
  type: TYPE_NORMAL
- en: The -m argument finds all plug-ins that match the search criteria specified
    in the -p argument; the -A argument returns all versions of the installed plug-ins,
    rather than just the highest version; and -vv returns verbose output that includes
    the display name and parent bundle. For the -p argument, we first use com.apple.Safari.extension,
    then com.apple.Safari.content-blocker. This ensures that we enumerate both traditional
    extensions and content blocker extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We execute pluginkit in a helper function we’ve named execTask (discussed in
    [Chapter 1](chapter1.xhtml)), which simply launches the specified program along
    with any specified arguments and returns the output to the caller. Try running
    pluginkit yourself to enumerate the Safari extensions installed on your Mac. In
    the following output, you can see that I’ve installed an ad blocker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Leveraging this external binary has the downside of introducing a dependency
    and the need to parse its output, but it’s still the most reliable option. There
    are many ways to parse any output. In [Listing 10-18](chapter10.xhtml#Lis10-18),
    KnockKnock takes the approach of extracting each extension’s name, path, and UUID.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-18: Parsing output containing installed Safari extensions'
  prefs: []
  type: TYPE_NORMAL
- en: The parsing code separates the output line by line, then splits each line into
    key-value pairs using an equal sign (*=*) as a delimiter. This will, for example,
    split the line Path = /Applications/Adblock Plus.app/Contents/PlugIns/Adblock
    Plus Toolbar.appex into the key Path and a value containing the path to the installed
    ad blocker extension. The code then extracts key-value pairs of interest, such
    as the path, name, and UUID.
  prefs: []
  type: TYPE_NORMAL
- en: Using the path to the extension, we load its *Info.plist* file and extract a
    description of the extension from the NSHumanReadableDescription key ([Listing
    10-19](chapter10.xhtml#Lis10-19)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-19: Initializing an Extension object for each extension'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we create a KnockKnock browser Extension item object with the collected
    extension metadata.  #### Dynamic Library Insertion'
  prefs: []
  type: TYPE_NORMAL
- en: A malware sample known as Flashback shattered the notion that Apple’s operating
    system was immune to malware.^([6](#chapter10-6)) Flashback exploited an unpatched
    vulnerability capable of automatically infecting users who browsed to a malicious
    website. Discovered in 2012, it amassed more than half a million victims, making
    it the most successful Mac malware at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flashback also persisted in a novel and stealthy manner. On an infected system,
    the malware gained user-assisted persistence by subverting Safari’s *Info.plist*
    file and inserting the following dictionary under a key named LSEnvironment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The dictionary’s DYLD_INSERT_LIBRARIES key contains a string pointing to the
    malicious library *UnHackMeBuild*. Safari will load this library into the browser
    when launched, where the malware could stealthily execute.
  prefs: []
  type: TYPE_NORMAL
- en: Today, Apple has mostly mitigated dylib insertions via the DYLD_INSERT_LIBRARIES
    environment variable and other approaches. The dynamic loader now ignores these
    variables in a wide range of cases, such as for platform binaries or for applications
    compiled with the hardened runtime.^([7](#chapter10-7)) However, programs supporting
    third-party plug-ins, especially on older versions of macOS, may still be at risk.
  prefs: []
  type: TYPE_NORMAL
- en: As such, KnockKnock contains a plug-in to detect this type of subversion. It
    scans launch items and applications, checking for the presence of a DYLD_INSERT_LIBRARIES
    entry. For launch items, this entry lives under the EnvironmentVariables key in
    their property list file, and for applications, you can find it under a key named
    LSEnvironment in the app’s *Info.plist* file, as we saw with Flashback. Because
    legitimate items rarely make use of persistent DYLD_INSERT_LIBRARIES insertions,
    you should closely examine any that you uncover.
  prefs: []
  type: TYPE_NORMAL
- en: Other plug-ins require a similar list of all launch items and applications,
    so KnockKnock produces this list in a global enumerator. Let’s briefly look at
    how KnockKnock tackles such enumeration, focusing on the case of installed apps,
    as there are multiple ways to list these items on a Mac. The least recommended
    is to manually enumerate bundles found in the common application directories (such
    as */Applications*), as you’d have to take into account subdirectories such as
    */Applications/Utilities/*, as well as user- specific applications. Plus, applications
    could be installed in other locations.
  prefs: []
  type: TYPE_NORMAL
- en: A Stack Overflow post suggests better options.^([8](#chapter10-8)) These include
    leveraging the lsregister utility to list all applications that have been registered
    with Launch Services, using the mdfind utility or related Spotlight APIs to list
    all applications indexed by macOS, or making use of the macOS system_profiler
    utility to obtain a list of applications known to the operating system’s software
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'KnockKnock opts for the system_profiler approach. The tool can output XML or
    JSON, which is easy to programmatically ingest and parse. Here is an example of
    XML output, along with the metadata for an instance of KnockKnock installed on
    my computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: KnockKnock executes system_profiler via the execTask helper function discussed
    earlier in this chapter ([Listing 10-20](chapter10.xhtml#Lis10-20)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-20: Installed applications enumerated via system_profiler'
  prefs: []
  type: TYPE_NORMAL
- en: Once this helper function returns ❶, KnockKnock serializes the XML output into
    an Objective-C object ❷, then saves the list of applications found under the _items
    key into an instance variable aptly named applications ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Now that KnockKnock’s global enumerator has obtained a list of applications
    (and launch items, although I didn’t show this logic here), the dylib insertion
    plug-in can scan each, looking for the addition of the DYLD_INSERT_LIBRARIES environment
    variable. [Listing 10-21](chapter10.xhtml#Lis10-21) shows this implementation
    in a method called scanApplications.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-21: Enumerating applications containing an inserted environment
    variable'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code iterates over all apps found by the global enumerator ❶. For each,
    it uses the application’s path to load the application’s bundle ❷, which has useful
    metadata about the application. This includes the contents of the app’s *Info.plist*
    file, which we can access through the bundle object’s infoDictionary property.
    After extracting the path to the *Info.plist* file ❸, it uses the key LSEnvironment
    to extract the dictionary containing specific environment variables ❹. Of course,
    most apps won’t set any environment variables, so the code skips these. However,
    for those that have the DYLD_INSERT_LIBRARIES key set, the code extracts its value:
    a path to the library inserted each time the application is run ❺. In Flashback,
    which subverted Safari, recall that the key-value pair looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the code in the plug-in creates and processes a File item object representing
    the inserted library, saving it to the list of persistent items uncovered by KnockKnock
    to then print to the terminal or display in the UI.  #### Dynamic Library Proxying
    and Hijacking'
  prefs: []
  type: TYPE_NORMAL
- en: The last plug-in I’ll cover in this chapter detects two other persistence mechanisms
    that make use of dynamic libraries. *Dylib proxying* replaces a library on which
    a target process depends with a malicious library. Whenever the target application
    starts, the malicious dynamic library loads and runs as well. To keep the application
    from losing legitimate functionality, it proxies requests to and from the original
    library.^([9](#chapter10-9))
  prefs: []
  type: TYPE_NORMAL
- en: Closely related to dylib proxying is *dylib hijacking*, which exploits the fact
    that the loader may look for dependencies in multiple locations. Malware could
    take advantage of this behavior by tricking the loader into using a malicious
    dependency instead of a legitimate one. Although malware doesn’t commonly abuse
    this technique, the post-exploitation agent EmPyre supports it as a persistence
    mechanism.^([10](#chapter10-10)) Dynamic libraries that perform such hijacking
    also proxy requests to keep from breaking legitimate functionality.
  prefs: []
  type: TYPE_NORMAL
- en: To detect either technique, KnockKnock generates a list of dynamic libraries,
    then checks each for an LC_REEXPORT_DYLIB load command that loads and proxies
    requests to the original library. While this load command is legitimate, benign
    libraries rarely use it, so we should closely examine any that do.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there isn’t a simple way to list all dynamic libraries installed
    on a macOS system, so KnockKnock focuses on those that are currently open or loaded
    by running processes. This approach isn’t as comprehensive as a scan of the entire
    system, but then again, any persisted malware is probably running somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: To build a list of loaded libraries, KnockKnock runs the lsof utility to list
    all open files on the system, then filters out everything but executables. If
    a dynamic library has been loaded somewhere, there should be an open file handle
    to it, which lsof can enumerate.
  prefs: []
  type: TYPE_NORMAL
- en: 'While getting a list of open files is fairly simple, determining whether a
    file is executable isn’t as easy as you might expect. You can’t just look for
    files whose extension is *.dylib* because that list wouldn’t include frameworks,
    which are technically libraries but don’t normally end in *.dylib*. For example,
    take a look at the *Electron* framework. The file command reports that it is indeed
    a dynamic library, though its extension isn’t *.dylib*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Another strategy might be to check which of the open files are binaries by
    checking the file’s executable bit, but this would include scripts and other random
    files on macOS, such as certain archives (which, as we can see here, have the
    executable bit, x, set):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: While you could manually parse each file, looking for a universal or Mach-O
    magic value, it turns out an Apple-provided API can do this for you. The relatively
    unknown CFBundleCopyExecutableArchitecturesForURL API extracts the executable
    architecture of a file, returning NULL or an empty array for nonbinary files.^([11](#chapter10-11))
    KnockKnock, which makes use of this API, also checks for binaries of supported
    architectures ([Listing 10-22](chapter10.xhtml#Lis10-22)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-22: Determining whether an item is a binary'
  prefs: []
  type: TYPE_NORMAL
- en: The isBinary function builds an array of architectures with values for both
    32 and 64 Intel in a dispatch_once to ensure that the initialization only occurs
    once, as we’ll invoke this function for every file any process has open ❶. Also,
    the code makes use of the @available Objective-C keyword to only add the ARM64
    architecture on versions of macOS that support it ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we extract the executable architecture of the passed-in file ❸, using
    the firstObjectCommonWithArray: method to check for any of the supported architectures
    ❹. If we find them, we can be sure that the open file is indeed a binary capable
    of executing on the macOS system. We add these binaries to a list of dynamic libraries
    that KnockKnock will shortly check for proxying capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: KnockKnock also enumerates all running processes to extract the dependencies
    of the process’s main binary. Each of these dependencies is added to the list
    of libraries to check ([Listing 10-23](chapter10.xhtml#Lis10-23)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-23: Enumerating the dependencies of all running processes'
  prefs: []
  type: TYPE_NORMAL
- en: To enumerate all running processes, the plug-in makes use of the proc _listallpids
    API discussed in [Chapter 1](chapter1.xhtml). Then, to extract each process’s
    dependencies, it invokes a method named enumLinkedDylibs, which iterates over
    each loaded process ❶, parses it using a Mach-O class I wrote based on code in
    [Chapter 2](chapter2.xhtml) ❷, and saves both strong and weak dependencies ❸.
    Finally, the function returns a list containing all dependencies found in all
    running processes ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we scan the list of libraries enumerated via lsof and via the running
    processes ([Listing 10-24](chapter10.xhtml#Lis10-24)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-24: Checking whether a binary is a dynamic library that (likely)
    performs proxying'
  prefs: []
  type: TYPE_NORMAL
- en: For each library to scan, the code snippet parses it via the Mach-O class ❶.
    Specifically, it checks the type of binary, ignoring any that aren’t explicitly
    dynamic libraries (identified by the MH_DYLIB type) ❷. For dynamic libraries,
    it checks and saves the library if it has a load command of type LC_REEXPORT_DYLIB
    ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The method returns a list of any proxy libraries it finds so KnockKnock can
    display them to the user, either in the terminal or in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most Mac malware persists, so a tool that can enumerate persistently installed
    items can uncover even sophisticated or never-before-seen threats. In this chapter,
    we examined KnockKnock, a tool that provides this capability, leaving persistent
    Mac malware with almost no hope of remaining undetected. In the next chapter,
    we’ll explore persistence further and cover a tool capable of detecting persistent
    Mac malware in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[  1](#chapter10_1).  See [*https://<wbr>learn<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/sysinternals<wbr>/downloads<wbr>/autoruns*](https://learn.microsoft.com/en-us/sysinternals/downloads/autoruns).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  2](#chapter10_2).  See [*https://<wbr>web<wbr>.archive<wbr>.org<wbr>/web<wbr>/20180117193229<wbr>/https:<wbr>/<wbr>/github<wbr>.com<wbr>/synack<wbr>/knockknock*](https://web.archive.org/web/20180117193229/https://github.com/synack/knockknock).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  3](#chapter10_3).  Csaba Fitzl, “Beyond the Good Ol’ LaunchAgents -32- Dock
    Tile Plugins,” *Theevilbit Blog*, September 28, 2023, [*https://<wbr>theevilbit<wbr>.github<wbr>.io<wbr>/beyond<wbr>/beyond<wbr>_0032<wbr>/*](https://theevilbit.github.io/beyond/beyond_0032/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  4](#chapter10_4).  “NSClassFromString(_:),” Apple Developer Documentation,
    [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/foundation<wbr>/1395135<wbr>-nsclassfromstring*](https://developer.apple.com/documentation/foundation/1395135-nsclassfromstring).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  5](#chapter10_5).  You can read more about programmatic integration with
    VirusTotal in the service’s developer documentation at [*https://<wbr>docs<wbr>.virustotal<wbr>.com<wbr>/reference<wbr>/overview*](https://docs.virustotal.com/reference/overview).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  6](#chapter10_6).  Patrick Wardle, “Methods of Malware Persistence on Mac
    OS X,” VirusBulletin, September 24, 2014, [*https://<wbr>www<wbr>.virusbulletin<wbr>.com<wbr>/uploads<wbr>/pdf<wbr>/conference<wbr>/vb2014<wbr>/VB2014<wbr>-Wardle<wbr>.pdf*](https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  7](#chapter10_7).  Patrick Wardle, *The Art of Mac Malware: The Guide to
    Analyzing Malicious Software*, Volume 1 (San Francisco: No Starch Press, 2022),
    36.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  8](#chapter10_8).  “Enumerate All Installed Applications on OS X,” Stack
    Overflow, [*https://<wbr>stackoverflow<wbr>.com<wbr>/questions<wbr>/15164132<wbr>/enumerate<wbr>-all<wbr>-installed<wbr>-applications<wbr>-on<wbr>-os<wbr>-x*](https://stackoverflow.com/questions/15164132/enumerate-all-installed-applications-on-os-x).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  9](#chapter10_9).  Wardle, *The Art of Mac Malware*, 1:36–37.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[10](#chapter10_10).  See [*https://<wbr>github<wbr>.com<wbr>/EmpireProject<wbr>/EmPyre<wbr>/blob<wbr>/master<wbr>/lib<wbr>/modules<wbr>/persistence<wbr>/osx<wbr>/CreateHijacker<wbr>.py*](https://github.com/EmpireProject/EmPyre/blob/master/lib/modules/persistence/osx/CreateHijacker.py).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[11](#chapter10_11).  “CFBundleCopyExecutableArchitecturesForURL,” Apple Developer
    Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/corefoundation<wbr>/1537108<wbr>-cfbundlecopyexecutablearchitectu<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/corefoundation/1537108-cfbundlecopyexecutablearchitectu?language=objc).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
