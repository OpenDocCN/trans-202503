- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 3 MEMORY ACCESS AND ORGANIZATION
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3 内存访问与组织
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: '[Chapters 1](chapter1.xhtml) and [2](chapter2.xhtml) showed you how to declare
    and access simple variables in an assembly language program. This chapter fully
    explains ARM memory access. You’ll learn how to efficiently organize your variable
    declarations to speed up access to their data. You’ll also learn about the ARM
    stack and how to manipulate data on it.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](chapter1.xhtml)和[第2章](chapter2.xhtml)向你展示了如何在汇编语言程序中声明和访问简单变量。本章将全面解释ARM内存访问。你将学习如何高效组织变量声明，以加快对其数据的访问。你还将了解ARM堆栈以及如何在堆栈上操作数据。'
- en: 'This chapter discusses several important concepts, including the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了几个重要概念，包括以下内容：
- en: Memory organization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存组织
- en: Memory access and the memory management unit
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存访问与内存管理单元
- en: Position-independent executables and address space layout randomization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立位置的可执行文件与地址空间布局随机化
- en: Variable storage and data alignment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量存储与数据对齐
- en: Endianness (memory byte order)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节序（内存字节顺序）
- en: ARM memory addressing modes and address expressions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARM内存寻址模式与地址表达式
- en: Stack operations, return addresses, and preserving register data
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈操作、返回地址与保存寄存器数据
- en: This chapter will teach to you make efficient use of your computer’s memory
    resources.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你如何高效利用计算机的内存资源。
- en: 3.1 Runtime Memory Organization
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1 运行时内存组织
- en: 'A running program uses memory in many ways, depending on the data’s type. Here
    are some common data classifications you’ll find in an assembly language program:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 运行中的程序以多种方式使用内存，具体取决于数据的类型。以下是你在汇编语言程序中会遇到的一些常见数据分类：
- en: '**Code**    Memory values that encode machine instructions (also known as the
    *text* section under Linux and macOS).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**    编码机器指令的内存值（在Linux和macOS中也称为*文本*段）。'
- en: '**Uninitialized static data**    An area in memory set aside by the program
    for uninitialized variables that exist the whole time the program runs; the OS
    will initialize this storage area to 0s when it loads the program into memory.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**未初始化的静态数据**    程序为未初始化变量预留的内存区域，这些变量在程序运行期间始终存在；操作系统在将程序加载到内存时会将该存储区域初始化为0。'
- en: '**Initialized static data**    A section of memory that also exists the whole
    time the program runs. However, the OS loads values for all the variables appearing
    in this section from the program’s executable file, so they have an initial value
    when the program first begins execution.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始化的静态数据**    一个在程序运行期间始终存在的内存区域。然而，操作系统会从程序的可执行文件中加载该区域内所有变量的值，因此在程序首次执行时，这些变量具有初始值。'
- en: '**Read-only data**    Similar to initialized static data, insofar as the OS
    loads initial data for this section of memory from the executable file. However,
    this section is marked *read-only* to prevent inadvertent modification of the
    data. Programs typically place constants and other unchanging data in this section
    (the code section is also marked read-only by the OS).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**只读数据**    与初始化的静态数据类似，操作系统从可执行文件中加载此内存段的初始数据。然而，此段被标记为*只读*，以防止数据被意外修改。程序通常将常量和其他不变的数据放入此段（代码段也由操作系统标记为只读）。'
- en: '**Heap**    This special section of memory is designated to hold dynamically
    allocated storage. Functions such as C’s malloc() and free() are responsible for
    allocating and deallocating storage in the heap area. Section 4.4.4, “Pointer
    Variables and Dynamic Memory Allocation,” on [page 178](chapter4.xhtml#pg_178)
    discusses dynamic storage allocation in greater detail.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆**    此特殊的内存区域用于存放动态分配的存储。诸如C语言的malloc()和free()等函数负责在堆区分配和释放存储空间。第4.4.4节“指针变量与动态内存分配”在[第178页](chapter4.xhtml#pg_178)中详细讨论了动态存储分配。'
- en: '**Stack**    In this special section in memory, the program maintains local
    variables for procedures and functions, program state information, and other transient
    data. See section 3.9, “The Push and Pop Operations,” on [page 155](chapter3.xhtml#pg_155)
    for more information about the stack section.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆栈**    在此特殊内存区域中，程序维护过程和函数的局部变量、程序状态信息及其他临时数据。有关堆栈部分的更多信息，请参见第3.9节“推入与弹出操作”，见[第155页](chapter3.xhtml#pg_155)。'
- en: These are the typical sections you will find in common programs, assembly language
    or otherwise. Smaller programs won’t use all these sections, though most programs
    have at least code, stack, and data sections. Complex programs may create additional
    sections in memory for their own purposes. Some programs may combine several of
    these sections. For example, many programs will combine the code and read-only
    sections into the same section in memory (as the data in both sections gets marked
    as read-only). Some programs combine the uninitialized and initialized data sections,
    initializing the uninitialized variables to 0\. Combining sections is generally
    handled by the linker program. See section 3.12, “For More Information,” on [page
    167](chapter3.xhtml#pg_167) concerning the GNU linker.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是你在常见程序中会找到的典型区域，无论是汇编语言程序还是其他语言的程序。较小的程序可能不会使用所有这些区域，但大多数程序至少会有代码区、栈区和数据区。复杂的程序可能会为自己的目的创建额外的内存区域。某些程序可能会将这些区域合并。例如，许多程序会将代码区和只读数据区合并到内存中的同一区域（因为这两个区域中的数据都被标记为只读）。有些程序会将已初始化和未初始化的数据区合并，将未初始化的变量初始化为0。合并区域通常由链接器程序处理。有关GNU链接器的更多信息，请参见第3.12节“更多信息”，[第167页](chapter3.xhtml#pg_167)。
- en: Linux and macOS tend to put different types of data into different sections
    (or *segments*) of memory. Although it is possible to reconfigure memory to your
    choice by running the linker and specifying various parameters, one typical organization
    might be similar to that in [Figure 3-1](chapter3.xhtml#fig3-1).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Linux和macOS倾向于将不同类型的数据放入内存的不同区域（或称为*段*）。虽然通过运行链接器并指定各种参数，可以重新配置内存，以满足自己的选择，但一种典型的组织方式可能类似于[图
    3-1](chapter3.xhtml#fig3-1)中的内容。
- en: '![](../images/Figure3-1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-1.jpg)'
- en: 'Figure 3-1: A Linux/macOS example runtime memory organization'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1：Linux/macOS示例运行时内存组织
- en: This figure is just an example. Real programs will likely organize memory differently,
    especially when using address space layout randomization, discussed later in this
    chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图仅仅是一个示例。实际的程序可能会以不同的方式组织内存，尤其是在使用地址空间布局随机化时，稍后在本章中会讨论这一点。
- en: 'The OS reserves the lowest memory addresses. Generally, your application cannot
    access data (or execute instructions) at these low addresses. One reason the OS
    reserves this space is to help trap NULL pointer references: if you attempt to
    access memory location 0x0 (NULL), the OS will generate a *segmentation fault*
    (also known as a *general protection fault*), meaning you’ve accessed a memory
    location that doesn’t contain valid data.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统保留了最低的内存地址。通常情况下，你的应用程序无法访问这些低地址中的数据（或执行指令）。操作系统保留这些空间的一个原因是为了帮助捕捉NULL指针引用：如果你尝试访问内存地址0x0（NULL），操作系统会生成*段错误*（也称为*一般保护错误*），意味着你访问了一个不包含有效数据的内存位置。
- en: The remaining six areas in the memory map hold different types of data associated
    with your program. These sections of memory include the stack section, the heap
    section, the .text (code) section, the .data section, the .rodata (read-only data)
    section, and the .bss (uninitialized data) section. Each of these memory sections
    corresponds to a type of data you can create in your Gas programs. I will describe
    the .text, .data, .rodata, and .bss sections in detail next. (The OS provides
    the stack and heap sections; you don’t normally declare these two in an assembly
    language program, so there isn’t anything more to discuss about them here.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射中的其余六个区域包含与程序相关的不同类型的数据。这些内存区域包括栈区、堆区、.text（代码）区、.data区、.rodata（只读数据）区和.bss（未初始化数据）区。每个内存区域对应着你在Gas程序中可以创建的某种数据类型。接下来我将详细描述.text、.data、.rodata和.bss区域。（操作系统提供栈区和堆区；你通常在汇编语言程序中不会声明这两个区域，所以这里不再讨论它们。）
- en: 3.1.1 The .text Section
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.1 . text 区
- en: The .text section contains the machine instructions that appear in a Gas program.
    Gas translates each machine instruction you write into a sequence of one or more
    word values. The CPU interprets these 32-bit word values as machine instructions
    during program execution.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: .text区包含在Gas程序中出现的机器指令。Gas会将你编写的每一条机器指令转换为一个或多个字值的序列。在程序执行过程中，CPU会将这些32位的字值解释为机器指令。
- en: By default, when GCC/Gas/*ld* links your program, it tells the system that your
    program can execute instructions and read data from the code segment, but cannot
    write data to the code segment. The OS will generate a segmentation fault if you
    attempt to store any data into the code segment.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当 GCC/Gas/*ld* 链接你的程序时，它会告诉系统，程序可以从代码段执行指令和读取数据，但不能向代码段写入数据。如果你尝试将任何数据存储到代码段中，操作系统将生成段错误。
- en: 3.1.2 The .data Section
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.2 .data 节段
- en: 'You’ll typically put your variables in the .data section. In addition to declaring
    static variables, you can embed lists of data into the .data declaration section.
    You use the same technique to embed data into your .data section that you use
    to embed data into the .text section: use the .byte, .hword, .word, .dword, and
    so on, directives. Consider the following example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会将变量放入 .data 节段中。除了声明静态变量外，你还可以将数据列表嵌入到 .data 声明节段中。你使用与将数据嵌入到 .text 节段中相同的技术来将数据嵌入到
    .data 节段中：使用 .byte、.hword、.word、.dword 等指令。考虑以下示例：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Values that Gas places in the .data memory segment by using these directives
    are written to the segment after the preceding variables. For example, the byte
    values 1,2,3 are emitted to the .data section after bb’s 0 byte. Because there
    aren’t any labels associated with these values, you do not have symbolic access
    to these values in your program. You can use the indexed addressing modes (described
    later in this chapter) to access these extra values.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 使用这些指令将值放入 .data 内存段时，会在前面的变量之后写入该段。例如，字节值 1、2、3 会在 bb 的 0 字节后写入 .data 节段。由于这些值没有关联标签，你无法在程序中对这些值进行符号访问。你可以使用索引寻址模式（本章稍后会介绍）来访问这些额外的值。
- en: 3.1.3 Read-Only Data Sections
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.3 只读数据节段
- en: 'Gas does not provide a stand-alone directive for creating sections that hold
    read-only constants. However, you can easily use the Gas .section directive to
    create a generic read-only constant section as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 没有提供单独的指令来创建存放只读常量的节段。然而，你可以轻松地使用 Gas 的 .section 指令创建一个通用的只读常量节段，如下所示：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Most programs use the .rodata identifier, by convention, for read-only data.
    For example, GCC uses this name for read-only constant sections. You could use
    any identifier you choose here. For example, I often use the name .const for constant
    sections. However, as GCC uses .rodata, I’ll stick to that convention in this
    book. I’ll say more about the .section directive a little later; for the time
    being, note that as long as the second argument is the empty string, Gas will
    create a read-only data section by using this directive.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序按照惯例使用 .rodata 标识符来表示只读数据。例如，GCC 使用该名称来表示只读常量节段。你可以在这里使用任何你选择的标识符。例如，我通常使用
    .const 作为常量节段的名称。然而，由于 GCC 使用 .rodata，我将在本书中遵循这一惯例。稍后我会更多地讲解 .section 指令；目前，请注意，只要第二个参数是空字符串，Gas
    就会通过这个指令创建一个只读数据节段。
- en: 'The .section .rodata section holds constants, tables, and other data that your
    program cannot change during execution. This section is similar to the .data section,
    with two differences:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: .section .rodata 节段存放常量、表格和程序在执行期间无法更改的其他数据。这个节段与 .data 节段类似，但有两个区别：
- en: The .rodata section is defined with .section .rodata, "" rather than .data.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .rodata 节段是通过 .section .rodata, "" 定义的，而不是 .data。
- en: The system does not allow you to write data to variables in an .rodata object
    while the program is running.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统不允许你在程序运行时向 .rodata 对象中的变量写入数据。
- en: 'Here’s an example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For many purposes, you can treat .rodata objects as literal constants. However,
    because they are actually memory objects, they behave like read-only .data objects.
    You cannot use an .rodata object anywhere a literal constant is allowed. For example,
    you cannot use them as *displacements* (constant *offsets* from a base pointer)
    in addressing modes (see section 3.6, “The ARM Memory Addressing Modes,” on [page
    140](chapter3.xhtml#pg_140)), in constant expressions, or as immediate values.
    In practice, you can use them anywhere that reading a .data variable is legal.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你可以将 .rodata 对象视为字面常量。然而，因为它们实际上是内存对象，它们的行为类似于只读 .data 对象。你不能在字面常量允许出现的地方使用
    .rodata 对象。例如，你不能在寻址模式中将它们用作 *位移*（相对于基指针的常量 *偏移量*）（参见第 3.6 节，“ARM 内存寻址模式”，[第 140
    页](chapter3.xhtml#pg_140)），在常量表达式中，或者作为立即数。在实践中，你可以在任何允许读取 .data 变量的地方使用它们。
- en: 'As with the .data section, you may embed data values in the .rodata section
    by using the .byte, .hword, .word, .dword, and so on, data declarations. For example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与 .data 段一样，你可以通过使用 .byte、.hword、.word、.dword 等数据声明，在 .rodata 段中嵌入数据值。例如：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can also declare constant values in the .text section. Data values you declare
    in this section are also read-only objects, as Linux and macOS write-protect the
    .text section. If you do place constant declarations in a .text section, take
    care to place them in a location that the program will not attempt to execute
    as code (such as after a b.al or ret instruction). Unless you’re using data declarations
    to manually encode ARM machine instructions (which would be rare and done only
    by expert programmers), you don’t want your program to attempt to execute data
    as machine instructions; the result is usually undefined.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 .text 段中声明常量值。你在该段中声明的数据值也是只读对象，因为 Linux 和 macOS 会对 .text 段进行写保护。如果你确实将常量声明放在
    .text 段中，请注意将它们放置在程序不会试图将其作为代码执行的位置（例如在 b.al 或 ret 指令之后）。除非你使用数据声明来手动编码 ARM 机器指令（这很少见，通常只由专家程序员执行），否则你不希望程序试图将数据当作机器指令执行；结果通常是未定义的。
- en: NOTE
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Technically, the result of executing data in the* .text *section is well defined:
    the machine will decode whatever bit pattern you place in memory as a machine
    instruction. However, few people will be able to look at a piece of data and interpret
    its meaning as a machine instruction.*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*从技术上讲，在 .text 段中执行数据的结果是明确定义的：机器将解码你放入内存中的任何位模式作为机器指令。然而，很少有人能查看一段数据并将其解释为机器指令。*'
- en: 3.1.4 The .bss Section
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.4 .bss 段
- en: 'The .data section requires that you initialize objects, even if you simply
    place a default value of 0 in the operand field. The .bss (block started by symbol)
    section lets you declare variables that are always uninitialized when the program
    begins running. This section begins with the .bss reserved word and contains variable
    declarations whose initializers must always be 0\. Here is an example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: .data 段要求你初始化对象，即使你只是将默认值 0 放入操作数字段中。 .bss（块由符号开始）段允许你声明在程序开始运行时始终未初始化的变量。该段以
    .bss 保留字开始，并包含变量声明，其初始化器必须始终为 0。以下是一个例子：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The OS will initialize all .bss objects to 0 when it loads your program into
    memory. However, it’s probably not a good idea to depend on this implicit initialization.
    If you need an object initialized with 0, declare it in a .data section and explicitly
    set it to 0.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统会在将程序加载到内存时将所有 .bss 对象初始化为 0。然而，依赖这种隐式初始化可能不是一个好主意。如果你需要一个初始化为 0 的对象，请在
    .data 段中声明它，并显式地将其设置为 0。
- en: Annoyingly, Gas requires you to explicitly provide an initializer of 0 when
    declaring variables in the .bss section. Good assembly language programmers don’t
    like doing this, because providing their source code with an explicit value tells
    the reader that they are expecting that variable to contain that value when the
    program runs. If the program explicitly isn’t expecting the variable to be initialized,
    it would be nice to tell the reader that.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 令人烦恼的是，Gas 要求在声明 .bss 段中的变量时显式提供一个初始化值为 0。优秀的汇编语言程序员不喜欢这样做，因为为他们的源代码提供一个显式值会告诉读者，他们期望该变量在程序运行时包含该值。如果程序显式地不期望该变量被初始化，那么最好告诉读者这一点。
- en: 'A very old convention to make this statement is to use the expression .-. in
    the operand field of such declarations. For example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一种非常古老的惯例是使用表达式 .-. 作为这种声明操作数字段的表示。例如：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Gas substitutes the current value of the location counter (see section 3.2,
    “Gas Storage Allocation for Variables,” on [page 131](chapter3.xhtml#pg_131))
    in place of the period (.). The expression location_counter minus location_counter
    is equal to 0, which satisfies the Gas requirements for initializers in the .bss
    section. This strange syntax lets the reader know that you’re not explicitly expecting
    the variable to be initialized with 0 when the program runs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 用当前位置计数器的当前值（参见第 3.2 节，“变量的 Gas 存储分配”，[第 131 页](chapter3.xhtml#pg_131)）替代了句点
    (.)。表达式 location_counter 减去 location_counter 等于 0，这符合 .bss 段中初始化器的 Gas 要求。这种奇怪的语法让读者知道，你并不期望变量在程序运行时显式地初始化为
    0。
- en: 'If .-. is too bizarre for your tastes (or you don’t want to have to type three
    characters), I’ve often used something like this to get the same results:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 .-. 对你来说太奇怪（或者你不想输入三个字符），我通常会使用类似这样的表达式来获得相同的结果：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This book tends to use the .-. form (when not explicitly specifying 0), as
    there is historical precedence for it. This form has one drawback, however: it
    does not work for .qword declarations (this is a Gas limitation).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本书倾向于使用 .-. 形式（当没有明确指定 0 时），因为这种形式具有历史先例。然而，这种形式有一个缺点：它不适用于 .qword 声明（这是 Gas
    的一个限制）。
- en: Variables you declare in the .bss section may consume less disk space in the
    executable file for the program. This is because Gas writes out initial values
    for .rodata and .data objects to the executable file, but it may use a compact
    representation for uninitialized variables you declare in the .bss section. Note,
    however, that this behavior is dependent on the OS version and object-module format.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 .bss 部分声明的变量可能会在程序的可执行文件中占用更少的磁盘空间。这是因为 Gas 会将 .rodata 和 .data 对象的初始值写入可执行文件，但它可能会对你在
    .bss 部分声明的未初始化变量使用紧凑的表示方法。请注意，这种行为依赖于操作系统版本和目标模块格式。
- en: 3.1.5 The .section Directive
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.5 .section 指令
- en: The .section directive allows you to create sections using any name you please
    (the .rodata section is an example). The syntax for this directive is
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: .section 指令允许你使用任何你喜欢的名称创建部分（.rodata 部分就是一个例子）。此指令的语法是：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'where identifier is any legal Gas identifier (it does not have to begin with
    a period) and flags is a string surrounded by quotes. The contents of the string
    vary by OS, but both Linux and macOS seem to support the following characters:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 identifier 是任何合法的 Gas 标识符（不必以句点开头），flags 是一个用引号括起来的字符串。字符串的内容根据操作系统的不同而有所变化，但
    Linux 和 macOS 都支持以下字符：
- en: b    Section is a .bss section and will hold uninitialized data. All data declarations
    must have a 0 initializer.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: b    部分是一个 .bss 部分，将保存未初始化的数据。所有数据声明必须具有 0 初始值。
- en: x    Section contains executable code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: x    部分包含可执行代码。
- en: w    Section contains writable data.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: w    部分包含可写数据。
- en: a    Section is allocatable (must be present for data sections).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: a    部分是可分配的（数据部分必须存在）。
- en: d    Section is a data section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: d    部分是数据部分。
- en: 'The flags string may contain zero or more of these characters, though certain
    flags (such as "b" and "x" or "d") are mutually exclusive. If the "w" flag is
    not present in the string, the section will be read-only. Here are some typical
    .section declarations:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: flags 字符串可以包含零个或多个这些字符，尽管某些标志（如 "b" 和 "x" 或 "d"）是互斥的。如果字符串中没有 "w" 标志，该部分将是只读的。以下是一些典型的
    .section 声明：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Each unique section you define will be given its own block of memory (such as
    the blocks that appear in [Figure 3-1](chapter3.xhtml#fig3-1)). The GNU linker/loader
    will merge all sections with the same name when assigning them to blocks of memory.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个你定义的独特部分将分配给自己的内存块（如 [图 3-1](chapter3.xhtml#fig3-1) 中所示的块）。GNU 链接器/加载器将在将它们分配到内存块时合并所有相同名称的部分。
- en: 3.1.6 Declaration Sections
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.6 声明部分
- en: 'The .data, .rodata, .bss, .text, and other named sections may appear zero or
    more times in your program. The declaration sections may appear in any order,
    as the following example demonstrates:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: .data、.rodata、.bss、.text 和其他命名部分在你的程序中可能出现零次或多次。声明部分可以按任何顺序出现，正如下面的示例所示：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The sections may appear in an arbitrary order, and a given declaration section
    may appear more than once in your program. As noted previously, when multiple
    declaration sections of the same type (for example, the three .bss sections in
    the preceding example) appear in a declaration section of your program, Gas combines
    them into a single group, in any order it pleases.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分可以按任意顺序出现，且给定的声明部分可以在程序中出现多次。如前所述，当多个相同类型的声明部分（例如前面示例中的三个 .bss 部分）出现在程序的声明部分时，Gas
    会将它们合并为一个组，以任何它喜欢的顺序。
- en: 3.1.7 Memory Access and MMU Pages
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.7 内存访问和 MMU 页
- en: The ARM’s *memory management unit (MMU)* divides memory into blocks known as
    *pages*. The OS is responsible for managing pages in memory, so application programs
    don’t typically worry about page organization. However, when working with pages
    in memory, make sure you’re aware of whether the CPU even allows access to a given
    memory location and whether it is read/write or read-only (write-protected).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 的 *内存管理单元（MMU）* 将内存划分为称为 *页* 的块。操作系统负责管理内存中的页，因此应用程序通常不需要关心页的组织。然而，在处理内存中的页时，确保你了解
    CPU 是否允许访问给定的内存位置，以及该位置是可读/写还是只读（写保护）。
- en: Each program section appears in memory in contiguous MMU pages. That is, the
    .rodata section begins at offset 0 in an MMU page and sequentially consumes pages
    in memory for all the data appearing in that section. The next section in memory
    (perhaps .data) begins at offset 0 in the next MMU page following the last page
    of the previous section. If that previous section (for example, .rodata) does
    not consume an integral multiple of 4,096 bytes, padding space will be present
    between the end of that section’s data and the end of its last page, to guarantee
    that the next section begins on an MMU page boundary.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序部分在内存中都出现在连续的 MMU 页面中。也就是说，.rodata 部分从 MMU 页面中的偏移量 0 开始，并依次消耗该部分中所有数据所占用的内存页面。内存中的下一个部分（可能是
    .data）从紧跟在上一个部分的最后一页后的下一个 MMU 页面的偏移量 0 开始。如果上一个部分（例如 .rodata）没有消耗 4,096 字节的整数倍，则该部分数据的末尾与最后一页的末尾之间会有填充空间，以确保下一个部分从
    MMU 页面边界开始。
- en: Each new section starts in its own MMU page because the MMU controls access
    to memory by using page *granularity*. For example, the MMU controls whether a
    page in memory is readable/writable or read-only. For .rodata sections, you want
    the memory to be read-only. For the .data section, you want to allow reads and
    writes. Because the MMU can enforce these attributes only on a page-by-page basis,
    you cannot have .data section information in the same MMU page as an .rodata section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新的部分都会在它自己的 MMU 页面中开始，因为 MMU 通过使用页面*粒度*来控制对内存的访问。例如，MMU 控制内存中的页面是可读/可写还是只读。对于
    .rodata 部分，你希望内存是只读的。对于 .data 部分，你希望允许读取和写入。因为 MMU 只能按页面逐页强制执行这些属性，所以你不能将 .data
    部分的信息与 .rodata 部分放在同一个 MMU 页面中。
- en: Normally, all this is completely transparent to your code. Data you declare
    in a .data (or .bss) section is readable and writable, and data in an .rodata
    or .text section is read-only (.text sections are also executable). Beyond placing
    data in a particular section, you don’t have to worry too much about the page
    attributes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有这些对你的代码都是完全透明的。你在 .data（或 .bss）部分声明的数据是可读且可写的，而 .rodata 或 .text 部分的数据是只读的（.text
    部分也可以执行）。除了将数据放在特定的部分之外，你无需过多担心页面属性。
- en: You do need to worry about MMU page organization in memory in one situation.
    Sometimes it is convenient to access (read) data beyond the end of a data structure
    in memory. However, if that data structure is aligned with the end of an MMU page,
    accessing the next page in memory could be problematic. Some pages in memory are
    *inaccessible*; the MMU does not allow reading, writing, or execution to occur
    on that page. Attempting to do so will generate an ARM *segmentation fault*. This
    will typically crash your program, unless you have an exception handler in place
    to handle segmentation faults. If you have a data access that crosses a page boundary,
    and the next page in memory is inaccessible, this will crash your program. For
    example, consider a half-word access to a byte object at the very end of an MMU
    page, as shown in [Figure 3-2](chapter3.xhtml#fig3-2).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在一种情况下，你确实需要关注内存中的 MMU 页面组织。有时，访问（读取）内存中数据结构末尾之外的数据是方便的。然而，如果该数据结构与 MMU 页面的末尾对齐，访问内存中的下一页可能会遇到问题。内存中的某些页面是*不可访问的*；MMU
    不允许对该页面进行读取、写入或执行操作。尝试这样做将产生 ARM *段错误*。这通常会崩溃你的程序，除非你已经设置了异常处理程序来处理段错误。如果你有一次数据访问跨越了页面边界，并且内存中的下一页不可访问，那么这将崩溃你的程序。例如，考虑对
    MMU 页面末尾的字节对象进行半字访问，如 [图 3-2](chapter3.xhtml#fig3-2) 所示。
- en: '![](../images/Figure3-2.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-2.jpg)'
- en: 'Figure 3-2: Half-word access at the end of a memory-management page'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-2：内存管理页末尾的半字访问
- en: As a general rule, you should never read data beyond the end of a data structure.
    If for some reason you need to do so, ensure that it is legal to access the next
    page in memory. It goes without saying that you should never write data beyond
    the end of a given data structure; this is always incorrect and can create far
    more problems than just crashing your program (including severe security issues).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你不应该读取数据结构末尾之外的数据。如果出于某种原因你必须这么做，确保访问内存中下一页是合法的。不言而喻，你永远不应写入数据结构末尾之外的数据；这样做总是错误的，可能带来比仅仅让程序崩溃更严重的问题（包括严重的安全问题）。
- en: 3.1.8 PIE and ASLR
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.8 PIE 和 ASLR
- en: 'As noted in [Chapter 1](chapter1.xhtml), macOS forces all code to use a position-independent
    executables (PIE) form. Linux doesn’t absolutely require this, but it allows you
    to write PIE code if you choose. There are two main reasons for PIE code: shared
    libraries and security, which were covered in “Linux vs. macOS: Position-Independent
    Executables” on [page 23](chapter1.xhtml#pg_23). However, as the behavior of PIE
    code profoundly affects the way you write ARM assembly language, it is worthwhile
    to spend a little more time discussing PIE, and especially *address space layout
    randomization (ASLR)*.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](chapter1.xhtml)中所述，macOS强制所有代码使用位置无关的可执行文件（PIE）格式。Linux并不绝对要求这样做，但如果你选择，可以编写PIE代码。PIE代码有两个主要原因：共享库和安全性，这些在《Linux与macOS：位置无关的可执行文件》一文中已在[第23页](chapter1.xhtml#pg_23)中详细讲解。然而，由于PIE代码的行为深刻影响了你编写ARM汇编语言的方式，因此值得花些时间进一步讨论PIE，尤其是*地址空间布局随机化（ASLR）*。
- en: ASLR is an attempt by the OS to thwart various exploits (hacks) that try to
    figure out where the code and data reside in an application. Prior to PIE and
    ASLR, most OSes always loaded the executable code and data to the same address
    in memory, making it easy for a hacker to patch or otherwise mess with the executable
    program. By loading the code and data sections into random memory locations, PIE/ASLR
    make it much more difficult for exploits to tap into the executing code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ASLR是操作系统的一种尝试，旨在阻止各种试图搞清楚代码和数据在应用程序中位置的攻击（黑客）。在PIE和ASLR之前，大多数操作系统总是将可执行代码和数据加载到内存中的相同地址，这使得黑客容易修补或以其他方式干扰可执行程序。通过将代码和数据段加载到随机内存位置，PIE/ASLR使得攻击者更难接触到正在执行的代码。
- en: As a result of ASLR, the layout of an executing program in memory will not actually
    look like that in [Figure 3-1](chapter3.xhtml#fig3-1). For one given instance
    of a program execution, it might look something like [Figure 3-3](chapter3.xhtml#fig3-3).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ASLR，正在执行的程序在内存中的布局实际上不会像[图3-1](chapter3.xhtml#fig3-1)所示那样。对于某个程序执行实例，它可能类似于[图3-3](chapter3.xhtml#fig3-3)所示。
- en: '![](../images/Figure3-3.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-3.jpg)'
- en: 'Figure 3-3: A possible memory layout for one execution of an application'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-3：应用程序执行的一种可能的内存布局
- en: However, on the next run of the program, the sections will likely be rearranged
    and placed at different locations in memory.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在程序的下一次运行中，代码段可能会被重新排列，并放置到内存中的不同位置。
- en: 'While PIE/ASLR makes it difficult for hackers to exploit your code, it also
    plays havoc with the ARM’s instruction set. Consider the following (legitimate)
    ARM ldr instruction:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然PIE/ASLR使得黑客更难利用你的代码，但它也对ARM的指令集产生了很大影响。考虑以下（合法的）ARM ldr指令：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: xs
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: xs
- en: 'This would normally load the W0 register from the 32-bit variable someWordVar
    found in the .data section. This particular instruction uses the *PC-relative
    addressing mode*, which means that the instruction encodes an offset from the
    address of the ldr instruction to the someWordVar variable in memory. However,
    if you assemble this program under macOS, you get the following error:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常会从位于.data段中的32位变量someWordVar加载W0寄存器。该指令使用*PC相对寻址模式*，这意味着该指令编码了从ldr指令的地址到内存中someWordVar变量的偏移量。然而，如果你在macOS下汇编这个程序，你会得到以下错误：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Under Linux (Ubuntu and Raspberry Pi OS seem to be different; your mileage may
    vary), you get something like
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux下（Ubuntu和Raspberry Pi OS似乎有所不同；你的使用情况可能有所不同），你会看到类似以下内容：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is a real ARM64 instruction and *should* work. In fact
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个真实的ARM64指令，*应该*可以工作。事实上
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: is just a special form of this instruction, and it does work.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是该指令的一种特殊形式，而且它确实有效。
- en: The problem is due to the ARM 32-bit instruction length. If you look up the
    encoding for the ldr instruction in the ARM reference manual, you’ll discover
    that it sets aside 19 bits for the address of the memory location. This turns
    out to be an *offset* (a distance in bytes) from the address of the ldr instruction
    (that is, the value of the 19-bit field is added to the PC to get the actual memory
    address). Because it’s referencing data in the .text section, and everything is
    word-aligned in the text section, the 19-bit offset is actually a word offset,
    not a byte offset. This effectively gives the ldr instruction another 2 bits (the
    LO 2 bits will always be 0). This effective 21-bit offset allows the ldr instruction
    to access data at a location ±1MB around the ldr instruction.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题源于 ARM 32 位指令长度。如果你查阅 ARM 参考手册中的 ldr 指令编码，你会发现它为内存位置的地址预留了 19 位。这实际上是一个*偏移量*（以字节为单位的距离），表示相对于
    ldr 指令的地址（即 19 位字段的值会加到程序计数器 PC 上，从而得到实际的内存地址）。因为它引用的数据在 .text 区段，并且 .text 区段中的所有内容都是按字对齐的，因此这个
    19 位的偏移量实际上是一个字偏移，而不是字节偏移。这有效地为 ldr 指令提供了额外的 2 位（低 2 位总是为 0）。这个有效的 21 位偏移量使得 ldr
    指令可以访问离 ldr 指令 ±1MB 以内的数据。
- en: Unfortunately, when accessing data in the .data section, which the OS has been
    nice enough to place at a random address (probably farther than 1MB away), the
    21-bit range of the ldr instruction won’t be sufficient. This is why Gas complains
    about attempting to access a variable in the .data section with the ldr instruction.
    As a bottom line, you can’t use that instruction to directly access data unless
    that data is also in the .text section and isn’t more than ±1MB away.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当访问位于 .data 区段的数据时，由于操作系统很友善地将其放置在一个随机地址（可能距离超过 1MB），ldr 指令的 21 位范围将不足以访问该数据。这就是为什么
    Gas 会报错，提示尝试用 ldr 指令访问 .data 区段的变量。底线是，除非数据也在 .text 区段并且与 ldr 指令的距离不超过 ±1MB，否则不能直接使用该指令来访问数据。
- en: 3.1.9 The .pool Section
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.9 .pool 区段
- en: 'The .pool section is a Gas pseudo-section in your program. As noted previously,
    the following instruction loads a large constant into a register by placing that
    constant somewhere in memory, then loading the contents of that memory location
    into the destination register:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: .pool 区段是你程序中的一个 Gas 伪区段。如前所述，以下指令通过将常量放置在内存中的某个位置，然后将该内存位置的内容加载到目标寄存器中，来将一个大常量加载到寄存器中：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In other words, this instruction is completely equivalent to either of the
    following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这个指令完全等价于以下两种情况中的任意一种：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Gas automatically figures out an appropriate place to put such constants: near
    the instructions that reference them but out of the code path.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 会自动找出合适的地方来放置这些常量：将它们放在引用这些常量的指令附近，但不在代码路径中。
- en: If you’d like to control the placement of these constants in your .text section,
    you can use the .pool directive. Wherever you place this directive in your .text
    section (and it must be in the .text section), Gas will emit the constants it
    produces. Just make sure that if you put a .pool directive in your code, you place
    it after an unconditional branch or return instruction so that the program flow
    won’t attempt to execute that data as machine instructions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望控制这些常量在 .text 区段中的位置，可以使用 .pool 指令。无论你将此指令放置在 .text 区段中的何处（并且必须放在 .text
    区段内），Gas 都会生成它所产生的常量。只要确保，如果你在代码中放置 .pool 指令，应该把它放在一个无条件跳转或返回指令之后，这样程序流就不会试图将这些数据作为机器指令执行。
- en: Normally, you don’t need to place a .pool directive in your source code, since
    Gas will do a reasonable job of finding a location to place its data. However,
    if you intend to also insert data of your own in the .text section, you may want
    to insert the .pool directive and place your data declarations immediately afterward.
    Note that the data after .pool is part of the .text section, so you can continue
    to place machine instructions after the .pool.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不需要在源代码中放置 .pool 指令，因为 Gas 会合理地找到一个合适的位置来放置数据。然而，如果你打算在 .text 区段中插入你自己的数据，你可能需要插入
    .pool 指令，并将数据声明紧跟其后。请注意，.pool 后的数据是 .text 区段的一部分，因此你可以继续在 .pool 后面放置机器指令。
- en: 3.2 Gas Storage Allocation for Variables
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2 Gas 变量存储分配
- en: Gas associates a current *location counter* with each of the declaration sections
    (.text, .data, .rodata, .bss, and any other named sections). These location counters
    initially contain 0. Whenever you declare a variable in one of these sections
    (or write code in a code section), Gas associates the current value of that section’s
    location counter with the label and bumps up the value of that location counter
    by the size of the object you’re declaring.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 会为每个声明节（.text、.data、.rodata、.bss 以及任何其他命名节）关联一个当前的*位置计数器*。这些位置计数器初始值为 0。每当你在这些节中声明一个变量（或在代码节中编写代码时），Gas
    会将该节的当前位置计数器的当前值与标签关联，并将该位置计数器的值增加你正在声明的对象的大小。
- en: 'For example, assume that the following is the only .data declaration section
    in a program:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设以下是程序中唯一的 .data 声明节：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Variable declarations listed in a single .data section have contiguous offsets
    (location counter values) into the .data section. Given the preceding declaration,
    s will immediately follow bb in memory, w will immediately follow s in memory,
    d will immediately follow w, and so on. These offsets aren’t the actual runtime
    addresses of the variables. At runtime, the system loads each section to a base
    address in memory. The linker and the OS add the base address of the memory section
    to each of these location counter values (normally called *displacements*, or
    *offsets*) to produce the actual memory address of the variables.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个 .data 节中列出的变量声明具有连续的偏移量（位置计数器值）。根据前面的声明，s 会紧跟在内存中的 bb 后面，w 会紧跟在 s 后面，d
    会紧跟在 w 后面，以此类推。这些偏移量并不是变量的实际运行时地址。在运行时，系统会将每个节加载到内存中的基址。链接器和操作系统将内存节的基址加到这些位置计数器值（通常称为*位移*或*偏移量*）上，从而生成变量的实际内存地址。
- en: Keep in mind that you may link other modules with your program (for example,
    from the C stdlib) or even additional .data sections in the same source file,
    and the linker has to merge the .data sections. Each individual section (even
    when it has the same name as another section) has its own location counter that
    starts from 0 when allocating storage for the variables in the section. Hence,
    the offset of an individual variable may have little bearing on its final memory
    address.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你可能会将其他模块与程序链接（例如，来自 C 标准库的模块）或甚至在同一源文件中添加额外的 .data 节，而链接器必须合并这些 .data 节。每个独立的节（即使它与其他节同名）都有自己的位置计数器，在为该节中的变量分配存储时，该计数器从
    0 开始。因此，单个变量的偏移量可能与其最终的内存地址几乎没有关系。
- en: 'Gas allocates memory objects you declare in .rodata, .data, and .bss sections
    in completely different regions of memory. Therefore, you cannot assume that the
    following three memory objects appear in adjacent memory locations (indeed, they
    probably will not):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 在 .rodata、.data 和 .bss 节中分配的内存对象位于内存的完全不同区域。因此，你不能假设以下三个内存对象会出现在相邻的内存位置（实际上，它们很可能不会）：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In fact, Gas will not even guarantee that variables you declare in separate
    .data (or other) sections are adjacent in memory, even if there is nothing between
    the declarations in your code. For example, you cannot assume whether bb, w, and
    d are—or aren’t—in adjacent memory locations in the following declarations:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Gas 甚至不会保证你在不同的 .data（或其他）节中声明的变量在内存中是相邻的，即使你的代码中这些声明之间没有任何内容。例如，你不能假设以下声明中的
    bb、w 和 d 是否在相邻的内存位置：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If your code requires these variables to consume adjacent memory locations,
    you must declare them in the same .data section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码要求这些变量占用相邻的内存位置，你必须将它们声明在同一个 .data 节中。
- en: 3.3 Little-Endian and Big-Endian Data Organization
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3 小端和大端数据组织
- en: As you learned in section 1.6.2, “The Memory Subsystem,” on [page 14](chapter1.xhtml#pg_14),
    the ARM stores multibyte data types in memory, with the LO byte at the lowest
    address in memory and the HO byte at the highest address (see [Figure 1-6](chapter1.xhtml#fig1-6)).
    This type of data organization in memory is known as *little endian*. Little-endian
    data organization, in which the LO byte comes first and the HO byte comes last,
    is common in many modern CPUs. It is not, however, the only possible approach.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第 1.6.2 节《内存子系统》中学到的，在[第14页](chapter1.xhtml#pg_14)，ARM 在内存中存储多字节数据类型时，将低字节存储在内存中最低地址位置，高字节存储在最高地址位置（见[图1-6](chapter1.xhtml#fig1-6)）。这种内存数据组织方式被称为*小端*。小端数据组织中，低字节先存储，高字节最后存储，这在许多现代CPU中是常见的。然而，这并不是唯一的可能方式。
- en: '*Big-endian* data organization reverses the order of the bytes in memory. The
    HO byte of the data structure appears first, in the lowest memory address, and
    the LO byte appears in the highest memory address. [Table 3-1](chapter3.xhtml#tab3-1)
    describes the memory organization for half words.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*大端*数据组织会反转内存中字节的顺序。数据结构的高位字节首先出现在最低内存地址，低位字节则出现在最高内存地址。[表 3-1](chapter3.xhtml#tab3-1)
    描述了半字的内存组织。'
- en: 'Table 3-1: Half-Word Object Memory Organization'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1：半字对象内存组织
- en: '| Data byte | Little endian | Big endian |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 数据字节 | 小端 | 大端 |'
- en: '| --- | --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 (LO byte) | base + 0 | base + 1 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 0 (低位字节) | base + 0 | base + 1 |'
- en: '| 1 (HO byte) | base + 1 | base + 0 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 1 (高位字节) | base + 1 | base + 0 |'
- en: '[Table 3-2](chapter3.xhtml#tab3-2) describes the memory organization for words.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-2](chapter3.xhtml#tab3-2) 描述了字的内存组织。'
- en: 'Table 3-2: Word Object Memory Organization'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-2：字对象内存组织
- en: '| Data byte | Little endian | Big endian |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 数据字节 | 小端 | 大端 |'
- en: '| --- | --- | --- |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 (LO byte) | base + 0 | base + 3 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 0 (低位字节) | base + 0 | base + 3 |'
- en: '| 1 | base + 1 | base + 2 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 1 | base + 1 | base + 2 |'
- en: '| 2 | base + 2 | base + 1 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 2 | base + 2 | base + 1 |'
- en: '| 3 (HO byte) | base + 3 | base + 0 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 3 (高位字节) | base + 3 | base + 0 |'
- en: '[Table 3-3](chapter3.xhtml#tab3-3) describe the memory organization for double
    words.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-3](chapter3.xhtml#tab3-3) 描述了双字的内存组织。'
- en: 'Table 3-3: Dword Object Memory Organization'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-3：双字对象内存组织
- en: '| Data byte | Little endian | Big endian |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 数据字节 | 小端 | 大端 |'
- en: '| --- | --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 (LO byte) | base + 0 | base + 7 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 0 (低位字节) | base + 0 | base + 7 |'
- en: '| 1 | base + 1 | base + 6 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 1 | base + 1 | base + 6 |'
- en: '| 2 | base + 2 | base + 5 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 2 | base + 2 | base + 5 |'
- en: '| 3 | base + 3 | base + 4 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 3 | base + 3 | base + 4 |'
- en: '| 4 | base + 4 | base + 3 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 4 | base + 4 | base + 3 |'
- en: '| 5 | base + 5 | base + 2 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 5 | base + 5 | base + 2 |'
- en: '| 6 | base + 6 | base + 1 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 6 | base + 6 | base + 1 |'
- en: '| 7 (HO byte) | base + 7 | base + 0 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 7 (高位字节) | base + 7 | base + 0 |'
- en: Normally, you wouldn’t be too concerned with big-endian memory organization
    on an ARM CPU. However, on occasion, you may need to deal with data produced by
    a different CPU (or by a protocol, such as Transmission Control Protocol/Internet
    Protocol, or TCP/IP) that uses big-endian organization as its canonical integer
    format. If you were to load a big-endian value in memory into a CPU register,
    the value would be incorrect.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不会太关注 ARM CPU 上的大端内存组织。然而，有时你可能需要处理由不同 CPU（或协议，如传输控制协议/互联网协议，简称 TCP/IP）产生的数据，这些数据使用大端组织作为其标准整数格式。如果你将一个大端值从内存加载到
    CPU 寄存器中，这个值将会不正确。
- en: 'If you have a 16-bit big-endian value in memory and you load it into a register,
    its bytes will be swapped. For 16-bit values, you can correct this issue by using
    the rev16 instruction, which has the following syntax:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个 16 位的大端值在内存中，并将其加载到寄存器中，它的字节将会被交换。对于 16 位的值，你可以通过使用 rev16 指令来修正这个问题，该指令的语法如下：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, regdest and regsrc are any 32- or 64-bit general-purpose registers (both
    must be the same size). This instruction will swap the 2 bytes in each of the
    16-bit half-words in the source register; that is, this operates on hword0 and
    hword1 in a 32-bit register and on hword0, hword1, hword2, and hword3 in a 64-bit
    register. For example
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，regdest 和 regsrc 是任何 32 位或 64 位的通用寄存器（两者必须相同大小）。这条指令会交换源寄存器中每个 16 位半字中的
    2 个字节；也就是说，它在 32 位寄存器中作用于 hword0 和 hword1，在 64 位寄存器中作用于 hword0、hword1、hword2 和
    hword3。例如：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: will produce 0x34127856 in the W1 register, having swapped bytes 0 and 1 as
    well as bytes 2 and 3.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将会在 W1 寄存器中产生 0x34127856，交换了字节 0 和 1 以及字节 2 和 3。
- en: 'If you have a 32-bit value in a register (32- or 64-bit), you can swap the
    4 bytes in that register by using the rev32 instruction:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个 32 位的值在寄存器中（无论是 32 位还是 64 位），你可以通过使用 rev32 指令交换该寄存器中的 4 个字节：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Again, the registers can be 32- or 64-bit, but both must be the same size. In
    a 32-bit register, this will swap bytes 0 and 3 as well as 1 and 2\. In a 64-bit
    register, it will swap bytes 0 and 3, 1 and 2, 7 and 4, and 6 and 5 (see [Figure
    3-4](chapter3.xhtml#fig3-4)).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，寄存器可以是 32 位或 64 位，但两者必须相同大小。在 32 位寄存器中，这将交换字节 0 和 3 以及字节 1 和 2。在 64 位寄存器中，它将交换字节
    0 和 3、1 和 2、7 和 4，以及 6 和 5（参见[图 3-4](chapter3.xhtml#fig3-4)）。
- en: '![](../images/Figure3-4.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-4.jpg)'
- en: 'Figure 3-4: Operation of the rev32 instruction'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-4：rev32 指令的操作
- en: The rev instruction will swap bytes 7 and 0, 6 and 1, 5 and 2, and 4 and 3 in
    a 64-bit register (see [Figure 3-5](chapter3.xhtml#fig3-5)).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: rev 指令将会在 64 位寄存器中交换字节 7 和 0、字节 6 和 1、字节 5 和 2、字节 4 和 3（参见[图 3-5](chapter3.xhtml#fig3-5)）。
- en: '![](../images/Figure3-5.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-5.jpg)'
- en: 'Figure 3-5: Operation of the rev instruction'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-5：rev指令的操作
- en: The rev instruction accepts only 64-bit registers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: rev指令仅接受64位寄存器。
- en: 3.4 Memory Access
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4 内存访问
- en: Section 1.6.2, “The Memory Subsystem,” on [page 14](chapter1.xhtml#pg_14) describes
    how the ARM CPU fetches data from memory on the data bus. In an idealized CPU,
    the data bus is the size of the standard integer registers on the CPU; therefore,
    you would expect the ARM CPUs to have a 64-bit data bus. In practice, modern CPUs
    often make the physical data bus connection to main memory much larger in order
    to improve system performance. The bus brings in large chunks of data from memory
    in a single operation and places that data in the CPU’s *cache*, which acts as
    a buffer between the CPU and physical memory.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第1.6.2节，“内存子系统”，在[第14页](chapter1.xhtml#pg_14)中描述了ARM CPU如何通过数据总线从内存中获取数据。在理想化的CPU中，数据总线的大小与CPU上标准的整数寄存器大小相同；因此，你可以预期ARM
    CPU会有一个64位的数据总线。但实际上，现代CPU通常会将物理数据总线与主内存的连接做得更大，以提高系统性能。总线通过一次操作将大块数据从内存中提取出来，并将这些数据放入CPU的*缓存*中，缓存充当着CPU与物理内存之间的缓冲区。
- en: From the CPU’s point of view, the cache *is* memory. Therefore, when the remainder
    of this section discusses memory, it’s generally talking about data sitting in
    the cache. As the system transparently maps memory accesses into the cache, we
    can discuss memory as though the cache were not present and discuss the advantages
    of the cache as necessary.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从CPU的角度来看，缓存*就是*内存。因此，当本节的其余部分讨论内存时，通常指的是缓存中的数据。由于系统会透明地将内存访问映射到缓存中，我们可以像讨论没有缓存一样讨论内存，并根据需要讨论缓存的优势。
- en: On early processors predating the ARM, memory was arranged as an array of bytes
    (8-bit machines, such as the Intel 8088), half words (16-bit machines, such as
    the Intel 8086 and 80286), or words (32-bit machines, such as the 32-bit ARM CPUs).
    On a 16-bit machine, the LO bit of the address did not physically appear on the
    address bus. This means the addresses 126 and 127 put the same bit pattern on
    the address bus (126, with an implicit 0 in bit position 0), as shown in [Figure
    3-6](chapter3.xhtml#fig3-6).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在ARM之前的早期处理器中，内存是按字节数组（8位机器，如Intel 8088）、半字（16位机器，如Intel 8086和80286）或字（32位机器，如32位ARM
    CPU）进行排列的。在16位机器上，地址的LO位在物理上不会出现在地址总线上。这意味着地址126和127在地址总线上会显示相同的位模式（126，LO位是0），如[图3-6](chapter3.xhtml#fig3-6)所示。
- en: '![](../images/Figure3-6.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-6.jpg)'
- en: 'Figure 3-6: The address and data bus for 16-bit processors'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-6：16位处理器的地址总线和数据总线
- en: When reading a byte, the CPU uses the LO bit of the address to select the LO
    byte or HO byte on the data bus. [Figure 3-7](chapter3.xhtml#fig3-7) shows the
    process when accessing a byte at an even address (126 in this figure).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取字节时，CPU使用地址的LO位来选择数据总线上的LO字节或HO字节。[图3-7](chapter3.xhtml#fig3-7)展示了在偶数地址（图中的地址126）访问字节时的过程。
- en: '![](../images/Figure3-7.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-7.jpg)'
- en: 'Figure 3-7: Reading a byte from an even address on a 16-bit CPU'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-7：在16位CPU上从偶数地址读取一个字节
- en: '[Figure 3-8](chapter3.xhtml#fig3-8) shows memory access for the byte at an
    odd address (127 in this figure). Note that in both [Figures 3-7](chapter3.xhtml#fig3-7)
    and [3-8](chapter3.xhtml#fig3-8), the address appearing on the address bus is
    126.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-8](chapter3.xhtml#fig3-8)展示了在奇数地址上读取字节的内存访问（图中地址127）。请注意，在[图3-7](chapter3.xhtml#fig3-7)和[图3-8](chapter3.xhtml#fig3-8)中，出现在地址总线上的地址都是126。'
- en: '![](../images/Figure3-8.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-8.jpg)'
- en: 'Figure 3-8: Reading a byte from an odd address on a 16-bit CPU'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-8：在16位CPU上从奇数地址读取一个字节
- en: What happens when this 16-bit CPU wants to access 16 bits of data at an odd
    address? For example, suppose that in these figures, the CPU reads the word at
    address 125\. When the CPU puts address 125 on the address bus, the LO bit doesn’t
    physically appear. Therefore, the actual address on the bus is 124\. If the CPU
    were to read the LO 8 bits off the data bus at this point, it would get the data
    at address 124, not address 125.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个16位CPU想要在奇数地址访问16位数据时，会发生什么情况？例如，假设在这些图中，CPU读取地址125的字。当CPU将地址125放到地址总线上时，LO位不会在物理上出现。因此，总线上实际的地址是124。如果CPU此时从数据总线上读取LO的8位，它将得到地址124的数据，而不是地址125的数据。
- en: 'Fortunately, the CPU is smart enough to figure out what’s going on here: it
    extracts the data from the HO 8 bits on the data bus and uses this as the LO 8
    bits of the data operand. However, the HO 8 bits that the CPU needs are not found
    on the data bus. The CPU has to initiate a second read operation, placing address
    126 on the address bus, to get the HO 8 bits (these will be sitting in the LO
    8 bits of the data bus, but the CPU can figure that out). It takes two memory
    cycles for this read operation to complete. Therefore, the instruction reading
    the data from memory will take longer to execute than it would have if the data
    had been read from an address that was an integral multiple of 2 (16-bit alignment).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，CPU 足够智能，能够搞清楚发生了什么：它从数据总线的高 8 位提取数据，并将其作为数据操作数的低 8 位使用。然而，CPU 所需的高 8 位并不在数据总线上。CPU
    必须发起第二次读取操作，将地址 126 放到地址总线上，以获取高 8 位（这些将位于数据总线的低 8 位，但 CPU 可以识别出来）。这个读取操作需要两个内存周期才能完成。因此，读取内存中的数据的指令将比从地址是
    2 的倍数（16 位对齐）读取数据时的执行时间更长。
- en: The same problem exists on 32-bit processors, except that the 32-bit data bus
    allows the CPU to read 4 bytes at a time. Reading a 32-bit value at an address
    that is not an integral multiple of 4 incurs the same performance penalty. However,
    accessing a 16-bit operand at an odd address doesn’t always guarantee an extra
    memory cycle—only addresses that, when divided by 4, have a remainder of 3 incur
    the penalty. In particular, if you access a 16-bit value (on a 32-bit bus) at
    an address where the LO 2 bits contain 0b01, the CPU can read the word in a single
    memory cycle, as shown in [Figure 3-9](chapter3.xhtml#fig3-9).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 32 位处理器上也存在相同的问题，只是 32 位数据总线允许 CPU 一次读取 4 字节。在一个不是 4 的整数倍地址上读取 32 位值会产生相同的性能惩罚。然而，在奇数地址上访问
    16 位操作数并不总是保证会有额外的内存周期——只有当地址除以 4 后余数为 3 时才会产生惩罚。特别是，如果你在一个地址上访问 16 位值（在 32 位总线上），该地址的低
    2 位包含 0b01，CPU 可以在一个内存周期内读取该字，如[图 3-9](chapter3.xhtml#fig3-9)所示。
- en: '![](../images/Figure3-9.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-9.jpg)'
- en: 'Figure 3-9: Accessing a word on a 32-bit data bus'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-9：在 32 位数据总线上访问一个字
- en: 'Modern ARM CPUs with cache systems have largely eliminated this problem. As
    long as the data (1, 2, 4, or 8 bytes in size) is fully within a *cache line*—a
    processor-defined number of bytes—no memory cycle penalty occurs for an unaligned
    access. If the access does cross a cache-line boundary, the CPU will run a little
    slower while it executes two memory operations to get (or store) the data.  ###
    3.5 Gas Support for Data Alignment'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现代带有缓存系统的 ARM CPU 已经基本消除了这个问题。只要数据（1、2、4 或 8 字节大小）完全位于一个*缓存行*内——一个由处理器定义的字节数——对未对齐访问不会产生内存周期惩罚。如果访问跨越了缓存行边界，CPU
    在执行两个内存操作以获取（或存储）数据时会稍微变慢。### 3.5 气体对数据对齐的支持
- en: To write fast programs, you must ensure that you properly align data objects
    in memory. Proper *alignment* means that the starting address for an object is
    a multiple of a certain size—usually the size of an object, if the object’s size
    is a power of 2 for values up to 32 bytes in length. For objects greater than
    32 bytes, aligning the object on an 8-, 16-, or 32-byte address boundary is probably
    sufficient. For objects fewer than 16 bytes, aligning the object at an address
    that is the next power of 2 greater than or equal to the object’s size is usually
    fine.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写快速的程序，必须确保正确地对齐内存中的数据对象。正确的*对齐*意味着对象的起始地址是某个大小的倍数——通常是对象的大小，如果对象的大小是 2 的幂并且长度不超过
    32 字节。对于大于 32 字节的对象，将对象对齐到 8、16 或 32 字节的地址边界通常就足够了。对于小于 16 字节的对象，将对象对齐到一个大于或等于对象大小的下一个
    2 的幂的地址通常是可以的。
- en: As noted in the previous section, accessing data that is not aligned at an appropriate
    address may require extra time. Therefore, if you want to ensure that your program
    runs as rapidly as possible, you should try to align data objects according to
    their size.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，访问未按适当地址对齐的数据可能需要额外的时间。因此，如果你希望确保程序运行尽可能快，你应该尝试根据数据对象的大小来对齐数据。
- en: Data becomes misaligned whenever you allocate storage for different-sized objects
    in adjacent memory locations. For example, if you declare a byte variable, it
    will consume 1 byte of storage, and the next variable you declare in that declaration
    section will have the address of that byte object plus 1\. If the byte variable’s
    address happens to be an even address, the variable following that byte will start
    at an odd address. If that following variable is a half-word, word, or dword object,
    its starting address will not be optimal.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你为不同大小的对象分配存储空间并且这些对象位于相邻的内存位置时，数据就会发生错位。例如，如果你声明一个 byte 变量，它将占用 1 字节存储空间，那么你在该声明部分中声明的下一个变量的地址将是该
    byte 对象的地址加 1。如果 byte 变量的地址恰好是偶数地址，则紧随其后的变量将从一个奇数地址开始。如果那个变量是 half-word、word 或
    dword 对象，它的起始地址将不理想。
- en: 'In this section, we’ll explore ways to ensure that a variable is aligned at
    an appropriate starting address based on its size. Consider the following Gas
    variable declarations:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将探索确保变量根据其大小在适当的起始地址对齐的方法。考虑以下 Gas 变量声明：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first .data declaration in a program places its variables at an address
    that is an even multiple of 4,096 bytes. Whatever variable first appears in that
    .data declaration is guaranteed to be aligned on a reasonable address. Each successive
    variable is allocated at an address that is the sum of the sizes of all the preceding
    variables, plus the starting address of that .data section.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的第一个 .data 声明将其变量放置在一个是 4,096 字节的偶数倍的地址上。无论哪个变量首先出现在该 .data 声明中，都保证会被对齐到一个合理的地址。每个后续变量的地址是所有前面变量大小之和，再加上该
    .data 部分的起始地址。
- en: 'Therefore, assuming Gas allocates the variables in the previous example at
    a starting address of 4096, it will allocate them at the following addresses:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，假设 Gas 在前面的例子中将变量分配到起始地址为 4096 的位置，它将按照以下地址分配这些变量：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With the exception of the first variable (which is aligned on a 4KB boundary)
    and the byte variables (whose alignment doesn’t matter), all these variables are
    misaligned. The s, s2, and w2 variables start at odd addresses, and the dw variable
    is aligned on an even address that is not a multiple of 8 (word-aligned but not
    dword-aligned).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第一个变量（它在 4KB 边界上对齐）和 byte 变量（它们的对齐无关紧要）之外，所有这些变量都是错位的。s、s2 和 w2 变量从奇数地址开始，而
    dw 变量虽然在一个偶数地址上对齐，但它并不是 8 的倍数（虽然对齐到 word，但没有对齐到 dword）。
- en: 'An easy way to guarantee that your variables are aligned properly is to put
    all the dword variables first, the word variables second, the half-word variables
    third, and the byte variables last in the declaration, as shown here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 保证变量正确对齐的一种简单方法是将所有的 dword 变量放在最前面，word 变量放在第二，half-word 变量放在第三，最后将 byte 变量放在声明的末尾，如下所示：
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This organization produces the following addresses in memory:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 该组织在内存中生成以下地址：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: These variables are all aligned at reasonable addresses.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量都对齐到了合理的地址。
- en: Unfortunately, it is rarely possible for you to arrange your variables in this
    manner. While many technical reasons make this alignment impossible, a good practical
    reason for not doing this is that it doesn’t let you organize your variable declarations
    by logical function (that is, you probably want to keep related variables next
    to one another, regardless of their size).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，你很少能以这种方式安排你的变量。虽然有许多技术原因使得这种对齐不可能实现，但一个实际的原因是，它不会让你按照逻辑功能来组织变量声明（也就是说，你可能希望将相关的变量放在一起，而不管它们的大小）。
- en: To resolve this problem, Gas provides the .align and .balign directives. As
    noted in section 1.2, “The Anatomy of an Assembly Language Program,” on [page
    5](chapter1.xhtml#pg_5), the .align argument is a value that will be raised to
    that power of 2, and the .balign’s operand is an integer that must be a power
    of 2 (1, 2, 4, 8, 16, and so on). These directives ensure that the next memory
    object will be aligned to the specified size.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Gas 提供了 .align 和 .balign 指令。如第 1.2 节“汇编语言程序的结构”中所述，在 [第 5 页](chapter1.xhtml#pg_5)，.align
    参数是一个将提高到 2 的幂的值，.balign 的操作数是必须是 2 的幂（1、2、4、8、16 等）的整数。这些指令确保下一个内存对象会对齐到指定的大小。
- en: 'By default, these directives will pad the data bytes they skip with 0s; in
    a .text section, Gas aligns the code by using nop (no-operation) instructions.
    If you would like to use a different padding value, these two directives allow
    a second operand:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这些指令会用0填充它们跳过的数据字节；在.text段中，Gas通过使用nop（无操作）指令来对齐代码。如果你希望使用不同的填充值，这两个指令允许第二个操作数：
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, padValue must be an 8-bit constant, which these directives will use as
    the padding value. Gas also allows a third argument, which is the maximum allowable
    padding; see the Gas documentation for more details.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，padValue必须是一个8位常量，指令将使用它作为填充值。Gas还允许第三个参数，这是最大允许的填充量；更多详情请参见Gas文档。
- en: 'The previous example could be rewritten, using the .align directive, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例可以使用.align指令重写，如下所示：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If Gas determines that an .align directive’s current address (location counter
    value) is not an integral multiple of the specified value, Gas will quietly emit
    extra bytes of padding after the previous variable declaration until the current
    address in the .data section is a multiple of the specified value. This makes
    your data larger by a few bytes, in exchange for faster access to it. Since your
    data will grow only slightly larger when you use this feature, this is probably
    a good trade-off.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Gas判断某个.align指令的当前地址（位置计数器值）不是指定值的整数倍，Gas会在前一个变量声明之后静默地添加额外的填充字节，直到.data段中的当前地址是指定值的整数倍。这会使你的数据增大几个字节，以换取更快的访问速度。由于使用此功能时数据只会稍微增大一些，这可能是一个值得的折中。
- en: As a general rule, if you want the fastest possible access, choose an alignment
    value equal to the size of the object you want to align. That is, align half words
    to even boundaries with an .align 1 statement, words to 4-byte boundaries with
    .align 2, double words to 8-byte boundaries with .align 3, and so on. If the object’s
    size is not a power of 2, align it to the next higher power of 2.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果你想要最快的访问速度，选择一个与要对齐对象大小相等的对齐值。也就是说，将半字对齐到偶数边界，使用.align 1指令；将字对齐到4字节边界，使用.align
    2；将双字对齐到8字节边界，使用.align 3，依此类推。如果对象的大小不是2的幂次方，则将其对齐到下一个较大的2的幂次方。
- en: Data alignment isn’t always necessary, since the cache architecture of modern
    ARM CPUs handles most misaligned data. Use the alignment directives only with
    variables for which speedy access is absolutely critical.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 数据对齐并非总是必需的，因为现代ARM CPU的缓存架构能够处理大部分非对齐数据。只有当变量需要极快的访问速度时，才应使用对齐指令。
- en: 3.6 The ARM Memory Addressing Modes
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6 ARM内存寻址模式
- en: For the most part, the ARM uses a very standard RISC *load/store architecture*.
    This means that it accomplishes almost all memory access by using instructions
    that load registers from memory or store the value held in registers to memory.
    The load and store instructions access memory by using memory *addressing modes*,
    mechanisms the CPU uses to determine the address of a memory location. The ARM
    memory addressing modes provide flexible access to memory, allowing you to easily
    access variables, arrays, structs, pointers, and other complex data types. Mastering
    ARM addressing modes is an important step toward mastering ARM assembly language.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，ARM使用的是非常标准的RISC *加载/存储架构*。这意味着它几乎通过使用从内存加载寄存器或将寄存器中存储的值存储到内存的指令来完成所有的内存访问。加载和存储指令通过使用内存*寻址模式*来访问内存，寻址模式是CPU用来确定内存位置地址的机制。ARM的内存寻址模式提供了灵活的内存访问方式，使你可以轻松访问变量、数组、结构体、指针及其他复杂数据类型。掌握ARM的寻址模式是掌握ARM汇编语言的重要一步。
- en: In addition to loads and stores, ARM uses *atomic instructions*. For the most
    part, these are variations of the load and store instructions, with a few extra
    bells and whistles needed for multiprocessing applications. Atomic instructions
    are beyond the scope of this text; for more information, see the ARM V8 reference
    manual.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 除了加载和存储，ARM还使用了*原子指令*。大多数情况下，这些指令是加载和存储指令的变体，额外增加了一些多处理器应用所需的功能。原子指令超出了本文的讨论范围；更多信息，请参阅ARM
    V8参考手册。
- en: 'Until now, this book has presented only two mechanisms for accessing memory:
    the register-indirect addressing mode (for example, [X0]) introduced in [Chapter
    1](chapter1.xhtml), and the PC-relative addressing mode discussed in section 3.1.8,
    “PIE and ASLR,” on [page 128](chapter3.xhtml#pg_128). However, the ARM provides
    more than half a dozen modes (depending on how you count them) for accessing data
    in memory. The following sections describe each of these modes.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书只介绍了两种访问内存的机制：在[第1章](chapter1.xhtml)中介绍的寄存器间接寻址模式（例如，[X0]），以及在[第3.1.8节](chapter3.xhtml#pg_128)
    “PIE 和 ASLR”中讨论的 PC 相对寻址模式。然而，ARM 提供了超过六种（根据你的计算方式）访问内存数据的模式。以下各节将描述这些模式。
- en: 3.6.1 PC-Relative
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.1 PC相对地址
- en: The PC-relative addressing mode is useful only for fetching values from the
    .text section, as the other sections will likely fall out of the ±1MB range of
    this addressing mode. Therefore, it is much easier to directly access constant
    data in the .text section than it would be in the .rodata section (or another
    read-only section).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: PC 相对寻址模式仅在从 .text 段中获取值时有用，因为其他段很可能超出了该寻址模式的±1MB范围。因此，直接访问 .text 段中的常量数据比访问
    .rodata 段（或其他只读段）中的数据要容易得多。
- en: A couple of issues arise when using the PC-relative addressing mode in the .text
    section. First, because the 19-bit offset buried in the 32-bit instruction encoding
    is shifted left 2 bits to produce a word offset (as discussed earlier), you can
    load only word and double-word values when using this addressing mode—no bytes
    or half words. For example, you can access byte and half-word values in the .text
    section with the register-indirect addressing mode, but not with the PC-relative
    addressing mode.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .text 段使用 PC 相对寻址模式时，会遇到一些问题。首先，由于32位指令编码中嵌入的19位偏移量被左移了2位来产生字的偏移量（如前所述），因此使用此寻址模式时只能加载字和双字值——不能加载字节或半字。例如，你可以使用寄存器间接寻址模式访问
    .text 段中的字节和半字值，但不能使用 PC 相对寻址模式。
- en: 'When accessing data in the .text section by using the PC-relative addressing
    mode, keep the following points in mind:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PC 相对寻址模式访问 .text 段中的数据时，请记住以下几点：
- en: Under macOS, all labels in the .text section must be aligned on a 4-byte boundary,
    even if the data associated with that label doesn’t require such alignment (such
    as bytes and half words).
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 macOS 上，.text 段中的所有标签必须按4字节对齐，即使与该标签关联的数据不需要这种对齐（例如字节和半字）。
- en: Data values in the .text section cannot refer to other sections (for example,
    pointer constants, discussed in [Chapter 4](chapter4.xhtml)). However, such objects
    can refer to data within the .text section itself (this is important for *jump
    tables*, covered in [Chapter 7](chapter7.xhtml)).
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .text 段中的数据值不能引用其他段（例如，[第4章](chapter4.xhtml)中讨论的指针常量）。然而，这些对象可以引用 .text 段中本身的数据（这对于*跳转表*来说很重要，详见[第7章](chapter7.xhtml)）。
- en: The data must reside within ±1MB of the instruction(s) that reference it. For
    example, you cannot create an array of data that exceeds 1MB.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据必须位于引用它的指令的±1MB范围内。例如，你不能创建超过1MB的数组数据。
- en: Only word and dword accesses are allowed when using the PC-relative addressing
    mode.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PC 相对寻址模式时，仅允许字（word）和双字（dword）访问。
- en: As the data resides in the .text section, it is read-only; you cannot put variables
    in the .text section.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于数据位于 .text 段中，它是只读的；你不能在 .text 段中放置变量。
- en: 'To use the PC-relative addressing mode, just reference the label you used to
    declare the object in the .text section:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 PC 相对寻址模式，只需引用你用于声明 .text 段中对象的标签：
- en: '[PRE28]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Don’t forget that all data declarations you put in the .text section need to
    be out of the execution path, preferably in the .pool section. (You’ll see an
    exception to this rule in [Chapter 5](chapter5.xhtml) when I discuss passing parameters
    in the code stream.)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了，你在 .text 段中声明的所有数据需要处于执行路径之外，最好放在 .pool 段中。（当我在[第5章](chapter5.xhtml)讨论代码流中的参数传递时，你会看到这个规则的一个例外。）
- en: 3.6.2 Register-Indirect
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.2 寄存器间接
- en: Up to this point, most examples in this book have used the register-indirect
    addressing mode. *Indirect* means that the operand is not the actual address,
    but that the operand’s value specifies the memory address to use. In a register-indirect
    addressing mode, the value held in the register is the address of the memory location
    to access. For example, the instruction
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中的大多数示例都使用了寄存器间接寻址模式。*间接*寻址意味着操作数不是实际地址，而是操作数的值指定了要使用的内存地址。在寄存器间接寻址模式下，寄存器中保存的值是要访问的内存位置的地址。例如，指令
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: tells the CPU to load X0’s value from the location whose address is currently
    in X1\. The square brackets around X1 tell Gas to use the register-indirect addressing
    mode.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉 CPU 从当前存储在 X1 中的地址位置加载 X0 的值。X1 周围的方括号告诉 Gas 使用寄存器间接寻址模式。
- en: The ARM has 32 forms of this addressing mode, one for each of the 32 general-purpose
    64-bit registers (though X31 is not legal; use SP instead). You cannot specify
    a 32-bit register in the square brackets when using an indirect addressing mode.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 有 32 种这种寻址模式，每一种都对应 32 个通用 64 位寄存器（尽管 X31 是非法的；应使用 SP 代替）。在使用间接寻址模式时，你不能在方括号中指定
    32 位寄存器。
- en: 'Technically, you could load a 64-bit register with an arbitrary numeric value
    and access that location indirectly by using the register-indirect addressing
    mode:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，你可以将一个任意数值加载到 64 位寄存器中，然后通过使用寄存器间接寻址模式间接访问该位置：
- en: '[PRE30]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Unfortunately (or fortunately, depending on how you look at it), this will probably
    cause the OS to generate a segmentation fault because it’s not always legal to
    access arbitrary memory locations. There are better ways to load the address of
    an object into a register, as you’ll see shortly.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是（或幸运的是，取决于你如何看待它），这可能会导致操作系统产生段错误，因为并非总是合法访问任意的内存位置。正如你很快会看到的，还有更好的方法将对象的地址加载到寄存器中。
- en: You can use the register-indirect addressing modes to access data referenced
    by a pointer, to step through array data, and, in general, whenever you need to
    modify an object’s address while your program is running.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用寄存器间接寻址模式来访问指针引用的数据、遍历数组数据，以及在程序运行时任何需要修改对象地址的情况。
- en: When using a register-indirect addressing mode, you refer to the value of a
    variable by its numeric memory address (the value you load into a register) rather
    than by the name of the variable. This is an example of using an *anonymous variable*.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用寄存器间接寻址模式时，你通过变量的数值内存地址（即加载到寄存器中的值）来引用变量，而不是通过变量的名称。这是使用 *匿名变量* 的一个例子。
- en: 'The *aoaa.inc* include file provides the lea macro, which you can use to take
    the address of a variable and put it into a 64-bit register:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*aoaa.inc* 包含文件提供了 lea 宏，你可以使用它获取变量的地址并将其放入一个 64 位寄存器中：'
- en: '[PRE31]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After executing this lea instruction, you can use the [x1] register-indirect
    addressing mode to indirectly access the value of j (which is how almost every
    example up to this point has accessed memory). In section 3.8, “Getting the Address
    of a Memory Object,” on [page 153](chapter3.xhtml#pg_153), you’ll see how the
    lea macro works.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这个 lea 指令后，你可以使用 [x1] 寄存器间接寻址模式间接访问 j 的值（这是到目前为止几乎所有示例访问内存的方式）。在第 3.8 节“获取内存对象的地址”，[第
    153 页](chapter3.xhtml#pg_153) 中，你将看到 lea 宏是如何工作的。
- en: '#### 3.6.3 Indirect-Plus-Offset'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 3.6.3 间接加偏移'
- en: 'Consider the following data declaration, similar to other examples given in
    this book:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下数据声明，它类似于本书中给出的其他示例：
- en: '[PRE32]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you load X1 with the address of bVar, you can access that byte (0) by using
    an instruction such as this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 X1 加载为 bVar 的地址，你可以使用如下指令访问该字节（0）：
- en: '[PRE33]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To access the other 3 bytes following that 0 in memory, you can use the *indirect-plus-offset*
    addressing mode. Here is the mode’s syntax:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问内存中该 0 后面的其他 3 个字节，你可以使用 *间接加偏移* 寻址模式。以下是该模式的语法：
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Xn|SP means X0 to X30 or SP, and signed_expression is a small integer expression
    in the range –256 to +255\. This particular addressing mode will compute the sum
    of the address in X*n* (*n* = 0 to 30, or SP) with the signed constant and use
    that as the *effective memory address* (the memory address to access).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Xn|SP 表示 X0 到 X30 或 SP，signed_expression 是一个小整数表达式，范围为 –256 到 +255。这个特定的寻址模式将计算
    X*n*（*n* = 0 到 30，或 SP）中地址与有符号常量的和，并将其作为 *有效内存地址*（即要访问的内存地址）使用。
- en: 'For example, if X1 contains the address of bVar from the previous example,
    the following instruction will fetch the byte just beyond bVar (that is, the byte
    containing 1 in that example):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果X1包含前一个示例中的bVar的地址，以下指令将获取bVar之后的字节（即该示例中包含1的字节）：
- en: '[PRE35]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once again, the 32-bit instruction size severely limits the range of this addressing
    mode (only 9 bits are available for the signed offset). If you need a greater
    offset, you must explicitly add a value to the address in X1 (perhaps using a
    different register if you need to maintain the base address in X1). For example,
    the following code does this using X2 to hold the effective address:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，32位指令大小严重限制了该寻址模式的范围（只有9位可用于有符号偏移量）。如果需要更大的偏移量，必须显式地将值添加到X1中的地址中（如果需要保持X1中的基地址，可能需要使用不同的寄存器）。例如，以下代码通过使用X2来保存有效地址来实现这一点：
- en: '[PRE36]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This computes X2 = X1 + 2000 and loads W2 with the word at that address.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这将计算出X2 = X1 + 2000，并将该地址处的字加载到W2中。
- en: 3.6.4 Scaled Indirect-Plus-Offset
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.4 带缩放的间接加偏移
- en: The *scaled indirect-plus-offset* addressing mode is a somewhat more complex
    variant of the indirect-plus-offset mode. It incorporates a 12-bit unsigned constant
    into the instruction encoding that is scaled (multiplied) by 1, 2, 4, or 8, depending
    on the size of the data transfer. This provides a range extension to the 9-bit
    signed offset of the indirect-plus-offset mode.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*带缩放的间接加偏移*寻址模式是间接加偏移模式的一种稍微复杂的变体。它将一个12位的无符号常数嵌入到指令编码中，并根据数据传输的大小将该常数缩放（乘以）1、2、4或8。这为间接加偏移模式的9位有符号偏移量提供了范围扩展。'
- en: 'This addressing mode uses the same syntax as the indirect-plus-offset addressing
    mode, except that it doesn’t allow signed offsets:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 该寻址模式与间接加偏移寻址模式使用相同的语法，只是它不允许有符号偏移量：
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For byte transfers (ldrb), the unsigned expression can be a value in the range
    0 to 0xFFF (4,095). For half-word transfers (ldrh), the unsigned expression can
    be a value in the range 0 to 0x1FFE, but the offset must be even. For word transfers
    (ldr), the unsigned expression must be in the range 0 to 0x3FFC and must also
    be divisible by 4\. For dword transfers, the unsigned expression must be in the
    range 0 to 0x7FF8 and must be divisible by 8\. As you’ll see in [Chapter 4](chapter4.xhtml),
    these numbers work great for accessing elements of a byte, half-word, word, or
    double-word array.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字节传输（ldrb），无符号表达式可以在0到0xFFF（4,095）范围内。对于半字传输（ldrh），无符号表达式可以在0到0x1FFE范围内，但偏移量必须是偶数。对于字传输（ldr），无符号表达式必须在0到0x3FFC范围内，并且必须是4的倍数。对于双字传输，无符号表达式必须在0到0x7FF8范围内，并且必须是8的倍数。正如你将在[第4章](chapter4.xhtml)中看到的，这些数字非常适合访问字节、半字、字或双字数组的元素。
- en: 'Generally, the assembler will automatically select between the indirect-plus-offset
    and scaled indirect-plus-offset addressing modes, based on the value of the offset
    appearing in the addressing mode. Sometimes the choice might be ambiguous. For
    example:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，汇编器会根据寻址模式中偏移量的值自动选择间接加偏移和带缩放的间接加偏移寻址模式。有时，这个选择可能会有歧义。例如：
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, the assembler could choose the scaled or unscaled versions of the addressing
    mode. Typically, it would choose the scaled form. Its decision shouldn’t matter
    to your code; either form will load the appropriate word in memory into the W0
    register.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，汇编器可以选择带缩放或不带缩放的寻址模式。通常，它会选择带缩放的形式。它的选择不应影响你的代码；无论选择哪种形式，都会将相应的内存单词加载到W0寄存器中。
- en: If, for some reason, you wish to explicitly specify the unscaled addressing
    mode, you can do so using the ldur and stur instructions (load or store register
    unscaled).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因，你希望显式指定不带缩放的寻址模式，可以使用ldur和stur指令（加载或存储不带缩放的寄存器）。
- en: 3.6.5 Pre-indexed
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.5 预索引
- en: The *pre-indexed* addressing mode is very similar to the indirect-plus-offset
    addressing mode, insofar as it combines a 64-bit register and a signed 9-bit offset.
    However, this addressing mode copies the sum of the register and offset into the
    register before accessing memory. In the end, it accesses the same address as
    the indirect-plus-offset mode, but once the instruction finishes, the index register
    points into memory at the indexed location. This mode is useful for stepping through
    arrays and other data structures by incrementing the register after each access
    in a loop.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*预索引*寻址模式与间接加偏移寻址模式非常相似，因为它结合了一个64位寄存器和一个有符号的9位偏移量。然而，这种寻址模式会在访问内存之前将寄存器和偏移量的和复制到寄存器中。最终，它访问的地址与间接加偏移模式相同，但一旦指令完成，索引寄存器将指向内存中的索引位置。该模式在通过循环递增寄存器访问数组和其他数据结构时非常有用。'
- en: 'Here’s the syntax for the pre-indexed addressing mode:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 预索引寻址模式的语法如下：
- en: '[PRE39]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The ! at the end of this sequence differentiates the pre-indexed addressing
    mode. As with the indirect-plus-offset mode, the signed_expression value is limited—in
    this case, to 9 bits (–256 to +255).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 该序列末尾的!符号区分了预索引寻址模式。与间接加偏移模式类似，signed_expression值是有限制的——在这种情况下，限制为9位（–256到+255）。
- en: 'The following code fragment uses this addressing mode:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段使用了该寻址模式：
- en: '[PRE40]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: On the first iteration of this loop, the addressing mode adds 1 to X0 so that
    it points at the first byte in the bVar array of 4 bytes. This also leaves X0
    pointing at that first byte. On each successful iteration of the loop, X0 is incremented
    by 1, accessing the next byte in the bVar array.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在该循环的第一次迭代中，寻址模式将1加到X0，使其指向bVar数组中第一个字节（4字节数组）。这也使得X0指向该第一个字节。在每次成功的循环迭代中，X0递增1，访问bVar数组中的下一个字节。
- en: The subs instruction will set the Z flag when it decrements X1 down to 0\. When
    that happens, the bne (branch if Z = 0) instruction will fall through, terminating
    the loop.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: subs指令将在X1递减到0时设置Z标志。当发生这种情况时，bne（如果Z = 0则分支）指令将跳过，终止循环。
- en: 3.6.6 Post-Indexed
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.6 后索引
- en: 'The post-indexed addressing mode is very similar to the pre-indexed addressing
    mode, except it uses the value of the register as the memory address *before*
    updating the register with the signed immediate value. Here’s the syntax for the
    post-indexed addressing mode:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 后索引寻址模式与预索引寻址模式非常相似，只是它在用有符号的立即数值更新寄存器之前，使用寄存器的值作为内存地址。后索引寻址模式的语法如下：
- en: '[PRE41]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Again, the signed_expression is limited to 9 bits (–256 to +255).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，signed_expression的值限制为9位（–256到+255）。
- en: 'The example of the previous section can be rewritten and slightly improved
    by using the post-indexed addressing mode:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的示例可以通过使用后索引寻址模式进行改写并稍作改进：
- en: '[PRE42]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This example starts with X0 pointing at bVar and ends with X0 pointing at the
    first byte beyond the (four-element) bVar array. On the first iteration of this
    loop, the ldr instruction first uses the value in X0, pointing at bVar, then increments
    X0 after fetching the byte where X0 points.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子开始时X0指向bVar，并以X0指向超出（四元素）bVar数组的第一个字节结束。在该循环的第一次迭代中，ldr指令首先使用X0中的值，指向bVar，然后在取出X0指向的字节后递增X0。
- en: '#### 3.6.7 Scaled-Indexed'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 3.6.7 缩放索引'
- en: 'The *scaled-indexed* addressing mode contains two register components (rather
    than a register and an immediate constant) that form the effective address. The
    syntax for this mode is the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*缩放索引*寻址模式包含两个寄存器组件（而不是一个寄存器和一个立即数），它们共同形成有效地址。该模式的语法如下：'
- en: '[PRE43]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The first form is the easiest to understand: it computes the effective address
    (EA) by adding the values in X*n* (or SP) and X*i*. Generally, X*n* (or SP) is
    known as the *base address*, and the value in X*i* is the index (which must be
    X0 to X30 or XZR). The base address is the lowest memory address of an object,
    and the index is an offset from that base address (much like the immediate constants
    in the indirect-plus-offset addressing mode). This is just a simple *base + index*
    addressing mode: no scaling takes place.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种形式最容易理解：它通过将X*n*（或SP）和X*i*中的值相加来计算有效地址（EA）。通常，X*n*（或SP）被称为*基地址*，而X*i*中的值是索引（必须是X0到X30或XZR）。基地址是对象的最低内存地址，索引是相对于该基地址的偏移量（有点类似于间接加偏移寻址模式中的立即数）。这就是一个简单的*基地址
    + 索引*寻址模式：不进行缩放。
- en: 'The base + index form is useful in these situations:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 基地址 + 索引形式在以下情况中非常有用：
- en: You have a pointer to an array object in a register (X*n*, the base address),
    and you want to access an element of that array by using an integer index (typically
    in a memory variable). In this case, you would load the index into the index register
    (X*i*) and use the base + index mode to access the actual element.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个指向数组对象的指针存储在寄存器中（X*n*，基地址），并且你想通过整数索引（通常是内存变量中的索引）访问该数组的元素。在这种情况下，你会将索引加载到索引寄存器（X*i*）中，并使用基址+索引模式来访问实际元素。
- en: You want to use the indirect-plus-offset addressing mode, but the offset is
    outside the range –256 to +255\. In this case, you can load the larger offset
    into X*i* and use the base + index addressing mode to access the memory location
    regardless of the offset.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想使用间接加偏移寻址模式，但偏移量超出了-256到+255的范围。在这种情况下，你可以将较大的偏移量加载到X*i*寄存器中，并使用基址+索引寻址模式访问内存位置，无论偏移量是多少。
- en: The second and third forms of the scaled-indexed addressing mode provide an
    extension/scaling operation, which is quite useful for indexing into arrays whose
    element size is larger than a byte. Of these two scaled-indexed modes, one uses
    a 32-bit register as the index register, and the other uses a 64-bit register.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放索引寻址模式的第二种和第三种形式提供了扩展/缩放操作，对于索引大于字节的数组元素来说非常有用。在这两种缩放索引模式中，一种使用32位寄存器作为索引寄存器，另一种使用64位寄存器。
- en: The 32-bit form is convenient because most of the time indices into an array
    are held in a 32-bit integer variable. If you load that 32-bit integer into a
    32-bit register (W*i*), you can easily use it as an index into an array with the
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 32位形式是方便的，因为大多数情况下，数组的索引都保存在32位整数变量中。如果将这个32位整数加载到32位寄存器（W*i*）中，就可以轻松地将其用作数组的索引。
- en: '[PRE44]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: form of the scaled-indexed addressing mode.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放索引寻址模式的形式。
- en: Ultimately, all effective addresses turn out to be 64 bits. In particular, when
    the CPU adds X*n* and W*i* together, it must somehow extend the W*i* index value
    to 64 bits prior to adding them. The extend operator tells Gas how to extend W*i*
    to 64 bits.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，所有有效地址都是64位的。特别是，当CPU将X*n*和W*i*相加时，它必须先以某种方式将W*i*索引值扩展到64位，然后再进行相加。扩展操作符告诉Gas如何将W*i*扩展到64位。
- en: 'The simplest forms of extend are the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展的最简单形式如下：
- en: '[PRE45]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The [Xn|SP, Wi, uxtw] form zero-extends W*i* to 64 bits before adding it to
    X*n*, while the [Xn|SP, Wi, sxtw] form sign-extends W*i* to 64 bits before the
    addition.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[Xn|SP, Wi, uxtw]形式会在将W*i*加到X*n*之前，先将W*i*零扩展到64位，而[Xn|SP, Wi, sxtw]形式则会在加法之前，将W*i*符号扩展到64位。'
- en: 'Another form of the scaled-indexed addressing mode introduces the *scaled*
    component. This form allows you to load elements from an array of bytes, half
    words, words, or dwords scaled by the size of the array element (1, 2, 4, or 8
    bytes). These particular forms are not stand-alone addressing modes that can be
    used with an arbitrary ldr or str instruction. Instead, each addressing mode form
    is tied to a specific instruction size. The following is the allowable syntax
    for the ldrb/ldrsb and strb instructions (W*d* is a 32-bit destination register,
    and W*s* is a 32-bit source register):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种缩放索引寻址模式引入了*缩放*组件。这种形式允许你根据数组元素的大小（1、2、4或8字节）加载字节、半字、字或双字数组中的元素。这些特定形式并不是可以与任意的ldr或str指令一起使用的独立寻址模式。相反，每种寻址模式形式都与特定的指令大小相关联。以下是ldrb/ldrsb和strb指令的允许语法（W*d*是32位目标寄存器，W*s*是32位源寄存器）：
- en: '[PRE46]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'These forms zero- or sign-extend W*i* (or X*i*) and add the result with X*n*
    to produce the EA. The previous instructions are equivalent to the following (because
    the #0 is optional):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这些形式会对W*i*（或X*i*）进行零扩展或符号扩展，并将结果与X*n*相加，生成有效地址。之前的指令等价于以下形式（因为#0是可选的）：
- en: '[PRE47]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For the ldrh/ldrsh and strh instructions, you can specify either the 0 (×1)
    or 1 (×2) scale factor:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ldrh/ldrsh和strh指令，你可以指定0（×1）或1（×2）作为缩放因子：
- en: '[PRE48]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'With a scaling factor of #1, these addressing modes compute W*i* × 2 or X*i*
    × 2 (after any zero or sign extension) and then add the result with the value
    in X*n* to produce the EA. This scales the EA to access half-word values (2 bytes
    per array element). If the scaling factor is #0, no scaling occurs, as the scaling
    factor is 2⁰. The preceding code must multiply W*i* or X*i* by an appropriate
    scaling factor, if needed. Loading or storing half words allows a scaling factor
    of only 0 or 1.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在缩放因子为#1时，这些寻址模式计算W*i* × 2或X*i* × 2（在进行任何零扩展或符号扩展后），然后将结果与X*n*中的值相加以生成EA。这会缩放EA，以访问半字值（每个数组元素2个字节）。如果缩放因子为#0，则不进行缩放，因为缩放因子是2⁰。前面的代码必须将W*i*或X*i*乘以适当的缩放因子（如有需要）。
- en: 'For the 32-bit ldr instruction (W*d* is the destination register) and str instruction
    (W*s* is the 32-bit source register), the allowable scaling factors are 0 (×1)
    or 2 (×4):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对于32位的ldr指令（W*d*为目标寄存器）和str指令（W*s*为32位源寄存器），允许的缩放因子为0（×1）或2（×4）：
- en: '[PRE49]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, for the 64-bit ldr and str instructions, the allowable scaling factors
    are 0 (×1) and 3 (×8):'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于64位的ldr和str指令，允许的缩放因子是0（×1）和3（×8）：
- en: '[PRE50]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You’ll see the main uses for the scaled-indexed addressing modes in the next
    chapter, when it discusses accessing elements of arrays.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将看到缩放索引寻址模式的主要用途，届时会讨论如何访问数组元素。
- en: 3.7 Address Expressions
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7 地址表达式
- en: Often, when accessing variables and other objects in memory, you will need to
    access locations immediately before or after a variable rather than at the address
    of the variable. For example, when accessing an element of an array, or a field
    of a struct, the exact element or field is probably not at the address of the
    variable itself. *Address expressions* provide a mechanism to access memory at
    an offset from the variable’s address.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在访问内存中的变量和其他对象时，你需要访问位于变量前后的位置，而不是变量本身的地址。例如，在访问数组元素或结构体字段时，确切的元素或字段可能并不位于变量的地址本身。*地址表达式*提供了一种机制，可以在变量地址的偏移量处访问内存。
- en: 'Consider the following legal Gas syntax for a memory address. This isn’t a
    new addressing mode but simply an extension of the PC-relative addressing mode:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下合法的Gas语法，用于表示内存地址。这并不是一种新的寻址模式，而只是对PC相对寻址模式的扩展：
- en: '[PRE51]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This form computes its effective address by adding the constant offset to the
    variable’s address. For example, the instruction
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式通过将常量偏移量加到变量的地址来计算其有效地址。例如，指令
- en: '[PRE52]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: loads the W0 register with the word in memory that is 4 bytes beyond the i object
    (which, presumably, is in the .text section; see [Figure 3-10](chapter3.xhtml#fig3-10)).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 将W0寄存器加载为内存中距离i对象（假设它位于.text段）4个字节的字数据；见[图3-10](chapter3.xhtml#fig3-10)。
- en: '![](../images/Figure3-10.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-10.jpg)'
- en: 'Figure 3-10: Using an address expression to access data beyond a variable'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-10：使用地址表达式访问超出变量的数据
- en: The offset value in this example must be a constant (for example, 3). If Index
    is a word variable, then varName + Index is not a legal address expression. If
    you wish to specify an index that varies at runtime, you must use one of the indirect
    or scaled-indexed addressing modes. Also remember that the offset in varName +
    offset is a byte address. This does not properly index into an array of objects
    unless varName is an array of bytes.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的偏移量值必须是常量（例如，3）。如果Index是一个字变量，那么varName + Index就不是一个合法的地址表达式。如果你希望指定一个在运行时变化的索引，则必须使用间接寻址模式或缩放索引寻址模式之一。还要记住，varName
    + offset中的偏移量是字节地址。除非varName是字节数组，否则这不能正确地为一个对象数组建立索引。
- en: '> NOTE'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '> 注'
- en: '*The ARM CPU does not allow the use of the* ldrb *and* ldrh *instructions when
    using the PC-relative addressing mode. You can only load words or double words
    when using this addressing mode. Furthermore, because the instructions don’t encode
    the LO 2 bits of the offset, any offset you specify using an address expression
    must be a multiple of 4.*'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*在使用PC相对寻址模式时，ARM CPU不允许使用* ldrb *和* ldrh *指令。你只能在使用这种寻址模式时加载字或双字。此外，因为这些指令不会编码偏移量的低2位，所以你通过地址表达式指定的任何偏移量必须是4的倍数。*'
- en: Until this point, the offset in the addressing mode examples has always been
    a single numeric constant. However, Gas also allows a constant expression anywhere
    an offset is legal. A *constant expression* consists of one or more constant terms
    manipulated by operators such as addition, subtraction, multiplication, division,
    and a wide variety of others, as shown in [Table 3-4](chapter3.xhtml#tab3-4).
    Note that operators at the same precedence level are left-associative.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，寻址模式示例中的偏移量始终是单一的数字常量。然而，Gas也允许常量表达式出现在任何合法的偏移量位置。一个*常量表达式*由一个或多个常量项组成，这些常量项通过加法、减法、乘法、除法等运算符进行操作，具体如[表3-4](chapter3.xhtml#tab3-4)所示。请注意，同一优先级的运算符是左结合的。
- en: 'Table 3-4: Gas Constant Expression Operators'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 表3-4：Gas常量表达式运算符
- en: '| Operator | Precedence | Description |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 优先级 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| + | 3 | Unary plus (no effect on expression) |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| + | 3 | 一元加号（对表达式没有影响） |'
- en: '| - | 3 | Unary minus (negates expression) |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| - | 3 | 一元负号（取反表达式） |'
- en: '| * | 2 | Multiplication |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| * | 2 | 乘法 |'
- en: '| / | 2 | Division |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| / | 2 | 除法 |'
- en: '| << | 2 | Shift left |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| << | 2 | 左移 |'
- en: '| >> | 2 | Shift right |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| >> | 2 | 右移 |'
- en: '| &#124; | 1 | Bitwise OR |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| &#124; | 1 | 按位或 |'
- en: '| & | 1 | Bitwise AND |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| & | 1 | 按位与 |'
- en: '| ^ | 1 | Bitwise XOR |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| ^ | 1 | 按位异或 |'
- en: '| ! | 1 | Bitwise AND-NOT |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| ! | 1 | 按位与非 |'
- en: '| + | 0 | Addition |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| + | 0 | 加法 |'
- en: '| - | 0 | Subtraction |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| - | 0 | 减法 |'
- en: 'Most address expressions, however, involve only addition, subtraction, multiplication,
    and sometimes division. Consider the following example:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数地址表达式仅涉及加法、减法、乘法，有时还涉及除法。考虑以下示例：
- en: '[PRE53]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This instruction will move the byte at address X + 8 into the W0 register.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令将把地址X + 8处的字节移动到W0寄存器中。
- en: The value X + 2*4 is an address expression that is always computed at compile
    time, never while the program is running. When Gas encounters the preceding instruction,
    it calculates
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 值X + 2*4是一个地址表达式，它总是在编译时计算，而不是在程序运行时计算。当Gas遇到前面的指令时，它会计算
- en: '[PRE54]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: on the spot and adds this result to the base address of X in the .text section.
    Gas encodes this single sum (base address of X plus 8) as part of the instruction;
    it does not emit extra instructions (that would waste time) to compute this sum
    for you at runtime. Because Gas computes the value of address expressions at compile
    time, and therefore Gas cannot know the runtime value of a variable while it is
    compiling the program, all components of the expression must be constants.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 该结果立即添加到.text段中的X基地址上。Gas将此单一的和（X的基地址加8）作为指令的一部分进行编码；它不会发出额外的指令（那样会浪费时间）在运行时为你计算这个和。因为Gas在编译时计算地址表达式的值，所以在编译程序时Gas无法知道变量的运行时值，因此表达式中的所有组成部分必须是常量。
- en: Address expressions are useful for accessing the data in memory beyond a variable,
    particularly when you’ve used directives like .byte, .hword, .word, and so on
    in a .data or .text section to tack on additional values after a data declaration.
    For example, consider the program in Listing 3-1 that uses address expressions
    to access the four consecutive words associated with memory object i (each word
    is 4 bytes apart in memory).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 地址表达式在访问内存中的数据时非常有用，特别是当你在.data或.text段中使用了像.byte、.hword、.word等指令，向数据声明后附加了额外的值时。例如，考虑在示例3-1中的程序，使用地址表达式访问与内存对象i关联的四个连续的字（每个字在内存中相隔4字节）。
- en: '[PRE55]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Loading W1 from location i + 0 fetches 0 from the word array ❶. Loading W1 from
    location i + 4 fetches 1 from the second word in the array, located 4 bytes beyond
    the first element ❷. Loading W1 from location i + 8 fetches 2 from the third word
    in the array ❸, located 8 bytes beyond the first element. Loading W1 from location
    i + 12 fetches 3 from the fourth word in the array ❹, located 12 bytes beyond
    the first element.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 从位置i + 0加载W1会从字数组❶中获取0。 从位置i + 4加载W1会从数组中的第二个字获取1，该字位于第一个元素4字节之外❷。 从位置i + 8加载W1会从数组中的第三个字获取2，该字位于第一个元素8字节之外❸。
    从位置i + 12加载W1会从数组中的第四个字获取3，该字位于第一个元素12字节之外❹。
- en: 'Here’s the program’s output:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是程序的输出：
- en: '[PRE56]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Because the value at the address of i is 0, the output displays the four values
    0, 1, 2, and 3 as though they were array elements. The address expression i +
    4 tells Gas to fetch the word appearing at i’s address plus 4\. This is the value
    1, because the .word statement in this program emits the value 1 to the .text
    segment immediately after the (word/4-byte) value 0. Likewise, for i + 4 and i
    + 8, this program displays the values 2 and 3.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 由于i地址处的值为0，输出会显示四个值0、1、2和3，仿佛它们是数组元素。地址表达式i + 4告诉Gas获取位于i地址加4的位置的字。这个值是1，因为该程序中的.word语句在（字/4字节）值0之后将值1写入.text段。类似地，对于i
    + 4和i + 8，该程序分别显示值2和3。
- en: 3.8 Getting the Address of a Memory Object
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.8 获取内存对象的地址
- en: Up to this point, this book has used the lea macro to obtain the address of
    a memory object. Now that this chapter has provided the necessary prerequisite
    information, instead of treating lea like a black box, it’s time to look behind
    the curtains to see what this macro is doing for you.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书已经使用lea宏来获取内存对象的地址。现在，本章提供了必要的前提信息，接下来，我们将不再将lea视为一个黑盒，而是深入探讨这个宏究竟为你做了什么。
- en: 'The ARM CPU provides two instructions for computing the effective address of
    a symbol in an assembly language program. The first is adr:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ARM CPU提供了两条指令来计算汇编语言程序中符号的有效地址。第一条是adr：
- en: '[PRE57]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This instruction loads the 64-bit destination register (X*d*) with the address
    of the specified label. Because instruction encodings (operation codes, or *opcodes*)
    are limited to 32 bits, a huge caveat is attached to adr: it has room for only
    a 21-bit offset within the opcode, so label must be a PC-relative address within
    ±1MB of the adr instruction. This effectively limits adr to taking the address
    of symbols within the .text section.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令将64位目标寄存器（X*d*）加载为指定标签的地址。由于指令编码（操作码，或*操作码*）限制为32位，因此adr指令有一个重要的限制：它在操作码中只能容纳一个21位的偏移量，因此标签必须是相对于程序计数器（PC）的地址，并且距离adr指令的距离在±1MB以内。这实际上将adr指令限制为只能获取.text段内符号的地址。
- en: 'To rectify this situation, the ARM CPU also provides the adrp (address of a
    page) instruction. This instruction has roughly the same generic syntax as adr:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，ARM CPU还提供了adrp（页面地址）指令。该指令的语法与adr指令大致相同：
- en: '[PRE58]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The instruction loads the address of the MMU page containing the label into
    the destination register. By adding the offset of the label into that page to
    the value in X*d*, you can obtain the actual address of the memory object, using
    code that looks something like this:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令将包含标签的MMU页面的地址加载到目标寄存器中。通过将标签在该页面中的偏移量加到X*d*中的值，你可以获得内存对象的实际地址，代码大致如下：
- en: '[PRE59]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: At this point, X*d* will contain the address of label.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，X*d*将包含标签的地址。
- en: 'This scheme has a couple of issues: first, computing the page offset of the
    label symbol is done differently in macOS versus Linux. Second, when you use the
    syntax just given to try the adrp instruction, you’ll find that Gas rejects this
    on macOS.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方案存在几个问题：首先，计算标签符号的页面偏移在macOS和Linux中的方式不同。其次，当你使用上述语法尝试adrp指令时，你会发现Gas在macOS上会拒绝该语法。
- en: 'Let’s first consider the Linux solutions to these problems, as they’re a little
    simpler than those for macOS. If you’re not creating a PIE application and the
    symbol is less than ±1MB away, you don’t have to use the adrp instruction. Instead,
    you can get by with the single adr instruction. If the data is more than ±1MB
    from the adr, you must use the adrp version. If you need to reference a memory
    object outside the .text section, you must use the adrp/add sequence. Here’s the
    code to do this:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先考虑Linux对这些问题的解决方案，因为它们比macOS的解决方案稍微简单一些。如果你没有创建PIE应用程序，并且符号距离不超过±1MB，那么你不需要使用adrp指令。相反，你可以仅使用adr指令。如果数据距离adr指令超过±1MB，则必须使用adrp版本。如果你需要引用.text段之外的内存对象，则必须使用adrp/add序列。以下是执行此操作的代码：
- en: '[PRE60]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The :lo12: item is a special operator that tells Gas to extract the LO 12 bits
    of label’s relocatable address; this value is the index into a 4,096-byte memory
    management page. For more information on this operator, see section 3.12, “For
    More Information,” on [page 167](chapter3.xhtml#pg_167). Unfortunately, the macOS
    assembler uses a completely different syntax to obtain the LO 12 bits of an address;
    you must use the following instead:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ':lo12: 项目是一个特殊的操作符，告诉 Gas 提取标签的可重定位地址的 LO 12 位；这个值是指向一个 4,096 字节内存管理页面的索引。有关此操作符的更多信息，请参见第
    3.12 节，“更多信息”，位于 [第 167 页](chapter3.xhtml#pg_167)。不幸的是，macOS 汇编器使用完全不同的语法来获取地址的
    LO 12 位；你必须使用以下内容：'
- en: '[PRE61]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The lea macro resolves this issue, automatically expanding into the appropriate
    sequence for whichever OS you’re using.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: lea 宏解决了这个问题，自动扩展成适用于你使用的操作系统的适当指令序列。
- en: 3.9 The Push and Pop Operations
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.9 推送和弹出操作
- en: The ARM maintains a hardware stack in the stack segment of memory (for which
    the OS reserves the storage). The *stack* is a dynamic data structure that grows
    and shrinks according to certain needs of the program. It also stores important
    information about the program, including local variables, subroutine information,
    and temporary data.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 在内存的堆栈段中维护一个硬件堆栈（操作系统为此保留存储空间）。*堆栈* 是一种动态数据结构，随着程序的需要而增长和缩小。它还存储程序的关键信息，包括局部变量、子程序信息和临时数据。
- en: The ARM CPU controls its stack via the SP register. When your program begins
    execution, the OS initializes SP with the address of the last memory location
    in the stack memory segment. Data is written to the stack segment by *pushing*
    data onto the stack and *popping* it off the stack.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ARM CPU 通过 SP 寄存器控制其堆栈。当程序开始执行时，操作系统将 SP 初始化为堆栈内存段中最后一个内存位置的地址。数据通过*推送*数据到堆栈和*弹出*数据从堆栈中移出，写入堆栈段。
- en: The ARM stack must always be 16-byte aligned—that is, the SP register must always
    contain a value that is a multiple of 16\. If you load the SP register with a
    value that is not 16-byte aligned, the application will immediately terminate
    with a bus error fault. One of the stack’s primary purposes is to provide a temporary
    storage area where you can save things such as register values. You will typically
    push a register’s value onto the stack, do some work (such as calling a function)
    that uses the register, and then pop that value off the stack and back into the
    register when you want to restore its value. However, the general-purpose registers
    are only 64 bits (8 bytes); pushing a dword value on the stack will not leave
    it 16-byte aligned, which will crash the system.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 堆栈必须始终保持 16 字节对齐——也就是说，SP 寄存器必须始终包含一个 16 的倍数值。如果你将 SP 寄存器加载一个不满足 16 字节对齐的值，应用程序将立即因总线错误而终止。堆栈的主要用途之一是提供一个临时存储区域，用来保存如寄存器值等内容。你通常会将一个寄存器的值推入堆栈，执行一些操作（如调用一个函数），然后在你想恢复该值时，将其从堆栈弹出并放回寄存器中。然而，通用寄存器只有
    64 位（8 字节）；将一个双字值推入堆栈将导致堆栈不再 16 字节对齐，从而导致系统崩溃。
- en: 'In this section, I’ll describe how to push and pop register values. Then I’ll
    present three solutions to the problem of pushing dword values that don’t leave
    the stack 16-byte aligned: wasting storage; pushing two registers simultaneously;
    and reserving storage on the stack, then moving the register’s data into this
    reserved area.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将描述如何推送和弹出寄存器值。接着，我将介绍三种解决推送不保持堆栈 16 字节对齐的双字值问题的方法：浪费存储；同时推送两个寄存器；以及在堆栈上保留存储空间，然后将寄存器的数据移动到该预留区域。
- en: 3.9.1 Using Double Loads and Stores
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.9.1 使用双重加载和存储
- en: 'The ldp instruction will load two registers from memory simultaneously. The
    generic syntax for this instruction is shown here:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: ldp 指令将同时从内存中加载两个寄存器。该指令的通用语法如下所示：
- en: '[PRE62]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The first form will load Xd1 from the memory location specified by mem and Xd2
    from the memory location 8 bytes later. The second form will load Wd1 from the
    specified memory location and Wd2 from the location 4 bytes later.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种形式将从指定的内存位置加载 Xd1，并从 8 字节后的位置加载 Xd2。第二种形式将从指定的内存位置加载 Wd1，并从 4 字节后的位置加载 Wd2。
- en: 'The stp instruction has a similar syntax; it stores a pair of registers into
    adjacent memory locations:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: stp 指令具有类似的语法，它将一对寄存器存储到相邻的内存位置：
- en: '[PRE63]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: These instructions have many uses. With respect to using the stack, however,
    the forms that load and store a pair of 64-bit registers will manipulate 16 bytes
    at a time—exactly what you need when pushing and popping data on the stack.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令有许多用途。就栈的使用而言，加载和存储一对 64 位寄存器的形式将一次操作 16 字节——这正是你在推送和弹出栈上数据时所需要的。
- en: 3.9.2 Executing the Basic Push Operation
  id: totrans-373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.9.2 执行基本的推入操作
- en: 'Many CPUs, such as the Intel x86-64, provide an explicit instruction that will
    push a register onto the stack. Because of the 16-byte stack alignment requirement,
    you can’t push a single 8-byte register onto the stack (without creating a stack
    fault). However, if you’re willing to use 16 bytes of space on the stack to hold
    a single register’s value, you can push that register’s value on the stack with
    the following instruction:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 CPU，如 Intel x86-64，提供了一个显式指令，可以将寄存器压入栈中。由于 16 字节栈对齐要求，你不能将一个单独的 8 字节寄存器压入栈中（否则会产生栈错误）。然而，如果你愿意在栈上使用
    16 字节的空间来保存一个寄存器的值，你可以使用以下指令将该寄存器的值压入栈中：
- en: '[PRE64]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Remember, the pre-indexed addressing mode will first add –16 to SP and then
    store X*s* (the source register) at the new location pointed at by SP. This store
    operation writes only to the LO 8 bytes of the 16-byte block created by dropping
    SP down by 16 (wasting the HO 8 bytes). However, this scheme keeps the CPU happy,
    so you won’t get a bus error.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，预索引寻址模式会首先将 -16 加到 SP 上，然后将 X*s*（源寄存器）的值存储到 SP 指向的新位置。该存储操作只会写入由 SP 向下移动
    16 字节创建的 16 字节块的低 8 字节（浪费高 8 字节）。然而，这种方案让 CPU 保持正常运行，因此你不会遇到总线错误。
- en: 'This push operation does the following:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 该推入操作执行了以下操作：
- en: '[PRE65]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: For example, assuming that SP contains 0x00FF_FFE0, the instruction
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设 SP 的值为 0x00FF_FFE0，指令
- en: '[PRE66]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: will set SP to 0x00FF_FFD0 and store the current value of X0 into memory location
    0x00FF_FFD0, as [Figures 3-11](chapter3.xhtml#fig3-11) and [3-12](chapter3.xhtml#fig3-12)
    show.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 会将 SP 设置为 0x00FF_FFD0，并将 X0 的当前值存储到内存位置 0x00FF_FFD0，如[图 3-11](chapter3.xhtml#fig3-11)和[图
    3-12](chapter3.xhtml#fig3-12)所示。
- en: '![](../images/Figure3-11.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-11.jpg)'
- en: 'Figure 3-11: The stack segment before the str x0, [sp, #-16]! operation'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '图 3-11：`str x0, [sp, #-16]!` 操作前的栈段'
- en: After the str instruction, the stack looks like [Figure 3-12](chapter3.xhtml#fig3-12).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`str` 指令执行后，栈的情况如[图 3-12](chapter3.xhtml#fig3-12)所示。'
- en: '![](../images/Figure3-12.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-12.jpg)'
- en: 'Figure 3-12: The stack segment after the str x0, [sp, #-16]! operation'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '图 3-12：执行 `str x0, [sp, #-16]!` 操作后的栈段'
- en: Although this wastes 8 bytes of space on the stack (shown at addresses 0x00FF_FFD8
    through 0x00FF_FFDF), the usage is probably temporary, and the stack space will
    be reclaimed when the program pops the data off the stack later.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这会浪费栈上的 8 字节空间（显示在地址 0x00FF_FFD8 到 0x00FF_FFDF 之间），但这种使用可能是暂时的，栈空间将在程序稍后弹出数据时被回收。
- en: 3.9.3 Executing the Basic Pop Operation
  id: totrans-388
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.9.3 执行基本的弹出操作
- en: 'The pop operation can be handled using the post-indexed addressing mode and
    a ldr instruction:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出操作可以通过使用后索引寻址模式和 `ldr` 指令来处理：
- en: '[PRE67]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This instruction fetches the data from the stack, where SP is pointing, and
    copies that data into the destination register (X*d*). When the operation is complete,
    this instruction adjusts SP by 16, restoring it to its original value (its value
    before the push operation). [Figure 3-13](chapter3.xhtml#fig3-13) shows the stack
    before the pop operation.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令从栈中获取数据（SP 所指向的位置），并将数据复制到目标寄存器（X*d*）。操作完成后，该指令会调整 SP 值，减少 16，使其恢复到原始值（即推送操作之前的值）。[图
    3-13](chapter3.xhtml#fig3-13)显示了弹出操作前的栈。
- en: '![](../images/Figure3-13.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-13.jpg)'
- en: 'Figure 3-13: Before the str operation'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-13：`str` 操作前的栈
- en: '[Figure 3-14](chapter3.xhtml#fig3-14) shows the stack organization after executing
    ldr.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-14](chapter3.xhtml#fig3-14)显示了执行 `ldr` 后的栈组织。'
- en: '![](../images/Figure3-14.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-14.jpg)'
- en: 'Figure 3-14: After the pop operation'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-14：弹出操作后的栈
- en: Popping a value does not erase the value in memory; it just adjusts the stack
    pointer so that it points at the next value above the popped value. However, never
    attempt to access a value you’ve popped off the stack. The next time something
    is pushed onto the stack, the popped value will be obliterated. Because your code
    isn’t the only thing that uses the stack (for example, the OS uses the stack to
    do subroutines), you cannot rely on data remaining in stack memory once you’ve
    popped it off the stack.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出一个值并不会清除内存中的值；它只是调整栈指针，使其指向弹出值上方的下一个值。然而，绝不要尝试访问你从栈中弹出的值。下一次将某个值压入栈时，弹出的值会被彻底覆盖。因为不仅仅是你的代码在使用栈（例如，操作系统使用栈来执行子例程），所以你不能依赖于数据在弹出栈后仍然存在于栈内存中。
- en: 3.9.4 Preserving at Least Two Registers
  id: totrans-398
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.9.4 至少保存两个寄存器
- en: 'If you need to preserve at least two registers, you can reclaim the wasted
    space shown in [Figures 3-11](chapter3.xhtml#fig3-11) and [3-12](chapter3.xhtml#fig3-12)
    by using the stp instruction rather than str. The following code fragment demonstrates
    how to push and pop both X0 and X7 simultaneously:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要保存至少两个寄存器，你可以通过使用stp指令而不是str来回收[图3-11](chapter3.xhtml#fig3-11)和[3-12](chapter3.xhtml#fig3-12)中显示的浪费空间。以下代码片段演示了如何同时推送和弹出X0和X7：
- en: '[PRE68]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The third way to push data on the stack is to drop SP down by a multiple of
    16 bytes and then store the value into the stack area by indexing off the SP register.
    The following code does basically the same thing as the stp/ldp pair:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据推入栈的第三种方法是将SP向下移动一个16字节的倍数，然后通过索引SP寄存器将值存储到栈区域。以下代码基本上做了与stp/ldp配对相同的事情：
- en: '[PRE69]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: While this clearly takes more instructions (and, therefore, takes longer to
    execute), it’s possible to reserve the stack storage only once within a function
    and reuse that space throughout the execution of the function. You’ll see examples
    of this in [Chapter 5](chapter5.xhtml).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这显然需要更多的指令（因此，执行时间更长），但它使得你只需在函数内为栈分配一次存储空间，并在整个函数执行过程中重用该空间。你将在[第5章](chapter5.xhtml)中看到此类示例。
- en: 3.9.5 Preserving Register Values on the Stack
  id: totrans-404
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.9.5 在栈上保存寄存器值
- en: 'As you’ve seen in previous examples, the stack is a great place to temporarily
    preserve registers so they can be used for other purposes. Consider the following
    program outline:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在之前的示例中看到的，栈是一个临时保存寄存器的好地方，这样它们就可以被用于其他目的。考虑以下程序大纲：
- en: '[PRE70]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The push and pop operations are perfect for this situation. By inserting a
    push sequence before the middle sequence, and a pop sequence after the middle
    sequence, you can preserve the value in X20 across those calculations:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 推送和弹出操作非常适合这种情况。通过在中间序列之前插入一个推送序列，并在中间序列之后插入一个弹出序列，你可以在这些计算之间保存X20的值：
- en: '[PRE71]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This push sequence copies the data computed in the first sequence of instructions
    onto the stack. Now the middle sequence of instructions can use X20 for any purpose
    it chooses. After the middle sequence of instructions finishes, the pop sequence
    restores the value in X20 so the last sequence of instructions can use the original
    value in X20.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这个推送序列将第一个指令序列中计算出的数据复制到栈上。现在，中间指令序列可以将X20用于任何它选择的用途。在中间指令序列执行完毕后，弹出序列将恢复X20中的值，这样最后的指令序列就可以使用X20中的原始值。
- en: 3.9.6 Saving Function Return Addresses on the Stack
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.9.6 在栈上保存函数返回地址
- en: 'Throughout the example programs up to this point, I’ve preserved the return
    address appearing in the link register (LR) by using instructions like the following:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在到目前为止的示例程序中，我通过使用如下指令来保存出现在链接寄存器（LR）中的返回地址：
- en: '[PRE72]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'I’ve also mentioned that this is a *truly horrible* way of preserving the value
    in LR. It takes six instructions to accomplish (remember, lea expands into two
    instructions), making it slower and bulkier than it needs to be. This scheme also
    creates problems when you have one user-written function calling another: all
    of a sudden, you need two separate saveLR variables, one for each function. In
    the presence of recursion (see [Chapter 5](chapter5.xhtml)) or, worse, multithreaded
    code, this mechanism fails completely.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我也提到过，这是一种*真正糟糕*的保存LR值的方式。它需要六条指令来完成（记住，lea会展开成两条指令），使得它比需要的更慢且更庞大。当你有一个用户编写的函数调用另一个函数时，这个方案也会产生问题：突然之间，你需要两个独立的saveLR变量，每个函数一个。在递归（参见[第5章](chapter5.xhtml)）或更糟糕的多线程代码中，这个机制完全失效。
- en: 'Fortunately, saving return addresses in the stack is the perfect solution.
    The stack’s LIFO structure (see the next section) completely emulates the way
    (nested) function calls and returns work, and it takes only a single instruction
    to push LR onto the stack or pop LR off the stack. The earlier code sequence can
    be easily replaced by:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，保存返回地址到堆栈是完美的解决方案。堆栈的LIFO结构（见下一节）完全模拟了（嵌套）函数调用和返回的方式，而且仅需要一条指令就可以将LR压入堆栈或从堆栈中弹出LR。之前的代码序列可以轻松替换为：
- en: '[PRE73]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Using the stack to save and restore the LR register is probably the most common
    use of the stack. [Chapter 5](chapter5.xhtml) discusses managing return addresses
    and other function-related values in much greater depth.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 使用堆栈保存和恢复LR寄存器可能是堆栈最常见的使用方式。[第5章](chapter5.xhtml)详细讨论了管理返回地址和其他与函数相关的值。
- en: '### 3.10 Pushing and Popping Stack Data'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '### 3.10 压栈和弹栈数据'
- en: You can push more than one value onto the stack without first popping previous
    values off the stack. However, the stack is a *last-in, first-out (LIFO)* data
    structure, so you must be careful in the way you push and pop multiple values.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在不先弹出先前值的情况下将多个值压入堆栈。然而，堆栈是一个*后进先出（LIFO）* 数据结构，因此你在压栈和弹栈多个值时必须小心。
- en: 'For example, suppose you want to preserve X0 and X1 across a block of instructions.
    The following code demonstrates the obvious (but incorrect) way to handle this:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想在一组指令块之间保留X0和X1。以下代码演示了一个明显的（但不正确的）处理方式：
- en: '[PRE74]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Unfortunately, this code will not work properly! [Figures 3-15](chapter3.xhtml#fig3-15)
    through [3-18](chapter3.xhtml#fig3-18) show the problem, with each box in these
    figures representing 8 bytes (note the addresses). Because this code pushes X0
    first and X1 second, the stack pointer is left pointing at X1’s value on the stack.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这段代码无法正常工作！[图3-15](chapter3.xhtml#fig3-15)到[3-18](chapter3.xhtml#fig3-18)展示了这个问题，这些图中的每个框表示8字节（注意地址）。由于这段代码先压入X0，再压入X1，堆栈指针最终指向堆栈中X1的值。
- en: '![](../images/Figure3-15.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-15.jpg)'
- en: 'Figure 3-15: The stack after pushing X0'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-15：压入X0后的堆栈
- en: '[Figure 3-16](chapter3.xhtml#fig3-16) shows the stack after pushing the second
    register (X1).'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-16](chapter3.xhtml#fig3-16)展示了压入第二个寄存器（X1）后的堆栈。'
- en: '![](../images/Figure3-16.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-16.jpg)'
- en: 'Figure 3-16: The stack after pushing X1'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-16：压入X1后的堆栈
- en: 'When the ldr x0, [sp], #16 instruction comes along, it removes the value that
    was originally in X1 from the stack and places it in X0 (see [Figure 3-17](chapter3.xhtml#fig3-17)).'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '当ldr x0, [sp], #16指令执行时，它从堆栈中移除最初在X1中的值并将其放入X0（见[图3-17](chapter3.xhtml#fig3-17)）。'
- en: '![](../images/Figure3-17.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-17.jpg)'
- en: 'Figure 3-17: The stack after popping X0'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-17：弹出X0后的堆栈
- en: 'Likewise, the ldr x1, [sp], #16 instruction pops the value that was originally
    in X0 into the X1 register. In the end, this code manages to swap the values in
    the registers by popping them in the same order that it pushes them (see [Figure
    3-18](chapter3.xhtml#fig3-18)).'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '同样，ldr x1, [sp], #16指令将最初在X0中的值弹出并存入X1寄存器。最终，这段代码通过以与压栈顺序相同的顺序弹栈来交换寄存器中的值（见[图3-18](chapter3.xhtml#fig3-18)）。'
- en: '![](../images/Figure3-18.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-18.jpg)'
- en: 'Figure 3-18: The stack after popping X1'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-18：弹出X1后的堆栈
- en: To rectify this problem, because the stack is a LIFO data structure, the first
    thing you must pop is the last thing you push onto the stack. Therefore, *always
    pop values in the reverse order that you push them.*
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 为了纠正这个问题，因为堆栈是LIFO数据结构，你必须首先弹出的是最后压入堆栈的内容。因此，*始终按照相反的顺序弹出值。*
- en: 'The correction to the previous code is shown here:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 对前一段代码的修正如下所示：
- en: '[PRE75]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Also remember to *always pop exactly the same number of bytes that you push.*
    In general, this means you’ll need exactly the same the number of pushes and pops.
    If you have too few pops, you will leave data on the stack, which may confuse
    the running program. If you have too many pops, you will accidentally remove previously
    pushed data, often with disastrous results.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，*始终弹出你压入的相同数量的字节。* 一般来说，这意味着你需要相同数量的压栈和弹栈操作。如果弹栈操作太少，你将把数据留在堆栈中，这可能会干扰正在运行的程序。如果弹栈操作太多，你会意外地移除先前压入的数据，通常会导致灾难性的结果。
- en: As a corollary, *be careful when pushing and popping data within a loop.* It’s
    easy to put the pushes in a loop and leave the pops outside the loop (or vice
    versa), creating an inconsistent stack. Remember, it’s the execution of the push
    and pop operations that matters, not the number of push and pop operations that
    appear in your program. At runtime, the number (and order) of the push operations
    the program executes must match the number (and reverse order) of the pop operations.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 由此产生的结论是，*在循环中推送和弹出数据时要小心*。很容易将推送操作放在循环内，而将弹出操作放在循环外（或反之），这会导致栈不一致。记住，重要的是执行推送和弹出操作，而不是程序中推送和弹出操作的数量。运行时，程序执行的推送操作数量（及顺序）必须与弹出操作的数量（及相反顺序）匹配。
- en: Finally, remember that *the ARM requires the stack to be aligned on a 16-byte
    boundary*. If you push and pop items on the stack (or use any other instructions
    that manipulate the stack), make sure that the stack is aligned on a 16-byte boundary
    before calling any functions or procedures that adhere to the ARM requirements.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，记住*ARM要求栈必须按照16字节边界对齐*。如果你在栈上进行推送和弹出操作（或使用任何其他操作栈的指令），确保在调用任何遵循ARM要求的函数或过程之前，栈已按照16字节边界对齐。
- en: 3.10.1 Removing Data from the Stack Without Popping It
  id: totrans-439
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.10.1 在不弹出数据的情况下从栈中移除数据
- en: 'You may often discover that you’ve pushed data you no longer need onto the
    stack. Although you could pop the data into an unused register, there is an easier
    way to remove unwanted data from the stack: simply adjust the value in the SP
    register to skip over the unwanted data on the stack.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能经常会发现自己将不再需要的数据推送到栈上。虽然你可以将数据弹出到一个未使用的寄存器中，但有一种更简单的方法来移除栈中不需要的数据：只需调整SP寄存器中的值，以跳过栈中不需要的数据。
- en: 'Consider the following dilemma (in pseudocode, not actual assembly language):'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下困境（伪代码，不是实际汇编语言）：
- en: '[PRE76]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Within the then section of the if statement, this code wants to remove the old
    values of X0 and X1 without otherwise affecting any registers or memory locations.
    How can you do this?
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在if语句的then部分，这段代码希望移除X0和X1的旧值，同时不影响任何其他的寄存器或内存位置。你该如何做到这一点？
- en: 'Because the SP register contains the memory address of the item on the top
    of the stack, we can remove the item from the top by adding the size of that item
    to the SP register. In the preceding example, we wanted to remove two dword items
    from the top. We can easily accomplish this by adding 16 to the stack pointer:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 因为SP寄存器包含栈顶项的内存地址，我们可以通过将该项的大小加到SP寄存器来移除栈顶的项。在之前的示例中，我们希望从栈顶移除两个双字项。我们可以通过将16加到栈指针来轻松实现这一点：
- en: '[PRE77]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Effectively, this code pops the data off the stack without moving it anywhere.
    This code is faster than two dummy pop operations, because it can remove any number
    of bytes from the stack with a single add instruction.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这段代码从栈中弹出数据，但并未将其移到其他地方。这个代码比两个虚拟的弹出操作要快，因为它可以通过一个加法指令从栈中移除任意数量的字节。
- en: Remember to keep the stack aligned on a quad-word (16-byte) boundary. This means
    you should always add a constant that is a multiple of 16 to SP when removing
    data from the stack.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，保持栈在一个四字（16字节）边界上对齐。这意味着，当从栈中移除数据时，你应该始终将一个16的倍数加到SP寄存器中。
- en: 3.10.2 Accessing Data Pushed onto the Stack Without Popping It
  id: totrans-448
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.10.2 在不弹出数据的情况下访问推送到栈的数据
- en: 'Once in a while, you’ll push data onto the stack and will want to get a copy
    of that data’s value, or perhaps you’ll want to change that data’s value without
    actually popping the data off the stack (that is, you wish to pop the data off
    the stack at a later time). The ARM [SP, #±offset] addressing mode provides the
    mechanism for this.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '偶尔，你可能会将数据推送到栈中，并希望获取该数据的值的副本，或者你可能希望在不弹出数据的情况下更改该数据的值（即，你希望稍后弹出数据）。ARM的[SP,
    #±offset]寻址模式提供了这一机制。'
- en: 'Consider the stack after the execution of the following instruction:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑执行以下指令后的栈：
- en: '[PRE78]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This produces the stack result shown in [Figure 3-19](chapter3.xhtml#fig3-19).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生[图3-19](chapter3.xhtml#fig3-19)所示的栈结果。
- en: '![](../images/Figure3-19.jpg)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-19.jpg)'
- en: 'Figure 3-19: The stack after pushing X0 and X1'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-19：推送X0和X1后的栈
- en: If you wanted to access the original X0 value without removing it from the stack,
    you could cheat by popping the value, then immediately pushing it again. Suppose,
    however, that you wish to access X1’s old value or another value even farther
    up the stack. Popping all the intermediate values and then pushing them back onto
    the stack is problematic at best, impossible at worst.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在不移除X0值的情况下访问其原始值，可以通过弹出该值，然后立即将其重新压入来“作弊”。不过，假设你希望访问X1的旧值或堆栈中更高位置的其他值。弹出所有中间值并将它们重新压入堆栈，最多是个问题，最坏情况下甚至不可能。
- en: 'However, as [Figure 3-19](chapter3.xhtml#fig3-19) shows, each value pushed
    on the stack is at a certain offset from the SP register in memory. Therefore,
    we can use the [SP, #±offset] addressing mode to gain direct access to the value
    we are interested in. In the preceding example, you can reload X1 with its original
    value by using this single instruction:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，正如[图 3-19](chapter3.xhtml#fig3-19)所示，每个压入堆栈的值在内存中都位于与SP寄存器的某个偏移量位置。因此，我们可以使用[SP,
    #±offset]寻址模式直接访问我们感兴趣的值。在前面的示例中，你可以通过使用这条单指令来重新加载X1的原始值：'
- en: '[PRE79]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This code copies the 8 bytes starting at memory address SP + 8 into the X1 register.
    This value just happens to be the previous value of X1 that was pushed onto the
    stack. You can use this same technique to access other data values you’ve pushed
    onto the stack.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将从内存地址SP + 8开始的8个字节复制到X1寄存器中。这个值恰好是之前压入堆栈的X1值。你可以使用相同的技术访问其他已经压入堆栈的数据值。
- en: 'Don’t forget that the offsets of values from SP into the stack change every
    time you push or pop data. Abusing this feature can create code that is hard to
    modify; using this feature throughout your code will make it difficult to push
    and pop other data items between the point where you first push data onto the
    stack and the point where you decide to access that data again using the [SP,
    #±offset] memory addressing mode.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了，值从SP寄存器到堆栈的偏移量在每次压入或弹出数据时都会发生变化。滥用这一特性可能会导致代码难以修改；如果在代码中广泛使用此特性，将使得在你首次将数据压入堆栈和你决定再次访问这些数据之间，推送和弹出其他数据项变得困难。
- en: 'The previous section pointed out how to remove data from the stack by adding
    a constant to the SP register. That pseudocode example could probably be written
    more safely as this:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节指出了如何通过向SP寄存器添加常数来从堆栈中移除数据。这个伪代码示例可能可以更安全地写成如下：
- en: '[PRE80]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In this code sequence, the calculated result was stored over the top of the
    values saved on the stack. Later, when the program pops the values, it loads these
    calculated values into X0 and X1.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码序列中，计算结果被存储在堆栈上已保存的值之上。稍后，当程序弹出这些值时，它将这些计算值加载到X0和X1寄存器中。
- en: 3.11 Moving On
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.11 继续前进
- en: This chapter discussed memory organization and access, and how to create and
    access memory variables on the ARM CPU. It went over problems that can occur when
    accessing data beyond the end of a data structure that crosses over into a new
    MMU page, then discussed little- and big-endian memory organizations and how to
    use the ARM memory addressing modes and address expressions to access those memory
    objects in multiple ways. You learned how to align data in memory to improve performance,
    how to obtain the address of a memory object, and the purpose of the ARM stack
    structure.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了内存的组织和访问，以及如何在ARM CPU上创建和访问内存变量。内容涵盖了在访问数据结构的末尾超出数据区域并跨越到新的MMU页面时可能出现的问题，接着讨论了小端和大端内存组织方式，以及如何使用ARM内存寻址模式和地址表达式，以多种方式访问这些内存对象。你还学习了如何在内存中对数据进行对齐以提高性能，如何获取内存对象的地址，以及ARM堆栈结构的目的。
- en: Thus far, this book has generally employed only basic data types such as different-sized
    integers, characters, Boolean objects, and floating-point numbers. Fancier data
    types, such as pointers, arrays, strings, and structs are the subject of the next
    chapter.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书通常只使用了基本数据类型，如不同大小的整数、字符、布尔对象和浮点数。更复杂的数据类型，如指针、数组、字符串和结构体，将在下一章讨论。
- en: 3.12 For More Information
  id: totrans-466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.12 更多信息
- en: See *[https://<wbr>ftp<wbr>.gnu<wbr>.org<wbr>/old<wbr>-gnu<wbr>/Manuals<wbr>/gas<wbr>-2<wbr>.9<wbr>.1<wbr>/html<wbr>_chapter<wbr>/as<wbr>_toc<wbr>.html](https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_toc.html)*
    for details on the GNU assembler.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详见 *[https://<wbr>ftp<wbr>.gnu<wbr>.org<wbr>/old<wbr>-gnu<wbr>/Manuals<wbr>/gas<wbr>-2<wbr>.9<wbr>.1<wbr>/html<wbr>_chapter<wbr>/as<wbr>_toc<wbr>.html](https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_toc.html)*，了解更多关于GNU汇编器的细节。
- en: Learn more about the GNU linker at *[https://<wbr>ftp<wbr>.gnu<wbr>.org<wbr>/old<wbr>-gnu<wbr>/Manuals<wbr>/ld<wbr>-2<wbr>.9<wbr>.1<wbr>/html<wbr>_mono<wbr>/ld<wbr>.html](https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_mono/ld.html)*.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解更多关于 GNU 链接器的信息，请访问 *[https://<wbr>ftp<wbr>.gnu<wbr>.org<wbr>/old<wbr>-gnu<wbr>/Manuals<wbr>/ld<wbr>-2<wbr>.9<wbr>.1<wbr>/html<wbr>_mono<wbr>/ld<wbr>.html](https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_mono/ld.html)*。
- en: For more about the macOS (LLVM) linker, see *[https://<wbr>lld<wbr>.llvm<wbr>.org](https://lld.llvm.org)*.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 macOS (LLVM) 链接器的更多信息，请参见 *[https://<wbr>lld<wbr>.llvm<wbr>.org](https://lld.llvm.org)*。
- en: Visit the ARM developer website at *[https://<wbr>developer<wbr>.arm<wbr>.com](https://developer.arm.com)*
    for more on ARM CPUs.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 ARM 开发者网站 *[https://<wbr>developer<wbr>.arm<wbr>.com](https://developer.arm.com)*，了解更多有关
    ARM CPU 的信息。
- en: Wikipedia offers an explanation of address space layout randomization at *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Address<wbr>_space<wbr>_layout<wbr>_randomization](https://en.wikipedia.org/wiki/Address_space_layout_randomization)*.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikipedia 提供了对地址空间布局随机化的解释，详情见 *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Address<wbr>_space<wbr>_layout<wbr>_randomization](https://en.wikipedia.org/wiki/Address_space_layout_randomization)*。
- en: To better understand position-independent executables, see *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Position<wbr>-independent<wbr>_code](https://en.wikipedia.org/wiki/Position-independent_code)*.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要更好地理解位置无关可执行文件，请参阅 *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Position<wbr>-independent<wbr>_code](https://en.wikipedia.org/wiki/Position-independent_code)*。
- en: 'For information on the :lo12: operator, see the “Assembly Expressions” section
    in the document downloadable from *[https://<wbr>developer<wbr>.arm<wbr>.com<wbr>/documentation<wbr>/100067<wbr>/0612<wbr>/armclang<wbr>-Integrated<wbr>-Assembler](https://developer.arm.com/documentation/100067/0612/armclang-Integrated-Assembler)*.'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '有关 :lo12: 运算符的信息，请参阅文档中的“汇编表达式”部分，文档可从 *[https://<wbr>developer<wbr>.arm<wbr>.com<wbr>/documentation<wbr>/100067<wbr>/0612<wbr>/armclang<wbr>-Integrated<wbr>-Assembler](https://developer.arm.com/documentation/100067/0612/armclang-Integrated-Assembler)*
    下载。'
