- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Disclosed Vulnerabilities and Exploits
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter is dedicated to exploring real-world hacking reports. These previously
    discovered GraphQL vulnerabilities and exploits will reinforce some of this book’s
    lessons and hopefully inspire you to conduct your own security research.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the book, you’ve learned about many approaches to testing GraphQL
    APIs in a lab environment. But in real-world scenarios, you might run into vulnerabilities
    that are unique to the application against which you are performing a test. In
    this chapter, you will discover how specific some vulnerabilities can be. Whenever
    you learn a new technology, reviewing publicly available hacking reports has numerous
    advantages. This chapter will be useful because you’ll discover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: New hacking techniques from others in the community
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other hackers’ approaches to the process of publicly disclosing vulnerabilities,
    including the technical depth of their reports as well as how to communicate with
    external companies, gauge a vulnerability’s severity, and demonstrate its practical
    business impact
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ways to identify the software weaknesses that companies care the most about
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The design and implementation of real-life GraphQL applications, and the types
    of vulnerabilities that companies deal with on a regular basis in their production
    environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Companies’ approaches to vulnerability mitigation, as finding a long-term mitigation
    strategy for a software security flaw is just as important as knowing how to break
    software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you’ll see, whenever you learn something new, there’s a good chance someone
    else has already done work that could give you a head start.
  prefs: []
  type: TYPE_NORMAL
- en: Denial of Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll review publicly disclosed reports that had DoS impacts
    on the APIs of numerous companies (some of which may even be familiar to you).
    Remember from Chapter 5 that DoS vulnerabilities are quite common in GraphQL because
    of the power of the query language. Let’s explore just how much of an impact these
    issues can have on a server.
  prefs: []
  type: TYPE_NORMAL
- en: A Large Payload (HackerOne)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HackerOne’s bug bounty platform uses GraphQL extensively in its production environment.
    In addition to hosting the bug bounty programs of other companies, it runs its
    own program, which hackers can use to disclose security issues identified in the
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: In May 2020, one hacker disclosed such a vulnerability ([https://hackerone.com/reports/887321](https://hackerone.com/reports/887321)).
    They identified that, despite the HackerOne documentation indicating the existence
    of a character limit on the API’s query inputs, this limit wasn’t enforced in
    practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the vulnerability, the hacker coded a Python-based exploit (included
    in the report) that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sets some necessary HTTP request information, such as cookies and authorization
    headers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initializes an empty string variable, `a`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Performs a `for` loop 15,000 times and adds a character string to `a`, effectively
    creating a string of 15,000 characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Performs another `for` loop 50 times to send a mutation query that uses the
    `CreateStructuredScope` field. This field uses the constructed payload from the
    previous step 10 times, effectively providing a value to the field’s `instruction`
    argument containing 150,000 characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Outputs the amount of time it takes the server to return a response to a client
    query. This value is used as an indicator of the query’s possible performance
    impact on the server. The slower the response time, the more obvious it becomes
    that server performance degrades.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is a snippet of the mutation used in the exploit. The large payload
    constructed by the exploit replaces the `$instruction` placeholder as part of
    the mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Sending this mutation to the server proved impactful. After the hacker sent
    a few of these requests, the GraphQL server started running into difficulties,
    returning the HTTP server errors *500 Internal Server Error*, *502 Bad Gateway*,
    and *504* *Gateway Timeout*, effectively causing a DoS. HTTP response codes at
    the 500 level are server-side errors that indicate something went wrong, either
    with the proxy or with the server.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that DoS vulnerabilities don’t necessarily need to knock a server completely
    offline to be effective. They can also consume a lot of resources, causing a visible
    performance degradation.
  prefs: []
  type: TYPE_NORMAL
- en: HackerOne granted the hacker a bounty of $2,500 for responsibly disclosing this
    report.
  prefs: []
  type: TYPE_NORMAL
- en: Regular Expressions (CS Money)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One form of DoS not covered in Chapter 5 uses regular expressions (regex). *Regular
    expression DoS (ReDoS)* exhausts a server by forcing it to process a malicious
    regex pattern whose evaluation consumes significant time and resources. These
    vulnerabilities aren’t API specific, although they can exist in all API technologies,
    including REST, SOAP, and GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'ReDoS vulnerabilities can happen in various ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The client provides a malicious regex pattern as input to the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server contains a regex logic pattern that could result in infinite evaluation
    when a matching input is provided, and a client provides such an input. If the
    input is abnormally large, ReDoS could occur.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of a regex pattern that could be vulnerable to ReDoS: `(a+)+`.
    This pattern can match against any string containing any number of the letter
    `a`, such as `aaaaaaaaaaaaaaaaaaaa`. If a client sent a large payload of 100,000
    `a` characters, the server might slow down while the pattern is being evaluated.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use online regex testing websites such as [https://regex101.com](https://regex101.com)
    to see how a particular expression behaves in practice, as shown in [Figure 10-1](#figure10-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c10/f10001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-1: The online regular expression tester at [https://regex101.com](https://regex101.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In October 2020, an ethical hacker who goes by the handle of mvm reported a
    ReDoS vulnerability in a GraphQL API to CS Money’s bug bounty program ([https://hackerone.com/reports/1000567](https://hackerone.com/reports/1000567)).
    The hacker found that the GraphQL `search` object takes a `q` (query) argument.
    In their testing, they inserted a Unicode null value (`\u0000`) as its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In response to this query, the GraphQL API server returned an interesting error
    that revealed some information critical to identifying the existence of the ReDoS
    vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the string supplied through the `q` argument was inserted into
    regex-matching logic on the server, indicated by the preceding `(?=.*` string
    in the response. The server might use this argument to search for relevant data
    in a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conveniently, the server had query tracing enabled through its extensions.
    *Query tracing* allows GraphQL servers to return response metadata useful for
    debugging and provides information about the query’s performance. The tracing
    information in the response disclosed three informative fields to the client (`startTime`,
    `endTime`, and `duration`), revealing the amount of time it took the server to
    process the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These fields also go to show how sometimes innocent-looking information can
    assist us during a penetration test. Always look at the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'After identifying the potential vulnerability, the hacker then used a malicious
    regex pattern and set it as the value of the `q` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This pattern will match against any character in the ranges `a` to `z`, `A`
    to -`Z`, and `0` to `9`.
  prefs: []
  type: TYPE_NORMAL
- en: The most important takeaway here is that this pattern would most likely match
    against many strings in the application’s backend database, causing the server
    to process (and possibly return) a lot of data. In their report, the hacker shared
    a proof-of-concept cURL command that uses the GraphQL query. They showed that,
    by running it 100 times, they were able to completely take down the GraphQL server.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, malicious payloads can take down servers. We highly discourage
    sending malicious payloads to a company’s production APIs without an explicit
    authorization from the company, as they can negatively impact business if the
    company isn’t equipped to handle malicious payloads.
  prefs: []
  type: TYPE_NORMAL
- en: The company granted a bounty of $250 for this report.
  prefs: []
  type: TYPE_NORMAL
- en: A Circular Introspection Query (GitLab)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following vulnerability was reported to GitLab in July 2019 ([https://gitlab.com/gitlab-org/gitlab/-/issues/30096](https://gitlab.com/gitlab-org/gitlab/-/issues/30096)).
    This vulnerability abuses the circular relationship between the `type` and `field`
    fields in GraphQL’s introspection query.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reporter, who goes by the handle freddd, identified that it was possible
    to trigger a DoS condition by using the `__schema` meta-field to call `types`,
    followed by a recursive call to `fields` and `type`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This query relies on introspection being enabled on the API. When introspection
    is disabled, it’s typically not possible to call the `__schema` meta-field directly.
  prefs: []
  type: TYPE_NORMAL
- en: Although GitLab had implemented query complexity checks to mitigate circular
    query-based DoS attacks, the control didn’t apply to the introspection query,
    effectively leaving it unintentionally vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting this vulnerability also didn’t require the hacker to be authenticated
    to the GraphQL API. The absence of authentication makes it more severe, as it
    lowers the barrier to entry when it comes to who can exploit it.
  prefs: []
  type: TYPE_NORMAL
- en: Aliases for Field Duplication (Magento)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Magento, one of the most popular ecommerce platforms on the internet, uses GraphQL,
    and in April 2021, the platform was impacted by a DoS vulnerability. Using field
    duplication, an attacker could exhaust server resources without being authenticated.
    (Magento allows unauthenticated clients to use certain GraphQL objects and requires
    a valid, authenticated session for others.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We, the authors of this book, identified that Magento did not protect itself
    against malicious queries that repeated fields many times. We used the following
    query as a proof of concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This query used GraphQL aliases as a way to batch repeat queries in a single
    HTTP request, a technique that allowed the attacker to send the server very complex
    queries. It effectively exhausted the server’s resources because of the absence
    of security controls, such as query cost limits.
  prefs: []
  type: TYPE_NORMAL
- en: Magento has since introduced many GraphQL security features into its platform,
    such as GraphQL query complexity limits and query depth analysis. [Figure 10-2](#figure10-2)
    shows the default values for the security controls Magento implemented in its
    API.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c10/f10002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-2: Magento’s default values for query complexity and query depth
    controls'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Magento has implemented a `queryComplexity` value of `300` and
    a `queryDepth` value of `20`, which means that a query cannot exceed a complexity
    level beyond 300, and a circular query cannot exceed 20 levels of nesting.
  prefs: []
  type: TYPE_NORMAL
- en: Array-Based Batching for Field Duplication (WPGraphQL)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This vulnerability is quite similar to the previous field duplication vulnerability
    we discussed. In April 2021, WPGraphQL, a GraphQL plug-in for WordPress ([https://www.wpgraphql.com](https://www.wpgraphql.com)),
    suffered a DoS vulnerability due to a lack of proper security controls and an
    insecure default configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The WPGraphQL plug-in provides a production-ready GraphQL API for any WordPress
    content management system and is available through the WordPress plug-in marketplace.
    [Figure 10-3](#figure10-3) shows this plug-in.
  prefs: []
  type: TYPE_NORMAL
- en: By default, WPGraphQL effectively made any WordPress instance with the plug-in
    vulnerable to DoS. First, it allowed clients to use array-based batching to batch
    multiple queries in a single request. In addition, the plug-in had limited security
    controls in place to protect against malicious queries. Third, because WordPress
    is a blogging platform that often serves unauthenticated clients (for example,
    blog readers), certain sections of the API’s functionalities were accessible without
    special permissions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c10/f10003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-3: The WPGraphQL plug-in for WordPress'
  prefs: []
  type: TYPE_NORMAL
- en: 'We found this vulnerability ourselves and published the following exploit code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This code sets two variables that essentially define the complexity of a single
    HTTP request: `FORCE_MULTIPLIER` is an integer variable that duplicates a selection
    set of fields, and `CHAINED_REQUESTS` holds the number of elements the exploit
    will add into the batched array.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, a `queries` variable is set to an empty array. This variable will hold
    the full malicious payload that will eventually be sent to WPGraphQL. The code
    then creates a special query that will be duplicated by the integer value assigned
    to the `FORCE_MULTIPLIER` variable and crafts this into a query JSON object for
    the HTTP request. Next, a loop runs *N* number of times, where *N* is the value
    of `CHAINED_REQUESTS`. If `CHAINED_REQUESTS` is set to `100`, the loop will run
    100 times and create an array containing 100 elements. Lastly, the exploit sends
    the HTTP request and calculates how long it takes the server to respond to the
    expensive query.
  prefs: []
  type: TYPE_NORMAL
- en: In short, if both `FORCE_MULTIPLIER` and `CHAINED_REQUESTS` are set to `100`,
    the final array will include 100 queries that each contain 100 duplicated fields.
    Imagine how expensive such a query might be to process if these two variables
    were set to 10,000.
  prefs: []
  type: TYPE_NORMAL
- en: Circular Fragments (Agoo)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We discovered a circular fragment vulnerability in May 2022 in a Ruby-based
    GraphQL server implementation named *Agoo*. Identified by CVE-2022-30288, the
    vulnerability stems from the absence of validations checks on incoming queries
    at the Agoo server level. This failure to validate means the server isn’t spec
    compliant. It also means that queries sent to an Agoo server can take it down
    in several ways. Let’s explore how we were able to do this with circular fragments.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, we wanted to check whether introspection was enabled by default,
    so we ran the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This query is simple; it returns the name of all the directives in the schema.
    This is a pretty good query to use when you don’t yet know what operations the
    GraphQL server supports.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we built a circular query using fragments that reference the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We created two fragments on the `__Schema` type. The first fragment `A` uses
    the `directives` top-level field with the `name` field. It then calls (or imports)
    fragment `B` at ❷. Fragment `B` contains `...A` at ❸, which calls fragment `A`
    again. At this point, we have two circular fragments. Now, to get them executed,
    we need to use either of them inside a query. At ❶, you can see how we use fragment
    `A` by calling `...A` inside the `__schema` meta-field.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the cyclical condition starts, and never ends! Running this query
    against Agoo will freeze the server, and it will no longer be able to serve queries.
    The only way to recover it is by restarting Agoo’s server process.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these DoS vulnerabilities were found in big-name products that have
    been using GraphQL for quite some time, proving that no one is immune to vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Broken Authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll explore vulnerabilities that impacted authorization controls
    in GraphQL APIs. These types of issues can eventually lead to data disclosure
    and allow unauthorized access to sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing Data Access to Deactivated Users (GitLab)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a publicly disclosed vulnerability reported to GitLab in August 2021, a hacker
    who goes by the handle Joaxcar was able to access data by using a deactivated
    user account to authenticate to the GraphQL API and perform actions that shouldn’t
    have been allowed ([https://hackerone.com/reports/1192460](https://hackerone.com/reports/1192460)).
  prefs: []
  type: TYPE_NORMAL
- en: Deactivated user accounts should have their access denied until they are reactivated
    by the application’s maintainer. While the user is deactivated, the application
    should reject the user’s access attempts, whether directly through the console
    or through API keys, even if they have active API keys.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the risk this poses, imagine that an employee goes on vacation
    and that the security team’s policy is to disable all employee accounts until
    they return to the office. Now imagine that the employee’s password was leaked
    to the internet, and a threat actor is in possession of these credentials. In
    the vulnerability scenario we’re describing here, the threat actor would be able
    to call the application even though the user’s account is disabled. This shouldn’t
    happen with proper authentication and authorization controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what Joaxcar did to exploit the vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: As an administrator, created a secondary user with an API key
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Still as an administrator, disabled the newly created user
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Used the deactivated user’s API key to call the GraphQL API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirmed that they were successfully able to perform actions with the deactivated
    user credentials
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'They used the following GraphQL query as part of the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The query uses the `labelCreate` object with an input type argument that accepts
    a `title` and a `projectPath`. In other words, the vulnerability allowed the ethical
    hacker to use a deactivated account to create a label field. It’s quite possible
    that the vulnerability would have allowed other actions too, other than label
    creation.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing an Unprivileged Staff Member to Modify a Customer’s Email (Shopify)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following vulnerability was reported to the Shopify bug bounty program by
    user ash_nz in September 2021 ([https://hackerone.com/reports/980511](https://hackerone.com/reports/980511)).
    An e-commerce company, Shopify has been a trailblazer in the GraphQL space for
    many years, developing useful open source tools, publishing articles about GraphQL
    best practices, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The vulnerability allowed ash_nz to modify a customer email by using an unprivileged
    shop staff account, which could update email objects through a dedicated GraphQL
    API mutation. Here is the mutation as seen in the report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The hacker passed a customer’s email to the mutation’s `input` parameter and
    sent it to the GraphQL API server, which updated the customer’s email, despite
    the API caller not having the right privileges to do so.
  prefs: []
  type: TYPE_NORMAL
- en: This is a fairly simple vulnerability, but identifying it does require testing
    multiple hypotheses and edge cases. Always evaluate APIs using various privilege
    levels and attempt cross-account or cross-user access to uncover authorization
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: The hacker received a bounty of $1,500 from Shopify for responsibly disclosing
    this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Disclosing the Number of Allowed Hackers Through a Team Object (HackerOne)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In April 2018, an ethical hacker with the handle haxta4ok00 identified a GraphQL
    authorization issue in HackerOne that led to an information disclosure vulnerability
    ([https://hackerone.com/reports/342978](https://hackerone.com/reports/342978)).
  prefs: []
  type: TYPE_NORMAL
- en: The hacker identified that, by making a query that uses the `team` object in
    HackerOne’s GraphQL API, they could access a restricted field that they otherwise
    shouldn’t have been able to access. The `team` object allowed querying for programs
    on the HackerOne platform and returning information such as their `id` and `name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hacker also identified that when the `whitelisted_hackers` field is specified,
    it returns the `total_count` of the program’s number of allowed hackers. Since
    the team object takes an argument of `handle`, it practically allows searching
    for programs based on their `handle` string. In the following example, the handle
    is `security`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The HackerOne triage team was able to determine that this vulnerability could
    have also allowed someone to identify other non-public programs on the platform
    by supplying various strings to the `handle` argument that might match a team’s
    handle. The response to the query is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the disclosed information isn’t very sensitive in nature, but
    it can be used to infer whether the program is private and, therefore, find HackerOne’s
    customers.
  prefs: []
  type: TYPE_NORMAL
- en: HackerOne paid a bounty of $2,500 for this authorization issue because of the
    information disclosure impact.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Private Notes (GitLab)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Issues created on GitLab may include private notes that only members should
    be able to view. In June 2019, an ethical hacker with the handle ngalog reported
    CVE-2019-15576 through a HackerOne report ([https://hackerone.com/reports/633001](https://hackerone.com/reports/633001)),
    which showed that hackers can read these notes through GitLab’s GraphQL API despite
    them being properly restricted in the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notes can be sensitive, as they may contain information about duplicate issues,
    issues moved to another project, or even project code. The ethical hacker used
    the following query to exploit the vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `issue` object is being used in conjunction with the `notes`
    field. This `notes` field allows access to other fields, such as the note’s `body`,
    the note’s `author`, and more. The screenshot in [Figure 10-4](#figure10-4), taken
    from GitLab GraphQL API documentation, shows the complete list of available fields.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c10/f10004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-4: GitLab’s documentation for the note fields'
  prefs: []
  type: TYPE_NORMAL
- en: The full GitLab GraphQL API documentation can be found at [https://docs.gitlab.com/ee/api/graphql/reference](https://docs.gitlab.com/ee/api/graphql/reference).
  prefs: []
  type: TYPE_NORMAL
- en: Disclosing Payment Transaction Information (HackerOne)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following vulnerability, reported to HackerOne in October 2019, impacted
    its own GraphQL API ([https://hackerone.com/reports/707433](https://hackerone.com/reports/707433)).
    It allowed msdian7, the hacker who found and disclosed the issue, to access the
    total number of payment transactions—information meant to be confidential and
    accessible by only authorized parties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GraphQL query used can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Payment data should never be public information. This vulnerability allowed
    access to the `total_count` field through the `payment_transactions` field by
    using an unauthorized session, effectively providing insight into the transactions
    made by other bug bounty programs on the HackerOne platform.
  prefs: []
  type: TYPE_NORMAL
- en: Information Disclosure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will review publicly disclosed vulnerabilities that led
    exclusively to information disclosure issues. Some of the issues we covered earlier
    in this chapter also resulted in information disclosure outcomes, though these
    stemmed from other vulnerabilities such as broken access control mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating GraphQL Users (GitLab)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In 2021, Rapid7 identified CVE-2021-4191 in GitLab’s Community Edition and Enterprise
    Edition. The vulnerability allowed unauthenticated attackers to access user information
    in private GitLab instances that had specifically restricted their user registration
    interfaces through the `users` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following query returns information about users in GitLab
    instances, such as their name, username, and ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to a user’s name and username, the vulnerability affected fields
    such as their email, location, user permissions, group memberships, state, and
    profile picture. Having access to so much information about users is useful for
    several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identifying accounts to attack.** Knowledge of usernames and emails allowed
    threat actors to target specific accounts. Having access to user emails also allowed
    threat actors to pivot to other attacks, such as social engineering, by sending
    phishing emails to users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identifying available groups.** The vulnerability allowed attackers to infer
    information about the company running GitLab through their group memberships.
    Group memberships can reveal information such as acquisitions, subsidiaries, other
    company branches, regions where the company operates, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identifying individuals.** The vulnerability allowed access to profile pictures,
    which could help threat actors target specific users on platforms outside of GitLab.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identifying state of accounts.** Knowing the state of an account (whether
    it’s disabled or enabled) could make attacks such as brute forcing more effective;
    threat actors could target only accounts that are in an enabled state, allowing
    them to optimize their attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This vulnerability is especially interesting because of how simple and straightforward
    it is to exploit. The fact that it can be done in an unauthenticated manner increases
    its severity quite a lot too.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Introspection Query via WebSocket (Nuri)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This report is an interesting one and quite unique. In April 2020, an ethical
    hacker who goes by the handle zerodivisi0n disclosed a vulnerability in Nuri’s
    API that caused schema information to leak through an introspection query ([https://hackerone.com/reports/862835](https://hackerone.com/reports/862835)).
    This GraphQL API used WebSocket as its transport protocol, not HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: In earlier chapters, you learned about GraphQL and WebSocket in the context
    of subscription operations; clients can subscribe to certain events of interest
    to get real-time information over the WebSocket protocol. Certain GraphQL libraries,
    such as *graphql-ws* ([https://github.com/enisdenjo/graphql-ws](https://github.com/enisdenjo/graphql-ws)),
    allow not only subscriptions to be sent over WebSocket but also queries and mutations.
  prefs: []
  type: TYPE_NORMAL
- en: The reported vulnerability enabled hackers to execute the introspection query
    directly via a WebSocket connection. While the report doesn’t include a whole
    lot of details about how the GraphQL implementation was designed to work, introspection
    was disabled on interfaces that aren’t WebSocket based, such as in query operations
    sent over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'An introspection query over a WebSocket client-to-server message could look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Query and mutation operations sent over WebSocket aren’t currently very common.
    You’re more likely to see GraphQL subscription operations transported over WebSocket,
    but this could change over time as GraphQL trends evolve.
  prefs: []
  type: TYPE_NORMAL
- en: Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following publicly disclosed GraphQL vulnerabilities resulted in application
    injection flaws. Chapter 8 covers injections and how impactful they can be if
    exploited.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Injection in a GET Query Parameter (HackerOne)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In November 2018, Jobert identified a SQL injection in HackerOne’s GraphQL
    production endpoint ([https://hackerone.com/reports/435066](https://hackerone.com/reports/435066)).
    Jobert had identified a nonstandard parameter passed to HackerOne’s GraphQL */graphql*
    endpoint, *embedded_submission_form_uuid*, that looked like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This URL parameter isn’t standard in GraphQL APIs, where you are more likely
    to see parameters such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`query`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`variables`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`operationName`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should already be familiar with these: `query` takes the full GraphQL query
    as its value, `variables` takes additional data passed to the query (variables
    such as argument values), and `operationName` is the name of the operation. Jobert
    was able to identify that the value passed to the custom parameter wasn’t checked
    on the backend, effectively allowing them to inject SQL commands.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The HackerOne triage team shared the Ruby code responsible for processing the
    GraphQL parameters, and we’ve modified it here to make the problem more apparent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `new_parameters` variable ❶ is a hash map containing the custom `embedded_submission_form_uuid`
    URL parameter and its value (which is client controlled). At ❷, a loop performs
    string interpolation on the keys and values assigned to the variable, effectively
    composing a string with the parameter and its value together. It combines this
    string with the `SET` `SESSION` SQL command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new SQL command is eventually assigned to the `safe_query` variable, which,
    at this point, the attacker controls without any checks. We’ve used a comment
    to highlight the value that gets assigned to the variable: the GET parameter `embedded_submission_form_uuid`
    key and its value. The variable eventually gets translated to a SQL query and
    executed. GraphQL parameters aren’t automatically sanitized either, which contributes
    to the SQL injection condition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Jobert crafted a special cURL request to verify the injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The URL-decoded version of this cURL request looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This request used a time-based SQL injection technique (covered in Chapter 8)
    to introduce a time delay of `10` seconds in the server’s processing by using
    the PostgreSQL command `pg_sleep`. The attacker then tracked the time it took
    the server to respond to the request by using the Linux `time` command. It took
    10.557 seconds to complete.
  prefs: []
  type: TYPE_NORMAL
- en: This technique not only confirmed the existence of the vulnerability but also
    avoided accidentally disclosing sensitive information or potentially sending dangerous
    commands to the database that could cause data to be lost.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Injection in an Object Argument (Apache SkyWalking)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apache SkyWalking is a performance-monitoring platform for microservices and
    cloud-native architectures created by the Apache Software Foundation. In June
    2020, it suffered from a SQL injection vulnerability introduced through a value
    passed to a GraphQL field argument. This vulnerability was assigned the identifier
    CVE-2020-9483.
  prefs: []
  type: TYPE_NORMAL
- en: SkyWalking can work with various storage backends, such as H2, OpenSearch, PostgreSQL,
    and TiDB. A hacker who goes by the handle Jumbo-WJB discovered that when SkyWalking
    was used in conjunction with either H2 or MySQL storage backends, it was vulnerable
    to a SQLi through the `getLinearIntValues` field `metric` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jumbo-WJB published an exploit for this vulnerability, constructing a special
    payload in the GraphQL query that abused the bug to achieve a SQLi. In the following
    example query, you can see that the value of `id`, which is passed as input to
    the `metric` argument, contains SQL query syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For a value, the `metric` argument expects an object that includes keys such
    as `id` and `name`. The vulnerability appeared to be in the `id` key, which doesn’t
    get sanitized before it is inserted into either H2 or MySQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: By examining the pull request on SkyWalking’s GitHub repository containing the
    fix, we can get an idea of what the vulnerable code area might have looked like
    ([Figure 10-5](#figure10-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c10/f10005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-5: Apache SkyWalking’s vulnerable code'
  prefs: []
  type: TYPE_NORMAL
- en: The `getLinearIntValues` method takes a few arguments, such as `tableName`,
    `valueCName`, and `ids` (line 110), and does some string building using Java’s
    `StringBuilder` (line 112). A loop is then used to iterate through the values
    passed to the `ids` argument and construct a string by concatenating them and
    decorating them using single quotes (lines 113 to 118). The newly built string
    eventually gets used as part of a SQL query without sanitization (lines 123 to
    125).
  prefs: []
  type: TYPE_NORMAL
- en: It is very possible that the `metric` object’s `id` GraphQL argument is inserted
    directly into the `ids` list and therefore allows injecting SQL commands.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Scripting (GraphQL Playground)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CVE-2021-41249 is a reflected XSS vulnerability impacting the GraphQL Playground
    IDE, which provides an interface for sending queries to the API, as well as raw
    schema information, documentation about the API’s features, and information taken
    from inline SDL code comments. This information is partially populated by an introspection
    query that gets sent automatically when GraphQL Playground loads. Other information
    might come from the GraphQL server.
  prefs: []
  type: TYPE_NORMAL
- en: 'This vulnerability is quite different from those covered so far in this chapter.
    First, it impacts the API consumer directly, as a successful exploitation would
    execute in their browser. Second, attackers could exploit it in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: By compromising a GraphQL server and modifying its schema to include dangerous
    characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By building a custom GraphQL server with a malicious payload implemented. The
    attacker could then target the client by sending them a link to load the GraphQL
    Playground with the malicious server’s address—for example, *http://blackhatgraphql.com/graphql?endpoint=http://attacker.com/graphql?query={__typename}*.
    If the victim clicks the link, their browser will automatically load the malicious
    API and run a query on their behalf, which executes the payload into the Playground
    running in their browser and triggers the XSS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s explore how a GraphQL server could serve such malicious payloads. Consider
    the following code sample from DVGA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This code represents DVGA’s `UserObject` object. Developers could use the `name`
    variable to rename an object’s name to a custom string, and a threat actor could
    do the same if they’ve compromised the server (or simply hosted their own version
    of it). This name will then get rendered in an IDE tool’s documentation section
    ([Figure 10-6](#figure10-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c10/f10006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-6: A malicious type name shown in a search'
  prefs: []
  type: TYPE_NORMAL
- en: When a client opens the GraphQL Playground to query the API, the malicious JavaScript
    payload will be rendered in their browser, which, in this case, is injected into
    a type’s name.
  prefs: []
  type: TYPE_NORMAL
- en: 'This exact vulnerability existed in the Playground Node Package Manager (npm)
    package *graphql-playground-react*. In late 2021, the library maintainers took
    the following steps to remediate the vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that any HTML text is escaped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that type names conform to the GraphQL specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding loading the documentation section if it contains dangerous characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that user-generated HTML is checked and made safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL IDEs are popular, so if you’re performing a penetration test and identify
    an old version of GraphQL Playground, it’s possible that it hasn’t been patched
    and is still vulnerable to this XSS. Alternatively, you could host your own malicious
    GraphQL server containing the vulnerable Playground library and trick a victim
    into visiting it.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Request Forgery (GitLab)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in the book, we highlighted techniques for identifying GraphQL APIs
    that allow GET-based queries. Let’s now see how a hacker was able to abuse this
    functionality. In March 2021, the hacker az3z3l disclosed a CSRF vulnerability
    to GitLab ([https://hackerone.com/reports/1122408](https://hackerone.com/reports/1122408)).
  prefs: []
  type: TYPE_NORMAL
- en: When handling GraphQL queries over the POST method, GitLab uses a special `X-CSRF-Token`
    HTTP header to protect against CSRF attacks. This header includes a unique token
    in each request or query.
  prefs: []
  type: TYPE_NORMAL
- en: GET requests aren’t typically used for actions such as data modifications, so
    companies don’t usually protect them with anti-CSRF tokens. But because GitLab
    supported queries using GET, the CSRF protection in place did not apply to those
    queries, even though these operations included queries and mutations and had the
    ability to perform changes through the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ethical hacker az3z3l provided proof-of-concept HTML code that abuses the CSRF
    vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This HTML code defines a submission form ❶ that includes two inputs: `query`
    ❷, which specifies the use of a mutation named `CreateSnippet`, and `variables`
    ❸, which holds a few variables passed via the input type. At ❹, the code uses
    JavaScript to submit the form on behalf of the client as soon as a client loads
    an HTML page that contains it. Because the API doesn’t check for a CSRF protection
    header, this is possible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The GraphQL mutation used in the exploit is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As a result of this query, a snippet will be created on behalf of the client
    with whatever data the attacker included in the HTML form. This CSRF could let
    the attacker take sensitive actions on behalf of the victim, such as accessing
    their account or data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter covered public disclosures of real-life vulnerabilities and exploits.
    You learned about how certain design choices in GraphQL implementations created
    vulnerabilities that led to information disclosure, injections, authorization
    issues, and more. We also discussed some of the mitigation approaches companies
    took to patch the vulnerabilities, where possible.
  prefs: []
  type: TYPE_NORMAL
- en: This book introduced you to GraphQL’s new ways of querying APIs. As you’ve learned,
    the framework has its own rules, advantages, and disadvantages. GraphQL’s design
    introduces new vulnerabilities and security challenges. Simultaneously, it remains
    prone to the classic vulnerabilities that have existed for years. Now that you
    know how to find vulnerabilities in GraphQL, we recommend that you try to poke
    holes in the GraphQL applications made available through vulnerability disclosure
    programs. Who knows; maybe you’ll make a buck or two.
  prefs: []
  type: TYPE_NORMAL
