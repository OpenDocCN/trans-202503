<html><head></head><body>
<h2 class="h" id="ch06"><span epub:type="pagebreak" id="page_153" class="calibre1"/><strong class="calibre2"><span class="big">6</span><br class="calibre3"/>FUNCTIONS, METAPROGRAMMING, AND ERRORS</strong></h2>
<div class="bq">
<p class="center"><em class="calibre11">A small error at the beginning of something is a great one at the end.</em></p>
<p class="center1">—Thomas Aquinas</p>
</div>
<div class="image"><img alt="Image" src="../images/common.jpg" class="calibre6"/></div>
<p class="noindent">In this chapter, we’ll explore three topics that afford greater power, control, and flexibility when writing programs. We’ll delve deeper into the central subject of functions, and further explore function arguments and higher-order functions. We’ll see how metaprogramming and macros let us create new syntax and bend Julia to our will in a way that’s not possible with most programming languages. Finally, we’ll see how to take control of the error system and use it to manipulate program execution.<span epub:type="pagebreak" id="page_154"/></p>
<h3 class="h2" id="ch06lev1"><strong class="calibre2">Functions and Their Arguments</strong></h3>
<p class="noindent">In <a href="ch04.xhtml" class="calibre10">Chapter 4</a>, we learned about positional and keyword arguments to functions. In this section we’ll extend our knowledge of functions and learn additional ways to supply them with arguments.</p>
<h4 class="h3" id="ch06lev1sec1"><strong class="calibre2"><em class="calibre4">Concise Syntax for Keyword Arguments</em></strong></h4>
<p class="noindent">Keyword arguments tend to have names that reflect their purposes, which means when calling a function using variables for some of the keyword arguments, the names of those variables often are the same as their names in the function definition. This is even more likely to happen if we’ve defined these variables with their eventual use in calling the function in mind.</p>
<p class="indent">Under such circumstances our function calls look something like this:</p>
<pre class="calibre13"><span class="codeitalic">somefunction(pos1, pos2; keyword1=keyword1, keyword2=keyword2)</span></pre>
<p class="indent">Julia has a syntax option that reduces this visual noise and unnecessary typing. We can replace the previous call with:</p>
<pre class="calibre13"><span class="codeitalic">somefunction(pos1, pos2; keyword1, struct.keyword2)</span></pre>
<p class="noindent">As the example shows, we can use either a variable with the same name as the keyword or a composite object that has a property name matching a keyword name.</p>
<h4 class="h3" id="ch06lev1sec2"><strong class="calibre2"><em class="calibre4">The Splat and Slurp Operators</em></strong></h4>
<p class="noindent">The <code>...</code> operator (three dots) is either a <em class="calibre11">splat</em> or a <em class="calibre11">slurp</em>, depending on context. When we’re supplying arguments to a function, we can <em class="calibre11">splat</em>, and when we’re defining a function, we can <em class="calibre11">slurp</em>.</p>
<h5 class="h4" id="ch06sec1sec1"><strong class="calibre2">Splatting</strong></h5>
<p class="noindent">Suppose we make a function that takes three arguments and adds them together:</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">function addthree(a, b, c)</span>
              <span class="codestrong">return a + b + c</span>
          <span class="codestrong">end;</span>

   julia&gt; <span class="codestrong">addthree(1, 2, 3)</span>
   6

   julia&gt; <span class="codestrong">v3 = [1, 2, 3];</span>

   julia&gt; <span class="codestrong">addthree(v3)</span>
<span class="ent">➊</span> ERROR: MethodError: no method matching addthree(::Vector{Int64})</pre>
<p class="indent">When we supply three arguments, as the function definition demands, the sum is returned. However, if the three values are part of a vector, we <span epub:type="pagebreak" id="page_155"/>get an error <span class="ent">➊</span> if we call the function with the vector as an argument. That’s because its definition includes no method that accepts a single <code>Vector</code> argument; the only option is three separate values.</p>
<p class="indent">We could handle this situation by extracting the values within <code>v3</code> into three separate variables and passing those to <code>addthree()</code>, but, since this situation arises frequently, Julia provides an easier way, through an operator spelled as three dots and called <em class="calibre11">splat</em>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">addthree(v3...)</span>
6</pre>
<p class="noindent">Here the splatting operator unpacks the values in a collection and supplies them as separate arguments to the called function.</p>
<p class="indent"><a href="ch06.xhtml#ch6lis1" class="calibre10">Listing 6-1</a> shows how we can also splat keyword arguments stored in a named tuple.</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">function addthreeWithCoefficients(a, b, c; f1=1, f2=1, f3=1)</span>
              <span class="codestrong">return f1 * a + f2 * b + f3 * c</span>
          <span class="codestrong">end;</span>

   julia&gt; <span class="codestrong">coeffs = (f1=100, f2=10)</span>
   (f1 = 100, f2 = 10)

<span class="ent">➊</span> julia&gt; <span class="codestrong">addthreeWithCoefficients(1, 2, 3; coeffs...)</span>
   123</pre>
<p class="list" id="ch6lis1"><em class="calibre11">Listing 6-1: Splatting a named tuple</em></p>
<p class="noindent">In this example, we create a new function, <code>addthreeWithCoefficients()</code>, that takes the three keyword arguments <code>f1</code>, <code>f2</code>, and <code>f3</code> and multiplies the positional arguments by them before returning the sum. We then create a named tuple, <code>coeffs</code>, that has two properties with names matching two of the keyword arguments. When we call the function with a splat applied to the named tuple <span class="ent">➊</span>, <code>f1</code> and <code>f2</code> get values assigned from the corresponding properties of the tuple. The argument <code>f3</code> does not exist in the tuple, so it gets its default value of 1.</p>
<p class="indent">Although structs also have properties, we can’t use them for splatting in this way. This limitation is related to the fact that we can’t iterate over a struct as we can over a named or ordinary tuple.</p>
<p class="indent">However, dictionaries will work, as long as the keyword names appear as symbols:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">csd = Dict(:f1=&gt;100, :f2=&gt;10);</span>

julia&gt; <span class="codestrong">addthreeWithCoefficients(1, 2, 3; csd...)</span>
123</pre>
<p class="noindent">Here the dictionary keys <code>:f1</code> and <code>:f2</code> correspond to the arguments <code>f1</code> and <code>f2</code> in the function definition in <a href="ch06.xhtml#ch6lis1" class="calibre10">Listing 6-1</a>.<span epub:type="pagebreak" id="page_156"/></p>
<h5 class="h4" id="ch06sec1sec2"><strong class="calibre2">Slurping</strong></h5>
<p class="noindent">In a function definition, the three dots indicate the <em class="calibre11">slurp</em> operator. Slurping is a kind of inverse operation to splatting: instead of unpacking a collection into separate arguments, it packs any number of separate arguments into a single iterable object. If we want a function to accept an unknown, or variable, number of positional arguments, we can use slurping:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">function addonlythreeWithNote(a, b, c, more...)</span>
           <span class="codestrong">if length(more) &gt; 0</span>
               <span class="codestrong">println("Ignoring $(length(more)) additional arguments.")</span>
           <span class="codestrong">end</span>
           <span class="codestrong">return a + b + c</span>
       <span class="codestrong">end;</span>

julia&gt; <span class="codestrong">addonlythreeWithNote(1, 2, 3, 99, 100, 101)</span>
Ignoring 3 additional arguments.
6</pre>
<p class="indent">The <code>addonlythreeWithNote()</code> function returns the sum of the first three arguments we supply, just as the <code>addthree()</code> function did. This version, however, accepts any number of additional arguments, which it packs into a tuple called <code>more</code>.</p>
<p class="indent">We can also slurp keyword arguments. The function defined in the following example performs two optional tests on the string supplied as its positional argument. If it gets a keyword called <code>palindrome</code>, it tests for the thusly named property, and if it gets one called <code>onlyascii</code>, it uses the <code>isascii()</code> function to check for the presence of non-ASCII characters in the string:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">function examine_string(s; checks...)</span>
           <span class="codestrong">if :palindrome in keys(checks)</span>
               <span class="codestrong">if s == reverse(s)</span>
                   <span class="codestrong">println("\"$s\" is a palindrome.")</span>
               <span class="codestrong">end</span>
           <span class="codestrong">end</span>
           <span class="codestrong">if :onlyascii in keys(checks)</span>
               <span class="codestrong">if isascii(s)</span>
                   <span class="codestrong">println("\"$s\" contains only ASCII characters.")</span>
               <span class="codestrong">else</span>
                   <span class="codestrong">println("\"$s\" contains non-ASCII characters.")</span>
               <span class="codestrong">end</span>
           <span class="codestrong">end</span>
       <span class="codestrong">end;</span>

<span class="ent">➊</span> julia&gt; <span class="codestrong">examine_string("step on no pets"; kw1=17, palindrome=1, onlyascii=1)</span>
"step on no pets" is a palindrome.
"step on no pets" contains only ASCII characters.

julia&gt; <span class="codestrong">examine_string("step on no pets"; palindrome=1)</span>
"step on no pets" is a palindrome.</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_157"/>Because we define <code>examine_string()</code> using slurping for keyword arguments, it doesn’t matter if it’s called with extra arguments <span class="ent">➊</span>; they will be ignored. Since we supply default values for the keyword arguments in the function definition, it also doesn’t matter if some are missing. Finally, since the program checks only for the presence of the keyword arguments, the values assigned in the call are arbitrary.</p>
<p class="indent">We can also call the function with a splatted value as before. The difference now is that the object we splat into the call may contain superfluous keywords without creating an error condition. Here’s an example:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">kws = Dict(:palindrome =&gt; 1, :anyOtherKeyword =&gt; 17)</span>
julia&gt; <span class="codestrong">examine_string("step on no pets"; kws...)</span>
"step on no pets" is a palindrome.</pre>
<p class="indent">Defining functions with slurped keyword arguments can be convenient for users. For example, some of the functions in the <code>Plots</code> package work this way. We can call them with keywords that they don’t use; they’ll use the ones they can handle and ignore the others. This might happen in the REPL if we create a plot using one plotting function supplied with a list of keywords and then decide we want to use a different one. We can press the up arrow and change the function’s name without having to consult its documentation to see whether it understands all the keywords we used previously.</p>
<p class="indent">Julia allows one more way to supply keyword arguments to such functions. We can list them separately in the form <code>:kw=&gt;value</code>, with keywords appearing as symbols, or we can splat a dictionary, but all of its keys must be symbols.</p>
<h4 class="h3" id="ch06lev1sec3"><strong class="calibre2"><em class="calibre4">Destructuring</em></strong></h4>
<p class="noindent"><em class="calibre11">Destructuring</em> refers to the unpacking of a tuple of values into named variables with a single assignment:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">x, y = (3, 4);</span>

julia&gt; <span class="codestrong">x</span>
3

julia&gt; <span class="codestrong">y</span>
4</pre>
<p class="indent">This feature is especially convenient in unpacking tuple return values from functions. As mentioned previously, tuples need not be written with parentheses as long as omitting them doesn’t create an ambiguity, so we can write the assignment in the example just shown as <code>x, y = 3, 4</code>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_158"/><a href="ch06.xhtml#ch6lis2" class="calibre10">Listing 6-2</a> shows another form of destructuring that unpacks keyword arguments from a struct, using the following syntax:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">(; url, title) = google</span>
Website("https://google.com", "google")

julia&gt; <span class="codestrong">url</span>
"https://google.com"

julia&gt; <span class="codestrong">title</span>
"google"</pre>
<p class="list" id="ch6lis2"><em class="calibre11">Listing 6-2: Destructuring a struct</em></p>
<p class="indent">In this example, the definition of <code>google</code> from <a href="ch05.xhtml#ch5lis2" class="calibre10">Listing 5-2</a> is in force. In this type of destructuring, the variable names on the left-hand side of the assignment must match the field names of the composite type on the right-hand side.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">Keyword destructuring from structs first appeared in Julia v1.7. In earlier versions,</em> <span class="codeitalic1">(; a, b)</span> <em class="calibre11">is a syntax error.</em></p>
</div>
<p class="indent">The utility of this form of destructuring may not be immediately obvious. After all, without this peculiar syntax, we can still do this:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">url, title = google.url, google.title</span></pre>
<p class="noindent">It’s not much more verbose than the form in <a href="ch06.xhtml#ch6lis2" class="calibre10">Listing 6-2</a> and has the same effect.</p>
<p class="indent">However, one advantage of this destructuring syntax is in providing a succinct way to define functions that take keyword arguments extracted from structs. In the following example, we first define a struct with three fields and create an object from the struct:</p>
<pre class="calibre13">
   julia&gt; <span class="codestrong">struct Fco</span>
              <span class="codestrong">f1</span>
              <span class="codestrong">f2</span>
              <span class="codestrong">f3</span>
          <span class="codestrong">end</span>

   julia&gt; <span class="codestrong">someco = Fco(100, 10, 1)</span>
   Fco(100, 10, 1)

<span class="ent">➊</span> julia&gt; <span class="codestrong">function addthreeWithCoefficients(a, b, c, (; f1, f2, f3))</span>
              <span class="codestrong">return f1 * a + f2 * b + f3 * c</span>
          <span class="codestrong">end;</span>

   julia&gt; <span class="codestrong">addthreeWithCoefficients(1, 2, 3, someco)</span>
   123</pre>
<p class="indent"><span epub:type="pagebreak" id="page_159"/>Then we make a different version of the <code>addthreeWithCoefficients()</code> function that we created in <a href="ch06.xhtml#ch6lis1" class="calibre10">Listing 6-1</a> <span class="ent">➊</span>. Instead of a list of keyword arguments, this version takes a fourth positional argument that has the syntax of a struct destructuring. When we call the function, supplying the composite object as the fourth positional argument, the function makes the assignment<code>(; f1, f2,</code> <code>f3) = someco</code>. Referring to the syntax in <a href="ch06.xhtml#ch6lis2" class="calibre10">Listing 6-2</a>, we can see that this will assign 100 to <code>f1</code>, 10 to <code>f2</code>, and 1 to <code>f3</code>. The struct used as an argument may contain fields that are not extracted by the function, as the destructing syntax doesn’t require all fields to be unpacked.</p>
<h4 class="h3" id="ch06lev1sec4"><strong class="calibre2"><em class="calibre4">Operators Are Functions Too</em></strong></h4>
<p class="noindent">Binary operators in Julia, such as <code>*</code> and <code>+</code>, also called <em class="calibre11">infix operators</em>, are functions of two arguments. Each one has a more explicit functional form:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">+(1, 2, 3)</span>
6

julia&gt; <span class="codestrong">*(8, 2)</span>
16</pre>
<p class="noindent">In the first example, the <code>+</code> function operates on the arguments 1, 2, and 3, adding them up to return 6. The functional form of infix operators can be more concise when we have many arguments.</p>
<p class="indent">Since binary operators are functions, we can pass them as arguments to higher-order functions (see <a href="ch06.xhtml#ch6lis5" class="calibre10">Listing 6-5</a> for an example).</p>
<p class="indent">In an expression involving infix operators, the order of operations, or <em class="calibre11">precedence rules</em> for operators, determines the result. For example, the expression <code>3 + 2 * 5</code> evaluates to <code>13</code> because multiplication happens before addition.</p>
<p class="indent">When using the functional forms of operators, there are no precedence rules, because the function application syntax makes the order of operations explicit. For example, the expression <code>3 + 2 * 5</code> is equivalent to <code>+(3, *(2, 5))</code>. The syntax shows that the multiplication occurs before the addition.</p>
<p class="indent">Julia allows us to use certain characters to define our own binary operators. If we create a function and give it one of these characters for its name, we can use the function in an infix position.</p>
<p class="indent">We can’t create an infix operator from any character, however. The source code for Julia’s interpreter provides a complete list of available characters (see “Further Reading” on <a href="ch06.xhtml#fur6" class="calibre10">page 187</a>). The source also indicates the precedence of each character by grouping them in classes with equal precedence. When deciding on a symbol for an infix operator, it’s not enough to pick one that looks right. We must decide how the operator is to fit within the hierarchy of precedence and choose a symbol in the appropriate group.</p>
<p class="indent">The three major precedence groups are multiplication, addition, and comparison. <a href="ch06.xhtml#ch6fig1" class="calibre10">Figure 6-1</a> shows a small selection of characters from each group.<span epub:type="pagebreak" id="page_160"/></p>
<div class="image1"><img alt="Image" id="ch6fig1" src="../images/ch06fig01.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 6-1: A few operator characters</em></p>
<p class="indent">Comparison operators have the lowest precedence of these three types, so the expression <code>2 * 3 + 2 &gt; 7</code> is equivalent to <code>((2 * 3) + 2) &gt; 7</code> and returns <code>true</code>.</p>
<p class="indent">Let’s use one of these characters to create a new infix operator that extends the idea of subtraction to give us the Euclidean distance between two vectors. We want it to have the same precedence as addition and subtraction operators, so we’ll pick a symbol from that group that looks like it has something to do with subtraction (enter <span class="codestrong1">\boxminus</span> followed by <small class="calibre5">TAB</small> to enter the function’s name in the REPL).</p>
<pre class="calibre13">julia&gt; <span class="codestrong">function ⊟(a, b)</span>
           <span class="codestrong">return sqrt((b[1] - a[1])^2 +</span>
                       <span class="codestrong">(b[2] - a[2])^2)</span>
       <span class="codestrong">end;</span></pre>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">To learn the shortcut for any other special character, paste it in after entering help mode.</em></p>
</div>
<p class="indent">After this definition, we have a new function with a single-character name.</p>
<p class="indent">Since the character is in the list of characters blessed for use as infix operators, it should work:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">v1 = [0, 1];</span>

julia&gt; <span class="codestrong">v2 = [1, 0];</span>

julia&gt; <span class="codestrong">v1</span> ⊟ <span class="codestrong">v2</span>
1.4142135623730951</pre>
<p class="noindent">This result is correct.</p>
<p class="indent">Let’s use the new operator in an expression containing a higher-precedence operation to check that it follows the desired precedence rules:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">3 .* v1 ⊟ 4 .* v2</span>
5.0</pre>
<p class="noindent">The multiplications were taken before the vector subtraction, as expected (the result may remind you of the 3-4-5 right triangle from high school trigonometry).</p>
<p class="indent"><span epub:type="pagebreak" id="page_161"/>We can transform infix operators we create ourselves into broadcast versions using the dot prefix, just like built-in operators:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">v1a = [v1, v1, v1]</span>
3-element Vector{Vector{Int64}}:
 [0, 1]
 [0, 1]
 [0, 1]

julia&gt; <span class="codestrong">v2a = [v1, v2, [0, 0]]</span>
3-element Vector{Vector{Int64}}:
 [0, 1]
 [1, 0]
 [0, 0]

julia&gt; <span class="codestrong">v2a .⊟ v1a</span>
3-element Vector{Float64}:
 0.0
 1.4142135623730951
 1.0</pre>
<p class="noindent">The broadcasting operation applies our function to all corresponding elements of the pair of vectors (of vectors). The result is a vector containing the Euclidean distance between each pair of corresponding vectors.</p>
<h4 class="h3" id="ch06lev1sec5"><strong class="calibre2"><em class="calibre4">The Mapping, Filtering, and Reduction Operators</em></strong></h4>
<p class="noindent">A <em class="calibre11">higher-order function</em> is a function that takes one or more functions as some of its arguments. Usually they either transform functions into other functions or apply them to data supplied as further arguments. The three operators <code>map()</code>, <code>filter()</code>, and <code>reduce()</code> are higher-order functions that apply a supplied function to a collection.</p>
<h5 class="h4" id="ch06sec1sec3"><strong class="calibre2">The map() Operator</strong></h5>
<p class="noindent">The <code>map()</code> operator applies a function to each element of a collection and returns another collection:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">double(x) = 2x</span>
double (generic function with 1 method)

julia&gt; <span class="codestrong">map(double, [2 3; 4 5])</span>
2×2 Matrix{Int64}:
 4   6
 8  10</pre>
<p class="noindent">Here <code>map()</code> applies <code>double()</code> to each element of the matrix individually, returning a result with the same shape as the matrix.</p>
<p class="indent"><span epub:type="pagebreak" id="page_162"/>In the case of an infix operator, <code>map</code> applies it between corresponding elements of all the collections supplied:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">map(+, [2 3], [4 5], [6 7])</span>
1×2 Matrix{Int64}:
 12  15</pre>
<p class="noindent">The result has the same shape as the collections that <code>map()</code> is operating on. The result’s first element comes from applying <code>+</code> to the first elements of all the collections; the second element, 15, is 3 + 5 + 7.</p>
<p class="indent">The key to understanding <code>map()</code> is understanding <code>zip()</code> because the <code>map()</code> operator combines the elements of the arrays we give it using <code>zip()</code>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">map(+, 20:10:40, [2 3; 4 5])</span>
3-element Vector{Int64}:
 22
 34
 43

julia&gt; <span class="codestrong">map(+, 20:10:90, [2 3; 4 5])</span>
4-element Vector{Int64}:
 22
 34
 43
 55</pre>
<p class="noindent">In these examples, <code>map()</code> applies the <code>+</code> operator between the elements of the vector and the 2×2 matrix in column-major order. In both cases, it stops when it runs out of elements in one of the collections.</p>
<p class="indent">In some cases, <code>map()</code> returns the same result as an equivalent broadcast using the dot. The map of <code>double()</code> earlier could have been written this way:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">double.([2 3; 4 5])</span>
2×2 Matrix{Int64}:
 4   6
 8  10</pre>
<p class="indent">However, mapping and broadcasting are not the same. We can see this clearly in the case of an infix operator:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">[20 30] .+ [2 3; 4 5]</span>
2×2 Matrix{Int64}:
 22  33
 24  35</pre>
<p class="noindent">In this example, the array on the left-hand side has a different shape from the one on the right-hand side. However, its shape fits the shape of the <em class="calibre11">rows</em> of the right-hand array. The broadcasting operator <code>.+</code> extends, or broadcasts, the array <code>[20 30]</code> over the rows of the other array.</p>
<p class="indent"><span epub:type="pagebreak" id="page_163"/>If we make the left-hand array a single column instead of a single row, it’s broadcast over the columns of the other array:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">[20, 30] .+ [2 3; 4 5]</span>
2×2 Matrix{Int64}:
 22  23
 34  35</pre>
<p class="indent">Examining the examples in this section should make the difference between mapping and broadcasting clear. Unlike broadcasting, <code>map()</code> does not perform operations on entire arrays, but goes element by element, using <code>zip()</code> under the hood. Using <code>map()</code> in this last example yields a different result:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">map(+, [20, 30], [2 3; 4 5])</span>
2-element Vector{Int64}:
 22
 34</pre>
<p class="indent">The <code>[3, 5]</code> column of the last argument is never used because <code>map()</code> runs out of elements before it gets there.</p>
<h5 class="h4" id="ch06sec1sec4"><strong class="calibre2">The filter() Operator</strong></h5>
<p class="noindent">The <code>filter()</code> operator takes a function of one variable as its first argument; this function should return <code>true</code> or <code>false</code>. It applies this function to each element of its second argument, which should be a collection. It returns a new collection with the elements for which the function returned <code>false</code> <em class="calibre11">filtered</em> out, or removed.</p>
<p class="indent">As with <code>map()</code>, <a href="ch06.xhtml#ch6lis3" class="calibre10">Listing 6-3</a> shows how <code>filter()</code> is often used with anonymous functions.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">filter(x -&gt; x % 17 == 0, 1:100)</span>
5-element Vector{Int64}:
 17
 34
 51
 68
 85</pre>
<p class="list" id="ch6lis3"><em class="calibre11">Listing 6-3: Using <span class="codeitalic">filter()</span> with an anonymous function</em></p>
<p class="noindent">Here we’ve created a list of the integers from 1 to 100 that are divisible by 17.</p>
<p class="indent">Julia provides a collection of test functions that can be convenient to use with <code>filter()</code>, such as <code>isodd()</code>, <code>iseven()</code>, <code>isfinite()</code>, and <code>isfile()</code>, which answer the questions indicated by their names.</p>
<p class="indent">The <code>isascii()</code> function tells you whether a character is part of the old ASCII character set; we can use it on a string to filter out non-ASCII characters:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">filter(isascii, "François")</span>
"Franois"</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_164"/>We get the string back with “ç” filtered out. We can also invert the condition to filter out the ASCII characters with <code>filter(!isascii, "François")</code>, which returns <code>"ç"</code>.</p>
<h5 class="h4" id="ch06sec1sec5"><strong class="calibre2">The reduce() Operator</strong></h5>
<p class="noindent">We’ve used the <code>sum()</code> function several times. It adds up all the numbers in an array, reducing it to a single number. The <code>reduce()</code> higher-order function generalizes this concept. It applies a function of two variables, supplied as its first argument, to a collection supplied as its second argument.</p>
<p class="indent">Let’s consider an example to visualize how it works. If there were no <code>sum()</code> function, we could use <code>reduce()</code> instead. We can calculate the sum <code>1 + 2 + 3</code> with <code>sum([1, 2, 3])</code>, but also with <code>reduce(+, [1, 2, 3])</code>.</p>
<p class="indent">We can use any binary operator, or any function of two variables, with <code>reduce()</code>. For example, <a href="ch06.xhtml#ch6lis4" class="calibre10">Listing 6-4</a> shows a function that divides its first argument by its second and uses it in <code>reduce()</code>.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">q(a, b) = a/b</span>
q (generic function with 1 method)

julia&gt; <span class="codestrong">reduce(q, 1:3)</span>
0.16666666666666666

julia&gt; <span class="codestrong">(1/2)/3</span>
0.16666666666666666</pre>
<p class="list" id="ch6lis4"><em class="calibre11">Listing 6-4: The <span class="codeitalic">reduce()</span> function</em></p>
<p class="noindent">The last line shows how <code>reduce()</code> inserts the function between elements, accumulating partial results as it goes.</p>
<p class="indent">However, reducing with division introduces a complication. While the <code>+</code> and <code>*</code> operators are <em class="calibre11">associative</em>, division and subtraction are not. Associativity means that it doesn’t matter how we group: <code>(1 + 2) + 3</code> gives the same result as <code>1 + (2 + 3)</code>. Division is not associative: <code>1/(2/3)</code> is equal to 1.5.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">In fact, addition and multiplication are associative when operating on real numbers (and other number systems in the realm of mathematics), but they are not truly associative when applied to floating-point numbers in a computer. Although the numerical effect of association, the difference between (</em>a <em class="calibre11">+</em> b<em class="calibre11">) +</em> c <em class="calibre11">and</em> a <em class="calibre11">+ (</em>b <em class="calibre11">+</em> c<em class="calibre11">), is usually small, it’s better to use the folding operators, which we’ll introduce next, when numerical accuracy or reproducibility are important.</em></p>
</div>
<p class="indent">In cases where the function or operator is not associative, the result of using <code>reduce()</code> is undefined: we cannot assume that it works from left to right. In such cases, we should use <code>foldl()</code> or <code>foldr()</code>, which work just like <code>reduce()</code>, but associate from the left or the right:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">foldl(q, 1:3)</span>
0.16666666666666666

julia&gt; <span class="codestrong">foldr(q, 1:3)</span>
1.5</pre>
<p class="indent"><span epub:type="pagebreak" id="page_165"/><a href="ch06.xhtml#ch6lis5" class="calibre10">Listing 6-5</a> shows how the <code>reduce()</code> operator, but not <code>foldl()</code> or <code>foldr()</code>, accepts the keyword argument <code>dims</code> to reduce along the specified dimension.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">reduce(+, [1 2; 10 20]; dims=2)</span>
2×1 Matrix{Int64}:
  3
 30

julia&gt; <span class="codestrong">reduce(+, [1 2; 10 20]; dims=1)</span>
1×2 Matrix{Int64}:
 11  22</pre>
<p class="list" id="ch6lis5"><em class="calibre11">Listing 6-5: Reducing along a specified dimension</em></p>
<p class="noindent">Here <code>dims=1</code> causes a reduction along the rows, while <code>dims=2</code> reduces along the columns. If we omit the <code>dims</code> argument, the result is a reduction over all elements, giving the single number 33.</p>
<p class="indent">All three reducing functions accept another keyword argument that acts as a default in case they encounter an empty collection. This argument is called <code>init</code>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">reduce(+, []; init=0)</span>
0</pre>
<p class="noindent">In this example, when faced with the empty collection <code>[]</code>, <code>reduce()</code> returns the specified value 0.</p>
<p class="indent">If a reducing function encounters an empty collection, no default neutral element exists, and no <code>init</code> argument has been supplied, it returns an error. Some reducing functions <em class="calibre11">may</em> use the value of <code>init</code> as a starting value for the reduction when the collection is not empty, but this behavior is formally unspecified and may change in future implementations of these functions. For that reason, to assure correct results, when <code>init</code> is present it should be the correct <em class="calibre11">neutral element</em> for the applied operation. For addition, this is 0, and for multiplication, the neutral element is 1.</p>
<p class="indent">Some reducing operations arise so frequently in programs that Julia has purpose-built versions for them. We’ve already seem <code>sum()</code>; <code>prod()</code> is similar but multiplies rather than adds:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">prod(1:7)</span>
5040

julia&gt; <span class="codestrong">factorial(7)</span>
5040</pre>
<p class="noindent">The first expression in this example multiplies together all the integers from 1 to 7 inclusive; as this is the definition of 7!, we get the same result returned from the second expression.</p>
<p class="indent"><span epub:type="pagebreak" id="page_166"/>The <code>maximum()</code> and <code>minimum()</code> reducers find the largest or smallest element of a collection:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">maximum(sin.(1:.01:2π))</span>
0.9999996829318346

julia&gt; <span class="codestrong">minimum(sin.(1:.01:2π))</span>
-0.999997146387718</pre>
<p class="noindent">In this example, we create the collections by broadcasting the <code>sin()</code> function over an interval.</p>
<p class="indent">The <code>any()</code> and <code>all()</code> reducing tests apply a test over a collection:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">any(iseven, 3:2:11)</span>
false

julia&gt; <span class="codestrong">all(isodd, 3:2:11)</span>
true</pre>
<p class="indent">These two operations answer the questions: do <em class="calibre11">any</em> or <em class="calibre11">all</em> elements of the collection satisfy the test in the first argument?</p>
<h5 class="h4" id="ch06sec1sec6"><strong class="calibre2">The mapreduce() Function</strong></h5>
<p class="noindent">The powerful <code>mapreduce()</code> function does what its name suggests: it combines a <code>map()</code> and a <code>reduce()</code>. For example, here are two ways to add up the first 100 squares:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">mapreduce(x -&gt; x^2, +, 1:100)</span>
338350

julia&gt; <span class="codestrong">reduce(+, map(x -&gt; x^2, 1:100))</span>
338350</pre>
<p class="noindent">The second method shows exactly what a <code>mapreduce()</code> call does. However, it’s almost always better to use <code>mapreduce()</code> instead of combining a <code>map()</code> and a <code>reduce()</code> because the former uses far less memory and is much faster; the gain in efficiency grows dramatically as the collection gets larger. The main reason is that combining <code>map()</code> and <code>reduce()</code> creates an intermediate collection to reduce over, whereas <code>mapreduce()</code> performs the calculation in one go, without allocating a collection.</p>
<h3 class="h2" id="ch06lev2"><strong class="calibre2">do Blocks</strong></h3>
<p class="noindent">Many functions in Julia take functions as their first arguments, and we often want to supply an anonymous function, as we have no need to reuse the function elsewhere. We’ve seen this with <code>plot()</code> and related plotting routines, and with the mapping and reducing functions described in this chapter.</p>
<p class="indent"><span epub:type="pagebreak" id="page_167"/>Constructing an anonymous function can be cumbersome or impossible using the <code>x -&gt; ...</code> syntax. For example, we might want it to contain loops or <code>if</code> blocks. In those situations, we can resort to first creating a named function and then passing it to the higher-level function, but Julia provides another way.</p>
<p class="indent">The <code>do</code> block is a type of function definition block solely for the purpose of creating anonymous functions. The function is inserted as the first argument of the function call immediately preceding the <code>do</code> block.</p>
<p class="indent">Let’s revisit reducing using our <code>q()</code> function from <a href="ch06.xhtml#ch6lis4" class="calibre10">Listing 6-4</a>. If any of the denominators taken from the collection is 0, the reduction will return <code>Inf</code>. But what if we want to simply skip those denominators?</p>
<pre class="calibre13">julia&gt; <span class="codestrong">foldl(q, 3:-1:0)</span>
Inf

julia&gt; <span class="codestrong">foldl(3:-1:0) do x, y</span>
           <span class="codestrong">if y == 0</span>
               <span class="codestrong">return x</span>
           <span class="codestrong">else</span>
               <span class="codestrong">return x/y</span>
           <span class="codestrong">end</span>
       <span class="codestrong">end</span>
1.5</pre>
<p class="indent">The <code>do</code> block defines an anonymous function of two variables that returns the first divided by the second, handling 0 denominators as a special case. The call to <code>foldl()</code> looks wrong because it passes only a single argument, but the function defined by the <code>do</code> block is inserted as the missing first argument.</p>
<h3 class="h2" id="ch06lev3"><strong class="calibre2">Symbols and Metaprogramming</strong></h3>
<p class="noindent">We’ve used the <code>Symbol</code> type in several places—for example, when setting attributes in plotting functions—but we’ve deferred a thorough discussion of what symbols in Julia actually are until now.</p>
<p class="indent">To grasp the meaning of symbols, we must introduce the concept of <em class="calibre11">metaprogramming</em> in Julia. Metaprogramming refers to a general class of language facilities and associated techniques for writing code that examines itself, modifies itself, and can even modify or add to the syntax of the language. In this section, we’ll introduce the basic concepts and apply them to the code-transforming programs called <em class="calibre11">macros</em> described in the next section.</p>
<p class="indent">Scientific code does not typically use much metaprogramming. However, Julia, and many of its packages, provides some indispensable macros, such as the <code>@layout</code> macro that we used in “Creating Complex Layouts Using @layout” on <a href="ch04.xhtml#ch04lev1sec28" class="calibre10">page 118</a>. Even if you never write a macro yourself, having a basic understanding of how they work is worthwhile. Programming in Julia routinely uses a handful of indispensable macros, so it’s important to be able to use them intelligently and debug them if something goes wrong.<span epub:type="pagebreak" id="page_168"/></p>
<h4 class="h3" id="ch06lev1sec6"><strong class="calibre2"><em class="calibre4">Expression Objects</em></strong></h4>
<p class="noindent">Julia has the ability to manipulate Julia code. That’s possible because Julia code itself is expressible as a data type that the language can operate on, just as it operates on numbers, strings, and arrays. This data type is called <code>Expr</code>. Objects with this data type are referred to as <code>Expr</code> objects or <em class="calibre11">expression objects</em>. Expression objects are different from <em class="calibre11">expressions</em>, which are language forms that return results, such as <code>3 * 5</code>.</p>
<p class="indent">Expression objects often involve Julia <code>Symbol</code>s. We can create a <code>Symbol</code> by prepending a colon to a name, as with the attributes, such as <code>:red</code>, that we used when making plots. We can convert a string to a symbol with the <code>Symbol()</code> function as well: <code>Symbol("red") == :red</code>.</p>
<p class="indent">We can also use colons to construct expression objects by following the colon with an expression in parentheses. To reiterate: <code>3 * 5</code> is an expression, while <code>:(3 * 5)</code> is an expression object. If we enter <code>3 * 5</code> in the REPL, Julia evaluates the expression and returns <code>15</code>. If we enter <code>:(3 * 5)</code>, or any other expression object, it simply returns what we entered.</p>
<p class="indent">In order to evaluate the expression that the <code>Expr</code> object represents, the part inside the parentheses, we use the <code>eval()</code> function. If we enter <code>eval(:(3 * 5))</code> in the REPL, Julia returns <code>15</code>.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">We can turn a string into an expression using</em> <span class="codeitalic1">Meta.parse()</span><em class="calibre11">—for example,</em> <span class="codeitalic1">Meta.parse("3 * 5")</span> <em class="calibre11">returns</em> <span class="codeitalic1">:(3 * 5)</span><em class="calibre11">.</em></p>
</div>
<p class="indent">Sometimes putting the entire expression object on one line is inconvenient. Julia has a block called <code>quote</code> for defining such objects:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">ex = quote</span>
           <span class="codestrong">a = 3</span>
           <span class="codestrong">a + 2</span>
       <span class="codestrong">end;</span>

julia&gt; <span class="codestrong">typeof(ex)</span>
Expr

julia&gt; a
ERROR: UndefVarError: a not defined

julia&gt; <span class="codestrong">eval(ex)</span>
5

julia&gt; <span class="codestrong">a</span>
3</pre>
<p class="noindent">The assignment beginning the example assigns the result of the <code>quote</code> block to <code>ex</code>. Since <code>quote</code> blocks create expression objects, that’s the type of <code>ex</code>, as we confirm in the following line. Evaluating the expression performs the operations within the block, as the next two lines confirm.</p>
<p class="indent"><span epub:type="pagebreak" id="page_169"/>The block gets its name from the concept of <em class="calibre11">quoting</em>, which means turning an expression into an expression object, whether we accomplish that by surrounding an expression with <code>:(...)</code> or using the <code>quote</code> block.</p>
<p class="indent">In English, sometimes we need to distinguish between <em class="calibre11">using</em> a word or expression and talking <em class="calibre11">about</em> the word or expression. We do this by surrounding the terms we are discussing with quotes. Quoting in Julia serves the same purpose. We quote an expression so that we can act on it as an expression; the expression object is simply the quoted expression.</p>
<p class="indent">Most languages have no way to talk about themselves. All those that do, such as Julia, all Lisps, and Elixir, have a way to quote expressions.</p>
<h4 class="h3" id="ch06lev1sec7"><strong class="calibre2"><em class="calibre4">Expression Object Interpolation</em></strong></h4>
<p class="noindent">We can interpolate values into an expression object similarly to how we can interpolate into a string. As a simple example, let’s define a variable and create two expression objects, one that uses the variable and one that uses the interpolated value of the variable:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">w = 3</span>
3

julia&gt; <span class="codestrong">ex = :(w * 5)</span>
:(w * 5)

julia&gt; <span class="codestrong">ey = :($w * 5)</span>
:(3 * 5)</pre>
<p class="indent">In the definition of <code>ey</code>, the value of <code>w</code> was interpolated into the expression object at the time of its creation. The expression object <code>ex</code> contains the <em class="calibre11">variable</em> <code>w</code> instead. Applying <code>eval()</code> to those expression objects, before and after changing the value of <code>w</code>, clarifies the consequences of this:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">eval(ex)</span>
15

julia&gt; <span class="codestrong">eval(ey)</span>
15

julia&gt; <span class="codestrong">w = 4</span>
4

julia&gt; <span class="codestrong">eval(ex)</span>
20

julia&gt; <span class="codestrong">eval(ey)</span>
15</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_170"/>Changing the value assigned to <code>w</code> does not change the result of evaluating <code>ey</code> because that expression does not contain <code>w</code> as a variable. Instead, it uses the <em class="calibre11">value</em> of <code>w</code> in its definition.</p>
<p class="indent">With just these few simple metaprogramming tools, we can already perform a whole category of programming tricks that are impossible without them. For example, suppose we want to create a function that, given a string and a value, creates a variable from the string and assigns the value to it. <a href="ch06.xhtml#ch6lis6" class="calibre10">Listing 6-6</a> shows a function that performs this task.</p>
<pre class="calibre13">mkvar(s, v) = eval(:($(Symbol(s)) = $v))</pre>
<p class="list" id="ch6lis6"><em class="calibre11">Listing 6-6: Putting expression objects to work</em></p>
<p class="noindent">The <code>mkvar()</code> function converts the <code>s</code> string into a <code>Symbol</code>. It then creates an expression object that assigns to the interpolated value of that symbol the value of <code>v</code>. Finally, it applies <code>eval()</code> to the expression object. The result of this <code>eval()</code> is a new variable with a name identical to the supplied string <code>s</code>, and with the value <code>v</code>.</p>
<p class="indent">Here it is in action:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">mkvar("Arthur", 42);</span>

julia&gt; <span class="codestrong">Arthur</span>
42</pre>
<p class="indent">This kind of functionality requires metaprogramming. In particular, we can’t do <code>"Arthur" = 42</code>, because we can’t assign to a string.</p>
<p class="indent">The previous example makes clear exactly what symbols are: they are the way Julia represents variables within expression objects. In other words, symbols are how Julia represents variables to itself. They are also, as we’ve shown, often drafted for service as keyword arguments and for other purposes, but that usage is tangential to their fundamental identity. Symbols are popular for these purposes simply because they’re more efficient than strings.</p>
<p class="indent">The <code>mkvar()</code> function is more than just a magic trick. The strings it consumes may be taken, for example, from the headings of a table of data read from a file. In that case, <code>mkvar()</code>, or something like it, could create variables named after those headings and assign them to the columns of data underneath them. We’ll explore applications of these ideas in <a href="ch10.xhtml" class="calibre10">Chapter 10</a>.</p>
<h3 class="h2" id="ch06lev4"><strong class="calibre2">Macros</strong></h3>
<p class="noindent">A <em class="calibre11">macro</em> is a function that accepts expressions, symbols, and literals as arguments and returns an expression object. The expression object is automatically evaluated at runtime.</p>
<p class="indent">There is a crucial difference between macros and the other functions that we’ve studied up to now, including functions that manipulate expression <span epub:type="pagebreak" id="page_171"/>objects. Functions are evaluated at runtime, using the current values of any global variables.</p>
<p class="indent">The processing inside a macro, in contrast, happens during a separate compilation stage <em class="calibre11">before</em> the program runs. The expression object returned by the macro is inserted into the code at the location of the macro and <code>eval()</code>ed. This property allows us to use macros to alter or add to the syntax of the language.</p>
<h4 class="h3" id="ch06lev1sec8"><strong class="calibre2"><em class="calibre4">How to Create Macros</em></strong></h4>
<p class="noindent">The following is a macro version of the <code>mkvar()</code> function that we defined in <a href="ch06.xhtml#ch6lis6" class="calibre10">Listing 6-6</a>:</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">macro mkvarmacro(s, v)</span>
              <span class="codestrong">ss = Symbol(s)</span>
           <span class="ent">➊</span> <span class="codestrong">return esc(:($ss = $v))</span>
          <span class="codestrong">end</span>
   @mkvarmacro (macro with 1 method)
   
<span class="ent">➋</span> julia&gt; <span class="codestrong">@mkvarmacro "color" 17</span>
   17
   
   julia&gt; <span class="codestrong">color</span>
   17</pre>
<p class="indent">Normally, to avoid collisions with names in the calling context, macros change the names of all the variables they contain into private versions. In cases where we want these variables to refer to variables of the same name when we use the macro, we use <code>esc()</code> <span class="ent">➊</span> to bypass the private naming process. This is one of those cases because the purpose of this macro is to create a variable from the string we supply and to assign it a value.</p>
<p class="indent">We invoke a macro by prepending an <code>@</code> sign to its name <span class="ent">➋</span>. The syntax for supplying arguments is more flexible than in the case of functions. We can list the arguments separately using spaces, as in this example, or place a comma-separated list inside parentheses, as we do with functions: <code>@mkvarmacro("color", 17)</code>. If the argument is a literal array, we can dispense with the space and the parentheses and call the macro as <code>@macroname[1 2 3]</code>.</p>
<p class="indent">As soon as the macro is invoked, the <code>Expr</code> object <code>($ss = $v)</code>, with interpolation substituting a literal <code>color</code> for <code>ss</code> and <code>17</code> for <code>v</code>, is evaluated, so 17 is assigned to the variable <code>color</code>.</p>
<p class="indent">As an example of how we can use macros to add new syntax to Julia, suppose we don’t like using the <code>end</code> keyword in <code>while</code> loops. In <a href="ch06.xhtml#ch6lis7" class="calibre10">Listing 6-7</a> we’ll create a simple macro that accepts a condition and a loop body, with no <code>end</code> required. We’re not allowed to reuse the <code>while</code> keyword, so we’ll call our macro <code>@during</code>.<span epub:type="pagebreak" id="page_172"/></p>
<pre class="calibre13">macro during(condition, body)
    return quote
        while $condition
         <span class="ent">➊</span> $(esc(body))
        end
    end
end</pre>
<p class="list" id="ch6lis7"><em class="calibre11">Listing 6-7: Creating new syntax with a macro</em></p>
<p class="indent">We use the <code>esc()</code> function <span class="ent">➊</span> because we want the loop body to be able to use variables defined outside the macro.</p>
<p class="indent">Here’s how to use this macro:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">i = 0</span>
0

julia&gt; <span class="codestrong">@during i &lt; 10 (println(i^2); i+=1)</span>
0
1
4
9
16
25
36
49
64
81

julia&gt; <span class="codestrong">i</span>
10</pre>
<p class="indent">The last two lines show that the macro indeed references the variable <code>i</code> in the global scope.</p>
<p class="indent">With our new powers, we can invent a kind of loop that doesn’t exist in the language. Let’s create an “until” loop that repeats a block <em class="calibre11">until</em> a condition is met. This is the same thing as a <code>while</code> loop that continues while the condition is <em class="calibre11">not</em> met. With this insight, our new macro is a simple modification of the one in <a href="ch06.xhtml#ch6lis7" class="calibre10">Listing 6-7</a>:</p>
<pre class="calibre13">macro until(condition, body)
    return quote
        while !$condition
            $(esc(body))
        end
    end
end</pre>
<p class="indent">Let’s test it in the REPL to see if it does what we expect:<span epub:type="pagebreak" id="page_173"/></p>
<pre class="calibre13">julia&gt; <span class="codestrong">i = 0</span>
0

julia&gt; <span class="codestrong">@until i == 11 (println(i^3); i+=1)</span>
0
1
8
27
64
125
216
343
512
729
1000</pre>
<p class="noindent">Our <code>@until</code> loop works as intended, incrementing <code>i</code> until <code>i == 11</code>.</p>
<p class="indent">Writing macros is inherently more difficult than writing normal functions, partly due to the necessity to keep track of levels of quoting and self-reference. Fortunately, you’ll never need to write a single macro to perform scientific calculations or numerical work. However, if you find you’re repeating “boilerplate” code often, and this repeated code can’t be expressed using a normal function, you may have a situation where the code-writing powers of macros can save you some work.</p>
<h4 class="h3" id="ch06lev1sec9"><strong class="calibre2"><em class="calibre4">Useful Macros</em></strong></h4>
<p class="noindent">Although you may never write your own macros, you’ll use them often. Both the standard library and many packages provide useful functionality through various macros. This section surveys several convenient macros for general use.</p>
<h5 class="h4" id="ch06sec1sec7"><strong class="calibre2">The Broadcast Macro</strong></h5>
<p class="noindent">We’ve described how Julia’s dot operator can extend functions and operators to act element-wise over entire arrays (see “Broadcasting” on <a href="ch02.xhtml#ch02lev1sec13" class="calibre10">page 51</a>). We often want to write long expressions in which all, or the great majority, of the functions need to be broadcast over their array arguments. The broadcast macro frees us from having to sprinkle dots everywhere in such an expression—for example:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">r = 1:10</span>

julia&gt; <span class="codestrong">[r (@. exp(r) &gt; r^4) (exp.(r) .&gt; r.^4)]</span>
10×2 BitMatrix:
  1  1  1
  2  0  0
  3  0  0
  4  0  0
  5  0  0
  6  0  0
  7  0  0
  8  0  0
  9  1  1
 10  1  1</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_174"/>This example constructs a three-column matrix showing when the exponential function becomes larger than its argument to the fourth power (<code>exp(x)</code> is the Julia function for <em class="calibre11">e</em><sup class="calibre23"><em class="calibre11">x</em></sup>). The second column is made from an expression using the broadcast macro, while the third is an expression with the identical meaning, but with explicit dots. The two columns are identical.</p>
<p class="indent">To exclude a function from the macro’s automatic broadcasting, precede it with a dollar sign (<code>$</code>). As an example, here is the sum of the first 10 squares:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">sum((1:10).^2)</span>
385</pre>
<p class="noindent">The <code>sum()</code> function, which adds all the numbers in an array, does not have a dot because it acts on the array as a whole, rather than element by element.</p>
<p class="indent">If we rewrite the expression using the broadcast macro, we should exempt <code>sum()</code> from the auto-dotting:</p>
<pre class="calibre13">julia&gt; @. <span class="codestrong">$sum((1:10)^2)</span>
385</pre>
<p class="noindent">Without the prepending dollar sign, <code>sum()</code> would be applied to each element individually; however, this is not what we want, as <code>sum(n)</code> is simply equal to <code>n</code> when <code>n</code> is a single number.</p>
<h5 class="h4" id="ch06sec1sec8"><strong class="calibre2">The @chain Macro</strong></h5>
<p class="noindent">The <code>@chain</code> macro, which is not part of the standard library and must be imported from the <code>Chain</code> package, is a more convenient alternative to the pipe operator (<code>|&gt;</code>) for transforming data through a series of expressions. The pipe operator has certain limitations. For example, it’s designed to work only with functions that have a single argument. The <code>@chain</code> macro is one of several approaches in the Julia ecosystem that creates a more flexible pipelining mechanism.</p>
<p class="indent">First, let’s look at the syntax of the built-in pipe with a simple example:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">"hello" |&gt; uppercase |&gt; reverse</span>
"OLLEH"</pre>
<p class="noindent">We’ve passed the string <code>"hello"</code> through two functions to transform it.</p>
<p class="indent">Suppose we want to continue the pipeline, adding <code>occursin()</code> as a third function, to check for the occurrence in the result of the string <code>"OL"</code>. The <code>occursin()</code> function takes the string to search in as the <em class="calibre11">second</em> argument, so there’s no obvious way to extend the pipeline to use it.</p>
<p class="indent"><span epub:type="pagebreak" id="page_175"/>Instead of the pipe operator, we can use the <code>@chain</code> macro to accomplish this task:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">@chain "hello" begin</span>
           <span class="codestrong">uppercase</span>
           <span class="codestrong">reverse</span>
        <span class="ent">➊</span> <span class="codestrong">occursin("OL", _)</span>
       <span class="codestrong">end</span>
true</pre>
<p class="indent">The <code>@chain</code> macro creates a pipeline from a series of expressions without the use of any extra operators. It handles functions of any number of arguments. By default, the result of each expression is fed into the first argument of the following function. To insert the result into an argument in a position other than the first, indicate its slot with an underscore <span class="ent">➊</span>.</p>
<h5 class="h4" id="ch06sec1sec9"><strong class="calibre2">The @time Macro</strong></h5>
<p class="noindent">The <code>@time</code> macro tells how much machine time a computation consumes, plus some information about memory allocations:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">@time sum((1:1e8).^2)</span>
  0.661141 seconds (2 allocations: 762.940 MiB, 1.01% gc time)
3.333333383333333e23</pre>
<p class="noindent">First the REPL prints a line with information about the resources used, and then the result of the computation.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">The</em> <span class="codeitalic1">@time</span> <em class="calibre11">macro is handy for getting a rough idea of timings, but for more systematic benchmarking or profiling, I recommend importing the</em> <span class="codeitalic1">BenchmarkTools</span> <em class="calibre11">package and using the</em> <span class="codeitalic1">@btime</span> <em class="calibre11">macro and other tools therein. The</em> <span class="codeitalic1">BenchmarkTools</span> <em class="calibre11">macros can run an expression multiple times and take an average, separate run time from compilation time, and more.</em></p>
</div>
<h5 class="h4" id="ch06sec1sec10"><strong class="calibre2">Macros for Performance</strong></h5>
<p class="noindent">Julia comes with several macros we can use to alter the behavior of the compiler, sometimes leading to more efficient code. They need to be used with care, as their use is not without risk. The two macros discussed in this section can provide significant speedups in some circumstances; in others, they have little or no effect. One usually has to experiment to find out if they’ll provide any benefit. These two macros, and similar strategies, should be explored at the final stages of performance tuning. During the development of an algorithm or a program, such attempts at optimization would likely be a counterproductive distraction.</p>
<p class="indent">Normally the compiler checks our indexing expressions to make sure we’re not indexing array elements that don’t exist, returning a <code>BoundsError</code> if we index beyond the end of an array, or wind up using a nonpositive index. <span epub:type="pagebreak" id="page_176"/>In some routines, this bounds checking can affect performance. If we’re sure that an area of code cannot contain an indexing error, we can instruct the compiler to skip the bounds checking for that location using the <code>@inbounds</code> macro:</p>
<pre class="calibre13">x = (1:1e6).^2; s = 0
@inbounds for i in 1:2:1000
    s += x[i]
end</pre>
<p class="noindent">The <code>@inbounds</code> instruction at the start of the <code>for</code> loop tells the compiler not to worry about <code>x[i]</code> being an illegal access during the loop. We’re responsible for ensuring that <code>i</code> stays within the bounds of <code>x</code>.</p>
<p class="indent">The utility of <code>inbounds</code> is much reduced in recent versions of Julia; there’s no longer a good reason to use it for versions more recent than 1.8. However, we’ll encounter it in much existing code, so it’s important to know what it’s supposed to do.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">A common error is to try to generate the indices for the array</em> <span class="codeitalic1">A</span> <em class="calibre11">with</em> <span class="codeitalic1">1:length(A)</span><em class="calibre11">. This does not create legal indices for every type of array, and, if used to access</em> <span class="codeitalic1">A</span> <em class="calibre11">within an</em> <span class="codeitalic1">@inbounds</span> <em class="calibre11">section, it can create silent bounds errors. Instead, we should use</em> <span class="codeitalic1">eachindex(A)</span><em class="calibre11">, which always returns an iterator over legal indices of</em> <span class="codeitalic1">A</span><em class="calibre11">.</em></p>
</div>
<p class="indent">As mentioned earlier in this chapter, addition and multiplication on floats are not associative: the results can depend on the order in which we add or multiply numbers. For this reason, the Julia compiler will normally perform arithmetic exactly the way we spell it out, even if it would be faster to change the order of operands or rewrite expressions to “real number equivalents” that would be more efficient. This ensures that running a program on different versions of the compiler will produce the same numerical results, as all the arithmetic will occur in the same order.</p>
<p class="indent">In situations where the last few decimal places of a result are not important, we can sacrifice some of this reproducibility to gain speed by allowing the compiler to rearrange our expressions. The instruction is provided by the <code>@fastmath</code> macro:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">const d = 1.0045338347428372e6</span>
1.0045338347428372e6

julia&gt; <span class="codestrong">@time sum(i/d for i in 1:1e9)</span>
  5.248617 seconds
4.9774331456739935e11

julia&gt; <span class="codestrong">@time @fastmath sum(i/d for i in 1:1e9)</span>
  3.856526 seconds
4.977433145673994e11</pre>
<p class="indent"><span epub:type="pagebreak" id="page_177"/>Here we’ve performed the same sum</p>

<div class="image"><img alt="Image" src="../images/math177.jpg" class="calibre6"/></div>
<p class="noindent">twice, the second time using the <code>@fastmath</code> directive. Our expression needlessly performs an extra billion divisions. One obvious optimization available for <code>@fastmath</code> is to factor out the constant <em class="calibre11">d</em>. The macro gets us a speedup of about 26 percent. It also changes the result slightly in the two final digits. Neither result is more “correct." This is an example of how arithmetic on floats depends on the details of the calculation.</p>
<h5 class="h4" id="ch06sec1sec11"><strong class="calibre2">Macros for String Formatting</strong></h5>
<p class="noindent">The <code>Printf</code> package provides two macros that format strings using the C-style specifications that have become a de facto standard across multiple programming languages. The following example shows how a macro makes our code neater, allowing us to list the variables to be formatted without parentheses and commas:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Printf</span>

julia&gt; <span class="codestrong">@printf "10! is about %.2e and √2 is approximately %.4f" factorial(10) √2</span>
10! is about 3.63e+06 and √2 is approximately 1.4142</pre>
<p class="noindent">The format specifiers are the fragments in the string beginning with <code>%</code>; the digit after the decimal point determines the number of digits after the point printed in the result. For a list of all the format specifiers and a guide to their syntax, see “Further Reading” on <a href="ch06.xhtml#fur6" class="calibre10">page 187</a>.</p>
<p class="indent">A companion to this macro is <code>sprintf</code>, which behaves the same way but returns the formatted string as a result rather than printing it. Use <code>sprintf</code> to store the generated string in a variable.</p>
<h5 class="h4" id="ch06sec1sec12"><strong class="calibre2">Macros for Information</strong></h5>
<p class="noindent">Several macros that provide information about the environment in which they are invoked are always available. The <code>@__MODULE__</code>, <code>@__DIR__</code>, <code>@__FILE__</code>, and <code>@__LINE__</code> macros return the module, directory, filepath, and line number, respectively, where they are called. These macros can be useful for debugging, writing build scripts, code formatting, testing, and other purposes. (Each of the macro names in this paragraph begins and ends with a double underscore.)</p>
<p class="indent">One essential aid when debugging macros is a macro called <code>@macroexpand</code>. Simply prepend it to your macro call, and it will show you what the macro is using for each variable and reference.<span epub:type="pagebreak" id="page_178"/></p>
<h3 class="h2" id="ch06lev5"><strong class="calibre2">Error Handling</strong></h3>
<p class="noindent">Like most modern languages, Julia has methods for handling, manipulating, and creating errors (also called <em class="calibre11">exceptions</em>). We’ve seen plenty of examples of errors in this book so far: they occurred in REPL sessions or as a result of running programs when Julia encountered a situation that prevented it from continuing with the computation. These situations have included calling functions with arguments that they were not designed to accept, indexing arrays outside their bounds, using an undefined name, and others. Each one was introduced in order to illustrate a characteristic of the language, but in practice we encounter errors when something unexpected happens, or something happens that we need to guard against.</p>
<p class="indent">In this section we’ll explore how to handle errors and some methods for making them part of our programs’ flow control. Julia’s type system and its method of function dispatch, covered in <a href="ch08.xhtml" class="calibre10">Chapter 8</a>, provide a cleaner way to accomplish some of what relies on exception handling in other languages. These more idiomatic Julia techniques should be preferred because they allow the compiler to perform more optimizations. Nevertheless, sometimes the methods described in this section are the most convenient way to accomplish a programming task.</p>
<h4 class="h3" id="ch06lev1sec10"><strong class="calibre2"><em class="calibre4">Types of Errors</em></strong></h4>
<p class="noindent">Julia uses about 25 distinct kinds of exceptions. Some occur rarely, while others we may only wish were rare. Here are the most common ones:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">1 + "1"</span>
ERROR: MethodError: no method matching +(::Int64, ::String)

julia&gt; <span class="codestrong">[1, 2, 3][4]</span>
ERROR: BoundsError:
  attempt to access 3-element Vector{Int64} at index [4]

julia&gt; <span class="codestrong">notdefined</span>
ERROR: UndefVarError: notdefined not defined

julia&gt; <span class="codestrong">'abc'</span>
ERROR: syntax: character literal contains multiple characters

julia&gt; <span class="codestrong">[1 2] * [3 4 5]</span> <span class="ent">➊</span>
ERROR: DimensionMismatch:
  matrix A has dimensions (1,2), matrix B has dimensions (1,3)

julia&gt; <span class="codestrong">log(-1)</span>
ERROR: DomainError with -1.0:
log will only return a complex result if called with a complex argument.
Try log(Complex(x)).

<span epub:type="pagebreak" id="page_179"/>julia&gt; <span class="codestrong">1 ÷ 0</span> <span class="ent">➋</span>
ERROR: DivideError: integer division error

julia&gt; <span class="codestrong">Int(2.1)</span> <span class="ent">➌</span>
ERROR: InexactError: Int64(2.1)

julia&gt; <span class="codestrong">Dict(["a" =&gt; 1, "b" =&gt; 2])["c"]</span>
ERROR: KeyError: key "c" not found

julia&gt; <span class="codestrong">factorial(55)</span>
ERROR: OverflowError: 55 is too large to look up in the table;
consider using `factorial(big(55))` instead <span class="ent">➍</span>

julia&gt; <span class="codestrong">"François"[6]</span>
ERROR: StringIndexError: invalid index [6], valid nearby indices [5]=&gt;'ç', [7]=&gt;'o'</pre>
<p class="noindent">The identifier immediately following the word <code>ERROR:</code> is the name of the error. It’s usually followed by some explanation and even occasionally some advice.</p>
<p class="indent">Most of the error messages are self-explanatory. A <code>MethodError</code> means that someone tried to call a function with argument types that it doesn’t support. Operators such as + are functions written with an infix syntax. (See “Creating Multiple Methods” on <a href="ch08.xhtml#ch08lev1sec6" class="calibre10">page 230</a> for more information on methods and the precise meaning of the error message.)</p>
<p class="indent">The <code>*</code> operator, when applied to arrays, performs matrix multiplication, which requires that the second dimension of the first argument match the first dimension of the second argument <span class="ent">➊</span>.</p>
<p class="indent">We’re allowed to divide by a floating-point 0, which results in <code>Inf</code> or <code>-Inf</code>, which means that we can do <code>1/0</code> because the <code>/</code> operator converts to floating point. However, dividing by 0 using the integer division operator (<code>÷</code>) results in a <code>DivideError</code> <span class="ent">➋</span>.</p>
<p class="indent">If we try a conversion between numerical types that would lose information, an <code>InexactError</code> is the result <span class="ent">➌</span>.</p>
<p class="indent">The usual types of integers aren’t large enough to hold the result of <code>factorial(55)</code>, but, as the advice following the error message <span class="ent">➍</span> suggests, we can turn to another type of number. We’ll cover <code>big</code> numbers in “‘Big’ and Irrational Types” on <a href="ch08.xhtml#ch08lev1sec1" class="calibre10">page 216</a>.</p>
<h4 class="h3" id="ch06lev1sec11"><strong class="calibre2"><em class="calibre4">The Call Stack</em></strong></h4>
<p class="noindent">Suppose we have a series of function calls, where a function calls a second function, which calls a third, and so on. When the final function in this chain finishes its job, the compiler needs to know what to do next. In order to know what the next instruction should be, the compiler keeps track of “how we got here.” That information, which includes the details of the chain of function calls, is called the <em class="calibre11">call stack</em>. It forms the sometimes lengthy part of error messages that I usually omit from the listings in this book to save space.</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_180" class="calibre1"/><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">In practice, the compiler optimizes nested function calls through “inlining” when possible. This optimization replaces the nested calls with direct insertion of the called function’s code into the calling function. But there is still the logical notion of the call stack, and the error report prints this logical stack, noting any inlining.</em></p>
</div>
<p class="indent">To illustrate how the call stack works, <a href="ch06.xhtml#ch6lis8" class="calibre10">Listing 6-8</a> sets up a series of five functions, each one defined to call the next one by name, except the last, which calls the <code>log()</code> function.</p>
<pre class="calibre13">function a(n)
    b(n)
end

function b(n)
    n -= 1
    c(n)
end

function c(n)
    n -= 1
    d(n)
end

function d(n)
    n -= 1
    e(n)
end

function e(n)
    return log(n)
end</pre>
<p class="list" id="ch6lis8"><em class="calibre11">Listing 6-8: A chain of functions</em></p>
<p class="noindent">Function <code>a()</code> calls <code>b()</code>, passing the supplied argument <code>n</code>. Function <code>b()</code> decrements that argument and calls <code>c()</code>, passing its new value, then <code>c()</code> calls <code>d()</code> similarly. Finally, <code>e()</code> calls <code>log(n)</code>, where now <code>n</code> is 3 less than the original <code>n</code>.</p>
<p class="indent"><a href="ch06.xhtml#ch6lis9" class="calibre10">Listing 6-9</a> shows calling <code>a()</code> a couple of times.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">a(5)</span>
0.6931471805599453

julia&gt; <span class="codestrong">a(2)</span>
ERROR: DomainError with -1.0:
log will only return a complex result if called with a
complex argument. Try log(Complex(x)).
Stacktrace:
  [1] throw_complex_domainerror(f::Symbol, x::Float64)
    @ Base.Math ./math.jl:33
  [2] _log(x::Float64, base::Val{:<span class="codeitalic">e</span>}, func::Symbol)
    @ Base.Math ./special/log.jl:292
  [3] log
    @ ./special/log.jl:257 [inlined]
  [4] log
    @ ./math.jl:1350 [inlined]
  [5] e
    @ ./REPL[215]:2 [inlined]
  [6] d
    @ ./REPL[214]:3 [inlined]
  [7] c
    @ ./REPL[213]:3 [inlined]
  [8] b
    @ ./REPL[212]:3 [inlined]
  [9] a(n::Int64)
    @ Main ./REPL[211]:2
 [10] top-level scope
    @ REPL[217]:1</pre>
<p class="list" id="ch6lis9"><span epub:type="pagebreak" id="page_181"/><em class="calibre11">Listing 6-9: A call stack when an error occurs</em></p>
<p class="indent">First we call <code>a(5)</code>, which ultimately leads to a call to <code>log(5-3)</code>, or <code>log(2)</code>, and returns the expected result. When we call <code>a(2)</code>, that results in <code>log(2-3)</code>, or <code>log(-1)</code>, and the attempt to take the logarithm of a negative number produces the expected <code>DomainError</code>. What follows is the stacktrace: information about the call stack at the moment that the error occurred. This data, which can become far lengthier than in this artificial example, is an aid to debugging, informing us about the state of the program that led to an error condition.</p>
<p class="indent">The numbers in square brackets are part of the trace as printed in the REPL, showing the sequence of function calls, beginning with the most recent, where the error was raised, and proceeding up the chain. The first entry is the function that actually handles the error. This is followed by the log functions themselves, and then our functions <code>e()</code> up through <code>a()</code>. The final entry informs us that <code>a()</code> was called from the REPL. The stacktrace also tells us which functions were inlined by the compiler.</p>
<h4 class="h3" id="ch06lev1sec12"><strong class="calibre2"><em class="calibre4">try...catch Blocks</em></strong></h4>
<p class="noindent">Instead of allowing errors to simply stop our program, we can intercept them. We do this in Julia with the <code>try</code>...<code>catch</code> block, another form of flow control like the <code>if</code> block. Here’s an example:</p>
<pre class="calibre13">function friendly_log(n)
    try
        return log(n)
    catch oops
        if oops isa DomainError
            @warn "you may have supplied a negative number: $n"
         <span class="ent">➊</span> @info "Trying with $(-n)."
            log(-n)
        elseif oops isa MethodError
         <span class="ent">➋</span> @error "please supply a positive number."
        end
    end
end</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_182"/>The <code>friendly_log()</code> function wraps the built-in <code>log()</code> function in some error handling. The normal <code>log()</code> rejects negative arguments with a <code>DomainError</code>, but this version tries again with the argument’s absolute value, warning the user about what it’s doing. The <code>try</code> part of the block contains the code whose errors we want to intercept; the <code>catch</code> part intercepts them, optionally assigning the error itself to a variable, here <code>oops</code>. Inside the <code>catch</code> block we put an ordinary <code>if</code> block, using <code>isa</code> to test for the type of error (“Types in Practice” on <a href="ch08.xhtml#ch08lev1" class="calibre10">page 214</a> explains more about <code>isa</code> and types). If <code>oops</code> happens to be a <code>DomainError</code>, the <code>@warn</code> macro prints a warning to the terminal, after which we issue another message, using the <code>@info</code> macro, explaining how the program plans to change the faulty argument <span class="ent">➊</span>. We then call <code>log()</code> with the argument made positive.</p>
<p class="indent">If the error is not a <code>DomainError</code>, but instead is a <code>MethodError</code>, something else is wrong with the argument. In this case, we don’t know what to do and the program should halt. The <code>@error</code> macro <span class="ent">➋</span> prints an error message, <em class="calibre11">after which the program continues</em>. Since there’s nothing else for it to do, it exits. The <code>@error</code> macro, like the <code>@warn</code> macro, simply prints an appropriately formatted message; neither macro creates an error condition nor has any effect on flow. On a color device, warnings are signaled in yellow and errors in red, and both attempt to indicate where in the program the problem occurred. Messages generated by <code>@info</code> appear in blue in the REPL, and don’t include a program location. All three macros are part of Julia’s logging system. See the link to the documentation in “Further Reading” on <a href="ch06.xhtml#fur6" class="calibre10">page 187</a> for information about more of what you can do with this logging information.</p>
<p class="indent">Since we “handle” the errors in the <code>catch</code> block, they won’t stop the program or lead to a stacktrace:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">function call_fl(n)</span>
           <span class="codestrong">friendly_log(n)</span>
       <span class="codestrong">end</span>

julia&gt; <span class="codestrong">call_fl(-3)</span>
 Warning: you may have supplied a negative number: -3
 @ Main REPL[222]:6
[ Info: Trying with 3.
1.0986122886681098</pre>
<p class="noindent">If we had not intercepted the error in the <code>catch</code> block, it would have led to a stacktrace as in the previous section, with <code>call_fl()</code> as part of the call stack.<span epub:type="pagebreak" id="page_183"/></p>
<h4 class="h3" id="ch06lev1sec13"><strong class="calibre2"><em class="calibre4">Using throw()</em></strong></h4>
<p class="noindent">The REPL’s help mode explains that <code>throw()</code> throws an object as an exception. Most Julia tutorials describe it as a way for the programmer to create errors. Both of these descriptions are true, but they tell only part of the story. Before delving into the full power of <code>throw()</code>, let’s look at a simple example of where we might want to create an error where there otherwise would not be one.</p>
<h5 class="h4" id="ch06sec1sec13"><strong class="calibre2">Creating Errors</strong></h5>
<p class="noindent">The <code>log()</code> function allows us to call it with an argument of 0, returning <code>-Inf</code> as the result. Suppose we wanted to have a logarithm function that did <em class="calibre11">not</em> allow 0 as an argument because we wanted to exclude infinities from its results. The <code>finite_log()</code> function would be one way to accomplish this:</p>
<pre class="calibre13">function finite_log(n)
    if n == 0
        throw(DomainError(n, "please supply a positive argument; log(0) = -Inf."))
    end
    return log(n)
end</pre>
<p class="noindent">An <code>if</code> block checks for the 0 input and calls <code>throw()</code> if it finds one. The argument of <code>throw()</code> is the name of an error turned into a function; each of Julia’s errors has such an associated function for constructing the error. The <code>finite_log()</code> function raises a <code>DomainError</code> if it gets 0 as an argument. We can raise any error we want, but as the idea here is to exclude a value from the domain, a <code>DomainError</code> makes sense:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">finite_log(2)</span>
0.6931471805599453

julia&gt; <span class="codestrong">finite_log(0)</span>
ERROR: DomainError with 0:
please supply a positive argument; log(0) = -Inf.
Stacktrace:
 [1] finite_log(n::Int64)
   @ Main ./REPL[230]:3
 [2] top-level scope
   @ REPL[234]:1

julia&gt; <span class="codestrong">log(0)</span>
-Inf</pre>
<p class="indent">Here <code>finite_log()</code> behaves like <code>log()</code> unless it gets a 0, when it halts with a <code>DomainError</code>. The message that we included in <code>throw()</code> is printed out with the error message.</p>
<p class="indent"><span epub:type="pagebreak" id="page_184"/>Most of the error constructors accept arguments for information for Julia to include in the error message. To see what arguments are permitted, ask the REPL:</p>
<pre class="calibre13">help?&gt; <span class="codestrong">DomainError</span>
search: DomainError

  DomainError(val)
  DomainError(val, msg)

  The argument val to a function or constructor is outside the valid domain.</pre>
<p class="noindent">The documentation informs us that there are two versions, one with just the offending value, and the version that we used, with an explanatory message as well.</p>
<h5 class="h4" id="ch06sec1sec14"><strong class="calibre2">Combining throw() with try...catch Blocks</strong></h5>
<p class="noindent">Combining <code>throw()</code> with <code>try</code>...<code>catch</code> blocks unleashes its full power. In combination, they create a new form of flow control that allows us to pass <em class="calibre11">any value</em> up the call stack until it is intercepted by a <code>catch</code>, at which point we can halt the program or do something else.</p>
<p class="indent">As an example, <a href="ch06.xhtml#ch6lis10" class="calibre10">Listing 6-10</a> modifies the chain of functions from <a href="ch06.xhtml#ch6lis8" class="calibre10">Listing 6-8</a>.</p>
<pre class="calibre13">function a(n)
    try
        b(n)
    catch oops
        if oops[1] == 0
            @warn "$(oops[2]) Attempted to call log(0) = Inf."
        else
            @error "$(oops[2]) Attempted to call log($(oops[1]))."
        end
    end
end

function b(n)
    n -= 1
    c(n)
end

function c(n)
    n -= 1
    d(n)
end

function d(n)
    n -= 1
    e(n)
end

function e(n)
    if n &lt; 0
     <span class="ent">➊</span> throw((n, "Got a negative number."))
    elseif n == 0
        throw((0, "Got 0."))
    end
    return log(n)
end</pre>
<p class="list" id="ch6lis10"><span epub:type="pagebreak" id="page_185"/><em class="calibre11">Listing 6-10: Throwing and catching</em></p>
<p class="indent">Looking at the <code>e()</code> function first, we’ve added an <code>if</code> block above what used to be its only line. Before trying to calculate the logarithm, it checks the argument <code>n</code>. If this argument is not positive, it calls <code>throw()</code> with a <code>Tuple</code> as an argument <span class="ent">➊</span>. In both cases, the tuple’s first element is <code>n</code> and its second element is a string. The <code>throw()</code> function sends this tuple up the call stack and returns from <code>e()</code> without attempting to calculate the logarithm. If <code>n == 0</code>, we send a different message up the call stack.</p>
<p class="indent">The message sent by <code>throw()</code> travels from function call to function call until it’s intercepted by the <code>try</code>...<code>catch</code> block in function <code>a()</code>. The <code>catch</code> statement assigns the message, in this case a <code>Tuple</code>, to the variable <code>oops</code>, where it’s examined in the <code>if</code> block, which prints the appropriate warning or error message.</p>
<p class="indent">Here it is in action:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">a(5)</span>
0.6931471805599453

julia&gt; <span class="codestrong">a(3)</span>
 Warning: Got 0. Attempted to call log(0) = Inf.
 @ Main REPL[1]:6

julia&gt; <span class="codestrong">a(2)</span>
 Error: Got a negative number. Attempted to call log(-1).
 @ Main REPL[1]:8</pre>
<p class="indent">This exhibits a dramatic difference from the error reporting shown in <a href="ch06.xhtml#ch6lis9" class="calibre10">Listing 6-9</a>. Here we see no call stack, but merely the messages constructed in our <code>try...catch</code> block. The <code>throw()...catch</code> mechanism lets us toss a message “over the heads” of any number of functions in a call stack, directly to the first one ready with the appropriate <code>catch</code> statement. <a href="ch06.xhtml#ch6lis9" class="calibre10">Listing 6-9</a> had no <code>catch</code> in place to intercept the error, so Julia halted the program and printed out the complete call stack for our diagnostic use.<span epub:type="pagebreak" id="page_186"/></p>
<h4 class="h3" id="ch06lev1sec14"><strong class="calibre2"><em class="calibre4">The finally Clause</em></strong></h4>
<p class="noindent">The <code>try...catch</code> block can optionally end with a <code>finally</code> clause, which is executed before the program exits. We typically use this for “cleanup,” such as releasing external resources or file handles that an error condition otherwise might leave in an uncertain state.</p>
<p class="indent">Let’s add a <code>finally</code> clause to <code>a()</code> from <a href="ch06.xhtml#ch6lis10" class="calibre10">Listing 6-10</a>:</p>
<pre class="calibre13">function a(n)
    try
        b(n)
    catch oops
        if oops[1] == 0
            @warn "$(oops[2]) Attempted to call log(0) = Inf."
        else
            @error "$(oops[2]) Attempted to call log($(oops[1]))."
        end
    finally
        @info "Calculation completed with input n = $n."
    end
end</pre>
<p class="indent">Calling it as before, we’ll see the following:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">a(5)</span>
[ Info: Calculation completed with input n = 5.
0.6931471805599453

julia&gt; <span class="codestrong">a(2)</span>
 Error: Got a negative number. Attempted to call log(-1).
 @ Main REPL[11]:8
[ Info: Calculation completed with input n = 2.</pre>
<p class="noindent">This example shows how the <code>finally</code> clause is always executed, whether there is a message to catch or not.</p>
<h3 class="h2" id="ch06lev6"><strong class="calibre2">Conclusion</strong></h3>
<p class="noindent">With the more advanced language features discussed in this chapter, we’ve attained a higher level of Julia mastery. We’re now better prepared for the detailed applications in <a href="part2.xhtml" class="calibre10">Part II</a>, where we’ll see how to apply our skills to address problems across a variety of fields.<span epub:type="pagebreak" id="page_187"/></p>
<div class="box">
<p class="boxtitle-d" id="fur6"><strong class="calibre2">FURTHER READING</strong></p>
<ul class="calibre12">
<li class="noindent1">The source containing the lists of characters available for infix operators,  with their precedences, is available at <a href="https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm" class="calibre10"><em class="calibre11">https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm</em></a>.</li>
<li class="noindent1">For more information on page tabulating C format specifiers, visit <a href="https://web.archive.org/web/20220127135451/https://www.journaldev.com/35137/format-specifiers-in-c" class="calibre10"><em class="calibre11">https://web.archive.org/web/20220127135451/https://www.journaldev.com/35137/format-specifiers-in-c</em></a>.</li>
<li class="noindent1">You can read Stefan Karpinski’s masterful explanation of what symbols really are at <a href="https://stackoverflow.com/a/23482257" class="calibre10"><em class="calibre11">https://stackoverflow.com/a/23482257</em></a>.</li>
<li class="noindent1">Documentation about the logging system and further uses for the <code>@info</code>, <code>@warn</code>, and <code>@error</code> macros is available at <a href="https://docs.julialang.org/en/v1/stdlib/Logging/" class="calibre10"><em class="calibre11">https://docs.julialang.org/en/v1/stdlib/Logging/</em></a>.<span epub:type="pagebreak" id="page_188"/></li></ul>
</div>
</body></html>