<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_175"/><span class="big">12</span><br/>CREATING STAND-ALONE PROGRAMS</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">Up to this point, we’ve used GHCi to do all of our calculations and to show us the results. We’ve written fairly sophisticated source code files, but we’ve always loaded them into GHCi to use their functions. Haskell, however, is a full-featured, production-ready computer language, and it’s completely capable of compiling stand-alone programs that don’t require any GHCi involvement. The animations in <a href="ch13.xhtml">Chapter 13</a> and later chapters are best carried out using stand-alone programs rather than GHCi.</p>&#13;
<p class="indent">This chapter explains three different ways to make a stand-alone (executable) program. The most basic way uses <code>ghc</code> to produce the executable program. With this method, you are responsible for installing any library packages that your program needs. The second way uses <code>cabal</code>, which will automatically install the library packages your program needs, but these packages must be listed in the appropriate place in a configuration file. The third way uses <code>stack</code>, which does even more things automatically, such as installing <span epub:type="pagebreak" id="page_176"/>a version of the GHC compiler compatible with versions of packages you request. To make a stand-alone program, you need to use only one of these three methods. If you are new to Haskell, you may find the <code>stack</code> method to be the easiest to use.</p>&#13;
<p class="indent">For each of the three methods, we’ll go through the steps required to produce an executable program (a) for a very simple program and (b) for a program that uses both modules we have written and modules other people have written.</p>&#13;
<h3 class="h3" id="ch12lev1">Using GHC to Make a Stand-Alone Program</h3>&#13;
<p class="noindent">In this section, we use GHC directly to make a stand-alone program. We do this first for a very simple program called “Hello, world!” and then for a more complex program that imports modules.</p>&#13;
<h4 class="h4" id="ch12lev2">Hello, World!</h4>&#13;
<p class="noindent">The simplest stand-alone program people often write when learning a new language is called “Hello, world!” All this program does is print the words “Hello, world!” and exit. For many computer languages, it makes sense to learn how to write the “Hello, world!” program very early in the process of learning the language. However, in Haskell, it doesn’t make sense to learn “Hello, world!” early because the “Hello, world!” program is all about producing an effect, namely printing something on the screen, while the core of Haskell programming, and functional programming in general, is about pure functions that have no effect.</p>&#13;
<p class="indent">The “Hello, world!” program in Haskell consists of two lines of code:</p>&#13;
<pre>main :: IO ()&#13;
main = putStrLn "Hello, world!"</pre>&#13;
<p class="indent">Every stand-alone program needs a function called <code>main</code>, which usually has type <code>IO ()</code>. We first introduced <code>IO ()</code> in <a href="ch07.xhtml">Chapter 7</a> as the type of an impure, or effectful, function that returns no meaningful value but produces an effect. In general, the type <code>IO a</code> represents a value of type <code>a</code> along with an effect.</p>&#13;
<p class="indent">The <code>main</code> function needs to produce some effect; otherwise, we wouldn’t be able to tell that the program actually ran. The purpose of the effectful function <code>main</code> is to describe to the compiler what we want the computer to <em>do</em>, and the type <code>IO ()</code> is the perfect type for this because it represents an effect without a meaningful value.</p>&#13;
<p class="indent">The function <code>putStrLn</code> is a Prelude function that takes a string as input, prints it on the screen, and advances to the next line so that any further printing occurs there. There is also a function called <code>putStr</code>, with the same type as <code>putStrLn</code>, that prints a string without advancing to the next line so that further printing occurs directly after the printed string. The <code>Ln</code> at the end of the name reminds us that the function advances to the next line <span epub:type="pagebreak" id="page_177"/>after printing. The type of <code>putStrLn</code> shows us that it takes a string as input and produces an effect.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:t putStrLn</span>&#13;
putStrLn :: String -&gt; IO ()</pre>&#13;
<p class="indent">Suppose we put these two lines in a source code file named <em>hello.hs</em>. If your operating system offers a command line, the command</p>&#13;
<pre><span class="codestrong1">$ ghc hello.hs</span></pre>&#13;
<p class="noindent">will compile the source code file <em>hello.hs</em> to produce an executable file, called <em>hello</em>, that you can run. On a Linux system, you can run the program <em>hello</em> from the command line with the command</p>&#13;
<pre><span class="codestrong1">$ ./hello</span></pre>&#13;
<p class="indent">The dot-slash in front of the program name tells the operating system to execute the program called <em>hello</em> that is in the current working directory. Omitting the dot-slash will cause the operating system to search its standard search path for a program called <em>hello</em>, which it may not find if the current working directory is not included in the search path.</p>&#13;
<h4 class="h4" id="ch12lev3">A Program That Imports Modules</h4>&#13;
<p class="noindent">Now we look at compiling a stand-alone program that uses functions from the <code>SimpleVec</code> module we wrote in <a href="ch10.xhtml">Chapter 10</a> and functions from the <code>Graphics</code> <code>.Gnuplot.Simple</code> module from the <code>gnuplot</code> package. The file <em>SimpleVec.hs</em> containing the source code for the <code>SimpleVec</code> module is available at <a href="https://lpfp.io">https://lpfp.io</a>. <a href="ch12.xhtml#ch12list1">Listing 12-1</a> shows the stand-alone program we want to compile.</p>&#13;
<pre id="ch12list1">{-# OPTIONS -Wall #-}&#13;
&#13;
import SimpleVec ( iHat, kHat, xComp, zComp, projectilePos, (^+^), (*^) )&#13;
import Graphics.Gnuplot.Simple ( Attribute(..), plotPath )&#13;
&#13;
main :: IO ()&#13;
main = let posInitial = 10 *^ kHat&#13;
           velInitial = 20 *^ cos (pi/6) *^ iHat ^+^ 20 *^ sin (pi/6) *^ kHat&#13;
           posFunc = projectilePos posInitial velInitial&#13;
           pairs = [(xComp r, zComp r) | t &lt;- [0, 0.01 ..], let r = posFunc t]&#13;
           plottingPairs = takeWhile (\(_,z) -&gt; z &gt;= 0) pairs&#13;
       in plotPath [Title "Projectile Motion"&#13;
                   ,XLabel "Horizontal position (m)"&#13;
                   ,YLabel "Height of projectile (m)"&#13;
                   ,PNG "projectile.png"&#13;
                   ,Key Nothing&#13;
                   ] plottingPairs</pre>&#13;
<p class="listing"><em>Listing 12-1: The stand-alone program MakeTrajectoryGraph.hs, which uses functions from the <span class="codeitalic1">SimpleVec</span> module and the <span class="codeitalic1">Graphics.Gnuplot.Simple</span> module</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_178"/>The program in <a href="ch12.xhtml#ch12list1">Listing 12-1</a> produces a graph of the trajectory of a ball thrown from the top of a building 10 m above the ground with an initial speed of 20 m/s at an angle 3<sup>0∘</sup> above horizontal. The program produces a file named <em>projectile.png</em> containing the graph. To do its work, this program imports functions such as <code>projectilePos</code>, <code>xComp</code>, <code>zComp</code>, <code>iHat</code>, and <code>kHat</code> from the <code>SimpleVec</code> module of <a href="ch10.xhtml">Chapter 10</a>. The program also uses the <code>plotPath</code> function from the <code>Graphics.Gnuplot.Simple</code> module. Because the data constructors <code>Title</code>, <code>XLabel</code>, and so on of the <code>Attribute</code> data type are used, we import the <code>Attribute</code> data type with its constructors by appending the name of the type <code>Attribute</code> with two dots enclosed in parentheses.</p>&#13;
<p class="indent">We’ll assume that the code in <a href="ch12.xhtml#ch12list1">Listing 12-1</a> is contained in a source code file called <em>MakeTrajectoryGraph.hs</em>. To use <code>ghc</code> to compile the program, two things must be true:</p>&#13;
<ul class="bull">&#13;
<li class="noindent">The file <em>SimpleVec.hs</em> containing the <code>SimpleVec</code> module must be present in the same directory as the file <em>MakeTrajectoryGraph.hs</em> containing the main program. We’ll call this directory the <em>working directory</em>.</li>&#13;
<li class="noindent">The working directory must have access to the <code>Graphics.Gnuplot.Simple</code> module. This requires that the <code>gnuplot</code> package be installed either (a) globally, so it can be accessed from any directory, or (b) locally, so it can be accessed from the working directory. To install the <code>gnuplot</code> package globally, issue the following command:&#13;
<pre><span class="codestrong1">$ cabal install --lib gnuplot</span></pre>&#13;
<p class="noindent">On my computer, this command creates or changes the file <em>/home/ walck/.ghc/x86_64-linux-8.10.5/environments/default</em> that contains the list of globally installed Haskell packages. To install the <code>gnuplot</code> package locally (in the working directory), issue the following command:</p>&#13;
<pre><span class="codestrong1">$ cabal install --lib gnuplot --package-env .</span></pre>&#13;
<p class="noindent">This command creates or changes a file with a name such as <em>.ghc .environment.x86_64-linux-8.10.5</em> in the current working directory. This file contains a list of packages installed locally (in the current working directory). See the appendix for more information about installing Haskell packages.</p></li>&#13;
</ul>&#13;
<p class="indent">Once these two criteria are met, we compile the source code file <em>Make TrajectoryGraph.hs</em> into an executable program by issuing the following command:</p>&#13;
<pre><span class="codestrong1">$ ghc MakeTrajectoryGraph.hs</span></pre>&#13;
<p class="indent">This command must be issued from the same working directory that contains the file <em>MakeTrajectoryGraph.hs</em>, the file <em>SimpleVec.hs</em>, and access to the <code>Graphics.Gnuplot.Simple</code> module.</p>&#13;
<p class="indent">If the compiler cannot find the <code>Graphics.Gnuplot.Simple</code> module, you will see an error like the following:</p>&#13;
<span epub:type="pagebreak" id="page_179"/>&#13;
<pre>MakeTrajectoryGraph.hs:4:1: error:&#13;
    Could not load module 'Graphics.Gnuplot.Simple'</pre>&#13;
<p class="indent">In this case, you must install the <code>gnuplot</code> package, either globally or locally, so it is accessible from the working directory.</p>&#13;
<p class="indent">If all goes well, the compiler will produce an executable file called <em>Make TrajectoryGraph</em> in the current working directory. The executable file is not installed in any global location, so to run the program, you’ll need to give the full pathname of the executable file or run it from the directory in which it lives by prefixing the executable filename with <code>./</code>, as shown here:</p>&#13;
<pre><span class="codestrong1">$ ./MakeTrajectoryGraph</span></pre>&#13;
<p class="indent">The advantage of using <code>ghc</code> to make your executable program is there are no configuration files to worry about. The disadvantage is that any modules your program needs, whether written by you or someone else, must be accessible from the directory in which your program resides. As the number of library packages your program depends on increases, the burden of this installation increases, especially because versions of packages that are acceptable to your program may conflict with versions that are acceptable to other programs you write or to other library packages you want to use. The <code>cabal</code> and <code>stack</code> tools we’ll describe next were designed to manage this complexity, so you don’t need to deal with it yourself.</p>&#13;
<h3 class="h3" id="ch12lev4">Using Cabal to Make a Stand-Alone Program</h3>&#13;
<p class="noindent">We used <code>cabal</code> to install a package in the previous section. But the <code>cabal</code> tool can play a larger role in your Haskell ecosystem, managing the modules and packages your stand-alone program needs and using versions that work together, even if they conflict with packages used by other projects you might have. To get basic information about what the <code>cabal</code> tool can do, issue the command</p>&#13;
<pre><span class="codestrong1">$ cabal help</span></pre>&#13;
<p class="noindent">at your command prompt.</p>&#13;
<p class="indent">The first step in using <code>cabal</code> to manage the dependencies of your project is to make a fresh subdirectory that will contain the source code of your stand-alone program as well as some files that <code>cabal</code> needs to do its work. We create a new directory called <em>Trajectory</em> under the current directory using the following command. Use a unique name for this directory because the name will be the default name for the executable program as well as the project generally.</p>&#13;
<pre><span class="codestrong1">$ mkdir Trajectory</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_180"/>We enter this new directory, and make it the working directory, by issuing the command</p>&#13;
<pre><span class="codestrong1">$ cd Trajectory</span></pre>&#13;
<p class="noindent">where <code>cd</code> stands for “change directory.” Inside this fresh directory, we issue the following command:</p>&#13;
<pre><span class="codestrong1">$ cabal init</span></pre>&#13;
<p class="indent">This creates a file called <em>Trajectory.cabal</em> and a subdirectory called <em>app</em>, which contains a file called <em>Main.hs</em>. Older versions of <code>cabal</code> create <em>Main.hs</em> in the current directory rather than in the <em>app</em> subdirectory.</p>&#13;
<p class="indent">Imagining that you might want to share your code with others at some point, <code>cabal</code> wants you to have a file called <em>LICENSE</em> that contains the terms for which others may use your code. The <code>cabal</code> tool may demand that you have such a file before it will compile your code, so be prepared to produce one. The <code>cabal</code> program does not care about the contents of the <em>LICENSE</em> file, only that it exists.</p>&#13;
<p class="indent">The file <em>Main.hs</em> is a default source code file that contains a very simple program. To compile it, type</p>&#13;
<pre><span class="codestrong1">$ cabal install</span></pre>&#13;
<p class="noindent">at your command prompt while the current working directory is <em>Trajectory</em>. If everything goes smoothly, <code>cabal</code> will compile the code in <em>Main.hs</em>, produce an executable file called <em>Trajectory</em>, and make that executable file available globally, meaning it can be run by giving its name, <em>Trajectory</em>, rather than its full pathname containing the directory structure leading to the file.</p>&#13;
<p class="indent">We can test the executable with</p>&#13;
<pre><span class="codestrong1">$ Trajectory</span></pre>&#13;
<p class="noindent">and we should get a short welcome message.</p>&#13;
<p class="indent">Moving on to using <code>cabal</code> to produce a stand-alone program for the code in <a href="ch12.xhtml#ch12list1">Listing 12-1</a>, we take a look at the file <em>Trajectory.cabal</em>. This is <code>cabal</code>’s configuration file that tells it how to go about compiling source code into executable code for the project in the current directory. The command <code>cabal</code> <code>init</code> shown earlier selected default values for several options when it created <em>Trajectory.cabal</em>. The lines we are interested in right now look something like the following:</p>&#13;
<pre>executable Trajectory&#13;
    main-is:          Main.hs&#13;
&#13;
    -- Modules included in this executable, other than Main.&#13;
    -- other-modules:&#13;
&#13;
    -- LANGUAGE extensions used by modules in this package.&#13;
    -- other-extensions:<span epub:type="pagebreak" id="page_181"/>&#13;
&#13;
    build-depends:    base ^&gt;=4.14.2.0&#13;
    hs-source-dirs:   app</pre>&#13;
<p class="indent">The first line indicates that the name of the executable program will be <em>Trajectory</em>. This default name matches the name of the project directory; however, we could change it to something else if we wanted to. The second line gives the name of the source code file that has the function <code>main</code> in it. By default, this file is called <em>Main.hs</em> and is located in the <em>app</em> subdirectory of the <em>Trajectory</em> directory. The lines preceded by double hyphens are comments. The line beginning with <code>build-depends:</code> is a list of packages that the main program depends on. By default, the <em>.cabal</em> file includes only a dependence on the package <code>base</code>. The <code>base</code> package makes all of the Prelude functions and types available. The line beginning with <code>hs-source-dirs:</code> is a list of subdirectories that contain source files.</p>&#13;
<p class="indent">To compile the code in <a href="ch12.xhtml#ch12list1">Listing 12-1</a>, which is contained in the file <em>Make TrajectoryGraph.hs</em>, we need to do three things:</p>&#13;
<ol>&#13;
<li class="noindent">Copy or move the file <em>MakeTrajectoryGraph.hs</em> into the <em>app</em> sub-directory of the <em>Trajectory</em> directory. Then edit <em>Trajectory.cabal</em> to change the name of the main source code file from <em>Main.hs</em> to <em>MakeTrajectoryGraph.hs</em>. The modified line in <em>Trajectory.cabal</em> looks like this:&#13;
<pre>   main-is:         MakeTrajectoryGraph.hs</pre></li>&#13;
<li class="noindent">Copy or move the file <em>SimpleVec.hs</em> containing the <code>SimpleVec</code> module into the <em>app</em> subdirectory of the <em>Trajectory</em> directory. (This file, along with all the other modules in this book, is available at <a href="https://lpfp.io">https://lpfp.io</a>.) Then edit <em>Trajectory.cabal</em> to uncomment (remove the double hyphen) the <code>other-modules:</code> line and add the <code>SimpleVec</code> module (without the <em>.hs</em> extension).&#13;
<pre>   other-modules:    SimpleVec</pre></li>&#13;
<li class="noindent">Edit <em>Trajectory.cabal</em> to include <code>gnuplot</code> in the <code>build-depends:</code> line. This allows us to import the module <code>Graphics.Gnuplot.Simple</code> in our main program. With all three changes, the modified lines in <em>Trajectory.cabal</em> look like this:&#13;
<pre>executable Trajectory&#13;
    main-is:          MakeTrajectoryGraph.hs&#13;
&#13;
    -- Modules included in this executable, other than Main.&#13;
    other-modules:    SimpleVec&#13;
&#13;
    -- LANGUAGE extensions used by modules in this package.&#13;
    -- other-extensions:&#13;
    build-depends:    base ^&gt;=4.14.2.0, gnuplot&#13;
    hs-source-dirs:   app</pre></li>&#13;
</ol>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_182"/>While the <code>base</code> package has bounds on the allowed versions of <code>base</code>, we have not given version bounds on the <code>gnuplot</code> package. The purpose of version bounds is to allow code that is still in development to evolve in ways that are not compatible with previous versions. Library package writers follow conventions stating that minor changes and bug fixes are indicated by small changes in the version number, while major changes are indicated by bigger changes in the version number. Using version bounds, like those with <code>base</code> just shown, is a technique designed to ensure you are getting the functionality you expect.</p>&#13;
<p class="indent">Adding <code>gnuplot</code> to the list of build dependencies causes <code>cabal</code> to install the <code>gnuplot</code> package, but in a way that makes it private to this project, the project in the <em>Trajectory</em> directory. The <code>gnuplot</code> package will not be available in GHCi, for example, as a result of adding it to the build dependencies for this project. To make <code>gnuplot</code> available in GHCi, follow the instructions in the appendix.</p>&#13;
<p class="indent">Now reissue</p>&#13;
<pre><span class="codestrong1">$ cabal install</span></pre>&#13;
<p class="noindent">to recompile the program called <em>Trajectory</em>. We can test the executable with</p>&#13;
<pre><span class="codestrong1">$ Trajectory</span></pre>&#13;
<p class="noindent">and the executable should create a file called <em>projectile.png</em>.</p>&#13;
<p class="indent">The packages, such as <code>gnuplot</code>, that <code>cabal</code> installs reside at <a href="https://hackage.haskell.org"><em>https://hackage.haskell.org</em></a>. You can go there to search for, browse, and read documentation about any of the packages <code>cabal</code> can install.</p>&#13;
<h3 class="h3" id="ch12lev5">Using Stack to Make a Stand-Alone Program</h3>&#13;
<p class="noindent">The <code>stack</code> tool can manage the modules and packages your stand-alone program needs, using versions that work together, even if they conflict with packages used by other projects you might have. To get basic information about what the <code>stack</code> tool can do, issue the command</p>&#13;
<pre><span class="codestrong1">$ stack --help</span></pre>&#13;
<p class="noindent">at your command prompt.</p>&#13;
<p class="indent">The first step in using <code>stack</code> to manage the dependencies of a new project called <em>Trajectory</em> is to issue the command</p>&#13;
<pre><span class="codestrong1">$ stack new Trajectory</span></pre>&#13;
<p class="indent">This will make a subdirectory with the name <em>Trajectory</em>. We enter this new directory, and make it the current directory, by issuing the following command:</p>&#13;
<pre><span class="codestrong1">$ cd Trajectory</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_183"/>Inside this directory, we find several files and subdirectories that <code>stack</code> has created for us. The most important file is <em>Trajectory.cabal</em>, which contains important information about how your program gets compiled. The <code>stack</code> tool is built on top of the <code>cabal</code> tool and uses its configuration file. The most important lines from <em>Trajectory.cabal</em> look like this:</p>&#13;
<pre>library&#13;
  exposed-modules:&#13;
     Lib&#13;
  other-modules:&#13;
     Paths_Trajectory&#13;
  hs-source-dirs:&#13;
     src&#13;
  build-depends:&#13;
     base &gt;=4.7 &amp;&amp; &lt;5&#13;
  default-language: Haskell2010&#13;
&#13;
executable Trajectory-exe&#13;
  main-is: Main.hs&#13;
  other-modules:&#13;
     Paths_Trajectory&#13;
  hs-source-dirs:&#13;
     app&#13;
  ghc-options: -threaded -rtsopts -with-rtsopts=-N&#13;
  build-depends:&#13;
     Trajectory&#13;
   , base &gt;=4.7 &amp;&amp; &lt;5&#13;
  default-language: Haskell2010</pre>&#13;
<p class="noindent">Here we see two stanzas: one beginning with <code>library</code> and the other beginning with <code>executable</code>. The <code>library</code> stanza is in charge of the names, locations, and dependencies of modules we have written, such as <code>SimpleVec</code>. The names of modules we have written that we want <code>stack</code> to manage go under the heading <code>exposed-modules:</code>, and they are separated by commas if there is more than one module. The default program that comes with a new stack project uses only one module, named <code>Lib</code>. Here, we do not need to use the <code>other-modules:</code> heading; we can leave it alone. The directories in which our modules are located go under the heading <code>hs-source-dirs:</code>. By default, the subdirectory <em>src</em> under the directory <em>Trajectory</em> is the location for modules, and we do not need to change this. We will simply copy or move our modules into the <em>src</em> directory that <code>stack</code> created for us. Packages that we have not written but upon which our modules depend, such as <code>gnuplot</code>, are listed under the <code>build-depends:</code> heading.</p>&#13;
<p class="indent">The first line of the <code>executable</code> stanza indicates that the name of the executable program will be <em>Trajectory-exe</em>. This default name matches the name we gave the project; however, we could change it to something else if we wanted to. The heading <code>main-is:</code> is followed by the name of the source code <span epub:type="pagebreak" id="page_184"/>file that has the function <code>main</code> in it. The default value is <em>Main.hs</em>. In the <code>executable</code> stanza, as in the <code>library</code> stanza, we do not need to use the <code>other</code> <code>-modules:</code> heading; we can leave it alone. The directories in which the source code for our executable (stand-alone) programs are located go under the heading <code>hs-source-dirs:</code>. By default, the subdirectory <em>app</em> under the directory <em>Trajectory</em> is the location for main program source code, and we do not need to change this. We will simply copy or move our code into the <em>app</em> directory that <code>stack</code> created for us. At present, the <em>app</em> subdirectory contains the <em>Main.hs</em> source code file.</p>&#13;
<p class="indent">The file <em>Main.hs</em> is a default source code file that contains a very simple program. To compile it, type</p>&#13;
<pre><span class="codestrong1">$ stack install</span></pre>&#13;
<p class="noindent">at your command prompt while the current working directory is <em>Trajectory</em> (the directory containing the <em>.cabal</em> file). If everything goes smoothly, <code>stack</code> will compile the code in <em>Main.hs</em>, produce an executable file called <em>Trajectory -exe</em>, and make that executable file available globally, so it can be run, even from other directories, by giving its name, <em>Trajectory-exe</em>.</p>&#13;
<p class="indent">We can test the executable with</p>&#13;
<pre><span class="codestrong1">$ Trajectory-exe</span></pre>&#13;
<p class="noindent">and we should see a short text string appear on the screen.</p>&#13;
<p class="indent">Moving on to using <code>stack</code> to produce a stand-alone program for the code in <a href="ch12.xhtml#ch12list1">Listing 12-1</a>, contained in the file <em>MakeTrajectoryGraph.hs</em>, we need to do three things:</p>&#13;
<ol>&#13;
<li class="noindent">Copy or move the file <em>MakeTrajectoryGraph.hs</em> into the <em>app</em> subdirectory of the <em>Trajectory</em> directory. Then edit <em>Trajectory.cabal</em> to change the name of the main source code file from <em>Main.hs</em> to <em>MakeTrajectory Graph.hs</em>. The modified line in <em>Trajectory.cabal</em> looks like this:&#13;
<pre>  main-is: MakeTrajectoryGraph.hs</pre></li>&#13;
<li class="noindent">Copy or move the file <em>SimpleVec.hs</em> containing the <code>SimpleVec</code> module into the <em>src</em> subdirectory of the <em>Trajectory</em> directory. This file, along with all the other modules in this book, is available at <a href="https://lpfp.io">https://lpfp.io</a>. Then edit <em>Trajectory.cabal</em> to include the <code>SimpleVec</code> module in the <code>exposed-modules:</code> field of the <code>library</code> stanza.&#13;
<pre>library&#13;
  exposed-modules:&#13;
      SimpleVec</pre></li>&#13;
<li class="noindent">Edit <em>Trajectory.cabal</em> to include the <code>gnuplot</code> package under the <code>build</code> <code>-depends:</code> heading of the <code>executable</code> stanza. This allows us to import the module <code>Graphics.Gnuplot.Simple</code> in our main program. With all three changes, the modified lines in <em>Trajectory.cabal</em> look like this:&#13;
<span epub:type="pagebreak" id="page_185"/>&#13;
<pre>library&#13;
  exposed-modules:&#13;
      SimpleVec&#13;
  other-modules:&#13;
      Paths_Trajectory&#13;
  hs-source-dirs:&#13;
      src&#13;
  build-depends:&#13;
      base &gt;=4.7 &amp;&amp; &lt;5&#13;
  default-language: Haskell2010&#13;
&#13;
executable Trajectory-exe&#13;
  main-is: MakeTrajectoryGraph.hs&#13;
  other-modules:&#13;
      Paths_Trajectory&#13;
  hs-source-dirs:&#13;
      app&#13;
  ghc-options: -threaded -rtsopts -with-rtsopts=-N&#13;
  build-depends:&#13;
      Trajectory&#13;
    , base &gt;=4.7 &amp;&amp; &lt;5&#13;
    , gnuplot&#13;
  default-language: Haskell2010</pre></li>&#13;
</ol>&#13;
<p class="indent">Keep in mind package names, not module names, need to be included in the list of build dependencies. When using <code>stack</code>, accidentally substituting the module name <code>Graphics.Gnuplot.Simple</code> for the package name <code>gnuplot</code> gives a parse error with no hint of what the real trouble is.</p>&#13;
<p class="indent">Now reissue</p>&#13;
<pre><span class="codestrong1">$ stack install</span></pre>&#13;
<p class="noindent">to recompile the program called <em>Trajectory-exe</em>. We can test the executable with</p>&#13;
<pre><span class="codestrong1">$ Trajectory-exe</span></pre>&#13;
<p class="noindent">and the executable should create a file called <em>projectile.png</em>.</p>&#13;
<p class="indent">The packages, such as <code>gnuplot</code>, that <code>stack</code> installs reside at <a href="https://hackage.haskell.org"><em>https://hackage.haskell.org</em></a>. You can go there to search for, browse, and read documentation about any of the packages <code>stack</code> can install.</p>&#13;
<h3 class="h3" id="ch12lev6">Summary</h3>&#13;
<p class="noindent">This chapter showed three ways to produce a stand-alone Haskell program. The first uses <code>ghc</code>, and you must install any needed library packages yourself. The second uses <code>cabal</code>, which can help manage library package dependencies. The third uses <code>stack</code>, which can also help manage library package <span epub:type="pagebreak" id="page_186"/>dependencies. In the next chapter, we will put these techniques to use in making animations.</p>&#13;
<h3 class="h3" id="ch12lev7">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 12.1.</strong> The print function is useful inside a stand-alone program. Ask GHCi for the type of print, and GHCi will tell you that print is a function whose input can have any type that is an instance of Show and whose output is IO (), meaning that it <em>does</em> something. What print does is send the value of its input to your screen. You can print numbers, lists, strings, and anything that can be shown. You can use print inside of GHCi, but it is not needed there because GHCi automatically prints the value of whatever you give it.</p>&#13;
<p class="indent">Write a stand-alone program that prints the first 21 powers of 2, starting with 2<sup>0</sup> and ending with 2<sup>20</sup>. When you run your program, the output should look like this:</p>&#13;
<pre>[1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,&#13;
262144,524288,1048576]</pre>&#13;
</div></body></html>