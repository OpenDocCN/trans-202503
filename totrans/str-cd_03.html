<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_43"/><span class="big">2</span><br/>THE ESSENTIALS OF PROGRAMMING LANGUAGES</h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">Attempting to compress the essentials of programming languages into a single chapter is an impossible task, but I’ll do my best to convey what is essential about programming languages as background for the rest of the book. In reality though, this chapter should be either a book or a semester-long undergraduate course.</p>&#13;
<p class="indent">The vignettes of <a href="ch01.xhtml#ch01">Chapter 1</a> were meant to give you an introduction to a few programming language concepts, but they left some big questions unanswered. For example, what exactly <em>is</em> a programming language? How are programming languages structured and implemented? What are programming paradigms? And so on. Potential questions abound. In this chapter, I’ll provide sufficient answers to these questions, and others, to give us what we need to work through the languages we’ll encounter and implement later in the book.</p>&#13;
<p class="indent">We’ll begin this chapter with a working definition of <em>programming language</em>. Then we’ll cover syntax and semantics—how to speak in a programming language and what the speech means. After that, we’ll briefly review the ways programming languages are implemented, or made real. We’ll <span epub:type="pagebreak" id="page_44"/>implement several esolangs in this book, so basic knowledge in this area will be useful.</p>&#13;
<p class="indent">We’ll then explore data types and data structures, what sort of data the language works with, and how it organizes that data. We’ll also explore variables and <em>scope</em>, which is the part of the language telling us what information can be seen and in what context.</p>&#13;
<p class="indent">All programming languages implement some form of <em>flow control</em>, that is, some way to do more than execute instruction after instruction in a linear fashion. We’ll explore that before ending the chapter with a discussion of <em>programming language paradigms</em>, or the different ways programming languages approach coding. We encountered several different programming paradigms in <a href="ch01.xhtml#ch01">Chapter 1</a>. Here, we’ll put names to the paradigms and discuss their characteristics. The paradigm, or paradigms, a language supports directly influence how we think in that language.</p>&#13;
<h3 class="h3" id="lev1sec20"><strong>Defining Programming Language</strong></h3>&#13;
<p class="noindent">A book about programming languages should include a definition of its subject. Therefore, let’s be explicit about what we mean when we write the words <em>programming language</em>.</p>&#13;
<div class="bq">&#13;
<p class="noindent">A programming language is a vehicle that expresses thought and actualizes it as an algorithm to control a computer. A programming language consists of two things: <em>a set of instructions</em> and <em>rules for organizing those instructions</em>.</p>&#13;
</div>&#13;
<p class="indent">All of the languages in <a href="ch01.xhtml#ch01">Chapter 1</a> meet our definition. Clearly, Short Code and everything created after it does: there are instructions and rules for organizing those instructions. Zuse’s Plankalkül and even Ada’s “diagram of development” meet this definition. Ada’s diagram encodes an algorithm in a manner useful for the Analytical Engine. Some might quibble that the Analytical Engine would not have been able to use the diagram directly, but a modern computer can’t use C, ALGOL, or Prolog source code directly, either. A programming language is abstract; it needs an interface between itself and the machine it seeks to control.</p>&#13;
<h3 class="h3" id="lev1sec21"><strong>Syntax and Semantics</strong></h3>&#13;
<p class="noindent"><em>Syntax</em> refers to how language elements can be combined to form valid statements in the grammar of a language. This is true for both human languages and programming languages. Most programming languages intended for real-world use have a formal grammar, that is, a specification of what is and isn’t allowed as a statement in the language. These grammars guide the development of interpreters and compilers for the language.</p>&#13;
<p class="indent">The word <em>semantics</em> refers to the meaning of a syntactically correct statement. Syntax is concrete; a statement either is or isn’t valid for the language. Semantics, on the other hand, is harder to pin down; it depends on what the programmer (speaker) intends, which may differ from the effective meaning. <span epub:type="pagebreak" id="page_45"/>In a human language context, this is a misunderstanding; in a programming language context, this is often a bug.</p>&#13;
<p class="indent">To help understand the difference between syntax and semantics, let’s consider a <code>while</code> statement in Pascal:</p>&#13;
<pre>while <span class="codeitalic1">&lt;boolean-expression&gt;</span> do <span class="codeitalic1">&lt;statements&gt;</span></pre>&#13;
<p class="noindent">This is an expression of the <code>while</code> statement’s syntax. Pascal’s formal grammar must define <span class="codeitalic">&lt;boolean-expression&gt;</span> and <span class="codeitalic">&lt;statements&gt;</span>. A <span class="codeitalic">&lt;boolean-expression&gt;</span> is an expression that returns a value that is true or false and <span class="codeitalic">&lt;statements&gt;</span> is a single statement or a sequence of statements with <code>begin</code> and <code>end</code> around them (a block statement).</p>&#13;
<p class="indent">Therefore, syntactically, this is a correct Pascal statement:</p>&#13;
<pre>while i &lt; 10 do i := i - 1;</pre>&#13;
<p class="noindent">However, semantically, this statement is unlikely to be correct. Its meaning is likely not what the programmer intended. If <code>i</code> is greater than or equal to 10, the <code>while</code> loop never executes because the condition is false. If <code>i</code> is less than 10, the <code>while</code> loop does execute, but would never end because <code>i</code> is less than 10 and is only getting smaller. In practice, the <code>while</code> loop will eventually end when <code>i</code> wraps around from the largest negative to the largest positive supported by the integer data type. In Pascal, the largest negative integer is <em>–</em>32,768 and the largest positive is 32,767. In Pascal, an integer is signed and 16 bits wide. This statement is, at best, a highly inefficient way to do <code>i := 32767</code>, and is likely not at all what the programmer intended.</p>&#13;
<p class="indent">Remember: syntax refers to grammatically correct statements and semantics refers to the meaning of a statement.</p>&#13;
<h3 class="h3" id="lev1sec22"><strong>Implementing Programming Languages</strong></h3>&#13;
<p class="noindent">Konrad Zuse’s Plankalkül was a programming language, but he didn’t implement it. Zuse expressed thought through it, but he couldn’t actualize the thought encoded because there was no interface, that is, no implementation of the language for a physical machine. Programming languages can exist without a computer to run them, but to control a machine, there must be an implementation. In this section, we’ll discuss the ways programming languages are implemented.</p>&#13;
<p class="indent">There are two main methods for implementing a programming language. An <em>interpreter</em> takes the program text, breaks it up into pieces called statements—that is, sets of instructions with meaning—and performs the actions implied by the instructions. On the other hand, a <em>compiler</em> takes the program text, breaks it up into pieces with meaning, and translates those pieces into another language, often the computer’s machine language.</p>&#13;
<p class="indent">The output of a compiler is a set of machine instructions that the computer can execute directly. Compilers are programs that translate one programming language into another. Interpreters are programs that implement the meaning of the instructions implied by the program text.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_46"/>Interpreters are like work crews. They get the work order and make it happen. Compilers are like translators. They map meaning from one programming language to another. Interpreters run programs; compilers produce programs to run later.</p>&#13;
<p class="indent">There is a clear conceptual break between what an interpreter does and what a compiler does. Unfortunately, in practice, this line isn’t as distinct as we might hope. For example, many new languages are both interpreted and compiled at the same time. This includes Python and Java, among others. There is a good reason for this: namely, portability between different hardware platforms. Languages that do this make use of <em>bytecode compilers</em>, which are compilers that translate from the high-level source language (like Python) to a low-level target language that can be interpreted very quickly. The compiler portion does the hard work of extracting the meaning of the program text while the interpreter concentrates on performance. The net result is a language implementation that is portable—just rewrite the interpreter part for a new target machine—and much faster than an old-style interpreter that mindlessly re-derived the meaning of the code, over and over, as it was executed.</p>&#13;
<h4 class="h4" id="lev2sec7"><strong><em>Tokens, Lexers, and Parsers</em></strong></h4>&#13;
<p class="noindent">Neither interpreters nor compilers work with source code text as typed. The text is first processed by a <em>lexer</em> to split the text into <em>tokens</em>, which are strings representing the elements of the programming language. The lexer often attaches extra information to the tokens, such as whether the token is a number or a keyword of the language.</p>&#13;
<p class="indent">The output of the lexer is usually passed to a <em>parser</em>, which groups the tokens into meaningful language statements, often in the form of a tree. The interpreter or compiler then uses that tree to evaluate the statement (interpreter) or transform the statement into the target language (compiler).</p>&#13;
<p class="indent">For example, consider this Pascal statement:</p>&#13;
<pre>y := m * x + b;</pre>&#13;
<p class="indent">The lexer splits the statement into tokens and then adds the associated information.</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Token</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Associated information</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>y</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Variable, type real</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>:=</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Assignment</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">m</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Variable, type real</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>*</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Multiplication</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">×</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Variable, type real</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>+</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Addition</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">b</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Variable, type real</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">End of statement</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_47"/>The parser uses this to construct an <em>abstract syntax tree</em> (see <a href="ch02.xhtml#ch02fig1">Figure 2-1</a>).</p>&#13;
<div class="image"><img id="ch02fig1" src="Images/02fig01.jpg" alt="Image" width="235" height="243"/></div>&#13;
<p class="figcap"><em>Figure 2-1: An abstract syntax tree for <span class="codeitalic1">y := m*x + b</span></em></p>&#13;
<p class="indent">The tree is a representation of the statement in a form the interpreter or compiler can process. An interpreter would evaluate the right side of the tree using the current value of the variables <code>m</code>, <code>x</code>, and <code>b</code> to assign a new value to the variable <code>y</code>. A compiler would use the tree to generate a series of assembly language or machine code instructions that, when executed, implement the assignment.</p>&#13;
<p class="indent">Lexers and parsers for real programming languages can be quite complex. Most people use parser generators like flex/bison or ANTLR to automatically generate code from the language specifications. Fortunately for us, the esolangs we’ll explore are often so simple that lexing is removing whitespace and comments and parsing is examining the next character in the string output by the lexer. For example, this is precisely how the ABC language of <a href="ch07.xhtml#ch07">Chapter 7</a> is processed by its interpreter.</p>&#13;
<h4 class="h4" id="lev2sec8"><strong><em>Interpreters</em></strong></h4>&#13;
<p class="noindent">Interpreters are usually easier to write than compilers. Computer scientists spent decades learning how to write optimizing compilers that produce highly efficient and fast code. The downside of an interpreter is that it’s often slow compared to the machine code generated by a compiler. All of the esolangs we’ll work with in this book are interpreted, though compilers do exist for some of them (for example Brainfuck; see <em><a href="https://github.com/Wilfred/bfc/">https://github.com/Wilfred/bfc/</a></em>).</p>&#13;
<p class="indent">Later in the book, we’ll write interpreters in Python for simple esolangs like ABC, FRACTRAN, Filska, and Firefly. By design, their syntax is simple enough that complex lexing and parsing are not necessary.</p>&#13;
<p class="indent">A complete example of an interpreter, with a specified language grammar and a complete lexer and parser, is beyond what we can present here. However, I do recommend attempting to do that yourself at some point. If you do, think clearly and be prepared for some level of frustration before you succeed. For now, let’s look at what an old BASIC interpreter does to parse a simple program.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_48"/>The Apple II computer came with BASIC in ROM. BASIC was both the command line and the programming language of the machine. Users entered a line of the program, which BASIC immediately parsed and stored in memory. Programs were stored in memory as a linked list, which is why every line needed a line number. It was so BASIC knew where to insert the line in the list.</p>&#13;
<p class="indent">Consider this simple program entered line by line at the prompt (<code>]</code>):</p>&#13;
<pre>] <span class="codestrong1">10 FOR X = 1 TO 10</span>&#13;
] <span class="codestrong1">20 PRINT X, X*X</span>&#13;
] <span class="codestrong1">30 NEXT X</span></pre>&#13;
<p class="noindent">If this program is <code>RUN</code>, it produces a table of squares.</p>&#13;
<pre>]<span class="codestrong1">RUN</span>&#13;
1     1&#13;
2     4&#13;
3     9&#13;
4     16&#13;
5     25&#13;
6     36&#13;
7     49&#13;
8     64&#13;
9     81&#13;
10    100</pre>&#13;
<p class="indent">The tokenized representation of this program occupies 30 bytes of the Apple II’s memory (<a href="ch02.xhtml#ch02list1">Listing 2-1</a>).</p>&#13;
<pre>0801: link: 080D &#13;
      0A 00 -- line number 10, uint16, lo/hi&#13;
      81 token "FOR"&#13;
      58 ASCII character, "X"&#13;
      D0 token "="&#13;
      31 ASCII character, "1"&#13;
      C1 token "TO"&#13;
      31 30 ASCII characters, "10"&#13;
      00 end of line&#13;
080D: link: 0818 &#13;
      14 00 -- line number 20, uint16, lo/hi&#13;
      BA token "PRINT"&#13;
      58 ASCII character, "X"&#13;
      2C ASCII character, ","&#13;
      58 ASCII character, "X"&#13;
      CA token "*"&#13;
      58 ASCII character, "X"&#13;
      00 end of line&#13;
0818: link: 081F &#13;
      1E 00 -- line number 30, uint16, lo/hi<span epub:type="pagebreak" id="page_49"/>&#13;
      82 token "NEXT"&#13;
      58 ASCII character, "X"&#13;
      00 end of line&#13;
081F: 00 00 -- end of program</pre>&#13;
<p class="caption" id="ch02list1"><em>Listing 2-1: A tokenized Applesoft BASIC program</em></p>&#13;
<p class="indent">The program begins at memory location 0x0801, with the link to the next line beginning at 0x080D. The line number is stored as a 16-bit unsigned integer, with the low-order byte first: <code>0A 00</code> = 0 × 256 + 10 = 10. The parsed line of code comes next, where known BASIC commands like <code>FOR</code> have been replaced by a single-byte token (0x81). Interestingly, the numbers, like 1 and 10 for the <code>FOR</code> loop limits, are not stored as numbers but rather as ASCII characters. The <code>PRINT</code> statement is also stored as ASCII characters, including the name of the variable, <code>X</code>.</p>&#13;
<p class="indent">BASIC must do a significant amount of work to interpret a line, and do so repeatedly in this case because a loop is involved. Because of this, BASIC was notoriously slow. However, to be fair, the Apple II’s BASIC interpreter was written in assembly language for a simple 8-bit microprocessor to run on a machine with as little as 16KB of RAM. We’ll use Python to implement our languages, so our task will be significantly easier and proportionately less impressive.</p>&#13;
<h4 class="h4" id="lev2sec9"><strong><em>Compilers</em></strong></h4>&#13;
<p class="noindent">One of the best books about compilers is the classic “Dragon Book” by Aho, Lam, Sethi, and Ullman: <em>Compilers: Principles, Techniques, and Tools</em>, 2nd edition (Addison Wesley, 2006). It’s called the Dragon Book because of the cover illustration. If you are at all curious about compiler design, I recommend this book.</p>&#13;
<p class="indent">Section 1.2 of the Dragon Book enumerates the phases of a compiler:</p>&#13;
<ol>&#13;
<li class="noindent">Lexical analyzer</li>&#13;
<li class="noindent">Syntax analyzer</li>&#13;
<li class="noindent">Semantic analyzer</li>&#13;
<li class="noindent">Intermediate code generator</li>&#13;
<li class="noindent">Code optimizer</li>&#13;
<li class="noindent">Code generator</li>&#13;
</ol>&#13;
<p class="noindent">Interpreters perform at least phases 1 through 3, and possibly some form of phase 4, and then execute the program. Compilers perform all or most of the phases to produce machine code output.</p>&#13;
<p class="indent">Let’s look at the code produced by a simple compiler called <code>pic0</code>. It compiles a simple stack-based language to assembly code for Microchip 10F2xx series microcontrollers. The 10F2xx series are perhaps the cheapest microcontrollers on the market. As of this writing, a single 10F200 can be yours for a mere 0.66 USD.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_50"/>The compiler is in the file <em>pic0.py</em>, and implements phases 1 through 5 above. Phase 6, final code generation, uses the <code>gpasm</code> assembler (see <em><a href="https://gputils.sourceforge.io/">https://gputils.sourceforge.io/</a></em>).</p>&#13;
<p class="indent">The file <em>timer.pic0</em> (<a href="ch02.xhtml#ch02list2">Listing 2-2</a>) contains a PIC0 program to toggle an LED attached to the microcontroller.</p>&#13;
<pre>p10f200&#13;
IntRC_OSC&#13;
WDT_OFF&#13;
CP_OFF&#13;
MCLRE_OFF&#13;
&#13;
equ[ count 0x12 ]&#13;
&#13;
[ main&#13;
  asm{ movwf OSCCAL }     ;  store oscillator calibration value&#13;
  OSCCAL/0                ;  disable INTOSC/4 on GPIO.2&#13;
  0 GPIO!                 ;  clear GPIO&#13;
  0b00001000 R0-&gt;W tris   ;  set GPIO directions&#13;
&#13;
  ;  Clear TMR0 and reset prescaler&#13;
  0 TMR0!  clrwdt 0b11000111 R0-&gt;W option&#13;
&#13;
  ;  Loop forever&#13;
  {&#13;
    ;  Wait for the timer to overflow 100 times&#13;
    100 count! {&#13;
        TMR0@ 0if&#13;
          count--  count@ ?0break&#13;
        then&#13;
    }&#13;
&#13;
    ;  Toggle LED&#13;
    if(GPIO^2) GPIO/2 else GPIO^2 then&#13;
  }&#13;
]</pre>&#13;
<p class="caption" id="ch02list2"><em>Listing 2-2: A PIC0 program to toggle an LED</em></p>&#13;
<p class="indent">The compiler takes this file as input producing <em>timer.asm</em> as output (<a href="ch02.xhtml#ch02list3">Listing 2-3</a>). For the final compilation phase, <code>gpasm</code> takes <em>timer.asm</em> as input to produce several output files: <em>timer.cod</em>, <em>timer.lst</em>, and <em>timer.hex</em>.</p>&#13;
<pre>    processor  10F200&#13;
    include    &lt;P10F200.inc&gt;&#13;
    __CONFIG   _IntRC_OSC &amp; _WDT_OFF &amp; _CP_OFF &amp; _MCLRE_OFF&#13;
&#13;
GP0    equ    d'0'&#13;
GP1    equ    d'1'<span epub:type="pagebreak" id="page_51"/>&#13;
GP2    equ    d'2'&#13;
GP3    equ    d'3'&#13;
R0     equ    d'16'&#13;
R1     equ    d'17'&#13;
count  equ    d'18'&#13;
&#13;
main&#13;
    movwf   OSCCAL &#13;
    bcf     OSCCAL,0&#13;
    movlw   d'0'&#13;
    movwf   GPIO&#13;
    movlw   d'8'&#13;
    movwf   R0&#13;
    movf    R0,w&#13;
    tris    GPIO&#13;
    movlw   d'0'&#13;
    movwf   TMR0&#13;
    clrwdt    &#13;
    movlw   d'199'&#13;
    movwf   R0&#13;
    movf    R0,w&#13;
    option    &#13;
A_0000&#13;
    movlw   d'100'&#13;
    movwf   d'18'&#13;
A_0002&#13;
    movf    TMR0,w&#13;
    movwf   R0&#13;
    movf    R0,f&#13;
    btfss   STATUS,Z&#13;
    goto    A_0004&#13;
    decf    d'18',f&#13;
    movf    d'18',w&#13;
    movwf   R0&#13;
    movf    R0,f&#13;
    btfss   STATUS,Z&#13;
    goto    A_0006&#13;
    goto    A_0003&#13;
A_0006&#13;
A_0004&#13;
    goto    A_0002&#13;
A_0003&#13;
    btfss   GPIO,2&#13;
    goto    A_0007&#13;
    bcf     GPIO,2&#13;
    goto    A_0008<span epub:type="pagebreak" id="page_52"/>&#13;
A_0007&#13;
    bsf     GPIO,2&#13;
A_0008&#13;
    goto    A_0000&#13;
A_0001&#13;
    sleep    &#13;
    END</pre>&#13;
<p class="caption" id="ch02list3"><em>Listing 2-3: PIC0 compiler output</em></p>&#13;
<p class="indent">The file <em>timer.hex</em> contains code actually loaded onto the microcontroller.</p>&#13;
<pre>:020000040000FA&#13;
:1000000025000504000C2600080C30001002060034&#13;
:10001000000C21000400C70C300010020200640C28&#13;
:10002000320001023000300243071D0AF2001202C2&#13;
:100030003000300243071D0A1E0A110A4607220A31&#13;
:0A0040004604230A46050F0A0300D8&#13;
:021FFE00EB0FE7&#13;
:00000001FF</pre>&#13;
<p class="indent"><a href="ch02.xhtml#ch02list2">Listing 2-2</a> may seem somewhat cryptic, but it’s likely more readable than <a href="ch02.xhtml#ch02list3">Listing 2-3</a> even though both programs achieve the same goal. To learn more about PIC0, see <em>PIC0_Manual.pdf</em> in the same directory as <em>timer.pic0</em>.</p>&#13;
<h4 class="h4" id="lev2sec10"><strong><em>Bytecode Compilers</em></strong></h4>&#13;
<p class="noindent">Modern interpreters blur the line between interpreter and compiler by compiling the high-level language to a low-level language that can be interpreted quickly. In essence, these languages produce code for a machine that doesn’t exist: a machine simulated via an interpreter. To muddy the waters still further, some bytecode compilers perform <em>just-in-time compilation</em> (JIT) to produce actual machine code instead of interpreting the bytecode itself. Do we still call those languages interpreted?</p>&#13;
<p class="indent">Bytecode compilers are not new, though they may not have been called that at first. For example, the UCSD Pascal system used in the late 1970s produced <em>p-code</em>, a bytecode that was then interpreted by programs written for a specific system. This made the output portable as only the interpreter needed to be rewritten for a new system. The Pascal system, including the compiler, was written in Pascal and already compiled to p-code.</p>&#13;
<p class="indent">As mentioned above, Python is also bytecode compiled. Python supplies a module, <code>dis</code>, showing us the bytecode for any function. For example, this function generates factorials recursively:</p>&#13;
<pre>def fact(n):&#13;
    if n == 0:&#13;
        return 1&#13;
    else:&#13;
        return n * fact(n-1)</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_53"/>To see the bytecode Python actually runs, we can add</p>&#13;
<pre>import dis; dis.dis(fact)</pre>&#13;
<p class="noindent">This produces</p>&#13;
<pre>2        0 LOAD_FAST             0 (n)&#13;
         2 LOAD_CONST            1 (0)&#13;
         4 COMPARE_OP            2 (==)&#13;
         6 POP_JUMP_IF_FALSE    12&#13;
&#13;
3        8 LOAD_CONST            2 (1)&#13;
        10 RETURN_VALUE&#13;
&#13;
5  &gt;&gt;   12 LOAD_FAST             0 (n)&#13;
        14 LOAD_GLOBAL           0 (fact)&#13;
        16 LOAD_FAST             0 (n)&#13;
        18 LOAD_CONST            2 (1)&#13;
        20 BINARY_SUBTRACT&#13;
        22 CALL_FUNCTION         1&#13;
        24 BINARY_MULTIPLY&#13;
        26 RETURN_VALUE&#13;
        28 LOAD_CONST            0 (None)&#13;
        30 RETURN_VALUE</pre>&#13;
<p class="indent">Again, even without studying the meaning of each part of the disassembly, we can follow the flow of the function by examining the tokens on the far right and the names of the instructions in the middle. For example, <code>POP_JUMP_IF_FALSE</code> must examine the result of applying <code>==</code>, and if not true, jumps to 12, which clearly implements the <code>else</code> portion of the function.</p>&#13;
<p class="indent">Notice the final two lines of the disassembly? They return <code>None</code>, which is the default value Python returns from a function. To us, it is obvious that the function never ends by exiting the <code>if</code>, as both branches use <code>return</code>, but the Python compiler must not detect this, so it adds code to handle leaving the function without executing <code>return</code>.</p>&#13;
<p class="indent">Programming languages, both compiled and interpreted, must operate on data. Let’s now explore how languages manipulate and store data.</p>&#13;
<h3 class="h3" id="lev1sec23"><strong>Data Types</strong></h3>&#13;
<p class="noindent">The phrase <em>data type</em> refers to the organization of data in a programming language. Is the data element a number? A character? A structure made up of other data pooled together? How data is processed and stored depends on the data type.</p>&#13;
<p class="indent">Programming languages fall into different categories based on how they deal with data types. A language may be strongly typed or weakly typed. Similarly, a language might be statically typed or dynamically typed.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_54"/>In a <em>strongly typed language</em>, the type of a variable will not, at a minimum, be automatically changed behind the scenes for a particular use of the variable. Python is a strongly typed language, as is Java. For example, in Python, adding an integer and string will result in a runtime error, even if the string is actually a number. You can see this by running <code>1 + '2'</code>, which should generate a <code>TypeError</code>.</p>&#13;
<p class="indent">A <em>weakly typed language</em> will change data types implicitly in different situations. In <a href="ch05.xhtml#ch05">Chapter 5</a>, we’ll explore SNOBOL. In SNOBOL, for some string operations, a numeric value is implicitly converted into a string. Similarly, a string that represents a number will be implicitly converted into a number if the expression expects a number. In SNOBOL, the expression <code>1 + '2'</code> isn’t an error. It correctly evaluates to <code>3</code> by quietly converting <code>'2'</code> into a number behind the scenes. Therefore, SNOBOL is a weakly typed language.</p>&#13;
<p class="indent">A <em>dynamically typed language</em> does not require the programmer to declare the type of data a variable holds before using it. Python is a dynamically typed language. If the variable contains a number, it can be assigned a string at any time, for example. Therefore, Python is both strongly and dynamically typed. Smalltalk variables are not given a type before use, so Smalltalk is also a dynamically typed language.</p>&#13;
<p class="indent">A <em>statically typed language</em> forces the programmer to declare what kind of data a variable will hold. C, C++, Java, Pascal, ALGOL, and FORTRAN are all statically typed languages. FORTRAN still supports implicit variable typing, which superficially looks like dynamic typing, but it isn’t. Unless otherwise instructed via <code>implicit none</code>, FORTRAN automatically treats variables beginning with the letters <em>I</em> through <em>N</em> as integers and all other variables as reals (floating-point). The type is still specified indirectly. Therefore, FORTRAN is statically typed as well.</p>&#13;
<p class="indent">As with many things in programming languages, absolute statements are fraught with peril. Nonetheless, for pedagogical purposes only, let’s categorize languages by whether they are dynamic or static and strongly or weakly typed. The result is <a href="ch02.xhtml#ch02tab1">Table 2-1</a>.</p>&#13;
<p class="tabcap" id="ch02tab1"><strong>Table 2-1:</strong> Languages by Strong/Weak and Dynamic/Static Typing</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"> </p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Dynamic</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Static</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><strong>Weak</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">JavaScript, Perl, SNOBOL</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">C, C++, Pascal</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><strong>Strong</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Python, Ruby, Smalltalk, APL</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Scala, Java, Ada, ALGOL, FORTRAN, COBOL, Simula</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Some languages don’t have a place in <a href="ch02.xhtml#ch02tab1">Table 2-1</a>. For example, in <a href="ch04.xhtml#ch04">Chapter 4</a> we’ll explore Forth, which is a stack-based language.</p>&#13;
<p class="indent">Forth has no concept of data type beyond the number of bits used by the values on its stack; however, some Forth systems have a separate floating-point data stack. The stack value might be a number, or it might be the address of a structure, which in Forth is only an agreed upon partitioning of some amount of memory. Forth is an <em>untyped</em> language and enforces nothing related to types.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_55"/>Data types and their study are an important part of theoretical computer science. Please see the reference material at the back of the book for information on where you can go to dive as deeply into the world of data types as you wish. Here, we’ll only concern ourselves with primitive data types and <em>records</em>, which are user-defined collections of other data types.</p>&#13;
<h4 class="h4" id="lev2sec11"><strong><em>Primitive Data Types</em></strong></h4>&#13;
<p class="noindent"><em>Primitive data types</em> are the atoms of a programming language. They are what you expect languages to work with: numbers, both integers and floating-point values, along with characters (C) and strings (Python). C doesn’t have strings as a primitive data type. Instead, it uses arrays of characters to represent strings. In Python, strings are primitive, along with Booleans (True or False). Additionally, Python supports complex numbers, which are usually represented internally as pairs of floating-point values, one for the real part and another for the imaginary part. Some languages, like Scheme, support fractions as a primitive data type. We’ll use this to good effect in <a href="ch08.xhtml#ch08">Chapter 8</a> when we implement FRACTRAN in Scheme.</p>&#13;
<p class="indent">Computers use multiple methods for representing numbers in memory. Depending on the language, a programmer might need to know explicit details of how a number is stored. This is often true for C when used in an embedded setting, such as on a microcontroller or single-board computer. In <a href="ch02.xhtml#ch02list1">Listing 2-1</a>, we saw how the Apple II stored the 16-bit integer used to represent the line number with its lowest-order byte first followed by the higher-order byte.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Storing integers with the lowest-order byte first is known as little-endian. As you might guess, the reverse is known as big-endian (or sometimes network order). For a detailed presentation of how computers store and operate on numbers, please see my book</em> Numbers and Computers <em>(Springer, 2017). To understand the origin of “little-endian” and “big-endian,” read</em> Gulliver’s Travels <em>by Jonathan Swift.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="lev2sec12"><strong><em>Records</em></strong></h4>&#13;
<p class="noindent">If you use a programming language for any length of time, you’ll eventually want to group different data types into a meaningful unit. A <em>record</em>, also known as a <em>structure</em>, is just that. Languages supporting records include the ALGOL family, both the Pascal and C branches (<a href="ch01.xhtml#ch01fig3">Figure 1-3</a>), along with many others, like SML. Exactly how a language supports this concept varies, and in some cases, the words <em>record</em> and <em>structure</em> are not synonymous. This is the case with C#, where a record is immutable but a structure is not. Let’s look at how Pascal and C implement records.</p>&#13;
<h5 class="h5" id="lev3sec3"><strong>Pascal Records</strong></h5>&#13;
<p class="noindent">A program to store information on people for later reference would benefit from a record grouping a person’s name, birthday, address, and phone number into a single unit. We might then define an array of these records <span epub:type="pagebreak" id="page_56"/>to hold the same set of information for many different people. In Pascal, such declarations might look like this:</p>&#13;
<pre>type&#13;
    PhoneNumberType = record&#13;
        area, exchange, number : Integer;&#13;
    end;&#13;
&#13;
    BirthdayType = record&#13;
        month, day, year : Integer;&#13;
    end;&#13;
&#13;
    PersonType = record&#13;
        first, last : string;&#13;
        address : string;&#13;
        phone : PhoneNumberType;&#13;
        bday : BirthdayType;&#13;
     end;</pre>&#13;
<p class="indent">The type <code>PersonType</code> combines several strings along with instances of <code>PhoneNumberType</code> and <code>BirthdayType</code>. A variable of type <code>PersonType</code> is a single variable with multiple fields.</p>&#13;
<pre>var  person : PersonType;</pre>&#13;
<p class="noindent">Fields are accessed by name using dot notation.</p>&#13;
<pre>person.first := 'Melvin';&#13;
person.bday.year := 1953;</pre>&#13;
<p class="noindent">The nested <code>BirthdayType</code> is referenced first by accessing <code>bday</code>, and then by field of <code>bday</code>.</p>&#13;
<p class="indent">A simple example using <code>PersonType</code> is in the file <em>lbb.pas</em>. To compile it, use the Free Pascal compiler (<em><a href="https://www.freepascal.org/">https://www.freepascal.org/</a></em>), which is easy to install on Ubuntu.</p>&#13;
<pre>&gt; <span class="codestrong1">sudo apt-get install fp-compiler-3.0.4</span></pre>&#13;
<p class="noindent">See the website for macOS and Windows versions. Once installed, compile <em>lbb.pas</em> with <code>fpc lbb.pas</code>. The program generates a random database of 100 different people. We’ll skip listing <em>lbb.pas</em> to save space, but do read through the file to understand what is going on.</p>&#13;
<h5 class="h5" id="lev3sec4"><strong>C Structures</strong></h5>&#13;
<p class="noindent">C structures are similar to Pascal records. The person structures look like:</p>&#13;
<pre>typedef char string[32];&#13;
&#13;
typedef struct {&#13;
    int area, exchange, number;<span epub:type="pagebreak" id="page_57"/>&#13;
} phone_number_t;&#13;
&#13;
typedef struct {&#13;
    int month, day, year;&#13;
} birthday_t;&#13;
&#13;
typedef struct {&#13;
    string first, last;&#13;
    string address;&#13;
    phone_number_t phone;&#13;
    birthday_t bday;&#13;
} person_t;</pre>&#13;
<p class="noindent">As C has no primitive string type, we first define one using a fixed array of 32 characters called <code>string</code>. The declarations use <code>typedef</code> to create a named type for each structure (<code>struct</code>). The names follow the C convention of using underscores and <code>_t</code> at the end to denote a type.</p>&#13;
<p class="indent">Some languages allow a structure to use the same region of memory to represent multiple fields with different types. I suspect the original motivation for this was to save memory for cases where fields were mutually exclusive. A C <code>union</code> works this way. For example, the following code defines a union where the same memory location is sometimes interpreted as a 32-bit float or a 32-bit unsigned integer.</p>&#13;
<pre>typedef union {&#13;
    float f;&#13;
    unsigned int d;&#13;
} fp_t;</pre>&#13;
<p class="noindent">Which interpretation is used depends on which field is accessed, <code>f</code> or <code>d</code>. The code below declares a variable <code>fp</code> to be of type <code>fp_t</code>, and then assigns the floating-point field the value of <em>π</em> before referencing the same memory as an unsigned 32-bit integer.</p>&#13;
<pre>fp_t fp;&#13;
fp.f = 3.14159265;&#13;
printf("%0.8f in hex is %08d\n", fp.f, fp.d);</pre>&#13;
<h3 class="h3" id="lev1sec24"><strong>Data Structures</strong></h3>&#13;
<p class="noindent">A <em>data structure</em> is a way to organize data in memory. A record is a data structure, but the term is usually used to describe more complex ways of managing data. Data structures are necessary but somewhat masked by modern programming languages, as their intrinsic data structures, like Python’s lists and dictionaries, are so powerful that more elaborate data structures are not necessary as often as they used to be. Still, for C and C++ programmers, understanding data structures is critical. Data structures are a book in their <span epub:type="pagebreak" id="page_58"/>own right, like many topics in this chapter. Sadly, we must give data structures short shrift by providing only quick summaries.</p>&#13;
<h4 class="h4" id="lev2sec13"><strong><em>Arrays</em></strong></h4>&#13;
<p class="noindent">At its simplest, an <em>array</em> is nothing more than a block of contiguous memory partitioned into chunks of equal size. An array of 100 32-bit integers occupies a block of 100 × 4 = 400 bytes because each integer is 4 bytes long. For example, in C, <code>int A[100]</code> declares <code>A</code> to be such an array. The C <code>sizeof</code> operator reports that <code>A</code> uses 400 bytes of memory, as expected.</p>&#13;
<p class="indent">The variable <code>A</code> refers to the first 4-byte block of memory allocated for the array. As C knows the size of each element of the array, finding the address of any index of the array is as simple as multiplying the index by four and adding that number to the base address of the array. This is why many programming languages index arrays from 0. That way the offset to the first array element is 0 bytes from the base address.</p>&#13;
<p class="indent">Multidimensional arrays are still stored as a single block of memory. For example, Pascal defines a 2D array like this:</p>&#13;
<pre>var A : array[0..7, 0..7] of integer;</pre>&#13;
<p class="noindent">The array <code>A</code> is an 8×8 array, or matrix, of integers (think of a chessboard). In memory, it’s still a contiguous block of memory, this time using 8 × 8 × 2 = 128 bytes. To index the array, we use two indices, <code>A[i,j]</code>, and calculate the address of the desired element as <code>8 * i + j</code> added to the base memory address. The eight is the number of elements in one row of the array, that is, the number of columns. Indexing basic arrays, even multidimensional arrays, is trivial and fast as long as the array is stored as a contiguous block of memory.</p>&#13;
<h4 class="h4" id="lev2sec14"><strong><em>Linked Lists</em></strong></h4>&#13;
<p class="noindent"><em>Linked lists</em> are the next simplest data structure. They are a collection of nodes, usually allocated on the heap, holding the data of interest along with a pointer to the following link in the chain. A <em>doubly linked</em> list also keeps a pointer to the previous node.</p>&#13;
<p class="indent">Inserting and removing elements of a linked list is easy once the proper node has been located. Locating a node in the first place is relatively slow by comparison because, in the simplest version of a linked list, the list must be traversed node by node from the beginning to find the target. Because of their conceptual simplicity, linked lists are a favorite homework assignment for introductory programming courses.</p>&#13;
<p class="indent">It might be tempting to wonder if Python lists are sophisticated instances of a linked list. However, this is not the case. Python lists are dynamic arrays of pointers to the objects they contain. Python lists can deliver good performance when indexing by cleverly managing how the arrays grow when new elements are added. They use the simple equations above to locate elements, bypassing the slow, node-by-node traversal of a linked list. That said, <span epub:type="pagebreak" id="page_59"/>dynamic arrays of object pointers are still too slow for many scientific applications, which was the motivation behind powerful array-processing libraries for Python, like NumPy.</p>&#13;
<h4 class="h4" id="lev2sec15"><strong><em>Trees</em></strong></h4>&#13;
<p class="noindent"><em>Trees</em> are elaborate hierarchical data structures, usually built dynamically in heap memory. There are many different kinds of trees, and they offer excellent performance in terms of inserting or removing information and locating information quickly. We saw an example of a tree earlier in the chapter in <a href="ch02.xhtml#ch02fig1">Figure 2-1</a>, where the parser for a programming language builds trees representing the structure of program statements.</p>&#13;
<p class="indent">Recursive algorithms exist for quickly traversing trees. Trees are ubiquitous in computer science, but again, they are now less often used in day-to-day scenarios because modern languages support robust data structures implicitly or via libraries. Thus, programmers are freed from implementing their own trees except in the most demanding of cases.</p>&#13;
<h4 class="h4" id="lev2sec16"><strong><em>Hash Tables</em></strong></h4>&#13;
<p class="noindent">In a <em>hash table</em>, a <em>hash</em>, the output of a <em>hash function</em>, is used to map a block of data to a single value. The idea behind a hash function is to map the data to a unique value, an integer in a specified range. For example, under the hood, Python dictionaries are hash tables. The key is given to the hash function to calculate a unique integer representing the key. Then, the table is indexed by the hash value to return the data associated with the key.</p>&#13;
<p class="indent">If two different keys generate the same hash value, a <em>collision</em> has occurred. There are different options for handling collisions. Python dictionaries randomly probe the table to locate an open position for the key in case of a collision. A good hash function, plus a thorough knowledge of the probabilities behind hash collisions for a specified table size, lets Python manage hashes efficiently to minimize collisions while not wasting memory.</p>&#13;
<p class="indent">Of course, there are many more types of data structures. The references at the end of the book will point you toward resources where you can explore data structures in more depth. For now, let’s learn about how programming languages decide which variable to access when referenced in a program.</p>&#13;
<h3 class="h3" id="lev1sec25"><strong>Variables and Scope</strong></h3>&#13;
<p class="noindent">Variables exist in some context, in a relationship to other variables and regions of the code. The region of code where a variable is visible is known as the variable’s <em>scope</em>. Programming languages fall into two main camps when it comes to scope: lexical scoping and dynamic scoping. The majority of programming languages use lexical scoping. A smaller subset uses dynamic scoping, and a few, like Perl, use both. Each language has its own, sometimes rather complex, scoping rules. In this section, we’ll restrict ourselves to the <span epub:type="pagebreak" id="page_60"/>difference between lexical and dynamic scoping and leave the minutiae of a particular language’s scoping rules out of the discussion.</p>&#13;
<h4 class="h4" id="lev2sec17"><strong><em>Lexical Scope</em></strong></h4>&#13;
<p class="noindent">In <em>lexical scoping</em> (also called <em>static scoping</em>), a variable reference is tied back to a declaration or assignment based on the structure of the program when the program was written, that is, the structure seen by a compiler. In this case, the relationships between variable references and which variable is used are static and fixed by the source code’s structure.</p>&#13;
<p class="indent">For lexical scoping, the variable corresponding to a reference follows a simple resolution algorithm: local block or function, next outer block or function, next outer, and so forth to the global level. Python is statically scoped. Consider the following example.</p>&#13;
<pre>def a():&#13;
    def b():&#13;
        def c():&#13;
            def d():&#13;
                x = 20&#13;
              <span class="ent">➊</span> print('d()  says', x)&#13;
          <span class="ent">➋</span> print('c()  says', x)&#13;
            d()&#13;
      <span class="ent">➌</span> print('b()  says', x)&#13;
        c()&#13;
    x = 15&#13;
    print('a()  says', x)&#13;
    b()&#13;
&#13;
x = 10&#13;
print('main says', x)&#13;
a()</pre>&#13;
<p class="noindent">The output of this program is</p>&#13;
<pre>main says 10&#13;
a()  says 15&#13;
b()  says 15&#13;
c()  says 15&#13;
d()  says 20</pre>&#13;
<p class="indent">Python allows nested function declarations, so the function <code>a</code> contains <code>b</code>, which contains <code>c</code>, which in turn contains <code>d</code>. The outermost level, global scope, defines <code>x=10</code>, as the first <code>print</code> informs us. We then call <code>a</code>, which sets <code>x=15</code> locally, as <code>a</code>’s <code>print</code> tells us. Then we call <code>b</code>, which does not define <code>x</code> locally. Therefore, to understand the reference to <code>x</code> <span class="ent">➌</span>, Python must search for <code>x</code> in an enclosing scope. Python finds <code>x</code> in <code>a</code>, so <code>b</code> uses <code>a</code>’s value, 15. When <code>c</code> is called by <code>b</code>, <code>c</code> must search for an <code>x</code> as well <span class="ent">➋</span>. Python doesn’t find <code>x</code> in <code>b</code>, so it <span epub:type="pagebreak" id="page_61"/>searches the next higher enclosing scope, that of <code>a</code>, where it does find <code>x=15</code>. Lastly, <code>c</code> calls <code>d</code> which defines <code>x=20</code> locally, as <code>d</code> reports <span class="ent">➊</span>.</p>&#13;
<p class="indent">Lexical scoping makes sense without excessive tracing of the program to understand which value is used for which reference. That’s why most languages, especially newer or more widely used commercial languages, use it.</p>&#13;
<h4 class="h4" id="lev2sec18"><strong><em>Dynamic Scope</em></strong></h4>&#13;
<p class="noindent"><em>Dynamic scoping</em> uses the current state of the program to decide which value goes with which reference. This means it isn’t always easy to see which value of a variable will be used by a function, as it depends on the context in which the function is used.</p>&#13;
<p class="indent">Let’s do a little experiment. We’ll write what is, more or less, the same program in four different languages: lexically scoped Python and C, dynamically scoped SNOBOL, and Perl, which, as we’ll see, is both lexically and dynamically scoped. We’ll then see if we can explain the output in each case. The presentation below lists the source code on the left and the program’s output on the right.</p>&#13;
<h4 class="h4" id="lev2sec19"><strong><em>Python</em></strong></h4>&#13;
<p class="noindent">We know that Python is lexically scoped, as we demonstrated it above. Therefore, let’s use Python as our base case, the one that shouldn’t surprise us in any way.</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:60%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h1"><p class="taba"><strong>Code</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h2"><p class="taba"><strong>Output</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-right_b"><p class="pre2">x = 10<br/>&#13;
def f():<br/>&#13;
    return x<br/>&#13;
def g():<br/>&#13;
    x = 20<br/>&#13;
    return f()<br/>&#13;
print(g())</p></td>&#13;
<td style="vertical-align: top;" class="table-right_b1"><p class="pre2">10</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The code first defines <code>x</code> globally, then <code>f</code>, which does nothing more than return <code>x</code>. Next, the code defines the function <code>g</code>, which defines <code>x=20</code> locally, within the scope of <code>g</code>, and then returns whatever <code>f</code> returns. The main part of the code prints whatever <code>g</code> returns.</p>&#13;
<p class="indent">Look at the definition of <code>g</code>. There is a local <code>x</code> defined before the call to <code>f</code>. So why wasn’t the output 20? After all, that’s what <code>x</code> is set to immediately before the call to <code>f</code>. The output isn’t 20 because when <code>f</code> is defined (compiled), <code>x</code> exists globally as 10. Therefore, that’s the value used for <code>f</code>, regardless of any local <code>x</code> defined by <code>g</code>.</p>&#13;
<p class="indent">Review this example, if necessary, to make sure you follow it. When you are ready, read on.</p>&#13;
<h4 class="h4" id="lev2sec20"><span epub:type="pagebreak" id="page_62"/><strong><em>C</em></strong></h4>&#13;
<p class="noindent">C, like Python, is also lexically scoped. Therefore, this example should be much like the example above. Let’s take a look.</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:60%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h1"><p class="taba"><strong>Code</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h2"><p class="taba"><strong>Output</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-right_b"><p class="pre2">&#13;
int x = 10;<br/>&#13;
int f() {  return x;  }<br/>&#13;
int g() {<br/>&#13;
    x = 20;<br/>&#13;
    return f();<br/>&#13;
}<br/>&#13;
int h() {<br/>&#13;
    int x = 15;<br/>&#13;
    return f();<br/>&#13;
}<br/>&#13;
void main() {<br/>&#13;
    printf("h() = %d\n", h());<br/>&#13;
    printf("g() = %d\n", g());<br/>&#13;
}</p></td>&#13;
<td style="vertical-align: top;" class="table-right_b1"><p class="pre2">h() = 10<br/>&#13;
g() = 20</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">For this example, begin at the bottom, with the function <code>main</code>. In C, <code>main</code> must exist and is the entry point for all programs. The function <code>main</code> prints two values: whatever <code>h</code> returns followed by whatever <code>g</code> returns.</p>&#13;
<p class="indent">The function <code>h</code> defines a local <code>x=15</code> and then calls <code>f</code> to return whatever <code>f</code> returns. The function <code>f</code> can only see the global <code>x=10</code>, so that’s what it returns. The first output line makes sense.</p>&#13;
<p class="indent">What about the output of <code>g</code>? Does that make sense? The function <code>g</code> is much like <code>h</code>, but the assignment to <code>x=20</code> doesn’t have an <code>int</code> type in front of it. When compiling this function, C realizes there is no locally defined <code>x</code> in <code>g</code>, so it goes up one level in scope to find <code>x</code> (in this case at global scope) and updates that <code>x</code>. So <code>g</code> has a side effect: it alters the value of <code>x</code> globally. This is why <code>f</code> now returns 20 instead of 10.</p>&#13;
<h4 class="h4" id="lev2sec21"><strong><em>SNOBOL</em></strong></h4>&#13;
<p class="noindent">SNOBOL, the subject of <a href="ch05.xhtml#ch05">Chapter 5</a>, is a text-processing language from the 1970s. SNOBOL is dynamically scoped. Its syntax is strange, which is fitting for such a quirky language. For now, we need know only a few things about SNOBOL:</p>&#13;
<ul>&#13;
<li class="noindent">Functions are declared with <code>define</code> and return whatever value is assigned to their name.</li>&#13;
<li class="noindent">Variables are declared as local to a function by adding them after the name and arguments in the <code>define</code> statement.</li>&#13;
<li class="noindent">Printing in SNOBOL is assigning to <code>output</code>.</li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_63"/>The code we’ll consider is</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:60%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h1"><p class="taba"><strong>Code</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h2"><p class="taba"><strong>Output</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-right_b"><p class="pre2">      x = 10<br/>&#13;
      define('f()')     :(ef)<br/>&#13;
f     f = x             :(return)<br/>&#13;
ef<br/>&#13;
      define('g()x')    :(eg)<br/>&#13;
g     x = 20<br/>&#13;
      g = f()           :(return)<br/>&#13;
eg<br/>&#13;
      output = 'global x = ' f()<br/>&#13;
      output = 'local  x = ' g()<br/>&#13;
      output = 'global x = ' x<br/>&#13;
end</p></td>&#13;
<td style="vertical-align: top;" class="table-right_b1"><p class="pre2">global x = 10<br/>&#13;
local  x = 20<br/>&#13;
global x = 10</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">This program defines two functions: <code>f</code> and <code>g</code>. The first returns whatever <code>x</code> is, and the second, which defines <code>x</code> as local to <code>g</code>, returns <code>f</code>’s return value. The main program begins with <code>x = 10</code>.</p>&#13;
<p class="indent">The first line of the output is much like we saw earlier: <code>x</code> is global and <code>f</code> returns its value. The second line isn’t what we saw earlier. Instead of <code>f</code> using the value of <code>x</code> that existed when <code>f</code> was defined, it uses the value of <code>x</code> set by <code>g</code>, even though <code>g</code>’s <code>x</code> is local to <code>g</code>. The function <code>f</code> uses the context in which it is called, at runtime, to locate the value corresponding to <code>x</code>. This is dynamic scoping.</p>&#13;
<p class="indent">The final line is there to show that <code>x</code> has not been updated by <code>g</code>, so this isn’t the situation we encountered with C where, in that case, <code>g</code> did update the global value of <code>x</code>.</p>&#13;
<h4 class="h4" id="lev2sec22"><strong><em>Perl</em></strong></h4>&#13;
<p class="noindent">Our final scoping example uses Perl. Perl is known for flexibility, so Perl supports both static and dynamic scoping, whichever suits the programmer’s fancy. Let’s see how.</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h1"><p class="taba"><strong>Code</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h2"><p class="taba"><strong>Output</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-right_b"><p class="pre2">$x = 10;<br/>&#13;
sub f { return $x; }<br/>&#13;
sub g {<br/>&#13;
    local $x = 20;<br/>&#13;
    return f()<br/>&#13;
}<br/>&#13;
sub h {<br/>&#13;
    my $x = 15;<br/>&#13;
    return f()<br/>&#13;
}<br/>&#13;
print g()."\n";<br/>&#13;
print h()."\n";</p></td>&#13;
<td style="vertical-align: top;" class="table-right_b1"><p class="pre2"> 20<br/>&#13;
 10</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_64"/>The form of this program is familiar. We see <code>f</code>, <code>g</code>, and <code>h</code>, just like the C example above. The program prints the output of <code>g</code> followed by <code>h</code>’s output. The only difference between <code>g</code> and <code>h</code>, besides the value assigned to <code>x</code>, is that <code>g</code> uses <code>local</code> and <code>h</code> uses <code>my</code>.</p>&#13;
<p class="indent">Both <code>local</code> and <code>my</code> define a variable local to a function. The difference lies in which type of scoping is applied to the variable. When <code>my</code> is used, scoping is static, so <code>h</code> returns what <code>f</code> sees via static scoping, namely, <code>x=10</code>. However, for <code>g</code>, Perl has been told, via <code>local</code>, to use dynamic scoping with <code>x</code>, so the call to <code>f</code> from <code>g</code> uses <code>g</code>’s context to figure out which <code>x</code> to use, that is, the <code>x</code> local to <code>g</code>, thereby returning <code>x=20</code>. The lesson is clear: read Perl source code carefully.</p>&#13;
<p class="indent">Variable scoping is intimately linked with program flow. Investigating how programming languages implement and manipulate program flow is next on our list.</p>&#13;
<h3 class="h3" id="lev1sec26"><strong>Controlling Program Flow</strong></h3>&#13;
<p class="noindent">All programming languages implement some form of <em>flow control</em>, which is some means for modifying the sequence of instructions executed in response to different conditions. The discussion in this section focuses on <em>control structures</em> commonly encountered in programming languages. We’ll divide languages into two main groups: unstructured and structured. Let’s learn something about the characteristics of each.</p>&#13;
<h4 class="h4" id="lev2sec23"><strong><em>Unstructured Languages</em></strong></h4>&#13;
<p class="noindent"><em>Unstructured languages</em> use goto, in some form, as the only way to modify program flow. Along with goto, these languages have some mechanism for testing different conditions. The combination of goto and conditional testing is sufficient to implement any algorithm, but that doesn’t mean doing so will be clear or easy to debug or verify.</p>&#13;
<p class="indent">Old-style BASIC, like the example in <a href="ch01.xhtml#ch01list3">Listing 1-3</a>, is unstructured. There are <code>if</code> statements and a <code>goto</code> statement (of potentially different kinds). Likewise, assembly language is unstructured. Review <a href="ch02.xhtml#ch02list3">Listing 2-3</a>, which includes instructions to test different conditions (<code>btfss</code>) and gotos.</p>&#13;
<p class="indent">SNOBOL is also unstructured. Every line in SNOBOL either succeeds or fails, and a label can be given to instruct SNOBOL where to go in either case. SNOBOL does not have a structured <code>if</code> statement, but instead has predicates that either succeed or fail, allowing a goto to handle either case.</p>&#13;
<p class="indent">Most of the esolangs we’ll explore in later chapters are unstructured languages. Most use simple tests and branching or goto, like machine code. Some, like the Firefly language we’ll develop in <a href="ch15.xhtml#ch15">Chapter 15</a>, or <a href="ch08.xhtml#ch08">Chapter 8</a>’s FRACTRAN, lack any form of goto beyond restarting the program from the beginning.</p>&#13;
<h4 class="h4" id="lev2sec24"><span epub:type="pagebreak" id="page_65"/><strong><em>Structured Languages</em></strong></h4>&#13;
<p class="noindent">Edsger Dijkstra’s famous 1968 letter “Go To Statement Considered Harmful” sounded the alarm on how goto as a flow control option is generally a bad idea. In the decades since, unstructured languages have faded and have largely been replaced by languages that implement <em>structured programming</em>, meaning languages that use the now-familiar control structures and eschew goto and the like.</p>&#13;
<h5 class="h5" id="lev3sec5"><strong>Selection</strong></h5>&#13;
<p class="noindent"><em>Selection</em> refers to using the result of a Boolean expression, or the equivalent, to alter program flow. The most common selection structure is the <code>if-then-else</code> construct. For example, in Pascal, and most modern languages, the syntax is virtually the same.</p>&#13;
<pre>if <span class="codeitalic1">&lt;condition&gt;</span> then <span class="codeitalic1">&lt;statements1&gt;</span> [else <span class="codeitalic1">&lt;statements2&gt;</span>]</pre>&#13;
<p class="noindent">Here, <code>&lt;condition&gt;</code> returns a Boolean value. If <code>&lt;condition&gt;</code> is true, <code>&lt;statements1&gt;</code> are executed; otherwise, <code>&lt;statements2&gt;</code>, if present, are executed. Variations on <code>if</code> statements exist, like <code>elif</code> in Python to combine a nested <code>if</code>:</p>&#13;
<pre>if x &lt; 2:                      if x &lt; 2:&#13;
    print("less")                  print("less") &#13;
else:                    =&gt;    elif x &lt; 12:&#13;
    if x &lt; 12:                     print("more")&#13;
        print("more")</pre>&#13;
<p class="indent">Many languages support <code>case</code> or <code>switch</code> statements. Pascal uses <code>case</code> and C uses <code>switch</code>. For example, in C, a <code>switch</code> statement to check on the value of an integer, <code>x</code>, might look like this:</p>&#13;
<pre>switch (x) {&#13;
    case 1:&#13;
        printf("one\n");&#13;
        break;&#13;
    case 3:  case 5:  case 7:&#13;
        printf("prime\n");&#13;
        break;&#13;
    case 2:  case 4:  case 6:&#13;
    case 8:  case 0:&#13;
        printf("even\n");&#13;
        break;&#13;
    default: break;&#13;
};</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_66"/>The <code>break</code> is necessary, as execution falls through to the next <code>case</code> if not present. The same construct in Pascal might look like the following:</p>&#13;
<pre>case x of&#13;
  1 : writeln('one');&#13;
  3,5,7 : writeln('prime');&#13;
  2,4,6,8,0 : writeln('even');&#13;
end;</pre>&#13;
<p class="noindent">Scheme uses a <code>cond</code> statement in much the same way.</p>&#13;
<pre>(cond&#13;
  ((= x 1) (display "one"))&#13;
  ((member x '(3 5 7)) (display "prime"))&#13;
  ((member x '(2 4 6 8 0)) (display "even")))</pre>&#13;
<p class="noindent">Here, each sublist of <code>cond</code> is <code>(&lt;condition&gt; &lt;statements&gt;)</code> and the statements are executed if the condition is true. The <code>cond</code> statement tests each condition in order until one of them is true.</p>&#13;
<h5 class="h5" id="lev3sec6"><strong>Repetition</strong></h5>&#13;
<p class="noindent">By <em>repetition</em>, I mean any form of looping structure. Specifically, we’ll discuss four kinds of loops: top-tested, bottom-tested, counted, and infinite. We’ll use Modula-2 for <a href="ch02.xhtml#ch02list4">Listing 2-4</a>, as it supports all four kinds. Modula-2 is a successor of Pascal.</p>&#13;
<pre>   MODULE loops;&#13;
   &#13;
   FROM StrIO IMPORT WriteString, WriteLn;&#13;
   FROM NumberIO IMPORT WriteCard;&#13;
   &#13;
   VAR&#13;
    <span class="ent">➊</span> i : CARDINAL;&#13;
   &#13;
   BEGIN&#13;
     WriteString("Top tested:");  WriteLn;&#13;
     WriteString("  index:");&#13;
  <span class="ent">➋</span> i := 0;&#13;
     WHILE (i &lt; 6) DO&#13;
       WriteCard(i,3);<span epub:type="pagebreak" id="page_67"/>&#13;
       i := i + 1;&#13;
     END;&#13;
     WriteLn;&#13;
   &#13;
     WriteString("Bottom tested:");  WriteLn;&#13;
     WriteString("  index:");&#13;
  <span class="ent">➌</span> i := 0;&#13;
     REPEAT&#13;
       WriteCard(i,3);&#13;
       i := i + 1;&#13;
     UNTIL i = 6;&#13;
     WriteLn;&#13;
   &#13;
     WriteString("Loop:");  WriteLn;&#13;
     WriteString("  index:");&#13;
<span class="ent">➍</span> i := 0;&#13;
     LOOP&#13;
       WriteCard(i,3);&#13;
       i := i + 1;&#13;
       IF i = 6 THEN &#13;
         EXIT;&#13;
       END;&#13;
     END;&#13;
     WriteLn;&#13;
   &#13;
     WriteString("Counted:");  WriteLn;&#13;
     WriteString("  index:");&#13;
<span class="ent">➎</span> FOR i := 0 TO 5 DO&#13;
       WriteCard(i,3);&#13;
     END;&#13;
     WriteLn;&#13;
   END loops.</pre>&#13;
<p class="caption" id="ch02list4"><em>Listing 2-4: Loops in Modula-2</em></p>&#13;
<p class="indent"><a href="ch02.xhtml#ch02list4">Listing 2-4</a> presents all four kinds of structured programming loops. The preamble loads required functions from the standard library. A single variable, <code>i</code>, is all we need <span class="ent">➊</span>. Modula-2 distinguishes between integers and cardinals, which are positive integers.</p>&#13;
<p class="indent">The first loop is a <em>top-tested</em> <code>WHILE</code> loop <span class="ent">➋</span>. The loop executes while the condition is true. Because the test on the condition is at the top of the loop, there is the possibility that the loop will never execute.</p>&#13;
<p class="indent">The second loop <span class="ent">➌</span> is a <em>bottom-tested</em> loop. The test on whether to continue the loop happens after the body of the loop; therefore, this loop executes the body at least once, regardless of <code>i</code>’s initial value. Modula-2 uses <code>UNTIL</code> for the bottom test, meaning the loop body repeats until the condition is true. Some languages, like C, use a <code>while</code> for the bottom test, so the loop executes while the condition is true.</p>&#13;
<p class="indent">Modula-2 is one of the few high-level languages with an explicit <em>infinite</em> loop structure <span class="ent">➍</span>. A <code>LOOP</code> executes the body forever, or until <code>EXIT</code> is executed. A <code>while</code> loop that is always true has the same effect.</p>&#13;
<p class="indent">The last example is a <code>FOR</code> loop <span class="ent">➎</span>. Modula-2’s <code>FOR</code> is virtually identical to that of many other languages. The loop index has an initial value and continues incrementing until it reaches its ending value. There are many variants of this kind of loop, called the <em>counted loop</em>. In this category, I’m including loops like Python’s <code>for</code> that iterate over any object supporting iteration.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_68"/>Program flow is influenced by the way the programming language is structured and its approach to coding. Let’s conclude the chapter with a review of important coding paradigms used by programming languages.</p>&#13;
<h3 class="h3" id="lev1sec27"><strong>Programming Paradigms</strong></h3>&#13;
<p class="noindent">A <em>programming paradigm</em> is the way a language approaches the act of coding. The most important paradigms are imperative, object-oriented, and declarative, to which we’ll add my personal favorite, array processing. Let’s discuss the high-level characteristics of a few paradigms and give some examples of languages supporting each paradigm. Many practical languages support more than one paradigm.</p>&#13;
<h4 class="h4" id="lev2sec25"><strong><em>Imperative</em></strong></h4>&#13;
<p class="noindent"><em>Imperative</em> programming languages instruct the computer step by step. Almost all languages, especially those you’ll encounter as a professional developer, use this paradigm, or at least support it somewhat. And that makes sense: this is the most natural way to think about coding. To achieve a goal, certain things must happen in a specific order. That’s imperative programming: the programmer issues commands to the computer via the programming language.</p>&#13;
<p class="indent">Think of a popular programming language. It’s almost undoubtedly imperative: Java, Python, C/C++, C#, JavaScript, and so on. All of the languages we encountered in <a href="ch01.xhtml#ch01">Chapter 1</a>, except for Prolog and SML, are imperative languages.</p>&#13;
<p class="indent">Imperative languages are often further subdivided into structured and unstructured. A structured imperative language uses structured programming, which we just discussed in the previous section. Therefore, Pascal, C, Modula-2, and so on, are all structured imperative programming languages. An unstructured imperative language does not use structured programming. This includes assembly, but also higher-level languages like SNOBOL.</p>&#13;
<p class="indent">All the esolangs we’ll encounter and develop are imperative languages. It’s the most obvious way to do things.</p>&#13;
<h4 class="h4" id="lev2sec26"><strong><em>Object-Oriented</em></strong></h4>&#13;
<p class="noindent"><em>Object-oriented</em> languages employ encapsulation, polymorphism, and inheritance. In a sense, object-oriented languages are imperative languages plus a higher level of organization. The leap from imperative programming to object-oriented is relatively straightforward.</p>&#13;
<p class="indent"><em>Encapsulation</em> means that objects are both data and methods—they have their own data, separate from other objects, and their own methods for operating on that data. This hides information from outside of the object. This separation between objects adds security and reliability to programs. It is less likely that changes in one part of the program will adversely and subtly affect another part of the program in an object-oriented language.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_69"/><em>Polymorphism</em> is perhaps best understood by example. Imagine a class called <code>Shape</code> that has a method called <code>draw</code>. Now imagine subclasses of <code>Shape</code>, such as <code>Rectangle</code>, <code>Square</code>, and <code>Circle</code>. Each of these subclasses supplies a <code>draw</code> method appropriate for its particular shape. This creates an object hierarchy (see <a href="ch02.xhtml#ch02fig2">Figure 2-2</a>).</p>&#13;
<div class="image"><img id="ch02fig2" src="Images/02fig02.jpg" alt="Image" width="234" height="131"/></div>&#13;
<p class="figcap"><em>Figure 2-2: Hierarchy of objects in an object-oriented language</em></p>&#13;
<p class="noindent">In this diagram, <code>Rectangle</code>, <code>Square</code>, and <code>Circle</code> are all children (subclasses) of <code>Shape</code>. If we now make a function accepting a <code>Shape</code> argument, and call the <code>draw</code> method of that <code>Shape</code>, we can pass any subclass of <code>Shape</code> to the function and the proper <code>draw</code> method will be called. This is polymorphism.</p>&#13;
<div class="box5">&#13;
<p class="boxtitle-d"><strong>FUNCTION OVERLOADING</strong></p>&#13;
<p class="noindent">Polymorphism also happens during <em>function overloading</em>, a situation where multiple functions using the same name are defined, but each accepts a different type of argument. For example, consider this C++ code:</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
using namespace std;&#13;
&#13;
double CtoF(int C) {&#13;
    return (9*C)/5 + 32; &#13;
}&#13;
double CtoF(double C) {&#13;
    return (9.0/5.0)*C + 32.0;&#13;
}&#13;
&#13;
int main() {&#13;
    cout &lt;&lt; CtoF(37) &lt;&lt; endl;&#13;
    cout &lt;&lt; CtoF(37.0) &lt;&lt; endl;&#13;
}</pre>&#13;
<p class="noindent">The function <code>CtoF</code> is defined twice. The first definition accepts an integer and returns a double. The second definition accepts a double (64-bit float) and returns a double. The <code>main</code> function then calls <code>CtoF</code>, first with an integer argument, and then again with a floating-point argument. The C++ compiler uses the argument type to match which function is called.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_70"/>The program outputs</p>&#13;
<pre>98&#13;
98.6</pre>&#13;
<p class="noindent">The first line is from the integer version of <code>CtoF</code> and the second is from the double version. Note that in C++, if the only <code>CtoF</code> available to the compiler is the double version, both calls will return 98.6, as the compiler is smart enough to know it can automatically change the integer to a double to make the call succeed. This is not the case in general and is an example of weak typing in C++. Function overloading is an example of <em>compile-time polymorphism</em> because the compiler selects which function is evaluated while building the output executable.</p>&#13;
</div>&#13;
<p class="indent">The final hallmark of an object-oriented language is <em>inheritance</em>. This means a class can inherit, or acquire, the methods of another class. We saw this above with <code>Shape</code> and <code>Circle</code>, which is a subclass of <code>Shape</code>. The class <code>Circle</code> will inherit any methods <code>Shape</code> shares, gaining that functionality for free. We also saw inheritance at work in the Simula example of <a href="ch01.xhtml#ch01">Chapter 1</a>, where the class <code>Pal</code> inherited the member variables of its parent class, <code>Person</code>.</p>&#13;
<h4 class="h4" id="lev2sec27"><strong><em>Declarative</em></strong></h4>&#13;
<p class="noindent"><em>Declarative</em> programming, in which the programmer states <em>what</em> instead of explicitly <em>how</em>, comes in several flavors. We already explored one flavor in <a href="ch01.xhtml#ch01">Chapter 1</a>—logic programming—when we discussed Prolog. In Prolog, the goal is presented as what needs to happen without explicit step-by-step instructions as to how to make it happen.</p>&#13;
<p class="indent">Functional programming languages, like SML, also from <a href="ch01.xhtml#ch01">Chapter 1</a>, fall under the declarative category as well. SML is a good example of how difficult it can be to assign a language to just one paradigm. Functional languages use functions and recursion to express the what of a program rather than imperative control structures like <code>while</code> loops. However, SML supports <code>while</code> loops, a concession to imperative programming. Other languages that are often called “functional” include Lisp and Scheme, and, sometimes, even Python. However, it seems better to say Python includes functional programming elements but isn’t a functional language.</p>&#13;
<p class="indent">Hallmarks of functional programming include treating functions as <em>first-class objects</em>, meaning they can be assigned to variables, and <em>higher-order functions</em>, functions that accept functions as arguments or return functions. Let’s review two examples with Python.</p>&#13;
<p class="indent">In <a href="ch01.xhtml#ch01">Chapter 1</a>, we saw an example of currying in SML. Now, let’s see how currying works in Python.</p>&#13;
<pre>def factory(x):&#13;
    def mult(y):&#13;
        return x*y<span epub:type="pagebreak" id="page_71"/>&#13;
    <span class="ent">➊</span> return mult&#13;
&#13;
<span class="ent">➋</span> mult2 = factory(2)&#13;
   mult11 = factory(11)&#13;
&#13;
   print(mult2(4))&#13;
   print(mult11(3))</pre>&#13;
<p class="indent">First, we define a function called <code>factory</code>, which takes an argument and returns a function. Look carefully at <code>factory</code>. The function, <code>mult</code>, is defined within <code>factory</code> and accepts one argument, <code>y</code>. However, the body of <code>mult</code> returns <code>x*y</code>, with <code>x</code> being the argument to <code>factory</code>. The value of <code>x</code> used by <code>mult</code> is the value of <code>x</code> passed to <code>factory</code> when <code>factory</code> is called.</p>&#13;
<p class="indent">Now look at the return value of <code>factory</code> <span class="ent">➊</span>: it is the function, <code>mult</code>. Moreover, it is <code>mult</code> in the environment of <code>factory</code>, which means <code>mult</code> is using the value for <code>x</code> passed to <code>factory</code>. Now we see why I chose the name: <code>factory</code> is a generator of functions where one argument, <code>x</code>, is fixed. Returning a nested function creates a <em>closure</em>, a function with a specific environment bound to it—namely, the value of <code>x</code>.</p>&#13;
<p class="indent">The variable <code>mult2</code> is assigned whatever <code>factory(2)</code> returns <span class="ent">➋</span>. However, <code>factory(2)</code> returns a function, <code>mult</code>, with <code>x=2</code>. The variable <code>mult2</code> holds a function that multiplies its argument by 2. Likewise, <code>mult11</code> holds a function multiplying its argument by 11. Therefore, the code prints <code>8</code> and <code>33</code> as output.</p>&#13;
<p class="indent">Our second functional example involves decorators, Python syntactic sugar for a higher-order function that wraps another function.</p>&#13;
<pre><span class="ent">➊</span> def mydecorator(f):&#13;
    def decorate(*args, **kwargs):&#13;
        return "Per your request, the result is " + str(f(*args,**kwargs))&#13;
    return decorate&#13;
&#13;
<span class="ent">➋</span> @mydecorator&#13;
   def afunc(x):&#13;
       return x**2 + 3*x + 4&#13;
&#13;
<span class="ent">➌</span> def bfunc(x):&#13;
       return x**2 + 3*x + 4&#13;
&#13;
   dfunc = mydecorator(bfunc)</pre>&#13;
<p class="indent">This example defines four functions: <code>mydecorator</code>, <code>afunc</code>, <code>bfunc</code>, and <code>dfunc</code>. The first function <span class="ent">➊</span> accepts a function, <code>f</code>, and returns a new function, <code>decorate</code>, that wraps the result of <code>f</code>. Much like how the <code>factory</code> example above created a closure binding the value of <code>x</code>, <code>decorate</code> binds <code>f</code> to the function passed to <code>mydecorator</code>. Using <code>*args</code> and <code>**kwargs</code> is Python-speak for an arbitrary collection of positional and keyword arguments. Therefore, <code>mydecorator</code> is a higher-order function because it accepts a function as an argument and returns a function (a closure).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_72"/>The definition of <code>afunc</code> <span class="ent">➋</span> is preceded by <code>@mydecorator</code>. This is the syntactic sugar part, a readable way to use <code>mydecorator</code> with <code>afunc</code>. To show this is so, <span class="ent">➌</span> defines <code>bfunc</code> identical to <code>afunc</code> and then assigns the output of <code>mydecorator</code> <code>(bfunc)</code> to <code>dfunc</code>.</p>&#13;
<p class="indent">Now, consider how <code>afunc</code> and <code>dfunc</code> work, assuming the code to be in the file <em>decorator.py</em>.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from decorator import *</span> &#13;
&gt;&gt;&gt; <span class="codestrong1">print(afunc(23.4))</span>&#13;
Per your request, the result is 621.76&#13;
&gt;&gt;&gt; <span class="codestrong1">print(dfunc(23.4))</span>&#13;
Per your request, the result is 621.76</pre>&#13;
<p class="indent">Both calls return the expected value wrapped by the string <code>'Per your</code> <code>request...'</code>, demonstrating that the decorator <code>@</code> syntax is, in reality, a function application. Decorators enable adding new functionality to a function without altering the original function or altering source code that uses the function. Any code depending on <code>afunc</code> would still work as expected, assuming the decorator did something more valuable than intercepting the return value and printing.</p>&#13;
<p class="indent">Many modern languages have adopted elements of functional programming. Pure functional languages—those that are only function calls without side effects like updating variable values directly—have yet to make much of a dent outside of academic circles. Computer scientists like pure functional languages because they are friendly to proving a program to be correct. In contrast, software engineers like some aspects of functional languages but still need the ability to easily and more directly implement in code thinking that conforms to how we operate—executing an algorithm, step by step, to reach a desired outcome.</p>&#13;
<h4 class="h4" id="lev2sec28"><strong><em>Array Processing</em></strong></h4>&#13;
<p class="noindent">Scientific programming makes frequent use of numerical data, which is often most easily organized as some form of array, be it a vector, matrix, or higher-order tensor. For example, image processing and deep learning with convolutional neural networks use 2D, 3D, and even 4D data.</p>&#13;
<p class="indent">Given this, it would make sense for programming languages to process entire arrays en masse without explicit loops. Such languages are known as <em>array-processing</em> languages. In <a href="ch01.xhtml#ch01">Chapter 1</a>, we briefly explored the first one, APL. Since APL, many array-processing languages have been developed.</p>&#13;
<p class="indent">Suppose I’m a deep learning researcher with a dataset of images I need to work with. If the images are each 512 rows by 512 columns, I can store the images in an array. If the image is grayscale, meaning each pixel is represented by a single integer, often in the byte range of [0,255], then I can use a 2D array. If I have a stack of images, all the same size, I can store them one on top of the other in a 3D array. If the images are color, I need an extra dimension for the channels, implying a 4D array.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_73"/>A common operation with deep neural networks is scaling the input so it lies in the range [0,1]. If I have 100 images, each 512 rows by 512 columns, I can store the stack in an array that is 100 by 512 by 512. In that case, the scaling operation in a language like Pascal becomes</p>&#13;
<pre>var&#13;
  A : array[0..99,0..511,0..511] of real;&#13;
  i,j,k : integer;&#13;
begin&#13;
  (* Load the array with the images *)&#13;
&#13;
  for i:= 0 to 99 do&#13;
    for j:= 0 to 511 do&#13;
      for k:= 0 to 511 do&#13;
        A[i,j,k] := A[i,j,k] / 255.0;</pre>&#13;
<p class="noindent">In order to access every element of the array, we need a triple loop over the indices of the array. It would be nice to write <code>A := A / 255.0;</code> and have the language just “know” that <code>A</code> is an array and automatically apply the scaling operation to every element of it. This is precisely what an array-processing language provides.</p>&#13;
<p class="indent">Most deep learning researchers use Python with the NumPy library. NumPy adds high-speed array processing to Python. Native array-processing languages are in widespread use as well. For example, IDL and Matlab, or their respective open source counterparts, GDL and Octave, were built from the ground up for array processing.</p>&#13;
<p class="indent">Let’s use GDL to see array processing in action. On Ubuntu, install GDL with the following command:</p>&#13;
<pre>&gt; <span class="codestrong1">sudo apt-get install gnudatalanguage</span></pre>&#13;
<p class="noindent">If using macOS or Windows, see the Github page for installation instructions at <em><a href="https://github.com/gnudatalanguage/gdl/">https://github.com/gnudatalanguage/gdl/</a></em>.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch02list5">Listing 2-5</a> contains GDL code to manipulate a small collection of public domain test images.</p>&#13;
<pre><span class="ent">➊</span> pro display, a, b, f&#13;
       compile_opt idl2, logical_predicate&#13;
       tvscl, a, 0&#13;
       tvscl, b, 1&#13;
       write_png, 'images/'+f, tvrd()&#13;
   end&#13;
&#13;
   pro arraydemo&#13;
       compile_opt idl2, logical_predicate&#13;
       window, 0, xs=1024, ys=512&#13;
&#13;
    <span class="ent">➋</span> i0 = read_png('images/barbara.png')&#13;
       i1 = read_png('images/boat.png')<span epub:type="pagebreak" id="page_74"/>&#13;
       i2 = read_png('images/cameraman.png')&#13;
       i3 = read_png('images/zelda.png')&#13;
   &#13;
    <span class="ent">➌</span> display, i2, 255-i2, 'cinvert.png'&#13;
   &#13;
    <span class="ent">➍</span> m03 = bytscl(1.0*i0 + i3)&#13;
       m12 = bytscl(1.0*i1 + 2*i2)&#13;
       write_png, 'images/bzelda.png', m03 &#13;
       write_png, 'images/cboat.png', m12&#13;
   &#13;
    <span class="ent">➎</span> t = i3/255.0&#13;
       m = t^3 - t&#13;
       display, i3, m, 'zelda_ghost.png'&#13;
   &#13;
    <span class="ent">➏</span> k = [[0,1,0],[-1,0,1],[0,-1,0]]&#13;
    <span class="ent">➐</span> im = convol(i1, k)&#13;
       display, i1, im, 'boat_edges.png'&#13;
       k = [[0,-1,0],[-1,5,-1],[0,-1,0]]&#13;
       im = convol(i0, k)&#13;
       display, i0, im, 'barbara_sharp.png'&#13;
    <span class="ent">➑</span> k = 5*(randomu(seed,3,3)-0.5)&#13;
       im = convol(1.0*i2, k)&#13;
       display, i2, im, 'camera_random.png'&#13;
       print, k&#13;
   end</pre>&#13;
<p class="caption" id="ch02list5"><em>Listing 2-5: Image processing in GDL</em></p>&#13;
<p class="indent">The code above is in <em>arraydemo.pro</em>. To run it, enter</p>&#13;
<pre>&gt; <span class="codestrong1">gdl -quiet</span>&#13;
GDL&gt; <span class="codestrong1">arraydemo</span></pre>&#13;
<p class="noindent">The <code>-quiet</code> command line argument suppresses GDL’s startup message. Use CTRL-D to exit GDL.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch02list5">Listing 2-5</a> shows two procedures, <code>display</code> and <code>arraydemo</code>. The procedure <code>display</code> <span class="ent">➊</span> uses GDL commands to show two images, <code>a</code> and <code>b</code>, side by side before writing them to disk as one image. The <code>tvscl</code> command displays an image with scaling to [0, 255]. The <code>tvrd</code> function returns the image in the current window.</p>&#13;
<p class="indent">All the action is in <code>arraydemo</code>. First, we read the test images into 512×512 pixel arrays <span class="ent">➋</span>. We then take the cameraman image and invert it by subtracting it from 255, the largest value in a byte image <span class="ent">➌</span>. The expression <code>255-i2</code> returns a new 512×512 array in which each element is the difference between 255 and the corresponding element of <code>i2</code>. The entire image has been processed with no explicit loops.</p>&#13;
<p class="indent">Next, we alpha-blend the test images <span class="ent">➍</span>. Alpha-blending is a technique that merges two images into one, like the image on the right in <a href="ch02.xhtml#ch02fig3">Figure 2-3</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_75"/><img id="ch02fig3" src="Images/02fig03.jpg" alt="Image" width="679" height="337"/></div>&#13;
<p class="figcap"><em>Figure 2-3: The test images (left) and a sample alpha-blend (right)</em></p>&#13;
<p class="indent">The variable <code>m03</code> holds the merged <em>barbara.png</em> and <em>zelda.png</em> images. Note that GDL respects data types, so we first multiply one of the images by the floating-point value 1.0 to convert the entire expression to floating-point, thereby avoiding the overflow that would happen if we left everything in the byte range. The <code>bytscl</code> function maps its input to [0,255] to make the result fit as a grayscale image.</p>&#13;
<p class="indent">The next bit of code merges the cameraman and boat images. Unlike the previous blend, the images are given unequal weighting, making the cameraman image twice as intense as the boat image. Do review the output images created by <code>arraydemo</code> to see the full effect.</p>&#13;
<p class="indent">For <span class="ent">➎</span>, we apply a mathematical expression to the <em>zelda.png</em> image. The image is first scaled to [0, 1], and then each output pixel is assigned via <img src="Images/f0075.jpg" alt="Image" width="120" height="34"/> for all array elements (<em>i</em>, <em>j</em> = 0, 1, <em>…</em>511). The indices are not needed because GDL knows to apply the same operation to every array element. In a non-array processing language, the expression would be a double loop over <em>i</em> and <em>j</em>.</p>&#13;
<p class="indent">A standard image processing technique involves convolving a kernel over an image. Convolution means sliding a smaller array (the kernel) over the larger array (the image), where for each position of the kernel, the output value is the sum of the product of the kernel with the currently overlapped image region for all elements in the kernel. Convolution produces an output image showing how the image responds to the kernel. In <span class="ent">➏</span>, we apply three kernels. The first detects edges, the second sharpens the image, and the last is randomly generated, so each run of <em>arraydemo.pro</em> produces a different output. The actual convolution uses GDL’s <code>convol</code> library routine. The random kernel comes from <code>randomu</code>, which returns a random array in [0,1).</p>&#13;
<p class="indent">Array processing is a powerful paradigm, especially for scientific applications. Without array processing, writing code, especially research code not meant for long-term use, would be exceedingly tedious and error prone.</p>&#13;
<h3 class="h3" id="lev1sec28"><span epub:type="pagebreak" id="page_76"/><strong>Summary</strong></h3>&#13;
<p class="noindent">In this whirlwind chapter, we presented cherry-picked essentials related to programming languages meant as background for the remainder of the book. We discussed syntax and semantics and how programming languages are implemented, both interpreters and compilers. We then explored data types, including primitive types and records/structures, after which we followed a summary of more complex data structures like lists, trees, and hash tables. Next, we covered variable scope and learned the difference between lexical and dynamic scope. We then reviewed control structures, which are ways of controlling and modifying program flow. The chapter then reviewed several important programming paradigms, including imperative, object-oriented, declarative, and array processing.</p>&#13;
<p class="indent">Next, let’s move on and explore a bit of computer science theory related to what “computability” means.</p>&#13;
</div></body></html>