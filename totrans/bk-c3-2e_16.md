## **16**

**VALUES AND SIZING**

![Image](graphics/common-01.jpg)

Much of CSS3, from its many new selectors to layout and font properties, is designed to give you more granular control over presentation than was available in CSS2.1\. That control will be even more evident in this chapter, as I introduce new value functions and units, as well as methods to calculate dimensions automatically.

### **Relative Length Units**

In CSS a *relative length unit* is one whose value is relative to another property. The two relative units in CSS2.1 are `em`, which is calculated from the `font-size` property of an element, and `ex`, which is calculated from the x-height of the element’s font (see “[`font-size-adjust`](ch05.html#ch05leve1sec62)” on [page 56](ch05.html#page_56)).

CSS3 expands the range of relative units, which are no longer relative solely to an element’s font size. The new units are defined in the Values and Units Module (*[http://www.w3.org/TR/css-values/](http://www.w3.org/TR/css-values/)*).

#### ***Root-Relative Units***

The first new unit introduced in CSS3 is the `rem`, or *root em*. It behaves like the `em` unit from CSS2.1, but instead of being relative to the `font-size` value of the current element, it’s relative to the `font-size` value of the document root (the `html` element).

Although `em` is quite useful, it’s not without its drawbacks, which become most apparent when nesting elements. To illustrate the problem, I’ll use this markup:

```
<ul>
    <li>Western gorilla
        <ul>
            <li>Western lowland gorilla</li>
            <li>Cross River gorilla</li>
        </ul>
    </li>
</ul>
```

and this simple style rule:

```
li { font-size: 2em; }
```

If you presume that the root `font-size` of the document is the common browser default of 16px, the first `li` element will have a calculated `font-size` of 32px (16 multiplied by 2). But the `font-size` of the `li` elements nested inside the first would be calculated relative to the inherited value, making them 64px (32 multiplied by 2).

This is where the `rem` unit becomes essential. Here’s the same code as the previous example, only now using the `rem` in place of the `em` unit:

```
li { font-size: 2rem; }
```

Again, presuming a root `font-size` of 16px, the first `li` has a calculated `font-size` of 32px. This time, however, the `font-size` of the nested `li` elements is also relative to the root value, the same as their parent. And no matter how many nested layers down you go, that value is always relative to the root.

#### ***Viewport-Relative Units***

When building responsively, developers tend to use percentage values for layout elements, as they scale fluidly across the range of different screen sizes that websites need to cater to. Percentages are useful at a top level, but—as you just saw with `em` units—you can run into difficulties when using percentages with nested elements.

This code illustrates the problem:

```
<div class="parent">
    <div class="child">…</div>
</div>
```

Now, imagine that `.parent` is 75 percent of the viewport width, and you want `.child` to be 65 percent of the viewport width—not the width of its parent. To do this, you have to divide 65 by 75, giving you a result of 86.666 (percent). This calculation is simple enough, but the deeper the nesting goes, the more complex the calculations become.

A better solution is to use CSS3’s viewport-relative units—`vh` and `vw`—which represent viewport height and width, respectively. Each unit of value represents 1 percent of the appropriate viewport dimension: 1vh is 1 percent of the viewport height, and 1vw is 1 percent of the viewport width. For example, the following code makes an element 75 percent of the viewport width and 50 percent of its height:

```
E {
    height: 50vh;
    width: 75vw;
}
```

The advantage of using these units is that when elements are nested, the units remain relative to the viewport. So, in the case of my previous example, to make `.child` 65 percent of the total viewport width, you simply do this:

```
.child { width: 65vw; }
```

No calculation required!

Another pair of supplemental units is available, too: `vmax` is equivalent to whichever is the greater value of `vh` and `vw`, and `vmin` is equivalent to the lesser value. For instance, if the viewport were 480×640, the height would be greater, so `vmax` would be equivalent to `vh`, and `vmin` would be equal to `vw`. Swap the viewport dimensions (640×480), and `vmax` and `vmin` reverse their values.

So if you presume a viewport of 480×640, in the following code snippet, element `*E*` is 640px wide, and element `*F*` is 480px wide:

```
E { width: 100vmax; }
F { width: 100vmin; }
```

The utility of `vmax` and `vmin` is in ensuring an element remains proportional to the viewport regardless of orientation—useful when that orientation can easily change, such as on a mobile or tablet device.

Internet Explorer 9 implemented `vmin` as the `vm` unit, but neither it nor IE10 supports `vmax` (support was added in IE11). Many older smartphone browsers don’t support these properties, although newer versions (such as iOS 6.0 and Android 4.4 and above) do (though often without support for `vmax`, most notably in iOS as of this writing).

### **Calculated Values**

One of the biggest changes in CSS3 lies in the way that lengths can be declared. In CSS2.1, lengths are always a single value plus a unit, and if calculations are required (say, subtracting the width of a border from a total width), the developer has to do the calculation. But in CSS3, the browser performs the calculations.

CSS calculations are performed with the `calc()` function. You can use this function anywhere you use the common value units—length, angle, number, and so on. It takes as an argument any mathematical expression using those common value units and four basic operands: `+` (addition), `-` (subtraction), `*` (multiplication), and `/` (division).

The `calc()` function is especially useful when mixing units. For example, you could create an expression to calculate the width of an element (as a percentage) minus its border (as an `em`) like this:

```
E {
    border: 10px;
    width: calc(75% - 2em);
}
```

Addition and subtraction can be performed with any units, but when using multiplication, at least one argument on either side of the operand must be a unitless number. In the case of division, the argument *after* the operand must be a unitless number. Here are examples of how to perform both multiplication and division:

```
E {
    left: calc(5 * 10em);
    width: (80% / 4);
}
```

You can use parentheses in expressions to show computational order. For example, the following code shows an expression that performs three calculations:

```
E { height: calc(10% * 5 + 15% * 2); }
```

The expression first multiplies 10 percent by 5, and then adds it to the result of 15 percent multiplied by 2\. This setup works fine, but it’s is not immediately apparent when you look at it, and given a quite complex calculation could be difficult indeed to immediately understand. The expression becomes easier when written with parentheses:

```
E { height: calc((10% * 5) + (15% * 2)); }
```

You can also use nested `calc()` functions to achieve the same result.

When using multiplication or division in an expression, you must insert a single whitespace character around the operand—failing to do this means the expression is invalid and the property will be ignored. The following code shows an expression written twice: the first one is invalid because it has no space around the operand; the second is correctly formatted and, therefore, valid.

```
E { border-width: calc(1em*10); } /* Invalid */
E { border-width: calc(1em * 10); } /* Valid */
```

### **Sizing Elements**

The size of an element is generally set using the `width` or `height` properties or their `max*-*` and `min*-*` variants, together with either an absolute (`px`), relative (`em`), or percentage value. Although these options are good enough for most day-to-day use, I often find times when I wish the box model were a little more flexible or aware of the elements around it. CSS3 introduces new properties and values aimed at providing this extra flexibility through a box-model toggle and new content-aware sizing methods.

#### ***Box Sizing***

For many years, Internet Explorer implemented its box model in contravention of the W3C spec. The W3C model dictated that the `width` value was the width of the content box and that any padding and borders were extra. In IE’s model, on the other hand, the `width` value was equal to the total width of the element including any padding and borders. Consider these style rules:

```
E {
    border: 5px;
    padding: 10px;
    width: 100px;
}
```

In the IE model, the content box would be 70px wide, whereas in the W3C model, it would be the full 100px.

Although the standard model is more logical, at times the IE model is more convenient to use. In CSS3, you can opt to use the IE model with the `box-sizing` property, which is described in the CSS3 Basic User Interface Module (*[http://www.w3.org/TR/css3-ui/](http://www.w3.org/TR/css3-ui/)*). The syntax is as follows:

```
E { box-sizing: keyword; }
```

The default keyword is `content-box`, which means apply the specified `width` or `height` to the content box only, as in the W3C model. In contrast, the alternative value `border-box` means any specified length should also include any padding and border boxes.

[Figure 16-1](ch16.html#ch16fig1) shows the difference. The top example uses the W3C box model, whereas the bottom one has the `border-box` value applied. As you can see, the total width of the lower example is equal to the content box of the upper.

![Image](graphics/f16-01.jpg)

*Figure 16-1: Comparing values for* `*box-sizing*`*: the default* `*content-box*` *(top) and* `*border-box*` *(bottom)*

**NOTE**
*Some people prefer to set a global style rule to apply* `*border-box*` *to all elements. I prefer to apply the rule only as required.*

#### ***Intrinsic and Extrinsic Sizing***

One challenge in web layout is that elements are ignorant of their content and the context in which they’re used—in other words, without JavaScript, an element is not aware of the dimensions of its child or parent elements. CSS3 introduces a new concept that changes that equation a bit with the addition of *intrinsic* and *extrinsic* sizing. Intrinsic sizing is based on an element’s children, and extrinsic sizing is based on the size of the parent element. These sizing models are defined in the CSS3 Intrinsic & Extrinsic Sizing Module (*[http://dev.w3.org/csswg/css-sizing/](http://dev.w3.org/csswg/css-sizing/)*).

All of the intrinsic and extrinsic sizing models are applied using a keyword value on the `width` or `height` properties (and their `min-` and `max-` variants). For example, this listing shows how a new sizing model would be applied to `width`:

```
E { width: keyword; }
```

##### **max-content and min-content**

The first new keyword values, `max-content` and `min-content`, are intrinsic values that make an element as wide or as high as the largest (`max-content`) or smallest (`min-content`) item of content (in text, the width of the longest word) it contains. Consider this markup of an `img` and `p` element inside a containing `div`:

```
<div>
    <img src="foo.png">
    <p>…</p>
</div>
```

Say the `img` element has a width of 200px and the width of the `p` is 300px. If the `div` element had a `width` value of `max-content`, it would be just wide enough to contain the `p`, and if it had a value of `min-content`, it would be just wide enough to fit the `img` and the text in the `p` would wrap.

Compare the results shown in [Figure 16-2](ch16.html#ch16fig2). The container element on the left has the `max-content` value applied, which makes it as wide as the widest child (the `p`), whereas the one on the right has `min-content` applied, which makes it as wide as the narrowest child (the `img`).

![Image](graphics/f16-02.jpg)

*Figure 16-2: The* `*max-content*` *value (left) makes the element as wide as its widest child, whereas* `*min-content*` *(right) makes the element as wide as its narrowest child.*

**NOTE**
*As of this writing, the current desktop and mobile versions of Chrome, Firefox, and Safari support these keywords, although each requires vendor prefixes (namely*`*-moz-min-content*` *and* `*-webkit-min-content*`*). Support is not currently present in Internet Explorer or older smartphones.*

##### **fit-content**

The next intrinsic keyword value is potentially the most useful. Called `fit-content`, it sizes an element just as floated elements or table cells do: An element will expand to be just wide enough to contain its content, unless the maximum width of the element is reached, in which case, the content will wrap.

[Figure 16-3](ch16.html#ch16fig3) compares the effect of `fit-content` to `max-content` and `min-content`. The box at the top left has `fit-content` applied, and the content wraps when it reaches the limit of the parent container. In contrast, the box at the top right has `max-content` applied, so it should expand to fit its content—however, the box now exceeds the width of its parent container, which has an `overflow` value of `hidden`, meaning the box is clipped.

The box at bottom left also has `fit-content` applied, so the container resizes to fit the width of the content; the box at the bottom right has `min-content` applied, so the container is only as wide as the `img` element and the text content wraps.

![Image](graphics/f16-03.jpg)

*Figure 16-3: The* `*fit-content*` *value, compared to* `*max-content*` *and* `*min-content*`

##### **fill**

The final keyword in the spec is named `fill`. (But in Firefox it’s `available` and in Chrome it’s `fill-available`!) This extrinsic value makes an element fill all available space along the height or width of its parent.

Say you want to make an inline-block `p` element, with border and padding, expand to be as wide as its parent. Generally, you would apply these rules:

```
p {
    border-width: 0 0.5em;
    display: inline-block;
    padding: 0 1em;
    width: 100%;
}
```

As you know, however, an element’s “real” width also includes padding and border, so, in this case, the `p` element would overflow its parent. One solution is to use the `box-sizing` property (see “[Box Sizing](ch16.html#ch16leve1sec213)” on [page 203](ch16.html#page_203)), but you may have good reasons for keeping the standard box model, so a better alternative is to use intrinsic sizing:

```
p { width: fill; }
```

The result is shown in [Figure 16-4](ch16.html#ch16fig4); the inline-block element, with border and padding, is resized to fill the available space in its parent.

![Image](graphics/f16-04.jpg)

*Figure 16-4: Using the* `*fill*` *value for* `*width*` *makes the inline-block caption shown here fill the available width of its parent.*

### **Summary**

In this chapter, I’ve discussed value units that are relative to a root font size and the viewport, dynamic calculations of values, and CSS3 ways to size elements based on their content and context. I’ve also discussed the CSS3 switch to a different box model.

Although units and sizing methods may seem like an unglamorous aspect of CSS, they offer you fine-grained control over your layouts, which is always welcome. Because websites are viewed on such a variety of different devices, for an element to be aware of its viewport, content, and context, so it presents content in the most appropriate way, is extremely valuable.

### **Values and Sizing: Browser Support**

|  | **Chrome** | **Firefox** | **Safari** | **IE** |
| Root-relative units | Yes | Yes | Yes | Yes |
| Viewport-relative units | Yes | Yes | Yes^([*](ch16.html#footnote35a)) | IE9^([†](ch16.html#footnote36a)), IE10^([‡](ch16.html#footnote37a)) |
| Calculated values | Yes | Yes | Yes | Yes |
| Box sizing | Yes | Yes | Yes | Yes |
| Intrinsic/extrinsic sizing | Yes^([§](ch16.html#footnote38a)) | Yes^([§](ch16.html#footnote38a)) | Yes^([§](ch16.html#footnote38a)) | No |

[*](ch16.html#footnote_35a) Buggy support for `vh` in iOS

[†](ch16.html#footnote_36a) Supports `vm` instead of `vmin`, no support for `vmax`

[‡](ch16.html#footnote_37a) No support for `vmax`

[§](ch16.html#footnote_38a) With vendor prefix