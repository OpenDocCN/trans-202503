- en: Chapter 13. System Updates and Root Access
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapters, we introduced Android’s security model and discussed
    how integrating SELinux into Android has reinforced it. In this chapter, we take
    a bit of a right turn and introduce methods that can be used to circumvent Android’s
    security model.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In order to perform a full OS update or to restore the device to its factory
    state, it’s necessary to escape the security sandbox and gain full access to a
    device, because even the most privileged Android components are not given complete
    access to all system partitions and storage devices. Additionally, while having
    full administrative (root) access at runtime is clearly against Android’s security
    design, executing with root privileges can be useful in order to implement functionality
    not offered by Android, such as the addition of custom firewall rules or full
    (including system partitions) device backup. Indeed, the wide availability of
    custom Android builds (often called *ROMs*) and apps that allow users to extend
    or replace OS functionality using root access (commonly known as *root apps*)
    has been one of the reasons for Android’s success.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explore the design of Android’s bootloader and recovery
    OS, and show how they can be used to replace the system software of a device.
    We then show how root access is implemented on engineering builds and how Android
    production builds can be modified to allow executing code with superuser privileges
    by installing a “superuser” application. Finally, we discuss how custom Android
    distributions implement and control root access.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Bootloader
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *bootloader* is a low-level program that is executed when a device is powered.
    Its main purpose is to initialize the hardware and find and start the main operating
    system.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: As briefly discussed in [Chapter 10](ch10.html "Chapter 10. Device Security"),
    Android bootloaders are usually locked and only allow booting or installing an
    operating system image that has been signed by the device manufacturer. This is
    an important step in establishing a verified boot path, because it ensures that
    only trusted and unmodified system software can be installed on a device. However,
    while most users are not interested in modifying the core OS of their devices,
    installing a third-party Android build is a valid user choice and may even be
    the only way to run a recent version of Android on devices that have stopped receiving
    OS updates from their manufacturer. That is why most recent devices provide a
    way to unlock the bootloader and install third-party Android builds.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*While Android bootloaders are typically closed source, the bootloaders of
    most ARM devices based on Qualcomm SoCs are derived from the Little Kernel (LK)
    bootloader,*^([[137](#ftn.ch13fn01)]) *which is open source.*^([[138](#ftn.ch13fn02)])'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we’ll look at how to interact with Android bootloaders
    and how the bootloader can be unlocked on Nexus devices. We then describe the
    fastboot protocol used to update devices via the bootloader.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨如何与 Android 引导加载程序进行交互，以及如何在 Nexus 设备上解锁引导加载程序。然后，我们会描述通过引导加载程序更新设备时使用的
    fastboot 协议。
- en: Unlocking the Bootloader
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解锁引导加载程序
- en: The bootloaders of Nexus devices are unlocked by issuing the `oem unlock` command
    when the device is in fastboot mode (discussed in the next section). Therefore,
    in order to unlock a device, it must first be started in fastboot mode, either
    by issuing the `adb reboot bootloader` command (if the device already allows ADB
    access), or by pressing a special key combination while the device is booting.
    For example, holding down the Volume down, Volume up, and Power buttons simultaneously
    on a powered-down Nexus 5 interrupts the normal boot process and brings up the
    fastboot screen shown in [Figure 13-1](ch13.html#nexus_5_bootloader_screen "Figure 13-1. Nexus
    5 bootloader screen").
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Nexus 设备的引导加载程序通过在设备处于 fastboot 模式时发出 `oem unlock` 命令来解锁（将在下一节讨论）。因此，为了解锁设备，必须首先通过发出
    `adb reboot bootloader` 命令（如果设备已允许 ADB 访问）或通过在设备启动时按下特定的按键组合进入 fastboot 模式。例如，在关闭电源的
    Nexus 5 上同时按住音量下、音量上和电源按钮，会中断正常的启动过程，并显示[图 13-1](ch13.html#nexus_5_bootloader_screen
    "图 13-1. Nexus 5 引导加载程序屏幕")中的 fastboot 屏幕。
- en: The bootloader has a simple UI that can be driven by the Volume up/down and
    Power buttons. It allows users to continue the boot process, restart the device
    in fastboot or recovery mode, and power down the device.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序具有一个简单的用户界面，可以通过音量上下和电源按钮进行操作。它允许用户继续启动过程、在 fastboot 或恢复模式下重新启动设备，并关闭设备电源。
- en: Connecting the device to a host machine via a USB cable allows additional commands
    to be sent to the device using the `fastboot` command-line tool (part of the Android
    SDK). Issuing the `fastboot oem unlock` command brings up the confirmation screen
    shown in [Figure 13-2](ch13.html#nexus_5_bootloader_unlock_screen "Figure 13-2. Nexus
    5 bootloader unlock screen").
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 USB 电缆将设备连接到主机计算机可以使用 `fastboot` 命令行工具（Android SDK 的一部分）向设备发送额外的命令。发出 `fastboot
    oem unlock` 命令会显示确认屏幕，如[图 13-2](ch13.html#nexus_5_bootloader_unlock_screen "图
    13-2. Nexus 5 引导加载程序解锁屏幕")所示。
- en: '![Nexus 5 bootloader screen](figs/web/13fig01.png.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![Nexus 5 引导加载程序屏幕](figs/web/13fig01.png.jpg)'
- en: Figure 13-1. Nexus 5 bootloader screen
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-1. Nexus 5 引导加载程序屏幕
- en: '![Nexus 5 bootloader unlock screen](figs/web/13fig02.png.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Nexus 5 引导加载程序解锁屏幕](figs/web/13fig02.png.jpg)'
- en: Figure 13-2. Nexus 5 bootloader unlock screen
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-2. Nexus 5 引导加载程序解锁屏幕
- en: The confirmation screen warns that unlocking the bootloader allows installation
    of untested third-party OS builds and clears all user data. Because a third-party
    OS build might not follow Android’s security model and might allow unrestricted
    access to data, clearing all user data is an important security measure; it ensures
    that existing user data cannot be extracted after the bootloader is unlocked.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 确认屏幕警告解锁引导加载程序将允许安装未经测试的第三方操作系统构建，并清除所有用户数据。由于第三方操作系统构建可能不遵循 Android 的安全模型，并可能允许对数据的无限制访问，因此清除所有用户数据是一个重要的安全措施；它确保在引导加载程序解锁后无法提取现有的用户数据。
- en: The bootloader can be locked again by issuing the `fastboot oem lock` command.
    Relocking the bootloader returns it to its original state, and loading or booting
    third-party OS images is no longer possible. However, besides a locked/unlocked
    flag, some bootloaders keep an additional, “tampered” flag that is set when the
    bootloader is first unlocked. This flag allows the bootloader to detect if it
    has ever been locked and disallow some operations or show a warning even if it
    is in a locked state.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过发出 `fastboot oem lock` 命令可以重新锁定引导加载程序。重新锁定引导加载程序将其恢复到原始状态，并且不再能够加载或启动第三方操作系统镜像。然而，除了锁定/解锁标志之外，一些引导加载程序还会保持一个额外的“篡改”标志，该标志会在引导加载程序首次解锁时被设置。这个标志可以让引导加载程序检测它是否曾经被锁定，并在它处于锁定状态时拒绝某些操作或显示警告。
- en: Fastboot Mode
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fastboot 模式
- en: While the `fastboot` command and protocol can be used to unlock the boot-loader,
    their original purpose was to make it easy to clear or overwrite device partitions
    by sending partition images to the bootloader, which are then written to the specified
    block device. This is particularly useful when porting Android to a new device
    (referred to as “device bring-up”) or restoring a device to factory state using
    partition images provided by the device manufacturer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Android Partition Layout
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android devices typically have several partitions, which fastboot refers to
    by name (rather than by the corresponding Linux device file). A list of partitions
    and their names can be obtained by listing the files in the *by-name/* directory
    corresponding to the device’s SoC in */dev/block/platform/*. For example, because
    the Nexus 5 is based on Qualcomm SoC, which includes a Mobile Station Modem (MSM)
    baseband processor, the corresponding directory is called *msm_sdcc.1/* as shown
    in [Example 13-1](ch13.html#list_of_partitions_on_a_nexus_5 "Example 13-1. List
    of partitions on a Nexus 5") (timestamps omitted).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-1. List of partitions on a Nexus 5
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, the Nexus 5 has 29 partitions, most of which store device-specific
    and proprietary data, such as the Android bootloader in *aboot* ➊, the baseband
    software in *modem* ➎, and the second stage bootloader in *sbl1* ➐. The Android
    OS is hosted in the *boot* ➋ partition, which stores the kernel and the *rootfs*
    RAM disk image, and the *system* partition ➑, which stores all other system files.
    User files are stored in the *userdata* partition ➒, and temporary files, such
    as downloaded OTA images and recovery OS commands and logs, are stored in the
    *cache* partition ➌. Finally, the recovery OS image resides in the *recovery*
    partition ➏.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The Fastboot Protocol
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fastboot protocol works over USB and is driven by the host. That is, communication
    is initiated by the host, which uses USB bulk transfers to send text-based commands
    and data to the bootloader. The USB client (boot-loader) responds with a status
    string such as *OKAY* or *FAIL*; an information message starting with *INFO*;
    or *DATA*, which signifies that the bootloader is ready to accept data from the
    host. When all data is received, the boot-loader responds with one of the *OKAY*,
    *FAIL*, or *INFO* messages describing the final status of the command.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Fastboot Commands
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `fastboot` command-line utility implements the fastboot protocol, and allows
    you to get a list of connected devices that support fastboot (using the `devices`
    command), obtain information about the bootloader (with the `getvar` command),
    reboot the device in various modes (with `continue`, `reboot`, `reboot-bootloader`),
    and `erase` or `format` a partition.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The `fastboot` command supports various ways to write a disk image to a partition.
    A single named partition can be flashed using the `flash` *`partition image-filename`*
    command, and multiple partition images contained in a ZIP file can be flashed
    at once using the `update` *`ZIP-filename`* command.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`fastboot`命令支持多种将磁盘镜像写入分区的方式。使用`flash` *`partition image-filename`*命令可以闪存单个命名分区，而使用`update`
    *`ZIP-filename`*命令可以一次性闪存ZIP文件中的多个分区镜像。'
- en: The `flashall` command automatically flashes the contents of the *boot.img*,
    *system.img*, and *recovery.img* files in its working directory to the *boot*,
    *system*, and *recovery* partitions of the device, respectively. Finally, the
    `flash:raw boot` *`kernel ramdisk`* command automatically creates a boot image
    from the specified kernel and RAM disk and flashes it to the *boot* partition.
    In addition to flashing partition images, `fastboot` can also be used to boot
    an image without writing it to the device when invoked with the `boot` *`boot-image`*
    or `boot` *`kernel ramdisk`* commands.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`flashall`命令会自动将其工作目录中的*boot.img*、*system.img*和*recovery.img*文件的内容分别闪存到设备的*boot*、*system*和*recovery*分区。最后，`flash:raw
    boot` *`kernel ramdisk`*命令会根据指定的内核和RAM磁盘自动创建一个启动镜像并将其闪存到*boot*分区。除了闪存分区镜像外，`fastboot`还可以在使用`boot`
    *`boot-image`*或`boot` *`kernel ramdisk`*命令时，启动一个镜像而无需将其写入设备。'
- en: Commands that modify device partitions, such as the various `flash` variations,
    and commands that boot custom kernels, such as the `boot` command, are not allowed
    when the bootloader is locked.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 修改设备分区的命令，如各种`flash`变体命令，以及启动自定义内核的命令，如`boot`命令，在启动加载程序被锁定时是不允许的。
- en: '[Example 13-2](ch13.html#example_fastboot_session "Example 13-2. Example fastboot
    session") shows an example `fastboot` session.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-2](ch13.html#example_fastboot_session "示例 13-2. 示例 fastboot 会话") 显示了一个`fastboot`会话的示例。'
- en: Example 13-2. Example `fastboot` session
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-2. 示例 `fastboot` 会话
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the first command ➊ lists the serial numbers of devices connected to the
    host, which are currently in fastboot mode. The commands at ➋ and ➌ obtain the
    bootloader and baseband version strings, respectively. Finally, the command at
    ➍ tries to boot a custom recovery image but fails because the bootloader is currently
    locked.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个命令➊列出了连接到主机的设备的序列号，这些设备当前处于fastboot模式。命令➋和➌分别获取启动加载程序和基带版本字符串。最后，命令➍尝试启动一个自定义恢复镜像，但由于启动加载程序当前被锁定，操作失败。
- en: Recovery
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复
- en: The *recovery OS*—also called *recovery console* or simply, *recovery*—is a
    minimal OS that is used for tasks that cannot be executed directly from Android,
    such as factory reset (erasing the *userdata* partition) or applying OTA updates.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*恢复操作系统*—也称为*恢复控制台*或简单的*恢复*—是一个最小化操作系统，用于执行不能直接从Android执行的任务，如恢复出厂设置（擦除*userdata*分区）或应用OTA更新。'
- en: Like the bootloader’s fastboot mode, the recovery OS can be started either by
    pressing a specific key combination while the device boots, or via ADB by using
    the `adb reboot recovery` command. Some bootloaders also provide a menu interface
    (see [Figure 13-1](ch13.html#nexus_5_bootloader_screen "Figure 13-1. Nexus 5 bootloader
    screen")) that can be used to start the recovery. In the following sections, we
    take a look at the “stock” Android recovery that ships with Nexus devices and
    is included in AOSP, and then introduce custom recoveries, which offer much richer
    functionality but require an unlocked bootloader in order to be installed or booted.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与启动加载程序的fastboot模式类似，恢复操作系统可以通过在设备启动时按下特定的按键组合，或通过使用`adb reboot recovery`命令通过ADB启动。一些启动加载程序还提供一个菜单界面（见[图13-1](ch13.html#nexus_5_bootloader_screen
    "图13-1. Nexus 5 启动加载器界面")），可以用来启动恢复。在接下来的部分，我们将介绍Nexus设备随附的“原生”Android恢复以及包含在AOSP中的恢复系统，然后介绍自定义恢复，这些恢复提供了更丰富的功能，但需要解锁启动加载程序才能安装或启动。
- en: Stock Recovery
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储恢复
- en: Android’s stock recovery implements the minimal functionality needed to satisfy
    the “Updatable Software” section of the *Android Compatibility Definition Document
    (CDD)*, which requires that “device implementations MUST include a mechanism to
    replace the entirety of the system software...” and that “the update mechanism
    used MUST support updates without wiping user data.”^([[139](#ftn.ch13fn03)])
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Android的原生恢复实现了满足*Android兼容性定义文档（CDD）*中“可更新软件”部分所需的最小功能，该部分要求“设备实现必须包括一个机制来替换整个系统软件……”并且“所使用的更新机制必须支持在不擦除用户数据的情况下进行更新。”^([[139](#ftn.ch13fn03)])
- en: That said, the CDD doesn’t specify the concrete update mechanism that should
    be used, so different approaches to system updates are possible and the stock
    recovery implements both OTA updates and tethered updates. For OTA updates, the
    main OS downloads the update file and then instructs the recovery to apply it.
    In the case of tethered updates, users download the update package on their PC
    and push it to the recovery using the `adb sideload` *`otafile.zip`* command.
    The actual update process for both approaches is the same; only the method of
    obtaining the OTA package differs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，CDD（兼容性定义文档）并没有指定应使用哪种具体的更新机制，因此可能有不同的系统更新方法，而默认恢复模式实现了 OTA 更新和连接更新两种方式。对于
    OTA 更新，主操作系统下载更新文件，然后指示恢复模式应用该更新。对于连接更新，用户在 PC 上下载更新包，并使用`adb sideload` *`otafile.zip`*命令将其推送到恢复模式。两种方法的实际更新过程是相同的；只有获取
    OTA 包的方法不同。
- en: The stock recovery has a simple menu interface (shown in [Figure 13-3](ch13.html#stock_recovery_menu
    "Figure 13-3. Stock recovery menu")) that is operated using the device’s hardware
    buttons, usually the Power button and Volume up/down. However, the menu is hidden
    by default and needs to be activated by pressing a dedicated key combination.
    On Nexus devices, the recovery menu can usually be displayed by holding down the
    Power and Volume down buttons simultaneously for a few seconds.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 默认恢复模式具有简单的菜单界面（如[图13-3](ch13.html#stock_recovery_menu "图13-3. 默认恢复菜单")所示），通过设备的硬件按钮操作，通常是电源按钮和音量上下按钮。然而，菜单默认是隐藏的，需要通过按下特定的按键组合来激活。在
    Nexus 设备上，通常通过同时按住电源和音量下按钮几秒钟即可显示恢复菜单。
- en: 'The system recovery menu has four options: *reboot*, *apply update from ADB*,
    *factory reset*, and *wipe cache partition*. The ***apply update from ADB*** option
    starts the ADB server on the device and enables the tethered update (side-load)
    mode. However, as you can see, there is no option for applying an OTA update because
    once the user chooses to apply an OTA update from the main OS (see [Figure 13-4](ch13.html#applying_a_system_update_from_the_main_o
    "Figure 13-4. Applying a system update from the main OS")), it is applied automatically,
    without further user interaction. Android accomplishes this by sending control
    commands to the recovery, which are automatically executed when the recovery starts.
    (We discuss the mechanisms used to control the recovery in the next section.)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 系统恢复菜单有四个选项：*重启*、*通过 ADB 应用更新*、*恢复出厂设置*和*清除缓存分区*。***通过 ADB 应用更新***选项会在设备上启动
    ADB 服务器，并启用连接更新（侧加载）模式。然而，如你所见，并没有应用 OTA 更新的选项，因为一旦用户选择从主操作系统应用 OTA 更新（见[图13-4](ch13.html#applying_a_system_update_from_the_main_o
    "图13-4. 从主操作系统应用系统更新")），系统会自动应用更新，无需进一步的用户操作。Android 通过向恢复模式发送控制命令来实现这一点，这些命令会在恢复模式启动时自动执行。（我们将在下一节讨论用于控制恢复模式的机制。）
- en: '![Stock recovery menu](figs/web/13fig03.png.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![默认恢复菜单](figs/web/13fig03.png.jpg)'
- en: Figure 13-3. Stock recovery menu
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-3. 默认恢复菜单
- en: '![Applying a system update from the main OS](figs/web/13fig04.png.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![从主操作系统应用系统更新](figs/web/13fig04.png.jpg)'
- en: Figure 13-4. Applying a system update from the main OS
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-4. 从主操作系统应用系统更新
- en: Controlling the Recovery
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制恢复模式
- en: The main OS controls the recovery via the `android.os.RecoverySystem` API, which
    communicates with the recovery by writing option strings, each on a new line,
    to the */cache/recovery/command* file. The contents of the *command* file are
    read by the `recovery` binary (located at */sbin/recovery* in the recovery OS),
    which is automatically started from *init.rc* when the recovery boots. The options
    modify the behavior of the `recovery` binary and cause it to wipe the specified
    partition, apply an OTA update, or simply reboot. [Table 13-1](ch13.html#options_for_the_stock_recovery_binary
    "Table 13-1. Options for the Stock recovery Binary") shows the options supported
    by the stock `recovery` binary.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 主操作系统通过`android.os.RecoverySystem` API 控制恢复模式，该 API 通过将每个选项字符串写入*/cache/recovery/command*文件中的新行，与恢复模式通信。*command*文件的内容会被`recovery`二进制文件（位于恢复操作系统的*/sbin/recovery*）读取，该文件会在恢复模式启动时从*init.rc*自动启动。选项会修改`recovery`二进制文件的行为，导致其擦除指定分区、应用
    OTA 更新或仅仅重启。[表13-1](ch13.html#options_for_the_stock_recovery_binary "表13-1. 默认恢复二进制的选项")显示了默认`recovery`二进制文件支持的选项。
- en: Table 13-1. Options for the Stock recovery Binary
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 表13-1. 默认恢复二进制的选项
- en: '| recovery Option | Description |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 恢复选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `--send_intent=<string>` | Save and communicate the specified intent action
    back to the main OS when finished |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `--send_intent=<string>` | 完成后将指定的意图动作保存并传回主操作系统 |'
- en: '| `--update_package=<OTA package path>` | Verify and install the specified
    OTA package |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `--update_package=<OTA包路径>` | 验证并安装指定的OTA包 |'
- en: '| `--wipe_data` | Erase the *userdata* and *cache* partitions, then reboot
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `--wipe_data` | 擦除*用户数据*和*缓存*分区，然后重启 |'
- en: '| `--wipe_cache` | Erase the *cache* partition, then reboot |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `--wipe_cache` | 擦除*缓存*分区，然后重启 |'
- en: '| `--show_text` | Message to display |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `--show_text` | 显示的消息 |'
- en: '| `--just_exit` | Exit and reboot |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `--just_exit` | 退出并重启 |'
- en: '| `--locale` | Locale to use for recovery messages and UI |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `--locale` | 恢复消息和UI使用的语言环境 |'
- en: '| `--stages` | Set the current stage of the recovery process |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `--stages` | 设置恢复过程的当前阶段 |'
- en: In order to ensure that the specified command(s) are always completed, the `recovery`
    binary copies its arguments to the bootloader control block (BCB), which is hosted
    on the *misc* partition (➍ in [Example 13-1](ch13.html#list_of_partitions_on_a_nexus_5
    "Example 13-1. List of partitions on a Nexus 5")). The BCB is used to communicate
    the current state of the recovery process to the bootloader. The format of the
    BCB is specified in the `bootloader_message` structure, shown in [Example 13-3](ch13.html#bcb_format_structure_definition
    "Example 13-3. BCB format structure definition").
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保指定的命令始终完成，`recovery`二进制文件将其参数复制到引导加载程序控制块（BCB），该控制块位于*misc*分区（➍处在[示例 13-1](ch13.html#list_of_partitions_on_a_nexus_5
    "示例 13-1. Nexus 5上的分区列表")中）。BCB用于将恢复过程的当前状态传递给引导加载程序。BCB的格式在`bootloader_message`结构中定义，详见[示例
    13-3](ch13.html#bcb_format_structure_definition "示例 13-3. BCB格式结构定义")。
- en: Example 13-3. BCB format structure definition
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-3. BCB格式结构定义
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If a device is rebooted or powered down in the middle of the recovery process,
    the next time it is started the bootloader inspects the BCB and starts the recovery
    again if the BCB contains the *boot-recovery* command. If the recovery process
    completes successfully, the `recovery` binary clears the BCB before exiting (sets
    all bytes to zero), and on the next reboot the boot-loader starts the main Android
    OS.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备在恢复过程中重启或断电，下次启动时，引导加载程序会检查BCB，如果BCB包含*boot-recovery*命令，则会重新启动恢复过程。如果恢复过程成功完成，`recovery`二进制文件会在退出前清除BCB（将所有字节设置为零），并且在下次重启时，引导加载程序会启动主Android操作系统。
- en: In [Example 13-3](ch13.html#bcb_format_structure_definition "Example 13-3. BCB
    format structure definition"), the command at ➊ is the command to the bootloader
    (usually *boot-recovery*); ➋ is a status file written by the bootloader after
    performing a platform-specific action; ➌ contains the options for the `recovery`
    binary (`--update_package`, `--wipe-data`, and so on); and ➍ is a string describing
    the install stage of OTA packages that require multiple restarts, for example
    *2/3* if the installation requires three reboots. The last field ➎ is reserved
    and not used as of this writing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 13-3](ch13.html#bcb_format_structure_definition "示例 13-3. BCB格式结构定义")中，➊处的命令是发送给引导加载程序的命令（通常是*boot-recovery*）；➋是引导加载程序在执行平台特定操作后写入的状态文件；➌包含`recovery`二进制文件的选项（如`--update_package`、`--wipe-data`等）；➍是描述OTA包安装阶段的字符串，若安装需要多次重启，则例如*2/3*表示安装需要三次重启。最后的字段➎是保留字段，目前未使用。
- en: Sideloading an OTA Package
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装OTA包
- en: Besides being downloaded by the main OS, an OTA package can be directly passed
    to the recovery from a host PC. In order to enable this update mode, the user
    must choose the *apply update from ADB* option from the recovery menu first. This
    starts a trimmed down version of the standard ADB daemon, which supports only
    the `sideload` command. Executing `adb sideload` *`OTA-package-file`* on the host
    transfers the OTA file to */tmp/update.zip* on the device and installs it (see
    “[Applying the Update](ch13.html#applying_the_update "Applying the Update")”).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了由主操作系统下载外，OTA包还可以直接从主机PC传递给恢复模式。为了启用这种更新模式，用户必须首先从恢复菜单中选择*从ADB应用更新*选项。这将启动一个简化版本的标准ADB守护进程，仅支持`adb
    sideload`命令。在主机上执行`adb sideload` *`OTA-package-file`*将OTA文件传输到设备上的*/tmp/update.zip*并进行安装（参见“[应用更新](ch13.html#applying_the_update
    "应用更新")”）。
- en: OTA Signature Verification
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OTA签名验证
- en: As we learned in [Chapter 3](ch03.html "Chapter 3. Package Management"), OTA
    packages are code signed, with the signature applied over the whole file (unlike
    JAR and APK files, which include a separate signature for each file in the archive).
    When the OTA process is started from the main Android OS, the OTA package (ZIP
    file) is first verified using the `verifyPackage()` method of the `RecoverySystem`
    class. This method receives both the path to the OTA package and a ZIP file containing
    a list of X.509 certificates that are allowed to sign OTA updates as parameters.
    If the OTA package is signed with the private key corresponding to any of the
    certificates in the ZIP file, the OTA is considered valid and the system reboots
    into recovery in order to apply it. If no certificate ZIP file is specified, the
    system default, */system/etc/security/otacerts.zip*, is used.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [第 3 章](ch03.html "第 3 章. 包管理") 中所学，OTA 包是经过代码签名的，签名覆盖整个文件（与 JAR 和 APK
    文件不同，后者为归档中的每个文件都包含单独的签名）。当从主 Android 操作系统启动 OTA 过程时，首先使用 `RecoverySystem` 类的
    `verifyPackage()` 方法验证 OTA 包（ZIP 文件）。该方法接收 OTA 包的路径和一个包含允许签署 OTA 更新的 X.509 证书列表的
    ZIP 文件作为参数。如果 OTA 包是使用与 ZIP 文件中任何证书对应的私钥签署的，则该 OTA 被视为有效，并且系统会重启进入恢复模式以应用该更新。如果未指定证书
    ZIP 文件，则使用系统默认值 */system/etc/security/otacerts.zip*。
- en: The recovery verifies the OTA package that it is instructed to apply independently
    of the main OS in order to ensure that the OTA package has not been replaced before
    starting the recovery. The verification is performed with a set of public keys
    built into the recovery image. When building the recovery, these keys are extracted
    from the specified set of OTA signing certificates, converted to mincrypt format
    using the `DumpPublicKey` tool, and written to the */res/keys* file. When RSA
    is used as the signature algorithm, the keys are mincrypt’s `RSAPublicKey` structures,
    serialized as C literals (as they would appear in a C source file), optionally
    preceded by a version identifier that specifies the hash used when signing the
    OTA package and the RSA key public exponent of the key. The *keys* file may look
    like [Example 13-4](ch13.html#contents_of_the_solidusressoliduskeys_fi "Example 13-4. Contents
    of the /res/keys file in the recovery OS").
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复程序验证它将应用的 OTA 包，而无需依赖主操作系统，以确保在启动恢复之前 OTA 包没有被替换。验证通过一组内置在恢复映像中的公钥来执行。在构建恢复时，这些密钥从指定的
    OTA 签名证书集中提取，使用 `DumpPublicKey` 工具转换为 mincrypt 格式，并写入到 */res/keys* 文件中。当使用 RSA
    作为签名算法时，这些密钥是 mincrypt 的 `RSAPublicKey` 结构，序列化为 C 字面量（如同在 C 源文件中出现的形式），可选择性地前面加上版本标识符，该标识符指定在签署
    OTA 包时使用的哈希以及 RSA 密钥的公共指数。*keys* 文件可能如下所示：[示例 13-4](ch13.html#contents_of_the_solidusressoliduskeys_fi
    "示例 13-4. 恢复操作系统中 /res/keys 文件的内容")。
- en: Example 13-4. Contents of the /res/keys file in the recovery OS
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-4. 恢复操作系统中 /res/keys 文件的内容
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the first line ➊ is a serialized version 1 key (implicit if a version
    identifier is not specified), which has a public exponent *e=3* and can be used
    to verify signatures created using SHA-1; the second line ➋ contains a version
    2 key that has a public exponent *e=65537* and is also used with SHA-1 signatures.
    The currently supported signature algorithms are 2048-bit RSA with SHA-1 (key
    versions 1 and 2) or SHA-256 (key versions 3 and 4), and ECDSA with SHA-256 (key
    version 5, available in AOSP’s mater branch) and 256-bit EC keys using the NIST
    P-256 curve.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第一行 ➊ 是一个序列化的版本 1 密钥（如果未指定版本标识符，则隐式使用该版本），该密钥具有公共指数 *e=3*，可以用于验证使用 SHA-1
    创建的签名；第二行 ➋ 包含一个版本 2 密钥，具有公共指数 *e=65537*，也用于 SHA-1 签名。当前支持的签名算法有 2048 位 RSA 配合
    SHA-1（密钥版本 1 和 2）或 SHA-256（密钥版本 3 和 4），以及 ECDSA 配合 SHA-256（密钥版本 5，AOSP 的 master
    分支可用）和使用 NIST P-256 曲线的 256 位 EC 密钥。
- en: Starting the System Update Process
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动系统更新过程
- en: If the signature of the OTA package verifies, the recovery applies the system
    update by executing the update command included in the OTA file. The update command
    is saved in the *META-INF/com/google/android/* directory of the recovery image
    as `update-binary` ➊, as shown in [Example 13-5](ch13.html#contents_of_a_system_update_ota_package
    "Example 13-5. Contents of a system update OTA package").
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 OTA 包的签名验证通过，恢复程序通过执行 OTA 文件中包含的更新命令来应用系统更新。更新命令保存在恢复映像的 *META-INF/com/google/android/*
    目录下，文件名为 `update-binary` ➊，如 [示例 13-5](ch13.html#contents_of_a_system_update_ota_package
    "示例 13-5. 系统更新 OTA 包的内容") 中所示。
- en: Example 13-5. Contents of a system update OTA package
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-5. 系统更新 OTA 包的内容
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The recovery extracts `update-binary` from the OTA file to */tmp/update_binary*
    and starts it, passing it three parameters: the recovery API version (version
    3 as of this writing); the file descriptor of a pipe that `update-binary` uses
    to communicate progress and messages back to the recovery; and the path to the
    OTA package. The *update-binary* process in turn extracts the updater script,
    included as *META-INF/com/google/android/updater-script* ➋ in the OTA package,
    and evaluates it. The updater script is written in a dedicated scripting language
    called *edify* (since version 1.6; previous versions used an older variant called
    *amend*). The edify language supports simple control structures such as `if` and
    `else`, and is extensible via functions, which can also act as control structures
    (by deciding which of their arguments to evaluate). The updater script includes
    a sequence of function calls that trigger the operations necessary to apply the
    update.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复过程从OTA文件中提取`update-binary`到*/tmp/update_binary*并启动它，传递三个参数：恢复API版本（截至本文写作时为版本3）；`update-binary`用于与恢复进程通信的管道文件描述符；以及OTA包的路径。然后，*update-binary*进程提取更新脚本，该脚本作为*META-INF/com/google/android/updater-script*
    ➋包含在OTA包中，并执行它。更新脚本使用一种名为*edify*的专用脚本语言编写（自1.6版本起；以前的版本使用旧的变种，称为*amend*）。edify语言支持简单的控制结构，如`if`和`else`，并且可以通过函数扩展，这些函数也可以充当控制结构（通过决定评估哪些参数）。更新脚本包含一系列函数调用，触发应用更新所需的操作。
- en: Applying the Update
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用更新
- en: The edify implementation defines and registers various functions that are used
    for copying, deleting, and patching files; formatting and mounting volumes; setting
    file permissions and SELinux labels; and more. [Table 13-2](ch13.html#summary_of_important_edify_functions
    "Table 13-2. Summary of Important edify Functions") shows a summary of the most
    often used edify functions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: edify实现定义并注册了用于复制、删除和修补文件；格式化和挂载卷；设置文件权限和SELinux标签等操作的各种函数。[表13-2](ch13.html#summary_of_important_edify_functions
    "表13-2. 重要edify函数摘要")展示了最常用的edify函数的摘要。
- en: Table 13-2. Summary of Important edify Functions
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表13-2. 重要edify函数摘要
- en: '| Function Name | Description |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 函数名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `abort` | Aborts the install process with an error message. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `abort` | 以错误信息中止安装过程。 |'
- en: '| `apply_patch` | Safely applies a binary patch. Ensures that the patched file
    has the expected hash value, before replacing the original. Can also patch disk
    partitions. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `apply_patch` | 安全地应用二进制补丁。在替换原始文件之前，确保补丁文件具有预期的哈希值。也可以修补磁盘分区。 |'
- en: '| `apply_patch_check` | Checks if a file has the specified hash value. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `apply_patch_check` | 检查文件是否具有指定的哈希值。 |'
- en: '| `assert` | Checks if a condition is true. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `assert` | 检查条件是否为真。 |'
- en: '| `delete/delete_recursive` | Deletes a file/all files in a directory. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `delete/delete_recursive` | 删除文件/目录中的所有文件。 |'
- en: '| `file_getprop` | Gets a system property from the specified property file.
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `file_getprop` | 从指定的属性文件中获取系统属性。 |'
- en: '| `format` | Formats a volume with the specified filesystem. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `format` | 使用指定的文件系统格式化一个卷。 |'
- en: '| `getprop` | Gets a system property. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `getprop` | 获取系统属性。 |'
- en: '| `mount` | Mounts a volume at the specified path. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `mount` | 将一个卷挂载到指定路径。 |'
- en: '| `package_extract_dir` | Extracts the specified ZIP directory to a path on
    the filesystem. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `package_extract_dir` | 将指定的ZIP目录提取到文件系统的路径。 |'
- en: '| `package_extract_file` | Extracts the specified ZIP file to a path on the
    filesystem or returns it as a blob. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `package_extract_file` | 将指定的ZIP文件提取到文件系统的路径，或将其作为二进制数据返回。 |'
- en: '| `run_program` | Executes the specified program in a subprocess and waits
    for it to finish. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `run_program` | 在子进程中执行指定程序，并等待其完成。 |'
- en: '| `set_metadata/set_metadata_recursive` | Sets the owner, group, permission
    bits, file capabilities, and SELinux label on file/all files in a directory. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `set_metadata/set_metadata_recursive` | 设置文件/目录中所有文件的所有者、组、权限位、文件功能和SELinux标签。
    |'
- en: '| `show_progress` | Reports back progress to the parent process. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `show_progress` | 向父进程报告进度。 |'
- en: '| `symlink` | Creates a symbolic link(s) to a target, deleting existing symbolic
    link files first. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `symlink` | 创建指向目标的符号链接，首先删除现有的符号链接文件。 |'
- en: '| `ui_print` | Sends a message back to the parent process. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `ui_print` | 向父进程发送一条消息。 |'
- en: '| `umount` | Unmounts a mounted volume. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `umount` | 卸载一个已挂载的卷。 |'
- en: '| `write_raw_image` | Writes a raw image to the specified disk partition. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `write_raw_image` | 将原始镜像写入指定的磁盘分区。 |'
- en: '[Example 13-6](ch13.html#contents_of_updater-script_in_a_full_sys "Example 13-6. Contents
    of updater-script in a full system update OTA package") shows the (abbreviated)
    contents of a typical system update edify script.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-6](ch13.html#contents_of_updater-script_in_a_full_sys "示例 13-6。完整系统更新
    OTA 包中的 updater-script 内容") 展示了一个典型的系统更新 edify 脚本的（简略）内容。'
- en: Example 13-6. Contents of updater-script in a full system update OTA package
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-6。完整系统更新 OTA 包中的 updater-script 内容
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Copying and Patching Files
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制和修补文件
- en: The updater script first mounts the *system* partition, then checks to see if
    the device model and its current build are what it expects ➊. This check is required
    because trying to install a system update over an incompatible build can leave
    a device in an unusable state. (This is often called a “soft brick,” because it
    can usually be recovered by reflashing all partitions with a working build; a
    “hard brick” cannot be recovered.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: updater 脚本首先挂载 *system* 分区，然后检查设备型号及其当前构建是否符合预期 ➊。此检查是必需的，因为试图在不兼容的构建上安装系统更新可能会导致设备无法使用。（这通常被称为“软砖”，因为通常可以通过重新刷写所有分区并使用有效的构建恢复；而“硬砖”是无法恢复的。）
- en: Because an OTA update usually does not contain complete system files, only binary
    patches against the previous version of each changed file (produced using `bsdiff`),^([[140](#ftn.ch13fn04)])
    applying an update can succeed only if each file-to-be-patched is the same as
    the one used to produce the respective patch. To ensure this, the updater script
    checks that the hash value of each file-to-be-patched is one it expects using
    the `apply_patch_check` function ➋.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 OTA 更新通常不包含完整的系统文件，而只是对每个已更改文件的前一版本进行二进制补丁（使用 `bsdiff` 生成），^([[140](#ftn.ch13fn04)])
    所以只有在每个待修补的文件与生成相应补丁时所使用的文件一致的情况下，更新才能成功。为确保这一点，updater 脚本使用 `apply_patch_check`
    函数 ➋ 检查每个待修补文件的哈希值是否符合预期。
- en: In addition to system files, the update process also patches partitions that
    don’t contain a filesystem, such as the *boot* and *modem* partitions. To guarantee
    that patching such partitions will succeed, the updater script checks the contents
    of target partitions as well and aborts if they are not in the expected state
    ➌. When all system files and partitions have been verified, the updater script
    deletes unnecessary files, as well as files that will be replaced completely instead
    of being patched ➍. The script then goes on to patch all system files ➎ and partitions
    ➏. It then removes any previous recovery patches and unpacks the new recovery
    in */system/* ➐.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 除了系统文件外，更新过程还会修补不包含文件系统的分区，如 *boot* 和 *modem* 分区。为了确保修补这些分区能成功，updater 脚本还会检查目标分区的内容，如果它们不处于预期状态则会中止
    ➌。验证完所有系统文件和分区后，updater 脚本会删除不必要的文件，以及那些将完全替换而不是修补的文件 ➍。接着，脚本会修补所有系统文件 ➎ 和分区 ➏。然后，它会删除任何先前的恢复补丁，并将新的恢复环境解包到
    */system/* ➐。
- en: Setting File Ownership, Permissions, and Security Labels
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置文件所有权、权限和安全标签
- en: The next step is to set the user, owner, permissions, and file capabilities
    of all created or patched files and directories using the `set_metadata_recursive`
    function ➑. As of version 4.3, Android supports SELinux (see [Chapter 12](ch12.html
    "Chapter 12. Selinux")), so all files must be properly labeled in order for access
    rules to be effective. That is why the `set_metadata_recursive` function has been
    extended to set the SELinux security label (the last parameter, *u:object_r:system_file:s0*
    in ➑) of files and directories.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用 `set_metadata_recursive` 函数 ➑ 设置所有创建或修补的文件和目录的用户、所有者、权限以及文件能力。从版本 4.3
    开始，Android 支持 SELinux（见 [第 12 章](ch12.html "第 12 章。Selinux")），因此所有文件必须正确标记，以便访问规则生效。这就是为什么
    `set_metadata_recursive` 函数被扩展以设置文件和目录的 SELinux 安全标签（➑ 中的最后一个参数，*u:object_r:system_file:s0*）。
- en: Finishing the Update
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成更新
- en: Next, the updater script patches the device’s baseband software ➒, which is
    typically stored in the *modem* partition. The final step of the script is to
    unmount the system partition➓.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，updater 脚本修补设备的基带软件 ➒，基带软件通常存储在 *modem* 分区。脚本的最后一步是卸载系统分区 ➓。
- en: After the *update-binary* process exits, the recovery wipes the cache partition
    if it was started with the `–wipe_cache` option and copies the execution logs
    to */cache/recovery/* so that they are accessible from the main OS. Finally, if
    no errors are reported, the recovery clears the BCB and reboots into the main
    OS.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在*update-binary*进程退出后，如果使用了`–wipe_cache`选项启动恢复操作系统，恢复会擦除缓存分区，并将执行日志复制到*/cache/recovery/*，以便从主操作系统访问。最后，如果没有报告错误，恢复操作系统会清除BCB并重启到主操作系统。
- en: If the update process is aborted due to an error, the recovery reports this
    to the user, and prompts them to reboot the device in order to try again. Because
    the BCB has not been cleared, the device automatically reboots in recovery mode,
    and the update process is started from scratch.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更新过程由于错误中止，恢复操作系统会向用户报告此错误，并提示用户重启设备以重新尝试。由于BCB未被清除，设备会自动以恢复模式重启，并从头开始更新过程。
- en: Updating the Recovery
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新恢复操作系统
- en: If you examine the entire updater script in [Example 13-6](ch13.html#contents_of_updater-script_in_a_full_sys
    "Example 13-6. Contents of updater-script in a full system update OTA package")
    in detail, you’ll notice that while it patches the *boot* ➏ and *modem* ➒ partitions
    and unpacks a patch for the *recovery* partition ➐ (which hosts the recovery OS),
    it does not apply the unpacked patch. This is by design. Because an update can
    be interrupted at any moment, the update process needs to be restarted from the
    same state the next time the device is powered on. If, for example, power is interrupted
    while writing to the *recovery* partition, updating the recovery OS would change
    that initial state and might leave the system in an unusable condition. Therefore,
    the recovery OS is updated from the main OS only when the main OS update has completed
    and the main OS boots successfully.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你详细查看[示例 13-6](ch13.html#contents_of_updater-script_in_a_full_sys "示例 13-6.
    完整系统更新OTA包中的updater-script内容")中的整个更新脚本，你会注意到，尽管它会修补*boot* ➏和*modem* ➒分区，并为*recovery*分区
    ➐（用于恢复操作系统）解压补丁，但它并不会应用解压后的补丁。这是设计使然。因为更新过程可能随时被中断，因此更新过程需要在设备下次开机时从相同的状态重新开始。例如，如果在写入*recovery*分区时电源中断，更新恢复操作系统会改变初始状态，可能会导致系统处于不可用的状态。因此，恢复操作系统仅在主操作系统更新完成且主操作系统成功启动后才会进行更新。
- en: The update is triggered by the *flash_recovery* service in Android’s *init.rc*
    file, as shown in [Example 13-7](ch13.html#definition_of_the_flashunderscorerecover
    "Example 13-7. Definition of the flash_recovery service in init.rc").
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 更新由Android的*init.rc*文件中的*flash_recovery*服务触发，如[示例 13-7](ch13.html#definition_of_the_flashunderscorerecover
    "示例 13-7. init.rc中flash_recovery服务的定义")所示。
- en: Example 13-7. Definition of the flash_recovery *service in* init.rc
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-7. flash_recovery *服务在* init.rc中的定义
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, this service simply starts the */system/etc/install-recovery.sh*
    shell script ➊. The shell script, along with a patch file for the recovery partition,
    is copied by the OTA updater script (➐ in [Example 13-6](ch13.html#contents_of_updater-script_in_a_full_sys
    "Example 13-6. Contents of updater-script in a full system update OTA package"))
    if the recovery requires an update. The contents of *install-recovery.sh* might
    look like [Example 13-8](ch13.html#contents_of_install-recoverydotsh "Example 13-8. Contents
    of install-recovery.sh").
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个服务仅仅是启动*/system/etc/install-recovery.sh* shell脚本 ➊。如果恢复需要更新，OTA更新脚本会将这个shell脚本及恢复分区的补丁文件（见[示例 13-6](ch13.html#contents_of_updater-script_in_a_full_sys
    "示例 13-6. 完整系统更新OTA包中的updater-script内容")中的➐）复制到设备中。*install-recovery.sh*的内容可能如[示例 13-8](ch13.html#contents_of_install-recoverydotsh
    "示例 13-8. install-recovery.sh的内容")所示。
- en: Example 13-8. Contents of install-recovery.sh
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-8. install-recovery.sh的内容
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The script uses the `applypatch` command to check whether the recovery OS needs
    to be patched by checking the hash value of the *recovery* partition ➊. If the
    hash of the device’s *recovery* partition matches the hash of the version against
    which the patch was created, the script applies the patch ➋. If the recovery has
    already been updated or has an unknown hash, the script logs a message and exits
    ➌.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本使用`applypatch`命令通过检查*recovery*分区的哈希值来判断恢复操作系统是否需要打补丁 ➊。如果设备的*recovery*分区的哈希值与创建补丁时所用版本的哈希值匹配，脚本将应用补丁
    ➋。如果恢复分区已经更新或哈希值未知，脚本将记录一条消息并退出 ➌。
- en: Custom Recoveries
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义恢复
- en: A custom recovery is a recovery OS build created by a third party (not the device
    manufacturer). Because it is created by a third party, a custom recovery is not
    signed with the manufacturer’s keys, and therefore a device’s bootloader needs
    to be unlocked in order to boot or flash it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: A custom recovery can be booted without installing it on the device with the
    `fastboot boot` *`custom-recovery.img`* command, or it may be permanently flashed
    using the `fastboot flash recovery` *`custom-recovery.img`* command.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: A custom recovery provides advanced functionality that is typically not available
    in stock recoveries, such as full partition backup and restore, a root shell with
    a full set of device management utilities, support for mounting external USB devices,
    and so on. A custom recovery can also disable OTA package signature checking,
    which allows for installing third-party OS builds or modification, such as framework
    or theme customizations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Various custom recoveries are available, but as of this writing, by far the
    most full-featured and actively maintained is the Team Win Recovery Project (TWRP).^([[141](#ftn.ch13fn05)])
    It is based on the AOSP stock recovery and is also an open source project.^([[142](#ftn.ch13fn06)])
    TWRP has a theme-able, touch screen interface that is very similar to the native
    Android UI. It supports encrypted partition backups, installing system updates
    from USB devices, and backup and restore to/from external devices, and it has
    an integrated file manager. The startup screen of TWRP version 2.7 is shown in
    [Figure 13-5](ch13.html#twrp_recovery_startup_screen "Figure 13-5. TWRP recovery
    startup screen").
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![TWRP recovery startup screen](figs/web/13fig05.png.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: Figure 13-5. TWRP recovery startup screen
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Like the stock AOSP recovery, custom recoveries can be controlled from the main
    OS. In addition to passing parameters via the */cache/recovery/ command* file,
    custom recoveries usually allow some (or all) of their extended features to be
    triggered from the main OS. For example, TWRP supports a minimal scripting language,
    which describes what recovery actions should be executed upon booting the recovery.
    This allows Android apps to queue recovery commands via a convenient GUI interface.
    For example, requesting a compressed backup of the *boot*, *userdata*, and *system*
    partitions generates the script shown in [Example 13-9](ch13.html#twrp_backup_script_example
    "Example 13-9. TWRP backup script example").
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-9. TWRP backup script example
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Warning
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Permanently flashing a custom recovery that has an option to ignore OTA package
    signatures might allow the system software of your device to be replaced and back-doored
    given brief physical access to the devices. Therefore, it is not recommended to
    flash a custom recovery on a device you use daily and which stores personal or
    sensitive information.*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Root Access
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android’s security model applies the principle of least privilege and strives
    to isolate system and app processes from each other by running each process as
    a dedicated user. However, Android is also based on a Linux kernel, which implements
    a standard Unix-style DAC (unless SELinux is enabled; see [Chapter 12](ch12.html
    "Chapter 12. Selinux")).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Android 的安全模型应用了最小权限原则，并通过将每个进程作为一个独立的用户来努力将系统和应用进程彼此隔离。然而，Android 也基于 Linux
    内核，后者实现了标准的 Unix 风格的 DAC（除非启用了 SELinux；请参见 [第12章](ch12.html "第12章。Selinux")）。
- en: One of the greatest shortcomings of this DAC security model is that a certain
    system user, typically called *root* (UID=0), also known as the *superuser*, is
    given absolute power over the system. Root can read, write, and change the permission
    bits of any file or directory; kill any process; mount and unmount volumes; and
    so on. While such unconstrained permissions are necessary for managing a traditional
    Linux system, having superuser access on an Android device allows one to effectively
    bypass Android’s sandbox, and read or write the private files of any application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 DAC 安全模型的最大缺点之一是，某个系统用户，通常称为 *root*（UID=0），也被称为 *超级用户*，被授予对系统的绝对控制权限。Root
    可以读取、写入并更改任何文件或目录的权限位；杀死任何进程；挂载和卸载卷；等等。尽管这种不受限制的权限对于管理传统的 Linux 系统是必要的，但在 Android
    设备上拥有超级用户权限，意味着可以有效绕过 Android 的沙盒，并读取或写入任何应用程序的私密文件。
- en: Root access also allows changing the system configuration by modifying partitions
    that are designed to be read-only, starting or stopping system services at will,
    and removing or disabling core system applications. This can adversely affect
    the stability of a device, or even render it unusable, which is why root access
    is typically not allowed on production devices.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Root 权限还允许通过修改本应为只读的分区、更改系统配置、随意启动或停止系统服务、以及删除或禁用核心系统应用程序。这可能会对设备的稳定性产生不利影响，甚至导致设备无法使用，这也是为什么生产设备通常不允许
    root 权限的原因。
- en: Furthermore, Android tries to limit the number of system processes that execute
    as root, because a programming error in any such process can open the doors to
    privilege escalation attacks, which could result in third-party applications gaining
    root access. With the deployment of SELinux in enforcing mode, processes are limited
    by the global security policy, and therefore compromising a root process does
    not necessarily grant unrestricted access to a device but could still allow access
    to sensitive data or allow modifying system behavior. Additionally, even a process
    constrained by SELinux could exploit a kernel vulnerability in order to circumvent
    the security policy or otherwise obtain unrestricted root access.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Android 尝试限制以 root 权限执行的系统进程数量，因为任何此类进程中的编程错误都可能导致权限提升攻击，进而使第三方应用程序获得 root
    权限。通过在强制模式下部署 SELinux，进程受到全局安全策略的限制，因此，即使破解了 root 进程，也不一定能获得对设备的无限制访问权限，但仍可能访问敏感数据或修改系统行为。此外，即使进程受到
    SELinux 限制，也有可能通过利用内核漏洞绕过安全策略，或以其他方式获得无限制的 root 权限。
- en: With all that said, root access could be very convenient for debugging or reverse
    engineering applications on development devices. Additionally, while allowing
    root access to third-party applications does compromise Android’s security model,
    it also allows various system customizations that are typically not available
    on production devices to be performed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，root 权限对于在开发设备上调试或逆向工程应用程序来说是非常方便的。此外，虽然允许第三方应用程序获得 root 权限会破坏 Android
    的安全模型，但它也允许进行一些通常在生产设备上无法执行的系统定制。
- en: Because one of Android’s biggest selling points has always been its ease of
    customization, the demand for ever greater flexibility via modifying the core
    OS (also called *modding*), has always been high, especially during Android’s
    early years. Besides customizing the system, having root access on an Android
    device allows for the implementation of applications that are not possible without
    modifying the framework and adding system services, such as firewalls, full device
    backup, network sharing, and so on.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Android 的一个最大卖点一直是其易于定制性，用户对通过修改核心操作系统（也称为 *modding*）获得更大灵活性的需求一直很高，尤其是在
    Android 的早期。除了定制系统外，获得 Android 设备的 root 权限还可以实现一些在不修改框架和添加系统服务的情况下无法实现的应用程序，例如防火墙、完整设备备份、网络共享等。
- en: In the following sections, we describe how root access is implemented in development
    (engineering) Android builds and custom Android builds (ROMs), and how it can
    be added to production builds. We then show how apps that require superuser access
    (typically called *root apps*) can request and use root privileges in order to
    execute processes as root.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Root Access on Engineering Builds
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android’s build system can produce several build variants for a particular device
    that differ by the number of applications and utilities included, as well as by
    the values of several key system properties that modify system behavior. Some
    of these build variants allow root access from the Android shell, as we’ll show
    in the following sections.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Starting ADB as Root
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Commercial devices use the *user* build variant (the current build variant is
    set as the value of the *ro.build.type* system property), which doesn’t include
    diagnostics and development tools, disables the ADB daemon by default, disallows
    debugging of applications that don’t explicitly set the `debuggable` attribute
    to `true` in their manifests, and disallows root access via the shell. The *userdebug*
    build variant is very close to *user*, but it also includes some additional modules
    (those with the *debug* module tag), allows debugging of all apps, and enables
    ADB by default.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Engineering, or *eng*, builds include most available modules, allow debugging,
    enable ADB by default, and set the *ro.secure* system property to 0, which changes
    the behavior of the ADB daemon running on a device. When set to 1 (secure mode),
    the *adbd* process, which initially runs as root, drops all capabilities from
    its capability bounding set with the exception of `CAP_SETUID` and `CAP_SETGID`
    (which are required to implement the `run-as` utility). It then adds several supplementary
    GIDs that are required to access network interfaces, external storage, and system
    logs, and finally changes its UID and GID to `AID_SHELL` (UID=2000). On the other
    hand, when *ro.secure* is set to 0 (the default for engineering builds), the *adbd*
    daemon continues to run as root and has the full capability bounding set. [Example 13-10](ch13.html#adbd_process_details_on_a_user_build
    "Example 13-10. adbd process details on a user build") shows the process IDs and
    capabilities for the *adbd* process on a *user* build.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-10. adbd process details on a user build
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the process’s UID ➊ and GID ➋ are both set to 2000 (`AID_SHELL`),
    and the *adbd* process has a number of supplementary GIDs added ➌. Finally, the
    process’s capability bounding set, which determines what capabilities child processes
    are allowed, is set to 0x0000000c0 (`CAP_SETUID|CAP_SETGID`) ➍. This capability
    setting guarantees that, on *user* builds, processes started from Android’s shell
    are limited to the `CAP_SETUID` and `CAP_SETGID` capabilities, even if the executed
    binary has the SUID bit set, or its file capabilities permit additional privileges.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, on an *eng* or *userdebug* build, the ADB daemon can execute as
    root, as shown in [Example 13-11](ch13.html#adbd_process_details_on_an_eng_build
    "Example 13-11. adbd process details on an eng build").
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-11. adbd process details on an eng build
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, the *adbd* process runs with UID ➌ and GID ➍ 0 (root), has no supplementary
    groups ➎, and has the full set of Linux capabilities (➏, ➐, and ➑). However, as
    you can see at ➋, the *ro.secure* system property is set to 1, which suggests
    that *adbd* should not be running as root.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: While the ADB daemon does drop its root privileges on *userdebug* builds (as
    in this example, ➊), it can be manually restarted in insecure mode by issuing
    the `adb root` command from a host, as shown in [Example 13-12](ch13.html#restarting_adbd_as_root_on_userdebug_bui
    "Example 13-12. Restarting adbd as root on userdebug builds").
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-12. Restarting adbd *as root on* userdebug *builds*
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the *adbd* daemon is initially running as *shell* (UID=2000), and any
    shells started from the host also have UID=2000 and GID=2000 ➊. Issuing the `adb
    root` command ➋ (which internally sets the *service.adb.root* system property
    to 1) restarts the ADB daemon as root ➌, and any subsequently started shells have
    UID and GUID=0 ➍.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Because this particular device has SELinux enabled, even though the UID and
    GID of the shell change, its security context (security label) stays the same:*
    u:r:shell:s0 *in both* ➊ *and* ➍*. Therefore, even after obtaining a root shell
    via ADB, all processes started from the shell are still bound by the permissions
    granted to the* shell *domain (unless allowed to transition to another domain
    by the MAC policy; see [Chapter 12](ch12.html "Chapter 12. Selinux") for details).
    In practice, as of Android 4.4, the* shell *domain is unconfined, so when running
    as root, processes in this domain are allowed almost full control over the device.*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Using the su Command
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On *userdebug* builds, root access can also be obtained without restarting ADB
    as root. This can be accomplished using the `su` (short for *substitute user*,
    also referred to as *switch user* and *superuser*) command, which is installed
    with the SUID bit set, thus allowing calling processes to obtain a root shell
    or execute a command as the specified UID (including UID=0). The default `su`
    implementation is very basic and only allows the *root* and *shell* users to use
    it, as shown in [Example 13-13](ch13.html#default_su_implementation_for_userdebug
    "Example 13-13. Default su implementation for userdebug builds").
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-13. Default *`su` implementation for* userdebug *builds*
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The main function first checks whether the calling UID is `AID_ROOT` (0) or
    `AID_SHELL` (2000) ➊, and exits if called by a user with a different UID. It then
    sets the process UID and GID to 0 (➋ and ➌), and finally starts the Android shell
    ➍. Any commands executed from this shell inherit its privileges by default, thus
    allowing superuser access to the device.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Root Access on Production Builds
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned in “[Root Access on Engineering Builds](ch13.html#root_access_on_engineering_builds
    "Root Access on Engineering Builds")”, commercial Android devices are usually
    based on the *user* build variant. This means that the ADB daemon is running as
    the *shell* user, and no `su` command is installed on the device.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: This is a secure configuration, and most users should be able to achieve their
    device configuration and customization tasks with the tools provided by the platform,
    or with third-party applications such as custom launchers, keyboards, or VPN clients.
    However, operations that modify the look and feel or core configuration of Android
    are not possible, and neither is low-level access to the underlying Linux OS.
    Such operations can only be performed by running certain commands with root privileges,
    which is why many power users seek to enable root access on their devices.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining root access on an Android device is commonly known as *rooting* and
    can be fairly simple on devices that have an unlockable bootloader or nearly impossible
    on devices that don’t allow bootloader unlocking and take additional measures
    to prevent system partition modifications. In the next sections, we describe the
    typical rooting process and introduce some of the most popular “superuser” apps
    that enable and manage root access.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Rooting by Changing the boot or system Image
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On some Android devices, given an unlocked bootloader, a *user* build can easily
    be turned into an engineering or *userdebug* build by simply flashing a new boot
    image (often called a *kernel*, or *custom kernel*), which changes the values
    of the *ro.secure* and *ro.debuggable* system properties. Changing these properties
    allows the ADB daemon to execute as root and enables root access via the Android
    shell, as described in“[Root Access on Engineering Builds](ch13.html#root_access_on_engineering_builds
    "Root Access on Engineering Builds")”. However, most current Android *user* builds
    disable this behavior at compile time (by not defining the `ALLOW_ADBD_ROOT` macro)
    and the values of the *ro.secure* and *ro.debuggable* system properties are ignored
    by the *adbd* daemon.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Another way to enable root access is to unpack the system image, add a SUID
    `su` binary or a similar utility, and overwrite the *system* partition with the
    new system image. This would typically allow root access not only from the shell,
    but from third-party applications as well. However, several security enhancements
    in Android 4.3^([[143](#ftn.ch13fn07)]) and later versions disallow apps from
    executing SUID programs by dropping all capabilities from the bounding set of
    Zygote-spawned processes, and mounting the *system* partition with the `nosetuid`
    flag.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, on Android versions that set SELinux to enforcing mode, executing
    a process with root privileges does not typically change its security context,
    and such a process is still limited by the MAC policy. For these reasons, enabling
    root access on a recent Android version may not be as simple as changing a few
    system properties or copying a SUID binary to the device. Of course, replacing
    the *boot* or *system* image allows SELinux to be disabled and any security mitigation
    to be reverted, thus relaxing the device’s security level and enabling root access.
    However, such a radical approach is not unlike replacing the whole OS and may
    prevent the device from receiving system updates from the device manufacturer.
    This is undesirable in most cases, and several root methods that try to coexist
    with the stock OS of the device have been developed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Rooting by Flashing an OTA Package
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An OTA package can add or modify system files, without replacing the whole OS
    image, and is therefore a good candidate for adding root access to a device. Most
    popular superuser apps are distributed as a combination of an OTA package, which
    needs to be installed once, and a companion manager application, which can be
    updated online.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: SuperSU
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll use the SuperSU OTA package ^([[144](#ftn.ch13fn08)]) and app ^([[145](#ftn.ch13fn09)])
    (developed by Jorrit “Chainfire” Jongma) to demonstrate how this approach works.
    SuperSU is currently the most popular superuser application and is actively maintained,
    keeping in step with the latest modifications to the Android platform. The SuperSU
    OTA package is similar in structure to a full system update package but contains
    only a small number of files, as shown in [Example 13-14](ch13.html#contents_of_the_supersu_ota_package
    "Example 13-14. Contents of the SuperSU OTA package").
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-14. Contents of the SuperSU OTA package
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The package contains a few native binaries compiled for the ARM ➊ and x86 ➐
    platforms, scripts for starting and installing the SuperSU daemon (➋ and ➌), the
    APK file of the management GUI application ➍, and two updater scripts (➎ and ➏)
    that apply the OTA package.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand how SuperSU enables root access, we need to first examine
    its install process. To do so, let’s analyze the contents of the `update-binary`
    script ➎, shown in [Example 13-15](ch13.html#supersu_ota_install_script "Example 13-15. SuperSU
    OTA install script"). (SuperSU uses a regular shell script instead of a native
    binary, so `updater-script` is simply a placeholder.)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-15. SuperSU OTA install script
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The update script first mounts the *rootfs* filesystem and the *system* and
    *userdata* partitions in read-write mode ➊, and then it extracts ➋ and copies
    the included files to their intended locations on the filesystem. The `su` and
    `daemonsu` native binaries ➌ are copied to */system/xbin/*, which is the usual
    location of extra native binaries (binaries that are not necessary for running
    the Android OS). The root access management application is copied to */system/app/*
    ➍ and is automatically installed by the package manager when the device reboots.
    Next, the update script copies the *install-recovery.sh* script to */system/etc/*
    ➎.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*As discussed in “[Updating the Recovery](ch13.html#updating_the_recovery "Updating
    the Recovery")”, this script is typically used to update the recovery image from
    the main OS, so you might be wondering why the SuperSU install is trying to update
    the recovery of the device. SuperSU uses this script to start some of its components
    at boot time, which we’ll discuss shortly.*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The next step of the OTA package install process is to set the permissions ➏
    and SELinux security labels ➐ of the installed binaries (`ch_con` is a shell function
    that calls the `chcon` SELinux utility and sets the *u:object_r:system_file:s0*
    label). Finally, the script calls the `su` command with the `--install` option
    ➑ in order to perform some post-install initialization, and then unmounts */system*
    and */data* ➒. When the script exits successfully, the recovery reboots the device
    into the main Android OS.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: How SuperSU Is Initialized
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To understand how SuperSU is initialized, let’s look at the contents of the
    *install-recovery.sh* script (see [Example 13-16](ch13.html#contents_of_supersuapostrophes_install-r
    "Example 13-16. Contents of SuperSU’s install-recovery.sh script"), with comments
    omitted), which is automatically executed by `init` on boot.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-16. Contents of SuperSU’s install-recovery.sh *script*
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The script first executes the `daemonsu` binary ➊, which starts a daemon process
    with root privileges. The next step executes the *install-recovery-2.sh* script
    ➋, which may be used to perform additional initialization, necessary for other
    root apps. Using a daemon in order to allow apps to execute code with root privileges
    is required in Android 4.3 and later, because all apps (which are forked from
    *zygote*) have their capability bounding set zeroed out, thus preventing them
    from executing privileged operations, even if they manage to start a process as
    root. Additionally, as of Android 4.4, SELinux is in enforcing mode, so any processes
    started by an application inherit its security context (typically *untrusted_app*),
    and therefore are subject to the same MAC restrictions as the app itself.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: SuperSU gets around these security restrictions by having apps use the `su`
    binary to execute commands as root, which in turn pipes those commands via a Unix
    domain socket to the *daemonsu* daemon, which ultimately executes the received
    commands as root within the *u:r:init:s0* SELinux context. The processes in play
    are illustrated in [Example 13-17](ch13.html#processes_started_when_an_app_requests_r
    "Example 13-17. Processes started when an app requests root access via SuperSU").
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-17. Processes started when an app requests root access via SuperSU
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the `com.example.app` app ➏ (whose parent process is *zygote* ➋) requests
    root access by passing a command to the `su` binary using its `-c` option. As
    you can see, the `su` process ➑ executes as the same user (*u0_a292*, UID=10292)
    and in the same SELinux domain (*untrusted_app*) as the requesting app. However,
    the process ➒ of the command the app requested to be executed as root (`sleep`
    in this example) indeed executes as root in the *init* SELinux domain (security
    context *u:r:init:s0*). If we trace its parent PID (PPID, in the fourth column),
    we find that the *sleep* process is started by the *daemonsu:10292* process ➎,
    which is a *daemonsu* instance dedicated to our example app (with UID=10292).
    The *daemonsu:10292* process ➎ inherits its *init* SELinux domain from the *daemonsu:master*
    instance ➍, which is in turn started by the first *daemonsu* instance ➌. This
    is the instance started via the *install-recovery.sh* script (see [Example 13-16](ch13.html#contents_of_supersuapostrophes_install-r
    "Example 13-16. Contents of SuperSU’s install-recovery.sh script")), and it runs
    within the domain of its parent—the *init* process ➊ (PID=1).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The *eu.chainfire.supersu* process ➐ belongs to the SuperSU management application,
    which shows the root access grant dialog shown in [Figure 13-6](ch13.html#supersu_root_access_request_grant_dialog
    "Figure 13-6. SuperSU root access request grant dialog").
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![SuperSU root access request grant dialog](figs/web/13fig06.png.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: Figure 13-6. SuperSU root access request grant dialog
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Superuser access can be granted one time only, for a certain period of time,
    or permanently. SuperSU keeps an internal whitelist of apps that have been granted
    root access and does not show the grant dialog if the requesting app is already
    in the whitelist.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*SuperSU has a companion library,* libsuperuser,^([[146](#ftn.ch13fn10)]) *which
    makes it easier to write root apps by providing Java wrappers for the different
    patterns of calling the `su` binary. The author of SuperSU also provides a comprehensive
    guide to writing root apps called* How-To SU.^([[147](#ftn.ch13fn11)])'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Root Access on Custom ROMs
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Custom ROMs that provide root access don’t have to go through *install-recovery.sh*
    in order to start their superuser daemon (equivalent to SuperSU’s *daemonsu*)
    because they can customize the startup process at will. For example, the popular
    CyanogenMod open source Android distribution starts its *su* daemon from *init.superuser.rc*,
    as shown in [Example 13-18](ch13.html#startup_script_for_the_su_daemon_in_cyan
    "Example 13-18. Startup script for the su daemon in CyanogenMod").
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-18. Startup script for the su *daemon in CyanogenMod*
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This *init* script defines the *su_daemon* service ➊, which can be started or
    stopped by changing the value of the *persist.sys.root_access* persistent system
    property (➋ through ➎). The value of this property also determines whether root
    access should be granted only to apps, ADB shells, or both. Root access is disabled
    by default and can be configured via CyanogenMod’s Development options, as shown
    in [Figure 13-7](ch13.html#cyanogenmod_root_access_options "Figure 13-7. CyanogenMod
    root access options").
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*While SuperSU and custom ROMs that allow root access take certain measures
    to regulate what apps are allowed to execute commands as root (usually by adding
    them to a whitelist), an implementation flaw could allow apps to bypass these
    measures and obtain root access without user confirmation. Therefore, root access
    should be disabled on everyday-use devices and used only when necessary for development
    or debugging.*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![CyanogenMod root access options](figs/web/13fig07.png.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: Figure 13-7. CyanogenMod root access options
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Rooting via Exploits
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On production devices that don’t have an unlockable bootloader, root access
    can be obtained by exploiting a privilege escalation vulnerability, which allows
    an app or shell process to start a root shell (also called *soft root*) and modify
    the system. The exploits are typically packaged into “one-click” apps or scripts,
    which try to persist root access by installing a `su` binary or modifying system
    configuration. For example, the so-called towelroot exploit (which is distributed
    as an Android app) takes advantage of a vulnerability in the Linux kernel (CVE-2014-3153)
    to obtain root access and installs SuperSU in order to persist it. (Root access
    can also be persisted by overwriting the *recovery* partition with a custom recovery,
    thus allowing the installation of arbitrary software, including superuser applications.
    However, some devices have additional protections that prevent modifications to
    the *boot*, *system*, and *recovery* partitions, so permanent root access might
    not be possible.)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*See [Chapter 3](ch03.html "Chapter 3. Package Management") of the* Android
    Hacker’s Handbook *(Wiley, 2014) for a detailed description of the major privilege-escalation
    vulnerabilities that have been used to obtain root access in various Android versions.
    [Chapter 12](ch12.html "Chapter 12. Selinux") of the same book introduces the
    main exploit-mitigation techniques that have been implemented in Android in order
    to prevent privilege-escalation attacks and generally harden the system.*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to allow for updating the system software or returning a device to
    its factory state, Android devices allow unrestricted, low-level access to their
    storage via the bootloader. The bootloader typically implements a management protocol,
    usually fastboot, that allows for transferring and flashing partition images from
    a host machine. Bootloaders on production devices are usually locked and allow
    flashing only of signed images. However, most bootloaders can be unlocked, thus
    allowing flashing images from third parties.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Android uses a dedicated partition to store a second, minimal OS, called a recovery,
    which is used to apply OTA update packages or clear all data on the device. Like
    bootloaders, recoveries on production devices typically allow applying only those
    OTA packages signed by the device manufacturer. If the bootloader is unlocked,
    a custom recovery, which allows installing updates signed by third parties or
    completely forgoes signature verification, can be booted or permanently installed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Engineering or debug builds of Android allow root access via the Android shell,
    but root access is typically disabled on production devices. Root access on such
    devices can be enabled by installing a third-party OTA package that includes a
    “superuser” daemon and a companion application that allow controlled root access
    to applications. Third-party Android builds (ROMs) typically allow root access
    out of the box, although it can also be disabled via the system settings interface.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: ^([[137](#ch13fn01)]) Code Aurora Forum, “(L)ittle (K)ernel based Android bootloader,”
    *[https://www.codeaurora.org/blogs/little-kernel-based-android-bootloader/](https://www.codeaurora.org/blogs/little-kernel-based-android-bootloader/)*
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: ^([[138](#ch13fn02)]) Code Aurora Forum, *[https://www.codeaurora.org/cgit/quic/la/kernel/lk/](https://www.codeaurora.org/cgit/quic/la/kernel/lk/)*
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: ^([[139](#ch13fn03)]) Google, *Android Compatibility Definition*, *[https://static.googleusercontent.com/media/source.android.com/en//compatibility/android-cdd.pdf](https://static.googleusercontent.com/media/source.android.com/en//compatibility/android-cdd.pdf)*
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: ^([[140](#ch13fn04)]) Colin Percival, “Binary diff/patch utility,” *[http://www.daemonology.net/bsdiff/](http://www.daemonology.net/bsdiff/)*
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: ^([[141](#ch13fn05)]) TeamWin, “TWRP 2.7,” *[http://teamw.in/project/twrp2/](http://teamw.in/project/twrp2/)*
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: ^([[142](#ch13fn06)]) TeamWin, “Team Win Recovery Project (TWRP),” *[https://github.com/TeamWin/Team-Win-Recovery-Project/](https://github.com/TeamWin/Team-Win-Recovery-Project/)*
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: ^([[143](#ch13fn07)]) Google, “Security Enhancements in Android 4.3,” *[http://source.android.com/devices/tech/security/enhancements43.html](http://source.android.com/devices/tech/security/enhancements43.html)*
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: ^([[144](#ch13fn08)]) Jorrit “Chainfire” Jongma, “CF-Root download page,” *[http://download.chainfire.eu/supersu/](http://download.chainfire.eu/supersu/)*
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '^([[145](#ch13fn09)]) Jorrit “Chainfire” Jongma, “Google Play Apps: SuperSU,”
    *[https://play.google.com/store/apps/details?id=eu.chainfire.supersu&hl=en](https://play.google.com/store/apps/details?id=eu.chainfire.supersu&hl=en)*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: ^([[146](#ch13fn10)]) Jorrit “Chainfire” Jongma, libsuperuser, *[https://github.com/Chainfire/libsuperuser/](https://github.com/Chainfire/libsuperuser/)*
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: ^([[147](#ch13fn11)]) Jorrit “Chainfire” Jongma, “How-To SU Guidelines for problem-free
    su usage,” *[http://su.chainfire.eu/](http://su.chainfire.eu/)*
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
