- en: Chapter 13. System Updates and Root Access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapters, we introduced Android’s security model and discussed
    how integrating SELinux into Android has reinforced it. In this chapter, we take
    a bit of a right turn and introduce methods that can be used to circumvent Android’s
    security model.
  prefs: []
  type: TYPE_NORMAL
- en: In order to perform a full OS update or to restore the device to its factory
    state, it’s necessary to escape the security sandbox and gain full access to a
    device, because even the most privileged Android components are not given complete
    access to all system partitions and storage devices. Additionally, while having
    full administrative (root) access at runtime is clearly against Android’s security
    design, executing with root privileges can be useful in order to implement functionality
    not offered by Android, such as the addition of custom firewall rules or full
    (including system partitions) device backup. Indeed, the wide availability of
    custom Android builds (often called *ROMs*) and apps that allow users to extend
    or replace OS functionality using root access (commonly known as *root apps*)
    has been one of the reasons for Android’s success.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explore the design of Android’s bootloader and recovery
    OS, and show how they can be used to replace the system software of a device.
    We then show how root access is implemented on engineering builds and how Android
    production builds can be modified to allow executing code with superuser privileges
    by installing a “superuser” application. Finally, we discuss how custom Android
    distributions implement and control root access.
  prefs: []
  type: TYPE_NORMAL
- en: Bootloader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *bootloader* is a low-level program that is executed when a device is powered.
    Its main purpose is to initialize the hardware and find and start the main operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: As briefly discussed in [Chapter 10](ch10.html "Chapter 10. Device Security"),
    Android bootloaders are usually locked and only allow booting or installing an
    operating system image that has been signed by the device manufacturer. This is
    an important step in establishing a verified boot path, because it ensures that
    only trusted and unmodified system software can be installed on a device. However,
    while most users are not interested in modifying the core OS of their devices,
    installing a third-party Android build is a valid user choice and may even be
    the only way to run a recent version of Android on devices that have stopped receiving
    OS updates from their manufacturer. That is why most recent devices provide a
    way to unlock the bootloader and install third-party Android builds.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*While Android bootloaders are typically closed source, the bootloaders of
    most ARM devices based on Qualcomm SoCs are derived from the Little Kernel (LK)
    bootloader,*^([[137](#ftn.ch13fn01)]) *which is open source.*^([[138](#ftn.ch13fn02)])'
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we’ll look at how to interact with Android bootloaders
    and how the bootloader can be unlocked on Nexus devices. We then describe the
    fastboot protocol used to update devices via the bootloader.
  prefs: []
  type: TYPE_NORMAL
- en: Unlocking the Bootloader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The bootloaders of Nexus devices are unlocked by issuing the `oem unlock` command
    when the device is in fastboot mode (discussed in the next section). Therefore,
    in order to unlock a device, it must first be started in fastboot mode, either
    by issuing the `adb reboot bootloader` command (if the device already allows ADB
    access), or by pressing a special key combination while the device is booting.
    For example, holding down the Volume down, Volume up, and Power buttons simultaneously
    on a powered-down Nexus 5 interrupts the normal boot process and brings up the
    fastboot screen shown in [Figure 13-1](ch13.html#nexus_5_bootloader_screen "Figure 13-1. Nexus
    5 bootloader screen").
  prefs: []
  type: TYPE_NORMAL
- en: The bootloader has a simple UI that can be driven by the Volume up/down and
    Power buttons. It allows users to continue the boot process, restart the device
    in fastboot or recovery mode, and power down the device.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the device to a host machine via a USB cable allows additional commands
    to be sent to the device using the `fastboot` command-line tool (part of the Android
    SDK). Issuing the `fastboot oem unlock` command brings up the confirmation screen
    shown in [Figure 13-2](ch13.html#nexus_5_bootloader_unlock_screen "Figure 13-2. Nexus
    5 bootloader unlock screen").
  prefs: []
  type: TYPE_NORMAL
- en: '![Nexus 5 bootloader screen](figs/web/13fig01.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-1. Nexus 5 bootloader screen
  prefs: []
  type: TYPE_NORMAL
- en: '![Nexus 5 bootloader unlock screen](figs/web/13fig02.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-2. Nexus 5 bootloader unlock screen
  prefs: []
  type: TYPE_NORMAL
- en: The confirmation screen warns that unlocking the bootloader allows installation
    of untested third-party OS builds and clears all user data. Because a third-party
    OS build might not follow Android’s security model and might allow unrestricted
    access to data, clearing all user data is an important security measure; it ensures
    that existing user data cannot be extracted after the bootloader is unlocked.
  prefs: []
  type: TYPE_NORMAL
- en: The bootloader can be locked again by issuing the `fastboot oem lock` command.
    Relocking the bootloader returns it to its original state, and loading or booting
    third-party OS images is no longer possible. However, besides a locked/unlocked
    flag, some bootloaders keep an additional, “tampered” flag that is set when the
    bootloader is first unlocked. This flag allows the bootloader to detect if it
    has ever been locked and disallow some operations or show a warning even if it
    is in a locked state.
  prefs: []
  type: TYPE_NORMAL
- en: Fastboot Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the `fastboot` command and protocol can be used to unlock the boot-loader,
    their original purpose was to make it easy to clear or overwrite device partitions
    by sending partition images to the bootloader, which are then written to the specified
    block device. This is particularly useful when porting Android to a new device
    (referred to as “device bring-up”) or restoring a device to factory state using
    partition images provided by the device manufacturer.
  prefs: []
  type: TYPE_NORMAL
- en: Android Partition Layout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android devices typically have several partitions, which fastboot refers to
    by name (rather than by the corresponding Linux device file). A list of partitions
    and their names can be obtained by listing the files in the *by-name/* directory
    corresponding to the device’s SoC in */dev/block/platform/*. For example, because
    the Nexus 5 is based on Qualcomm SoC, which includes a Mobile Station Modem (MSM)
    baseband processor, the corresponding directory is called *msm_sdcc.1/* as shown
    in [Example 13-1](ch13.html#list_of_partitions_on_a_nexus_5 "Example 13-1. List
    of partitions on a Nexus 5") (timestamps omitted).
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-1. List of partitions on a Nexus 5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the Nexus 5 has 29 partitions, most of which store device-specific
    and proprietary data, such as the Android bootloader in *aboot* ➊, the baseband
    software in *modem* ➎, and the second stage bootloader in *sbl1* ➐. The Android
    OS is hosted in the *boot* ➋ partition, which stores the kernel and the *rootfs*
    RAM disk image, and the *system* partition ➑, which stores all other system files.
    User files are stored in the *userdata* partition ➒, and temporary files, such
    as downloaded OTA images and recovery OS commands and logs, are stored in the
    *cache* partition ➌. Finally, the recovery OS image resides in the *recovery*
    partition ➏.
  prefs: []
  type: TYPE_NORMAL
- en: The Fastboot Protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fastboot protocol works over USB and is driven by the host. That is, communication
    is initiated by the host, which uses USB bulk transfers to send text-based commands
    and data to the bootloader. The USB client (boot-loader) responds with a status
    string such as *OKAY* or *FAIL*; an information message starting with *INFO*;
    or *DATA*, which signifies that the bootloader is ready to accept data from the
    host. When all data is received, the boot-loader responds with one of the *OKAY*,
    *FAIL*, or *INFO* messages describing the final status of the command.
  prefs: []
  type: TYPE_NORMAL
- en: Fastboot Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `fastboot` command-line utility implements the fastboot protocol, and allows
    you to get a list of connected devices that support fastboot (using the `devices`
    command), obtain information about the bootloader (with the `getvar` command),
    reboot the device in various modes (with `continue`, `reboot`, `reboot-bootloader`),
    and `erase` or `format` a partition.
  prefs: []
  type: TYPE_NORMAL
- en: The `fastboot` command supports various ways to write a disk image to a partition.
    A single named partition can be flashed using the `flash` *`partition image-filename`*
    command, and multiple partition images contained in a ZIP file can be flashed
    at once using the `update` *`ZIP-filename`* command.
  prefs: []
  type: TYPE_NORMAL
- en: The `flashall` command automatically flashes the contents of the *boot.img*,
    *system.img*, and *recovery.img* files in its working directory to the *boot*,
    *system*, and *recovery* partitions of the device, respectively. Finally, the
    `flash:raw boot` *`kernel ramdisk`* command automatically creates a boot image
    from the specified kernel and RAM disk and flashes it to the *boot* partition.
    In addition to flashing partition images, `fastboot` can also be used to boot
    an image without writing it to the device when invoked with the `boot` *`boot-image`*
    or `boot` *`kernel ramdisk`* commands.
  prefs: []
  type: TYPE_NORMAL
- en: Commands that modify device partitions, such as the various `flash` variations,
    and commands that boot custom kernels, such as the `boot` command, are not allowed
    when the bootloader is locked.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 13-2](ch13.html#example_fastboot_session "Example 13-2. Example fastboot
    session") shows an example `fastboot` session.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-2. Example `fastboot` session
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first command ➊ lists the serial numbers of devices connected to the
    host, which are currently in fastboot mode. The commands at ➋ and ➌ obtain the
    bootloader and baseband version strings, respectively. Finally, the command at
    ➍ tries to boot a custom recovery image but fails because the bootloader is currently
    locked.
  prefs: []
  type: TYPE_NORMAL
- en: Recovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *recovery OS*—also called *recovery console* or simply, *recovery*—is a
    minimal OS that is used for tasks that cannot be executed directly from Android,
    such as factory reset (erasing the *userdata* partition) or applying OTA updates.
  prefs: []
  type: TYPE_NORMAL
- en: Like the bootloader’s fastboot mode, the recovery OS can be started either by
    pressing a specific key combination while the device boots, or via ADB by using
    the `adb reboot recovery` command. Some bootloaders also provide a menu interface
    (see [Figure 13-1](ch13.html#nexus_5_bootloader_screen "Figure 13-1. Nexus 5 bootloader
    screen")) that can be used to start the recovery. In the following sections, we
    take a look at the “stock” Android recovery that ships with Nexus devices and
    is included in AOSP, and then introduce custom recoveries, which offer much richer
    functionality but require an unlocked bootloader in order to be installed or booted.
  prefs: []
  type: TYPE_NORMAL
- en: Stock Recovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android’s stock recovery implements the minimal functionality needed to satisfy
    the “Updatable Software” section of the *Android Compatibility Definition Document
    (CDD)*, which requires that “device implementations MUST include a mechanism to
    replace the entirety of the system software...” and that “the update mechanism
    used MUST support updates without wiping user data.”^([[139](#ftn.ch13fn03)])
  prefs: []
  type: TYPE_NORMAL
- en: That said, the CDD doesn’t specify the concrete update mechanism that should
    be used, so different approaches to system updates are possible and the stock
    recovery implements both OTA updates and tethered updates. For OTA updates, the
    main OS downloads the update file and then instructs the recovery to apply it.
    In the case of tethered updates, users download the update package on their PC
    and push it to the recovery using the `adb sideload` *`otafile.zip`* command.
    The actual update process for both approaches is the same; only the method of
    obtaining the OTA package differs.
  prefs: []
  type: TYPE_NORMAL
- en: The stock recovery has a simple menu interface (shown in [Figure 13-3](ch13.html#stock_recovery_menu
    "Figure 13-3. Stock recovery menu")) that is operated using the device’s hardware
    buttons, usually the Power button and Volume up/down. However, the menu is hidden
    by default and needs to be activated by pressing a dedicated key combination.
    On Nexus devices, the recovery menu can usually be displayed by holding down the
    Power and Volume down buttons simultaneously for a few seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system recovery menu has four options: *reboot*, *apply update from ADB*,
    *factory reset*, and *wipe cache partition*. The ***apply update from ADB*** option
    starts the ADB server on the device and enables the tethered update (side-load)
    mode. However, as you can see, there is no option for applying an OTA update because
    once the user chooses to apply an OTA update from the main OS (see [Figure 13-4](ch13.html#applying_a_system_update_from_the_main_o
    "Figure 13-4. Applying a system update from the main OS")), it is applied automatically,
    without further user interaction. Android accomplishes this by sending control
    commands to the recovery, which are automatically executed when the recovery starts.
    (We discuss the mechanisms used to control the recovery in the next section.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stock recovery menu](figs/web/13fig03.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-3. Stock recovery menu
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying a system update from the main OS](figs/web/13fig04.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-4. Applying a system update from the main OS
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the Recovery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main OS controls the recovery via the `android.os.RecoverySystem` API, which
    communicates with the recovery by writing option strings, each on a new line,
    to the */cache/recovery/command* file. The contents of the *command* file are
    read by the `recovery` binary (located at */sbin/recovery* in the recovery OS),
    which is automatically started from *init.rc* when the recovery boots. The options
    modify the behavior of the `recovery` binary and cause it to wipe the specified
    partition, apply an OTA update, or simply reboot. [Table 13-1](ch13.html#options_for_the_stock_recovery_binary
    "Table 13-1. Options for the Stock recovery Binary") shows the options supported
    by the stock `recovery` binary.
  prefs: []
  type: TYPE_NORMAL
- en: Table 13-1. Options for the Stock recovery Binary
  prefs: []
  type: TYPE_NORMAL
- en: '| recovery Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `--send_intent=<string>` | Save and communicate the specified intent action
    back to the main OS when finished |'
  prefs: []
  type: TYPE_TB
- en: '| `--update_package=<OTA package path>` | Verify and install the specified
    OTA package |'
  prefs: []
  type: TYPE_TB
- en: '| `--wipe_data` | Erase the *userdata* and *cache* partitions, then reboot
    |'
  prefs: []
  type: TYPE_TB
- en: '| `--wipe_cache` | Erase the *cache* partition, then reboot |'
  prefs: []
  type: TYPE_TB
- en: '| `--show_text` | Message to display |'
  prefs: []
  type: TYPE_TB
- en: '| `--just_exit` | Exit and reboot |'
  prefs: []
  type: TYPE_TB
- en: '| `--locale` | Locale to use for recovery messages and UI |'
  prefs: []
  type: TYPE_TB
- en: '| `--stages` | Set the current stage of the recovery process |'
  prefs: []
  type: TYPE_TB
- en: In order to ensure that the specified command(s) are always completed, the `recovery`
    binary copies its arguments to the bootloader control block (BCB), which is hosted
    on the *misc* partition (➍ in [Example 13-1](ch13.html#list_of_partitions_on_a_nexus_5
    "Example 13-1. List of partitions on a Nexus 5")). The BCB is used to communicate
    the current state of the recovery process to the bootloader. The format of the
    BCB is specified in the `bootloader_message` structure, shown in [Example 13-3](ch13.html#bcb_format_structure_definition
    "Example 13-3. BCB format structure definition").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-3. BCB format structure definition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If a device is rebooted or powered down in the middle of the recovery process,
    the next time it is started the bootloader inspects the BCB and starts the recovery
    again if the BCB contains the *boot-recovery* command. If the recovery process
    completes successfully, the `recovery` binary clears the BCB before exiting (sets
    all bytes to zero), and on the next reboot the boot-loader starts the main Android
    OS.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 13-3](ch13.html#bcb_format_structure_definition "Example 13-3. BCB
    format structure definition"), the command at ➊ is the command to the bootloader
    (usually *boot-recovery*); ➋ is a status file written by the bootloader after
    performing a platform-specific action; ➌ contains the options for the `recovery`
    binary (`--update_package`, `--wipe-data`, and so on); and ➍ is a string describing
    the install stage of OTA packages that require multiple restarts, for example
    *2/3* if the installation requires three reboots. The last field ➎ is reserved
    and not used as of this writing.
  prefs: []
  type: TYPE_NORMAL
- en: Sideloading an OTA Package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides being downloaded by the main OS, an OTA package can be directly passed
    to the recovery from a host PC. In order to enable this update mode, the user
    must choose the *apply update from ADB* option from the recovery menu first. This
    starts a trimmed down version of the standard ADB daemon, which supports only
    the `sideload` command. Executing `adb sideload` *`OTA-package-file`* on the host
    transfers the OTA file to */tmp/update.zip* on the device and installs it (see
    “[Applying the Update](ch13.html#applying_the_update "Applying the Update")”).
  prefs: []
  type: TYPE_NORMAL
- en: OTA Signature Verification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we learned in [Chapter 3](ch03.html "Chapter 3. Package Management"), OTA
    packages are code signed, with the signature applied over the whole file (unlike
    JAR and APK files, which include a separate signature for each file in the archive).
    When the OTA process is started from the main Android OS, the OTA package (ZIP
    file) is first verified using the `verifyPackage()` method of the `RecoverySystem`
    class. This method receives both the path to the OTA package and a ZIP file containing
    a list of X.509 certificates that are allowed to sign OTA updates as parameters.
    If the OTA package is signed with the private key corresponding to any of the
    certificates in the ZIP file, the OTA is considered valid and the system reboots
    into recovery in order to apply it. If no certificate ZIP file is specified, the
    system default, */system/etc/security/otacerts.zip*, is used.
  prefs: []
  type: TYPE_NORMAL
- en: The recovery verifies the OTA package that it is instructed to apply independently
    of the main OS in order to ensure that the OTA package has not been replaced before
    starting the recovery. The verification is performed with a set of public keys
    built into the recovery image. When building the recovery, these keys are extracted
    from the specified set of OTA signing certificates, converted to mincrypt format
    using the `DumpPublicKey` tool, and written to the */res/keys* file. When RSA
    is used as the signature algorithm, the keys are mincrypt’s `RSAPublicKey` structures,
    serialized as C literals (as they would appear in a C source file), optionally
    preceded by a version identifier that specifies the hash used when signing the
    OTA package and the RSA key public exponent of the key. The *keys* file may look
    like [Example 13-4](ch13.html#contents_of_the_solidusressoliduskeys_fi "Example 13-4. Contents
    of the /res/keys file in the recovery OS").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-4. Contents of the /res/keys file in the recovery OS
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first line ➊ is a serialized version 1 key (implicit if a version
    identifier is not specified), which has a public exponent *e=3* and can be used
    to verify signatures created using SHA-1; the second line ➋ contains a version
    2 key that has a public exponent *e=65537* and is also used with SHA-1 signatures.
    The currently supported signature algorithms are 2048-bit RSA with SHA-1 (key
    versions 1 and 2) or SHA-256 (key versions 3 and 4), and ECDSA with SHA-256 (key
    version 5, available in AOSP’s mater branch) and 256-bit EC keys using the NIST
    P-256 curve.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the System Update Process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the signature of the OTA package verifies, the recovery applies the system
    update by executing the update command included in the OTA file. The update command
    is saved in the *META-INF/com/google/android/* directory of the recovery image
    as `update-binary` ➊, as shown in [Example 13-5](ch13.html#contents_of_a_system_update_ota_package
    "Example 13-5. Contents of a system update OTA package").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-5. Contents of a system update OTA package
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The recovery extracts `update-binary` from the OTA file to */tmp/update_binary*
    and starts it, passing it three parameters: the recovery API version (version
    3 as of this writing); the file descriptor of a pipe that `update-binary` uses
    to communicate progress and messages back to the recovery; and the path to the
    OTA package. The *update-binary* process in turn extracts the updater script,
    included as *META-INF/com/google/android/updater-script* ➋ in the OTA package,
    and evaluates it. The updater script is written in a dedicated scripting language
    called *edify* (since version 1.6; previous versions used an older variant called
    *amend*). The edify language supports simple control structures such as `if` and
    `else`, and is extensible via functions, which can also act as control structures
    (by deciding which of their arguments to evaluate). The updater script includes
    a sequence of function calls that trigger the operations necessary to apply the
    update.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the Update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The edify implementation defines and registers various functions that are used
    for copying, deleting, and patching files; formatting and mounting volumes; setting
    file permissions and SELinux labels; and more. [Table 13-2](ch13.html#summary_of_important_edify_functions
    "Table 13-2. Summary of Important edify Functions") shows a summary of the most
    often used edify functions.
  prefs: []
  type: TYPE_NORMAL
- en: Table 13-2. Summary of Important edify Functions
  prefs: []
  type: TYPE_NORMAL
- en: '| Function Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `abort` | Aborts the install process with an error message. |'
  prefs: []
  type: TYPE_TB
- en: '| `apply_patch` | Safely applies a binary patch. Ensures that the patched file
    has the expected hash value, before replacing the original. Can also patch disk
    partitions. |'
  prefs: []
  type: TYPE_TB
- en: '| `apply_patch_check` | Checks if a file has the specified hash value. |'
  prefs: []
  type: TYPE_TB
- en: '| `assert` | Checks if a condition is true. |'
  prefs: []
  type: TYPE_TB
- en: '| `delete/delete_recursive` | Deletes a file/all files in a directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `file_getprop` | Gets a system property from the specified property file.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `format` | Formats a volume with the specified filesystem. |'
  prefs: []
  type: TYPE_TB
- en: '| `getprop` | Gets a system property. |'
  prefs: []
  type: TYPE_TB
- en: '| `mount` | Mounts a volume at the specified path. |'
  prefs: []
  type: TYPE_TB
- en: '| `package_extract_dir` | Extracts the specified ZIP directory to a path on
    the filesystem. |'
  prefs: []
  type: TYPE_TB
- en: '| `package_extract_file` | Extracts the specified ZIP file to a path on the
    filesystem or returns it as a blob. |'
  prefs: []
  type: TYPE_TB
- en: '| `run_program` | Executes the specified program in a subprocess and waits
    for it to finish. |'
  prefs: []
  type: TYPE_TB
- en: '| `set_metadata/set_metadata_recursive` | Sets the owner, group, permission
    bits, file capabilities, and SELinux label on file/all files in a directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `show_progress` | Reports back progress to the parent process. |'
  prefs: []
  type: TYPE_TB
- en: '| `symlink` | Creates a symbolic link(s) to a target, deleting existing symbolic
    link files first. |'
  prefs: []
  type: TYPE_TB
- en: '| `ui_print` | Sends a message back to the parent process. |'
  prefs: []
  type: TYPE_TB
- en: '| `umount` | Unmounts a mounted volume. |'
  prefs: []
  type: TYPE_TB
- en: '| `write_raw_image` | Writes a raw image to the specified disk partition. |'
  prefs: []
  type: TYPE_TB
- en: '[Example 13-6](ch13.html#contents_of_updater-script_in_a_full_sys "Example 13-6. Contents
    of updater-script in a full system update OTA package") shows the (abbreviated)
    contents of a typical system update edify script.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-6. Contents of updater-script in a full system update OTA package
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Copying and Patching Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The updater script first mounts the *system* partition, then checks to see if
    the device model and its current build are what it expects ➊. This check is required
    because trying to install a system update over an incompatible build can leave
    a device in an unusable state. (This is often called a “soft brick,” because it
    can usually be recovered by reflashing all partitions with a working build; a
    “hard brick” cannot be recovered.)
  prefs: []
  type: TYPE_NORMAL
- en: Because an OTA update usually does not contain complete system files, only binary
    patches against the previous version of each changed file (produced using `bsdiff`),^([[140](#ftn.ch13fn04)])
    applying an update can succeed only if each file-to-be-patched is the same as
    the one used to produce the respective patch. To ensure this, the updater script
    checks that the hash value of each file-to-be-patched is one it expects using
    the `apply_patch_check` function ➋.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to system files, the update process also patches partitions that
    don’t contain a filesystem, such as the *boot* and *modem* partitions. To guarantee
    that patching such partitions will succeed, the updater script checks the contents
    of target partitions as well and aborts if they are not in the expected state
    ➌. When all system files and partitions have been verified, the updater script
    deletes unnecessary files, as well as files that will be replaced completely instead
    of being patched ➍. The script then goes on to patch all system files ➎ and partitions
    ➏. It then removes any previous recovery patches and unpacks the new recovery
    in */system/* ➐.
  prefs: []
  type: TYPE_NORMAL
- en: Setting File Ownership, Permissions, and Security Labels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is to set the user, owner, permissions, and file capabilities
    of all created or patched files and directories using the `set_metadata_recursive`
    function ➑. As of version 4.3, Android supports SELinux (see [Chapter 12](ch12.html
    "Chapter 12. Selinux")), so all files must be properly labeled in order for access
    rules to be effective. That is why the `set_metadata_recursive` function has been
    extended to set the SELinux security label (the last parameter, *u:object_r:system_file:s0*
    in ➑) of files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the Update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, the updater script patches the device’s baseband software ➒, which is
    typically stored in the *modem* partition. The final step of the script is to
    unmount the system partition➓.
  prefs: []
  type: TYPE_NORMAL
- en: After the *update-binary* process exits, the recovery wipes the cache partition
    if it was started with the `–wipe_cache` option and copies the execution logs
    to */cache/recovery/* so that they are accessible from the main OS. Finally, if
    no errors are reported, the recovery clears the BCB and reboots into the main
    OS.
  prefs: []
  type: TYPE_NORMAL
- en: If the update process is aborted due to an error, the recovery reports this
    to the user, and prompts them to reboot the device in order to try again. Because
    the BCB has not been cleared, the device automatically reboots in recovery mode,
    and the update process is started from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Recovery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you examine the entire updater script in [Example 13-6](ch13.html#contents_of_updater-script_in_a_full_sys
    "Example 13-6. Contents of updater-script in a full system update OTA package")
    in detail, you’ll notice that while it patches the *boot* ➏ and *modem* ➒ partitions
    and unpacks a patch for the *recovery* partition ➐ (which hosts the recovery OS),
    it does not apply the unpacked patch. This is by design. Because an update can
    be interrupted at any moment, the update process needs to be restarted from the
    same state the next time the device is powered on. If, for example, power is interrupted
    while writing to the *recovery* partition, updating the recovery OS would change
    that initial state and might leave the system in an unusable condition. Therefore,
    the recovery OS is updated from the main OS only when the main OS update has completed
    and the main OS boots successfully.
  prefs: []
  type: TYPE_NORMAL
- en: The update is triggered by the *flash_recovery* service in Android’s *init.rc*
    file, as shown in [Example 13-7](ch13.html#definition_of_the_flashunderscorerecover
    "Example 13-7. Definition of the flash_recovery service in init.rc").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-7. Definition of the flash_recovery *service in* init.rc
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this service simply starts the */system/etc/install-recovery.sh*
    shell script ➊. The shell script, along with a patch file for the recovery partition,
    is copied by the OTA updater script (➐ in [Example 13-6](ch13.html#contents_of_updater-script_in_a_full_sys
    "Example 13-6. Contents of updater-script in a full system update OTA package"))
    if the recovery requires an update. The contents of *install-recovery.sh* might
    look like [Example 13-8](ch13.html#contents_of_install-recoverydotsh "Example 13-8. Contents
    of install-recovery.sh").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-8. Contents of install-recovery.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The script uses the `applypatch` command to check whether the recovery OS needs
    to be patched by checking the hash value of the *recovery* partition ➊. If the
    hash of the device’s *recovery* partition matches the hash of the version against
    which the patch was created, the script applies the patch ➋. If the recovery has
    already been updated or has an unknown hash, the script logs a message and exits
    ➌.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Recoveries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A custom recovery is a recovery OS build created by a third party (not the device
    manufacturer). Because it is created by a third party, a custom recovery is not
    signed with the manufacturer’s keys, and therefore a device’s bootloader needs
    to be unlocked in order to boot or flash it.
  prefs: []
  type: TYPE_NORMAL
- en: A custom recovery can be booted without installing it on the device with the
    `fastboot boot` *`custom-recovery.img`* command, or it may be permanently flashed
    using the `fastboot flash recovery` *`custom-recovery.img`* command.
  prefs: []
  type: TYPE_NORMAL
- en: A custom recovery provides advanced functionality that is typically not available
    in stock recoveries, such as full partition backup and restore, a root shell with
    a full set of device management utilities, support for mounting external USB devices,
    and so on. A custom recovery can also disable OTA package signature checking,
    which allows for installing third-party OS builds or modification, such as framework
    or theme customizations.
  prefs: []
  type: TYPE_NORMAL
- en: Various custom recoveries are available, but as of this writing, by far the
    most full-featured and actively maintained is the Team Win Recovery Project (TWRP).^([[141](#ftn.ch13fn05)])
    It is based on the AOSP stock recovery and is also an open source project.^([[142](#ftn.ch13fn06)])
    TWRP has a theme-able, touch screen interface that is very similar to the native
    Android UI. It supports encrypted partition backups, installing system updates
    from USB devices, and backup and restore to/from external devices, and it has
    an integrated file manager. The startup screen of TWRP version 2.7 is shown in
    [Figure 13-5](ch13.html#twrp_recovery_startup_screen "Figure 13-5. TWRP recovery
    startup screen").
  prefs: []
  type: TYPE_NORMAL
- en: '![TWRP recovery startup screen](figs/web/13fig05.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-5. TWRP recovery startup screen
  prefs: []
  type: TYPE_NORMAL
- en: Like the stock AOSP recovery, custom recoveries can be controlled from the main
    OS. In addition to passing parameters via the */cache/recovery/ command* file,
    custom recoveries usually allow some (or all) of their extended features to be
    triggered from the main OS. For example, TWRP supports a minimal scripting language,
    which describes what recovery actions should be executed upon booting the recovery.
    This allows Android apps to queue recovery commands via a convenient GUI interface.
    For example, requesting a compressed backup of the *boot*, *userdata*, and *system*
    partitions generates the script shown in [Example 13-9](ch13.html#twrp_backup_script_example
    "Example 13-9. TWRP backup script example").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-9. TWRP backup script example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Permanently flashing a custom recovery that has an option to ignore OTA package
    signatures might allow the system software of your device to be replaced and back-doored
    given brief physical access to the devices. Therefore, it is not recommended to
    flash a custom recovery on a device you use daily and which stores personal or
    sensitive information.*'
  prefs: []
  type: TYPE_NORMAL
- en: Root Access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android’s security model applies the principle of least privilege and strives
    to isolate system and app processes from each other by running each process as
    a dedicated user. However, Android is also based on a Linux kernel, which implements
    a standard Unix-style DAC (unless SELinux is enabled; see [Chapter 12](ch12.html
    "Chapter 12. Selinux")).
  prefs: []
  type: TYPE_NORMAL
- en: One of the greatest shortcomings of this DAC security model is that a certain
    system user, typically called *root* (UID=0), also known as the *superuser*, is
    given absolute power over the system. Root can read, write, and change the permission
    bits of any file or directory; kill any process; mount and unmount volumes; and
    so on. While such unconstrained permissions are necessary for managing a traditional
    Linux system, having superuser access on an Android device allows one to effectively
    bypass Android’s sandbox, and read or write the private files of any application.
  prefs: []
  type: TYPE_NORMAL
- en: Root access also allows changing the system configuration by modifying partitions
    that are designed to be read-only, starting or stopping system services at will,
    and removing or disabling core system applications. This can adversely affect
    the stability of a device, or even render it unusable, which is why root access
    is typically not allowed on production devices.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, Android tries to limit the number of system processes that execute
    as root, because a programming error in any such process can open the doors to
    privilege escalation attacks, which could result in third-party applications gaining
    root access. With the deployment of SELinux in enforcing mode, processes are limited
    by the global security policy, and therefore compromising a root process does
    not necessarily grant unrestricted access to a device but could still allow access
    to sensitive data or allow modifying system behavior. Additionally, even a process
    constrained by SELinux could exploit a kernel vulnerability in order to circumvent
    the security policy or otherwise obtain unrestricted root access.
  prefs: []
  type: TYPE_NORMAL
- en: With all that said, root access could be very convenient for debugging or reverse
    engineering applications on development devices. Additionally, while allowing
    root access to third-party applications does compromise Android’s security model,
    it also allows various system customizations that are typically not available
    on production devices to be performed.
  prefs: []
  type: TYPE_NORMAL
- en: Because one of Android’s biggest selling points has always been its ease of
    customization, the demand for ever greater flexibility via modifying the core
    OS (also called *modding*), has always been high, especially during Android’s
    early years. Besides customizing the system, having root access on an Android
    device allows for the implementation of applications that are not possible without
    modifying the framework and adding system services, such as firewalls, full device
    backup, network sharing, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we describe how root access is implemented in development
    (engineering) Android builds and custom Android builds (ROMs), and how it can
    be added to production builds. We then show how apps that require superuser access
    (typically called *root apps*) can request and use root privileges in order to
    execute processes as root.
  prefs: []
  type: TYPE_NORMAL
- en: Root Access on Engineering Builds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android’s build system can produce several build variants for a particular device
    that differ by the number of applications and utilities included, as well as by
    the values of several key system properties that modify system behavior. Some
    of these build variants allow root access from the Android shell, as we’ll show
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Starting ADB as Root
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Commercial devices use the *user* build variant (the current build variant is
    set as the value of the *ro.build.type* system property), which doesn’t include
    diagnostics and development tools, disables the ADB daemon by default, disallows
    debugging of applications that don’t explicitly set the `debuggable` attribute
    to `true` in their manifests, and disallows root access via the shell. The *userdebug*
    build variant is very close to *user*, but it also includes some additional modules
    (those with the *debug* module tag), allows debugging of all apps, and enables
    ADB by default.
  prefs: []
  type: TYPE_NORMAL
- en: Engineering, or *eng*, builds include most available modules, allow debugging,
    enable ADB by default, and set the *ro.secure* system property to 0, which changes
    the behavior of the ADB daemon running on a device. When set to 1 (secure mode),
    the *adbd* process, which initially runs as root, drops all capabilities from
    its capability bounding set with the exception of `CAP_SETUID` and `CAP_SETGID`
    (which are required to implement the `run-as` utility). It then adds several supplementary
    GIDs that are required to access network interfaces, external storage, and system
    logs, and finally changes its UID and GID to `AID_SHELL` (UID=2000). On the other
    hand, when *ro.secure* is set to 0 (the default for engineering builds), the *adbd*
    daemon continues to run as root and has the full capability bounding set. [Example 13-10](ch13.html#adbd_process_details_on_a_user_build
    "Example 13-10. adbd process details on a user build") shows the process IDs and
    capabilities for the *adbd* process on a *user* build.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-10. adbd process details on a user build
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the process’s UID ➊ and GID ➋ are both set to 2000 (`AID_SHELL`),
    and the *adbd* process has a number of supplementary GIDs added ➌. Finally, the
    process’s capability bounding set, which determines what capabilities child processes
    are allowed, is set to 0x0000000c0 (`CAP_SETUID|CAP_SETGID`) ➍. This capability
    setting guarantees that, on *user* builds, processes started from Android’s shell
    are limited to the `CAP_SETUID` and `CAP_SETGID` capabilities, even if the executed
    binary has the SUID bit set, or its file capabilities permit additional privileges.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, on an *eng* or *userdebug* build, the ADB daemon can execute as
    root, as shown in [Example 13-11](ch13.html#adbd_process_details_on_an_eng_build
    "Example 13-11. adbd process details on an eng build").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-11. adbd process details on an eng build
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, the *adbd* process runs with UID ➌ and GID ➍ 0 (root), has no supplementary
    groups ➎, and has the full set of Linux capabilities (➏, ➐, and ➑). However, as
    you can see at ➋, the *ro.secure* system property is set to 1, which suggests
    that *adbd* should not be running as root.
  prefs: []
  type: TYPE_NORMAL
- en: While the ADB daemon does drop its root privileges on *userdebug* builds (as
    in this example, ➊), it can be manually restarted in insecure mode by issuing
    the `adb root` command from a host, as shown in [Example 13-12](ch13.html#restarting_adbd_as_root_on_userdebug_bui
    "Example 13-12. Restarting adbd as root on userdebug builds").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-12. Restarting adbd *as root on* userdebug *builds*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, the *adbd* daemon is initially running as *shell* (UID=2000), and any
    shells started from the host also have UID=2000 and GID=2000 ➊. Issuing the `adb
    root` command ➋ (which internally sets the *service.adb.root* system property
    to 1) restarts the ADB daemon as root ➌, and any subsequently started shells have
    UID and GUID=0 ➍.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Because this particular device has SELinux enabled, even though the UID and
    GID of the shell change, its security context (security label) stays the same:*
    u:r:shell:s0 *in both* ➊ *and* ➍*. Therefore, even after obtaining a root shell
    via ADB, all processes started from the shell are still bound by the permissions
    granted to the* shell *domain (unless allowed to transition to another domain
    by the MAC policy; see [Chapter 12](ch12.html "Chapter 12. Selinux") for details).
    In practice, as of Android 4.4, the* shell *domain is unconfined, so when running
    as root, processes in this domain are allowed almost full control over the device.*'
  prefs: []
  type: TYPE_NORMAL
- en: Using the su Command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On *userdebug* builds, root access can also be obtained without restarting ADB
    as root. This can be accomplished using the `su` (short for *substitute user*,
    also referred to as *switch user* and *superuser*) command, which is installed
    with the SUID bit set, thus allowing calling processes to obtain a root shell
    or execute a command as the specified UID (including UID=0). The default `su`
    implementation is very basic and only allows the *root* and *shell* users to use
    it, as shown in [Example 13-13](ch13.html#default_su_implementation_for_userdebug
    "Example 13-13. Default su implementation for userdebug builds").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-13. Default *`su` implementation for* userdebug *builds*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The main function first checks whether the calling UID is `AID_ROOT` (0) or
    `AID_SHELL` (2000) ➊, and exits if called by a user with a different UID. It then
    sets the process UID and GID to 0 (➋ and ➌), and finally starts the Android shell
    ➍. Any commands executed from this shell inherit its privileges by default, thus
    allowing superuser access to the device.
  prefs: []
  type: TYPE_NORMAL
- en: Root Access on Production Builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned in “[Root Access on Engineering Builds](ch13.html#root_access_on_engineering_builds
    "Root Access on Engineering Builds")”, commercial Android devices are usually
    based on the *user* build variant. This means that the ADB daemon is running as
    the *shell* user, and no `su` command is installed on the device.
  prefs: []
  type: TYPE_NORMAL
- en: This is a secure configuration, and most users should be able to achieve their
    device configuration and customization tasks with the tools provided by the platform,
    or with third-party applications such as custom launchers, keyboards, or VPN clients.
    However, operations that modify the look and feel or core configuration of Android
    are not possible, and neither is low-level access to the underlying Linux OS.
    Such operations can only be performed by running certain commands with root privileges,
    which is why many power users seek to enable root access on their devices.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining root access on an Android device is commonly known as *rooting* and
    can be fairly simple on devices that have an unlockable bootloader or nearly impossible
    on devices that don’t allow bootloader unlocking and take additional measures
    to prevent system partition modifications. In the next sections, we describe the
    typical rooting process and introduce some of the most popular “superuser” apps
    that enable and manage root access.
  prefs: []
  type: TYPE_NORMAL
- en: Rooting by Changing the boot or system Image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On some Android devices, given an unlocked bootloader, a *user* build can easily
    be turned into an engineering or *userdebug* build by simply flashing a new boot
    image (often called a *kernel*, or *custom kernel*), which changes the values
    of the *ro.secure* and *ro.debuggable* system properties. Changing these properties
    allows the ADB daemon to execute as root and enables root access via the Android
    shell, as described in“[Root Access on Engineering Builds](ch13.html#root_access_on_engineering_builds
    "Root Access on Engineering Builds")”. However, most current Android *user* builds
    disable this behavior at compile time (by not defining the `ALLOW_ADBD_ROOT` macro)
    and the values of the *ro.secure* and *ro.debuggable* system properties are ignored
    by the *adbd* daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to enable root access is to unpack the system image, add a SUID
    `su` binary or a similar utility, and overwrite the *system* partition with the
    new system image. This would typically allow root access not only from the shell,
    but from third-party applications as well. However, several security enhancements
    in Android 4.3^([[143](#ftn.ch13fn07)]) and later versions disallow apps from
    executing SUID programs by dropping all capabilities from the bounding set of
    Zygote-spawned processes, and mounting the *system* partition with the `nosetuid`
    flag.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, on Android versions that set SELinux to enforcing mode, executing
    a process with root privileges does not typically change its security context,
    and such a process is still limited by the MAC policy. For these reasons, enabling
    root access on a recent Android version may not be as simple as changing a few
    system properties or copying a SUID binary to the device. Of course, replacing
    the *boot* or *system* image allows SELinux to be disabled and any security mitigation
    to be reverted, thus relaxing the device’s security level and enabling root access.
    However, such a radical approach is not unlike replacing the whole OS and may
    prevent the device from receiving system updates from the device manufacturer.
    This is undesirable in most cases, and several root methods that try to coexist
    with the stock OS of the device have been developed.
  prefs: []
  type: TYPE_NORMAL
- en: Rooting by Flashing an OTA Package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An OTA package can add or modify system files, without replacing the whole OS
    image, and is therefore a good candidate for adding root access to a device. Most
    popular superuser apps are distributed as a combination of an OTA package, which
    needs to be installed once, and a companion manager application, which can be
    updated online.
  prefs: []
  type: TYPE_NORMAL
- en: SuperSU
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll use the SuperSU OTA package ^([[144](#ftn.ch13fn08)]) and app ^([[145](#ftn.ch13fn09)])
    (developed by Jorrit “Chainfire” Jongma) to demonstrate how this approach works.
    SuperSU is currently the most popular superuser application and is actively maintained,
    keeping in step with the latest modifications to the Android platform. The SuperSU
    OTA package is similar in structure to a full system update package but contains
    only a small number of files, as shown in [Example 13-14](ch13.html#contents_of_the_supersu_ota_package
    "Example 13-14. Contents of the SuperSU OTA package").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-14. Contents of the SuperSU OTA package
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The package contains a few native binaries compiled for the ARM ➊ and x86 ➐
    platforms, scripts for starting and installing the SuperSU daemon (➋ and ➌), the
    APK file of the management GUI application ➍, and two updater scripts (➎ and ➏)
    that apply the OTA package.
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand how SuperSU enables root access, we need to first examine
    its install process. To do so, let’s analyze the contents of the `update-binary`
    script ➎, shown in [Example 13-15](ch13.html#supersu_ota_install_script "Example 13-15. SuperSU
    OTA install script"). (SuperSU uses a regular shell script instead of a native
    binary, so `updater-script` is simply a placeholder.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-15. SuperSU OTA install script
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The update script first mounts the *rootfs* filesystem and the *system* and
    *userdata* partitions in read-write mode ➊, and then it extracts ➋ and copies
    the included files to their intended locations on the filesystem. The `su` and
    `daemonsu` native binaries ➌ are copied to */system/xbin/*, which is the usual
    location of extra native binaries (binaries that are not necessary for running
    the Android OS). The root access management application is copied to */system/app/*
    ➍ and is automatically installed by the package manager when the device reboots.
    Next, the update script copies the *install-recovery.sh* script to */system/etc/*
    ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*As discussed in “[Updating the Recovery](ch13.html#updating_the_recovery "Updating
    the Recovery")”, this script is typically used to update the recovery image from
    the main OS, so you might be wondering why the SuperSU install is trying to update
    the recovery of the device. SuperSU uses this script to start some of its components
    at boot time, which we’ll discuss shortly.*'
  prefs: []
  type: TYPE_NORMAL
- en: The next step of the OTA package install process is to set the permissions ➏
    and SELinux security labels ➐ of the installed binaries (`ch_con` is a shell function
    that calls the `chcon` SELinux utility and sets the *u:object_r:system_file:s0*
    label). Finally, the script calls the `su` command with the `--install` option
    ➑ in order to perform some post-install initialization, and then unmounts */system*
    and */data* ➒. When the script exits successfully, the recovery reboots the device
    into the main Android OS.
  prefs: []
  type: TYPE_NORMAL
- en: How SuperSU Is Initialized
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To understand how SuperSU is initialized, let’s look at the contents of the
    *install-recovery.sh* script (see [Example 13-16](ch13.html#contents_of_supersuapostrophes_install-r
    "Example 13-16. Contents of SuperSU’s install-recovery.sh script"), with comments
    omitted), which is automatically executed by `init` on boot.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-16. Contents of SuperSU’s install-recovery.sh *script*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The script first executes the `daemonsu` binary ➊, which starts a daemon process
    with root privileges. The next step executes the *install-recovery-2.sh* script
    ➋, which may be used to perform additional initialization, necessary for other
    root apps. Using a daemon in order to allow apps to execute code with root privileges
    is required in Android 4.3 and later, because all apps (which are forked from
    *zygote*) have their capability bounding set zeroed out, thus preventing them
    from executing privileged operations, even if they manage to start a process as
    root. Additionally, as of Android 4.4, SELinux is in enforcing mode, so any processes
    started by an application inherit its security context (typically *untrusted_app*),
    and therefore are subject to the same MAC restrictions as the app itself.
  prefs: []
  type: TYPE_NORMAL
- en: SuperSU gets around these security restrictions by having apps use the `su`
    binary to execute commands as root, which in turn pipes those commands via a Unix
    domain socket to the *daemonsu* daemon, which ultimately executes the received
    commands as root within the *u:r:init:s0* SELinux context. The processes in play
    are illustrated in [Example 13-17](ch13.html#processes_started_when_an_app_requests_r
    "Example 13-17. Processes started when an app requests root access via SuperSU").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-17. Processes started when an app requests root access via SuperSU
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `com.example.app` app ➏ (whose parent process is *zygote* ➋) requests
    root access by passing a command to the `su` binary using its `-c` option. As
    you can see, the `su` process ➑ executes as the same user (*u0_a292*, UID=10292)
    and in the same SELinux domain (*untrusted_app*) as the requesting app. However,
    the process ➒ of the command the app requested to be executed as root (`sleep`
    in this example) indeed executes as root in the *init* SELinux domain (security
    context *u:r:init:s0*). If we trace its parent PID (PPID, in the fourth column),
    we find that the *sleep* process is started by the *daemonsu:10292* process ➎,
    which is a *daemonsu* instance dedicated to our example app (with UID=10292).
    The *daemonsu:10292* process ➎ inherits its *init* SELinux domain from the *daemonsu:master*
    instance ➍, which is in turn started by the first *daemonsu* instance ➌. This
    is the instance started via the *install-recovery.sh* script (see [Example 13-16](ch13.html#contents_of_supersuapostrophes_install-r
    "Example 13-16. Contents of SuperSU’s install-recovery.sh script")), and it runs
    within the domain of its parent—the *init* process ➊ (PID=1).
  prefs: []
  type: TYPE_NORMAL
- en: The *eu.chainfire.supersu* process ➐ belongs to the SuperSU management application,
    which shows the root access grant dialog shown in [Figure 13-6](ch13.html#supersu_root_access_request_grant_dialog
    "Figure 13-6. SuperSU root access request grant dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![SuperSU root access request grant dialog](figs/web/13fig06.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-6. SuperSU root access request grant dialog
  prefs: []
  type: TYPE_NORMAL
- en: Superuser access can be granted one time only, for a certain period of time,
    or permanently. SuperSU keeps an internal whitelist of apps that have been granted
    root access and does not show the grant dialog if the requesting app is already
    in the whitelist.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*SuperSU has a companion library,* libsuperuser,^([[146](#ftn.ch13fn10)]) *which
    makes it easier to write root apps by providing Java wrappers for the different
    patterns of calling the `su` binary. The author of SuperSU also provides a comprehensive
    guide to writing root apps called* How-To SU.^([[147](#ftn.ch13fn11)])'
  prefs: []
  type: TYPE_NORMAL
- en: Root Access on Custom ROMs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Custom ROMs that provide root access don’t have to go through *install-recovery.sh*
    in order to start their superuser daemon (equivalent to SuperSU’s *daemonsu*)
    because they can customize the startup process at will. For example, the popular
    CyanogenMod open source Android distribution starts its *su* daemon from *init.superuser.rc*,
    as shown in [Example 13-18](ch13.html#startup_script_for_the_su_daemon_in_cyan
    "Example 13-18. Startup script for the su daemon in CyanogenMod").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-18. Startup script for the su *daemon in CyanogenMod*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This *init* script defines the *su_daemon* service ➊, which can be started or
    stopped by changing the value of the *persist.sys.root_access* persistent system
    property (➋ through ➎). The value of this property also determines whether root
    access should be granted only to apps, ADB shells, or both. Root access is disabled
    by default and can be configured via CyanogenMod’s Development options, as shown
    in [Figure 13-7](ch13.html#cyanogenmod_root_access_options "Figure 13-7. CyanogenMod
    root access options").
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*While SuperSU and custom ROMs that allow root access take certain measures
    to regulate what apps are allowed to execute commands as root (usually by adding
    them to a whitelist), an implementation flaw could allow apps to bypass these
    measures and obtain root access without user confirmation. Therefore, root access
    should be disabled on everyday-use devices and used only when necessary for development
    or debugging.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![CyanogenMod root access options](figs/web/13fig07.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-7. CyanogenMod root access options
  prefs: []
  type: TYPE_NORMAL
- en: Rooting via Exploits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On production devices that don’t have an unlockable bootloader, root access
    can be obtained by exploiting a privilege escalation vulnerability, which allows
    an app or shell process to start a root shell (also called *soft root*) and modify
    the system. The exploits are typically packaged into “one-click” apps or scripts,
    which try to persist root access by installing a `su` binary or modifying system
    configuration. For example, the so-called towelroot exploit (which is distributed
    as an Android app) takes advantage of a vulnerability in the Linux kernel (CVE-2014-3153)
    to obtain root access and installs SuperSU in order to persist it. (Root access
    can also be persisted by overwriting the *recovery* partition with a custom recovery,
    thus allowing the installation of arbitrary software, including superuser applications.
    However, some devices have additional protections that prevent modifications to
    the *boot*, *system*, and *recovery* partitions, so permanent root access might
    not be possible.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*See [Chapter 3](ch03.html "Chapter 3. Package Management") of the* Android
    Hacker’s Handbook *(Wiley, 2014) for a detailed description of the major privilege-escalation
    vulnerabilities that have been used to obtain root access in various Android versions.
    [Chapter 12](ch12.html "Chapter 12. Selinux") of the same book introduces the
    main exploit-mitigation techniques that have been implemented in Android in order
    to prevent privilege-escalation attacks and generally harden the system.*'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to allow for updating the system software or returning a device to
    its factory state, Android devices allow unrestricted, low-level access to their
    storage via the bootloader. The bootloader typically implements a management protocol,
    usually fastboot, that allows for transferring and flashing partition images from
    a host machine. Bootloaders on production devices are usually locked and allow
    flashing only of signed images. However, most bootloaders can be unlocked, thus
    allowing flashing images from third parties.
  prefs: []
  type: TYPE_NORMAL
- en: Android uses a dedicated partition to store a second, minimal OS, called a recovery,
    which is used to apply OTA update packages or clear all data on the device. Like
    bootloaders, recoveries on production devices typically allow applying only those
    OTA packages signed by the device manufacturer. If the bootloader is unlocked,
    a custom recovery, which allows installing updates signed by third parties or
    completely forgoes signature verification, can be booted or permanently installed.
  prefs: []
  type: TYPE_NORMAL
- en: Engineering or debug builds of Android allow root access via the Android shell,
    but root access is typically disabled on production devices. Root access on such
    devices can be enabled by installing a third-party OTA package that includes a
    “superuser” daemon and a companion application that allow controlled root access
    to applications. Third-party Android builds (ROMs) typically allow root access
    out of the box, although it can also be disabled via the system settings interface.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[137](#ch13fn01)]) Code Aurora Forum, “(L)ittle (K)ernel based Android bootloader,”
    *[https://www.codeaurora.org/blogs/little-kernel-based-android-bootloader/](https://www.codeaurora.org/blogs/little-kernel-based-android-bootloader/)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[138](#ch13fn02)]) Code Aurora Forum, *[https://www.codeaurora.org/cgit/quic/la/kernel/lk/](https://www.codeaurora.org/cgit/quic/la/kernel/lk/)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[139](#ch13fn03)]) Google, *Android Compatibility Definition*, *[https://static.googleusercontent.com/media/source.android.com/en//compatibility/android-cdd.pdf](https://static.googleusercontent.com/media/source.android.com/en//compatibility/android-cdd.pdf)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[140](#ch13fn04)]) Colin Percival, “Binary diff/patch utility,” *[http://www.daemonology.net/bsdiff/](http://www.daemonology.net/bsdiff/)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[141](#ch13fn05)]) TeamWin, “TWRP 2.7,” *[http://teamw.in/project/twrp2/](http://teamw.in/project/twrp2/)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[142](#ch13fn06)]) TeamWin, “Team Win Recovery Project (TWRP),” *[https://github.com/TeamWin/Team-Win-Recovery-Project/](https://github.com/TeamWin/Team-Win-Recovery-Project/)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[143](#ch13fn07)]) Google, “Security Enhancements in Android 4.3,” *[http://source.android.com/devices/tech/security/enhancements43.html](http://source.android.com/devices/tech/security/enhancements43.html)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[144](#ch13fn08)]) Jorrit “Chainfire” Jongma, “CF-Root download page,” *[http://download.chainfire.eu/supersu/](http://download.chainfire.eu/supersu/)*
  prefs: []
  type: TYPE_NORMAL
- en: '^([[145](#ch13fn09)]) Jorrit “Chainfire” Jongma, “Google Play Apps: SuperSU,”
    *[https://play.google.com/store/apps/details?id=eu.chainfire.supersu&hl=en](https://play.google.com/store/apps/details?id=eu.chainfire.supersu&hl=en)*'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[146](#ch13fn10)]) Jorrit “Chainfire” Jongma, libsuperuser, *[https://github.com/Chainfire/libsuperuser/](https://github.com/Chainfire/libsuperuser/)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[147](#ch13fn11)]) Jorrit “Chainfire” Jongma, “How-To SU Guidelines for problem-free
    su usage,” *[http://su.chainfire.eu/](http://su.chainfire.eu/)*
  prefs: []
  type: TYPE_NORMAL
