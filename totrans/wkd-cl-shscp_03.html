<html><head></head><body>
<h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_51"/><span class="big"><strong>2</strong></span><br/><strong>IMPROVING ON USER COMMANDS</strong></h2>&#13;
<div class="imagec"><img src="../images/common4.jpg" alt="image"/></div>&#13;
<p class="noindent">A typical Unix or Linux system includes hundreds of commands by default, which, when you factor in flags and the possible ways to combine commands with pipes, produces millions of different ways to work on the command line.</p>&#13;
<p class="indent">Before we go any further, <a href="ch02.xhtml#ch2ex1">Listing 2-1</a> shows a bonus script that will tell you how many commands are in your <code>PATH</code>.</p>&#13;
<pre class="programs">#!/bin/bash&#13;
&#13;
# How many commands: a simple script to count how many executable&#13;
#   commands are in your current PATH&#13;
&#13;
&#13;
IFS=":"&#13;
count=0 ; nonex=0&#13;
for directory in $PATH ;  do&#13;
  if [ -d "$directory" ] ; then&#13;
    for command in "$directory"/* ; do&#13;
      if [ -x "$command" ] ; then&#13;
        count="$(( $count + 1 ))"&#13;
      else&#13;
        nonex="$(( $nonex + 1 ))"&#13;
      fi&#13;
    done&#13;
  fi&#13;
done&#13;
&#13;
echo "$count commands, and $nonex entries that weren't executable"&#13;
&#13;
exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_52"/><a id="ch2ex1"/><em>Listing 2-1: Counting the number of executables and nonexecutables in the current</em> <code><em>PATH</em></code></p>&#13;
<p class="indent">This script counts the number of executable files rather than just the number of files, and it can be used to reveal how many commands and nonexecutables are in the default <code>PATH</code> variables of many popular operating systems (see <a href="ch02.xhtml#ch02table1">Table 2-1</a>).</p>&#13;
<p class="tablecap"><a id="ch02table1"/><strong>Table 2-1:</strong> Typical Command Count by OS</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Operating system</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Commands</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Nonexecutables</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_3a"><p class="table">Ubuntu 15.04 (including all developer libraries)</p></td>&#13;
<td style="vertical-align: top;" class="table_3a"><p class="table">3,156</p></td>&#13;
<td style="vertical-align: top;" class="table_3a"><p class="table">5</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_3a"><p class="table">OS X 10.11 (with developer options installed)</p></td>&#13;
<td style="vertical-align: top;" class="table_3a"><p class="table">1,663</p></td>&#13;
<td style="vertical-align: top;" class="table_3a"><p class="table">11</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_3a"><p class="table">FreeBSD 10.2</p></td>&#13;
<td style="vertical-align: top;" class="table_3a"><p class="table">954</p></td>&#13;
<td style="vertical-align: top;" class="table_3a"><p class="table">4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_3a"><p class="table">Solaris 11.2</p></td>&#13;
<td style="vertical-align: top;" class="table_3a"><p class="table">2,003</p></td>&#13;
<td style="vertical-align: top;" class="table_3a"><p class="table">15</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Clearly, the different flavors of Linux and Unix offer a large number of commands and executable scripts. Why are there so many? The answer is based on the foundational Unix philosophy: commands should do one thing, and do it well. Word processors that have spellcheck, find file, and email capabilities might work well in the Windows and Mac world, but on the command line, each of these functions should be separate and discrete.</p>&#13;
<p class="indent">There are lots of advantages to this design philosophy, the most important being that each function can be modified and extended individually, giving all applications that utilize it access to these new capabilities. With any task you might want to perform on Unix, you can usually cobble together something that’ll do the trick easily, whether by downloading some nifty utility that adds capabilities to your system, creating some aliases, or dipping a toe into the shell-scripting pond.</p>&#13;
<p class="indent">The scripts throughout the book not only are helpful but also are a logical extension of the Unix philosophy. After all, ’tis better to extend and expand than to build complex, incompatible versions of commands for your own installation.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_53"/>The scripts explored in this chapter are all similar to the script in <a href="ch02.xhtml#ch2ex1">Listing 2-1</a> in that they add fun or useful features and capabilities without a high degree of complexity. Some of the scripts accept different command flags to allow even greater flexibility in their use, and some also demonstrate how a shell script can be used as a <em>wrapper</em>, a program that intercedes to allow users to specify commands or command flags in a common notation and then translates those flags into the proper format and syntax required by the actual Unix command.</p>&#13;
<h3 class="h3" id="ch02lev1sec01"><strong>#14 Formatting Long Lines</strong></h3>&#13;
<p class="noindenta">If you’re lucky, your Unix system already includes the <code>fmt</code> command, a program that’s remarkably useful if you work with text regularly. From reformatting emails to making lines use up all the available width in documents, <code>fmt</code> is a helpful utility to know.</p>&#13;
<p class="indent">However, some Unix systems don’t include <code>fmt</code>. This is particularly true of legacy systems, which often have fairly minimalistic implementations.</p>&#13;
<p class="indent">As it turns out, the <code>nroff</code> command, which has been part of Unix since the very beginning and is a shell script wrapper in its own right, can be used in short shell scripts to wrap long lines and fill in short lines to even out line lengths, as shown in <a href="ch02.xhtml#ch2ex2">Listing 2-2</a>.</p>&#13;
<h4 class="h4" id="ch02lev2sec01"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # fmt--Text formatting utility that acts as a wrapper for nroff&#13;
   #   Adds two useful flags: -w X for line width&#13;
   #   and -h to enable hyphenation for better fills&#13;
<span class="ent">➊</span> while getopts "hw:" opt; do&#13;
     case $opt in&#13;
       h ) hyph=1              ;;&#13;
       w ) width="$OPTARG"     ;;&#13;
     esac&#13;
   done&#13;
<span class="ent">➋</span> shift $(($OPTIND - 1))&#13;
&#13;
<span class="ent">➌</span> nroff &lt;&lt; EOF&#13;
<span class="ent">➍</span> .ll ${width:-72}&#13;
   .na&#13;
   .hy ${hyph:-0}&#13;
   .pl 1&#13;
<span class="ent">➎</span> $(cat "$@")&#13;
   EOF&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch2ex2"/><em>Listing 2-2: The</em> <code><em>fmt</em></code> <em>shell script for formatting long texts nicely</em></p>&#13;
<h4 class="h4" id="ch02lev2sec02"><span epub:type="pagebreak" id="page_54"/><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">This succinct script offers two different command flags: <code>-w X</code> to specify that lines should be wrapped when they exceed <code>X</code> characters (the default is 72) and <code>-h</code> to enable hyphenated word breaks across lines. Notice the check for flags at <span class="ent">➊</span>. The <code>while</code> loop uses <code>getopts</code> to read each option passed to the script one at a time, and the inner <code>case</code> block decides what to do with them. Once the options are parsed, the script calls <code>shift</code> at <span class="ent">➋</span> to throw away all the option flags using <code>$OPTIND</code> (which holds the index of the next argument to be read by <code>getopts</code>) and leaves the remaining arguments to continue getting processed.</p>&#13;
<p class="indent">This script also makes use of a <em>here document</em> (discussed in <a href="ch01.xhtml#ch01lev1sec10">Script #9</a> on <a href="ch01.xhtml#page_34">page 34</a>), which is a type of code block that can be used to feed multiple lines of input to a command. Using this notational convenience, the script at <span class="ent">➌</span> feeds <code>nroff</code> all the necessary commands to achieve the desired output. In this document, we use a bashism to replace a variable that isn’t defined <span class="ent">➍</span>, in order to provide a sane default value if the user does not specify one as an argument. Finally, the script calls the <code>cat</code> command with the requested file names to process. To complete the task, the <code>cat</code> command’s output is also fed directly to <code>nroff</code> <span class="ent">➎</span>. This is a technique that will appear frequently in the scripts presented in this book.</p>&#13;
<h4 class="h4" id="ch02lev2sec03"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script can be invoked directly from the command line, but it would more likely be part of an external pipe invoked from within an editor like <code>vi</code> or <code>vim</code> (for example, <code>!}fmt</code>) to format a paragraph of text.</p>&#13;
<h4 class="h4" id="ch02lev2sec04"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta"><a href="ch02.xhtml#ch2ex3">Listing 2-3</a> enables hyphenation and specifies a maximum width of 50 characters.</p>&#13;
<pre class="programs">$ <span class="codestrong">fmt -h -w 50 014-ragged.txt</span>&#13;
So she sat on, with closed eyes, and half believed&#13;
herself in Wonderland, though she knew she had but&#13;
to open them again, and all would change to dull&#13;
reality--the grass would be only rustling in the&#13;
wind, and the pool rippling to the waving of the&#13;
reeds--the rattling teacups would change to <span class="codestrong">tin-</span>&#13;
<span class="codestrong">kling</span> sheep-bells, and the Queen's shrill cries&#13;
to the voice of the shepherd boy--and the sneeze&#13;
of the baby, the shriek of the Gryphon, and all&#13;
the other queer noises, would change (she knew) to&#13;
the confused clamour of the busy farm-yard--while&#13;
the lowing of the cattle in the distance would&#13;
take the place of the Mock Turtle's heavy sobs.</pre>&#13;
<p class="listcap"><a id="ch2ex3"/><em>Listing 2-3: Formatting text with the</em> <code><em>fmt</em></code> <em>script to hyphenate wrapped words at 50 characters</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_55"/>Compare <a href="ch02.xhtml#ch2ex3">Listing 2-3</a> (note the newly hyphenated word <code>tinkling</code>, highlighted on lines 6 and 7) with the output in <a href="ch02.xhtml#ch2ex4">Listing 2-4</a>, generated using the default width and no hyphenation.</p>&#13;
<pre class="programs">$ <span class="codestrong">fmt 014-ragged.txt</span>&#13;
So she sat on, with closed eyes, and half believed herself in&#13;
Wonderland, though she knew she had but to open them again, and all&#13;
would change to dull reality--the grass would be only rustling in the&#13;
wind, and the pool rippling to the waving of the reeds--the rattling&#13;
teacups would change to tinkling sheep-bells, and the Queen's shrill&#13;
cries to the voice of the shepherd boy--and the sneeze of the baby, the&#13;
shriek of the Gryphon, and all the other queer noises, would change (she&#13;
knew) to the confused clamour of the busy farm-yard--while the lowing of&#13;
the cattle in the distance would take the place of the Mock Turtle's&#13;
heavy sobs.</pre>&#13;
<p class="listcap"><a id="ch2ex4"/><em>Listing 2-4: The default formatting of the</em> <code><em>fmt</em></code> <em>script with no hyphenation</em></p>&#13;
<h3 class="h3" id="ch02lev1sec02"><strong>#15 Backing Up Files as They’re Removed</strong></h3>&#13;
<p class="noindenta">One of the most common problems that Unix users have is that there is no easy way to recover a file or folder that has been accidentally removed. There’s no user-friendly application like Undelete 360, WinUndelete, or an OS X utility that allows you to easily browse and restore deleted files at the touch of a button. Once you press <small>ENTER</small> after typing <code>rm <em>filename</em></code>, the file is history.</p>&#13;
<p class="indent">A solution to this problem is to secretly and automatically archive files and directories to a <em>.deleted-files</em> archive. With some fancy footwork in a script (as <a href="ch02.xhtml#ch2ex5">Listing 2-5</a> shows), this process can be made almost completely invisible to users.</p>&#13;
<h4 class="h4" id="ch02lev2sec05"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # newrm--A replacement for the existing rm command.&#13;
   #   This script provides a rudimentary unremove capability by creating and&#13;
   #   utilizing a new directory within the user's home directory. It can handle&#13;
   #   directories of content as well as individual files. If the user specifies&#13;
   #   the -f flag, files are removed and NOT archived.&#13;
&#13;
   # Big Important Warning: You'll want a cron job or something similar to keep&#13;
   #   the trash directories tamed. Otherwise, nothing will ever actually&#13;
   #   be deleted from the system, and you'll run out of disk space!&#13;
&#13;
   archivedir="$HOME/.deleted-files"&#13;
   realrm="$(which rm)"&#13;
   copy="$(which cp) -R"&#13;
&#13;
   if [ $# -eq 0 ] ; then            # Let 'rm' output the usage error.&#13;
     exec $realrm                    # Our shell is replaced by /bin/rm.&#13;
   fi&#13;
&#13;
   # Parse all options looking for '-f'&#13;
&#13;
   flags=""&#13;
&#13;
   while getopts "dfiPRrvW" opt&#13;
   do&#13;
     case $opt in&#13;
       f ) exec $realrm "$@"     ;;  # exec lets us exit this script directly.&#13;
       * ) flags="$flags -$opt"  ;;  # Other flags are for rm, not us.&#13;
     esac&#13;
   done&#13;
   shift $(( $OPTIND - 1 ))&#13;
&#13;
   # BEGIN MAIN SCRIPT&#13;
   # =================&#13;
&#13;
   # Make sure that the $archivedir exists.&#13;
&#13;
<span class="ent">➊</span> if [ ! -d $archivedir] ; then&#13;
     if [ ! -w $HOME ] ; then&#13;
       echo "$0 failed: can't create $archivedir in $HOME" &gt;&amp;2&#13;
       exit 1&#13;
     fi&#13;
     mkdir $archivedir&#13;
<span class="ent">➋</span>   chmod 700 $archivedir           # A little bit of privacy, please.&#13;
   fi&#13;
&#13;
   for arg&#13;
   do&#13;
<span class="ent">➌</span>   newname="$archivedir/$(date "+%S.%M.%H.%d.%m").$(basename "$arg")"&#13;
     if [ -f "$arg" -o -d "$arg" ] ; then&#13;
       $copy "$arg" "$newname"&#13;
     fi&#13;
   done&#13;
&#13;
<span class="ent">➍</span> exec $realrm $flags "$@"          # Our shell is replaced by realrm.</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_56"/><a id="ch2ex5"/><em>Listing 2-5: The</em> <code><em>newrm</em></code> <em>shell script, which backs up files before they are deleted from the disk</em></p>&#13;
<h4 class="h4" id="ch02lev2sec06"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">There are a bunch of cool things to consider in this script, not the least of which is the significant effort it puts forth to ensure that users aren’t aware it exists. For example, this script doesn’t generate error messages in situations where it can’t work; it just lets <code>realrm</code> generate them by invoking (typically) <em>/bin/rm</em> with possibly bad parameters. The calls to <code>realrm</code> are done with the <code>exec</code> command, which replaces the current process with the new process specified. As soon as <code>exec</code> invokes <code>realrm</code> <span class="ent">➍</span>, it effectively exits this script, and the return code from the <code>realrm</code> process is given to the invoking shell.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_57"/>Because this script secretly creates a directory in the user’s home directory <span class="ent">➊</span>, it needs to ensure that the files there aren’t suddenly readable by others simply because of a badly set <code>umask</code> value. (The <code>umask</code> value defines the default permissions for a newly created file or directory.) To avoid such oversharing, the script at <span class="ent">➋</span> uses <code>chmod</code> to ensure that the directory is set to read/write/execute for the user and is closed for everyone else.</p>&#13;
<p class="indent">Finally at <span class="ent">➌</span>, the script uses <code>basename</code> to strip out any directory information from the file’s path, and it adds a date- and timestamp to every deleted file in the form <em>second.minute.hour.day.month.filename</em>:</p>&#13;
<pre class="programs">newname="$archivedir/$(date "+"%S.%M.%H.%d.%m").$(basename "$arg")"</pre>&#13;
<p class="indent">Notice the use of multiple <code>$( )</code> elements in the same substitution. Though perhaps a bit complicated, it’s nonetheless helpful. Remember, anything between <code>$(</code> and <code>)</code> is fed into a subshell, and the whole expression is then replaced by the result of that command.</p>&#13;
<p class="indent">So why bother with a timestamp anyway? To support storing multiple deleted files with the same name. Once the files are archived, the script makes no distinction between <em>/home/oops.txt</em> and <em>/home/subdir/oops.txt</em>, other than by the times they were deleted. If multiple files with same name are deleted simultaneously (or within the same second), the files that were archived first will get overwritten. One solution to this problem would be to add the absolute paths of the original files to the archived filenames.</p>&#13;
<h4 class="h4" id="ch02lev2sec07"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">To install this script, add an alias so that when you enter <code>rm</code>, you actually run this script, not the <code>/bin/rm</code> command. A bash or ksh alias would look like this:</p>&#13;
<pre class="programs">alias rm=<span class="codeitalic">yourpath</span>/newrm</pre>&#13;
<h4 class="h4" id="ch02lev2sec08"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">The results of running this script are hidden by design (as <a href="ch02.xhtml#ch2ex6">Listing 2-6</a> shows), so let’s keep an eye on the <em>.deleted-files</em> directory along the way.</p>&#13;
<pre class="programs">$ <span class="codestrong">ls ~/.deleted-files</span>&#13;
ls: /Users/taylor/.deleted-files/: No such file or directory&#13;
$ <span class="codestrong">newrm file-to-keep-forever</span>&#13;
$ <span class="codestrong">ls ~/.deleted-files/</span>&#13;
51.36.16.25.03.file-to-keep-forever</pre>&#13;
<p class="listcap"><a id="ch2ex6"/><em>Listing 2-6: Testing the</em> <code><em>newrm</em></code> <em>shell script</em></p>&#13;
<p class="indent">Exactly right. While the file was deleted from the local directory, a copy of it was secretly squirreled away in the <em>.deleted-files</em> directory. The timestamp allows other deleted files with the same name to be stored in the same directory without overwriting each other.</p>&#13;
<h4 class="h4" id="ch02lev2sec09"><span epub:type="pagebreak" id="page_58"/><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">One useful tweak would be to change the timestamp so that it’s in reverse time order to produce file listings from <code>ls</code> in chronological order. Here’s the line to modify the script:</p>&#13;
<pre class="programs">newname="$archivedir/$(date "+"%S.%M.%H.%d.%m").$(basename "$arg")"</pre>&#13;
<p class="indent">You could reverse the order of tokens in that formatted request so that the original filename is first and the date is second in the backed-up filename. However, since our time granularity is seconds, you might remove more than one version of an identically named file within the same second (for example, <code>rm test testdir/test</code>), resulting in two identically named files. Therefore, another useful modification would be to incorporate the location of the file into the archived copy. This would produce, for example, <em>timestamp.test</em> and <em>timestamp.testdir.test</em>, which are clearly two different files.</p>&#13;
<h3 class="h3" id="ch02lev1sec03"><strong>#16 Working with the Removed File Archive</strong></h3>&#13;
<p class="noindenta">Now that a directory of deleted files is hidden within the user’s home directory, a script to let the user choose between different versions of deleted files would be useful. However, it’s quite a task to address all the possible situations, ranging from not finding the specified file at all to finding multiple deleted files that match the given criteria. In the case of more than one match, for example, should the script automatically pick the newest file to undelete? Throw an error indicating how many matches there are? Or present the different versions and let the user pick? Let’s see what we can do with <a href="ch02.xhtml#ch2ex7">Listing 2-7</a>, which details the <code>unrm</code> shell script.</p>&#13;
<h4 class="h4" id="ch02lev2sec10"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # unrm--Searches the deleted files archive for the specified file or&#13;
   #   directory. If there is more than one matching result, it shows a list&#13;
   #   of results ordered by timestamp and lets the user specify which one&#13;
   #   to restore.&#13;
&#13;
   archivedir="$HOME/.deleted-files"&#13;
   realrm="$(which rm)"&#13;
   move="$(which mv)"&#13;
&#13;
   dest=$(pwd)&#13;
&#13;
   if [ ! -d $archivedir ] ; then&#13;
     echo "$0: No deleted files directory: nothing to unrm" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
<span epub:type="pagebreak" id="page_59"/>   cd $archivedir&#13;
&#13;
   # If given no arguments, just show a listing of the deleted files.&#13;
<span class="ent">➊</span> if [ $# -eq 0 ] ; then&#13;
     echo "Contents of your deleted files archive (sorted by date):"&#13;
<span class="ent">➋</span>   ls -FC | sed -e 's/\([[:digit:]][[:digit:]]\.\)\{5\}//g' \&#13;
       -e 's/^/ /'&#13;
     exit 0&#13;
   fi&#13;
&#13;
   # Otherwise, we must have a user-specified pattern to work with.&#13;
   #   Let's see if the pattern matches more than one file or directory&#13;
   #   in the archive.&#13;
&#13;
<span class="ent">➌</span> matches="$(ls -d *"$1" 2&gt; /dev/null | wc -l)"&#13;
&#13;
   if [ $matches -eq 0 ] ; then&#13;
     echo "No match for \"$1\" in the deleted file archive." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
<span class="ent">➍</span> if [ $matches -gt 1 ] ; then&#13;
     echo "More than one file or directory match in the archive:"&#13;
     index=1&#13;
     for name in $(ls -td *"$1")&#13;
     do&#13;
       datetime="$(echo $name | cut -c1-14| \&#13;
<span class="ent">➎</span>       awk -F. '{ print $5"/"$4" at "$3":"$2":"$1 }')"&#13;
       filename="$(echo $name | cut -c16-)"&#13;
       if [ -d $name ] ; then&#13;
<span class="ent">➏</span>      filecount="$(ls $name | wc -l | sed 's/[^[:digit:]]//g')"&#13;
         echo " $index) $filename (contents = ${filecount} items," \&#13;
              " deleted = $datetime)"&#13;
       else&#13;
<span class="ent">➐</span>       size="$(ls -sdk1 $name | awk '{print $1}')"&#13;
         echo " $index) $filename (size = ${size}Kb, deleted = $datetime)"&#13;
       fi&#13;
       index=$(( $index + 1))&#13;
     done&#13;
     echo ""&#13;
     /bin/echo -n "Which version of $1 should I restore ('0' to quit)? [1] : "&#13;
     read desired&#13;
     if [ ! -z "$(echo $desired | sed 's/[[:digit:]]//g')" ] ; then&#13;
       echo "$0: Restore canceled by user: invalid input." &gt;&amp;2&#13;
       exit 1&#13;
     fi&#13;
&#13;
     if [ ${desired:=1} -ge $index ] ; then&#13;
       echo "$0: Restore canceled by user: index value too big." &gt;&amp;2&#13;
       exit 1&#13;
     fi&#13;
&#13;
<span epub:type="pagebreak" id="page_60"/>     if [ $desired -lt 1 ] ; then&#13;
       echo "$0: Restore canceled by user." &gt;&amp;2&#13;
       exit 1&#13;
     fi&#13;
&#13;
<span class="ent">➑</span>   restore="$(ls -td1 *"$1" | sed -n "${desired}p")"&#13;
&#13;
<span class="ent">➒</span>   if [ -e "$dest/$1" ] ; then&#13;
       echo "\"$1\" already exists in this directory. Cannot overwrite." &gt;&amp;2&#13;
       exit 1&#13;
     fi&#13;
&#13;
     /bin/echo -n "Restoring file \"$1\" ..."&#13;
     $move "$restore" "$dest/$1"&#13;
     echo "done."&#13;
&#13;
<span class="ent">➓</span>   /bin/echo -n "Delete the additional copies of this file? [y] "&#13;
     read answer&#13;
&#13;
     if [ ${answer:=y} = "y" ] ; then&#13;
       $realrm -rf *"$1"&#13;
       echo "Deleted."&#13;
     else&#13;
       echo "Additional copies retained."&#13;
     fi&#13;
   else&#13;
     if [ -e "$dest/$1" ] ; then&#13;
       echo "\"$1\" already exists in this directory. Cannot overwrite." &gt;&amp;2&#13;
       exit 1&#13;
     fi&#13;
&#13;
     restore="$(ls -d *"$1")"&#13;
&#13;
     /bin/echo -n "Restoring file \"$1\" ... "&#13;
     $move "$restore" "$dest/$1"&#13;
     echo "Done."&#13;
   fi&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch2ex7"/><em>Listing 2-7: The</em> <code><em>unrm</em></code> <em>shell script for restoring backed-up files</em></p>&#13;
<h4 class="h4" id="ch02lev2sec11"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The first chunk of code at <span class="ent">➊</span>, the <code>if [$# -eq 0]</code> conditional block, executes if no arguments are specified, displaying the contents of the deleted files archive. However, there’s a catch: we don’t want to show the user the timestamp data we added to the filenames since that’s only for the script’s internal use. It would just clutter up the output. In order to display this data in a more attractive format, the <code>sed</code> statement at <span class="ent">➋</span> deletes the first five occurrences of <em>digit digit dot</em> in the <code>ls</code> output.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_61"/>The user can specify the name of the file or directory to recover as an argument. The next step at <span class="ent">➌</span> is to ascertain how many matches there are for the name provided.</p>&#13;
<p class="indent">The unusual use of nested double quotes in this line (around <code>$1</code>) is to ensure <code>ls</code> matches filenames with embedded spaces, while the <code>*</code> wildcard expands the match to include any preceding timestamp. The <code>2&gt; /dev/null</code> sequence is used to discard any error resulting from the command instead of showing it to the user. The errors being discarded will most likely be <em>No such file or directory</em>, when the specified filename isn’t found.</p>&#13;
<p class="indent">If there are multiple matches for the given file or directory name, then the most complex part of this script, the <code>if [ $matches -gt 1 ]</code> block at <span class="ent">➍</span>, is executed and displays all the results. Using the <code>-t</code> flag for the <code>ls</code> command in the main <code>for</code> loop causes the archive files to be presented from newest to oldest, and at <span class="ent">➎</span>, a succinct call to the <code>awk</code> command translates the timestamp portion of the filename into a deletion date and time in parentheses. In the size calculation at <span class="ent">➐</span>, the inclusion of the <code>-k</code> flag to <code>ls</code> forces the file sizes to be represented in kilobytes.</p>&#13;
<p class="indent">Rather than displaying the size of matching directory entries, the script displays the number of files within each matching directory, which is a more helpful statistic. The number of entries within a directory is easy to calculate. At <span class="ent">➏</span>, we just count the number of lines given by <code>ls</code> and strip any spaces out of the <code>wc</code> output.</p>&#13;
<p class="indent">Once the user specifies one of the possible matching files or directories, the exact file is identified at <span class="ent">➑</span>. This statement contains a slightly different use of <code>sed</code>. Specifying the <code>-n</code> flag with a line number (<code>${desired}</code>) followed by the <code>p</code> (print) command is a very fast way to extract only the specified line from the input stream. Want to see only line 37? The command <code>sed -n 37p</code> does just that.</p>&#13;
<p class="indent">Then there’s a test at <span class="ent">➒</span> to ensure that <code>unrm</code> isn’t going to step on an existing copy of the file, and the file or directory is restored with a call to <code>/bin/mv</code>. Once that’s finished, the user is given a chance to remove the additional (probably superfluous) copies of the file <span class="ent">➓</span>, and the script is done.</p>&#13;
<p class="indent">Note that using <code>ls</code> with <code>*"$1"</code> matches any filenames ending with the value in <code>$1</code>, so the list of multiple “matching files” may contain more than just the file the user wants to restore. For instance, if the deleted files directory contains the files <em>11.txt</em> and <em>111.txt</em>, running <code>unrm 11.txt</code> would signal that it found multiple matches and return listings for both <em>11.txt</em> and <em>111.txt</em>. While that might be okay, once the user chooses to restore the correct file (<em>11.txt</em>), accepting the prompt to delete additional copies of the file would also remove <em>111.txt</em>. Therefore, defaulting to delete under those circumstances might not be optimal. However, this could be easily overcome by using the <code>??.??.??.??.??."$1"</code> pattern instead, if you kept the same timestamp format for <code>newrm</code> as shown in <a href="ch02.xhtml#ch02lev1sec02">Script #15</a> on <a href="ch02.xhtml#page_55">page 55</a>.</p>&#13;
<h4 class="h4" id="ch02lev2sec12"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">There are two ways to run this script. Without any arguments, the script will show a listing of all files and directories in the user’s deleted files archive. <span epub:type="pagebreak" id="page_62"/>When given a filename as its argument, the script will try to restore that file or directory (if there’s only one match), or it will show a list of candidates for restoration and allow the user to specify which version of the deleted file or directory to restore.</p>&#13;
<h4 class="h4" id="ch02lev2sec13"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">Without any arguments specified, the script shows what’s in the deleted files archive as <a href="ch02.xhtml#ch2ex8">Listing 2-8</a> shows.</p>&#13;
<pre class="programs">$ <span class="codestrong">unrm</span>&#13;
Contents of your deleted files archive (sorted by date):&#13;
  detritus            this is a test&#13;
  detritus            garbage</pre>&#13;
<p class="listcap"><a id="ch2ex8"/><em>Listing 2-8: Running the</em> <code><em>unrm</em></code> <em>shell script with no arguments lists the current files available to restore</em></p>&#13;
<p class="indent">When a filename is specified, the script displays more information about the file if there are multiple files with that name, as shown in <a href="ch02.xhtml#ch2ex9">Listing 2-9</a>.</p>&#13;
<pre class="programs">$ <span class="codestrong">unrm detritus</span>&#13;
More than one file or directory match in the archive:&#13;
 1)   detritus (size = 7688Kb, deleted = 11/29 at 10:00:12)&#13;
 2)   detritus  (size = 4Kb, deleted = 11/29 at 09:59:51)&#13;
&#13;
Which version of detritus should I restore ('0' to quit)? [1] : <span class="codestrong">0</span>&#13;
unrm: Restore canceled by user.</pre>&#13;
<p class="listcap"><a id="ch2ex9"/><em>Listing 2-9: Running the</em> <code><em>unrm</em></code> <em>shell script with a single argument attempts to restore the file</em></p>&#13;
<h4 class="h4" id="ch02lev2sec14"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">If you use this script, be aware that without any controls or limits, the files and directories in the deleted files archive will grow without bound. To avoid this, invoke <code>find</code> from within a <code>cron</code> job to prune the deleted files archive, using the <code>-mtime</code> flag to identify those files that have been sitting untouched for weeks. A 14-day archive is probably quite sufficient for most users and will keep the archival script from consuming too much disk space.</p>&#13;
<p class="indent">While we’re at it, there are some improvements that could make this script more user friendly. Think about adding starting flags like <code>-l</code> to <code>restore latest</code> and <code>-D</code> to <code>delete 00additional copies of the file</code>. Which flags would you add, and how would they streamline processing?</p>&#13;
<h3 class="h3" id="ch02lev1sec04"><strong>#17 Logging File Removals</strong></h3>&#13;
<p class="noindenta">Instead of archiving deleted files, you may just want to keep track of what deletions are happening on your system. In <a href="ch02.xhtml#ch2ex10">Listing 2-10</a>, file deletions with the <code>rm</code> command will be logged in a separate file without notifying the user. <span epub:type="pagebreak" id="page_63"/>This can be accomplished by using the script as a wrapper. The basic idea of wrappers is that they live between an actual Unix command and the user, offering the user useful functionality that’s not available with the original command alone.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>Wrappers are such a powerful concept that you’ll see them show up time and again as you go through this book.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch02lev2sec15"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # logrm--Logs all file deletion requests unless the -s flag is used&#13;
&#13;
   removelog="/var/log/remove.log"&#13;
&#13;
<span class="ent">➊</span> if [ $# -eq 0 ] ; then&#13;
     echo "Usage: $0 [-s] list of files or directories" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
<span class="ent">➋</span> if [ "$1" = "-s" ] ; then&#13;
     # Silent operation requested ... don't log.&#13;
     shift&#13;
   else&#13;
<span class="ent">➌</span>   echo "$(date): ${USER}: $@" &gt;&gt; $removelog&#13;
   fi&#13;
&#13;
<span class="ent">➍</span> /bin/rm "$@"&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch2ex10"/><em>Listing 2-10: The</em> <code><em>logrm</em></code> <em>shell script</em></p>&#13;
<h4 class="h4" id="ch02lev2sec16"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The first section <span class="ent">➊</span> tests the user input, generating a simple file listing if no arguments are given. Then at <span class="ent">➋</span>, the script tests whether argument <code>1</code> is <code>-s</code>; if so, it skips logging the removal request. Finally, the timestamp, user, and command are added to the <em>$removelog</em> file <span class="ent">➌</span>, and the user command is silently passed over to the real <em>/bin/rm</em> program <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch02lev2sec17"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">Rather than giving this script a name like <code>logrm</code>, a typical way to install a wrapper program is to rename the underlying command it’s intending to wrap and then install the wrapper using the original command’s old name. If you choose this route, however, make sure that the wrapper invokes the newly renamed program, not itself! For example, if you rename <em>/bin/rm</em> to <em>/bin/rm.old</em>, and name this script <em>/bin/rm</em>, then the last few lines of the script will need to be changed so that it invokes <em>/bin/rm.old</em> instead of itself.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_64"/>Alternatively, you can use an alias to replace standard <code>rm</code> calls with this command:</p>&#13;
<pre class="programs">alias rm=logrm</pre>&#13;
<p class="indent">In either case, you will need write and execute access to <em>/var/log</em>, which might not be the default configuration on your particular system.</p>&#13;
<h4 class="h4" id="ch02lev2sec18"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">Let’s create a few files, delete them, and then examine the remove log, as shown in <a href="ch02.xhtml#ch2ex11">Listing 2-11</a>.</p>&#13;
<pre class="programs">$ <span class="codestrong">touch unused.file ciao.c /tmp/junkit</span>&#13;
$ <span class="codestrong">logrm unused.file /tmp/junkit</span>&#13;
$ <span class="codestrong">logrm ciao.c</span>&#13;
$ <span class="codestrong">cat /var/log/remove.log</span>&#13;
Thu Apr  6 11:32:05 MDT 2017: susan: /tmp/central.log&#13;
Fri Apr  7 14:25:11 MDT 2017: taylor: unused.file /tmp/junkit&#13;
Fri Apr  7 14:25:14 MDT 2017: taylor: ciao.c</pre>&#13;
<p class="listcap"><a id="ch2ex11"/><em>Listing 2-11: Testing the</em> <code><em>logrm</em></code> <em>shell script</em></p>&#13;
<p class="indent">Aha! Notice that on Thursday, user Susan deleted the file <em>/tmp/central.log</em>.</p>&#13;
<h4 class="h4" id="ch02lev2sec19"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">There’s a potential log file ownership permission problem here. Either the <em>remove.log</em> file is writable by all, in which case a user could clear its contents out with a command like <code>cat /dev/null &gt; /var/log/remove.log</code>, or it isn’t writable by all, in which case the script can’t log the events. You could use a <code>setuid</code> permission—with the script running as root—so that the script runs with the same permissions as the log file. However, there are two problems with this approach. First, it’s a really bad idea! Never run shell scripts under <code>setuid</code>! By using <code>setuid</code> to run a command as a specific user, no matter who is executing the command, you are potentially introducing security weaknesses to your system. Second, you could get into a situation where the users have permission to delete their files but the script doesn’t, and because the effective uid set with <code>setuid</code> would be inherited by the <code>rm</code> command itself, things would break. Great confusion would ensue when users couldn’t even remove their own files!</p>&#13;
<p class="indent">If you have an ext2, ext3, or ext4 filesystem (as is usually the case with Linux), a different solution is to use the <code>chattr</code> command to set a specific append-only file permission on the log file and then leave it writable to all without any danger. Yet another solution is to write the log messages to <code>syslog</code>, using the helpful <code>logger</code> command. Logging the <code>rm</code> commands with <code>logger</code> is straightforward, as shown here:</p>&#13;
<pre class="programs">logger -t logrm "${USER:-LOGNAME}: $*"</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_65"/>This adds an entry to the <code>syslog</code> data stream, which is untouchable by regular users and is tagged with <code>logrm</code>, the username, and the command specified.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>If you opt to use</em> <code><em>logger</em></code><em>, you’ll want to check</em> <code><em>syslogd(8)</em></code> <em>to ensure that your configuration doesn’t discard</em> <code><em>user.notice</em></code> <em>priority log events. It’s almost always specified in the</em> /etc/syslogd.conf <em>file.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch02lev1sec05"><strong>#18 Displaying the Contents of Directories</strong></h3>&#13;
<p class="noindenta">One aspect of the <code>ls</code> command has always seemed pointless: when a directory is listed, <code>ls</code> either lists the directory’s contents file by file or shows the number of 1,024-byte blocks required for the directory data. A typical entry in an <code>ls -l</code> output might be something like this:</p>&#13;
<pre class="programs">drwxrwxr-x    2 taylor   taylor        4096 Oct 28 19:07 bin</pre>&#13;
<p class="indent">But that’s not very useful! What we really want to know is how many files are in the directory. That’s what the script in <a href="ch02.xhtml#ch2ex12">Listing 2-12</a> does. It generates a nice multicolumn listing of files and directories, showing files with their sizes and directories with the number of files they contain.</p>&#13;
<h4 class="h4" id="ch02lev2sec20"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # formatdir--Outputs a directory listing in a friendly and useful format&#13;
&#13;
   # Note that you need to ensure "scriptbc" (<a href="ch01.xhtml#ch01lev1sec10">Script #9</a>) is in your current path&#13;
   #   because it's invoked within the script more than once.&#13;
&#13;
   scriptbc=$(which scriptbc)&#13;
&#13;
&#13;
   # Function to format sizes in KB to KB, MB, or GB for more readable output&#13;
<span class="ent">➊</span> readablesize()&#13;
   {&#13;
&#13;
     if [ $1 -ge 1048576 ] ; then&#13;
       echo "$($scriptbc -p 2 $1 / 1048576)GB"&#13;
     elif [ $1 -ge 1024 ] ; then&#13;
       echo "$($scriptbc -p 2 $1 / 1024)MB"&#13;
     else&#13;
       echo "${1}KB"&#13;
     fi&#13;
   }&#13;
&#13;
   #################&#13;
   ## MAIN CODE&#13;
&#13;
   if [ $# -gt 1 ] ; then&#13;
     echo "Usage: $0 [dirname]" &gt;&amp;2&#13;
     exit 1&#13;
<span class="ent">➋</span> elif [ $# -eq 1 ] ; then   # Specified a directory other than the current one?&#13;
     cd "$@"                  # Then let's change to that one.&#13;
     if [ $? -ne 0 ] ; then   # Or quit if the directory doesn't exist.&#13;
       exit 1&#13;
     fi&#13;
   fi&#13;
&#13;
   for file in *&#13;
   do&#13;
     if [ -d "$file" ] ; then&#13;
<span class="ent">➌</span>     size=$(ls "$file" | wc -l | sed 's/[^[:digit:]]//g')&#13;
       if [ $size -eq 1 ] ; then&#13;
         echo "$file ($size entry)|"&#13;
       else&#13;
         echo "$file ($size entries)|"&#13;
       fi&#13;
     else&#13;
       size="$(ls -sk "$file" | awk '{print $1}')"&#13;
<span class="ent">➍</span>     echo "$file ($(readablesize $size))|"&#13;
     fi&#13;
   done | \&#13;
<span class="ent">➎</span>   sed 's/ /^^^/g' | \&#13;
     xargs -n 2 | \&#13;
     sed 's/\^\^\^/ /g' | \&#13;
<span class="ent">➏</span>   awk -F\| '{ printf "%-39s %-39s\n", $1, $2 }'&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_66"/><a id="ch2ex12"/><em>Listing 2-12: The</em> <code><em>formatdir</em></code> <em>shell script for more readable directory listings</em></p>&#13;
<h4 class="h4" id="ch02lev2sec21"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">One of the most interesting parts of this script is the <code>readablesize</code> function <span class="ent">➊</span>, which accepts numbers in kilobytes and outputs their value in either kilobytes, megabytes, or gigabytes, depending on which unit is most appropriate. Instead of having the size of a very large file shown as 2,083,364KB, for example, this function will instead show a size of 2.08GB. Note that <code>readablesize</code> is called with the <code>$( )</code> notation <span class="ent">➍</span>:</p>&#13;
<pre class="programs">echo "$file ($(readablesize $size))|"</pre>&#13;
<p class="indent">Since subshells automatically inherit any functions defined in the running shell, the subshell created by the <code>$()</code> sequence has access to the <code>readablesize</code> function. Handy.</p>&#13;
<p class="indent">Near the top of the script at <span class="ent">➋</span>, there is also a shortcut that allows users to specify a directory other than the current directory and then changes the current working directory of the running shell script to the desired location, simply by using <code>cd</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_67"/>The main logic of this script involves organizing its output into two neat, aligned columns. One issue to deal with is that you can’t simply replace spaces with line breaks in the output stream, because files and directories may have spaces within their names. To get around this problem, the script at <span class="ent">➎</span> first replaces each space with a sequence of three carets (<code>^^^</code>). Then it uses the <code>xargs</code> command to merge paired lines so that every group of two lines becomes one line separated by a real, expected space. Finally, at <span class="ent">➏</span> it uses the <code>awk</code> command to output columns in the proper alignment.</p>&#13;
<p class="indent">Notice how the number of (nonhidden) entries in a directory is easily calculated at <span class="ent">➌</span> with a quick call to <code>wc</code> and a <code>sed</code> invocation to clean up the output:</p>&#13;
<pre class="programs">size=$(ls "$file" | wc -l | sed 's/[^[:digit:]]//g')</pre>&#13;
<h4 class="h4" id="ch02lev2sec22"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">For a listing of the current directory, invoke the command without arguments, as <a href="ch02.xhtml#ch2ex13">Listing 2-13</a> shows. For information about the contents of a different directory, specify a directory name as the sole command line argument.</p>&#13;
<h4 class="h4" id="ch02lev2sec23"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">formatdir ~</span>&#13;
Applications (0 entries)                Classes (4KB)&#13;
DEMO (5 entries)                        Desktop (8 entries)&#13;
Documents (38 entries)                  Incomplete (9 entries)&#13;
IntermediateHTML (3 entries)            Library (38 entries)&#13;
Movies (1 entry)                        Music (1 entry)&#13;
NetInfo (9 entries)                     Pictures (38 entries)&#13;
Public (1 entry)                        RedHat 7.2 (2.08GB)&#13;
Shared (4 entries)                      Synchronize! Volume ID (4KB)&#13;
X Desktop (4KB)                         automatic-updates.txt (4KB)&#13;
bin (31 entries)                        cal-liability.tar.gz (104KB)&#13;
cbhma.tar.gz (376KB)                    errata (2 entries)&#13;
fire aliases (4KB)                      games (3 entries)&#13;
junk (4KB)                              leftside navbar (39 entries)&#13;
mail (2 entries)                        perinatal.org (0 entries)&#13;
scripts.old (46 entries)                test.sh (4KB)&#13;
testfeatures.sh (4KB)                   topcheck (3 entries)&#13;
tweakmktargs.c (4KB)                    websites.tar.gz (18.85MB)</pre>&#13;
<p class="listcap"><a id="ch2ex13"/><em>Listing 2-13: Testing the</em> <code><em>formatdir</em></code> <em>shell script</em></p>&#13;
<h4 class="h4" id="ch02lev2sec24"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">An issue worth considering is whether you happen to have a user who likes to use sequences of three carets in filenames. This naming convention is pretty unlikely—a 116,696-file Linux install that we spot-tested didn’t have <span epub:type="pagebreak" id="page_68"/>even a single caret within any of its filenames—but if it did occur, you’d get some confusing output. If you’re concerned, you could address this potential pitfall by translating spaces into another sequence of characters that’s even less likely to occur in user filenames. Four carets? Five?</p>&#13;
<h3 class="h3" id="ch02lev1sec06"><strong>#19 Locating Files by Filename</strong></h3>&#13;
<p class="noindenta">One command that’s quite useful on Linux systems, but isn’t always present on other Unix flavors, is <code>locate</code>, which searches a prebuilt database of filenames for a user-specified regular expression. Ever want to quickly find the location of the master <em>.cshrc</em> file? Here’s how that’s done with <code>locate</code>:</p>&#13;
<div class="imagec"><img src="../images/f0068-01.jpg" alt="image"/></div>&#13;
<p class="indent">You can see that the master <em>.cshrc</em> file is in the <em>/private/etc</em> directory on this OS X system. The version of <code>locate</code> we’re going to build sees every file on the disk when building its internal file index, whether the file is in the trash queue or on a separate volume or even if it’s a hidden dotfile. This is both an advantage and a disadvantage, as we will discuss shortly.</p>&#13;
<h4 class="h4" id="ch02lev2sec25"><em><strong>The Code</strong></em></h4>&#13;
<p class="noindenta">This method of finding files is simple to implement and comes in two scripts. The first (shown in <a href="ch02.xhtml#ch2ex14">Listing 2-14</a>) builds a database of all filenames by invoking <code>find</code>, and the second (shown in <a href="ch02.xhtml#ch2ex15">Listing 2-15</a>) is a simple <code>grep</code> of the new database.</p>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # mklocatedb--Builds the locate database using find. User must be root&#13;
   #   to run this script.&#13;
&#13;
   locatedb="/var/locate.db"&#13;
&#13;
<span class="ent">➊</span> if [ "$(whoami)" != "root" ] ; then&#13;
     echo "Must be root to run this command." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   find / -print &gt; $locatedb&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch2ex14"/><em>Listing 2-14: The</em> <code><em>mklocatedb</em></code> <em>shell script</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_69"/>The second script is even shorter.</p>&#13;
<pre class="programs">#!/bin/sh&#13;
&#13;
# locate--Searches the locate database for the specified pattern&#13;
&#13;
locatedb="/var/locate.db"&#13;
&#13;
exec grep -i "$@" $locatedb</pre>&#13;
<p class="listcap"><a id="ch2ex15"/><em>Listing 2-15: The</em> <code><em>locate</em></code> <em>shell script</em></p>&#13;
<h4 class="h4" id="ch02lev2sec26"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The <code>mklocatedb</code> script must be run as the root user to ensure that it can see all the files in the entire system, so this is checked at <span class="ent">➊</span> with a call to <code>whoami</code>. Running any script as root, however, is a security problem because if a directory is closed to a specific user’s access, the <code>locate</code> database shouldn’t store any information about the directory or its contents. This issue will be addressed in <a href="ch05.xhtml#ch05">Chapter 5</a> with a new, more secure <code>locate</code> script that takes privacy and security into account (see <a href="ch05.xhtml#ch05lev1sec05">Script #39</a> on <a href="ch05.xhtml#page_127">page 127</a>). For now, however, this script exactly emulates the behavior of the <code>locate</code> command in standard Linux, OS X, and other distributions.</p>&#13;
<p class="indent">Don’t be surprised if <code>mklocatedb</code> takes a few minutes or longer to run; it’s traversing the entire filesystem, which can take a while on even a mediumsized system. The results can be quite large, too. On one OS X system we tested, the <em>locate.db</em> file had over 1.5 million entries and ate up 1874.5MB of disk space.</p>&#13;
<p class="indent">Once the database is built, the <code>locate</code> script itself is a breeze to write; it’s just a call to the <code>grep</code> command with whatever arguments are specified by the user.</p>&#13;
<h4 class="h4" id="ch02lev2sec27"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">To run the <code>locate</code> script, it’s first necessary to run <code>mklocatedb</code>. Once that’s done, <code>locate</code> invocations will almost instantly find all matching files on the system for any pattern specified.</p>&#13;
<h4 class="h4" id="ch02lev2sec28"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">The <code>mklocatedb</code> script has no arguments or output, as <a href="ch02.xhtml#ch2ex16">Listing 2-16</a> shows.</p>&#13;
<pre class="programs">$ <span class="codestrong">sudo mklocatedb</span>&#13;
Password:&#13;
...&#13;
<span class="codeitalic">Much time passes</span>&#13;
...&#13;
$</pre>&#13;
<p class="listcap"><a id="ch2ex16"/><em>Listing 2-16: Running the</em> <code><em>mklocatedb</em></code> <em>shell script as root with the</em> <code><em>sudo</em></code> <em>command</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_70"/>We can check the size of the database with a quick <code>ls</code>, as shown here:</p>&#13;
<pre class="programs">$ <span class="codestrong">ls -l /var/locate.db</span>&#13;
-rw-r--r--  1 root  wheel  174088165 Mar 26 10:02 /var/locate.db</pre>&#13;
<p class="indent">Now we’re ready to start finding files on the system using <code>locate</code>:</p>&#13;
<pre class="programs">$ <span class="codestrong">locate -i solitaire</span>&#13;
/Users/taylor/Documents/AskDaveTaylor image folders/0-blog-pics/vista-search-&#13;
solitaire.png&#13;
/Users/taylor/Documents/AskDaveTaylor image folders/8-blog-pics/windows-play-&#13;
solitaire-1.png&#13;
/usr/share/emacs/22.1/lisp/play/solitaire.el.gz&#13;
/usr/share/emacs/22.1/lisp/play/solitaire.elc&#13;
/Volumes/MobileBackups/Backups.backupdb/Dave's MBP/2014-04-03-163622/BigHD/&#13;
Users/taylor/Documents/AskDaveTaylor image folders/0-blog-pics/vista-search-&#13;
solitaire.png&#13;
/Volumes/MobileBackups/Backups.backupdb/Dave's MBP/2014-04-03-163622/BigHD/&#13;
Users/taylor/Documents/AskDaveTaylor image folders/8-blog-pics/windows-play-&#13;
solitaire-3.png</pre>&#13;
<p class="indent">This script also lets you ascertain other interesting statistics about your system, such as how many C source files you have, like this:</p>&#13;
<pre class="programs">$ <span class="codestrong">locate '\.c$' | wc -l</span>&#13;
  1479</pre>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>Pay attention to the regular expression here. The</em> <code><em>grep</em></code> <em>command requires us to escape the dot (</em><code>.</code><em>) or it will match any single character. Also, the</em> <code><em>$</em></code> <em>denotes the end of the line or, in this case, the end of the filename.</em></p>&#13;
</div>&#13;
<p class="indent">With a bit more work, we could feed each one of these C source files to the <code>wc</code> command and ascertain the total number of lines of C code on the system, but, um, that would be kinda daft, wouldn’t it?</p>&#13;
<h4 class="h4" id="ch02lev2sec29"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">To keep the database reasonably up-to-date, it would be easy to schedule <code>mklocatedb</code> to run from <code>cron</code> in the wee hours of the night on a weekly basis— as most systems with built-in <code>locate</code> commands do—or even more frequently based on local usage patterns. As with any script executed by the root user, take care to ensure that the script itself isn’t editable by non-root users.</p>&#13;
<p class="indent">One potential improvement to this script would be to have <code>locate</code> check its invocation and fail with a meaningful error message if no pattern is specified or if the <em>locate.db</em> file doesn’t exist. As it’s written now, the script will spit out a standard <code>grep</code> error instead, which isn’t very useful. More importantly, as we discussed earlier, there’s a significant security issue with letting users <span epub:type="pagebreak" id="page_71"/>have access to a listing of all filenames on the system, including those they wouldn’t ordinarily be able to see. A security improvement to this script is addressed in <a href="ch05.xhtml#ch05lev1sec05">Script #39</a> on <a href="ch05.xhtml#page_127">page 127</a>.</p>&#13;
<h3 class="h3" id="ch02lev1sec07"><strong>#20 Emulating Other Environments: MS-DOS</strong></h3>&#13;
<p class="noindenta">Though it’s unlikely you’ll ever need them, it’s interesting and illustrative of some scripting concepts to create versions of classic MS-DOS commands, like <code>DIR</code>, as Unix-compatible shell scripts. Sure, we could just use a shell alias to map <code>DIR</code> to the Unix <code>ls</code> command, as in this example:</p>&#13;
<pre class="programs">alias DIR=ls</pre>&#13;
<p class="indent">But this mapping doesn’t emulate the actual behavior of the command; it just helps forgetful people learn new command names. If you’re hip to the ancient ways of computing, you’ll remember that the <code>/W</code> option produces a wide listing format, for example. But if you specify <code>/W</code> to the <code>ls</code> command now, the program will just complain that the <code>/W</code> directory doesn’t exist. Instead, the following <code>DIR</code> script in <a href="ch02.xhtml#ch2ex17">Listing 2-17</a> can be written so that it works with the forward-slash style of command flags.</p>&#13;
<h4 class="h4" id="ch02lev2sec30"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # DIR--Pretends we're the DIR command in DOS and displays the contents&#13;
   #   of the specified file, accepting some of the standard DIR flags&#13;
&#13;
   function usage&#13;
   {&#13;
   cat &lt;&lt; EOF &gt;&amp;2&#13;
     Usage: $0 [DOS flags] directory or directories&#13;
     Where:&#13;
      /D           sort by columns&#13;
      /H           show help for this shell script&#13;
      /N           show long listing format with filenames on right&#13;
      /OD          sort by oldest to newest&#13;
      /O-D         sort by newest to oldest&#13;
      /P           pause after each screenful of information&#13;
      /Q           show owner of the file&#13;
      /S           recursive listing&#13;
      /W           use wide listing format&#13;
   EOF&#13;
     exit 1&#13;
   }&#13;
&#13;
   #####################&#13;
   ### MAIN BLOCK&#13;
&#13;
   postcmd=""&#13;
   flags=""&#13;
   while [ $# -gt 0 ]&#13;
   do&#13;
     case $1 in&#13;
       /D        ) flags="$flags -x"      ;;&#13;
       /H        ) usage                  ;;&#13;
<span class="ent">➊</span>     /[NQW]    ) flags="$flags -l"      ;;&#13;
       /OD       ) flags="$flags -rt"     ;;&#13;
       /O-D      ) flags="$flags -t"      ;;&#13;
       /P        ) postcmd="more"         ;;&#13;
       /S        ) flags="$flags -s"      ;;&#13;
               * ) # Unknown flag: probably a DIR specifier break;&#13;
                   #   so let's get out of the while loop.&#13;
     esac&#13;
     shift         # Processed flag; let's see if there's another.&#13;
   done&#13;
&#13;
   # Done processing flags; now the command itself:&#13;
&#13;
   if [ ! -z "$postcmd" ] ; then&#13;
     ls $flags "$@" | $postcmd&#13;
   else&#13;
     ls $flags "$@"&#13;
   fi&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_72"/><a id="ch2ex17"/><em>Listing 2-17: The</em> <code><em>DIR</em></code> <em>shell script for emulating the</em> <code><em>DIR</em></code> <em>DOS command on Unix</em></p>&#13;
<h4 class="h4" id="ch02lev2sec31"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">This script highlights the fact that shell <code>case</code> statement conditional tests are actually regular expression tests. You can see at <span class="ent">➊</span> that the DOS flags <code>/N</code>, <code>/Q</code>, and <code>/W</code> all map to the same <code>-l Unix</code> flag in the final invocation of the <code>ls</code> command and that all this is done in a simple regular expression <code>/[NQW]</code>.</p>&#13;
<h4 class="h4" id="ch02lev2sec32"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">Name this script <code>DIR</code> (and consider creating a system-wide shell alias of <code>dir=DIR</code> since DOS was case insensitive but Unix is most assuredly case sensitive). This way, whenever users type <code>DIR</code> at the command line with typical MS-DOS <code>DIR</code> flags, they’ll get meaningful and useful output (shown in <a href="ch02.xhtml#ch2ex18">Listing 2-18</a>) rather than a <code>command not found</code> error message.</p>&#13;
<h4 class="h4" id="ch02lev2sec33"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">DIR /OD /S ~/Desktop</span>&#13;
total 48320&#13;
 7720 PERP - Google SEO.pdf              28816 Thumbs.db&#13;
    0 Traffic Data                       8 desktop.ini&#13;
    8 gofatherhood-com-crawlerrors.csv   80 change-lid-close-behavior-win7-1.png&#13;
   16 top-100-errors.txt                 176 change-lid-close-behavior-win7-2.png&#13;
    0 $RECYCLE.BIN                       400 change-lid-close-behavior-win7-3.png&#13;
    0 Drive Sunshine                     264 change-lid-close-behavior-win7-4.png&#13;
   96 facebook-forcing-pay.jpg           32 change-lid-close-behavior-win7-5.png&#13;
10704 WCSS Source Files</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_73"/><a id="ch2ex18"/><em>Listing 2-18: Testing the</em> <code><em>DIR</em></code> <em>shell script to list files</em></p>&#13;
<p class="indent">This listing of the specified directory, sorted from oldest to newest, indicates file sizes (though directories always have a size of 0).</p>&#13;
<h4 class="h4" id="ch02lev2sec34"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">At this point, it might be tough to find someone who remembers the MS-DOS command line, but the basic concept is powerful and worth knowing. One improvement you could make, for example, would be to have the Unix or Linux equivalent command be displayed before being executed and then, after a certain number of system invocations, have the script show the translation but not actually invoke the command. The user would be forced to learn the new commands just to accomplish anything!</p>&#13;
<h3 class="h3" id="ch02lev1sec08"><strong>#21 Displaying Time in Different Time Zones</strong></h3>&#13;
<p class="noindenta">The most fundamental requirement for a working <code>date</code> command is that it displays the date and time in your time zone. But what if you have users across multiple time zones? Or, more likely, what if you have friends and colleagues in different locations, and you’re always confused about what time it is in, say, Casablanca, Vatican City, or Sydney?</p>&#13;
<p class="indent">It turns out that the <code>date</code> command on most modern Unix flavors is built atop an amazing time zone database. Usually stored in the directory <em>/usr/share/zoneinfo</em>, this database lists over 600 regions and details the appropriate time zone offset from UTC (Coordinated Universal Time, also often referred to as <em>GMT</em>, or <em>Greenwich Mean Time</em>) for each. The <code>date</code> command pays attention to the <code>TZ</code> time zone variable, which we can set to any region in the database, like so:</p>&#13;
<pre class="programs">$ <span class="codestrong">TZ="Africa/Casablanca" date</span>&#13;
Fri Apr  7 16:31:01 WEST 2017</pre>&#13;
<p class="indent">However, most system users aren’t comfortable specifying temporary environment variable settings. Using a shell script, we can create a more user-friendly frontend to the time zone database.</p>&#13;
<p class="indent">The bulk of the script in <a href="ch02.xhtml#ch2ex19">Listing 2-19</a> involves digging around in the time zone database (which is typically stored across several files in the <em>zonedir</em> directory) and trying to find a file that matches a specified pattern. Once it finds a matching file, the script grabs the full time zone name (as with <code>TZ="Africa/Casablanca"</code> in this example) and invokes <code>date</code> with that as a subshell environment setting. The <code>date</code> command checks <code>TZ</code> to see what time zone it’s in and has no idea if it’s a one-off or the time zone you sit in most of the time.</p>&#13;
<h4 class="h4" id="ch02lev2sec35"><span epub:type="pagebreak" id="page_74"/><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # timein--Shows the current time in the specified time zone or&#13;
   #   geographic zone. Without any argument, this shows UTC/GMT.&#13;
   #   Use the word "list" to see a list of known geographic regions.&#13;
   #   Note that it's possible to match zone directories (regions),&#13;
   #   but that only time zone files (cities) are valid specifications.&#13;
&#13;
   # Time zone database ref: http://www.twinsun.com/tz/tz-link.htm&#13;
&#13;
   zonedir="/usr/share/zoneinfo"&#13;
&#13;
   if [ ! -d $zonedir ] ; then&#13;
     echo "No time zone database at $zonedir." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   if [ -d "$zonedir/posix" ] ; then&#13;
     zonedir=$zonedir/posix        # Modern Linux systems&#13;
   fi&#13;
&#13;
   if [ $# -eq 0 ] ; then&#13;
     timezone="UTC"&#13;
     mixedzone="UTC"&#13;
<span class="ent">➊</span> elif [ "$1" = "list" ] ; then&#13;
     ( echo "All known time zones and regions defined on this system:"&#13;
       cd $zonedir&#13;
       find -L * -type f -print | xargs -n 2 | \&#13;
         awk '{ printf " %-38s %-38s\n", $1, $2 }'&#13;
     ) | more&#13;
     exit 0&#13;
   else&#13;
&#13;
     region="$(dirname $1)"&#13;
     zone="$(basename $1)"&#13;
&#13;
     # Is the given time zone a direct match? If so, we're good to go.&#13;
     #   Otherwise we need to dig around a bit to find things. Start by&#13;
     #   just counting matches.&#13;
&#13;
     matchcnt="$(find -L $zonedir -name $zone -type f -print |\&#13;
           wc -l | sed 's/[^[:digit:]]//g' )"&#13;
&#13;
     # Check if at least one file matches.&#13;
     if [ "$matchcnt" -gt 0 ] ; then&#13;
       # But exit if more than one file matches.&#13;
       if [ $matchcnt -gt 1 ] ; then&#13;
         echo "\"$zone\" matches more than one possible time zone record." &gt;&amp;2&#13;
         echo "Please use 'list' to see all known regions and time zones." &gt;&amp;2&#13;
         exit 1&#13;
         fi&#13;
         match="$(find -L $zonedir -name $zone -type f -print)"&#13;
         mixedzone="$zone"&#13;
       else # Maybe we can find a matching time zone region, rather than a specific&#13;
            #   time zone.&#13;
         # First letter capitalized, rest of word lowercase for region + zone&#13;
         mixedregion="$(echo ${region%${region#?}} \&#13;
                  | tr '[[:lower:]]' '[[:upper:]]')\&#13;
                  $(echo ${region#?} | tr '[[:upper:]]' '[[:lower:]]')"&#13;
       mixedzone="$(echo ${zone%${zone#?}} | tr '[[:lower:]]' '[[:upper:]]') \&#13;
                  $(echo ${zone#?} | tr '[[:upper:]]' '[[:lower:]]')"&#13;
&#13;
       if [ "$mixedregion" != "." ] ; then&#13;
         # Only look for specified zone in specified region&#13;
         #   to let users specify unique matches when there's&#13;
         #   more than one possibility (e.g., "Atlantic").&#13;
         match="$(find -L $zonedir/$mixedregion -type f -name $mixedzone -print)"&#13;
       else&#13;
         match="$(find -L $zonedir -name $mixedzone -type f -print)"&#13;
       fi&#13;
&#13;
       # If file exactly matched the specified pattern&#13;
       if [ -z "$match" ] ; then&#13;
         # Check if the pattern was too ambiguous.&#13;
         if [ ! -z $(find -L $zonedir -name $mixedzone -type d -print) ] ; then&#13;
<span class="ent">➋</span>         echo "The region \"$1\" has more than one time zone. " &gt;&amp;2&#13;
         else  # Or if it just didn't produce any matches at all&#13;
           echo "Can't find an exact match for \"$1\". " &gt;&amp;2&#13;
         fi&#13;
         echo "Please use 'list' to see all known regions and time zones." &gt;&amp;2&#13;
         exit 1&#13;
       fi&#13;
     fi&#13;
<span class="ent">➌</span>   timezone="$match"&#13;
   fi&#13;
&#13;
   nicetz=$(echo $timezone | sed "s|$zonedir/||g")    # Pretty up the output.&#13;
&#13;
   echo It\'s $(TZ=$timezone date '+%A, %B %e, %Y, at %l:%M %p') in $nicetz&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_75"/><a id="ch2ex19"/><em>Listing 2-19: The</em> <code><em>timein</em></code> <em>shell script for reporting the time in a certain time zone</em></p>&#13;
<h4 class="h4" id="ch02lev2sec36"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">This script exploits the ability of the <code>date</code> command to show the date and time for a specified time zone, regardless of your current environment settings. In fact, the entire script is all about identifying a valid time zone name so that the <code>date</code> command will work when invoked at the very end.</p>&#13;
<p class="indent">Most of the complexity of this script comes from trying to anticipate names of world regions entered by users that do not match the names of regions in the time zone database. The time zone database is laid out with <em>timezonename</em> and <em>region/locationname</em> columns, and the script tries to display <span epub:type="pagebreak" id="page_76"/>useful error messages for typical input problems, like a time zone that’s not found because the user is specifying a country like <em>Brazil</em>, which has more than one time zone.</p>&#13;
<p class="indent">For example, although <code>TZ="Casablanca" date</code> would fail to find a matching region and display the UTC/GMT time instead, the city Casablanca does exist in the time zone database. The issue is that you have to use its proper region name of <em>Africa/Casablanca</em> in order for it to work, as was shown in the introduction to this script.</p>&#13;
<p class="indent">This script, on the other hand, can find Casablanca in the Africa directory on its own and identify the zone accurately. However, just specifying <em>Africa</em> wouldn’t be specific enough, as the script knows there are subregions within Africa, so it produces an error message indicating that the information is insufficient to uniquely identify a specific time zone <span class="ent">➋</span>. You can also just use <code>list</code> to list all time zones <span class="ent">➊</span> or an actual time zone name <span class="ent">➌</span> (for example, UTC or WET), which can be used as an argument to this script.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>An excellent reference to the time zone database can be found online at</em> <a href="http://www.twinsun.com/tz/tz-link.htm">http://www.twinsun.com/tz/tz-link.htm</a>.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch02lev2sec37"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">To check the time in a region or city, specify the region or city name as an argument to the <code>timein</code> command. If you know both the region and the city, you can also specify them as <code><em>region</em>/<em>city</em></code> (for example, <code>Pacific/Honolulu</code>). Without any arguments, <code>timein</code> shows UTC/GMT. <a href="ch02.xhtml#ch2ex20">Listing 2-20</a> shows the <code>timein</code> script running with a variety of time zones.</p>&#13;
<h4 class="h4" id="ch02lev2sec38"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$  <span class="codestrong">timein</span>&#13;
It's Wednesday, April 5, 2017, at 4:00 PM in UTC&#13;
$ <span class="codestrong">timein London</span>&#13;
It's Wednesday, April 5, 2017, at 5:00 PM in Europe/London&#13;
$ <span class="codestrong">timein Brazil</span>&#13;
The region "Brazil" has more than one time zone. Please use 'list'&#13;
to see all known regions and time zones.&#13;
$ <span class="codestrong">timein Pacific/Honolulu</span>&#13;
It's Wednesday, April 5, 2017, at 6:00 AM in Pacific/Honolulu&#13;
$ <span class="codestrong">timein WET</span>&#13;
It's Wednesday, April 5, 2017, at 5:00 PM in WET&#13;
$ <span class="codestrong">timein mycloset</span>&#13;
Can't find an exact match for "mycloset". Please use 'list'&#13;
to see all known regions and time zones.</pre>&#13;
<p class="listcap"><a id="ch2ex20"/><em>Listing 2-20: Testing the</em> <code><em>timein</em></code> <em>shell script with various time zones</em></p>&#13;
<h4 class="h4" id="ch02lev2sec39"><span epub:type="pagebreak" id="page_77"/><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">Knowing the time in a specific time zone across the world is a great ability, especially for a systems admin who manages global networks. But sometimes, you really just want to know the <em>difference</em> in time between two time zones quickly. The <code>timein</code> script could be hacked to provide just this functionality. By creating a new script, perhaps called <code>tzdiff</code>, based on the <code>timein</code> script, you could accept two arguments instead of one.</p>&#13;
<p class="indent">Using both of the arguments, you could determine the current time in both time zones and then print the hour difference between the two. Keep in mind, though, that a two-hour difference between two time zones could be two hours <em>forward</em> or two hours <em>backward</em>, and this makes a big difference. Distinguishing between a two-hour difference going forward or backward is crucial in making this hack a useful script.<span epub:type="pagebreak" id="page_78"/></p>&#13;
</body></html>