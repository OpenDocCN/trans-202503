<html><head></head><body>
<h2 class="h" id="ch14"><span epub:type="pagebreak" id="page_429" class="calibre1"/><strong class="calibre2"><span class="big">14</span><br class="calibre3"/>SIGNAL AND IMAGE PROCESSING</strong></h2>
<div class="bq">
<p class="center"><em class="calibre11">I studied Latin in high school, and I was reading stuff from Cicero. And that signal took a few thousand years to get to me. But I was still interested in what he had to say.</em></p>
<p class="center1">—Seth Shostak</p>
</div>
<div class="image"><img alt="Image" src="../images/common.jpg" class="calibre6"/></div>
<p class="noindent">This chapter contains examples from problems in both signal and image processing. The two subjects are usually considered germane to unrelated areas of research: signal processing interests the audio or electrical engineer, while image processing is relevant to biologists and astronomers. However, they belong together because they use many of the same techniques, and the relevant tools have the same mathematical foundations. For many purposes, we can think of an image as just a two-dimensional signal, and apply similar algorithms to transform, smooth, filter, and more, extending the single time dimension to two (or three) space dimensions.</p>
<p class="indent"><span epub:type="pagebreak" id="page_430"/>We’ll first look at one-dimensional signals, considering the common case of an independent coordinate representing time. After that, we’ll explore Julia’s packages for image processing.</p>
<h3 class="h2" id="ch14lev1"><strong class="calibre2">Signals in Time</strong></h3>
<p class="noindent">Sound comes to us as a time-varying air pressure, and we store it as a record of amplitude versus time, where the amplitude may represent direct measurements of pressure or its conversion to electrical voltages or some other quantity by our measuring apparatus. We’ll explore signal processing in Julia by working with a sound from nature.</p>
<h4 class="h3" id="ch14lev1sec1"><strong class="calibre2"><em class="calibre4">Exploring a Sound Sample</em></strong></h4>
<p class="noindent">Our real-life sound is the call of the endangered cactus ferruginous pygmy owl (<em class="calibre11">Glaucidium brasilianum cactorum</em>), a native of Arizona. I found the sound sample at <a href="http://www.naturesongs.com/falcstri.html#cobo" class="calibre10"><em class="calibre11">http://www.naturesongs.com/falcstri.html#cobo</em></a> and saved it on disk with the filename <em class="calibre11">cfpo1.wav</em>. The sample is a WAV file: a common file format for audio that nearly any music playback or sound editing software, on any operating system, can play. Listening to the sample reveals a call consisting of a short, medium-high-pitched vocalization repeated about three times per second for about 12 total seconds.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">WAV files are often described erroneously as “uncompressed” audio. The audio data they contain is almost always compressed using one of a handful of available lossless compression algorithms (similar to the compression used in the ZIP family of file compression utilities). They take up far more space than the same sound compressed using a perceptual encoder such as that used for MP3 files, but such files are not useful for scientific signal processing and analysis.</em></p>
</div>
<p class="indent">In a Linux terminal, we can get some information about the file using the <code>file</code> command:</p>
<pre class="calibre13">$ <span class="codestrong">file cfpo1.wav</span>
cfpo1.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 8 bit, mono 8000 Hz</pre>
<p class="noindent">The output reflects the most common file format; the data is little-endian because the WAV format was invented at Microsoft. The third clause names the compression algorithm; Microsoft PCM is the most common. The rest of the output means that the samples were saved with 8 bits of precision, providing 2<sup class="calibre23">8</sup> = 256 available amplitude levels per point, and that we have one channel sampled at 8,000 samples per second.</p>
<p class="indent">Back in the Julia REPL, let’s read in the sample, assign it to <code>cfpo</code>, and plot the waveform:</p>
<pre class="calibre13"><span epub:type="pagebreak" id="page_431"/>julia&gt; <span class="codestrong">using SignalAnalysis, SignalAnalysis.Units, Plots</span>

julia&gt; <span class="codestrong">cfpo = signal("cfpo1.wav");</span>

julia&gt; <span class="codestrong">plot(cfpo)</span></pre>
<p class="indent">First we import two convenient packages for signal analysis. All the other examples in this section assume this <code>using</code> statement. The <code>SignalAnalysis.Units</code> package provides time and frequency unit abbreviations, and a handy form of time-based indexing that we’ll use later.</p>
<p class="indent">The <code>signal()</code> function has many methods. When supplied with a string, it loads the named file and packages the data into a type defined in the package. The <code>SignalAnalysis</code> package also extends <code>Plots</code> to be able to plot signals directly. <a href="ch14.xhtml#ch14fig1" class="calibre10">Figure 14-1</a> shows the waveform of the owl call.</p>
<div class="image1"><img alt="Image" id="ch14fig1" src="../images/ch14fig01.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-1: The call of the cactus ferruginous pygmy owl</em></p>
<p class="indent">As the sound sample contains 100,558 elements, plotting is not instantaneous. The plot recipe uses information about the sample rate to create a correct time axis, and labels the axis as well. The <code>signal()</code> function rescales the 8-bit samples to <code>Float64</code> numbers ranging from –1.0 to 1.0.</p>
<p class="indent"><span epub:type="pagebreak" id="page_432"/>The <code>SignalAnalysis</code> package supplies several functions for extracting information about the signal. The following are the most important of these:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">framerate(cfpo)</span>
8000.0f0

julia&gt; <span class="codestrong">nframes(cfpo)</span>
100558

julia&gt; <span class="codestrong">duration(cfpo)</span>
12.56975f0</pre>
<p class="indent">The term <code>nframes</code> refers to samples and <code>duration()</code> reports the length of the signal in seconds.</p>
<p class="indent"><a href="ch14.xhtml#ch14fig1" class="calibre10">Figure 14-1</a> shows the three-chirps-per-second structure of the owl call clearly, but we can’t tell what note the owl is singing. Let’s zoom in:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">one_chirp = plot(cfpo[2.05:2.25s]);</span>

julia&gt; <span class="codestrong">chirp_zoomed = plot(cfpo[2.1:2.11s]);</span>

julia&gt; <span class="codestrong">plot(one_chirp, chirp_zoomed; layout=(2, 1))</span></pre>
<p class="indent">The first two plot statements take advantage of the convenient time-based indexing that the <code>SignalAnalysis</code> package enables. It frees us from having to convert between time and index number of the signal data. The indexing works only with seconds and only with a range of floats. To access the single frame at two seconds, we can write <code>cfpo[2.0:2.0s]</code>.</p>
<p class="indent"><a href="ch14.xhtml#ch14fig2" class="calibre10">Figure 14-2</a> shows the combined plot: two segments of the signal at two different scales. The plot recipe always labels the plots beginning at <code>t = 0</code>, but we can always define <code>xticks</code> to reference the original time interval if desired.</p>
<div class="image1"><img alt="Image" id="ch14fig2" src="../images/ch14fig02.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-2: Two magnified segments of the owl call</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_433"/>The bottom plot in <a href="ch14.xhtml#ch14fig2" class="calibre10">Figure 14-2</a> is in the middle of one of the chirps, and is sufficiently magnified to allow us to count cycles easily. There appear to be about 3.25 cycles in 2.5 ms (most easily counted from <em class="calibre11">t</em> = 5.0 ms, where a peak of the wave happens to align exactly with a grid line, to <em class="calibre11">t</em> = 7.5 ms), which is a frequency of 3.25/2.5e–3 = 1,300.0 Hz, which is very close to the musical note E<sub class="calibre24">6</sub>.</p>
<h4 class="h3" id="ch14lev1sec2"><strong class="calibre2"><em class="calibre4">Analyzing Frequencies</em></strong></h4>
<p class="noindent">One of the senses of the word <em class="calibre11">analysis</em> is the separating of something into component parts. We’ll perform two types of frequency analysis of signals. The first type converts the signal, a function of amplitude versus time, into a function of amplitude versus frequency. This is the purpose of the Fourier transform, which assumes that the signal is periodic, and analyzes it into a sum of periodic functions (sines and cosines of various amplitudes, sines or cosines of various phases and amplitudes, or complex exponentials—all equivalent representations). The representation as a sum of frequencies is the signal’s <em class="calibre11">spectrum</em>. The second type combines temporal and frequency information into a <em class="calibre11">spectrogram</em>. Here we no longer assume that the signal is periodic. The spectrogram shows us the spectrum as it varies in time.</p>
<p class="indent">The <code>SignalAnalysis</code> package provides several plotting routines we can use to visualize both types of frequency analysis. The <code>psd()</code> function plots the <em class="calibre11">power spectral density</em> of a signal based on its Fourier transform. Its interpretation is straightforward when applied to a periodic signal, which describes the owl call pretty well:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">psd(cfpo; xticks=0:100:4000, xrot=90, lw=2)</span></pre>
<p class="indent">Since <code>psd()</code> uses the <code>Plots</code> package, we can supply the familiar keyword arguments. <a href="ch14.xhtml#ch14fig3" class="calibre10">Figure 14-3</a> shows the spectrum.</p>
<div class="image1"><img alt="Image" id="ch14fig3" src="../images/ch14fig03.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-3: Fourier spectrum of the call of an owl</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_434"/>The spectrum has a peak just barely below 1,300 Hz, which agrees with our estimate from counting cycles of the waveform. We can also see peaks close to the second and third harmonics (twice and thrice 1,300 Hz).</p>
<p class="indent">Displays such as <a href="ch14.xhtml#ch14fig3" class="calibre10">Figure 14-3</a> are useful analytic and diagnostic tools, but they don’t convey a full idea of the nature of the signal under investigation. We can see that the signal is dominated by a 1,300 Hz frequency, with two strong overtones, but there’s no hint of the rapid staccato performance.</p>
<p class="indent">For a fuller analysis, we turn to the spectrogram. The <code>SignalAnalysis</code> package also provides a function to create these visualizations easily:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">specgram(cfpo; c=:grayC)</span></pre>
<p class="indent"><a href="ch14.xhtml#ch14fig4" class="calibre10">Figure 14-4</a> contains the spectrogram, and clearly shows the frequency distribution of energy in the signal: the strong component near 1,300 Hz and the two higher harmonics at lower amplitudes. We can also see the temporal structure; the chirps repeating at about three times per second are obvious.</p>
<div class="image1"><img alt="Image" id="ch14fig4" src="../images/ch14fig04.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-4: Spectrogram of the owl call</em></p>
<p class="indent">Spectrograms use Fourier transforms and a <em class="calibre11">window</em> sliding over the signal to calculate the spectrum as it evolves, resulting in a visualization combining frequency and time information. They’re more informative than a <code>psd()</code>-type plot for any except periodic signals. Practical Fourier transform routines, such as the ones used by <code>psd()</code>, also use windowing, but for the purpose of eliminating the inevitable discontinuities at the edges of the signal and the resulting “leakage” of spurious high-frequency components.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">This section presents the quickest and most convenient methods for signal analysis, with an emphasis on getting to the visualizations that interest most scientists. For <span epub:type="pagebreak" id="page_435"/>more control, or to obtain direct access to spectra, import the</em> <span class="codeitalic1">DSP.jl</span> <em class="calibre11">package. The</em> <span class="codeitalic1">SignalAnalysis</span> <em class="calibre11">package wraps many of its routines, but importing</em> <span class="codeitalic1">DSP</span> <em class="calibre11">grants access to its definitions for various Fourier transform windows and other details that we can invoke with keyword arguments to the higher-level</em> <span class="codeitalic1">SignalAnalysis</span> <em class="calibre11">routines such as</em> <span class="codeitalic1">psd()</span><em class="calibre11">.</em></p>
</div>
<p class="indent">Now that we’ve dealt with two ways to examine the frequency spectra of signals, in the next section we’ll explore methods for transforming the signal by altering the spectrum.</p>
<h4 class="h3" id="ch14lev1sec3"><strong class="calibre2"><em class="calibre4">Filtering</em></strong></h4>
<p class="noindent">A <em class="calibre11">filter</em> in the context of signal processing is a circuit, device, or, in our case, a computation, that attenuates some of the frequencies present in a signal. Perhaps the most familiar examples are the crossover circuits in speakers that route the high frequencies to the tweeters and the low frequencies to the woofers.</p>
<p class="indent">Filters are also important in empirical science—for example, in reducing noise in measurements. Imagine a sensor that records the variations in depth of a waterway. We might be interested in measuring the effect of tides, and detecting any long-term change in the average depth. These changes occur on the timescales of hours and longer. However, the measurements will be polluted by the more rapid changes caused by wind, weather, and passing boats. Using filtering, we can seek to erase the irrelevant data from the signal by eliminating frequencies faster than, say, one cycle per hour.</p>
<p class="indent">This strategy suggested in the previous paragraph is called a <em class="calibre11">low-pass</em> filter, because it attenuates frequencies <em class="calibre11">above</em> a specified cutoff, allowing those below the cutoff to pass. An example of a <em class="calibre11">high-pass</em> filter would be the crossover circuit leading to a speaker’s tweeter.</p>
<p class="indent">Another type of filtering common in scientific instrumentation is a <em class="calibre11">notch</em> filter: one that attenuates frequencies near a target frequency. Notch filters are useful for eliminating 60 or 50 Hz power line noise from instruments through which the signal passes (but are only useful if the signal doesn’t contain information near the power line frequency).</p>
<p class="indent">A <em class="calibre11">band-pass</em> filter attenuates anything outside a narrow band around a target frequency.</p>
<h5 class="h4" id="ch14sec1sec1"><strong class="calibre2">Making Filters with fir()</strong></h5>
<p class="noindent">The <code>SignalAnalysis</code> package makes it easy to construct any of these types of filters and apply them to signals. In each case we begin with the <code>fir()</code> function to construct the filter. Its basic use involves three positional arguments and an optional keyword argument named <code>fs</code>, giving the sampling frequency of the signal.</p>
<p class="indent">The first argument is an integer number of <em class="calibre11">taps</em>, which is related to the number of terms retained in the polynomial that describes the filter. Essentially, a greater number of taps causes the filter to be more selective and its response to be smoother. The second and third arguments are the <span epub:type="pagebreak" id="page_436"/>lower and upper bounds of the unfiltered frequency range. If we provide the <code>fs</code> keyword, we supply these arguments in <code>Hz</code>, <code>kHz</code>, or another unit from <code>SignalAnalysis.Units</code>. For example, <a href="ch14.xhtml#ch14lis1" class="calibre10">Listing 14-1</a> shows how to make a low-pass filter that filters out everything above 2,000 Hz.</p>
<pre class="calibre13">lpf = fir(127, 0, 2kHz; fs=8kHz);</pre>
<p class="list" id="ch14lis1"><em class="calibre11">Listing 14-1: Constructing a low-pass filter</em></p>
<p class="noindent">The example makes a 127-tap filter, which is a typical value.</p>
<p class="indent">The lower bound for a low-pass filter is 0, as in the example. To make a high-pass filter, we pass <code>nothing</code> as the upper bound.</p>
<p class="indent">The <code>SignalAnalysis</code> package provides a plotting function to visualize the filters created with <code>fir()</code>. To see a plot of the frequency response of the <code>lpf</code> filter defined previously, we need simply enter:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">plotfreqresp(lpf; fs=8000)</span></pre>
<p class="indent">This creates the plot shown in <a href="ch14.xhtml#ch14fig5" class="calibre10">Figure 14-5</a>.</p>
<div class="image1"><img alt="Image" id="ch14fig5" src="../images/ch14fig05.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-5: Frequency response of a low-pass filter</em></p>
<p class="indent">The top graph in <a href="ch14.xhtml#ch14fig5" class="calibre10">Figure 14-5</a> indicates the amount by which the frequency component, given on the horizontal axis, will be reduced when the filter is applied to a signal. The units are in dB (decibels), which is conventional in signal processing. <a href="ch14.xhtml#ch14fig5" class="calibre10">Figure 14-5</a> shows 0 dB, or no change, to the frequencies until we approach 2,000 Hz, when the signal is rapidly attenuated. For normal sounds, a reduction of 20 dB effectively silences the component it’s applied to; therefore, the oscillations in the filter response below –50 dB have no audible effect.</p>
<p class="indent"><span epub:type="pagebreak" id="page_437"/>The bottom graph shows the phase shifts created by the filter. These are usually inaudible, but may or may not be relevant, depending on one’s plans for the filtered signal.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">For more detailed control over the filter characteristics, we can import</em> <span class="codeitalic1">DSP.jl</span> <em class="calibre11">and pass a</em> <span class="codeitalic1">method</span> <em class="calibre11">keyword to</em> <span class="codeitalic1">fir()</span> <em class="calibre11">using one of the filter construction methods described at</em> <a href="https://docs.juliadsp.org/stable/filters/" class="calibre10">https://docs.juliadsp.org/stable/filters/</a>.</p>
</div>
<p class="indent">The dB numbers in the frequency response plot are directly added to the values of frequency component peaks displayed in the <code>psd()</code> plot of a signal, which are also displayed in dB. To calculate the change in amplitude of the signal itself, we use the formula</p>
<div class="image"><img alt="Image" src="../images/437math.jpg" class="calibre6"/></div>
<p class="noindent">where <em class="calibre11">V</em> is the amplitude of the component in the input signal and <em class="calibre11">V</em><sub class="calibre24"><em class="calibre11">f</em></sub> is the filtered amplitude. Therefore, a 6 dB reduction halves the amplitude:</p>
<div class="image"><img alt="Image" src="../images/437math1.jpg" class="calibre6"/></div>
<p class="indent">To see the effect of larger tap values, we can make two additional low-pass filters with the same frequency ranges but with more taps:</p>
<pre class="calibre13">lpf_255 = fir(255, 0, 2kHz; fs=8kHz);
lpf_1027 = fir(1027, 0, 2kHz; fs=8kHz);</pre>
<p class="indent">A higher tap number will produce a filter with a response closer to ideal, as <a href="ch14.xhtml#ch14fig6" class="calibre10">Figure 14-6</a> shows.</p>
<div class="image1"><img alt="Image" id="ch14fig6" src="../images/ch14fig06.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-6: A low-pass filter using different tap numbers</em></p>
<p class="indent">Although using a higher tap number creates a cleaner filter with a sharper cutoff, it leads to a more expensive filtering calculation. The added calculation time makes no difference for our example, using a stored signal of moderate length, but it can be a consideration with real-time filtering, for example.</p>
<h5 class="h4" id="ch14sec1sec2"><span epub:type="pagebreak" id="page_438" class="calibre1"/><strong class="calibre2">Applying Filters</strong></h5>
<p class="noindent">To filter the signal, we can use the function <code>sfilt()</code>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">cfpo_lp = sfilt(lpf, cfpo);</span></pre>
<p class="indent">This applies the low-pass filter defined in <a href="ch14.xhtml#ch14lis1" class="calibre10">Listing 14-1</a> to the owl sample and assigns the result, a new signal, to <code>cfpo_lp</code>. Plotting the power spectrum of the filtered signal using <code>psd()</code> shows the effect of the filtering (see <a href="ch14.xhtml#ch14fig7" class="calibre10">Figure 14-7</a>).</p>
<div class="image1"><img alt="Image" id="ch14fig7" src="../images/ch14fig07.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-7: The filtered owl call</em></p>
<p class="indent">This plot displays the original, unfiltered spectrum using a dotted line and the filtered spectrum with a thicker, solid line. The spectrum below the low-pass cutoff at 2 kHz is untouched, while all frequencies above have been eliminated.</p>
<p class="indent">We create <a href="ch14.xhtml#ch14fig7" class="calibre10">Figure 14-7</a> with the following commands:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Plots.PlotMeasures</span>

julia&gt; <span class="codestrong">psd(cfpo_lp; lw=2, label="Filtered signal", legend=true)</span>

julia&gt; <span class="codestrong">psd!(cfpo; ls=:dot, ticks=0:200:4000, xrot=90, label="Original signal",
            legend=true, margin=5mm)</span></pre>
<p class="indent">It’s necessary to repeat some of the keyword arguments when adding to <code>psd()</code> plots because the plotting recipe resets them.</p>
<p class="indent">The spectrogram of the filtered signal in <a href="ch14.xhtml#ch14fig8" class="calibre10">Figure 14-8</a> also shows the elimination of the second and third harmonics with the preservation of the signal otherwise.</p>
<div class="image1"><img alt="Image" id="ch14fig8" src="../images/ch14fig08.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-8: Spectrogram of the filtered owl call</em></p>
<h5 class="h4" id="ch14sec1sec3"><span epub:type="pagebreak" id="page_439" class="calibre1"/><strong class="calibre2">Synthetic Signals</strong></h5>
<p class="noindent">In order to ensure that we understand, quantitatively, signal analysis and filtering, let’s start with a signal synthesized from known frequency components. Another method of <code>signal()</code> creates a signal with embedded sampling rate information from a normal vector. In <a href="ch14.xhtml#ch14lis2" class="calibre10">Listing 14-2</a>, we create a vector consisting of the addition of two sine waves, representing data with two components at 1,000 and 2,050 Hz sampled at 8 kHz. We then package the data into a signal.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">sin1000_2050 = signal(sin.((0.0:1.0/8000:1.0)*2π*1000)  .+
                             0.5 .*  sin.((0.0:1.0/8000:1.0)*2π*2050), 8000);</span></pre>
<p class="list" id="ch14lis2"><em class="calibre11">Listing 14-2: Creating a synthetic signal</em></p>
<p class="indent">We assigned the result to <code>sin1000_2050</code>. The second argument to <code>signal()</code> gives the sampling rate. The component at 2,050 Hz has half the amplitude of the component at 1,000 Hz. The power spectrum should show two peaks, with the higher-frequency peak 6 dB lower than the lower-frequency peak. <a href="ch14.xhtml#ch14fig9" class="calibre10">Figure 14-9</a> shows the result of <a href="ch14.xhtml#ch14lis3" class="calibre10">Listing 14-3</a>.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">psd(sin1000_2050; xrange=(500, 2500), xticks=600:100:2500,
           xminorticks=2, yticks=-61:3:-02, xrot=45, margin=5mm)</span></pre>
<p class="list" id="ch14lis3"><em class="calibre11">Listing 14-3: Spectrum of a synthetic signal</em></p>
<p class="indent">Because the signal contains embedded sampling rate information, <code>psd()</code> is able to scale the plot correctly.</p>
<div class="image1"><img alt="Image" id="ch14fig9" src="../images/ch14fig09.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-9: Spectrum of a synthetic signal with two frequency components</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_440"/><a href="ch14.xhtml#ch14fig9" class="calibre10">Figure 14-9</a> shows the power spectrum with two narrow peaks where we put them, and the correct 6 dB difference in their amplitudes.</p>
<p class="indent">Now let’s measure the effect of filtering. We’ll use the <code>lpf</code> filter defined in <a href="ch14.xhtml#ch14lis1" class="calibre10">Listing 14-1</a>, but first we need to take a closer look at it near its cutoff frequency:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">plotfreqresp(lpf; fs=8000, xrange=(1800, 2100), yrange=(-50, 1),
                    yticks=0:-4:-50, xticks=1800:50:2100, right_margin=5mm)</span></pre>
<p class="indent">The expanded plot of the filter response in <a href="ch14.xhtml#ch14fig10" class="calibre10">Figure 14-10</a> (with the phase response omitted) shows that the filter should reduce the 2,050 Hz component by 16 dB.</p>
<div class="image1"><img alt="Image" id="ch14fig10" src="../images/ch14fig10.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-10: The cutoff region of the low-pass filter</em></p>
<p class="indent">We can check whether the filter is working as expected by overlaying the power spectrum of the filtered signal onto the plot created in <a href="ch14.xhtml#ch14lis3" class="calibre10">Listing 14-3</a>:</p>
<pre class="calibre13"><span epub:type="pagebreak" id="page_441"/>julia&gt; <span class="codestrong">psd!(sfilt(lpf, sin1000_2050), xrange=(500, 2500), xticks=600:100:2500,
            xminorticks=2, yticks=-61:3:-02, xrot=45, margin=5mm)</span></pre>
<p class="indent"><a href="ch14.xhtml#ch14fig11" class="calibre10">Figure 14-11</a> shows that the higher-frequency peak is reduced by 16 dB while the lower-frequency peak is unchanged.</p>
<div class="image1"><img alt="Image" id="ch14fig11" src="../images/ch14fig11.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-11: Power spectrum of the filtered synthetic signal</em></p>
<p class="indent">This little exercise shows that the filters have predictable effects, altering the spectra without introducing artifacts.</p>
<h5 class="h4" id="ch14sec1sec4"><strong class="calibre2">Saving Signals</strong></h5>
<p class="noindent">We can read a WAV file from disk into a signal using the <code>signal()</code> function, but saving a signal as a WAV file requires importing the <code>WAV.jl</code> package:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using WAV</span>
julia&gt; <span class="codestrong">wavwrite(cfpo_lp, "cfpo_lp.wav"; compression=WAVE_FORMAT_PCM, nbits=8)</span></pre>
<p class="indent">The keyword arguments select a compression format and word size that’s compatible with a wide variety of software. After making the <code>wavwrite()</code> call, a WAV file called <em class="calibre11">cfpo_lp.wav</em> will exist on the disk drive.</p>
<p class="indent">If we want to save our <code>sin1000_2050</code> signal as a WAV file, we first have to scale it to have unit amplitude:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">scaled = sin1000_2050 ./ maximum(sin1000_2050)</span></pre>
<p class="noindent">Then we save it using <code>wavwrite()</code> as before and play it using any audio software.</p>
<h3 class="h2" id="ch14lev2"><span epub:type="pagebreak" id="page_442" class="calibre1"/><strong class="calibre2">Image Processing</strong></h3>
<p class="noindent">Let’s consider an image interpretation task common in medicine and laboratory biology: how many blood cells are in a photograph of a blood sample taken through a microscope? The traditional method of acquiring this “blood count” was to enumerate the cells manually, a tiresome and errorprone process. We’ll see how to use various image processing techniques with Julia to automate the procedure. The result will be a faster and more accurate count that doesn’t require tedious labor. However, the techniques we’ll investigate here aren’t limited to blood counts. We could apply them to everything from counting bacteria to analyzing satellite reconnaissance.</p>
<h4 class="h3" id="ch14lev1sec4"><strong class="calibre2"><em class="calibre4">Loading and Converting Images</em></strong></h4>
<p class="noindent">The command <code>using Images</code> imports the file and image input-output functions, including optimized routines for most image types:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Images</span>

julia&gt; <span class="codestrong">frog_blood = load("frogBloodoriginal.jpg");</span></pre>
<p class="indent">After the import, a simple <code>load()</code> command reads the file into an image, which in Julia is an array of pixels.</p>
<p class="indent">When working in a notebook, such as Pluto, the results of image operations are displayed as images; in the terminal REPL, they’re displayed similarly to other arrays. For graphical image display from the REPL, the <code>ImageView</code> package supplies the <code>imshow()</code> function. The window opened by <code>imshow()</code> features a few GUI powers, the most useful of which is a display of pixel address and color value in response to moving the mouse pointer over the image.</p>
<p class="indent">Images can be matrices of numbers or pixel types. There are several types of pixels, but the ones we’ll be using are <code>RGB</code> and <code>Gray</code> pixels. Since we loaded the <code>frog_blood</code> image from a color picture, it’s an array of <code>RGB</code> (red-green-blue) pixels:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">eltype(frog_blood)</span>
RGB{N0f8}</pre>
<p class="indent">This is clearly a parametric type (see “Parametric Types” on <a href="ch08.xhtml#ch08lev6" class="calibre10">page 248</a>). The parameter <code>N0f8</code> is another (parametric) type that maps unsigned 8-bit integers to floats in the range <code>[0.0, 1.0]</code>. An element of <code>frog_blood</code> looks like the following:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">frog_blood[1, 1]</span>
RGB{N0f8}(0.361,0.008,0.384)</pre>
<p class="noindent">This would be purple: nearly equal amounts of red and blue and almost no green.</p>
<p class="indent">If we want to replace the extreme upper-left pixel with pure green, we could execute:</p>
<pre class="calibre13"><span epub:type="pagebreak" id="page_443"/>frog_blood[1, 1] = RGB{N0f8}(0.0, 1.0, 0.0)</pre>
<p class="noindent">However, we won’t.</p>
<p class="indent">We can convert the color image to a grayscale version by broadcasting <code>Gray()</code> as a conversion function to the image array:</p>
<pre class="calibre13">frog_blood_gs = Gray.(frog_blood);
save("frog_blood_gs.jpg", frog_blood_gs)
save("frog_blood_gs.png", frog_blood_gs)</pre>
<p class="indent">The listing also shows how to save images in files. The <code>save()</code> function converts image data to the file format indicated by the filename extension. Here we’ve saved two versions of the same image, one as a <em class="calibre11">.jpg</em> file and one as a <em class="calibre11">.png</em> file.</p>
<p class="indent"><a href="ch14.xhtml#ch14fig12" class="calibre10">Figure 14-12</a> shows the grayscaled image.</p>
<div class="image1"><img alt="Image" id="ch14fig12" src="../images/ch14fig12.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-12: The frog blood image converted to grayscale. Original image by Wayne Large (CC BY-ND 2.0). Available from</em> <a href="https://flic.kr/p/cBDUEG" class="calibre10">https://flic.kr/p/cBDUEG</a>.</p>
<p class="indent">Other useful color conversion functions are <code>red()</code>, <code>green()</code>, and <code>blue()</code>, which extract the named color channels from an <code>RGB</code> pixel and can also, of course, be broadcast to entire images to separate them into their color channels.</p>
<p class="indent">In order to compare two, or several, versions of an image, perhaps to eyeball the effect of a transformation or processing step, the <code>mosaicview()</code> function is handy:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">imshow(mosaicview(red.(frog_blood), green.(frog_blood),
              blue.(frog_blood), frog_blood_gs; ncol=2, npad=6))</span></pre>
<p class="indent"><span epub:type="pagebreak" id="page_444"/>This command creates four images showing the three color channels of the original <code>frog_blood</code> image and the composite grayscale version, sticks them together in a grid, then displays them. If working in a notebook, we don’t need the <code>imshow()</code> call. The <code>ncol</code> argument specifies the numbers of columns in the image grid (an <code>nrows</code> is also available), and the <code>npad</code> argument puts a border of the specified number of pixels between the images.</p>
<p class="indent"><a href="ch14.xhtml#ch14fig13" class="calibre10">Figure 14-13</a> shows what <code>mosaicview()</code> produces.</p>
<div class="image1"><img alt="Image" id="ch14fig13" src="../images/ch14fig13.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-13: The red, green, blue, and all channels (top to bottom, left to right) of the frog blood image</em></p>
<p class="indent">The original image, containing all of the color channels, is in the lower-right quadrant.</p>
<h4 class="h3" id="ch14lev1sec5"><strong class="calibre2"><em class="calibre4">Counting Cells Using an Area Fraction</em></strong></h4>
<p class="noindent">Our first attempt at automating the counting of blood cells will use the <code>ImageBinarization</code> package. This package contains a handful of algorithms for separating an image into a “foreground” and a “background,” coloring the foreground pure black and the background pure white. In other words, each pixel in the original image is assigned either 0.0 or 1.0, depending on the results of the algorithm invoked. The package documentation displays examples of the results of all the available algorithms on a variety of image types.</p>
<p class="indent">The goal is to generate an image that separates the blood cells from everything else, as much as possible. This binary image will then be a good starting point for further analysis. We’ve already made some progress in this direction through the color separations shown in <a href="ch14.xhtml#ch14fig13" class="calibre10">Figure 14-13</a>. The blue channel, at the bottom, seems to have increased the contrast between <span epub:type="pagebreak" id="page_445"/>the (larger) red blood cells and the other particles. Instead of binarizing the original color image, we’ll start with the blue channel:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using ImageBinarization</span>

julia&gt; <span class="codestrong">frog_blood_blue = blue.(frog_blood);</span>

julia&gt; <span class="codestrong">frog_blood_b1 = binarize(frog_blood_blue, Intermodes())</span></pre>
<p class="indent">The <code>binarize()</code> function takes the image as the first argument and the name of the binarization algorithm as the second argument, and returns the binarized image. The documentation describes the details of the <code>Intermodes</code> algorithm. For our purposes, it does a good job at detecting discrete structures, such as cells, against a plain background.</p>
<p class="indent"><a href="ch14.xhtml#ch14fig14" class="calibre10">Figure 14-14</a> shows the binarized image.</p>
<div class="image1"><img alt="Image" id="ch14fig14" src="../images/ch14fig14.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-14: The blue channel of the frog blood slide after binarization</em></p>
<p class="indent">We’ll use this image as the basis for the blood count.</p>
<p class="indent">If we knew the average area of the blood cells in the image, we could divide that into the total area occupied by all blood cells to arrive at an estimate of the number of cells. The cells appear to be approximately elliptical (in this two-dimensional image).</p>
<p class="indent">Using the GUI in the <code>imshow()</code> window, I used the pixel readout to measure the major and minor axis lengths of four typical cells at 26.8 pixels and a typical minor axis at 24.5 pixels. Using <em class="calibre11">A</em> = <em class="calibre11">πr</em><sub class="calibre24">1</sub><em class="calibre11">r</em><sub class="calibre24">2</sub> for the area of an ellipse with radii <em class="calibre11">r</em><sub class="calibre24">1</sub> and <em class="calibre11">r</em><sub class="calibre24">2</sub>, the average of the four areas was 511.3 square pixels.</p>
<p class="indent">Finding the total blood fraction is simple using the binarized image. In <code>frog_blood_b1</code>, the cells are black, with a pixel value of 0, and the background is white, with a value of 1. The total cell count is therefore <code>sum(1 .- frog_blood_b1)</code>, <span epub:type="pagebreak" id="page_446"/>which evaluates to 255,029.0. Dividing this result by the average cell area yields 499 cells.</p>
<h4 class="h3" id="ch14lev1sec6"><strong class="calibre2"><em class="calibre4">Counting Cells by Recognizing Features</em></strong></h4>
<p class="noindent">We can improve on the estimate in the previous section by exploiting algorithms that search for features with particular shapes in the image. The Hough transform (see “Further Reading” on <a href="ch14.xhtml#fur14" class="calibre10">page 465</a> for background) is one such class of algorithms that can be specialized to various shapes. The <code>ImageFeatures</code> package, which we’ll assume is imported in the following examples, offers implementations for detecting lines and circles. As the features we need to detect resemble circles, we’ll use the <code>hough_circle_gradient()</code> function, an implementation of the Hough transform for circles.</p>
<p class="indent">Before applying the algorithm, we’ll process the image to make its task easier and produce a more accurate result. One problem with the image is that the cells we want to count are not circles, but elongated. Hough transforms for ellipses do exist, but are not yet available in the <code>ImageFeatures</code> package. Another problem is that many cells are touching, and a few are overlapping. The Hough transform can deal with touching and overlapping circles, but it has a better time with cleanly separated shapes.</p>
<p class="indent">Nature has provided some assistance with the second problem: each cell has a nucleus, clearly delineated in the picture. Even when blood cells are in contact or overlapping, their nuclei are separated. If we could eliminate most of everything except the nuclei from the image, we could simply count those to get the blood count.</p>
<p class="indent">Here we are fortunate: the color of the nuclei makes them easy to distinguish from everything else in the image. This may not be apparent to the eye, but by placing the mouse cursor on the nuclei in the <code>imshow()</code> window, and comparing with other locations, we can see that the nuclei are unique in having a green value close to 0 while having a red value &gt; 0.2. We can confirm this in other ways—for example, by plotting the three color components along lines through the image.</p>
<p class="indent">The following array comprehension creates a new image from the original pixel by pixel, by leaving the pixels within the nucleus color range unchanged, while turning the others white:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">nuclei = Gray.([(green(e) &lt; 0.1) &amp; (red(e) &gt; 0.2) ? e :</span>
                <span class="codestrong">RGB{N0f8}(1.0, 1.0, 1.0) for e in frog_blood]);</span></pre>
<p class="indent">We also transform the result into a grayscale image for further processing and printing. <a href="ch14.xhtml#ch14fig15" class="calibre10">Figure 14-15</a> shows the result.</p>
<div class="image1"><img alt="Image" id="ch14fig15" src="../images/ch14fig15.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-15: Frog blood nuclei isolated by color</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_447"/>We’ve managed to isolate the nuclei pretty well and eliminate some of the particles that are something other than blood cells.</p>
<p class="indent"><a href="ch14.xhtml#ch14fig15" class="calibre10">Figure 14-15</a> is a good candidate for the circle-finding algorithm, but we must complete two preliminary steps first. The <code>hough_circle_gradient()</code> function doesn’t operate on actual images, but on maps of <em class="calibre11">edges</em> and <em class="calibre11">phases</em>. The edge map is the output of an edge-detection algorithm, transforming the image into, essentially, a line drawing tracing its shapes. The map of phases is a matrix of angles calculated from the edge map, giving the direction at every point of its gradient, as an angle from <em class="calibre11">–π</em> to π.</p>
<p class="indent">The <code>canny()</code> function is an excellent edge detector:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">edges = canny(nuclei, (0.15, 0.0))</span></pre>
<p class="indent">Its second argument is a tuple of thresholds used for defining an edge from the input image (which must be grayscale). I arrived at the values it contains through trial and error, aiming for a set of edges that captured the nuclei while ignoring most of the scattering of white blood cells and other particles. <a href="ch14.xhtml#ch14fig16" class="calibre10">Figure 14-16</a> shows the output of the <code>canny()</code> function.</p>
<div class="image1"><img alt="Image" id="ch14fig16" src="../images/ch14fig16.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-16: Edge detection of the nuclei image</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_448"/>This is a pretty clean result, and is what we were aiming for.</p>
<p class="indent">The phase calculation itself requires two steps—first the gradient map itself and then the phases derived from it:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">dx, dy = imgradients(edges, KernelFactors.ando5);</span>

julia&gt; <span class="codestrong">phases = phase(dx, dy);</span></pre>
<p class="indent">With the edges and phases computed, we can run the Hough transform:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">centers, radii = hough_circle_gradient(edges, phases, 1:5; min_dist=20);</span></pre>
<p class="indent">After this call, <code>centers</code> contains a vector of indices giving the locations of each circle and <code>radii</code> a vector of their corresponding radii. The length of either vector gives the number of circles found. In this case, the length is 534, which is in reasonable agreement with the estimate of 499 we arrived at earlier.</p>
<p class="indent">The third argument to <code>hough_circle_gradient()</code> gives the allowed range for the circle radii, in pixels. The <code>min_dist</code> keyword argument is the minimum allowed distance between circle centers.</p>
<p class="indent">To see how well the circle fitting did, and how much confidence we should lend to the estimate of 534 blood cells, we can use the <code>centers</code> array to draw circles directly on the original image where the <code>hough_circle_gradient()</code> function says they should be:</p>
<pre class="calibre13"><span epub:type="pagebreak" id="page_449"/>julia&gt; <span class="codestrong">using ImageDraw</span>

julia&gt; <span class="codestrong">for p in centers
           draw!(frog_blood, CirclePointRadius(p, 15; thickness=8, fill=false))
       end</span></pre>
<p class="indent">The <code>draw!()</code> function, provided by <code>ImageDraw</code>, mutates its first argument by drawing shapes on it, in white by default. The <code>CirclePointRadius()</code> in the second argument creates a circle at point <code>p</code> with radius 15; the <code>fill=false</code> creates an open circle with perimeter thickness controlled by the <code>thickness</code> keyword.</p>
<p class="indent"><a href="ch14.xhtml#ch14fig17" class="calibre10">Figure 14-17</a> shows the result of drawing the circles on top of the (grayscale version of) the original image.</p>
<div class="image1"><img alt="Image" id="ch14fig17" src="../images/ch14fig17.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-17: Circles detected by a Hough transform</em></p>
<p class="indent"><a href="ch14.xhtml#ch14fig17" class="calibre10">Figure 14-17</a> shows that the Hough transform did an excellent job. Nearly every blood cell is marked with a circle, and most of the other objects are ignored. There are a few misses and a few false detections, but, on the whole, the count of 534 is quite accurate.</p>
<p class="indent">The image processing pipeline described in this section would be practical for automating blood counts, although the specific parameters would need to be adjusted for different types of samples, different stains, and so on. The approach is far faster and probably more accurate than manual counting.</p>
<h4 class="h3" id="ch14lev1sec7"><span epub:type="pagebreak" id="page_450" class="calibre1"/><strong class="calibre2"><em class="calibre4">Applying Advanced Array Concepts</em></strong></h4>
<p class="noindent">As an image is an array, various advanced array concepts available in Julia can make their manipulation more convenient and concise. This section explores techniques for dealing with arrays that we haven’t used directly up to now, although we’ve seen how they’re used in several packages. Placed within an image processing context, their use becomes easier to visualize.</p>
<h5 class="h4" id="ch14sec1sec5"><strong class="calibre2">Views</strong></h5>
<p class="noindent">A <em class="calibre11">view</em> is a reference to another array or to a section of another array. The other array is called the <em class="calibre11">parent</em>. A view is a kind of virtual array, which occupies almost no memory: it shares memory with the parent, so modifying one modifies the other.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">It is dangerous to alter the shape of the parent array after creating a view. Subsequent operation on the view may create out-of-bounds memory accesses or segmentation faults.</em></p>
</div>
<p class="indent">To see how views work, we’ll create a small grid of middle-gray values and a view pointing to every other element in the grid:</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">rgi = rand(Float64, (10, 10)) .* 0.2 .+ 0.4;</span>

   julia&gt; <span class="codestrong">checkers = @view rgi[1:2:end, 1:2:end];</span>

   julia&gt; <span class="codestrong">size(checkers)</span>
   (5, 5)

<span class="ent">➊</span> julia&gt; <span class="codestrong">checkers .= 0.0;</span>

   julia&gt; <span class="codestrong">black_squares = heatmap(rgi; c=:grays, clim=(0.0, 1.0), colorbar=false);</span>

   julia&gt; <span class="codestrong">checkers .= 1.0;</span>

   julia&gt; <span class="codestrong">white_squares = heatmap(rgi; c=:grays, clim=(0.0, 1.0), colorbar=false);</span>

   julia&gt; <span class="codestrong">plot(black_squares, white_squares)</span></pre>
<p class="indent">The second line shows how to create a view with the <code>@view</code> macro. The <code>checkers</code> view, defined by selecting alternate squares of the parent array, forms a checkerboard pattern. Its size is half that of the parent. After setting all its elements to 0.0 <span class="ent">➊</span>, the corresponding elements in the parent are likewise modified. We can change the values of elements in the view repeatedly, and these updates are reflected in the parent. <a href="ch14.xhtml#ch14fig18" class="calibre10">Figure 14-18</a> shows the outcome.</p>
<div class="image1"><img alt="Image" id="ch14fig18" src="../images/ch14fig18.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-18: Patterns created using a view</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_451"/>This example shows how views can simplify certain expressions. They’re also useful as an aid to memory parsimony. If a computation uses parts of arrays as intermediate containers, which we don’t need in the final result, we can avoid allocating memory to hold these temporary structures by using views instead.</p>
<p class="indent">As an illustration, here are two versions of a little function that returns the difference between the sums of alternate elements in an array:</p>
<pre class="calibre13">function odd_even_difference(a::AbstractArray)
    return sum(a[begin:2:end]) - sum(a[begin+1:2:end])
end

function odd_even_difference2(a::AbstractArray)
 <span class="ent">➊</span> return @views sum(a[begin:2:end]) - sum(a[begin+1:2:end])
end

julia&gt; <span class="codestrong">using BenchmarkTools</span>

julia&gt; <span class="codestrong">@btime odd_even_difference(rand(Int(1e7)));</span>
  96.716 ms (6 allocations: 152.59 MiB)

julia&gt; <span class="codestrong">@btime odd_even_difference2(rand(Int(1e7)));</span>
  62.116 ms (2 allocations: 76.29 MiB)</pre>
<p class="indent"><span epub:type="pagebreak" id="page_452"/>The <code>@views</code> macro <span class="ent">➊</span> transforms all slice operations in the expression to its right into view operations. The first version of the program creates two arrays and computes the sum of odd and even indexed elements. The second performs the same computation, but by creating views instead of new arrays. The timing runs show that using views cut the memory consumption in half while also decreasing runtime by a third. Avoiding unnecessary array copying by using views where possible is an easy optimization.</p>
<h5 class="h4" id="ch14sec1sec6"><strong class="calibre2">AxisArrays</strong></h5>
<p class="noindent">With the <code>AxisArrays</code> package, we can give names to array dimensions and axes, give units to arrays, and enjoy more flexible indexing. Dataframes (see “Dataframes” on <a href="ch10.xhtml#ch10lev1sec7" class="calibre10">page 333</a>) also allow us to name rows and columns, but are limited to two dimensions.</p>
<p class="indent">The following example shows how to name the rows and columns of a matrix:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using AxisArrays</span>

julia&gt; <span class="codestrong">ae = AxisArray(reshape(1:100, 10, 10); row='a':'j', col='A':'J')</span>
2-dimensional AxisArray{Int64,2,...} with axes:
    :row, 'a':1:'j'
    :col, 'A':1:'J'
And data, a 10×10 reshape(::UnitRange{Int64}, 10, 10) with eltype Int64:
  1  11  21  31  41  51  61  71  81   91
  2  12  22  32  42  52  62  72  82   92
  3  13  23  33  43  53  63  73  83   93
  4  14  24  34  44  54  64  74  84   94
  5  15  25  35  45  55  65  75  85   95
  6  16  26  36  46  56  66  76  86   96
  7  17  27  37  47  57  67  77  87   97
  8  18  28  38  48  58  68  78  88   98
  9  19  29  39  49  59  69  79  89   99
 10  20  30  40  50  60  70  80  90  100</pre>
<p class="indent">With this definition, we can index using the numbers that we’re used to or the names that we’ve assigned to the axes, or mix them up:</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">ae['a', 'B']</span>
   11

   julia&gt; <span class="codestrong">ae[1, 2] == ae['a', 2] == ae[1, 'B']</span>
   true

<span class="ent">➊</span> julia&gt; <span class="codestrong">ae['a':'c', 'B':'D']</span>
   2-dimensional AxisArray{Int64,2,...} with axes:
       :row, ['a', 'b', 'c']
       :col, ['B', 'C', 'D']
   And data, a 3×3 Matrix{Int64}:
    <span epub:type="pagebreak" id="page_453"/>11  21  31
    12  22  32
    13  23  33

<span class="ent">➋</span> julia&gt; <span class="codestrong">ae[col=2, row=1]</span>
   11</pre>
<p class="indent">The example shows that we can slice with our custom names <span class="ent">➊</span> as we do with numerical indices, and that, if we use the names of the dimensions, we can supply indices in any order <span class="ent">➋</span>. We can use any names where we use <code>row</code> and <code>col</code> here. They’re defined only within index expressions; they don’t exist as variables outside the brackets.</p>
<p class="indent">The next example shows how to incorporate units into the definition of an array:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Unitful</span>

julia&gt; <span class="codestrong">mm = u"mm";</span>

julia&gt; <span class="codestrong">cm = u"cm";</span>

julia&gt; <span class="codestrong">rgin = AxisArray(rand(Float64, (10, 10)) .* 0.2 .+ 0.4,
                 Axis{:y}(0mm:1mm:9mm), Axis{:x}(0cm:1cm:9cm));</span>

julia&gt; <span class="codestrong">rgin[x=3, y=2] == rgin[1mm, 2cm] == rgin[2, 3] == rgin[x=2cm, y=1mm] ==
       rgin[2, 2cm]</span>
true</pre>
<p class="noindent">This shows the use of the <code>Axis{}()</code> constructor, and, in the final line, various ways we can index into the array, including mixing numerical and unit indices.</p>
<p class="indent">We can use an ellipsis, from the automatically imported <code>EllipsisNotation</code> package, to represent ranges of units:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">rgin[1mm .. 2mm, 1cm .. 3cm] == rgin[1mm .. 2.3mm, 10mm .. 30mm]</span>
true</pre>
<p class="indent">This illustrates two properties of dimension ranges. We can use equivalent units, here using 10 mm = 1 cm, and the endpoints of the intervals need not lie exactly on an element of the array. Beware that the indexing rounds <em class="calibre11">down</em> and not to the nearest element.</p>
<p class="indent">Let’s define a rectangle using ranges of lengths, paint it white, and plot the resulting array:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">rgin[2mm .. 7.2mm, 3cm .. 4.9cm] .= 1.0;</span>

julia&gt; <span class="codestrong">heatmap(rgin; c=:grays, clim=(0.0, 1.0), colorbar=false, ratio=1,</span>
        <span class="codestrong">xticks=(1:10, ["$(i)mm" for i in 0:9]),</span>
        <span class="codestrong">yticks=(1:10, ["$(i)cm" for i in 0:9]),</span>
        <span class="codestrong">xrange=(0, 11))</span></pre>
<p class="indent"><span epub:type="pagebreak" id="page_454"/>The plotting command is an example of custom labeled ticks. <a href="ch14.xhtml#ch14fig19" class="calibre10">Figure 14-19</a> shows the new state of <code>rgin</code>.</p>
<div class="image1"><img alt="Image" id="ch14fig19" src="../images/ch14fig19.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-19: We paint this white rectangle by specifying physical lengths.</em></p>
<p class="indent">The direct use of physical dimensions to index arrays frees us from the mental or programmatic labor of constantly translating between integer indices and the quantities that they represent in our models.</p>
<h5 class="h4" id="ch14sec1sec7"><strong class="calibre2">OffsetArrays</strong></h5>
<p class="noindent">Those with experience in Python or C, when encountering Julia for the first time, sometimes complain about its 1-based indexing, whereas old Fortran hands know that it’s a better choice. The former group may be pleased to know that in Julia, as in Fortran, we can make arrays that start anywhere.</p>
<div class="box">
<p class="boxtitle-d"><strong class="calibre2">DON’T ASSUME 1-BASED INDEXING</strong></p>
<p class="noindent">Assuming that an array passed to a function will be 1-based is a source of occasional bugs in public packages. The existence of <code>OffsetArrays</code> is the reason for our earlier warning not to iterate over arrays with:</p>
<pre class="calibre13">for i = 1:length(A) # Do not do this.
    # ...expressions with A[i]...</pre>
<p class="noindent">Instead, use <code>eachindex(A)</code> or another construction that generates legal indices. But there is another reason: using <code>eachindex()</code> generates more efficient memory accesses for certain types of arrays.</p>
</div>
<p class="indent"><span epub:type="pagebreak" id="page_455"/>The <code>OffsetArrays</code> package provides several ways to create an <code>OffsetArray</code>. We can call the <code>OffsetArray()</code> function with the source array and each dimension’s <em class="calibre11">offset</em> as positional arguments. A dimension’s offset is how far its indices are shifted from their normal position. An offset of 0 means no shift, and an offset of –2 means that the dimension’s index runs from –1 to two less than its length. To illustrate how an <code>OffsetArray</code> works, we’ll start with our random gray matrix again:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using OffsetArrays, Random</span>

julia&gt; <span class="codestrong">rgen = MersenneTwister(7654);</span>

julia&gt; <span class="codestrong">rgi = rand(rgen, Float64, (10, 10)) .* 0.2 .+ 0.4;</span>

julia&gt; <span class="codestrong">rgi_offset = OffsetArray(rgi, -3, 2);</span>

julia&gt; <span class="codestrong">rgi[1, 1]</span>
0.5447560977385423

julia&gt; <span class="codestrong">rgi_offset[-2, 3]</span>
0.5447560977385423</pre>
<p class="indent">In this example, we use a seeded random number generator (see “Random Numbers in Julia” on <a href="ch10.xhtml#ch10lev2" class="calibre10">page 307</a>) so that the results will be identical for readers trying these commands. The <code>(-2, 3)</code> position of <code>rgi_offset</code> corresponds to the <code>(1, 1)</code> position of <code>rgi</code>.</p>
<p class="indent">This use of <code>OffsetArray()</code> creates a view, rather than a copy of the original, as shown in <a href="ch14.xhtml#ch14lis4" class="calibre10">Listing 14-4</a>.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">rgi_offset[-2, 3] = 0.0</span>
0.0

julia&gt; <span class="codestrong">rgi[1, 1]</span>
0.0</pre>
<p class="list" id="ch14lis4"><em class="calibre11">Listing 14-4:</em> <span class="codeitalic">OffsetArrays</span> <em class="calibre11">are views.</em></p>
<p class="indent">Since the two arrays share memory, modifying <code>rgi_offset</code> modifies <code>rgi</code>. Of course, we can make a new array using <code>copy()</code> if needed:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">rgi_offset_copy = copy(OffsetArray(rgi, -3, 2));</span>

julia&gt; <span class="codestrong">rgi_offset_copy[-2, 3] = 1.0</span>
1.0

julia&gt; <span class="codestrong">rgi[1, 1]</span>
0.0</pre>
<p class="indent"><span epub:type="pagebreak" id="page_456"/>Painting part of the array white illustrates that ranges work as before, taking into account the offsets:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">rgi_offset[0:5, 8:11] .= 1.0;</span></pre>
<p class="indent"><a href="ch14.xhtml#ch14fig20" class="calibre10">Figure 14-20</a> shows the image of the array, with the black element set in <a href="ch14.xhtml#ch14lis4" class="calibre10">Listing 14-4</a> and the white rectangle set in this example. The plotting grid for heatmaps is centered on the elements, so we can examine which elements were changed to verify that we understand the indexing ranges.</p>
<div class="image1"><img alt="Image" id="ch14fig20" src="../images/ch14fig20.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-20: The white rectangle was defined as an</em> <span class="codeitalic">OffsetArray</span>.</p>
<p class="indent">Plotting with <code>heatmap()</code> doesn’t work with <code>OffsetArrays</code> unless we explicitly supply coordinate vectors. In other words, we can call <code>heatmap(rgi)</code>, but must use <code>heatmap(1:10, 1:10, rgi_offset)</code> to prevent the plotting routine from getting confused. The two calls produce the same image in this case, as the two arrays share memory.</p>
<p class="indent"><code>OffsetArray()</code> provides another syntax, using ranges of indices rather than single offsets. This method is convenient when extracting a subset of an existing array:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">passage = Float64.(Gray.(load("titanPassage.jpg")));</span>

julia&gt; <span class="codestrong">passage = reverse(passage; dims=1);</span>

julia&gt; <span class="codestrong">middle_passage = OffsetArray(passage[300:600, 400:700], 300:600, 400:700);</span> <span class="ent">➊</span>

julia&gt; <span class="codestrong">passage[300:600, 400:700] .= 0.0;</span>

julia&gt; <span class="codestrong">passage[350:550, 450:650] = middle_passage[350:550, 450:650];</span> <span class="ent">➋</span></pre>
<p class="indent"><span epub:type="pagebreak" id="page_457"/>First we load a color photograph, convert it to grayscale, and then to a floating-point array, assigning the result to the <code>passage</code>. Since we plan to inspect the images in this example using <code>heatmap()</code>, we flip the image vertically for convenience to undo the effect of the orientation of the vertical axis.</p>
<p class="indent">Using <code>OffsetArray()</code>, we extract a square portion of the image and assign it to <code>middle_passage</code> <span class="ent">➊</span>. This line shows another way to establish the offset indices: instead of a single integer offset, we supply the range of indices indexing the array. We choose these to be identical to the indices used to extract the sub-image, so that a pixel addressed in the extracted part will correspond to the pixel in the original image with the same indices. This technique greatly simplifies programs where we want to maintain a correspondence between an array and a sub-array, eliminating the need to constantly translate indices. The <code>middle_passage</code> matrix is a new array, not a view, because the index ranges create a copy.</p>
<p class="indent">The next line paints the square region, from which we took the extract, black.</p>
<p class="indent">In the final line, we replace a portion of the black square with a portion of the extracted part of the image <span class="ent">➋</span>. Since the index ranges in both arrays are identical, the replaced part of the image will exactly correspond to what was there originally. The result is a black frame around a part of the image, with nothing else altered, as <a href="ch14.xhtml#ch14fig21" class="calibre10">Figure 14-21</a> shows.</p>
<div class="image1"><img alt="Image" id="ch14fig21" src="../images/ch14fig21.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-21:</em> <span class="codeitalic">OffsetArrays</span> <em class="calibre11">make many image manipulations easier. Original photograph taken inside a Titan missile facility by Lee Phillips (CC BY-ND 2.0).</em></p>
<p class="indent">The use of offset indices makes this code easier to write and read, and less prone to errors. With conventional arrays we would have been forced to <span epub:type="pagebreak" id="page_458"/>add lines performing array arithmetic to translate between pixel ranges in the large and extracted images, or construct the frame from pieces.</p>
<p class="indent">The <code>OffsetArrays</code> package proves two additional ways to construct array offsets automatically, both of which can be convenient in image processing. We can order up an <code>OffsetArray</code> centered on an array:</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">passage = Float64.(Gray.(load("titanPassage.jpg")));</span>

<span class="ent">➊</span> julia&gt; <span class="codestrong">OffsetArrays.center(passage)</span>
   (375, 500)

   julia&gt; <span class="codestrong">passage[375, 500]</span>
   0.25098039215686274

<span class="ent">➋</span> julia&gt; <span class="codestrong">passage_centered = OffsetArrays.centered(passage);</span>

   julia&gt; <span class="codestrong">passage_centered[0, 0]</span>
   0.25098039215686274</pre>
<p class="indent">The <code>center()</code> function <span class="ent">➊</span> from <code>OffsetArrays</code> returns the index of the center of an array (if the array has an odd number of elements along some dimension, it rounds down). The package’s <code>centered()</code> function <span class="ent">➋</span> creates an <code>OffsetArray</code> with the index <code>[0, 0]</code> at its center. We usually need to qualify these function names with the package name because of collisions.</p>
<p class="indent">Having the center of index space at the center of an array is helpful in the common situation where the array represents a quantity in physical space, or in space and time, where we often use a coordinate system with the origin at the center. Here’s another visual example, where having the <code>[0, 0]</code> point at the center of an image simplifies calculations:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">dmax = minimum(size(passage_centered))/2</span>

julia&gt; <span class="codestrong">for j in eachindex(passage_centered[1, :]),
           i in eachindex(passage_centered[:, 1])
           passage_centered[i, j] *= max(0.0, 1.0 - sqrt(i^2 + j^2)/dmax)
       end</span></pre>
<p class="indent">We’ve set <code>dmax</code> to the distance from the center to end along the shorter dimension. Then we multiply each pixel by a decreasing function of distance from the center. <a href="ch14.xhtml#ch14fig22" class="calibre10">Figure 14-22</a> shows the result, a centered circular frame darkening toward the edges.</p>
<div class="image1"><img alt="Image" id="ch14fig22" src="../images/ch14fig22.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-22:</em> <span class="codeitalic">OffsetArrays</span> <em class="calibre11">make it easy to reference the center of an array.</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_459"/>Using a centered <code>OffsetArray</code> simplifies the code, allowing us to dispense with the index arithmetic usually needed to reference the center of an array.</p>
<h5 class="h4" id="ch14sec1sec8"><strong class="calibre2">Cartesian Indices</strong></h5>
<p class="noindent">Julia’s <em class="calibre11">cartesian indices</em> are a powerful tool that can greatly simplify all kinds of computations with arrays. The two relevant types built into Julia are the <code>CartesianIndex</code> and <code>CartesianIndices</code>. A <code>CartesianIndex</code> represents an address of an element in an array of any size. <code>CartesianIndices</code> are iterators that span a rectangular region, of any dimensionality, within an array.</p>
<p class="indent">For concreteness, and so that we can look at pictures, we’ll concentrate on two-dimensional arrays, as shown in <a href="ch14.xhtml#ch14lis5" class="calibre10">Listing 14-5</a>.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">ci = CartesianIndex(1, 1)</span>
CartesianIndex(1, 1)

julia&gt; <span class="codestrong">collect(5ci:8ci)</span>
4×4 Matrix{CartesianIndex{2}}:
 CartesianIndex(5, 5)  CartesianIndex(5, 6)  CartesianIndex(5, 7)  CartesianIndex(5, 8)
 CartesianIndex(6, 5)  CartesianIndex(6, 6)  CartesianIndex(6, 7)  CartesianIndex(6, 8)
 CartesianIndex(7, 5)  CartesianIndex(7, 6)  CartesianIndex(7, 7)  CartesianIndex(7, 8)
 CartesianIndex(8, 5)  CartesianIndex(8, 6)  CartesianIndex(8, 7)  CartesianIndex(8, 8)</pre>
<p class="list" id="ch14lis5"><em class="calibre11">Listing 14-5: Iterating over</em> <span class="codeitalic">CartesianIndices</span></p>
<p class="indent"><span epub:type="pagebreak" id="page_460"/>This example shows how using <code>CartesianIndices</code> simplifies iterating over a rectangular region. First we assign the <code>CartesianIndex</code> corresponding to the index <code>[1, 1]</code> to <code>ci</code>. Then we iterate from <code>CartesianIndex(5, 5)</code>, represented as <code>5ci</code>, to <code>8ci</code>, using <code>collect()</code> to instantiate the iteration so we can inspect it. The power is in how a linear iteration is expanded into a nested iteration over both dimensions, spanning the rectangle between the two corners <code>[5, 5]</code> and <code>[8, 8]</code>. We can use this type of iteration in any number of dimensions:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">collect(CartesianIndex(1, 1, 1):CartesianIndex(3, 3, 3))</span>
3×3×3 Array{CartesianIndex{3}, 3}:
[:, :, 1] =
 CartesianIndex(1, 1, 1)  CartesianIndex(1, 2, 1)  CartesianIndex(1, 3, 1)
 CartesianIndex(2, 1, 1)  CartesianIndex(2, 2, 1)  CartesianIndex(2, 3, 1)
 CartesianIndex(3, 1, 1)  CartesianIndex(3, 2, 1)  CartesianIndex(3, 3, 1)

[:, :, 2] =
 CartesianIndex(1, 1, 2)  CartesianIndex(1, 2, 2)  CartesianIndex(1, 3, 2)
 CartesianIndex(2, 1, 2)  CartesianIndex(2, 2, 2)  CartesianIndex(2, 3, 2)
 CartesianIndex(3, 1, 2)  CartesianIndex(3, 2, 2)  CartesianIndex(3, 3, 2)

[:, :, 3] =
 CartesianIndex(1, 1, 3)  CartesianIndex(1, 2, 3)  CartesianIndex(1, 3, 3)
 CartesianIndex(2, 1, 3)  CartesianIndex(2, 2, 3)  CartesianIndex(2, 3, 3)
 CartesianIndex(3, 1, 3)  CartesianIndex(3, 2, 3)  CartesianIndex(3, 3, 3)</pre>
<p class="indent">Here the iteration represents a cube. Without <code>CartesianIndices</code>, we would have to write it as three nested loops, but here it’s a simple range expression.</p>
<p class="indent">In fact, <code>CartesianIndices</code> are more general than what’s shown in these examples. They need not represent contiguous rectangular regions:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">collect(CartesianIndex(1, 1):CartesianIndex(2, 2):CartesianIndex(5, 5))</span>
3×3 Matrix{CartesianIndex{2}}:
 CartesianIndex(1, 1)  CartesianIndex(1, 3)  CartesianIndex(1, 5)
 CartesianIndex(3, 1)  CartesianIndex(3, 3)  CartesianIndex(3, 5)
 CartesianIndex(5, 1)  CartesianIndex(5, 3)  CartesianIndex(5, 5)</pre>
<p class="indent">Their utility is in compactly representing nested iterations, and in constructing “portable” ranges of indices we can use in different arrays. <a href="ch14.xhtml#ch14lis6" class="calibre10">Listing 14-6</a> illustrates this idea.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">by2 = CartesianIndex(1, 1):CartesianIndex(2, 2):CartesianIndex(5, 5)</span>
CartesianIndices((1:2:5, 1:2:5))

julia&gt; <span class="codestrong">reshape(1:100, 10, 10)[by2]</span>
3×3 Matrix{Int64}:
 1  21  41
 3  23  43
 5  25  45</pre>
<p class="list" id="ch14lis6"><em class="calibre11">Listing 14-6: Using</em> <span class="codeitalic">CartesianIndices</span> <em class="calibre11">to construct "portable" ranges of indices</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_461"/>Here we’ve assigned a <code>CartesianIndices</code> iterator to <code>by2</code>, which we then used to extract nine noncontiguous elements from a 10×10 matrix. This example also shows a more compact way to define the iterators, suggested to us by the form of the result returned on the first line:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">CartesianIndices((1:3, 1:3, 1:3)) ==
       CartesianIndex(1, 1, 1):CartesianIndex(3, 3, 3)</span>
true</pre>
<p class="indent">To help visualize <code>CartesianIndices</code>, we’ll start with a 100×100 version of our random gray matrix and select a rectangle within it by iterating over multiples of <code>ci</code>, defined in <a href="ch14.xhtml#ch14lis6" class="calibre10">Listing 14-6</a>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">rgi = rand(rgen, Float64, (100, 100)) .* 0.2 .+ 0.4;</span>

julia&gt; <span class="codestrong">rgi[5ci:20ci] .= 0.0;</span></pre>
<p class="indent"><a href="ch14.xhtml#ch14fig23" class="calibre10">Figure 14-23</a> shows what this does to <code>rgi</code>.</p>
<div class="image1"><img alt="Image" id="ch14fig23" src="../images/ch14fig23.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-23: Defining a rectangular region with</em> <span class="codeitalic">CartesianIndices</span></p>
<p class="indent">Julia’s <code>CartesianIndices</code> equip us with a way to define a rectangular region that we can perform direct arithmetic on, to, for example, shift it to various locations around an array. This kind of “moving window” operates behind the scenes in the fast Fourier transform and spectrogram functions that we used earlier in this chapter. It’s also a big part of solving partial differential equations on a grid, a major enterprise in computational science. Those with <span epub:type="pagebreak" id="page_462"/>experience programming such stencil operations in a traditional language such as Fortran know how tricky the process can be. Here we’ll apply the idea to a photograph, by sliding a square window around the image to create a blurred, pixel-averaged version:</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">monk = Float64.(load("monk-mintons-1947.jpg"));</span>

<span class="ent">➊</span> julia&gt; <span class="codestrong">average_monk = similar(monk);</span>

   julia&gt; <span class="codestrong">cim = CartesianIndices(monk);</span>

   julia&gt; <span class="codestrong">ws = 1; # Window size</span>

<span class="ent">➋</span> julia&gt; <span class="codestrong">c1 = CartesianIndex(ws, ws);</span>

   julia&gt; <span class="codestrong">for i in cim
              n = s = 0.0
              for j in max(first(cim), i - c1):min(last(cim), i + c1)
                  n += 1
                  s += monk[j]
              end
          average_monk[i] = s/n
          end</span></pre>
<p class="indent">After loading the image, we initialize an array to hold the averaged version using <code>similar()</code> <span class="ent">➊</span>, which makes a copy of an array with the same size and types. We’ll use the <code>cim</code> variable to iterate over the entire original image. The size of the moving square window is assigned to <code>ws</code>, which is used to define its extent <span class="ent">➋</span>. The <code>for</code> loop visits each point in the original, replacing it with the average of all the pixels in the square window centered on that point.</p>
<p class="indent">The purpose of the <code>max()</code> and <code>min()</code> calls is to handle the border regions, where the moving window would extend beyond the edge of the matrix. This works because of how <code>max()</code> and <code>min()</code> treat <code>CartesianIndex</code> types:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">max(CartesianIndex(3, 4), CartesianIndex(-2, 9))</span>
CartesianIndex(3, 9)

julia&gt; <span class="codestrong">min(CartesianIndex(3, 4), CartesianIndex(-2, 9))</span>
CartesianIndex(-2, 4)</pre>
<p class="indent">The functions return a new <code>CartesianIndex</code> where each dimensional index is individually maximized or minimized; therefore, we need only refer to the corners of the original array to ensure that no index component is too large or too small.</p>
<p class="indent">The functions act differently on tuples:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">max((3, 4), (-2, 9))</span>
(3, 4)</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_463"/>Here the tuples (or vectors) are ordered by their first elements, and the return value is always one of the arguments.</p>
<p class="indent"><a href="ch14.xhtml#ch14fig24" class="calibre10">Figure 14-24</a> shows the original image and the results of averaging over 1, 4, and 8 pixels.</p>
<div class="image1"><img alt="Image" id="ch14fig24" src="../images/ch14fig24.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-24: Thelonious Monk, 1947. Original and with averaging over 1, 4, and 8 pixels, left to right and top to bottom. Photo by William Gottlieb (public domain</em>, <a href="http://hdl.loc.gov/loc.music/gottlieb.06191" class="calibre10">http://hdl.loc.gov/loc.music/gottlieb.06191</a>).</p>
<p class="indent">The result is an increasing softening of the original image, the result of a simple form of low-pass filtering.</p>
<p class="indent">We can use a similar technique to create a reduced image—for example, by a factor of two in each dimension:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">smaller_monk = zeros(size(monk) .÷ 2);</span>
julia&gt; <span class="codestrong">cism = CartesianIndices(smaller_monk);</span>
julia&gt; <span class="codestrong">c1 = CartesianIndex(1, 1)</span>
julia&gt; <span class="codestrong">for i in cism
           n = s = 0.0
        <span class="ent">➊</span> for j in max(first(cim), 2i - c1):min(last(cim), 2i + c1)
               <span epub:type="pagebreak" id="page_464"/>n += 1
               s += monk[j]
           end
       smaller_monk[i] = s/n
       end</span></pre>
<p class="indent">After initializing an array half the size of the original to hold the reduced image, we create a <code>CartesianIndices</code> iterator spanning it, assigned to <code>cism</code>. The outer loop iterates over the smaller array and sets each of its elements to the average of the pixels surrounding the corresponding pixel in the original. The indexing <span class="ent">➊</span> is due to the fact that for location <code>[i, j]</code> in the reduced image, the corresponding location in the original is <code>[2i, 2j]</code>.</p>
<p class="indent"><a href="ch14.xhtml#ch14fig25" class="calibre10">Figure 14-25</a> shows the original alongside the reduced version.</p>
<div class="image1"><img alt="Image" id="ch14fig25" src="../images/ch14fig25.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 14-25: Piano four hands: reducing an image with pixel averaging</em></p>
<p class="indent">Of course, we could also create a quick reduced image with <code>original[1:2:dy, 1:2:dx]</code>, but averaging pixels leads to a better outcome, especially in the appearance of diagonal lines. Professional image reduction algorithms usually employ a larger window with a sampling method more elaborate than the simple arithmetic mean in this example.</p>
<h3 class="h2" id="ch14lev3"><strong class="calibre2">Conclusion</strong></h3>
<p class="noindent">In this chapter, we’ve analyzed and manipulated artifacts from the physical world of sounds and images. We’ve explored a variety of tools from packages for signal and image processing, but also found that the power of Julia’s <span epub:type="pagebreak" id="page_465"/>facilities for array manipulation make difficult jobs easy, allowing us to write short and simple programs that perform complex tasks.</p>
<div class="box">
<p class="boxtitle-d" id="fur14"><strong class="calibre2">FURTHER READING</strong></p>
<ul class="calibre12">
<li class="noindent1">Documentation for <code>SignalAnalysis.jl</code> is available at <a href="https://org-arl.github.io/SignalAnalysis.jl/stable/" class="calibre10"><em class="calibre11">https://org-arl.github.io/SignalAnalysis.jl/stable/</em></a>.</li>
<li class="noindent1">For details about the WAV file format, visit <a href="https://docs.fileformat.com/audio/wav/" class="calibre10"><em class="calibre11">https://docs.fileformat.com/audio/wav/</em></a>.</li>
<li class="noindent1">JuliaImages is a starting place to find various image processing packages for Julia and their documentation: <a href="https://juliaimages.org/stable" class="calibre10"><em class="calibre11">https://juliaimages.org/stable</em></a>.</li>
<li class="noindent1">For some background about the Hough transform, start with <a href="https://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm" class="calibre10"><em class="calibre11">https://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm</em></a>.</li>
<li class="noindent1">Cartesian indices . . . what are they good for? Tim Holy explains: <a href="https://julialang.org/blog/2016/02/iteration/" class="calibre10"><em class="calibre11">https://julialang.org/blog/2016/02/iteration/</em></a>. This article inspired the image reduction used in this chapter.<span epub:type="pagebreak" id="page_466"/></li>
</ul>
</div>
</body></html>