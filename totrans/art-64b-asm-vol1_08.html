<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="287" id="Page_287"/>6</span><br/>
<span class="ChapterTitle">Arithmetic</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">This chapter discusses arithmetic computation in assembly language. By the end of this chapter, you should be able to translate arithmetic expressions and assignment statements from high-level languages like Pascal and C/C++ into x86-64 assembly language.</p>
<h2 id="h1-501089c06-0001">	6.1	x86-64 Integer Arithmetic Instructions</h2>
<p class="BodyFirst">Before you learn how to encode arithmetic expressions in assembly language, it would be a good idea to first discuss the remaining arithmetic instructions in the x86-64 instruction set. Previous chapters have covered most of the arithmetic and logical instructions, so this section covers the few remaining instructions you’ll need.</p>
<h3 id="h2-501089c06-0001"><span epub:type="pagebreak" title="288" id="Page_288"/>6.1.1	Sign- and Zero-Extension Instructions</h3>
<p class="BodyFirst">Several arithmetic operations require sign- or zero-extended values before the operation. So let’s first consider the sign- and zero-extension instructions. The x86-64 provides several instructions to sign- or zero-extend a smaller number to a larger number. <a href="#table6-1" id="tableanchor6-1">Table 6-1</a> lists instructions that will sign-extend the AL, AX, EAX, and RAX registers.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-1">Table 6-1</a>: Instructions for Extending AL, AX, EAX, and RAX</p></figcaption>
<table id="table-501089c06-0001" border="1">
<thead>
<tr>
<td><b>Instruction</b></td>
<td><b>Explanation</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>cbw</code></td>
<td>Converts the byte in AL to a word in AX via sign extension</td>
</tr>
<tr>
<td><code>cwd</code></td>
<td>Converts the word in AX to a double word in DX:AX via sign extension</td>
</tr>
<tr>
<td><code>cdq</code></td>
<td>Converts the double word in EAX to a quad word in EDX:EAX via sign extension</td>
</tr>
<tr>
<td><code>cqo</code></td>
<td>Converts the quad word in RAX to an octal word in RDX:RAX via sign extension</td>
</tr>
<tr>
<td><code>cwde</code></td>
<td>Converts the word in AX to a double word in EAX via sign extension</td>
</tr>
<tr>
<td><code>cdqe</code></td>
<td>Converts the double word in EAX to a quad word in RAX via sign extension</td>
</tr>
</tbody>
</table>
</figure>
<p>Note that the <code>cwd</code> (<em>convert word to double word</em>) instruction does not sign-extend the word in AX to a double word in EAX. Instead, it stores the HO word of the sign extension into the DX register (the notation DX:AX indicates that you have a double-word value, with DX containing the upper 16 bits and AX containing the lower 16 bits of the value). If you want the sign extension of AX to go into EAX, you should use the <code>cwde</code> (<em>convert word to double word, extended</em>) instruction. In a similar fashion, the <code>cdq</code> instruction sign-extends EAX into EDX:EAX. Use the <code>cdqe</code> instruction if you want to sign-extend EAX into RAX.</p>
<p>For general sign-extension operations, the x86-64 provides an extension of the <code>mov</code> instruction, <code>movsx</code> (<em>move with sign extension</em>), that copies data and sign-extends the data while copying it. The <code>movsx</code> instruction’s syntax is similar to that of <code>mov</code>:</p>
<pre><code>movsxd <var>dest</var>, <var>source</var> ; If dest is 64 bits and source is 32 bits
movsx  <var>dest</var>, <var>source</var> ; For all other operand combinations</code></pre>
<p>The big difference in syntax between these instructions and the <code>mov</code> instruction is that the destination operand must usually be larger than the source operand.<sup class="FootnoteReference"><a id="c06-footnoteref-1" href="#c06-footnote-1">1</a></sup> For example, if the source operand is a byte, then the destination operand must be a word, dword, or qword. The destination operand must also be a register; the source operand, however, can be a memory location.<sup class="FootnoteReference"><a id="c06-footnoteref-2" href="#c06-footnote-2">2</a></sup> The <code>movsx</code> instruction does not allow constant operands.</p>
<p><span epub:type="pagebreak" title="289" id="Page_289"/>For whatever reason, MASM requires a different instruction mnemonic (instruction name) when sign-extending a 32-bit operand into a 64-bit register (<code>movsxd</code> rather than <code>movsx</code>).</p>
<p>To zero-extend a value, you can use the <code>movzx</code> instruction. It does not have the restrictions of <code>movsx</code>; as long as the destination operand is larger than the source operand, the instruction works fine. It allows 8 to 16, 32, or 64 bits, and 16 to 32 or 64 bits. There is no 32- to 64-bit version (it turns out this is unnecessary).</p>
<p>The x86-64 CPUs, for historical reasons, will always zero-extend a register from 32 bits to 64 bits when performing 32-bit operations. Therefore, to zero-extend a 32-bit register into a 64-bit register, you need only move the (32-bit) register into itself; for example:</p>
<pre><code>mov eax, eax  ; Zero-extends EAX into RAX</code></pre>
<p>Zero-extending certain 8-bit registers (AL, BL, CL, and DL) into their corresponding 16-bit registers is easily accomplished without using <code>movzx</code> by loading the complementary HO register (AH, BH, CH, or DH) with 0. To zero-extend AX into DX:AX or EAX into EDX:EAX, all you need to do is load DX or EDX with 0.<sup class="FootnoteReference"><a id="c06-footnoteref-3" href="#c06-footnote-3">3</a></sup></p>
<p>Because of instruction-encoding limitations, the x86-64 does not allow you to zero- or sign-extend the AH, BH, CH, or DH registers into any of the 64-bit registers.</p>
<h3 id="h2-501089c06-0002">6.1.2	The mul and imul Instructions</h3>
<p class="BodyFirst">You’ve already seen a subset of the <code>imul</code> instructions available in the x86-64 instruction set (see <span class="xref" itemid="xref_target_“The imul Instruction” in Chapter 4">“The imul Instruction” in Chapter 4</span>). This section presents the extended-precision version of <code>imul</code> along with the unsigned <code>mul</code> instruction.</p>
<p>The multiplication instructions provide you with another taste of irregularity in the x86-64’s instruction set. Instructions like <code>add</code>, <code>sub</code>, and many others in the x86-64 instruction set support two operands, just like the <code>mov</code> instruction. Unfortunately, there weren’t enough bits in the original 8086 opcode byte to support all instructions, so the x86-64 treats the <code>mul</code> (<em>unsigned multiply</em>) and <code>imul</code> (<em>signed integer multiply</em>) instructions as single-operand instructions, just like the <code>inc</code>, <code>dec</code>, and <code>neg</code> instructions. Of course, multiplication <em>is </em>a two-operand function. To work around this fact, the x86-64 always assumes the accumulator (AL, AX, EAX, or RAX) is the destination operand.</p>
<p>Another problem with the <code>mul</code> and <code>imul</code> instructions is that you cannot use them to multiply the accumulator by a constant. Intel quickly discovered the need to support multiplication by a constant and added the more general versions of the <code>imul</code> instruction to overcome this problem. Nevertheless, you must be aware that the basic <code>mul</code> and <code>imul</code> instructions do not support the full range of operands as the <code>imul</code> appearing in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span> does.</p>
<p><span epub:type="pagebreak" title="290" id="Page_290"/>The multiply instruction has two forms: unsigned multiplication (<code>mul</code>) and signed multiplication (<code>imul</code>). Unlike addition and subtraction, you need separate instructions for signed and unsigned operations.</p>
<p>The single-operand multiply instructions take the following forms:</p>
<p class="BodyContinued">Unsigned multiplication:</p>
<pre><code>mul <var>reg</var><sub>8</sub>   ; Returns AX
mul <var>reg</var><sub>16</sub>  ; Returns DX:AX
mul <var>reg</var><sub>32</sub>  ; Returns EDX:EAX
mul <var>reg</var><sub>64</sub>  ; Returns RDX:RAX

mul <var>mem</var><sub>8</sub>   ; Returns AX
mul <var>mem</var><sub>16</sub>  ; Returns DX:AX
mul <var>mem</var><sub>32</sub>  ; Returns EDX:EAX
mul <var>mem</var><sub>64</sub>  ; Returns RDX:RAX</code></pre>
<p class="BodyContinued">Signed (integer) multiplication:</p>
<pre><code>imul <var>reg</var><sub>8</sub>  ; Returns AX
imul <var>reg</var><sub>16</sub> ; Returns DX:AX
imul <var>reg</var><sub>32</sub> ; Returns EDX:EAX
imul <var>reg</var><sub>64</sub> ; Returns RDX:RAX

imul <var>mem</var><sub>8</sub>  ; Returns AX
imul <var>mem</var><sub>16</sub> ; Returns DX:AX
imul <var>mem</var><sub>32</sub> ; Returns EDX:EAX
imul <var>mem</var><sub>64</sub> ; Returns RDX:RAX</code></pre>
<p>The result of multiplying two <em>n</em>-bit values may require as many as 2 × <em>n</em> bits. Therefore, if the operand is an 8-bit quantity, the result could require 16 bits. Likewise, a 16-bit operand produces a 32-bit result, a 32-bit operand produces 64 bits, and a 64-bit operand requires as many as 128 bits to hold the result. <a href="#table6-2" id="tableanchor6-2">Table 6-2</a> lists the various computations.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-2">Table 6-2</a>: <code>mul</code> and <code>imul</code> Operations</p></figcaption>
<table id="table-501089c06-0002" border="1">
<thead>
<tr>
<td><b>Instruction</b></td>
<td><b>Computes</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>mul </code><var>operand</var><sub>8</sub></td>
<td>AX = AL × <em>operand</em><sub>8</sub> (unsigned)</td>
</tr>
<tr>
<td><code>imul </code><var>operand</var><sub>8</sub></td>
<td>AX = AL × <em>operand</em><sub>8</sub> (signed)</td>
</tr>
<tr>
<td><code>mul </code><var>operand</var><sub>16</sub></td>
<td>DX:AX = AX × <em>operand</em><sub>16</sub> (unsigned)</td>
</tr>
<tr>
<td><code>imul </code><var>operand</var><sub>16</sub></td>
<td>DX:AX = AX × <em>operand</em><sub>16</sub> (signed)</td>
</tr>
<tr>
<td><code>mul </code><var>operand</var><sub>32</sub></td>
<td>EDX:EAX = EAX × <em>operand</em><sub>32</sub> (unsigned)</td>
</tr>
<tr>
<td><code>imul </code><var>operand</var><sub>32</sub></td>
<td>EDX:EAX = EAX × <em>operand</em><sub>32</sub> (signed)</td>
</tr>
<tr>
<td><code>mul </code><var>operand</var><sub>64</sub></td>
<td>RDX:RAX = RAX × <em>operand</em><sub>64</sub> (unsigned)</td>
</tr>
<tr>
<td><code>imul </code><var>operand</var><sub>64</sub></td>
<td>RDX:RAX = RAX × <em>operand</em><sub>64</sub> (signed)</td>
</tr>
</tbody>
</table>
</figure>
<p>If an 8×8-, 16×16-, 32×32-, or 64×64-bit product requires more than 8, 16, 32, or 64 bits (respectively), the <code>mul</code> and <code>imul</code> instructions set the carry and overflow flags. <code>mul</code> and <code>imul</code> scramble the sign and zero flags.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="291" id="Page_291"/><h2><span class="NoteHead">Note</span></h2>
<p>	The sign and zero flags do not contain meaningful values after the execution of these two instructions.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>You’ll use the single-operand <code>mul</code> and <code>imul</code> instructions quite a lot when you learn about extended-precision arithmetic in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>. Unless you’re doing multiprecision work, however, you’ll probably want to use the more generic multi-operand version of the <code>imul</code> instruction in place of the extended-precision <code>mul</code> or <code>imul</code>. However, the generic <code>imul</code> (see <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>) is not a complete replacement for these two instructions; in addition to the number of operands, several differences exist. The following rules apply specifically to the generic (multi-operand) <code>imul</code> instruction:</p>
<ul>
<li>There isn’t an 8×8-bit multi-operand <code>imul</code> instruction available.</li>
<li>The generic <code>imul</code> instruction does not produce a 2×<em>n</em>-bit result, but truncates the result to <em>n</em> bits. That is, a 16×16-bit multiplication produces a 16-bit result. Likewise, a 32×32-bit multiplication produces a 32-bit result. These instructions set the carry and overflow flags if the result does not fit into the destination register.</li>
</ul>
<h3 id="h2-501089c06-0003">6.1.3	The div and idiv Instructions</h3>
<p class="BodyFirst">The x86-64 divide instructions perform a 128/64-bit division, a 64/32-bit division, a 32/16-bit division, or a 16/8-bit division. These instructions take the following forms:</p>
<pre><code>div <var>reg</var><sub>8</sub>
div <var>reg</var><sub>16</sub>
div <var>reg</var><sub>32</sub>
div <var>reg</var><sub>64</sub>

div <var>mem</var><sub>8</sub>
div <var>mem</var><sub>16</sub>
div <var>mem</var><sub>32</sub>
div <var>mem</var><sub>64</sub>

idiv <var>reg</var><sub>8</sub>
idiv <var>reg</var><sub>16</sub>
idiv <var>reg</var><sub>32</sub>
idiv <var>reg</var><sub>64</sub>

idiv <var>mem</var><sub>8</sub>
idiv <var>mem</var><sub>16</sub>
idiv <var>mem</var><sub>32</sub>
idiv <var>mem</var><sub>64</sub></code></pre>
<p>The <code>div</code> instruction is an unsigned division operation. If the operand is an 8-bit operand, <code>div</code> divides the AX register by the operand, leaving the quotient in AL and the remainder (modulo) in AH. If the operand is a 16-bit quantity, the <code>div</code> instruction divides the 32-bit quantity in DX:AX by the operand, leaving the quotient in AX and the remainder in DX. With <span epub:type="pagebreak" title="292" id="Page_292"/>32-bit operands, <code>div</code> divides the 64-bit value in EDX:EAX by the operand, leaving the quotient in EAX and the remainder in EDX. Finally, with 64-bit operands, <code>div</code> divides the 128-bit value in RDX:RAX by the operand, leaving the quotient in RAX and the remainder in RDX.</p>
<p>There is no variant of the <code>div</code> or <code>idiv</code> instructions that allows you to divide a value by a constant. If you want to divide a value by a constant, you need to create a memory object (preferably in the <code>.const</code> section) that is initialized with the constant, and then use that memory value as the <code>div</code>/<code>idiv</code> operand. For example:</p>
<pre><code>        .const
ten     dword   10
          .
          .
          .
         div    ten ; Divides EDX:EAX by 10</code></pre>
<p>The <code>idiv</code> instruction computes a signed quotient and remainder. The syntax for the <code>idiv</code> instruction is identical to <code>div</code> (except for the use of the <code>idiv</code> mnemonic), though creating signed operands for <code>idiv</code> may require a different sequence of instructions prior to executing <code>idiv</code> than for <code>div</code>.</p>
<p>You cannot, on the x86-64, simply divide one unsigned 8-bit value by another. If the denominator is an 8-bit value, the numerator must be a 16-bit value. If you need to divide one unsigned 8-bit value by another, you must zero-extend the numerator to 16 bits by loading the numerator into the AL register and then moving 0 into the AH register. <em>Failing to zero-extend AL before executing </em><var>div</var><em> may cause the x86-64 to produce incorrect results</em>! When you need to divide two 16-bit unsigned values, you must zero-extend the AX register (which contains the numerator) into the DX register. To do this, just load 0 into the DX register. If you need to divide one 32-bit value by another, you must zero-extend the EAX register into EDX (by loading a 0 into EDX) before the division. Finally, to divide one 64-bit number by another, you must zero-extend RAX into RDX (for example, using an <code>xor rdx, rdx</code> instruction) prior to the division.</p>
<p>When dealing with signed integer values, you will need to sign-extend AL into AX, AX into DX, EAX into EDX, or RAX into RDX before executing <code>idiv</code>. To do so, use the <code>cbw</code>, <code>cwd</code>, <code>cdq</code>, or <code>cqo</code> instructions.<sup class="FootnoteReference"><a id="c06-footnoteref-4" href="#c06-footnote-4">4</a></sup> Failure to do so may produce incorrect results.</p>
<p>The x86-64’s divide instructions have one other issue: you can get a fatal error when using this instruction. First, of course, you can attempt to divide a value by 0. Another problem is that the quotient may be too large to fit into the RAX, EAX, AX, or AL register. For example, the 16/8-bit division 8000h/2 produces the quotient 4000h with a remainder of 0. 4000h will not fit into 8 bits. If this happens, or you attempt to divide by 0, the x86-64 will generate a division exception or integer overflow exception. This usually means your program will crash. If this happens to you, chances are you <span epub:type="pagebreak" title="293" id="Page_293"/>didn’t sign- or zero-extend your numerator before executing the division operation. Because this error may cause your program to crash, you should be very careful about the values you select when using division.</p>
<p>The x86-64 leaves the carry, overflow, sign, and zero flags undefined after a division operation. Therefore, you cannot test for problems after a division operation by checking the flag bits.</p>
<h3 id="h2-501089c06-0004">6.1.4	The cmp Instruction, Revisited</h3>
<p class="BodyFirst">As noted in <span class="xref" itemid="xref_target_“The cmp Instruction and Corresponding Conditional Jumps” in Chapter 2">“The cmp Instruction and Corresponding Conditional Jumps” in Chapter 2</span>, the <code>cmp</code> instruction updates the x86-64’s flags according to the result of the subtraction operation (<var>leftOperand</var><code> - </code><var>rightOperand</var>). The x86-64 sets the flags in an appropriate fashion so that we can read this instruction as “compare <var>leftOperand</var> to <var>rightOperand</var>.” You can test the result of the comparison by using the conditional set instructions to check the appropriate flags in the FLAGS register (see <span class="xref" itemid="xref_target_“The setcc Instructions” on page 295">“The setcc Instructions” on page 295</span>) or the conditional jump instructions (<span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span> or <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>).</p>
<p>Probably the first place to start when exploring the <code>cmp</code> instruction is to look at exactly how it affects the flags. Consider the following <code>cmp</code> instruction:</p>
<pre><code>cmp ax, bx</code></pre>
<p>This instruction performs the computation AX – BX and sets the flags depending on the result of the computation. The flags are set as follows (also see <a href="#table6-3" id="tableanchor6-3">Table 6-3</a>):</p>
<p class="ListHead"><b>ZF</b></p>
<ol class="none">
<li>The zero flag is set if and only if AX = BX. This is the only time AX – BX produces a 0 result. Hence, you can use the zero flag to test for equality or inequality.</li>
</ol>
<p class="ListHead"><b>SF</b></p>
<ol class="none">
<li>The sign flag is set to 1 if the result is negative. At first glance, you might think that this flag would be set if AX is less than BX, but this isn’t always the case. If AX = 7FFFh and BX = –1 (0FFFFh), then subtracting AX from BX produces 8000h, which is negative (and so the sign flag will be set). So, for signed comparisons anyway, the sign flag doesn’t contain the proper status. For unsigned operands, consider AX = 0FFFFh and BX = 1. Here, AX is greater than BX, but their difference is 0FFFEh, which is still negative. As it turns out, the sign flag and the overflow flag, taken together, can be used for comparing two signed values.</li>
</ol>
<p class="ListHead"><b>OF</b></p>
<ol class="none">
<li>The overflow flag is set after a <code>cmp</code> operation if the difference of AX and BX produced an overflow or underflow. As mentioned previously, the sign and overflow flags are both used when performing signed comparisons.</li>
</ol>
<p class="ListHead"><b><span epub:type="pagebreak" title="294" id="Page_294"/>CF</b></p>
<ol class="none">
<li>The carry flag is set after a <code>cmp</code> operation if subtracting BX from AX requires a borrow. This occurs only when AX is less than BX, where AX and BX are both unsigned values.</li>
</ol>
<figure>
<figcaption class="TableTitle"><p><a id="table6-3">Table 6-3</a>: Condition Code Settings After <code>cmp</code></p></figcaption>
<table id="table-501089c06-0003" border="1">
<thead>
<tr>
<td><b>Unsigned operands</b></td>
<td><b>Signed operands</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>ZF:  Equality/inequality</td>
<td>ZF:  Equality/inequality</td>
</tr>
<tr>
<td>CF:  Left <code>&lt;</code> Right (C = 1)<br/>
      Left <code>≥</code> Right (C = 0)</td>
<td>CF:  No meaning </td>
</tr>
<tr>
<td>SF:  No meaning</td>
<td>SF:  See discussion in this section</td>
</tr>
<tr>
<td>OF:  No meaning</td>
<td>OF:  See discussion in this section</td>
</tr>
</tbody>
</table>
</figure>
<p>Given that the <code>cmp</code> instruction sets the flags in this fashion, you can test the comparison of the two operands with the following flags:</p>
<pre><code>cmp <var>Left</var>, <var>Right</var></code></pre>
<p>For signed comparisons, the SF (sign) and OF (overflow) flags, taken together, have the following meanings:</p>
<ul>
<li>If [(SF = 0) and (OF = 1)] or [(SF = 1) and (OF = 0)], then <var>Left</var> <code>&lt;</code> <var>Right</var> for a signed comparison.</li>
<li>If [(SF = 0) and (OF = 0)] or [(SF = 1) and (OF = 1)], then <var>Left</var> <code>≥</code> <var>Right</var> for a signed comparison.</li>
</ul>
<p>Note that (SF <code>xor</code> OF) is 1 if the left operand is less than the right operand. Conversely, (SF <code>xor</code> OF) is 0 if the left operand is greater than or equal to the right operand.</p>
<p>To understand why these flags are set in this manner, consider the examples in <a href="#table6-4" id="tableanchor6-4">Table 6-4</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-4">Table 6-4</a>: Sign and Overflow Flag Settings After Subtraction</p></figcaption>
<table id="table-501089c06-0004" border="1">
<thead>
<tr>
<td><b>Left</b></td>
<td><b>Minus</b></td>
<td><b>Right</b></td>
<td><b>SF</b></td>
<td><b>OF</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>0FFFFh (–1)</td>
<td>–</td>
<td>0FFFEh (–2)</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>8000h (–32,768)</td>
<td>–</td>
<td>0001h</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0FFFEh (–2)</td>
<td>–</td>
<td>0FFFFh (–1)</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>7FFFh (32767)</td>
<td>–</td>
<td>0FFFFh (–1)</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</figure>
<p>Remember, the <code>cmp</code> operation is really a subtraction; therefore, the first example in <a href="#table6-4">Table 6-4</a> computes (–1) – (–2), which is (+1). The result is positive and an overflow did not occur, so both the S and O flags are 0. Because (SF <code>xor</code> OF) is 0, <var>Left</var> is greater than or equal to <var>Right</var>.</p>
<p><span epub:type="pagebreak" title="295" id="Page_295"/>In the second example, the <code>cmp</code> instruction computes (–32,768) – (+1), which is (–32,769). Because a 16-bit signed integer cannot represent this value, the value wraps around to 7FFFh (+32,767) and sets the overflow flag. The result is positive (at least as a 16-bit value), so the CPU clears the sign flag. (SF <code>xor</code> OF) is 1 here, so <var>Left</var> is less than <var>Right</var>.</p>
<p>In the third example, <code>cmp</code> computes (–2) – (–1), which produces (–1). No overflow occurred, so the OF is 0, and the result is negative, so the SF is 1. Because (SF <code>xor</code> OF) is 1, <var>Left</var> is less than <var>Right</var>.</p>
<p>In the fourth (and final) example, <code>cmp</code> computes (+32,767) – (–1). This produces (+32,768), setting the overflow flag. Furthermore, the value wraps around to 8000h (–32,768), so the sign flag is set as well. Because (SF <code>xor</code> OF) is 0, <var>Left</var> is greater than or equal to <var>Right</var>.</p>
<h3 id="h2-501089c06-0005">6.1.5	The setcc Instructions</h3>
<p class="BodyFirst">The <code>set</code><var>cc</var> (<em>set on condition</em>) instructions set a single-byte operand (register or memory) to 0 or 1 depending on the values in the FLAGS register. The general formats for the <code>set</code><var>cc</var> instructions are as follows:</p>
<pre><code>set<var>cc</var> <var>reg</var><sub>8</sub>
set<var>cc</var> <var>mem</var><sub>8</sub></code></pre>
<p>The <code>set</code><var>cc</var> represents a mnemonic appearing in Tables 6-5, 6-6, and 6-7. These instructions store a 0 in the corresponding operand if the condition is false, and they store a 1 in the 8-bit operand if the condition is true.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-5">Table 6-5</a>: <code>set</code><var>cc</var> Instructions That Test Flags</p></figcaption>
<table id="table-501089c06-0005" border="1">
<thead>
<tr>
<td><b>Instruction</b></td>
<td><b>Description</b></td>
<td><b>Condition</b></td>
<td><b>Comments</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>setc</code></td>
<td>Set if carry</td>
<td>Carry = 1</td>
<td>Same as <code>setb</code>, <code>setnae</code></td>
</tr>
<tr>
<td><code>setnc</code></td>
<td>Set if no carry</td>
<td>Carry = 0</td>
<td>Same as <code>setnb</code>, <code>setae</code></td>
</tr>
<tr>
<td><code>setz</code></td>
<td>Set if zero</td>
<td>Zero = 1</td>
<td>Same as <code>sete</code></td>
</tr>
<tr>
<td><code>setnz</code></td>
<td>Set if not zero</td>
<td>Zero = 0</td>
<td>Same as <code>setne</code></td>
</tr>
<tr>
<td><code>sets</code></td>
<td>Set if sign</td>
<td>Sign = 1</td>
<td/>
</tr>
<tr>
<td><code>setns</code></td>
<td>Set if no sign</td>
<td>Sign = 0</td>
<td/>
</tr>
<tr>
<td><code>seto</code></td>
<td>Set if overflow</td>
<td>Overflow = 1</td>
<td/>
</tr>
<tr>
<td><code>setno</code></td>
<td>Set if no overflow</td>
<td>Overflow = 0</td>
<td/>
</tr>
<tr>
<td><code>setp</code></td>
<td>Set if parity</td>
<td>Parity = 1</td>
<td>Same as <code>setpe</code></td>
</tr>
<tr>
<td><code>setpe</code></td>
<td>Set if parity even</td>
<td>Parity = 1</td>
<td>Same as <code>setp</code></td>
</tr>
<tr>
<td><code>setnp</code></td>
<td>Set if no parity</td>
<td>Parity = 0</td>
<td>Same as <code>setpo</code></td>
</tr>
<tr>
<td><code>setpo</code></td>
<td>Set if parity odd</td>
<td>Parity = 0</td>
<td>Same as <code>setnp</code></td>
</tr>
</tbody>
</table>
</figure>
<p><span epub:type="pagebreak" title="296" id="Page_296"/>The <code>set</code><var>cc</var> instructions in <a href="#table6-5" id="tableanchor6-5">Table 6-5</a> simply test the flags without any other meaning attached to the operation. You could, for example, use <code>setc</code> to check the carry flag after a shift, rotate, bit test, or arithmetic operation.</p>
<p>The <code>setp</code>/<code>setpe</code> and <code>setnp</code>/<code>setpo</code> instructions check the parity flag. These instructions appear here for completeness, but this book will not spend much time discussing the parity flag; in modern code, it’s typically used only to check for an FPU not-a-number (NaN) condition.</p>
<p>The <code>cmp</code> instruction works synergistically with the <code>set</code><var>cc</var> instructions. Immediately after a <code>cmp</code> operation, the processor flags provide information concerning the relative values of those operands. They allow you to see if one operand is less than, equal to, or greater than the other.</p>
<p>Two additional groups of <code>set</code><var>cc</var> instructions are useful after a <code>cmp</code> operation. The first group deals with the result of an unsigned comparison (<a href="#table6-6" id="tableanchor6-6">Table 6-6</a>); the second group deals with the result of a signed comparison (<a href="#table6-7" id="tableanchor6-7">Table 6-7</a>).</p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-6">Table 6-6</a>: <code>set</code><var>cc</var> Instructions for Unsigned Comparisons</p></figcaption>
<table id="table-501089c06-0006" border="1">
<thead>
<tr>
<td><b>Instruction</b></td>
<td><b>Description</b></td>
<td><b>Condition</b></td>
<td><b>Comments</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>seta</code></td>
<td>Set if above (<code>&gt;</code>)</td>
<td>Carry <code>=</code> 0, Zero <code>=</code> 0</td>
<td>Same as <code>setnbe</code></td>
</tr>
<tr>
<td><code>setnbe</code></td>
<td>Set if not below or equal (not <code>≤</code>)</td>
<td>Carry <code>=</code> 0, Zero <code>=</code> 0</td>
<td>Same as <code>seta</code></td>
</tr>
<tr>
<td><code>setae</code></td>
<td>Set if above or equal (<code>≥</code>)</td>
<td>Carry <code>=</code> 0</td>
<td>Same as <code>setnc</code>, <code>setnb</code></td>
</tr>
<tr>
<td><code>setnb</code></td>
<td>Set if not below (not <code>&lt;</code>)</td>
<td>Carry <code>=</code> 0</td>
<td>Same as <code>setnc</code>, <code>setae</code></td>
</tr>
<tr>
<td><code>setb</code></td>
<td>Set if below (<code>&lt;</code>)</td>
<td>Carry <code>=</code> 1</td>
<td>Same as <code>setc</code>, <code>setnae</code></td>
</tr>
<tr>
<td><code>setnae</code></td>
<td>Set if not above or equal (not <code>≥</code>)</td>
<td>Carry <code>=</code> 1</td>
<td>Same as <code>setc</code>, <code>setb</code></td>
</tr>
<tr>
<td><code>setbe</code></td>
<td>Set if below or equal (<code>≤</code>)</td>
<td>Carry <code>=</code> 1 or Zero <code>=</code> 1</td>
<td>Same as <code>setna</code></td>
</tr>
<tr>
<td><code>setna</code></td>
<td>Set if not above (not <code>&gt;</code>)</td>
<td>Carry <code>=</code> 1 or Zero <code>=</code> 1</td>
<td>Same as <code>setbe</code></td>
</tr>
<tr>
<td><code>sete</code></td>
<td>Set if equal (<code>==</code>)</td>
<td>Zero <code>=</code> 1</td>
<td>Same as <code>setz</code></td>
</tr>
<tr>
<td><code>setne</code></td>
<td>Set if not equal (<code>≠</code>)</td>
<td>Zero <code>=</code> 0</td>
<td>Same as <code>setnz</code></td>
</tr>
</tbody>
</table>
</figure>
<figure>
<figcaption class="TableTitle"><p><a id="table6-7">Table 6-7</a>: <code>set</code><var>cc</var> Instructions for Signed Comparisons</p></figcaption>
<table id="table-501089c06-0007" border="1">
<thead>
<tr>
<td><b>Instruction</b></td>
<td><b>Description</b></td>
<td><b>Condition</b></td>
<td><b>Comments</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>setg</code></td>
<td>Set if greater (<code>&gt;</code>)</td>
<td>Sign <code>==</code> Overflow and 
Zero <code>==</code> 0</td>
<td>Same as <code>setnle</code></td>
</tr>
<tr>
<td><code>setnle</code></td>
<td>Set if not less than or equal (not <code>≤</code>)</td>
<td>Sign <code>==</code> Overflow or 
Zero <code>==</code> 0</td>
<td>Same as <code>setg</code></td>
</tr>
<tr>
<td><code><span epub:type="pagebreak" title="297" id="Page_297"/>setge</code></td>
<td>Set if greater than or equal (<code>≥</code>)</td>
<td>Sign <code>==</code> Overflow</td>
<td>Same as <code>setnl</code></td>
</tr>
<tr>
<td><code>setnl</code></td>
<td>Set if not less than (not <code>&lt;</code>)</td>
<td>Sign <code>==</code> Overflow</td>
<td>Same as <code>setge</code></td>
</tr>
<tr>
<td><code>setl</code></td>
<td>Set if less than (<code>&lt;</code>)</td>
<td>Sign <code>≠</code> Overflow</td>
<td>Same as <code>setnge</code></td>
</tr>
<tr>
<td><code>setnge</code></td>
<td>Set if not greater or equal (not <code>≥</code>)</td>
<td>Sign <code>≠</code> Overflow</td>
<td>Same as <code>setl</code></td>
</tr>
<tr>
<td><code>setle</code></td>
<td>Set if less than or equal (<code>≤</code>)</td>
<td>Sign <code>≠</code> Overflow or 
Zero <code>==</code> 1</td>
<td>Same as <code>setng</code></td>
</tr>
<tr>
<td><code>setng</code></td>
<td>Set if not greater than (not <code>&gt;</code>)</td>
<td>Sign <code>≠</code> Overflow or 
Zero <code>==</code> 1</td>
<td>Same as <code>setle</code></td>
</tr>
<tr>
<td><code>sete</code></td>
<td>Set if equal (<code>=</code>)</td>
<td>Zero <code>==</code> 1</td>
<td>Same as <code>setz</code></td>
</tr>
<tr>
<td><code>setne</code></td>
<td>Set if not equal (<code>≠</code>)</td>
<td>Zero <code>==</code> 0</td>
<td>Same as <code>setnz</code></td>
</tr>
</tbody>
</table>
</figure>
<p>The <code>set</code><var>cc</var> instructions are particularly valuable because they can convert the result of a comparison to a Boolean value (false/true or 0/1). This is especially important when translating statements from a high-level language like Swift or C/C++ into assembly language. The following example shows how to use these instructions in this manner:</p>
<pre><code>; bool = a &lt;= b:

          mov eax, a
          cmp eax, b
          setle bool    ; bool is a byte variable</code></pre>
<p>Because the <code>set</code><var>cc</var> instructions always produce 0 or 1, you can use the results with the <code>and</code> and <code>or</code> instructions to compute complex Boolean values:</p>
<pre><code>; bool = ((a &lt;= b) &amp;&amp; (d == e)):

          mov   eax, a
          cmp   eax, b
          setle bl
          mov   eax, d
          cmp   eax, e
          sete  bh
          and   bh, bl
          mov   bool, bh</code></pre>
<h3 id="h2-501089c06-0006">6.1.6	The test Instruction</h3>
<p class="BodyFirst">The x86-64 <code>test</code> instruction is to the <code>and</code> instruction what the <code>cmp</code> instruction is to <code>sub</code>. That is, the <code>test</code> instruction computes the logical AND of its two operands and sets the condition code flags based on the result; it does not, <span epub:type="pagebreak" title="298" id="Page_298"/>however, store the result of the logical AND back into the destination operand. The syntax for the <code>test</code> instruction is similar to <code>and</code>:</p>
<pre><code>test <var>operand1</var>, <var>operand2</var></code></pre>
<p>The <code>test</code> instruction sets the zero flag if the result of the logical AND operation is 0. It sets the sign flag if the HO bit of the result contains a 1. The <code>test</code> instruction always clears the carry and overflow flags.</p>
<p>The primary use of the <code>test</code> instruction is to check whether an individual bit contains a 0 or a 1. Consider the instruction <code>test al, 1</code>. This instruction logically ANDs AL with the value 1; if bit 0 of AL contains 0, the result will be 0 (setting the zero flag) because all the other bits in the constant 1 are 0. Conversely, if bit 0 of AL contains 1, then the result is not 0, so <code>test</code> clears the zero flag. Therefore, you can test the zero flag after this <code>test</code> instruction to see if bit 0 contains a 0 or a 1 (for example, using <code>setz</code> or <code>setnz</code> instructions, or the <code>jz</code>/<code>jnz</code> instructions).</p>
<p>The <code>test</code> instruction can also check whether all the bits in a specified set of bits contain 0. The instruction <code>test al, 0fh</code> sets the zero flag if and only if the LO 4 bits of AL all contain 0.</p>
<p>One important use of the <code>test</code> instruction is to check whether a register contains 0. The instruction <code>test </code><var>reg</var><code>, </code><var>reg</var>, where both operands are the same register, will logically AND that register with itself. If the register contains 0, the result is 0 and the CPU will set the zero flag. However, if the register contains a nonzero value, logically ANDing that value with itself produces that same nonzero value, so the CPU clears the zero flag. Therefore, you can check the zero flag immediately after the execution of this instruction (for example, using the <code>setz</code> or <code>setnz</code> instructions or the <code>jz</code> and <code>jnz</code> instructions) to see if the register contains 0. Here are some examples:</p>
<pre><code>          test eax, eax
          setz bl          ; BL is set to 1 if EAX contains 0
               .
               .
               .
          test bl, bl
          jz   bxIs0

     <var>Do something if BL != 0</var>

bxIs0:</code></pre>
<p>One major failing of the <code>test</code> instruction is that immediate (constant) operands can be no larger than 32 bits (as is the case with most instructions), which makes it difficult to use this instruction to test for set bits beyond bit position 31. For testing individual bits, you can use the <code>bt</code> (<em>bit test</em>) instruction (see <span class="xref" itemid="xref_target_“Instructions That Manipulate Bits” in Chapter 12">“Instructions That Manipulate Bits” in Chapter 12</span>). Otherwise, you’ll have to move the 64-bit constant into a register (the <code>mov</code> instruction does support 64-bit immediate operands) and then test your target register against the 64-bit constant value in the newly loaded register.</p>
<h2 id="h1-501089c06-0002"><span epub:type="pagebreak" title="299" id="Page_299"/>	6.2	Arithmetic Expressions</h2>
<p class="BodyFirst">Probably the biggest shock to beginners facing assembly language for the first time is the lack of familiar arithmetic expressions. <em>Arithmetic expressions</em>, in most high-level languages, look similar to their algebraic equivalents. For example:</p>
<pre><code>x = y * z;</code></pre>
<p>In assembly language, you’ll need several statements to accomplish this same task:</p>
<pre><code>mov  eax, y
imul eax, z
mov  x, eax</code></pre>
<p>Obviously, the HLL version is much easier to type, read, and understand. Although a lot of typing is involved, converting an arithmetic expression into assembly language isn’t difficult at all. By attacking the problem in steps, the same way you would solve the problem by hand, you can easily break any arithmetic expression into an equivalent sequence of assembly language statements.</p>
<h3 id="h2-501089c06-0007">6.2.1	Simple Assignments</h3>
<p class="BodyFirst">The easiest expressions to convert to assembly language are simple assignments. <em>Simple assignments</em> copy a single value into a variable and take one of two forms:</p>
<pre><code><var>variable</var> = <var>constant</var></code></pre>
<p class="BodyContinued">or</p>
<pre><code><var>var1</var> = <var>var2</var></code></pre>
<p>Converting the first form to assembly language is simple—just use this assembly language statement:</p>
<pre><code>mov <var>variable</var>, <var>constant</var></code></pre>
<p>This <code>mov</code> instruction copies the constant into the variable.</p>
<p>The second assignment is slightly more complicated because the x86-64 doesn’t provide a memory-to-memory <code>mov</code> instruction. Therefore, to copy one memory variable into another, you must move the data through a register. By convention (and for slight efficiency reasons), most programmers tend to favor AL, AX, EAX, or RAX for this purpose. For example:</p>
<pre><code><var>var1</var> = <var>var2</var>;</code></pre>
<p class="BodyContinued">becomes</p>
<pre><code>mov eax, <var>var2</var>
mov <var>var1</var>, eax</code></pre>
<p class="BodyContinued"><span epub:type="pagebreak" title="300" id="Page_300"/>assuming that <var>var1</var> and <var>var2</var> are 32-bit variables. Use AL if they are 8-bit variables, use AX if they are 16-bit variables, or use RAX if they are 64-bit variables.</p>
<p>Of course, if you’re already using AL, AX, EAX, or RAX for something else, one of the other registers will suffice. Regardless, you will generally use a register to transfer one memory location to another.</p>
<h3 id="h2-501089c06-0008">6.2.2	Simple Expressions</h3>
<p class="BodyFirst">The next level of complexity is a simple expression. A <em>simple expression</em> takes the form</p>
<pre><code><var>var1</var> = <var>term1</var> <var>op</var> <var>term2</var>;</code></pre>
<p class="BodyContinued">where <var>var1</var> is a variable, <var>term1</var> and <var>term2</var> are variables or constants, and <var>op</var> is an arithmetic operator (addition, subtraction, multiplication, and so on). Most expressions take this form. It should come as no surprise, then, that the x86-64 architecture was optimized for just this type of expression.</p>
<p>A typical conversion for this type of expression takes the form</p>
<pre><code>mov eax, <var>term1</var>
<var>op</var>  eax, <var>term2</var>
mov <var>var1</var>, eax</code></pre>
<p class="BodyContinued">where <var>op</var> is the mnemonic that corresponds to the specified operation (for example, + is <code>add</code>, – is <code>sub</code>, and so forth).</p>
<p>Note that the simple expression <var>var1</var><code> = </code><var>const1</var><code> </code><var>op</var><code> </code><var>const2</var><code>;</code> is easily handled with a compile-time expression and a single <code>mov</code> instruction. For example, to compute <var>var1</var><code> = 5 + 3;</code>, use the single instruction <code>mov </code><var>var1</var><code>, 5 + 3</code>.</p>
<p>You need to be aware of a few inconsistencies. When dealing with the <code>(</code><var>i</var><code>)mul</code> and <code>(</code><var>i</var><code>)div</code> instructions on the x86-64, you must use the AL, AX, EAX, and RAX registers and the AH, DX, EDX, and RDX registers. You cannot use arbitrary registers as you can with other operations. Also, don’t forget the sign-extension instructions if you’re performing a division operation to divide one 16-, 32-, or 64-bit number by another. Finally, don’t forget that some instructions may cause overflow. You may want to check for an overflow (or underflow) condition after an arithmetic operation.</p>
<p>Here are examples of common simple expressions:</p>
<pre><code>; x = y + z:

          mov eax, y
          add eax, z
          mov x, eax

; x = y - z:

          mov eax, y
<span epub:type="pagebreak" title="301" id="Page_301"/>          sub eax, z
          mov x, eax

; x = y * z; (unsigned):

          mov eax, y
          mul z              ; Don't forget this wipes out EDX
          mov x, eax

; x = y * z; (signed):

          mov  eax, y
          imul eax, z        ; Does not affect EDX!
          mov x, eax

; x = y div z; (unsigned div):

          mov eax, y
          xor edx, edx       ; Zero-extend EAX into EDX
          div z
          mov x, eax

; x = y idiv z; (signed div):

          mov eax, y
          cdq                ; Sign-extend EAX into EDX
          idiv z
          mov x, eax

; x = y % z; (unsigned remainder):

          mov  eax, y
          xor  edx, edx      ; Zero-extend EAX into EDX
          div  z
          mov  x, edx        ; Note that remainder is in EDX

; x = y % z; (signed remainder):

          mov  eax, y
          cdq                ; Sign-extend EAX into EDX
          idiv z
          mov  x, edx        ; Remainder is in EDX</code></pre>
<p>Certain unary operations also qualify as simple expressions, producing additional inconsistencies to the general rule. A good example of a unary operation is <em>negation</em>. In a high-level language, negation takes one of two possible forms:</p>
<pre><code><var>var</var> = <var>–var</var></code></pre>
<p class="BodyContinued">or</p>
<pre><code><var>var1</var> = <var>–var2</var></code></pre>
<p><span epub:type="pagebreak" title="302" id="Page_302"/>Note that <var>var</var><code> = –</code><var>constant</var> is really a simple assignment, not a simple expression. You can specify a negative constant as an operand to the <code>mov</code> instruction:</p>
<pre><code>mov var, -14</code></pre>
<p>To handle <var>var1</var><code> = –</code><var>var1</var>, use this single assembly language statement:</p>
<pre><code>; <var>var1</var> = <var>-var1</var>;

neg <var>var1</var></code></pre>
<p>If two different variables are involved, use the following:</p>
<pre><code>; <var>var1</var> = <var>-var2</var>;

mov eax, <var>var2</var>
neg eax
mov <var>var1</var>, eax</code></pre>
<h3 id="h2-501089c06-0009">6.2.3	Complex Expressions</h3>
<p class="BodyFirst">A <em>complex </em><em>expression</em> is any arithmetic expression involving more than two terms and one operator. Such expressions are commonly found in programs written in a high-level language. Complex expressions may include parentheses to override operator precedence, function calls, array accesses, and so on. This section outlines the rules for converting such expressions.</p>
<p>A complex expression that is easy to convert to assembly language is one that involves three terms and two operators. For example:</p>
<pre><code>w = w - y - z;</code></pre>
<p>Clearly the straightforward assembly language conversion of this statement requires two <code>sub</code> instructions. However, even with an expression as simple as this, the conversion is not trivial. There are actually <em>two ways</em> to convert the preceding statement into assembly language:</p>
<pre><code>mov eax, w
sub eax, y
sub eax, z
mov w, eax</code></pre>
<p class="BodyContinued">and</p>
<pre><code>mov eax, y
sub eax, z
sub w, eax</code></pre>
<p>The second conversion, because it is shorter, looks better. However, it produces an incorrect result (assuming C-like semantics for the original statement). Associativity is the problem. The second sequence in the preceding example computes <code>w = w – (y – z)</code>, which is not the same as <code>w = (w – y) – z</code>. <span epub:type="pagebreak" title="303" id="Page_303"/>How we place the parentheses around the subexpressions can affect the result. Note that if you are interested in a shorter form, you can use the following sequence:</p>
<pre><code>mov eax, y
add eax, z
sub w, eax</code></pre>
<p>This computes <code>w = w – (y + z)</code>, equivalent to <code>w = (w – y) – z</code>.</p>
<p><em>Precedence</em> is another issue. Consider this expression:</p>
<pre><code>x = w * y + z;</code></pre>
<p>Once again, we can evaluate this expression in two ways:</p>
<pre><code>x = (w * y) + z;</code></pre>
<p class="BodyContinued">or</p>
<pre><code>x = w * (y + z);</code></pre>
<p>By now, you’re probably thinking that this explanation is crazy. Everyone knows the correct way to evaluate these expressions is by the former form. However, you’d be wrong. The APL programming language, for example, evaluates expressions solely from right to left and does not give one operator precedence over another. Which way is “correct” depends entirely on how you define precedence in your arithmetic system.</p>
<p>Consider this expression:</p>
<pre><code>x <var>op1</var> y <var>op2</var> z</code></pre>
<p>If <var>op1</var> takes precedence over <var>op2</var>, then this evaluates to <code>(x </code><var>op1</var><code> y) </code><var>op2</var><code> z</code><em>.</em> Otherwise, if <var>op2</var> takes precedence over <var>op1</var>, this evaluates to <code>x </code><var>op1</var><code> (y </code><var>op2</var><code> z)</code>. Depending on the operators and operands involved, these two computations could produce different results.</p>
<p>Most high-level languages use a fixed set of precedence rules to describe the order of evaluation in an expression involving two or more different operators. Such programming languages usually compute multiplication and division before addition and subtraction. Those that support exponentiation (for example, FORTRAN and BASIC) usually compute that before multiplication and division. These rules are intuitive because almost everyone learns them before high school.</p>
<p>When converting expressions into assembly language, you must be sure to compute the subexpression with the highest precedence first. The following example demonstrates this technique:</p>
<pre><code>; w = x + y * z:

          mov ebx, x
          mov eax, y     ; Must compute y * z first because "*"
          imul eax, z    ; has higher precedence than "+"
<span epub:type="pagebreak" title="304" id="Page_304"/>          add eax, ebx
          mov w, eax</code></pre>
<p>If two operators appearing within an expression have the same precedence, you determine the order of evaluation by using associativity rules. Most operators are <em>left-associative</em>, meaning they evaluate from left to right. Addition, subtraction, multiplication, and division are all left-associative. A <em>right-associative</em> operator evaluates from right to left. The exponentiation operator in FORTRAN is a good example of a right-associative operator:</p>
<pre><code>2**2**3</code></pre>
<p class="BodyContinued">is equal to</p>
<pre><code>2**(2**3)</code></pre>
<p class="BodyContinued">not</p>
<pre><code>(2**2)**3</code></pre>
<p>The precedence and associativity rules determine the order of evaluation. Indirectly, these rules tell you where to place parentheses in an expression to determine the order of evaluation. Of course, you can always use parentheses to override the default precedence and associativity. However, the ultimate point is that your assembly code must complete certain operations before others to correctly compute the value of a given expression. The following examples demonstrate this principle:</p>
<pre><code>; w = x - y - z:

          mov eax, x     ; All the same operator precedence,
          sub eax, y     ; so we need to evaluate from left
          sub eax, z     ; to right because they are left-
          mov w, eax     ; associative

; w = x + y * z:

          mov  eax, y    ; Must compute y * z first because
          imul eax, z    ; multiplication has a higher
          add eax, x     ; precedence than addition
          mov w, eax

; w = x / y - z:

          mov  eax, x    ; Here we need to compute division
          cdq            ; first because it has the highest
          idiv y         ; precedence
          sub eax, z
          mov w, eax

<span epub:type="pagebreak" title="305" id="Page_305"/>; w = x * y * z:

          mov  eax, y     ; Addition and multiplication are
          imul eax, z     ; commutative; therefore, the order
          imul eax, x     ; of evaluation does not matter
          mov  w, eax</code></pre>
<p>The associativity rule has one exception: if an expression involves multiplication and division, it is generally better to perform the multiplication first. For example, given an expression of the form</p>
<pre><code>w = x / y * z      ; Note: This is (x * z) / y, not x / (y * z)</code></pre>
<p class="BodyContinued">it is usually better to compute <code>x * z</code> and then divide the result by <code>y</code> rather than divide <code>x</code> by <code>y</code> and multiply the quotient by <code>z</code>.</p>
<p>This approach is better for two reasons. First, remember that the <code>imul</code> instruction always produces a 64-bit result (assuming 32-bit operands). By doing the multiplication first, you automatically <em>sign-extend</em> the product into the EDX register so you do not have to sign-extend EAX prior to the division.</p>
<p>A second reason for doing the multiplication first is to increase the accuracy of the computation. Remember, (integer) division often produces an inexact result. For example, if you compute 5 / 2, you will get the value 2, not 2.5. Computing (5 / 2) × 3 produces 6. However, if you compute (5 × 3) / 2, you get the value 7, which is a little closer to the real quotient (7.5). Therefore, if you encounter an expression of the form</p>
<pre><code>w = x / y * z;</code></pre>
<p class="BodyContinued">you can usually convert it to the following assembly code:</p>
<pre><code>mov  eax, x
imul z      ; Note the use of extended imul!
idiv y
mov  w, eax</code></pre>
<p>If the algorithm you’re encoding depends on the truncation effect of the division operation, you cannot use this trick to improve the algorithm. Moral of the story: always make sure you fully understand any expression you are converting to assembly language. If the semantics dictate that you must perform the division first, then do so.</p>
<p>Consider the following statement:</p>
<pre><code>w = x – y * x;</code></pre>
<p> Because subtraction is not commutative, you cannot compute <code>y * x</code> and then subtract <code>x</code> from this result. Rather than use a straightforward multiplication-and-addition sequence, you’ll have to load <code>x</code> into a register, multiply <code/><span epub:type="pagebreak" title="306" id="Page_306"/>y and <code>x</code> (leaving their product in a different register), and then subtract this product from <code>x</code>. For example:</p>
<pre><code>mov  ecx, x
mov  eax, y
imul eax, x
sub  ecx, eax
mov  w, ecx </code></pre>
<p>This trivial example demonstrates the need for <em>temporary variables</em> in an expression. The code uses the ECX register to temporarily hold a copy of <code>x</code> until it computes the product of <code>y</code> and <code>x</code>. As your expressions increase in complexity, the need for temporaries grows. Consider the following C statement:</p>
<pre><code>w = (a + b) * (y + z);</code></pre>
<p>Following the normal rules of algebraic evaluation, you compute the subexpressions inside the parentheses first (that is, the two subexpressions with the highest precedence) and set their values aside. When you’ve computed the values for both subexpressions, you can compute their product. One way to deal with a complex expression like this is to reduce it to a sequence of simple expressions whose results wind up in temporary variables. For example, you can convert the preceding single expression into the following sequence:</p>
<pre><code>temp1 = a + b;
temp2 = y + z;
w = temp1 * temp2;</code></pre>
<p>Because converting simple expressions to assembly language is quite easy, it’s now a snap to compute the former complex expression in assembly. The code is shown here:</p>
<pre><code>mov  eax, a
add  eax, b
mov  temp1, eax
mov  eax, y
add  eax, z
mov  temp2, eax
mov  eax, temp1
imul eax, temp2
mov  w, eax</code></pre>
<p>This code is grossly inefficient and requires that you declare a couple of temporary variables in your data segment. However, it is easy to optimize this code by keeping temporary variables, as much as possible, in x86-64 registers. By using x86-64 registers to hold the temporary results, this code becomes the following:</p>
<pre><code>mov  eax, a
add  eax, b
<span epub:type="pagebreak" title="307" id="Page_307"/>mov  ebx, y
add  ebx, z
imul eax, ebx
mov  w, eax</code></pre>
<p>Here’s yet another example:</p>
<pre><code>x = (y + z) * (a - b) / 10;</code></pre>
<p>This can be converted to a set of four simple expressions:</p>
<pre><code>temp1 = (y + z)
temp2 = (a - b)
temp1 = temp1 * temp2
x = temp1 / 10</code></pre>
<p>You can convert these four simple expressions into the following assembly language statements:</p>
<pre><code>          .const
ten       dword   10
           .
           .
           .
          mov   eax, y        ; Compute EAX = y + z
          add   eax, z
          mov   ebx, a        ; Compute EBX = a - b
          sub   ebx, b
          imul  ebx           ; This sign-extends EAX into EDX
          idiv  ten
          mov x, eax</code></pre>
<p>The most important thing to keep in mind is that you should keep temporary values in registers for efficiency. Use memory locations to hold temporaries only if you’ve run out of registers.</p>
<p>Ultimately, converting a complex expression to assembly language is very similar to solving the expression by hand, except instead of actually computing the result at each stage of the computation, you simply write the assembly code that computes the result.</p>
<h3 id="h2-501089c06-0010">6.2.4	Commutative Operators</h3>
<p class="BodyFirst">If <var>op</var> represents an operator, that operator is <em>commutative</em> if the following relationship is always true:</p>
<pre><code>(A <var>op</var> B) = (B <var>op</var> A)</code></pre>
<p>As you saw in the previous section, commutative operators are nice because the order of their operands is immaterial, and this lets you rearrange a computation, often making it easier or more efficient. Often, rearranging a computation allows you to use fewer temporary variables. Whenever you encounter a commutative operator in an expression, you <span epub:type="pagebreak" title="308" id="Page_308"/>should always check whether you can use a better sequence to improve the size or speed of your code.</p>
<p>Tables 6-8 and 6-9, respectively, list the commutative and noncommutative operators you typically find in high-level languages.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-8">Table 6-8</a>: Common Commutative Binary Operators</p></figcaption>
<table id="table-501089c06-0008" border="1">
<thead>
<tr>
<td><b>Pascal</b></td>
<td><b>C/C++</b></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>+</code></td>
<td><code>+</code></td>
<td>Addition</td>
</tr>
<tr>
<td><code>*</code></td>
<td><code>*</code></td>
<td>Multiplication</td>
</tr>
<tr>
<td><code>and</code></td>
<td><code>&amp;&amp;</code> or <code>&amp;</code></td>
<td>Logical or bitwise AND</td>
</tr>
<tr>
<td><code>or</code></td>
<td><code>||</code> or <code>|</code></td>
<td>Logical or bitwise OR</td>
</tr>
<tr>
<td><code>xor</code></td>
<td><code>^</code></td>
<td>(Logical or) bitwise exclusive-OR</td>
</tr>
<tr>
<td><code>=</code></td>
<td><code>==</code></td>
<td>Equality</td>
</tr>
<tr>
<td><code>&lt;&gt;</code></td>
<td><code>!=</code></td>
<td>Inequality</td>
</tr>
</tbody>
</table>
</figure>
<figure>
<figcaption class="TableTitle"><p><a id="table6-9">Table 6-9</a>: Common Noncommutative Binary Operators</p></figcaption>
<table id="table-501089c06-0009" border="1">
<thead>
<tr>
<td><b>Pascal</b></td>
<td><b>C/C++</b></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>-</code></td>
<td><code>-</code></td>
<td>Subtraction</td>
</tr>
<tr>
<td><code>/</code> or <code>div</code></td>
<td><code>/</code></td>
<td>Division</td>
</tr>
<tr>
<td><code>mod</code></td>
<td><code>%</code></td>
<td>Modulo or remainder</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td><code>&lt;</code></td>
<td>Less than</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td><code>&lt;=</code></td>
<td>Less than or equal</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td><code>&gt;</code></td>
<td>Greater than</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td><code>&gt;=</code></td>
<td>Greater than or equal</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="h1-501089c06-0003">	6.3	Logical (Boolean) Expressions</h2>
<p class="BodyFirst">Consider the following expression from a C/C++ program:</p>
<pre><code>b = ((x == y) &amp;&amp; (a &lt;= c)) || ((z - a) != 5);</code></pre>
<p>Here, <code>b</code> is a Boolean variable, and the remaining variables are all integers.</p>
<p>Although it takes only a single bit to represent a Boolean value, most assembly language programmers allocate a whole byte or word to represent Boolean variables. Most programmers (and, indeed, some programming languages like C) choose 0 to represent false and anything else to represent true. Some people prefer to represent true and false with 1 and 0 (respectively) and not allow any other values. Others select all 1 bits (0FFFF_FFFF_FFFF_FFFFh, 0FFFF_FFFFh, 0FFFFh, or 0FFh) for true and 0 for false. You could also use a positive value for true and a negative value for false. All these mechanisms have their advantages and drawbacks.</p>
<p><span epub:type="pagebreak" title="309" id="Page_309"/>Using only 0 and 1 to represent false and true offers two big advantages. First, the <code>set</code><var>cc</var> instructions produce these results, so this scheme is compatible with those instructions. Second, the x86-64 logical instructions (<code>and</code>, <code>or</code>, <code>xor</code>, and, to a lesser extent, <code>not</code>) operate on these values exactly as you would expect. That is, if you have two Boolean variables <code>a</code> and <code>b</code>, then the following instructions perform the basic logical operations on these two variables:</p>
<pre><code>; d = a AND b:

     mov al, a
     and al, b
     mov d, al

; d = a || b:

     mov al, a
     or al, b
     mov d, al

; d = a XOR b:

     mov al, a
     xor al, b
     mov d, al

; b = NOT a:

     mov al, a     ; Note that the NOT instruction does not
     not al        ; properly compute AL = NOT all by itself.
     and al, 1     ; That is, (NOT 0) does not equal 1. The AND
     mov b, al     ; instruction corrects this problem

     mov al, a     ; Another way to do b = NOT a;
     xor al, 1     ; Inverts bit 0
     mov b, al</code></pre>
<p>As pointed out here, the <code>not</code> instruction will not properly compute logical negation. The bitwise <code>not</code> of 0 is 0FFh, and the bitwise <code>not</code> of 1 is 0FEh. Neither result is 0 or 1. However, by ANDing the result with 1, you get the proper result. Note that you can implement the <code>not</code> operation more efficiently by using the <code>xor al, 1</code> instruction because it affects only the LO bit.</p>
<p>As it turns out, using 0 for false and anything else for true has a lot of subtle advantages. Specifically, the test for true or false is often implicit in the execution of any logical instruction. However, this mechanism suffers from a big disadvantage: you cannot use the x86-64 <code>and</code>, <code>or</code>, <code>xor</code>, and <code>not</code> instructions to implement the Boolean operations of the same name. Consider the two values 55h and 0AAh. They’re both nonzero, so they both represent the value true. However, if you logically AND 55h and 0AAh together by using the x86-64 <code>and</code> instruction, the result is 0. True AND true should produce true, not false. Although you can account for situations like this, it usually requires a few extra instructions and is somewhat less efficient when computing Boolean operations.</p>
<p><span epub:type="pagebreak" title="310" id="Page_310"/>A system that uses nonzero values to represent true and 0 to represent false is an <em>arithmetic logical system</em>. A system that uses two distinct values like 0 and 1 to represent false and true is called a <em>Boolean logical system</em>, or simply a Boolean system. You can use either system, as convenient. Consider again this Boolean expression:</p>
<pre><code>b = ((x == y) and (a &lt;= d)) || ((z - a) != 5);</code></pre>
<p>The resulting simple expressions might be as follows:</p>
<pre><code>mov   eax, x
cmp   eax, y
sete  al       ; AL = x == y;

mov   ebx, a
cmp   ebx, d
setle bl       ; BL = a &lt;= d;
and   bl, al   ; BL = (x = y) and (a &lt;= d);

mov   eax, z
sub   eax, a
cmp   eax, 5
setne al
or    al, bl   ; AL = ((x == y) &amp;&amp; (a &lt;= d)) ||
mov   b, al    ;      ((z - a) != 5);</code></pre>
<p>When working with Boolean expressions, don’t forget that you might be able to optimize your code by simplifying them with algebraic transformations. In <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>, you’ll also see how to use control flow to calculate a Boolean result, which is generally quite a bit more efficient than using <em>complete Boolean evaluation</em>, as the examples in this section teach.</p>
<h2 id="h1-501089c06-0004">	6.4	Machine and Arithmetic Idioms</h2>
<p class="BodyFirst">An <em>idiom</em> is an idiosyncrasy (a peculiarity). Several arithmetic operations and x86-64 instructions have idiosyncrasies that you can take advantage of when writing assembly language code. Some people refer to the use of machine and arithmetic idioms as <em>tricky programming</em> that you should always avoid in well-written programs. While it is wise to avoid tricks just for the sake of tricks, many machine and arithmetic idioms are well known and commonly found in assembly language programs. You will see some important idioms all the time, so it makes sense to discuss them.</p>
<h3 id="h2-501089c06-0011">6.4.1	Multiplying Without mul or imul</h3>
<p class="BodyFirst">When multiplying by a constant, you can sometimes write faster code by using shifts, additions, and subtractions in place of multiplication instructions.</p>
<p>Remember, a <code>shl</code> instruction computes the same result as multiplying the specified operand by 2. Shifting to the left two bit positions multiplies the operand by 4. Shifting to the left three bit positions multiplies the operand <span epub:type="pagebreak" title="311" id="Page_311"/>by 8. In general, shifting an operand to the left <em>n</em> bits multiplies it by 2<sup><em>n</em></sup>. You can multiply any value by a constant by using a series of shifts and additions or shifts and subtractions. For example, to multiply the AX register by 10, you need only multiply it by 8 and then add two times the original value. That is, 10 × AX = 8 × AX + 2 × AX. The code to accomplish this is as follows:</p>
<pre><code>shl ax, 1          ; Multiply AX by 2
mov bx, ax         ; Save 2 * AX for later
shl ax, 2          ; Multiply AX by 8 (*4 really,
                   ; but AX contains *2)
add ax, bx         ; Add in AX * 2 to AX * 8 to get AX * 10</code></pre>
<p>If you look at the instruction timings, the preceding shift-and-add example requires fewer clock cycles on some processors in the 80x86 family than the <code>mul</code> instruction. Of course, the code is somewhat larger (by a few bytes), but the performance improvement is usually worth it.</p>
<p>You can also use subtraction with shifts to perform a multiplication operation. Consider the following multiplication by 7:</p>
<pre><code>mov ebx, eax       ; Save EAX * 1
shl eax, 3         ; EAX = EAX * 8
sub eax, ebx       ; EAX * 8 - EAX * 1 is EAX * 7</code></pre>
<p>A common error that beginning assembly language programmers make is subtracting or adding 1 or 2 rather than EAX × 1 or EAX × 2. The following does not compute EAX × 7:</p>
<pre><code>shl eax, 3
sub eax, 1</code></pre>
<p>It computes (8 × EAX) – 1, something entirely different (unless, of course, EAX = 1). Beware of this pitfall when using shifts, additions, and subtractions to perform multiplication operations.</p>
<p>You can also use the <code>lea</code> instruction to compute certain products. The trick is to use the scaled-index addressing modes. The following examples demonstrate some simple cases:</p>
<pre><code>lea eax, [ecx][ecx]          ; EAX = ECX * 2
lea eax, [eax][eax * 2]      ; EAX = ECX * 3
lea eax, [eax * 4]           ; EAX = ECX * 4
lea eax, [ebx][ebx * 4]      ; EAX = EBX * 5
lea eax, [eax * 8]           ; EAX = EAX * 8
lea eax, [edx][edx * 8]      ; EAX = EDX * 9</code></pre>
<p>As time has progressed, Intel (and AMD) has improved the performance of the <code>imul</code> instruction to the point that it rarely makes sense to try to improve performance by using <em>strength-reduction optimizations</em> such as substituting shifts and additions for a multiplication. You should consult the Intel and AMD documentation (particularly the section on instruction timing) to see if a multi-instruction sequence is faster. Generally, a single shift <span epub:type="pagebreak" title="312" id="Page_312"/>instruction (for multiplication by a power of 2) or <code>lea</code> is going to produce better results than <code>imul</code>; beyond that, it’s best to measure and see.</p>
<h3 id="h2-501089c06-0012">6.4.2	Dividing Without div or idiv</h3>
<p class="BodyFirst">Just as the <code>shl</code> instruction is useful for simulating a multiplication by a power of 2, the <code>shr</code> and <code>sar</code> instructions can simulate a division by a power of two. Unfortunately, you cannot easily use shifts, additions, and subtractions to perform division by an arbitrary constant. Therefore, this trick is useful only when dividing by powers of 2. Also, don’t forget that the <code>sar</code> instruction rounds toward negative infinity, unlike the <code>idiv</code> instruction, which rounds toward 0.</p>
<p>You can also divide by a value by multiplying by its reciprocal. Because the <code>mul</code> instruction is faster than the <code>div</code> instruction, multiplying by a reciprocal is usually faster than division.</p>
<p>To multiply by a reciprocal when dealing with integers, we must cheat. If you want to multiply by 1/10, there is no way you can load the value 1/10 into an x86-64 integer register prior to performing the multiplication. However, we could multiply 1/10 by 10, perform the multiplication, and then divide the result by 10 to get the final result. Of course, this wouldn’t buy you anything; in fact, it would make things worse because you’re now doing a multiplication by 10 as well as a division by 10. However, suppose you multiply 1/10 by 65,536 (6554), perform the multiplication, and then divide by 65,536. This would still perform the correct operation, and, as it turns out, if you set up the problem correctly, you can get the division operation for free. Consider the following code that divides AX by 10:</p>
<pre><code>mov dx, 6554          ; 6554 = round(65,536 / 10)
mul dx</code></pre>
<p>This code leaves AX/10 in the DX register.</p>
<p>To understand how this works, consider what happens when you use the <code>mul</code> instruction to multiply AX by 65,536 (1_0000h). This moves AX into DX and sets AX to 0 (a multiplication by 1_0000h is equivalent to a shift left by 16 bits). Multiplying by 6554 (65,536 divided by 10) puts AX divided by 10 into the DX register. Because <code>mul</code> is faster than <code>div</code>, this technique runs a little faster than using division.</p>
<p>Multiplying by a reciprocal works well when you need to divide by a constant. You could even use this approach to divide by a variable, but the overhead to compute the reciprocal pays off only if you perform the division many, many times by the same value.</p>
<h3 id="h2-501089c06-0013">6.4.3	Implementing Modulo-N Counters with AND</h3>
<p class="BodyFirst">If you want to implement a counter variable that counts up to 2<sup><em>n</em></sup><em> </em>– 1 and then resets to 0, use the following code:</p>
<pre><code>inc CounterVar
and CounterVar, <var>n_bits</var></code></pre>
<p class="BodyContinued"><span epub:type="pagebreak" title="313" id="Page_313"/>where <var>n_bits</var> is a binary value containing <em>n</em> bits of 1s right-justified in the number. For example, to create a counter that cycles between 0 and 15 (2<sup>4</sup> – 1), you could use the following:</p>
<pre><code>inc CounterVar
and CounterVar, 00001111b</code></pre>
<h2 id="h1-501089c06-0005">	6.5	Floating-Point Arithmetic</h2>
<p class="BodyFirst">Integer arithmetic does not let you represent fractional numeric values. Therefore, modern CPUs support an approximation of <em>real</em> arithmetic: <em>floating-point arithmetic</em>. To represent real numbers, most floating-point formats employ scientific notation and use a certain number of bits to represent a mantissa and a smaller number of bits to represent an exponent.</p>
<p>For example, in the number 3.456e+12, the mantissa consists of 3.456, and the exponent digits are 12. Because the number of bits is fixed in computer-based representations, computers can represent only a certain number of digits (known as <em>significant digits</em>) in the mantissa. For example, if a floating-point representation could handle only three significant digits, then the fourth digit in 3.456e+12 (the 6) could not be accurately represented with that format, as three significant digits can represent only 3.45e+12 correctly.</p>
<p>Because computer-based floating-point representations also use a finite number of bits to represent the exponent, it also has a limited range of values, ranging from 10<sup>±38</sup> for the single-precision format to 10<sup>±308</sup> for the double-precision format (and up to 10<sup>±4932</sup> for the extended-precision format). This is known as the <em>dynamic range</em> of the value.</p>
<p>A big problem with floating-point arithmetic is that it does not follow the standard rules of algebra. Normal algebraic rules apply only to <em>infinite-precision</em> arithmetic.</p>
<p>Consider the simple statement <em>x </em>= <em>x</em> + 1, where <em>x</em> is an integer. On any modern computer, this statement follows the normal rules of algebra <em>as long as overflow does not occur.</em> That is, this statement is valid only for certain values of <em>x</em> (<em>minint</em> ≤ <em>x</em> &lt; <em>maxint</em>). Most programmers do not have a problem with this because they are well aware that integers in a program do not follow the standard algebraic rules (for example, 5 / 2 does not equal 2.5).</p>
<p>Integers do not follow the standard rules of algebra because the computer represents them with a finite number of bits. You cannot represent any of the (integer) values above the maximum integer or below the minimum integer. Floating-point values suffer from this same problem, only worse. After all, integers are a subset of real numbers. Therefore, the floating-point values must represent the same infinite set of integers. However, an infinite number of real values exists between any two integer values. In addition to having to limit your values between a maximum and minimum range, you cannot represent all the values between any pair of integers, either.</p>
<p>To demonstrate the impact of limited-precision arithmetic, we will adopt a simplified decimal floating-point format for our examples. Our <span epub:type="pagebreak" title="314" id="Page_314"/>floating-point format will provide a mantissa with three significant digits and a decimal exponent with two digits. The mantissa and exponents are both signed values, as shown in <a href="#figure6-1" id="figureanchor6-1">Figure 6-1</a>.</p>
<figure>
<img src="image_fi/501089c06/f06001.png" alt="f06001" class=""/>
<figcaption><p><a id="figure6-1">Figure 6-1</a>:  A floating-point format</p></figcaption>
</figure>
<p>When adding and subtracting two numbers in scientific notation, we must adjust the two values so that their exponents are the same. Multiplication and division don’t require the exponents to be the same; instead, the exponent after a multiplication is the sum of the two operand exponents, and the exponent after a division is the difference of the dividend and divisor’s exponents.</p>
<p>For example, when adding 1.2e1 and 4.5e0, we must adjust the values so they have the same exponent. One way to do this is to convert 4.5e0 to 0.45e1 and then add. This produces 1.65e1. Because the computation and result require only three significant digits, we can compute the correct result via the representation shown in <a href="#figure6-1">Figure 6-1</a>. However, suppose we want to add the two values 1.23e1 and 4.56e0. Although both values can be represented using the three-significant-digit format, the computation and result do not fit into three significant digits. That is, 1.23e1 + 0.456e1 requires four digits of precision in order to compute the correct result of 1.686, so we must either <em>round</em> or <em>truncate</em> the result to three significant digits. Rounding generally produces the most accurate result, so let’s round the result to obtain 1.69e1.</p>
<p>In fact, the rounding does not occur after adding the two values together (that is, producing the sum 1.686e1 and then rounding this to 1.69e1). The rounding actually occurs when converting 4.56e0 to 0.456e1, because the value 0.456e1 requires four digits of precision to maintain. Therefore, during the conversion, we have to round it to 0.46e1 so that the result fits into three significant digits. Then, the sum of 1.23e1 and 0.46e1 produces the final (rounded) sum of 1.69e1.</p>
<p>As you can see, the lack of <em>precision</em> (the number of digits or bits we maintain in a computation) affects the <em>accuracy</em> (the correctness of the computation).</p>
<p>In the addition/subtraction example, we were able to round the result because we maintained <em>four</em> significant digits <em>during </em>the calculation (specifically, when converting 4.56e0 to 0.456e1). If our floating-point calculation had been limited to three significant digits during computation, we would have had to truncate the last digit of the smaller number, obtaining 0.45e1, resulting in a sum of 1.68e1, a value that is even less accurate.</p>
<p>To improve the accuracy of floating-point calculations, it is useful to maintain one or more extra digits for use during the calculation (such as the extra digit used to convert 4.56e0 to 0.456e1). Extra digits available during a computation are known as <em>guard digits</em><em> </em>(or <em>guard bits</em> in the case of a binary format). They greatly enhance accuracy during a long chain of computations.</p>
<p><span epub:type="pagebreak" title="315" id="Page_315"/>In a sequence of floating-point operations, the error can <em>accumulate </em>and greatly affect the computation itself. For example, suppose we were to add 1.23e3 to 1.00e0. Adjusting the numbers so their exponents are the same before the addition produces 1.23e3 + 0.001e3. The sum of these two values, even after rounding, is 1.23e3. This might seem perfectly reasonable to you; after all, we can maintain only three significant digits, so adding in a small value shouldn’t affect the result at all. However, suppose we were to add 1.00e0 to 1.23e3 <em>10 times</em>.<sup class="FootnoteReference"><a id="c06-footnoteref-5" href="#c06-footnote-5">5</a></sup> The first time we add 1.00e0 to 1.23e3, we get 1.23e3. Likewise, we get this same result the second, third, fourth . . . and tenth times when we add 1.00e0 to 1.23e3. On the other hand, had we added 1.00e0 to itself 10 times, then added the result (1.00e1) to 1.23e3, we would have gotten a different result, 1.24e3. This is an important fact to know about limited-precision arithmetic:</p>
<blockquote class="review">
<p class="Blockquote">The order of evaluation can affect the accuracy of the result.</p></blockquote>
<p>You will get more accurate results if the relative magnitudes (the exponents) are close to one another when adding and subtracting floating-point values. If you are performing a chain calculation involving addition and subtraction, you should attempt to group the values appropriately.</p>
<p>Another problem with addition and subtraction is that you can wind up with <em>false </em><em>precision</em>. Consider the computation 1.23e0 – 1.22e0, which produces 0.01e0. Although the result is mathematically equivalent to 1.00e – 2, this latter form suggests that the last two digits are exactly 0. Unfortunately, we have only a single significant digit at this time (remember, the original result was 0.01e0, and those two leading 0s were significant digits). Indeed, some floating-point unit (FPU) or software packages might actually insert random digits (or bits) into the LO positions. This brings up a second important rule concerning limited-precision arithmetic:</p>
<blockquote class="review">
<p class="Blockquote">Subtracting two numbers with the same signs (or adding two numbers with different signs) can produce high-order significant digits (bits) that are 0. This reduces the number of significant digits (bits) by a like amount in the final result.</p></blockquote>
<p>By themselves, multiplication and division do not produce particularly poor results. However, they tend to multiply any error that already exists in a value. For example, if you multiply 1.23e0 by 2, when you should be multiplying 1.24e0 by 2, the result is even less accurate. This brings up a third important rule when working with limited-precision arithmetic:</p>
<blockquote class="review">
<p class="Blockquote">When performing a chain of calculations involving addition, subtraction, multiplication, and division, try to perform the multiplication and division operations first.</p></blockquote>
<p>Often, by applying normal algebraic transformations, you can arrange a calculation so the multiply and divide operations occur first. For example, suppose you want to compute <code>x * (y + z)</code>. Normally, you would add <code>y</code> and <code/><span epub:type="pagebreak" title="316" id="Page_316"/>z together and multiply their sum by <code>x</code>. However, you will get a little more accuracy if you transform <code>x * (y + z)</code> to get <code>x * y + x * z</code> and compute the result by performing the multiplications first.<sup class="FootnoteReference"><a id="c06-footnoteref-6" href="#c06-footnote-6">6</a></sup></p>
<p>Multiplication and division are not without their own problems. When two very large or very small numbers are multiplied, it is quite possible for <em>overflow </em>or <em>underflow </em>to occur. The same situation occurs when dividing a small number by a large number, or dividing a large number by a small (fractional) number. This brings up a fourth rule you should attempt to follow when multiplying or dividing values:</p>
<blockquote class="review">
<p class="Blockquote">When multiplying and dividing sets of numbers, try to arrange the multiplications so that they multiply large and small numbers together; likewise, try to divide numbers that have the same relative magnitudes.</p></blockquote>
<p>Given the inaccuracies present in any computation (including converting an input string to a floating-point value), you should <em>never</em> compare two floating-point values to see if they are equal. In a binary floating-point format, different computations that produce the same (mathematical) result may differ in their least significant bits. For example, 1.31e0 + 1.69e0 should produce 3.00e0. Likewise, 1.50e0 + 1.50e0 should produce 3.00e0. However, if you were to compare (1.31e0 + 1.69e0) against (1.50e0 + 1.50e0), you might find out that these sums are <em>not </em>equal to one another. The test for equality succeeds if and only if all bits (or digits) in the two operands are exactly the same. Because this is not necessarily true after two different floating-point computations that should produce the same result, a straight test for equality may not work. Instead, you should use the following test:</p>
<pre><code>if <var>Value1</var> &gt;= (<var>Value2</var> - <var>error</var>) and <var>Value1</var> &lt;= (<var>Value2</var> + <var>error</var>) then ...</code></pre>
<p>Another common way to handle this same comparison is to use a statement of this form:</p>
<pre><code>if abs(<var>Value1</var> - <var>Value2</var>) &lt;= <var>error</var> then ...</code></pre>
<p><var>error</var> should be a value slightly greater than the largest amount of error that will creep into your computations. The exact value will depend on the particular floating-point format you use. Here is the final rule we will state in this section:</p>
<blockquote class="review">
<p class="Blockquote">When comparing two floating-point numbers, always compare one value to see if it is in the range given by the second value plus or minus a small error value.</p></blockquote>
<p>Many other little problems can occur when using floating-point values. This book can point out only some of the major problems and make you aware that you cannot treat floating-point arithmetic like real arithmetic <span epub:type="pagebreak" title="317" id="Page_317"/>because of the inaccuracies present in limited-precision arithmetic. A good text on numerical analysis or even scientific computing can help fill in the details. If you are going to be working with floating-point arithmetic <em>in any language</em>, you should take the time to study the effects of limited-precision arithmetic on your computations.</p>
<h3 id="h2-501089c06-0014">6.5.1	Floating-Point on the x86-64</h3>
<p class="BodyFirst">When the 8086 CPU first appeared in the late 1970s, semiconductor technology was not to the point where Intel could put floating-point instructions directly on the 8086 CPU. Therefore, Intel devised a scheme to use a second chip to perform the floating-point calculations—the <em>8087</em> <em>floating-point unit (or x87 </em><em>FPU)</em>.<sup class="FootnoteReference"><a id="c06-footnoteref-7" href="#c06-footnote-7">7</a></sup> By the release of the Intel Pentium chip, semiconductor technology had advanced to the point that the FPU was fully integrated onto the x86 CPU. Today, the x86-64 still contains the x87 FPU device, but it has also expanded the floating-point capabilities by using the SSE, SSE2, AVX, and AVX2 instruction sets.</p>
<p>This section describes the x86 FPU instruction set. Later sections (and chapters) discuss the more advanced floating-point capabilities of the SSE through AVX2 instruction sets.</p>
<h3 id="h2-501089c06-0015">6.5.2	FPU Registers</h3>
<p class="BodyFirst">The x87 FPUs add 14 registers to the x86-64: eight floating-point data registers, a control register, a status register, a tag register, an instruction pointer, a data pointer, and an opcode register. The <em>data registers</em> are similar to the x86-64’s general-purpose register set insofar as all floating-point calculations take place in these registers. The <em>control register</em> contains bits that let you decide how the FPU handles certain degenerate cases like rounding of inaccurate computations; it also contains bits that control precision and so on. The <em>status register</em> is similar to the x86-64’s FLAGS register; it contains the condition code bits and several other floating-point flags that describe the state of the FPU. The <em>tag register</em> contains several groups of bits that determine the state of the value in each of the eight floating-point data registers. The <em>instruction</em>, <em>data pointer</em>, and <em>opcode</em> registers contain certain state information about the last floating-point instruction executed. We do not consider the last four registers here; see the Intel documentation for more details.</p>
<h4 id="h3-501089c06-0001">6.5.2.1	FPU Data Registers</h4>
<p class="BodyFirst">The FPUs provide eight 80-bit data registers organized as a stack, a significant departure from the organization of the general-purpose registers on the x86-64 CPU. MASM refers to these registers as ST(0), ST(1), . . . ST(7).<sup class="FootnoteReference"><a id="c06-footnoteref-8" href="#c06-footnote-8">8</a></sup></p>
<p><span epub:type="pagebreak" title="318" id="Page_318"/>The biggest difference between the FPU register set and the x86-64 register set is the stack organization. On the x86-64 CPU, the AX register is always the AX register, no matter what happens. On the FPU, however, the register set is an eight-element stack of 80-bit floating-point values (<a href="#figure6-2" id="figureanchor6-2">Figure 6-2</a>).</p>
<figure>
<img src="image_fi/501089c06/f06002.png" alt="f06002" class=""/>
<figcaption><p><a id="figure6-2">Figure 6-2</a>: FPU floating-point register stack</p></figcaption>
</figure>
<p>ST(0) refers to the item on the top of stack, ST(1) refers to the next item on the stack, and so on. Many floating-point instructions push and pop items on the stack; therefore, ST(1) will refer to the previous contents of ST(0) after you push something onto the stack. Getting used to the register numbers changing will take some thought and practice, but this is an easy problem to overcome.</p>
<h4 id="h3-501089c06-0002">6.5.2.2	The FPU Control Register</h4>
<p class="BodyFirst">When Intel designed the 8087 (and, essentially, the IEEE floating-point standard), there were no standards in floating-point hardware. Different (mainframe and mini) computer manufacturers all had different and incompatible floating-point formats. Unfortunately, several applications had been written taking into account the idiosyncrasies of these different floating-point formats.</p>
<p>Intel wanted to design an FPU that could work with the majority of the software out there (keep in mind that the IBM PC was three to four years away when Intel began designing the 8087, so Intel couldn’t rely on that “mountain” of software available for the PC to make its chip popular). Unfortunately, many of the features found in these older floating-point formats were mutually incompatible. For example, in some floating-point systems, rounding would occur when there was insufficient precision; in others, truncation would occur. Some applications would work with one floating-point system but not with the other.</p>
<p>Intel wanted as many applications as possible to work with as few changes as possible on its 8087 FPUs, so it added a special register, the <em>FPU control register</em>, that lets the user choose one of several possible operating modes for the FPU. The 80x87 control register contains 16 bits organized as shown in <a href="#figure6-3" id="figureanchor6-3">Figure 6-3</a>.</p>
<span epub:type="pagebreak" title="319" id="Page_319"/><figure>
<img src="image_fi/501089c06/f06003.png" alt="f06003" class=""/>
<figcaption><p><a id="figure6-3">Figure 6-3</a>: FPU control register</p></figcaption>
</figure>
<p>Bits 10 and 11 of the FPU control register provide rounding control according to the values in <a href="#table6-10" id="tableanchor6-10">Table 6-10</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-10">Table 6-10</a>: Rounding Control</p></figcaption>
<table id="table-501089c06-0010" border="1">
<thead>
<tr>
<td><b>Bits 10 and 11</b></td>
<td><b>Function</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>To nearest or even</td>
</tr>
<tr>
<td>01</td>
<td>Round down</td>
</tr>
<tr>
<td>10</td>
<td>Round up</td>
</tr>
<tr>
<td>11</td>
<td>Truncate</td>
</tr>
</tbody>
</table>
</figure>
<p>The 00 setting is the default. The FPU rounds up values above one-half of the least significant bit. It rounds down values below one-half of the least significant bit. If the value below the least significant bit is exactly one-half of the least significant bit, the FPU rounds the value toward the value whose least significant bit is 0. For long strings of computations, this provides a reasonable, automatic way to maintain maximum precision.</p>
<p>The round-up and round-down options are present for those computations requiring accuracy. By setting the rounding control to round down and performing the operation, then repeating the operation with the rounding control set to round up, you can determine the minimum and maximum ranges between which the true result will fall.</p>
<p>The truncate option forces all computations to truncate any excess bits. You will rarely use this option if accuracy is important. However, you might use this option to help when porting older software to the FPU. This option is also extremely useful when converting a floating-point value to an integer. Because most software expects floating-point–to–integer conversions to <span epub:type="pagebreak" title="320" id="Page_320"/>truncate the result, you will need to use the truncation/rounding mode to achieve this.</p>
<p>Bits 8 and 9 of the control register specify the precision during computation. This capability is provided to allow compatibility with older software as required by the IEEE 754 standard. The precision-control bits use the values in <a href="#table6-11" id="tableanchor6-11">Table 6-11</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-11">Table 6-11</a>: Mantissa Precision-Control Bits</p></figcaption>
<table id="table-501089c06-0011" border="1">
<thead>
<tr>
<td><b>Bits 8 and 9</b></td>
<td><b>Precision control</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>24 bits</td>
</tr>
<tr>
<td>01</td>
<td>Reserved</td>
</tr>
<tr>
<td>10</td>
<td>53 bits</td>
</tr>
<tr>
<td>11</td>
<td>64 bits</td>
</tr>
</tbody>
</table>
</figure>
<p>Some CPUs may operate faster with floating-point values whose precision is 53 bits (that is, 64-bit floating-point format) rather than 64 bits (that is, 80-bit floating-point format). See the documentation for your specific processor for details. Generally, the CPU defaults these bits to 11 to select the 64-bit mantissa precision.</p>
<p>Bits 0 to 5 are the <em>exception masks</em>. These are similar to the interrupt enable bit in the x86-64’s FLAGS register. If these bits contain a 1, the corresponding condition is ignored by the FPU. However, if any bit contains 0s, and the corresponding condition occurs, then the FPU immediately generates an interrupt so the program can handle the degenerate condition.</p>
<p>Bit 0 corresponds to an invalid operation error, which generally occurs as the result of a programming error. Situations that raise the invalid operation exception include pushing more than eight items onto the stack or attempting to pop an item off an empty stack, taking the square root of a negative number, or loading a non-empty register.</p>
<p>Bit 1 masks the <em>denormalized </em>interrupt that occurs whenever you try to manipulate denormalized values. Denormalized exceptions occur when you load arbitrary extended-precision values into the FPU or work with very small numbers just beyond the range of the FPU’s capabilities. Normally, you would probably <em>not </em>enable this exception. If you enable this exception and the FPU generates this interrupt, the Windows runtime system raises an<em> </em>exception.</p>
<p>Bit 2 masks the <em>zero-divide </em>exception. If this bit contains 0, the FPU will generate an interrupt if you attempt to divide a nonzero value by 0. If you do not enable the zero-divide exception, the FPU will produce NaN whenever you perform a zero division. It’s probably a good idea to enable this exception by programming a 0 into this bit. Note that if your program generates this interrupt, the Windows runtime system will raise an exception.</p>
<p>Bit 3 masks the <em>overflow</em> exception. The FPU will raise the overflow exception if a calculation overflows or if you attempt to store a value that is too large to fit into the destination operand (for example, storing a large <span epub:type="pagebreak" title="321" id="Page_321"/>extended-precision value into a single-precision variable). If you enable this exception and the FPU generates this interrupt, the Windows runtime system raises an<em> </em>exception.</p>
<p>Bit 4, if set, masks the <em>underflow </em>exception. Underflow occurs when the result is too small to fit in the destination operand. Like overflow, this exception can occur whenever you store a small extended-precision value into a smaller variable (single or double precision) or when the result of a computation is too small for extended precision. If you enable this exception and the FPU generates this interrupt, the Windows runtime system raises an exception.</p>
<p>Bit 5 controls whether the <em>precision </em>exception can occur. A precision exception occurs whenever the FPU produces an imprecise result, generally the result of an internal rounding operation. Although many operations will produce an exact result, many more will not. For example, dividing 1 by 10 will produce an inexact result. Therefore, this bit is usually 1 because inexact results are common. If you enable this exception and the FPU generates this interrupt, the Windows runtime system raises an<em> </em>exception.</p>
<p>Bits 6 and 7, and 12 to 15, in the control register are currently undefined and reserved for future use (bits 7 and 12 were valid on older FPUs but are no longer used).</p>
<p>The FPU provides two instructions, <code>fldcw</code> (<em>load control word</em>) and <code>fstcw</code> (<em>store control word</em>), that let you load and store the contents of the control register, respectively. The single operand to these instructions must be a 16-bit memory location. The <code>fldcw</code> instruction loads the control register from the specified memory location. <code>fstcw</code> stores the control register into the specified memory location. The syntax for these instructions is shown here:</p>
<pre><code>fldcw <var>mem</var><sub>16</sub>
fstcw <var>mem</var><sub>16</sub></code></pre>
<p>Here’s some example code that sets the rounding control to <em>truncate result</em> and sets the rounding precision to 24 bits:</p>
<pre><code>       .data
fcw16  word   ?
          .
          .
          .
       fstcw fcw16
       mov   ax, fcw16
       and   ax, 0f0ffh ; Clears bits 8-11
       or    ax, 0c00h  ; Rounding control = %11, Precision = %00
       mov   fcw16, ax
       fldcw fcw16</code></pre>
<h4 id="h3-501089c06-0003">6.5.2.3	The FPU Status Register</h4>
<p class="BodyFirst">The 16-bit FPU status register provides the status of the FPU at the instant you read it; its layout appears in <a href="#figure6-4" id="figureanchor6-4">Figure 6-4</a>. The <code>fstsw</code> instruction stores the 16-bit floating-point status register into a word variable.</p>
<span epub:type="pagebreak" title="322" id="Page_322"/><figure>
<img src="image_fi/501089c06/f06004.png" alt="f06004" class=""/>
<figcaption><p><a id="figure6-4">Figure 6-4</a>: The FPU status register</p></figcaption>
</figure>
<p>Bits 0 through 5 are the exception flags. These bits appear in the same order as the exception masks in the control register. If the corresponding condition exists, the bit is set. These bits are independent of the exception masks in the control register. The FPU sets and clears these bits regardless of the corresponding mask setting.</p>
<p>Bit 6 indicates a <em>stack fault</em>. A stack fault occurs whenever a stack overflow or underflow occurs. When this bit is set, the C<sub>1</sub> condition code bit determines whether there was a stack overflow (C<sub>1</sub> = 1) or stack underflow (C<sub>1</sub> = 0) condition.</p>
<p>Bit 7 of the status register is set if <em>any </em>error condition bit is set. It is the logical <code>or</code> of bits 0 through 5. A program can test this bit to quickly determine if an error condition exists.</p>
<p>Bits 8, 9, 10, and 14 are the coprocessor condition code bits. Various instructions set the condition code bits, as shown in Tables 6-12 and 6-13, respectively.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-12">Table 6-12</a>: FPU Comparison Condition Code Bits (X = “Don’t care”)</p></figcaption>
<table id="table-501089c06-0012" border="1">
<thead>
<tr>
<td><b>Instruction</b></td>
<td colspan="4"><b>Condition code bits</b></td>
<td><b>Condition</b></td>
</tr>
<tr>
<td/>
<td><b>C<sub>3</sub></b></td>
<td><b>C<sub>2</sub></b></td>
<td><b>C<sub>1</sub></b></td>
<td><b>C<sub>0</sub></b></td>
<td/>
</tr>
</thead>
<tbody>
<tr>
<td><code>fcom</code><br/>
<code>fcomp</code><br/>
<code>fcompp</code><br/>
<code>ficom</code><br/>
<code>ficomp</code></td>
<td>0<br/>
0<br/>
1<br/>
1</td>
<td>0<br/>
0<br/>
0<br/>
1</td>
<td>X<br/>
X<br/>
X<br/>
X</td>
<td>0<br/>
1<br/>
0<br/>
1</td>
<td>ST <code>&gt;</code> source<br/>
ST <code>&lt;</code> source<br/>
ST <code>=</code> source<br/>
ST or source not comparable</td>
</tr>
<tr>
<td><code>ftst</code></td>
<td>0<br/>
0<br/>
1<br/>
1</td>
<td>0<br/>
0<br/>
0<br/>
1</td>
<td>X<br/>
X<br/>
X<br/>
X</td>
<td>0<br/>
1<br/>
0<br/>
1</td>
<td>ST is positive<br/>
ST is negative<br/>
ST is 0 (+ or –)<br/>
ST is not comparable</td>
</tr>
<tr>
<td><code><span epub:type="pagebreak" title="323" id="Page_323"/>fxam</code></td>
<td>0<br/>
0<br/>
0<br/>
0<br/>
1<br/>
1<br/>
1<br/>
1<br/>
0<br/>
0<br/>
0<br/>
0<br/>
1</td>
<td>0<br/>
0<br/>
1<br/>
1<br/>
0<br/>
0<br/>
1<br/>
1<br/>
0<br/>
0<br/>
1<br/>
1<br/>
0</td>
<td>0<br/>
1<br/>
0<br/>
1<br/>
0<br/>
1<br/>
0<br/>
1<br/>
0<br/>
1<br/>
0<br/>
1<br/>
X</td>
<td>0<br/>
0<br/>
0<br/>
0<br/>
0<br/>
0<br/>
0<br/>
0<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1</td>
<td>Unsupported<br/>
Unsupported<br/>
+ Normalized<br/>
– Normalized<br/>
+ 0<br/>
– 0<br/>
+ Denormalized<br/>
– Denormalized<br/>
+ NaN<br/>
– NaN<br/>
+ Infinity<br/>
– Infinity<br/>
Empty register</td>
</tr>
<tr>
<td><code>fucom</code><br/>
<code>fucomp</code><br/>
<code>fucompp</code></td>
<td>0<br/>
0<br/>
1<br/>
1</td>
<td>0<br/>
0<br/>
0<br/>
1</td>
<td>X<br/>
X<br/>
X<br/>
X</td>
<td>0<br/>
1<br/>
0<br/>
1</td>
<td>ST <code>&gt;</code> source<br/>
ST <code>&lt;</code> source<br/>
ST <code>=</code> source<br/>
Unordered/not comparable</td>
</tr>
</tbody>
</table>
</figure>
<figure>
<figcaption class="TableTitle"><p><a id="table6-13">Table 6-13</a>: FPU Condition Code Bits (X = “Don’t care”)</p></figcaption>
<table id="table-501089c06-0013" border="1">
<thead>
<tr>
<td><b>Instruction</b></td>
<td colspan="4"><b>Condition code bits</b></td>
</tr>
<tr>
<td/>
<td><b>C<sub>3</sub></b></td>
<td><b>C<sub>2</sub></b></td>
<td><b>C<sub>1</sub></b></td>
<td><b>C<sub>0</sub></b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>fcom</code>, <code>fcomp</code>, <code>fcompp</code>, <code>ftst</code>, <code>fucom</code>, <code>fucomp</code>, <code>fucompp</code>, <code>ficom</code>, <code>ficomp</code><br/>
</td>
<td>Result of comparison, see <a href="#table6-12" id="tableanchor6-12">Table 6-12</a>.</td>
<td>Operands are not comparable.</td>
<td>Set to 0.</td>
<td>Result of comparison, see <a href="#table6-12">Table 6-12</a>.</td>
</tr>
<tr>
<td><code>fxam</code></td>
<td>See <a href="#table6-12">Table 6-12</a>.</td>
<td>See <a href="#table6-12">Table 6-12</a>.</td>
<td>Sign of result, or stack overflow/underflow if stack exception bit is set.</td>
<td>See <a href="#table6-12">Table 6-12</a>.</td>
</tr>
<tr>
<td><code>fprem, fprem1</code></td>
<td>Bit 0 of quotient</td>
<td>0—reduction done<br/>
1—reduction incomplete</td>
<td>Bit 0 of quotient, or stack overflow/underflow if stack exception bit is set.</td>
<td>Bit 2 of quotient</td>
</tr>
<tr>
<td><code>fist</code>, <code>fbstp</code>, <code>frndint</code>, <code>fst</code>, <code>fstp</code>, <code>fadd</code>, <code>fmul</code>, <code>fdiv</code>, <code>fdivr</code>, <code>fsub</code>, <code>fsubr, fscale</code>, <code>fsqrt</code>, <code>fpatan</code>, <code>f2xm1</code>, <code>fyl2x</code>, <code>fyl2xp1</code><br/>
</td>
<td>Undefined</td>
<td>Undefined</td>
<td>Rounding direction if exception; otherwise, set to 0.</td>
<td>Undefined</td>
</tr>
<tr>
<td><code>fptan</code>, <code>fsin</code>, <code>fcos</code>, <code>fsincos</code><br/>
</td>
<td>Undefined</td>
<td>Set to 1 if within range; otherwise, 0.</td>
<td>Round-up occurred or stack overflow/underflow if stack exception bit is set. Undefined if C<sub>2</sub> is set.</td>
<td>Undefined</td>
</tr>
<tr>
<td><code><span epub:type="pagebreak" title="324" id="Page_324"/>fchs</code>, <code>fabs</code>, <code>fxch</code>, <code>fincstp</code>, <code>fdecstp</code>, <code>const loads</code>, <code>fxtract</code>, <code>fld</code>, <code>fild</code>,<code> fbld</code>, <code>fstp (80 bit)</code></td>
<td>Undefined</td>
<td>Undefined</td>
<td>Set to 0 or stack overflow/underflow if stack exception bit is set.</td>
<td>Undefined</td>
</tr>
<tr>
<td><code>fldenv</code>, <code>frstor</code></td>
<td>Restored from memory operand</td>
<td>Restored from memory operand</td>
<td>Restored from memory operand</td>
<td>Restored from memory operand</td>
</tr>
<tr>
<td><code>fldcw</code>, <code>fstenv</code>,<code> fstcw</code>, <code>fstsw</code>, <code>fclex</code></td>
<td>Undefined</td>
<td>Undefined</td>
<td>Undefined</td>
<td>Undefined</td>
</tr>
<tr>
<td><code>finit</code>, <code>fsave</code></td>
<td>Cleared to 0</td>
<td>Cleared to 0</td>
<td>Cleared to 0</td>
<td>Cleared to 0</td>
</tr>
</tbody>
</table>
</figure>
<p>Bits 11 to 13 of the FPU status register provide the register number of the top of stack. During computations, the FPU adds (modulo 8) the logical register numbers supplied by the programmer to these 3 bits to determine the <em>physical </em>register number at runtime.</p>
<p>Bit 15 of the status register is the <em>busy bit</em>. It is set whenever the FPU is busy. This bit is a historical artifact from the days when the FPU was a separate chip; most programs will have little reason to access this bit.</p>
<h3 id="h2-501089c06-0016">6.5.3	FPU Data Types</h3>
<p class="BodyFirst">The FPU supports seven data types: three integer types, a packed decimal type, and three floating-point types. The <em>integer type</em> supports 16-, 32-, and 64-bit integers, although it is often faster to do the integer arithmetic by using the integer unit of the CPU. The <em>packed decimal type</em> provides an 18-digit signed decimal (BCD) integer. The primary purpose of the BCD format is to convert between strings and floating-point values. The remaining three data types are the 32-, 64-, and 80-bit <em>floating-point data types</em>. The 80x87 data types appear in Figures 6-5, 6-6, and 6-7. Just note, for future reference, that the largest BCD value the x87 supports is an 18-digit BCD value (bits 72 to 78 are unused in this format).</p>
<figure>
<img src="image_fi/501089c06/f06005.png" alt="f06005" class=""/>
<figcaption><p><a id="figure6-5">Figure 6-5</a>: FPU floating-point formats</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="325" id="Page_325"/>The FPU generally stores values in a <em>normalized</em> format. The HO bit of the mantissa is always 1 when a floating-point number is normalized. In the 32- and 64-bit floating-point formats, the FPU does not actually store this bit; the FPU always assumes that it is 1. Therefore, 32- and 64-bit floating-point numbers are always normalized. In the extended-precision 80-bit floating-point format, the FPU does <em>not</em> assume that the HO bit of the mantissa is 1; the HO bit of the mantissa appears as part of the string of bits.</p>
<figure>
<img src="image_fi/501089c06/f06006.png" alt="f06006" class=""/>
<figcaption><p><a id="figure6-6">Figure 6-6</a>: FPU integer formats</p></figcaption>
</figure>
<p>Normalized values provide the greatest precision for a given number of bits. However, many non-normalized values <em>cannot</em> be represented with the 80-bit format. These values are very close to 0 and represent the set of values whose mantissa HO bit is not 0. The FPUs support a special 80-bit form known as <em>denormalized</em> values. Denormalized values allow the FPU to encode very small values it cannot encode using normalized values, but denormalized values offer fewer bits of precision than normalized values. Therefore, using denormalized values in a computation may introduce slight inaccuracy. Of course, this is always better than underflowing the denormalized value to 0 (which could make the computation even less accurate), but you must keep in mind that if you work with very small values, you may lose some accuracy in your computations. The FPU status register contains a bit you can use to detect when the FPU uses a denormalized value in a computation.</p>
<figure>
<img src="image_fi/501089c06/f06007.png" alt="f06007" class=""/>
<figcaption><p><a id="figure6-7">Figure 6-7</a>: FPU packed decimal format</p></figcaption>
</figure>
<h3 id="h2-501089c06-0017">6.5.4	The FPU Instruction Set</h3>
<p class="BodyFirst">The FPU adds many instructions to the x86-64 instruction set. We can classify these instructions as data movement instructions, conversions, arithmetic instructions, comparisons, constant instructions, transcendental instructions, and miscellaneous instructions. The following sections describe each of the instructions in these categories.</p>
<h3 id="h2-501089c06-0018"><span epub:type="pagebreak" title="326" id="Page_326"/>6.5.5	FPU Data Movement Instructions</h3>
<p class="BodyFirst">The <em>data movement instructions</em> transfer data between the internal FPU registers and memory. The instructions in this category are <code>fld</code>, <code>fst</code>, <code>fstp</code>, and <code>fxch</code>. The <code>fld</code> instruction always pushes its operand onto the floating-point stack. The <code>fstp</code> instruction always pops the top of stack after storing it. The remaining instructions do not affect the number of items on the stack.</p>
<h4 id="h3-501089c06-0004">6.5.5.1	The fld Instruction</h4>
<p class="BodyFirst">The <code>fld</code> instruction loads a 32-, 64-, or 80-bit floating-point value onto the stack. This instruction converts 32- and 64-bit operands to an 80-bit extended-precision value before pushing the value onto the floating-point stack.</p>
<p>The <code>fld</code> instruction first decrements the TOS pointer (bits 11 to 13 of the status register) and then stores the 80-bit value in the physical register specified by the new TOS pointer. If the source operand of the <code>fld</code> instruction is a floating-point data register, <code>st(</code><var>i</var><code>)</code>, then the actual register that the FPU uses for the load operation is the register number <em>before </em>decrementing the TOS pointer. Therefore, <code>fld st(0)</code> duplicates the value on the top of stack.</p>
<p>The <code>fld</code> instruction sets the stack fault bit if stack overflow occurs. It sets the denormalized exception bit if you load an 80-bit denormalized value. It sets the invalid operation bit if you attempt to load an empty floating-point register onto the TOS (or perform another invalid operation).</p>
<p>Here are some examples:</p>
<pre><code>fld st(1)
fld real4_variable
fld real8_variable
fld real10_variable
fld real8 ptr [rbx]</code></pre>
<p>There is no way to directly load a 32-bit integer register onto the floating-point stack, even if that register contains a <code>real4</code> value. To do so, you must first store the integer register into a memory location, and then push that memory location onto the FPU stack by using the <code>fld</code> instruction. For example:</p>
<pre><code>mov tempReal4, eax  ; Save real4 value in EAX to memory
fld tempReal4       ; Push that value onto the FPU stack</code></pre>
<h4 id="h3-501089c06-0005">6.5.5.2	The fst and fstp Instructions</h4>
<p class="BodyFirst">The <code>fst</code> and <code>fstp</code> instructions copy the value on the top of the floating-point stack to another floating-point register or to a 32-, 64-, or (<code>fstp</code> only) 80-bit memory variable. When copying data to a 32- or 64-bit memory variable, the FPU rounds the 80-bit extended-precision value on the TOS to the smaller format as specified by the rounding control bits in the FPU control register.</p>
<p>By incrementing the TOS pointer in the status register after accessing the data in ST(0), the <code>fstp</code> instruction pops the value off the top of stack <span epub:type="pagebreak" title="327" id="Page_327"/>when moving it to the destination location. If the destination operand is a floating-point register, the FPU stores the value at the specified register number <em>before</em> popping the data off the top of stack.</p>
<p>Executing an <code>fstp st(0)</code> instruction effectively pops the data off the top of stack with no data transfer. Here are some examples:</p>
<pre><code>fst real4_variable
fst real8_variable
fst realArray[rbx * 8]
fst st(2)
fstp st(1)</code></pre>
<p>The last example effectively pops ST(1) while leaving ST(0) on the top of stack.</p>
<p>The <code>fst</code> and <code>fstp</code> instructions will set the stack exception bit if a stack underflow occurs (attempting to store a value from an empty register stack). They will set the precision bit if a loss of precision occurs during the store operation (for example, when storing an 80-bit extended-precision value into a 32- or 64-bit memory variable and some bits are lost during conversion). They will set the underflow exception bit when storing an 80-bit value into a 32- or 64-bit memory variable, but the value is too small to fit into the destination operand. Likewise, these instructions will set the overflow exception bit if the value on the top of stack is too big to fit into a 32- or 64-bit memory variable. They set the invalid operation flag if an invalid operation (such as storing into an empty register) occurs. Finally, these instructions set the C<sub>1</sub> condition bit if rounding occurs during the store operation (this occurs only when storing into a 32- or 64-bit memory variable and you have to round the mantissa to fit into the destination) or if a stack fault occurs.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Because of an idiosyncrasy in the FPU instruction set related to the encoding of the instructions, you cannot use the <code>fst</code> instruction to store data into a <code>real10</code> memory variable. You may, however, store 80-bit data by using the <code>fstp</code> instruction.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-501089c06-0006">6.5.5.3	The fxch Instruction</h4>
<p class="BodyFirst">The <code>fxch</code> instruction exchanges the value on the top of stack with one of the other FPU registers. This instruction takes two forms: one with a single FPU register as an operand and the second without any operands. The first form exchanges the top of stack with the specified register. The second form of <code>fxch</code> swaps the top of stack with ST(1).</p>
<p>Many FPU instructions (for example, <code>fsqrt</code>) operate only on the top of the register stack. If you want to perform such an operation on a value that is not on top, you can use the <code>fxch</code> instruction to swap that register with TOS, perform the desired operation, and then use <code>fxch</code> to swap the TOS with the original register. The following example takes the square root of ST(2):</p>
<pre><code>fxch st(2)
fsqrt
fxch st(2)</code></pre>
<p><span epub:type="pagebreak" title="328" id="Page_328"/>The <code>fxch</code> instruction sets the stack exception bit if the stack is empty; it sets the invalid operation bit if you specify an empty register as the operand; and it always clears the C<sub>1</sub> condition code bit.</p>
<h3 id="h2-501089c06-0019">6.5.6	Conversions</h3>
<p class="BodyFirst">The FPU performs all arithmetic operations on 80-bit real quantities. In a sense, the <code>fld</code> and <code>fst</code>/<code>fstp</code> instructions are conversion instructions because they automatically convert between the internal 80-bit real format and the 32- and 64-bit memory formats. Nonetheless, we’ll classify them as data movement operations, rather than conversions, because they are moving real values to and from memory. The FPU provides six other instructions that convert to or from integer or BCD format when moving data. These instructions are <code>fild</code>, <code>fist</code>, <code>fistp</code>, <code>fisttp</code>, <code>fbld</code>, and <code>fbstp</code>.</p>
<h4 id="h3-501089c06-0007">6.5.6.1	The fild Instruction</h4>
<p class="BodyFirst">The <code>fild</code> (<em>integer load</em>) instruction converts a 16-, 32-, or 64-bit two’s complement integer to the 80-bit extended-precision format and pushes the result onto the stack. This instruction always expects a single operand: the address of a word, double-word, or quad-word integer variable. You cannot specify one of the x86-64’s 16-, 32-, or 64-bit general-purpose registers. If you want to push the value of an x86-64 general-purpose register onto the FPU stack, you must first store it into a memory variable and then use <code>fild</code> to push that memory variable.</p>
<p>The <code>fild</code> instruction sets the stack exception bit and C<sub>1</sub> (accordingly) if stack overflow occurs while pushing the converted value. Look at these examples:</p>
<pre><code>fild word_variable 
fild dword_val[rcx * 4]
fild qword_variable
fild sqword ptr [rbx]</code></pre>
<h4 id="h3-501089c06-0008">6.5.6.2	The fist, fistp, and fisttp Instructions</h4>
<p class="BodyFirst">The <code>fist</code>, <code>fistp</code>, and <code>fisttp</code> instructions convert the 80-bit extended-precision variable on the top of stack to a 16-, 32-, or (<code>fistp</code>/<code>fistpp</code> only) 64-bit integer and store the result away into the memory variable specified by the single operand. The <code>fist</code> and <code>fistp</code> instructions convert the value on TOS to an integer according to the rounding setting in the FPU control register (bits 10 and 11). The <code>fisttp</code> instruction always does the conversion using the truncation mode. As with the <code>fild</code> instruction, the <code>fist</code>, <code>fistp</code>, and <code>fisttp</code> instructions will not let you specify one of the x86-64’s general-purpose 16-, 32-, or 64-bit registers as the destination operand.</p>
<p>The <code>fist</code> instruction converts the value on the top of stack to an integer and then stores the result; it does not otherwise affect the floating-point register stack. The <code>fistp</code> and <code>fisttp</code> instructions pop the value off the floating-point register stack after storing the converted value.</p>
<p><span epub:type="pagebreak" title="329" id="Page_329"/>These instructions set the stack exception bit if the floating-point register stack is empty (this will also clear C<sub>1</sub>). They set the precision (imprecise operation) and C<sub>1</sub> bits if rounding occurs (that is, if the value in ST(0) has any fractional component). These instructions set the underflow exception bit if the result is too small (less than 1 but greater than 0, or less than 0 but greater than –1). Here are some examples:</p>
<pre><code>fist   word_var[rbx * 2]
fist   dword_var
fisttp dword_var
fistp  qword_var</code></pre>
<p>The <code>fist</code> and <code>fistp</code> instructions use the rounding control settings to determine how they will convert the floating-point data to an integer during the store operation. By default, the rounding control is usually set to round mode; yet, most programmers expect <code>fist</code>/<code>fistp</code> to truncate the decimal portion during conversion. If you want <code>fist</code>/<code>fistp</code> to truncate floating-point values when converting them to an integer, you will need to set the rounding control bits appropriately in the floating-point control register (or use the <code>fisttp</code> instruction to truncate the result regardless of the rounding control bits). Here’s an example:</p>
<pre><code>          .data
fcw16     word    ?
fcw16_2   word    ?
IntResult sdword  ?
          .
          .
          .
    fstcw fcw16
    mov   ax, fcw16
    or    ax, 0c00h     ; Rounding = %11 (truncate)
    mov   fcw16_2, ax   ; Store and reload the ctrl word
    fldcw fcw16_2

    fistp IntResult     ; Truncate ST(0) and store as int32

    fldcw fcw16         ; Restore original rounding control</code></pre>
<h4 id="h3-501089c06-0009">6.5.6.3	The fbld and fbstp Instructions</h4>
<p class="BodyFirst">The <code>fbld</code> and <code>fbstp</code> instructions load and store 80-bit BCD values. The <code>fbld</code> instruction converts a BCD value to its 80-bit extended-precision equivalent and pushes the result onto the stack. The <code>fbstp</code> instruction pops the extended-precision real value on TOS, converts it to an 80-bit BCD value (rounding according to the bits in the floating-point control register), and stores the converted result at the address specified by the destination memory operand. There is no <code>fbst</code> instruction.</p>
<p>The <code>fbld</code> instruction sets the stack exception bit and C<sub>1</sub> if stack overflow occurs. The results are undefined if you attempt to load an invalid BCD <span epub:type="pagebreak" title="330" id="Page_330"/>value. The <code>fbstp</code> instruction sets the stack exception bit and clears C<sub>1</sub> if stack underflow occurs (the stack is empty). It sets the underflow flag under the same conditions as <code>fist</code> and <code>fistp</code>. Look at these examples:</p>
<pre><code>; Assuming fewer than eight items on the stack, the following
; code sequence is equivalent to an fbst instruction:

          fld   st(0)
          fbstp tbyte_var

; The following example easily converts an 80-bit BCD value to
; a 64-bit integer:

          fbld  tbyte_var
          fistp qword_var</code></pre>
<p>These two instructions are especially useful for converting between string and floating-point formats. Along with the <code>fild</code> and <code>fist</code> instructions, you can use <code>fbld</code> and <code>fbstp</code> to convert between integer and string formats (see <span class="xref" itemid="xref_target_“Converting Unsigned Decimal Values to Strings” in Chapter 9">“Converting Unsigned Decimal Values to Strings” in Chapter 9</span>).</p>
<h3 id="h2-501089c06-0020">6.5.7	Arithmetic Instructions</h3>
<p class="BodyFirst"><em>Arithmetic instructions</em> make up a small but important subset of the FPU’s instruction set. These instructions fall into two general categories: those that operate on real values and those that operate on a real and an integer value.</p>
<h4 id="h3-501089c06-0010">6.5.7.1	The fadd, faddp, and fiadd Instructions</h4>
<p class="BodyFirst">The <code>fadd</code>, <code>faddp</code>, and <code>fiadd</code> instructions take the following forms:</p>
<pre><code>fadd
faddp
fadd   st(<var>i</var>), st(0)
fadd   st(0), st(<var>i</var>)
faddp  st(<var>i</var>), st(0)
fadd   <var>mem</var><sub>32</sub>
fadd   <var>mem</var><sub>64</sub>
fiadd  <var>mem</var><sub>16</sub>
fiadd  <var>mem</var><sub>32</sub></code></pre>
<p>The <code>fadd</code> instruction, with no operands, is a synonym for <code>faddp</code>. The <code>faddp</code> instruction (also with no operands) pops the two values on the top of stack, adds them, and pushes their sum back onto the stack.</p>
<p>The next two forms of the <code>fadd</code> instruction, those with two FPU register operands, behave like the x86-64’s <code>add</code> instruction. They add the value in the source register operand to the value in the destination register operand. One of the register operands must be ST(0).</p>
<p><span epub:type="pagebreak" title="331" id="Page_331"/>The <code>faddp</code> instruction with two operands adds ST(0) (which must always be the source operand) to the destination operand and then pops ST(0). The destination operand must be one of the other FPU registers.</p>
<p>The last two forms, <code>fadd</code> with a memory operand, adds a 32- or 64-bit floating-point variable to the value in ST(0). This instruction will convert the 32- or 64-bit operands to an 80-bit extended-precision value before performing the addition. Note that this instruction does <em>not </em>allow an 80-bit memory operand. There are also instructions for adding 16- and 32-bit integers in memory to ST(0): <code>fiadd </code><var>mem</var><span class="SubscriptLiteral">16</span> and <code>fiadd </code><var>mem</var><span class="SubscriptLiteral">32</span>.</p>
<p>These instructions can raise the stack, precision, underflow, overflow, denormalized, and illegal operation exceptions, as appropriate. If a stack fault exception occurs, C<sub>1</sub> denotes stack overflow or underflow, or the rounding direction (see <a href="#table6-13" id="tableanchor6-13">Table 6-13</a>).</p>
<p><a href="#listing6-1" id="listinganchor6-1">Listing 6-1</a> demonstrates the various forms of the <code>fadd</code> instruction.</p>
<pre><code>; Listing 6-1

; Demonstration of various forms of fadd.

        option  casemap:none

nl          =       10

            .const
ttlStr      byte    "Listing 6-1", 0
fmtSt0St1   byte    "st(0):%f, st(1):%f", nl, 0
fmtAdd1     byte    "fadd: st0:%f", nl, 0
fmtAdd2     byte    "faddp: st0:%f", nl, 0
fmtAdd3     byte    "fadd st(1), st(0): st0:%f, st1:%f", nl, 0
fmtAdd4     byte    "fadd st(0), st(1): st0:%f, st1:%f", nl, 0
fmtAdd5     byte    "faddp st(1), st(0): st0:%f", nl, 0
fmtAdd6     byte    "fadd mem: st0:%f", nl, 0

zero        real8   0.0
one         real8   1.0
two         real8   2.0
minusTwo    real8   -2.0

            .data
st0         real8   0.0
st1         real8   0.0

            .code
            externdef printf:proc

; Return program title to C++ program:

            public  getTitle
getTitle    proc
            lea     rax, ttlStr
            ret
getTitle    endp

<span epub:type="pagebreak" title="332" id="Page_332"/>; printFP - Prints values of st0 and (possibly) st1.
;           Caller must pass in ptr to fmtStr in RCX.

printFP     proc
            sub     rsp, 40

; For varargs (for example, printf call), double
; values must appear in RDX and R8 rather
; than XMM1, XMM2.
; Note: if only one double arg in format
; string, printf call will ignore 2nd
; value in R8.

            mov     rdx, qword ptr st0
            mov     r8, qword ptr st1
            call    printf
            add     rsp, 40
            ret
printFP     endp

; Here is the "asmMain" function.

            public  asmMain
asmMain     proc
            push    rbp
            mov     rbp, rsp
            sub     rsp, 48         ; Shadow storage
        
; Demonstrate various fadd instructions:

            mov     rax, qword ptr one
            mov     qword ptr st1, rax
            mov     rax, qword ptr minusTwo
            mov     qword ptr st0, rax
            lea     rcx, fmtSt0St1
            call    printFP

; fadd (same as faddp):
 
            fld     one
            fld     minusTwo
            fadd                    ; Pops st(0)!
            fstp    st0

            lea     rcx, fmtAdd1
            call    printFP
            
; faddp:
 
            fld     one
            fld     minusTwo
            faddp                   ; Pops st(0)!
            fstp    st0

<span epub:type="pagebreak" title="333" id="Page_333"/>            lea     rcx, fmtAdd2
            call    printFP

; fadd st(1), st(0):
 
            fld     one
            fld     minusTwo
            fadd    st(1), st(0)
            fstp    st0
            fstp    st1

            lea     rcx, fmtAdd3
            call    printFP

; fadd st(0), st(1):

            fld     one
            fld     minusTwo
            fadd    st(0), st(1)
            fstp    st0
            fstp    st1

            lea     rcx, fmtAdd4
            call    printFP

; faddp st(1), st(0):

            fld     one
            fld     minusTwo
            faddp   st(1), st(0)
            fstp    st0
            
            lea     rcx, fmtAdd5
            call    printFP

; faddp mem64:

            fld     one
            fadd    two
            fstp    st0

            lea     rcx, fmtAdd6
            call    printFP

            leave
            ret     ; Returns to caller

asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing6-1">Listing 6-1</a>: Demonstration of <code>fadd</code> instructions</p>
<p><span epub:type="pagebreak" title="334" id="Page_334"/>Here’s the build command and output for the program in <a href="#listing6-1">Listing 6-1</a>:</p>
<pre><code>C:\&gt;<b>build listing6-1</b>

C:\&gt;<b>echo off</b>
 Assembling: listing6-1.asm
c.cpp

C:\&gt;<b>listing6-1</b>
Calling Listing 6-1:
st(0):-2.000000, st(1):1.000000
fadd: st0:-1.000000
faddp: st0:-1.000000
fadd st(1), st(0): st0:-2.000000, st1:-1.000000
fadd st(0), st(1): st0:-1.000000, st1:1.000000
faddp st(1), st(0): st0:-1.000000
fadd mem: st0:3.000000
Listing 6-1 terminated</code></pre>
<h4 id="h3-501089c06-0011">6.5.7.2	The fsub, fsubp, fsubr, fsubrp, fisub, and fisubr Instructions</h4>
<p class="BodyFirst">These six instructions take the following forms:</p>
<pre><code>fsub
fsubp
fsubr
fsubrp

fsub   st(<var>i</var>), st(0)
fsub   st(0), st(<var>i</var>)
fsubp  st(<var>i</var>), st(0)
fsub   <var>mem</var><sub>32</sub>
fsub   <var>mem</var><sub>64</sub>

fsubr  st(<var>i</var>), st(0)
fsubr  st(0), st(<var>i</var>)
fsubrp st(<var>i</var>), st(0)
fsubr  <var>mem</var><sub>32</sub>
fsubr  <var>mem</var><sub>64</sub>

fisub  <var>mem</var><sub>16</sub>
fisub  <var>mem</var><sub>32</sub>
fisubr <var>mem</var><sub>16</sub>
fisubr <var>mem</var><sub>32</sub></code></pre>
<p>With no operands, <code>fsub</code> is the same as <code>fsubp</code> (without operands). With no operands, the <code>fsubp</code> instruction pops ST(0) and ST(1) from the register stack, computes ST(1) – ST(0), and then pushes the difference back onto the stack. The <code>fsubr</code> and <code>fsubrp</code> instructions (<em>reverse subtraction</em>) operate in an identical fashion except they compute ST(0) – ST(1).</p>
<p>With two register operands (<em>destination, source</em>), the <code>fsub</code> instruction computes <em>destination</em> = <em>destination</em> – <em>source</em>. One of the two registers must be <span epub:type="pagebreak" title="335" id="Page_335"/>ST(0). With two registers as operands, the <code>fsubp</code> also computes <em>destination</em> = <em>destination</em> – <em>source</em>,<em> </em>and then it pops ST(0) off the stack after computing the difference. For the <code>fsubp</code> instruction, the source operand must be ST(0).</p>
<p>With two register operands, the <code>fsubr</code> and <code>fsubrp</code> instructions work in a similar fashion to <code>fsub</code> and <code>fsubp</code>, except they compute <em>destination</em> = <em>source</em> – <em>destination</em>.</p>
<p>The <code>fsub </code><var>mem</var><sub>32</sub>, <code>fsub </code><var>mem</var><sub>64</sub>, <code>fsubr </code><var>mem</var><sub>32</sub>, and <code>fsubr </code><var>mem</var><sub>64</sub> instructions accept a 32- or 64-bit memory operand. They convert the memory operand to an 80-bit extended-precision value and subtract this from ST(0) (<code>fsub</code>) or subtract ST(0) from this value (<code>fsubr</code>) and store the result back into ST(0). There are also instructions for subtracting 16- and 32-bit integers in memory from ST(0): <code>fisub mem</code><sub>16</sub> and <code>fisub mem</code><sub>32</sub> (also <code>fisubr mem</code><sub>16</sub> and <code>fisubr mem</code><sub>32</sub>).</p>
<p>These instructions can raise the stack, precision, underflow, overflow, denormalized, and illegal operation exceptions, as appropriate. If a stack fault exception occurs, C<sub>1</sub> denotes stack overflow or underflow, or indicates the rounding direction (see <a href="#table6-13">Table 6-13</a>).</p>
<p><a href="#listing6-2" id="listinganchor6-2">Listing 6-2</a> demonstrates the <code>fsub</code>/<code>fsubr</code> instructions.</p>
<pre><code>; Listing 6-2

; Demonstration of various forms of fsub/fsubrl.

        option  casemap:none

nl          =       10

            .const
ttlStr      byte    "Listing 6-2", 0
fmtSt0St1   byte    "st(0):%f, st(1):%f", nl, 0
fmtSub1     byte    "fsub: st0:%f", nl, 0
fmtSub2     byte    "fsubp: st0:%f", nl, 0
fmtSub3     byte    "fsub st(1), st(0): st0:%f, st1:%f", nl, 0
fmtSub4     byte    "fsub st(0), st(1): st0:%f, st1:%f", nl, 0
fmtSub5     byte    "fsubp st(1), st(0): st0:%f", nl, 0
fmtSub6     byte    "fsub mem: st0:%f", nl, 0
fmtSub7     byte    "fsubr st(1), st(0): st0:%f, st1:%f", nl, 0
fmtSub8     byte    "fsubr st(0), st(1): st0:%f, st1:%f", nl, 0
fmtSub9     byte    "fsubrp st(1), st(0): st0:%f", nl, 0
fmtSub10    byte    "fsubr mem: st0:%f", nl, 0

zero        real8   0.0
three       real8   3.0
minusTwo    real8   -2.0

            .data
st0         real8   0.0
st1         real8   0.0

            .code
            externdef printf:proc

<span epub:type="pagebreak" title="336" id="Page_336"/>; Return program title to C++ program:

            public  getTitle
getTitle    proc
            lea     rax, ttlStr
            ret
getTitle    endp

; printFP - Prints values of st0 and (possibly) st1.
;           Caller must pass in ptr to fmtStr in RCX.

printFP     proc
            sub     rsp, 40

; For varargs (for example, printf call), double
; values must appear in RDX and R8 rather
; than XMM1, XMM2.
; Note: if only one double arg in format
; string, printf call will ignore 2nd
; value in R8.

            mov     rdx, qword ptr st0
            mov     r8, qword ptr st1
            call    printf
            add     rsp, 40
            ret
printFP     endp

; Here is the "asmMain" function.

            public  asmMain
asmMain     proc
            push    rbp
            mov     rbp, rsp
            sub     rsp, 48   ; Shadow storage

; Demonstrate various fsub instructions:

            mov     rax, qword ptr three
            mov     qword ptr st1, rax
            mov     rax, qword ptr minusTwo
            mov     qword ptr st0, rax
            lea     rcx, fmtSt0St1
            call    printFP

; fsub (same as fsubp):
 
            fld     three
            fld     minusTwo
            fsub                    ; Pops st(0)!
            fstp    st0

            lea     rcx, fmtSub1
            call    printFP

<span epub:type="pagebreak" title="337" id="Page_337"/>; fsubp:

            fld     three
            fld     minusTwo
            fsubp                   ; Pops st(0)!
            fstp    st0

            lea     rcx, fmtSub2
            call    printFP

; fsub st(1), st(0):

            fld     three
            fld     minusTwo
            fsub    st(1), st(0)
            fstp    st0
            fstp    st1

            lea     rcx, fmtSub3
            call    printFP

; fsub st(0), st(1):
 
            fld     three
            fld     minusTwo
            fsub    st(0), st(1)
            fstp    st0
            fstp    st1

            lea     rcx, fmtSub4
            call    printFP

; fsubp st(1), st(0):

            fld     three
            fld     minusTwo
            fsubp   st(1), st(0)
            fstp    st0

            lea     rcx, fmtSub5
            call    printFP

; fsub mem64:

            fld     three
            fsub    minusTwo
            fstp    st0

            lea     rcx, fmtSub6
            call    printFP

; fsubr st(1), st(0):

            fld     three
            fld     minusTwo
<span epub:type="pagebreak" title="338" id="Page_338"/>            fsubr   st(1), st(0)
            fstp    st0
            fstp    st1

            lea     rcx, fmtSub7
            call    printFP

; fsubr st(0), st(1):

            fld     three
            fld     minusTwo
            fsubr   st(0), st(1)
            fstp    st0
            fstp    st1

            lea     rcx, fmtSub8
            call    printFP 

; fsubrp st(1), st(0):

            fld     three
            fld     minusTwo
            fsubrp  st(1), st(0)
            fstp    st0

            lea     rcx, fmtSub9
            call    printFP 

; fsubr mem64:

            fld     three
            fsubr   minusTwo
            fstp    st0

            lea     rcx, fmtSub10
            call    printFP

            leave
            ret     ; Returns to caller

asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing6-2">Listing 6-2</a>: Demonstration of the <code>fsub</code> instructions</p>
<p>Here’s the build command and output for <a href="#listing6-2">Listing 6-2</a>:</p>
<pre><code>C:\&gt;<b>build listing6-2</b>

C:\&gt;<b>echo off</b>
 Assembling: listing6-2.asm
c.cpp

<span epub:type="pagebreak" title="339" id="Page_339"/>C:\&gt;<b>listing6-2</b>
Calling Listing 6-2:
st(0):-2.000000, st(1):3.000000
fsub: st0:5.000000
fsubp: st0:5.000000
fsub st(1), st(0): st0:-2.000000, st1:5.000000
fsub st(0), st(1): st0:-5.000000, st1:3.000000
fsubp st(1), st(0): st0:5.000000
fsub mem: st0:5.000000
fsubr st(1), st(0): st0:-2.000000, st1:-5.000000
fsubr st(0), st(1): st0:5.000000, st1:3.000000
fsubrp st(1), st(0): st0:-5.000000
fsubr mem: st0:-5.000000
Listing 6-2 terminated</code></pre>
<h4 id="h3-501089c06-0012">6.5.7.3	The fmul, fmulp, and fimul Instructions</h4>
<p class="BodyFirst">The <code>fmul</code> and <code>fmulp</code> instructions multiply two floating-point values. The <code>fimul</code> instruction multiples an integer and a floating-point value. These instructions allow the following forms:</p>
<pre><code>fmul
fmulp

fmul  st(0), st(<var>i</var>)
fmul  st(<var>i</var>), st(0)
fmul  <var>mem</var><sub>32</sub>
fmul  <var>mem</var><sub>64</sub>

fmulp st(<var>i</var>), st(0)

fimul <var>mem</var><sub>16</sub>
fimul <var>mem</var><sub>32</sub></code></pre>
<p>With no operands, <code>fmul</code> is a synonym for <code>fmulp</code>. The <code>fmulp</code> instruction, with no operands, will pop ST(0) and ST(1), multiply these values, and push their product back onto the stack. The <code>fmul</code> instructions with two register operands compute <em>destination</em> = <em>destination</em> × <em>source</em>. One of the registers (source or destination) must be ST(0).</p>
<p>The <code>fmulp st(0), st(</code><var>i</var><code>)</code> instruction computes ST(<em>i</em>) = ST(<em>i</em>) × ST(0) and then pops ST(0). This instruction uses the value for <em>i</em> before popping ST(0). The <code>fmul </code><var>mem</var><sub>32</sub> and <code>fmul </code><var>mem</var><sub>64</sub> instructions require a 32- or 64-bit memory operand, respectively. They convert the specified memory variable to an 80-bit extended-precision value and then multiply ST(0) by this value. There are also instructions for multiplying 16- and 32-bit integers in memory by ST(0): <code>fimul mem</code><sub>16</sub> and <code>fimul mem</code><sub>32</sub>.</p>
<p>These instructions can raise the stack, precision, underflow, overflow, denormalized, and illegal operation exceptions, as appropriate. If rounding occurs during the computation, these instructions set the C<sub>1</sub> condition code bit. If a stack fault exception occurs, C<sub>1</sub> denotes stack overflow or underflow.</p>
<p><span epub:type="pagebreak" title="340" id="Page_340"/><a href="#listing6-3" id="listinganchor6-3">Listing 6-3</a> demonstrates the various forms of the <code>fmul</code> instruction.</p>
<pre><code>; Listing 6-3

; Demonstration of various forms of fmul.

        option  casemap:none

nl          =       10

            .const
ttlStr      byte    "Listing 6-3", 0
fmtSt0St1   byte    "st(0):%f, st(1):%f", nl, 0
fmtMul1     byte    "fmul: st0:%f", nl, 0
fmtMul2     byte    "fmulp: st0:%f", nl, 0
fmtMul3     byte    "fmul st(1), st(0): st0:%f, st1:%f", nl, 0
fmtMul4     byte    "fmul st(0), st(1): st0:%f, st1:%f", nl, 0
fmtMul5     byte    "fmulp st(1), st(0): st0:%f", nl, 0
fmtMul6     byte    "fmul mem: st0:%f", nl, 0

zero        real8   0.0
three       real8   3.0
minusTwo    real8   -2.0

            .data
st0         real8   0.0
st1         real8   0.0

            .code
            externdef printf:proc

; Return program title to C++ program:

            public  getTitle
getTitle    proc
            lea     rax, ttlStr
            ret
getTitle    endp

; printFP - Prints values of st0 and (possibly) st1.
;           Caller must pass in ptr to fmtStr in RCX.

printFP     proc
            sub     rsp, 40

; For varargs (for example, printf call), double
; values must appear in RDX and R8 rather
; than XMM1, XMM2.
; Note: if only one double arg in format
; string, printf call will ignore 2nd
; value in R8.

            mov     rdx, qword ptr st0
            mov     r8, qword ptr st1
            call    printf
<span epub:type="pagebreak" title="341" id="Page_341"/>            add     rsp, 40
            ret
printFP     endp

; Here is the "asmMain" function.

            public  asmMain
asmMain     proc
            push    rbp
            mov     rbp, rsp
            sub     rsp, 48         ; Shadow storage

; Demonstrate various fmul instructions:

            mov     rax, qword ptr three
            mov     qword ptr st1, rax
            mov     rax, qword ptr minusTwo
            mov     qword ptr st0, rax
            lea     rcx, fmtSt0St1
            call    printFP

; fmul (same as fmulp):

            fld     three
            fld     minusTwo
            fmul                    ; Pops st(0)!
            fstp    st0

            lea     rcx, fmtMul1
            call    printFP

; fmulp:

            fld     three
            fld     minusTwo
            fmulp                   ; Pops st(0)!
            fstp    st0

            lea     rcx, fmtMul2
            call    printFP

; fmul st(1), st(0):

            fld     three
            fld     minusTwo
            fmul    st(1), st(0)
            fstp    st0
            fstp    st1

            lea     rcx, fmtMul3
            call    printFP

; fmul st(0), st(1):

            fld     three
<span epub:type="pagebreak" title="342" id="Page_342"/>            fld     minusTwo
            fmul    st(0), st(1)
            fstp    st0
            fstp    st1

            lea     rcx, fmtMul4
            call    printFP

; fmulp st(1), st(0):

            fld     three
            fld     minusTwo
            fmulp   st(1), st(0)
            fstp    st0

            lea     rcx, fmtMul5
            call    printFP

; fmulp mem64:

            fld     three
            fmul    minusTwo
            fstp    st0

            lea     rcx, fmtMul6
            call    printFP

            leave
            ret     ; Returns to caller

asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing6-3">Listing 6-3</a>: Demonstration of the <code>fmul</code> instruction</p>
<p>Here is the build command and output for <a href="#listing6-3">Listing 6-3</a>:</p>
<pre><code>C:\&gt;<b>build listing6-3</b>

C:\&gt;<b>echo off</b>
 Assembling: listing6-3.asm
c.cpp

C:\&gt;<b>listing6-3</b>
Calling Listing 6-3:
st(0):-2.000000, st(1):3.000000
fmul: st0:-6.000000
fmulp: st0:-6.000000
fmul st(1), st(0): st0:-2.000000, st1:-6.000000
fmul st(0), st(1): st0:-6.000000, st1:3.000000
fmulp st(1), st(0): st0:-6.000000
fmul mem: st0:-6.000000
Listing 6-3 terminated</code></pre>
<h4 id="h3-501089c06-0013"><span epub:type="pagebreak" title="343" id="Page_343"/>6.5.7.4	The fdiv, fdivp, fdivr, fdivrp, fidiv, and fidivr Instructions</h4>
<p class="BodyFirst">These six instructions allow the following forms:</p>
<pre><code>fdiv
fdivp
fdivr
fdivrp

fdiv   st(0), st(<var>i</var>)
fdiv   st(<var>i</var>), st(0)
fdivp  st(<var>i</var>), st(0)

fdivr  st(0), st(<var>i</var>)
fdivr  st(<var>i</var>), st(0)
fdivrp st(<var>i</var>), st(0)

fdiv   <var>mem</var><sub>32</sub>
fdiv   <var>mem</var><sub>64</sub>
fdivr  <var>mem</var><sub>32</sub>
fdivr  <var>mem</var><sub>64</sub>

fidiv  <var>mem</var><sub>16</sub>
fidiv  <var>mem</var><sub>32</sub>
fidivr <var>mem</var><sub>16</sub>
fidivr <var>mem</var><sub>32</sub></code></pre>
<p>With no operands, the <code>fdiv</code> instruction is a synonym for <code>fdivp</code>. The <code>fdivp</code> instruction with no operands computes ST(1) = ST(1) / ST(0). The <code>fdivr</code> and <code>fdivrp</code> instructions work in a similar fashion to <code>fdiv</code> and <code>fdivp</code> except that they compute ST(0) / ST(1) rather than ST(1) / ST(0).</p>
<p>With two register operands, these instructions compute the following quotients:</p>
<pre><code>fdiv   st(0), st(<var>i</var>)    ; st(0) = st(0)/st(<var>i</var>)
fdiv   st(<var>i</var>), st(0)    ; st(<var>i</var>) = st(<var>i</var>)/st(0)
fdivp  st(<var>i</var>), st(0)    ; st(<var>i</var>) = st(<var>i</var>)/st(0) then pop st0
fdivr  st(0), st(<var>i</var>)    ; st(0) = st(<var>i</var>)/st(0)
fdivr  st(<var>i</var>), st(0)    ; st(<var>i</var>) = st(0)/st(<var>i</var>)
fdivrp st(<var>i</var>), st(0)    ; st(<var>i</var>) = st(0)/st(<var>i</var>) then pop st0</code></pre>
<p>The <code>fdivp</code> and <code>fdivrp</code> instructions also pop ST(0) after performing the division operation. The value for <em>i</em> in these two instructions is computed before popping ST(0).</p>
<p>These instructions can raise the stack, precision, underflow, overflow, denormalized, zero divide, and illegal operation exceptions, as appropriate. If rounding occurs during the computation, these instructions set the C<sub>1</sub> condition code bit. If a stack fault exception occurs, C<sub>1</sub> denotes stack overflow or underflow.</p>
<p><span epub:type="pagebreak" title="344" id="Page_344"/><a href="#listing6-4" id="listinganchor6-4">Listing 6-4</a> provides a demonstration of the <code>fdiv</code>/<code>fdivr</code> instructions.</p>
<pre><code>; Listing 6-4

; Demonstration of various forms of fsub/fsubrl.

        option  casemap:none

nl          =       10

            .const
ttlStr      byte    "Listing 6-4", 0
fmtSt0St1   byte    "st(0):%f, st(1):%f", nl, 0
fmtDiv1     byte    "fdiv: st0:%f", nl, 0
fmtDiv2     byte    "fdivp: st0:%f", nl, 0
fmtDiv3     byte    "fdiv st(1), st(0): st0:%f, st1:%f", nl, 0
fmtDiv4     byte    "fdiv st(0), st(1): st0:%f, st1:%f", nl, 0
fmtDiv5     byte    "fdivp st(1), st(0): st0:%f", nl, 0
fmtDiv6     byte    "fdiv mem: st0:%f", nl, 0
fmtDiv7     byte    "fdivr st(1), st(0): st0:%f, st1:%f", nl, 0
fmtDiv8     byte    "fdivr st(0), st(1): st0:%f, st1:%f", nl, 0
fmtDiv9     byte    "fdivrp st(1), st(0): st0:%f", nl, 0
fmtDiv10    byte    "fdivr mem: st0:%f", nl, 0

three       real8   3.0
minusTwo    real8   -2.0

            .data
st0         real8   0.0
st1         real8   0.0

            .code
            externdef printf:proc

; Return program title to C++ program:

            public  getTitle
getTitle    proc
            lea     rax, ttlStr
            ret
getTitle    endp

; printFP - Prints values of st0 and (possibly) st1.
;           Caller must pass in ptr to fmtStr in RCX.

printFP     proc
            sub     rsp, 40

; For varargs (for example, printf call), double
; values must appear in RDX and R8 rather
; than XMM1, XMM2.
; Note: if only one double arg in format
; string, printf call will ignore 2nd
; value in R8.

<span epub:type="pagebreak" title="345" id="Page_345"/>            mov     rdx, qword ptr st0
            mov     r8, qword ptr st1
            call    printf
            add     rsp, 40
            ret
printFP     endp

; Here is the "asmMain" function.

            public  asmMain
asmMain     proc
            push    rbp
            mov     rbp, rsp
            sub     rsp, 48         ; Shadow storage

; Demonstrate various fdiv instructions:

            mov     rax, qword ptr three
            mov     qword ptr st1, rax
            mov     rax, qword ptr minusTwo
            mov     qword ptr st0, rax
            lea     rcx, fmtSt0St1
            call    printFP

; fdiv (same as fdivp):

            fld     three
            fld     minusTwo
            fdiv                    ; Pops st(0)!
            fstp    st0

            lea     rcx, fmtDiv1
            call    printFP

; fdivp:
 
            fld     three
            fld     minusTwo
            fdivp                   ; Pops st(0)!
            fstp    st0

            lea     rcx, fmtDiv2
            call    printFP

; fdiv st(1), st(0):

            fld     three
            fld     minusTwo
            fdiv    st(1), st(0)
            fstp    st0
            fstp    st1

            lea     rcx, fmtDiv3
            call    printFP

<span epub:type="pagebreak" title="346" id="Page_346"/>; fdiv st(0), st(1):

            fld     three
            fld     minusTwo
            fdiv    st(0), st(1)
            fstp    st0
            fstp    st1

            lea     rcx, fmtDiv4
            call    printFP 

; fdivp st(1), st(0):

            fld     three
            fld     minusTwo
            fdivp   st(1), st(0)
            fstp    st0

            lea     rcx, fmtDiv5
            call    printFP

; fdiv mem64:
 
            fld     three
            fdiv    minusTwo
            fstp    st0

            lea     rcx, fmtDiv6
            call    printFP

; fdivr st(1), st(0):

            fld     three
            fld     minusTwo
            fdivr   st(1), st(0)
            fstp    st0
            fstp    st1

            lea     rcx, fmtDiv7
            call    printFP

; fdivr st(0), st(1):

            fld     three
            fld     minusTwo
            fdivr   st(0), st(1)
            fstp    st0
            fstp    st1

            lea     rcx, fmtDiv8
            call    printFP

; fdivrp st(1), st(0):

            fld     three
<span epub:type="pagebreak" title="347" id="Page_347"/>            fld     minusTwo
            fdivrp  st(1), st(0)
            fstp    st0
            
            lea     rcx, fmtDiv9
            call    printFP 

; fdivr mem64:

            fld     three
            fdivr   minusTwo
            fstp    st0

            lea     rcx, fmtDiv10
            call    printFP

            leave
            ret     ; Returns to caller

asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing6-4">Listing 6-4</a>: Demonstration of the <code>fdiv</code>/<code>fdivr</code> instructions</p>
<p>Here’s the build command and sample output for <a href="#listing6-4">Listing 6-4</a>:</p>
<pre><code>C:\&gt;<b>build listing6-4</b>

C:\&gt;<b>echo off</b>
 Assembling: listing6-4.asm
c.cpp

C:\&gt;<b>listing6-4</b>
Calling Listing 6-4:
st(0):-2.000000, st(1):3.000000
fdiv: st0:-1.500000
fdivp: st0:-1.500000
fdiv st(1), st(0): st0:-2.000000, st1:-1.500000
fdiv st(0), st(1): st0:-0.666667, st1:3.000000
fdivp st(1), st(0): st0:-1.500000
fdiv mem: st0:-1.500000
fdivr st(1), st(0): st0:-2.000000, st1:-0.666667
fdivr st(0), st(1): st0:-1.500000, st1:3.000000
fdivrp st(1), st(0): st0:-0.666667
fdivr mem: st0:-0.666667
Listing 6-4 terminated</code></pre>
<h4 id="h3-501089c06-0014">6.5.7.5	The fsqrt Instruction  </h4>
<p class="BodyFirst">The <code>fsqrt</code> routine does not allow any operands. It computes the square root of the value on TOS and replaces ST(0) with this result. The value on TOS must be 0 or positive; otherwise, <code>fsqrt</code> will generate an invalid operation exception.</p>
<p><span epub:type="pagebreak" title="348" id="Page_348"/>This instruction can raise the stack, precision, denormalized, and invalid operation exceptions, as appropriate. If rounding occurs during the computation, <code>fsqrt</code> sets the C<sub>1</sub> condition code bit. If a stack fault exception occurs, C<sub>1</sub> denotes stack overflow or underflow.</p>
<p>Here’s an example:</p>
<pre><code>; Compute z = sqrt(x**2 + y**2):

          fld x                  ; Load x
          fld st(0)              ; Duplicate x on TOS
          fmulp                  ; Compute x**2

          fld y                  ; Load y
          fld st(0)              ; Duplicate y
          fmul                   ; Compute y**2

          faddp                  ; Compute x**2 + y**2
          fsqrt                  ; Compute sqrt(x**2 + y**2)
          fstp z                 ; Store result away into z</code></pre>
<h4 id="h3-501089c06-0015">6.5.7.6	The fprem and fprem1 Instructions </h4>
<p class="BodyFirst">The <code>fprem</code> and <code>fprem1</code> instructions compute a <em>partial remainder</em> (a value that may require additional computation to produce the actual remainder). Intel designed the <code>fprem</code> instruction before the IEEE finalized its floating-point standard. In the final draft of that standard, the definition of <code>fprem</code> was a little different from Intel’s original design. To maintain compatibility with the existing software that used the <code>fprem</code> instruction, Intel designed a new version to handle the IEEE partial remainder operation, <code>fprem1</code>. You should always use <code>fprem1</code> in new software; therefore, we will discuss only <code>fprem1</code> here, although you use <code>fprem</code> in an identical fashion.</p>
<p><code>fprem1</code> computes the partial remainder of ST(0) / ST(1). If the difference between the exponents of ST(0) and ST(1) is less than 64, <code>fprem1</code> can compute the exact remainder in one operation. Otherwise, you will have to execute <code>fprem1</code> two or more times to get the correct remainder value. The C<sub>2</sub> condition code bit determines when the computation is complete. Note that <code>fprem1</code> does <em>not</em> pop the two operands off the stack; it leaves the partial remainder in ST(0) and the original divisor in ST(1) in case you need to compute another partial product to complete the result.</p>
<p>The <code>fprem1</code> instruction sets the stack exception flag if there aren’t two values on the top of stack. It sets the underflow and denormal exception bits if the result is too small. It sets the invalid operation bit if the values on TOS are inappropriate for this operation. It sets the C<sub>2</sub> condition code bit if the partial remainder operation is not complete (or on stack underflow). Finally, it loads C<sub>1</sub>, C<sub>2</sub>, and C<sub>0</sub> with bits 0, 1, and 2 of the quotient, respectively.</p>
<p><span epub:type="pagebreak" title="349" id="Page_349"/>An example follows:</p>
<pre><code>; Compute z = x % y:

          fld y
          fld x
repeatLp:

          fprem1
          fstsw ax        ; Get condition code bits into AX
          and   ah, 1     ; See if C2 is set
          jnz   repeatLp  ; Repeat until C2 is clear
          fstp z          ; Store away the remainder
          fstp st(0)      ; Pop old y value</code></pre>
<h4 id="h3-501089c06-0016">6.5.7.7	The frndint Instruction</h4>
<p class="BodyFirst">The <code>frndint</code> instruction rounds the value on TOS to the nearest integer by using the rounding algorithm specified in the control register.</p>
<p>This instruction sets the stack exception flag if there is no value on the TOS (it will also clear C<sub>1</sub> in this case). It sets the precision and denormal exception bits if a loss of precision occurred. It sets the invalid operation flag if the value on the TOS is not a valid number. Note that the result on the TOS is still a floating-point value; it simply does not have a fractional component.</p>
<h4 id="h3-501089c06-0017">6.5.7.8	The fabs Instruction</h4>
<p class="BodyFirst"><code>fabs</code> computes the absolute value of ST(0) by clearing the mantissa sign bit of ST(0). It sets the stack exception bit and invalid operation bits if the stack is empty.</p>
<p>Here’s an example:</p>
<pre><code>; Compute x = sqrt(abs(x)):

          fld   x
          fabs
          fsqrt
          fstp  x</code></pre>
<h4 id="h3-501089c06-0018">6.5.7.9	The fchs Instruction </h4>
<p class="BodyFirst"><code>fchs</code> changes the sign of ST(0)’s value by inverting the mantissa sign bit (this is the floating-point negation instruction). It sets the stack exception bit and invalid operation bits if the stack is empty.</p>
<p>Look at this example:</p>
<pre><code>; Compute x = -x if x is positive, x = x if x is negative.
; That is, force x to be a negative value.

<span epub:type="pagebreak" title="350" id="Page_350"/>          fld  x
          fabs
          fchs
          fstp x</code></pre>
<h3 id="h2-501089c06-0021">6.5.8	Comparison Instructions</h3>
<p class="BodyFirst">The FPU provides several instructions for comparing real values. The <code>fcom</code>, <code>fcomp</code>, and <code>fcompp</code> instructions compare the two values on the top of stack and set the condition codes appropriately. The <code>ftst</code> instruction compares the value on the top of stack with 0.</p>
<p>Generally, most programs test the condition code bits immediately after a comparison. Unfortunately, no instructions test the FPU condition codes. Instead, you use the <code>fstsw</code> instruction to copy the floating-point status register into the AX register, then the <code>sahf</code> instruction to copy the AH register into the x86-64’s condition code bits. Then you can test the standard x86-64 flags to check for a condition. This technique copies C<sub>0</sub> into the carry flag, C<sub>2</sub> into the parity flag, and C<sub>3</sub> into the zero flag. The <code>sahf</code> instruction does not copy C<sub>1</sub> into any of the x86-64’s flag bits.</p>
<p>Because <code>sahf</code> does not copy any FPU status bits into the sign or overflow flags, you cannot use signed comparison instructions. Instead, use unsigned operations (for example, <code>seta</code>, <code>setb</code>, <code>ja</code>, <code>jb</code>) when testing the results of a floating-point comparison. Yes, these instructions normally test unsigned values, and <em>floating-point numbers are signed values</em>. However, use the unsigned operations anyway; the <code>fstsw</code> and <code>sahf</code> instructions set the x86-64 FLAGS register as though you had compared unsigned values with the <code>cmp</code> instruction.</p>
<p>The x86-64 processors provide an extra set of floating-point comparison instructions that directly affect the x86-64 condition code flags. These instructions circumvent having to use <code>fstsw</code> and <code>sahf</code> to copy the FPU status into the x86-64 condition codes. These instructions include <code>fcomi</code> and <code>fcomip</code>. You use them just like the <code>fcom</code> and <code>fcomp</code> instructions, except, of course, you do not have to manually copy the status bits to the FLAGS register.</p>
<h4 id="h3-501089c06-0019">6.5.8.1	The fcom, fcomp, and fcompp Instructions</h4>
<p class="BodyFirst">The <code>fcom</code>, <code>fcomp</code>, and <code>fcompp</code> instructions compare ST(0) to the specified operand and set the corresponding FPU condition code bits based on the result of the comparison. The legal forms for these instructions are as follows:</p>
<pre><code>fcom
fcomp
fcompp

fcom  st(<var>i</var>)
fcomp st(<var>i</var>)

fcom  <var>mem</var><sub>32</sub>
fcom  <var>mem</var><sub>64</sub>
fcomp <var>mem</var><sub>32</sub>
fcomp <var>mem</var><sub>64</sub></code></pre>
<p><span epub:type="pagebreak" title="351" id="Page_351"/>With no operands, <code>fcom</code>, <code>fcomp</code>, and <code>fcompp</code> compare ST(0) against ST(1) and set the FPU flags accordingly. In addition, <code>fcomp</code> pops ST(0) off the stack, and <code>fcompp</code> pops both ST(0) and ST(1) off the stack.</p>
<p>With a single-register operand, <code>fcom</code> and <code>fcomp</code> compare ST(0) against the specified register. <code>fcomp</code> also pops ST(0) after the comparison.</p>
<p>With a 32- or 64-bit memory operand, the <code>fcom</code> and <code>fcomp</code> instructions convert the memory variable to an 80-bit extended-precision value and then compare ST(0) against this value, setting the condition code bits accordingly. <code>fcomp</code> also pops ST(0) after the comparison.</p>
<p>These instructions set C<sub>2</sub> (which winds up in the parity flag when using <code>sahf</code>) if the two operands are not comparable (for example, NaN). If it is possible for an illegal floating-point value to wind up in a comparison, you should check the parity flag for an error before checking the desired condition (for example, with the <code>setp</code>/<code>setnp</code> or <code>jp</code>/<code>jnp</code> instructions).</p>
<p>These instructions set the stack fault bit if there aren’t two items on the top of the register stack. They set the denormalized exception bit if either or both operands are denormalized. They set the invalid operation flag if either or both operands are NaNs. These instructions always clear the C<sub>1</sub> condition code.</p>
<p>Let’s look at an example of a floating-point comparison:</p>
<pre><code>          fcompp
          fstsw ax
          sahf
          setb al    ; AL = true if st(0) &lt; st(1)
               .
               .
               .
          fcompp
          fstsw ax
          sahf
          jnb st1GEst0

   ; Code that executes if st(0) &lt; st(1).

st1GEst0:</code></pre>
<p>Because all x86-64 64-bit CPUs support the <code>fcomi</code> and <code>fcomip</code> instructions (described in the next section), you should consider using those instructions as they spare you from having to store the FPU status word into AX and then copy AH into the FLAGS register before testing the condition. On the other hand, <code>fcomi</code> and <code>fcomip</code> support only a limited number of operand forms (the <code>fcom</code> and <code>fcomp</code> instructions are more general).</p>
<p><a href="#listing6-5" id="listinganchor6-5">Listing 6-5</a> is a sample program that demonstrates the use of the various <code>fcom</code> instructions.</p>
<pre><code>; Listing 6-5

; Demonstration of fcom instructions.

        option  casemap:none

<span epub:type="pagebreak" title="352" id="Page_352"/>nl          =       10

            .const
ttlStr      byte    "Listing 6-5", 0
fcomFmt     byte    "fcom %f &lt; %f is %d", nl, 0
fcomFmt2    byte    "fcom(2) %f &lt; %f is %d", nl, 0
fcomFmt3    byte    "fcom st(1) %f &lt; %f is %d", nl, 0
fcomFmt4    byte    "fcom st(1) (2) %f &lt; %f is %d", nl, 0
fcomFmt5    byte    "fcom mem %f &lt; %f is %d", nl, 0
fcomFmt6    byte    "fcom mem %f (2) &lt; %f is %d", nl, 0
fcompFmt    byte    "fcomp %f &lt; %f is %d", nl, 0
fcompFmt2   byte    "fcomp (2) %f &lt; %f is %d", nl, 0
fcompFmt3   byte    "fcomp st(1) %f &lt; %f is %d", nl, 0
fcompFmt4   byte    "fcomp st(1) (2) %f &lt; %f is %d", nl, 0
fcompFmt5   byte    "fcomp mem %f &lt; %f is %d", nl, 0
fcompFmt6   byte    "fcomp mem (2) %f &lt; %f is %d", nl, 0
fcomppFmt   byte    "fcompp %f &lt; %f is %d", nl, 0
fcomppFmt2  byte    "fcompp (2) %f &lt; %f is %d", nl, 0

three       real8   3.0
zero        real8   0.0
minusTwo    real8   -2.0

            .data
st0         real8   ?
st1         real8   ?

            .code
            externdef printf:proc

; Return program title to C++ program:

            public  getTitle
getTitle    proc
            lea     rax, ttlStr
            ret
getTitle    endp

; printFP - Prints values of st0 and (possibly) st1.
;           Caller must pass in ptr to fmtStr in RCX.

printFP     proc
            sub     rsp, 40

; For varargs (for example, printf call), double
; values must appear in RDX and R8 rather
; than XMM1, XMM2.
; Note: if only one double arg in format
; string, printf call will ignore 2nd
; value in R8.

            mov     rdx, qword ptr st0
            mov     r8, qword ptr st1
            movzx   r9, al
<span epub:type="pagebreak" title="353" id="Page_353"/>            call    printf
            add     rsp, 40
            ret
printFP     endp

; Here is the "asmMain" function.

            public  asmMain
asmMain     proc
            push    rbp
            mov     rbp, rsp
            sub     rsp, 48   ; Shadow storage

; fcom demo:

            xor     eax, eax
            fld     three
            fld     zero
            fcom
            fstsw   ax
            sahf
            setb    al
            fstp    st0
            fstp    st1
            lea     rcx, fcomFmt
            call    printFP

; fcom demo 2:

            xor     eax, eax
            fld     zero
            fld     three
            fcom
            fstsw   ax
            sahf
            setb    al
            fstp    st0
            fstp    st1
            lea     rcx, fcomFmt2
            call    printFP

; fcom st(<var>i</var>) demo:

            xor     eax, eax
            fld     three
            fld     zero
            fcom    st(1)
            fstsw   ax
            sahf
            setb    al
            fstp    st0
            fstp    st1
            lea     rcx, fcomFmt3
            call    printFP

<span epub:type="pagebreak" title="354" id="Page_354"/>; fcom st(<var>i</var>) demo 2:

            xor     eax, eax
            fld     zero
            fld     three
            fcom    st(1)
            fstsw   ax
            sahf
            setb    al
            fstp    st0
            fstp    st1
            lea     rcx, fcomFmt4
            call    printFP

; fcom mem64 demo:

            xor     eax, eax
            fld     three           ; Never on stack so
            fstp    st1             ; copy for output
            fld     zero
            fcom    three
            fstsw   ax
            sahf
            setb    al
            fstp    st0
            lea     rcx, fcomFmt5
            call    printFP

; fcom mem64 demo 2:

            xor     eax, eax
            fld     zero            ; Never on stack so
            fstp    st1             ; copy for output
            fld     three
            fcom    zero
            fstsw   ax
            sahf
            setb    al
            fstp    st0
            lea     rcx, fcomFmt6
            call    printFP

; fcomp demo:

            xor     eax, eax
            fld     zero
            fld     three
            fst     st0            ; Because this gets popped
            fcomp
            fstsw   ax
            sahf
            setb    al
            fstp    st1
            lea     rcx, fcompFmt
            call    printFP
                        
<span epub:type="pagebreak" title="355" id="Page_355"/>; fcomp demo 2:

            xor     eax, eax
            fld     three
            fld     zero
            fst     st0            ; Because this gets popped
            fcomp
            fstsw   ax
            sahf
            setb    al
            fstp    st1
            lea     rcx, fcompFmt2
            call    printFP

; fcomp demo 3:

            xor     eax, eax
            fld     zero
            fld     three
            fst     st0            ; Because this gets popped
            fcomp   st(1)
            fstsw   ax
            sahf
            setb    al
            fstp    st1
            lea     rcx, fcompFmt3
            call    printFP

; fcomp demo 4:

            xor     eax, eax
            fld     three
            fld     zero
            fst     st0            ; Because this gets popped
            fcomp   st(1)
            fstsw   ax
            sahf
            setb    al
            fstp    st1
            lea     rcx, fcompFmt4
            call    printFP

; fcomp demo 5:

            xor     eax, eax
            fld     three
            fstp    st1
            fld     zero
            fst     st0            ; Because this gets popped
            fcomp   three
            fstsw   ax
            sahf
            setb    al
            lea     rcx, fcompFmt5
            call    printFP

<span epub:type="pagebreak" title="356" id="Page_356"/>; fcomp demo 6:

            xor     eax, eax
            fld     zero
            fstp    st1
            fld     three
            fst     st0            ; Because this gets popped
            fcomp   zero
            fstsw   ax
            sahf
            setb    al
            lea     rcx, fcompFmt6
            call    printFP

; fcompp demo:

            xor     eax, eax
            fld     zero
            fst     st1            ; Because this gets popped
            fld     three
            fst     st0            ; Because this gets popped
            fcompp  
            fstsw   ax
            sahf
            setb    al
            lea     rcx, fcomppFmt
            call    printFP

; fcompp demo 2:

            xor     eax, eax
            fld     three
            fst     st1            ; Because this gets popped
            fld     zero
            fst     st0            ; Because this gets popped
            fcompp  
            fstsw   ax
            sahf
            setb    al
            lea     rcx, fcomppFmt2
            call    printFP

            leave
            ret     ; Returns to caller

asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing6-5">Listing 6-5</a>: Program that demonstrates the <code>fcom</code> instructions</p>
<p>Here’s the build command and output for the program in <a href="#listing6-5">Listing 6-5</a>:</p>
<pre><code>C:\&gt;<b>build listing6-5</b>

C:\&gt;<b>echo off</b>
<span epub:type="pagebreak" title="357" id="Page_357"/> Assembling: listing6-5.asm
c.cpp

C:\&gt;<b>listing6-5</b>
Calling Listing 6-5:
fcom 0.000000 &lt; 3.000000 is 1
fcom(2) 3.000000 &lt; 0.000000 is 0
fcom st(1) 0.000000 &lt; 3.000000 is 1
fcom st(1) (2) 3.000000 &lt; 0.000000 is 0
fcom mem 0.000000 &lt; 3.000000 is 1
fcom mem 3.000000 (2) &lt; 0.000000 is 0
fcomp 3.000000 &lt; 0.000000 is 0
fcomp (2) 0.000000 &lt; 3.000000 is 1
fcomp st(1) 3.000000 &lt; 0.000000 is 0
fcomp st(1) (2) 0.000000 &lt; 3.000000 is 1
fcomp mem 0.000000 &lt; 3.000000 is 1
fcomp mem (2) 3.000000 &lt; 0.000000 is 0
fcompp 3.000000 &lt; 0.000000 is 0
fcompp (2) 0.000000 &lt; 3.000000 is 1
Listing 6-5 terminated</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The x87 FPU also provides instructions that do <em>unordered comparisons</em>: <code>fucom</code>, <code>fucomp</code>, and <code>fucompp</code>. These are functionally equivalent to <code>fcom</code>, <code>fcomp</code>, and <code>fcompp</code> except they raise an exception under different conditions. See the Intel documentation for more details.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-501089c06-0020">6.5.8.2	The fcomi and fcomip Instructions</h4>
<p class="BodyFirst">The <code>fcomi</code> and <code>fcomip</code> instructions compare ST(0) to the specified operand and set the corresponding FLAGS condition code bits based on the result of the comparison. You use these instructions in a similar manner to <code>fcom</code> and <code>fcomp</code> except you can test the CPU’s flag bits directly after the execution of these instructions without first moving the FPU status bits into the FLAGS register. The legal forms for these instructions are as follows:</p>
<pre><code>fcomi   st(0), st(<var>i</var>)
fcomip  st(0), st(<var>i</var>)</code></pre>
<p>Note that a <em>pop-pop</em> version (<code>fcomipp</code>) does not exist. If all you want to do is compare the top two items on the FPU stack, you will have to explicitly pop that item yourself (for example, by using the <code>fstp st(0)</code> instruction).</p>
<p><a href="#listing6-6" id="listinganchor6-6">Listing 6-6</a> is a sample program that demonstrates the operation of the <code>fcomi</code> and <code>fcomip</code> instructions.</p>
<pre><code>; Listing 6-6

; Demonstration of fcomi and fcomip instructions.

        option  casemap:none

nl          =       10

<span epub:type="pagebreak" title="358" id="Page_358"/>            .const
ttlStr      byte    "Listing 6-6", 0
fcomiFmt    byte    "fcomi %f &lt; %f is %d", nl, 0
fcomiFmt2   byte    "fcomi(2) %f &lt; %f is %d", nl, 0
fcomipFmt   byte    "fcomip %f &lt; %f is %d", nl, 0
fcomipFmt2  byte    "fcomip (2) %f &lt; %f is %d", nl, 0

three       real8   3.0
zero        real8   0.0
minusTwo    real8   -2.0

            .data
st0         real8   ?
st1         real8   ?

            .code
            externdef printf:proc

; Return program title to C++ program:

            public  getTitle
getTitle    proc
            lea     rax, ttlStr
            ret
getTitle    endp

; printFP - Prints values of st0 and (possibly) st1.
;           Caller must pass in ptr to fmtStr in RCX.

printFP     proc
            sub     rsp, 40

; For varargs (for example, printf call), double
; values must appear in RDX and R8 rather
; than XMM1, XMM2.
; Note: if only one double arg in format
; string, printf call will ignore 2nd
; value in R8.

            mov     rdx, qword ptr st0
            mov     r8, qword ptr st1
            movzx   r9, al
            call    printf
            add     rsp, 40
            ret
printFP     endp

; Here is the "asmMain" function.

            public  asmMain
asmMain     proc
            push    rbp
            mov     rbp, rsp
            sub     rsp, 48    ; Shadow storage

<span epub:type="pagebreak" title="359" id="Page_359"/>; Test to see if 0 &lt; 3.
; Note: ST(0) contains 0, ST(1) contains 3.

            xor     eax, eax
            fld     three
            fld     zero
            fcomi   st(0), st(1)
            setb    al
            fstp    st0
            fstp    st1
            lea     rcx, fcomiFmt
            call    printFP

; Test to see if 3 &lt; 0.
; Note: ST(0) contains 0, ST(1) contains 3.

            xor     eax, eax
            fld     zero
            fld     three
            fcomi   st(0), st(1)
            setb    al
            fstp    st0
            fstp    st1
            lea     rcx, fcomiFmt2
            call    printFP
                        
; Test to see if 3 &lt; 0.
; Note: ST(0) contains 0, ST(1) contains 3.

            xor     eax, eax
            fld     zero
            fld     three
            fst     st0            ; Because this gets popped
            fcomip  st(0), st(1)
            setb    al
            fstp    st1
            lea     rcx, fcomipFmt
            call    printFP

; Test to see if 0 &lt; 3.
; Note: ST(0) contains 0, ST(1) contains 3.

            xor     eax, eax
            fld     three
            fld     zero
            fst     st0            ; Because this gets popped
            fcomip  st(0), st(1)
            setb    al
            fstp    st1
            lea     rcx, fcomipFmt2
            call    printFP

            leave
            ret    ; Returns to caller

<span epub:type="pagebreak" title="360" id="Page_360"/>asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing6-6">Listing 6-6</a>: Sample program demonstrating floating-point comparisons</p>
<p>Here’s the build command and output for the program in <a href="#listing6-6">Listing 6-6</a>:</p>
<pre><code>C:\&gt;<b>build listing6-6</b>

C:\&gt;<b>echo off</b>
 Assembling: listing6-6.asm
c.cpp

C:\&gt;<b>listing6-6</b>
Calling Listing 6-6:
fcomi 0.000000 &lt; 3.000000 is 1
fcomi(2) 3.000000 &lt; 0.000000 is 0
fcomip 3.000000 &lt; 0.000000 is 0
fcomip (2) 0.000000 &lt; 3.000000 is 1
Listing 6-6 terminated</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The x87 FPU also provides two instructions that do <em>unordered comparisons</em>: <code>fucomi</code> and <code>fucomip</code>. These are functionally equivalent to <code>fcomi</code> and <code>fcomip</code> except they raise an exception under different conditions. See the Intel documentation for more details.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-501089c06-0021">6.5.8.3	The ftst Instruction </h4>
<p class="BodyFirst">The <code>ftst</code> instruction compares the value in ST(0) against 0.0. It behaves just like the <code>fcom</code> instruction would if ST(1) contained 0.0. This instruction does not differentiate –0.0 from +0.0. If the value in ST(0) is either of these values, <code>ftst</code> will set C<sub>3</sub> to denote equality (or unordered). This instruction does <em>not </em>pop ST(0) off the stack.</p>
<p>Here’s an example:</p>
<pre><code>ftst
fstsw ax 
sahf
sete al       ; Set AL to 1 if TOS = 0.0</code></pre>
<h3 id="h2-501089c06-0022">6.5.9	Constant Instructions</h3>
<p class="BodyFirst">The FPU provides several instructions that let you load commonly used constants onto the FPU’s register stack. These instructions set the stack fault, invalid operation, and C<sub>1</sub> flags if a stack overflow occurs; they do not otherwise affect the FPU flags. The specific instructions in this category include the following:</p>
<pre><code>fldz               ; Pushes +0.0
fld1               ; Pushes +1.0
fldpi              ; Pushes pi (3.14159...)
fldl2t             ; Pushes log2(10)
<span epub:type="pagebreak" title="361" id="Page_361"/>fldl2e             ; Pushes log2(e)
fldlg2             ; Pushes log10(2)
fldln2             ; Pushes ln(2)</code></pre>
<h3 id="h2-501089c06-0023">6.5.10	Transcendental Instructions</h3>
<p class="BodyFirst">The FPU provides eight <em>transcendental</em> (logarithmic and trigonometric) instructions to compute sine, cosine, partial tangent, partial arctangent, 2<sup><em>x</em></sup><sup> </sup>– 1, <em>y</em> × log<sub>2</sub>(<em>x</em>), and <em>y</em> × log<sub>2</sub>(<em>x</em> + 1). Using various algebraic identities, you can easily compute most of the other common transcendental functions by using these instructions.</p>
<h4 id="h3-501089c06-0022">6.5.10.1	The f2xm1 Instruction</h4>
<p class="BodyFirst"><code>f2xm1</code> computes 2<sup>ST(0)</sup> – 1. The value in ST(0) must be in the range –1.0 to +1.0. If ST(0) is out of range, <code>f2xm1</code> generates an undefined result but raises no exceptions. The computed value replaces the value in ST(0).</p>
<p>Here’s an example computing 10<sup><em>i</em></sup> using the identity 10<sup><em>i</em></sup> = 2<sup><em>i</em></sup><sup> × log2(10)</sup>. This is useful for only a small range of <em>i</em> that doesn’t put ST(0) outside the previously mentioned valid range:</p>
<pre><code>fld i
fldl2t
fmul
f2xm1
fld1
fadd</code></pre>
<p>Because <code>f2xm1</code> computes 2<sup><em>x</em></sup> – 1, the preceding code adds 1.0 to the result at the end of the computation.</p>
<h4 id="h3-501089c06-0023">6.5.10.2	The fsin, fcos, and fsincos Instructions</h4>
<p class="BodyFirst">These instructions pop the value off the top of the register stack and compute the sine, cosine, or both, and push the result(s) back onto the stack. The <code>fsincos</code> instruction pushes the sine followed by the cosine of the original operand; hence, it leaves cos(ST(0)) in ST(0) and sin(ST(0)) in ST(1).</p>
<p>These instructions assume ST(0) specifies an angle in radians, and this angle must be in the range –2<sup>63</sup> &lt; ST(0) &lt; +2<sup>63</sup>. If the original operand is out of range, these instructions set the C<sub>2</sub> flag and leave ST(0) unchanged. You can use the <code>fprem1</code> instruction, with a divisor of 2π, to reduce the operand to a reasonable range.</p>
<p>These instructions set the stack fault (or rounding)/C<sub>1</sub>, precision, underflow, denormalized, and invalid operation flags according to the result of the computation.</p>
<h4 id="h3-501089c06-0024">6.5.10.3	The fptan Instruction</h4>
<p class="BodyFirst"><code>fptan</code> computes the tangent of ST(0), replaces ST(0) with this value, and then pushes 1.0 onto the stack. Like the <code>fsin</code> and <code>fcos</code> instructions, the value of ST(0) must be in radians and in the range –2<sup>63</sup> &lt; ST(0) &lt; +2<sup>63</sup>. If the <span epub:type="pagebreak" title="362" id="Page_362"/>value is outside this range, <code>fptan</code> sets C<sub>2</sub> to indicate that the conversion did not take place. As with the <code>fsin</code>, <code>fcos</code>, and <code>fsincos</code> instructions, you can use the <code>fprem1</code> instruction to reduce this operand to a reasonable range by using a divisor of 2π.</p>
<p>If the argument is invalid (that is, 0 or π radians, which causes a division by 0), the result is undefined and this instruction raises no exceptions. <code>fptan</code> will set the stack fault/rounding, precision, underflow, denormal, invalid operation, C<sub>2</sub>, and C<sub>1</sub> bits as required by the operation.</p>
<h4 id="h3-501089c06-0025">6.5.10.4	The fpatan Instruction</h4>
<p class="BodyFirst"><code>fpatan</code> expects two values on the top of stack. It pops them and computes ST(0) = tan<sup>-1</sup>(ST(1) / ST(0)). The resulting value is the arctangent of the ratio on the stack expressed in radians. If you want to compute the arctangent of a particular value, use <code>fld1</code> to create the appropriate ratio and then execute the <code>fpatan</code> instruction.</p>
<p>This instruction affects the stack fault/C<sub>1</sub>, precision, underflow, denormal, and invalid operation bits if a problem occurs during the computation. It sets the C<sub>1</sub> condition code bit if it has to round the result.</p>
<h4 id="h3-501089c06-0026">6.5.10.5	The fyl2x Instruction</h4>
<p class="BodyFirst">The <code>fyl2x</code> instruction computes ST(0) = ST(1) × log<sub>2</sub>(ST(0)). The instruction itself has no operands, but expects two operands on the FPU stack in ST(1) and ST(0), thus using the following syntax:</p>
<pre><code>fyl2x</code></pre>
<p>To compute the log of any other base, you can use the arithmetic identity log<sub><em>n</em></sub>(<em>x</em>) = log<sub>2</sub>(<em>x</em>) / log<sub>2</sub>(<em>n</em>). So if you first compute log<sub>2</sub>(<em>n</em>) and put its reciprocal on the stack, then push <em>x</em> onto the stack and execute <code>fyl2x</code>, you wind up with log<em>n</em>(<em>x</em>).</p>
<p>The <code>fyl2x</code> instruction sets the C<sub>1</sub> condition code bit if it has to round up the value. It clears C<sub>1</sub> if no rounding occurs or if a stack overflow occurs. The remaining floating-point condition codes are undefined after the execution of this instruction. <code>fyl2x</code> can raise the following floating-point exceptions: invalid operation, denormal result, overflow, underflow, and inexact result. Note that the <code>fldl2t</code> and <code>fldl2e</code> instructions turn out to be quite handy when using the <code>fyl2x</code> instruction (for computing log<sub>10</sub> and ln).</p>
<h4 id="h3-501089c06-0027">6.5.10.6	The fyl2xp1 Instruction</h4>
<p class="BodyFirst"><code>fyl2xp1</code> computes ST(0) = ST(1) × log<sub>2</sub>(ST(0) + 1.0) from two operands on the FPU stack. The syntax for this instruction is as follows:</p>
<pre><code>fyl2xp1</code></pre>
<p>Otherwise, the instruction is identical to <code>fyl2x</code>.</p>
<h3 id="h2-501089c06-0024"><span epub:type="pagebreak" title="363" id="Page_363"/>6.5.11	Miscellaneous Instructions</h3>
<p class="BodyFirst">The FPU includes several additional instructions that control the FPU, synchronize operations, and let you test or set various status bits: <code>finit</code>/<code>fninit</code>, <code>fldcw</code>, <code>fstcw</code>, <code>fclex</code>/<code>fnclex</code>, and <code>fstsw</code>.</p>
<h4 id="h3-501089c06-0028">6.5.11.1	The finit and fninit Instructions</h4>
<p class="BodyFirst">The <code>finit</code> and <code>fninit</code> instructions initialize the FPU for proper operation. Your code should execute one of these instructions before executing any other FPU instructions. They initialize the control register to 37Fh, the status register to 0, and the tag word to 0FFFFh. The other registers are unaffected.</p>
<p>Here are some examples:</p>
<pre><code>finit
fninit</code></pre>
<p>The difference between <code>finit</code> and <code>fninit</code> is that <code>finit</code> first checks for any pending floating-point exceptions before initializing the FPU; <code>fninit</code> does not.</p>
<h4 id="h3-501089c06-0029">6.5.11.2	The fldcw and fstcw Instructions </h4>
<p class="BodyFirst">The <code>fldcw</code> and <code>fstcw</code> instructions require a single 16-bit memory operand:</p>
<pre><code>fldcw <var>mem</var><sub>16</sub>
fstcw <var>mem</var><sub>16</sub></code></pre>
<p>These two instructions load the control word from a memory location (<code>fldcw</code>) or store the control word to a 16-bit memory location (<code>fstcw</code>).</p>
<p>When you use <code>fldcw</code> to turn on one of the exceptions, if the corresponding exception flag is set when you enable that exception, the FPU will generate an immediate interrupt before the CPU executes the next instruction. Therefore, you should use <code>fclex</code> to clear any pending interrupts before changing the FPU exception enable bits.</p>
<h4 id="h3-501089c06-0030">6.5.11.3	The fclex and fnclex Instructions </h4>
<p class="BodyFirst">The <code>fclex</code> and <code>fnclex</code> instructions clear all exception bits, the stack fault bit, and the busy flag in the FPU status register.</p>
<p>Here are examples:</p>
<pre><code>fclex
fnclex</code></pre>
<p>The difference between these instructions is the same as that between <code>finit</code> and <code>fninit</code>: <code>fclex</code> first checks for pending floating-point exceptions.</p>
<h4 id="h3-501089c06-0031"><span epub:type="pagebreak" title="364" id="Page_364"/>6.5.11.4	The fstsw and fnstsw Instructions  </h4>
<p class="BodyFirst">These instructions store the FPU status word into a 16-bit memory location or the AX register:</p>
<pre><code>fstsw  ax
fnstsw ax
fstsw  <var>mem</var><sub>16</sub>
fnstsw <var>mem</var><sub>16</sub></code></pre>
<p>These instructions are unusual in the sense that they can copy an FPU value into one of the x86-64 general-purpose registers (specifically, AX). The purpose is to allow the CPU to easily test the condition code register with the <code>sahf</code> instruction. The difference between <code>fstsw</code> and <code>fnstsw</code> is the same as that for <code>fclex</code> and <code>fnclex</code>.</p>
<h2 id="h1-501089c06-0006">	6.6	Converting Floating-Point Expressions to Assembly Language</h2>
<p class="BodyFirst">Because the FPU register organization is different from the x86-64 integer register set, translating arithmetic expressions involving floating-point operands is a little different from translating integer expressions. Therefore, it makes sense to spend some time discussing how to manually translate floating-point expressions into assembly language.</p>
<p>The FPU uses <em>postfix notation </em>(also called <em>reverse Polish notation</em>, or <em>RPN</em>) for arithmetic operations. Once you get used to using postfix notation, it’s actually a bit more convenient for translating expressions because you don’t have to worry about allocating temporary variables—they always wind up on the FPU stack. Postfix notation, as opposed to standard <em>infix notation</em>, places the operands before the operator. <a href="#table6-14" id="tableanchor6-14">Table 6-14</a> provides simple examples of infix notation and the corresponding postfix notation.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-14">Table 6-14</a>: Infix-to-Postfix Translation</p></figcaption>
<table id="table-501089c06-0014" border="1">
<thead>
<tr>
<td><b>Infix notation</b></td>
<td><b>Postfix notation</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>5 + 6</td>
<td>5 6 +</td>
</tr>
<tr>
<td>7 – 2</td>
<td>7 2 –</td>
</tr>
<tr>
<td>y × z</td>
<td>y z ×</td>
</tr>
<tr>
<td>a / b</td>
<td>a b /</td>
</tr>
</tbody>
</table>
</figure>
<p>A postfix expression like <code>5 6 +</code> says, “Push 5 onto the stack, push 6 onto the stack, and then pop the value off the top of stack (6) and add it to the new top of stack.” Sound familiar? This is exactly what the <code>fld</code> and <code>fadd</code> instructions do. In fact, you can calculate the result by using the following code:</p>
<pre><code>fld five   ; Declared somewhere as five real8 5.0 (or real4/real10)
fld six    ; Declared somewhere as six real8 6.0 (or real4/real10)
fadd       ; 11.0 is now on the top of the FPU stack</code></pre>
<p><span epub:type="pagebreak" title="365" id="Page_365"/>As you can see, postfix is a convenient notation because it’s easy to translate this code into FPU instructions.</p>
<p>Another advantage to postfix notation is that it doesn’t require any parentheses. The examples in <a href="#table6-15" id="tableanchor6-15">Table 6-15</a> demonstrate some slightly more complex infix-to-postfix conversions.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-15">Table 6-15</a>: More-Complex Infix-to-Postfix Translations</p></figcaption>
<table id="table-501089c06-0015" border="1">
<thead>
<tr>
<td><b>Infix notation</b></td>
<td><b>Postfix notation</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>(y + z) * 2</td>
<td>y z + 2 *</td>
</tr>
<tr>
<td>y * 2 – (a + b)</td>
<td>y 2 * a b + –</td>
</tr>
<tr>
<td>(a + b) * (c + d)</td>
<td>a b + c d + *</td>
</tr>
</tbody>
</table>
</figure>
<p>The postfix expression <code>y z + 2 *</code> says, “Push <em>y</em>, then push <em>z</em>; next, add those values on the stack (producing <code>y + z</code> on the stack). Next, push 2 and then multiply the two values (<code>2</code> and <code>y + z</code>) on the stack to produce two times the quantity <code>y + z</code>.” Once again, we can translate these postfix expressions directly into assembly language. The following code demonstrates the conversion for each of the preceding expressions:</p>
<pre><code>; y z + 2 *

          fld y
          fld z
          fadd
          fld const2   ; const2 real8 2.0 in .data section
          fmul

; y 2 * a b + -

          fld y
          fld const2   ; const2 real8 2.0 in .data section
          fmul
          fld a
          fld b
          fadd
          fsub

; a b + c d + *

          fld a
          fld b
          fadd
          fld c
          fld d
          fadd
          fmul</code></pre>
<h3 id="h2-501089c06-0025"><span epub:type="pagebreak" title="366" id="Page_366"/>6.6.1	Converting Arithmetic Expressions to Postfix Notation</h3>
<p class="BodyFirst">For simple expressions, those involving two operands and a single expression, the translation from infix to postfix notation is trivial: simply move the operator from the infix position to the postfix position (that is, move the operator from between the operands to after the second operand). For example <code>5 + 6</code> becomes <code>5 6 +</code>. Other than separating your operands so you don’t confuse them (that is, is it 5 and 6 or 56?), converting simple infix expressions into postfix notation is straightforward.</p>
<p>For complex expressions, the idea is to convert the simple subexpressions into postfix notation and then treat each converted subexpression as a single operand in the remaining expression. The following discussion surrounds completed conversions with square brackets so it is easy to see which text needs to be treated as a single operand in the conversion.</p>
<p>As for integer expression conversion, the best place to start is in the innermost parenthetical subexpression and then work your way outward, considering precedence, associativity, and other parenthetical subexpressions. As a concrete working example, consider the following expression:</p>
<pre><code>x = ((y – z) * a) – (a + b * c) / 3.14159</code></pre>
<p>A possible first translation is to convert the subexpression (<code>y - z</code>) into postfix notation:</p>
<pre><code>x = ([y z -] * a) - (a + b * c) / 3.14159</code></pre>
<p>Square brackets surround the converted postfix code just to separate it from the infix code, for readability. Remember, for the purposes of conversion, we will treat the text inside the square brackets as a single operand. Therefore, you would treat <code>[y z -]</code> as though it were a single variable name or constant.</p>
<p>The next step is to translate the subexpression (<code>[y z -] * a</code>) into postfix form. This yields the following:</p>
<pre><code>x = [y z - a *] - (a + b * c) / 3.14159</code></pre>
<p>Next, we work on the parenthetical expression (<code>a + b * c</code>). Because multiplication has higher precedence than addition, we convert <code>b * c</code> first:</p>
<pre><code>x = [y z - a *] - (a + [b c *]) / 3.14159</code></pre>
<p>After converting <code>b * c</code>, we finish the parenthetical expression:</p>
<pre><code>x = [y z - a *] - [a b c * +] / 3.14159</code></pre>
<p>This leaves only two infix operators: subtraction and division. Because division has the higher precedence, we’ll convert that first:</p>
<pre><code>x = [y z - a *] - [a b c * + 3.14159 /]</code></pre>
<p><span epub:type="pagebreak" title="367" id="Page_367"/>Finally, we convert the entire expression into postfix notation by dealing with the last infix operation, subtraction:</p>
<pre><code>x = [y z - a *] [a b c * + 3.14159 /] -</code></pre>
<p>Removing the square brackets yields the following postfix expression:</p>
<pre><code>x = y z - a * a b c * + 3.14159 / -</code></pre>
<p>The following steps demonstrate another infix-to-postfix conversion for this expression:</p>
<pre><code>a = (x * y - z + t) / 2.0</code></pre>
<ol class="decimal">
<li value="1">Work inside the parentheses. Because multiplication has the highest precedence, convert that first:
<pre><code>a = ([x y *] - z + t) / 2.0</code></pre></li>
<li value="2">Still working inside the parentheses, we note that addition and subtraction have the same precedence, so we rely on associativity to determine what to do next. These operators are left-associative, so we must translate the expressions from left to right. This means translate the subtraction operator first:
<pre><code>a = ([x y * z -] + t) / 2.0</code></pre></li>
<li value="3">Now translate the addition operator inside the parentheses. Because this finishes the parenthetical operators, we can drop the parentheses:
<pre><code>a = [x y * z - t +] / 2.0</code></pre></li>
<li value="4">Translate the final infix operator (division). This yields the following:
<pre><code>a = [x y * z - t + 2.0 /]</code></pre></li>
<li value="5">Drop the square brackets, and we’re done:
<pre><code>a = x y * z - t + 2.0 /</code></pre></li>
</ol>
<h3 id="h2-501089c06-0026">6.6.2	Converting Postfix Notation to Assembly Language</h3>
<p class="BodyFirst">Once you’ve translated an arithmetic expression into postfix notation, finishing the conversion to assembly language is easy. All you have to do is issue an <code>fld</code> instruction whenever you encounter an operand and issue an <span epub:type="pagebreak" title="368" id="Page_368"/>appropriate arithmetic instruction when you encounter an operator. This section uses the completed examples from the previous section to demonstrate how little there is to this process.</p>
<pre><code>x = y z - a * a b c * + 3.14159 / -</code></pre>
<ol class="decimal">
<li value="1">Convert <code>y</code> to <code>fld y</code>.</li>
<li value="2">Convert <code>z</code> to <code>fld z</code>.</li>
<li value="3">Convert <code>-</code> to <code>fsub</code>.</li>
<li value="4">Convert <code>a</code> to <code>fld a</code>.</li>
<li value="5">Convert <code>*</code> to <code>fmul</code>.</li>
<li value="6">Continuing in a left-to-right fashion, generate the following code for the expression:
<pre><code>fld   y
fld   z
fsub
fld   a
fmul
fld   a
fld   b
fld   c
fmul
fadd
fldpi       ; Loads pi (3.14159)
fdiv
fsub

fstp   x    ; Store result away into x</code></pre></li>
</ol>
<p>Here’s the translation for the second example in the previous section:</p>
<pre><code>a = x y * z - t + 2.0 /
          fld   x
          fld   y
          fmul
          fld   z
          fsub
          fld   t
          fadd
          fld   const2    ; const2 real8 2.0 in .data section
          fdiv

          fstp  a         ; Store result away into a</code></pre>
<p>As you can see, the translation is fairly simple once you’ve converted the infix notation to postfix notation. Also note that, unlike integer expression conversion, you don’t need any explicit temporaries. It turns out that the <span epub:type="pagebreak" title="369" id="Page_369"/>FPU stack provides the temporaries for you.<sup class="FootnoteReference"><a id="c06-footnoteref-9" href="#c06-footnote-9">9</a></sup> For these reasons, converting floating-point expressions into assembly language is actually easier than converting integer expressions.</p>
<h2 id="h1-501089c06-0007">	6.7	SSE Floating-Point Arithmetic</h2>
<p class="BodyFirst">Although the x87 FPU is relatively easy to use, the stack-based design of the FPU created performance bottlenecks as CPUs became more powerful. After introducing the <em>Streaming SIMD Extensions (SSE)</em> in its Pentium III CPUs (way back in 1999), Intel decided to resolve the FPU performance bottleneck and added scalar (non-vector) floating-point instructions to the SSE instruction set that could use the XMM registers. Most modern programs favor the use of the SSE (and later) registers and instructions for floating-point operations over the x87 FPU, using only those x87 operations available exclusively on the x87.</p>
<p>The SSE instruction set supports two floating-point data types: 32-bit single-precision (Intel calls these <em>scalar single</em> operations) and 64-bit double-precision values (Intel calls these <em>scalar double</em> operations).<sup class="FootnoteReference"><a id="c06-footnoteref-10" href="#c06-footnote-10">10</a></sup> The SSE does not support the 80-bit extended-precision floating-point data types of the x87 FPU. If you need the extended-precision format, you’ll have to use the x87 FPU.</p>
<h3 id="h2-501089c06-0027">6.7.1	SSE MXCSR Register</h3>
<p class="BodyFirst">The SSE MXCSR register is a 32-bit status and control register that controls SSE floating-point operations. Bits 16 to 32 are reserved and currently have no meaning. <a href="#table6-16" id="tableanchor6-16">Table 6-16</a> lists the functions of the LO 16 bits.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-16">Table 6-16</a>: SSE MXCSR Register</p></figcaption>
<table id="table-501089c06-0016" border="1">
<thead>
<tr>
<td><b>Bit</b></td>
<td><b>Name</b></td>
<td><b>Function</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>IE</td>
<td>Invalid operation exception flag. Set if an invalid operation was attempted.</td>
</tr>
<tr>
<td>1</td>
<td>DE</td>
<td>Denormal exception flag. Set if operations produced a denormalized value.</td>
</tr>
<tr>
<td>2</td>
<td>ZE</td>
<td>Zero exception flag. Set if an attempt to divide by 0 was made.</td>
</tr>
<tr>
<td>3</td>
<td>OE</td>
<td>Overflow exception flag. Set if there was an overflow.</td>
</tr>
<tr>
<td>4</td>
<td>UE</td>
<td>Underflow exception flag. Set if there was an underflow.</td>
</tr>
<tr>
<td>5</td>
<td>PE</td>
<td>Precision exception flag. Set if there was a precision exception.</td>
</tr>
<tr>
<td><span epub:type="pagebreak" title="370" id="Page_370"/>6</td>
<td>DAZ</td>
<td>Denormals are 0. If set, treat denormalized values as 0.</td>
</tr>
<tr>
<td>7</td>
<td>IM</td>
<td>Invalid operation mask. If set, ignore invalid operation exceptions.</td>
</tr>
<tr>
<td>8</td>
<td>DM</td>
<td>Denormal mask. If set, ignore denormal exceptions.</td>
</tr>
<tr>
<td>9</td>
<td>ZM</td>
<td>Divide-by-zero mask. If set, ignore division-by-zero exceptions.</td>
</tr>
<tr>
<td>10</td>
<td>OM</td>
<td>Overflow mask. If set, ignore overflow exceptions.</td>
</tr>
<tr>
<td>11</td>
<td>UM</td>
<td>Underflow mask. If set, ignore underflow exceptions.</td>
</tr>
<tr>
<td>12</td>
<td>PM</td>
<td>Precision mask. If set, ignore precision exceptions.</td>
</tr>
<tr>
<td>13<br/>
14</td>
<td>Rounding<br/>
Control</td>
<td>00: Round to nearest          01: Round toward –infinity<br/>
10: Round toward +infinity  11: Round toward 0 (truncate)</td>
</tr>
<tr>
<td>15</td>
<td>FTZ</td>
<td>Flush to zero. When set, all underflow conditions set the register to 0.</td>
</tr>
</tbody>
</table>
</figure>
<p>Access to the SSE MXCSR register is via the following two instructions:</p>
<pre><code>ldmxcsr <var>mem</var><sub>32</sub>
stmxcsr <var>mem</var><sub>32</sub></code></pre>
<p>The <code>ldmxcsr</code> instruction loads the MXCSR register from the specified 32-bit memory location. The <code>stmxcsr</code> instruction stores the current contents of the MXCSR register to the specified memory location.</p>
<p>By far, the most common use of these two instructions is to set the rounding mode. In typical programs using the SSE floating-point instructions, it is common to switch between the round-to-nearest and round-to-zero (truncate) modes.</p>
<h3 id="h2-501089c06-0028">6.7.2	SSE Floating-Point Move Instructions</h3>
<p class="BodyFirst">The SSE instruction set provides two instructions to move floating-point values between XMM registers and memory: <code>movss</code> (<em>move scalar single</em>) and <code>movsd</code> (<em>move scalar double</em>). Here is their syntax:</p>
<pre><code>movss <var>xmm</var><sub><em>n</em></sub>, <var>mem</var><sub>32</sub>
movss <var>mem</var><sub>32</sub>, <var>xmm</var><sub><em>n</em></sub>
movsd <var>xmm</var><sub><em>n</em></sub>, <var>mem</var><sub>64</sub>
movsd <var>mem</var><sub>64</sub>, <var>xmm</var><sub><em>n</em></sub></code></pre>
<p>As for the standard general-purpose registers, the <code>movss</code> and <code>movsd</code> instructions move data between an appropriate memory location (containing a 32- or 64-bit floating-point value) and one of the 16 XMM registers (XMM0 to XMM15).</p>
<p>For maximum performance, <code>movss</code> memory operands should appear at a double-word-aligned memory address, and <code>movsd</code> memory operands should appear at a quad-word-aligned memory address. Though these instructions will function properly if the memory operands are not properly aligned in memory, there is a performance hit for misaligned accesses.</p>
<p><span epub:type="pagebreak" title="371" id="Page_371"/>In addition to the <code>movss</code> and <code>movsd</code> instructions that move floating-point values between XMM registers or XMM registers and memory, you’ll find a couple of other SSE move instructions useful that move data between XMM and general-purpose registers, <code>movd</code> and <code>movq</code>:</p>
<pre><code>movd  <var>reg</var><sub>32</sub>, <var>xmm</var><sub><em>n</em></sub>
movd  <var>xmm</var><sub><em>n</em></sub>, <var>reg</var><sub>32</sub>
movq  <var>reg</var><sub>64</sub>, <var>xmm</var><sub><em>n</em></sub>
movq  <var>xmm</var><sub><em>n</em></sub>, <var>reg</var><sub>64</sub></code></pre>
<p>These instructions also have a form that allows a source memory operand. However, you should use <code>movss</code> and <code>movsd</code> to move floating-point variables into XMM registers.</p>
<p>The <code>movq</code> and <code>movd</code> instructions are especially useful for copying XMM registers into 64-bit general-purpose registers prior to a call to <code>printf()</code> (when printing floating-point values). As you’ll see in a few sections, these instructions are also useful for floating-point comparisons on the SSE.</p>
<h3 id="h2-501089c06-0029">6.7.3	SSE Floating-Point Arithmetic Instructions</h3>
<p class="BodyFirst">The Intel SSE instruction set adds the following floating-point arithmetic instructions:</p>
<pre><code>addss <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>n</em></sub>
addss <var>xmm</var><sub><em>n</em></sub>, <var>mem</var><sub>32</sub>
addsd <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>n</em></sub>
addsd <var>xmm</var><sub><em>n</em></sub>, <var>mem</var><sub>64</sub>

subss <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>n</em></sub>
subss <var>xmm</var><sub><em>n</em></sub>, <var>mem</var><sub>32</sub>
subsd <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>n</em></sub>
subsd <var>xmm</var><sub><em>n</em></sub>, <var>mem</var><sub>64</sub>

mulss <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>n</em></sub>
mulss <var>xmm</var><sub><em>n</em></sub>, <var>mem</var><sub>32</sub>
mulsd <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>n</em></sub>
mulsd <var>xmm</var><sub><em>n</em></sub>, <var>mem</var><sub>64</sub>

divss <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>n</em></sub>
divss <var>xmm</var><sub><em>n</em></sub>, <var>mem</var><sub>32</sub>
divsd <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>n</em></sub>
divsd <var>xmm</var><sub><em>n</em></sub>, <var>mem</var><sub>64</sub>

minss <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>n</em></sub>
minss <var>xmm</var><sub><em>n</em></sub>, <var>mem</var><sub>32</sub>
minsd <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>n</em></sub>
minsd <var>xmm</var><sub><em>n</em></sub>, <var>mem</var><sub>64</sub>

maxss <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>n</em></sub>
maxss <var>xmm</var><sub><em>n</em></sub>, <var>mem</var><sub>32</sub>
maxsd <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>n</em></sub>
maxsd <var>xmm</var><sub><em>n</em></sub>, <var>mem</var><sub>64</sub>

<span epub:type="pagebreak" title="372" id="Page_372"/>sqrtss  <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>n</em></sub>
sqrtss  <var>xmm</var><sub><em>n</em></sub>, <var>mem</var><sub>32</sub>
sqrtsd  <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>n</em></sub>
sqrtsd  <var>xmm</var><sub><em>n</em></sub>, <var>mem</var><sub>64</sub>

rcpss   <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>n</em></sub>
rcpss   <var>xmm</var><sub><em>n</em></sub>, <var>mem</var><sub>32</sub>

rsqrtss <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>n</em></sub>
rsqrtss <var>xmm</var><sub><em>n</em></sub>, <var>mem</var><sub>32</sub></code></pre>
<p>The <code>adds</code><var>x</var>, <code>subs</code><var>x</var>, <code>muls</code><var>x</var>, and <code>divs</code><var>x</var> instructions perform the expected floating-point arithmetic operations. The <code>mins</code><var>x</var> instructions compute the minimum value of the two operands, storing the minimum value into the destination (first) operand. The <code>maxs</code><var>x</var> instructions do the same thing, but compute the maximum of the two operands. The <code>sqrts</code><var>x</var> instructions compute the square root of the source (second) operand and store the result into the destination (first) operand. The <code>rcps</code><var>x</var> instructions compute the reciprocal of the source, storing the result into the destination.<sup class="FootnoteReference"><a id="c06-footnoteref-11" href="#c06-footnote-11">11</a></sup> The <code>rsqrts</code><var>x</var> instructions compute the reciprocal of the square root.<sup class="FootnoteReference"><a id="c06-footnoteref-12" href="#c06-footnote-12">12</a></sup></p>
<p>The operand syntax is somewhat limited for the SSE instructions (compared with the generic integer instructions): the destination operand must always be an XMM register.</p>
<h3 id="h2-501089c06-0030">6.7.4	SSE Floating-Point Comparisons</h3>
<p class="BodyFirst">The <em>SSE floating-point comparisons</em> work quite a bit differently from the integer and x87 FPU compare instructions. Rather than having a single generic instruction that sets flags (to be tested by <code>set</code><var>cc</var> or <code>j</code><var>cc</var> instructions), the SSE provides a set of condition-specific comparison instructions that store true (all 1 bits) or false (all 0 bits) into the destination operand. You can then test the result value for true or false. Here are the instructions:</p>
<pre><code>cmpss <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>m</em></sub>/<var>mem</var><sub>32</sub>, <var>imm</var><sub>8</sub>
cmpsd <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>m</em></sub>/<var>mem</var><sub>64</sub>, <var>imm</var><sub>8</sub>

cmpeqss     <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>m</em></sub>/<var>mem</var><sub>32</sub>
cmpltss     <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>m</em></sub>/<var>mem</var><sub>32</sub>
cmpless     <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>m</em></sub>/<var>mem</var><sub>32</sub>
cmpunordss  <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>m</em></sub>/<var>mem</var><sub>32</sub>
cmpne  qss  <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>m</em></sub>/<var>mem</var><sub>32</sub>
cmpnltss    <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>m</em></sub>/<var>mem</var><sub>32</sub>
cmpnless    <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>m</em></sub>/<var>mem</var><sub>32</sub>
cmpordss    <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>m</em></sub>/<var>mem</var><sub>32</sub>

<span epub:type="pagebreak" title="373" id="Page_373"/>cmpeqsd     <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>m</em></sub>/<var>mem</var><sub>64</sub>
cmpltsd     <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>m</em></sub>/<var>mem</var><sub>64</sub>
cmplesd     <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>m</em></sub>/<var>mem</var><sub>64</sub>
cmpunordsd  <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>m</em></sub>/<var>mem</var><sub>64</sub>
cmpneqsd    <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>m</em></sub>/<var>mem</var><sub>64</sub>
cmpnltsd    <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>m</em></sub>/<var>mem</var><sub>64</sub>
cmpnlesd    <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>m</em></sub>/<var>mem</var><sub>64</sub>
cmpordsd    <var>xmm</var><sub><em>n</em></sub>, <var>xmm</var><sub><em>m</em></sub>/<var>mem</var><sub>64</sub></code></pre>
<p>The immediate constant is a value in the range 0 to 7 and represents one of the comparisons in <a href="#table6-17" id="tableanchor6-17">Table 6-17</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-17">Table 6-17</a>: SSE Compare Immediate Operand</p></figcaption>
<table id="table-501089c06-0017" border="1">
<thead>
<tr>
<td><b>imm<sub>8</sub></b></td>
<td><b>Comparison</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>First operand <code>==</code> second operand</td>
</tr>
<tr>
<td>1</td>
<td>First operand <code>&lt;</code> second operand</td>
</tr>
<tr>
<td>2</td>
<td>First operand <code>&lt;=</code> second operand</td>
</tr>
<tr>
<td>3</td>
<td>First operand unordered second operand</td>
</tr>
<tr>
<td>4</td>
<td>First operand <code>≠</code> second operand</td>
</tr>
<tr>
<td>5</td>
<td>First operand not less than second operand (<code>≥</code>)</td>
</tr>
<tr>
<td>6</td>
<td>First operand not less than or equal to second operand (<code>&gt;</code>)</td>
</tr>
<tr>
<td>7</td>
<td>First operand ordered second operand</td>
</tr>
</tbody>
</table>
</figure>
<p>The instructions without the third (immediate) operand are special <em>pseudo-ops</em> MASM provides that automatically supply the appropriate third operand. You can use the <code>nlt</code> form for <code>ge</code> and <code>nle</code> form for <code>gt</code>, assuming the operands are ordered.</p>
<p>The <em>unordered</em> comparison returns true if either (or both) operands are unordered (typically, NaN values). Likewise, the ordered comparison returns true if both operands are ordered.</p>
<p>As noted, these instructions leave 0 or all 1 bits in the destination register to represent false or true. If you want to branch based on these conditions, you should move the destination XMM register into a general-purpose register and test that register for zero/not zero. You can use the <code>movq</code> or <code>movd</code> instructions to accomplish this:</p>
<pre><code>  cmpeqsd xmm0, xmm1
  movd    eax, xmm0    ; Move true/false to EAX
  test    eax, eax     ; Test for true/false
  jnz     xmm0EQxmm1   ; Branch if xmm0 == xmm1

; Code to execute if xmm0 != xmm1.</code></pre>
<h3 id="h2-501089c06-0031">6.7.5	SSE Floating-Point Conversions</h3>
<p class="BodyFirst">The x86-64 provides several floating-point conversion instructions that convert between floating-point and integer formats. <a href="#table6-18" id="tableanchor6-18">Table 6-18</a> lists these instructions and their syntax.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-18">Table 6-18</a>: SSE Conversion Instructions<span epub:type="pagebreak" title="374" id="Page_374"/></p></figcaption>
<table id="table-501089c06-0018" border="1">
<thead>
<tr>
<td><b>Instruction syntax</b></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>cvtsd2si </code><var>reg</var><sub>32/64</sub><code>, </code><var>xmm</var><sub><em>n</em></sub><code>/mem</code><sub>64</sub></td>
<td>Converts scalar double-precision FP to 32- or 64-bit integer. Uses the current rounding mode in the MXCSR to determine how to deal with fractional components. Result is stored in a general-purpose 32- or 64-bit register.</td>
</tr>
<tr>
<td><code>cvtsd2ss </code><var>xmm</var><sub><em>n</em></sub><code>, </code><var>xmm</var><sub><em>n</em></sub><code>/</code><var>mem</var><sub>64</sub></td>
<td>Converts scalar double-precision FP (in an XMM register or memory) to scalar single-precision FP and leaves the result in the destination XMM register. Uses the current rounding mode in the MXCSR to determine how to deal with inexact conversions.</td>
</tr>
<tr>
<td><code>cvtsi2sd </code><var>xmm</var><sub><em>n</em></sub><code>, </code><var>reg</var><sub>32/64</sub><code>/</code><var>mem</var><sub>32/64</sub></td>
<td>Converts a 32- or 64-bit integer in an integer register or memory to a double-precision floating-point value, leaving the result in an XMM register.</td>
</tr>
<tr>
<td><code>cvtsi2ss </code><var>xmm</var><sub><em>n</em></sub><code>, </code><var>reg</var><sub>32/64</sub><code>/</code><var>mem</var><sub>32/64</sub></td>
<td>Converts a 32- or 64-bit integer in an integer register or memory to a single-precision floating-point value, leaving the result in an XMM register.</td>
</tr>
<tr>
<td><code>cvtss2sd </code><var>xmm</var><sub><em>n</em></sub><code>, </code><var>xmm</var><sub><em>n</em></sub><code>/</code><var>mem</var><sub>32</sub></td>
<td>Converts a single-precision floating-point value in an XMM register or memory to a double-precision value, leaving the result in the destination XMM register.</td>
</tr>
<tr>
<td><code>cvtss2si </code><var>reg</var><sub>32/64</sub><code>, </code><var>xmm</var><sub><em>n</em></sub><code>/</code><var>mem</var><sub>32</sub></td>
<td>Converts a single-precision floating-point value in an XMM register or memory to an integer and leaves the result in a general-purpose 32- or 64-bit register. Uses the current rounding mode in the MXCSR to determine how to deal with inexact conversions.</td>
</tr>
<tr>
<td><code>cvttsd2si </code><var>reg</var><sub>32/64</sub><code>, </code><var>xmm</var><sub><em>n</em></sub><code>/</code><var>mem</var><sub>64</sub></td>
<td>Converts scalar double-precision FP to a 32- or 64-bit integer. Conversion is done using truncation (does not use the rounding control setting in the MXCSR). Result is stored in a general-purpose 32- or 64-bit register.</td>
</tr>
<tr>
<td><code>cvttss2si </code><var>reg</var><sub>32/64</sub><code>, </code><var>xmm</var><sub><em>n</em></sub><code>/</code><var>mem</var><sub>32</sub></td>
<td>Converts scalar single-precision FP to a 32- or 64-bit integer. Conversion is done using truncation (does not use the rounding control setting in the MXCSR). Result is stored in a general-purpose 32- or 64-bit register.</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="h1-501089c06-0008">	6.8	For More Information</h2>
<p class="BodyFirst">The Intel and AMD processor manuals fully describe the operation of each of the integer and floating-point arithmetic instructions, including a detailed description of how these instructions affect the condition code bits and other flags in the FLAGS and FPU status registers. To write the best possible assembly language code, you need to be intimately familiar with how the arithmetic instructions affect the execution environment, so spending time with the Intel and AMD manuals is a good idea.</p>
<p><span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span> discusses multiprecision integer arithmetic. See that chapter for details on handling integer operands that are greater than 64 bits in size.</p>
<p>The x86-64 SSE instruction set found on later iterations of the CPU provides support for floating-point arithmetic using the AVX register set. Consult the Intel and AMD documentation for details concerning the AVX floating-point instruction set.</p>
<h2 id="h1-501089c06-0009"><span epub:type="pagebreak" title="375" id="Page_375"/>	6.9	Test Yourself</h2>
<ol class="decimal">
<li value="1">What are the implied operands for the single-operand <code>imul</code> and <code>mul</code> instructions?</li>
<li value="2">What is the result size for an 8-bit <code>mul</code> operation? A 16-bit <code>mul</code> operation? A 32-bit <code>mul</code> operation? A 64-bit <code>mul</code> operation? Where does the CPU put the products?</li>
<li value="3">What result(s) does an x86 <code>div</code> instruction produce?</li>
<li value="4">When performing a signed 16×16–bit division using <code>idiv</code>, what must you do before executing the <code>idiv</code> instruction?</li>
<li value="5">When performing an unsigned 32×32–bit division using <code>div</code>, what must you do before executing the <code>div</code> instruction?</li>
<li value="6">What are the two conditions that will cause a <code>div</code> instruction to produce an exception?</li>
<li value="7">How do the <code>mul</code> and <code>imul</code> instructions indicate overflow?</li>
<li value="8">How do the <code>mul</code> and <code>imul</code> instructions affect the zero flag?</li>
<li value="9">What is the difference between the extended-precision (single operand) <code>imul</code> instruction and the more generic (multi-operand) <code>imul</code> instruction?</li>
<li value="10">What instructions would you normally use to sign-extend the accumulator prior to executing an <code>idiv</code> instruction?</li>
<li value="11">How do the <code>div</code> and <code>idiv</code> instructions affect the carry, zero, overflow, and sign flags?</li>
<li value="12">How does the <code>cmp</code> instruction affect the zero flag?</li>
<li value="13">How does the <code>cmp</code> instruction affect the carry flag (with respect to an unsigned comparison)?</li>
<li value="14">How does the <code>cmp</code> instruction affect the sign and overflow flags (with respect to a signed comparison)?</li>
<li value="15">What operands do the <code>set</code><var>cc</var> instructions take?</li>
<li value="16">What do the <code>set</code><var>cc</var> instructions do to their operand?</li>
<li value="17">What is the difference between the <code>test</code> instruction and the <code>and</code> instruction?</li>
<li value="18">What are the similarities between the <code>test</code> instruction and the <code>and</code> instruction?</li>
<li value="19">Explain how you would use the <code>test</code> instruction to see if an individual bit is 1 or 0 in an operand.</li>
<li value="20">Convert the following expressions to assembly language (assume all variables are signed 32-bit integers):
<pre><code>x = x + y
x = y – z
x = y * z
x = y + z * t
<span epub:type="pagebreak" title="376" id="Page_376"/>x = (y + z) * t
x = -((x * y) / z)
x = (y == z) &amp;&amp; (t != 0)</code></pre></li>
<li value="21">Compute the following expressions without using an <code>imul</code> or <code>mul</code> instruction (assume all variables are signed 32-bit integers):
<pre><code>x = x * 2
x = y * 5
x = y * 8</code></pre></li>
<li value="22">Compute the following expressions without using a <code>div</code> or <code>idiv</code> instruction (assume all variables are unsigned 16-bit integers):
<pre><code>x = x / 2
x = y / 8
x = z / 10</code></pre></li>
<li value="23">Convert the following expressions to assembly language by using the FPU (assume all variables are <code>real8</code> floating-point values):
<pre><code>x = x + y
x = y – z
x = y * z
x = y + z * t
x = (y + z) * t
x = -((x * y) / z)</code></pre></li>
<li value="24">Convert the following expressions to assembly language by using SSE instructions (assume all variables are <code>real4</code> floating-point values):
<pre><code>x = x + y
x = y – z
x = y * z
x = y + z * t</code></pre></li>
<li value="25">Convert the following expressions to assembly language by using FPU instructions; assume <code>b</code> is a one-byte Boolean variable and <code>x</code>, <code>y</code>, and <code>z</code> are <code>real8</code> floating-point variables:
<pre><code>b = x &lt; y
b = x &gt;= y &amp;&amp; x &lt; z</code></pre></li>
</ol>
<section class="footnotes">
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c06-footnote-1" href="#c06-footnoteref-1">1</a></sup>.  In two special cases, the operands are the same size. Those two instructions, however, aren’t especially useful.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c06-footnote-2" href="#c06-footnoteref-2">2</a></sup>.  This doesn’t turn out to be much of a limitation because sign extension almost always precedes an arithmetic operation that must take place in a register.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c06-footnote-3" href="#c06-footnoteref-3">3</a></sup>.  Zero-extending into DX:AX or EDX:EAX is just as necessary as the <span class="LiteralFootnote"><code>cwd</code></span> and <span class="LiteralFootnote"><code>cdq</code></span> instructions, as you will eventually see.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c06-footnote-4" href="#c06-footnoteref-4">4</a></sup>. You could also use <span class="LiteralFootnote"><code>movsx</code></span> to sign-extend AL into AX.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c06-footnote-5" href="#c06-footnoteref-5">5</a></sup>. But not in the same calculation, where guard digits could maintain the fourth digit during the calculation.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c06-footnote-6" href="#c06-footnoteref-6">6</a></sup>. Of course, the drawback is that you must now perform two multiplications rather than one, so the result may be slower.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c06-footnote-7" href="#c06-footnoteref-7">7</a></sup>. Intel has also referred to this device as the <em>Numeric Data Processor (NDP)</em>, <em>Numeric Processor Extension</em> <em>(NPX)</em>, and <em>math coprocessor</em>.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c06-footnote-8" href="#c06-footnoteref-8">8</a></sup>. Often, programmers will create text equates for these register names to use the identifiers ST0 to ST7.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c06-footnote-9" href="#c06-footnoteref-9">9</a></sup>. This assumes, of course, that your calculations aren’t so complex that you exceed the eight-element limitation of the FPU stack.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c06-footnote-10" href="#c06-footnoteref-10">10</a></sup>. This book has typically used <em>scalar</em> to denote atomic (noncomposite) data types that were not floating-point (chars, Booleans, integers, and so forth). In fact, floating-point values (that are not part of a larger composite data type) are also scalars. Intel uses <em>scalar</em> as opposed to <em>vector</em> (the SSE also supports vector operations).</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c06-footnote-11" href="#c06-footnoteref-11">11</a></sup>. Intel’s documentation claims that the reciprocal operation is just an approximation. Then again, by definition, the square root operation is also an approximation because it produces irrational results.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c06-footnote-12" href="#c06-footnoteref-12">12</a></sup>. Also an approximation.</p></aside>
</section>
</section>
</body></html>