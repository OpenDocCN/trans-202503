["```\nbool IsRemoteDebuggerPresent() {\n    BOOL dbg = false;\n    CheckRemoteDebuggerPresent(GetCurrentProcess(), &dbg);\n    return dbg;\n}\n```", "```\ninline bool Has2DBreakpointHandler() {\n    __try { __asm INT 0x2D }\n    __except (EXCEPTION_EXECUTE_HANDLER){ return false; }\n    return true;\n}\n\ninline bool Has03BreakpointHandler() {\n    __try { __asm INT 0x03 }\n    __except (EXCEPTION_EXECUTE_HANDLER){ return false; }\n    return true;\n}\n```", "```\nbool HasHardwareBreakpoints() {\n    CONTEXT ctx = {0};\n    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;\n    auto hThread = GetCurrentThread();\n    if(GetThreadContext(hThread, &ctx) == 0)\n        return false;\n    return (ctx.Dr0 != 0 || ctx.Dr1 != 0 || ctx.Dr2 != 0 || ctx.Dr3 != 0);\n}\n```", "```\ninline bool CanCallOutputDebugString() {\n    SetLastError(0);\n    OutputDebugStringA(\"test\");\n    return (GetLastError() == 0);\n}\n```", "```\n#define DBG_RIPEXCEPTION 0x40010007\ninline bool hasRIPExceptionHandler() {\n    __try { RaiseException(DBG_RIPEXCEPTION, 0, 0, 0); }\n    __except(EXCEPTION_EXECUTE_HANDLER){ return false; }\n    return true;\n}\n```", "```\n--snip--\nauto startTime = GetTickCount();\nprotectMemory<>(...);\nif (GetTickCount() - startTime >= 100)\n    debuggerDetectedGoConfuseIt();\n--snip--\n```", "```\nbool DebuggerDriversPresent() {\n    // an array of common debugger driver device names\n    const char drivers[9][20] = {\n        \"\\\\\\\\.\\\\EXTREM\", \"\\\\\\\\.\\\\ICEEXT\",\n        \"\\\\\\\\.\\\\NDBGMSG.VXD\", \"\\\\\\\\.\\\\RING0\",\n        \"\\\\\\\\.\\\\SIWVID\", \"\\\\\\\\.\\\\SYSER\",\n        \"\\\\\\\\.\\\\TRW\", \"\\\\\\\\.\\\\SYSERBOOT\",\n        \"\\0\"\n    };\n    for (int i = 0; drivers[i][0] != '\\0'; i++) {\n        auto h = CreateFileA(drivers[i], 0, 0, 0, OPEN_EXISTING, 0, 0);\n        if (h != INVALID_HANDLE_VALUE) {\n            CloseHandle(h);\n            return true;\n        }\n    }\n    return false;\n}\n```", "```\nOutputDebugString(\"%s%s%s%s\");\n```", "```\nvoid SelfDestruct() {\n    std::vector<char*> explosion;\n    while (true)\n        explosion.push_back(new char[10000]);\n}\n```", "```\n#include <random>\ntypedef void (* _recurse)();\nvoid recurse1(); void recurse2();\nvoid recurse3(); void recurse4();\nvoid recurse5();\n_recurse recfuncs[5] = {\n    &recurse1, &recurse2, &recurse3,\n    &recurse4, &recurse5\n};\nvoid recurse1() { recfuncs[rand() % 5](); }\nvoid recurse2() { recfuncs[(rand() % 3) + 2](); }\nvoid recurse3() {\n    if (rand() % 100 < 50) recurse1();\n    else recfuncs[(rand() % 3) + 1]();\n}\nvoid recurse4() { recfuncs[rand() % 2](); }\nvoid recurse5() {\n    for (int i = 0; i < 100; i++)\n        if (rand() % 50 == 1)\n            recfuncs[i % 5]();\n    recurse5();\n}\n// call any of the above functions to trigger a stack overflow\n```", "```\nvoid BSODBaby() {\n    typedef long (WINAPI *RtlSetProcessIsCritical)\n        (BOOLEAN New, BOOLEAN *Old, BOOLEAN NeedScb);\n    auto ntdll = LoadLibraryA(\"ntdll.dll\");\n    if (ntdll) {\n        auto SetProcessIsCritical = (RtlSetProcessIsCritical)\n            GetProcAddress(ntdll, \"RtlSetProcessIsCritical\");\n        if (SetProcessIsCritical)\n            SetProcessIsCritical(1, 0, 0);\n    }\n}\n\nBSODBaby();\nexit(1);\n```", "```\nBSODBaby();\nOutputDebugString(\"%s%s%s%s\");\nrecurse1();\nexit(1);\n```", "```\n   NTSTATUS onNtQueryVirtualMemory(\n       HANDLE process, PVOID baseAddress,\n       MEMORY_INFORMATION_CLASS memoryInformationClass,\n       PVOID buffer, ULONG numberOfBytes, PULONG numberOfBytesRead) {\n\n       // if the scan is on this process, make sure it can't see the hook DLL\n       if ((process == INVALID_HANDLE_VALUE ||\n           process == GetCurrentProcess()) &&\n           baseAddress >= MY_HOOK_DLL_BASE &&\n           baseAddress <= MY_HOOK_DLL_BASE_PLUS_SIZE)\n➊             return STATUS_ACCESS_DENIED;\n\n       // if the scan is on the bot, zero the returned memory\n       auto ret = origNtQueryVirtualMemory(\n           process, baseAddress,\n           memoryInformationClass,\n           buffer, numberOfBytes, numberOfBytesRead);\n       if(GetProcessId(process) == MY_BOT_PROCESS)\n➋         ZeroMemory(buffer, numberOfBytesRead);\n       return ret;\n   }\n```", "```\nvoid onGetSystemTimeAsFileTime(LPFILETIME systemTimeAsFileTime) {\n    myBot->hideUI(2000); // hide UI for 2 seconds\n    origGetSystemTimeAsFileTime(systemTimeAsFileTime);\n}\n```", "```\nNTSTATUS onNtQueryVirtualMemory(\n    HANDLE process, PVOID baseAddress,\n    MEMORY_INFORMATION_CLASS memoryInformationClass,\n    PVOID buffer, ULONG numberOfBytes, PULONG numberOfBytesRead) {\n\n    auto ret = origNtQueryVirtualMemory(\n        process, baseAddress,\n        memoryInformationClass,\n        buffer, numberOfBytes, numberOfBytesRead);\n    // place tricky code somewhere in here\n    return ret;\n}\n```", "```\n   // is the scan on the current process?\n   bool currentProcess =\n       process == INVALID_HANDLE_VALUE ||\n       process == GetCurrentProcess();\n\n   // is the hook in the memory range being scanned?\n   auto endAddress = baseAddress + numberOfBytesRead - 1;\n   bool containsHook =\n       (HOOK_START_ADDRESS >= baseAddress &&\n        HOOK_START_ADDRESS <= endAddress) ||\n       (HOOK_END_ADDRESS >= baseAddress &&\n        HOOK_END_ADDRESS <= endAddress);\n➊ if (currentProcess && containsHook) {\n       // hide the hook\n   }\n```", "```\nint readStart, writeStart;\nif (HOOK_START_ADDRESS >= baseAddress) {\n    readStart = 0;\n    writeStart = HOOK_START_ADDRESS - baseAddress;\n} else {\n    readStart = baseAddress - HOOK_START_ADDRESS;\n    writeStart = baseAddress;\n}\n\nint readEnd;\nif (HOOK_END_ADDRESS <= endAddress)\n    readEnd = HOOK_LENGTH - readStart - 1;\nelse\n    readEnd = endAddress – HOOK_START_ADDRESS;\n```", "```\nchar* replaceBuffer = (char*)buffer;\nfor ( ; readStart <= readEnd; readStart++, writeStart++)\n    replaceBuffer[writeStart] = HOOK_ORIG_DATA[readStart];\n```", "```\nNTSTATUS onNtQueryVirtualMemory(\n    HANDLE process, PVOID baseAddress,\n    MEMORY_INFORMATION_CLASS memoryInformationClass,\n    PVOID buffer, ULONG numberOfBytes, PULONG numberOfBytesRead) {\n    auto ret = origNtQueryVirtualMemory(\n        process, baseAddress,\n        memoryInformationClass,\n        buffer, numberOfBytes, numberOfBytesRead);\n    bool currentProcess =\n        process == INVALID_HANDLE_VALUE ||\n        process == GetCurrentProcess();\n    auto endAddress = baseAddress + numberOfBytesRead - 1;\n    bool containsHook =\n        (HOOK_START_ADDRESS >= baseAddress &&\n         HOOK_START_ADDRESS <= endAddress) ||\n        (HOOK_END_ADDRESS >= baseAddress &&\n         HOOK_END_ADDRESS <= endAddress);\n    if (currentProcess && containsHook) {\n        int readStart, writeStart;\n        if (HOOK_START_ADDRESS >= baseAddress) {\n            readStart = 0;\n            writeStart = HOOK_START_ADDRESS - baseAddress;\n        } else {\n            readStart = baseAddress - HOOK_START_ADDRESS;\n            writeStart = baseAddress;\n        }\n\n        int readEnd;\n        if (HOOK_END_ADDRESS <= endAddress)\n            readEnd = HOOK_LENGTH - readStart - 1;\n        else\n            readEnd = endAddress – HOOK_START_ADDRESS;\n\n        char* replaceBuffer = (char*)buffer;\n        for ( ; readStart <= readEnd; readStart++, writeStart++)\n            replaceBuffer[writeStart] = HOOK_ORIG_DATA[readStart];\n    }\n    return ret;\n}\n```", "```\n// copy and load ntdll\ncopyFile(\"ntdll.dll\", \"ntdll_copy.dll\");\nauto module = LoadLibrary(\"ntdll_copy.dll\");\n\n// dynamically import NtWriteVirtualMemory\ntypedef NTSTATUS (WINAPI* _NtWriteVirtualMemory)\n    (HANDLE, PVOID, PVOID, ULONG, PULONG);\nauto myWriteVirtualMemory = (_NtWriteVirtualMemory)\n    GetProcAddress(module, \"NtWriteVirtualMemory\");\n\n// call NtWriteVirtualMemory\nmyWriteVirtualMemory(process, address, data, length, &writtenlength);\n```"]