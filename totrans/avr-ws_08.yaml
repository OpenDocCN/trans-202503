- en: '[8](nsp-boxall502581-0008.xhtml#rch08)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Controlling Motors with Mosfets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/nsp-boxall502581-ct.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'AVRs cannot directly control motors. In order to enable this, we need to use
    external components: *metal-oxide-semiconductor field-effect transistors (MOSFETs)*
    , transistors that can switch or amplify voltages in circuits.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: • Use PWM with MOSFETs to control DC motors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Use MOSFETs to control larger currents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Use motor driver ICs to interface larger motors with your AVR microcontrollers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along the way, you’ll build a temperature-controlled fan and a two-wheel-drive
    robot vehicle, building on prior knowledge to complete more interesting and complex
    projects. By the end of the chapter, you’ll have the skills to begin using MOSFETs
    in your own projects both for fun and for more serious applications, such as robotics,
    automation, or toys.
  prefs: []
  type: TYPE_NORMAL
- en: '[The MOSFET](nsp-boxall502581-0008.xhtml#rah1001)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use MOSFETs when we need to control large currents and voltage using a small
    signal, such as that from a microcontroller’s digital output pin. MOSFETs are
    available in various sizes, such as those shown in [Figure 8-1](nsp-boxall502581-0018.xhtml#f08001)
    , to match different projects’ requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of four different MOSFETs](images/nsp-boxall502581-f08001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-1 : Various MOSFETs'
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the small 2N7000 version shown at the bottom left in [Figure
    8-1](nsp-boxall502581-0018.xhtml#f08001) , which has three leads. When you’re
    looking at the front of the 2N7000—the flat-faced side—the pins are, from left
    to right, the source, gate, and drain pins (I’ll explain their functions momentarily).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-2](nsp-boxall502581-0018.xhtml#f08002) shows the schematic symbol
    for the 2N7000 MOSFET.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic symbol for the 2N7000 MOSFET](images/nsp-boxall502581-f08002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-2 : Schematic symbol for 2N7000 MOSFET'
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to operate a MOSFET. When you apply a small current to the gate pin,
    a large current can flow in through the drain pin and out through the source pin.
    You can also connect a PWM signal to the gate pin of a MOSFET, allowing you to
    control lights, motors, and more in various ways. That’s what we’ll focus on in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Our 2N7000 MOSFET can handle up to 60 V DC at 200 mA continuously, or 500 mA
    in bursts. When choosing a MOSFET for your projects, be sure to check the voltage
    and current maximums against the signal you want to switch.
  prefs: []
  type: TYPE_NORMAL
- en: We connect a 10 kΩ resistor between the MOSFET’s gate and the source pin every
    time we use a MOSFET, as you’ll see in the following project. This acts to keep
    the gate switched off when a current is not applied to it, in the same way a resistor
    pulls down a button, as shown in [Chapter 3](nsp-boxall502581-0013.xhtml#ch03)
    ; it stops the MOSFET from turning slightly on or off at random.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 34: DC Motor Control with PWM and MOSFET](nsp-boxall502581-0008.xhtml#rpro34)'
  prefs: []
  type: TYPE_NORMAL
- en: This project demonstrates how to control a small DC motor using PWM and a MOSFET.
    As the microcontroller cannot provide enough current for the motor on its own,
    we use an external power supply and a MOSFET to handle the motor’s requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1001)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this project, you’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Small DC motor and matching power
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 2N7000 MOSFET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 10 kΩ resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A small DC motor model like the one shown in [Figure 8-3](nsp-boxall502581-0018.xhtml#f08003)
    with a maximum of 12 V DC will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of a small DC motor](images/nsp-boxall502581-f08003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-3 : Small DC motor'
  prefs: []
  type: TYPE_NORMAL
- en: You will also need external power, such as a battery pack that holds several
    AA cells. A 6 AA cell pack like the one shown in [Figure 8-4](nsp-boxall502581-0018.xhtml#f08004)
    will provide up to 9 V DC, enough power to run a 12 V DC motor nicely.
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of six AA cells in a battery holder for a 9 V supply](images/nsp-boxall502581-f08004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-4 : AA battery pack'
  prefs: []
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 8-5](nsp-boxall502581-0018.xhtml#f08005)
    . Note that the black/negative lead from the battery pack will be connected to
    GND.
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 34](images/nsp-boxall502581-f08005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-5 : Schematic for [Project 34](nsp-boxall502581-0018.xhtml#pro34)'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t disassemble the circuit once you’ve finished using it, as you will use
    it as part of the circuit in the [following project](nsp-boxall502581-0018.xhtml#pro35)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1002)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 34* subfolder of this book’s
    *Chapter 8* folder, and enter the command `make flash` . The DC motor should start
    from 0, increase speed to a complete on state, then reduce speed back to a complete
    off state, then repeat the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be familiar with the code used in this project by now as you learned
    about using PWM in [Chapter 7](nsp-boxall502581-0017.xhtml#ch07) , but let’s go
    through it together. First, we set the required registers to initialize PWM operation
    ❷. To make control easier, we use three functions: `motorOn()` , `motorOff()`
    , and `motorPWM()` . The `motorOn()` function turns the motor completely on by
    first disconnecting PORTB1 from PWM ❸ and then setting it to high. This gives
    100 percent power to the motor via the MOSFET at all times.'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `motorOff()` function to completely turn the motor off by disconnecting
    PORTB1 from PWM ❹ and setting it to low. This turns off the MOSFET gate pin, so
    the motor has no power. Again, this is necessary as you can’t send a 0 percent
    duty cycle to the OCR1A register and expect it to be off 100 percent of the time.
    Even with a duty cycle of 0 percent, every time the hardware timer resets the
    output is turned on briefly during the reset.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the function `motorPWM()` , which accepts the required duty cycle value,
    is used to set the motor speed with PWM. It connects PORTB1 to PWM ❺ and then
    loads the OCR1A register with the required value.
  prefs: []
  type: TYPE_NORMAL
- en: Our main code repeatedly turns the motor on and increases the speed to 100 percent,
    then reduces the speed back to 0, then turns the motor off for 3 seconds. We turn
    the motor off at the start of the code, to allow the end user a moment’s notice
    before spinning it up. You can change the delay time in the PWM loops by altering
    the value of `wait` ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to control a DC motor, let’s apply this skill to a practical
    example by building a temperature-controlled fan system.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 35: Temperature-Controlled Fan](nsp-boxall502581-0008.xhtml#rpro35)'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll combine your existing knowledge of motor control with
    your newfound MOSFET skills, using temperature sensors to make a temperature-controlled
    fan.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1003)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this project, you’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Small DC motor and matching power
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 2N7000 MOSFET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • TMP36 temperature sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 0.1 μF ceramic capacitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 10 kΩ resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the small DC motor from the [previous project](nsp-boxall502581-0018.xhtml#pro34)
    just to see how this works, or you can pick up a DC motor–powered cooling fan
    from an electrical retailer, such as the unit from PMD Way (part number 59119182)
    shown in [Figure 8-6](nsp-boxall502581-0018.xhtml#f08006) . Some fans may have
    four wires, but only two of these are required (power and GND). Once again, we’ll
    need to use external power for the fan.
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of a small cooling fan](images/nsp-boxall502581-f08006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-6 : DC cooling fan'
  prefs: []
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 8-7](nsp-boxall502581-0018.xhtml#f08007)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 35](images/nsp-boxall502581-f08007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-7 : Schematic for [Project 35](nsp-boxall502581-0018.xhtml#pro35)'
  prefs: []
  type: TYPE_NORMAL
- en: As you assemble the project, note that the black/negative lead from the battery
    pack or fan power supply will be connected to GND. Also, don’t forget to connect
    AV [CC] to 5 V.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1004)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 35* subfolder of this book’s
    *Chapter 8* folder, and enter the command `make flash` . Once you’ve applied power,
    the project should wait three seconds before taking the temperature and operating
    the fan, depending on the current temperature.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code builds upon the ADC and temperature sensor from [Project 19](nsp-boxall502581-0014.xhtml#pro19)
    in [Chapter 4](nsp-boxall502581-0014.xhtml#ch04) and the PWM motor control used
    in [Project 34](nsp-boxall502581-0018.xhtml#pro34) . First, we activate the ADC
    to read the TMP36 temperature sensor and activate PWM for variable-speed motor
    control ❶ (the `startADC()` and `initPWM()` functions are defined at the beginning
    of the program). We introduce the variables required to calculate the temperature
    for the thermostat ❷, and then we introduce a delay at startup so the motor doesn’t
    jump into life straight after a reset or power-up ❸.
  prefs: []
  type: TYPE_NORMAL
- en: In the main loop, we take the value from the ADC ❹ and convert it to degrees
    Celsius ❺. The code can now use this temperature value to determine whether to
    operate the motor. In this project, the motor is switched off if the temperature
    is below 25 degrees ❻. If the temperature is between 25 and 34 degrees inclusive,
    the fan runs at half speed ❼. If the temperature is 35 degrees or over, the fan
    runs at full speed ❽.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after checking the temperature, there is a short delay ❾ to avoid *hysteresis*
    —that is, rapid changes in the characteristics of the circuit. For example, if
    the sensor were in the path of a breeze or a fluttering curtain, the temperature
    might fluctuate rapidly between 24.99 and 25 degrees, causing the motor to turn
    continuously on and off. The delay allows us to avoid this.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, I hope you’re beginning to see how we can combine basic AVR code
    and tools to solve new problems. Building on prior knowledge, we’ve started to
    move beyond the simpler projects in earlier chapters to more complex, practical
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve experimented with basic motor control using the MOSFET, we’ll
    move on to controlling the direction of rotation as well as the speed of a DC
    motor. To do this, we’ll use the L293D motor driver IC.
  prefs: []
  type: TYPE_NORMAL
- en: '[The L293D Motor Driver IC](nsp-boxall502581-0008.xhtml#rah1002)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To control the speed and direction of one or two small DC motors, we’ll use the
    L293D motor driver IC from STMicroelectronics, shown in [Figure 8-8](nsp-boxall502581-0018.xhtml#f08008)
    . This is in the same type of package as a microcontroller, and thus we can easily
    use it in a solderless breadboard for experimenting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of the L293D motor driver IC](images/nsp-boxall502581-f08008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-8 : L293D motor driver IC'
  prefs: []
  type: TYPE_NORMAL
- en: You can use small motor driver ICs like the L293D for robotics or small toys
    that run from 4.5 to 36 V DC at up to 600 mA, with some restrictions with regard
    to heat that I’ll explain later. The L293D saves you a lot of time, as it takes
    care of distributing power to the motors and spares you from building a bunch
    of external circuitry. It is known as an *H-BRIDGE IC* because it has an internal
    circuit of MOSFETs and other components configured in the shape of the letter
    H, as shown in [Figure 8-9](nsp-boxall502581-0018.xhtml#f08009) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Internal block diagram for the L293D motor driver IC](images/nsp-boxall502581-f08009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-9 : L293D IC block diagram'
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, we don’t need to build the L293D IC’s circuitry ourselves; it’s
    already set up and ready for us to connect the motors, control logic, and power.
    Instead, we just connect motors, power, GND, and outputs from a microcontroller.
    To see how to wire up the L293D to one DC motor, take a look at the pinouts in
    [Figure 8-10](nsp-boxall502581-0018.xhtml#f08010) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Pinouts for the L293D motor driver IC](images/nsp-boxall502581-f08010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-10 : L293D IC pinouts'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four GND pins: 4, 5, 12, and 13\. Connect those to GND. Next, locate
    the two power pins. Connect the first one—V [CC] 1, which is the logic (or control)
    power pin—to the 5 V, as you did with your microcontroller in our earlier projects.
    Then connect the second power pin, V [CC] 2, to the positive of the motor power
    supply (up to 36 V DC). Finally, connect the motor: one wire to pin 3 and the
    other to pin 6.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Controlling the motor requires three signals from digital outputs on our microcontroller.
    First, we set the ENABLE pin: either to high, so that the driver IC sends power
    to the motor, or to low, so that the motor stops. The signals from the next two
    pins, 1A and 2A, control the polarity of the power to the motor, and thus the
    rotational direction. With ENABLE set high, the motor will rotate in one direction
    with 1A high and 2A low and rotate in the other direction with 1A low and 2A high.
    [Table 8-1](nsp-boxall502581-0018.xhtml#tab0801) summarizes all this for easy
    reference.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table 8-1 : L293D Single Motor Control |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| ENABLE pin/EN1 (pin 1) | 1A pin/out 1 (pin 2) | 2A pin/out 2 (pin 7) | Motor
    action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| High | High | Low | Forward |'
  prefs: []
  type: TYPE_TB
- en: '| High | Low | High | Backward |'
  prefs: []
  type: TYPE_TB
- en: '| Low | High or Low | High or Low | Stop |'
  prefs: []
  type: TYPE_TB
- en: There’s no way to tell from the outside whether your motor will run forward
    or backward; you will need to do a test run to determine which of the two 1A/2A
    combinations is which for your motor. You can alter the speed of the motor by
    applying a PWM signal to the ENABLE pin.
  prefs: []
  type: TYPE_NORMAL
- en: A Few Words about Heat
  prefs: []
  type: TYPE_NORMAL
- en: The L293D can become warm (or hot) when running toward the higher end of its
    capacity. It shouldn’t be used in a solderless breadboard in these situations,
    as the four GND pins are also used as a heatsink. This means they might melt the
    plastic around the pins, leaving the L293D stuck in the breadboard. If you’re
    going to control larger motors, build your circuit using your own PCB, use a breakout
    board for the motor control, or solder the circuit onto a stripboard.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’re familiar with the theory of the L293D, let’s put it into practice
    in the [next project](nsp-boxall502581-0018.xhtml#pro36) .
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 36: DC Motor Control with L293D](nsp-boxall502581-0008.xhtml#rpro36)'
  prefs: []
  type: TYPE_NORMAL
- en: This project demonstrates how you can control a small DC motor using PWM and
    the L293D motor driver IC, operating the motor in either direction and at various
    speeds. This will give you the remaining skills you need to build your first moving
    robot vehicle in the [next project](nsp-boxall502581-0018.xhtml#pro37) .
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1005)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this project, you’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Small DC motor and matching power
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • L293D motor driver IC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the same DC motor and matching power supply you used for [Project 34](nsp-boxall502581-0018.xhtml#pro34)
    . Assemble the circuit as shown in [Figure 8-11](nsp-boxall502581-0018.xhtml#f08011)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 36](images/nsp-boxall502581-f08011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-11 : Schematic for [Project 36](nsp-boxall502581-0018.xhtml#pro36)'
  prefs: []
  type: TYPE_NORMAL
- en: As you assemble the circuit, connect the black/negative lead from the battery
    pack or external power to GND once again.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1006)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 36* subfolder of this book’s
    *Chapter 8* folder, and enter the command `make flash` . Once you’ve applied power,
    the project should wait three seconds before operating the motor at two different
    speeds successively, both forward and backward.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code builds on that of previous motor control projects in this chapter,
    with the required additions for the L293D. We set up PWM at points ❶ and ❽. The
    first of the motor control functions, `motorForward()` ❷, rotates the motor in
    one direction and accepts a duty cycle value of between 1 and 255\. Per [Table
    8-1](nsp-boxall502581-0018.xhtml#tab0801) , we set the outputs as high and low
    for motor directional control ❸. The code then checks if the required duty cycle
    value is 255 ❹, and if so simply switches the ENABLE pin to high for full-speed
    motor running instead of using PWM. However, if it’s less than 255, then PWM is
    enabled for the output pin controlling the L293D ENABLE pin ❺ and the required
    duty cycle value is dropped into OCR2A.
  prefs: []
  type: TYPE_NORMAL
- en: The motor control method used in `motorForward()` is repeated with the function
    `motorBackward()` ❻, except with the outputs for motor control set to low and
    high for reverse rotation. Finally, the `motorOff()` function ❼ turns off the
    motor by first disabling PWM for the output pin controlling the L293D ENABLE pin
    and then setting it to low. With all this complete, you can now use the motor
    control functions to control the speed and direction of motor rotation, as demonstrated
    in the main loop of the code ❾.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to control the speed and direction of a DC motor, let’s
    use two motors to control a small robot vehicle.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 37: Controlling a Two-Wheel-Drive Robot Vehicle](nsp-boxall502581-0008.xhtml#rpro37)'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll learn to control a small two-wheel-drive robot vehicle.
    The suggested hardware includes two DC motors and a *castor* (a small, swiveling
    wheel fixed to the bottom of your robot vehicle), allowing you to easily control
    the speed and direction of travel. I hope this inspires you to create your own
    more complex robotic creations!
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1007)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this project, you’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two small DC motors and matching power
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 2WD robot vehicle chassis (such as PMD Way part number 72341119)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Four AA battery cells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 1N4004 power diode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • L293D motor driver IC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chassis
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The foundation of any robot vehicle is a solid chassis containing the motors,
    drivetrain, and power supply. You can choose from many chassis models available
    on the market. To keep things simple, this project relies on an inexpensive robot
    chassis with two small DC motors that operate at around 6 V DC and two matching
    wheels, as shown in [Figure 8-12](nsp-boxall502581-0018.xhtml#f08012) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of a two-wheel-drive robot chassis with motors, wheels, and battery
    holder](images/nsp-boxall502581-f08012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-12 : Two-wheel-drive robot vehicle chassis (PMD Way part number 72341119)'
  prefs: []
  type: TYPE_NORMAL
- en: The task of physically assembling the robot chassis varies between models, but
    most require a few additional tools beyond those included in the kit, such as
    screwdrivers. If you haven’t settled on a final design and wish to get your robot
    moving in a temporary configuration, you can attach the electronics to the chassis
    with a reusable putty adhesive like Blu-Tack.
  prefs: []
  type: TYPE_NORMAL
- en: The Power Supply
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The motors included with the robot chassis typically operate at around 6 V DC,
    so we’ll use the 4 AA cell battery holder included with the example chassis in
    [Figure 8-12](nsp-boxall502581-0018.xhtml#f08012) . We can’t use 6 V to power
    the microcontroller circuit, so we place a 1N4004 diode between the power supply
    positive and the 5 V connection on the microcontroller. The diode will cause a
    0.7 V drop in voltage, bringing the microcontroller supply to around 5.3 V DC.
    The voltage will again drop as the battery life decreases.
  prefs: []
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 8-13](nsp-boxall502581-0018.xhtml#f08013)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 37](images/nsp-boxall502581-f08013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-13 : Schematic for [Project 37](nsp-boxall502581-0018.xhtml#pro37)'
  prefs: []
  type: TYPE_NORMAL
- en: Again, the black/negative lead from the battery pack or external power connects
    to GND, and the red/positive lead runs to both the L293D V [CC] 2 pin and the
    1N4004 diode.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1008)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 37* subfolder of this book’s
    *Chapter 8* folder, and enter the command `make flash` . Once you remove the AVR
    programmer and the vehicle starts up, it should wait three seconds before moving
    off forward and then turning left, right, and so on as directed by the sequence
    of functions in the main loop of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is the culmination of our experiments with DC motor control using
    the L293D motor controller IC and PWM. Let’s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: At ❶ and ❽, the code initiates PWM for two digital outputs so it can control
    two motors. After PWM initiation comes `moveForward()` , the first of five functions
    to control the motors. You might need to switch the wires on each motor if they
    appear to work opposite to the code. Four of these functions— `moveForward()`
    , `moveBackward()` , `moveLeft()` , and `moveRight()` —are identical, except in
    the order of motor rotation. They all accept a value for the duty cycle to control
    the speed of the motors. The function `motorsOff()` cuts the power off to both
    motors.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we set the direction of the motors forward by making digital outputs
    high or low, depending on required rotation type ❷. Refer to [Table 8-1](nsp-boxall502581-0018.xhtml#tab0801)
    for the requisite output configurations. The motor movement functions check if
    the user requires full speed (a duty cycle of 100 percent, represented by 255)
    ❸. If so, it simply sets the ENABLE pins of the L293D to on. However, if you pass
    a lower value for the duty cycle through a motor movement function, the program
    activates the PWM output to the ENABLE pins ❹ and fills the PWM registers OCR2A
    and B with the required duty cycle.
  prefs: []
  type: TYPE_NORMAL
- en: The other three movement functions operate similarly, except that the motor
    rotations are set up to allow for turning left or right or moving backward. The
    `motorsOff()` function stops movement by turning off PWM and setting both L293D
    ENABLE pins to low ❺. Finally, the program sets the six required pins to outputs
    to control the L293D ❻❼.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the functions used in the main loop of the code to change the direction
    of movement, the speed via the duty cycles, and the duration with the delay functions,
    and stop the motors when required.
  prefs: []
  type: TYPE_NORMAL
- en: We have used a single timer with two PWM outputs for both motors (OCR2A and
    OCR2B) so that they share the same PWM generation and will thus synchronize with
    each other. If you use two different timers for two motors that need to operate
    together, the PWM signals will differ slightly and the two motors will operate
    slightly differently from one other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have experimented with DC motors, in the [next chapter](nsp-boxall502581-0019.xhtml#ch09)
    we’ll examine another useful tool of the AVR system: the internal EEPROM.'
  prefs: []
  type: TYPE_NORMAL
