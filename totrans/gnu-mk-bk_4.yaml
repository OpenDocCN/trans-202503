- en: Chapter 4. Pitfalls and Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to deal with problems faced by makefile maintainers
    as projects get considerably larger. Tasks that seem easy with small makefiles
    become more difficult with large, sometimes recursive, `make` processes. As makefiles
    become more complex, it’s easy to run into problems with edge cases or sometimes
    poorly understood behavior of GNU `make`.
  prefs: []
  type: TYPE_NORMAL
- en: Here you’ll see a complete solution to the “recursive `make` problem,” how to
    overcome GNU `make`’s problems handling filenames that contain spaces, how to
    deal with cross-platform file paths, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'GNU make Gotcha: ifndef and ?='
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s easy to get tripped up by the two ways of checking whether a variable is
    defined, `ifndef` and `?=`, because they do similar things, yet one has a deceptive
    name. `ifndef` doesn’t really test whether a variable is defined; it only checks
    that the variable is not empty, whereas `?=` does make its decision based on whether
    the variable is defined or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare these two ways of conditionally setting the variable `FOO` in a makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: They look like they should do the same thing, and they do, well, almost.
  prefs: []
  type: TYPE_NORMAL
- en: What ?= Does
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `?=` operator in GNU `make` sets the variable mentioned on its left side
    to the value on the right side if the left side is not defined. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This makefile sets `FOO` to `New Value`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the following one does not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Neither does this one (even though `FOO` was initially empty):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, `?=` is the same as the following makefile, which uses the GNU `make
    $(origin)` function to determine whether a variable is undefined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`$(origin FOO)` will return a string that shows whether and how `FOO` is defined.
    If `FOO` is undefined, then `$(origin FOO)` is the string `undefined`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that variables defined with `?=` are expanded, just like variables defined
    with the `=` operator. They are expanded when used but not when defined, just
    like a normal GNU `make` variable.
  prefs: []
  type: TYPE_NORMAL
- en: What ifndef Does
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned earlier, `ifndef` tests whether a variable is empty but does not
    check to see whether the variable is defined. `ifndef` means *if the variable
    is undefined or is defined but is empty*. Thus, this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'will set `FOO` to the `New Value` if `FOO` is undefined or `FOO` is empty.
    So `ifndef` can be rewritten as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: because an undefined variable is always treated as having an empty value when
    read.
  prefs: []
  type: TYPE_NORMAL
- en: $(shell) and := Go Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The suggestion in this section often speeds up makefiles with just the addition
    of a suitably placed colon. To understand how a single colon can make such a difference,
    you need to understand GNU `make`’s `$(shell)` function and the difference between
    `=` and `:=`.
  prefs: []
  type: TYPE_NORMAL
- en: $(shell) Explained
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`$(shell)` is GNU `make`’s equivalent of the backtick (`` ` ``) operator in
    the shell. It executes a command, flattens the result (turns all whitespace, including
    new lines, into spaces), and returns the resulting string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to get the output of the `date` command into a variable
    called `NOW`, you write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to count the number of files in the current directory and get that
    number into `FILE_COUNT`, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `$(shell)` flattens output to get the names of all the files in the
    current directory into a variable, the following works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The newline between files is replaced with a single space, making `FILES` a
    space-separated list of filenames.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common to see an execution of the `pwd` command to get the current working
    directory into a variable (in this case `CWD`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We’ll look at the `pwd` command later when considering how to optimize an example
    makefile that wastes time getting the working directory over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: The Difference Between = and :=
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ninety-nine percent of the time, you’ll see variable definitions in makefiles
    that use the `=` form, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, variables `FOO`, `BAR`, and `FOOBAR` are *recursively expanded* variables.
    That means that when the value of a variable is needed, any variables that it
    references are expanded at that point. For example, if the value of `$(FOOBAR)`
    is needed, GNU `make` gets the value of `$(FOO)` and `$(BAR)`, puts them together
    with the space in between, and returns `foo bar`. Expansion through as many levels
    of variables as necessary is done when the variable is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this makefile `FOOBAR` has two different values. Running it prints out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The value of `FOOBAR` is used to define the list of prerequisites to the `all`
    rule and is expanded as `foo bar`; the same thing happens for the next rule ➊,
    which defines rules for `foo` and `bar`.
  prefs: []
  type: TYPE_NORMAL
- en: But when the rules are *run*, the value of `FOOBAR` as used in the `echo` produces
    `fooey barney`. (You can verify that the value of `FOOBAR` was `foo bar` when
    the rules were defined by looking at the value of `$@`, the target being built,
    when the rules are run).
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind the following two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: When a rule is being defined in a makefile, variables will evaluate to their
    value *at that point* in the makefile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Variables used in recipes (that is, in the commands) have the final value:
    whatever value the variable had at the end of the makefile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the definition of `FOOBAR` is changed to use a `:=` instead of `=`, running
    the makefile produces a very different result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now `FOOBAR` has the same value everywhere. This is because `:=` forces the
    right side of the definition to be expanded at that moment during makefile parsing.
    Rather than storing `$(FOO) $(BAR)` as the definition of `FOOBAR`, GNU `make`
    stores the expansion of `$(FOO) $(BAR)`, which at that point is `foo bar`. The
    fact that `FOO` and `BAR` are redefined later in the makefile is irrelevant; `FOOBAR`
    has already been expanded and set to a fixed string. GNU `make` refers to variables
    defined in this way as *simply expanded*.
  prefs: []
  type: TYPE_NORMAL
- en: Once a variable has become simply expanded, it remains that way unless it is
    redefined using the `=` operator. This means that when text is appended to a simply
    expanded variable, it is expanded before being added to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: results in `FOOBAR` being `foo bar baz`. If `=` had been used instead of `:=`,
    when `$(BAZ)` was appended, it would not have been expanded and the resulting
    `FOOBAR` would have been `foo baz bazzy`.
  prefs: []
  type: TYPE_NORMAL
- en: The Hidden Cost of =
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at this example makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It gets the current working directory into `CWD`, defines a source and object
    directory as subdirectories of the `CWD`, defines a set of objects (`foo.o`, `bar.o`,
    and `baz.o`) to be built in the `OBJ_DIR`, sets up a pattern rule showing how
    to build a `.o` from a `.c`, and finally states that by default the makefile should
    build all the objects and print out a list of those that were out of date (`$?`
    is the list of prerequisites of a rule that were out of date) as well as a full
    list of objects.
  prefs: []
  type: TYPE_NORMAL
- en: You might be surprised to learn that this makefile ends up making eight shell
    invocations just to get the `CWD` value. Imagine how many times GNU `make` would
    make costly calls to the shell in a real makefile with hundreds or thousands of
    objects!
  prefs: []
  type: TYPE_NORMAL
- en: 'So many calls to `$(shell)` are made because the makefile uses recursively
    expanded variables: variables whose value is determined when the variable is used
    but not at definition time. `OBJS` references `OBJ_DIR` three times, which references
    `CWD` each time; every time `OBJS` is referenced, three calls are made to `$(shell
    pwd)`. Any other reference to `SRC_DIR` or `OBJ_DIR` (for example, the pattern
    rule definition) results in another `$(shell pwd)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But a quick fix for this is just to change the definition of `CWD` to simply
    expand by inserting a `:` to turn `=` into `:=`. Because the working directory
    doesn’t change during the `make`, we can safely get it once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, a single call out to the shell is made to get the working directory. In
    a real makefile this could be a huge time-saver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because it can be difficult to follow through a makefile to see everywhere
    a variable is used, you can use a simple trick that will cause `make` to print
    out the exact line at which a variable is expanded. Insert `$(warning Call to
    shell)` in the definition of `CWD` so that its definition becomes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you get the following output when you run `make`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `$(warning)` doesn’t change the value of `CWD`, but it does output a message
    to `STDERR`. From the output you can see the eight calls to the shell and which
    lines in the makefile caused them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `CWD` is defined using `:=`, the `$(warning)` trick verifies that `CWD`
    is expanded only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick way to determine if a makefile uses the expensive combination of `=`
    and `$(shell)` is to run the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This prints out the line number and details of every line in the makefile that
    contains a `$(shell)` and doesn’t contain a `:=`.
  prefs: []
  type: TYPE_NORMAL
- en: $(eval) and Variable Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned how to use `:=` to speed up makefiles by
    not repeatedly performing a `$(shell)`. Unfortunately, it can be problematic to
    rework makefiles to use `:=` because they may rely on being able to define variables
    in any order.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to use GNU `make`’s `$(eval)` function to
    get the benefits of recursively expanded variables using `=` while getting the
    sort of speedup that’s possible with `:=`.
  prefs: []
  type: TYPE_NORMAL
- en: About $(eval)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`$(eval)`’s argument is expanded and then parsed as if it were typed in as
    part of a makefile. As a result, within a `$(eval)` (which could be inside a variable
    definition) you can programmatically define variables, create rules (explicit
    or pattern), include other makefiles, and so on. It’s a powerful function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This results in `FOO` having the value `BAR` and `A` having the value `B`. Obviously,
    this example could have been achieved without `$(eval)`, but it’s easy to see
    how you can use `$(eval)` to make programmatic changes to the definitions in a
    makefile.
  prefs: []
  type: TYPE_NORMAL
- en: An $(eval) Side Effect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One use of `$(eval)` is to create side effects. For example, here’s a variable
    that is actually an auto-incrementing counter (it uses the arithmetic functions
    from the GMSL):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time `counter` is used, its value is incremented by one. For example,
    the following sequence of `$(info)` functions outputs numbers in sequence starting
    from `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You could use a simple side effect like this to find out how often a particular
    variable is reevaluated by GNU `make`. You might be surprised at the result. For
    example, when building GNU `make`, the variable `srcdir` from its makefile is
    accessed 48 times; `OBJEXT` is accessed 189 times, and that’s in a very small
    project.
  prefs: []
  type: TYPE_NORMAL
- en: GNU `make` wastes time accessing an unchanging variable by looking at the same
    string repeatedly. If the variable being accessed is long (such as a long path)
    or contains calls to `$(shell)` or complex GNU `make` functions, the performance
    of variable handling could affect the overall runtime of a `make`.
  prefs: []
  type: TYPE_NORMAL
- en: That’s especially important if you are trying to minimize build time by parallelizing
    the `make` or if a developer is running an incremental build requiring just a
    few files to be rebuilt. In both cases a long startup time by GNU `make` could
    be very inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: Caching Variable Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GNU `make` does provide a solution to the problem of reevaluating a variable
    over and over again: use `:=` instead of `=`. A variable defined using `:=` gets
    its value set once and for all, the right side is evaluated once, and the resulting
    value is set in the variable. Using := can cause a makefile to be parsed more
    quickly because the right side is evaluated only once. But it does introduce limitations,
    so it is rarely used. One limitation is that it requires variable definitions
    to be ordered a certain way. For example, if ordered this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'the result in `FOO` would have a totally different value than if it was ordered
    this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the first snippet `FOO` is empty, and in the second `FOO` is `bar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrast that with the simplicity of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, `FOO` is `bar`. Most makefiles are written in this style, and only very
    conscientious (and speed conscious) makefile authors use `:=`.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, almost all of these recursively defined variables only ever
    have one value when used. The long evaluation time for a complex recursively defined
    variable is a convenience for the makefile author.
  prefs: []
  type: TYPE_NORMAL
- en: An ideal solution would be to cache variable values so the flexibility of the
    `=` style is preserved, but the variables are only evaluated once for speed. Clearly,
    this would cause a minor loss of flexibility, because a variable can’t take two
    different values (which is sometimes handy in a makefile). But for most uses,
    it would provide a significant speed boost.
  prefs: []
  type: TYPE_NORMAL
- en: Speed Improvements with Caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the example makefile in [Example 4-1](ch04.html#in_this_makefilecomma_foo_and_c_are_usel
    "Example 4-1. In this makefile, FOO and C are uselessly evaluated over and over
    again."):'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-1. In this makefile, `FOO` and `C` are uselessly evaluated over and
    over again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It defines a variable `C`, which is a long string (it’s actually `1234567890`
    repeated 2,048 times followed by the alphabet repeated 2,048 times plus spaces
    for a total of 77,824 characters). Here `:=` is used so that `C` is created quickly.
    `C` is designed to emulate the sort of long strings that are generated within
    makefiles (for example, long lists of source files with paths).
  prefs: []
  type: TYPE_NORMAL
- en: Then a variable `FOO` is defined that manipulates `C` using the built-in `$(subst)`
    function. `FOO` emulates the sort of manipulation that occurs within makefiles
    (such as changing filename extensions from `.c` to `.o`).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `$(FOO)` is evaluated 200 times to emulate the use of `FOO` in a small
    but realistically sized makefile. The makefile does nothing; there’s a dummy,
    empty `all` rule at the end.
  prefs: []
  type: TYPE_NORMAL
- en: On my laptop, using GNU `make` 3.81, this makefile takes about 3.1 seconds to
    run. That’s a long time spent repeatedly manipulating `C` and `FOO` but not doing
    any actual building.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `counter` trick from [An $(eval) Side Effect](ch04.html#dollarleft_parenthesisevalright-id00007
    "An $(eval) Side Effect"), you can figure out how many times `FOO` and `C` are
    evaluated in this makefile. `FOO` was evaluated 200 times and `C` 1600 times.
    It’s amazing how fast these evaluations can add up.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the values of `C` and `FOO` need to be calculated only once, because they
    don’t change. Let’s say you alter the definition of `FOO` to use `:=`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This drops the runtime to 1.8 seconds, `C` is evaluated nine times, and `FOO`
    is evaluated just once. But, of course, that requires using `:=` with all its
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: A Caching Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An alternative caching function is this simple caching scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: First, a function called `cache` is defined, which automatically caches a variable’s
    value the first time it is evaluated and retrieves it from the cache for each
    subsequent attempt to retrieve it.
  prefs: []
  type: TYPE_NORMAL
- en: '`cache` uses two variables to store the cached value of a variable (when caching
    variable `A`, the cached value is stored in `cache-A`) and whether the variable
    has been cached (when caching variable `A`, the *has been cached flag* is `cached-A`).'
  prefs: []
  type: TYPE_NORMAL
- en: First, it checks to see whether the variable has been cached; if it has, the
    `$(if)` does nothing. If it hasn’t, the cached flag is set for that variable in
    the first `$(eval)` and then the value of the variable is expanded (notice the
    `$($1)`, which gets the name of the variable and then gets its value) and cached.
    Finally, `cache` returns the value from cache.
  prefs: []
  type: TYPE_NORMAL
- en: To update the makefile, simply turn any reference to a variable into a call
    to the `cache` function. For example, you can modify the makefile from [Example 4-1](ch04.html#in_this_makefilecomma_foo_and_c_are_usel
    "Example 4-1. In this makefile, FOO and C are uselessly evaluated over and over
    again.") by changing all occurrences of `$(FOO)` to `$(call cache,FOO)` using
    a simple find and replace. The result is shown in [Example 4-2](ch04.html#modified_version_of_listing_4-1_that_use
    "Example 4-2. A modified version of Example 4-1 that uses the cache function").
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-2. A modified version of [Example 4-1](ch04.html#in_this_makefilecomma_foo_and_c_are_usel
    "Example 4-1. In this makefile, FOO and C are uselessly evaluated over and over
    again.") that uses the `cache function`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Running this on my machine shows that there’s now one access of `FOO`, the same
    nine accesses of `C`, and a runtime of 2.4 seconds. It’s not as fast as the `:=`
    version (which took 1.8 seconds), but it’s still 24 percent faster. On a big makefile,
    this technique could make a real difference.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fastest way to handle variables is to use `:=` whenever you can, but it
    requires care and attention, and is probably best done only in a new makefile
    (just imagine trying to go back and reengineer an existing makefile to use `:=`).
  prefs: []
  type: TYPE_NORMAL
- en: If you’re stuck with `=`, the `cache` function presented here can give you a
    speed boost that developers doing incremental short builds will especially appreciate.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it’s only necessary to change a single variable definition, it’s possible
    to eliminate the `cache` function. For example, here’s the definition of `FOO`
    changed to magically switch from being recursively defined to a simple definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first time `$(FOO)` is referenced, the `$(eval)` happens, turning `FOO`
    from a recursively defined variable to a simple definition (using `:=`). The `$(value
    FOO)` at the end returns the value stored in `FOO`, making this process transparent.
  prefs: []
  type: TYPE_NORMAL
- en: The Trouble with Hidden Targets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the makefile in [Example 4-3](ch04.html#in_this_makefilecomma_the_rule_to_make_f
    "Example 4-3. In this makefile, the rule to make foo also makes foo.c."):'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-3. In this makefile, the rule to make `foo` also makes `foo.c`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It contains a nasty trap for the unwary that can cause `make` to report odd
    errors, stop the `-n` option from working, and prevent a speedy parallel `make`.
    It can even cause GNU `make` to do the wrong work and update an up-to-date file.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the face of it this makefile looks pretty simple. If you run it through
    GNU `make`, it’ll build `foo` (which creates the files `foo` and `foo.c`) and
    then use the pattern at the bottom to make `foo.o` from `foo.c`. It ends up running
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: But there’s a fatal flaw. Nowhere does this makefile mention that the rule to
    make `foo` actually also makes `foo.c`. So `foo.c` is a *hidden target*, a file
    that was built but that GNU `make` is unaware of, and hidden targets cause an
    endless number of problems.
  prefs: []
  type: TYPE_NORMAL
- en: GNU `make` is very good at keeping track of targets, files that need to be built,
    and the dependencies between targets. But the `make` program is only as good as
    its inputs. If you don’t tell `make` about a relationship between two files, it
    won’t discover it on its own and it’ll make mistakes because it assumes it has
    perfect knowledge about the files and their relationships.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, `make` only works because it builds the prerequisites of `all`
    from left to right. First it encounters `foo`, which it builds, creating `foo.c`
    as a side effect, and then it builds `foo.o` using the pattern. If you change
    the order of the prerequisites of `all` so that it doesn’t build `foo` first,
    the build will fail.
  prefs: []
  type: TYPE_NORMAL
- en: There are (at least!) five nasty side effects of hidden targets.
  prefs: []
  type: TYPE_NORMAL
- en: An Unexpected Error if the Hidden Target Is Missing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose that `foo` exists, but `foo.c` and `foo.o` are missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`make` tries to update `foo.o`, but because it doesn’t know how to make `foo.c`
    (because it’s not mentioned as the target of any rule), invoking GNU `make` results
    in an error.'
  prefs: []
  type: TYPE_NORMAL
- en: The -n Option Fails
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The helpful `-n` debugging option in GNU `make` tells it to print out the commands
    that it would run to perform the build without actually running them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You’ve seen that `make` would actually perform two `touch` commands (`touch
    foo foo.c` followed by `touch foo.o`), but doing a `make -n` (with no `foo*` files
    present) results in an error. `make` doesn’t know that the rule for `foo` makes
    `foo.c`, and because it hasn’t actually run the `touch` command, `foo.c` is missing.
    Thus, the `-n` doesn’t represent the actual commands that `make` would run, making
    it useless for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: You Can’t Parallelize make
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GNU `make` provides a handy feature that allows it to run multiple jobs at once.
    If you have many compiles in a build, specifying the `-j` option (followed by
    a number indicating the number of jobs to run at the same time) can maximize CPU
    utilization and shorten the build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, a hidden target spoils that plan. Here’s the output from `make
    -j3` running three jobs at once on our example makefile from [Example 4-3](ch04.html#in_this_makefilecomma_the_rule_to_make_f
    "Example 4-3. In this makefile, the rule to make foo also makes foo.c."):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: GNU `make` tried to build `foo`, `foo.o`, and `foo.c` at the same time, and
    discovered that it didn’t know how to build `foo.c` because it had no way of knowing
    that it should wait for `foo` to be made.
  prefs: []
  type: TYPE_NORMAL
- en: make Does the Wrong Work if the Hidden Target Is Updated
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose the file `foo.c` already exists when `make` is run. Because `make`
    doesn’t know that the rule for `foo` will mess with `foo.c`, it’ll get updated
    even though it’s up-to-date. In [Example 4-2](ch04.html#modified_version_of_listing_4-1_that_use
    "Example 4-2. A modified version of Example 4-1 that uses the cache function"),
    `foo.c` is altered by a benign `touch` operation that only alters the file’s timestamp,
    but a different operation could destroy or overwrite the contents of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`make` rebuilds `foo` because it’s missing and updates `foo.c` at the same
    time, even though it was apparently up-to-date.'
  prefs: []
  type: TYPE_NORMAL
- en: You Can’t Direct make to Build foo.o
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’d hope that typing `make foo.o` would result in GNU `make` building `foo.o`
    from `foo.c` and, if necessary, building `foo.c`. But `make` doesn’t know how
    to build `foo.c`. That just happens by accident when building `foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: So if `foo.c` is missing, `make foo.o` results in an error.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you’re now convinced that hidden targets are a bad idea and can lead
    to all sorts of build problems.
  prefs: []
  type: TYPE_NORMAL
- en: GNU make’s Escaping Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you’ll need to insert a special character in a makefile. Perhaps you
    need a newline inside an `$(error)` message, a space character in a `$(subst)`,
    or a comma as the argument to a GNU `make` function. Those three simple tasks
    can be frustratingly difficult to do in GNU `make`; this section takes you through
    simple syntax that eliminates the frustration.
  prefs: []
  type: TYPE_NORMAL
- en: GNU `make`’s use of the tab character at the start of any line containing commands
    is a notorious language feature, but some other special characters can also trip
    you up. The ways GNU `make` handles `$`, `%`, `?`, `*`, `[`, `~`, `\`, and `#`
    are all special.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with $
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every GNU `make` user is familiar with `$` for starting a variable reference.
    It’s possible to write `$(variable)` (with parentheses) or `${variable}` (with
    curly brackets) to get the value of `variable`, and if the variable name is a
    single character (such as `a`), you can drop the parentheses and just use `$a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a literal `$`, you write `$$`. So to define a variable containing a
    single `$` symbol you’d write: `dollar := $$`.'
  prefs: []
  type: TYPE_NORMAL
- en: Playing with %
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Escaping `%` is not as simple as `$`, but it needs to be done in only three
    situations, and the same rules apply for each: in the `vpath` directive, in a
    `$(patsubst)`, and in a pattern or static-pattern rule.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The three rules for `%` escaping are:'
  prefs: []
  type: TYPE_NORMAL
- en: You can escape `%` with a single `\` character (that is, `\%` becomes a literal
    `%`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to put a literal `\` in front of a `%` (that is, you want the `\`
    to not escape the `%`), escape it with `\` (in other words, `\\%` becomes a literal
    `\` followed by a `%` character that *will* be used for the pattern match).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t worry about escaping `\` anywhere else in a pattern. It will be treated
    as a literal. For example, `\hello` is `\hello`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wildcards and Paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The symbols `?`, `*`, `[`, and `]` get treated specially when they appear in
    a filename. A makefile that has
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: will actually search for all `.c` files in the current directory and define
    a rule for each. The targets (along with prerequisites and files mentioned in
    the `include` directive) are globbed (the filesystem is searched and filenames
    matched against the wildcard characters) if they contain a wildcard character.
    The globbing characters have the same meaning as in the Bourne shell.
  prefs: []
  type: TYPE_NORMAL
- en: The `~` character is also handled specially in filenames and is expanded to
    the home directory of the current user.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of those special filename characters can be escaped with a `\`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This makefile defines a rule for the file named (literally) `*.c`.
  prefs: []
  type: TYPE_NORMAL
- en: Continuations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Other than the escaping function, you can also use the `\` as a continuation
    character at the end of a line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the rule for `all` has three prerequisites: `prerequisite`, `something`,
    and `else`.'
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the `#` character to start a comment, and you can make it a literal
    with a `\` escape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `$(pound)` is a single character: `#`.'
  prefs: []
  type: TYPE_NORMAL
- en: I Just Want a Newline!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GNU `make` does its best to insulate you from the newline character. You can’t
    escape a newline—there’s no syntax for special characters (for example, you can’t
    write `\n`), and even the `$(shell)` function strips newlines from the returned
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'But you can define a variable that contains a newline using the `define` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this definition contains two blank lines, but using `$(newline)`
    will expand into only one newline, which can be useful for formatting error messages
    nicely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of GNU `make`’s rather liberal variable naming rules, it’s possible
    to define a variable called `\n`. So if you like to maintain a familiar look,
    you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We’ll look more at special variable names in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Function Arguments: Spaces and Commas'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A problem that many GNU `make` users run into is the handling of spaces and
    commas in GNU `make` function arguments. Consider the following use of `$(subst)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This takes three arguments separated by commas: the `from` text, the `to` text,
    and the string to change.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It defines a function called `spaces-to-commas` to convert all spaces in its
    argument to commas (which might be handy for making a CSV file for example). Unfortunately,
    it doesn’t work for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument of the `$(subst)` is a space. GNU `make` strips all leading
    and trailing whitespace around function arguments. In this case, the first argument
    is interpreted as an empty string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument is a comma. GNU `make` cannot distinguish between the commas
    used for argument separators and the comma as an argument. In addition, there’s
    no way to escape the comma.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can work around both issues if you know that GNU `make` does the whitespace
    stripping and separation of arguments before it does any expansion of the arguments.
    So if we can define a variable containing a space and a variable containing a
    comma, we can write the following to get the desired effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Defining a variable containing a comma is easy, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'But space is a bit harder. You can define a space in a couple of ways. One
    way is to use the fact that whenever you append to a variable (using `+=`), a
    space is inserted before the appended text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way is to first define a variable that contains nothing, and then use
    it to surround the space so that it doesn’t get stripped by GNU `make`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use this technique to get a literal tab character into a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Much in the way that `$(\n)` was defined in the previous section, it’s possible
    to define specially named space and comma variables. GNU `make`’s rules are liberal
    enough to allow us to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The first line defines a variable called `,` (which can be used as `$(,)` or
    even `$,`) containing a comma.
  prefs: []
  type: TYPE_NORMAL
- en: The last three lines define a variable called `space` containing a space character
    and then use it to define a variable named (that’s right, its name is a space
    character) containing a space.
  prefs: []
  type: TYPE_NORMAL
- en: With that definition it’s possible to write `$( )` or even `$` (there’s a space
    after that `$`) to get a space character. Note that doing this might cause problems
    in the future as `make` is updated, so playing tricks like this can be dangerous.
    If you’re averse to risks, just use the variable named `space` and avoid `$( )`.
    Because whitespace is special in GNU `make`, pushing `make`’s parser to the limit
    with tricks like `$( )` might lead to breakages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using those definitions, the `spaces-to-commas` function can be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This strange-looking definition replaces spaces with commas using `subst`. It
    works because the `$( )` will get expanded by `subst` and will itself be a space.
    That space will then be the first parameter (the string that will be replaced).
    The second parameter is `$(,)`, which, when expanded, becomes a `,`. The result
    is that `spaces-to-commas` turns spaces into commas without confusing GNU `make`
    with the actual space and comma characters.
  prefs: []
  type: TYPE_NORMAL
- en: The Twilight Zone
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s possible to take definitions like `$( )` and `$(\n)` and go much further,
    defining variables with names like `=`, `#` or `:`. Here are other interesting
    variable definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'These definitions probably aren’t useful, but if you want to push GNU `make`
    syntax to its limits, try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Yes, that defines a variable called `+` containing a `+`.
  prefs: []
  type: TYPE_NORMAL
- en: The Trouble with $(wildcard)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The function `$(wildcard)` is GNU `make`’s globbing function. It’s a useful
    way of getting a list of files inside a makefile, but it can behave in unexpected
    ways. It doesn’t always provide the same answer as running `ls`. Read on to find
    out why and what to do about it.
  prefs: []
  type: TYPE_NORMAL
- en: $(wildcard) Explained
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use `$(wildcard)` anywhere in a makefile or rule to get a list of files
    that match one or more *glob* style patterns. For example, `$(wildcard *.foo)`
    returns a list of files ending in `.foo`. Recall that a list is a string where
    list elements are separated by spaces, so `$(wildcard *.foo)` might return `a.foo
    b.foo c.foo`. (If a filename contains a space, the returned list may appear incorrect
    because there’s no way to spot the difference between the list separator—a space—and
    the space in a filename.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also call `$(wildcard)` with a list of patterns, so `$(wildcard *.foo
    *.bar)` returns all the files ending in `.foo` or `.bar`. The `$(wildcard)` function
    supports the following globbing operators: `*` (match 0 or more characters), `?`
    (match 1 character), and `[...]` (matches characters, `[123]`, or a range of characters,
    `[a-z]`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful feature of `$(wildcard)` is that if the filename passed to it
    does not contain a pattern, that file is simply checked for existence. If the
    file exists, its name is returned; otherwise, `$(wildcard)` returns an empty string.
    Thus, `$(wildcard)` can be combined with `$(if)` to create an `if-exists` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '`if-exists` has three parameters: the name of the filename to check for, what
    to do if the file exists, and what to do if it does not. Here’s a simple example
    of its use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This will print `a.foo is there` if `a.foo` exists, or it will print `a.foo
    is not there` if not.
  prefs: []
  type: TYPE_NORMAL
- en: Unexpected Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each of the following examples uses two variables to obtain a list of files
    ending in `.foo` in a particular directory: `WILDCARD_LIST` and `LS_LIST` each
    return the list of files ending in `.foo` by calling `$(wildcard)` and `$(shell
    ls)`, respectively. The variable `DIRECTORY` holds the directory in which the
    examples look for files; for the current directory, `DIRECTORY` is left empty.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The starting makefile looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'With a single file `a.foo` in the current directory, running GNU `make` results
    in this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now extend the makefile so it makes a file called `b.foo` using `touch`. The
    makefile should look like [Example 4-4](ch04.html#when_you_run_this_makefilecomma_ls_and_d
    "Example 4-4. When you run this makefile, ls and $(wildcard) return different
    results."):'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-4. When you run this makefile, `ls` and `$(wildcard)` return different
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this makefile through GNU `make` (with just the preexisting `a.foo`
    file) results in the following surprising output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `ls` returns the correct list (because `b.foo` has been created by the time
    the `all` rule runs), but `$(wildcard)` does not; `$(wildcard)` appears to be
    showing the state before `b.foo` was created.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the `.foo` files in a subdirectory (not in the current working
    directory) results in different output, as shown in [Example 4-5](ch04.html#this_timecomma_ls_and_dollarleft_parenth
    "Example 4-5. This time, ls and $(wildcard) return the same results.").
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-5. This time, `ls` and `$(wildcard)` return the same results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Here, the makefile is updated so that it uses the `DIRECTORY` variable to specify
    the subdirectory `subdir`. There’s a single preexisting file `subdir/a.foo`, and
    the makefile will create `subdir/b.foo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this makefile results in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, both `$(wildcard)` and `ls` return the same results, and both show the
    presence of the two `.foo` files: `subdir/a.foo`, which existed before `make`
    was run, and `subdir/b.foo`, which was created by the makefile.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at one final makefile ([Example 4-6](ch04.html#small_change_makes_ls_and_dollarleft_par
    "Example 4-6. A small change makes ls and $(wildcard) return different results."))
    before I explain what’s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-6. A small change makes `ls` and `$(wildcard)` return different results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In this makefile, `$(warning)` is used to print out a list of the `.foo` files
    that already exist in the subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Notice now that GNU `make` appears to be behaving like it does in [Example 4-4](ch04.html#when_you_run_this_makefilecomma_ls_and_d
    "Example 4-4. When you run this makefile, ls and $(wildcard) return different
    results."); the `subdir/b.foo` file that was made by the makefile is invisible
    to `$(wildcard)` and doesn’t appear, even though it was created and `ls` found
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Unexpected Results Explained
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We get unexpected, and apparently inconsistent, results because GNU `make` contains
    its own cache of directory entries. `$(wildcard)` reads from that cache (not directly
    from disk like `ls`) to get its results. Knowing when that cache is filled is
    vital to understanding the results the `$(wildcard)` will return.
  prefs: []
  type: TYPE_NORMAL
- en: GNU `make` fills the cache only when it is forced to (for example, when it needs
    to read the directory entries to satisfy a `$(wildcard)` or other globbing request).
    If you know that GNU `make` fills the cache only when needed, then it’s possible
    to explain the results.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 4-4](ch04.html#when_you_run_this_makefilecomma_ls_and_d "Example 4-4. When
    you run this makefile, ls and $(wildcard) return different results."), GNU `make`
    fills the cache for the current working directory when it starts. So the file
    `b.foo` doesn’t appear in the output of `$(wildcard)` because it wasn’t present
    when the cache was filled.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 4-5](ch04.html#this_timecomma_ls_and_dollarleft_parenth "Example 4-5. This
    time, ls and $(wildcard) return the same results."), GNU `make` didn’t fill the
    cache with entries from `subdir` until they were needed. The entries were first
    needed for the `$(wildcard)`, which is performed after `subdir/b.foo` is created;
    hence, `subdir/b.foo` does appear in the `$(wildcard)` output.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 4-6](ch04.html#small_change_makes_ls_and_dollarleft_par "Example 4-6. A
    small change makes ls and $(wildcard) return different results."), the `$(warning)`
    happens at the start of the makefile and fills the cache (because it did a `$(wildcard)`);
    hence, `subdir/b.foo` was missing from the output of `$(wildcard)` for the duration
    of that `make`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Predicting when the cache will be filled is very difficult. `$(wildcard)` will
    fill the cache, but so will use of a globbing operator like `*` in the target
    or prerequisite list of a rule. [Example 4-7](ch04.html#when_gnu_make_fillscomma_the_dollarleft
    "Example 4-7. When GNU make fills, the $(wildcard) cache can be difficult to understand.")
    is a makefile that builds two files (`subdir/b.foo` and `subdir/c.foo`) and does
    a couple of `$(wildcard)`s:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-7. When GNU `make` fills, the `$(wildcard)` cache can be difficult
    to understand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The output may surprise you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Even though the first `$(wildcard)` is being done in the rule that makes `subdir/b.foo`
    and after the `touch` that created `subdir/b.foo`, there’s no mention of `subdir/b.foo`
    in the output of `$(wildcard)` ➊. Nor is there mention of `subdir/b.foo` in the
    output of the `ls`.
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that the complete block of commands is expanded into its final
    form before any of the lines in the rule are run. So the `$(wildcard)` and `$(shell
    ls)` are done before the `touch` has run.
  prefs: []
  type: TYPE_NORMAL
- en: The output of `$(wildcard)` is even more unpredictable if the `make` is run
    in parallel with the `-j` switch. In that case, the exact order in which the rules
    are run is not predictable, so the output of `$(wildcard)` can be even less predictable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what I recommend: don’t use `$(wildcard)` in a rule; use `$(wildcard)`
    in the makefile only at parsing time (before any rules start running). If you
    restrict the use of `$(wildcard)` to parsing time, you can be assured of consistent
    results: `$(wildcard)` will show the state of the filesystem before GNU `make`
    was run.'
  prefs: []
  type: TYPE_NORMAL
- en: Making Directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One common problem faced by real-world makefile hackers is the need to build
    a hierarchy of directories before the build, or at least before commands that
    use those directories can run. The most common case is that the makefile hacker
    wants to ensure that the directories where object files will be created exist,
    and they want that to happen automatically. This section looks at a variety of
    ways to achieve directory creation in GNU `make` and points out a common trap
    for the unwary.
  prefs: []
  type: TYPE_NORMAL
- en: An Example Makefile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following makefile builds an object file `/out/foo.o` from `foo.c` using
    the GNU `make` built-in variable `COMPILE.C` to make a `.o` file from a `.c` by
    running the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '`foo.c` is in the same directory as the makefile, but `foo.o` is placed in
    `/out/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This example works fine as long as `/out/` exists. But if it does not, you’ll
    get an error from the compiler along the lines of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, what you want is for the makefile to automatically create `/out/`
    if it is missing.
  prefs: []
  type: TYPE_NORMAL
- en: What Not to Do
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because GNU `make` excels at making things that don’t exist, it seems obvious
    to make `/out/` a prerequisite of `/out/foo.o` and have a rule to make the directory.
    That way if we need to build `/out/foo.o`, the directory will get created.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 4-8](ch04.html#this_makefile_can_end_up_doing_unnecessa "Example 4-8. This
    makefile can end up doing unnecessary work.") shows the reworked makefile with
    the directory as a prerequisite and a rule to build the directory using `mkdir`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-8. This makefile can end up doing unnecessary work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'For simplification, the name of the output directory is stored in a variable
    called `OUT`, and the `-p` option on the `mkdir` command is used so that it will
    build all the necessary parent directories. In this case the path is simple: it’s
    just `/out/`, but `-p` means that `mkdir` could make a long chain of directories
    in one go.'
  prefs: []
  type: TYPE_NORMAL
- en: This works well for this basic example, but there’s a major problem. Because
    the timestamp on a directory is typically updated when the directory is updated
    (for example, when a file is created, deleted, or renamed), this makefile can
    end up doing too much work.
  prefs: []
  type: TYPE_NORMAL
- en: For example, just creating another file inside `/out/` forces a rebuild of `/out/foo.o`.
    In a complex example, this could mean that many object files are rebuilt for no
    good reason, just because other files were rebuilt in the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 1: Build the Directory When the Makefile Is Parsed'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A simple solution to the problem in [Example 4-8](ch04.html#this_makefile_can_end_up_doing_unnecessa
    "Example 4-8. This makefile can end up doing unnecessary work.") is to just create
    the directory when the makefile is parsed. A quick call to `$(shell)` can achieve
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Before any targets are created or commands run, the makefile is read and parsed.
    If you put `$(shell mkdir -p $(OUT))` somewhere in the makefile, GNU `make` will
    run the `mkdir` every time the makefile is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: One possible disadvantage is that if many directories need to be created, this
    process could be slow. And GNU `make` is doing unnecessary work, because it will
    attempt to build the directories every time you type `make`. Some users also don’t
    like this method because it creates all the directories, even if they’re not actually
    used by the rules in the makefile.
  prefs: []
  type: TYPE_NORMAL
- en: 'A small improvement can be made by first testing to see whether the directory
    exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Here, `$(wildcard)` is used with a `/.` appended to check for the presence of
    a directory. If the directory is missing, `$(wildcard)` will return an empty string
    and the `$(shell)` will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 2: Build the Directory When all Is Built'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A related solution is to build the directory only when `all` is being built.
    This means that the directories won’t get created every time the makefile is parsed
    (which could avoid unnecessary work when you type `make clean` or `make depend`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This solution is messy because you must specify `make_directories` as a prerequisite
    of any target that the user might specify after `make`. If you don’t, you could
    run into the situation in which the directories have not been built. You should
    avoid this technique, especially because it will completely break parallel builds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 3: Use a Directory Marker File'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you look back at [Example 4-8](ch04.html#this_makefile_can_end_up_doing_unnecessa
    "Example 4-8. This makefile can end up doing unnecessary work."), you’ll notice
    one rather nice feature: it builds only the directory needed for a specific target.
    In a more complex example (where there were many such directories to be built)
    it would be nice to be able to use something like that solution while avoiding
    the problem of constant rebuilds as the timestamp on the directory changes.'
  prefs: []
  type: TYPE_NORMAL
- en: To do that, you can store a special empty file, which I call a *marker* file,
    in the directory and use that as the prerequisite. Because it’s a normal file,
    normal GNU `make` rebuilding rules apply and its timestamp is not affected by
    changes in its directory.
  prefs: []
  type: TYPE_NORMAL
- en: If you add a rule to build the marker file (and to ensure that its directory
    exists), you can specify a directory as a prerequisite by specifying the marker
    file as a proxy for the directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the rule to build `$(OUT)/.f` creates the directory, if necessary,
    and touches the `.f` file. Because the target is a file (`.f`), it can safely
    be used as a prerequisite in the `$(OUT)/foo.o` rule.
  prefs: []
  type: TYPE_NORMAL
- en: The `$(OUT)/.f` rule uses the GNU `make` function `$(dir FILE)` to extract the
    directory portion of the target (which is the path to the `.f` file) and passes
    that directory to `mkdir`.
  prefs: []
  type: TYPE_NORMAL
- en: The only disadvantage here is that it’s necessary to specify the `.f` files
    for every rule that builds a target in a directory that might need to be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this easy to use, you can create functions that automatically make
    the rule to create a directory and that calculate the correct name for `.f` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Here, `marker` and `make-dir` are used to simplify the makefile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 4: Use an Order-Only Prerequisite to Build the Directory'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In GNU `make` 3.80 and later, another solution is to use an *order-only* prerequisite.
    An order-only prerequisite is built before the target as normal but does not cause
    the target to be rebuilt when the prerequisite is changed. Usually, when a prerequisite
    is rebuilt, the target will also be rebuilt because GNU `make` assumes that the
    target depends on the prerequisite. Order-only prerequisites are different: they
    get built before the target, but the target isn’t updated just because an order-only
    prerequisite was built.'
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly what we would’ve liked in the original broken example in [Example 4-8](ch04.html#this_makefile_can_end_up_doing_unnecessa
    "Example 4-8. This makefile can end up doing unnecessary work.")—to make sure
    that the directory gets rebuilt as needed but doesn’t rebuild the `.o` file every
    time the directory’s timestamp changes.
  prefs: []
  type: TYPE_NORMAL
- en: Order-only prerequisites are any prerequisites that come after the bar symbol
    `|` and must be placed after any normal prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, just adding this single character to the broken example in [Example 4-8](ch04.html#this_makefile_can_end_up_doing_unnecessa
    "Example 4-8. This makefile can end up doing unnecessary work.") can make it work
    correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The rule for `$(OUT)/` ➊ will be run if the directory is missing, but changes
    to the directory will not cause `$(OUT)/foo.o` to be rebuilt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 5: Use Pattern Rules, Second Expansion, and a Marker File'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a typical makefile (not simple examples in books like this), targets are
    usually built using pattern rules, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: But we can change this pattern rule to build directories automatically using
    marker files.
  prefs: []
  type: TYPE_NORMAL
- en: In GNU `make` 3.81 and later, there is an exciting feature called *second expansion*
    (which is enabled by specifying the `.SECONDEXPANSION` target in the makefile).
    With second expansion, the prerequisite list of any rule undergoes a second expansion
    (the first expansion happens when the makefile is read) just before the rule is
    used. By escaping any `$` signs with a second `$`, it’s possible to use GNU `make`
    automatic variables (such as `$@`) in the prerequisite list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a marker file for each directory and second expansion, you can create
    a makefile that automatically creates directories only when necessary with a simple
    addition to the prerequisite list of any rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The pattern rule used to make `.o` files has a special prerequisite `$$(@D)/.f`,
    which uses the second expansion feature to obtain the directory in which the target
    is to be built. It does this by applying the `D` modifier to `$@`, which gets
    the directory of the target (while `$@` on its own obtains the name of the target).
  prefs: []
  type: TYPE_NORMAL
- en: That directory will be built by the `%/.f` pattern rule in the process of building
    a `.f` file. Notice that the `.f` files are marked as *precious* so that GNU `make`
    will not delete them. Without this line, the `.f` files are considered to be useless
    intermediate files and would be cleaned up by GNU `make` on exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 6: Make the Directory in Line'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s also possible to make directories inside the rules that need them; this
    is called making directories *in line*. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Here I’ve modified the `$(OUT)/foo.o` rule so that it makes the directory using
    `-p` each time. This only works if a small number of rules need to create directories.
    Updating every rule to add the `mkdir` is laborious and likely to result in some
    rules being missed.
  prefs: []
  type: TYPE_NORMAL
- en: GNU make Meets Filenames with Spaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GNU `make` treats the space character as a list separator; any string containing
    spaces can be thought of as a list of space-delimited words. This is fundamental
    to GNU `make`, and space-separated lists abound. Unfortunately, that presents
    a problem when filenames contain spaces. This section looks at how to work around
    the “spaces in filenames problem.”
  prefs: []
  type: TYPE_NORMAL
- en: An Example Makefile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose you are faced with creating a makefile that needs to deal with two files
    named `foo bar` and `bar baz`, with `foo bar` built from `bar baz`. Filenames
    that include spaces can be tricky to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'A naive way to write this in a makefile would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'But that doesn’t work. GNU `make` can’t differentiate between cases where spaces
    are part of the filename and cases where they’re not. In fact, the naively written
    makefile is exactly the same as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Placing quotations marks around the filenames doesn’t work either. If you try
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: GNU `make` thinks you’re talking about four files called `"foo`, `bar"`, `"bar`,
    and `baz"`. GNU `make` ignores the double quotes and splits the list by spaces
    as it normally would.
  prefs: []
  type: TYPE_NORMAL
- en: Escape Spaces with \
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way to deal with the spaces problem is to use GNU `make`’s escaping operator,
    `\`, which you can use to escape sensitive characters (such as a literal `#` so
    that it doesn’t start a comment or a literal `%` so that it isn’t used as a wildcard).
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, use `\` to escape spaces in rules for filenames with spaces. Our example
    makefile can then be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: and it will work correctly. The `\` is removed during the parsing of the makefile,
    so the actual target and prerequisite names correctly contain spaces. This will
    be reflected in the automatic variables (such as `$@`).
  prefs: []
  type: TYPE_NORMAL
- en: 'When `foo bar` needs updating, the simple makefile will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the same escaping mechanism inside GNU `make`’s `$(wildcard)`
    function. To check for the existence of `foo bar`, you can use `$(wildcard foo\
    bar)` and GNU `make` will treat `foo bar` as a single filename to look for in
    the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, GNU `make`’s other functions that deal with space-separated lists
    do not respect the escaping of spaces. The output of `$(sort foo\ bar)` for example,
    is the list `bar foo\`, not `foo\ bar` as you might expect. In fact, `$(wildcard)`
    is the only GNU `make` function that respects the `\` character to escape a space.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads to a problem if you have to deal with the automatic variables that
    contain lists of targets. Consider this slightly more complicated example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `foo bar` has two prerequisites `bar baz` and `a b`. What’s the value of
    `$^` (the list of all prerequisites) in this case? It’s `bar baz a b`: the escaping
    is gone, and even if it weren’t gone, the fact that only `$(wildcard)` respects
    the `\` means that it would be useless. `$^` is, from GNU `make`’s perspective,
    a list with four elements.'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the definitions of the automatic variables tells us which are safe
    to use in the presence of spaces in filenames. [Table 4-1](ch04.html#safety_of_automatic_variables
    "Table 4-1. Safety of Automatic Variables") shows each automatic variable and
    whether it is safe.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1. Safety of Automatic Variables
  prefs: []
  type: TYPE_NORMAL
- en: '| Automatic variable | Is it safe? |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `$@` | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `$<` | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `$%` | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `$*` | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `$?` | No |'
  prefs: []
  type: TYPE_TB
- en: '| `$^` | No |'
  prefs: []
  type: TYPE_TB
- en: '| `$+` | No |'
  prefs: []
  type: TYPE_TB
- en: Those that are inherently lists (`$?`, `$^`, and `$+`) are not safe because
    GNU `make` lists are separated by spaces; the others are safe.
  prefs: []
  type: TYPE_NORMAL
- en: And it gets a little worse. Even though the first four automatic variables in
    the table are safe to use, their modified versions with `D` and `F` suffixes (which
    extract the directory and filename portions of the corresponding automatic variable)
    are not. This is because they are defined in terms of the `dir` and `notdir` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The value of `$@` is `/tmp/foo bar/baz` as expected, but the value of `$(@D)`
    is `/tmp bar` (as opposed to `/tmp/foo bar`) and the value of `$(@F)` is `foo
    baz` (instead of just `baz`).
  prefs: []
  type: TYPE_NORMAL
- en: Turn Spaces into Question Marks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to deal with the spaces problem is to turn spaces into question
    marks. Here’s the original makefile transformed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Because GNU `make` does globbing of target and prerequisite names (and respects
    any spaces found), this will work. But the results are inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: If `foo bar` exists when this makefile runs, the pattern `foo?bar` will get
    turned into `foo bar` and that value will be used for `$@`. If that file were
    missing when the makefile is parsed, the pattern (and hence `$@`) remains as `foo?bar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another problem also exists: `?` could match something other than a space.
    If there’s a file called `foombar` on the system, for example, the makefile may
    end up working on the wrong file.'
  prefs: []
  type: TYPE_NORMAL
- en: To get around this problem, Robert Mecklenburg defines two functions to add
    and remove spaces automatically in *Managing Projects with GNU Make, 3rd edition*
    (O’Reilly, 2004). The `sq` function turns every space into a question mark (`sq`
    means space to question mark); the `qs` function does the opposite (it turns every
    question mark into a space). Here’s the updated makefile using two functions (`sq`
    and `qs`) to add and remove question marks. This works unless any filename contains
    a question mark but requires wrapping all uses of the filenames in calls to `sq`
    and `qs`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Either way, because we still can’t be sure whether automatic variables will
    have question marks in them, using the list-based automatic variables or any GNU
    `make` list functions is still impossible.
  prefs: []
  type: TYPE_NORMAL
- en: My Advice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given that GNU `make` has difficulty with spaces in filenames, what can you
    do? Here’s my advice:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rename your files to avoid spaces if possible.**'
  prefs: []
  type: TYPE_NORMAL
- en: However, this is impossible for many people because the spaces in filenames
    may have been added by a third party.
  prefs: []
  type: TYPE_NORMAL
- en: '**Use 8.3 filenames.**'
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with Windows, it may be possible to use short, 8.3 filenames,
    which allows you to still have spaces on disk but avoid them in the makefile.
  prefs: []
  type: TYPE_NORMAL
- en: '**Use `\` for escaping.**'
  prefs: []
  type: TYPE_NORMAL
- en: If you need the spaces, escape them with `\`, which does give consistent results.
    Just be sure to avoid the automatic variables listed as not safe in [Table 4-1](ch04.html#safety_of_automatic_variables
    "Table 4-1. Safety of Automatic Variables").
  prefs: []
  type: TYPE_NORMAL
- en: If you use `\` for escaping and you need to manipulate lists of filenames that
    contain spaces, the best thing to do is substitute spaces with some other character
    and then change them back again.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `s+` and `+s` functions in the following code change escaped
    spaces to `+` signs and back again. Then you can safely manipulate lists of filenames
    using all the GNU `make` functions. Just be sure to remove the `+` signs before
    using these names in a rule.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example using them to transform a list of source files with escaped
    spaces into a list of object files, which are then used to define the prerequisites
    of an `all` rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The source files are stored in `SRCS` with spaces in filenames escaped. So `SRCS`
    contains three files named `a b.c`, `c d.c`, and `e f.c`. GNU `make`’s `\` escaping
    is used to preserve the escaped spaces in each name. Transforming `SRCS` into
    a list of objects in `OBJS` is done in the usual manner using `.c=.o` to replace
    each `.c` extension with `.o`, but first `SRCS` is altered using the `s+` function
    so the escaped spaces become `+` signs. As a result, GNU `make` will see `SRCS`
    as a list of three elements, `a+b.c`, `c+d.c`, and `e+f.c`, and changing the extension
    will work correctly. When `OBJS` is used later in the makefile, the `+` signs
    are turned back into escaped spaces using a call to the function `+s`.
  prefs: []
  type: TYPE_NORMAL
- en: Path Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Makefile creators often have to manipulate filesystem paths, but GNU `make`
    provides few functions for path manipulation. And cross-platform `make` is difficult
    due to differences in path syntax. This section explains ways to manipulate paths
    in GNU `make` and navigate through the cross-platform minefield.
  prefs: []
  type: TYPE_NORMAL
- en: Target Name Matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Look at the following example makefile and suppose that `../foo` is missing.
    Does the makefile manage to create it?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run that makefile with GNU `make`, you might be surprised to see the
    following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'If you change the makefile to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: you’ll find that it works as expected and performs a `touch ../foo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first makefile fails because GNU `make` doesn’t do path manipulation on
    target names, so it sees two different targets called `../foo` and `.././foo`,
    and fails to make the connection between the two. The second makefile works because
    I lied in the preceding sentence. GNU `make` does do a tiny bit of path manipulation:
    it will strip leading `./` from target names. So in the second makefile both targets
    are `../foo`, and it works as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: The general rule with GNU `make` targets is that they are treated as literal
    strings without interpreting them in any way. Therefore, it’s essential that when
    you’re referring to a target in a makefile, you always ensure that the same string
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Path Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It bears repeating that GNU `make` lists are just strings in which any whitespace
    is considered a list separator. Consequently, paths with spaces in them are not
    recommended because it makes using many of GNU `make`’s built-in functions impossible,
    and spaces in paths cause problems with targets.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose a target is `/tmp/sub directory/target`, and we write
    a rule for it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'GNU `make` will actually interpret that as two rules, one for `/tmp/sub` and
    one for `directory/target`, just as if you’d written this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: You can work around that problem by escaping the space with `\`, but that escape
    is poorly respected by GNU `make` (it works only in target names and the `$(wildcard`)
    function).
  prefs: []
  type: TYPE_NORMAL
- en: Unless you must use them, avoid spaces in target names.
  prefs: []
  type: TYPE_NORMAL
- en: Lists of Paths in VPATH and vpath
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another place that lists of paths appear in GNU `make` is when specifying the
    `VPATH` or in a `vpath` directive used to specify where GNU `make` finds prerequisites.
    For example, it’s possible to set the `VPATH` to search for source files in a
    list of `:` or whitespace separated paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'GNU `make` will split that path correctly at either colons or whitespace. On
    Windows systems, the native builds of GNU `make` use `;` as the path separator
    for `VPATH` (and `vpath`) because `:` is needed for drive letters. On Windows,
    GNU `make` actually tries to be smart and splits paths on colons unless it looks
    like a drive letter (one letter followed by a colon). This drive letter intelligence
    actually creates a problem if you have a directory in the path whose name is a
    single letter: in that case you must use `;` as the path separator. Otherwise,
    GNU `make` will think it’s a drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: On both POSIX and Windows systems, a space in a path is a separator in a `VPATH`
    and `vpath`. So using spaces is the best bet for cross-platform makefiles.
  prefs: []
  type: TYPE_NORMAL
- en: Using / or \
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On POSIX systems `/` is the path separator, and on Windows systems it’s `\`.
    It’s common to see paths being built up in makefiles like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be ideal to remove the POSIX-only `/` there and replace it with something
    that would work with a different separator. One way to do that is to define a
    variable called `/` (GNU `make` lets you get away with using almost anything as
    a variable name) and use it in place of `/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'If that makes you uncomfortable, just call it `SEP`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Now when you switch to Windows, you can just redefine `/` (or `SEP`) to `\`.
    It’s difficult to assign a literal `\` on its own as a variable value (because
    GNU `make` interprets it as a line continuation and it can’t be escaped), so it’s
    defined here using `$(strip)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'However, note that the Windows builds of GNU `make` will also accept `/` as
    a path separator, so weird paths like `c:/src` are legal. Using those paths will
    simplify the makefile, but be careful when passing them to a native Windows tool
    that expects \ separated paths. If that’s necessary, use this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: This simple function will convert a forward slash path to a backslash path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows Oddity: Case Insensitive but Case Preserving'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On POSIX systems filenames are case sensitive; on Windows they are not. On Windows
    the files `File`, `file`, and `FILE` are all the same file. But an oddity with
    Windows is that the first time a file is accessed, the specific case used is recorded
    and preserved. Thus, if we `touch File`, it will appear as `File` in the filesystem
    (but can be accessed as `FILE`, `file`, or any other case combination).
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, GNU `make` does case-sensitive target comparisons, so the following
    makefile does not do what you might expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: As is, this file causes an error, but you can compile GNU `make` on Windows
    to do case-insensitive comparisons instead (with the build `HAVE_CASE_INSENSITIVE_FS`
    option).
  prefs: []
  type: TYPE_NORMAL
- en: This oddity is more likely to arise when a target specified in a makefile is
    also found in a wildcard search because the operating system may return a different
    case than the case used in the makefile. The target names may differ in case,
    and that may cause an unexpected `No rule to make` error.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in Path Functions and Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can determine the current working directory in GNU `make` using the built-in
    `CURDIR`. Note that `CURDIR` will follow symlinks. If you are in `/foo` but `/foo`
    is actually a symlink to `/somewhere/foo`, `CURDIR` will report the directory
    as `/somewhere/foo`. If you need the non-symlink-followed directory name, use
    the value of the environment variable `PWD`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'But be sure to grab its value before any other part of the makefile has changed
    `PWD`: it can be altered, just like any other variable imported from the environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also find the directory in which the current makefile is stored using
    the `MAKEFILE_LIST` variable that was introduced in GNU `make` 3.80\. At the start
    of a makefile, it’s possible to extract its directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'GNU `make` has functions for splitting paths into components: `dir`, `notdir`,
    `basename`, and `suffix`.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the filename `/foo/bar/source.c` stored in the variable `FILE`. You
    can use the functions `dir`, `notdir`, `basename`, and `suffix` to extract the
    directory, filename, and suffix. So to get the directory, for example, use `$(dir
    $(FILE))`. [Table 4-2](ch04.html#results_of_dircomma_notdircomma_basename "Table 4-2. Results
    of dir, notdir, basename, and suffix") shows each of these functions and its result.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-2. Results of `dir`, `notdir`, `basename`, and `suffix`
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `dir` | `/foo/bar/` |'
  prefs: []
  type: TYPE_TB
- en: '| `notdir` | `source.c` |'
  prefs: []
  type: TYPE_TB
- en: '| `basename` | `source` |'
  prefs: []
  type: TYPE_TB
- en: '| `suffix` | `.c` |'
  prefs: []
  type: TYPE_TB
- en: You can see that the directory, the non-directory part, the suffix (or extension),
    and the non-directory part without the suffix have been extracted. These four
    functions make filename manipulation easy. If no directory was specified, GNU
    `make` uses the current directory (`./`). For example, suppose that `FILE` was
    just `source.c`. [Table 4-3](ch04.html#results_of_dircomma_notdircomma-id00011
    "Table 4-3. Results of dir, notdir, basename, and suffix with No Directory Specified")
    shows the result for each function.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-3. Results of `dir`, `notdir`, `basename`, and `suffix` with No Directory
    Specified
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `dir` | `./` |'
  prefs: []
  type: TYPE_TB
- en: '| `notdir` | `source.c` |'
  prefs: []
  type: TYPE_TB
- en: '| `basename` | `source` |'
  prefs: []
  type: TYPE_TB
- en: '| `suffix` | `.c` |'
  prefs: []
  type: TYPE_TB
- en: Because these functions are commonly used in conjunction with GNU `make`’s automatic
    variables (like `$@`), GNU `make` provides a modifier syntax. Appending `D` or
    `F` to any automatic variable is equivalent to calling `$(dir)` or `$(notdir)`
    on it. For example, `$(@D)` is equivalent to `$(dir $@)` and `$(@F)` is the same
    as `$(notdir $@)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Useful Functions in 3.81: abspath and realpath'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`realpath` is a GNU `make` wrapper for the C library `realpath` function, which
    removes `./`, resolves `../`, removes duplicated `/`, and follows symlinks. The
    argument to `realpath` must exist in the filesystem. The path returned by `realpath`
    is absolute. If the path does not exist, the function returns an empty string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you could find the full path of the current directory like this:
    `current := $(realpath ./)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`abspath` is similar but does not follow symlinks, and its argument does not
    have to refer to an existing file or directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Usman’s Law
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`make clean` doesn’t make clean. That’s Usman’s law (named after a smart coworker
    of mine who spent months working with real-world makefiles). `make clean` is intended
    to return to a state in which everything will be rebuilt from scratch. Often it
    doesn’t. Read on to find out why.'
  prefs: []
  type: TYPE_NORMAL
- en: The Human Factor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `clean` rule from the OpenSSL makefile looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Notice how it’s a long list of clearly human-maintained directories, patterns,
    and filenames that need to be deleted to get back to a clean state. Human maintenance
    means human error. Suppose someone adds a rule that creates a temporary file with
    a fixed name. That temporary file should be added to the `clean` rule, but it
    most likely won’t be.
  prefs: []
  type: TYPE_NORMAL
- en: Usman’s law strikes.
  prefs: []
  type: TYPE_NORMAL
- en: Poor Naming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s a snippet found in many automatically generated makefiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, three sorts of `clean` appear to have different degrees of
    cleanliness: `mostlyclean`, `clean`, and `extraclean`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`mostlyclean` just deletes the object files compiled from source. `clean` does
    that plus deletes the generated library and a few other files. You’d think that
    `extraclean` would delete more than the other two, but it actually deletes a different
    set of files. And I’ve seen makefiles with `reallyclean`, `veryclean`, `deepclean`,
    and even `partiallyclean` rules!'
  prefs: []
  type: TYPE_NORMAL
- en: When you can’t tell from the naming what does what, it can easily lead to potential
    problems down the line.
  prefs: []
  type: TYPE_NORMAL
- en: Usman’s law strikes again.
  prefs: []
  type: TYPE_NORMAL
- en: Silent Failure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s another makefile snippet that works some of the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The `@` means that the command isn’t echoed. The `-` means that any error returned
    is ignored and all output is redirected with `&>` to `/dev/null`, making it invisible.
    Because no `-f` is on the `rm` command, any failure (from say, permissions problems)
    will go totally unnoticed.
  prefs: []
  type: TYPE_NORMAL
- en: Usman’s law strikes again.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive Clean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many makefiles are recursive, and `make clean` must be recursive too, so you
    see the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: The problem with this is that it means `make clean` has to work correctly in
    every directory in `SUBDIR`, leading to more opportunity for error.
  prefs: []
  type: TYPE_NORMAL
- en: Usman’s law strikes again.
  prefs: []
  type: TYPE_NORMAL
- en: Pitfalls and Benefits of GNU make Parallelization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many build processes run for hours, so build managers commonly type `make`
    and go home for the night. GNU `make`’s solution to this problem is parallel execution:
    a simple command line option that causes GNU `make` to run jobs in parallel using
    the dependency information in the makefile to run them in the correct order.'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, however, GNU `make` parallel execution is severely limited by the
    fact that almost all makefiles are written with the assumption that their rules
    will run in series. Rarely do makefile authors *think in parallel* when writing
    their makefiles. That leads to hidden traps that either cause the build to fail
    with a fatal error or, worse, build “successfully” but result in incorrect binaries
    when GNU `make` is run in parallel mode.
  prefs: []
  type: TYPE_NORMAL
- en: This section looks at GNU `make`’s parallel pitfalls and how to work around
    them to get maximum parallelism.
  prefs: []
  type: TYPE_NORMAL
- en: Using -j (or -jobs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start GNU `make` in parallel mode, you can specify either the `-j` or `--jobs`
    option on the command line. The argument to the option is the maximum number of
    processes that GNU `make` will run in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: For example, typing `make --jobs=4` allows GNU `make` to run up to four subprocesses
    in parallel, which would give a theoretical maximum speedup of 4×. However, the
    theoretical time is severely limited by restrictions in the makefile. To calculate
    the maximum actual speedup, you use Amdahl’s law (which is covered in [Amdahl’s
    Law and the Limits of Parallelization](ch04.html#amdahlapostrophes_law_and_the_limits_of
    "Amdahl’s Law and the Limits of Parallelization")).
  prefs: []
  type: TYPE_NORMAL
- en: One simple but annoying problem found in parallel GNU `make` is that because
    the jobs are no longer run serially (and the order depends on the timing of jobs),
    the output from GNU `make` will be sorted randomly depending on the actual order
    of job execution.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, that problem has been addressed in GNU `make` 4.0 with the `--output-sync`
    option described in [Chapter 1](ch01.html "Chapter 1. The Basics Revisited").
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the example in [Example 4-9](ch04.html#simple_makefile_to_illustrate_parallel_m
    "Example 4-9. A simple makefile to illustrate parallel making"):'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-9. A simple makefile to illustrate parallel making
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'It builds five targets: `t1`, `t2`, `t3`, `t4`, and `t5`. All are simply touched
    except for `t2`, which is copied from `t3`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running [Example 4-9](ch04.html#simple_makefile_to_illustrate_parallel_m "Example 4-9. A
    simple makefile to illustrate parallel making") through standard GNU `make` without
    a parallel option gives the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: The order of execution will be the same each time because GNU `make` will follow
    the prerequisites depth first and from left to right. Note that the left-to-right
    execution (in the `all` rule for example, `t5` is built before `t4`, which is
    built before `t1`) is part of the POSIX `make` standard.
  prefs: []
  type: TYPE_NORMAL
- en: Now if `make` is run in parallel mode, it’s clear that `t5`, `t4`, and `t1`
    can be run at the same time because there are no dependencies between them. Similarly,
    `t3` and `t2` do not depend on each other, so they can be run in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of a parallel run of [Example 4-9](ch04.html#simple_makefile_to_illustrate_parallel_m
    "Example 4-9. A simple makefile to illustrate parallel making") might be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Or even:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: This makes any process that examines log files to check for build problems (such
    as diffing log files) difficult. Unfortunately, there’s no easy solution for this
    in GNU `make` without the `--output-sync` option, so you’ll just have to live
    with it unless you upgrade to GNU `make` 4.0.
  prefs: []
  type: TYPE_NORMAL
- en: Missing Dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The example in [Example 4-9](ch04.html#simple_makefile_to_illustrate_parallel_m
    "Example 4-9. A simple makefile to illustrate parallel making") has an additional
    problem. The author fell into the classic left-to-right trap when writing the
    makefile, so when it’s run in parallel, it’s possible for the following to happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason is that when run in parallel, the rule to build `t2` can occur before
    the rule to build `t3`, and `t2` needs `t3` to have already been built. This didn’t
    happen in the serial case because of the left-to-right assumption: the rule to
    build `t1` is `t1: t3 t2`, which implies that `t3` will be built before `t2`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But no actual dependency exists in the makefile that states that `t3` must
    be built before `t2`. The fix is simple: just add `t2: t3` to the makefile.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple example of the real problem of missing or implicit (left-to-right)
    dependencies that plagues makefiles when run in parallel. If a makefile breaks
    when run in parallel, it’s worth looking for missing dependencies straightaway
    because they are very common.
  prefs: []
  type: TYPE_NORMAL
- en: The Hidden Temporary File Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way GNU `make` can break when running in parallel is if multiple rules
    use the same temporary file. Consider the example makefile in [Example 4-10](ch04.html#hidden_temporary_file_that_breaks_parall
    "Example 4-10. A hidden temporary file that breaks parallel builds"):'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-10. A hidden temporary file that breaks parallel builds
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Run without a parallel option, GNU `make` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'and the `t` file contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'But run in parallel, [Example 4-10](ch04.html#hidden_temporary_file_that_breaks_parall
    "Example 4-10. A hidden temporary file that breaks parallel builds") gives the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `t` contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: This occurs because no dependency exists between `t1` and `t2` (because neither
    requires the output of the other), so they can run in parallel. In the output,
    you can see that they are running in parallel but that the output from the two
    rules is interleaved. Because the two `echo` statements ran first, `t2` overwrote
    the output of `t1`, so the temporary file (shared by both rules) had the wrong
    value when it was finally `cat`ed to `t1`, resulting in the wrong value for `t`.
  prefs: []
  type: TYPE_NORMAL
- en: This example may seem contrived, but the same thing happens in real makefiles
    when run in parallel, resulting in either broken builds or the wrong binary being
    built. The `yacc` program for example, produces temporary files called `y.tab.c`
    and `y.tab.h`. If more than one `yacc` is run in the same directory at the same
    time, the wrong files could be used by the wrong process.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple solution for the makefile in [Example 4-10](ch04.html#hidden_temporary_file_that_breaks_parall
    "Example 4-10. A hidden temporary file that breaks parallel builds") is to change
    the definition of `TMP_FILE` to `TMP_FILE = /tmp/scratch_file.$@`, so its name
    will depend on the target being built. Now a parallel run would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: A related problem occurs when multiple jobs in the makefile write to a shared
    file. Even if they never read the file (for example, they might write to a log
    file), locking the file for write access can cause competing jobs to stall, reducing
    the overall performance of the parallel build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the example makefile in [Example 4-11](ch04.html#locking_on_shared_files_can_lock_a_paral
    "Example 4-11. Locking on shared files can lock a parallel build and make it run
    serially.") that uses the `lockfile` command to lock a file and simulate write
    locking. Although the file is locked, each job waits for a number of seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-11. Locking on shared files can lock a parallel build and make it
    run serially.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Running [Example 4-11](ch04.html#locking_on_shared_files_can_lock_a_paral "Example 4-11. Locking
    on shared files can lock a parallel build and make it run serially.") in a serial
    build takes about 30 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'But it isn’t any faster in parallel, even though `t1` and `t2` should be able
    to run in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: It’s actually slower because of the way `lockfile` detects lock availability.
    As you can imagine, write locking a file could cause similar delays in otherwise
    parallel-friendly makefiles.
  prefs: []
  type: TYPE_NORMAL
- en: Related to the file locking problem is a danger concerning archive (`ar`) files.
    If multiple `ar` processes were to run simultaneously on the same archive file,
    the archive could be corrupted. Locking around archive updates is necessary in
    a parallel build; otherwise, you’ll need to prevent your dependencies from running
    multiple `ar` commands on the same file at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: One way to prevent parallelism problems is to specify `.NOTPARALLEL` in a makefile.
    If this is seen, the entire `make` execution will be run in series and the `-j`
    or `--jobs` command line option will be ignored. `.NOTPARALLEL` is a very blunt
    tool because it affects an entire invocation of GNU `make`, but it could be handy
    in a recursive `make` situation with, for example, a third-party makefile that
    is not parallel safe.
  prefs: []
  type: TYPE_NORMAL
- en: The Right Way to Do Recursive make
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GNU `make` is smart enough to share parallelism across sub-makes if a makefile
    using `$(MAKE)` is careful about how it calls sub-makes. GNU `make` has a message
    passing mechanism that works across most platforms (Windows support was added
    in GNU `make` 4.0) and enables sub-makes to use all the available jobs specified
    through `-j` or `--jobs` by passing tokens across pipes between the `make` processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only serious gotcha is that you must write your makefile in a way that
    actually allows your sub-makes to run in parallel. The classic recursive `make`
    style that uses a shell `for` loop to process each sub-make doesn’t allow for
    more than one sub-make to run at once. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'This code has a big problem: if sub-make fails, the `make` will look like it
    has succeeded. It’s possible to fix that, but the fixes become more and more complicated:
    other approaches are better.'
  prefs: []
  type: TYPE_NORMAL
- en: When run in parallel mode, the `all` rule walks through each subdirectory and
    waits for its `$(MAKE)` to complete. Even though each of those sub-makes will
    be able to run in parallel, the overall `make` does not, meaning a less than ideal
    speedup. For example, if the `make` in the `bar` directory is capable of running
    only four jobs at once, then running on a 16-core machine won’t make the build
    any faster than on one with just 4 cores.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to remove the `for` loop and replace it with a single rule
    for each directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Each directory is considered to be a phony target, because the directory doesn’t
    actually get built.
  prefs: []
  type: TYPE_NORMAL
- en: Now each directory can run while the others are running, and parallelism is
    maximized; it’s even possible to have dependencies between directories causing
    some sub-makes to run before others. Directory dependencies can be handy when
    it’s important that one sub-make runs before another.
  prefs: []
  type: TYPE_NORMAL
- en: Amdahl’s Law and the Limits of Parallelization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Additionally, there are real limits to the amount of parallelization that is
    possible in a project. Look at [Example 4-12](ch04.html#makefile_with_sleep_used_to_simulate_job
    "Example 4-12. A makefile with sleep used to simulate jobs that take time to complete"):'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-12. A makefile with `sleep` used to simulate jobs that take time to
    complete
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'When run in series, it takes about 88 seconds to complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'What’s the maximum speedup possible, assuming as many CPUs are available as
    desired? Working through the makefile step by step, you’ll see that `t` takes
    10 seconds to build and everything else must be built before that. `t1`, `t2`,
    `t4`, `t6`, and `t7` are all independent, and the longest of them takes 12 seconds.
    `t3` waits for `t5`, which needs `t8`: that chain takes a total of 20 seconds.
    `t9` needs `t10` for a total of 10 seconds, and `t11` needs `t12` for another
    10 seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: So the longest serial part of this build is the sequence `t`, `t3`, `t5`, `t8`,
    which takes a total of 30 seconds. This build can never go faster than 30 seconds
    (or 2.93 times faster than the serial 88 second time). How many processors are
    needed to achieve that speedup?
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the maximum speedup achievable is governed by Amdahl’s law: if
    `F` is the fraction of the build that cannot be parallelized and `N` is the number
    of available processors, then the maximum speedup achievable is `1 / ( F + ( 1
    - F ) / N )`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the [Example 4-12](ch04.html#makefile_with_sleep_used_to_simulate_job "Example 4-12. A
    makefile with sleep used to simulate jobs that take time to complete") example,
    34 percent of the build can’t be parallelized. [Table 4-4](ch04.html#maximum_speedup_based_on_number_of_proce
    "Table 4-4. Maximum Speedup Based on Number of Processors") shows the results
    of applying Amdahl’s law:'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-4. Maximum Speedup Based on Number of Processors
  prefs: []
  type: TYPE_NORMAL
- en: '| Number of processors | Maximum speedup |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 1.49x |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1.79x |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 1.98x |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 2.12x |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 2.22x |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 2.30x |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 2.37x |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 2.42x |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 2.46x |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | 2.50x |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | 2.53x |'
  prefs: []
  type: TYPE_TB
- en: For this small build, the maximum speedup Amdahl’s law predicts has a plateau
    starting at around eight processors. The actual plateau is further limited by
    the fact that only 13 possible jobs are in the build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the structure of the build, we can see that eight processors is
    the maximum because five jobs can run in parallel without any dependencies: `t1`,
    `t2`, `t4`, `t6`, and `t7`. Then three small chains of jobs can each use one processor
    at a time: `t3`, `t5`, and `t8`; `t9` and `t10`; and `t11` and `t12`. Building
    `t` can reuse one of the eight processors because they’ll all be idle at that
    point.'
  prefs: []
  type: TYPE_NORMAL
- en: A real-world instance of Amdahl’s law significantly impacting build times occurs
    with languages that have a linking step, such as C and C++. Typically, all the
    objects files are built before the link step and then a single (often huge) link
    process has to run. That link process is often not parallelizable and becomes
    the limiting factor on build parallelization.
  prefs: []
  type: TYPE_NORMAL
- en: Making $(wildcard) Recursive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The built-in `$(wildcard)` function is not recursive: it only searches for
    files in a single directory. You can have multiple globbing patterns in a `$(wildcard)`
    and use that to look in subdirectories. For example, `$(wildcard */*.c)` finds
    all the `.c` files in all subdirectories of the current directory. But if you
    need to search an arbitrary tree of directories, there’s no built-in way to do
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, it’s pretty easy to make a recursive version of `$(wildcard)`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `rwildcard` takes two parameters: the first is the directory from
    which to start searching (this parameter can be left empty to start from the current
    directory), and the second is the glob pattern for the files to find in each directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to find all `.c` files in the current directory (along with its
    subdirectories), use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Or to find all `.c` files in `/tmp`, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '`rwildcard` also supports multiple patterns. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: This finds all `.c` and `.h` files under `/src/`.
  prefs: []
  type: TYPE_NORMAL
- en: Which Makefile Am I In?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common request is: Is there a way to find the name and path of the current
    makefile? By *current*, people usually mean the makefile that GNU `make` is currently
    parsing. There’s no built-in way to quickly get the answer, but there is a way
    using the GNU `make` variable `MAKEFILE_LIST`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`MAKEFILE_LIST` is the list of makefiles currently loaded or `include`d. Each
    time a makefile is loaded or `include`d, the `MAKEFILE_LIST` is appended with
    its path and name. The paths and names in the variable are relative to the current
    working directory (where GNU `make` was started or where it moved to with the
    `-C` or `--directory` option), but you can access the current directory from the
    `CURDIR` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So using that, you can define a GNU `make` function (let’s call it `where-am-i`)
    that will return the current makefile (it uses `$(word)` to get the last makefile
    name from the list):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, whenever you want to find the full path to the current makefile, write
    the following at the top of the makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: It’s important that this line goes at the top because any `include` statement
    in the makefile will change the value of `MAKEFILE_LIST`, so you want to grab
    the location of the current makefile before that happens.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 4-13](ch04.html#makefile_that_can_determine_where_it_is "Example 4-13. A
    makefile that can determine where it is located on the filesystem") shows an example
    makefile that uses `where-am-i` and includes another makefile from the `foo/`
    subdirectory, which, in turn, includes a makefile from the `foo/bar/` directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-13. A makefile that can determine where it is located on the filesystem
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: The contents of `foo/makefile` is shown in [Example 4-14](ch04.html#makefile_included_by_listing_4-13
    "Example 4-14. A makefile included by Example 4-13").
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-14. A makefile included by [Example 4-13](ch04.html#makefile_that_can_determine_where_it_is
    "Example 4-13. A makefile that can determine where it is located on the filesystem")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: The contents of `foo/bar/makefile` is shown in [Example 4-15](ch04.html#makefile_included_by_listing_4-14
    "Example 4-15. A makefile included by Example 4-14").
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-15. A makefile included by [Example 4-14](ch04.html#makefile_included_by_listing_4-13
    "Example 4-14. A makefile included by Example 4-13")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting the three makefiles in [Example 4-13](ch04.html#makefile_that_can_determine_where_it_is
    "Example 4-13. A makefile that can determine where it is located on the filesystem"),
    [Example 4-14](ch04.html#makefile_included_by_listing_4-13 "Example 4-14. A makefile
    included by Example 4-13") and [Example 4-15](ch04.html#makefile_included_by_listing_4-14
    "Example 4-15. A makefile included by Example 4-14") in `/tmp` (and subdirectories)
    and running GNU `make` gives the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, we’ve looked at common problems that makefile creators and
    maintainers run into when working on real makefiles. In any sizable project that
    uses `make`, you are likely to run into one or more (perhaps even all!) of them.
  prefs: []
  type: TYPE_NORMAL
