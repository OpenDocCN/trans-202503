- en: Chapter 4. Pitfalls and Problems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章：陷阱与问题
- en: In this chapter, you’ll learn how to deal with problems faced by makefile maintainers
    as projects get considerably larger. Tasks that seem easy with small makefiles
    become more difficult with large, sometimes recursive, `make` processes. As makefiles
    become more complex, it’s easy to run into problems with edge cases or sometimes
    poorly understood behavior of GNU `make`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何应对随着项目规模扩大，makefile 维护者所面临的问题。那些在小型 makefile 中看似简单的任务，在大型的、可能是递归的
    `make` 进程中会变得更加困难。随着 makefile 变得更加复杂，容易遇到一些边缘情况的问题，或者 GNU `make` 的行为难以理解的情况。
- en: Here you’ll see a complete solution to the “recursive `make` problem,” how to
    overcome GNU `make`’s problems handling filenames that contain spaces, how to
    deal with cross-platform file paths, and more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将看到解决“递归 `make` 问题”的完整方案，如何克服 GNU `make` 处理包含空格的文件名的问题，如何处理跨平台的文件路径等等。
- en: 'GNU make Gotcha: ifndef and ?='
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GNU make 注意事项：ifndef 和 ?=
- en: It’s easy to get tripped up by the two ways of checking whether a variable is
    defined, `ifndef` and `?=`, because they do similar things, yet one has a deceptive
    name. `ifndef` doesn’t really test whether a variable is defined; it only checks
    that the variable is not empty, whereas `?=` does make its decision based on whether
    the variable is defined or not.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 检查变量是否已定义的两种方式 `ifndef` 和 `?=` 很容易让人迷惑，因为它们做的是相似的事情，但一个名字具有误导性。`ifndef` 并不真正检查变量是否已定义，它只检查变量是否为空，而
    `?=` 则根据变量是否已定义来做决定。
- en: 'Compare these two ways of conditionally setting the variable `FOO` in a makefile:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 比较以下两种在 makefile 中有条件设置变量 `FOO` 的方式：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: and
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: They look like they should do the same thing, and they do, well, almost.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 它们看起来应该做相同的事情，实际上它们差不多。
- en: What ?= Does
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`?=` 的作用'
- en: 'The `?=` operator in GNU `make` sets the variable mentioned on its left side
    to the value on the right side if the left side is not defined. For example:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 中的 `?=` 运算符将其左侧的变量设置为右侧的值，前提是左侧的变量尚未定义。例如：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This makefile sets `FOO` to `New Value`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 makefile 将 `FOO` 设置为 `New Value`。
- en: 'But the following one does not:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但以下内容则不返回此值：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Neither does this one (even though `FOO` was initially empty):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `FOO` 最初为空，这个也不会返回：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In fact, `?=` is the same as the following makefile, which uses the GNU `make
    $(origin)` function to determine whether a variable is undefined:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`?=` 与以下 makefile 是相同的，它使用 GNU `make $(origin)` 函数来判断变量是否未定义：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`$(origin FOO)` will return a string that shows whether and how `FOO` is defined.
    If `FOO` is undefined, then `$(origin FOO)` is the string `undefined`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(origin FOO)` 将返回一个字符串，显示 `FOO` 是否以及如何定义。如果 `FOO` 未定义，则 `$(origin FOO)` 的值为
    `undefined`。'
- en: Note that variables defined with `?=` are expanded, just like variables defined
    with the `=` operator. They are expanded when used but not when defined, just
    like a normal GNU `make` variable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用 `?=` 定义的变量会像使用 `=` 运算符定义的变量一样进行展开。它们在使用时会展开，但在定义时不会展开，就像普通的 GNU `make`
    变量一样。
- en: What ifndef Does
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ifndef` 的作用'
- en: 'As mentioned earlier, `ifndef` tests whether a variable is empty but does not
    check to see whether the variable is defined. `ifndef` means *if the variable
    is undefined or is defined but is empty*. Thus, this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`ifndef` 测试变量是否为空，但并不检查变量是否已定义。`ifndef` 意味着 *如果变量未定义或已定义但为空*。因此，以下内容：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'will set `FOO` to the `New Value` if `FOO` is undefined or `FOO` is empty.
    So `ifndef` can be rewritten as such:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `FOO` 未定义或 `FOO` 为空，则会将 `FOO` 设置为 `New Value`。因此，`ifndef` 可以重写为：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: because an undefined variable is always treated as having an empty value when
    read.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因为未定义的变量在读取时总是被视为具有空值。
- en: $(shell) and := Go Together
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: $(shell) 和 := 一起使用
- en: The suggestion in this section often speeds up makefiles with just the addition
    of a suitably placed colon. To understand how a single colon can make such a difference,
    you need to understand GNU `make`’s `$(shell)` function and the difference between
    `=` and `:=`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的建议通常通过适当放置冒号来加速 makefile 的执行。要理解一个冒号如何带来如此大的变化，你需要了解 GNU `make` 的 `$(shell)`
    函数以及 `=` 和 `:=` 之间的区别。
- en: $(shell) Explained
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $(shell) 解释
- en: '`$(shell)` is GNU `make`’s equivalent of the backtick (`` ` ``) operator in
    the shell. It executes a command, flattens the result (turns all whitespace, including
    new lines, into spaces), and returns the resulting string.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(shell)` 是 GNU `make` 中与 shell 中反引号（`` ` ``）操作符相对应的函数。它执行一个命令，将结果展平（把所有空白字符，包括换行符，转换为空格），并返回最终的字符串。'
- en: 'For example, if you want to get the output of the `date` command into a variable
    called `NOW`, you write:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想将`date`命令的输出存入一个名为`NOW`的变量，你可以这样写：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you want to count the number of files in the current directory and get that
    number into `FILE_COUNT`, do this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想统计当前目录中的文件数量，并将该数量存入`FILE_COUNT`，可以这样做：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Because `$(shell)` flattens output to get the names of all the files in the
    current directory into a variable, the following works:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`$(shell)`会将输出展平，获取当前目录中所有文件的名称并将其存入一个变量，以下方法有效：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The newline between files is replaced with a single space, making `FILES` a
    space-separated list of filenames.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 文件之间的换行符被替换为一个空格，使得`FILES`成为一个用空格分隔的文件名列表。
- en: 'It’s common to see an execution of the `pwd` command to get the current working
    directory into a variable (in this case `CWD`):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的做法是执行`pwd`命令，将当前工作目录存入一个变量（在此例中为`CWD`）：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ll look at the `pwd` command later when considering how to optimize an example
    makefile that wastes time getting the working directory over and over again.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会查看`pwd`命令，考虑如何优化一个示例makefile，避免重复多次获取当前工作目录。
- en: The Difference Between = and :=
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`=`和`:=`的区别'
- en: 'Ninety-nine percent of the time, you’ll see variable definitions in makefiles
    that use the `=` form, like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 百分之九十九的情况下，你会看到在makefile中使用`=`形式的变量定义，像这样：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, variables `FOO`, `BAR`, and `FOOBAR` are *recursively expanded* variables.
    That means that when the value of a variable is needed, any variables that it
    references are expanded at that point. For example, if the value of `$(FOOBAR)`
    is needed, GNU `make` gets the value of `$(FOO)` and `$(BAR)`, puts them together
    with the space in between, and returns `foo bar`. Expansion through as many levels
    of variables as necessary is done when the variable is used.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，变量`FOO`、`BAR`和`FOOBAR`是*递归展开*的变量。这意味着，当需要一个变量的值时，任何它引用的变量都会在此时展开。例如，如果需要`$(FOOBAR)`的值，GNU
    `make`会获取`$(FOO)`和`$(BAR)`的值，将它们合并并在中间加上空格，最终返回`foo bar`。通过必要的多级变量展开会在变量使用时完成。
- en: 'In this makefile `FOOBAR` has two different values. Running it prints out:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个makefile中，`FOOBAR`有两个不同的值。运行它会输出：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The value of `FOOBAR` is used to define the list of prerequisites to the `all`
    rule and is expanded as `foo bar`; the same thing happens for the next rule ➊,
    which defines rules for `foo` and `bar`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`FOOBAR`的值用于定义`all`规则的先决条件列表，并被展开为`foo bar`；同样的事情也发生在下一个规则➊中，该规则定义了`foo`和`bar`的规则。'
- en: But when the rules are *run*, the value of `FOOBAR` as used in the `echo` produces
    `fooey barney`. (You can verify that the value of `FOOBAR` was `foo bar` when
    the rules were defined by looking at the value of `$@`, the target being built,
    when the rules are run).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当规则被*执行*时，在`echo`中使用的`FOOBAR`的值会产生`fooey barney`。（你可以通过查看`$@`的值来验证，在规则定义时`FOOBAR`的值是`foo
    bar`，`$@`是正在构建的目标，规则执行时可以查看它的值）。
- en: 'Keep in mind the following two cases:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住以下两种情况：
- en: When a rule is being defined in a makefile, variables will evaluate to their
    value *at that point* in the makefile.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在makefile中定义规则时，变量会评估为*那个时刻*在makefile中的值。
- en: 'Variables used in recipes (that is, in the commands) have the final value:
    whatever value the variable had at the end of the makefile.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在配方中使用的变量（即在命令中）会有最终的值：无论变量在makefile的末尾时是什么值。
- en: 'If the definition of `FOOBAR` is changed to use a `:=` instead of `=`, running
    the makefile produces a very different result:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`FOOBAR`的定义改为使用`:=`而不是`=`，运行makefile将产生完全不同的结果：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now `FOOBAR` has the same value everywhere. This is because `:=` forces the
    right side of the definition to be expanded at that moment during makefile parsing.
    Rather than storing `$(FOO) $(BAR)` as the definition of `FOOBAR`, GNU `make`
    stores the expansion of `$(FOO) $(BAR)`, which at that point is `foo bar`. The
    fact that `FOO` and `BAR` are redefined later in the makefile is irrelevant; `FOOBAR`
    has already been expanded and set to a fixed string. GNU `make` refers to variables
    defined in this way as *simply expanded*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`FOOBAR`在所有地方都有相同的值。这是因为`:=`强制在makefile解析时立刻展开定义的右侧内容。GNU `make`没有将`$(FOO)
    $(BAR)`作为`FOOBAR`的定义，而是存储了`$(FOO) $(BAR)`的展开结果，在那个时刻就是`foo bar`。即使后来在makefile中重新定义了`FOO`和`BAR`，也不影响结果；`FOOBAR`已经被展开并设置为固定字符串。GNU
    `make`将这种方式定义的变量称为*简单展开*。
- en: Once a variable has become simply expanded, it remains that way unless it is
    redefined using the `=` operator. This means that when text is appended to a simply
    expanded variable, it is expanded before being added to the variable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个变量变为简单展开变量，它就会保持这种状态，除非通过`=`操作符重新定义。这意味着当文本追加到一个简单展开变量时，它会在添加到变量之前进行展开。
- en: 'For example, this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: results in `FOOBAR` being `foo bar baz`. If `=` had been used instead of `:=`,
    when `$(BAZ)` was appended, it would not have been expanded and the resulting
    `FOOBAR` would have been `foo baz bazzy`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 导致`FOOBAR`变为`foo bar baz`。如果使用`=`而不是`:=`，当`$(BAZ)`被追加时，它不会被展开，结果是`FOOBAR`将变为`foo
    baz bazzy`。
- en: The Hidden Cost of =
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`=`的隐性成本'
- en: 'Take a look at this example makefile:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个示例的makefile：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It gets the current working directory into `CWD`, defines a source and object
    directory as subdirectories of the `CWD`, defines a set of objects (`foo.o`, `bar.o`,
    and `baz.o`) to be built in the `OBJ_DIR`, sets up a pattern rule showing how
    to build a `.o` from a `.c`, and finally states that by default the makefile should
    build all the objects and print out a list of those that were out of date (`$?`
    is the list of prerequisites of a rule that were out of date) as well as a full
    list of objects.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它将当前工作目录获取到`CWD`中，定义源目录和目标目录为`CWD`的子目录，定义一组对象（`foo.o`、`bar.o`和`baz.o`），将在`OBJ_DIR`中构建，设置一个模式规则，展示如何从`.c`文件构建`.o`文件，最后声明默认情况下，makefile应构建所有对象并打印出那些过时的对象的列表（`$?`是过时规则的前提条件列表），以及所有对象的完整列表。
- en: You might be surprised to learn that this makefile ends up making eight shell
    invocations just to get the `CWD` value. Imagine how many times GNU `make` would
    make costly calls to the shell in a real makefile with hundreds or thousands of
    objects!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地发现，这个makefile最终只为了获取`CWD`值就进行了八次shell调用。试想一下，在一个包含成百上千个对象的真实makefile中，GNU
    `make`会进行多少次耗时的shell调用！
- en: 'So many calls to `$(shell)` are made because the makefile uses recursively
    expanded variables: variables whose value is determined when the variable is used
    but not at definition time. `OBJS` references `OBJ_DIR` three times, which references
    `CWD` each time; every time `OBJS` is referenced, three calls are made to `$(shell
    pwd)`. Any other reference to `SRC_DIR` or `OBJ_DIR` (for example, the pattern
    rule definition) results in another `$(shell pwd)`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于makefile使用了递归展开变量（即变量的值在使用时确定，而不是在定义时确定），因此会进行许多`$(shell)`调用：`OBJS`引用`OBJ_DIR`三次，每次都引用`CWD`；每次引用`OBJS`时，都会对`$(shell
    pwd)`进行三次调用。任何对`SRC_DIR`或`OBJ_DIR`的引用（例如，模式规则定义）都会导致另一次`$(shell pwd)`调用。
- en: 'But a quick fix for this is just to change the definition of `CWD` to simply
    expand by inserting a `:` to turn `=` into `:=`. Because the working directory
    doesn’t change during the `make`, we can safely get it once:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但一个快速的解决方法是将`CWD`的定义更改为通过插入`:`来展开，将`=`变为`:=`。因为工作目录在`make`过程中不会改变，所以我们可以安全地获取一次：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, a single call out to the shell is made to get the working directory. In
    a real makefile this could be a huge time-saver.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过对shell进行一次调用来获取工作目录。在真实的makefile中，这可能是一个巨大的节省时间的办法。
- en: 'Because it can be difficult to follow through a makefile to see everywhere
    a variable is used, you can use a simple trick that will cause `make` to print
    out the exact line at which a variable is expanded. Insert `$(warning Call to
    shell)` in the definition of `CWD` so that its definition becomes this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在makefile中追踪变量的使用可能会很困难，你可以使用一个简单的技巧，使`make`打印出变量展开的确切位置。在`CWD`的定义中插入`$(warning
    Call to shell)`，使其定义变为如下：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then you get the following output when you run `make`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当你运行`make`时，会得到以下输出：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `$(warning)` doesn’t change the value of `CWD`, but it does output a message
    to `STDERR`. From the output you can see the eight calls to the shell and which
    lines in the makefile caused them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(warning)`不会改变`CWD`的值，但它会输出一条消息到`STDERR`。从输出中，你可以看到八次对shell的调用以及这些调用在makefile中是由哪几行引起的。'
- en: 'If `CWD` is defined using `:=`, the `$(warning)` trick verifies that `CWD`
    is expanded only once:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`CWD`是使用`:=`定义的，`$(warning)`技巧可以验证`CWD`仅被展开一次：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A quick way to determine if a makefile uses the expensive combination of `=`
    and `$(shell)` is to run the command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速的检查makefile是否使用了`=`和`$(shell)`这种耗时组合的方法是运行以下命令：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This prints out the line number and details of every line in the makefile that
    contains a `$(shell)` and doesn’t contain a `:=`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出包含`$(shell)`且不包含`:=`的每一行的行号和详细信息。
- en: $(eval) and Variable Caching
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: $(eval) 和变量缓存
- en: In the previous section, you learned how to use `:=` to speed up makefiles by
    not repeatedly performing a `$(shell)`. Unfortunately, it can be problematic to
    rework makefiles to use `:=` because they may rely on being able to define variables
    in any order.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何使用 `:=` 来通过避免反复执行 `$(shell)` 来加速 makefile。不幸的是，重新修改 makefile 以使用
    `:=` 可能会有问题，因为它们可能依赖于能够按照任何顺序定义变量。
- en: In this section, you’ll learn how to use GNU `make`’s `$(eval)` function to
    get the benefits of recursively expanded variables using `=` while getting the
    sort of speedup that’s possible with `:=`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用 GNU `make` 的 `$(eval)` 函数，在使用 `=` 扩展变量的递归优势的同时，获得类似于 `:=` 的速度提升。
- en: About $(eval)
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 `$(eval)`
- en: '`$(eval)`’s argument is expanded and then parsed as if it were typed in as
    part of a makefile. As a result, within a `$(eval)` (which could be inside a variable
    definition) you can programmatically define variables, create rules (explicit
    or pattern), include other makefiles, and so on. It’s a powerful function.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(eval)` 的参数会被扩展，然后像 makefile 中的部分内容一样解析。因此，在 `$(eval)` 中（它可能位于变量定义内），你可以编程式地定义变量、创建规则（显式或模式规则）、包含其他
    makefile 等等。这是一个强大的函数。'
- en: 'Here’s an example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This results in `FOO` having the value `BAR` and `A` having the value `B`. Obviously,
    this example could have been achieved without `$(eval)`, but it’s easy to see
    how you can use `$(eval)` to make programmatic changes to the definitions in a
    makefile.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致 `FOO` 的值为 `BAR`，`A` 的值为 `B`。显然，这个例子可以在没有 `$(eval)` 的情况下实现，但很容易看出如何使用 `$(eval)`
    对 makefile 中的定义进行编程式修改。
- en: An $(eval) Side Effect
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个 `$(eval)` 副作用
- en: 'One use of `$(eval)` is to create side effects. For example, here’s a variable
    that is actually an auto-incrementing counter (it uses the arithmetic functions
    from the GMSL):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(eval)` 的一种用途是创建副作用。例如，这里有一个变量，实际上是一个自动递增的计数器（它使用了 GMSL 的算术函数）：'
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Every time `counter` is used, its value is incremented by one. For example,
    the following sequence of `$(info)` functions outputs numbers in sequence starting
    from `0`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每次使用 `counter` 时，它的值都会增加1。例如，以下 `$(info)` 函数序列会按顺序输出从 `0` 开始的数字：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here’s the output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You could use a simple side effect like this to find out how often a particular
    variable is reevaluated by GNU `make`. You might be surprised at the result. For
    example, when building GNU `make`, the variable `srcdir` from its makefile is
    accessed 48 times; `OBJEXT` is accessed 189 times, and that’s in a very small
    project.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用像这样的简单副作用来找出 GNU `make` 重新评估某个变量的频率。你可能会对结果感到惊讶。例如，在构建 GNU `make` 时，它的
    makefile 中的变量 `srcdir` 被访问了48次；`OBJEXT` 被访问了189次，而这只是一个非常小的项目。
- en: GNU `make` wastes time accessing an unchanging variable by looking at the same
    string repeatedly. If the variable being accessed is long (such as a long path)
    or contains calls to `$(shell)` or complex GNU `make` functions, the performance
    of variable handling could affect the overall runtime of a `make`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 通过重复访问相同的字符串浪费时间来访问不变的变量。如果被访问的变量很长（例如长路径）或包含 `$(shell)` 调用或复杂的 GNU
    `make` 函数，那么变量处理的性能可能会影响 `make` 的整体运行时间。
- en: That’s especially important if you are trying to minimize build time by parallelizing
    the `make` or if a developer is running an incremental build requiring just a
    few files to be rebuilt. In both cases a long startup time by GNU `make` could
    be very inefficient.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图通过并行化 `make` 来最小化构建时间，或者开发人员正在运行只需要重新构建少数文件的增量构建，这一点尤其重要。在这两种情况下，GNU `make`
    的长启动时间可能会非常低效。
- en: Caching Variable Values
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存变量值
- en: 'GNU `make` does provide a solution to the problem of reevaluating a variable
    over and over again: use `:=` instead of `=`. A variable defined using `:=` gets
    its value set once and for all, the right side is evaluated once, and the resulting
    value is set in the variable. Using := can cause a makefile to be parsed more
    quickly because the right side is evaluated only once. But it does introduce limitations,
    so it is rarely used. One limitation is that it requires variable definitions
    to be ordered a certain way. For example, if ordered this way:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 确实提供了解决反复重新评估变量问题的方案：使用 `:=` 代替 `=`。使用 `:=` 定义的变量会将其值设置为一次性确定，右侧的表达式只会被评估一次，结果值被设置到变量中。使用
    `:=` 可以使 makefile 解析更快，因为右侧只会被评估一次。但它确实引入了一些限制，因此很少使用。一个限制是它要求变量定义的顺序必须特定。例如，如果按如下顺序排列：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'the result in `FOO` would have a totally different value than if it was ordered
    this way:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按照这种顺序排列，`FOO` 中的结果将与其它顺序下的值完全不同：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the first snippet `FOO` is empty, and in the second `FOO` is `bar`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个代码片段中，`FOO`是空的，而在第二个代码片段中，`FOO`是`bar`。
- en: 'Contrast that with the simplicity of the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与以下内容的简洁性相比：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, `FOO` is `bar`. Most makefiles are written in this style, and only very
    conscientious (and speed conscious) makefile authors use `:=`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`FOO` 的值是 `bar`。大多数 makefile 都是以这种方式编写的，只有非常用心（且注重速度）的 makefile 编写者才会使用 `:=`。
- en: On the other hand, almost all of these recursively defined variables only ever
    have one value when used. The long evaluation time for a complex recursively defined
    variable is a convenience for the makefile author.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，几乎所有这些递归定义的变量在使用时只有一个值。复杂的递归定义变量的长时间求值对于 makefile 编写者来说是一种便利。
- en: An ideal solution would be to cache variable values so the flexibility of the
    `=` style is preserved, but the variables are only evaluated once for speed. Clearly,
    this would cause a minor loss of flexibility, because a variable can’t take two
    different values (which is sometimes handy in a makefile). But for most uses,
    it would provide a significant speed boost.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的解决方案是缓存变量值，以便保留`=`样式的灵活性，但变量只在首次计算时进行求值，从而提高速度。显然，这会导致灵活性略有丧失，因为变量不能取两个不同的值（这在
    makefile 中有时是有用的）。但对于大多数用途来说，这会显著提升速度。
- en: Speed Improvements with Caching
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用缓存的速度提升
- en: 'Consider the example makefile in [Example 4-1](ch04.html#in_this_makefilecomma_foo_and_c_are_usel
    "Example 4-1. In this makefile, FOO and C are uselessly evaluated over and over
    again."):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见示例 makefile 在 [示例 4-1](ch04.html#in_this_makefilecomma_foo_and_c_are_usel
    "示例 4-1。在这个 makefile 中，FOO 和 C 被无意义地反复求值。") 中。
- en: Example 4-1. In this makefile, `FOO` and `C` are uselessly evaluated over and
    over again.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-1。在这个 makefile 中，`FOO`和`C`被无意义地反复求值。
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It defines a variable `C`, which is a long string (it’s actually `1234567890`
    repeated 2,048 times followed by the alphabet repeated 2,048 times plus spaces
    for a total of 77,824 characters). Here `:=` is used so that `C` is created quickly.
    `C` is designed to emulate the sort of long strings that are generated within
    makefiles (for example, long lists of source files with paths).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 它定义了一个变量 `C`，这是一个长字符串（实际上是 `1234567890` 重复 2,048 次，再加上字母表重复 2,048 次，最后加上空格，总共有
    77,824 个字符）。在这里使用 `:=`，以便快速创建 `C`。`C` 旨在模拟在 makefile 中生成的长字符串（例如，带路径的源文件长列表）。
- en: Then a variable `FOO` is defined that manipulates `C` using the built-in `$(subst)`
    function. `FOO` emulates the sort of manipulation that occurs within makefiles
    (such as changing filename extensions from `.c` to `.o`).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后定义一个变量 `FOO`，使用内建的 `$(subst)` 函数来操作 `C`。`FOO` 模拟了 makefile 中的操作（例如，将文件名扩展名从
    `.c` 改为 `.o`）。
- en: Finally, `$(FOO)` is evaluated 200 times to emulate the use of `FOO` in a small
    but realistically sized makefile. The makefile does nothing; there’s a dummy,
    empty `all` rule at the end.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`$(FOO)`在小而实际的 makefile 中被求值200次，模拟了`FOO`的使用。这个 makefile 什么也不做；最后有一个虚拟的、空的
    `all` 规则。
- en: On my laptop, using GNU `make` 3.81, this makefile takes about 3.1 seconds to
    run. That’s a long time spent repeatedly manipulating `C` and `FOO` but not doing
    any actual building.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的笔记本上，使用 GNU `make` 3.81，这个 makefile 运行大约需要 3.1 秒。这是大量时间都花在反复操作 `C` 和 `FOO`，但并没有进行实际的构建。
- en: Using the `counter` trick from [An $(eval) Side Effect](ch04.html#dollarleft_parenthesisevalright-id00007
    "An $(eval) Side Effect"), you can figure out how many times `FOO` and `C` are
    evaluated in this makefile. `FOO` was evaluated 200 times and `C` 1600 times.
    It’s amazing how fast these evaluations can add up.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来自 [An $(eval) Side Effect](ch04.html#dollarleft_parenthesisevalright-id00007
    "An $(eval) Side Effect") 的 `counter` 技巧，你可以计算出在这个 makefile 中 `FOO` 和 `C` 被求值的次数。`FOO`
    被求值了 200 次，而 `C` 被求值了 1600 次。令人惊讶的是，这些求值可以加起来非常快。
- en: 'But the values of `C` and `FOO` need to be calculated only once, because they
    don’t change. Let’s say you alter the definition of `FOO` to use `:=`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `C` 和 `FOO` 的值只需要计算一次，因为它们不会改变。假设你修改了 `FOO` 的定义，使用 `:=`：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This drops the runtime to 1.8 seconds, `C` is evaluated nine times, and `FOO`
    is evaluated just once. But, of course, that requires using `:=` with all its
    problems.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行时间降至 1.8 秒，`C` 被求值九次，而 `FOO` 只被求值一次。但当然，这需要使用 `:=`，并且会带来它的所有问题。
- en: A Caching Function
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个缓存函数
- en: 'An alternative caching function is this simple caching scheme:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种缓存功能是这个简单的缓存方案：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: First, a function called `cache` is defined, which automatically caches a variable’s
    value the first time it is evaluated and retrieves it from the cache for each
    subsequent attempt to retrieve it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义了一个名为`cache`的函数，它会在变量第一次被评估时自动缓存该变量的值，并在随后的每次尝试获取该值时从缓存中取出。
- en: '`cache` uses two variables to store the cached value of a variable (when caching
    variable `A`, the cached value is stored in `cache-A`) and whether the variable
    has been cached (when caching variable `A`, the *has been cached flag* is `cached-A`).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`cache`使用两个变量来存储变量的缓存值（在缓存变量`A`时，缓存值存储在`cache-A`中）以及该变量是否已被缓存（在缓存变量`A`时，*已缓存标志*是`cached-A`）。'
- en: First, it checks to see whether the variable has been cached; if it has, the
    `$(if)` does nothing. If it hasn’t, the cached flag is set for that variable in
    the first `$(eval)` and then the value of the variable is expanded (notice the
    `$($1)`, which gets the name of the variable and then gets its value) and cached.
    Finally, `cache` returns the value from cache.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它检查变量是否已经缓存；如果缓存过，则`$(if)`什么也不做。如果没有缓存，则在第一次`$(eval)`中设置该变量的缓存标志，然后扩展变量的值（注意`$($1)`，它获取变量的名称并获取其值），并进行缓存。最后，`cache`返回缓存中的值。
- en: To update the makefile, simply turn any reference to a variable into a call
    to the `cache` function. For example, you can modify the makefile from [Example 4-1](ch04.html#in_this_makefilecomma_foo_and_c_are_usel
    "Example 4-1. In this makefile, FOO and C are uselessly evaluated over and over
    again.") by changing all occurrences of `$(FOO)` to `$(call cache,FOO)` using
    a simple find and replace. The result is shown in [Example 4-2](ch04.html#modified_version_of_listing_4-1_that_use
    "Example 4-2. A modified version of Example 4-1 that uses the cache function").
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新 makefile，只需将任何对变量的引用改为调用`cache`函数。例如，你可以通过简单的查找和替换，将[示例 4-1](ch04.html#in_this_makefilecomma_foo_and_c_are_usel
    "示例 4-1. 在这个 makefile 中，FOO 和 C 被无意义地多次求值")中的所有`$(FOO)`更改为`$(call cache,FOO)`。结果如[示例
    4-2](ch04.html#modified_version_of_listing_4-1_that_use "示例 4-2. 一个修改版的示例 4-1，使用了
    cache 函数")所示。
- en: Example 4-2. A modified version of [Example 4-1](ch04.html#in_this_makefilecomma_foo_and_c_are_usel
    "Example 4-1. In this makefile, FOO and C are uselessly evaluated over and over
    again.") that uses the `cache function`
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-2. 使用`cache`函数的[示例 4-1](ch04.html#in_this_makefilecomma_foo_and_c_are_usel
    "示例 4-1. 在这个 makefile 中，FOO 和 C 被无意义地多次求值")的修改版。
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Running this on my machine shows that there’s now one access of `FOO`, the same
    nine accesses of `C`, and a runtime of 2.4 seconds. It’s not as fast as the `:=`
    version (which took 1.8 seconds), but it’s still 24 percent faster. On a big makefile,
    this technique could make a real difference.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上运行此代码后，显示现在有一次访问`FOO`，仍然是九次访问`C`，并且运行时间为2.4秒。这不如`:=`版本（耗时1.8秒）快，但仍然快了24%。在一个大的
    makefile 中，这种技术可能会带来实际的差异。
- en: Wrapping Up
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: The fastest way to handle variables is to use `:=` whenever you can, but it
    requires care and attention, and is probably best done only in a new makefile
    (just imagine trying to go back and reengineer an existing makefile to use `:=`).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 处理变量的最快方式是尽可能使用`:=`，但这需要小心和注意，最好只在新的 makefile 中进行（想象一下尝试回去重新设计一个已有的 makefile
    来使用`:=`）。
- en: If you’re stuck with `=`, the `cache` function presented here can give you a
    speed boost that developers doing incremental short builds will especially appreciate.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你被`=`困住了，这里介绍的`cache`函数可以提供一个速度提升，尤其是对于进行增量短构建的开发者来说，这将是非常有用的。
- en: 'If it’s only necessary to change a single variable definition, it’s possible
    to eliminate the `cache` function. For example, here’s the definition of `FOO`
    changed to magically switch from being recursively defined to a simple definition:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只需要更改单个变量的定义，可以消除`cache`函数。例如，下面是将`FOO`的定义更改为神奇地从递归定义切换到简单定义的示例：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first time `$(FOO)` is referenced, the `$(eval)` happens, turning `FOO`
    from a recursively defined variable to a simple definition (using `:=`). The `$(value
    FOO)` at the end returns the value stored in `FOO`, making this process transparent.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次引用`$(FOO)`时，会触发`$(eval)`，将`FOO`从递归定义的变量变为简单定义（使用`:=`）。最后的`$(value FOO)`返回存储在`FOO`中的值，使得这个过程变得透明。
- en: The Trouble with Hidden Targets
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏目标的问题
- en: 'Take a look at the makefile in [Example 4-3](ch04.html#in_this_makefilecomma_the_rule_to_make_f
    "Example 4-3. In this makefile, the rule to make foo also makes foo.c."):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[示例 4-3](ch04.html#in_this_makefilecomma_the_rule_to_make_f "示例 4-3. 在这个 makefile
    中，构建 foo 的规则也构建了 foo.c")中的 makefile：
- en: Example 4-3. In this makefile, the rule to make `foo` also makes `foo.c`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-3。在这个 makefile 中，生成 `foo` 的规则也会生成 `foo.c`。
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It contains a nasty trap for the unwary that can cause `make` to report odd
    errors, stop the `-n` option from working, and prevent a speedy parallel `make`.
    It can even cause GNU `make` to do the wrong work and update an up-to-date file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含了一个危险的陷阱，可能会导致 `make` 报告奇怪的错误，停止 `-n` 选项的正常工作，并阻止快速的并行 `make`。它甚至可能导致 GNU
    `make` 做错工作，并更新一个已经是最新的文件。
- en: 'On the face of it this makefile looks pretty simple. If you run it through
    GNU `make`, it’ll build `foo` (which creates the files `foo` and `foo.c`) and
    then use the pattern at the bottom to make `foo.o` from `foo.c`. It ends up running
    the following commands:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面看，这个 makefile 看起来很简单。如果你通过 GNU `make` 执行它，它会先构建 `foo`（生成文件 `foo` 和 `foo.c`），然后使用底部的模式从
    `foo.c` 生成 `foo.o`。它最终会运行以下命令：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: But there’s a fatal flaw. Nowhere does this makefile mention that the rule to
    make `foo` actually also makes `foo.c`. So `foo.c` is a *hidden target*, a file
    that was built but that GNU `make` is unaware of, and hidden targets cause an
    endless number of problems.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但其中有一个致命的缺陷。这个 makefile 中没有提到生成 `foo` 的规则实际上也生成了 `foo.c`。因此，`foo.c` 是一个*隐藏目标*，这是一个已经构建但
    GNU `make` 不知道的文件，而隐藏目标会引发无数问题。
- en: GNU `make` is very good at keeping track of targets, files that need to be built,
    and the dependencies between targets. But the `make` program is only as good as
    its inputs. If you don’t tell `make` about a relationship between two files, it
    won’t discover it on its own and it’ll make mistakes because it assumes it has
    perfect knowledge about the files and their relationships.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 在跟踪目标、需要构建的文件以及目标之间的依赖关系方面非常擅长。但 `make` 程序的表现好坏取决于其输入。如果你没有告诉 `make`
    两个文件之间的关系，它不会自己发现这个关系，而且它会因为假设自己对文件及其关系拥有完美的了解而犯错误。
- en: In this example, `make` only works because it builds the prerequisites of `all`
    from left to right. First it encounters `foo`, which it builds, creating `foo.c`
    as a side effect, and then it builds `foo.o` using the pattern. If you change
    the order of the prerequisites of `all` so that it doesn’t build `foo` first,
    the build will fail.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`make` 之所以能工作，是因为它按从左到右的顺序构建 `all` 的先决条件。首先它遇到 `foo`，构建了它，并副作用地创建了 `foo.c`，然后再使用模式构建
    `foo.o`。如果你改变 `all` 的先决条件的顺序，使得它不先构建 `foo`，构建就会失败。
- en: There are (at least!) five nasty side effects of hidden targets.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏目标至少有五个可怕的副作用。
- en: An Unexpected Error if the Hidden Target Is Missing
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果隐藏目标缺失，会发生意外错误
- en: 'Suppose that `foo` exists, but `foo.c` and `foo.o` are missing:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `foo` 存在，但 `foo.c` 和 `foo.o` 丢失：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`make` tries to update `foo.o`, but because it doesn’t know how to make `foo.c`
    (because it’s not mentioned as the target of any rule), invoking GNU `make` results
    in an error.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`make` 试图更新 `foo.o`，但因为它不知道如何生成 `foo.c`（因为它没有被列为任何规则的目标），调用 GNU `make` 会导致错误。'
- en: The -n Option Fails
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: -n 选项失效
- en: 'The helpful `-n` debugging option in GNU `make` tells it to print out the commands
    that it would run to perform the build without actually running them:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 中有一个有用的 `-n` 调试选项，它会告诉 `make` 打印出它将要运行的命令，而不是实际运行它们：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You’ve seen that `make` would actually perform two `touch` commands (`touch
    foo foo.c` followed by `touch foo.o`), but doing a `make -n` (with no `foo*` files
    present) results in an error. `make` doesn’t know that the rule for `foo` makes
    `foo.c`, and because it hasn’t actually run the `touch` command, `foo.c` is missing.
    Thus, the `-n` doesn’t represent the actual commands that `make` would run, making
    it useless for debugging.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，`make` 实际上会执行两个 `touch` 命令（`touch foo foo.c`，然后是 `touch foo.o`），但执行 `make
    -n`（没有 `foo*` 文件时）会导致错误。`make` 不知道生成 `foo` 的规则还会生成 `foo.c`，而且因为它没有实际运行 `touch`
    命令，`foo.c` 就缺失了。因此，`-n` 不代表 `make` 实际会执行的命令，这使得它在调试时没有用处。
- en: You Can’t Parallelize make
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你无法并行化 make
- en: GNU `make` provides a handy feature that allows it to run multiple jobs at once.
    If you have many compiles in a build, specifying the `-j` option (followed by
    a number indicating the number of jobs to run at the same time) can maximize CPU
    utilization and shorten the build.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 提供了一个方便的功能，允许它同时运行多个作业。如果构建中有多个编译任务，可以指定 `-j` 选项（后面跟一个数字，表示同时运行的作业数），以最大化
    CPU 使用率并缩短构建时间。
- en: 'Unfortunately, a hidden target spoils that plan. Here’s the output from `make
    -j3` running three jobs at once on our example makefile from [Example 4-3](ch04.html#in_this_makefilecomma_the_rule_to_make_f
    "Example 4-3. In this makefile, the rule to make foo also makes foo.c."):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '不幸的是，一个隐藏的目标破坏了这个计划。以下是运行`make -j3`在我们的示例makefile中同时运行三个任务时的输出，参考自[示例4-3](ch04.html#in_this_makefilecomma_the_rule_to_make_f
    "示例4-3。在这个makefile中，构建foo的规则也构建了foo.c。"):'
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: GNU `make` tried to build `foo`, `foo.o`, and `foo.c` at the same time, and
    discovered that it didn’t know how to build `foo.c` because it had no way of knowing
    that it should wait for `foo` to be made.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make`尝试同时构建`foo`、`foo.o`和`foo.c`，并发现它不知道如何构建`foo.c`，因为它无法知道应该等待`foo`被构建。
- en: make Does the Wrong Work if the Hidden Target Is Updated
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果隐藏目标被更新，make会做错工作
- en: 'Suppose the file `foo.c` already exists when `make` is run. Because `make`
    doesn’t know that the rule for `foo` will mess with `foo.c`, it’ll get updated
    even though it’s up-to-date. In [Example 4-2](ch04.html#modified_version_of_listing_4-1_that_use
    "Example 4-2. A modified version of Example 4-1 that uses the cache function"),
    `foo.c` is altered by a benign `touch` operation that only alters the file’s timestamp,
    but a different operation could destroy or overwrite the contents of the file:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`foo.c`文件在运行`make`时已经存在。因为`make`不知道`foo`的规则会影响到`foo.c`，它会被更新，即使它已经是最新的。在[示例4-2](ch04.html#modified_version_of_listing_4-1_that_use
    "示例4-2。修改版示例4-1，使用了缓存函数")中，`foo.c`被一个无害的`touch`操作修改，只有文件的时间戳被改变，但不同的操作可能会破坏或覆盖文件的内容：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`make` rebuilds `foo` because it’s missing and updates `foo.c` at the same
    time, even though it was apparently up-to-date.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`make`重建了`foo`，因为它缺失，并同时更新了`foo.c`，即使它显然是最新的。'
- en: You Can’t Direct make to Build foo.o
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你不能直接让make构建foo.o
- en: 'You’d hope that typing `make foo.o` would result in GNU `make` building `foo.o`
    from `foo.c` and, if necessary, building `foo.c`. But `make` doesn’t know how
    to build `foo.c`. That just happens by accident when building `foo`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望输入`make foo.o`会导致GNU `make`从`foo.c`构建`foo.o`，并在必要时构建`foo.c`。但是`make`不知道如何构建`foo.c`。当构建`foo`时，`foo.c`恰好被构建出来：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: So if `foo.c` is missing, `make foo.o` results in an error.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果`foo.c`缺失，`make foo.o`会导致错误。
- en: Hopefully, you’re now convinced that hidden targets are a bad idea and can lead
    to all sorts of build problems.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 希望现在你已经相信隐藏目标是一个坏主意，并且可能会导致各种构建问题。
- en: GNU make’s Escaping Rules
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GNU make的转义规则
- en: Sometimes you’ll need to insert a special character in a makefile. Perhaps you
    need a newline inside an `$(error)` message, a space character in a `$(subst)`,
    or a comma as the argument to a GNU `make` function. Those three simple tasks
    can be frustratingly difficult to do in GNU `make`; this section takes you through
    simple syntax that eliminates the frustration.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要在makefile中插入特殊字符。也许你需要在`$(error)`消息中插入换行符、在`$(subst)`中插入空格字符，或者作为GNU `make`函数的参数插入逗号。这三项简单的任务在GNU
    `make`中可能会让人非常沮丧；本节将带你通过简单的语法，消除这些沮丧。
- en: GNU `make`’s use of the tab character at the start of any line containing commands
    is a notorious language feature, but some other special characters can also trip
    you up. The ways GNU `make` handles `$`, `%`, `?`, `*`, `[`, `~`, `\`, and `#`
    are all special.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make`在包含命令的任何行开头使用制表符字符是一个著名的语言特性，但一些其他特殊字符也可能会让你困惑。GNU `make`处理`$`、`%`、`?`、`*`、`[`、`~`、`\`和`#`的方式都是特殊的。
- en: Dealing with $
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理`$`
- en: Every GNU `make` user is familiar with `$` for starting a variable reference.
    It’s possible to write `$(variable)` (with parentheses) or `${variable}` (with
    curly brackets) to get the value of `variable`, and if the variable name is a
    single character (such as `a`), you can drop the parentheses and just use `$a`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每个GNU `make`用户都熟悉`$`，它用于开始变量引用。你可以写`$(variable)`（带括号）或`${variable}`（带大括号）来获取`variable`的值，如果变量名是单个字符（如`a`），你可以省略括号，直接使用`$a`。
- en: 'To get a literal `$`, you write `$$`. So to define a variable containing a
    single `$` symbol you’d write: `dollar := $$`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取字面量的`$`，你需要写`$$`。因此，要定义一个包含单个`$`符号的变量，你可以写：`dollar := $$`。
- en: Playing with %
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩转`%`
- en: 'Escaping `%` is not as simple as `$`, but it needs to be done in only three
    situations, and the same rules apply for each: in the `vpath` directive, in a
    `$(patsubst)`, and in a pattern or static-pattern rule.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 转义`%`不像`$`那么简单，但只需要在三种情况中做转义，并且相同的规则适用于每种情况：在`vpath`指令中，在`$(patsubst)`中，以及在模式或静态模式规则中。
- en: 'The three rules for `%` escaping are:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 转义`%`的三个规则是：
- en: You can escape `%` with a single `\` character (that is, `\%` becomes a literal
    `%`).
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以用一个单独的 `\` 字符来转义 `%`（也就是说，`\%` 就变成了字面量的 `%`）。
- en: If you need to put a literal `\` in front of a `%` (that is, you want the `\`
    to not escape the `%`), escape it with `\` (in other words, `\\%` becomes a literal
    `\` followed by a `%` character that *will* be used for the pattern match).
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要在 `%` 前加一个字面量的 `\`（也就是说，你希望 `\` 不转义 `%`），则使用 `\` 进行转义（换句话说，`\\%` 变成了字面量的
    `\` 后跟一个 `%` 字符，这个 `%` 将用于模式匹配）。
- en: Don’t worry about escaping `\` anywhere else in a pattern. It will be treated
    as a literal. For example, `\hello` is `\hello`.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不用担心在模式的其他地方转义 `\`。它会被当作字面量处理。例如，`\hello` 就是 `\hello`。
- en: Wildcards and Paths
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通配符和路径
- en: The symbols `?`, `*`, `[`, and `]` get treated specially when they appear in
    a filename. A makefile that has
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当符号 `?`、`*`、`[` 和 `]` 出现在文件名中时，它们会被特殊处理。一个包含以下内容的 makefile：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: will actually search for all `.c` files in the current directory and define
    a rule for each. The targets (along with prerequisites and files mentioned in
    the `include` directive) are globbed (the filesystem is searched and filenames
    matched against the wildcard characters) if they contain a wildcard character.
    The globbing characters have the same meaning as in the Bourne shell.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上会搜索当前目录中的所有 `.c` 文件，并为每个文件定义一个规则。目标（以及 `include` 指令中提到的先决条件和文件）如果包含通配符字符，则会被
    glob（文件系统被搜索，文件名与通配符字符匹配）。这些 glob 字符的意义与 Bourne shell 中相同。
- en: The `~` character is also handled specially in filenames and is expanded to
    the home directory of the current user.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`~` 字符在文件名中也有特殊处理，会被扩展为当前用户的主目录。'
- en: 'All of those special filename characters can be escaped with a `\`. For example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些特殊的文件名字符都可以通过 `\` 来转义。例如：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This makefile defines a rule for the file named (literally) `*.c`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 makefile 为名为（字面上的）`*.c` 的文件定义了一个规则。
- en: Continuations
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 续行
- en: 'Other than the escaping function, you can also use the `\` as a continuation
    character at the end of a line:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 除了转义功能外，你还可以在行尾使用 `\` 作为续行字符：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, the rule for `all` has three prerequisites: `prerequisite`, `something`,
    and `else`.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`all` 的规则有三个先决条件：`prerequisite`、`something` 和 `else`。
- en: Comments
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: 'You can use the `#` character to start a comment, and you can make it a literal
    with a `\` escape:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `#` 字符来开始注释，也可以通过 `\` 转义将其变成字面量：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here, `$(pound)` is a single character: `#`.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`$(pound)` 是一个单一字符：`#`。
- en: I Just Want a Newline!
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我只想要一个换行符！
- en: GNU `make` does its best to insulate you from the newline character. You can’t
    escape a newline—there’s no syntax for special characters (for example, you can’t
    write `\n`), and even the `$(shell)` function strips newlines from the returned
    value.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 尽最大努力将你与换行符隔离开。你不能转义换行符——没有特殊字符的语法（例如，你不能写 `\n`），即使是 `$(shell)` 函数也会从返回值中去掉换行符。
- en: 'But you can define a variable that contains a newline using the `define` syntax:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你可以使用 `define` 语法定义一个包含换行符的变量：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Note that this definition contains two blank lines, but using `$(newline)`
    will expand into only one newline, which can be useful for formatting error messages
    nicely:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个定义包含了两行空白行，但使用 `$(newline)` 只会展开成一个换行符，这对于格式化错误消息非常有用：
- en: '[PRE46]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Because of GNU `make`’s rather liberal variable naming rules, it’s possible
    to define a variable called `\n`. So if you like to maintain a familiar look,
    you can do this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 GNU `make` 相当宽松的变量命名规则，可以定义一个名为 `\n` 的变量。所以，如果你喜欢保持熟悉的外观，可以这样做：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We’ll look more at special variable names in the next section.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中更详细地讨论特殊的变量名。
- en: 'Function Arguments: Spaces and Commas'
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数参数：空格和逗号
- en: 'A problem that many GNU `make` users run into is the handling of spaces and
    commas in GNU `make` function arguments. Consider the following use of `$(subst)`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 GNU `make` 用户遇到的一个问题是处理 GNU `make` 函数参数中的空格和逗号。考虑以下 `$(subst)` 的用法：
- en: '[PRE48]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This takes three arguments separated by commas: the `from` text, the `to` text,
    and the string to change.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要三个由逗号分隔的参数：`from` 文本，`to` 文本，以及要更改的字符串。
- en: 'It defines a function called `spaces-to-commas` to convert all spaces in its
    argument to commas (which might be handy for making a CSV file for example). Unfortunately,
    it doesn’t work for two reasons:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 它定义了一个名为 `spaces-to-commas` 的函数，用于将参数中的所有空格转换为逗号（这对于制作 CSV 文件可能很有用）。不幸的是，它由于两个原因无法正常工作：
- en: The first argument of the `$(subst)` is a space. GNU `make` strips all leading
    and trailing whitespace around function arguments. In this case, the first argument
    is interpreted as an empty string.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$(subst)`的第一个参数是一个空格。GNU `make`会去掉函数参数两端的所有空白字符。在这种情况下，第一个参数会被解释为空字符串。'
- en: The second argument is a comma. GNU `make` cannot distinguish between the commas
    used for argument separators and the comma as an argument. In addition, there’s
    no way to escape the comma.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是一个逗号。GNU `make`无法区分用作参数分隔符的逗号和作为参数的逗号。此外，没有办法转义逗号。
- en: 'You can work around both issues if you know that GNU `make` does the whitespace
    stripping and separation of arguments before it does any expansion of the arguments.
    So if we can define a variable containing a space and a variable containing a
    comma, we can write the following to get the desired effect:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道GNU `make`在展开参数之前会进行空白字符的剥离和参数分隔，那么你可以绕过这两个问题。所以，如果我们能定义一个包含空格的变量和一个包含逗号的变量，我们可以写出如下的代码来达到预期效果：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Defining a variable containing a comma is easy, as shown here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个包含逗号的变量很简单，如下所示：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'But space is a bit harder. You can define a space in a couple of ways. One
    way is to use the fact that whenever you append to a variable (using `+=`), a
    space is inserted before the appended text:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 但是空格有点复杂。你可以通过几种方式定义一个空格。一个方法是利用每次向变量添加内容（使用`+=`）时，都会在添加的文本前插入一个空格：
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Another way is to first define a variable that contains nothing, and then use
    it to surround the space so that it doesn’t get stripped by GNU `make`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是先定义一个不包含任何内容的变量，然后用它来围绕空格，以防空格被GNU `make`剥离：
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You can also use this technique to get a literal tab character into a variable:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用这个技巧将一个字面上的制表符字符放入变量中：
- en: '[PRE53]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Much in the way that `$(\n)` was defined in the previous section, it’s possible
    to define specially named space and comma variables. GNU `make`’s rules are liberal
    enough to allow us to do this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一节中定义了`$(\n)`一样，定义特别命名的空格和逗号变量也是可能的。GNU `make`的规则足够宽松，允许我们这么做：
- en: '[PRE54]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The first line defines a variable called `,` (which can be used as `$(,)` or
    even `$,`) containing a comma.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了一个名为`,`的变量（可以用`$(,)`甚至`$,`），其内容是一个逗号。
- en: The last three lines define a variable called `space` containing a space character
    and then use it to define a variable named (that’s right, its name is a space
    character) containing a space.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三行定义了一个名为`space`的变量，其内容是一个空格字符，然后用它来定义一个名为（没错，它的名字就是一个空格字符）的变量，该变量包含一个空格。
- en: With that definition it’s possible to write `$( )` or even `$` (there’s a space
    after that `$`) to get a space character. Note that doing this might cause problems
    in the future as `make` is updated, so playing tricks like this can be dangerous.
    If you’re averse to risks, just use the variable named `space` and avoid `$( )`.
    Because whitespace is special in GNU `make`, pushing `make`’s parser to the limit
    with tricks like `$( )` might lead to breakages.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个定义，你可以写`$( )`甚至`$`（在那个`$`后面有一个空格）来获得一个空格字符。请注意，这样做可能会在未来的`make`更新中引发问题，因此像这样玩弄技巧可能是危险的。如果你不喜欢冒险，最好使用名为`space`的变量，避免使用`$(
    )`。因为空白字符在GNU `make`中是特殊的，通过像`$( )`这样的技巧将`make`的解析器推向极限可能会导致破坏。
- en: 'Using those definitions, the `spaces-to-commas` function can be written as:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些定义，可以将`spaces-to-commas`函数写成：
- en: '[PRE55]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This strange-looking definition replaces spaces with commas using `subst`. It
    works because the `$( )` will get expanded by `subst` and will itself be a space.
    That space will then be the first parameter (the string that will be replaced).
    The second parameter is `$(,)`, which, when expanded, becomes a `,`. The result
    is that `spaces-to-commas` turns spaces into commas without confusing GNU `make`
    with the actual space and comma characters.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看起来很奇怪的定义通过`subst`将空格替换为逗号。它之所以有效，是因为`$( )`会被`subst`展开，并且本身就是一个空格。这个空格会成为第一个参数（即将被替换的字符串）。第二个参数是`$(,)`，当它被展开时，会变成一个逗号。结果是，`spaces-to-commas`将空格转化为逗号，而不会让GNU
    `make`混淆空格和逗号字符。
- en: The Twilight Zone
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 《暮光之区》
- en: 'It’s possible to take definitions like `$( )` and `$(\n)` and go much further,
    defining variables with names like `=`, `#` or `:`. Here are other interesting
    variable definitions:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像定义`$( )`和`$(\n)`这样的变量定义一样，进一步发展，定义像`=`、`#`或`:`这样的变量名。以下是一些其他有趣的变量定义：
- en: '[PRE56]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'These definitions probably aren’t useful, but if you want to push GNU `make`
    syntax to its limits, try this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义可能没有太大用处，但如果你想将GNU `make`的语法推向极限，可以尝试以下方法：
- en: '[PRE57]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Yes, that defines a variable called `+` containing a `+`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这定义了一个名为 `+` 的变量，内容是一个 `+`。
- en: The Trouble with $(wildcard)
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`$(wildcard)` 的问题'
- en: The function `$(wildcard)` is GNU `make`’s globbing function. It’s a useful
    way of getting a list of files inside a makefile, but it can behave in unexpected
    ways. It doesn’t always provide the same answer as running `ls`. Read on to find
    out why and what to do about it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(wildcard)` 函数是 GNU `make` 的模式匹配函数。它是获取 makefile 中文件列表的一个有用方法，但它可能会表现得出乎意料。它并不总是提供与运行
    `ls` 相同的结果。继续阅读，了解为什么会这样以及该怎么做。'
- en: $(wildcard) Explained
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`$(wildcard)` 解释'
- en: You can use `$(wildcard)` anywhere in a makefile or rule to get a list of files
    that match one or more *glob* style patterns. For example, `$(wildcard *.foo)`
    returns a list of files ending in `.foo`. Recall that a list is a string where
    list elements are separated by spaces, so `$(wildcard *.foo)` might return `a.foo
    b.foo c.foo`. (If a filename contains a space, the returned list may appear incorrect
    because there’s no way to spot the difference between the list separator—a space—and
    the space in a filename.)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 makefile 或规则中任何地方使用 `$(wildcard)` 来获取与一个或多个 *glob* 风格模式匹配的文件列表。例如，`$(wildcard
    *.foo)` 返回一个以 `.foo` 结尾的文件列表。回想一下，列表是一个字符串，其中元素之间用空格分隔，因此 `$(wildcard *.foo)`
    可能返回 `a.foo b.foo c.foo`。（如果文件名中包含空格，返回的列表可能会看起来不正确，因为无法区分列表分隔符（空格）和文件名中的空格。）
- en: 'You can also call `$(wildcard)` with a list of patterns, so `$(wildcard *.foo
    *.bar)` returns all the files ending in `.foo` or `.bar`. The `$(wildcard)` function
    supports the following globbing operators: `*` (match 0 or more characters), `?`
    (match 1 character), and `[...]` (matches characters, `[123]`, or a range of characters,
    `[a-z]`).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以传递一个模式列表给 `$(wildcard)`，因此 `$(wildcard *.foo *.bar)` 会返回所有以 `.foo` 或 `.bar`
    结尾的文件。`$(wildcard)` 函数支持以下模式匹配操作符：`*`（匹配 0 或更多字符）、`?`（匹配 1 个字符）和 `[...]`（匹配字符，`[123]`，或字符范围，`[a-z]`）。
- en: 'Another useful feature of `$(wildcard)` is that if the filename passed to it
    does not contain a pattern, that file is simply checked for existence. If the
    file exists, its name is returned; otherwise, `$(wildcard)` returns an empty string.
    Thus, `$(wildcard)` can be combined with `$(if)` to create an `if-exists` function:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(wildcard)` 的另一个有用功能是，如果传给它的文件名不包含模式，它只是检查文件是否存在。如果文件存在，它返回文件名；否则，`$(wildcard)`
    返回一个空字符串。因此，`$(wildcard)` 可以与 `$(if)` 结合使用，创建一个 `if-exists` 函数：'
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '`if-exists` has three parameters: the name of the filename to check for, what
    to do if the file exists, and what to do if it does not. Here’s a simple example
    of its use:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-exists` 有三个参数：要检查的文件名、文件存在时要执行的操作，以及文件不存在时要执行的操作。以下是其使用的一个简单示例：'
- en: '[PRE59]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This will print `a.foo is there` if `a.foo` exists, or it will print `a.foo
    is not there` if not.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `a.foo` 存在，它将打印 `a.foo is there`；如果不存在，它将打印 `a.foo is not there`。
- en: Unexpected Results
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 意外的结果
- en: 'Each of the following examples uses two variables to obtain a list of files
    ending in `.foo` in a particular directory: `WILDCARD_LIST` and `LS_LIST` each
    return the list of files ending in `.foo` by calling `$(wildcard)` and `$(shell
    ls)`, respectively. The variable `DIRECTORY` holds the directory in which the
    examples look for files; for the current directory, `DIRECTORY` is left empty.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下每个示例使用两个变量来获取特定目录中以 `.foo` 结尾的文件列表：`WILDCARD_LIST` 和 `LS_LIST` 分别通过调用 `$(wildcard)`
    和 `$(shell ls)` 来返回以 `.foo` 结尾的文件列表。变量 `DIRECTORY` 存储示例查找文件的目录；对于当前目录，`DIRECTORY`
    保持为空。
- en: 'The starting makefile looks like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 起始的 makefile 如下所示：
- en: '[PRE60]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'With a single file `a.foo` in the current directory, running GNU `make` results
    in this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前目录中只有一个文件 `a.foo` 时，运行 GNU `make` 结果如下：
- en: '[PRE61]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now extend the makefile so it makes a file called `b.foo` using `touch`. The
    makefile should look like [Example 4-4](ch04.html#when_you_run_this_makefilecomma_ls_and_d
    "Example 4-4. When you run this makefile, ls and $(wildcard) return different
    results."):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '现在扩展 makefile，使其通过 `touch` 创建一个名为 `b.foo` 的文件。这个 makefile 应该如下所示：[示例 4-4](ch04.html#when_you_run_this_makefilecomma_ls_and_d
    "示例 4-4。当你运行这个 makefile 时，ls 和 $(wildcard) 返回不同的结果。"):'
- en: Example 4-4. When you run this makefile, `ls` and `$(wildcard)` return different
    results.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-4。当你运行这个 makefile 时，`ls` 和 `$(wildcard)` 返回不同的结果。
- en: '[PRE62]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Running this makefile through GNU `make` (with just the preexisting `a.foo`
    file) results in the following surprising output:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 GNU `make` 运行这个 makefile（仅有已存在的 `a.foo` 文件）会产生以下令人惊讶的输出：
- en: '[PRE63]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `ls` returns the correct list (because `b.foo` has been created by the time
    the `all` rule runs), but `$(wildcard)` does not; `$(wildcard)` appears to be
    showing the state before `b.foo` was created.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls` 返回正确的列表（因为`b.foo`在`all`规则执行时已经被创建），但`$(wildcard)`没有；`$(wildcard)`似乎显示的是`b.foo`创建之前的状态。'
- en: Working with the `.foo` files in a subdirectory (not in the current working
    directory) results in different output, as shown in [Example 4-5](ch04.html#this_timecomma_ls_and_dollarleft_parenth
    "Example 4-5. This time, ls and $(wildcard) return the same results.").
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在子目录中使用`.foo`文件（而不是当前工作目录中的文件）会导致不同的输出，如[示例 4-5](ch04.html#this_timecomma_ls_and_dollarleft_parenth
    "示例 4-5. 这次，ls 和 $(wildcard) 返回相同的结果。")所示。
- en: Example 4-5. This time, `ls` and `$(wildcard)` return the same results.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-5. 这次，`ls` 和 `$(wildcard)` 返回相同的结果。
- en: '[PRE64]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here, the makefile is updated so that it uses the `DIRECTORY` variable to specify
    the subdirectory `subdir`. There’s a single preexisting file `subdir/a.foo`, and
    the makefile will create `subdir/b.foo`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，Makefile 已更新，以便使用`DIRECTORY`变量来指定子目录`subdir`。有一个预先存在的文件`subdir/a.foo`，Makefile
    将会创建`subdir/b.foo`。
- en: 'Running this makefile results in:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个 Makefile 会得到：
- en: '[PRE65]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Here, both `$(wildcard)` and `ls` return the same results, and both show the
    presence of the two `.foo` files: `subdir/a.foo`, which existed before `make`
    was run, and `subdir/b.foo`, which was created by the makefile.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`$(wildcard)`和`ls`都返回相同的结果，并且都显示了两个`.foo`文件的存在：`subdir/a.foo`，它在运行`make`之前就已经存在，以及`subdir/b.foo`，它是由
    Makefile 创建的。
- en: 'Let’s look at one final makefile ([Example 4-6](ch04.html#small_change_makes_ls_and_dollarleft_par
    "Example 4-6. A small change makes ls and $(wildcard) return different results."))
    before I explain what’s happening:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我解释发生了什么之前，让我们看看最后一个 Makefile ([示例 4-6](ch04.html#small_change_makes_ls_and_dollarleft_par
    "示例 4-6. 一个小的变化使得 ls 和 $(wildcard) 返回不同的结果。"))：
- en: Example 4-6. A small change makes `ls` and `$(wildcard)` return different results.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-6. 一个小的变化使得`ls`和`$(wildcard)`返回不同的结果。
- en: '[PRE66]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In this makefile, `$(warning)` is used to print out a list of the `.foo` files
    that already exist in the subdirectory.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 Makefile 中，使用了`$(warning)`来打印出子目录中已经存在的`.foo`文件列表。
- en: 'Here’s the output:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE67]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Notice now that GNU `make` appears to be behaving like it does in [Example 4-4](ch04.html#when_you_run_this_makefilecomma_ls_and_d
    "Example 4-4. When you run this makefile, ls and $(wildcard) return different
    results."); the `subdir/b.foo` file that was made by the makefile is invisible
    to `$(wildcard)` and doesn’t appear, even though it was created and `ls` found
    it.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在 GNU `make` 的行为看起来像是[示例 4-4](ch04.html#when_you_run_this_makefilecomma_ls_and_d
    "示例 4-4. 当你运行这个 Makefile 时，ls 和 $(wildcard) 返回不同的结果。")中的行为；即使`subdir/b.foo`文件已由
    Makefile 创建，`$(wildcard)`仍然看不到它并未显示，尽管它已经被创建并且`ls`找到了它。
- en: Unexpected Results Explained
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 意外结果解释
- en: We get unexpected, and apparently inconsistent, results because GNU `make` contains
    its own cache of directory entries. `$(wildcard)` reads from that cache (not directly
    from disk like `ls`) to get its results. Knowing when that cache is filled is
    vital to understanding the results the `$(wildcard)` will return.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到意外且显然不一致的结果，因为 GNU `make` 包含它自己的目录条目缓存。`$(wildcard)`是从这个缓存中读取（而不是像`ls`那样直接从磁盘读取）来获取结果。了解何时填充缓存对于理解`$(wildcard)`返回的结果至关重要。
- en: GNU `make` fills the cache only when it is forced to (for example, when it needs
    to read the directory entries to satisfy a `$(wildcard)` or other globbing request).
    If you know that GNU `make` fills the cache only when needed, then it’s possible
    to explain the results.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 只有在被迫时才会填充缓存（例如，当它需要读取目录条目以满足`$(wildcard)`或其他模式匹配请求时）。如果你知道 GNU `make`
    只有在需要时才会填充缓存，那么就可以解释结果。
- en: In [Example 4-4](ch04.html#when_you_run_this_makefilecomma_ls_and_d "Example 4-4. When
    you run this makefile, ls and $(wildcard) return different results."), GNU `make`
    fills the cache for the current working directory when it starts. So the file
    `b.foo` doesn’t appear in the output of `$(wildcard)` because it wasn’t present
    when the cache was filled.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 4-4](ch04.html#when_you_run_this_makefilecomma_ls_and_d "示例 4-4. 当你运行这个
    Makefile 时，ls 和 $(wildcard) 返回不同的结果。")中，GNU `make`在开始时会填充当前工作目录的缓存。因此，文件`b.foo`不会出现在`$(wildcard)`的输出中，因为它在缓存填充时并不存在。
- en: In [Example 4-5](ch04.html#this_timecomma_ls_and_dollarleft_parenth "Example 4-5. This
    time, ls and $(wildcard) return the same results."), GNU `make` didn’t fill the
    cache with entries from `subdir` until they were needed. The entries were first
    needed for the `$(wildcard)`, which is performed after `subdir/b.foo` is created;
    hence, `subdir/b.foo` does appear in the `$(wildcard)` output.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 4-5](ch04.html#this_timecomma_ls_and_dollarleft_parenth "示例 4-5。这一次，`ls`
    和 `$(wildcard)` 返回相同的结果。")中，GNU `make` 直到需要时才会填充来自 `subdir` 的缓存条目。这些条目首次被 `$(wildcard)`
    需要，而 `$(wildcard)` 是在 `subdir/b.foo` 创建后执行的，因此 `subdir/b.foo` 会出现在 `$(wildcard)`
    输出中。
- en: In [Example 4-6](ch04.html#small_change_makes_ls_and_dollarleft_par "Example 4-6. A
    small change makes ls and $(wildcard) return different results."), the `$(warning)`
    happens at the start of the makefile and fills the cache (because it did a `$(wildcard)`);
    hence, `subdir/b.foo` was missing from the output of `$(wildcard)` for the duration
    of that `make`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 4-6](ch04.html#small_change_makes_ls_and_dollarleft_par "示例 4-6。一个小变化使得
    `ls` 和 `$(wildcard)` 返回不同的结果。")中，`$(warning)` 在 Makefile 开始时触发并填充了缓存（因为它执行了 `$(wildcard)`），因此
    `subdir/b.foo` 在那次 `make` 过程中没有出现在 `$(wildcard)` 的输出中。
- en: 'Predicting when the cache will be filled is very difficult. `$(wildcard)` will
    fill the cache, but so will use of a globbing operator like `*` in the target
    or prerequisite list of a rule. [Example 4-7](ch04.html#when_gnu_make_fillscomma_the_dollarleft
    "Example 4-7. When GNU make fills, the $(wildcard) cache can be difficult to understand.")
    is a makefile that builds two files (`subdir/b.foo` and `subdir/c.foo`) and does
    a couple of `$(wildcard)`s:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 预测缓存何时被填充非常困难。`$(wildcard)` 会填充缓存，但规则的目标或先决条件列表中使用像 `*` 这样的通配符操作符也会填充缓存。[示例
    4-7](ch04.html#when_gnu_make_fillscomma_the_dollarleft "示例 4-7。当 GNU `make` 填充缓存时，`$(wildcard)`
    缓存可能很难理解。")是一个 Makefile，它构建了两个文件（`subdir/b.foo` 和 `subdir/c.foo`），并执行了几个 `$(wildcard)`
    操作：
- en: Example 4-7. When GNU `make` fills, the `$(wildcard)` cache can be difficult
    to understand.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-7。 当 GNU `make` 填充缓存时，`$(wildcard)` 缓存可能很难理解。
- en: '[PRE68]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The output may surprise you:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可能会让你感到惊讶：
- en: '[PRE69]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Even though the first `$(wildcard)` is being done in the rule that makes `subdir/b.foo`
    and after the `touch` that created `subdir/b.foo`, there’s no mention of `subdir/b.foo`
    in the output of `$(wildcard)` ➊. Nor is there mention of `subdir/b.foo` in the
    output of the `ls`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 即使第一个 `$(wildcard)` 已经在生成 `subdir/b.foo` 的规则中执行，并且在创建了 `subdir/b.foo` 后执行了 `touch`，但在
    `$(wildcard)` 的输出中并没有提到 `subdir/b.foo` ➊。`ls` 的输出中也没有提到 `subdir/b.foo`。
- en: The reason is that the complete block of commands is expanded into its final
    form before any of the lines in the rule are run. So the `$(wildcard)` and `$(shell
    ls)` are done before the `touch` has run.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于，整个命令块在规则中的任何一行执行之前就已经扩展成其最终形式。因此，`$(wildcard)` 和 `$(shell ls)` 会在 `touch`
    执行之前完成。
- en: The output of `$(wildcard)` is even more unpredictable if the `make` is run
    in parallel with the `-j` switch. In that case, the exact order in which the rules
    are run is not predictable, so the output of `$(wildcard)` can be even less predictable.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在使用 `-j` 开关并行执行 `make`，`$(wildcard)` 的输出会变得更加不可预测。在这种情况下，规则执行的确切顺序无法预测，因此
    `$(wildcard)` 的输出可能变得更加不可预测。
- en: 'Here’s what I recommend: don’t use `$(wildcard)` in a rule; use `$(wildcard)`
    in the makefile only at parsing time (before any rules start running). If you
    restrict the use of `$(wildcard)` to parsing time, you can be assured of consistent
    results: `$(wildcard)` will show the state of the filesystem before GNU `make`
    was run.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你：不要在规则中使用 `$(wildcard)`；只在解析时（在任何规则开始执行之前）在 Makefile 中使用 `$(wildcard)`。如果你将
    `$(wildcard)` 的使用限制在解析时，你可以确保结果一致：`$(wildcard)` 将显示在 GNU `make` 执行之前的文件系统状态。
- en: Making Directories
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建目录
- en: One common problem faced by real-world makefile hackers is the need to build
    a hierarchy of directories before the build, or at least before commands that
    use those directories can run. The most common case is that the makefile hacker
    wants to ensure that the directories where object files will be created exist,
    and they want that to happen automatically. This section looks at a variety of
    ways to achieve directory creation in GNU `make` and points out a common trap
    for the unwary.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界中的 Makefile 黑客常遇到的一个问题是，在构建之前，或者至少在使用这些目录的命令运行之前，需要构建目录层次结构。最常见的情况是，Makefile
    黑客希望确保将创建目标文件的目录已存在，并且他们希望这个过程自动化。本节将探讨在 GNU `make` 中实现目录创建的多种方法，并指出一个常见的陷阱。
- en: An Example Makefile
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个示例 Makefile
- en: The following makefile builds an object file `/out/foo.o` from `foo.c` using
    the GNU `make` built-in variable `COMPILE.C` to make a `.o` file from a `.c` by
    running the compiler.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 makefile 使用 GNU `make` 内建变量 `COMPILE.C` 从 `foo.c` 构建目标文件 `/out/foo.o`，通过运行编译器将
    `.c` 文件转换为 `.o` 文件。
- en: '`foo.c` is in the same directory as the makefile, but `foo.o` is placed in
    `/out/`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo.c` 和 makefile 在同一目录下，但 `foo.o` 会被放到 `/out/` 目录中：'
- en: '[PRE70]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This example works fine as long as `/out/` exists. But if it does not, you’ll
    get an error from the compiler along the lines of:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例在 `/out/` 存在的情况下工作良好。但如果它不存在，你会收到类似下面的编译错误：
- en: '[PRE71]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Obviously, what you want is for the makefile to automatically create `/out/`
    if it is missing.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你希望的是 makefile 在 `/out/` 不存在时能自动创建它。
- en: What Not to Do
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不应该做的事
- en: Because GNU `make` excels at making things that don’t exist, it seems obvious
    to make `/out/` a prerequisite of `/out/foo.o` and have a rule to make the directory.
    That way if we need to build `/out/foo.o`, the directory will get created.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 GNU `make` 擅长创建不存在的东西，所以看起来很明显，应该将 `/out/` 作为 `/out/foo.o` 的前提条件，并为创建目录编写一个规则。这样，当我们需要构建
    `/out/foo.o` 时，目录就会被创建。
- en: '[Example 4-8](ch04.html#this_makefile_can_end_up_doing_unnecessa "Example 4-8. This
    makefile can end up doing unnecessary work.") shows the reworked makefile with
    the directory as a prerequisite and a rule to build the directory using `mkdir`.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-8](ch04.html#this_makefile_can_end_up_doing_unnecessa "示例 4-8. 这个 makefile
    最终可能会做不必要的工作") 展示了修改后的 makefile，其中目录作为前提条件，并使用 `mkdir` 创建目录的规则。'
- en: Example 4-8. This makefile can end up doing unnecessary work.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-8. 这个 makefile 最终可能会做不必要的工作。
- en: '[PRE72]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'For simplification, the name of the output directory is stored in a variable
    called `OUT`, and the `-p` option on the `mkdir` command is used so that it will
    build all the necessary parent directories. In this case the path is simple: it’s
    just `/out/`, but `-p` means that `mkdir` could make a long chain of directories
    in one go.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，输出目录的名称存储在一个名为 `OUT` 的变量中，并且 `mkdir` 命令使用 `-p` 选项，这样它就会一次性构建所有必要的父目录。在这个例子中，路径很简单：就是
    `/out/`，但 `-p` 选项意味着 `mkdir` 可以一次性创建一条长路径的所有目录。
- en: This works well for this basic example, but there’s a major problem. Because
    the timestamp on a directory is typically updated when the directory is updated
    (for example, when a file is created, deleted, or renamed), this makefile can
    end up doing too much work.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个基础示例来说，这个方法工作良好，但存在一个重大问题。因为目录的时间戳通常在目录更新时（例如，文件被创建、删除或重命名时）会更新，所以这个 makefile
    可能会做过多的工作。
- en: For example, just creating another file inside `/out/` forces a rebuild of `/out/foo.o`.
    In a complex example, this could mean that many object files are rebuilt for no
    good reason, just because other files were rebuilt in the same directory.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，仅仅在 `/out/` 目录下创建另一个文件就会强制重新构建 `/out/foo.o`。在更复杂的示例中，这可能意味着许多目标文件会因为其他文件在同一目录下被重建而无故重建。
- en: 'Solution 1: Build the Directory When the Makefile Is Parsed'
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 1：在解析 makefile 时创建目录
- en: 'A simple solution to the problem in [Example 4-8](ch04.html#this_makefile_can_end_up_doing_unnecessa
    "Example 4-8. This makefile can end up doing unnecessary work.") is to just create
    the directory when the makefile is parsed. A quick call to `$(shell)` can achieve
    that:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 4-8](ch04.html#this_makefile_can_end_up_doing_unnecessa "示例 4-8. 这个 makefile
    最终可能会做不必要的工作")中，解决问题的一个简单方法是，在解析 makefile 时直接创建目录。通过快速调用 `$(shell)` 可以实现：
- en: '[PRE73]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Before any targets are created or commands run, the makefile is read and parsed.
    If you put `$(shell mkdir -p $(OUT))` somewhere in the makefile, GNU `make` will
    run the `mkdir` every time the makefile is loaded.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建任何目标或运行任何命令之前，makefile 会被读取和解析。如果你在 makefile 中的某个位置放置 `$(shell mkdir -p $(OUT))`，GNU
    `make` 每次加载 makefile 时都会运行 `mkdir`。
- en: One possible disadvantage is that if many directories need to be created, this
    process could be slow. And GNU `make` is doing unnecessary work, because it will
    attempt to build the directories every time you type `make`. Some users also don’t
    like this method because it creates all the directories, even if they’re not actually
    used by the rules in the makefile.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的缺点是，如果需要创建多个目录，这个过程可能会比较慢。而且 GNU `make` 会做不必要的工作，因为每次运行 `make` 时，它都会尝试构建这些目录。某些用户也不喜欢这种方法，因为即使某些目录在
    makefile 中的规则并未使用，所有目录还是会被创建。
- en: 'A small improvement can be made by first testing to see whether the directory
    exists:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 通过首先测试目录是否存在，可以进行一些小的改进：
- en: '[PRE74]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Here, `$(wildcard)` is used with a `/.` appended to check for the presence of
    a directory. If the directory is missing, `$(wildcard)` will return an empty string
    and the `$(shell)` will be executed.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`$(wildcard)`与`/.`一起使用，以检查目录是否存在。如果目录缺失，`$(wildcard)`将返回一个空字符串，`$(shell)`将会被执行。
- en: 'Solution 2: Build the Directory When all Is Built'
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案2：仅在构建all时创建目录
- en: 'A related solution is to build the directory only when `all` is being built.
    This means that the directories won’t get created every time the makefile is parsed
    (which could avoid unnecessary work when you type `make clean` or `make depend`):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的解决方案是仅在构建`all`时才创建目录。这意味着在每次解析makefile时，目录不会被创建（这可以避免在你输入`make clean`或`make
    depend`时进行不必要的工作）：
- en: '[PRE75]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This solution is messy because you must specify `make_directories` as a prerequisite
    of any target that the user might specify after `make`. If you don’t, you could
    run into the situation in which the directories have not been built. You should
    avoid this technique, especially because it will completely break parallel builds.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案有些杂乱，因为你必须将`make_directories`指定为任何目标的前提条件，该目标可能是在`make`后由用户指定的。如果不这样做，可能会遇到目录未创建的情况。你应该避免使用这种技术，特别是因为它会完全破坏并行构建。
- en: 'Solution 3: Use a Directory Marker File'
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案3：使用目录标记文件
- en: 'If you look back at [Example 4-8](ch04.html#this_makefile_can_end_up_doing_unnecessa
    "Example 4-8. This makefile can end up doing unnecessary work."), you’ll notice
    one rather nice feature: it builds only the directory needed for a specific target.
    In a more complex example (where there were many such directories to be built)
    it would be nice to be able to use something like that solution while avoiding
    the problem of constant rebuilds as the timestamp on the directory changes.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回头看看[示例 4-8](ch04.html#this_makefile_can_end_up_doing_unnecessa "示例 4-8.
    这个makefile最终可能会做不必要的工作")，你会注意到一个相当不错的特性：它只为特定目标构建所需的目录。在一个更复杂的例子中（有许多这样的目录需要构建），能够使用类似的解决方案会很好，同时避免目录时间戳变化导致的不断重建问题。
- en: To do that, you can store a special empty file, which I call a *marker* file,
    in the directory and use that as the prerequisite. Because it’s a normal file,
    normal GNU `make` rebuilding rules apply and its timestamp is not affected by
    changes in its directory.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，你可以在目录中存储一个特殊的空文件，我称之为*标记*文件，并将其作为前提条件使用。因为它是一个普通文件，普通的GNU `make`重建规则适用，并且其时间戳不会受到目录变化的影响。
- en: If you add a rule to build the marker file (and to ensure that its directory
    exists), you can specify a directory as a prerequisite by specifying the marker
    file as a proxy for the directory.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你添加一个规则来构建标记文件（并确保其目录存在），你可以通过指定标记文件作为目录的代理，来指定目录作为前提条件。
- en: '[PRE76]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Notice how the rule to build `$(OUT)/.f` creates the directory, if necessary,
    and touches the `.f` file. Because the target is a file (`.f`), it can safely
    be used as a prerequisite in the `$(OUT)/foo.o` rule.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，构建`$(OUT)/.f`的规则会在必要时创建目录，并触及`.f`文件。因为目标是一个文件（`.f`），它可以安全地作为`$(OUT)/foo.o`规则的前提条件。
- en: The `$(OUT)/.f` rule uses the GNU `make` function `$(dir FILE)` to extract the
    directory portion of the target (which is the path to the `.f` file) and passes
    that directory to `mkdir`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(OUT)/.f`规则使用GNU `make`函数`$(dir FILE)`来提取目标的目录部分（即`.f`文件的路径），并将该目录传递给`mkdir`。'
- en: The only disadvantage here is that it’s necessary to specify the `.f` files
    for every rule that builds a target in a directory that might need to be created.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的缺点是，对于每个可能需要创建的目录中的目标构建规则，都必须指定`.f`文件。
- en: 'To make this easy to use, you can create functions that automatically make
    the rule to create a directory and that calculate the correct name for `.f` files:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化使用，你可以创建函数，自动生成创建目录的规则，并计算`.f`文件的正确名称：
- en: '[PRE77]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here, `marker` and `make-dir` are used to simplify the makefile.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`marker`和`make-dir`用于简化makefile。
- en: 'Solution 4: Use an Order-Only Prerequisite to Build the Directory'
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案4：使用仅顺序前提条件来创建目录
- en: 'In GNU `make` 3.80 and later, another solution is to use an *order-only* prerequisite.
    An order-only prerequisite is built before the target as normal but does not cause
    the target to be rebuilt when the prerequisite is changed. Usually, when a prerequisite
    is rebuilt, the target will also be rebuilt because GNU `make` assumes that the
    target depends on the prerequisite. Order-only prerequisites are different: they
    get built before the target, but the target isn’t updated just because an order-only
    prerequisite was built.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GNU `make` 3.80 及以后版本中，另一种解决方案是使用*仅顺序*前提条件。仅顺序前提条件在目标之前正常构建，但当前提条件发生变化时不会导致目标重新构建。通常情况下，当前提条件被重新构建时，目标也会被重新构建，因为
    GNU `make` 假设目标依赖于前提条件。而仅顺序前提条件则不同：它们在目标之前被构建，但目标不会因为仅顺序前提条件的构建而更新。
- en: This is exactly what we would’ve liked in the original broken example in [Example 4-8](ch04.html#this_makefile_can_end_up_doing_unnecessa
    "Example 4-8. This makefile can end up doing unnecessary work.")—to make sure
    that the directory gets rebuilt as needed but doesn’t rebuild the `.o` file every
    time the directory’s timestamp changes.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们希望在[示例 4-8](ch04.html#this_makefile_can_end_up_doing_unnecessa "示例 4-8.
    这个 Makefile 可能会做不必要的工作")中的原始破损示例中实现的——确保目录按需重建，但不会在每次目录的时间戳更改时重新构建 `.o` 文件。
- en: Order-only prerequisites are any prerequisites that come after the bar symbol
    `|` and must be placed after any normal prerequisites.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 仅顺序的前提条件是指那些出现在竖线符号 `|` 后面的前提条件，且必须放在任何正常前提条件之后。
- en: 'In fact, just adding this single character to the broken example in [Example 4-8](ch04.html#this_makefile_can_end_up_doing_unnecessa
    "Example 4-8. This makefile can end up doing unnecessary work.") can make it work
    correctly:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，仅仅在[示例 4-8](ch04.html#this_makefile_can_end_up_doing_unnecessa "示例 4-8.
    这个 Makefile 可能会做不必要的工作")中的破损示例中添加这一字符，就能使其正确工作：
- en: '[PRE78]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The rule for `$(OUT)/` ➊ will be run if the directory is missing, but changes
    to the directory will not cause `$(OUT)/foo.o` to be rebuilt.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目录缺失，`$(OUT)/` ➊ 的规则将会被执行，但对目录的更改不会导致 `$(OUT)/foo.o` 被重新构建。
- en: 'Solution 5: Use Pattern Rules, Second Expansion, and a Marker File'
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 5：使用模式规则、第二次展开和标记文件
- en: 'In a typical makefile (not simple examples in books like this), targets are
    usually built using pattern rules, like so:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的 makefile 中（不是像书中这样的简单示例），目标通常通过模式规则构建，如下所示：
- en: '[PRE79]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: But we can change this pattern rule to build directories automatically using
    marker files.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以改变这个模式规则，通过使用标记文件自动构建目录。
- en: In GNU `make` 3.81 and later, there is an exciting feature called *second expansion*
    (which is enabled by specifying the `.SECONDEXPANSION` target in the makefile).
    With second expansion, the prerequisite list of any rule undergoes a second expansion
    (the first expansion happens when the makefile is read) just before the rule is
    used. By escaping any `$` signs with a second `$`, it’s possible to use GNU `make`
    automatic variables (such as `$@`) in the prerequisite list.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GNU `make` 3.81 及以后版本中，有一个令人兴奋的功能叫做*第二次展开*（通过在 makefile 中指定 `.SECONDEXPANSION`
    目标来启用）。通过第二次展开，任何规则的前提条件列表在规则被使用之前会进行第二次展开（第一次展开发生在读取 makefile 时）。通过用第二个 `$` 转义任何
    `$` 符号，可以在前提条件列表中使用 GNU `make` 的自动变量（如 `$@`）。
- en: 'Using a marker file for each directory and second expansion, you can create
    a makefile that automatically creates directories only when necessary with a simple
    addition to the prerequisite list of any rule:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 使用每个目录的标记文件和第二次展开，你可以创建一个 makefile，通过在任何规则的前提条件列表中简单地添加一项内容，自动仅在必要时创建目录：
- en: '[PRE80]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The pattern rule used to make `.o` files has a special prerequisite `$$(@D)/.f`,
    which uses the second expansion feature to obtain the directory in which the target
    is to be built. It does this by applying the `D` modifier to `$@`, which gets
    the directory of the target (while `$@` on its own obtains the name of the target).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 用于生成 `.o` 文件的模式规则有一个特殊的前提条件 `$$(@D)/.f`，它利用第二次展开功能来获取目标要构建的目录。它通过对 `$@` 应用 `D`
    修饰符来实现这一点，`$@` 获取目标的目录（而 `$@` 本身获取目标的名称）。
- en: That directory will be built by the `%/.f` pattern rule in the process of building
    a `.f` file. Notice that the `.f` files are marked as *precious* so that GNU `make`
    will not delete them. Without this line, the `.f` files are considered to be useless
    intermediate files and would be cleaned up by GNU `make` on exit.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 该目录将在构建 `.f` 文件的过程中通过`%/.f`模式规则生成。请注意，`.f` 文件被标记为*珍贵*，以便 GNU `make` 不会删除它们。如果没有这一行，`.f`
    文件会被视为无用的中间文件，并且在退出时会被 GNU `make` 清理掉。
- en: 'Solution 6: Make the Directory in Line'
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s also possible to make directories inside the rules that need them; this
    is called making directories *in line*. For example:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Here I’ve modified the `$(OUT)/foo.o` rule so that it makes the directory using
    `-p` each time. This only works if a small number of rules need to create directories.
    Updating every rule to add the `mkdir` is laborious and likely to result in some
    rules being missed.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: GNU make Meets Filenames with Spaces
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GNU `make` treats the space character as a list separator; any string containing
    spaces can be thought of as a list of space-delimited words. This is fundamental
    to GNU `make`, and space-separated lists abound. Unfortunately, that presents
    a problem when filenames contain spaces. This section looks at how to work around
    the “spaces in filenames problem.”
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: An Example Makefile
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose you are faced with creating a makefile that needs to deal with two files
    named `foo bar` and `bar baz`, with `foo bar` built from `bar baz`. Filenames
    that include spaces can be tricky to work with.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'A naive way to write this in a makefile would be:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'But that doesn’t work. GNU `make` can’t differentiate between cases where spaces
    are part of the filename and cases where they’re not. In fact, the naively written
    makefile is exactly the same as:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Placing quotations marks around the filenames doesn’t work either. If you try
    this:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: GNU `make` thinks you’re talking about four files called `"foo`, `bar"`, `"bar`,
    and `baz"`. GNU `make` ignores the double quotes and splits the list by spaces
    as it normally would.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Escape Spaces with \
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way to deal with the spaces problem is to use GNU `make`’s escaping operator,
    `\`, which you can use to escape sensitive characters (such as a literal `#` so
    that it doesn’t start a comment or a literal `%` so that it isn’t used as a wildcard).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, use `\` to escape spaces in rules for filenames with spaces. Our example
    makefile can then be rewritten as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: and it will work correctly. The `\` is removed during the parsing of the makefile,
    so the actual target and prerequisite names correctly contain spaces. This will
    be reflected in the automatic variables (such as `$@`).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'When `foo bar` needs updating, the simple makefile will output:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: You can also use the same escaping mechanism inside GNU `make`’s `$(wildcard)`
    function. To check for the existence of `foo bar`, you can use `$(wildcard foo\
    bar)` and GNU `make` will treat `foo bar` as a single filename to look for in
    the filesystem.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, GNU `make`’s other functions that deal with space-separated lists
    do not respect the escaping of spaces. The output of `$(sort foo\ bar)` for example,
    is the list `bar foo\`, not `foo\ bar` as you might expect. In fact, `$(wildcard)`
    is the only GNU `make` function that respects the `\` character to escape a space.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads to a problem if you have to deal with the automatic variables that
    contain lists of targets. Consider this slightly more complicated example:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now `foo bar` has two prerequisites `bar baz` and `a b`. What’s the value of
    `$^` (the list of all prerequisites) in this case? It’s `bar baz a b`: the escaping
    is gone, and even if it weren’t gone, the fact that only `$(wildcard)` respects
    the `\` means that it would be useless. `$^` is, from GNU `make`’s perspective,
    a list with four elements.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the definitions of the automatic variables tells us which are safe
    to use in the presence of spaces in filenames. [Table 4-1](ch04.html#safety_of_automatic_variables
    "Table 4-1. Safety of Automatic Variables") shows each automatic variable and
    whether it is safe.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1. Safety of Automatic Variables
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '| Automatic variable | Is it safe? |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
- en: '| `$@` | Yes |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
- en: '| `$<` | Yes |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
- en: '| `$%` | Yes |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
- en: '| `$*` | Yes |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
- en: '| `$?` | No |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
- en: '| `$^` | No |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
- en: '| `$+` | No |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
- en: Those that are inherently lists (`$?`, `$^`, and `$+`) are not safe because
    GNU `make` lists are separated by spaces; the others are safe.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: And it gets a little worse. Even though the first four automatic variables in
    the table are safe to use, their modified versions with `D` and `F` suffixes (which
    extract the directory and filename portions of the corresponding automatic variable)
    are not. This is because they are defined in terms of the `dir` and `notdir` functions.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example makefile:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The value of `$@` is `/tmp/foo bar/baz` as expected, but the value of `$(@D)`
    is `/tmp bar` (as opposed to `/tmp/foo bar`) and the value of `$(@F)` is `foo
    baz` (instead of just `baz`).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Turn Spaces into Question Marks
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to deal with the spaces problem is to turn spaces into question
    marks. Here’s the original makefile transformed:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Because GNU `make` does globbing of target and prerequisite names (and respects
    any spaces found), this will work. But the results are inconsistent.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: If `foo bar` exists when this makefile runs, the pattern `foo?bar` will get
    turned into `foo bar` and that value will be used for `$@`. If that file were
    missing when the makefile is parsed, the pattern (and hence `$@`) remains as `foo?bar`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'Another problem also exists: `?` could match something other than a space.
    If there’s a file called `foombar` on the system, for example, the makefile may
    end up working on the wrong file.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: To get around this problem, Robert Mecklenburg defines two functions to add
    and remove spaces automatically in *Managing Projects with GNU Make, 3rd edition*
    (O’Reilly, 2004). The `sq` function turns every space into a question mark (`sq`
    means space to question mark); the `qs` function does the opposite (it turns every
    question mark into a space). Here’s the updated makefile using two functions (`sq`
    and `qs`) to add and remove question marks. This works unless any filename contains
    a question mark but requires wrapping all uses of the filenames in calls to `sq`
    and `qs`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Either way, because we still can’t be sure whether automatic variables will
    have question marks in them, using the list-based automatic variables or any GNU
    `make` list functions is still impossible.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: My Advice
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given that GNU `make` has difficulty with spaces in filenames, what can you
    do? Here’s my advice:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '**Rename your files to avoid spaces if possible.**'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: However, this is impossible for many people because the spaces in filenames
    may have been added by a third party.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '**Use 8.3 filenames.**'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with Windows, it may be possible to use short, 8.3 filenames,
    which allows you to still have spaces on disk but avoid them in the makefile.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '**Use `\` for escaping.**'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: If you need the spaces, escape them with `\`, which does give consistent results.
    Just be sure to avoid the automatic variables listed as not safe in [Table 4-1](ch04.html#safety_of_automatic_variables
    "Table 4-1. Safety of Automatic Variables").
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: If you use `\` for escaping and you need to manipulate lists of filenames that
    contain spaces, the best thing to do is substitute spaces with some other character
    and then change them back again.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `s+` and `+s` functions in the following code change escaped
    spaces to `+` signs and back again. Then you can safely manipulate lists of filenames
    using all the GNU `make` functions. Just be sure to remove the `+` signs before
    using these names in a rule.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Here’s an example using them to transform a list of source files with escaped
    spaces into a list of object files, which are then used to define the prerequisites
    of an `all` rule:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The source files are stored in `SRCS` with spaces in filenames escaped. So `SRCS`
    contains three files named `a b.c`, `c d.c`, and `e f.c`. GNU `make`’s `\` escaping
    is used to preserve the escaped spaces in each name. Transforming `SRCS` into
    a list of objects in `OBJS` is done in the usual manner using `.c=.o` to replace
    each `.c` extension with `.o`, but first `SRCS` is altered using the `s+` function
    so the escaped spaces become `+` signs. As a result, GNU `make` will see `SRCS`
    as a list of three elements, `a+b.c`, `c+d.c`, and `e+f.c`, and changing the extension
    will work correctly. When `OBJS` is used later in the makefile, the `+` signs
    are turned back into escaped spaces using a call to the function `+s`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Path Handling
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Makefile creators often have to manipulate filesystem paths, but GNU `make`
    provides few functions for path manipulation. And cross-platform `make` is difficult
    due to differences in path syntax. This section explains ways to manipulate paths
    in GNU `make` and navigate through the cross-platform minefield.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Target Name Matching
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Look at the following example makefile and suppose that `../foo` is missing.
    Does the makefile manage to create it?
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'If you run that makefile with GNU `make`, you might be surprised to see the
    following error:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'If you change the makefile to this:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: you’ll find that it works as expected and performs a `touch ../foo`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'The first makefile fails because GNU `make` doesn’t do path manipulation on
    target names, so it sees two different targets called `../foo` and `.././foo`,
    and fails to make the connection between the two. The second makefile works because
    I lied in the preceding sentence. GNU `make` does do a tiny bit of path manipulation:
    it will strip leading `./` from target names. So in the second makefile both targets
    are `../foo`, and it works as expected.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 makefile 会失败，因为 GNU `make` 不对目标名称进行路径处理，所以它会将 `../foo` 和 `.././foo` 视为两个不同的目标，导致无法将它们关联起来。第二个
    makefile 则工作正常，因为我在前述句子中说谎了。实际上，GNU `make` 确实会做一点路径处理：它会去掉目标名称前面的 `./`。因此，在第二个
    makefile 中，两个目标都是 `../foo`，并按预期工作。
- en: The general rule with GNU `make` targets is that they are treated as literal
    strings without interpreting them in any way. Therefore, it’s essential that when
    you’re referring to a target in a makefile, you always ensure that the same string
    is used.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 目标的普遍规则是，它们被视为字面字符串，不会以任何方式进行解释。因此，当你在 makefile 中引用目标时，确保使用相同的字符串是非常重要的。
- en: Working with Path Lists
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理路径列表
- en: It bears repeating that GNU `make` lists are just strings in which any whitespace
    is considered a list separator. Consequently, paths with spaces in them are not
    recommended because it makes using many of GNU `make`’s built-in functions impossible,
    and spaces in paths cause problems with targets.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 需要再次强调的是，GNU `make` 列表仅仅是字符串，其中任何空格都被视为列表分隔符。因此，不推荐路径中有空格，因为这会导致无法使用许多 GNU `make`
    的内建函数，且路径中的空格会给目标带来问题。
- en: 'For example, suppose a target is `/tmp/sub directory/target`, and we write
    a rule for it like this:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设目标是`/tmp/sub directory/target`，我们可以为它写出如下规则：
- en: '[PRE96]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'GNU `make` will actually interpret that as two rules, one for `/tmp/sub` and
    one for `directory/target`, just as if you’d written this:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 实际上会将其解释为两个规则，一个针对 `/tmp/sub`，另一个针对 `directory/target`，就像你写的是这样：
- en: '[PRE97]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: You can work around that problem by escaping the space with `\`, but that escape
    is poorly respected by GNU `make` (it works only in target names and the `$(wildcard`)
    function).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `\` 来转义空格来解决这个问题，但 GNU `make` 对这个转义的支持不太好（它仅在目标名称和 `$(wildcard`) 函数中有效）。
- en: Unless you must use them, avoid spaces in target names.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 除非必须使用空格，否则避免在目标名称中使用空格。
- en: Lists of Paths in VPATH and vpath
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`VPATH` 和 `vpath` 中的路径列表'
- en: 'Another place that lists of paths appear in GNU `make` is when specifying the
    `VPATH` or in a `vpath` directive used to specify where GNU `make` finds prerequisites.
    For example, it’s possible to set the `VPATH` to search for source files in a
    list of `:` or whitespace separated paths:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在 GNU `make` 中出现路径列表的地方是指定 `VPATH` 或 `vpath` 指令，用来指定 GNU `make` 查找前提条件的位置。例如，可以设置
    `VPATH` 来在一系列 `:` 或空格分隔的路径中查找源文件：
- en: '[PRE98]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'GNU `make` will split that path correctly at either colons or whitespace. On
    Windows systems, the native builds of GNU `make` use `;` as the path separator
    for `VPATH` (and `vpath`) because `:` is needed for drive letters. On Windows,
    GNU `make` actually tries to be smart and splits paths on colons unless it looks
    like a drive letter (one letter followed by a colon). This drive letter intelligence
    actually creates a problem if you have a directory in the path whose name is a
    single letter: in that case you must use `;` as the path separator. Otherwise,
    GNU `make` will think it’s a drive:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 会在冒号或空格处正确地拆分路径。在 Windows 系统上，GNU `make` 的原生构建使用 `;` 作为 `VPATH`（和
    `vpath`）的路径分隔符，因为 `:` 被用于驱动器字母。在 Windows 上，GNU `make` 实际上会智能地在冒号处拆分路径，除非它看起来像一个驱动器字母（一个字母后跟一个冒号）。这种驱动器字母的智能会在路径中有单个字母的目录名时造成问题：在这种情况下，必须使用
    `;` 作为路径分隔符。否则，GNU `make` 会认为它是一个驱动器：
- en: '[PRE99]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: On both POSIX and Windows systems, a space in a path is a separator in a `VPATH`
    and `vpath`. So using spaces is the best bet for cross-platform makefiles.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在 POSIX 和 Windows 系统中，路径中的空格是 `VPATH` 和 `vpath` 中的分隔符。所以，使用空格是跨平台 makefile 的最佳选择。
- en: Using / or \
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 / 或 \
- en: 'On POSIX systems `/` is the path separator, and on Windows systems it’s `\`.
    It’s common to see paths being built up in makefiles like this:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在 POSIX 系统中，`/` 是路径分隔符，而在 Windows 系统中是 `\`。在 makefile 中常见的路径构建方式如下：
- en: '[PRE100]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'It would be ideal to remove the POSIX-only `/` there and replace it with something
    that would work with a different separator. One way to do that is to define a
    variable called `/` (GNU `make` lets you get away with using almost anything as
    a variable name) and use it in place of `/`:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'If that makes you uncomfortable, just call it `SEP`:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Now when you switch to Windows, you can just redefine `/` (or `SEP`) to `\`.
    It’s difficult to assign a literal `\` on its own as a variable value (because
    GNU `make` interprets it as a line continuation and it can’t be escaped), so it’s
    defined here using `$(strip)`.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'However, note that the Windows builds of GNU `make` will also accept `/` as
    a path separator, so weird paths like `c:/src` are legal. Using those paths will
    simplify the makefile, but be careful when passing them to a native Windows tool
    that expects \ separated paths. If that’s necessary, use this instead:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This simple function will convert a forward slash path to a backslash path.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows Oddity: Case Insensitive but Case Preserving'
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On POSIX systems filenames are case sensitive; on Windows they are not. On Windows
    the files `File`, `file`, and `FILE` are all the same file. But an oddity with
    Windows is that the first time a file is accessed, the specific case used is recorded
    and preserved. Thus, if we `touch File`, it will appear as `File` in the filesystem
    (but can be accessed as `FILE`, `file`, or any other case combination).
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, GNU `make` does case-sensitive target comparisons, so the following
    makefile does not do what you might expect:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: As is, this file causes an error, but you can compile GNU `make` on Windows
    to do case-insensitive comparisons instead (with the build `HAVE_CASE_INSENSITIVE_FS`
    option).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: This oddity is more likely to arise when a target specified in a makefile is
    also found in a wildcard search because the operating system may return a different
    case than the case used in the makefile. The target names may differ in case,
    and that may cause an unexpected `No rule to make` error.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Built-in Path Functions and Variables
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can determine the current working directory in GNU `make` using the built-in
    `CURDIR`. Note that `CURDIR` will follow symlinks. If you are in `/foo` but `/foo`
    is actually a symlink to `/somewhere/foo`, `CURDIR` will report the directory
    as `/somewhere/foo`. If you need the non-symlink-followed directory name, use
    the value of the environment variable `PWD`:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'But be sure to grab its value before any other part of the makefile has changed
    `PWD`: it can be altered, just like any other variable imported from the environment.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also find the directory in which the current makefile is stored using
    the `MAKEFILE_LIST` variable that was introduced in GNU `make` 3.80\. At the start
    of a makefile, it’s possible to extract its directory as follows:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'GNU `make` has functions for splitting paths into components: `dir`, `notdir`,
    `basename`, and `suffix`.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Consider the filename `/foo/bar/source.c` stored in the variable `FILE`. You
    can use the functions `dir`, `notdir`, `basename`, and `suffix` to extract the
    directory, filename, and suffix. So to get the directory, for example, use `$(dir
    $(FILE))`. [Table 4-2](ch04.html#results_of_dircomma_notdircomma_basename "Table 4-2. Results
    of dir, notdir, basename, and suffix") shows each of these functions and its result.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-2. Results of `dir`, `notdir`, `basename`, and `suffix`
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Result |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
- en: '| `dir` | `/foo/bar/` |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
- en: '| `notdir` | `source.c` |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
- en: '| `basename` | `source` |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
- en: '| `suffix` | `.c` |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
- en: You can see that the directory, the non-directory part, the suffix (or extension),
    and the non-directory part without the suffix have been extracted. These four
    functions make filename manipulation easy. If no directory was specified, GNU
    `make` uses the current directory (`./`). For example, suppose that `FILE` was
    just `source.c`. [Table 4-3](ch04.html#results_of_dircomma_notdircomma-id00011
    "Table 4-3. Results of dir, notdir, basename, and suffix with No Directory Specified")
    shows the result for each function.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-3. Results of `dir`, `notdir`, `basename`, and `suffix` with No Directory
    Specified
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Result |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
- en: '| `dir` | `./` |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
- en: '| `notdir` | `source.c` |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
- en: '| `basename` | `source` |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
- en: '| `suffix` | `.c` |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
- en: Because these functions are commonly used in conjunction with GNU `make`’s automatic
    variables (like `$@`), GNU `make` provides a modifier syntax. Appending `D` or
    `F` to any automatic variable is equivalent to calling `$(dir)` or `$(notdir)`
    on it. For example, `$(@D)` is equivalent to `$(dir $@)` and `$(@F)` is the same
    as `$(notdir $@)`.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: 'Useful Functions in 3.81: abspath and realpath'
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`realpath` is a GNU `make` wrapper for the C library `realpath` function, which
    removes `./`, resolves `../`, removes duplicated `/`, and follows symlinks. The
    argument to `realpath` must exist in the filesystem. The path returned by `realpath`
    is absolute. If the path does not exist, the function returns an empty string.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you could find the full path of the current directory like this:
    `current := $(realpath ./)`.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '`abspath` is similar but does not follow symlinks, and its argument does not
    have to refer to an existing file or directory.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: Usman’s Law
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`make clean` doesn’t make clean. That’s Usman’s law (named after a smart coworker
    of mine who spent months working with real-world makefiles). `make clean` is intended
    to return to a state in which everything will be rebuilt from scratch. Often it
    doesn’t. Read on to find out why.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: The Human Factor
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `clean` rule from the OpenSSL makefile looks like this:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Notice how it’s a long list of clearly human-maintained directories, patterns,
    and filenames that need to be deleted to get back to a clean state. Human maintenance
    means human error. Suppose someone adds a rule that creates a temporary file with
    a fixed name. That temporary file should be added to the `clean` rule, but it
    most likely won’t be.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: Usman’s law strikes.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: Poor Naming
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s a snippet found in many automatically generated makefiles:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'In this example, three sorts of `clean` appear to have different degrees of
    cleanliness: `mostlyclean`, `clean`, and `extraclean`.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '`mostlyclean` just deletes the object files compiled from source. `clean` does
    that plus deletes the generated library and a few other files. You’d think that
    `extraclean` would delete more than the other two, but it actually deletes a different
    set of files. And I’ve seen makefiles with `reallyclean`, `veryclean`, `deepclean`,
    and even `partiallyclean` rules!'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: When you can’t tell from the naming what does what, it can easily lead to potential
    problems down the line.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: Usman’s law strikes again.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: Silent Failure
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s another makefile snippet that works some of the time:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The `@` means that the command isn’t echoed. The `-` means that any error returned
    is ignored and all output is redirected with `&>` to `/dev/null`, making it invisible.
    Because no `-f` is on the `rm` command, any failure (from say, permissions problems)
    will go totally unnoticed.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: Usman’s law strikes again.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: Recursive Clean
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many makefiles are recursive, and `make clean` must be recursive too, so you
    see the following pattern:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The problem with this is that it means `make clean` has to work correctly in
    every directory in `SUBDIR`, leading to more opportunity for error.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: Usman’s law strikes again.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: Pitfalls and Benefits of GNU make Parallelization
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many build processes run for hours, so build managers commonly type `make`
    and go home for the night. GNU `make`’s solution to this problem is parallel execution:
    a simple command line option that causes GNU `make` to run jobs in parallel using
    the dependency information in the makefile to run them in the correct order.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: In practice, however, GNU `make` parallel execution is severely limited by the
    fact that almost all makefiles are written with the assumption that their rules
    will run in series. Rarely do makefile authors *think in parallel* when writing
    their makefiles. That leads to hidden traps that either cause the build to fail
    with a fatal error or, worse, build “successfully” but result in incorrect binaries
    when GNU `make` is run in parallel mode.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: This section looks at GNU `make`’s parallel pitfalls and how to work around
    them to get maximum parallelism.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Using -j (or -jobs)
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start GNU `make` in parallel mode, you can specify either the `-j` or `--jobs`
    option on the command line. The argument to the option is the maximum number of
    processes that GNU `make` will run in parallel.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: For example, typing `make --jobs=4` allows GNU `make` to run up to four subprocesses
    in parallel, which would give a theoretical maximum speedup of 4×. However, the
    theoretical time is severely limited by restrictions in the makefile. To calculate
    the maximum actual speedup, you use Amdahl’s law (which is covered in [Amdahl’s
    Law and the Limits of Parallelization](ch04.html#amdahlapostrophes_law_and_the_limits_of
    "Amdahl’s Law and the Limits of Parallelization")).
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: One simple but annoying problem found in parallel GNU `make` is that because
    the jobs are no longer run serially (and the order depends on the timing of jobs),
    the output from GNU `make` will be sorted randomly depending on the actual order
    of job execution.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, that problem has been addressed in GNU `make` 4.0 with the `--output-sync`
    option described in [Chapter 1](ch01.html "Chapter 1. The Basics Revisited").
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the example in [Example 4-9](ch04.html#simple_makefile_to_illustrate_parallel_m
    "Example 4-9. A simple makefile to illustrate parallel making"):'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-9. A simple makefile to illustrate parallel making
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'It builds five targets: `t1`, `t2`, `t3`, `t4`, and `t5`. All are simply touched
    except for `t2`, which is copied from `t3`.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: 'Running [Example 4-9](ch04.html#simple_makefile_to_illustrate_parallel_m "Example 4-9. A
    simple makefile to illustrate parallel making") through standard GNU `make` without
    a parallel option gives the output:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The order of execution will be the same each time because GNU `make` will follow
    the prerequisites depth first and from left to right. Note that the left-to-right
    execution (in the `all` rule for example, `t5` is built before `t4`, which is
    built before `t1`) is part of the POSIX `make` standard.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: Now if `make` is run in parallel mode, it’s clear that `t5`, `t4`, and `t1`
    can be run at the same time because there are no dependencies between them. Similarly,
    `t3` and `t2` do not depend on each other, so they can be run in parallel.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of a parallel run of [Example 4-9](ch04.html#simple_makefile_to_illustrate_parallel_m
    "Example 4-9. A simple makefile to illustrate parallel making") might be:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Or even:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: This makes any process that examines log files to check for build problems (such
    as diffing log files) difficult. Unfortunately, there’s no easy solution for this
    in GNU `make` without the `--output-sync` option, so you’ll just have to live
    with it unless you upgrade to GNU `make` 4.0.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: Missing Dependencies
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The example in [Example 4-9](ch04.html#simple_makefile_to_illustrate_parallel_m
    "Example 4-9. A simple makefile to illustrate parallel making") has an additional
    problem. The author fell into the classic left-to-right trap when writing the
    makefile, so when it’s run in parallel, it’s possible for the following to happen:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The reason is that when run in parallel, the rule to build `t2` can occur before
    the rule to build `t3`, and `t2` needs `t3` to have already been built. This didn’t
    happen in the serial case because of the left-to-right assumption: the rule to
    build `t1` is `t1: t3 t2`, which implies that `t3` will be built before `t2`.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: 'But no actual dependency exists in the makefile that states that `t3` must
    be built before `t2`. The fix is simple: just add `t2: t3` to the makefile.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple example of the real problem of missing or implicit (left-to-right)
    dependencies that plagues makefiles when run in parallel. If a makefile breaks
    when run in parallel, it’s worth looking for missing dependencies straightaway
    because they are very common.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: The Hidden Temporary File Problem
  id: totrans-534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way GNU `make` can break when running in parallel is if multiple rules
    use the same temporary file. Consider the example makefile in [Example 4-10](ch04.html#hidden_temporary_file_that_breaks_parall
    "Example 4-10. A hidden temporary file that breaks parallel builds"):'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-10. A hidden temporary file that breaks parallel builds
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Run without a parallel option, GNU `make` produces the following output:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'and the `t` file contains:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'But run in parallel, [Example 4-10](ch04.html#hidden_temporary_file_that_breaks_parall
    "Example 4-10. A hidden temporary file that breaks parallel builds") gives the
    following output:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Now `t` contains:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This occurs because no dependency exists between `t1` and `t2` (because neither
    requires the output of the other), so they can run in parallel. In the output,
    you can see that they are running in parallel but that the output from the two
    rules is interleaved. Because the two `echo` statements ran first, `t2` overwrote
    the output of `t1`, so the temporary file (shared by both rules) had the wrong
    value when it was finally `cat`ed to `t1`, resulting in the wrong value for `t`.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: This example may seem contrived, but the same thing happens in real makefiles
    when run in parallel, resulting in either broken builds or the wrong binary being
    built. The `yacc` program for example, produces temporary files called `y.tab.c`
    and `y.tab.h`. If more than one `yacc` is run in the same directory at the same
    time, the wrong files could be used by the wrong process.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple solution for the makefile in [Example 4-10](ch04.html#hidden_temporary_file_that_breaks_parall
    "Example 4-10. A hidden temporary file that breaks parallel builds") is to change
    the definition of `TMP_FILE` to `TMP_FILE = /tmp/scratch_file.$@`, so its name
    will depend on the target being built. Now a parallel run would look like this:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: A related problem occurs when multiple jobs in the makefile write to a shared
    file. Even if they never read the file (for example, they might write to a log
    file), locking the file for write access can cause competing jobs to stall, reducing
    the overall performance of the parallel build.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the example makefile in [Example 4-11](ch04.html#locking_on_shared_files_can_lock_a_paral
    "Example 4-11. Locking on shared files can lock a parallel build and make it run
    serially.") that uses the `lockfile` command to lock a file and simulate write
    locking. Although the file is locked, each job waits for a number of seconds:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-11. Locking on shared files can lock a parallel build and make it
    run serially.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Running [Example 4-11](ch04.html#locking_on_shared_files_can_lock_a_paral "Example 4-11. Locking
    on shared files can lock a parallel build and make it run serially.") in a serial
    build takes about 30 seconds:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'But it isn’t any faster in parallel, even though `t1` and `t2` should be able
    to run in parallel:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: It’s actually slower because of the way `lockfile` detects lock availability.
    As you can imagine, write locking a file could cause similar delays in otherwise
    parallel-friendly makefiles.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: Related to the file locking problem is a danger concerning archive (`ar`) files.
    If multiple `ar` processes were to run simultaneously on the same archive file,
    the archive could be corrupted. Locking around archive updates is necessary in
    a parallel build; otherwise, you’ll need to prevent your dependencies from running
    multiple `ar` commands on the same file at the same time.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: One way to prevent parallelism problems is to specify `.NOTPARALLEL` in a makefile.
    If this is seen, the entire `make` execution will be run in series and the `-j`
    or `--jobs` command line option will be ignored. `.NOTPARALLEL` is a very blunt
    tool because it affects an entire invocation of GNU `make`, but it could be handy
    in a recursive `make` situation with, for example, a third-party makefile that
    is not parallel safe.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: The Right Way to Do Recursive make
  id: totrans-561
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GNU `make` is smart enough to share parallelism across sub-makes if a makefile
    using `$(MAKE)` is careful about how it calls sub-makes. GNU `make` has a message
    passing mechanism that works across most platforms (Windows support was added
    in GNU `make` 4.0) and enables sub-makes to use all the available jobs specified
    through `-j` or `--jobs` by passing tokens across pipes between the `make` processes.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: 'The only serious gotcha is that you must write your makefile in a way that
    actually allows your sub-makes to run in parallel. The classic recursive `make`
    style that uses a shell `for` loop to process each sub-make doesn’t allow for
    more than one sub-make to run at once. For example:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'This code has a big problem: if sub-make fails, the `make` will look like it
    has succeeded. It’s possible to fix that, but the fixes become more and more complicated:
    other approaches are better.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: When run in parallel mode, the `all` rule walks through each subdirectory and
    waits for its `$(MAKE)` to complete. Even though each of those sub-makes will
    be able to run in parallel, the overall `make` does not, meaning a less than ideal
    speedup. For example, if the `make` in the `bar` directory is capable of running
    only four jobs at once, then running on a 16-core machine won’t make the build
    any faster than on one with just 4 cores.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to remove the `for` loop and replace it with a single rule
    for each directory:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Each directory is considered to be a phony target, because the directory doesn’t
    actually get built.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: Now each directory can run while the others are running, and parallelism is
    maximized; it’s even possible to have dependencies between directories causing
    some sub-makes to run before others. Directory dependencies can be handy when
    it’s important that one sub-make runs before another.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: Amdahl’s Law and the Limits of Parallelization
  id: totrans-571
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Additionally, there are real limits to the amount of parallelization that is
    possible in a project. Look at [Example 4-12](ch04.html#makefile_with_sleep_used_to_simulate_job
    "Example 4-12. A makefile with sleep used to simulate jobs that take time to complete"):'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-12. A makefile with `sleep` used to simulate jobs that take time to
    complete
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'When run in series, it takes about 88 seconds to complete:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'What’s the maximum speedup possible, assuming as many CPUs are available as
    desired? Working through the makefile step by step, you’ll see that `t` takes
    10 seconds to build and everything else must be built before that. `t1`, `t2`,
    `t4`, `t6`, and `t7` are all independent, and the longest of them takes 12 seconds.
    `t3` waits for `t5`, which needs `t8`: that chain takes a total of 20 seconds.
    `t9` needs `t10` for a total of 10 seconds, and `t11` needs `t12` for another
    10 seconds.'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: So the longest serial part of this build is the sequence `t`, `t3`, `t5`, `t8`,
    which takes a total of 30 seconds. This build can never go faster than 30 seconds
    (or 2.93 times faster than the serial 88 second time). How many processors are
    needed to achieve that speedup?
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the maximum speedup achievable is governed by Amdahl’s law: if
    `F` is the fraction of the build that cannot be parallelized and `N` is the number
    of available processors, then the maximum speedup achievable is `1 / ( F + ( 1
    - F ) / N )`.'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: 'In the [Example 4-12](ch04.html#makefile_with_sleep_used_to_simulate_job "Example 4-12. A
    makefile with sleep used to simulate jobs that take time to complete") example,
    34 percent of the build can’t be parallelized. [Table 4-4](ch04.html#maximum_speedup_based_on_number_of_proce
    "Table 4-4. Maximum Speedup Based on Number of Processors") shows the results
    of applying Amdahl’s law:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-4. Maximum Speedup Based on Number of Processors
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '| Number of processors | Maximum speedup |'
  id: totrans-582
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
- en: '| 2 | 1.49x |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1.79x |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
- en: '| 4 | 1.98x |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
- en: '| 5 | 2.12x |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
- en: '| 6 | 2.22x |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
- en: '| 7 | 2.30x |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
- en: '| 8 | 2.37x |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
- en: '| 9 | 2.42x |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
- en: '| 10 | 2.46x |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
- en: '| 11 | 2.50x |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
- en: '| 12 | 2.53x |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
- en: For this small build, the maximum speedup Amdahl’s law predicts has a plateau
    starting at around eight processors. The actual plateau is further limited by
    the fact that only 13 possible jobs are in the build.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the structure of the build, we can see that eight processors is
    the maximum because five jobs can run in parallel without any dependencies: `t1`,
    `t2`, `t4`, `t6`, and `t7`. Then three small chains of jobs can each use one processor
    at a time: `t3`, `t5`, and `t8`; `t9` and `t10`; and `t11` and `t12`. Building
    `t` can reuse one of the eight processors because they’ll all be idle at that
    point.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: A real-world instance of Amdahl’s law significantly impacting build times occurs
    with languages that have a linking step, such as C and C++. Typically, all the
    objects files are built before the link step and then a single (often huge) link
    process has to run. That link process is often not parallelizable and becomes
    the limiting factor on build parallelization.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: Making $(wildcard) Recursive
  id: totrans-598
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The built-in `$(wildcard)` function is not recursive: it only searches for
    files in a single directory. You can have multiple globbing patterns in a `$(wildcard)`
    and use that to look in subdirectories. For example, `$(wildcard */*.c)` finds
    all the `.c` files in all subdirectories of the current directory. But if you
    need to search an arbitrary tree of directories, there’s no built-in way to do
    it.'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, it’s pretty easy to make a recursive version of `$(wildcard)`,
    like this:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The function `rwildcard` takes two parameters: the first is the directory from
    which to start searching (this parameter can be left empty to start from the current
    directory), and the second is the glob pattern for the files to find in each directory.'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to find all `.c` files in the current directory (along with its
    subdirectories), use this:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Or to find all `.c` files in `/tmp`, use this:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '`rwildcard` also supports multiple patterns. For example:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: This finds all `.c` and `.h` files under `/src/`.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: Which Makefile Am I In?
  id: totrans-610
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common request is: Is there a way to find the name and path of the current
    makefile? By *current*, people usually mean the makefile that GNU `make` is currently
    parsing. There’s no built-in way to quickly get the answer, but there is a way
    using the GNU `make` variable `MAKEFILE_LIST`.'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '`MAKEFILE_LIST` is the list of makefiles currently loaded or `include`d. Each
    time a makefile is loaded or `include`d, the `MAKEFILE_LIST` is appended with
    its path and name. The paths and names in the variable are relative to the current
    working directory (where GNU `make` was started or where it moved to with the
    `-C` or `--directory` option), but you can access the current directory from the
    `CURDIR` variable.'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: 'So using that, you can define a GNU `make` function (let’s call it `where-am-i`)
    that will return the current makefile (it uses `$(word)` to get the last makefile
    name from the list):'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Then, whenever you want to find the full path to the current makefile, write
    the following at the top of the makefile:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: It’s important that this line goes at the top because any `include` statement
    in the makefile will change the value of `MAKEFILE_LIST`, so you want to grab
    the location of the current makefile before that happens.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 4-13](ch04.html#makefile_that_can_determine_where_it_is "Example 4-13. A
    makefile that can determine where it is located on the filesystem") shows an example
    makefile that uses `where-am-i` and includes another makefile from the `foo/`
    subdirectory, which, in turn, includes a makefile from the `foo/bar/` directory.'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-13. A makefile that can determine where it is located on the filesystem
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The contents of `foo/makefile` is shown in [Example 4-14](ch04.html#makefile_included_by_listing_4-13
    "Example 4-14. A makefile included by Example 4-13").
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-14. A makefile included by [Example 4-13](ch04.html#makefile_that_can_determine_where_it_is
    "Example 4-13. A makefile that can determine where it is located on the filesystem")
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The contents of `foo/bar/makefile` is shown in [Example 4-15](ch04.html#makefile_included_by_listing_4-14
    "Example 4-15. A makefile included by Example 4-14").
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-15. A makefile included by [Example 4-14](ch04.html#makefile_included_by_listing_4-13
    "Example 4-14. A makefile included by Example 4-13")
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Putting the three makefiles in [Example 4-13](ch04.html#makefile_that_can_determine_where_it_is
    "Example 4-13. A makefile that can determine where it is located on the filesystem"),
    [Example 4-14](ch04.html#makefile_included_by_listing_4-13 "Example 4-14. A makefile
    included by Example 4-13") and [Example 4-15](ch04.html#makefile_included_by_listing_4-14
    "Example 4-15. A makefile included by Example 4-14") in `/tmp` (and subdirectories)
    and running GNU `make` gives the output:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: In this chapter, we’ve looked at common problems that makefile creators and
    maintainers run into when working on real makefiles. In any sizable project that
    uses `make`, you are likely to run into one or more (perhaps even all!) of them.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
