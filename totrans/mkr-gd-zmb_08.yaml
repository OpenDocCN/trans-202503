- en: '**8**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**BUILDING A CONTROL CENTER FOR YOUR BASE**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f0001-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll learn how to make an integrated control center using
    a Raspberry Pi computer interfaced with earlier projects from this book. The control
    center will allow you to monitor all of your alarm and surveillance devices on
    one screen so you’ll know instantly if a zombie has breached your compound ([Figure
    8-1](ch08.html#ch08fig1)). As an extra feature, you’ll learn how to add wireless
    connectivity to your control center.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f08-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-1: A quiet night at the security desk'
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT 13: A RASPBERRY PI CONTROL CENTER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this project, you’ll connect the Raspberry Pi system of [Chapter 5](ch05.html#ch05)
    with the following Arduino monitoring devices developed earlier in the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '• “[Project 4: Battery Monitor](ch03.html#ch00lev1sec63)” on [page 53](ch03.html#page_53)'
  prefs: []
  type: TYPE_NORMAL
- en: '• “[Project 6: PIR Zombie Detector](ch04.html#ch00lev1sec81)” on [page 72](ch04.html#page_72)'
  prefs: []
  type: TYPE_NORMAL
- en: '• “[Project 10: Door Sensor](ch06.html#ch00lev1sec116)” on [page 112](ch06.html#page_112)'
  prefs: []
  type: TYPE_NORMAL
- en: '• “[Project 11: Quiet Fire Alarm](ch07.html#ch00lev1sec121)” on [page 120](ch07.html#page_120)'
  prefs: []
  type: TYPE_NORMAL
- en: '• “[Project 12: Temperature Alarm](ch07.html#ch00lev1sec130)” on [page 131](ch07.html#page_131)'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll link the two boards with USB cables, which we can later replace in Project
    14 with a wireless Bluetooth link. The Arduino will still be able to work without
    the Raspberry Pi after this wireless modification, but linking it to the Raspberry
    Pi will allow you to show the status of your sensors and alarms in a window on
    the Raspberry Pi. [Figure 8-2](ch08.html#ch08fig2) shows the setup; you can see
    the sensor status window in the center of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f08-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-2: Raspberry Pi and Arduino working together'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU WILL NEED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This project brings together the Raspberry Pi system of [Chapter 5](ch05.html#ch05)
    and most of the Arduino projects described in the book thus far. As such, all
    you will need is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/square.jpg) One or more of the previous Arduino projects'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/square.jpg) The Raspberry Pi system from [Chapter 5](ch05.html#ch05)'
  prefs: []
  type: TYPE_IMG
- en: '![image](graphics/square.jpg) A USB lead/cable (of the same type used to program
    your Arduino project)'
  prefs: []
  type: TYPE_IMG
- en: '**CONSTRUCTION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Assuming that you have been slowly adding projects to your Arduino, the Arduino
    now has five projects attached to it. If you’re really prepared, you probably
    built these ages ago and have them stashed in your go bag, ready for the apocalypse.
    Either way, you should at least have the sensors you are interested in using.
  prefs: []
  type: TYPE_NORMAL
- en: If your Arduino projects and Raspberry Pi are already set up, you won’t need
    to do much construction to link them. You connect an Arduino project to the Raspberry
    Pi by plugging one end of the USB lead into the Pi and the other end into the
    Arduino. If your Raspberry Pi does not have any free USB ports, then you will
    need to add a USB hub to provide more ports.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have linked your Arduino and your Raspberry Pi, you’ll need to
    program them. It’s best to program the Arduino from your regular computer before
    swapping the USB cable over to the Raspberry Pi, as programming the Arduino from
    the Raspberry Pi’s small screen can be frustrating.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-3](ch08.html#ch08fig3) shows the arrangement of the various system
    components.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f08-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-3: A schematic of the control center'
  prefs: []
  type: TYPE_NORMAL
- en: This arrangement plays to the strengths of both the Arduino and Raspberry Pi.
    The Raspberry Pi cannot directly use many of the sensors that are connected to
    the Arduino, while the Arduino can. At the same time, the Arduino does not have
    a screen, while the Raspberry Pi does.
  prefs: []
  type: TYPE_NORMAL
- en: '**SOFTWARE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two parts to the software for this project: a modified version of
    the *All_Sensors* Arduino sketch and a Python program run on the Raspberry Pi
    to allow it to communicate with the Arduino.'
  prefs: []
  type: TYPE_NORMAL
- en: Before the apocalypse, make sure you’ve downloaded the source code for this
    book; go to *[http://www.nostarch.com/zombies/](http://www.nostarch.com/zombies/)*
    to get started.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARDUINO SOFTWARE**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Arduino sketch you will use for this project, *Project_13_Control_Center_
    USB*, is based on the *All_Sensors* sketch that runs all of the other Arduino
    projects in this book. *Project_13_Control_Center_USB* just adds code to allow
    your Arduino to communicate with other devices over a serial connection (in this
    case, USB).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: For instructions on loading sketches onto your Arduino, see [Appendix C](app03.html#app03).
  prefs: []
  type: TYPE_NORMAL
- en: It’s best to test each part of this fairly complex system in isolation on your
    regular desktop or laptop computer before connecting it to the Raspberry Pi. You
    can power the Arduino from the USB connection to your laptop while testing, so
    you don’t need to use your postapocalyptic car battery power supply for preapocalyptic
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: To begin testing, load the *Project_13_Control_Center_USB* sketch onto the Arduino
    and click the magnifying glass in the Arduino IDE to open the serial monitor ([Figure
    8-4](ch08.html#ch08fig4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f08-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-4: The serial monitor'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that “9600 baud” is selected in the drop-down list at the bottom right
    of the serial monitor. This is the baud rate, the speed at which data is sent
    (measured in bits per second), and it must match the speed set in the sketch.
  prefs: []
  type: TYPE_NORMAL
- en: In the text entry area at the top of the serial monitor, enter the ? command
    and click **Send**. The Arduino should display a line of numbers like the `4.27
    26.10 1 0 0` shown in [Figure 8-4](ch08.html#ch08fig4) (your numbers will not
    match these, exactly). These numbers are the battery voltage, temperature, door
    status, PIR status, and smoke alarm status, respectively. For the three status
    values, `0` means everything is okay and `1` indicates an alarm. These are the
    values that will later be displayed on the control center. By simulating how the
    Raspberry Pi will fetch the values, you are testing that the Arduino part of the
    project is working.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re currently holding any zombies captive for research, try putting the
    temperature sensor up against a zombie’s skin and enter the `?` command again.
    If you’re lacking in test subjects (or feeling less adventurous), just hold the
    sensor between your fingers. Either way, you should see the temperature part of
    the message change.
  prefs: []
  type: TYPE_NORMAL
- en: If the responses in the serial monitor indicate that the Arduino side of your
    control center is working properly, you can unplug the Arduino from the regular
    computer and attach it to a USB port of the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: If the numbers do not appear, then check that the sketch uploaded properly onto
    the Arduino. If the numbers reported are not what you would expect for one of
    the projects, then check the wiring for that particular project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the Arduino code in *Project_13_Control_Center_USB*, and you will see
    that unlike in *All_Sensors*, the setup function includes the following line at
    the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This line tells the Arduino to open a serial connection, via its USB-serial
    interface, at a baud rate of 9600\. The value passed to `begin` must match the
    value you set in the serial monitor’s baud rate drop-down list.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sketch also has a change at the top of the loop function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines check whether any serial communication over USB is waiting to be
    processed. If so, when you send the `?` message, the `reportStatus` function is
    called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `reportStatus` function formats the response from earlier, separating the
    parts of the message with a space character. The final `println` command adds
    a newline character to the end of the response.
  prefs: []
  type: TYPE_NORMAL
- en: '**RASPBERRY PI SOFTWARE**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The program for this project can be found in the *Raspberry Pi/control_center_usb*
    folder. To download all the Raspberry Pi programs used in this book in one go,
    you could also use the following commands from a terminal window on the Raspberry
    Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: $ cd /home/pi
  prefs: []
  type: TYPE_NORMAL
- en: $ git clone https://github.com/simonmonk/zombies.git
  prefs: []
  type: TYPE_NORMAL
- en: These commands should fetch all of the code for the book, including the Arduino
    code used in other projects.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: For these commands to work, you will need to have the Pi connected to your network
    with an Ethernet cable, and your Internet connection needs to be up and running.
    Therefore, this is definitely something to do when you sense the apocalypse looming.
    Don’t wait until afterward!
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the control center, you need to run the Python program *control.py*.
    Enter the following commands in a terminal window on your Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: $ cd "zombies/Raspberry Pi/control_center_usb"
  prefs: []
  type: TYPE_NORMAL
- en: $ python control.py
  prefs: []
  type: TYPE_NORMAL
- en: When the program has started up, the window in [Figure 8-5](ch08.html#ch08fig5)
    should appear.
  prefs: []
  type: TYPE_NORMAL
- en: The program displays the readings from the Arduino in a human-readable way,
    and any readings that require your immediate attention will be highlighted in
    red. When there is no cause for alarm, the readings will be green. In this example,
    my door is open, which means zombies may be breaking into my compound as I write!
    While I go check on that, you can open the *control_center_ usb.py* file in a
    text editor and take a look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f08-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-5: The control center'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the first time we have looked at Python code since [Chapter 5](ch05.html#ch05),
    so the syntax may look unfamiliar after so much Arduino code. If you get confused
    about which is which, just keep in mind the main differences: in Python code,
    there aren’t any semicolons at the end of lines, and indentation is used to group
    code into blocks instead of curly braces as in Arduino code.'
  prefs: []
  type: TYPE_NORMAL
- en: I haven’t listed the full code for the control center here as it is almost 100
    lines, but in the following paragraphs, I’ll highlight a few key features. It
    is useful to know how the code works in case you decide you’d like to modify it.
    You might, for instance, want to improve the display window so it has an extra
    column for the units used in the measurements. You could even have it display
    more explicit warnings about fires, detected zombies, and so on to tell you when
    you need to get out of your base in a hurry. Visit *[http://effbot.org/tkinterbook/tkinter-index.htm](http://effbot.org/tkinterbook/tkinter-index.htm)*
    to find out more about making fancy user interfaces in Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: '**THRESHOLD VALUES**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'At the top of the file are three constants that may need to be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'These constants specify the value limits that determine when the results turn
    red in the control window. In this example, if the voltage drops under 11V, that
    row will turn from green to red. The same happens if the temperature drops below
    –10 or rises above 45 degrees Celsius. The units of temperature used in `TEMP_MAX`
    and `TEMP_MIN` come from the units you used in the Arduino sketch. For details
    on how to switch between degrees Celsius and Fahrenheit, refer to “[Project 12:
    Temperature Alarm](ch07.html#ch00lev1sec130)” on [page 131](ch07.html#page_131).'
  prefs: []
  type: TYPE_NORMAL
- en: Set your thresholds to appropriate values for your base, taking into account
    how much advance warning you want if your battery level gets low or the temperature
    rises.
  prefs: []
  type: TYPE_NORMAL
- en: '**STATUS LABELS**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The following code shows how the labels and results in the user interface are
    coded, using battery voltage as an example. The code is contained within a class
    named `App`, and the user interface is defined in the `__init__` initialize method
    of this `App` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates the label `Volts` and positions it using a grid layout
    at row 0, column 0\. The `sticky` attribute indicates that the field should “stick”
    to the “east” wall of the layout cell—in other words, be right justified.
  prefs: []
  type: TYPE_NORMAL
- en: The second line defines a special type of variable (`StringVar`) used by the
    Tk graphics library that provides the user interface for the program. This variable
    is assigned to a member variable called `volts_var`, which is then referenced
    in the third line when the label for the voltage value is defined. When the value
    of the `volts_var` variable changes, the label field will automatically display
    the new value of `volts_var`.
  prefs: []
  type: TYPE_NORMAL
- en: Grid layouts divide the window up rather like table cells and allow you to specify
    the positions of user interface items without having to provide exact coordinates.
    The grid is arranged as rows numbered from top to bottom, with the topmost row
    being 0, and as columns numbered from left to right, with the leftmost column
    being 0\. The last line of code for the volts display positions the label on the
    grid layout at row 0 and column 1 to put it alongside the label `Volts`.
  prefs: []
  type: TYPE_NORMAL
- en: The code for the other fields displayed in the window is defined in the same
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you may want to use more—or less—descriptive labels, so change them
    to anything you like. For more information on formatting with the Tk graphics
    library, see *[http://tkinter.unpythonic.net/wiki/](http://tkinter.unpythonic.net/wiki/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMUNICATING WITH THE ARDUINO**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'At the end of the `__init__` method you will find these two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first of these lines opens serial communication with the Arduino. The second
    pauses for two seconds to allow the Arduino time to start up before any messages
    are sent to it.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEEPING YOUR CONTROL CENTER UPDATED**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If the displayed values don’t automatically update, your control center is pretty
    useless. Updating is accomplished with the `read_arduino` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the first part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `read_arduino` method first sends the `?` command to the Arduino, which
    responds with a line of values separated by spaces, as you saw when trying out
    the Arduino code in the serial monitor. The returned string of values is then
    split up, using the spaces as a delimiter (this is the default delimiter for the
    `.split()` function). `StringVars` associated with each field in the window are
    then updated in the display.
  prefs: []
  type: TYPE_NORMAL
- en: After the values are updated, the remainder of the `read_arduino` method sets
    the color of the fields to red or green as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that the `read_arduino` method is called at regular intervals, it
    is necessary to schedule a call to it from the Tk user interface object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code ensures that after 100 milliseconds (1/10 second), the function update
    will be called. The function update first calls `read_arduino` and then schedules
    itself to run again in 500 milliseconds (half a second), meaning that our control
    center checks all of our sensors every half second. If you’re in danger, whether
    from zombies or environmental hazards, you’ll know quickly!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run this program at the same time as you run the USB webcam of “[Project
    7: Monitor Zombies with a USB Webcam](ch05.html#ch00lev1sec95)” on [page 87](ch05.html#page_87)
    by opening two LXTerminal windows and running one program in each terminal window.
    That way, you can see instantly what might have triggered your alarms.'
  prefs: []
  type: TYPE_NORMAL
- en: '**USING THE CONTROL CENTER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now, you have a screen that will give you continuous updates on all of the safeguards
    of your stronghold. Place your control center somewhere you can easily see it,
    and if you’ve included all of the components from [Figure 8-3](ch08.html#ch08fig3),
    you’ll know instantly if your supplies are in danger, if your power supply is
    running low, and if zombies have breached your perimeter.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that the user interface values do not update, then go back to “[Arduino
    Software](ch08.html#ch00lev1sec141)” on [page 143](ch08.html#page_143) and again
    test the Arduino using the serial monitor by sending the `?` command to look for
    a status response in the serial monitor.
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT 14: GOING WIRELESS WITH BLUETOOTH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The control center of Project 13 is bogged down in wires right now, and you
    have to keep the Arduino and the Raspberry Pi together. That also means that you’ll
    probably only know that, say, your base has caught on fire once the flames have
    reached you—and then it will be too late. You can make your control center much
    more effective by connecting the Raspberry Pi and the Arduino wirelessly over
    Bluetooth, as we’ll do in this project, so your sensors can detect danger before
    it reaches you and your monitor.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi does not have Bluetooth built in, but it will accept a wide
    range of Bluetooth USB dongles. We’ll add Bluetooth to the Arduino using a Bluetooth
    serial module, shown sticking out at the right in [Figure 8-6](ch08.html#ch08fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f08-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-6: Adding Bluetooth to an Arduino'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this project, first complete “[Project 13: A Raspberry Pi Control Center](ch08.html#ch00lev1sec137)”
    on [page 140](ch08.html#page_140) and make sure that everything else is working
    properly. Then you’ll be ready to add the wireless link.'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU WILL NEED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make this project, you are going to need everything from Project 13 plus
    the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **ITEMS** | **NOTES** | **SOURCE** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ![image](graphics/square.jpg) USB Bluetooth dongle | Compatible with Raspberry
    Pi | Computer store, eBay |'
  prefs: []
  type: TYPE_TB
- en: '| ![image](graphics/square.jpg) Bluetooth module | HC-06 Bluetooth serial module
    | eBay |'
  prefs: []
  type: TYPE_TB
- en: '| ![image](graphics/square.jpg) 270 Ω resistor |  | Mouser (293-270-RC) |'
  prefs: []
  type: TYPE_TB
- en: '| ![image](graphics/square.jpg) 470 Ω resistor |  | Mouser (293-470-RC) |'
  prefs: []
  type: TYPE_TB
- en: '| ![image](graphics/square.jpg) Connecting wire |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ![image](graphics/square.jpg) Header pins | 4-way | Adafruit (392), eBay
    |'
  prefs: []
  type: TYPE_TB
- en: '| ![image](graphics/square.jpg) Screwshield |  | Adafruit (196) |'
  prefs: []
  type: TYPE_TB
- en: '| ![image](graphics/square.jpg) Multistranded or solid-core hookup wire | For
    making connections on the prototyping area of the screwshield | Adafruit (1311),
    scavenge |'
  prefs: []
  type: TYPE_TB
- en: '| ![image](graphics/square.jpg) Female-female jumper wires (×4) | (Optional)
    Would replace header pins | Adafruit (266) |'
  prefs: []
  type: TYPE_TB
- en: The hardware for this project can be built onto the screwshield that you have
    used while building up the various sensor projects (4, 6, 10, 11, and 12) that
    use a screwshield. The Bluetooth module I used is a Cambridge Silicon Radio (CSR)
    device. For a list of Bluetooth dongles compatible with the Raspberry Pi, visit
    *[http://elinux.org/RPi_USB_Bluetooth_adapters/](http://elinux.org/RPi_USB_Bluetooth_adapters/)*.
    If you are worried about soldering the Bluetooth module directly to the header
    pins, then you may prefer to use four female-to-female jumper wires to link the
    header pins to the Bluetooth module.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: You can save yourself some tricky soldering by looking for a module and adapter
    pair that already has the module soldered into place.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of the Bluetooth HC-06 modules have six rather than four pins. The pins
    you will be using are +5V, GND, TXD, and RXD, so you can ignore the other two.
    These are usually the outside pins, but do check the pinout names as occasionally
    some designs swap the pin positions around.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONSTRUCTION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To enable Bluetooth connectivity for your Raspberry Pi, you only need to attach
    a USB dongle to your system.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino requires the aforementioned Bluetooth module and a pair of resistors
    to divide the 5V signal level of the Arduino to the 3V level expected by the Bluetooth
    module. Mount the module and resistors to the side of the screwshield’s prototyping
    area not already being used by the fire alarm interface from Project 11.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-7](ch08.html#ch08fig7) shows the wiring layout for the project. To
    avoid confusion, [Figure 8-7](ch08.html#ch08fig7) shows the Bluetooth module attached
    to a screwshield without any other projects built on it.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f08-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-7: Wiring layout for adding Bluetooth to an Arduino'
  prefs: []
  type: TYPE_NORMAL
- en: The Bluetooth module needs to lie flat to keep it out of the way of the LCD
    shield. For this, you need to solder a row of four 0.1-inch header pins and then
    solder the Bluetooth module perpendicular to the pins, lying flat over the screwshield.
    If you prefer, you may also use female-to-female jumper wires to connect the Bluetooth
    module to the header pins.
  prefs: []
  type: TYPE_NORMAL
- en: '**STEP 1: SOLDER THE HEADER PINS**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Solder the strip of header pins into place. You can see in [Figure 8-8](ch08.html#ch08fig8)
    that the +5V and GND pin connections neatly line up with the two power rows at
    the top of the screwshield.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f08-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-8: The header pins soldered in place'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the wire shown leading to pin 3 of the Arduino is part of the fire
    alarm from Project 11, not this project.
  prefs: []
  type: TYPE_NORMAL
- en: '**STEP 2: SOLDERING THE RESISTORS AND LINKING WIRE**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Solder the resistors and linking wire to the screwshield in the positions shown
    in [Figure 8-9](ch08.html#ch08fig9): the 470 Ω resistor goes from GND at Arduino
    column 7 to the bottom header at column 4; the 270 Ω resistor goes from the bottom
    pin of the header at row 3 to Arduino pin 1\. The connecting wire runs from Arduino
    pin 0 to the third header pin down.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f08-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-9: Soldering the resistors and connecting wire'
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve soldered the resistors and connecting wire in place, flip the screwshield
    over to solder the underside of the board.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-10](ch08.html#ch08fig10) shows a close-up of the underside of the
    screwshield. To make it easier to identify what is connected to what, the resistors
    and linking wire are shown as if they were visible through the board.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f08-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-10: Connecting the underside of the screwshield'
  prefs: []
  type: TYPE_NORMAL
- en: First, bend the bottom lead of the 270 Ω resistor over toward the bottom pin
    header ➊. Solder this to the bottom pin header’s pad and snip off the remaining
    lead. Bend the remaining lead from the bottom end of the 470 Ω resistor to meet
    the pad one position to its left ➋. Solder the lead to that pad and snip off the
    excess lead. You have now made a continuous connection from the bottom of the
    header pins to the bottoms of the 270 Ω resistor and the 470 Ω resistor.
  prefs: []
  type: TYPE_NORMAL
- en: The final connection on the underside ➌ uses the spare wire from soldering the
    lead from the jumper wire to the header pin to its immediate left.
  prefs: []
  type: TYPE_NORMAL
- en: '**STEP 3: SOLDERING THE BLUETOOTH MODULE**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The final step is to solder the Bluetooth module to the header pins. Solder
    one pad on the module to one of the header pins, and while keeping the solder
    molten, position the Bluetooth module so that it is resting against the 1 kΩ resistor
    that came attached to the screwshield. Then attach the first prong of the module
    to the first pin. You can see this resistor on the bottom right of [Figure 8-9](ch08.html#ch08fig9).
    Once the first prong is soldered, all the other prongs should be lined up and
    easy to solder. If you prefer, you could use female-to-female jumper wires to
    link the screwshield to the Bluetooth module. [Figure 8-11](ch08.html#ch08fig11)
    shows the Bluetooth module in position.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f08-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-11: The Bluetooth module soldered in position'
  prefs: []
  type: TYPE_NORMAL
- en: '**SOFTWARE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since your sensors aren’t changing, you’ll use the same Arduino software as
    in “[Arduino Software](ch08.html#ch00lev1sec141)” on [page 143](ch08.html#page_143).
    The Bluetooth module replaces the USB interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this hardware communicates with the Bluetooth module using the serial
    port, which on an Arduino Uno is shared with the USB interface. This means that
    you need to unplug the shield (or just the Bluetooth module if you used jumper
    wires) before you program the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Raspberry Pi software, however, does need a couple of minor changes, and
    getting the Raspberry Pi to use Bluetooth does require you to install a whole
    load of software. Remember: You’ll need to install this software before the Internet
    fails!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Plug the Bluetooth USB adapter into a free USB slot on your Raspberry Pi and
    then run the following commands in an LXTerminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: $ sudo apt-get update
  prefs: []
  type: TYPE_NORMAL
- en: $ sudo apt-get install bluetooth
  prefs: []
  type: TYPE_NORMAL
- en: $ sudo apt-get install bluez-utils
  prefs: []
  type: TYPE_NORMAL
- en: $ sudo apt-get install blueman
  prefs: []
  type: TYPE_NORMAL
- en: Installing the software will take a considerable amount of time, so you might
    want to practice your martial arts skills on any willing humans or unwilling zombies
    available.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the software is installed and you’ve worked up a good sweat, reboot the
    Raspberry Pi with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: $ sudo reboot
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the Raspberry Pi has rebooted, open a terminal and run the following command
    to ascertain the ID of the BT interface:'
  prefs: []
  type: TYPE_NORMAL
- en: $ hciconfig
  prefs: []
  type: TYPE_NORMAL
- en: '➊  hci0: Type: BR/EDR Bus: USB'
  prefs: []
  type: TYPE_NORMAL
- en: 'BD Address: 00:15:83:0C:BF:EB ACL MTU: 339:8 SCO MTU: 128:2'
  prefs: []
  type: TYPE_NORMAL
- en: UP RUNNING PSCAN
  prefs: []
  type: TYPE_NORMAL
- en: RX bytes:419213 acl:19939 sco:0 events:7407 errors:0
  prefs: []
  type: TYPE_NORMAL
- en: TX bytes:95875 acl:7321 sco:0 commands:57 errors:0
  prefs: []
  type: TYPE_NORMAL
- en: The information we want here is the name of the interface, which in this case
    is `hci0` at ➊. When you run this, if the number after `hci` above is not `0`,
    then make a note of the number; you will need it later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every Bluetooth device has a unique ID called a *MAC address*. We need to find
    the MAC address for our new Arduino Bluetooth module to pair it with the Raspberry
    Pi. When you power up the Arduino, you should see an LED blinking on the Bluetooth
    module. The LED is blinking because it has not yet been paired up with the Raspberry
    Pi; once it has been paired, the LED will go on and stay on. Run the following
    command to find the ID of the Bluetooth module:'
  prefs: []
  type: TYPE_NORMAL
- en: $ hcitool scan
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from the `hcitool` command should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The ID is the six-part number. Copy this into the copy-and-paste buffer (Copy
    and Paste are on the right-click menu). Then enter the following command to link
    the Raspberry Pi and the Bluetooth module (remember to change the Bluetooth ID
    to match your Bluetooth module’s ID):'
  prefs: []
  type: TYPE_NORMAL
- en: $ sudo hcitool cc 00:11:04:08:04:76
  prefs: []
  type: TYPE_NORMAL
- en: If you have not already done so, follow the instructions in “[Raspberry Pi Software](ch08.html#ch00lev1sec142)”
    on [page 145](ch08.html#page_145) for downloading the Raspberry Pi software. You
    will find the Bluetooth version of *control.py* in the folder *Raspberry Pi/control_center_bt*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have the program, run the following `sudo` command, again replacing
    the Bluetooth ID with your own:'
  prefs: []
  type: TYPE_NORMAL
- en: $ sudo rfcomm connect 0 00:11:04:08:04:76 1 &
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 2625'
  prefs: []
  type: TYPE_NORMAL
- en: $ Connected /dev/rfcomm0 to 00:11:04:08:04:76 on channel 1
  prefs: []
  type: TYPE_NORMAL
- en: Press CTRL-C for hangup
  prefs: []
  type: TYPE_NORMAL
- en: $
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need to run this command before you run the program each time your Raspberry
    Pi reboots. The `&` on the end of the command runs it in the background so that
    you can use the terminal window to run the program itself. Hit ENTER to get the
    `$` command prompt back.
  prefs: []
  type: TYPE_NORMAL
- en: If your Bluetooth interface name did not have a `0` after `hci` when you ran
    the `hciconfig` command earlier, change the first `0` after `connect` to match
    the number on the end of `hci`. Remember when I asked you to make a note of this
    number?
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, move to the project directory and run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: $ cd ~/zombies/control_center_bt/
  prefs: []
  type: TYPE_NORMAL
- en: $ python control.py
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the *control.py* files from this project and Project 13, you
    can see that the only difference is the port. In this version of *control.py*,
    we set the port to */dev/rfcomm0* rather than */dev/ttyACM0* so that it uses the
    Bluetooth connection rather than the USB connection.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING THE BLUETOOTH-ENABLED COMMAND CENTER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The project works in exactly the same way as the USB version in Project 13,
    with the window displaying the same information, only now it’s a little more portable
    as long as your webcam is wireless. If zombies get into your compound, just grab
    the Raspberry Pi, monitor, and power source and barricade yourself inside a closet
    until they lose interest.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll work on ways to distract zombies in a pinch, because
    the undead are usually much easier to run from than they are to actually kill.
  prefs: []
  type: TYPE_NORMAL
