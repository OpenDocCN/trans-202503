<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="ch5" epub:type="chapter" role="doc-chapter">
<span aria-label="81" epub:type="pagebreak" id="pg_81" role="doc-pagebreak"/>
<hgroup>
<h2 class="CHAPTER" id="ch5">
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">5</span></span>
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">CUSTOM FUNCTIONS</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="380" src="../images/opener.jpg" width="380"/>
</figure>
<p class="INTRO">In this chapter, you’ll learn how to declare and use your own <i>functions</i>, which are named, self-contained sequences of code that accomplish a particular task. You’ll see how functions promote code reusability, since putting code in a function is much more efficient than having to rewrite the same sequence of code every time you need to perform that function’s task. Functions also let you write programs that achieve a lot with a small number of statements, since each statement can invoke the complex logic hidden within one of your functions.</p>
<p class="TX">Custom functions are typically declared in a separate file from the main program statements that an application will execute. This stems from the <i>PHP Standards Recommendations (PSRs)</i>, a list of guidelines and best practices for PHP programming. According to PSR-1, a file should either declare <span aria-label="82" epub:type="pagebreak" id="pg_82" role="doc-pagebreak"/>symbols (such as functions) or cause side effects, but not both. A <i>side effect</i> is a concrete outcome of executing a piece of code, such as outputting text, updating a global variable, changing the contents of a file, and so on.</p>
<p class="TX">While functions themselves can cause side effects such as these, <i>declaring</i> a function (defining what the function will do) isn’t the same as <i>calling</i> the function (having the function actually do that thing). Therefore, functions should be declared in one file and called in another. To adhere to this guideline, this chapter first touches on the basics of how to work with code spread across multiple files before we turn our attention to functions. We’ll revisit the topic of working with files in more detail in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="toc-link_69"/><span class="SANS_Futura_Std_Bold_B_11">Separating Code into Multiple Files</span></h3>
<p class="TNI1">Even if we set aside the best practice of declaring functions in a separate file, it’s still standard to break up an application’s code across multiple files. Consider that a sophisticated application might consist of tens of thousands of lines of code. If all that code were in a single large text file, navigating that file and locating a particular section of code to work on would be difficult. Organizing code into different files makes a project much more manageable.</p>
<p class="TX">Using multiple files also promotes code reusability. Once you start writing your own functions, you’ll see how declaring those functions in separate files makes it easy to reuse the function in different parts of a project or in different projects altogether. To give another example, multipage web applications often include the same elements, such as HTML headers, footers, and navigation lists on many pages. Rather than repeating that code for each page that needs it, the common code can be written once in its own file. This way, if you need to change something about it (for example, updating the image reference for a web logo), you need to make the change in only one place instead of tracking down and updating every instance of the repeated code. Software engineers call this the <i>don’t repeat yourself (DRY)</i> principle.</p>
<p class="TX">Once you start spreading an application’s code across multiple files, you need a way to access one file’s code from within another file. In this section, we’ll look at some PHP language features that make this possible.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="H2" id="sec2"><span id="toc-link_70"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Reading in and Executing Another Script</span></h4>
<p class="TNI1">PHP’s <span class="SANS_TheSansMonoCd_W5Regular_11">require_once</span> command reads the code in another file and executes it. To see how this command works, we’ll create two scripts. One, the main script, will use <span class="SANS_TheSansMonoCd_W5Regular_11">require_once</span> to access the code from the other script. First, create a <i>main.php</i> file containing the code shown in <a href="#lis5-1">Listing 5-1</a>.</p>
<span id="lis5-1"/>
<pre><code>&lt;?php&#13;
print "I'm in main.php\n";&#13;
&#13;
require_once 'file2.php';&#13;
&#13;
print "I'm back in main.php\n";</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-1: A main script to read in and execute code from a different script</span></p>
<p class="TX"><span aria-label="83" epub:type="pagebreak" id="pg_83" role="doc-pagebreak"/>In this script, we print out two messages indicating that we’re in the main application file. In between, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">require_once</span> command to read in and execute the contents of the <i>file2.php</i> script. The filename is specified as a string immediately after the command. Since we haven’t specified a directory path along with the filename (for example, <i>Users/matt/file2.php</i>), it’s understood that the file is in the same folder as this current script. This is known as a <i>relative path</i>: the file’s location is determined relative to the location of the current script.</p>
<p class="TX">Now create <i>file2.php</i> containing the code shown in <a href="#lis5-2">Listing 5-2</a>. Be sure to save this file in the same location as <i>main.php</i>.</p>
<span id="lis5-2"/>
<pre><code>&lt;?php&#13;
print "\t I'm printing from file2.php\n";&#13;
print "\t I'm also printing from file2.php\n";</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-2: The contents of</span> <span class="SANS_Futura_Std_Book_11">file2.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">to be read in and executed from another script</span></p>
<p class="TX">This script has two <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> statements, printing out messages saying they’re from <i>file2.php</i>. Notice that each message begins with a tab escape character (<span class="SANS_TheSansMonoCd_W5Regular_11">\t</span>). This way, these messages will be indented, whereas the messages printed from our main script won’t be, a visual clue that the messages are coming from separate scripts.</p>
<p class="TX">Now enter <span class="SANS_TheSansMonoCd_W7Bold_11">php main.php</span> at the command line to run the main script. Here’s the output:</p>
<pre><code>I'm in main.php&#13;
    I'm printing from file2.php&#13;
    I'm also printing from file2.php&#13;
I'm back in main.php</code></pre>
<p class="TX">We see the first message from the main script, followed by the two indented messages from <i>file2.php</i>. This confirms that the contents of <i>file2.php</i> were read in and executed thanks to the <span class="SANS_TheSansMonoCd_W5Regular_11">require_once</span> statement in our main script. Finally, the program flow of control returns back to the main script after the <span class="SANS_TheSansMonoCd_W5Regular_11">require_once</span> statement, and we see the final printed message from the main script.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>Besides</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">require_once</span><i>, PHP provides three other commands for reading in and executing code declared in a separate file:</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">require</span><i>,</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">include</span><i>, and</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">include_once</span><i>. They all work similarly; you can read about the differences in the PHP documentation. In 99.99 percent of the web applications I write, I use</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">require_once</span><i>.</i></p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="H2" id="sec3"><span id="toc-link_71"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Creating Absolute Filepaths</span></h4>
<p class="TNI1">The constant <span class="SANS_TheSansMonoCd_W5Regular_11">__DIR__</span> will always refer to the <i>absolute filepath</i> to the script currently being executed, meaning the complete filepath, starting from the root directory. This is one of PHP’s <i>magic constants</i>, built-in constants whose value changes depending on the context. In the case of <span class="SANS_TheSansMonoCd_W5Regular_11">__DIR__</span>, the value varies based on the location of the file in which <span class="SANS_TheSansMonoCd_W5Regular_11">__DIR__</span> is being evaluated.</p>
<p class="TX"><span aria-label="84" epub:type="pagebreak" id="pg_84" role="doc-pagebreak"/>It’s best to use <span class="SANS_TheSansMonoCd_W5Regular_11">__DIR__</span> whenever possible when writing <span class="SANS_TheSansMonoCd_W5Regular_11">require_once</span> statements: simply concatenate the value of <span class="SANS_TheSansMonoCd_W5Regular_11">__DIR__</span> with any remaining relative path information to access the file you’re trying to read in and execute. This avoids any confusion as to whether the path relates to the current script (the one calling the <span class="SANS_TheSansMonoCd_W5Regular_11">require_once</span> command) or to a script that might have required the current script. Consider that you might have a chain of scripts, with one script requiring another, and that script also requiring another. If these scripts were in different directories, using the <span class="SANS_TheSansMonoCd_W5Regular_11">__DIR__</span> magic constant ensures that wherever you write a <span class="SANS_TheSansMonoCd_W5Regular_11">require_once</span> statement, you’ll know the path will be correct to the files you wish to read in and execute.</p>
<p class="TX">To try using <span class="SANS_TheSansMonoCd_W5Regular_11">__DIR__</span>, update your <i>main.php</i> file as shown in <a href="#lis5-3">Listing 5-3</a>. The changes are shown in black text.</p>
<span id="lis5-3"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print "I'm in main.php\n";</span>&#13;
&#13;
$callingScriptPath = __DIR__;&#13;
print "callingScriptPath = $callingScriptPath\n";&#13;
&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> <span class="TheSansMonoCd_W5Regular_Grey_11">require_once</span> __DIR__ . '/file2.php';&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print "I'm back in main.php\n";</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-3: A main script using</span> <span class="TheSansMonoCd_W5Regular_Italic_11">__DIR__</span> <span class="SANS_Futura_Std_Book_Oblique_11">to read in and execute code in a different script</span></p>
<p class="TX">We assign the <span class="SANS_TheSansMonoCd_W5Regular_11">$callingScriptPath</span> variable the value of the <span class="SANS_TheSansMonoCd_W5Regular_11">__DIR__</span> magic constant and print a message containing this variable. Then we use <span class="SANS_TheSansMonoCd_W5Regular_11">__DIR__</span> after the <span class="SANS_TheSansMonoCd_W5Regular_11">require_once</span> command to make it explicit that the <i>file2.php</i> script resides in the same directory as this main script <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Notice that we use the string concatenation operator (<span class="SANS_TheSansMonoCd_W5Regular_11">.</span>) to combine the value of <span class="SANS_TheSansMonoCd_W5Regular_11">__DIR__</span> with the string <span class="SANS_TheSansMonoCd_W5Regular_11">'/file2.php'</span>, building an absolute path to the other file. Here’s the output of running the main script:</p>
<pre><code>I'm in main.php&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> callingScriptPath = /Users/matt/magic&#13;
    I'm printing from file2.php&#13;
    I'm also printing from file2.php&#13;
I'm back in main.php</code></pre>
<p class="TX">As before, the first message from <i>main.php</i> prints out. Then we see the path to the main script (the value of <span class="SANS_TheSansMonoCd_W5Regular_11">__DIR__</span>) printed out <span aria-label="annotation1" class="CodeAnnotation">❶</span>. For me, it is <i>/Users/matt/magic</i>, the path to the directory on my computer for this example project. The rest of the output is the same as before, featuring the messages from <i>file2.php</i> followed by the final printed message from the main script.</p>
</section>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H1" id="sec4"><span id="toc-link_72"/><span class="SANS_Futura_Std_Bold_B_11">Declaring and Calling a Function</span></h3>
<p class="TNI1">Now let’s turn our attention to declaring and using our first custom function. The function will determine which of two numbers is smaller. In <span aria-label="85" epub:type="pagebreak" id="pg_85" role="doc-pagebreak"/>keeping with best practices, we’ll declare the function in one file, <i>my_functions.php</i>, and then call it from a separate file, <i>main.php</i>. Start a new project and create <i>my_functions.php</i> containing the code shown in <a href="#lis5-4">Listing 5-4</a>.</p>
<span id="lis5-4"/>
<pre><code>&lt;?php&#13;
function which_is_smaller(int $n1, int $n2): int&#13;
{&#13;
    if ($n1 &lt; $n2) {&#13;
        return $n1;&#13;
    } else {&#13;
        return $n2;&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-4: Declaring a function in</span> <span class="SANS_Futura_Std_Book_11">my_functions.php</span></p>
<p class="TX">Here we declare a function named <span class="SANS_TheSansMonoCd_W5Regular_11">which_is_smaller()</span>. We begin with the keyword <span class="SANS_TheSansMonoCd_W5Regular_11">function</span>, followed by the function name. By convention, function names are written in snake case, in all lowercase letters and with underscores to join multiple words. This enables you to write meaningful, easy-to-read function names (although, unfortunately, not all of PHP’s built-in functions follow this naming convention because of choices made in the language’s early design).</p>
<p class="TX">After the function name comes a set of parentheses containing a comma-separated list of the function’s <i>parameters</i>. These are inputs that the function needs to do its job. In this case, we have two parameters, <span class="SANS_TheSansMonoCd_W5Regular_11">$n1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$n2</span>, representing the two numbers we want the function to compare. Each parameter name is preceded by its data type to ensure that the correct form of data enters the function. Here, for example, <span class="SANS_TheSansMonoCd_W5Regular_11">int $n1</span> indicates that parameter <span class="SANS_TheSansMonoCd_W5Regular_11">$n1</span> should be an integer.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>If a function doesn’t need any parameters, you still have to include an empty set of parentheses after the function name.</i></p>
<p class="TX">After the parentheses comes a colon (<span class="SANS_TheSansMonoCd_W5Regular_11">:</span>), followed by the function’s return type. Most functions do some work and produce a value as a result, which the function then <i>returns</i>, or provides, to the script that called the function. The <i>return type</i> specifies the data type of this value. In this case, the function will return the integer <span class="SANS_TheSansMonoCd_W5Regular_11">$n1</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">$n2</span>, whichever is smaller, so we set the return type to <span class="SANS_TheSansMonoCd_W5Regular_11">int</span>.</p>
<p class="TX">The code we’ve written so far has defined the function’s <i>signature</i>, a combination of its name, parameters (and their types), and return type. The PHP engine uses a function’s signature to uniquely identify the function, recognize when we’re calling it, validate that appropriate data is being passed to the function’s parameters, and ensure that the function is returning an appropriate value.</p>
<p class="TX">Next comes the <i>body</i> of the function, a statement group enclosed within curly brackets and containing the code that will execute each time the function is called. The body of our <span class="SANS_TheSansMonoCd_W5Regular_11">which_is_smaller()</span> function consists of an <span aria-label="86" epub:type="pagebreak" id="pg_86" role="doc-pagebreak"/><span class="SANS_TheSansMonoCd_W5Regular_11">if...else</span> statement that tests whether integer <span class="SANS_TheSansMonoCd_W5Regular_11">$n1</span> is smaller than integer <span class="SANS_TheSansMonoCd_W5Regular_11">$n2</span>. If <span class="SANS_TheSansMonoCd_W5Regular_11">$n1</span> is smaller, the <span class="SANS_TheSansMonoCd_W5Regular_11">return $n1;</span> statement will be executed. Otherwise (if <span class="SANS_TheSansMonoCd_W5Regular_11">$n2</span> is smaller or the same as <span class="SANS_TheSansMonoCd_W5Regular_11">$n1</span>), <span class="SANS_TheSansMonoCd_W5Regular_11">return $n2;</span> will be executed. In both cases, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> keyword to make the function provide a value (either <span class="SANS_TheSansMonoCd_W5Regular_11">$n1</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">$n2</span>) to the script that called it. As soon as a function reaches a <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> statement, the function stops executing and gives control back to the calling script. Even if the function body includes additional statements after the <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> statement, they won’t execute after the function has returned a value.</p>
<p class="TX">Now that we’ve declared a function, let’s use it. Create <i>main.php</i> in the same location as <i>my_functions.php</i> and enter the code shown in <a href="#lis5-5">Listing 5-5</a>.</p>
<span id="lis5-5"/>
<pre><code>&lt;?php&#13;
require_once __DIR__ . '/my_functions.php';&#13;
&#13;
$result1 = which_is_smaller(5, 2);&#13;
print "the smaller of 5 and 2 = $result1\n";&#13;
&#13;
$result2 = which_is_smaller(5, 22);&#13;
print "the smaller of 5 and 22 = $result2\n";</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-5: Calling the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">which_is_smaller()</span> <span class="SANS_Futura_Std_Book_Oblique_11">function from</span> <span class="SANS_Futura_Std_Book_11">main.php</span></p>
<p class="TX">We use <span class="SANS_TheSansMonoCd_W5Regular_11">require_once</span> to read in the declaration of our function from <i>my_functions.php</i>. This doesn’t call the function; it simply makes the function available for use in our <i>main.php</i> script. Next, we call our function by writing the function name, followed in parentheses by the values we want the function to compare, <span class="SANS_TheSansMonoCd_W5Regular_11">5</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">2</span>. These values are known as <i>arguments</i>; they fill in the values of the function’s parameters. Notice that we call the function as part of an assignment statement for the <span class="SANS_TheSansMonoCd_W5Regular_11">$result1</span> variable. This way, the function’s return value will be stored in <span class="SANS_TheSansMonoCd_W5Regular_11">$result1</span> for later use (in this case, in the next line of code, where it’s printed out in a message). When a function has a return value, it’s common to follow this pattern of calling a function and assigning the result to a variable.</p>
<p class="TX">We conclude the script by calling the function again, this time using <span class="SANS_TheSansMonoCd_W5Regular_11">5</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">22</span> as arguments. This is the beauty of functions: you can call them as many times as you want, with different input values each time. We store the return value of the second function call in the <span class="SANS_TheSansMonoCd_W5Regular_11">$result2</span> variable and again print out a message showing the result. Here’s the output of running the <i>main.php</i> script:</p>
<pre><code>the smaller of 5 and 2 = 2&#13;
the smaller of 5 and 22 = 5</code></pre>
<p class="TX">We can see that our function is working correctly. It returns <span class="SANS_TheSansMonoCd_W5Regular_11">2</span> as the smaller of <span class="SANS_TheSansMonoCd_W5Regular_11">5</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">2</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">5</span> as the smaller of <span class="SANS_TheSansMonoCd_W5Regular_11">5</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">22</span>.</p>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="H2" id="sec5"><span id="toc-link_73"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Parameters vs. Arguments</span></h4>
<p class="TNI1">The terms <i>parameter</i> and <i>argument</i> are closely related and often mistaken for each other. When you <i>declare</i> a function, the parameters are variables that <span aria-label="87" epub:type="pagebreak" id="pg_87" role="doc-pagebreak"/>stand in for the inputs the function will work with. As you saw in <a href="#lis5-4">Listing 5-4</a>, you list the parameters in the parentheses after the function name. In our <span class="SANS_TheSansMonoCd_W5Regular_11">which_is_smaller()</span> function, the parameters were <span class="SANS_TheSansMonoCd_W5Regular_11">$n1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$n2</span>. Each parameter is a temporary variable, local to the function code itself, that will be assigned a value when the function is called. These variables exist only while the function is being executed. Once the function has finished executing, the local parameter variables are discarded from the computer’s memory.</p>
<p class="TX">The technical term for how long a variable “lives” in a software system is <i>scope</i>. The scope of any variable declared in a function, including a parameter, is local to the function itself. As such, you can’t expect to access a function’s variables from any code outside the function declaration. In our example, we can’t use the variables <span class="SANS_TheSansMonoCd_W5Regular_11">$n1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$n2</span> in <i>main.php</i>. Instead, the way to get a value out of a function is with a <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> statement.</p>
<p class="TX">When we <i>call</i> a function, the arguments are the specific values we pass to the function in the parentheses after the function name. These arguments supply the values for the function’s parameters. When we call <span class="SANS_TheSansMonoCd_W5Regular_11">which_is_smaller(5, 22)</span>, for example, the argument <span class="SANS_TheSansMonoCd_W5Regular_11">5</span> is assigned as the value of parameter <span class="SANS_TheSansMonoCd_W5Regular_11">$n1</span>, and the argument <span class="SANS_TheSansMonoCd_W5Regular_11">22</span> is assigned as the value of parameter <span class="SANS_TheSansMonoCd_W5Regular_11">$n2</span>. The order of arguments matches the order of parameters. In this case, the arguments are literals, but arguments can also be variables, as shown here:</p>
<pre><code>which_is_smaller($applesCount, $orangesCount)</code></pre>
<p class="TX">That’s all there is to it. Arguments are the values passed when executing a function, and parameters are the local variables created when the function executes, populated by the arguments received. Each argument passed to a function will therefore have a corresponding local (temporary) parameter variable while that function is executing. (One exception is the special case of pass-by-reference parameters, which we’ll cover later this chapter.)</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="H2" id="sec6"><span id="toc-link_74"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Errors from Incorrect Function Calls</span></h4>
<p class="TNI1">In two common cases, you’ll get an error when calling a function: if you don’t pass the correct number of arguments, or if you pass arguments of the wrong data type. (See <span class="Xref">“Errors, Warnings, and Notices”</span> on <span class="Xref"><a href="#pg_88">page 88</a></span> for information on errors and other kinds of alerts generated about your code.) Consider this call to our custom <span class="SANS_TheSansMonoCd_W5Regular_11">which_is_smaller()</span> function:</p>
<pre><code>$result = which_is_smaller(3);</code></pre>
<p class="TX">The function requires two integer arguments, but we’re providing only one. If you try to execute this expression, the application will halt and you’ll see a fatal error similar to the following:</p>
<pre><code>PHP Fatal error:  Uncaught ArgumentCountError: Too few arguments to function&#13;
which_is_smaller(), 1 passed in /Users/matt/main.php on line 9 and exactly 2&#13;
expected in /Users/matt/my_functions.php:2</code></pre>
<p class="TX"><span aria-label="88" epub:type="pagebreak" id="pg_88" role="doc-pagebreak"/>You’ll also get a fatal error if you pass arguments of the wrong data type (that is, values that can’t be type-juggled into the parameter data types specified in the function declaration). Consider this expression, where we pass non-numeric strings to our <span class="SANS_TheSansMonoCd_W5Regular_11">which_is_smaller()</span> function:</p>
<pre><code>$result = which_is_smaller('mouse', 'lion');</code></pre>
<p class="TX">Trying to execute this statement will produce an error message like the following:</p>
<pre><code>PHP Fatal error:  Uncaught TypeError: which_is_smaller(): Argument #1 ($n1)&#13;
must be of type int, string given, called in /Users/matt/main.php on line 10&#13;
and defined in /Users/matt/my_functions.php:2</code></pre>
<p class="BodyContinued">A fatal <span class="SANS_TheSansMonoCd_W5Regular_11">TypeError</span> has occurred because our function requires two integer arguments but we’ve provided strings instead.</p>
<aside aria-labelledby="box-4" class="box">
<h5 class="BoxTitle" id="box-4"><span class="SANS_Dogma_OT_Bold_B_11">ERRORS, WARNINGS, AND NOTICES</span></h5>
<p class="BoxBodyFirst"><span class="SANS_Futura_Std_Book_11">PHP communicates that it has identified issues in your code in three ways. In order from most to least severe, they are errors, warnings, and notices.</span></p>
<p class="BoxBody"><span class="SANS_Futura_Std_Book_11">A</span> <span class="SANS_Futura_Std_Book_Oblique_11">fatal runtime error</span> <span class="SANS_Futura_Std_Book_11">indicates that a problem that can’t be recovered from has occurred while code is being executed. In this case, the PHP engine immediately terminates the execution of the program. An example of a fatal runtime error is attempting to execute a function that the PHP engine can’t find (perhaps the function name is misspelled, or the statement to read in the file containing the function is missing). Errors can also occur when the PHP engine is parsing, rather than executing, a file containing code, such as when the PHP engine reads in a function declaration from a file. These</span> <span class="SANS_Futura_Std_Book_Oblique_11">parse errors</span> <span class="SANS_Futura_Std_Book_11">can be triggered, for example, by a missing semicolon or closing quotation mark in a function declaration. Fixing errors is crucial, or your code won’t run.</span></p>
<p class="BoxBody"><span class="SANS_Futura_Std_Book_Oblique_11">Warnings</span> <span class="SANS_Futura_Std_Book_11">identify nonfatal issues, meaning the PHP engine is able to continue executing your code in spite of the problem. For example, PHP will warn you if you’re using a variable that hasn’t been assigned a value, but it won’t halt the program. Instead, it’ll give the variable a default value such as</span> <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> <span class="SANS_Futura_Std_Book_11">and continue executing the code. You should always heed warnings and take steps to fix your code so the issue highlighted in the warning is resolved.</span></p>
<p class="BoxBody"><span class="SANS_Futura_Std_Book_11">A</span> <span class="SANS_Futura_Std_Book_Oblique_11">runtime notice</span> <span class="SANS_Futura_Std_Book_11">indicates something has occurred during code execution that</span> <span class="SANS_Futura_Std_Book_Oblique_11">could</span> <span class="SANS_Futura_Std_Book_11">indicate an error but that might also be intended behavior of correctly running code. An example is a</span> <span class="SANS_Futura_Std_Book_Oblique_11">deprecation message</span><span class="SANS_Futura_Std_Book_11">, a notice about a language feature that still works in the current version of the PHP engine but will be removed in a future version. These messages help you monitor your software and plan ahead for a feature eventually becoming unavailable. In fact, since PHP 8, many deprecation messages have been upgraded from notices to warnings as part of the quality improvements to encourage modern PHP programmers to write more robust and correct code.</span></p>
</aside>
</section>
<section aria-labelledby="sec7" epub:type="division">
<span aria-label="89" epub:type="pagebreak" id="pg_89" role="doc-pagebreak"/>
<h4 class="H2" id="sec7"><span id="toc-link_75"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Type Juggling</span></h4>
<p class="TNI1">To avoid a <span class="SANS_TheSansMonoCd_W5Regular_11">TypeError</span> like the one we just saw when arguments of the wrong type are provided, the PHP engine attempts to juggle those arguments into the expected data type. (For a refresher on type juggling, see <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>.) <a href="#lis5-6">Listing 5-6</a> shows some examples where we provide non-integer arguments to our <span class="SANS_TheSansMonoCd_W5Regular_11">which_is_smaller()</span> function. Update your <i>main.php</i> file to match the listing.</p>
<span id="lis5-6"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">require_once __DIR__ . '/my_functions.php';</span>&#13;
&#13;
$result1 = which_is_smaller(3.5, 2);&#13;
print "the smaller of 3.5 and 2 = $result1\n";&#13;
&#13;
$result2 = which_is_smaller(3, '55');&#13;
print "the smaller of 3 and '55' = $result2\n";&#13;
&#13;
$result3 = which_is_smaller(false, -8);&#13;
print "the smaller of false and -8 = $result3\n";</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-6: Updating the</span> <span class="SANS_Futura_Std_Book_11">main.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">script to demonstrate type juggling</span></p>
<p class="TX">We call <span class="SANS_TheSansMonoCd_W5Regular_11">which_is_smaller()</span> three times and print the results. None of these function calls will trigger an error, since the arguments can all be juggled to integers. First, we call the function with float <span class="SANS_TheSansMonoCd_W5Regular_11">3.5</span> and integer <span class="SANS_TheSansMonoCd_W5Regular_11">2</span>. The float will be juggled to integer <span class="SANS_TheSansMonoCd_W5Regular_11">3</span>. Next, we use integer <span class="SANS_TheSansMonoCd_W5Regular_11">3</span> and string <span class="SANS_TheSansMonoCd_W5Regular_11">'55'</span> as arguments. This time, the string will be converted to integer <span class="SANS_TheSansMonoCd_W5Regular_11">55</span>. Finally, we pass Boolean <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> and integer <span class="SANS_TheSansMonoCd_W5Regular_11">-8</span> as arguments. The <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> will be converted to integer <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>. Here’s the output of running the script:</p>
<pre><code>PHP Deprecated:  Implicit conversion from float 3.5 to int loses precision in&#13;
/Users/matt/my_functions.php on line 2&#13;
&#13;
the smaller of 3.5 and 2 = 2&#13;
the smaller of 3 and '55' = 3&#13;
the smaller of false and -8 = -8</code></pre>
<p class="TX">When you run the script, the first thing you should see printed out is a deprecation message informing you that you’re losing precision when float <span class="SANS_TheSansMonoCd_W5Regular_11">3.5</span> is juggled into integer <span class="SANS_TheSansMonoCd_W5Regular_11">3</span>. This message indicates that at some point in the future (possibly PHP 9), PHP will stop automatically juggling floats with fractional components into integers, so the code will someday stop working and trigger an error. After this message, you should see the results of the three <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> statements, indicating that the three function calls occurred without issue, thanks to PHP’s automatic type juggling.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>When you encounter a deprecation message, reading a discussion about the upcoming change can be informative. For example, the request for comments (RFC) document explaining the deprecation message output from <a href="#lis5-6">Listing 5-6</a> is available online at</i> <span class="note_LinkURL"><a href="https://wiki.php.net/rfc/implicit-float-int-deprecate">https://wiki.php.net/rfc/implicit-float-int-deprecate</a></span><i>.</i></p>
<p class="TX"><span aria-label="90" epub:type="pagebreak" id="pg_90" role="doc-pagebreak"/>These function calls worked despite the incorrect argument data types, but well-written programs should avoid relying on type juggling altogether. Take note of deprecation warnings like the one we just encountered, and look for ways to revise your code to cope with different kinds of values without warnings or errors. In this particular case, we could refactor the function to use union types (discussed in <span class="Xref">“Union Types” on <a href="#pg_98">page 98</a></span>), which would allow both integers and floats as arguments.</p>
</section>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="H1" id="sec8"><span id="toc-link_76"/><span class="SANS_Futura_Std_Bold_B_11">Functions Without Explicit Return Values</span></h3>
<p class="TNI1">Not every function has to explicitly return a value. For example, you could write a function that simply prints out a message without returning anything to the calling script. When a function doesn’t have an explicit return value, declare its return type as <span class="SANS_TheSansMonoCd_W5Regular_11">void</span>.</p>
<p class="TX">To demonstrate, we’ll declare a function that prints out a given number of stars, padded on both sides with another spacer character to achieve a fixed line length. We’ll be able to use the function to create ASCII art, images formed by arranging characters of text. Start a new project and create <i>my_functions.php</i> containing the code shown in <a href="#lis5-7">Listing 5-7</a>.</p>
<span id="lis5-7"/>
<pre><code>&lt;?php&#13;
function print_stars(int $numStars, string $spacer): void&#13;
{&#13;
    $lineLength = 20;&#13;
    $starsString = str_repeat('*', $numStars);&#13;
    $centeredStars = str_pad($starsString, $lineLength, $spacer, STR_PAD_BOTH);&#13;
    print $centeredStars . "\n";&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-7: Declaring the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">print_stars()</span> <span class="SANS_Futura_Std_Book_Oblique_11">function in</span> <span class="SANS_Futura_Std_Book_11">my_functions.php</span></p>
<p class="TX">Here we declare a function named <span class="SANS_TheSansMonoCd_W5Regular_11">print_stars()</span>. The function requires two parameters: <span class="SANS_TheSansMonoCd_W5Regular_11">$numStars</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$spacer</span>. The integer <span class="SANS_TheSansMonoCd_W5Regular_11">$numStars</span> is the number of stars (<span class="SANS_TheSansMonoCd_W5Regular_11">*</span> characters) to be printed out. The string <span class="SANS_TheSansMonoCd_W5Regular_11">$spacer</span> is the character to use as padding on both sides of the stars. After the parentheses, we use <span class="SANS_TheSansMonoCd_W5Regular_11">: void</span> to indicate that this function won’t explicitly return any value.</p>
<p class="TX">Inside the function body, we set the length of the line to be printed to 20 characters. (Since this value is <i>hardcoded</i> into the function, it will be the same each time the function is called; a more flexible alternative could be to set <span class="SANS_TheSansMonoCd_W5Regular_11">$lineLength</span> as a parameter.) Then we generate a string (<span class="SANS_TheSansMonoCd_W5Regular_11">$starsString</span>) containing the number of asterisks specified by the <span class="SANS_TheSansMonoCd_W5Regular_11">$numStars</span> parameter. Next, we use the built-in <span class="SANS_TheSansMonoCd_W5Regular_11">str_pad()</span> function (discussed in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>) to create a string 20 characters long, with <span class="SANS_TheSansMonoCd_W5Regular_11">$starsString</span> centered and padded symmetrically on the left and right with whatever string is in the <span class="SANS_TheSansMonoCd_W5Regular_11">$spacer</span> parameter. If <span class="SANS_TheSansMonoCd_W5Regular_11">$numStars</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">10</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$spacer</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">'.'</span>, for example, this will produce the string <span class="SANS_TheSansMonoCd_W5Regular_11">'.....**********.....'</span>, 10 asterisks with 5 periods on each side, giving a total length of 20. Finally, we print out the result, followed by a newline character.</p>
<p class="TX"><span aria-label="91" epub:type="pagebreak" id="pg_91" role="doc-pagebreak"/>Notice that we haven’t included a <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> statement in the function body. There’s no need, since all the function is doing is constructing and printing a string. If we were to try to return a value from this function, it would trigger a fatal error, since we declared the function as <span class="SANS_TheSansMonoCd_W5Regular_11">void</span>.</p>
<p class="TX">Now let’s use our function to generate an ASCII art image of a tree. Create <i>main.php</i> containing the code shown in <a href="#lis5-8">Listing 5-8</a>.</p>
<span id="lis5-8"/>
<pre><code>&lt;?php&#13;
require_once __DIR__ . '/my_functions.php';&#13;
&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> $spacer = '/';&#13;
print_stars(1, $spacer);&#13;
print_stars(5, $spacer);&#13;
print_stars(9, $spacer);&#13;
print_stars(13, $spacer);&#13;
print_stars(1, $spacer);&#13;
print_stars(1, $spacer);</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-8: A script in</span> <span class="SANS_Futura_Std_Book_11">main.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">to generate a tree shape with the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">print_stars()</span> <span class="SANS_Futura_Std_Book_Oblique_11">function</span></p>
<p class="TX">After reading in the function declaration with <span class="SANS_TheSansMonoCd_W5Regular_11">require_once</span>, we set the spacer character to be a forward slash (<span class="SANS_TheSansMonoCd_W5Regular_11">/</span>) <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Then we call our <span class="SANS_TheSansMonoCd_W5Regular_11">print_stars()</span> function six times, printing a tree shape made up of lines with 1, 5, 9, and 13 stars, plus two more lines with just 1 star for the trunk. Here’s the output of running the <i>main.php</i> script at the terminal:</p>
<pre><code>/////////*//////////&#13;
///////*****////////&#13;
/////*********//////&#13;
///*************////&#13;
/////////*//////////&#13;
/////////*//////////</code></pre>
<p class="BodyContinued">We’ve created a tree during a heavy rainstorm!</p>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="H2" id="sec9"><span id="toc-link_77"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Returning NULL</span></h4>
<p class="TNI1">Even when a function is declared as <span class="SANS_TheSansMonoCd_W5Regular_11">void</span>, it still technically has a return value: <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>. If a function finishes executing without returning a value, the function returns <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> by default. To prove it, let’s try calling our <span class="SANS_TheSansMonoCd_W5Regular_11">print_stars()</span> function again and assigning the result to a variable, as we would with a function that has a return value. Update your <i>main.php</i> file to match <a href="#lis5-9">Listing 5-9</a>. The changes are shown in black text.</p>
<span id="lis5-9"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">require_once __DIR__ . '/my_functions.php';</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$spacer = '/';</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print_stars(1, $spacer);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print_stars(5, $spacer);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print_stars(9, $spacer);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print_stars(13, $spacer);</span>&#13;
<span aria-label="92" epub:type="pagebreak" id="pg_92" role="doc-pagebreak"/><span class="TheSansMonoCd_W5Regular_Grey_11">print_stars(1, $spacer);</span>&#13;
$result = print_stars(1, $spacer);&#13;
&#13;
var_dump($result);</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-9: Updating</span> <span class="SANS_Futura_Std_Book_11">main.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">to store and print the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">print_tree()</span> <span class="SANS_Futura_Std_Book_Oblique_11">function’s</span> <span class="TheSansMonoCd_W5Regular_Italic_11">NULL</span> <span class="SANS_Futura_Std_Book_Oblique_11">return value</span></p>
<p class="TX">We make the same calls to the <span class="SANS_TheSansMonoCd_W5Regular_11">print_stars()</span> function as before, but this time we store the return value of the last function call in the <span class="SANS_TheSansMonoCd_W5Regular_11">$result</span> variable. We then use <span class="SANS_TheSansMonoCd_W5Regular_11">var_dump()</span> to see the contents of <span class="SANS_TheSansMonoCd_W5Regular_11">$result</span>. Since <span class="SANS_TheSansMonoCd_W5Regular_11">print_stars()</span> doesn’t have an explicit return value, <span class="SANS_TheSansMonoCd_W5Regular_11">$result</span> should contain <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>. Here’s the output of running the <i>main.php</i> script:</p>
<pre><code>/////////*//////////&#13;
///////*****////////&#13;
/////*********//////&#13;
///*************////&#13;
/////////*//////////&#13;
/////////*//////////&#13;
NULL</code></pre>
<p class="TX">We can see the ASCII tree again, followed by <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> from the call to <span class="SANS_TheSansMonoCd_W5Regular_11">var_dump()</span>. This confirms that the function has returned <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> by default, despite being declared as <span class="SANS_TheSansMonoCd_W5Regular_11">void</span>.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="H2" id="sec10"><span id="toc-link_78"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Exiting a Function Early</span></h4>
<p class="TNI1">A function declared as <span class="SANS_TheSansMonoCd_W5Regular_11">void</span> can still use a <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> statement, as long as the statement doesn’t include a value. As mentioned earlier, a function stops executing as soon as it encounters a <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> statement, so writing <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> without a value provides a mechanism for exiting a function early. This can be useful, for example, if a problem occurs with one of the function’s parameters. You can add validation logic to check the parameters at the start of the function, and use <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> to halt the function execution and resume the main calling script if one or more argument values aren’t as expected.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">str_pad()</span> function we’ve been using to create centered lines of stars will trigger a fatal error if the padding string is empty. Rather than let that crash our program, let’s update our <span class="SANS_TheSansMonoCd_W5Regular_11">print_stars()</span> function to first check whether the <span class="SANS_TheSansMonoCd_W5Regular_11">$spacer</span> string parameter is empty. If it is, we’ll use <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> to exit the function early. Modify <i>my_functions.php</i> to match <a href="#lis5-10">Listing 5-10</a>.</p>
<span id="lis5-10"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">function print_stars(int $numStars, string $spacer): void</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">{</span>&#13;
<b>    </b>if (empty($spacer)) {&#13;
<b>    </b>    return;&#13;
    }&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    $lineLength = 20;</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    $starsString = str_repeat('*', $numStars);</span>&#13;
&#13;
<span aria-label="93" epub:type="pagebreak" id="pg_93" role="doc-pagebreak"/><span class="TheSansMonoCd_W5Regular_Grey_11">    $centeredStars = str_pad($starsString, $lineLength, $spacer, STR_PAD_BOTH);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    print $centeredStars . "\n";</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">}</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-10: Adding a</span> <span class="TheSansMonoCd_W5Regular_Italic_11">return</span> <span class="SANS_Futura_Std_Book_Oblique_11">statement to exit the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">print_stars()</span> <span class="SANS_Futura_Std_Book_Oblique_11">function early</span></p>
<p class="TX">We add an <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement to the start of the function body, using the built-in <span class="SANS_TheSansMonoCd_W5Regular_11">empty()</span> function to test whether <span class="SANS_TheSansMonoCd_W5Regular_11">$spacer</span> is an empty string. If so, we use <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> without any value to end function execution early and return program control to the calling script. If the function execution gets past this <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement, then we know that <span class="SANS_TheSansMonoCd_W5Regular_11">$spacer</span> isn’t empty, so our call to <span class="SANS_TheSansMonoCd_W5Regular_11">str_pad()</span> should work fine.</p>
<p class="TX">To see whether the <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> statement is working, update the <i>main.php</i> script as shown in <a href="#lis5-11">Listing 5-11</a>.</p>
<span id="lis5-11"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">require_once __DIR__ . '/my_functions.php';</span>&#13;
&#13;
$spacer = '';&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print_stars(1, $spacer);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print_stars(5, $spacer);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print_stars(9, $spacer);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print_stars(13, $spacer);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print_stars(1, $spacer);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$result = print_stars(1, $spacer);</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">var_dump($result);</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-11: Updating</span> <span class="SANS_Futura_Std_Book_11">main.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">to call</span> <span class="TheSansMonoCd_W5Regular_Italic_11">print_tree()</span> <span class="SANS_Futura_Std_Book_Oblique_11">with an empty spacer string</span></p>
<p class="TX">We set <span class="SANS_TheSansMonoCd_W5Regular_11">$spacer</span> to an empty string rather than a slash before making our calls to <span class="SANS_TheSansMonoCd_W5Regular_11">print_stars()</span>. The output of running the main script should now simply be <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">print_stars()</span> function returns early each time it is called because <span class="SANS_TheSansMonoCd_W5Regular_11">$spacer</span> is an empty string, so we no longer see our ASCII tree. Then again, we don’t see a fatal error either, because our <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> statement prevents us from calling <span class="SANS_TheSansMonoCd_W5Regular_11">str_pad()</span> with an invalid argument. We still see <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> in the output, the result of the <span class="SANS_TheSansMonoCd_W5Regular_11">var_dump()</span> call. This indicates that when a function encounters a <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> statement without a value, it returns <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>, just as it would if it didn’t have a <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> statement at all.</p>
</section>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h3 class="H1" id="sec11"><span id="toc-link_79"/><span class="SANS_Futura_Std_Bold_B_11">Calling Functions from Within Functions</span></h3>
<p class="TNI1">It’s perfectly reasonable to call one function from within the body of another function. In fact, we’ve done it several times already, calling built-in PHP functions like <span class="SANS_TheSansMonoCd_W5Regular_11">str_repeat()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">str_pad()</span> inside our <span class="SANS_TheSansMonoCd_W5Regular_11">print_stars()</span> function. It’s also possible, and in fact, quite common, to call your own custom functions from within other custom functions.</p>
<p class="TX">A lot of the power of programming comes from breaking problems into smaller tasks. You write basic functions to tackle those small tasks and then <span aria-label="94" epub:type="pagebreak" id="pg_94" role="doc-pagebreak"/>write higher-level functions that combine the tasks to solve the larger problem. In the end, your main application script looks quite simple: you just call one or two functions. The trick is that those functions themselves call several other functions, and so on.</p>
<p class="TX">It took us six calls to our <span class="SANS_TheSansMonoCd_W5Regular_11">print_stars()</span> function to generate an ASCII tree. Let’s move those six calls into another function, <span class="SANS_TheSansMonoCd_W5Regular_11">print_tree()</span>. That way, every time we want to print a tree, all we need is one function call in our main script. Add the new <span class="SANS_TheSansMonoCd_W5Regular_11">print_tree()</span> function to <i>my_functions.php</i> as shown in <a href="#lis5-12">Listing 5-12</a>.</p>
<span id="lis5-12"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">function print_stars(int $numStars, string $spacer): void</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">{</span>&#13;
<span class="TheSansMonoCd_W5Regular_Italic_11">--snip--</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">}</span>&#13;
&#13;
function print_tree(string $spacer): void&#13;
{&#13;
    print_stars(1, $spacer);&#13;
    print_stars(5, $spacer);&#13;
    print_stars(9, $spacer);&#13;
    print_stars(13, $spacer);&#13;
    print_stars(1, $spacer);&#13;
    print_stars(1, $spacer);&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-12: Adding the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">print_tree()</span> <span class="SANS_Futura_Std_Book_Oblique_11">function to</span> <span class="SANS_Futura_Std_Book_11">my_functions.php</span></p>
<p class="TX">We declare the <span class="SANS_TheSansMonoCd_W5Regular_11">print_tree()</span> function after our previously declared <span class="SANS_TheSansMonoCd_W5Regular_11">print_stars()</span> function. It requires a string parameter called <span class="SANS_TheSansMonoCd_W5Regular_11">$spacer</span>. In the function body, we write our six original calls to <span class="SANS_TheSansMonoCd_W5Regular_11">print_stars()</span>. Notice that <span class="SANS_TheSansMonoCd_W5Regular_11">$spacer</span>, the parameter of the <span class="SANS_TheSansMonoCd_W5Regular_11">print_tree()</span> function, is also acting as an argument when we call <span class="SANS_TheSansMonoCd_W5Regular_11">print_stars()</span>. This way, we can easily print trees with different padding characters around the asterisks just by changing the string we pass in when we call <span class="SANS_TheSansMonoCd_W5Regular_11">print_tree()</span>.</p>
<p class="TX">With this new function, we can now greatly simplify our main script. Update <i>main.php</i> as shown in <a href="#lis5-13">Listing 5-13</a>.</p>
<span id="lis5-13"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">require_once __DIR__ . '/my_functions.php';</span>&#13;
print_tree('/');&#13;
print_tree(' ');</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-13: Simplifying the</span> <span class="SANS_Futura_Std_Book_11">main.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">script with the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">print_tree()</span> <span class="SANS_Futura_Std_Book_Oblique_11">function</span></p>
<p class="TX">After reading in the function declaration file, we call <span class="SANS_TheSansMonoCd_W5Regular_11">print_tree()</span> twice to generate two trees. The first time we use a forward slash as the spacer, as before, and the second time we use a space character. Here’s the result:</p>
<pre><code><span aria-label="95" epub:type="pagebreak" id="pg_95" role="doc-pagebreak"/>/////////*//////////&#13;
///////*****////////&#13;
/////*********//////&#13;
///*************////&#13;
/////////*//////////&#13;
/////////*//////////&#13;
         *&#13;
       *****&#13;
     *********&#13;
   *************&#13;
         *&#13;
         *</code></pre>
<p class="TX">Our main script has accomplished with 2 calls to <span class="SANS_TheSansMonoCd_W5Regular_11">print_tree()</span> what would have previously taken 12 calls to <span class="SANS_TheSansMonoCd_W5Regular_11">print_stars()</span>. Of course, those calls to <span class="SANS_TheSansMonoCd_W5Regular_11">print_stars()</span> are still happening, but we’ve hidden them inside the <span class="SANS_TheSansMonoCd_W5Regular_11">print_tree()</span> definition, making our main script much tidier. You can begin to see the power of functions to organize code and promote reusability.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="H1" id="sec12"><span id="toc-link_80"/><span class="SANS_Futura_Std_Bold_B_11">Functions with Multiple Return and Parameter Types</span></h3>
<p class="TNI1">For straightforward situations, you can usually write a function that does something and returns a value of a single type or that returns no value. Other times, however, you’ll want to make a function more reusable by allowing it to return values of different data types depending on the situation. Likewise, you might want a function’s parameters to accept values of different data types to ensure that your code can cope with input validation issues. <i>Nullable types</i> and <i>union types</i> offer elegant ways to permit multiple types, both for a function’s return value and its parameters.</p>
<section aria-labelledby="sec13" epub:type="division">
<h4 class="H2" id="sec13"><span id="toc-link_81"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Nullable Types</span></h4>
<p class="TNI1">It’s quite common to write functions that normally return one kind of value, such as a string or a number, but that sometimes return <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> instead. For example, a function that typically performs a calculation might return <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> if it receives invalid inputs, or a function that retrieves information from a database might return <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> if it’s unable to establish a database connection (we’ll see this in <span class="Xref"><a href="part6.xhtml">Part VI</a></span> when we discuss databases). To allow for this, declare the function’s return type to be <i>nullable</i> by adding a question mark (<span class="SANS_TheSansMonoCd_W5Regular_11">?</span>) immediately before the return type. For instance, placing <span class="SANS_TheSansMonoCd_W5Regular_11">: ?int</span> at the end of the first line of a function declaration means that the function will return either <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> or an integer.</p>
<p class="TX">Let’s see this in action with a function that attempts to return the integer value of a spelled-out number (such as <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> instead of <span class="SANS_TheSansMonoCd_W5Regular_11">'one'</span>). If the function doesn’t recognize the input string, it will return <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> instead. Start a new project and create <i>my_functions.php</i> containing the contents of <a href="#lis5-14">Listing 5-14</a>.</p>
<span id="lis5-14"/>
<pre><code><span aria-label="96" epub:type="pagebreak" id="pg_96" role="doc-pagebreak"/>&lt;?php&#13;
function string_to_int(string $numberString): <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> ?int&#13;
{&#13;
    return match ($numberString) {&#13;
        'one' =&gt; 1,&#13;
        'two' =&gt; 2,&#13;
        'three' =&gt; 3,&#13;
        'four' =&gt; 4,&#13;
        'five' =&gt; 5,&#13;
      <span aria-label="annotation2" class="Code_CodeAnnotation">❷</span> default =&gt; NULL&#13;
    };&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-14: A function that returns an integer or</span> <span class="TheSansMonoCd_W5Regular_Italic_11">NULL</span></p>
<p class="TX">We declare the <span class="SANS_TheSansMonoCd_W5Regular_11">string_to_int()</span> function, using the nullable type <span class="SANS_TheSansMonoCd_W5Regular_11">?int</span> to indicate that the function will return either <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> or an integer <span aria-label="annotation1" class="CodeAnnotation">❶</span>. The function takes in the string parameter <span class="SANS_TheSansMonoCd_W5Regular_11">$numberString</span>. Its body is a single <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> statement that chooses a value to return by using a <span class="SANS_TheSansMonoCd_W5Regular_11">match</span> expression. This is possible because <span class="SANS_TheSansMonoCd_W5Regular_11">match</span> expressions evaluate to a single value. The expression has five clauses matching the strings <span class="SANS_TheSansMonoCd_W5Regular_11">'one'</span> through <span class="SANS_TheSansMonoCd_W5Regular_11">'five'</span> to the corresponding integer. A sixth clause sets the <span class="SANS_TheSansMonoCd_W5Regular_11">default</span> case <span aria-label="annotation2" class="CodeAnnotation">❷</span>, returning <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> if any other string is provided. In this way, the <span class="SANS_TheSansMonoCd_W5Regular_11">match</span> expression returns an integer or <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>, just as the function’s nullable return type indicates.</p>
<p class="TX">Now we’ll write a <i>main.php</i> file with a script that calls our function. When you call a function with a nullable return type, it’s important to test the return value, in case it’s <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>. <a href="#lis5-15">Listing 5-15</a> shows how.</p>
<span id="lis5-15"/>
<pre><code>&lt;?php&#13;
require_once __DIR__ . '/my_functions.php';&#13;
&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> $text1 = 'three';&#13;
$number1 = string_to_int($text1);&#13;
<span aria-label="annotation2" class="codeannotated_CodeAnnotation">❷</span> if (is_null($number1)) {&#13;
    print "sorry, could not convert '$text1' to an integer\n";&#13;
} else {&#13;
    print "'$text1' as an integer = $number1\n";&#13;
}&#13;
&#13;
$text2 = 'onee';&#13;
$number2 = string_to_int($text2);&#13;
if (is_null($number2)) {&#13;
    print "sorry, could not convert '$text2' to an integer\n";&#13;
} else {&#13;
    print "'$text2' as an integer = $number2\n";&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-15: A</span> <span class="SANS_Futura_Std_Book_11">main.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">script calling the nullable-type</span> <span class="TheSansMonoCd_W5Regular_Italic_11">string_to_int()</span> <span class="SANS_Futura_Std_Book_Oblique_11">function</span></p>
<p class="TX">We assign string <span class="SANS_TheSansMonoCd_W5Regular_11">'three'</span> as the value of the <span class="SANS_TheSansMonoCd_W5Regular_11">$text1</span> variable, then pass that variable to our <span class="SANS_TheSansMonoCd_W5Regular_11">string_to_int()</span> function, storing the return value in <span class="SANS_TheSansMonoCd_W5Regular_11">$number1</span> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Next, we use an <span class="SANS_TheSansMonoCd_W5Regular_11">if...else</span> statement to test whether the value in <span class="SANS_TheSansMonoCd_W5Regular_11">$number1</span> is empty (<span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>) <span aria-label="annotation2" class="CodeAnnotation">❷</span>. If so, we print a message stating that the string <span aria-label="97" epub:type="pagebreak" id="pg_97" role="doc-pagebreak"/>couldn’t be converted to an integer. Otherwise, we print a message showing the string and its corresponding integer. We then repeat the process with string <span class="SANS_TheSansMonoCd_W5Regular_11">'onee'</span>. Here’s the output:</p>
<pre><code>'three' as an integer = 3&#13;
sorry, could not convert 'onee' to an integer</code></pre>
<p class="TX">We can see that the function returns the integer <span class="SANS_TheSansMonoCd_W5Regular_11">3</span> when the argument is the string <span class="SANS_TheSansMonoCd_W5Regular_11">'three'</span>, but it returns <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> when the argument is the misspelled string <span class="SANS_TheSansMonoCd_W5Regular_11">'onee'</span>. Declaring our <span class="SANS_TheSansMonoCd_W5Regular_11">string_to_int()</span> function with a nullable return type gives us the flexibility to respond to this problematic input in a meaningful way.</p>
<p class="TX">Just as functions can have nullable return types, you can use the same question mark syntax to declare function parameters as nullable, meaning the parameter can be <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> or some other type. For example, the parameter list <span class="SANS_TheSansMonoCd_W5Regular_11">(?string $name)</span> means that a function accepts a <span class="SANS_TheSansMonoCd_W5Regular_11">$name</span> parameter that is either <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> or a string.</p>
<p class="TX">Rather than having to duplicate the <span class="SANS_TheSansMonoCd_W5Regular_11">if...else</span> statement in our <i>main.php</i> script each time we call our <span class="SANS_TheSansMonoCd_W5Regular_11">string_to_int()</span> function, as we did in <a href="#lis5-15">Listing 5-15</a>, we might take the function’s <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> or integer return value and pass it as an argument to another function to generate an appropriate message. That function therefore needs to be able to accept a parameter that may be <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> or an integer. <a href="#lis5-16">Listing 5-16</a> shows such a function named <span class="SANS_TheSansMonoCd_W5Regular_11">int_to_message()</span>. Add the function to the end of your <i>my_functions.php</i> file<i>.</i></p>
<span id="lis5-16"/>
<pre><code>function int_to_message(?int $number): string&#13;
{&#13;
    if (is_null($number)) {&#13;
        return "sorry, could not convert string to an integer\n";&#13;
    } else {&#13;
        return "an integer = $number\n";&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-16: A function with a nullable type for the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">$number</span> <span class="SANS_Futura_Std_Book_Oblique_11">parameter</span></p>
<p class="TX">The signature for this function includes a single parameter called <span class="SANS_TheSansMonoCd_W5Regular_11">$number</span> of nullable type <span class="SANS_TheSansMonoCd_W5Regular_11">?int</span>. This means that the argument provided to the function can be either <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> or an integer. The function body uses the <span class="SANS_TheSansMonoCd_W5Regular_11">if...else</span> statement we had in our <i>main.php</i> script to return an appropriate message depending on which data type is passed in.</p>
<p class="TX">We can now greatly simplify our main script by removing the duplicated <span class="SANS_TheSansMonoCd_W5Regular_11">if...else</span> statements and calling our new function instead. <a href="#lis5-17">Listing 5-17</a> shows the updated script.</p>
<span id="lis5-17"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">require_once __DIR__ . '/my_functions.php';</span>&#13;
&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> <span class="TheSansMonoCd_W5Regular_Grey_11">$text1 = 'three';</span>&#13;
<span aria-label="annotation2" class="codeannotated_CodeAnnotation">❷</span> <span class="TheSansMonoCd_W5Regular_Grey_11">$number1 = string_to_int($text1);</span>&#13;
<span aria-label="annotation3" class="codeannotated_CodeAnnotation">❸</span> print int_to_message($number1);&#13;
&#13;
<span aria-label="98" epub:type="pagebreak" id="pg_98" role="doc-pagebreak"/><span class="TheSansMonoCd_W5Regular_Grey_11">$text2 = 'onee';</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$number2 = string_to_int($text2);</span>&#13;
print int_to_message($number2);&#13;
&#13;
<span aria-label="annotation4" class="codeannotated_CodeAnnotation">❹</span> print int_to_message(string_to_int('four'));</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-17: Simplifying</span> <span class="SANS_Futura_Std_Book_11">main.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">with the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">int_to_message()</span> <span class="SANS_Futura_Std_Book_Oblique_11">function</span></p>
<p class="TX">Notice that our main script is much simpler now that the logic for generating the message has been moved to a function. For each input, we follow a pattern of three basic statements: declaring a string <span aria-label="annotation1" class="CodeAnnotation">❶</span>, storing the integer (or <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>) returned from calling <span class="SANS_TheSansMonoCd_W5Regular_11">string_to_int()</span> with that string <span aria-label="annotation2" class="CodeAnnotation">❷</span>, and printing the string returned by passing this integer or <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> value to the <span class="SANS_TheSansMonoCd_W5Regular_11">int_to_message()</span> function <span aria-label="annotation3" class="CodeAnnotation">❸</span>.</p>
<p class="TX">If we really want to make our code even more succinct, we can put all three of those statements into a single line <span aria-label="annotation4" class="CodeAnnotation">❹</span>, calling the <span class="SANS_TheSansMonoCd_W5Regular_11">string_to_int()</span>function inside the parentheses when we call the <span class="SANS_TheSansMonoCd_W5Regular_11">int_to_message()</span> function. This way, the former’s return value is passed directly as an argument to the latter, without the need for an intermediary variable. This choice is a matter of programming style. Personally, I prefer to use intermediate variables to prevent a single line of code from becoming too complex.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h4 class="H2" id="sec14"><span id="toc-link_82"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Union Types</span></h4>
<p class="TNI1">If you want a function to be able to return a range of data types, declare its return value by using a <i>union type</i>. This is a list of the value’s possible data types, separated by vertical bars. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">int|float</span> indicates that a value could be an integer or a float. Union types can apply to function parameters as well as return values.</p>
<p class="TX">Nullable types are essentially a special category of union types, and their question mark syntax provides a convenient shorthand when one of the possible data types is <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>. The union type <span class="SANS_TheSansMonoCd_W5Regular_11">string|NULL</span> is the same as the more concise nullable type <span class="SANS_TheSansMonoCd_W5Regular_11">?string</span>, for example. Union types are most useful when your code has multiple non-<span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> types, like <span class="SANS_TheSansMonoCd_W5Regular_11">int|float</span>, or when there are multiple non-<span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> types plus <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>, like <span class="SANS_TheSansMonoCd_W5Regular_11">string|int|NULL</span>, indicating the data type could be a string, an integer, or <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>. This couldn’t be expressed with nullable-type syntax, since you can’t mix a nullable type with others in a union by writing something like <span class="SANS_TheSansMonoCd_W5Regular_11">?string|int</span>. You also can’t include <span class="SANS_TheSansMonoCd_W5Regular_11">void</span> as one of the types in the union.</p>
<p class="TX">To demonstrate union types, let’s modify our <span class="SANS_TheSansMonoCd_W5Regular_11">string_to_int()</span> function into a <span class="SANS_TheSansMonoCd_W5Regular_11">string_to_number()</span> function that can return an integer, a float, or <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>, depending on the string passed in. We’ll also update our <span class="SANS_TheSansMonoCd_W5Regular_11">int_to_message()</span> function into a <span class="SANS_TheSansMonoCd_W5Regular_11">number_to_message()</span> function that can take in an integer, a float, or <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> as a parameter. Update <i>my_functions.php</i> to match <a href="#lis5-18">Listing 5-18</a>.</p>
<span id="lis5-18"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">function</span> string_to_number<span class="TheSansMonoCd_W5Regular_Grey_11">(string $numberString):</span><b> </b><span aria-label="annotation1" class="Code_CodeAnnotation">❶</span><b> </b>int|float|NULL&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">{</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    return match ($numberString) {</span>&#13;
    <b>  </b><span aria-label="annotation2" class="Code_CodeAnnotation">❷</span><b> </b>'half' =&gt; 0.5,&#13;
<span aria-label="99" epub:type="pagebreak" id="pg_99" role="doc-pagebreak"/><span class="TheSansMonoCd_W5Regular_Grey_11">        'one' =&gt; 1,</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        'two' =&gt; 2,</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        'three' =&gt; 3,</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        'four' =&gt; 4,</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        'five' =&gt; 5,</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        default =&gt; NULL</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    };</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">}</span>&#13;
&#13;
function number_to_message(string $text, <span aria-label="annotation3" class="Code_CodeAnnotation">❸</span> int|float|NULL $number): string&#13;
{&#13;
<b>  </b><span aria-label="annotation4" class="Code_CodeAnnotation">❹</span><b> </b>if (is_int($number)) {&#13;
        return "'$text' as an integer = $number\n";&#13;
    }&#13;
&#13;
<b>  </b><span aria-label="annotation5" class="Code_CodeAnnotation">❺</span><b> </b>if (is_float($number)) {&#13;
        return "'$text' as a float = $number\n";&#13;
    }&#13;
&#13;
  <span aria-label="annotation6" class="Code_CodeAnnotation">❻</span> return "sorry, could not convert '$text' to a number\n";&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-18: Using union types as function return values and parameters</span></p>
<p class="TX">First, we declare <span class="SANS_TheSansMonoCd_W5Regular_11">string_to_number()</span>, a revised version of our <span class="SANS_TheSansMonoCd_W5Regular_11">string_to_int()</span> function. We use the union type <span class="SANS_TheSansMonoCd_W5Regular_11">int|float|null</span> to indicate that the function will return an integer, a float, or <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Just like <span class="SANS_TheSansMonoCd_W5Regular_11">string_to_int()</span> previously, this function takes in a single string parameter. We add a new clause to the <span class="SANS_TheSansMonoCd_W5Regular_11">match</span> statement in the function body, matching the string <span class="SANS_TheSansMonoCd_W5Regular_11">'half'</span> to the float value <span class="SANS_TheSansMonoCd_W5Regular_11">0.5</span> <span aria-label="annotation2" class="CodeAnnotation">❷</span>, hence the need for the union type.</p>
<p class="TX">Next, we declare <span class="SANS_TheSansMonoCd_W5Regular_11">number_to_message()</span>, a revised version of <span class="SANS_TheSansMonoCd_W5Regular_11">int_to_message()</span> that returns a string. This function takes in two parameters. The first, the string <span class="SANS_TheSansMonoCd_W5Regular_11">$text</span>, will be the same as the string passed to our <span class="SANS_TheSansMonoCd_W5Regular_11">string_to_number()</span> function. The second, <span class="SANS_TheSansMonoCd_W5Regular_11">$number</span>, will be that function’s return value, and so it might be an integer, a float, or <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>. We therefore use the same <span class="SANS_TheSansMonoCd_W5Regular_11">int|float|NULL</span> union type for the parameter <span aria-label="annotation3" class="CodeAnnotation">❸</span>.</p>
<p class="TX">In the function body, we first test whether <span class="SANS_TheSansMonoCd_W5Regular_11">$number</span> contains an integer value <span aria-label="annotation4" class="CodeAnnotation">❹</span>, in which case we return a message stating that <span class="SANS_TheSansMonoCd_W5Regular_11">$text</span> is an integer. Next, we test whether <span class="SANS_TheSansMonoCd_W5Regular_11">$number</span> contains a float value <span aria-label="annotation5" class="CodeAnnotation">❺</span>, returning an appropriate message if it does. Finally, we return a message stating that <span class="SANS_TheSansMonoCd_W5Regular_11">$text</span> couldn’t be converted to a number <span aria-label="annotation6" class="CodeAnnotation">❻</span>. Execution wouldn’t get this far if either of the previous <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> statements was executed, so we know at this point that <span class="SANS_TheSansMonoCd_W5Regular_11">$number</span> is neither an integer nor a float. We therefore don’t need to place this final <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> statement inside an <span class="SANS_TheSansMonoCd_W5Regular_11">else</span> clause or another <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement, although we could.</p>
<p class="TX">This choice is a matter of personal programming style. I like to end functions like this with an unconditional <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> statement, so I can clearly see the default to be returned. However, some programmers prefer to end the last <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement with an <span class="SANS_TheSansMonoCd_W5Regular_11">else</span> clause as a way to communicate the default. The execution is the same either way.</p>
<p class="TX"><span aria-label="100" epub:type="pagebreak" id="pg_100" role="doc-pagebreak"/>Now let’s test our functions. Update your <i>main.php</i> script to match <a href="#lis5-19">Listing 5-19</a>.</p>
<span id="lis5-19"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">require_once __DIR__ . '/my_functions.php';</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$text1 = 'three';</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$number1 = string_to_number($text1);</span>&#13;
print number_to_message($text1, $number1);</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-19: Calling functions with union type parameters and return values in</span> <span class="SANS_Futura_Std_Book_11">main.php</span></p>
<p class="TX">We call our <span class="SANS_TheSansMonoCd_W5Regular_11">string_to_number()</span> function, passing in the string <span class="SANS_TheSansMonoCd_W5Regular_11">'three'</span>, and store the result in the <span class="SANS_TheSansMonoCd_W5Regular_11">$number1</span> variable. Then we pass <span class="SANS_TheSansMonoCd_W5Regular_11">$number1</span> along to our <span class="SANS_TheSansMonoCd_W5Regular_11">number_to_message()</span> function and print the message that it returns. This code should output the message <span class="SANS_TheSansMonoCd_W5Regular_11">'three' as an integer = 3</span>.</p>
</section>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h3 class="H1" id="sec15"><span id="toc-link_83"/><span class="SANS_Futura_Std_Bold_B_11">Optional Parameters</span></h3>
<p class="TNI1">If the value of a parameter will usually be the same each time you call a function, you can set a default value for that parameter when you declare the function. In effect, this makes the parameter optional. You’ll need to include an argument corresponding to that parameter only when you know you’ll want the value to be something other than the default.</p>
<p class="TX">Many of PHP’s built-in functions have optional parameters with default values. For example, PHP’s <span class="SANS_TheSansMonoCd_W5Regular_11">number_format()</span> function, which takes in a float and converts it into a string, has several optional parameters controlling how the string will be formatted. Enter <span class="TheSansMonoCd_W7Bold_11-1">php -a</span> at the command line to try out the following code in interactive mode:</p>
<pre><code><span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> php &gt; <b>print number_format(1.2345);</b>&#13;
1&#13;
<span aria-label="annotation2" class="codeannotated_CodeAnnotation">❷</span> php &gt; <b>print number_format(1.2345, 2);</b>&#13;
1.23&#13;
<span aria-label="annotation3" class="codeannotated_CodeAnnotation">❸</span> php &gt; <b>print number_format(1.2345, 1, ',');</b>&#13;
1,2</code></pre>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">number_format()</span> function’s first parameter is not optional; it’s the float that we want to format. By default, calling the function with just one argument <span aria-label="annotation1" class="CodeAnnotation">❶</span> returns a string version of the number with the decimal portion removed. When we add an integer as an optional second argument <span aria-label="annotation2" class="CodeAnnotation">❷</span>, the function uses that integer to set the number of decimal places to include. We’ve used the value <span class="SANS_TheSansMonoCd_W5Regular_11">2</span> to preserve two decimal places. By default, the decimal separator is represented with a period, but if we add a string as an optional third argument <span aria-label="annotation3" class="CodeAnnotation">❸</span>, the function will use that string as the decimal separator instead. In this case, we’re using a comma, a common decimal separator in continental Europe.</p>
<p class="TX"><span aria-label="101" epub:type="pagebreak" id="pg_101" role="doc-pagebreak"/><a href="#lis5-20">Listing 5-20</a> shows the signature for the <span class="SANS_TheSansMonoCd_W5Regular_11">number_format()</span> function, taken from the PHP online documentation, to illustrate how the default values for the parameters are declared.</p>
<span id="lis5-20"/>
<pre><code>number_format(&#13;
    float $num,&#13;
    int $decimals = 0,&#13;
    ?string $decimal_separator = ".",&#13;
    ?string $thousands_separator = ","&#13;
): string</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-20: The built-in</span> <span class="TheSansMonoCd_W5Regular_Italic_11">number_format()</span> <span class="SANS_Futura_Std_Book_Oblique_11">function, including optional parameters with default values</span></p>
<p class="TX">First, notice that when you have a long list of parameters, you can spread them over several lines to make the code more readable. The function takes up to four parameters, but the second, third, and fourth all have default values assigned with the assignment operator (<span class="SANS_TheSansMonoCd_W5Regular_11">=</span>) after the parameter name. For example, the second parameter, <span class="SANS_TheSansMonoCd_W5Regular_11">$decimals</span>, has a default value of <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, so when we call <span class="SANS_TheSansMonoCd_W5Regular_11">number_format(1.2345)</span> without providing a second argument, the function executes with the default value for <span class="SANS_TheSansMonoCd_W5Regular_11">$decimals</span> and formats the number to include zero decimal places. Likewise, the <span class="SANS_TheSansMonoCd_W5Regular_11">$decimal_separator</span> parameter has a period as its default value, and the <span class="SANS_TheSansMonoCd_W5Regular_11">$thousands_separator</span> parameter has a comma.</p>
<p class="TX">The order in which the parameters are declared is important. All mandatory parameters (those without default values) must be listed first, followed by the optional parameters. This is because the order of arguments when you call a function must match the order of the parameters. If you had an optional parameter followed by a mandatory one, and you omitted the optional parameter, there’d be no way to know that your first argument was meant to correspond to the second parameter. The only exception to this rule is if you use named arguments, as we’ll discuss later in the chapter.</p>
<p class="TX">Now that we’ve seen how optional parameters work, let’s add one to a custom function. We’ll revisit our <span class="SANS_TheSansMonoCd_W5Regular_11">which_is_smaller()</span> function from earlier in the chapter and add an optional parameter controlling how the function behaves if the values passed in for comparison are the same. Return to the <i>my_functions.php</i> file for that project and update the script to match <a href="#lis5-21">Listing 5-21</a>.</p>
<span id="lis5-21"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">function which_is_smaller(int $n1, int $n2,</span> <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> bool $nullIfSame = false): ?int&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">{</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    if ($n1 &lt; $n2) {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        return $n1;</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    }</span>&#13;
&#13;
    if ($n2 &lt; $n1) {&#13;
        return $n2;&#13;
    }&#13;
&#13;
<span aria-label="102" epub:type="pagebreak" id="pg_102" role="doc-pagebreak"/>  <span aria-label="annotation2" class="Code_CodeAnnotation">❷</span> if ($nullIfSame) {&#13;
        return NULL;&#13;
    }&#13;
&#13;
  <span aria-label="annotation3" class="Code_CodeAnnotation">❸</span> return $n1;&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">}</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-21: Updating the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">which_is_smaller()</span> <span class="SANS_Futura_Std_Book_Oblique_11">function to include an optional parameter</span></p>
<p class="TX">We add a third parameter to our function, the Boolean <span class="SANS_TheSansMonoCd_W5Regular_11">$nullIfSame</span>, and give it a default value of <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Thanks to this default value, the function will typically return <span class="SANS_TheSansMonoCd_W5Regular_11">$n1</span> if <span class="SANS_TheSansMonoCd_W5Regular_11">$n1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$n2</span> are found to be the same <span aria-label="annotation3" class="CodeAnnotation">❸</span>. However, if the user overrides this default by passing <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> as the third argument when calling the function, <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> is returned instead <span aria-label="annotation2" class="CodeAnnotation">❷</span>. To account for this possibility, we use the nullable type <span class="SANS_TheSansMonoCd_W5Regular_11">?int</span> to set the function’s return type.</p>
<p class="TX">The sequence of <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> statements matters here. The code will get to <span class="SANS_TheSansMonoCd_W5Regular_11">if ($nullIfSame)</span> <span aria-label="annotation2" class="CodeAnnotation">❷</span> only if <span class="SANS_TheSansMonoCd_W5Regular_11">$n1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$n2</span> are equal. Since <span class="SANS_TheSansMonoCd_W5Regular_11">$nullIfSame</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> by default, this condition will typically fail, so the final <span class="SANS_TheSansMonoCd_W5Regular_11">return $n1;</span> will execute <span aria-label="annotation3" class="CodeAnnotation">❸</span>. It’s only if the user has set <span class="SANS_TheSansMonoCd_W5Regular_11">$nullIfSame</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> that the function returns <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>.</p>
<p class="TX">Update the project’s <i>main.php</i> file as shown in <a href="#lis5-22">Listing 5-22</a> to test the function.</p>
<span id="lis5-22"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">require_once __DIR__ . '/my_functions.php';</span>&#13;
&#13;
$result1 = which_is_smaller(1, 1);&#13;
var_dump($result1);&#13;
$result2 = which_is_smaller(1, 1, true);&#13;
var_dump($result2);</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-22: Calling</span> <span class="TheSansMonoCd_W5Regular_Italic_11">which_is_smaller()</span> <span class="SANS_Futura_Std_Book_Oblique_11">from</span> <span class="SANS_Futura_Std_Book_11">main.php</span><span class="SANS_Futura_Std_Book_Oblique_11">, with and without the optional parameter</span></p>
<p class="TX">We call out <span class="SANS_TheSansMonoCd_W5Regular_11">which_is_smaller()</span> twice, using <span class="SANS_TheSansMonoCd_W5Regular_11">var_dump()</span> to show the results. The first time we pass in <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> and leave out the optional argument, so <span class="SANS_TheSansMonoCd_W5Regular_11">$nullIfSame</span> will be <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> by default. The second time, we add <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> as a third argument, overriding the default. Here’s the output of running the main script:</p>
<pre><code>int(1)&#13;
NULL</code></pre>
<p class="TX">The first line indicates that the function followed the default behavior of returning <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> (the value of the first argument) when we omitted the optional argument. When we used the third argument to set <span class="SANS_TheSansMonoCd_W5Regular_11">$nullIfSame</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>, however, the function returned <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>.</p>
<section aria-labelledby="sec16" epub:type="division">
<h4 class="H2" id="sec16"><span id="toc-link_84"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Positional vs. Named Arguments</span></h4>
<p class="TNI1">When you call a function, the PHP engine by default interprets the arguments <i>positionally</i>, matching them to the function’s parameters based on <span aria-label="103" epub:type="pagebreak" id="pg_103" role="doc-pagebreak"/>their order. However, you can also call a function by using <i>named arguments</i>: you explicitly pair an argument’s value with the name of the corresponding parameter. In this case, the order of arguments no longer matters. Named arguments are especially useful when a function has optional parameters.</p>
<p class="TX">To use named rather than positional arguments, you don’t have to change the function declaration in any way, although it becomes even more important to have meaningful parameter names. Instead, all you have to do is include the parameter name (minus the dollar sign) inside the parentheses when you call a function, followed by a colon (<span class="SANS_TheSansMonoCd_W5Regular_11">:</span>) and the desired argument value. For example, to use a named argument to pass <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> as the value of the <span class="SANS_TheSansMonoCd_W5Regular_11">$nullIfSame</span> parameter when calling our <span class="SANS_TheSansMonoCd_W5Regular_11">which_is_smaller()</span> function, you would include <span class="SANS_TheSansMonoCd_W5Regular_11">nullIfSame: true</span> in the argument list. The convention is to add a space after the colon.</p>
<p class="TX"><a href="#lis5-23">Listing 5-23</a> shows an updated <i>main.php</i> file, adding an extra call to <span class="SANS_TheSansMonoCd_W5Regular_11">which_is_smaller()</span> using named arguments.</p>
<span id="lis5-23"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">require_once __DIR__ . '/my_functions.php';</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$result1 = which_is_smaller(1, 1);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">var_dump($result1);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$result2 = which_is_smaller(1, 1, true);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">var_dump($result2);</span>&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> $result3 = which_is_smaller(nullIfSame: true, n1: 1, n2: 1);&#13;
var_dump($result3);</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-23: Calling</span> <span class="TheSansMonoCd_W5Regular_Italic_11">which_is_smaller()</span> <span class="SANS_Futura_Std_Book_Oblique_11">by using positional and named arguments</span></p>
<p class="TX">The new call to <span class="SANS_TheSansMonoCd_W5Regular_11">which_is_smaller()</span> <span aria-label="annotation1" class="CodeAnnotation">❶</span> is functionally equivalent to the previous call, but we use named arguments. As such, we’re able to list the arguments in a different order from the way the parameters were declared: first <span class="SANS_TheSansMonoCd_W5Regular_11">$nullIfSame</span>, then <span class="SANS_TheSansMonoCd_W5Regular_11">$n1</span>, then <span class="SANS_TheSansMonoCd_W5Regular_11">$n2</span>. Here’s the result:</p>
<pre><code>int(1)&#13;
NULL&#13;
NULL</code></pre>
<p class="BodyContinued">The last two lines of output are both <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>, indicating the last two function calls achieved the same result using positional and named arguments.</p>
<p class="TX">In this example, each function call used all positional or all named arguments, but you can also mix both styles of arguments in the same function call. In that case, the positional arguments must come first, in the same sequence as the function declaration, followed by the named arguments in whatever sequence you wish. Consider this example:</p>
<pre><code>$result = which_is_smaller(5, nullIfSame: true, n2: 5);</code></pre>
<p class="TX">Here the first argument, <span class="SANS_TheSansMonoCd_W5Regular_11">5</span>, doesn’t have a name. PHP will therefore treat it positionally and match it to the first parameter declared, which is <span class="SANS_TheSansMonoCd_W5Regular_11">$n1</span>. <span aria-label="104" epub:type="pagebreak" id="pg_104" role="doc-pagebreak"/>The remaining arguments are named and so can appear in any order. By contrast, here’s another call to the function:</p>
<pre><code>$result = which_is_smaller(nullIfSame: true, 5, n2: 5);</code></pre>
<p class="TX">This time we’ve started with a named argument for <span class="SANS_TheSansMonoCd_W5Regular_11">$nullIfSame</span>. Then we have an unnamed argument, <span class="SANS_TheSansMonoCd_W5Regular_11">5</span>, presumably intended for the <span class="SANS_TheSansMonoCd_W5Regular_11">$n1</span> parameter. The PHP engine will have no way of knowing this, however, since we started with a named argument, and so this function call will trigger an error.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h4 class="H2" id="sec17"><span id="toc-link_85"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Skipped Parameters</span></h4>
<p class="TNI1">When a function has multiple optional parameters, you can use named arguments to set just the optional parameters that you want while skipping the rest. This works because the named arguments free you from adhering to the order of the parameters. Any parameters you skip will take on their default values. To illustrate, let’s create a function that prints customizable greetings. Start a new project and create <i>my_functions.php</i> to match <a href="#lis5-24">Listing 5-24</a>.</p>
<span id="lis5-24"/>
<pre><code>&lt;?php&#13;
function greet(&#13;
    string $name,&#13;
    string $greeting = 'Good morning',&#13;
    bool $hasPhD = false&#13;
): void&#13;
{&#13;
    if ($hasPhD) {&#13;
      <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> print "$greeting, Dr. $name\n";&#13;
    } else {&#13;
        print "$greeting, $name\n";&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-24: A</span> <span class="TheSansMonoCd_W5Regular_Italic_11">greet()</span> <span class="SANS_Futura_Std_Book_Oblique_11">function with two optional parameters</span></p>
<p class="TX">We declare the <span class="SANS_TheSansMonoCd_W5Regular_11">greet()</span> function as <span class="SANS_TheSansMonoCd_W5Regular_11">void</span>, since it prints out a message without returning a value. The function has a required string parameter <span class="SANS_TheSansMonoCd_W5Regular_11">$name</span>, as well as two optional parameters with default values, <span class="SANS_TheSansMonoCd_W5Regular_11">$greeting</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$hasPhD</span>. The body of the function is an <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement that outputs the values of <span class="SANS_TheSansMonoCd_W5Regular_11">$greeting</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$name</span>, inserting the title <span class="SANS_TheSansMonoCd_W5Regular_11">Dr.</span> in between if parameter <span class="SANS_TheSansMonoCd_W5Regular_11">$hasPhD</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> <span aria-label="annotation1" class="CodeAnnotation">❶</span>.</p>
<p class="TX">Now we’ll look at a few ways to call the <span class="SANS_TheSansMonoCd_W5Regular_11">greet()</span> function. Create <i>main.php</i> containing the code shown in <a href="#lis5-25">Listing 5-25</a>.</p>
<span id="lis5-25"/>
<pre><code>&lt;?php&#13;
require_once __DIR__ . '/my_functions.php';&#13;
&#13;
greet('Matt');&#13;
greet('Matt', hasPhD: true);</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-25: A main script calling</span> <span class="TheSansMonoCd_W5Regular_Italic_11">greet()</span> <span class="SANS_Futura_Std_Book_Oblique_11">with skipped parameters</span></p>
<p class="TX"><span aria-label="105" epub:type="pagebreak" id="pg_105" role="doc-pagebreak"/>The first time we call <span class="SANS_TheSansMonoCd_W5Regular_11">greet()</span>, we pass just the string <span class="SANS_TheSansMonoCd_W5Regular_11">'Matt'</span> as an argument. We don’t use named arguments, so this will be matched positionally to the <span class="SANS_TheSansMonoCd_W5Regular_11">$name</span> parameter. The other parameters will use their default values, resulting in the message <span class="SANS_TheSansMonoCd_W5Regular_11">Good morning, Matt</span>.</p>
<p class="TX">The second time we call <span class="SANS_TheSansMonoCd_W5Regular_11">greet()</span>, we use the positional argument <span class="SANS_TheSansMonoCd_W5Regular_11">'Matt'</span> and the named argument <span class="SANS_TheSansMonoCd_W5Regular_11">hasPhD: true</span>. Notice that <span class="SANS_TheSansMonoCd_W5Regular_11">$hasPhD</span> is the third parameter in the function declaration; we’ve skipped over the second parameter! This is perfectly fine. The parameter we skipped, <span class="SANS_TheSansMonoCd_W5Regular_11">$message</span>, has a default value, and thanks to our use of a named argument, the PHP engine will know unambiguously which provided arguments match which function parameters. We should get the message <span class="SANS_TheSansMonoCd_W5Regular_11">Good morning, Dr. Matt</span> as a result.</p>
<p class="TX">Here’s the output of running the <i>main.php</i> script:</p>
<pre><code>Good morning, Matt&#13;
Good morning, Dr. Matt</code></pre>
<p class="BodyContinued">The output is just as we expect. Thanks to the combination of default parameter values and named arguments, we are able to skip the <span class="SANS_TheSansMonoCd_W5Regular_11">$message</span> parameter without issue.</p>
</section>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h3 class="H1" id="sec18"><span id="toc-link_86"/><span class="SANS_Futura_Std_Bold_B_11">Pass-by-Value vs. Pass-by-Reference</span></h3>
<p class="TNI1">By default, PHP functions match arguments to parameters by using a <i>pass-by-value</i> approach: the values of the arguments are copied and assigned (passed) to the appropriate parameters, which are created as temporary variables limited to the scope of the function. In this way, if the values of any parameters are manipulated while the function is executing, those changes will have no effect on any values outside the function itself. After all, the function is working with copies of the original values.</p>
<p class="TX">Another approach is <i>pass-by-reference</i>: instead of receiving copies, the function parameters are passed references to the original variables themselves. In this way, if a variable is passed as an argument to a function, the function can permanently change the value of that variable. To indicate a pass-by-reference parameter, place an ampersand (<span class="SANS_TheSansMonoCd_W5Regular_11">&amp;</span>) immediately before the parameter name when you’re declaring the function.</p>
<p class="TX">I don’t typically recommend using pass-by-reference parameters; in fact, I can’t think of a single one I’ve written in the last 20 years. Allowing functions to change the variables passed to them makes programs more complex and therefore harder to understand, test, and debug. Still, it’s important to be familiar with the concept, since you might encounter pass-by-reference parameters in other people’s code, including in third-party libraries you might want to use for your own projects. Calling a function with pass-by-reference parameters without knowing how they work could lead to unintended results.</p>
<span aria-label="106" epub:type="pagebreak" id="pg_106" role="doc-pagebreak"/>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>In some programming languages, programmers use several pass-by-reference parameters as a way for a function to “return” multiple values without the need for</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">return</span> <i>statements. There are better ways to do this in modern PHP, however, such as returning an array (see <a href="chapter7.xhtml">Chapter 7</a>) or an object (see <a href="part5.xhtml">Part V</a>).</i></p>
<p class="TX">To illustrate the difference between pass-by-value and pass-by-reference parameters, and to show why the latter are often best avoided, we’ll create two versions of a function that calculates someone’s future age. Start a new project and create <i>my_functions.php</i> with the contents of <a href="#lis5-26">Listing 5-26</a>.</p>
<span id="lis5-26"/>
<pre><code>&lt;?php&#13;
function future_age (int $age): void&#13;
{&#13;
    $age = $age + 1;&#13;
    print "You will be $age years old on your next birthday.\n";&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-26: A pass-by-value version of</span> <span class="TheSansMonoCd_W5Regular_Italic_11">future_age()</span></p>
<p class="TX">Here we declare a function named <span class="SANS_TheSansMonoCd_W5Regular_11">future_age()</span>. It features an integer parameter <span class="SANS_TheSansMonoCd_W5Regular_11">$age</span> declared in the usual way, so this will be a normal pass-by-value parameter. The function is declared <span class="SANS_TheSansMonoCd_W5Regular_11">void</span> since no value is to be returned. In the body of the function, we add <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">$age</span> and print out a message containing the result.</p>
<p class="TX">Now create a main script in <i>main.php</i> containing the code shown in <a href="#lis5-27">Listing 5-27</a>.</p>
<span id="lis5-27"/>
<pre><code>&lt;?php&#13;
require_once __DIR__ . '/my_functions.php';&#13;
&#13;
$currentAge = 20;&#13;
print "You are $currentAge years old.\n";&#13;
future_age($currentAge);&#13;
print "You are $currentAge years old.\n";</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-27: Testing the pass-by-value version of</span> <span class="TheSansMonoCd_W5Regular_Italic_11">future_age()</span></p>
<p class="TX">We assign the <span class="SANS_TheSansMonoCd_W5Regular_11">$currentAge</span> variable an integer value of <span class="SANS_TheSansMonoCd_W5Regular_11">20</span>. Then we print out a message showing the value of this variable. Next, we call our <span class="SANS_TheSansMonoCd_W5Regular_11">future_age()</span> function, passing <span class="SANS_TheSansMonoCd_W5Regular_11">$currentAge</span> as an argument. We then print out another message showing the value of the variable. This gives us a look at the value of <span class="SANS_TheSansMonoCd_W5Regular_11">$currentAge</span> before and after the function call. Here’s the result:</p>
<pre><code>You are 20 years old.&#13;
You will be 21 years old on your next birthday.&#13;
You are 20 years old.</code></pre>
<p class="TX">The first and last lines of output are the same, indicating that calling <span class="SANS_TheSansMonoCd_W5Regular_11">future_age()</span> has no effect on the value of the <span class="SANS_TheSansMonoCd_W5Regular_11">$currentAge</span> variable. In fact, when the function is called, a local variable <span class="SANS_TheSansMonoCd_W5Regular_11">$age</span> is created within the scope of the function, and the value of <span class="SANS_TheSansMonoCd_W5Regular_11">$currentAge</span> is copied into it. This way, <span aria-label="107" epub:type="pagebreak" id="pg_107" role="doc-pagebreak"/>when the function adds <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">$age</span>, it does so without changing the value of <span class="SANS_TheSansMonoCd_W5Regular_11">$currentAge</span>. That’s how pass-by-value parameters work: they don’t have any influence outside the scope of the function itself.</p>
<p class="TX">Now let’s modify our <span class="SANS_TheSansMonoCd_W5Regular_11">future_age()</span> function to use a pass-by-reference parameter and see what difference that makes. Update your <i>my_functions.php</i> file as shown in <a href="#lis5-28">Listing 5-28</a>.</p>
<span id="lis5-28"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">function future_age (</span>int &amp;$age<span class="TheSansMonoCd_W5Regular_Grey_11">): void</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">{</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    $age = $age + 1;</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    print "You will be $age years old on your next birthday.\n";</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">}</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 5-28: A pass-by-reference version of</span> <span class="TheSansMonoCd_W5Regular_Italic_11">future_age()</span></p>
<p class="TX">The only change here is adding an ampersand (<span class="SANS_TheSansMonoCd_W5Regular_11">&amp;</span>) before the parameter name, indicating <span class="SANS_TheSansMonoCd_W5Regular_11">$age</span> is a pass-by-reference parameter. As a result, <span class="SANS_TheSansMonoCd_W5Regular_11">$age</span> will no longer be a local variable containing a copy of the value in the variable passed as an argument when the function is called. Rather, <span class="SANS_TheSansMonoCd_W5Regular_11">$age</span> will be a reference to that variable, so any changes made to <span class="SANS_TheSansMonoCd_W5Regular_11">$age</span> will also be made to that variable. To prove it, run your <i>main.php</i> script again. This time you should see the following output:</p>
<pre><code>You are 20 years old.&#13;
You will be 21 years old on your next birthday.&#13;
You are 21 years old.</code></pre>
<p class="TX">Notice that adding <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> to the <span class="SANS_TheSansMonoCd_W5Regular_11">$age</span> parameter within the function also adds <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> to the <span class="SANS_TheSansMonoCd_W5Regular_11">$currentAge</span> variable outside the function. Unless the user’s birthday occurred in the instant between the function call and the final <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> statement, this probably isn’t what we want. This illustrates the danger of using pass-by-reference parameters: they can change the value of variables that are normally outside the scope of a function.</p>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h3 class="H1" id="sec19"><span id="toc-link_87"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>
<p class="TNI1">In this chapter, we’ve explored how to promote code reusability by declaring and calling functions, named sequences of code that accomplish a particular task. You practiced declaring functions in a separate.p<i>hp</i> file and then loading them into your main application file with <span class="SANS_TheSansMonoCd_W5Regular_11">require_once</span>, allowing you to write concise, well-organized scripts. You saw how <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> statements allow functions to send values back to the calling script while also providing a mechanism to terminate a function early, and you explored how nullable and union types give functions the flexibility to take in or output values of various data types.</p>
<p class="TX">You learned about the difference between parameters (the variables used within a function) and arguments (the values passed to those variables when you call a function). You saw how to make parameters optional <span aria-label="108" epub:type="pagebreak" id="pg_108" role="doc-pagebreak"/>by giving them a default value, and how to use named arguments to pass in values in any order or even skip parameters. Finally, you learned about the difference between pass-by-value and pass-by-reference parameters, in the rare event you want a function to be able to update variables outside its own scope.</p>
</section>
<section aria-labelledby="sec20" epub:type="division">
<h3 class="H1" id="sec20"><span id="toc-link_88"/><span class="SANS_Futura_Std_Bold_B_11">Exercises</span></h3>
<p class="ListNumber">1.   Create a project with separate <i>main.php</i> and <i>file2.php</i> scripts. The <i>file2.php</i> script should print out the string <span class="SANS_TheSansMonoCd_W5Regular_11">'456'</span>. In your <i>main.php</i> script, first print out <span class="SANS_TheSansMonoCd_W5Regular_11">'123'</span>, then read in and execute <i>file2.php</i>, then print out <span class="SANS_TheSansMonoCd_W5Regular_11">'789'</span>. The overall output should be <span class="SANS_TheSansMonoCd_W5Regular_11">123456789</span>, but the middle <span class="SANS_TheSansMonoCd_W5Regular_11">456</span> has been printed from <i>file2.php</i>.</p>
<p class="ListNumber">2.   Write a project declaring a <span class="SANS_TheSansMonoCd_W5Regular_11">which_is_larger()</span> function that returns the larger of two integers. Your <i>main.php</i> script should read in and execute the file declaring your function, and then print out the results of calling the function with the following arguments:</p>
<p class="ListPlainSub"><span class="SANS_TheSansMonoCd_W5Regular_11">4</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">5</span></p>
<p class="ListPlainSub"><span class="SANS_TheSansMonoCd_W5Regular_11">21</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">19</span></p>
<p class="ListPlainSub"><span class="SANS_TheSansMonoCd_W5Regular_11">3</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">3</span></p>
<p class="ListBody1">What happens in the last case, where the parameters are the same?</p>
<p class="ListNumber">3.   Modify your <span class="SANS_TheSansMonoCd_W5Regular_11">which_is_larger()</span> function to accept either integers or floats, and to return an integer, a float, or <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> if both numbers are the same.</p>
<p class="ListNumber">4.   Create a file <i>my_functions.php</i> that declares a <span class="SANS_TheSansMonoCd_W5Regular_11">void</span> function to print out the first letter of your name in ASCII art style. This function should have two parameters, one (<span class="SANS_TheSansMonoCd_W5Regular_11">$character</span>) a string setting the character to use for making the art, and the second (<span class="SANS_TheSansMonoCd_W5Regular_11">$spacer</span>) a string setting the character to fill in the gaps. Assign suitable default values to each parameter. For example, since the first character of my name is <span class="SANS_TheSansMonoCd_W5Regular_11">M</span>, my function might be <span class="SANS_TheSansMonoCd_W5Regular_11">capital_m(string $character = 'M', string $spacer = ' ')</span>, and it might provide the following output when called with no arguments:</p>
<pre><code>MM          MM&#13;
MMMM      MMMM&#13;
MM MMM  MMM MM&#13;
MM   MMMM   MM&#13;
MM          MM&#13;
MM          MM&#13;
MM          MM</code></pre>
<p class="ListBody">Next, write a <i>main.php</i> script to call your function with no arguments (using both default values). Then use named arguments to call the function two more times, once providing just the main character, and then providing just the spacer character.</p>
</section>
</section>
</div></body></html>