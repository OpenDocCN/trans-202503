- en: Chapter 12. Computation Expressions
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 6](ch06.html "Chapter 6. Going to Collections"), we looked at how
    sequence expressions simplify creating sequences. In [Chapter 10](ch10.html "Chapter 10. Show
    Me the Data"), we saw how query expressions provide a unified approach to querying
    data from disparate data sources. Similarly, in [Chapter 11](ch11.html "Chapter 11. Asynchronous
    and Parallel Programming"), we explored how asynchronous workflows can be employed
    to simplify creating and executing asynchronous operations. Each of these constructs
    serves a very different purpose, but what they all have in common is that they’re
    examples of another F# language feature: the computation expression.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '*Computation expressions*, sometimes referred to as *workflows*, provide a
    convenient construct for expressing a series of operations where data flow and
    side effects are controlled. In that regard, computation expressions are similar
    to what other functional languages refer to as *monads*. Where computation expressions
    differ, though, is that they’re designed in such a way that individual expressions
    look like a natural part of the language.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Within the context of a computation expression, you can repurpose several familiar
    language elements—such as the `let` and `use` keywords, and `for` loops—to unify
    the syntax with the language. Computation expressions also provide an alternative
    “bang” syntax for some of these elements, allowing you to nest computation expressions
    for inline evaluation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: This feature’s generalized nature means that computation expressions can simplify
    working with complex types and are applicable to a variety of situations. For
    instance, we already know that the built-in computation expressions streamline
    sequence creation, querying, and asynchronous processing, but they also have applications
    in logging and in projects such as the {m}brace framework that aim to simplify
    offloading computations to the cloud.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore the inner workings of computation expressions.
    We’ll forego discussing monadic theory because it doesn’t really help you understand
    how computation expressions can fit into your solutions. Instead, we’ll begin
    with a look at builder classes and how they enable computation expressions. With
    that foundation established, we’ll then walk through two examples of custom computation
    expressions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a Computation Expression
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’re already familiar with the basic pattern for writing computation expressions,
    but until now, you haven’t seen how they work beyond a brief glimpse behind the
    scenes when we created some additional query operators in [Extending Query Expressions](ch10.html#extending_query_expressions
    "Extending Query Expressions"). To reiterate for the more general case, computation
    expressions take the following form:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Computation expressions are designed around an underlying *computation type*
    (sometimes called a *monadic type*) that we compute by transparently invoking
    methods exposed by a *builder class*. In the preceding syntax, *builder-name*
    represents a concrete instance of a builder class, and *computation-expression-body*
    represents the series of nested expressions that map to the method calls necessary
    to produce an instance of the computation type. For example, asynchronous workflows
    are based on `Async<'T>` and built via `AsyncBuilder`. Similarly, query expressions
    are based on `QuerySource<'T, 'Q>` and built via `QueryBuilder`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Sequence expressions are an anomaly in the realm of computation expressions
    in that they don’t follow the normal implementation pattern. Although sequence
    expressions use the computation expression syntax and are based on `IEnumerable<''T>`,
    they don’t have a corresponding builder class. Instead, the details that would
    normally be handled by the builder class are handled directly by the F# compiler.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Builder classes define the operations supported by a computation expression.
    Defining a builder class is largely a matter of convention, as there are no specific
    interfaces to implement or base classes to inherit. There aren’t any steadfast
    rules for naming builder classes, but you typically do so by appending `Builder`
    to the underlying type name (for example, `AsyncBuilder` and `QueryBuilder`).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Although computation expressions are part of the language, they are really just
    syntactic sugar—a more convenient way to call into the builder class’s methods.
    When the compiler encounters what appears to be a computation expression, it attempts
    to convert the code to a series of method calls through a process called *desugaring*.
    This process involves replacing each operation in the computation expression with
    a call to a corresponding instance method on the builder type (similar to how
    LINQ query expressions are translated to extension method calls and delegates
    in C# and Visual Basic). I like to think of the builder class methods as belonging
    to either of two groups. The first group, listed in [Table 12-1](ch12.html#control_methods_for_syntactic_elements
    "Table 12-1. Control Methods for Syntactic Elements"), controls various syntactic
    elements such as bindings, `for` and `while` loops, and return values.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-1. Control Methods for Syntactic Elements
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description | Signature |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| `Bind` | Enables `let!` and `do!` bindings | `M<''T> * (''T -> M<''U>) ->
    M<''U>` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| `For` | Enables `for` loops | `seq<''T> * (''T -> M<''U>) -> M<''U>`or`seq<''T>
    * (''T -> M<''U>) -> seq<M<''U>>` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| `Return` | Enables `return` | `''T -> M<''T>` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: '| `ReturnFrom` | Enables `return!` | `M<''T> -> M<''T>` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: '| `TryFinally` | Allows exception handling through `try...finally` | `M<''T>
    * (unit -> unit) -> M<''T>` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: '| `TryWith` | Allows exception handling through `try...with` | `M<''T> * (exn
    -> M<''T>) -> M<''T>` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: '| `Using` | Enables creating `IDisposable` objects with `use` and `use!` |
    `''T * (''T -> M<''U>) -> M<''U>`when`''U :> IDisposable` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `Using` | 使得可以使用 `use` 和 `use!` 创建 `IDisposable` 对象 | `''T * (''T -> M<''U>)
    -> M<''U>`当`''U :> IDisposable`时 |'
- en: '| `While` | Allows you to use `while...do` loops within a computation expression
    | `(unit -> bool) * M<''T> -> M<''T>` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `While` | 允许在计算表达式中使用 `while...do` 循环 | `(unit -> bool) * M<''T> -> M<''T>`
    |'
- en: '| `Yield` | Returns items from a nested computation expression using a sequence-like
    approach with the `yield` keyword | `''T -> M<''T>` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `Yield` | 使用 `yield` 关键字，以类似序列的方式从嵌套的计算表达式中返回项 | `''T -> M<''T>` |'
- en: '| `YieldFrom` | Returns items from a nested computation expression using a
    sequence-like approach with the `yield!` keyword | `M<''T> -> M<''T>` |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `YieldFrom` | 使用 `yield!` 关键字，以类似序列的方式从嵌套的计算表达式中返回项 | `M<''T> -> M<''T>`
    |'
- en: The second group of methods, those that control how computation expressions
    are evaluated, is listed in [Table 12-2](ch12.html#methods_affecting_computation_expression
    "Table 12-2. Methods Affecting Computation Expression Evaluation").
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组方法，控制计算表达式如何被评估的方法，列在[表12-2](ch12.html#methods_affecting_computation_expression
    "Table 12-2. 影响计算表达式评估的方法")中。
- en: Table 12-2. Methods Affecting Computation Expression Evaluation
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 表12-2. 影响计算表达式评估的方法
- en: '| Method | Description | Signature |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 | 签名 |'
- en: '| --- | --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Combine` | Merges two parts of a computation expression into one | `M<''T>
    * M<''T> -> M<''T>`or`M<unit> * M<''T> -> M<''T>` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `Combine` | 将计算表达式的两个部分合并成一个 | `M<''T> * M<''T> -> M<''T>`或`M<unit> * M<''T>
    -> M<''T>` |'
- en: '| `Delay` | Wraps a computation expression in a function for deferred execution,
    thereby helping prevent unintended side effects | `(unit -> M<''T>) -> M<''T>`
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `Delay` | 将计算表达式包装成一个函数，以便延迟执行，从而帮助防止不必要的副作用 | `(unit -> M<''T>) -> M<''T>`
    |'
- en: '| `Run` | Executed as the last step in evaluating a computation expression;
    can “undo” a delay by invoking the function returned by `Delay` and can also transform
    the result into a more consumable format | `M<''T> -> M<''T>`or`M<''T> -> ''T`
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `Run` | 在评估计算表达式时作为最后一步执行；可以通过调用 `Delay` 返回的函数来“撤销”延迟，也可以将结果转换为更易消费的格式 |
    `M<''T> -> M<''T>`或`M<''T> -> ''T` |'
- en: '| `Zero` | Returns a default value for the expression’s monadic type; used
    when a computation expression doesn’t explicitly return a value | `unit -> M<''T>`(`''T`
    can be `unit`) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `Zero` | 返回表达式的单子类型的默认值；当计算表达式没有显式返回值时使用 | `unit -> M<''T>`（`''T` 可以是 `unit`）
    |'
- en: Because computation expressions are intended to be designed in such a way that
    they apply to a variety of situations, it’s important to keep them as generic
    as possible. This is reflected in the highly generalized structure of the signatures.
    For instance, the notation `M<_>` is used to indicate that the underlying type
    wraps another value.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计算表达式的设计目的是使其能够适用于各种情况，因此保持它们尽可能通用非常重要。这一点通过签名的高度通用结构得以体现。例如，`M<_>`的符号表示底层类型封装了另一个值。
- en: 'It is not necessary to implement each method listed in [Table 12-1](ch12.html#control_methods_for_syntactic_elements
    "Table 12-1. Control Methods for Syntactic Elements") in your builder classes.
    Should you omit any of those methods, though, the corresponding mapped syntax
    will not be available within the computation expression and the compiler will
    produce an error. For example, if you try to include a `use` binding within a
    custom computation expression but omit the `Using` method from the builder class,
    compilation will fail with the message:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的构建器类中并不需要实现[表12-1](ch12.html#control_methods_for_syntactic_elements "Table
    12-1. 语法元素的控制方法")中列出的每个方法。然而，如果你省略了某些方法，相应的映射语法将无法在计算表达式中使用，编译器会报错。例如，如果你尝试在自定义计算表达式中包含
    `use` 绑定，但省略了构建器类中的 `Using` 方法，编译将失败，并显示如下错误信息：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Likewise, it is not always necessary to implement each method from [Table 12-2](ch12.html#methods_affecting_computation_expression
    "Table 12-2. Methods Affecting Computation Expression Evaluation"), but failure
    to do so in some situations can lead to undesirable results. For instance, not
    implementing the `Delay` method will prevent you from composing expressions that
    yield multiple results. Furthermore, when your computation expression involves
    side effects, not implementing the `Delay` method can invoke the side effects
    prematurely—regardless of where they appear within the expression—because they
    are evaluated immediately when they’re encountered instead of wrapped up in a
    function for deferred execution.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，并非每个方法都需要从[表12-2](ch12.html#methods_affecting_computation_expression "表12-2。影响计算表达式评估的方法")实现，但在某些情况下未实现某些方法可能会导致不希望出现的结果。例如，未实现
    `Delay` 方法将阻止你组合返回多个结果的表达式。此外，当计算表达式涉及副作用时，未实现 `Delay` 方法可能会过早引发副作用——无论它们出现在表达式的何处——因为它们会在遇到时立即被评估，而不是被包装在一个函数中以便延迟执行。
- en: Computation expressions can be difficult to understand when discussed in abstract
    terms focused on the builder classes and method calls. I think it’s far more helpful
    to walk through some simple implementations to see how the pieces work together.
    We’ll spend the remainder of the chapter discussing two examples. In particular,
    we’ll look at the builder implementations, their corresponding expression syntax,
    and the desugaring process.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们仅仅讨论构建器类和方法调用时，计算表达式可能很难理解。我认为，走过一些简单的实现示例，看看这些组件如何协同工作，更加有帮助。本章剩余的部分我们将讨论两个示例。特别是，我们将查看构建器实现、它们对应的表达式语法以及去糖过程。
- en: 'Example: FizzBuzz'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：FizzBuzz
- en: In [Chapter 7](ch07.html "Chapter 7. Patterns, Patterns, Everywhere"), we looked
    at a few ways to solve the FizzBuzz problem by iterating over a sequence using
    `Seq.map` and using pattern-matching functions with active patterns and partial
    active patterns to identify which value should be printed. At its core, however,
    the FizzBuzz problem is essentially just an exercise in sequence transformation.
    As such, the problem can easily be solved with a computation expression.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。模式，处处是模式")中，我们研究了几种通过使用`Seq.map`迭代序列以及使用带有活动模式和部分活动模式的模式匹配函数来解决
    FizzBuzz 问题的方法。然而，FizzBuzz 问题的核心本质上只是一个序列转换的练习。因此，使用计算表达式可以轻松解决该问题。
- en: When implemented as a computation expression, our FizzBuzz sequence can be constructed
    in a manner such that it looks and behaves like a standard sequence expression.
    With the computation expression, though, mapping a number to the corresponding
    string will be completely abstracted away within the builder class.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为计算表达式实现时，我们的 FizzBuzz 序列可以以一种方式构建，使其看起来和行为像一个标准的序列表达式。然而，使用计算表达式时，将数字映射到相应的字符串将完全抽象化，隐藏在构建器类中。
- en: Because FizzBuzz transforms integers to strings and carries no intrinsic state,
    we’ll forego creating an intermediary wrapper type and jump right into creating
    the builder class incrementally, beginning with the `Yield` method.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 FizzBuzz 将整数转换为字符串并且不包含内在状态，我们将跳过创建中介包装类型，直接从创建构建器类开始，逐步实现，首先从 `Yield` 方法开始。
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we have a rudimentary builder class, we can create the instance that
    we’ll use for every FizzBuzz computation expression, like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个基础的构建器类，我们可以创建实例，并在每次 FizzBuzz 计算表达式中使用它，像这样：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That’s it! There’s nothing fancy here; we just create an instance of the class
    via its primary constructor. To use the instance as a computation expression,
    we can write something such as the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！没有什么花哨的地方；我们只是通过它的主构造函数创建了类的一个实例。为了将该实例用作计算表达式，我们可以编写如下内容：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, evaluating the preceding expression doesn’t give us quite the
    result we’re looking for. Instead of returning a sequence of strings, it gives
    us only a single string, because so far the builder class doesn’t know how to
    create a sequence; it simply yields a string based on an integer value. You can
    see this a bit more clearly in the desugared form, which resembles this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，评估前面的表达式并没有给我们预期的结果。它并没有返回一个字符串序列，而是只返回了一个单一的字符串，因为到目前为止，构建器类还不知道如何创建序列；它只是基于整数值返回一个字符串。你可以在去糖后的形式中更清楚地看到这一点，它大致如下：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To get a sequence of strings, we could make `Yield` return a singleton sequence
    (a sequence containing only a single item), but doing so would complicate implementing
    other methods, such as `For` and `While`. Instead, we’ll extend the builder class
    to include the `Delay` method as follows (be sure to re-create the builder instance
    after updating the builder class to ensure that the `fizzbuzz` expressions are
    evaluated using the latest definitions):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得一个字符串序列，我们可以让`Yield`返回一个单例序列（只包含一个项目的序列），但这样做会使实现其他方法（如`For`和`While`）变得复杂。相反，我们将扩展构建器类，包含`Delay`方法，如下所示（确保在更新构建器类后重新创建构建器实例，以确保使用最新定义来评估`fizzbuzz`表达式）：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Evaluating the previous `fizzbuzz` expression with the `Delay` method in place
    gives us a slightly more desirable result:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Delay`方法到位的情况下，评估之前的`fizzbuzz`表达式会得到一个稍微更理想的结果：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Again, the desugared expression can help clarify what’s happening. With the
    inclusion of the `Delay` method, the desugared form now looks like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，去糖化后的表达式可以帮助澄清发生了什么。通过包含`Delay`方法，去糖化后的形式现在如下所示：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As it stands now, though, all we’ll ever get from a `fizzbuzz` expression is
    a singleton sequence because we can’t yield multiple values. In fact, trying to
    do so as follows will result in a compiler error indicating that the builder class
    must define a `Combine` method:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如今，来自`fizzbuzz`表达式的所有结果都只是一个单例序列，因为我们无法生成多个值。实际上，试图按照以下方式生成多个值将导致编译器错误，指示构建器类必须定义一个`Combine`方法：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To make the preceding snippet work, we’ll provide two overloaded implementations
    of the `Combine` method. The reason for overloading the methods is that, depending
    on their position within the expression, we’ll either be combining individual
    strings into a sequence or appending a new string to an existing sequence. We
    want to be careful that we don’t create a sequence containing a sequence, so we’ll
    also need to overload the existing `Delay` method to simply return a supplied
    sequence. We can implement each of these methods as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使前面的代码片段能够正常工作，我们将提供两个重载版本的`Combine`方法。重载方法的原因是，根据表达式中的位置，我们可能是将单个字符串组合成一个序列，或者是将一个新的字符串附加到现有的序列中。我们需要小心，避免创建包含序列的序列，因此我们还需要重载现有的`Delay`方法，使其简单地返回一个提供的序列。我们可以按如下方式实现这些方法：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now evaluating the preceding `fizzbuzz` expression will result in a sequence
    containing three strings:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，评估前面的`fizzbuzz`表达式将得到一个包含三个字符串的序列：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When yielding multiple results like this, the desugaring process produces a
    much more complicated chain of method calls. For instance, desugaring the preceding
    expression that yields three items results in code that resembles this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当像这样生成多个结果时，去糖化过程会产生一个更复杂的链式方法调用。例如，去糖化前面的表达式（生成三个项）会得到类似下面的代码：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Yielding instances one at a time as we’ve been doing isn’t a very effective
    way to build a sequence of any length. It would be much nicer if we could compose
    a `fizzbuzz` expression using a `for` loop. For this we need to implement the
    `For` method. The approach we’ll take is to simply wrap a call to `Seq.map`, as
    shown here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性生成一个实例的方式（我们一直在使用的这种方式）并不是构建任意长度序列的高效方法。如果我们能够通过一个`for`循环来组合一个`fizzbuzz`表达式，那就会更好。为此，我们需要实现`For`方法。我们采取的方法是简单地包装一次对`Seq.map`的调用，如下所示：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now it’s trivial to generate FizzBuzz sequences because instead of using multiple
    `yield` expressions, we can nest a single `yield` expression within a `for` loop,
    like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在生成FizzBuzz序列变得非常简单，因为我们可以将一个单独的`yield`表达式嵌套在`for`循环中，而不是使用多个`yield`表达式，像这样：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Part of the beauty of implementing the `Yield`, `Delay`, `Combine`, and `For`
    methods in the builder class is that we can combine the styles for more flexible
    expressions. For instance, we can yield values directly before yielding them from
    a loop:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建器类中实现`Yield`、`Delay`、`Combine`和`For`方法的一个优点是，我们可以将这些风格组合起来，从而实现更灵活的表达式。例如，我们可以直接在循环中生成值，然后再将它们输出：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As it’s currently written, the builder class doesn’t support every way you could
    combine the various expressions, but you shouldn’t have trouble adding the appropriate
    overloads to support many more scenarios.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如目前所写，构建器类并不支持你可以组合各种表达式的每一种方式，但你不应该在添加适当的重载以支持更多场景时遇到问题。
- en: 'For your convenience, here’s the builder class in its entirety:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，这里是完整的构建器类：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Example: Building Strings'
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：构建字符串
- en: 'FizzBuzz does a nice job showing how you can use computation expressions to
    create your own sequence-like constructs with the `For` and `Yield` methods, but
    it’s not particularly practical for everyday computing. For a more useful example,
    we turn to a common programming task: combining strings.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'It has long been established that constructing strings using a `StringBuilder`
    is usually more efficient than concatenation. `StringBuilder`’s fluent interface
    keeps the code fairly clean, as shown in the following snippet:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Creating a `StringBuider` instance and chaining calls to the various `Append`
    methods doesn’t really fit into the functional-first paradigm, however. The `Printf`
    module tries to address this disconnect through the `bprintf` function, which
    formats a string and appends it to a `StringBuilder` instance as shown here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'All `bprintf` really accomplishes, though, is replacing an instance method
    call with a call to a function that accepts a `StringBuilder` as an argument.
    What’s more, you still have to manage the `StringBuilder` instance and pass it
    to each `bprintf` call. With a computation expression, not only can you make string
    construction look like a natural part of the F# language, you can also abstract
    away the `StringBuilder`! The computation expression we’ll define shortly will
    allow us to compose strings using the following syntax:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we chain together a number of strings by yielding them within a `buildstring`
    expression. To make this magic happen, we first need to define the underlying
    type for the expression. For convenience we’ll use a discriminated union called
    `StringFragment` to track all of the strings as we yield them. The `StringFragment`
    type is defined as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `StringFragment` union has three cases, `Empty`①, `Fragment` ②, and `Concat`
    ③. The `Empty` case represents empty strings, while the `String` case contains
    a single string. The final case, `Concat`, forms a hierarchy of `StringFragment`
    instances that will eventually be joined together through the `ToString` method.
    The beauty of this type is that once the builder is in place, you never have to
    manually manage these instances or the `StringBuilder`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: The builder class, which we’ll call `StringFragmentBuilder`, is similar to the
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '`FizzBuzzBuilder`, but instead of creating sequences it creates `StringFragment`s.
    We already know based on the earlier syntax that we’ll be using the `yield` keyword,
    so we’ll need to provide a `Yield` method. To yield multiple items, we’ll need
    to implement the `Combine` and `Delay` methods as well. It would be nice to allow
    nested expressions, too, so we’ll implement a `YieldFrom` method. Here is the
    `StringFragmentBuilder` class in its entirety along with the instance used with
    `buildString` expressions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `StringFragmentBuilder` class is considerably simpler than `FizzBuzzSequenceBuilder`
    because it’s concerned only with mapping strings to `StringFragments` and controlling
    execution. Let’s look at each method individually to understand how it’s used
    within the context of the computation expression.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringFragmentBuilder`类比`FizzBuzzSequenceBuilder`简单得多，因为它仅关注将字符串映射到`StringFragments`并控制执行。我们逐一查看每个方法，以了解它们在计算表达式中的使用方式。'
- en: The first method, `Zero`, returns a default value for the expression. In this
    case, we return `Empty` to indicate an empty string. During the desugaring process,
    a call to `Zero` will be inserted automatically in scenarios such as the expression
    returning `unit`, or a nested `if` expression not including an `else` branch.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法`Zero`为表达式返回一个默认值。在这种情况下，我们返回`Empty`表示一个空字符串。在去糖化过程中，当表达式返回`unit`或嵌套的`if`表达式不包括`else`分支时，会自动插入对`Zero`的调用。
- en: The `Yield` method enables the `yield` keyword within the `buildstring` expression.
    In this implementation, `Yield` accepts a string, which it wraps in a new `Fragment`
    instance.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Yield`方法在`buildstring`表达式中启用了`yield`关键字。在这个实现中，`Yield`接受一个字符串，并将其包装在一个新的`Fragment`实例中。'
- en: The `YieldFrom` method allows you to evaluate a nested `buildstring` expression
    through the `yield!` keyword. This method is similar to `Yield`, but instead of
    returning a new `StringFragment`, it returns the one created by the nested expression.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`YieldFrom`方法允许你通过`yield!`关键字求值一个嵌套的`buildstring`表达式。这个方法类似于`Yield`，但它返回的是嵌套表达式创建的`StringFragment`，而不是返回一个新的`StringFragment`。'
- en: Each `yield` or `yield!` in the computation expression represents the end of
    a portion of the expression, so we need a way to merge them all together. For
    that we turn to the `Combine` method, which essentially treats the remainder of
    the expression as a continuation. `Combine` takes two `StringFragments` and wraps
    them each within a `Concat` instance.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`yield`或`yield!`在计算表达式中代表着表达式的一部分结束，因此我们需要一种方法将它们合并在一起。为此，我们使用`Combine`方法，它本质上将表达式的其余部分视为一个延续。`Combine`接受两个`StringFragments`，并将它们各自包装在一个`Concat`实例中。
- en: Combine, Exposed
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Combine，暴露
- en: 'I think it’s easier to understand the `Combine` method’s role by looking at
    the desugared form. Say you’re writing a `buildstring` expression that combines
    `"A"` and `"B"` into a single string like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为通过查看去糖化的形式，更容易理解`Combine`方法的作用。假设你正在编写一个`buildstring`表达式，将`"A"`和`"B"`合并为一个字符串，如下所示：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The corresponding desugared form of this expression would look very much like
    this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 该表达式的相应去糖化形式将非常类似于此：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For clarity, I simplified the desugared form to just the parts essential for
    understanding the process. Here, the first call to `Yield` returns `Fragment("A")`
    and the second returns `Fragment("B")`. The `Combine` method takes both of these
    and produces the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清晰地理解，我将去糖化的形式简化为仅包含理解过程所需的部分。这里，第一个`Yield`调用返回`Fragment("A")`，第二个返回`Fragment("B")`。`Combine`方法接受这两者并生成以下内容：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`Combine` is called for every yield after the first. If our hypothetical example
    were extended to also yield `"C"`, then the desugared form would then resemble
    this simplified code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Combine`会在第一个`yield`之后为每个`yield`调用。如果我们的假设示例扩展到也`yield` `"C"`，那么去糖化后的形式将类似于以下简化代码：'
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The resulting `StringFragment` should then be:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的`StringFragment`应为：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next method in the `StringFragmentBuilder` class, `Delay`, controls when
    the computation expression is evaluated. When a computation expression has multiple
    parts, the compiler requires you to define `Delay` to avoid prematurely evaluating
    expressions that contain side effects and control execution as expressions are
    combined. Many of the method calls are wrapped in a function that’s passed to
    `Delay`, so that those portions of the expression won’t be evaluated until `Delay`
    is invoked. More specifically, the entire expression is wrapped in one `Delay`
    call, as are the calls that compute the second argument to each `Combine` call.
    The desugared form looks a bit like this (simplified for clarity):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringFragmentBuilder`类中的下一个方法`Delay`控制计算表达式何时被求值。当一个计算表达式有多个部分时，编译器要求你定义`Delay`以避免过早求值包含副作用的表达式，并在表达式组合时控制执行。许多方法调用被包装在传递给`Delay`的函数中，这样这些表达式部分直到调用`Delay`时才会被求值。更具体地说，整个表达式被包装在一个`Delay`调用中，每个`Combine`调用的第二个参数计算也被如此包装。去糖化后的形式大致如下（为清晰起见简化）：'
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Finally, the `For` method allows us to use `for` loops within a `buildstring`
    expression. Unlike the FizzBuzz implementation, however, this version employs
    the Map/Reduce pattern to map the supplied sequence values to individual `StringFragment`
    instances and then reduce them into a single `StringFragment` instance through
    the `Combine` method. This flattened instance can then be used in conjunction
    with other instances.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve seen the builder class and understand how the methods work
    together through the desugaring process, let’s look at an example that exercises
    the entire chain. For this, we can use `buildstring` expressions to build the
    lyrics to a popular children’s song about a farmer and his dog, Bingo. The song’s
    simple lyrics and its repetitive nature make it easy to represent programmatically,
    like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Nested within the `bingo` function are three functions: `buildNamePhrase`,`buildClapAndSpellPhrases`,
    and `buildVerse`. Each of these functions constructs a `StringFragment` through
    a `buildstring` expression. At the end of each verse, the `buildstring` expression
    includes a match expression to determine whether it should end with the `Zero`
    value (implied by returning `unit`) or recursively include another fully constructed
    verse via the `yield!` keyword.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Evaluating the preceding snippet should print the following string (remember,
    the `%O` token formats the corresponding argument by calling its `ToString` method):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Computation expressions play an important role within F#. Out of the box, they
    make creating sequences, querying data from disparate data sources, and managing
    asynchronous operations appear to be a native part of the language by reusing
    familiar language elements. They’re also fully extensible, so you can define your
    own computation expressions by creating a builder class that constructs an instance
    of an underlying type. Creating custom computation expressions can be a tricky
    endeavor, but once you understand the purpose of each builder class method and
    the desugaring process, the result can be cleaner, more descriptive code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: It can be difficult to find good information about computation expressions,
    but there are a few resources you can use for further study. First, the computation
    expressions series at *F# for Fun and Profit* (*[http://fsharpforfunandprofit.com/series/computation-expressions.htm](http://fsharpforfunandprofit.com/series/computation-expressions.htm)*)
    has plenty of examples covering the range of builder methods. For some more real-world
    examples, check out the ExtCore project on GitHub (*[https://github.com/jack-pappas/ExtCore/](https://github.com/jack-pappas/ExtCore/)*),
    which contains several practical applications for computation expressions, such
    as a lazy list implementation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
