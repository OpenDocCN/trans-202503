<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="ch10" epub:type="chapter" role="doc-chapter">
<span aria-label="177" epub:type="pagebreak" id="pg_177" role="doc-pagebreak"/>
<hgroup>
<h2 class="CHAPTER" id="ch10">
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">10</span></span>
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">CLIENT/SERVER COMMUNICATION AND WEB DEVELOPMENT BASICS</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="380" src="../images/opener.jpg" width="380"/>
</figure>
<p class="INTRO">As a language of the internet, PHP is closely connected to the communications between web <i>clients</i> and web <i>servers</i>. In this chapter, we’ll look at how clients and servers work, and we’ll examine the messages that pass between them. We’ll also see how to efficiently embed PHP statements in static HTML code to construct a full HTML text file that a web browser client can understand and render onscreen as a web page. Finally, we’ll discuss how a typical PHP web application is structured, including a first look at the model-view-controller (MVC) architecture.</p>
<p class="TX">Whether you realize it or not, you probably use clients and servers every day. When you check your email or social media accounts, you’re using a client application to communicate with a server to request updates. These kinds of apps are continually making requests to servers; for example, your <span aria-label="178" epub:type="pagebreak" id="pg_178" role="doc-pagebreak"/>email app requests from servers such as Google Gmail or Apple iCloud in order to download any new email and update the messages and folders on your phone to mirror any changes.</p>
<p class="TX">You can run a web server application in two places: locally on your own computer or publicly on an internet-accessible computer. As a PHP programmer, you’ll do a lot of your software development locally on your own machine. Then, when you think a project is ready, you’ll test it on a public server, and finally publish the website live when all testing is complete.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="toc-link_140"/><span class="SANS_Futura_Std_Bold_B_11">The HTTP Request-Response Cycle</span></h3>
<p class="TNI1">At the heart of web-based client/server communications is the <i>http request-response cycle</i>. At a high level, a client sends a <i>request</i> to the server, and the server returns a <i>response</i> to the client. The response itself may be an error code, or it could be a message whose body is text, an image file, a binary executable, or other content. <a href="#fig10-1">Figure 10-1</a> illustrates a simple request-response cycle.</p>
<figure class="IMG"><a id="fig10-1"/><img alt="" class="img100" height="764" src="../images/figure10-1.jpg" width="1216"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-1: A simple HTTP request-response cycle</span></p></figcaption>
</figure>
<p class="TX">The client, a web browser, sends a request asking for the <i>index.xhtml</i> file <span aria-label="annotation1" class="CodeAnnotation">❶</span>. The server receives and decodes the request, then searches for and successfully finds the requested resource (file) <span aria-label="annotation2" class="CodeAnnotation">❷</span>. The server then creates and returns a response, whose body is the HTML text of <i>index.xhtml</i> <span aria-label="annotation3" class="CodeAnnotation">❸</span>. Finally, the web browser reads through the received HTML and displays the web page contents nicely to the user in the browser window <span aria-label="annotation4" class="CodeAnnotation">❹</span>.</p>
<p class="TX">Clients can send different types of requests. The two most common request methods are <span class="SANS_TheSansMonoCd_W5Regular_11">GET</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">POST</span>. The HTTP <span class="SANS_TheSansMonoCd_W5Regular_11">GET</span> method is simpler and, when using a web browser client, displays much of what’s being sent in the web browser URL address bar. For example, if you use the Google search <span aria-label="179" epub:type="pagebreak" id="pg_179" role="doc-pagebreak"/>engine to search for the phrase <i>cheese cake</i>, you’ll see those words appear at the end of the URL when you send the query to Google: <i>https://www.google.com/search?q=cheese+cake</i>. In fact, anytime you type a URL into the web browser address bar and hit <small>ENTER</small>, you’re sending a <span class="SANS_TheSansMonoCd_W5Regular_11">GET</span> request.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">POST</span> method, on the other hand, can hide much of what’s being sent in the body of the request message. Therefore, it’s often used for more private website operations.</p>
<p class="TX">In addition to <span class="SANS_TheSansMonoCd_W5Regular_11">GET</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">POST</span>, the original HTTP 1.0 defined a third method, <span class="SANS_TheSansMonoCd_W5Regular_11">HEAD</span>. It asks for a response with no body, just the headers, which contain general information about the response. Since the introduction of HTTP 1.1, five other methods are permitted (<span class="SANS_TheSansMonoCd_W5Regular_11">OPTIONS</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">PUT</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">DELETE</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">TRACE</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">CONNECT</span>). These aren’t needed for the level of web development in this book, although they can be useful for sophisticated web applications.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="H2" id="sec2"><span id="toc-link_141"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Response Status Codes</span></h4>
<p class="TNI1">At the beginning of every HTTP response returned by the server is a three-digit HTTP <i>status code</i> that tells the client the status of the server’s attempt to process and fulfill the request. All HTTP-compliant servers must use a set of standard codes, and on top of that, custom codes are used by different servers. The most common codes are <span class="SANS_TheSansMonoCd_W5Regular_11">200 OK</span> to indicate that a request has been successfully fulfilled and <span class="SANS_TheSansMonoCd_W5Regular_11">404 Not Found</span> to indicate that the server was unable to find the requested resource.</p>
<p class="TX">The first digit of the code indicates the general status of the server’s interpretation and processing of the request. Here’s a summary of what the first-digit prefixes signify:</p>
<p class="RunInParaF"><span class="SANS_TheSansMonoCd_W7Bold_11">1</span><span class="SANS_TheSansMonoCd_W7Bold_Italic_11">nn</span> <b>(information)</b>   The request headers were received and understood, and further processing is needed. In other words, “So far so good, but not finished yet.” These status codes are fairly uncommon. They’re informational and used when the server needs to communicate some information, but not a full response, back to the client.</p>
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">2</span><span class="SANS_TheSansMonoCd_W7Bold_Italic_11">nn</span> <b>(success)</b>   The request was received, understood, and accepted (for example, <span class="SANS_TheSansMonoCd_W5Regular_11">200 OK</span>).</p>
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">3</span><span class="SANS_TheSansMonoCd_W7Bold_Italic_11">nn</span> <b>(redirection)</b>   The request was understood, but the client must take further action, such as choosing from options (<span class="SANS_TheSansMonoCd_W5Regular_11">300 Multiple Choices</span>) or following a new URL if the resource has permanently moved (<span class="SANS_TheSansMonoCd_W5Regular_11">301 Moved Permanently</span>).</p>
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">4</span><span class="SANS_TheSansMonoCd_W7Bold_Italic_11">nn</span> <b>(client error)</b>   Either the request is invalid (such as <span class="SANS_TheSansMonoCd_W5Regular_11">400 Bad Request</span>), or the server can’t fulfill the request because of client error (such as <span class="SANS_TheSansMonoCd_W5Regular_11">404 Not Found</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">403 Forbidden</span>).</p>
<p class="RunInParaL"><span class="SANS_TheSansMonoCd_W7Bold_11">5</span><span class="SANS_TheSansMonoCd_W7Bold_Italic_11">nn</span> <b>(server error)</b>   The server has experienced an error or is unable to complete the request for other reasons. Examples include <span class="SANS_TheSansMonoCd_W5Regular_11">500 Server Error</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">502 Service Unavailable</span>.</p>
<p class="TX">You can learn more about HTTP and its status codes at Todd Fredrich’s free online REST API tutorial: <i><a href="https://www.restapitutorial.com">https://www.restapitutorial.com</a></i>.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<span aria-label="180" epub:type="pagebreak" id="pg_180" role="doc-pagebreak"/>
<h4 class="H2" id="sec3"><span id="toc-link_142"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">An Example GET Request</span></h4>
<p class="TNI1">Let’s look at a simple example of the request-response cycle by examining what happens behind the scenes when we visit the No Starch Press website. First, you need to display the browser request-response inspection tools. In Google Chrome, these tools are usually accessible as a menu item named Developer Tools. Once the developer tools are open, you’ll see a window like that at the bottom of <a href="#fig10-2">Figure 10-2</a>.</p>
<figure class="IMG"><a id="fig10-2"/><img alt="" class="img100" height="1520" src="../images/figure10-2.jpg" width="1403"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-2: A</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">GET</span> <span class="SANS_Futura_Std_Book_Oblique_11">request to the No Starch Press home page</span></p></figcaption>
</figure>
<p class="TX">Click the <b>Network</b> tab, and you’re ready to record and examine the HTTP request-response cycle. Type <b>nostarch.com</b> in the browser URL address bar. When you press <small>ENTER</small>, you should see the home page appear. Find the Name column on the left of the developer window, locate the first file, which <span aria-label="181" epub:type="pagebreak" id="pg_181" role="doc-pagebreak"/>should be <i>nostarch.com</i>, and click it. Click <b>Headers</b> to see the HTTP headers summary, shown in <a href="#fig10-3">Figure 10-3</a>.</p>
<p class="TX">This summary indicates that the HTTP request is for the URL <i><a href="https://nostarch.com">https://nostarch.com</a></i> and that the request method is <span class="SANS_TheSansMonoCd_W5Regular_11">GET</span> (since we just entered a URL in the address bar). The most important part of the HTTP response header is the success status code of <span class="SANS_TheSansMonoCd_W5Regular_11">200</span>.</p>
<p class="TX">Scroll farther down the HTTP headers contents and you’ll see full details of both the HTTP request and HTTP response headers. Under the Request Headers section, you can see the list of file types that the web client is willing to accept, such as HTML, XML, images, and so on. You can also see which human language the content is available in (for example, <span class="SANS_TheSansMonoCd_W5Regular_11">EN</span> for English). Correspondingly, the response headers indicate the actual content type in the body of the response, such as <span class="SANS_TheSansMonoCd_W5Regular_11">text/html</span>, the date the file was last modified, and so on.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>The majority of modern websites now use HyperText Transfer Protocol Secure (HTTPS), which enables the client and server to exchange certificates allowing HTTP messages to be securely encrypted. This is why the No Starch Press URL begins with</i> <span class="note">https://</span><i>. HTTPS is built into many PHP web servers, so we won’t go into it at this point.</i></p>
<p class="TX">Now click the <b>Response</b> tab to see the content of the response’s body, shown in <a href="#fig10-3">Figure 10-3</a>. This is the HTML text that the web browser receives and then renders to make an attractive-looking graphical web page for you to see and interact with.</p>
<figure class="IMG"><a id="fig10-3"/><img alt="" class="img100" height="412" src="../images/figure10-3.jpg" width="1691"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-3: HTML text content in the HTTP response body</span></p></figcaption>
</figure>
<p class="TX">At the bottom of the HTML code, you’ll see a list of CSS links. When processing the received HTML, the web client (browser) looks for any additional content files needed for the web page, like CSS stylesheets, image files, and JavaScript files. The browser quickly (we rarely notice this with modern network speeds) makes additional HTTP requests to the server for each of these files, and as the corresponding HTTP responses arrive, the browser renders the web page. These extra files received from the web server can be seen in the Name column in <a href="#fig10-2">Figure 10-2</a>, beneath the original request to <i>nostarch.com</i>. They have names like <i>css_lQaZ</i> and so on.</p>
<p class="TX"><span aria-label="182" epub:type="pagebreak" id="pg_182" role="doc-pagebreak"/>It’s important to underscore that not every HTTP request has to be initiated by a human user entering a URL, clicking a link, or submitting a form. The web browser can, behind the scenes (asynchronously), make additional requests for required resources such as images, CSS files, and JavaScript files. These additional requests may be to the same web server that delivered the HTML the browser is processing, or to other web servers (perhaps to download a free Google font, for example, or the Bootstrap CSS and JavaScript).</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>JavaScript code can also make additional HTTP requests, such as retrieving data from remote websites. This is known as</i> <span class="note">asynchronous JavaScript and XML (AJAX)</span><i>, although many types of data files may be retrieved, such as JSON and plaintext, so such HTTP requests aren’t limited to retrieving only XML data. This topic is beyond the scope of this PHP book.</i></p>
</section>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H1" id="sec4"><span id="toc-link_143"/><span class="SANS_Futura_Std_Bold_B_11">How Servers Operate</span></h3>
<p class="TNI1">We’ve discussed at a high level how clients and servers communicate through HTTP requests and responses. Now let’s take a closer look at how web servers function. We’ll also begin to see how PHP can play a role in the server’s operations.</p>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="H2" id="sec5"><span id="toc-link_144"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Simple Web Servers for File Retrieval</span></h4>
<p class="TNI1">The task of a simple web server is to listen for requests for resources and, when a request is received, to identify the resource requested and return either a message containing the resource or an error message if it can’t be found. A simple web server is basically a file server that’s able to understand HTTP requests and send HTTP responses. <a href="#fig10-4">Figure 10-4</a> illustrates a simple web server.</p>
<figure class="IMG"><a id="fig10-4"/><img alt="" class="img100" height="745" src="../images/figure10-4.jpg" width="1367"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-4: A simple web server communication with a web client</span></p></figcaption>
</figure>
<p class="TX"><span aria-label="183" epub:type="pagebreak" id="pg_183" role="doc-pagebreak"/>Typically, the client sends a <span class="SANS_TheSansMonoCd_W5Regular_11">GET</span> request <span aria-label="annotation1" class="CodeAnnotation">❶</span>, requesting a file such as <i>index.xhtml</i>, <i>style.css</i>, or <i>logo.png</i>. The server receives and interprets the request, then searches for the requested resource (file) <span aria-label="annotation2" class="CodeAnnotation">❷</span>. If the file can’t be found, the server creates and returns a <span class="SANS_TheSansMonoCd_W5Regular_11">404 Not Found</span> error. If the file is found, the server retrieves its contents <span aria-label="annotation3" class="CodeAnnotation">❸</span>. Finally, the server creates and returns a response to the client <span aria-label="annotation4" class="CodeAnnotation">❹</span>. The response body is the content of the requested file, and its header includes the <span class="SANS_TheSansMonoCd_W5Regular_11">200 OK</span> status code.</p>
<p class="TX">A good analogy for this process is that a simple web server functions like a librarian in a library: the librarian goes off to locate a requested book and returns with either the book or a message saying the book can’t be located.</p>
<p class="TX">Simple web servers are sufficient for hypertext or hypermedia browsing of an unchanging set of HTML pages, such as a set of frequently asked questions (FAQ) and answer paragraphs or reference materials that rarely need to be updated, like a user manual. Simple web servers are <i>stateless</i>, meaning the same request will always get the same file returned. Different clients will also get the same file returned. This is often termed <i>static</i> content to indicate that it’s unchanging. Returning to the librarian analogy, you wouldn’t expect a librarian to change the content of a book as they’re retrieving it.</p>
<p class="TX">We can summarize the behavior of simple stateless web servers as follows:</p>
<ul class="ul">
<li class="ListBullet">Never changes</li>
<li class="ListBullet">The same regardless of whether the user has visited before</li>
<li class="ListBullet">The same for every user</li>
</ul>
<p class="TX">Most web activity is more interactive than simply clicking links to specific static documents. The majority of modern web projects require <i>dynamic interactivity</i>, in which the system responds differently according to user inputs. Dynamic interactivity encompasses tasks like processing web forms, managing shopping carts, customizing content based on recent browsing history, and more. Most PHP web applications are <i>dynamic</i> web servers, which we’ll explore next.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="H2" id="sec6"><span id="toc-link_145"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Dynamic Web Servers for Processing Data</span></h4>
<p class="TNI1">For a web-based system to be interactive beyond static resource retrieval, further technologies are required beyond basic content markup and hypertext linking. These capabilities include the following:</p>
<ul class="ul">
<li class="ListBullet">Support for user input methods, like inputting text, clicking buttons, and choosing from menus</li>
<li class="ListBullet">Short code scripts that can process and respond in different ways to different user inputs</li>
<li class="ListBullet">Methods for the browser to send user inputs or data to the server programs that will process the data and generate interactive responses</li>
</ul>
<p class="TX">Dynamic servers with capabilities such as these handle many typical modern internet activities, like entering keywords into a search engine and being presented with a tailor-made page of prioritized links, logging into your personal email system and retrieving your own email in your inbox, <span aria-label="184" epub:type="pagebreak" id="pg_184" role="doc-pagebreak"/>and browsing catalogs of products online and making a purchase using a credit card.</p>
<p class="TX">In this book, we’re most interested in dynamic web servers that understand and can run PHP scripts. <a href="#fig10-5">Figure 10-5</a> illustrates client communication with one such dynamic web server.</p>
<figure class="IMG"><a id="fig10-5"/><img alt="" class="img100" height="745" src="../images/figure10-5.jpg" width="1367"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-5: A dynamic web server communication with a web client</span></p></figcaption>
</figure>
<p class="TX">In this model, the client sends an HTTP request to the server <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Then the server program interprets the request and identifies which PHP server script should be executed <span aria-label="annotation2" class="CodeAnnotation">❷</span>. The script is executed <span aria-label="annotation3" class="CodeAnnotation">❸</span> and generates output, such as HTML text. Running a PHP script can also trigger other actions on the web server, such as communication with a database, which is something we’ll explore in <span class="Xref"><a href="part6.xhtml">Part VI</a></span>. Next, the web server application receives the output <span aria-label="annotation4" class="CodeAnnotation">❹</span>. Finally, the output is packaged up in the body of an HTTP response message and returned with appropriate headers to the client that originally made the request <span aria-label="annotation5" class="CodeAnnotation">❺</span>.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h4 class="H2" id="sec7"><span id="toc-link_146"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">The Routing Process</span></h4>
<p class="TNI1"><i>Routing</i> is the process the web server uses in deciding what to do to respond appropriately to the HTTP request it has received; the server examines the request and determines what action it believes the client is requesting, such as asking for a file, trying to log in with username and password data included in the request, deleting an item from a database, and so on. In the simplest scenario, the request contains a valid path for a specific resource file, like <i>/images/logo.jpg</i> or <i>/styles/homepage.css</i>. In this case, the web server acts like a file server and returns an HTTP response message containing the contents of the file with appropriate header information.</p>
<p class="TX">If a valid path to a publicly available.<i>php</i> file is requested, such as <i>/about.php</i>, that PHP script will be interpreted and executed to build the HTTP response that’s returned to the client. If no specific file is requested, almost <span aria-label="185" epub:type="pagebreak" id="pg_185" role="doc-pagebreak"/>all web servers have <i>default routing</i> defined, which will often route to a home page file, usually named <i>index</i>. Simple static web servers will look for <i>index.xhtml</i> to return as the default home page, whereas PHP web servers will usually look first for <i>index.php</i> and perhaps then look for <i>index.xhtml</i> if no default PHP file is found. If no file is requested and no index file is found, the server will return a <span class="SANS_TheSansMonoCd_W5Regular_11">404 Not Found</span> response.</p>
<p class="TX">Sophisticated PHP web applications will use logic encoded inside the default <i>index.php</i> script to examine the contents and pattern of the URL path requested and from there decide how to respond to the request. An <i>index.php</i> file that uses logic like this to manage the complexity of a many-featured website is known as a <i>front controller</i>.</p>
<p class="TX">Here are some examples of the types of URLs that web browsers use to make requests to web servers, with explanations of what they mean:</p>
<p class="RunInParaF"><b><i>tudublin.ie</i></b>   No path is indicated beyond the domain name, so the web server will execute the default home page script (<i>index.php</i> if it’s a PHP web server). The TU Dublin home page HTML content is returned to the client.</p>
<p class="RunInPara"><b><i>bbc.com/travel/columns/discovery</i></b>   The path contains text separated by forward slashes, so the home page script executes with logic to search the site’s database for today’s content relating to the main topic <i>travel</i> and the subtopic <i>discovery</i>.</p>
<p class="RunInPara"><b><i>nostarch.com/sites/all/themes/nostarch/logo.png</i></b>   The path includes a static resource file, so the web server locates and returns the contents of the <i>logo.png</i> image file.</p>
<p class="RunInParaL"><b><i>google.com/search?q=cheese+cake</i></b>   The path contains text indicating a search after the forward slash (<i>search</i>) and then the search text (<i>cheese cake</i>) in a variable (<i>q</i>) assigned after a question mark character (<i>?</i>). So the Google home page script executes with logic to search for web pages relating to <i>cheese cake</i>. In <span class="runinpara_Xref"><a href="chapter11.xhtml">Chapter 11</a></span>, you’ll learn all about passing data through variables in URLs like this one.</p>
<p class="BodyContinued">In <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>, we’ll look at how to write PHP front-controller logic to perform routing decisions such as the ones summarized here.</p>
</section>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="H1" id="sec8"><span id="toc-link_147"/><span class="SANS_Futura_Std_Bold_B_11">Templating</span></h3>
<p class="TNI1">Almost all PHP applications are designed to run websites. For most HTTP requests, the content of the response is some sort of text, like an HTML, JavaScript, or CSS file, or perhaps data encoded as JSON or XML. PHP consequently was designed to facilitate outputting text (with, for example, the <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> commands).</p>
<p class="TX">Further, as was hinted in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, the language also makes it easy to mix prewritten text such as HTML with text created on the fly by executing PHP code. This feature is what makes PHP a <i>templating language</i>: it can insert dynamically generated values into static templates of HTML or other text. PHP-driven websites benefit from this sort of dynamic output, which may <span aria-label="186" epub:type="pagebreak" id="pg_186" role="doc-pagebreak"/>result from database interactions or communication between various data sources like Google Maps, weather APIs, and so on.</p>
<p class="TX">In the previous chapters, we’ve been writing pure PHP programs, which are scripts that contain only PHP code. Once we start using PHP as a templating language, mixing PHP statements with other template text (often HTML) becomes more common. This allows us to write the unchanging HTML for web pages as just HTML; any parts that need to change dynamically can be output from the logic we write in PHP statements. Conveniently, the HTML in many website pages contains much of the same content, such as a header, a navigation bar (which might change only by highlighting the particular page being visited), and page layout HTML code (for example, a hierarchy of <span class="SANS_TheSansMonoCd_W5Regular_11">div</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">header</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">footer</span> elements). All this nonchanging, static content is perfect for PHP templating.</p>
<p class="TX">It’s theoretically possible to make a pure PHP script output HTML by writing lots of <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> statements, but this approach results in code that’s long and hard to read. Take a look at <a href="#lis10-1">Listing 10-1</a>, which outputs HTML by using pure PHP <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> statements.</p>
<span id="lis10-1"/>
<pre><code>&lt;?php&#13;
print '&lt;!doctype html&gt;';&#13;
print '&lt;head&gt;&lt;title&gt;home&lt;/title&gt;&lt;/head&gt;';&#13;
print '&lt;body&gt;';&#13;
print '&lt;p&gt;Welcome to My Great Website&lt;br&gt;';&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> print 'today is ' . date('F d, Y');&#13;
print '&lt;p&gt;';&#13;
print '&lt;/body&gt;&lt;/html&gt;';</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 10-1: Outputting HTML through</span> <span class="TheSansMonoCd_W5Regular_Italic_11">print</span> <span class="SANS_Futura_Std_Book_Oblique_11">statements</span></p>
<p class="TX">The only real PHP logic we’re using here is calling the <span class="SANS_TheSansMonoCd_W5Regular_11">date()</span> function to get the current date as a string in the form <i>Month day, year</i> (for example, <i>January 1, 2025</i>) <span aria-label="annotation1" class="CodeAnnotation">❶</span>. All other lines are <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> statements that output unchanging HTML, and these <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> statements aren’t necessary. We can make the code more compact and readable by using PHP only where it’s needed, inserting it into an HTML template. That’s what we do in <a href="#lis10-2">Listing 10-2</a>, where the unchanging HTML is written just as it will appear in the final HTML text file to be sent to the client.</p>
<span id="lis10-2"/>
<pre><code>&lt;!doctype html&gt;&#13;
&lt;head&gt;&lt;title&gt;home&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#13;
&lt;p&gt;Welcome to My Great Website&lt;br&gt;&#13;
today is&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> &lt;?php&#13;
    print date('F d, Y');&#13;
<span aria-label="annotation2" class="codeannotated_CodeAnnotation">❷</span> ?&gt;&#13;
&lt;/p&gt;&#13;
&lt;/body&gt;&lt;/html&gt;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 10-2: Mixing HTML template text with a PHP code block</span></p>
<p class="TX">We use opening <span aria-label="annotation1" class="CodeAnnotation">❶</span> and closing <span aria-label="annotation2" class="CodeAnnotation">❷</span> PHP tags to surround just the <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> statement where we call the <span class="SANS_TheSansMonoCd_W5Regular_11">date()</span> function, since this is the only place where <span aria-label="187" epub:type="pagebreak" id="pg_187" role="doc-pagebreak"/>PHP code is needed to dynamically generate content. Meanwhile, we’ve written everything else as regular HTML; no <span class="SANS_TheSansMonoCd_W5Regular_11">print</span>s, quotes, or semicolons are needed. <a href="#fig10-6">Figure 10-6</a> shows how PHP sees and processes the script content.</p>
<figure class="IMG"><a id="fig10-6"/><img alt="" class="img100" height="1168" src="../images/figure10-6.jpg" width="1667"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-6: How PHP processes mixed template text and dynamic code</span></p></figcaption>
</figure>
<p class="TX">First, a block of template text needs to be copied verbatim into the text output. Next, a block of PHP code (between <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;?php</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">?&gt;</span>) needs to be interpreted and executed before the result is added to the script’s text output. Finally, another block of template text needs to be copied verbatim to the output text. The temporary store for the text being output by the multiple parts of a PHP script is referred to as the <i>output buffer</i>.</p>
<p class="TX">Imagine for a moment that the script in <a href="#lis10-2">Listing 10-2</a> is part of an HTTP request from a web browser. When all PHP execution in the script is completed, the text in the output buffer will be wrapped up into an HTTP response by adding headers and then sent back to the browser web client. The browser will then render (draw) the web page for the user to see, interpreting the HTML it received in the body text of the HTTP response, resulting in the simple page shown at the bottom of <a href="#fig10-6">Figure 10-6</a>.</p>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="H2" id="sec9"><span id="toc-link_148"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">PHP Tags</span></h4>
<p class="TNI1">As you’ve just seen, when you embed PHP code in template text, it’s important to use both the opening <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;?php</span> tag and the closing <span class="SANS_TheSansMonoCd_W5Regular_11">?&gt;</span> tag to delimit the <span aria-label="188" epub:type="pagebreak" id="pg_188" role="doc-pagebreak"/>code. By contrast, when writing PHP scripts that contain <i>just</i> code without any template text, the script should start with an opening <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;?php</span> tag, but you shouldn’t include the closing <span class="SANS_TheSansMonoCd_W5Regular_11">?&gt;</span> tag at the end of the file.</p>
<p class="TX">You leave off the closing tag for two reasons. First, you don’t need it, since the code has no template text to be separated from the PHP statements. Second, if you did include the closing PHP tag, any (unintentional and invisible) whitespace that occurs after the closing tag, including spaces, tabs, or newline characters, will be interpreted as template text and could prematurely begin creating the output buffer.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="H2" id="sec10"><span id="toc-link_149"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Short Echo Tags</span></h4>
<p class="TNI1">We’ve so far focused on PHP’s main <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;?php</span> tag, but the language also provides a <i>short echo tag</i>, denoted with the <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;?=</span> symbol, that further simplifies templating. This tag allows you to avoid writing lengthy commands when all you want to do is output the result of an expression as text. This might be to display the contents of a variable, or the result of a complex calculation or series of string concatenations. For example, instead of writing something like <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;?php print $someVariable; ?&gt;</span> to output the value of <span class="SANS_TheSansMonoCd_W5Regular_11">$someVariable</span>, you can simply write <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;?= $someVariable ?&gt;</span> with the short echo tag.</p>
<p class="TX">The short echo tag calls for less typing since it omits <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> (or <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span>) and doesn’t require an ending semicolon. Also, any experienced PHP programmer who encounters the short echo tag can immediately recognize that the only logic is to output a string. Overall, the key advantage of the short echo tag is that it doesn’t distract the reader (or writer) with extraneous PHP code-block syntax when a script mostly contains HTML template text. The dynamically generated PHP code values blend in better with the surrounding HTML, as <a href="#lis10-3">Listing 10-3</a> illustrates.</p>
<span id="lis10-3"/>
<pre><code>&lt;?php&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> $dateString = date('F d, Y', time());&#13;
?&gt;&#13;
&lt;!doctype html&gt;&lt;head&gt;&lt;title&gt;home&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#13;
&lt;p&gt;Welcome to My Great Website&lt;br&gt;&#13;
<span aria-label="annotation2" class="codeannotated_CodeAnnotation">❷</span> Today is &lt;?= $dateString ?&gt;&#13;
&lt;/p&gt;&#13;
&lt;/body&gt;&lt;/html&gt;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 10-3: Simplifying code with the PHP short echo tag</span></p>
<p class="TX">In a full PHP code block surrounded by ordinary PHP tags, we create a <span class="SANS_TheSansMonoCd_W5Regular_11">$dateString</span> variable containing our formatted date string <span aria-label="annotation1" class="CodeAnnotation">❶</span>. This frees us up to simply write <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;?= $dateString ?&gt;</span>, using the short echo tag at the spot in the template where we want the string to be output <span aria-label="annotation2" class="CodeAnnotation">❷</span>. There’s no need for a <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> statement or semicolon.</p>
</section>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h3 class="H1" id="sec11"><span id="toc-link_150"/><span class="SANS_Futura_Std_Bold_B_11">The Model-View-Controller Architecture</span></h3>
<p class="TNI1">Almost all large-scale web applications delegate different responsibilities to different system components. Most do this by implementing some form <span aria-label="189" epub:type="pagebreak" id="pg_189" role="doc-pagebreak"/>of the <i>model-view-controller (MVC)</i> architecture. This is a software design pattern that distinguishes between the data underlying the software (the <i>model</i>), the way that data is displayed to the user (the <i>view</i>), and the decisions about what data to display when (the <i>controller</i>).</p>
<p class="TX">We’ve already touched on aspects of the MVC architecture in this chapter. We’ve noted how PHP applications can make routing decisions based on incoming HTTP requests (a controller task) and how we can use PHP for templating by injecting dynamically generated values into static HTML text (a view task). Now let’s fill in a few more gaps to see how the MVC pattern fits into the request-response cycle. <a href="#fig10-7">Figure 10-7</a> illustrates a typical interpretation of the MVC architecture for a web application.</p>
<figure class="IMG"><a id="fig10-7"/><img alt="" class="img60" height="905" src="../images/figure10-7.jpg" width="811"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-7: The MVC architecture common for web applications</span></p></figcaption>
</figure>
<p class="TX">First, the web client sends an HTTP request <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Then the controller (the main application logic) interprets the request and decides what to do <span aria-label="annotation2" class="CodeAnnotation">❷</span>. This may involve checking any stored security credentials and other data (such as shopping-cart contents) and deciding the appropriate actions to take in response to the received request. Often the controller needs to read the contents of a data store, such as a database system, file store, or even an API running on another server. This data is the model component of the MVC pattern. If the received request contains data submitted from a form, the controller may need to update or delete some of the model data.</p>
<p class="TX">Then the controller invokes the view component <span aria-label="annotation3" class="CodeAnnotation">❸</span>, such as a template file, to create the contents of the response to be returned to the user. If appropriate, the controller passes along data collected from the model when it invokes the view component. Finally, the controller sends the response that it has created back to the web client (adding any appropriate headers, response codes, and the like) <span aria-label="annotation4" class="CodeAnnotation">❹</span>.</p>
<p class="TX"><span aria-label="190" epub:type="pagebreak" id="pg_190" role="doc-pagebreak"/>We’ll revisit the MVC pattern throughout this book as we delve further into structuring PHP web applications. As mentioned, in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a>,</span> we’ll look at how to create a front-controller script to manage the controller portion of the architecture. In <span class="Xref"><a href="chapter21.xhtml">Chapter 21</a></span>, we’ll introduce the Twig library, which simplifies templating for the view portion of the architecture. Finally, in <span class="Xref"><a href="part6.xhtml">Part VI</a></span>, starting with <span class="Xref"><a href="chapter27.xhtml">Chapter 27</a></span>, we’ll investigate how to integrate a PHP application with a database to handle the model portion of the architecture.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="H1" id="sec12"><span id="toc-link_151"/><span class="SANS_Futura_Std_Bold_B_11">Structuring a PHP Web Development Project</span></h3>
<p class="TNI1">As we discussed in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, the PHP engine comes with a built-in web server for testing purposes that you can run at the command line by using the <span class="SANS_TheSansMonoCd_W5Regular_11">php -S localhost:8000</span> command. By default, this command makes every file and folder that lives in the directory that the command line is currently pointing to publicly available through the web server. For example, if your command line was navigated to the root of your main hard disk (such as <i>C:\</i> on a Windows computer) and you executed the PHP web server command, you’d be making everything on the hard disk available to be requested! This probably isn’t a good idea from a security point of view.</p>
<p class="TX">Even within a specific PHP project folder, you may have files or other content that you wouldn’t want to publish publicly, such as code containing username and password credentials for data access or scripts that should be accessed only by authorized users. Therefore, it’s customary (and highly recommended) to create a <i>public</i> folder within the overall folder for any PHP web development project. This <i>public</i> folder (and its subfolders, if any) should contain only those files that are to be made publicly accessible via the web server, including any images, sound files, video files, CSS stylesheets, JavaScript text files, and the like that are needed for the website. Any PHP scripts that are to be executed in direct response to incoming HTTP requests from web clients should also be located in the <i>public</i> folder, while other content that shouldn’t be publicly accessible should be located elsewhere in the project’s directory structure.</p>
<p class="TX">The usual way to organize a secure web application is to have just one PHP script named <i>index.php</i> in the project’s <i>public</i> folder. This script (the front controller we’ll discuss further in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>) then decides which other nonpublic scripts should be executed based on the properties of the incoming HTTP requests and other stored data. A typical PHP project folder therefore looks as follows:</p>
<span aria-label="191" epub:type="pagebreak" id="pg_191" role="doc-pagebreak"/>
<figure class="IMG-1"><img alt="" class="img100" height="546" src="../images/pg191.jpg" width="1359"/>
</figure>
<p class="TX">Generally, it’s best to do any command line work from the root folder of a project rather than from the <i>public</i> folder. Since this practice is so common, the built-in PHP web server offers the <span class="SANS_TheSansMonoCd_W5Regular_11">-t</span> command line option for specifying a subfolder from which to serve web pages. With your command line interface navigated to the root project directory, you can therefore enter the following command to serve only files in the <i>public</i> folder via port 8000:</p>
<pre><code><b>php -S localhost:8000 -t public</b></code></pre>
<p class="TX">Let’s test these two ways to run the built-in PHP web server: with and without the <span class="SANS_TheSansMonoCd_W5Regular_11">-t</span> option. First, create a new empty folder named <i><a href="chapter10.xhtml">chapter 10</a></i>, and in this folder create an <i>index.php</i> file containing the code shown in <a href="#lis10-4">Listing 10-4</a>.</p>
<span id="lis10-4"/>
<pre><code>&lt;?php&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> $total = 2 + 2;&#13;
?&gt;&#13;
&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Home page&lt;/title&gt;&lt;/head&gt;&#13;
&lt;body&gt;&#13;
<span aria-label="annotation2" class="codeannotated_CodeAnnotation">❷</span> &lt;?= "total = $total" ?&gt;&#13;
&lt;/body&gt;&lt;/html&gt;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 10-4: A simple</span> <span class="SANS_Futura_Std_Book_11">index.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">file</span></p>
<p class="TX">This script contains only two PHP statements: within full PHP tags, we set the <span class="SANS_TheSansMonoCd_W5Regular_11">$total</span> variable to the result of evaluating the mathematical expression <span class="SANS_TheSansMonoCd_W5Regular_11">2 + 2</span> <span aria-label="annotation1" class="CodeAnnotation">❶</span>, and with the short echo tag we output the contents of this variable <span aria-label="annotation2" class="CodeAnnotation">❷</span>. To make sure this script works, navigate your command line interface to the <i>chapter10</i> folder (use the <span class="SANS_TheSansMonoCd_W5Regular_11">cd</span> command to change directories if you aren’t there already), and then run the built-in PHP web server at port 8000 without specifying a folder to serve:</p>
<pre><code>% <b>php -S localhost:8000</b></code></pre>
<p class="BodyContinued">Open a web browser to <i>localhost:8000</i> and you should see a web page showing the result of the PHP output statement: <span class="SANS_TheSansMonoCd_W5Regular_11">total = 4</span>.</p>
<p class="TX">Now let’s see why publishing the entire contents of a project folder is a bad idea. In your <i>chapter10</i> folder, also create a text file called <i>password.txt</i> containing the text <span class="SANS_TheSansMonoCd_W5Regular_11">password=mysecret</span>. Then visit <i>localhost:8000/password.txt</i> in <span aria-label="192" epub:type="pagebreak" id="pg_192" role="doc-pagebreak"/>your web browser to see that this text file is also publicly accessible from the web server, just like the <i>index.php</i> script (see <a href="#fig10-8">Figure 10-8</a>).</p>
<figure class="IMG"><a id="fig10-8"/><img alt="" class="img100" height="386" src="../images/figure10-8.jpg" width="1303"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 10-8: The web server publishing a secret password</span></p></figcaption>
</figure>
<p class="TX">Let’s make this file more secure by creating a subfolder named <i>public</i> and moving the <i>index.php</i> script into this subfolder, while keeping <i>password.tx</i>t in the main <i>chapter10</i> folder. Once you’ve made this change, press <small>CTRL</small>-C to kill the old web server process and then run the web server again, this time restricting it to only the content of the <i>public</i> subfolder:</p>
<pre><code>% <b>php -S localhost:8000 -t public</b></code></pre>
<p class="TX">Try visiting both <i>localhost:8000</i> and <i>localhost:8000/password.txt</i> in your browser again. You should still be able to see the index page since it’s located in the <i>public</i> folder, but you should get a <span class="SANS_TheSansMonoCd_W5Regular_11">404</span> error when you try to access the <i>password.txt</i> file since it isn’t in the <i>public</i> folder. We’ll follow this structure of using a <i>public</i> folder to isolate just the resources that should be publicly accessible throughout the book.</p>
<aside aria-labelledby="box-8" class="box">
<h4 class="BoxTitle" id="box-8"><span class="SANS_Dogma_OT_Bold_B_11">INSTALLING A DIFFERENT WEB SERVER</span></h4>
<p class="BoxBodyFirst"><span class="SANS_Futura_Std_Book_11">In most cases, the built-in PHP web server is fine for development purposes. (Personally, I don’t have any other server on my PHP development laptop.) That said, for a given project or client, you might know that the final published website will run on a specific web server such as Apache HTTP Server or nginx. If this is the case, installing the same server application on your local development computer makes sense so you can identify server-specific issues as early as possible.</span></p>
<p class="BoxBody"><span class="SANS_Futura_Std_Book_11">Perhaps the most common way to install a web server on a local computer is to install an “all-in-one”</span> <span class="SANS_Futura_Std_Book_Oblique_11">AMP stack</span><span class="SANS_Futura_Std_Book_11">. This acronym refers to</span> <span class="SANS_Futura_Std_Book_Oblique_11">Apache-MySQL-PHP</span><span class="SANS_Futura_Std_Book_11">, although usually other applications and languages are also available, such as Python and the nginx web server. A good option, available in both free and paid versions, is MAMP, which was originally for macOS but is now also available for Windows. Once installed, MAMP offers a choice of either Apache or nginx.</span></p>
<p class="BoxBodyLast"><span class="SANS_Futura_Std_Book_11">See <a href="appendix-a.xhtml">Appendix A</a> for other suggestions on AMP stack installations.</span></p>
</aside>
</section>
<section aria-labelledby="sec13" epub:type="division">
<span aria-label="193" epub:type="pagebreak" id="pg_193" role="doc-pagebreak"/>
<h3 class="H1" id="sec13"><span id="toc-link_152"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>
<p class="TNI1">In this chapter, we explored concepts fundamental to PHP web development. We considered the HTTP messages that form the basis for web client/server communications and began to discuss the concept of routing, which is how web servers evaluate the content of the HTTP request’s path and decide what files to return or which server scripts to execute. We also looked at PHP as a templating language that enables us to mix dynamic PHP statements with unchanging template text. We saw a tidy way to mix PHP output with HTML template text using the short echo tag.</p>
<p class="TX">We had our first look at the MVC architecture, a powerful way of dividing and organizing the tasks and data that drive a web application. Finally, we looked at the typical structure of a PHP web development project. In particular, we discussed the need for a <i>public</i> subfolder containing any resources that should be publicly accessible; any files or scripts that shouldn’t be publicly accessible must be located outside this subfolder.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h3 class="H1" id="sec14"><span id="toc-link_153"/><span class="SANS_Futura_Std_Bold_B_11">Exercises</span></h3>
<p class="ListNumber">1.   Open the developer tools for your web browser and visit a favorite website. Examine the headers of your HTTP <span class="SANS_TheSansMonoCd_W5Regular_11">GET</span> request and the body of the HTTP response message that’s returned to the browser.</p>
<p class="ListNumber">2.   With the developer tools for your web browser open, visit a web page that offers a form. Complete the form and, when you submit it, view the HTTP request body. You should see the name or value variables that were sent to the web server via the <span class="SANS_TheSansMonoCd_W5Regular_11">POST</span> HTTP method.</p>
<p class="ListNumber">3.   Write a “pure” PHP script, all in a single PHP block of code, to do the following:</p>
<p class="ListNumberSub">a.   Define a PHP <span class="SANS_TheSansMonoCd_W5Regular_11">$pageTitle</span> variable containing the string <span class="SANS_TheSansMonoCd_W5Regular_11">'Home Page'</span>.</p>
<p class="ListNumberSub">b.   Output <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;</span>.</p>
<p class="ListNumberSub">c.   Output the value inside the <span class="SANS_TheSansMonoCd_W5Regular_11">$pageTitle</span> variable.</p>
<p class="ListNumberSub">d.   Output <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;/title&gt;&lt;/head&gt;</span>.</p>
<p class="ListNumber">4.   Rewrite your answer for Exercise 3, using template text instead of PHP code where possible. Use complete code blocks with <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;?php</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">?&gt;</span> tags for the PHP code.</p>
<p class="ListNumber">5.   Rewrite your answer for Exercise 4 to use the short echo tag to output the value inside the <span class="SANS_TheSansMonoCd_W5Regular_11">$pageTitle</span> variable.</p>
</section>
</section>
</div></body></html>