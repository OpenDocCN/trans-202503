["```\n$ file /usr/bin/* | grep \"shell script\" | cut -d: -f1 | xargs wc -l \\\n| sort -n | head -15\n    3 zcmp\n    3 zegrep\n    3 zfgrep\n    4 mkfontdir\n    5 pydoc\n    7 sgmlwhich\n    8 batch\n    8 ps2pdf12\n    8 ps2pdf13\n    8 ps2pdf14\n    8 timed-read\n    9 timed-run\n   10 c89\n   10 c99\n   10 neqn\n```", "```\n#!/bin/bash\n# Provision of this shell script should not be taken to imply that use of\n#   GNU eqn with groff -Tascii|-Tlatin1|-Tutf8|-Tcp1047 is supported.\n\n: ${GROFF_BIN_PATH=/usr/bin}\nPATH=$GROFF_BIN_PATH:$PATH\nexport PATH\nexec eqn -Tascii ${1+\"$@\"}\n\n# eof\n```", "```\n   #!/bin/bash\n\n   # fquota--Disk quota analysis tool for Unix; assumes all user\n   #   accounts are >= UID 100\n\n   MAXDISKUSAGE=20000   # In megabytes\n\n   for name in $(cut -d: -f1,3 /etc/passwd | awk -F: '$2 > 99 {print $1}')\n   do\n     /bin/echo -n \"User $name exceeds disk quota. Disk usage is: \"\n     # You might need to modify the following list of directories to match\n     #   the layout of your disk. The most likely change is from /Users to /home.\n➊   find / /usr /var /Users -xdev -user $name -type f -ls | \\\n       awk '{ sum += $7 } END { print sum / (1024*1024) \" Mbytes\" }'\n\n➋ done | awk \"\\$9 > $MAXDISKUSAGE { print \\$0 }\"\n\n   exit 0\n```", "```\n$ sudo fquota\nUser taylor exceeds disk quota. Disk usage is: 21799.4 Mbytes\n```", "```\n   #!/bin/bash\n\n   # diskhogs--Disk quota analysis tool for Unix; assumes all user\n   #   accounts are >= UID 100\\. Emails a message to each violating user\n   #   and reports a summary to the screen.\n\n   MAXDISKUSAGE=500\n➊ violators=\"/tmp/diskhogs0.$$\"\n\n➋ trap \"$(which rm) -f $violators\" 0\n\n➌ for name in $(cut -d: -f1,3 /etc/passwd | awk -F: '$2 > 99 { print $1 }')\n   do\n➍   /bin/echo -n \"$name \"\n     # You might need to modify the following list of directories to match the\n     #   layout of your disk. The most likely change is from /Users to /home.\n     find / /usr /var /Users -xdev -user $name -type f -ls | \\\n       awk '{ sum += $7 } END { print sum / (1024*1024) }'\n\n   done | awk \"\\$2 > $MAXDISKUSAGE { print \\$0 }\" > $violators\n\n➎ if [ ! -s $violators ] ; then\n     echo \"No users exceed the disk quota of ${MAXDISKUSAGE}MB\"\n     cat $violators\n     exit 0\n   fi\n\n   while read account usage ; do\n\n➏   cat << EOF | fmt | mail -s \"Warning: $account Exceeds Quota\" $account\n     Your disk usage is ${usage}MB, but you have been allocated only\n     ${MAXDISKUSAGE}MB. This means that you need to delete some of your\n     files, compress your files (see 'gzip' or 'bzip2' for powerful and\n     easy-to-use compression programs), or talk with us about increasing\n     your disk allocation.\n\n     Thanks for your cooperation in this matter.\n\n     Your afriendly neighborhood sysadmin\n     EOF\n\n     echo \"Account $account has $usage MB of disk space. User notified.\"\n\n   done < $violators\n\n   exit 0\n```", "```\n$ sudo diskhogs\nAccount ashley has 539.7MB of disk space. User notified.\nAccount taylor has 91799.4MB of disk space. User notified.\n```", "```\nSubject: Warning: ashley Exceeds Quota\n\nYour disk usage is 539.7MB, but you have been allocated only 500MB. This means\nthat you need to delete some of your files, compress your files (see 'gzip' or\n'bzip2' for powerful and easy-to-use compression programs), or talk with us\nabout increasing your disk allocation.\n\nThanks for your cooperation in this matter.\n\nYour friendly neighborhood sysadmin\n```", "```\n   #!/bin/bash\n\n   # newdf--A friendlier version of df\n\n   awkscript=\"/tmp/newdf.$$\"\n\n   trap \"rm -f $awkscript\" EXIT\n\n   cat << 'EOF' > $awkscript\n   function showunit(size)\n➊ { mb = size / 1024; prettymb=(int(mb * 100)) / 100;\n➋   gb = mb / 1024; prettygb=(int(gb * 100)) / 100;\n\n     if ( substr(size,1,1) !~ \"[0-9]\" ||\n          substr(size,2,1) !~ \"[0-9]\" ) { return size }\n     else if ( mb < 1) { return size \"K\" }\n     else if ( gb < 1) { return prettymb \"M\" }\n     else              { return prettygb \"G\" }\n   }\n\n   BEGIN {\n     printf \"%-37s %10s %7s %7s %8s %-s\\n\",\n           \"Filesystem\", \"Size\", \"Used\", \"Avail\", \"Capacity\", \"Mounted\"\n   }\n\n   !/Filesystem/ {\n\n     size=showunit($2);\n     used=showunit($3);\n     avail=showunit($4);\n\n     printf \"%-37s %10s %7s %7s %8s %-s\\n\",\n           $1, size, used, avail, $5, $6\n   }\n\n   EOF\n\n➌ df -k | awk -f $awkscript\n\n   exit 0\n```", "```\n$ df\nFilesystem                        512-blocks Used      Available Capacity Mounted on\n/dev/disk0s2                      935761728  628835600 306414128 68%      /\ndevfs                             375        375       0         100%     /dev\nmap -hosts                        0          0         0         100%     /net\nmap auto_home                     0          0         0         100%     /home\nlocalhost:/mNhtYYw9t5GR1SlUmkgN1E 935761728  935761728 0         100%     /Volumes/MobileBackups\n```", "```\n$ newdf\nFilesystem                         Size    Used     Avail    Capacity  Mounted\n/dev/disk0s2                       446.2G  299.86G  146.09G  68%       /\ndevfs                              187K    187K     0        100%      /dev\nmap -hosts                         0       0        0        100%\nmap auto_home                      0       0        0        100%\nlocalhost:/mNhtYYw9t5GR1SlUmkgN1E  446.2G  446.2G   0        100%      /Volumes/MobileBackups\n```", "```\n$ df\nFilesystem          1K-blocks  Used     Available  Use%  Mounted on\n/dev/hdb2           25695892   1871048  22519564   8%    /\n/dev/hdb1           101089     6218     89652      7%    /boot\nnone                127744     0        127744     0%    /dev/shm\n```", "```\n   #!/bin/bash\n\n   # diskspace--Summarizes available disk space and presents it in a logical\n   #   and readable fashion\n\n   tempfile=\"/tmp/available.$$\"\n   trap \"rm -f $tempfile\" EXIT\n\n   cat << 'EOF' > $tempfile\n       { sum += $4 }\n   END { mb = sum / 1024\n         gb = mb / 1024\n         printf \"%.0f MB (%.2fGB) of available disk space\\n\", mb, gb\n       }\n   EOF\n\n➊ df -k | awk -f $tempfile\n\n   exit 0\n```", "```\n$ diskspace\n96199 MB (93.94GB) of available disk space\n```", "```\n   #!/bin/bash\n\n   # mkslocatedb--Builds the central, public locate database as user nobody\n   #   and simultaneously steps through each user's home directory to find\n   #   those that contain a .slocatedb file. If found, an additional, private\n   #   version of the locate database will be created for that user.\n\n   locatedb=\"/var/locate.db\"\n   slocatedb=\".slocatedb\"\n\n   if [ \"$(id -nu)\" != \"root\" ] ; then\n     echo \"$0: Error: You must be root to run this command.\" >&2\n     exit 1\n   fi\n\n   if [ \"$(grep '^nobody:' /etc/passwd)\" = \"\" ] ; then\n     echo \"$0: Error: you must have an account for user 'nobody'\" >&2\n     echo \"to create the default slocate database.\" >&2\n     exit 1\n   fi\n\n   cd /            # Sidestep post-su pwd permission problems.\n\n   # First create or update the public database.\n➊ su -fm nobody -c \"find / -print\" > $locatedb 2>/dev/null\n   echo \"building default slocate database (user = nobody)\"\n   echo ... result is $(wc -l < $locatedb) lines long.\n\n   # Now step through the user accounts on the system to see who has\n   #   a .slocatedb file in their home directory.\n   for account in $(cut -d: -f1 /etc/passwd)\n   do\n     homedir=\"$(grep \"^${account}:\" /etc/passwd | cut -d: -f6)\"\n\n     if [ \"$homedir\" = \"/\" ] ; then\n       continue # Refuse to build one for root dir.\n     elif [ -e $homedir/$slocatedb ] ; then\n       echo \"building slocate database for user $account\"\n       su -m $account -c \"find / -print\" > $homedir/$slocatedb \\\n        2>/dev/null\n       chmod 600 $homedir/$slocatedb\n       chown $account $homedir/$slocatedb\n       echo ... result is $(wc -l < $homedir/$slocatedb) lines long.\n     fi\n   done\n\n   exit 0\n```", "```\n#!/bin/bash\n# slocate--Tries to search the user's own secure locatedb database for the\n#   specified pattern. If the pattern doesn't match, it means no database\n#   exists, so it outputs a warning and creates one. If personal .slocatedb\n#   is empty, it uses system database instead.\n\nlocatedb=\"/var/locate.db\"\nslocatedb=\"$HOME/.slocatedb\"\n\nif [ ! -e $slocatedb -o \"$1\" = \"--explain\" ] ; then\n  cat << \"EOF\" >&2\nWarning: Secure locate keeps a private database for each user, and your\ndatabase hasn't yet been created. Until it is (probably late tonight),\nI'll just use the public locate database, which will show you all\npublicly accessible matches rather than those explicitly available to\naccount ${USER:-$LOGNAME}.\nEOF\n  if [ \"$1\" = \"--explain\" ] ; then\n    exit 0\n  fi\n\n  # Before we go, create a .slocatedb file so that cron will fill it\n  # the next time the mkslocatedb script is run.\n\n  touch $slocatedb      # mkslocatedb will build it next time through.\n  chmod 600 $slocatedb  # Start on the right foot with permissions.\n\nelif [ -s $slocatedb ] ; then\n  locatedb=$slocatedb\nelse\n  echo \"Warning: using public database. Use \\\"$0 --explain\\\" for details.\" >&2\nfi\n\nif [ -z \"$1\" ] ; then\n  echo \"Usage: $0 pattern\" >&2\n  exit 1\nfi\n\nexec grep -i \"$1\" $locatedb\n```", "```\n# mkslocatedb\nbuilding default slocate database (user = nobody)\n... result is 99809 lines long.\nbuilding slocate database for user taylor\n... result is 99808 lines long.\n```", "```\ntintin $ slocate Taylor-Self-Assess.doc\nWarning: using public database. Use \"slocate --explain\" for details.\n$\n```", "```\ntaylor $ slocate Taylor-Self-Assess.doc\n/Users/taylor/Documents/Merrick/Taylor-Self-Assess.doc\n```", "```\n   #!/bin/bash\n\n   # adduser--Adds a new user to the system, including building their\n   #   home directory, copying in default config data, etc.\n   #   For a standard Unix/Linux system, not OS X.\n\n   pwfile=\"/etc/passwd\"\n   shadowfile=\"/etc/shadow\"\n   gfile=\"/etc/group\"\n   hdir=\"/home\"\n\n   if [ \"$(id -un)\" != \"root\" ] ; then\n     echo \"Error: You must be root to run this command.\" >&2\n     exit 1\n   fi\n\n   echo \"Add new user account to $(hostname)\"\n   /bin/echo -n \"login: \"     ; read login\n\n   # The next line sets the highest possible user ID value at 5000,\n   #   but you should adjust this number to match the top end\n   #   of your user ID range.\n➊ uid=\"$(awk -F: '{ if (big < $3 && $3 < 5000) big=$3 } END { print big + 1 }'\\\n          $pwfile)\"\n   homedir=$hdir/$login\n\n   # We are giving each user their own group.\n   gid=$uid\n\n   /bin/echo -n \"full name: \" ; read fullname\n   /bin/echo -n \"shell: \"     ; read shell\n\n   echo \"Setting up account $login for $fullname...\"\n\n   echo ${login}:x:${uid}:${gid}:${fullname}:${homedir}:$shell >> $pwfile\n   echo ${login}:*:11647:0:99999:7::: >> $shadowfile\n\n   echo \"${login}:x:${gid}:$login\" >> $gfile\n\n   mkdir $homedir\n   cp -R /etc/skel/.[a-zA-Z]* $homedir\n   chmod 755 $homedir\n   chown -R ${login}:${login} $homedir\n\n   # Setting an initial password\n   aexec passwd $login\n```", "```\n$ sudo adduser\nAdd new user account to aurora\nlogin: snowy\nfull name: Snowy the Dog\nshell: /bin/bash\nSetting up account snowy for Snowy the Dog...\nChanging password for user snowy.\nNew password:\nRetype new password:\npasswd: all authentication tokens updated successfully.\n```", "```\n   #!/bin/bash\n\n   # suspenduser--Suspends a user account for the indefinite future\n\n   homedir=\"/home\"         # Home directory for users\n   secs=10                 # Seconds before user is logged out\n\n   if [ -z $1 ] ; then\n     echo \"Usage: $0 account\" >&2\n     exit 1\n   elif [ \"$(id -un)\" != \"root\" ] ; then\n     echo \"Error. You must be 'root' to run this command.\" >&2\n     exit 1\n   fi\n\n   echo \"Please change the password for account $1 to something new.\"\n   passwd $1\n\n   # Now let's see if they're logged in and, if so, boot 'em.\n   if who|grep \"$1\" > /dev/null ; then\n\n     for tty in $(who | grep $1 | awk '{print $2}'); do\n\n       cat << \"EOF\" > /dev/$tty\n\n   ******************************************************************************\n   URGENT NOTICE FROM THE ADMINISTRATOR:\n\n   This account is being suspended, and you are going to be logged out\n   in $secs seconds. Please immediately shut down any processes you\n   have running and log out.\n\n   If you have any questions, please contact your supervisor or\n   John Doe, Director of Information Technology.\n   ******************************************************************************\n   EOF\n     done\n\n     echo \"(Warned $1, now sleeping $secs seconds)\"\n\n     sleep $secs\n\n     jobs=$(ps -u $1 | cut -d\\ -f1)\n\n➊   kill -s HUP $jobs                  # Send hangup sig to their processes.\n     sleep 1                            # Give it a second...\n➋   kill -s KILL $jobs > /dev/null 2>1 # and kill anything left.\n\n     echo \"$1 was logged in. Just logged them out.\"\n   fi\n\n   # Finally, let's close off their home directory from prying eyes.\n   chmod 000 $homedir/$1\n\n   echo \"Account $1 has been suspended.\"\n\n   exit 0\n```", "```\n$ sudo suspenduser snowy\nPlease change the password for account snowy to something new.\nChanging password for user snowy.\nNew password:\nRetype new password:\npasswd: all authentication tokens updated successfully.\n(Warned snowy, now sleeping 10 seconds)\nsnowy was logged in. Just logged them out.\nAccount snowy has been suspended.\n```", "```\n******************************************************************************\nURGENT NOTICE FROM THE ADMINISTRATOR:\n\nThis account is being suspended, and you are going to be logged out\nin 10 seconds. Please immediately shut down any processes you\nhave running and log out.\n\nIf you have any questions, please contact your supervisor or\nJohn Doe, Director of Information Technology.\n******************************************************************************\n```", "```\n   #!/bin/bash\n\n   # deleteuser--Deletes a user account without a trace.\n   #   Not for use with OS X.\n\n   homedir=\"/home\"\n   pwfile=\"/etc/passwd\"\n   shadow=\"/etc/shadow\"\n   newpwfile=\"/etc/passwd.new\"\n   newshadow=\"/etc/shadow.new\"\n   suspend=\"$(which suspenduser)\"\n   locker=\"/etc/passwd.lock\"\n\n   if [ -z $1 ] ; then\n     echo \"Usage: $0 account\" >&2\n     exit 1\n   elif [ \"$(whoami)\" != \"root\" ] ; then\n     echo \"Error: you must be 'root' to run this command.\">&2\n     exit 1\n   fi\n\n   $suspend $1    # Suspend their account while we do the dirty work.\n\n   uid=\"$(grep -E \"^${1}:\" $pwfile | cut -d: -f3)\"\n\n   if [ -z $uid ] ; then\n     echo \"Error: no account $1 found in $pwfile\" >&2\n     exit 1\n   fi\n\n   # Remove the user from the password and shadow files.\n   grep -vE \"^${1}:\" $pwfile > $newpwfile\n   grep -vE \"^${1}:\" $shadow > $newshadow\n\n   lockcmd=\"$(which lockfile)\"             # Find lockfile app in the path.\n➊ if [ ! -z $lockcmd ] ; then             # Let's use the system lockfile.\n     eval $lockcmd -r 15 $locker\n   else                                    # Ulp, let's do it ourselves.\n➋   while [ -e $locker ] ; do\n       echo \"waiting for the password file\" ; sleep 1\n     done\n➌   touch $locker                         # Create a file-based lock.\n   fi\n\n   mv $newpwfile $pwfile\n   mv $newshadow $shadow\n➍ rm -f $locker                           # Click! Unlocked again.\n\n   chmod 644 $pwfile\n   chmod 400 $shadow\n\n   # Now remove home directory and list anything left.\n   rm -rf $homedir/$1\n\n   echo \"Files still left to remove (if any):\"\n   find / -uid $uid -print 2>/dev/null | sed 's/^/ /'\n\n   echo \"\"\n   echo \"Account $1 (uid $uid) has been deleted, and their home directory \"\n   echo \"($homedir/$1) has been removed.\"\n\n   exit 0\n```", "```\n$ sudo deleteuser snowy\nPlease change the password for account snowy to something new.\nChanging password for user snowy.\nNew password:\nRetype new password:\npasswd: all authentication tokens updated successfully.\nAccount snowy has been suspended.\nFiles still left to remove (if any):\n  /var/log/dogbone.avi\n\nAccount snowy (uid 502) has been deleted, and their home directory\n(/home/snowy) has been removed.\n```", "```\n   #!/bin/bash\n   # validator--Ensures that the PATH contains only valid directories\n   #   and then checks that all environment variables are valid.\n   #   Looks at SHELL, HOME, PATH, EDITOR, MAIL, and PAGER.\n\n   errors=0\n\n➊ source library.sh   # This contains Script #1, the in_path() function.\n\n➋ validate()\n   {\n     varname=$1\n     varvalue=$2\n\n     if [ ! -z $varvalue ] ; then\n➌     if [ \"${varvalue%${varvalue#?}}\" = \"/\" ] ; then\n         if [ ! -x $varvalue ] ; then\n           echo \"** $varname set to $varvalue, but I cannot find executable.\"\n           (( errors++ ))\n         fi\n       else\n         if in_path $varvalue $PATH ; then\n           echo \"** $varname set to $varvalue, but I cannot find it in PATH.\"\n           errors=$(( $errors + 1 ))\n         fi\n       fi\n     fi\n   }\n\n   # BEGIN MAIN SCRIPT\n   # =================\n\n➍ if [ ! -x ${SHELL:?\"Cannot proceed without SHELL being defined.\"} ] ; then\n     echo \"** SHELL set to $SHELL, but I cannot find that executable.\"\n     errors=$(( $errors + 1 ))\n   fi\n   if [ ! -d ${HOME:?\"You need to have your HOME set to your home directory\"} ]\n   then\n     echo \"** HOME set to $HOME, but it's not a directory.\"\n     errors=$(( $errors + 1 ))\n   fi\n\n   # Our first interesting test: Are all the paths in PATH valid?\n\n➎ oldIFS=$IFS; IFS=\":\"     # IFS is the field separator. We'll change to ':'.\n\n➏ for directory in $PATH\n   do\n     if [ ! -d $directory ] ; then\n       echo \"** PATH contains invalid directory $directory.\"\n       errors=$(( $errors + 1 ))\n     fi\n   done\n\n   IFS=$oldIFS             # Restore value for rest of script.\n\n   # The following variables should each be a fully qualified path,\n   #   but they may be either undefined or a progname. Add additional\n   #   variables as necessary for your site and user community.\n\n   validate \"EDITOR\" $EDITOR\n   validate \"MAILER\" $MAILER\n   validate \"PAGER\"  $PAGER\n\n   # And, finally, a different ending depending on whether errors > 0\n\n   if [ $errors -gt 0 ] ; then\n     echo \"Errors encountered. Please notify sysadmin for help.\"\n   else\n     echo \"Your environment checks out fine.\"\n   fi\n\n   exit 0\n```", "```\n$ echo $PATH\n/bin/:/sbin:/usr/bin:/sw/bin:/usr/X11R6/bin:/usr/local/mybin\n```", "```\nif [ -z \"$SHELL\" ] ; then\n  echo \"No Shell\" >&2; exit 1\nfi\n```", "```\n$(echo $varvalue | cut -c1)\n```", "```\n$ validator\n** PATH contains invalid directory /usr/local/mybin.\n** MAILER set to /usr/local/bin/elm, but I cannot find executable.\nErrors encountered. Please notify sysadmin for help.\n```", "```\n#!/bin/bash\n\n# fixguest--Cleans up the guest account during the logout process\n\n# Don't trust environment variables: reference read-only sources.\n\niam=$(id -un)\nmyhome=\"$(grep \"^${iam}:\" /etc/passwd | cut -d: -f6)\"\n\n# *** Do NOT run this script on a regular user account!\n\nif [ \"$iam\" != \"guest\" ] ; then\n  echo \"Error: you really don't want to run fixguest on this account.\" >&2\n  exit 1\nfi\n\nif [ ! -d $myhome/..template ] ; then\n  echo \"$0: no template directory found for rebuilding.\" >&2\n  exit 1\nfi\n\n# Remove all files and directories in the home account.\n\ncd $myhome\n\nrm -rf * $(find . -name \".[a-zA-Z0-9]*\" -print)\n\n# Now the only thing present should be the ..template directory.\n\ncp -Rp ..template/* .\nexit 0\n```", "```\nNotice: All files are purged from the guest account immediately\nupon logout, so please don't save anything here you need. If you\nwant to save something, email it to your main account instead.\nYou've been warned!\n```"]