- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EvilQuest’s Infection, Triage, and Deobfuscation
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: EvilQuest is a complex Mac malware specimen. Because it employs anti-analysis
    logic, a viral persistence mechanism, and insidious payloads, it’s practically
    begging to be analyzed. Let’s apply the skills you’ve gained from this book to
    do just that!
  prefs: []
  type: TYPE_NORMAL
- en: This chapter begins our comprehensive analysis of the malware by detailing its
    infection vector, triaging its binary, and identifying its anti-analysis logic.
    Chapter 11 will continue our analysis by covering the malware’s methods of persistence
    and its myriad of capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The Infection Vector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much like a biological virus, identifying a specimen’s infection vector is frequently
    the best way to understand its potential impact and thwart its continued spread.
    So, when you’re analyzing a new malware specimen, one of your first goals is answering
    the question, “How does the malware infect Mac systems?”
  prefs: []
  type: TYPE_NORMAL
- en: As you saw in Chapter 1, malware authors employ a variety of tactics, ranging
    from unsophisticated social engineering attacks to powerful zero-day exploits,
    to infect Mac users. Dinesh Devadoss, the researcher who discovered EvilQuest,
    did not specify how the malware was able to infect Mac users.^([1](#c10-endnote-1))
    However, another researcher, Thomas Reed, later noted that the malware had been
    found in pirated versions of popular macOS software shared on torrent sites. Specifically,
    he wrote about
  prefs: []
  type: TYPE_NORMAL
- en: an apparently malicious Little Snitch installer available for download on a
    Russian forum dedicated to sharing torrent links. A post offered a torrent download
    for Little Snitch, and was soon followed by a number of comments that the download
    included malware. In fact, we discovered that not only was it malware, but a new
    Mac ransomware variant spreading via piracy.^([2](#c10-endnote-2))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Distributing pirated or cracked applications that have been maliciously trojanized
    is a fairly common method of targeting macOS users for infection. Though not the
    most sophisticated approach, it is rather effective, as many users have a distaste
    for paid software and instead seek out pirated alternatives. [Figure 10-1](#figure10-1)
    shows the download link for the malicious Little Snitch software.
  prefs: []
  type: TYPE_NORMAL
- en: '![The webpage for pirating Little Snitch contains information about the software,
    such as the year—2020—the version, developer, description, and so on. At the bottom
    of the screen is a link to “Download the distribution by magnet link (59.3 MB).”
    Beneath the link is a warning: “Your Internet Provider and Government can see
    what you are downloading. Don’t forget to hide your IP with VPN to avoid fines
    and lawsuits!” Links to NordVPN, ExpressVPN, and others are directly below.](image_fi/501942c10/f10001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-1: Pirated version of Little Snitch trojanized with EvilQuest'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this infection vector requires user interaction. Specifically, in
    order to become infected with EvilQuest, users would have to download and run
    an infected application. Moreover, as you’ll see, the malware’s installer package
    is unsigned, so users on recent versions of macOS may have to proactively take
    steps to bypass system notarization checks.
  prefs: []
  type: TYPE_NORMAL
- en: In an attempt to infect as many Mac users as possible, the malware authors surreptitiously
    trojanized many different pirated applications distributed via torrent sites.
    In this chapter, we’ll focus on a sample that was maliciously packaged up with
    the popular DJ application Mixed In Key.^([3](#c10-endnote-3))
  prefs: []
  type: TYPE_NORMAL
- en: Triage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that an application is actually a special directory structure called
    a *bundle* that must be packaged up before being distributed. The sample of EvilQuest
    we’re analyzing here was distributed as a disk image, *Mixed In Key 8.dmg*. As
    shown in [Figure 10-2](#figure10-2), when first discovered, this sample’s SHA-256
    hash (B34738E181A6119F23E930476AE949FC0C7C4DED6EFA003019FA946C4E5B287A) was not
    flagged as malicious by any of the antivirus engines on the aggregate scanning
    site VirusTotal.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mixed In Key 8.dmg is shown to have a score of 0/58 on VirusTotal.](image_fi/501942c10/f10002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-2: The trojanized *Mixed* *In* *Key 8.dmg* file on VirusTotal'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, today this disk image is widely detected as containing malware.
  prefs: []
  type: TYPE_NORMAL
- en: Confirming the File Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As analysis tools are often file-type specific and malware authors may attempt
    to mask the true file type of their malicious creations, it is wise to first determine
    or confirm a file’s true type when you are presented with a potentially malicious
    specimen. Here we attempt to use the `file` utility to confirm that the trojanized
    *Mixed In Key 8.dmg* is indeed a disk image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Oops, looks like the `file` utility misidentified the file as something other
    than a disk image. This is unsurprising, as disk images compressed with zlib are
    often reported as “VAX COFF” due to the zlib header.^([4](#c10-endnote-4))
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try again, this time using my WhatsYourSign (WYS) utility, which shows
    an item’s code-signing information and more accurately identifies the item’s file
    type. As you can see in [Figure 10-3](#figure10-3), the tool’s Item Type field
    confirms that *Mixed In Key 8.dmg* is indeed a disk image, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '![In the WhatsYourSign tool, Mixed In Key 8.dmg contains the following information:
    “Item Type: Disk Image,” “Entitled: None,” and “Sign Auths: unsigned (‘errSecCSUnsigned’).”](image_fi/501942c10/f10003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-3: WYS confirms the item as a disk image'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the Contents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we’ve confirmed that this *.dmg* file is indeed a disk image, our next
    task is to extract the disk image’s contents for analysis. Using macOS’s built-in
    `hdiutil` utility, we can mount the disk image to access its files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this command has completed, the disk image will be mounted to */Volumes/Mixed
    In Key 8/*. Listing the contents of this directory reveals a single file, *Mixed
    In Key 8.pkg*, which appears to be an installer package ([Listing 10-1](#listing10-1)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-1: Listing the mounted disk image’s contents'
  prefs: []
  type: TYPE_NORMAL
- en: We again turn to WYS to confirm that the *.pkg* file is indeed a package, and
    also to check the package’s signing status. As you can see in [Figure 10-4](#figure10-4),
    the *.pkg* file type is confirmed, though the package is unsigned.
  prefs: []
  type: TYPE_NORMAL
- en: '![In the WhatsYourSign tool, Mixed In Key 8.dmg shows the following information:
    “Item Type: Installer package archive,” “Entitled: none,” “Sign Auths: unsigned
    (‘errSecCSUnsigned’).”](image_fi/501942c10/f10004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-4: WYS confirms the item as an unsigned package'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also check any package signatures (or lack thereof) from the terminal
    with the `pkgutil` utility. Just pass in `--check-signature` and the path to the
    package, as shown in [Listing 10-2](#listing10-2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-2: Checking the package’s signature'
  prefs: []
  type: TYPE_NORMAL
- en: As the package is unsigned, macOS will prompt the user before allowing it to
    be opened. However, users attempting to pirate software will likely ignore this
    warning, pressing onwards and inadvertently commencing the infection.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Chapter 4 we discussed using the Suspicious Package utility to explore the
    contents of installer packages. Here we’ll use it to open *Mixed In Key 8.pkg*
    ([Figure 10-5](#figure10-5)). In the All Files tab, we’ll find an application
    named *Mixed In Key 8.app* and an executable file simply named *patch*.
  prefs: []
  type: TYPE_NORMAL
- en: '![In the Suspicious Package tool, Mixed In Key 8.dmg is shown to contain an
    Applications folder with the Mixed In Key 8.app file and a Utils folder that contains
    an executable file named Patch.](image_fi/501942c10/f10005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-5: Using Suspicious Package to explore files within the trojanized
    *Mixed in Key* package'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll triage these files shortly, but first we should check for any pre- or
    post-install scripts. Recall that when a package is installed, any such scripts
    will also be automatically executed. As such, if an installer package contains
    malware, you’ll often find malicious installer logic within these scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking the **All Scripts** tab reveals that *Mixed In Key 8.pkg* does contain
    a post-install script ([Listing 10-3](#listing10-3)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-3: *Mixed* *In* *Key 8.pkg*’s post-install script'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the trojanized *Mixed In Key 8.pkg* is installed, the script will be executed
    and performs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory named */Library/mixednkey*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the *patch* binary (which was installed to */Applications/Utils/patch*)
    into the newly created */Library/mixednkey* directory as a binary named *toolroomd*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attempt to delete the */Applications/Utils/* directory (created earlier in the
    install process). However, due to a bug in the command (the malware author missed
    the “s” in */Applications*), this will fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the *toolroomd* binary to be executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the *toolroomd* binary in the background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The installer requests root privileges during the install, so if the user provides
    the necessary credentials, this post-install script will also run with elevated
    privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Through dynamic analysis monitoring tools, such as my ProcessMonitor and FileMonitor,
    we can passively observe this installation process, including the execution of
    the post-install script and the script’s commands ([Listing 10-4](#listing10-4)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-4: Monitoring the actions of the malicious post-install script'
  prefs: []
  type: TYPE_NORMAL
- en: In this abridged output from ProcessMonitor, you can see various commands from
    the post-install script, such as `mkdir` and `mv`, being executed as the malware
    is installed. Most notably, observe that at its completion the script executes
    the malware, now installed as *toolroomd* 1.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now extract both the *Mixed In Key 8* application and *patch* binary from
    the package using Suspicious Package by exporting each file. First, let’s take
    a peek at the *Mixed In Key 8* application. By using WYS, we can see that it is
    still validly signed by the Mixed In Key developers ([Figure 10-6](#figure10-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![In the WhatsYourSign tool, Mixed In Key 8.app is declared to be “validly
    signed,” with the signer listed as “Apple Dev-ID.” More information is available
    under sign auth: “Developer ID Application: Mixed In Key, LLC (T4A2E2DEM7),” “Developer
    ID Certification Authority,” “Apple Root CA.”](image_fi/501942c10/f10006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-6: The still validly signed application (via WYS)'
  prefs: []
  type: TYPE_NORMAL
- en: Confirming the validity of an item’s code-signing signature tells us that it
    has not been modified or tampered with since being signed.
  prefs: []
  type: TYPE_NORMAL
- en: Could the malware authors have compromised Mixed In Key, stolen its code-signing
    certificate, surreptitiously modified the application, and then re-signed it?
    Fair question, and the answer is that it’s possible, though highly unlikely. If
    this were the case, the malware authors probably wouldn’t have had to resort to
    such an unsophisticated infection mechanism (distributing the software via shady
    torrent sites), nor would they have had to include another unsigned binary in
    the package.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the main application remains validly signed by the developers, let’s turn
    our attention to the *patch* file. As you’ll see shortly, this is the malware.
    (Recall that it gets installed as a file called *toolroomd.*) Using the `file`
    utility we can determine that it is a 64-bit Mach-O binary, and the `codesign`
    utility indicates that it is unsigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As *patch* is a binary rather than, say, a script, we’ll continue our analysis
    by leveraging static analysis tools that are either file-type agnostic or specifically
    tailored toward binary analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting Embedded Information from the patch Binary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we’ll run the `strings` utility to extract any embedded ASCII strings,
    as these strings can often provide valuable insight into the malware’s logic and
    capabilities. Note that I’ve reordered the output for convenience ([Listing 10-5](#listing10-5)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-5: Extracting embedded strings'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the embedded strings reveals strings that appear to be command line
    arguments (like `--silent`), networking requests (like `GET /%s HTTP/1.0`), potential
    file-encryption logic (like `_generate_xkey`), and key mappings (like `[right-cmd]`),
    possibly indicating the presence of keylogging logic. We also uncover a path that
    contains a directory name (*toidievitceffe*) that unscrambles to “effectiveidiot.”
    Our continued analysis will soon reveal other strings and function names containing
    the abbreviation “ei” (such as `EI_RESCUE` and `ei_loader_main`). It seems likely
    that “effectiveidiot” is the moniker given to the malware by its developers.
  prefs: []
  type: TYPE_NORMAL
- en: The output from the `strings` utility reveals a large number of embedded strings
    (like `2Uy5DI3hMp7o0cq|T|14vHRz0000013`) that appear obfuscated. These nonsensical
    strings likely indicate that EvilQuest employs anti-analysis. Shortly we’ll break
    this anti-analysis logic to deobfuscate all such strings. First, though, let’s
    statically extract more information from the malware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that macOS’s built-in `nm` utility can extract embedded information,
    such as function names and system APIs invoked by the malware. Like the output
    of the `strings` utility, this information can provide insight into the malware’s
    capabilities and guide continued analysis. Let’s run `nm` on the *patch* binary,
    as in [Listing 10-6](#listing10-6). Again, I’ve reordered the output for convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-6: Extracting embedded names (API calls, functions, and so on)'
  prefs: []
  type: TYPE_NORMAL
- en: First we see references to system APIs, such as `CGEventTapCreate` and `CGEventTapEnable`,
    often leveraged to capture user keypresses, as well as `NSCreateObjectFileImageFromMemory`
    and `NSLinkModule`, which can be used to execute binary payloads in memory. The
    output also contains a long list of function names that map directly back to the
    malware’s original source code. Unless these are named incorrectly to mislead
    us, they can provide insight into many aspects of the malware. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '`is_debugging`, `is_virtual_mchn`, and `prevent_trace` may indicate that the
    malware implements dynamic-analysis-thwarting logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_host_identifier` and `get_process_list` may indicate host survey capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`persist_executable` and `install_daemon` likely relate to how the malware
    persists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eib_secure_decode` and `eib_string_key` may be responsible for decoding the
    obfuscated strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_targets`, `is_target`, and `eip_encrypt` could contain the malware’s purported
    ransomware logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `react_*` functions (such as `react_exec`) possibly contain the logic to
    execute remote commands from the attacker’s command and control server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, we should verify this functionality during static or dynamic analysis.
    However, these names alone can help focus our continued analysis. For example,
    it would be wise to statically analyze what appear to be various anti-analysis
    functions before beginning a debugging session, as those functions may attempt
    to thwart the debugger and thus would need to be bypassed.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the Command Line Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Armed with the myriad of intriguing information collected during our static
    analysis triage, it’s time to dig a little deeper. We can disassemble the *patch*
    binary by loading it into a disassembler, such as Hopper. A quick triage of the
    disassembler code reveals that the core logic of the *patch* binary occurs within
    its main function, which is rather extensive. First the binary parses any command
    line parameters looking for `--silent`, `--noroot`, and `--ignrp`. If these command
    line arguments are present, various flags are set. If we then analyze code that
    references these flags, we can ascertain their meaning.
  prefs: []
  type: TYPE_NORMAL
- en: --silent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If `--silent` is passed in via the command line, the malware sets a global variable
    to 0\. This appears to instruct the malware to run “silently,” for example suppressing
    the printing of error messages. In the following snippet of disassembly, the value
    of a variable (which I’ve named `silent` below) is first checked via the `cmp`
    instruction. If it is set, the malware will jump over the call to the `printf`
    function so that an error message is not displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This flag is also passed to the `ei_rootgainer_main` function, which influences
    how the malware (running as a normal user) may request root privileges. Note,
    in the following disassembly, that the address of the flag is loaded into the
    `RDX` register, which holds the third argument in the context of a function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, this flag is explicitly initialized to 0 (and set to 0 again
    if the `--silent` parameter is specified). It appears to never be set to 1 (true).
    Thus, the malware will always run in “silent” mode, even if `--silent` is not
    specified. It’s possible that, in a debug build of the malware, the flag could
    be initialized to 1 as the default value.
  prefs: []
  type: TYPE_NORMAL
- en: To acquire root privileges, the `ei_rootgainer_main` function calls into a helper
    function, `run_as_admin_async`, to execute the following (originally encrypted)
    command, substituting itself for the `%s`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This results in an authentication prompt from the macOS built-in `osascript`
    ([Figure 10-7](#figure10-7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![The authentication prompt states, “osascript wants to make changes. Enter
    your password to allow this.”](image_fi/501942c10/f10007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-7: The malware’s authentication prompt, via `osascript`'
  prefs: []
  type: TYPE_NORMAL
- en: If the user provides appropriate credentials, the malware will have gained root
    privileges.
  prefs: []
  type: TYPE_NORMAL
- en: --noroot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If `--noroot` is passed in via the command line, the malware sets another flag
    to 1 (true). Various code within the malware then checks this flag and, if it
    is set, takes different actions, such as skipping the request for root privileges.
    In the snippet of disassembled code, note that if the flag (initially `var_20`
    but named `noRoot` here) is set, the call to the `ei_rootgainer_main` function
    is skipped.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--noroot` argument is also passed to a persistence function, `ei_persistence_main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Subsequent analysis of this function reveals that this flag dictates how the
    malware persists; either as a launch daemon or a launch agent. Recall that persisting
    as a launch daemon requires root privileges, whereas persisting as a launch agent
    requires only user privileges.
  prefs: []
  type: TYPE_NORMAL
- en: --ignrp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If `--ignrp` (“ignore persistence”) is passed in via the command line, the malware
    sets a flag to 1 and instructs itself not to manually start any persisted launch
    items.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can confirm this by examining disassembled code in the `ei_selfretain_main`
    function, which contains logic to load persisted components. This function first
    checks the flag (named `ignorePersistence` here) and, if it’s not set, the function
    simply returns without loading the persisted items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that, even if the `--ignrp` command line option is specified, the malware
    itself will still persist and thus be automatically restarted each time an infected
    system is rebooted or the user logs in.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing Anti-Analysis Logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a malicious sample contains anti-analysis logic, we must identify and thwart
    it to continue our analysis. Luckily for us, other than what appear to be encrypted
    strings, EvilQuest does not seem to employ any methods that will hinder our static
    analysis efforts. However, we’re not so lucky when it comes to dynamic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: As noted in Chapter 9, a sample prematurely exiting when run in a virtual machine
    or debugger likely indicates that some sort of dynamic anti-analysis logic was
    triggered. If you try to run EvilQuest in a debugger, you’ll notice that it simply
    terminates. This isn’t surprising; recall that the malware contains functions
    with names such as `is_debugging` and `prevent_trace`. A function named `is_virtual_mchn`
    is also invoked before these likely anti-debugger functions. Let’s begin our analysis
    of what appears to be the malware’s anti-analysis logic there.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Machine–Thwarting Logic?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In your disassembler, take a look at `0x000000010000be5f` in the main function.
    Once the malware has processed any command line options, it invokes a function
    named `is_virtual_mchn`. As shown in the following snippet of decompiled code,
    the malware will prematurely exit if this function returns a nonzero value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a closer look at the decompilation of this function ([Listing 10-7](#listing10-7)),
    as we want to ensure the malware runs (or can be coerced to run) in a virtual
    machine, such that we can analyze it dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-7: Anti-sandbox check, through time checks'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the decompilation of `is_virtual_mchn`, the `time` function
    is invoked twice, with a call to `sleep` in between. It then compares the differences
    between the two calls to `time` to match the amount of time that the code slept
    for. This allows it to detect sandboxes that patch, or speed up, calls to `sleep`.
    As security researcher Clemens Kolbitsch has noted,
  prefs: []
  type: TYPE_NORMAL
- en: Sandboxes will patch the sleep function to try to outmaneuver malware that uses
    time delays. In response, malware will check to see if time was accelerated. Malware
    will get the timestamp, go to sleep and then again get the timestamp when it wakes
    up. The time difference between the timestamps should be the same duration as
    the amount of time the malware was programmed to sleep. If not, then the malware
    knows it is running in an environment that is patching the sleep function, which
    would only happen in a sandbox.^([5](#c10-endnote-5))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This means that, in reality, the `is_virtual_mchn` function is more of a sandbox
    check and will not actually detect a standard virtual machine, which doesn’t manipulate
    any time constructs. That’s good news for our continued analysis of the malware,
    which occurs within an isolated virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging-Thwarting Logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We also need to discuss the other anti-analysis mechanisms employed by the
    malware, as this logic could thwart our dynamic analysis efforts later. Recall
    that in the output of the `strings` utility, we saw what appeared to be anti-debugging
    functions: `is_debugging` and `prevent_trace`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `is_debugging` function is implemented at address `0x0000000100007aa0`.
    Looking at a snippet of annotated disassembly of this function in [Listing 10-8](#listing10-8),
    we see the malware invoking the `sysctl` function with `CTL_KERN`, `KERN_PROC`,
    `KERN_PROC_PID`, and its PID, obtained via the `getpid()` API function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-8: The start of anti-debugging logic, via the `sysctl` API'
  prefs: []
  type: TYPE_NORMAL
- en: Once the `sysctl` function has returned, the malware checks the `p_flag` member
    of the `info.kp_proc` structure populated by the call to `sysctl` to see whether
    it has the `P_TRACED` flag set ([Listing 10-9](#listing10-9)). As this flag is
    only set if the process is being debugged, the malware can use it to determine
    if it is being debugged.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-9: Is the `P_TRACED` flag (`0x800`) set? If so, the process is being
    debugged.'
  prefs: []
  type: TYPE_NORMAL
- en: If the `is_debugging` function detects a debugger, it returns a nonzero value,
    as shown in [Listing 10-10](#listing10-10)’s full reconstruction, which I’ve based
    on the decompilation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-10: Anti-debugging logic that uses `sysctl` and `P_TRACED`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code such as the `ei_persistence_main` function invokes the `is_debugging`
    function and promptly terminates if a debugger is detected ([Listing 10-11](#listing10-11)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-11: A premature exit if a debugger is detected'
  prefs: []
  type: TYPE_NORMAL
- en: To circumvent this anti-analysis logic, we can either modify EvilQuest’s binary
    and patch out this code or use a debugger to subvert the malware’s execution state
    in memory. If you wanted to modify the code, you could replace the `cmovnz` instruction
    (at `0x0000000100007b7a`) with an instruction such as `xor eax, eax` to zero out
    the return value from the function. As this replacement instruction is one byte
    less than the `cmovnz`, you’ll have to add a one-byte NOP instruction for padding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The debugging approach proves more straightforward, as we can simply zero out
    the return value from the `is_debugging` function. Specifically, we can first
    set a breakpoint on the instruction immediately following the call to the `is_debugging`
    function (`0x000000010000b89f`), which checks the return value via `cmp eax, 0x0`.
    Once the breakpoint is hit, we can set the `RAX` register to 0 with `reg write
    $rax 0`, leaving the malware blind to the fact that it’s being debugged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We’re not quite done yet, as the malware also contains a function named `prevent_trace`,
    which, as the name suggests, attempts to prevent tracing via a debugger. [Listing
    10-12](#listing10-12) shows the complete annotated disassembly of the function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-12: Anti-debugging logic via the `ptrace` API'
  prefs: []
  type: TYPE_NORMAL
- en: After invoking the `getpid` function to retrieve its process ID, the malware
    invokes `ptrace` with the `PT_DENY_ATTACH` flag (`0x1f`) 1. As noted in the previous
    chapter, this hinders debugging in two ways. First of all, once this call has
    been made, any attempt to attach a debugger will fail. Secondly, if a debugger
    is already attached, the process will immediately terminate after this call is
    made.
  prefs: []
  type: TYPE_NORMAL
- en: To subvert this logic so that the malware can be debugged to facilitate continued
    analysis, we again leverage the debugger to avoid the call to `prevent_trace`
    altogether. First we set a breakpoint at `0x000000010000b8b2`, which is a call
    that invokes this function. Once the breakpoint is hit, we modify the value of
    the instruction pointer (`RIP`) to point to the next instruction (at `0x000000010000b8b7`).
    This ensures the problematic call to `ptrace` is never executed.
  prefs: []
  type: TYPE_NORMAL
- en: Continued analysis reveals that all of EvilQuest’s anti-debugger functions are
    invoked from within a single function (`ei_persistence_main`). Thus, we can actually
    set a single breakpoint within the `ei_persistence_main` function and then modify
    the instruction pointer to jump past both anti-debugging calls. However, as the
    `ei_persistence_main` function is called multiple times, our breakpoint would
    be hit multiple times, requiring us to manually modify `RIP` each time. A more
    efficient approach would be to add a command to this breakpoint to instruct the
    debugger to automatically both modify `RIP` when the breakpoint is hit and then
    continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let’s set a breakpoint at the `call is_debugging` instruction (found
    at `0x000000010000b89a`). Once the breakpoint is set we add a breakpoint command
    via `br command add`. In this command we can instruct the debugger to modify `RIP`,
    setting it to the address immediately following the call to the second anti-debugging
    function, `prevent_trace` (`0x000000010000b8b7`), as shown in [Listing 10-13](#listing10-13):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-13: Bypassing anti-debugging logic with a breakpoint command'
  prefs: []
  type: TYPE_NORMAL
- en: As we also added `continue` to our breakpoint command, the debugger will automatically
    continue execution once the instruction pointer has been modified. Once the breakpoint
    command has been added, both the call to `is_debugging` and the `prevent_trace`
    anti-debugging functions will be automatically skipped. With EvilQuest’s anti-analysis
    logic fully thwarted, our analysis can continue uninhibited.
  prefs: []
  type: TYPE_NORMAL
- en: Obfuscated Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Back in the main function, the malware gathers some basic user information,
    such as the value of the `HOME` environment variable, and then it invokes a function
    named `extract_ei`. This function attempts to read `0x20` bytes of “trailer” data
    from the end of its on-disk binary image. However, as a function named `unpack_trailer`
    (invoked by `extract_ei`) returns 0 (false), a check for the magic value of `0xdeadface`
    fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Subsequent analysis will soon uncover the fact that the `0xdeadface` value is
    placed at the end of other binaries the malware infects. In other words, this
    is the malware checking whether it is running via a host binary that has been
    (locally) virally infected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function returning 0 causes the malware to skip certain repersistence logic
    that appears to persist the malware as a daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It appears that various values of interest to us, such as the likely name and
    path of the daemon, are obfuscated 1. As these obfuscated strings, and others
    in the code snippet, are all passed to the `ei_str` function, it seems reasonable
    to assume that this is the function responsible for string deobfuscation ([Listing
    10-14](#listing10-14)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-14: Obfuscated strings, passed to the `ei_str` function'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we should verify our assumptions. Take a closer look at the decompilation
    of the `ei_str` function in [Listing 10-15](#listing10-15):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-15: The `ei_str` function, decompiled'
  prefs: []
  type: TYPE_NORMAL
- en: This reveals a one-time initialization of a global variable named `eib_string_key`
    1, followed by a call into a function named `eib_secure_decode` 2, which then
    calls a method named `tpdcrypt`. The decompilation also reveals that the `ei_str`
    function takes a single parameter (the obfuscated string) and returns its deobfuscated
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted in Chapter 9, we don’t actually have to concern ourselves with the
    details of the deobfuscation or decryption algorithm. We can simply set a debugger
    breakpoint at the end of the `ei_str` function and print out the deobfuscated
    string held in the `RAX` register. This is illustrated below, where after setting
    a breakpoint at the start and end of the `ei_str` function, we are able to print
    out both the obfuscated string (`"1bGvIR16wpmp1uNjl83EMxn43AtszK1T6...HRCIR3TfHDd0000063"`)
    and its deobfuscated value, a template for the malware’s launch item persistence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The downside to this approach is that we’ll only decrypt strings when the malware
    invokes the `ei_str` function and our debugger breakpoint is hit. Thus, if an
    encrypted string is only referenced in blocks of code that aren’t executed, such
    as the persistence logic that is only invoked when the malware is executed from
    within an infected file, we won’t ever see its decrypted value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For analysis purposes, it would be useful to coerce the malware to decrypt
    all these strings for us. Recall that in the last chapter we created an injectable
    dynamic library capable of exactly this. Specifically, once loaded into EvilQuest,
    it first resolves the address of the malware’s `ei_str` function and then invokes
    this function on all of the obfuscated strings embedded in the malware. In the
    last chapter, we showed an excerpt of this library’s output. [Listing 10-16](#listing10-16)
    shows it in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-16: Decrypting all EvilQuest’s embedded strings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the decrypted output, we find many revealing strings:'
  prefs: []
  type: TYPE_NORMAL
- en: The addresses of servers, potentially used for command and control, like *andrewka6.pythonanywhere.com*
    and *167.71.237.219*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions perhaps pertaining to files of interest relating to keys,
    certificates, and wallets, like `*id_rsa*/i`, `*key*.pdf/i`, `*wallet*.pdf`, and
    so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An embedded property list file likely used for launch item persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Names of security products such as Little Snitch and Kaspersky
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Decryption instructions and file extensions for reported ransomware logic of
    the malware to target: *.zip*, *.doc*, *.txt*, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These decrypted strings provide more insight into many facets of the malware
    and will aid us in our continued analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Up Next
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter we triaged EvilQuest and identified its anti-analysis code aimed
    at hampering analysis. We then looked at how to effectively sidestep this code
    so that our analysis could continue. In the next chapter we’ll continue our study
    of this complex malware, detailing its persistence and its multitude of capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Endnotes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
