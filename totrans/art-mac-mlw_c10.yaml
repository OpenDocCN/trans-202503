- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: EvilQuest’s Infection, Triage, and Deobfuscation
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: EvilQuest 的感染、分类和去混淆
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: EvilQuest is a complex Mac malware specimen. Because it employs anti-analysis
    logic, a viral persistence mechanism, and insidious payloads, it’s practically
    begging to be analyzed. Let’s apply the skills you’ve gained from this book to
    do just that!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: EvilQuest 是一个复杂的 Mac 恶意软件样本。因为它使用了反分析逻辑、病毒持久性机制和隐秘的有效载荷，它几乎是刻意让人分析的。让我们运用你从本书中学到的技巧来进行分析吧！
- en: This chapter begins our comprehensive analysis of the malware by detailing its
    infection vector, triaging its binary, and identifying its anti-analysis logic.
    Chapter 11 will continue our analysis by covering the malware’s methods of persistence
    and its myriad of capabilities.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始了对恶意软件的全面分析，详细描述了它的感染途径、分类它的二进制文件，并识别了其反分析逻辑。第 11 章将继续我们的分析，介绍恶意软件的持久性方法及其众多功能。
- en: The Infection Vector
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 感染途径
- en: Much like a biological virus, identifying a specimen’s infection vector is frequently
    the best way to understand its potential impact and thwart its continued spread.
    So, when you’re analyzing a new malware specimen, one of your first goals is answering
    the question, “How does the malware infect Mac systems?”
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 就像生物病毒一样，识别一个样本的感染途径通常是了解其潜在影响并阻止其继续传播的最佳方法。因此，当你分析一个新的恶意软件样本时，首先要回答的问题之一就是：“恶意软件是如何感染
    Mac 系统的？”
- en: As you saw in Chapter 1, malware authors employ a variety of tactics, ranging
    from unsophisticated social engineering attacks to powerful zero-day exploits,
    to infect Mac users. Dinesh Devadoss, the researcher who discovered EvilQuest,
    did not specify how the malware was able to infect Mac users.^([1](#c10-endnote-1))
    However, another researcher, Thomas Reed, later noted that the malware had been
    found in pirated versions of popular macOS software shared on torrent sites. Specifically,
    he wrote about
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第一章中看到的，恶意软件作者使用了各种策略，从不太复杂的社交工程攻击到强大的零日漏洞，来感染 Mac 用户。发现 EvilQuest 的研究员
    Dinesh Devadoss 并没有具体说明恶意软件是如何感染 Mac 用户的。^([1](#c10-endnote-1)) 然而，另一位研究员 Thomas
    Reed 后来指出，恶意软件出现在通过种子网站分享的盗版流行 macOS 软件中。他特别写道
- en: an apparently malicious Little Snitch installer available for download on a
    Russian forum dedicated to sharing torrent links. A post offered a torrent download
    for Little Snitch, and was soon followed by a number of comments that the download
    included malware. In fact, we discovered that not only was it malware, but a new
    Mac ransomware variant spreading via piracy.^([2](#c10-endnote-2))
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个看似恶意的 Little Snitch 安装程序可以在一个专门分享种子链接的俄罗斯论坛上下载。一篇帖子提供了 Little Snitch 的种子下载链接，随后不久便有许多评论指出该下载包含恶意软件。事实上，我们发现它不仅是恶意软件，而且是一个通过盗版传播的新型
    Mac 勒索病毒变种。^([2](#c10-endnote-2))
- en: Distributing pirated or cracked applications that have been maliciously trojanized
    is a fairly common method of targeting macOS users for infection. Though not the
    most sophisticated approach, it is rather effective, as many users have a distaste
    for paid software and instead seek out pirated alternatives. [Figure 10-1](#figure10-1)
    shows the download link for the malicious Little Snitch software.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 分发被恶意篡改的盗版或破解应用程序是一个相当常见的针对 macOS 用户进行感染的方法。虽然这不是最复杂的方法，但它相当有效，因为许多用户不喜欢付费软件，而是寻找盗版替代品。[图
    10-1](#figure10-1) 显示了恶意 Little Snitch 软件的下载链接。
- en: '![The webpage for pirating Little Snitch contains information about the software,
    such as the year—2020—the version, developer, description, and so on. At the bottom
    of the screen is a link to “Download the distribution by magnet link (59.3 MB).”
    Beneath the link is a warning: “Your Internet Provider and Government can see
    what you are downloading. Don’t forget to hide your IP with VPN to avoid fines
    and lawsuits!” Links to NordVPN, ExpressVPN, and others are directly below.](image_fi/501942c10/f10001.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![盗版 Little Snitch 的网页包含了关于软件的信息，例如年份——2020年——版本、开发者、描述等等。屏幕底部有一个链接，指向“通过磁力链接下载分发版（59.3
    MB）”。链接下方有一则警告：“您的互联网服务提供商和政府能够看到您下载的内容。别忘了使用 VPN 隐藏您的 IP 以避免罚款和诉讼！”下面直接链接到 NordVPN、ExpressVPN
    等。](image_fi/501942c10/f10001.png)'
- en: 'Figure 10-1: Pirated version of Little Snitch trojanized with EvilQuest'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-1：被 EvilQuest 篡改的盗版 Little Snitch
- en: Of course, this infection vector requires user interaction. Specifically, in
    order to become infected with EvilQuest, users would have to download and run
    an infected application. Moreover, as you’ll see, the malware’s installer package
    is unsigned, so users on recent versions of macOS may have to proactively take
    steps to bypass system notarization checks.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种感染途径需要用户交互。具体来说，为了感染 EvilQuest，用户必须下载并运行被感染的应用程序。此外，正如你将看到的，恶意软件的安装包是未签名的，因此在
    macOS 的新版本上，用户可能需要主动采取步骤绕过系统的 notarization 检查。
- en: In an attempt to infect as many Mac users as possible, the malware authors surreptitiously
    trojanized many different pirated applications distributed via torrent sites.
    In this chapter, we’ll focus on a sample that was maliciously packaged up with
    the popular DJ application Mixed In Key.^([3](#c10-endnote-3))
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能感染更多的 Mac 用户，恶意软件作者悄悄篡改了许多通过 torrent 网站分发的盗版应用程序。在本章中，我们将重点关注一个恶意包装的示例，它是与流行
    DJ 应用程序 Mixed In Key 一起捆绑的。^([3](#c10-endnote-3))
- en: Triage
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分类
- en: Recall that an application is actually a special directory structure called
    a *bundle* that must be packaged up before being distributed. The sample of EvilQuest
    we’re analyzing here was distributed as a disk image, *Mixed In Key 8.dmg*. As
    shown in [Figure 10-2](#figure10-2), when first discovered, this sample’s SHA-256
    hash (B34738E181A6119F23E930476AE949FC0C7C4DED6EFA003019FA946C4E5B287A) was not
    flagged as malicious by any of the antivirus engines on the aggregate scanning
    site VirusTotal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一个应用程序实际上是一个特殊的目录结构，称为 *bundle*，在分发之前必须将其打包。我们正在分析的 EvilQuest 样本是作为一个磁盘镜像
    *Mixed In Key 8.dmg* 分发的。如图 [10-2](#figure10-2) 所示，首次发现该样本时，其 SHA-256 哈希值（B34738E181A6119F23E930476AE949FC0C7C4DED6EFA003019FA946C4E5B287A）并未被
    VirusTotal 上的任何杀毒引擎标记为恶意。
- en: '![Mixed In Key 8.dmg is shown to have a score of 0/58 on VirusTotal.](image_fi/501942c10/f10002.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Mixed In Key 8.dmg 在 VirusTotal 上显示的得分为 0/58。](image_fi/501942c10/f10002.png)'
- en: 'Figure 10-2: The trojanized *Mixed* *In* *Key 8.dmg* file on VirusTotal'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-2：VirusTotal 上被篡改的 *Mixed* *In* *Key 8.dmg* 文件
- en: Of course, today this disk image is widely detected as containing malware.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，今天这个磁盘镜像被广泛检测为含有恶意软件。
- en: Confirming the File Type
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确认文件类型
- en: As analysis tools are often file-type specific and malware authors may attempt
    to mask the true file type of their malicious creations, it is wise to first determine
    or confirm a file’s true type when you are presented with a potentially malicious
    specimen. Here we attempt to use the `file` utility to confirm that the trojanized
    *Mixed In Key 8.dmg* is indeed a disk image.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分析工具通常针对特定的文件类型，而且恶意软件作者可能会尝试掩盖其恶意创作的真实文件类型，因此在遇到潜在的恶意样本时，首先确定或确认文件的真实类型是明智的。在这里，我们尝试使用
    `file` 工具确认被篡改的 *Mixed In Key 8.dmg* 确实是一个磁盘镜像。
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Oops, looks like the `file` utility misidentified the file as something other
    than a disk image. This is unsurprising, as disk images compressed with zlib are
    often reported as “VAX COFF” due to the zlib header.^([4](#c10-endnote-4))
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，看起来 `file` 工具错误地将该文件识别为磁盘镜像以外的其他类型。这并不意外，因为使用 zlib 压缩的磁盘镜像通常会因 zlib 头部而被报告为“VAX
    COFF”。^([4](#c10-endnote-4))
- en: Let’s try again, this time using my WhatsYourSign (WYS) utility, which shows
    an item’s code-signing information and more accurately identifies the item’s file
    type. As you can see in [Figure 10-3](#figure10-3), the tool’s Item Type field
    confirms that *Mixed In Key 8.dmg* is indeed a disk image, as expected.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一次，这次使用我的 WhatsYourSign (WYS) 工具，它显示了项的代码签名信息并更准确地识别项的文件类型。如图 [10-3](#figure10-3)
    所示，该工具的“项类型”字段确认 *Mixed In Key 8.dmg* 确实是一个磁盘镜像，正如预期的那样。
- en: '![In the WhatsYourSign tool, Mixed In Key 8.dmg contains the following information:
    “Item Type: Disk Image,” “Entitled: None,” and “Sign Auths: unsigned (‘errSecCSUnsigned’).”](image_fi/501942c10/f10003.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![在 WhatsYourSign 工具中，Mixed In Key 8.dmg 包含以下信息：“项类型：磁盘镜像”，“授权：无”，“签名认证：未签名（‘errSecCSUnsigned’）”。](image_fi/501942c10/f10003.png)'
- en: 'Figure 10-3: WYS confirms the item as a disk image'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-3：WYS 确认该项为磁盘镜像
- en: Extracting the Contents
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取内容
- en: 'Once we’ve confirmed that this *.dmg* file is indeed a disk image, our next
    task is to extract the disk image’s contents for analysis. Using macOS’s built-in
    `hdiutil` utility, we can mount the disk image to access its files:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确认该 *.dmg* 文件确实是一个磁盘镜像，我们的下一步任务就是提取磁盘镜像的内容以供分析。使用 macOS 内建的 `hdiutil` 工具，我们可以挂载磁盘镜像并访问其文件：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once this command has completed, the disk image will be mounted to */Volumes/Mixed
    In Key 8/*. Listing the contents of this directory reveals a single file, *Mixed
    In Key 8.pkg*, which appears to be an installer package ([Listing 10-1](#listing10-1)):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦此命令完成，磁盘映像将被挂载到 */Volumes/Mixed In Key 8/*。列出该目录的内容会显示一个名为 *Mixed In Key 8.pkg*
    的文件，看起来是一个安装包（[Listing 10-1](#listing10-1)）：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 10-1: Listing the mounted disk image’s contents'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 10-1: 列出已挂载磁盘映像的内容'
- en: We again turn to WYS to confirm that the *.pkg* file is indeed a package, and
    also to check the package’s signing status. As you can see in [Figure 10-4](#figure10-4),
    the *.pkg* file type is confirmed, though the package is unsigned.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用 WYS 确认 *.pkg* 文件确实是一个包文件，并检查该包的签名状态。如 [Figure 10-4](#figure10-4) 所示，文件类型已确认为
    *.pkg*，但该包未签名。
- en: '![In the WhatsYourSign tool, Mixed In Key 8.dmg shows the following information:
    “Item Type: Installer package archive,” “Entitled: none,” “Sign Auths: unsigned
    (‘errSecCSUnsigned’).”](image_fi/501942c10/f10004.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![在 WhatsYourSign 工具中，Mixed In Key 8.dmg 显示以下信息：“项目类型：安装包归档”，“授权：无”，“签名认证：未签名（‘errSecCSUnsigned’）”。](image_fi/501942c10/f10004.png)'
- en: 'Figure 10-4: WYS confirms the item as an unsigned package'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 10-4: WYS 确认该项为未签名的包'
- en: 'We can also check any package signatures (or lack thereof) from the terminal
    with the `pkgutil` utility. Just pass in `--check-signature` and the path to the
    package, as shown in [Listing 10-2](#listing10-2):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过终端使用 `pkgutil` 工具检查任何包的签名（或缺少签名）。只需传入 `--check-signature` 和包的路径，如 [Listing
    10-2](#listing10-2) 所示：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 10-2: Checking the package’s signature'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 10-2: 检查包的签名'
- en: As the package is unsigned, macOS will prompt the user before allowing it to
    be opened. However, users attempting to pirate software will likely ignore this
    warning, pressing onwards and inadvertently commencing the infection.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该包未签名，macOS 会在允许打开之前提示用户。然而，尝试盗版软件的用户很可能会忽略此警告，继续操作并不知不觉地开始感染。
- en: Exploring the Package
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索包文件
- en: In Chapter 4 we discussed using the Suspicious Package utility to explore the
    contents of installer packages. Here we’ll use it to open *Mixed In Key 8.pkg*
    ([Figure 10-5](#figure10-5)). In the All Files tab, we’ll find an application
    named *Mixed In Key 8.app* and an executable file simply named *patch*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 章中，我们讨论了如何使用 Suspicious Package 工具来探索安装包的内容。在这里，我们将使用它打开 *Mixed In Key
    8.pkg*（[Figure 10-5](#figure10-5)）。在 "All Files" 标签页中，我们将找到一个名为 *Mixed In Key
    8.app* 的应用程序文件和一个名为 *patch* 的可执行文件。
- en: '![In the Suspicious Package tool, Mixed In Key 8.dmg is shown to contain an
    Applications folder with the Mixed In Key 8.app file and a Utils folder that contains
    an executable file named Patch.](image_fi/501942c10/f10005.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![在 Suspicious Package 工具中，Mixed In Key 8.dmg 显示包含一个名为 Mixed In Key 8.app 的应用程序文件和一个名为
    Patch 的可执行文件的 Applications 文件夹，以及一个包含 Patch 可执行文件的 Utils 文件夹。](image_fi/501942c10/f10005.png)'
- en: 'Figure 10-5: Using Suspicious Package to explore files within the trojanized
    *Mixed in Key* package'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 10-5: 使用 Suspicious Package 工具探索篡改过的 *Mixed In Key* 包中的文件'
- en: We’ll triage these files shortly, but first we should check for any pre- or
    post-install scripts. Recall that when a package is installed, any such scripts
    will also be automatically executed. As such, if an installer package contains
    malware, you’ll often find malicious installer logic within these scripts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将检查这些文件，但首先我们应该检查是否有安装前或安装后的脚本。回想一下，当包文件被安装时，任何此类脚本也会自动执行。因此，如果一个安装包包含恶意软件，你通常会在这些脚本中发现恶意安装逻辑。
- en: 'Clicking the **All Scripts** tab reveals that *Mixed In Key 8.pkg* does contain
    a post-install script ([Listing 10-3](#listing10-3)):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **All Scripts** 标签页显示 *Mixed In Key 8.pkg* 确实包含一个安装后脚本（[Listing 10-3](#listing10-3)）：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 10-3: *Mixed* *In* *Key 8.pkg*’s post-install script'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 10-3: *Mixed* *In* *Key 8.pkg* 的安装后脚本'
- en: 'When the trojanized *Mixed In Key 8.pkg* is installed, the script will be executed
    and performs the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当篡改过的 *Mixed In Key 8.pkg* 被安装时，脚本将被执行并执行以下操作：
- en: Create a directory named */Library/mixednkey*.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 */Library/mixednkey* 的目录。
- en: Move the *patch* binary (which was installed to */Applications/Utils/patch*)
    into the newly created */Library/mixednkey* directory as a binary named *toolroomd*.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *patch* 二进制文件（它被安装到了 */Applications/Utils/patch*）移动到新创建的 */Library/mixednkey*
    目录中，并将其重命名为 *toolroomd*。
- en: Attempt to delete the */Applications/Utils/* directory (created earlier in the
    install process). However, due to a bug in the command (the malware author missed
    the “s” in */Applications*), this will fail.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试删除 */Applications/Utils/* 目录（在安装过程中创建的目录）。然而，由于命令中的一个错误（恶意软件作者在 */Applications*
    中遗漏了 "s"），该操作会失败。
- en: Set the *toolroomd* binary to be executable.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*toolroomd*二进制文件设置为可执行。
- en: Launch the *toolroomd* binary in the background.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后台启动*toolroomd*二进制文件。
- en: The installer requests root privileges during the install, so if the user provides
    the necessary credentials, this post-install script will also run with elevated
    privileges.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序在安装过程中请求root权限，因此如果用户提供必要的凭据，此后安装脚本也将以提升的特权运行。
- en: 'Through dynamic analysis monitoring tools, such as my ProcessMonitor and FileMonitor,
    we can passively observe this installation process, including the execution of
    the post-install script and the script’s commands ([Listing 10-4](#listing10-4)):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过动态分析监控工具（例如我的ProcessMonitor和FileMonitor），我们可以被动观察此安装过程，包括执行后安装脚本和脚本的命令（[清单10-4](#listing10-4)）：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 10-4: Monitoring the actions of the malicious post-install script'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 清单10-4：监控恶意后安装脚本的操作
- en: In this abridged output from ProcessMonitor, you can see various commands from
    the post-install script, such as `mkdir` and `mv`, being executed as the malware
    is installed. Most notably, observe that at its completion the script executes
    the malware, now installed as *toolroomd* 1.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在来自ProcessMonitor的这段缩减输出中，您可以看到来自后安装脚本的各种命令（例如`mkdir`和`mv`）在安装恶意软件时被执行。 特别要注意，在完成时脚本会执行已安装为*toolroomd*
    1的恶意软件。
- en: Let’s now extract both the *Mixed In Key 8* application and *patch* binary from
    the package using Suspicious Package by exporting each file. First, let’s take
    a peek at the *Mixed In Key 8* application. By using WYS, we can see that it is
    still validly signed by the Mixed In Key developers ([Figure 10-6](#figure10-6)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用Suspicious Package从包中分别导出*Mixed In Key 8*应用程序和*patch*二进制文件。 首先，让我们来看一下*Mixed
    In Key 8*应用程序。 通过使用WYS，我们可以看到它仍然由Mixed In Key开发人员有效签名（[图10-6](#figure10-6)）。
- en: '![In the WhatsYourSign tool, Mixed In Key 8.app is declared to be “validly
    signed,” with the signer listed as “Apple Dev-ID.” More information is available
    under sign auth: “Developer ID Application: Mixed In Key, LLC (T4A2E2DEM7),” “Developer
    ID Certification Authority,” “Apple Root CA.”](image_fi/501942c10/f10006.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![在WhatsYourSign工具中，Mixed In Key 8.app被声明为“有效签名”，签名者列为“Apple Dev-ID”。 更多信息在签名认证下可用：“Developer
    ID Application：Mixed In Key，LLC（T4A2E2DEM7）”，“Developer ID Certification Authority”，“Apple
    Root CA”。](image_fi/501942c10/f10006.png)'
- en: 'Figure 10-6: The still validly signed application (via WYS)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-6：仍然有效签名的应用程序（通过WYS）
- en: Confirming the validity of an item’s code-signing signature tells us that it
    has not been modified or tampered with since being signed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 确认项目代码签名签名的有效性告诉我们它自签名以来未被修改或篡改。
- en: Could the malware authors have compromised Mixed In Key, stolen its code-signing
    certificate, surreptitiously modified the application, and then re-signed it?
    Fair question, and the answer is that it’s possible, though highly unlikely. If
    this were the case, the malware authors probably wouldn’t have had to resort to
    such an unsophisticated infection mechanism (distributing the software via shady
    torrent sites), nor would they have had to include another unsigned binary in
    the package.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者是否可能已经篡改了Mixed In Key，并窃取了其代码签名证书，偷偷修改了应用程序，然后重新签名？ 公平的问题，答案是可能的，尽管可能性极小。
    如果是这种情况，恶意软件作者可能不必采用如此低级的感染机制（通过不光彩的种子站点分发软件），也不必在包中包含另一个未签名的二进制文件。
- en: 'As the main application remains validly signed by the developers, let’s turn
    our attention to the *patch* file. As you’ll see shortly, this is the malware.
    (Recall that it gets installed as a file called *toolroomd.*) Using the `file`
    utility we can determine that it is a 64-bit Mach-O binary, and the `codesign`
    utility indicates that it is unsigned:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于主应用程序仍由开发人员有效签名，让我们将注意力转向*补丁*文件。 正如您很快将看到的那样，这是恶意软件。 （请记住，它作为名为*toolroomd*的文件安装。）使用`file`实用程序，我们可以确定它是一个64位Mach-O二进制文件，而`codesign`实用程序则指示它未经签名：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As *patch* is a binary rather than, say, a script, we’ll continue our analysis
    by leveraging static analysis tools that are either file-type agnostic or specifically
    tailored toward binary analysis.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*patch*是二进制文件而不是脚本，我们将通过利用无论文件类型是否特定于二进制分析的静态分析工具来继续我们的分析。
- en: Extracting Embedded Information from the patch Binary
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从补丁二进制文件中提取嵌入信息
- en: 'First we’ll run the `strings` utility to extract any embedded ASCII strings,
    as these strings can often provide valuable insight into the malware’s logic and
    capabilities. Note that I’ve reordered the output for convenience ([Listing 10-5](#listing10-5)):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将运行 `strings` 工具来提取任何嵌入的 ASCII 字符串，因为这些字符串通常能为恶意软件的逻辑和功能提供宝贵的洞见。请注意，为了方便起见，我已重新排序输出（见
    [Listing 10-5](#listing10-5)）：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 10-5: Extracting embedded strings'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 10-5：提取嵌入的字符串
- en: Extracting the embedded strings reveals strings that appear to be command line
    arguments (like `--silent`), networking requests (like `GET /%s HTTP/1.0`), potential
    file-encryption logic (like `_generate_xkey`), and key mappings (like `[right-cmd]`),
    possibly indicating the presence of keylogging logic. We also uncover a path that
    contains a directory name (*toidievitceffe*) that unscrambles to “effectiveidiot.”
    Our continued analysis will soon reveal other strings and function names containing
    the abbreviation “ei” (such as `EI_RESCUE` and `ei_loader_main`). It seems likely
    that “effectiveidiot” is the moniker given to the malware by its developers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 提取的嵌入字符串揭示了一些看似命令行参数的字符串（如 `--silent`）、网络请求（如 `GET /%s HTTP/1.0`）、潜在的文件加密逻辑（如
    `_generate_xkey`）以及键盘映射（如 `[right-cmd]`），这些可能表明存在键盘记录的逻辑。我们还发现了一个包含目录名的路径（*toidievitceffe*），该目录名解码为“effectiveidiot”。我们的继续分析很快会揭示出包含缩写“ei”的其他字符串和函数名（如
    `EI_RESCUE` 和 `ei_loader_main`）。看起来“effectiveidiot”是恶意软件开发者为其命名的代号。
- en: The output from the `strings` utility reveals a large number of embedded strings
    (like `2Uy5DI3hMp7o0cq|T|14vHRz0000013`) that appear obfuscated. These nonsensical
    strings likely indicate that EvilQuest employs anti-analysis. Shortly we’ll break
    this anti-analysis logic to deobfuscate all such strings. First, though, let’s
    statically extract more information from the malware.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings` 工具的输出揭示了大量的嵌入字符串（如 `2Uy5DI3hMp7o0cq|T|14vHRz0000013`），这些字符串看起来经过了混淆。这些无意义的字符串很可能表明
    EvilQuest 使用了反分析技术。稍后我们将破译这些反分析逻辑，解密所有此类字符串。不过首先，让我们静态提取更多的恶意软件信息。'
- en: 'Recall that macOS’s built-in `nm` utility can extract embedded information,
    such as function names and system APIs invoked by the malware. Like the output
    of the `strings` utility, this information can provide insight into the malware’s
    capabilities and guide continued analysis. Let’s run `nm` on the *patch* binary,
    as in [Listing 10-6](#listing10-6). Again, I’ve reordered the output for convenience:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，macOS 内置的 `nm` 工具可以提取嵌入的信息，例如恶意软件调用的函数名和系统 API。与 `strings` 工具的输出类似，这些信息可以帮助我们了解恶意软件的功能，并指导后续的分析。让我们对
    *patch* 二进制文件运行 `nm`，如同在 [Listing 10-6](#listing10-6) 中所示。为了方便起见，我已重新排序输出：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 10-6: Extracting embedded names (API calls, functions, and so on)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 10-6：提取嵌入的名称（API 调用、函数等）
- en: First we see references to system APIs, such as `CGEventTapCreate` and `CGEventTapEnable`,
    often leveraged to capture user keypresses, as well as `NSCreateObjectFileImageFromMemory`
    and `NSLinkModule`, which can be used to execute binary payloads in memory. The
    output also contains a long list of function names that map directly back to the
    malware’s original source code. Unless these are named incorrectly to mislead
    us, they can provide insight into many aspects of the malware. For example,
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看到一些系统 API 的引用，如 `CGEventTapCreate` 和 `CGEventTapEnable`，这些通常用于捕获用户按键，还有
    `NSCreateObjectFileImageFromMemory` 和 `NSLinkModule`，它们可以用来在内存中执行二进制有效负载。输出中还包含了一个长列表的函数名，这些函数名可以直接映射回恶意软件的原始源代码。除非这些函数名被故意错误命名来误导我们，否则它们可以揭示恶意软件的许多方面。例如，
- en: '`is_debugging`, `is_virtual_mchn`, and `prevent_trace` may indicate that the
    malware implements dynamic-analysis-thwarting logic.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_debugging`、`is_virtual_mchn` 和 `prevent_trace` 可能表明恶意软件实现了动态分析阻止逻辑。'
- en: '`get_host_identifier` and `get_process_list` may indicate host survey capabilities.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_host_identifier` 和 `get_process_list` 可能表明主机调查能力。'
- en: '`persist_executable` and `install_daemon` likely relate to how the malware
    persists.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`persist_executable` 和 `install_daemon` 可能与恶意软件如何保持持久性有关。'
- en: '`eib_secure_decode` and `eib_string_key` may be responsible for decoding the
    obfuscated strings.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eib_secure_decode` 和 `eib_string_key` 可能负责解码这些混淆的字符串。'
- en: '`get_targets`, `is_target`, and `eip_encrypt` could contain the malware’s purported
    ransomware logic.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_targets`、`is_target` 和 `eip_encrypt` 可能包含恶意软件的所谓勒索软件逻辑。'
- en: The `react_*` functions (such as `react_exec`) possibly contain the logic to
    execute remote commands from the attacker’s command and control server.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react_*` 函数（如 `react_exec`）可能包含执行攻击者命令和控制服务器远程命令的逻辑。'
- en: Of course, we should verify this functionality during static or dynamic analysis.
    However, these names alone can help focus our continued analysis. For example,
    it would be wise to statically analyze what appear to be various anti-analysis
    functions before beginning a debugging session, as those functions may attempt
    to thwart the debugger and thus would need to be bypassed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们应该在静态或动态分析中验证此功能。然而，仅凭这些名称就能帮助我们集中精力进行进一步分析。例如，在开始调试会话之前，静态分析那些看起来像是各种反分析功能的代码是明智的，因为这些功能可能会试图阻止调试器，因此需要绕过它们。
- en: Analyzing the Command Line Parameters
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析命令行参数
- en: Armed with the myriad of intriguing information collected during our static
    analysis triage, it’s time to dig a little deeper. We can disassemble the *patch*
    binary by loading it into a disassembler, such as Hopper. A quick triage of the
    disassembler code reveals that the core logic of the *patch* binary occurs within
    its main function, which is rather extensive. First the binary parses any command
    line parameters looking for `--silent`, `--noroot`, and `--ignrp`. If these command
    line arguments are present, various flags are set. If we then analyze code that
    references these flags, we can ascertain their meaning.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通过静态分析筛选收集到的大量有趣信息的支持下，现在是时候进一步深入探讨了。我们可以通过将 *patch* 二进制文件加载到反汇编工具（如 Hopper）中进行反汇编。对反汇编代码的快速筛查显示，*patch*
    二进制文件的核心逻辑出现在其主函数中，该函数相当庞大。首先，二进制文件解析任何命令行参数，查找 `--silent`、`--noroot` 和 `--ignrp`。如果这些命令行参数存在，则会设置相应的标志。接着，如果我们分析引用这些标志的代码，就能了解它们的含义。
- en: --silent
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: --silent
- en: If `--silent` is passed in via the command line, the malware sets a global variable
    to 0\. This appears to instruct the malware to run “silently,” for example suppressing
    the printing of error messages. In the following snippet of disassembly, the value
    of a variable (which I’ve named `silent` below) is first checked via the `cmp`
    instruction. If it is set, the malware will jump over the call to the `printf`
    function so that an error message is not displayed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过命令行传入 `--silent`，恶意软件会将一个全局变量设置为 0。这似乎指示恶意软件以“静默”模式运行，例如抑制错误信息的打印。在以下的反汇编代码片段中，首先通过
    `cmp` 指令检查一个变量（我在下面称之为 `silent`）的值。如果它被设置，恶意软件将跳过对 `printf` 函数的调用，从而不会显示错误消息。
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This flag is also passed to the `ei_rootgainer_main` function, which influences
    how the malware (running as a normal user) may request root privileges. Note,
    in the following disassembly, that the address of the flag is loaded into the
    `RDX` register, which holds the third argument in the context of a function call:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标志也被传递给 `ei_rootgainer_main` 函数，它影响恶意软件（以普通用户身份运行）如何请求 root 权限。请注意，在以下反汇编中，标志的地址被加载到
    `RDX` 寄存器中，该寄存器在函数调用的上下文中保存第三个参数：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Interestingly, this flag is explicitly initialized to 0 (and set to 0 again
    if the `--silent` parameter is specified). It appears to never be set to 1 (true).
    Thus, the malware will always run in “silent” mode, even if `--silent` is not
    specified. It’s possible that, in a debug build of the malware, the flag could
    be initialized to 1 as the default value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这个标志显式初始化为 0（如果指定了 `--silent` 参数，它会再次设置为 0）。它似乎从未被设置为 1（真）。因此，即使没有指定 `--silent`，恶意软件也将始终以“静默”模式运行。可能在恶意软件的调试版本中，默认值会将该标志初始化为
    1。
- en: To acquire root privileges, the `ei_rootgainer_main` function calls into a helper
    function, `run_as_admin_async`, to execute the following (originally encrypted)
    command, substituting itself for the `%s`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取 root 权限，`ei_rootgainer_main` 函数调用了一个辅助函数 `run_as_admin_async`，以执行以下（最初加密的）命令，并用自身替换
    `%s`。
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This results in an authentication prompt from the macOS built-in `osascript`
    ([Figure 10-7](#figure10-7)).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致 macOS 内置的 `osascript` 提示身份验证（见 [图 10-7](#figure10-7)）。
- en: '![The authentication prompt states, “osascript wants to make changes. Enter
    your password to allow this.”](image_fi/501942c10/f10007.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![身份验证提示显示：“osascript 想要进行更改。请输入密码以允许此操作。”](image_fi/501942c10/f10007.png)'
- en: 'Figure 10-7: The malware’s authentication prompt, via `osascript`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-7：恶意软件的身份验证提示，通过 `osascript`
- en: If the user provides appropriate credentials, the malware will have gained root
    privileges.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户提供了适当的凭证，恶意软件将获得 root 权限。
- en: --noroot
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: --noroot
- en: If `--noroot` is passed in via the command line, the malware sets another flag
    to 1 (true). Various code within the malware then checks this flag and, if it
    is set, takes different actions, such as skipping the request for root privileges.
    In the snippet of disassembled code, note that if the flag (initially `var_20`
    but named `noRoot` here) is set, the call to the `ei_rootgainer_main` function
    is skipped.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过命令行传入了`--noroot`，恶意软件会将另一个标志设置为1（真）。恶意软件内部的各种代码会检查此标志，如果设置了该标志，则采取不同的操作，如跳过请求根权限的步骤。在反汇编代码片段中，请注意，如果设置了标志（最初为`var_20`但此处命名为`noRoot`），则跳过对`ei_rootgainer_main`函数的调用。
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `--noroot` argument is also passed to a persistence function, `ei_persistence_main`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`--noroot`参数也被传递给一个持久性函数`ei_persistence_main`：'
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Subsequent analysis of this function reveals that this flag dictates how the
    malware persists; either as a launch daemon or a launch agent. Recall that persisting
    as a launch daemon requires root privileges, whereas persisting as a launch agent
    requires only user privileges.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对该函数的后续分析显示，此标志决定了恶意软件的持久性方式；作为启动守护程序需要根权限，而作为启动代理则只需要用户权限。
- en: --ignrp
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: --ignrp
- en: If `--ignrp` (“ignore persistence”) is passed in via the command line, the malware
    sets a flag to 1 and instructs itself not to manually start any persisted launch
    items.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过命令行传入了`--ignrp`（“忽略持久性”），恶意软件会将一个标志设置为1，并指示自己不启动任何持久启动项。
- en: 'We can confirm this by examining disassembled code in the `ei_selfretain_main`
    function, which contains logic to load persisted components. This function first
    checks the flag (named `ignorePersistence` here) and, if it’s not set, the function
    simply returns without loading the persisted items:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查`ei_selfretain_main`函数中的反汇编代码来确认这一点，该函数包含加载持久组件的逻辑。此函数首先检查标志（此处命名为`ignorePersistence`），如果未设置，则函数将简单返回而不加载持久项目：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that, even if the `--ignrp` command line option is specified, the malware
    itself will still persist and thus be automatically restarted each time an infected
    system is rebooted or the user logs in.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使指定了`--ignrp`命令行选项，恶意软件仍将持久存在，因此在感染系统重新启动或用户登录时会自动重新启动。
- en: Analyzing Anti-Analysis Logic
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析反分析逻辑
- en: If a malicious sample contains anti-analysis logic, we must identify and thwart
    it to continue our analysis. Luckily for us, other than what appear to be encrypted
    strings, EvilQuest does not seem to employ any methods that will hinder our static
    analysis efforts. However, we’re not so lucky when it comes to dynamic analysis.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果恶意样本包含反分析逻辑，我们必须识别并挫败它以继续分析工作。幸运的是，除了看起来是加密字符串外，EvilQuest似乎没有采用任何会妨碍我们静态分析的方法。但是，当涉及到动态分析时，我们的运气就不那么好了。
- en: As noted in Chapter 9, a sample prematurely exiting when run in a virtual machine
    or debugger likely indicates that some sort of dynamic anti-analysis logic was
    triggered. If you try to run EvilQuest in a debugger, you’ll notice that it simply
    terminates. This isn’t surprising; recall that the malware contains functions
    with names such as `is_debugging` and `prevent_trace`. A function named `is_virtual_mchn`
    is also invoked before these likely anti-debugger functions. Let’s begin our analysis
    of what appears to be the malware’s anti-analysis logic there.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如第9章所述，样本在虚拟机或调试器中运行时过早退出，通常表明触发了某种动态反分析逻辑。如果尝试在调试器中运行EvilQuest，您会注意到它简单地终止。这并不奇怪；请回想一下，恶意软件包含名称为`is_debugging`和`prevent_trace`的函数。在这些可能是反调试函数之前，还调用了名为`is_virtual_mchn`的函数。让我们从那里开始分析看起来是恶意软件的反分析逻辑。
- en: Virtual Machine–Thwarting Logic?
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防虚拟机逻辑？
- en: 'In your disassembler, take a look at `0x000000010000be5f` in the main function.
    Once the malware has processed any command line options, it invokes a function
    named `is_virtual_mchn`. As shown in the following snippet of decompiled code,
    the malware will prematurely exit if this function returns a nonzero value:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的反汇编器中，查看主函数中的`0x000000010000be5f`。一旦恶意软件处理了任何命令行选项，它就会调用一个名为`is_virtual_mchn`的函数。如下所示的反编译代码片段显示，如果此函数返回非零值，恶意软件将会提前退出：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let’s take a closer look at the decompilation of this function ([Listing 10-7](#listing10-7)),
    as we want to ensure the malware runs (or can be coerced to run) in a virtual
    machine, such that we can analyze it dynamically.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地查看此函数的反编译（[Listing 10-7](#listing10-7)），因为我们希望确保恶意软件在虚拟机中运行（或可以被迫在虚拟机中运行），以便我们可以动态分析它。
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 10-7: Anti-sandbox check, through time checks'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 10-7: 反沙箱检测，通过时间检查'
- en: As you can see in the decompilation of `is_virtual_mchn`, the `time` function
    is invoked twice, with a call to `sleep` in between. It then compares the differences
    between the two calls to `time` to match the amount of time that the code slept
    for. This allows it to detect sandboxes that patch, or speed up, calls to `sleep`.
    As security researcher Clemens Kolbitsch has noted,
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在`is_virtual_mchn`的反编译中所见，`time`函数被调用了两次，中间有一个`sleep`调用。然后它比较两次`time`调用之间的差值，以匹配代码休眠的时间。这使得它能够检测到那些修改或加速`sleep`调用的沙箱。正如安全研究员Clemens
    Kolbitsch所指出的，
- en: Sandboxes will patch the sleep function to try to outmaneuver malware that uses
    time delays. In response, malware will check to see if time was accelerated. Malware
    will get the timestamp, go to sleep and then again get the timestamp when it wakes
    up. The time difference between the timestamps should be the same duration as
    the amount of time the malware was programmed to sleep. If not, then the malware
    knows it is running in an environment that is patching the sleep function, which
    would only happen in a sandbox.^([5](#c10-endnote-5))
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 沙箱会修改`sleep`函数，以试图绕过使用时间延迟的恶意软件。作为回应，恶意软件会检查时间是否被加速。它会获取时间戳，进入休眠，然后在醒来时再次获取时间戳。两个时间戳之间的时间差应该与恶意软件预定的休眠时间相同。如果不同，则恶意软件知道它正在运行在一个修改了`sleep`函数的环境中，这种情况通常只会发生在沙箱中。^([5](#c10-endnote-5))
- en: This means that, in reality, the `is_virtual_mchn` function is more of a sandbox
    check and will not actually detect a standard virtual machine, which doesn’t manipulate
    any time constructs. That’s good news for our continued analysis of the malware,
    which occurs within an isolated virtual machine.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，实际上，`is_virtual_mchn`函数更像是一个沙箱检查，而不会真正检测到标准的虚拟机，因为标准虚拟机不会修改任何时间构造。对我们在隔离虚拟机中继续分析恶意软件的工作来说，这是个好消息。
- en: Debugging-Thwarting Logic
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防调试逻辑
- en: 'We also need to discuss the other anti-analysis mechanisms employed by the
    malware, as this logic could thwart our dynamic analysis efforts later. Recall
    that in the output of the `strings` utility, we saw what appeared to be anti-debugging
    functions: `is_debugging` and `prevent_trace`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要讨论恶意软件使用的其他反分析机制，因为这些逻辑可能会妨碍我们之后的动态分析工作。回想一下在`strings`工具的输出中，我们看到了似乎是反调试功能的函数：`is_debugging`和`prevent_trace`。
- en: 'The `is_debugging` function is implemented at address `0x0000000100007aa0`.
    Looking at a snippet of annotated disassembly of this function in [Listing 10-8](#listing10-8),
    we see the malware invoking the `sysctl` function with `CTL_KERN`, `KERN_PROC`,
    `KERN_PROC_PID`, and its PID, obtained via the `getpid()` API function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_debugging`函数实现于地址`0x0000000100007aa0`。查看[清单10-8](#listing10-8)中这个函数的注释反汇编片段，我们看到恶意软件使用`CTL_KERN`、`KERN_PROC`、`KERN_PROC_PID`及通过`getpid()`
    API函数获取的PID调用了`sysctl`函数：'
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 10-8: The start of anti-debugging logic, via the `sysctl` API'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 清单10-8：通过`sysctl` API开始的反调试逻辑
- en: Once the `sysctl` function has returned, the malware checks the `p_flag` member
    of the `info.kp_proc` structure populated by the call to `sysctl` to see whether
    it has the `P_TRACED` flag set ([Listing 10-9](#listing10-9)). As this flag is
    only set if the process is being debugged, the malware can use it to determine
    if it is being debugged.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`sysctl`函数返回，恶意软件会检查由`sysctl`调用填充的`info.kp_proc`结构中的`p_flag`成员，以查看是否设置了`P_TRACED`标志（[清单10-9](#listing10-9)）。由于此标志仅在进程正在被调试时设置，因此恶意软件可以通过它来判断是否正在被调试。
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 10-9: Is the `P_TRACED` flag (`0x800`) set? If so, the process is being
    debugged.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 清单10-9：`P_TRACED`标志（`0x800`）是否被设置？如果设置了，说明进程正在被调试。
- en: If the `is_debugging` function detects a debugger, it returns a nonzero value,
    as shown in [Listing 10-10](#listing10-10)’s full reconstruction, which I’ve based
    on the decompilation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`is_debugging`函数检测到调试器，它会返回非零值，如[清单10-10](#listing10-10)的完整重构所示，我是基于反编译结果得出的。
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 10-10: Anti-debugging logic that uses `sysctl` and `P_TRACED`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 清单10-10：使用`sysctl`和`P_TRACED`的反调试逻辑
- en: 'Code such as the `ei_persistence_main` function invokes the `is_debugging`
    function and promptly terminates if a debugger is detected ([Listing 10-11](#listing10-11)):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如`ei_persistence_main`函数中的代码会调用`is_debugging`函数，如果检测到调试器则立即终止（[清单10-11](#listing10-11)）：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 10-11: A premature exit if a debugger is detected'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 清单10-11：如果检测到调试器则提前退出
- en: To circumvent this anti-analysis logic, we can either modify EvilQuest’s binary
    and patch out this code or use a debugger to subvert the malware’s execution state
    in memory. If you wanted to modify the code, you could replace the `cmovnz` instruction
    (at `0x0000000100007b7a`) with an instruction such as `xor eax, eax` to zero out
    the return value from the function. As this replacement instruction is one byte
    less than the `cmovnz`, you’ll have to add a one-byte NOP instruction for padding.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这个反分析逻辑，我们可以选择修改EvilQuest的二进制文件并修补掉这段代码，或者使用调试器来颠覆恶意软件在内存中的执行状态。如果你想修改代码，可以将`cmovnz`指令（`0x0000000100007b7a`处）替换为类似`xor
    eax, eax`的指令，以将函数的返回值清零。由于该替换指令比`cmovnz`少一个字节，你需要为填充添加一个字节的NOP指令。
- en: 'The debugging approach proves more straightforward, as we can simply zero out
    the return value from the `is_debugging` function. Specifically, we can first
    set a breakpoint on the instruction immediately following the call to the `is_debugging`
    function (`0x000000010000b89f`), which checks the return value via `cmp eax, 0x0`.
    Once the breakpoint is hit, we can set the `RAX` register to 0 with `reg write
    $rax 0`, leaving the malware blind to the fact that it’s being debugged:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 调试方法更加直接，因为我们只需将`is_debugging`函数的返回值置为零。具体来说，我们可以首先在调用`is_debugging`函数后面的指令（`0x000000010000b89f`）设置一个断点，该指令通过`cmp
    eax, 0x0`检查返回值。一旦断点被触发，我们可以通过`reg write $rax 0`将`RAX`寄存器设置为0，从而让恶意软件无法察觉到它正在被调试：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We’re not quite done yet, as the malware also contains a function named `prevent_trace`,
    which, as the name suggests, attempts to prevent tracing via a debugger. [Listing
    10-12](#listing10-12) shows the complete annotated disassembly of the function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完全完成，因为恶意软件还包含一个名为`prevent_trace`的函数，顾名思义，它试图通过调试器阻止追踪。[列表10-12](#listing10-12)展示了该函数的完整注释反汇编。
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 10-12: Anti-debugging logic via the `ptrace` API'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10-12：通过`ptrace` API实现的反调试逻辑
- en: After invoking the `getpid` function to retrieve its process ID, the malware
    invokes `ptrace` with the `PT_DENY_ATTACH` flag (`0x1f`) 1. As noted in the previous
    chapter, this hinders debugging in two ways. First of all, once this call has
    been made, any attempt to attach a debugger will fail. Secondly, if a debugger
    is already attached, the process will immediately terminate after this call is
    made.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`getpid`函数以检索其进程ID之后，恶意软件调用带有`PT_DENY_ATTACH`标志（`0x1f`）的`ptrace` 1。如前一章所述，这种方式会以两种方式阻碍调试。首先，一旦这个调用被执行，任何尝试附加调试器的操作都会失败。其次，如果调试器已经附加，则在调用该函数后，进程会立即终止。
- en: To subvert this logic so that the malware can be debugged to facilitate continued
    analysis, we again leverage the debugger to avoid the call to `prevent_trace`
    altogether. First we set a breakpoint at `0x000000010000b8b2`, which is a call
    that invokes this function. Once the breakpoint is hit, we modify the value of
    the instruction pointer (`RIP`) to point to the next instruction (at `0x000000010000b8b7`).
    This ensures the problematic call to `ptrace` is never executed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了颠覆这种逻辑，以便能够调试恶意软件并促进持续分析，我们再次利用调试器避免调用`prevent_trace`。首先，我们在`0x000000010000b8b2`处设置一个断点，这是调用该函数的位置。当断点被触发时，我们修改指令指针（`RIP`）的值，使其指向下一条指令（`0x000000010000b8b7`）。这样可以确保有问题的`ptrace`调用永远不会执行。
- en: Continued analysis reveals that all of EvilQuest’s anti-debugger functions are
    invoked from within a single function (`ei_persistence_main`). Thus, we can actually
    set a single breakpoint within the `ei_persistence_main` function and then modify
    the instruction pointer to jump past both anti-debugging calls. However, as the
    `ei_persistence_main` function is called multiple times, our breakpoint would
    be hit multiple times, requiring us to manually modify `RIP` each time. A more
    efficient approach would be to add a command to this breakpoint to instruct the
    debugger to automatically both modify `RIP` when the breakpoint is hit and then
    continue.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步分析表明，EvilQuest的所有反调试功能都来自同一个函数（`ei_persistence_main`）。因此，我们实际上可以在`ei_persistence_main`函数内设置一个断点，然后修改指令指针，使其跳过两个反调试调用。然而，由于`ei_persistence_main`函数被多次调用，我们的断点会被多次触发，每次都需要手动修改`RIP`。更高效的方法是，在这个断点上添加一个命令，指示调试器在断点触发时自动修改`RIP`并继续执行。
- en: 'First let’s set a breakpoint at the `call is_debugging` instruction (found
    at `0x000000010000b89a`). Once the breakpoint is set we add a breakpoint command
    via `br command add`. In this command we can instruct the debugger to modify `RIP`,
    setting it to the address immediately following the call to the second anti-debugging
    function, `prevent_trace` (`0x000000010000b8b7`), as shown in [Listing 10-13](#listing10-13):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`call is_debugging`指令处设置一个断点（该指令位于`0x000000010000b89a`）。设置断点后，我们通过`br
    command add`添加断点命令。在此命令中，我们可以指示调试器修改`RIP`，将其设置为紧接着调用第二个反调试函数`prevent_trace`（`0x000000010000b8b7`）的地址，如[Listing
    10-13](#listing10-13)所示：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 10-13: Bypassing anti-debugging logic with a breakpoint command'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 10-13：通过断点命令绕过反调试逻辑
- en: As we also added `continue` to our breakpoint command, the debugger will automatically
    continue execution once the instruction pointer has been modified. Once the breakpoint
    command has been added, both the call to `is_debugging` and the `prevent_trace`
    anti-debugging functions will be automatically skipped. With EvilQuest’s anti-analysis
    logic fully thwarted, our analysis can continue uninhibited.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还将`continue`添加到断点命令中，调试器将在指令指针被修改后自动继续执行。一旦添加了断点命令，对`is_debugging`的调用和`prevent_trace`反调试函数的调用将会被自动跳过。随着EvilQuest的反分析逻辑被完全破解，我们的分析可以不受阻碍地继续进行。
- en: Obfuscated Strings
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混淆字符串
- en: 'Back in the main function, the malware gathers some basic user information,
    such as the value of the `HOME` environment variable, and then it invokes a function
    named `extract_ei`. This function attempts to read `0x20` bytes of “trailer” data
    from the end of its on-disk binary image. However, as a function named `unpack_trailer`
    (invoked by `extract_ei`) returns 0 (false), a check for the magic value of `0xdeadface`
    fails:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 回到主函数，恶意软件收集了一些基本的用户信息，如`HOME`环境变量的值，然后调用了一个名为`extract_ei`的函数。该函数尝试从其磁盘映像的末尾读取`0x20`字节的“尾部”数据。然而，名为`unpack_trailer`的函数（由`extract_ei`调用）返回0（即假），因此检查魔法值`0xdeadface`失败：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Subsequent analysis will soon uncover the fact that the `0xdeadface` value is
    placed at the end of other binaries the malware infects. In other words, this
    is the malware checking whether it is running via a host binary that has been
    (locally) virally infected.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 后续的分析很快会揭示出，`0xdeadface`值被放置在恶意软件感染的其他二进制文件的末尾。换句话说，这就是恶意软件检查它是否通过一个已经（本地）被病毒感染的宿主二进制文件运行。
- en: 'The function returning 0 causes the malware to skip certain repersistence logic
    that appears to persist the malware as a daemon:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 返回0的函数导致恶意软件跳过某些持久化逻辑，这些逻辑似乎将恶意软件作为守护进程持续运行：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It appears that various values of interest to us, such as the likely name and
    path of the daemon, are obfuscated 1. As these obfuscated strings, and others
    in the code snippet, are all passed to the `ei_str` function, it seems reasonable
    to assume that this is the function responsible for string deobfuscation ([Listing
    10-14](#listing10-14)):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，我们关心的各种值，比如守护进程的名称和路径，都是混淆过的1。由于这些混淆字符串以及代码片段中的其他字符串都传递给`ei_str`函数，因此合理推测，这就是负责字符串解混淆的函数（[Listing
    10-14](#listing10-14)）：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 10-14: Obfuscated strings, passed to the `ei_str` function'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 10-14：混淆的字符串，传递给`ei_str`函数
- en: 'Of course, we should verify our assumptions. Take a closer look at the decompilation
    of the `ei_str` function in [Listing 10-15](#listing10-15):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们应该验证我们的假设。仔细查看[Listing 10-15](#listing10-15)中`ei_str`函数的反编译：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 10-15: The `ei_str` function, decompiled'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 10-15：`ei_str`函数，反编译后的代码
- en: This reveals a one-time initialization of a global variable named `eib_string_key`
    1, followed by a call into a function named `eib_secure_decode` 2, which then
    calls a method named `tpdcrypt`. The decompilation also reveals that the `ei_str`
    function takes a single parameter (the obfuscated string) and returns its deobfuscated
    value.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这揭示了一个名为`eib_string_key`的全局变量的一次性初始化1，随后调用了一个名为`eib_secure_decode` 2的函数，之后又调用了一个名为`tpdcrypt`的方法。反编译还揭示了`ei_str`函数接受一个参数（即混淆后的字符串），并返回其解混淆后的值。
- en: 'As noted in Chapter 9, we don’t actually have to concern ourselves with the
    details of the deobfuscation or decryption algorithm. We can simply set a debugger
    breakpoint at the end of the `ei_str` function and print out the deobfuscated
    string held in the `RAX` register. This is illustrated below, where after setting
    a breakpoint at the start and end of the `ei_str` function, we are able to print
    out both the obfuscated string (`"1bGvIR16wpmp1uNjl83EMxn43AtszK1T6...HRCIR3TfHDd0000063"`)
    and its deobfuscated value, a template for the malware’s launch item persistence:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如第9章所指出的，我们实际上不需要关心去模糊化或解密算法的细节。我们可以简单地在`ei_str`函数的结尾设置调试器断点，并打印出存储在`RAX`寄存器中的去模糊化字符串。如下所示，在`ei_str`函数的开始和结束设置断点后，我们能够打印出模糊化字符串（`"1bGvIR16wpmp1uNjl83EMxn43AtszK1T6...HRCIR3TfHDd0000063"`）及其去模糊化后的值，这是恶意软件启动项持久化的模板：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The downside to this approach is that we’ll only decrypt strings when the malware
    invokes the `ei_str` function and our debugger breakpoint is hit. Thus, if an
    encrypted string is only referenced in blocks of code that aren’t executed, such
    as the persistence logic that is only invoked when the malware is executed from
    within an infected file, we won’t ever see its decrypted value.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，我们只有在恶意软件调用`ei_str`函数并触发调试器断点时才会解密字符串。因此，如果加密字符串仅在未执行的代码块中引用，例如仅在恶意软件从感染文件中执行时才会调用的持久化逻辑，我们将永远看不到其解密后的值。
- en: 'For analysis purposes, it would be useful to coerce the malware to decrypt
    all these strings for us. Recall that in the last chapter we created an injectable
    dynamic library capable of exactly this. Specifically, once loaded into EvilQuest,
    it first resolves the address of the malware’s `ei_str` function and then invokes
    this function on all of the obfuscated strings embedded in the malware. In the
    last chapter, we showed an excerpt of this library’s output. [Listing 10-16](#listing10-16)
    shows it in its entirety:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 出于分析的目的，强制恶意软件解密所有这些字符串对我们将非常有用。回顾上一章，我们创建了一个可注入的动态库，能够完成这一操作。具体来说，一旦加载到EvilQuest中，它首先解析恶意软件的`ei_str`函数地址，然后对恶意软件中所有模糊化的字符串调用此函数。在上一章中，我们展示了该库输出的一个片段。[列表
    10-16](#listing10-16)展示了其完整内容：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 10-16: Decrypting all EvilQuest’s embedded strings'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-16：解密所有EvilQuest嵌入的字符串
- en: 'Among the decrypted output, we find many revealing strings:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在解密输出中，我们发现了许多揭示性字符串：
- en: The addresses of servers, potentially used for command and control, like *andrewka6.pythonanywhere.com*
    and *167.71.237.219*
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器地址，可能用于命令与控制，如*andrewka6.pythonanywhere.com*和*167.71.237.219*
- en: Regular expressions perhaps pertaining to files of interest relating to keys,
    certificates, and wallets, like `*id_rsa*/i`, `*key*.pdf/i`, `*wallet*.pdf`, and
    so on
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式可能与涉及密钥、证书和钱包的感兴趣文件相关，例如`*id_rsa*/i`、`*key*.pdf/i`、`*wallet*.pdf`等
- en: An embedded property list file likely used for launch item persistence
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个嵌入的属性列表文件，可能用于启动项持久化
- en: Names of security products such as Little Snitch and Kaspersky
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全产品的名称，如Little Snitch和Kaspersky
- en: 'Decryption instructions and file extensions for reported ransomware logic of
    the malware to target: *.zip*, *.doc*, *.txt*, and so on'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解密指令和恶意软件针对的报告勒索病毒逻辑的文件扩展名：*.zip*、*.doc*、*.txt*等
- en: These decrypted strings provide more insight into many facets of the malware
    and will aid us in our continued analysis.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解密后的字符串为我们提供了更多关于恶意软件各个方面的见解，将有助于我们继续分析。
- en: Up Next
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来
- en: In this chapter we triaged EvilQuest and identified its anti-analysis code aimed
    at hampering analysis. We then looked at how to effectively sidestep this code
    so that our analysis could continue. In the next chapter we’ll continue our study
    of this complex malware, detailing its persistence and its multitude of capabilities.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们对EvilQuest进行了分类，并识别出了其旨在阻碍分析的反分析代码。接着，我们探讨了如何有效绕过这些代码，以便我们的分析能够继续。在下一章，我们将继续研究这一复杂的恶意软件，详细介绍其持久化机制和多种功能。
- en: Endnotes
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束注释
