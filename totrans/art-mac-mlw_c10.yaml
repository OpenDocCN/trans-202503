- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: EvilQuest’s Infection, Triage, and Deobfuscation
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: EvilQuest 的感染、分类和去混淆
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: EvilQuest is a complex Mac malware specimen. Because it employs anti-analysis
    logic, a viral persistence mechanism, and insidious payloads, it’s practically
    begging to be analyzed. Let’s apply the skills you’ve gained from this book to
    do just that!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: EvilQuest 是一个复杂的 Mac 恶意软件样本。因为它使用了反分析逻辑、病毒持久性机制和隐秘的有效载荷，它几乎是刻意让人分析的。让我们运用你从本书中学到的技巧来进行分析吧！
- en: This chapter begins our comprehensive analysis of the malware by detailing its
    infection vector, triaging its binary, and identifying its anti-analysis logic.
    Chapter 11 will continue our analysis by covering the malware’s methods of persistence
    and its myriad of capabilities.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始了对恶意软件的全面分析，详细描述了它的感染途径、分类它的二进制文件，并识别了其反分析逻辑。第 11 章将继续我们的分析，介绍恶意软件的持久性方法及其众多功能。
- en: The Infection Vector
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 感染途径
- en: Much like a biological virus, identifying a specimen’s infection vector is frequently
    the best way to understand its potential impact and thwart its continued spread.
    So, when you’re analyzing a new malware specimen, one of your first goals is answering
    the question, “How does the malware infect Mac systems?”
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 就像生物病毒一样，识别一个样本的感染途径通常是了解其潜在影响并阻止其继续传播的最佳方法。因此，当你分析一个新的恶意软件样本时，首先要回答的问题之一就是：“恶意软件是如何感染
    Mac 系统的？”
- en: As you saw in Chapter 1, malware authors employ a variety of tactics, ranging
    from unsophisticated social engineering attacks to powerful zero-day exploits,
    to infect Mac users. Dinesh Devadoss, the researcher who discovered EvilQuest,
    did not specify how the malware was able to infect Mac users.^([1](#c10-endnote-1))
    However, another researcher, Thomas Reed, later noted that the malware had been
    found in pirated versions of popular macOS software shared on torrent sites. Specifically,
    he wrote about
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第一章中看到的，恶意软件作者使用了各种策略，从不太复杂的社交工程攻击到强大的零日漏洞，来感染 Mac 用户。发现 EvilQuest 的研究员
    Dinesh Devadoss 并没有具体说明恶意软件是如何感染 Mac 用户的。^([1](#c10-endnote-1)) 然而，另一位研究员 Thomas
    Reed 后来指出，恶意软件出现在通过种子网站分享的盗版流行 macOS 软件中。他特别写道
- en: an apparently malicious Little Snitch installer available for download on a
    Russian forum dedicated to sharing torrent links. A post offered a torrent download
    for Little Snitch, and was soon followed by a number of comments that the download
    included malware. In fact, we discovered that not only was it malware, but a new
    Mac ransomware variant spreading via piracy.^([2](#c10-endnote-2))
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个看似恶意的 Little Snitch 安装程序可以在一个专门分享种子链接的俄罗斯论坛上下载。一篇帖子提供了 Little Snitch 的种子下载链接，随后不久便有许多评论指出该下载包含恶意软件。事实上，我们发现它不仅是恶意软件，而且是一个通过盗版传播的新型
    Mac 勒索病毒变种。^([2](#c10-endnote-2))
- en: Distributing pirated or cracked applications that have been maliciously trojanized
    is a fairly common method of targeting macOS users for infection. Though not the
    most sophisticated approach, it is rather effective, as many users have a distaste
    for paid software and instead seek out pirated alternatives. [Figure 10-1](#figure10-1)
    shows the download link for the malicious Little Snitch software.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 分发被恶意篡改的盗版或破解应用程序是一个相当常见的针对 macOS 用户进行感染的方法。虽然这不是最复杂的方法，但它相当有效，因为许多用户不喜欢付费软件，而是寻找盗版替代品。[图
    10-1](#figure10-1) 显示了恶意 Little Snitch 软件的下载链接。
- en: '![The webpage for pirating Little Snitch contains information about the software,
    such as the year—2020—the version, developer, description, and so on. At the bottom
    of the screen is a link to “Download the distribution by magnet link (59.3 MB).”
    Beneath the link is a warning: “Your Internet Provider and Government can see
    what you are downloading. Don’t forget to hide your IP with VPN to avoid fines
    and lawsuits!” Links to NordVPN, ExpressVPN, and others are directly below.](image_fi/501942c10/f10001.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![盗版 Little Snitch 的网页包含了关于软件的信息，例如年份——2020年——版本、开发者、描述等等。屏幕底部有一个链接，指向“通过磁力链接下载分发版（59.3
    MB）”。链接下方有一则警告：“您的互联网服务提供商和政府能够看到您下载的内容。别忘了使用 VPN 隐藏您的 IP 以避免罚款和诉讼！”下面直接链接到 NordVPN、ExpressVPN
    等。](image_fi/501942c10/f10001.png)'
- en: 'Figure 10-1: Pirated version of Little Snitch trojanized with EvilQuest'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-1：被 EvilQuest 篡改的盗版 Little Snitch
- en: Of course, this infection vector requires user interaction. Specifically, in
    order to become infected with EvilQuest, users would have to download and run
    an infected application. Moreover, as you’ll see, the malware’s installer package
    is unsigned, so users on recent versions of macOS may have to proactively take
    steps to bypass system notarization checks.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种感染途径需要用户交互。具体来说，为了感染 EvilQuest，用户必须下载并运行被感染的应用程序。此外，正如你将看到的，恶意软件的安装包是未签名的，因此在
    macOS 的新版本上，用户可能需要主动采取步骤绕过系统的 notarization 检查。
- en: In an attempt to infect as many Mac users as possible, the malware authors surreptitiously
    trojanized many different pirated applications distributed via torrent sites.
    In this chapter, we’ll focus on a sample that was maliciously packaged up with
    the popular DJ application Mixed In Key.^([3](#c10-endnote-3))
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能感染更多的 Mac 用户，恶意软件作者悄悄篡改了许多通过 torrent 网站分发的盗版应用程序。在本章中，我们将重点关注一个恶意包装的示例，它是与流行
    DJ 应用程序 Mixed In Key 一起捆绑的。^([3](#c10-endnote-3))
- en: Triage
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分类
- en: Recall that an application is actually a special directory structure called
    a *bundle* that must be packaged up before being distributed. The sample of EvilQuest
    we’re analyzing here was distributed as a disk image, *Mixed In Key 8.dmg*. As
    shown in [Figure 10-2](#figure10-2), when first discovered, this sample’s SHA-256
    hash (B34738E181A6119F23E930476AE949FC0C7C4DED6EFA003019FA946C4E5B287A) was not
    flagged as malicious by any of the antivirus engines on the aggregate scanning
    site VirusTotal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一个应用程序实际上是一个特殊的目录结构，称为 *bundle*，在分发之前必须将其打包。我们正在分析的 EvilQuest 样本是作为一个磁盘镜像
    *Mixed In Key 8.dmg* 分发的。如图 [10-2](#figure10-2) 所示，首次发现该样本时，其 SHA-256 哈希值（B34738E181A6119F23E930476AE949FC0C7C4DED6EFA003019FA946C4E5B287A）并未被
    VirusTotal 上的任何杀毒引擎标记为恶意。
- en: '![Mixed In Key 8.dmg is shown to have a score of 0/58 on VirusTotal.](image_fi/501942c10/f10002.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Mixed In Key 8.dmg 在 VirusTotal 上显示的得分为 0/58。](image_fi/501942c10/f10002.png)'
- en: 'Figure 10-2: The trojanized *Mixed* *In* *Key 8.dmg* file on VirusTotal'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-2：VirusTotal 上被篡改的 *Mixed* *In* *Key 8.dmg* 文件
- en: Of course, today this disk image is widely detected as containing malware.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，今天这个磁盘镜像被广泛检测为含有恶意软件。
- en: Confirming the File Type
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确认文件类型
- en: As analysis tools are often file-type specific and malware authors may attempt
    to mask the true file type of their malicious creations, it is wise to first determine
    or confirm a file’s true type when you are presented with a potentially malicious
    specimen. Here we attempt to use the `file` utility to confirm that the trojanized
    *Mixed In Key 8.dmg* is indeed a disk image.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分析工具通常针对特定的文件类型，而且恶意软件作者可能会尝试掩盖其恶意创作的真实文件类型，因此在遇到潜在的恶意样本时，首先确定或确认文件的真实类型是明智的。在这里，我们尝试使用
    `file` 工具确认被篡改的 *Mixed In Key 8.dmg* 确实是一个磁盘镜像。
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Oops, looks like the `file` utility misidentified the file as something other
    than a disk image. This is unsurprising, as disk images compressed with zlib are
    often reported as “VAX COFF” due to the zlib header.^([4](#c10-endnote-4))
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，看起来 `file` 工具错误地将该文件识别为磁盘镜像以外的其他类型。这并不意外，因为使用 zlib 压缩的磁盘镜像通常会因 zlib 头部而被报告为“VAX
    COFF”。^([4](#c10-endnote-4))
- en: Let’s try again, this time using my WhatsYourSign (WYS) utility, which shows
    an item’s code-signing information and more accurately identifies the item’s file
    type. As you can see in [Figure 10-3](#figure10-3), the tool’s Item Type field
    confirms that *Mixed In Key 8.dmg* is indeed a disk image, as expected.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一次，这次使用我的 WhatsYourSign (WYS) 工具，它显示了项的代码签名信息并更准确地识别项的文件类型。如图 [10-3](#figure10-3)
    所示，该工具的“项类型”字段确认 *Mixed In Key 8.dmg* 确实是一个磁盘镜像，正如预期的那样。
- en: '![In the WhatsYourSign tool, Mixed In Key 8.dmg contains the following information:
    “Item Type: Disk Image,” “Entitled: None,” and “Sign Auths: unsigned (‘errSecCSUnsigned’).”](image_fi/501942c10/f10003.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![在 WhatsYourSign 工具中，Mixed In Key 8.dmg 包含以下信息：“项类型：磁盘镜像”，“授权：无”，“签名认证：未签名（‘errSecCSUnsigned’）”。](image_fi/501942c10/f10003.png)'
- en: 'Figure 10-3: WYS confirms the item as a disk image'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-3：WYS 确认该项为磁盘镜像
- en: Extracting the Contents
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取内容
- en: 'Once we’ve confirmed that this *.dmg* file is indeed a disk image, our next
    task is to extract the disk image’s contents for analysis. Using macOS’s built-in
    `hdiutil` utility, we can mount the disk image to access its files:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确认该 *.dmg* 文件确实是一个磁盘镜像，我们的下一步任务就是提取磁盘镜像的内容以供分析。使用 macOS 内建的 `hdiutil` 工具，我们可以挂载磁盘镜像并访问其文件：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once this command has completed, the disk image will be mounted to */Volumes/Mixed
    In Key 8/*. Listing the contents of this directory reveals a single file, *Mixed
    In Key 8.pkg*, which appears to be an installer package ([Listing 10-1](#listing10-1)):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 10-1: Listing the mounted disk image’s contents'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: We again turn to WYS to confirm that the *.pkg* file is indeed a package, and
    also to check the package’s signing status. As you can see in [Figure 10-4](#figure10-4),
    the *.pkg* file type is confirmed, though the package is unsigned.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![In the WhatsYourSign tool, Mixed In Key 8.dmg shows the following information:
    “Item Type: Installer package archive,” “Entitled: none,” “Sign Auths: unsigned
    (‘errSecCSUnsigned’).”](image_fi/501942c10/f10004.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-4: WYS confirms the item as an unsigned package'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also check any package signatures (or lack thereof) from the terminal
    with the `pkgutil` utility. Just pass in `--check-signature` and the path to the
    package, as shown in [Listing 10-2](#listing10-2):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 10-2: Checking the package’s signature'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: As the package is unsigned, macOS will prompt the user before allowing it to
    be opened. However, users attempting to pirate software will likely ignore this
    warning, pressing onwards and inadvertently commencing the infection.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Package
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Chapter 4 we discussed using the Suspicious Package utility to explore the
    contents of installer packages. Here we’ll use it to open *Mixed In Key 8.pkg*
    ([Figure 10-5](#figure10-5)). In the All Files tab, we’ll find an application
    named *Mixed In Key 8.app* and an executable file simply named *patch*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![In the Suspicious Package tool, Mixed In Key 8.dmg is shown to contain an
    Applications folder with the Mixed In Key 8.app file and a Utils folder that contains
    an executable file named Patch.](image_fi/501942c10/f10005.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-5: Using Suspicious Package to explore files within the trojanized
    *Mixed in Key* package'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: We’ll triage these files shortly, but first we should check for any pre- or
    post-install scripts. Recall that when a package is installed, any such scripts
    will also be automatically executed. As such, if an installer package contains
    malware, you’ll often find malicious installer logic within these scripts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking the **All Scripts** tab reveals that *Mixed In Key 8.pkg* does contain
    a post-install script ([Listing 10-3](#listing10-3)):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 10-3: *Mixed* *In* *Key 8.pkg*’s post-install script'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'When the trojanized *Mixed In Key 8.pkg* is installed, the script will be executed
    and performs the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory named */Library/mixednkey*.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the *patch* binary (which was installed to */Applications/Utils/patch*)
    into the newly created */Library/mixednkey* directory as a binary named *toolroomd*.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attempt to delete the */Applications/Utils/* directory (created earlier in the
    install process). However, due to a bug in the command (the malware author missed
    the “s” in */Applications*), this will fail.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the *toolroomd* binary to be executable.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*toolroomd*二进制文件设置为可执行。
- en: Launch the *toolroomd* binary in the background.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后台启动*toolroomd*二进制文件。
- en: The installer requests root privileges during the install, so if the user provides
    the necessary credentials, this post-install script will also run with elevated
    privileges.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序在安装过程中请求root权限，因此如果用户提供必要的凭据，此后安装脚本也将以提升的特权运行。
- en: 'Through dynamic analysis monitoring tools, such as my ProcessMonitor and FileMonitor,
    we can passively observe this installation process, including the execution of
    the post-install script and the script’s commands ([Listing 10-4](#listing10-4)):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过动态分析监控工具（例如我的ProcessMonitor和FileMonitor），我们可以被动观察此安装过程，包括执行后安装脚本和脚本的命令（[清单10-4](#listing10-4)）：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 10-4: Monitoring the actions of the malicious post-install script'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 清单10-4：监控恶意后安装脚本的操作
- en: In this abridged output from ProcessMonitor, you can see various commands from
    the post-install script, such as `mkdir` and `mv`, being executed as the malware
    is installed. Most notably, observe that at its completion the script executes
    the malware, now installed as *toolroomd* 1.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在来自ProcessMonitor的这段缩减输出中，您可以看到来自后安装脚本的各种命令（例如`mkdir`和`mv`）在安装恶意软件时被执行。 特别要注意，在完成时脚本会执行已安装为*toolroomd*
    1的恶意软件。
- en: Let’s now extract both the *Mixed In Key 8* application and *patch* binary from
    the package using Suspicious Package by exporting each file. First, let’s take
    a peek at the *Mixed In Key 8* application. By using WYS, we can see that it is
    still validly signed by the Mixed In Key developers ([Figure 10-6](#figure10-6)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用Suspicious Package从包中分别导出*Mixed In Key 8*应用程序和*patch*二进制文件。 首先，让我们来看一下*Mixed
    In Key 8*应用程序。 通过使用WYS，我们可以看到它仍然由Mixed In Key开发人员有效签名（[图10-6](#figure10-6)）。
- en: '![In the WhatsYourSign tool, Mixed In Key 8.app is declared to be “validly
    signed,” with the signer listed as “Apple Dev-ID.” More information is available
    under sign auth: “Developer ID Application: Mixed In Key, LLC (T4A2E2DEM7),” “Developer
    ID Certification Authority,” “Apple Root CA.”](image_fi/501942c10/f10006.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![在WhatsYourSign工具中，Mixed In Key 8.app被声明为“有效签名”，签名者列为“Apple Dev-ID”。 更多信息在签名认证下可用：“Developer
    ID Application：Mixed In Key，LLC（T4A2E2DEM7）”，“Developer ID Certification Authority”，“Apple
    Root CA”。](image_fi/501942c10/f10006.png)'
- en: 'Figure 10-6: The still validly signed application (via WYS)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-6：仍然有效签名的应用程序（通过WYS）
- en: Confirming the validity of an item’s code-signing signature tells us that it
    has not been modified or tampered with since being signed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 确认项目代码签名签名的有效性告诉我们它自签名以来未被修改或篡改。
- en: Could the malware authors have compromised Mixed In Key, stolen its code-signing
    certificate, surreptitiously modified the application, and then re-signed it?
    Fair question, and the answer is that it’s possible, though highly unlikely. If
    this were the case, the malware authors probably wouldn’t have had to resort to
    such an unsophisticated infection mechanism (distributing the software via shady
    torrent sites), nor would they have had to include another unsigned binary in
    the package.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者是否可能已经篡改了Mixed In Key，并窃取了其代码签名证书，偷偷修改了应用程序，然后重新签名？ 公平的问题，答案是可能的，尽管可能性极小。
    如果是这种情况，恶意软件作者可能不必采用如此低级的感染机制（通过不光彩的种子站点分发软件），也不必在包中包含另一个未签名的二进制文件。
- en: 'As the main application remains validly signed by the developers, let’s turn
    our attention to the *patch* file. As you’ll see shortly, this is the malware.
    (Recall that it gets installed as a file called *toolroomd.*) Using the `file`
    utility we can determine that it is a 64-bit Mach-O binary, and the `codesign`
    utility indicates that it is unsigned:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于主应用程序仍由开发人员有效签名，让我们将注意力转向*补丁*文件。 正如您很快将看到的那样，这是恶意软件。 （请记住，它作为名为*toolroomd*的文件安装。）使用`file`实用程序，我们可以确定它是一个64位Mach-O二进制文件，而`codesign`实用程序则指示它未经签名：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As *patch* is a binary rather than, say, a script, we’ll continue our analysis
    by leveraging static analysis tools that are either file-type agnostic or specifically
    tailored toward binary analysis.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*patch*是二进制文件而不是脚本，我们将通过利用无论文件类型是否特定于二进制分析的静态分析工具来继续我们的分析。
- en: Extracting Embedded Information from the patch Binary
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从补丁二进制文件中提取嵌入信息
- en: 'First we’ll run the `strings` utility to extract any embedded ASCII strings,
    as these strings can often provide valuable insight into the malware’s logic and
    capabilities. Note that I’ve reordered the output for convenience ([Listing 10-5](#listing10-5)):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 10-5: Extracting embedded strings'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the embedded strings reveals strings that appear to be command line
    arguments (like `--silent`), networking requests (like `GET /%s HTTP/1.0`), potential
    file-encryption logic (like `_generate_xkey`), and key mappings (like `[right-cmd]`),
    possibly indicating the presence of keylogging logic. We also uncover a path that
    contains a directory name (*toidievitceffe*) that unscrambles to “effectiveidiot.”
    Our continued analysis will soon reveal other strings and function names containing
    the abbreviation “ei” (such as `EI_RESCUE` and `ei_loader_main`). It seems likely
    that “effectiveidiot” is the moniker given to the malware by its developers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The output from the `strings` utility reveals a large number of embedded strings
    (like `2Uy5DI3hMp7o0cq|T|14vHRz0000013`) that appear obfuscated. These nonsensical
    strings likely indicate that EvilQuest employs anti-analysis. Shortly we’ll break
    this anti-analysis logic to deobfuscate all such strings. First, though, let’s
    statically extract more information from the malware.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that macOS’s built-in `nm` utility can extract embedded information,
    such as function names and system APIs invoked by the malware. Like the output
    of the `strings` utility, this information can provide insight into the malware’s
    capabilities and guide continued analysis. Let’s run `nm` on the *patch* binary,
    as in [Listing 10-6](#listing10-6). Again, I’ve reordered the output for convenience:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 10-6: Extracting embedded names (API calls, functions, and so on)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: First we see references to system APIs, such as `CGEventTapCreate` and `CGEventTapEnable`,
    often leveraged to capture user keypresses, as well as `NSCreateObjectFileImageFromMemory`
    and `NSLinkModule`, which can be used to execute binary payloads in memory. The
    output also contains a long list of function names that map directly back to the
    malware’s original source code. Unless these are named incorrectly to mislead
    us, they can provide insight into many aspects of the malware. For example,
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '`is_debugging`, `is_virtual_mchn`, and `prevent_trace` may indicate that the
    malware implements dynamic-analysis-thwarting logic.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_host_identifier` and `get_process_list` may indicate host survey capabilities.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`persist_executable` and `install_daemon` likely relate to how the malware
    persists.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eib_secure_decode` and `eib_string_key` may be responsible for decoding the
    obfuscated strings.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_targets`, `is_target`, and `eip_encrypt` could contain the malware’s purported
    ransomware logic.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `react_*` functions (such as `react_exec`) possibly contain the logic to
    execute remote commands from the attacker’s command and control server.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, we should verify this functionality during static or dynamic analysis.
    However, these names alone can help focus our continued analysis. For example,
    it would be wise to statically analyze what appear to be various anti-analysis
    functions before beginning a debugging session, as those functions may attempt
    to thwart the debugger and thus would need to be bypassed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the Command Line Parameters
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Armed with the myriad of intriguing information collected during our static
    analysis triage, it’s time to dig a little deeper. We can disassemble the *patch*
    binary by loading it into a disassembler, such as Hopper. A quick triage of the
    disassembler code reveals that the core logic of the *patch* binary occurs within
    its main function, which is rather extensive. First the binary parses any command
    line parameters looking for `--silent`, `--noroot`, and `--ignrp`. If these command
    line arguments are present, various flags are set. If we then analyze code that
    references these flags, we can ascertain their meaning.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: --silent
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If `--silent` is passed in via the command line, the malware sets a global variable
    to 0\. This appears to instruct the malware to run “silently,” for example suppressing
    the printing of error messages. In the following snippet of disassembly, the value
    of a variable (which I’ve named `silent` below) is first checked via the `cmp`
    instruction. If it is set, the malware will jump over the call to the `printf`
    function so that an error message is not displayed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This flag is also passed to the `ei_rootgainer_main` function, which influences
    how the malware (running as a normal user) may request root privileges. Note,
    in the following disassembly, that the address of the flag is loaded into the
    `RDX` register, which holds the third argument in the context of a function call:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Interestingly, this flag is explicitly initialized to 0 (and set to 0 again
    if the `--silent` parameter is specified). It appears to never be set to 1 (true).
    Thus, the malware will always run in “silent” mode, even if `--silent` is not
    specified. It’s possible that, in a debug build of the malware, the flag could
    be initialized to 1 as the default value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: To acquire root privileges, the `ei_rootgainer_main` function calls into a helper
    function, `run_as_admin_async`, to execute the following (originally encrypted)
    command, substituting itself for the `%s`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This results in an authentication prompt from the macOS built-in `osascript`
    ([Figure 10-7](#figure10-7)).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![The authentication prompt states, “osascript wants to make changes. Enter
    your password to allow this.”](image_fi/501942c10/f10007.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-7: The malware’s authentication prompt, via `osascript`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: If the user provides appropriate credentials, the malware will have gained root
    privileges.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: --noroot
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If `--noroot` is passed in via the command line, the malware sets another flag
    to 1 (true). Various code within the malware then checks this flag and, if it
    is set, takes different actions, such as skipping the request for root privileges.
    In the snippet of disassembled code, note that if the flag (initially `var_20`
    but named `noRoot` here) is set, the call to the `ei_rootgainer_main` function
    is skipped.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过命令行传入了`--noroot`，恶意软件会将另一个标志设置为1（真）。恶意软件内部的各种代码会检查此标志，如果设置了该标志，则采取不同的操作，如跳过请求根权限的步骤。在反汇编代码片段中，请注意，如果设置了标志（最初为`var_20`但此处命名为`noRoot`），则跳过对`ei_rootgainer_main`函数的调用。
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `--noroot` argument is also passed to a persistence function, `ei_persistence_main`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`--noroot`参数也被传递给一个持久性函数`ei_persistence_main`：'
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Subsequent analysis of this function reveals that this flag dictates how the
    malware persists; either as a launch daemon or a launch agent. Recall that persisting
    as a launch daemon requires root privileges, whereas persisting as a launch agent
    requires only user privileges.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对该函数的后续分析显示，此标志决定了恶意软件的持久性方式；作为启动守护程序需要根权限，而作为启动代理则只需要用户权限。
- en: --ignrp
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: --ignrp
- en: If `--ignrp` (“ignore persistence”) is passed in via the command line, the malware
    sets a flag to 1 and instructs itself not to manually start any persisted launch
    items.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过命令行传入了`--ignrp`（“忽略持久性”），恶意软件会将一个标志设置为1，并指示自己不启动任何持久启动项。
- en: 'We can confirm this by examining disassembled code in the `ei_selfretain_main`
    function, which contains logic to load persisted components. This function first
    checks the flag (named `ignorePersistence` here) and, if it’s not set, the function
    simply returns without loading the persisted items:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查`ei_selfretain_main`函数中的反汇编代码来确认这一点，该函数包含加载持久组件的逻辑。此函数首先检查标志（此处命名为`ignorePersistence`），如果未设置，则函数将简单返回而不加载持久项目：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that, even if the `--ignrp` command line option is specified, the malware
    itself will still persist and thus be automatically restarted each time an infected
    system is rebooted or the user logs in.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使指定了`--ignrp`命令行选项，恶意软件仍将持久存在，因此在感染系统重新启动或用户登录时会自动重新启动。
- en: Analyzing Anti-Analysis Logic
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析反分析逻辑
- en: If a malicious sample contains anti-analysis logic, we must identify and thwart
    it to continue our analysis. Luckily for us, other than what appear to be encrypted
    strings, EvilQuest does not seem to employ any methods that will hinder our static
    analysis efforts. However, we’re not so lucky when it comes to dynamic analysis.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果恶意样本包含反分析逻辑，我们必须识别并挫败它以继续分析工作。幸运的是，除了看起来是加密字符串外，EvilQuest似乎没有采用任何会妨碍我们静态分析的方法。但是，当涉及到动态分析时，我们的运气就不那么好了。
- en: As noted in Chapter 9, a sample prematurely exiting when run in a virtual machine
    or debugger likely indicates that some sort of dynamic anti-analysis logic was
    triggered. If you try to run EvilQuest in a debugger, you’ll notice that it simply
    terminates. This isn’t surprising; recall that the malware contains functions
    with names such as `is_debugging` and `prevent_trace`. A function named `is_virtual_mchn`
    is also invoked before these likely anti-debugger functions. Let’s begin our analysis
    of what appears to be the malware’s anti-analysis logic there.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如第9章所述，样本在虚拟机或调试器中运行时过早退出，通常表明触发了某种动态反分析逻辑。如果尝试在调试器中运行EvilQuest，您会注意到它简单地终止。这并不奇怪；请回想一下，恶意软件包含名称为`is_debugging`和`prevent_trace`的函数。在这些可能是反调试函数之前，还调用了名为`is_virtual_mchn`的函数。让我们从那里开始分析看起来是恶意软件的反分析逻辑。
- en: Virtual Machine–Thwarting Logic?
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防虚拟机逻辑？
- en: 'In your disassembler, take a look at `0x000000010000be5f` in the main function.
    Once the malware has processed any command line options, it invokes a function
    named `is_virtual_mchn`. As shown in the following snippet of decompiled code,
    the malware will prematurely exit if this function returns a nonzero value:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的反汇编器中，查看主函数中的`0x000000010000be5f`。一旦恶意软件处理了任何命令行选项，它就会调用一个名为`is_virtual_mchn`的函数。如下所示的反编译代码片段显示，如果此函数返回非零值，恶意软件将会提前退出：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let’s take a closer look at the decompilation of this function ([Listing 10-7](#listing10-7)),
    as we want to ensure the malware runs (or can be coerced to run) in a virtual
    machine, such that we can analyze it dynamically.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地查看此函数的反编译（[Listing 10-7](#listing10-7)），因为我们希望确保恶意软件在虚拟机中运行（或可以被迫在虚拟机中运行），以便我们可以动态分析它。
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 10-7: Anti-sandbox check, through time checks'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 10-7: 反沙箱检测，通过时间检查'
- en: As you can see in the decompilation of `is_virtual_mchn`, the `time` function
    is invoked twice, with a call to `sleep` in between. It then compares the differences
    between the two calls to `time` to match the amount of time that the code slept
    for. This allows it to detect sandboxes that patch, or speed up, calls to `sleep`.
    As security researcher Clemens Kolbitsch has noted,
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Sandboxes will patch the sleep function to try to outmaneuver malware that uses
    time delays. In response, malware will check to see if time was accelerated. Malware
    will get the timestamp, go to sleep and then again get the timestamp when it wakes
    up. The time difference between the timestamps should be the same duration as
    the amount of time the malware was programmed to sleep. If not, then the malware
    knows it is running in an environment that is patching the sleep function, which
    would only happen in a sandbox.^([5](#c10-endnote-5))
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This means that, in reality, the `is_virtual_mchn` function is more of a sandbox
    check and will not actually detect a standard virtual machine, which doesn’t manipulate
    any time constructs. That’s good news for our continued analysis of the malware,
    which occurs within an isolated virtual machine.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Debugging-Thwarting Logic
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We also need to discuss the other anti-analysis mechanisms employed by the
    malware, as this logic could thwart our dynamic analysis efforts later. Recall
    that in the output of the `strings` utility, we saw what appeared to be anti-debugging
    functions: `is_debugging` and `prevent_trace`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'The `is_debugging` function is implemented at address `0x0000000100007aa0`.
    Looking at a snippet of annotated disassembly of this function in [Listing 10-8](#listing10-8),
    we see the malware invoking the `sysctl` function with `CTL_KERN`, `KERN_PROC`,
    `KERN_PROC_PID`, and its PID, obtained via the `getpid()` API function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 10-8: The start of anti-debugging logic, via the `sysctl` API'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Once the `sysctl` function has returned, the malware checks the `p_flag` member
    of the `info.kp_proc` structure populated by the call to `sysctl` to see whether
    it has the `P_TRACED` flag set ([Listing 10-9](#listing10-9)). As this flag is
    only set if the process is being debugged, the malware can use it to determine
    if it is being debugged.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 10-9: Is the `P_TRACED` flag (`0x800`) set? If so, the process is being
    debugged.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: If the `is_debugging` function detects a debugger, it returns a nonzero value,
    as shown in [Listing 10-10](#listing10-10)’s full reconstruction, which I’ve based
    on the decompilation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 10-10: Anti-debugging logic that uses `sysctl` and `P_TRACED`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Code such as the `ei_persistence_main` function invokes the `is_debugging`
    function and promptly terminates if a debugger is detected ([Listing 10-11](#listing10-11)):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 10-11: A premature exit if a debugger is detected'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: To circumvent this anti-analysis logic, we can either modify EvilQuest’s binary
    and patch out this code or use a debugger to subvert the malware’s execution state
    in memory. If you wanted to modify the code, you could replace the `cmovnz` instruction
    (at `0x0000000100007b7a`) with an instruction such as `xor eax, eax` to zero out
    the return value from the function. As this replacement instruction is one byte
    less than the `cmovnz`, you’ll have to add a one-byte NOP instruction for padding.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'The debugging approach proves more straightforward, as we can simply zero out
    the return value from the `is_debugging` function. Specifically, we can first
    set a breakpoint on the instruction immediately following the call to the `is_debugging`
    function (`0x000000010000b89f`), which checks the return value via `cmp eax, 0x0`.
    Once the breakpoint is hit, we can set the `RAX` register to 0 with `reg write
    $rax 0`, leaving the malware blind to the fact that it’s being debugged:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We’re not quite done yet, as the malware also contains a function named `prevent_trace`,
    which, as the name suggests, attempts to prevent tracing via a debugger. [Listing
    10-12](#listing10-12) shows the complete annotated disassembly of the function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 10-12: Anti-debugging logic via the `ptrace` API'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: After invoking the `getpid` function to retrieve its process ID, the malware
    invokes `ptrace` with the `PT_DENY_ATTACH` flag (`0x1f`) 1. As noted in the previous
    chapter, this hinders debugging in two ways. First of all, once this call has
    been made, any attempt to attach a debugger will fail. Secondly, if a debugger
    is already attached, the process will immediately terminate after this call is
    made.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: To subvert this logic so that the malware can be debugged to facilitate continued
    analysis, we again leverage the debugger to avoid the call to `prevent_trace`
    altogether. First we set a breakpoint at `0x000000010000b8b2`, which is a call
    that invokes this function. Once the breakpoint is hit, we modify the value of
    the instruction pointer (`RIP`) to point to the next instruction (at `0x000000010000b8b7`).
    This ensures the problematic call to `ptrace` is never executed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Continued analysis reveals that all of EvilQuest’s anti-debugger functions are
    invoked from within a single function (`ei_persistence_main`). Thus, we can actually
    set a single breakpoint within the `ei_persistence_main` function and then modify
    the instruction pointer to jump past both anti-debugging calls. However, as the
    `ei_persistence_main` function is called multiple times, our breakpoint would
    be hit multiple times, requiring us to manually modify `RIP` each time. A more
    efficient approach would be to add a command to this breakpoint to instruct the
    debugger to automatically both modify `RIP` when the breakpoint is hit and then
    continue.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'First let’s set a breakpoint at the `call is_debugging` instruction (found
    at `0x000000010000b89a`). Once the breakpoint is set we add a breakpoint command
    via `br command add`. In this command we can instruct the debugger to modify `RIP`,
    setting it to the address immediately following the call to the second anti-debugging
    function, `prevent_trace` (`0x000000010000b8b7`), as shown in [Listing 10-13](#listing10-13):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 10-13: Bypassing anti-debugging logic with a breakpoint command'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: As we also added `continue` to our breakpoint command, the debugger will automatically
    continue execution once the instruction pointer has been modified. Once the breakpoint
    command has been added, both the call to `is_debugging` and the `prevent_trace`
    anti-debugging functions will be automatically skipped. With EvilQuest’s anti-analysis
    logic fully thwarted, our analysis can continue uninhibited.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Obfuscated Strings
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Back in the main function, the malware gathers some basic user information,
    such as the value of the `HOME` environment variable, and then it invokes a function
    named `extract_ei`. This function attempts to read `0x20` bytes of “trailer” data
    from the end of its on-disk binary image. However, as a function named `unpack_trailer`
    (invoked by `extract_ei`) returns 0 (false), a check for the magic value of `0xdeadface`
    fails:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Subsequent analysis will soon uncover the fact that the `0xdeadface` value is
    placed at the end of other binaries the malware infects. In other words, this
    is the malware checking whether it is running via a host binary that has been
    (locally) virally infected.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'The function returning 0 causes the malware to skip certain repersistence logic
    that appears to persist the malware as a daemon:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It appears that various values of interest to us, such as the likely name and
    path of the daemon, are obfuscated 1. As these obfuscated strings, and others
    in the code snippet, are all passed to the `ei_str` function, it seems reasonable
    to assume that this is the function responsible for string deobfuscation ([Listing
    10-14](#listing10-14)):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 10-14: Obfuscated strings, passed to the `ei_str` function'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we should verify our assumptions. Take a closer look at the decompilation
    of the `ei_str` function in [Listing 10-15](#listing10-15):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 10-15: The `ei_str` function, decompiled'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: This reveals a one-time initialization of a global variable named `eib_string_key`
    1, followed by a call into a function named `eib_secure_decode` 2, which then
    calls a method named `tpdcrypt`. The decompilation also reveals that the `ei_str`
    function takes a single parameter (the obfuscated string) and returns its deobfuscated
    value.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted in Chapter 9, we don’t actually have to concern ourselves with the
    details of the deobfuscation or decryption algorithm. We can simply set a debugger
    breakpoint at the end of the `ei_str` function and print out the deobfuscated
    string held in the `RAX` register. This is illustrated below, where after setting
    a breakpoint at the start and end of the `ei_str` function, we are able to print
    out both the obfuscated string (`"1bGvIR16wpmp1uNjl83EMxn43AtszK1T6...HRCIR3TfHDd0000063"`)
    and its deobfuscated value, a template for the malware’s launch item persistence:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The downside to this approach is that we’ll only decrypt strings when the malware
    invokes the `ei_str` function and our debugger breakpoint is hit. Thus, if an
    encrypted string is only referenced in blocks of code that aren’t executed, such
    as the persistence logic that is only invoked when the malware is executed from
    within an infected file, we won’t ever see its decrypted value.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'For analysis purposes, it would be useful to coerce the malware to decrypt
    all these strings for us. Recall that in the last chapter we created an injectable
    dynamic library capable of exactly this. Specifically, once loaded into EvilQuest,
    it first resolves the address of the malware’s `ei_str` function and then invokes
    this function on all of the obfuscated strings embedded in the malware. In the
    last chapter, we showed an excerpt of this library’s output. [Listing 10-16](#listing10-16)
    shows it in its entirety:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 10-16: Decrypting all EvilQuest’s embedded strings'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the decrypted output, we find many revealing strings:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The addresses of servers, potentially used for command and control, like *andrewka6.pythonanywhere.com*
    and *167.71.237.219*
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions perhaps pertaining to files of interest relating to keys,
    certificates, and wallets, like `*id_rsa*/i`, `*key*.pdf/i`, `*wallet*.pdf`, and
    so on
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An embedded property list file likely used for launch item persistence
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Names of security products such as Little Snitch and Kaspersky
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Decryption instructions and file extensions for reported ransomware logic of
    the malware to target: *.zip*, *.doc*, *.txt*, and so on'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These decrypted strings provide more insight into many facets of the malware
    and will aid us in our continued analysis.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Up Next
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter we triaged EvilQuest and identified its anti-analysis code aimed
    at hampering analysis. We then looked at how to effectively sidestep this code
    so that our analysis could continue. In the next chapter we’ll continue our study
    of this complex malware, detailing its persistence and its multitude of capabilities.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Endnotes
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
