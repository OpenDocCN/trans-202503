- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays, Pointers, and Strings
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: So far, we’ve used very simple integers to represent data. But let’s face it,
    not everything in the world can be described as a single integer. In this chapter
    you’ll learn some of the basics of organizing your data.
  prefs: []
  type: TYPE_NORMAL
- en: First, you’ll learn about *arrays*, which are data structures that hold multiple
    items you can select using an integer index. I’ll also go a little beyond simple
    arrays to show you how the compiler implements arrays and how arrays implement
    strings of characters like `"Hello World!\n"`. Along the way, you’ll learn to
    work with C’s `char` type.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn how to use memory *pointers*, which hold the address of a memory
    location, and then see how arrays and pointers are both similar and different.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also learn how to use the `const` modifier to create a variable that
    cannot be modified, better known as a *constant*. Constants help you organize
    your data by preventing unintentional changes to it.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ve already seen how to declare a basic variable, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This variable can hold only one value at a time. Yet we can also declare a
    variable that holds a set of values using an *array declaration*, which places
    the number of items to include in the array in brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This code declares an array of five integers numbered 0, 1, 2, 3, and 4\. The
    element numbers are called *indices*, and the first index is 0, not 1\. To access
    individual elements of the array, we use square brackets containing an index.
    For example, the following line assigns a value of 99 to the fourth item in the
    array (the one at index 3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing in the C language that prevents you from indexing a nonexistent
    array element, but although it is possible to use an illegal index, the results
    are not defined (meaning something bad will probably happen). For example, the
    last element of `anArray` is 4, so the following declaration is legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this one isn’t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This statement tries to access an element that isn’t in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how arrays work in action. Take a look at [Listing 6-1](#listing6-1),
    which is a program that sums the elements of an array and outputs the total.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-1: Basic array usage'
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining a variable, `NUMBER_ELEMENTS`, to hold the number of elements
    we have in the array. The keyword `const` tells C that this variable is not to
    be changed (more on this later).
  prefs: []
  type: TYPE_NORMAL
- en: We use this constant two places. The first declares the array. The second loops
    through each element of the array. While we could have instead used the value
    `5` in both of these places, doing so would have introduced a magic number into
    our code. A *magic number* is a number that appears in the program in multiple
    places but whose connection to the code is unclear. Using a magic number is risky;
    in this case, if we changed the `5` in the array declaration, we would have to
    remember to also change the `5` in the loop. By using the constant declaration,
    we define the size of the array in only one place. If we change the constant to
    `14`, we take care of every place it is used automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Back to the code. We need to put some numbers in our array, so we do so by assigning
    a value to each of its indices. Next, we use a `for` loop to access each element
    of the array. The `for` loop statement illustrates a common C programming phrase
    for looping through an array. The loop starts at zero and continues as long as
    the index is *less than* (<) the size of the array. The index must be less than
    5, because `number[5]` is a nonexistent element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays can be initialized at the time of declaration, just like simple variables,
    by listing all of the elements inside curly brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the number of elements must match the size of the array or you’ll
    get a warning message.
  prefs: []
  type: TYPE_NORMAL
- en: 'C is a smart language. It can deduce the size of the array from the number
    of elements, so this declaration also works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the Hood: Pointers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: My father, C. M. Oualline, famously taught me, “There are things and there are
    pointers to things.” See [Figure 6-1](#figure6-1) for a detailed diagram of what
    this means. Although it looks simple, understanding this diagram is extremely
    important.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06001](image_fi/501621c06/f06001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-1: Things and pointers to things'
  prefs: []
  type: TYPE_NORMAL
- en: An integer is a thing. In fact, it is a thing that has an integer in it. A pointer
    is an address of a thing.
  prefs: []
  type: TYPE_NORMAL
- en: Things come in different sizes. A `uint64_t` integer is a relatively big thing,
    while a `uint8_t` is a small thing. The key here is that things come in different
    sizes. A pointer is a fixed size. The thing it points to can be big or small,
    but the pointer is always the same size.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers are useful for quickly accessing data structures and linking data structures
    together. In embedded programming, pointers are used to point to memory-mapped
    I/O devices, which gives the program control of the devices.
  prefs: []
  type: TYPE_NORMAL
- en: The big advantage of pointers is that they can point to anything. The biggest
    disadvantage is that they can point to things they shouldn’t. When that happens,
    programs start to do strange and unexpected things, so use pointers very carefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a pointer, use an asterisk (`*`) in the declaration to indicate
    that the variable is a pointer and not a thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The *address of* (`&`) operator changes a thing into a pointer to a thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `thingPtr` points to `thing`. The *dereference* (`*`) operator turns a
    pointer back into a thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This assigns `otherThing` to the value *pointed to* by `thingPtr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program shows how these operations work. In this program, we
    introduce a new `printf` conversion, `%p`, which prints pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go through this in detail. We start by declaring three things and two
    pointers. We use the suffix `Ptr` when naming all pointers to make them very obvious.
    At this point, `smallPtr` does not point to any particular thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we use the pointer, let’s use our `smallThing`. Using two calls to `printf`,
    we print the value and the size of `smallThing` 1. This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s take a look at the pointer 2. First, we print the value of the pointer,
    which is a memory address. We are on an x86-type machine with 64-bit pointers,
    so the value of the pointer is a 64-bit number. The actual number value comes
    from the way that memory is laid out, which we will discuss in detail in Chapter
    11. When we print `sizeof(smallPtr)`, we see that it is indeed 8 bytes or 64 bits
    long, and the value *pointed to* by `smallPtr` is `5`. All in all, these three
    calls to `printf` will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We do something similar with `largePtr`. Notice that while the size of the
    thing being pointed to is different, the size of the pointer remains the same.
    The size of the pointer depends on the processor type, not the type of data being
    pointed to. On our STM32 processor, we have 32-bit addresses, so the pointer will
    be a 32-bit value. On an x64 machine with 64-bit addresses, the size of a pointer
    is 4 bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To see what the pointers are actually pointing to, enter this program into the
    STM32 Workbench and run it using the debugger. Put a breakpoint just after everything
    has been assigned and run the program up to the breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Opening the Variables panel shows us all the variables and their values (see
    [Figure 6-2](#figure6-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06002](image_fi/501621c06/f06002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-2: The Variables panel with pointers'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the value of the pointer is not that interesting. What’s more interesting
    is what it points to. Clicking the + icon expands the `smallPtr` entry, and we
    can see that `smallPtr` points to `6` (also known as the character `'\006'`).
    Similarly, we can see that `largePtr` points to `987654321`.
  prefs: []
  type: TYPE_NORMAL
- en: Array and Pointer Arithmetic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C treats array variables and pointers very much alike. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We’ve assigned `arrayPtr` the value of `array`, not `&array`, because C will
    automatically turn an array into a pointer when it’s used like a pointer. In fact,
    arrays and pointers are almost interchangeable, except that they are declared
    differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s access an element of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax is the same as the following, which says to take the value of `arrayPtr`,
    add 1 to it (scaled by the size of the data being pointed to), and return the
    data pointed to by the result of this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following program demonstrates the relationship between arrays and pointers
    in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing this program does is print the address and contents of each
    array element in the conventional manner: by using a `for` loop to access each
    index in turn.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next loop, we print using pointer arithmetic. Now, we need to understand
    exactly what we are dealing with. The variable `array` is an array. The expression
    `array[index]` is an integer, and the `&` (address of) operator changes an integer
    into a pointer, so `&array[index]` is a pointer. As a result, this code prints
    the following memory addresses for each element in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The pointer value increases by 4, the size of an integer, each time, so `array[0]`
    is at address `0x7fffa22e0610`, and `array[1]` is at a memory location 4 bytes
    larger, at `0x7fffa22e0614`.
  prefs: []
  type: TYPE_NORMAL
- en: This method uses pointer arithmetic. (We actually used pointer arithmetic in
    the first method too, but C hid it all behind our back.) With this loop, you can
    see that `arrayPtr + 1` is `0x7fffa22e0614`, which is exactly the same as `&array[1]`.
    Again, notice that with pointer arithmetic, things are automatically scaled by
    the size of the item being pointed to. In this case, the type of the data being
    pointed to is `int`, so the expression `arrayPtr + 1` is actually `arrayPtr +
    1 * sizeof(int)`, and thus `0x7fffa22e0610 + 1` is really `0x7fffa22e0610 + 1
    * sizeof(int)`, which is `0x7fffa22e0614`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we do the same thing a third way using an incrementing pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Using pointers to access arrays is common, because many people think doing so
    is more efficient than using an array index. After all, computing `array[index]`
    involves an address calculation, but compiler technology has improved over the
    years. Today’s compilers are very good at generating more efficient code, so using
    pointers for array indexing is not actually more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Using address logic is, however, more confusing. It’s not clear what’s being
    pointed to and what the limits of the array are, so the second two methods should
    be avoided. I’ve included them in the example because there’s a lot of legacy
    code out there that uses pointer arithmetic to access arrays, and to show you
    what not to do.
  prefs: []
  type: TYPE_NORMAL
- en: Array Overflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C does not do *bounds checking*, meaning it does not check whether you’re trying
    to access elements outside the bounds of an array. The legal elements of a five-element
    array (`int a[5]`) are `a[0]`, `a[1]`, `a[2]`, `a[3]`, `a[4]`, but there’s nothing
    to prevent you from using illegal values such as `a[5]`, `a[6]`, `a[7]`, or even
    `a[932343]`. The trouble with the illegal values is that they are the locations
    of some other variables or data in memory. The program in [Listing 6-2](#listing6-2)
    demonstrates what happens when you go beyond the end of array (called *array overflow*).
  prefs: []
  type: TYPE_NORMAL
- en: '**`array.bad.c`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-2: Array overflow'
  prefs: []
  type: TYPE_NORMAL
- en: '*The key item to watch is `numbers2[0]`, which we set to 21 when we initialize
    it. When we print it the first time, at 1, its value is, in fact, 21\. However,
    when we print it later, at 3, it is 99\. What happened?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the output of this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: From this, we see that `numbers1` is allocated the memory from `0x7ffc5e94ff00`
    to `0x7ffc5e94ff13`. The variable `numbers2` is allocated `0x7ffc5e94ff20` to
    `0x7ffc5e94ff33`. This memory layout is visually expressed in [Table 6-1](#table6-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-1: Memory Layout'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Variable** | **Address** | **Contents** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `numbers1` | `0x7ffc5e94ff00` | `11` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `0x7ffc5e94ff04` | `12` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `0x7ffc5e94ff08` | `13` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `0x7ffc5e94ff0c` | `14` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `0x7ffc5e94ff10` | `15` |'
  prefs: []
  type: TYPE_TB
- en: '| `numbers2` | `0x7ffc5e94ff20` | `21` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `0x7ffc5e94ff24` | `22` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `0x7ffc5e94ff28` | `23` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `0x7ffc5e94ff2c` | `24` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `0x7ffc5e94ff30` | `25` |'
  prefs: []
  type: TYPE_TB
- en: The statement at 2 in [Listing 6-2](#listing6-2) uses an illegal index, since
    `numbers1` has only five elements. So, what memory does this overwrite? From the
    output of our program, we see that the address of this value is `0x7ffc5e94ff20`.
    By a strange coincidence, this is also the address of `numbers2[0]`. Our sample
    program makes the memory corruption immediately apparent when it prints the content
    of `numbers2[0]` the second time.
  prefs: []
  type: TYPE_NORMAL
- en: This program is a simple illustration of what can go wrong when an array overflows.
    In real life, identifying such problems is much harder. Usually, these errors
    show up as weird program behavior that occurs long after the index error, so debugging
    them is complicated. Avoid making this type of mistake.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common error novice C programmers make is to forget that C arrays
    start at 0 and go to `size``-1`. For example, you might write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you program on Linux machines, tools such as Valgrind and the GCC address
    sanitizer will do a runtime check for array overflows. In the embedded world,
    we have no such tools, so we just have to be careful.
  prefs: []
  type: TYPE_NORMAL
- en: Characters and Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve discussed working with numbers, but you might sometimes want to include
    other kinds of data, like text, in your programs. For this, we turn to a new variable
    type, `char`, which holds a single character enclosed in single quotes (`''`).
    For example, the following creates a `char` variable called `stop` to hold the
    character `''S''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: A *string* is an array of characters that ends with an end-of-string (`\0`)
    character. The character `\0` is known as the NUL character (with one *L*) as
    well. That’s because, during original serial communications, it signified nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To practice using strings, let’s now take a look at the following program,
    which prints the string “Hello World”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We first define a string called `hello` with the value `"Hello World"`. This
    initialization explicitly defines every element of the string. You hardly ever
    see initializations like this in real life because C provides a shortcut that
    makes things a lot easier. (We’ll see that shortly.) This version makes everything
    obvious, which is good for learning but not for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we print the string using the standard C function `puts`. The `puts`
    function prints a single string and is simple, whereas `printf` can do formatting
    and is a large, complex function. The `puts` function also adds a newline, so
    we didn’t put one in our original string.
  prefs: []
  type: TYPE_NORMAL
- en: 'C has a shorthand for initializing strings, allowing us to write the same declaration
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Both statements create an array of 12 characters and initialize it. (`"Hello
    World"` contains 11 characters, and the 12th is the end-of-string character `'\0'`,
    which is automatically supplied when you use the shorthand.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Because arrays and pointers are very similar, you can also declare the string
    as a pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll notice that we now have two `const` keywords. Things are getting a little
    tricky here. The first `const` affects the pointer; the second affects the data
    being pointed to. The following program illustrates how these work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This program shows every possible way `const` can be used to define a character
    pointer. We then try to modify the pointer and the data being pointed to. Depending
    on where we put `const` modifiers, some of these statements will fail and some
    will work.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We started this book by dealing with variables that could hold single values.
    Arrays let us deal with a set of data. This gives us much more power when it comes
    to organization.
  prefs: []
  type: TYPE_NORMAL
- en: Strings are a special type of array. They hold characters and have an end-of-string
    marker to signal their end.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers and arrays are similar in that both can be used to access a section
    of memory. Arrays are restricted by their size (although they can overflow), while
    pointers are not. C does not restrict the use of pointers, and that gives the
    language a lot of power. This power can be used for good, such as when dealing
    with memory-mapped I/O, or bad, such as when accidentally destroying random memory.
  prefs: []
  type: TYPE_NORMAL
- en: As we are seeing, C gives programmers the power to fully use their machines.
    But this power comes at a cost. C does not prevent you from doing something stupid.
    C gives you tools like arrays and pointers to organize your data. It’s up to you
    to do it wisely.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a program to find the lowest and highest numbered elements in an array
    of integers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program to scan an array for duplicate numbers. The duplicated numbers
    will be in consecutive elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program to scan an array for duplicate numbers that may occur anywhere
    in the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a program that prints only the odd numbers of an array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program that goes through a string and makes the first letter of each
    word uppercase. You’ll need to look up the standard C functions `isalpha` and
    `toupper`.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
