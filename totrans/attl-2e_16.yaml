- en: '16'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: USING THE M4 MACRO PROCESSOR WITH AUTOCONF
  prefs: []
  type: TYPE_NORMAL
- en: '*By the time you’ve sorted out a complicated idea into little steps that even
    a stupid machine can deal with, you’ve learned something about it yourself.*'
  prefs: []
  type: TYPE_NORMAL
- en: —*Douglas Adams*, Dirk Gently’s Holistic Detective Agency
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The M4 macro processor is simple to use, yet hard to comprehend. The simplicity
    comes from the fact that it does just one thing very well. I’ll wager that you
    or I could write the base functionality of M4 in a C program in just a few hours.
    At the same time, two aspects of M4 make it rather difficult to understand immediately.
  prefs: []
  type: TYPE_NORMAL
- en: First, the exceptions introduced by *special cases* that M4 deals with when
    it processes input text make it hard to grasp all of its rules immediately, though
    this complexity is easily mastered with time, patience, and practice. Second,
    the stack-based, pre-order recursive nature of M4’s text-processing model is difficult
    for the human mind to comprehend. Humans tend to process information breadth first,
    comprehending complete levels of a problem or data set, one level at a time, whereas
    M4 processes text in a depth-first fashion.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers what I consider the bare minimum you need to know to write
    Autoconf input files. I can’t do justice to M4 in a single chapter of this book,
    so I’ll cover just the highlights. For more detail, read the *GNU M4 Manual*.^([1](footnote.xhtml#ch16fn1))
    If you’ve already had some experience with M4, try the examples in that manual
    and then try solving a few text problems of your own using M4\. A small amount
    of such experimentation will vastly improve your understanding of M4.
  prefs: []
  type: TYPE_NORMAL
- en: M4 Text Processing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like many other classic Unix tools, M4 is written as a standard input/output
    (`stdio`) filter. That is, it accepts input from standard input (`stdin`), processes
    it, and then sends it to standard output (`stdout`). Input text is read in as
    a stream of bytes and converted to *tokens* before processing. Tokens consist
    of comments, names, quoted strings, and single characters that are not part of
    a comment, name, or quoted string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *default* quote characters are the backtick (`` ` ``) and the single quote
    (`''`).^([2](footnote.xhtml#ch16fn2)) Use the backtick to start a quoted string
    and the single quote character to terminate one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: M4 comments are similar to quoted strings in that each one is processed as a
    single token. Each comment is delimited by a hash mark (`#`) and a newline (`\n`)
    character. Thus, all text following an *unquoted* hash mark, up to and including
    the next newline character, is considered part of a comment.
  prefs: []
  type: TYPE_NORMAL
- en: Comments are not stripped from the output as they are in other computer language
    preprocessors, such as the C-language preprocessor. Rather, they are simply passed
    through without further processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example contains five tokens: a name token, a space character
    token, another name token, a second space character token, and finally, a single
    comment token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A *name* is any sequence of letters, digits, and underscore characters that
    does not begin with a digit. Thus, the first line of the following example contains
    two digit character tokens, followed by a name token, whereas the second line
    contains only a single name token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that whitespace characters (horizontal and vertical tabs, form feeds, carriage
    returns, spaces, and newlines) are specifically not part of a name, so whitespace
    characters may (and often do) act as name or other token delimiters. However,
    such whitespace delimiters are not discarded by M4, as they often are by a computer
    language compiler’s parser. They’re simply passed through from the input stream
    directly to the output stream without further modification.
  prefs: []
  type: TYPE_NORMAL
- en: '*Defining Macros*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: M4 provides a variety of built-in macros, many of which are critical to the
    proper use of this tool. For instance, it would be very difficult to get any useful
    functionality out of M4 if it didn’t provide a way of defining macros. M4’s macro-definition
    macro is called `define`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `define` macro is simple to describe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `define` macro expects at least one parameter, even if it’s empty. If you
    supply only one parameter, then instances of the macro name that are found in
    the input text are simply deleted from the output text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note in the output text at ➊ that there are two spaces between `Hello` and
    `world!` All tokens except names that map to defined macros are passed from the
    input stream to the output stream without modification, with one exception: whenever
    any quoted text outside of comments is read from the input stream, one level of
    quotes is removed.'
  prefs: []
  type: TYPE_NORMAL
- en: Another subtle aspect of the `define` macro is that its expansion is the empty
    string. Thus, the output of the preceding definition is simply the trailing carriage
    return after the definition in the input string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Names, of course, are candidates for macro expansion. If a name token is found
    in the symbol table, it is replaced with the macro expansion, as shown in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The second output line at ➌ shows us that the first token (the name `macro`)
    is expanded and the outer level of quotes around [PRE6] `text''` are removed by
    M4\. The blank line at ➋ following the macro definition comes from the newline
    character I entered into the input stream when I pressed the enter key after the
    macro definition at ➊. Since this newline character is not part of the macro definition,
    M4 simply passes it through to the output stream. This can be a problem when defining
    macros in input text because you could end up with a slew of blank lines in the
    output text, one for each macro defined in the input text. Fortunately, there
    are ways around this problem. For example, I could simply not enter that newline
    character, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That solves the problem, but it doesn’t take a genius to see that this can lead
    to some readability issues. If you have to define your macros in this manner so
    that they don’t affect your output text, you’ll have a few run-on sentences in
    your input text!
  prefs: []
  type: TYPE_NORMAL
- en: As a solution for this problem, M4 provides another built-in macro called `dnl`,^([3](footnote.xhtml#ch16fn3))
    which causes all input text up to and including the next newline character to
    be discarded. It’s common to find `dnl` used in *configure.ac*, but it’s even
    more common to find it used in *.m4* macro definition files consumed by Autoconf
    while processing *configure.ac* files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of the proper use of `dnl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There are a few dozen built-in M4 macros, all of which provide functionality
    that can’t be obtained in any other way within M4\. Some redefine fundamental
    behavior in M4.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `changequote` macro is used to change the default quote characters
    from backtick and single quote to whatever you want. Autoconf uses a line like
    this near the top of the input stream to change the M4 quotes to the left and
    right square bracket characters, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Why would the Autoconf designers do this? Well, it’s quite common in shell code
    to find unbalanced pairs of single quote characters. In shell code, both backtick
    and single quote are common in expressions that use the same character to both
    start and end an expression. This is confusing to M4, which requires open and
    close quote characters to be distinct from each other in order to properly process
    its input stream. You’ll recall from [Chapter 4](ch04.xhtml) that the input text
    to Autoconf is shell script, which means that there’s a good chance Autoconf will
    run into an unbalanced pair of M4 quotes in every input file it reads. This can
    lead to errors that are very difficult to track down, because they have more to
    do with M4 than they do with Autoconf. It’s far less likely that the input shell
    script will contain an unbalanced pair of square bracket characters.
  prefs: []
  type: TYPE_NORMAL
- en: '*Macros with Arguments*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Macros may also be defined to accept arguments, which may be referenced in
    the expansion text with `$1`, `$2`, `$3`, and so on. The number of arguments passed
    can be found in the variable `$#`, and `$@` can be used to pass all arguments
    of one macro call onto another. When using arguments in a macro call, there can
    be no intervening whitespace between the macro name and the opening parenthesis.
    Here’s an example of a macro that’s defined and then called in various ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the first call at ➊ is a macro call without arguments. The
    second call is a macro call with one empty argument. Such calls treat the parameters
    as if empty arguments were actually passed.^([4](footnote.xhtml#ch16fn4)) In both
    cases, the macro expands to “`The N arguments are and .`” (note the double space
    between the last two words and the space between the last word and the period),
    but the “N” is 0 in the first call and 1 in the second. Therefore, the empty set
    of parentheses in the second call carries an empty single argument. The next three
    calls, beginning at ➋, pass one, two, and three arguments, respectively. As you
    can see by the resulting outputs of these three calls, parameters in the expansion
    text that reference missing arguments are treated as empty, while arguments passed
    without corresponding references are simply ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The last call, at ➌, is a bit different. Notice that it contains a space between
    the macro name and the opening parenthesis. The initial output of this call is
    similar to that of the first call, but following that initial output, we find
    what appears to be a minor variation on the originally intended argument list
    (the quotes are missing). This is a macro call *without arguments*. Since it’s
    not actually part of the macro call, M4 treats the argument list simply as text
    on the input stream. Thus, it’s copied directly to the output stream, minus one
    level of quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When passing arguments in macro calls, be aware of whitespace around arguments.
    The rules are simple: unquoted *leading* whitespace is removed from arguments,
    and *trailing* whitespace is always preserved, whether quoted or not. Of course,
    *whitespace* here refers to carriage returns and newline characters, as well as
    spaces and tabs. Here’s an example of calling a macro with variations in leading
    and trailing whitespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, I purposely omitted the quotes around the macro arguments in
    the calls at ➊ and ➋ in order to reduce confusion. The call at ➊ has only leading
    whitespace in the form of newlines and tab characters, while the call at ➋ has
    only trailing whitespace. I’ll cover quoting rules shortly, at which point you’ll
    see clearly how quoting affects whitespace in macro arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The Recursive Nature of M4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we consider the recursive nature of the M4 input stream. Whenever a name
    token is expanded by a macro definition, the expansion text is pushed back onto
    the input stream for complete reprocessing. This recursive reprocessing continues
    to occur as long as there are macro calls found in the input stream that generate
    text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, I define a macro called *macro* and then present this macro name on the
    input stream, followed by additional text, some of which is quoted and some of
    which is double quoted.
  prefs: []
  type: TYPE_NORMAL
- en: The process used by M4 to parse this example is shown in [Figure 16-1](ch16.xhtml#ch16fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/16fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: The procedure used by M4 to process an input text stream*'
  prefs: []
  type: TYPE_NORMAL
- en: In the bottom line of the figure, M4 is generating a stream of output text (``expansion
    `quoted[PRE13]macro ``quoted' text'[PRE14] ``quoted' text' [PRE15]
  prefs: []
  type: TYPE_NORMAL
- en: $ m4
  prefs: []
  type: TYPE_NORMAL
- en: define(`macro', `This is a macro')dnl
  prefs: []
  type: TYPE_NORMAL
- en: macro
  prefs: []
  type: TYPE_NORMAL
- en: This is a This is a This is a This is a This is a This is a... <ctrl-c>
  prefs: []
  type: TYPE_NORMAL
- en: $
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: $ m4
  prefs: []
  type: TYPE_NORMAL
- en: define(`def', `DEF')dnl
  prefs: []
  type: TYPE_NORMAL
- en: ➊ define(`abc', `def')dnl
  prefs: []
  type: TYPE_NORMAL
- en: abc
  prefs: []
  type: TYPE_NORMAL
- en: DEF
  prefs: []
  type: TYPE_NORMAL
- en: ➋ define(`abc', ``def'')dnl
  prefs: []
  type: TYPE_NORMAL
- en: abc
  prefs: []
  type: TYPE_NORMAL
- en: def
  prefs: []
  type: TYPE_NORMAL
- en: ➌ define(`abc', [PRE17]
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the first time `abc` is defined (at ➊), it’s quoted once. As
    M4 processes the macro definition, it removes a layer of quotes. Thus, the expansion
    text is stored in the symbol table without quotes, but it’s pushed back onto the
    input stream and therefore is transformed into `DEF` due to the first macro definition.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the second definition of `abc` (at ➋) is double quoted, so when
    the definition is processed and the outer layer of quotes is stripped off, we
    would expect the expansion text in the symbol table to contain at least one set
    of quotes, and it does. Then why don’t we see quotes around the output text? Remember
    that when macros are expanded, the expansion text is pushed onto the front of
    the input stream and reparsed using the usual rules. Thus, while the text of the
    second definition is stored quoted in the symbol table, as it’s reprocessed upon
    use, the second layer of quotes is removed between the input and output streams.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between ➊ and ➋ in this example is that the expansion text of
    ➋ is treated as quoted text by M4, rather than as a potential macro name. The
    quotes are removed during definition, but the enclosed text is not considered
    for further expansion because it’s still quoted.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the third definition of `abc` (at ➌), we finally see the result we were
    perhaps hoping to obtain: a quoted version of the output text. The expansion text
    is entered into the symbol table double quoted, because the outermost set of quotes
    is stripped off during processing of the definition. Then, when the macro is used,
    the expansion text is reprocessed and the second set of quotes is stripped off,
    leaving one set in the final output text.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you keep these rules in mind as you work with macros within Autoconf (including
    both definitions and calls), you’ll find it easier to understand why things may
    not work the way you think they should. The *GNU M4 Manual* provides a simple
    rule of thumb for using quotes in macro calls: for each layer of nested parentheses
    in a macro call, use one layer of quotes.'
  prefs: []
  type: TYPE_NORMAL
- en: Autoconf and M4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `autoconf` program is a rather simple shell script. About 80 percent of
    the shell code in the script exists simply to ensure that the shell is functional
    enough to perform the required tasks. The remaining 20 percent parses command
    line options. The last line of the script executes the `autom4te` program, a Perl
    script that acts as a wrapper around the `m4` utility. Ultimately, `autom4te`
    calls `m4` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the three files that M4 is processing are */usr/share**/autoconf**/autoconf.m4f*,
    *aclocal.m4*, and *configure.ac*, in that order.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The* .m4f *extension on the master Autoconf macro file signifies a* frozen
    *M4 input file—a sort of precompiled version of the original* .m4 *file. When
    a frozen macro file is processed, it must be specified after a `--reload-state`
    option, in order to make M4 aware that it’s not a normal input file. State is
    built cumulatively within M4 over all input files, so any macros defined by* aclocal.m4,
    *for instance, are available during the processing of* configure.ac.'
  prefs: []
  type: TYPE_NORMAL
- en: The ellipsis between the two `--trace` options in the command line above is
    a placeholder for more than 100 such `--trace` options. It’s a good thing the
    shell can handle long command lines!
  prefs: []
  type: TYPE_NORMAL
- en: The master Autoconf macro file, *autoconf.m4*, merely includes (using the `m4_include`
    macro) the other dozen or so Autoconf macro files, in the correct order, and then
    does a small amount of housekeeping before leaving M4 ready to process user input
    (via *configure.ac*). The *aclocal.m4* file is our project’s macro file, built
    originally by the `aclocal` utility or handwritten for projects that don’t use
    Automake. By the time *configure.ac* is processed, the M4 environment has been
    configured with hundreds of Autoconf macro definitions, which may be called as
    needed by *configure.ac*. This environment includes not only the recognized `AC_*`
    macros but also a few lower layers of Autoconf-provided macros that you may use
    to write your own macros.
  prefs: []
  type: TYPE_NORMAL
- en: One such lower layer is *m4sugar*,^([5](footnote.xhtml#ch16fn5)) which provides
    a nice clean namespace in which to define all of the Autoconf macros, as well
    as several improvements and additions to the existing M4 macros.
  prefs: []
  type: TYPE_NORMAL
- en: Autoconf modifies the M4 environment in a few ways. First, as mentioned earlier,
    it changes the default quote characters from the backtick and single quote characters
    to the open and close square bracket characters. In addition, it configures M4
    built-in macros such that most are prefixed with `m4_`, thereby creating a unique
    namespace for M4 macros. Thus, the M4 `define` macro becomes `m4_define`, and
    so on.^([6](footnote.xhtml#ch16fn6))
  prefs: []
  type: TYPE_NORMAL
- en: 'Autoconf provides its own version of `m4_define` called `AC_DEFUN`. You should
    use `AC_DEFUN` instead of `m4_define` because it ensures that certain environmental
    constraints important to Autoconf are in place when your macro is called. The
    `AC_DEFUN` macro supports a prerequisite framework, so you can specify which macros
    are required to have been called before your macro may be called. This framework
    is accessed by using the `AC_REQUIRE` macro to indicate your macro’s requirements
    at the beginning of your macro definition, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The rules for writing Autoconf macros using `AC_DEFUN` and the prerequisite
    framework are outlined in [Chapter 9](ch09.xhtml) of the *GNU Autoconf Manual*.
    Before you write your own macros, read [Chapters 8](ch08.xhtml) and [9](ch09.xhtml)
    of that manual.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Autoconf Macros
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Why would we want to write Autoconf macros in the first place? One reason is
    that a project’s *configure.ac* file might contain several instances of similar
    sets of code and we need the `configure` script to perform the same set of high-level
    operations on multiple directories or file sets. By converting the process into
    a macro, we reduce the number of lines of code in the *configure.ac* file, thereby
    reducing the number of possible points of failure. Another reason might be that
    an easily encapsulated bit of *configure.ac* code could be useful in other projects,
    or even to other people.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The GNU Autoconf Archive provides many sets of related macros to solve common
    Autoconf problems. Anyone may contribute to the archive by emailing their macros
    to the project maintainer. There are frequent tarball releases available for free
    from the project website.*^([7](footnote.xhtml#ch16fn7))'
  prefs: []
  type: TYPE_NORMAL
- en: '*Simple Text Replacement*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The simplest type of macro is one that replaces text verbatim, with no substitutions.
    An excellent example of this is found in the FLAIM project, where the flaim, xflaim,
    and sql projects’ `configure` scripts attempt to locate the ftk (FLAIM toolkit)
    project library and header file. Since I already discussed the operation of this
    code in [Chapter 14](ch14.xhtml), I’ll only cover it briefly here as it relates
    to writing Autoconf macros, but I provide the relevant bit of *configure.ac* code
    in [Listing 16-1](ch16.xhtml#ch16ex1) for convenience.^([8](footnote.xhtml#ch16fn8))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-1:* xflaim/configure.ac: *The ftk search code from the xflaim project*'
  prefs: []
  type: TYPE_NORMAL
- en: This code is identical in flaim, xflaim, and sql, though it may be modified
    in the future for one reason or another, so keeping it embedded in all three *configure.ac*
    files is redundant and error prone.
  prefs: []
  type: TYPE_NORMAL
- en: Even if we were to convert this code to a macro, we’d still have to put a copy
    of the macro file into each of the projects’ *m4* directories. However, we could
    later edit only one of these macro files and copy it from the authoritative location
    into the other projects’ *m4* directories, or even use symlinks in git rather
    than copies to ensure there is truly only a single copy of the *.m4* file. This
    would be a better solution than having all of the code embedded in all three *configure.ac*
    files.
  prefs: []
  type: TYPE_NORMAL
- en: By converting this code to a macro, we can keep it in one place where portions
    of it cannot be confused for code that is not related to the process of locating
    the FLAIM toolkit library and header file. This happens quite often during later
    maintenance of a project’s *configure.ac* file, as additional code designed for
    other purposes is dropped between chunks of code belonging to sequences like this.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try converting this code into a macro. Our first attempt might look like
    [Listing 16-2](ch16.xhtml#ch16ex2). (I’ve omitted a large chunk in the middle
    that is identical to the original code, for the sake of brevity.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-2:* xflaim/m4/flm_ftk_search.m4: *A first attempt at encapsulating
    ftk search code*'
  prefs: []
  type: TYPE_NORMAL
- en: In this pass, I’ve simply cut and pasted the entire *configure.ac* code sequence
    verbatim into the `macro-body` argument of a call to `AC_DEFUN`. The `AC_DEFUN`
    macro is defined by Autoconf and provides some additional functionality over the
    `m4_define` macro provided by M4\. This additional functionality is strictly related
    to the prerequisite framework provided by Autoconf.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Be aware that *`AC_DEFUN`* must be used (rather than *`m4_define`*) in order
    for the macro definition to be found by *`aclocal`* in your external macro definition
    files. You must use *`AC_DEFUN`* if your macro definitions are in external files,
    but for simple macros defined within* configure.ac *itself, you can use* `m4_define`.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of M4 quoting around both the macro name (`FLM_FTK _SEARCH`)
    and the entire macro body. To illustrate the problems with not using these quotes
    in this example, consider how M4 would process the macro definition without the
    quotes. If the macro name were left unquoted, not much damage would be done, unless
    the macro happened to already be defined. If the macro were already defined, M4
    would treat the macro name as a call with no parameters, and the existing definition
    would replace the macro name as M4 was reading the macro definition. (In this
    case, because of the unique name of the macro, there’s not much chance that it’s
    already defined, so I could have left the macro name unquoted with little effect,
    but it’s good to be consistent.)
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the macro body contains a fair amount of text and even Autoconf
    macro calls. Had we left the body unquoted, these macro calls would be expanded
    during the reading of the definition rather than during the later use of the macro,
    as we had intended.
  prefs: []
  type: TYPE_NORMAL
- en: Because the quotes are present, M4 stores the macro body as provided, with no
    additional processing during the reading of the definition other than to remove
    the outermost layer of quotes. Later, when the macro is called, the body text
    is inserted into the input stream in place of the macro call, with one layer of
    quotes removed, and only then are the embedded macros expanded.
  prefs: []
  type: TYPE_NORMAL
- en: This macro requires no arguments because the same text is used identically in
    all three *configure.ac* files. The effect on *configure.ac* is to replace the
    entire chunk of code with the name of the macro, as shown in [Listing 16-3](ch16.xhtml#ch16ex3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-3:* xflaim/configure.ac: *Replacing the ftk search code with the
    new macro call*'
  prefs: []
  type: TYPE_NORMAL
- en: When writing a macro from existing code, consider the inputs to the existing
    chunk of code and the outputs provided by the code. Inputs will become possible
    macro arguments, and outputs will become documented effects. In [Listing 16-3](ch16.xhtml#ch16ex3),
    we have no inputs and thus no arguments, but what are the documentable effects
    of this code?
  prefs: []
  type: TYPE_NORMAL
- en: The comment at ➊ over the macro call in [Listing 16-3](ch16.xhtml#ch16ex3) alludes
    to these effects. The `FTKLIB` and `FTKINC` variables are defined, and the `FTK_LTLIB`
    and `FTK_INCLUDE` variables are defined and substituted using `AC_SUBST`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Documenting Your Macros*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A proper macro definition provides a header comment that documents possible
    arguments, results, and potential side effects of the macro, as shown in [Listing
    16-4](ch16.xhtml#ch16ex4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-4:* xflaim/m4/flm_ftk_search.m4: *Adding a documentation header
    to the macro definition*'
  prefs: []
  type: TYPE_NORMAL
- en: This header comment documents both the effects of this macro and the way it
    operates, giving the user a clear picture of the sort of functionality they’ll
    get when they call it. The *GNU Autoconf Manual* indicates that such macro definition
    header comments are stripped from the final output; if you search the `configure`
    script for some text in the comment header, you’ll see that it’s missing.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding coding style, the *GNU Autoconf Manual* suggests that it is good macro
    definition style to place the macro body’s closing square-bracket quote and the
    closing parenthesis alone on the last line of the macro definition, along with
    a comment containing only the name of the macro being defined, as shown in [Listing
    16-5](ch16.xhtml#ch16ex5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-5:* xflaim/m4/flm_ftk_search.m4: *Suggested macro body closing
    style*'
  prefs: []
  type: TYPE_NORMAL
- en: The *GNU Autoconf Manual* also suggests that, if you don’t like the extra carriage
    return that the use of this format adds to the generated `configure` script, you
    can append the text `[]dnl` to the last line of the macro body, as shown at ➊
    in [Listing 16-5](ch16.xhtml#ch16ex5). The use of `dnl` causes the trailing carriage
    return to be ignored, and the open and close square brackets are simply empty
    Autoconf quotes that are stripped out during processing of later macro calls.
    The quotes (square brackets) are used to separate `fi` and `dnl` so they’re recognized
    by M4 as two separate words.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The* GNU Autoconf Manual *defines a very complete naming convention for macros
    and their containing files. I’ve chosen simply to prefix all macro names and their
    containing files that are strictly related to the project with a project-specific
    prefix—in this case, *`FLM_`* (*`flm_`*).*'
  prefs: []
  type: TYPE_NORMAL
- en: '*M4 Conditionals*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you know how to write basic M4 macros, we’ll consider what it means
    to allow M4 to decide which text should be used to replace your macro call, based
    on arguments passed in the call.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a Macro with and Without Arguments
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Take a look at [Listing 16-6](ch16.xhtml#ch16ex6), which is my first attempt
    at writing the `FLM_PROG``_TRY_DOXYGEN` macro that was first used in [Chapter
    14](ch14.xhtml). This macro was designed with an optional argument, which isn’t
    apparent from its use in [Chapter 14](ch14.xhtml) because the FLAIM code called
    the macro without arguments. Let’s examine the definition of this macro. In the
    process, we’ll discover what it means to call it with and without arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-6:* ftk/m4/flm_prog_try_doxygen.m4: *A first attempt at `FLM_PROG_TRY_DOXYGEN`*'
  prefs: []
  type: TYPE_NORMAL
- en: First, we see a call to the `AC_ARG_VAR` macro at ➊, which is used to make the
    `DOXYGEN` variable precious to Autoconf. Making a variable precious causes Autoconf
    to display it within the `configure` script’s help text as an influential environment
    variable. The `AC_ARG_VAR` macro also makes the specified variable an Autoconf
    substitution variable. At ➋, we come to the heart of this macro—the call to `AC_CHECK_PROGS`.
    This macro checks for a `doxygen` program in the system search path, but it only
    looks for the program (passed in the second argument) if the variable (passed
    in the first argument) is empty. If this variable is not empty, `AC_CHECK_PROGS`
    assumes that the end user has already specified the proper program in the variable
    in the user’s environment, and it does nothing. In this case, the `DOXYGEN` variable
    is populated with *doxygen* if the `doxygen` program is found in the system search
    path. In either case, a reference to the `DOXYGEN` variable is substituted into
    template files by Autoconf. (Since we just called `AC_ARG_VAR` on `DOXYGEN`, this
    step is redundant but harmless.)
  prefs: []
  type: TYPE_NORMAL
- en: The call to `m4_ifval` at ➌ brings us to the point of this section. This is
    a conditional macro defined in Autoconf’s *m4sugar* layer—a layer of simple macros
    designed to make writing higher-level Autoconf macros easier. M4 conditional macros
    are designed to generate one block of text if a condition is true and another
    if the condition is false. The purpose of `m4_ifval` is to generate text based
    on whether its first argument is empty. If its first argument is not empty, the
    macro generates the text in its second argument. If its first argument is empty,
    the macro generates the text in its third argument.
  prefs: []
  type: TYPE_NORMAL
- en: The `FLM_PROG_TRY_DOXYGEN` macro works with or without an argument. If no arguments
    are passed, `FLM_PROG_TRY_DOXYGEN` will print a warning message that the build
    is continuing without Doxygen support if the `doxygen` program is not in the system
    search path. On the other hand, if the `quiet` option is passed to `FLM_PROG_TRY_DOXYGEN`,
    no message will be printed if the `doxygen` program is not found.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 16-6](ch16.xhtml#ch16ex6), `m4_ifval` generates no text (the second
    argument is empty) if the first argument contains text. The first argument is
    `$1`, which refers to the contents of the first argument passed to `FLM_PROG_TRY_DOXGEN`.
    If no arguments are given to our macro, `$1` will be empty, and `m4_ifval` will
    generate the text in its third argument shown at ➍. On the other hand, if we pass
    `quiet` (or any text, for that matter) to `FLM_PROG_TRY_DOXYGEN`, `$1` will contain
    `quiet`, and `m4_ifval` will generate nothing.
  prefs: []
  type: TYPE_NORMAL
- en: The shell code in the third argument (at ➍) checks to see if the `DOXYGEN` variable
    is still empty after the call to `AC_CHECK_PROGS`. If it is, it calls `AC_MSG_WARN`
    to display a configuration warning.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Precision
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Autoconf provides a macro called `m4_if`, a renamed version of the M4 built-in
    `ifelse` macro. The `m4_if` macro is similar in nature to *m4sugar*’s `m4_ifval`.
    [Listing 16-7](ch16.xhtml#ch16ex7) shows how we might use `ifelse` in place of
    `m4_ifval`, if we didn’t have *m4sugar* macros to work with.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-7: Using `ifelse` instead of `m4_ifval`*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The macros appear to be identical in function, but this appearance is only
    circumstantial; the parameters are used differently. In this case, if the first
    argument (`$1`) is the same as the second argument (the empty string), the contents
    of the third argument (`[if test -z ...]`) are generated. Otherwise, the contents
    of the fourth (nonexistent) argument are generated because omitted arguments are
    treated as if the empty string had been passed. Therefore, the following two macro
    invocations are identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`FLM_PROG_TRY_DOXYGEN` treats any text in its argument as if `quiet` was passed.
    In order to facilitate future enhancements to this macro, we should limit the
    allowed text in this argument to something that makes sense; otherwise, users
    could abuse this parameter and we’d be stuck supporting whatever they pass for
    the sake of backward compatibility. The `m4_if` macro can help us out here. This
    macro is quite powerful because it accepts an unlimited number of arguments. Here
    are its basic prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If only one parameter is passed to `m4_if`, that parameter is treated as a comment
    because there’s not much that `m4_if` can do with one argument. If three or four
    arguments are passed, the description I gave for `ifelse` in [Listing 16-7](ch16.xhtml#ch16ex7)
    is also accurate for `m4_if`. However, if five or more arguments are passed, the
    fourth and fifth become the comparison strings for a second else-if clause. The
    last argument in an arbitrarily long set of triples is generated if the last two
    comparison strings are different.
  prefs: []
  type: TYPE_NORMAL
- en: We can use `m4_if` to ensure that `quiet` is the only acceptable option in the
    list of options accepted by `FLM_PROG_TRY_DOXYGEN`. [Listing 16-8](ch16.xhtml#ch16ex8)
    shows one possible implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-8: Restricting the argument options allowed by `FLM_PROG_TRY_DOXYGEN`*'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we want a message to be printed if `doxygen` is missing in all
    cases except when the `quiet` option is given as the first argument passed into
    our macro. In [Listing 16-8](ch16.xhtml#ch16ex8), I’ve given `FLM_PROG_TRY_DOXYGEN`
    the ability to detect cases when something other than `quiet` or the empty string
    is passed in this parameter and to do something specific in response. [Listing
    16-9](ch16.xhtml#ch16ex9) shows the resulting pseudocode generated by the expansion
    of `FLM_PROG_TRY_DOXYGEN`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-9: Pseudocode for [Listing 16-8](ch16.xhtml#ch16ex8)’s use of the
    `m4_if` macro*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine exactly what’s going on in [Listing 16-8](ch16.xhtml#ch16ex8).
    If arguments one (`[$1]`) and two (`[]`) are the same, a warning message is generated
    when `doxygen` is not found. If arguments four (`[$1]`) and five (`[quiet]`) are
    the same, nothing is generated; otherwise, arguments four and five are different,
    and a fatal error (via `m4_fatal`) is generated by Autoconf when it’s executed
    against the calling *configure.ac* file. It’s very simple, once you see how it
    works *and* once you get the bugs worked out—which brings us nicely to our next
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: Diagnosing Problems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most significant stumbling blocks that people run into at this point
    is not so much a lack of understanding of how these macros work but a lack of
    attention to detail. There are several places where things can go wrong when writing
    even a simple macro like this. For example, you might have any of the following
    problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Space between a macro name and the opening parenthesis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unbalanced brackets or parentheses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The wrong number of parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A misspelled macro name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorrectly quoted arguments to a macro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A missing comma in a macro’s parameter list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: M4 is rather unforgiving of such mistakes. Worse, its error messages can be
    even more cryptic than those of `make`.^([9](footnote.xhtml#ch16fn9)) If you get
    strange errors and you think your macro should be working, your best diagnostic
    method is to scan the definition very carefully looking for the preceding conditions.
    These mistakes are easy to make, and in the end most problems come down to some
    combination of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another very useful debugging tool is the `m4_traceon` and `m4_traceoff` macro
    pair. The macro signatures are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: All arguments are optional. When given, the arguments should be a comma-separated
    list of macro names you’d like M4 to print to the output stream as these names
    are encountered in the input stream. If you omit the arguments, M4 will print
    the name of every macro it expands.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical trace session in M4 looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The number between dashes in the output lines at ➊ and ➋ indicates the nesting
    level, which is usually 1\. The value of the trace facility is that you can easily
    see when the traced macros are expanded within the context of the output text
    generated. The M4 tracing facility can also be enabled from the command line with
    the `-t` or `--trace` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Or more appropriately for this discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The latter has the added benefit of allowing you to specify a format for the
    trace output. For more insight into the use of the format portion of the option,
    try entering `autom4te --help` at the command prompt. For more information on
    the use of the M4 trace options, refer to [Chapter 7](ch07.xhtml) (specifically,
    Section 7.2) of the *GNU M4 Manual*.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Autotools rely heavily on tracing for more than just debugging. Various
    of the Autotools and their supporting utilities use traces on* configure.ac *to
    gather information used in other stages of the configuration process. (Recall
    the 100+ trace options on the* m4 *command line.) For more information on tracing
    within Autoconf, refer to Section 3.4 of the* GNU Autoconf Manual, *titled “Using
    *`autoconf`* to Create *`configure`*.”*'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using M4 is deceptively complex. On the surface it appears simple, but as you
    get deeper into it, you find ways of using it that almost defy comprehension.
    Nonetheless, the complexities are not insurmountable. As you become proficient
    with M4, you’ll find that your way of thinking about certain problems changes.
    It’s worth gaining some M4 proficiency for that reason alone. It’s like adding
    a new tool to your software-engineering toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: A powerful M4 concept I did not cover, but that you should be aware of, is *iteration*.
    Normally, we think of iteration in terms of loops, but M4 has no actual looping
    constructs. Rather, iteration is managed through recursion. For details, refer
    to the manual’s discussion of the `forloop` and `foreach` macros.
  prefs: []
  type: TYPE_NORMAL
- en: Because the very foundation of Autoconf is M4, becoming proficient with M4 will
    give you more insight into Autoconf than you might think. The more about M4 you
    know, the more about Autoconf you’ll understand at a glance.
  prefs: []
  type: TYPE_NORMAL
