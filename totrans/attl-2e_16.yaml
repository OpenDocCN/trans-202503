- en: '16'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '16'
- en: USING THE M4 MACRO PROCESSOR WITH AUTOCONF
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 M4 宏处理器与 Autoconf
- en: '*By the time you’ve sorted out a complicated idea into little steps that even
    a stupid machine can deal with, you’ve learned something about it yourself.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你将一个复杂的想法拆解成小步骤，甚至傻乎乎的机器都能处理时，你自己也已经对这个想法有了深入的理解。*'
- en: —*Douglas Adams*, Dirk Gently’s Holistic Detective Agency
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —*道格拉斯·亚当斯*，《 Dirk Gently 的全能侦探社》
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: The M4 macro processor is simple to use, yet hard to comprehend. The simplicity
    comes from the fact that it does just one thing very well. I’ll wager that you
    or I could write the base functionality of M4 in a C program in just a few hours.
    At the same time, two aspects of M4 make it rather difficult to understand immediately.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: M4 宏处理器易于使用，但难以理解。简单之处在于它只做一件事，而且做得非常好。我敢打赌，你或我只需几个小时就能用 C 程序编写 M4 的基本功能。与此同时，M4
    的两个方面使得它很难立即理解。
- en: First, the exceptions introduced by *special cases* that M4 deals with when
    it processes input text make it hard to grasp all of its rules immediately, though
    this complexity is easily mastered with time, patience, and practice. Second,
    the stack-based, pre-order recursive nature of M4’s text-processing model is difficult
    for the human mind to comprehend. Humans tend to process information breadth first,
    comprehending complete levels of a problem or data set, one level at a time, whereas
    M4 processes text in a depth-first fashion.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，M4 在处理输入文本时引入的*特殊情况*使得很难立即掌握它的所有规则，尽管这些复杂性通过时间、耐心和实践可以轻松掌握。其次，M4 的基于栈的先序递归文本处理模型对于人类思维来说难以理解。人类倾向于广度优先处理信息，一次理解问题或数据集的完整层次，而
    M4 以深度优先的方式处理文本。
- en: This chapter covers what I consider the bare minimum you need to know to write
    Autoconf input files. I can’t do justice to M4 in a single chapter of this book,
    so I’ll cover just the highlights. For more detail, read the *GNU M4 Manual*.^([1](footnote.xhtml#ch16fn1))
    If you’ve already had some experience with M4, try the examples in that manual
    and then try solving a few text problems of your own using M4\. A small amount
    of such experimentation will vastly improve your understanding of M4.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了我认为编写 Autoconf 输入文件所需的最基本知识。我无法在本书的单章中充分介绍 M4，因此我将只讲解一些重点内容。欲了解更多细节，请阅读*GNU
    M4 手册*。^([1](footnote.xhtml#ch16fn1)) 如果你已经有一些 M4 的经验，可以尝试手册中的例子，然后试着自己解决一些文本问题。通过少量的实验，你对
    M4 的理解将会大大提升。
- en: M4 Text Processing
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: M4 文本处理
- en: Like many other classic Unix tools, M4 is written as a standard input/output
    (`stdio`) filter. That is, it accepts input from standard input (`stdin`), processes
    it, and then sends it to standard output (`stdout`). Input text is read in as
    a stream of bytes and converted to *tokens* before processing. Tokens consist
    of comments, names, quoted strings, and single characters that are not part of
    a comment, name, or quoted string.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多其他经典的 Unix 工具一样，M4 是作为标准输入/输出（`stdio`）过滤器编写的。也就是说，它接受来自标准输入（`stdin`）的输入，处理后将其发送到标准输出（`stdout`）。输入文本以字节流的形式读取，并在处理前转换为*标记*。标记包括注释、名称、引用字符串和不属于注释、名称或引用字符串的单个字符。
- en: 'The *default* quote characters are the backtick (`` ` ``) and the single quote
    (`''`).^([2](footnote.xhtml#ch16fn2)) Use the backtick to start a quoted string
    and the single quote character to terminate one:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*默认*的引用字符是反引号（`` ` ``）和单引号（`''`）。^([2](footnote.xhtml#ch16fn2)) 使用反引号开始一个引用字符串，用单引号字符结束一个引用字符串：'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: M4 comments are similar to quoted strings in that each one is processed as a
    single token. Each comment is delimited by a hash mark (`#`) and a newline (`\n`)
    character. Thus, all text following an *unquoted* hash mark, up to and including
    the next newline character, is considered part of a comment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: M4 注释类似于引用字符串，每个注释都被当作一个单独的标记处理。每个注释由一个井号（`#`）和换行符（`\n`）限定。因此，所有跟在*未引用*的井号之后的文本，直到下一个换行符为止，都被视为注释的一部分。
- en: Comments are not stripped from the output as they are in other computer language
    preprocessors, such as the C-language preprocessor. Rather, they are simply passed
    through without further processing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注释不会像在其他编程语言的预处理器中那样从输出中删除，例如 C 语言的预处理器。相反，它们会被直接传递而不进行进一步处理。
- en: 'The following example contains five tokens: a name token, a space character
    token, another name token, a second space character token, and finally, a single
    comment token:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例包含五个标记：一个名称标记，一个空格字符标记，另一个名称标记，第二个空格字符标记，最后是一个单独的注释标记：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A *name* is any sequence of letters, digits, and underscore characters that
    does not begin with a digit. Thus, the first line of the following example contains
    two digit character tokens, followed by a name token, whereas the second line
    contains only a single name token:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*名称*是由字母、数字和下划线字符组成的任何序列，且不能以数字开头。因此，下面示例的第一行包含两个数字字符令牌，后面跟着一个名称令牌，而第二行仅包含一个名称令牌：'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that whitespace characters (horizontal and vertical tabs, form feeds, carriage
    returns, spaces, and newlines) are specifically not part of a name, so whitespace
    characters may (and often do) act as name or other token delimiters. However,
    such whitespace delimiters are not discarded by M4, as they often are by a computer
    language compiler’s parser. They’re simply passed through from the input stream
    directly to the output stream without further modification.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，空白字符（水平和垂直制表符、换页符、回车符、空格和换行符）不是名称的一部分，因此空白字符可能（并且通常会）作为名称或其他令牌的分隔符。然而，这些空白分隔符不会像计算机语言编译器的解析器那样被
    M4 丢弃。它们会被直接从输入流传递到输出流，而不做进一步修改。
- en: '*Defining Macros*'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*定义宏*'
- en: M4 provides a variety of built-in macros, many of which are critical to the
    proper use of this tool. For instance, it would be very difficult to get any useful
    functionality out of M4 if it didn’t provide a way of defining macros. M4’s macro-definition
    macro is called `define`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: M4 提供了多种内置宏，其中许多对正确使用此工具至关重要。例如，如果 M4 不提供定义宏的方式，获取任何有用的功能将非常困难。M4 的宏定义宏叫做 `define`。
- en: 'The `define` macro is simple to describe:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`define` 宏很简单，可以这样描述：'
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `define` macro expects at least one parameter, even if it’s empty. If you
    supply only one parameter, then instances of the macro name that are found in
    the input text are simply deleted from the output text:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`define` 宏至少需要一个参数，即使它是空的。如果你只提供一个参数，那么在输入文本中找到的宏名称实例将会被简单地删除：'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note in the output text at ➊ that there are two spaces between `Hello` and
    `world!` All tokens except names that map to defined macros are passed from the
    input stream to the output stream without modification, with one exception: whenever
    any quoted text outside of comments is read from the input stream, one level of
    quotes is removed.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在 ➊ 处的输出文本中，`Hello` 和 `world!` 之间有两个空格。除了映射到已定义宏的名称外，所有其他令牌都会从输入流传递到输出流而不做修改，只有一个例外：每当从输入流中读取任何引用的文本（评论外），M4
    会移除一层引号。
- en: Another subtle aspect of the `define` macro is that its expansion is the empty
    string. Thus, the output of the preceding definition is simply the trailing carriage
    return after the definition in the input string.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`define` 宏的另一个微妙之处是它的展开结果是空字符串。因此，前面定义的输出仅仅是输入字符串中定义后的回车符。'
- en: 'Names, of course, are candidates for macro expansion. If a name token is found
    in the symbol table, it is replaced with the macro expansion, as shown in the
    following example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，名称是宏展开的候选项。如果在符号表中找到一个名称令牌，它将被宏展开所替代，如下例所示：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The second output line at ➌ shows us that the first token (the name `macro`)
    is expanded and the outer level of quotes around [PRE6] `text''` are removed by
    M4\. The blank line at ➋ following the macro definition comes from the newline
    character I entered into the input stream when I pressed the enter key after the
    macro definition at ➊. Since this newline character is not part of the macro definition,
    M4 simply passes it through to the output stream. This can be a problem when defining
    macros in input text because you could end up with a slew of blank lines in the
    output text, one for each macro defined in the input text. Fortunately, there
    are ways around this problem. For example, I could simply not enter that newline
    character, as shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行输出在 ➌ 处显示，第一个令牌（名称 `macro`）被展开，围绕 [PRE6] `text'` 的外部引号被 M4 移除。宏定义后的空行 ➋ 是我在按下回车键后输入流中添加的换行符。由于这个换行符不是宏定义的一部分，M4
    会直接将其传递到输出流中。当在输入文本中定义宏时，这可能会成为一个问题，因为你可能会在输出文本中得到一大堆空行，每个宏定义都会生成一个空行。幸运的是，有办法解决这个问题。例如，我可以简单地不输入那个换行符，如下所示：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That solves the problem, but it doesn’t take a genius to see that this can lead
    to some readability issues. If you have to define your macros in this manner so
    that they don’t affect your output text, you’ll have a few run-on sentences in
    your input text!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了问题，但不需要天才也能看出，这可能会导致一些可读性问题。如果你不得不以这种方式定义宏，以免它们影响输出文本，那么你的输入文本中可能会有一些连贯的句子！
- en: As a solution for this problem, M4 provides another built-in macro called `dnl`,^([3](footnote.xhtml#ch16fn3))
    which causes all input text up to and including the next newline character to
    be discarded. It’s common to find `dnl` used in *configure.ac*, but it’s even
    more common to find it used in *.m4* macro definition files consumed by Autoconf
    while processing *configure.ac* files.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为该问题的解决方案，M4提供了另一个内置宏，称为`dnl`，^([3](footnote.xhtml#ch16fn3))，它会导致所有输入文本直到并包括下一个换行符被丢弃。通常会在*configure.ac*中看到使用`dnl`，但在Autoconf处理*configure.ac*文件时，在*.m4*宏定义文件中使用它更为常见。
- en: 'Here’s an example of the proper use of `dnl`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`dnl`正确使用的示例：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There are a few dozen built-in M4 macros, all of which provide functionality
    that can’t be obtained in any other way within M4\. Some redefine fundamental
    behavior in M4.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有几十个内置的M4宏，它们提供了在M4中无法通过其他方式获得的功能。一些宏重新定义了M4中的基本行为。
- en: 'For example, the `changequote` macro is used to change the default quote characters
    from backtick and single quote to whatever you want. Autoconf uses a line like
    this near the top of the input stream to change the M4 quotes to the left and
    right square bracket characters, like so:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`changequote`宏用于将默认的引号字符从反引号和单引号更改为你想要的任何字符。Autoconf在输入流的顶部附近使用类似以下的行，将M4的引号更改为左方括号和右方括号字符：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Why would the Autoconf designers do this? Well, it’s quite common in shell code
    to find unbalanced pairs of single quote characters. In shell code, both backtick
    and single quote are common in expressions that use the same character to both
    start and end an expression. This is confusing to M4, which requires open and
    close quote characters to be distinct from each other in order to properly process
    its input stream. You’ll recall from [Chapter 4](ch04.xhtml) that the input text
    to Autoconf is shell script, which means that there’s a good chance Autoconf will
    run into an unbalanced pair of M4 quotes in every input file it reads. This can
    lead to errors that are very difficult to track down, because they have more to
    do with M4 than they do with Autoconf. It’s far less likely that the input shell
    script will contain an unbalanced pair of square bracket characters.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么Autoconf的设计者要这样做呢？嗯，在Shell代码中，经常会遇到不匹配的单引号对。在Shell代码中，反引号和单引号常用于使用相同字符同时开始和结束表达式的情况。这会让M4感到困惑，因为M4需要打开和关闭的引号字符彼此区分，以便正确处理其输入流。你可能还记得在[第4章](ch04.xhtml)中提到，Autoconf的输入文本是Shell脚本，这意味着Autoconf在读取每个输入文件时，很可能会遇到不匹配的M4引号对。这可能会导致非常难以追踪的错误，因为这些错误更多与M4相关，而与Autoconf无关。而输入的Shell脚本包含不匹配的方括号字符的可能性要小得多。
- en: '*Macros with Arguments*'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*带参数的宏*'
- en: 'Macros may also be defined to accept arguments, which may be referenced in
    the expansion text with `$1`, `$2`, `$3`, and so on. The number of arguments passed
    can be found in the variable `$#`, and `$@` can be used to pass all arguments
    of one macro call onto another. When using arguments in a macro call, there can
    be no intervening whitespace between the macro name and the opening parenthesis.
    Here’s an example of a macro that’s defined and then called in various ways:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 宏也可以定义为接受参数，这些参数可以通过`$1`、`$2`、`$3`等在展开的文本中引用。传递的参数数量可以通过变量`$#`找到，而`$@`可以用来将一个宏调用的所有参数传递给另一个宏。当在宏调用中使用参数时，宏名称与左括号之间不能有空格。以下是一个定义并以各种方式调用的宏示例：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, the first call at ➊ is a macro call without arguments. The
    second call is a macro call with one empty argument. Such calls treat the parameters
    as if empty arguments were actually passed.^([4](footnote.xhtml#ch16fn4)) In both
    cases, the macro expands to “`The N arguments are and .`” (note the double space
    between the last two words and the space between the last word and the period),
    but the “N” is 0 in the first call and 1 in the second. Therefore, the empty set
    of parentheses in the second call carries an empty single argument. The next three
    calls, beginning at ➋, pass one, two, and three arguments, respectively. As you
    can see by the resulting outputs of these three calls, parameters in the expansion
    text that reference missing arguments are treated as empty, while arguments passed
    without corresponding references are simply ignored.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，第一次调用位于➊处，是一个没有参数的宏调用。第二次调用是一个带有一个空参数的宏调用。这样的调用将参数视为实际上传递了空参数。^([4](footnote.xhtml#ch16fn4))
    在这两种情况下，宏展开为“`这些N个参数是和`” （注意最后两个词之间的双空格，以及最后一个词和句号之间的空格），但第一次调用中的“N”是0，第二次调用中的“N”是1。因此，第二次调用中的空括号带有一个空的单一参数。接下来的三个调用，从➋开始，分别传递一个、两个和三个参数。正如你从这三次调用的输出中所看到的，展开文本中引用缺失参数的地方被视为空，而没有对应引用的传递参数则会被忽略。
- en: The last call, at ➌, is a bit different. Notice that it contains a space between
    the macro name and the opening parenthesis. The initial output of this call is
    similar to that of the first call, but following that initial output, we find
    what appears to be a minor variation on the originally intended argument list
    (the quotes are missing). This is a macro call *without arguments*. Since it’s
    not actually part of the macro call, M4 treats the argument list simply as text
    on the input stream. Thus, it’s copied directly to the output stream, minus one
    level of quotes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的调用，位于➌处，有些不同。注意它在宏名称和左括号之间包含了一个空格。这个调用的初始输出类似于第一次调用的输出，但在初始输出之后，我们发现原本预期的参数列表有一些轻微变化（引号丢失了）。这是一个*没有参数*的宏调用。由于它实际上并不是宏调用的一部分，M4将参数列表仅视为输入流中的文本。因此，它会被直接复制到输出流中，去掉一层引号。
- en: 'When passing arguments in macro calls, be aware of whitespace around arguments.
    The rules are simple: unquoted *leading* whitespace is removed from arguments,
    and *trailing* whitespace is always preserved, whether quoted or not. Of course,
    *whitespace* here refers to carriage returns and newline characters, as well as
    spaces and tabs. Here’s an example of calling a macro with variations in leading
    and trailing whitespace:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在宏调用中传递参数时，要注意参数周围的空白符。规则很简单：未加引号的*前导*空白符会从参数中移除，而*尾随*空白符则始终保留，无论是否加引号。当然，*空白符*这里指的是回车符和换行符，以及空格和制表符。以下是一个带有前导和尾随空白符变体的宏调用示例：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, I purposely omitted the quotes around the macro arguments in
    the calls at ➊ and ➋ in order to reduce confusion. The call at ➊ has only leading
    whitespace in the form of newlines and tab characters, while the call at ➋ has
    only trailing whitespace. I’ll cover quoting rules shortly, at which point you’ll
    see clearly how quoting affects whitespace in macro arguments.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我故意省略了➊和➋处宏调用中参数周围的引号，以减少混淆。➊处的调用只有前导空白符，包括换行符和制表符，而➋处的调用只有尾随空白符。稍后我会讲解引号规则，到时你会清楚地看到引号是如何影响宏参数中的空白符的。
- en: The Recursive Nature of M4
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: M4的递归特性
- en: Now we consider the recursive nature of the M4 input stream. Whenever a name
    token is expanded by a macro definition, the expansion text is pushed back onto
    the input stream for complete reprocessing. This recursive reprocessing continues
    to occur as long as there are macro calls found in the input stream that generate
    text.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们考虑M4输入流的递归特性。每当宏定义扩展一个名称标记时，扩展文本会被推回到输入流中进行完全的重新处理。只要输入流中还有生成文本的宏调用，这种递归重新处理就会继续发生。
- en: 'Here’s an example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, I define a macro called *macro* and then present this macro name on the
    input stream, followed by additional text, some of which is quoted and some of
    which is double quoted.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我定义了一个名为*macro*的宏，然后在输入流中呈现这个宏名称，后面跟着附加的文本，其中一部分是加了引号的，一部分是加了双引号的。
- en: The process used by M4 to parse this example is shown in [Figure 16-1](ch16.xhtml#ch16fig1).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: M4用于解析这个例子的过程如[图16-1](ch16.xhtml#ch16fig1)所示。
- en: '![Image](../images/16fig01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/16fig01.jpg)'
- en: '*Figure 16-1: The procedure used by M4 to process an input text stream*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-1：M4处理输入文本流的过程*'
- en: In the bottom line of the figure, M4 is generating a stream of output text (``expansion
    `quoted[PRE13]macro ``quoted' text'[PRE14] ``quoted' text' [PRE15]
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在图的底部，M4正在生成一串输出文本（``扩展 `引用[PRE13]宏 ``引用' 文本'[PRE14] ``引用' 文本' [PRE15]
- en: $ m4
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: $ m4
- en: define(`macro', `This is a macro')dnl
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: define(`macro', `这是一个宏')dnl
- en: macro
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 宏
- en: This is a This is a This is a This is a This is a This is a... <ctrl-c>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个这是一个这是一个这是一个这是一个这是一个... <ctrl-c>
- en: $
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: $
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: $ m4
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: $ m4
- en: define(`def', `DEF')dnl
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: define(`def', `DEF')dnl
- en: ➊ define(`abc', `def')dnl
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ define(`abc', `def')dnl
- en: abc
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: abc
- en: DEF
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: DEF
- en: ➋ define(`abc', ``def'')dnl
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ define(`abc', ``def'')dnl
- en: abc
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: abc
- en: def
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: def
- en: ➌ define(`abc', [PRE17]
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ define(`abc', [PRE17]
- en: In this example, the first time `abc` is defined (at ➊), it’s quoted once. As
    M4 processes the macro definition, it removes a layer of quotes. Thus, the expansion
    text is stored in the symbol table without quotes, but it’s pushed back onto the
    input stream and therefore is transformed into `DEF` due to the first macro definition.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，第一次定义`abc`（见 ➊）时，它被加了引号。随着M4处理宏定义，它去除了一个引号层。因此，扩展文本以没有引号的形式存储在符号表中，但它会被推送回输入流，因此由于第一次宏定义，它被转换成了`DEF`。
- en: As you can see, the second definition of `abc` (at ➋) is double quoted, so when
    the definition is processed and the outer layer of quotes is stripped off, we
    would expect the expansion text in the symbol table to contain at least one set
    of quotes, and it does. Then why don’t we see quotes around the output text? Remember
    that when macros are expanded, the expansion text is pushed onto the front of
    the input stream and reparsed using the usual rules. Thus, while the text of the
    second definition is stored quoted in the symbol table, as it’s reprocessed upon
    use, the second layer of quotes is removed between the input and output streams.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，第二次定义`abc`（见 ➋）时，文本是双引号的，因此当定义被处理并且最外层的引号被去除时，我们期望符号表中的扩展文本至少包含一层引号，事实也是如此。那为什么我们没有看到输出文本周围的引号呢？记住，当宏被扩展时，扩展文本会被推送到输入流的前面，并按照通常的规则重新解析。因此，尽管第二次定义的文本在符号表中以引号形式存储，但当它在使用时重新处理时，第二层引号会在输入和输出流之间被去除。
- en: The difference between ➊ and ➋ in this example is that the expansion text of
    ➋ is treated as quoted text by M4, rather than as a potential macro name. The
    quotes are removed during definition, but the enclosed text is not considered
    for further expansion because it’s still quoted.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，➊和➋的区别在于，➋的扩展文本被M4视为引号文本，而不是潜在的宏名称。引号在定义时被去除，但包含的文本不会再被视为进一步扩展，因为它仍然是被引号包围的。
- en: 'In the third definition of `abc` (at ➌), we finally see the result we were
    perhaps hoping to obtain: a quoted version of the output text. The expansion text
    is entered into the symbol table double quoted, because the outermost set of quotes
    is stripped off during processing of the definition. Then, when the macro is used,
    the expansion text is reprocessed and the second set of quotes is stripped off,
    leaving one set in the final output text.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`abc`的第三次定义（见 ➌）中，我们终于看到了可能期待的结果：输出文本的带引号版本。扩展文本以双引号的形式进入符号表，因为最外层的引号在定义处理过程中被去除。然后，当宏被使用时，扩展文本会重新处理，并且第二层引号会被去除，最终输出文本只保留一层引号。
- en: 'If you keep these rules in mind as you work with macros within Autoconf (including
    both definitions and calls), you’ll find it easier to understand why things may
    not work the way you think they should. The *GNU M4 Manual* provides a simple
    rule of thumb for using quotes in macro calls: for each layer of nested parentheses
    in a macro call, use one layer of quotes.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在使用Autoconf中的宏（包括定义和调用）时牢记这些规则，你会发现更容易理解为什么有些事情没有按照你预期的方式工作。*GNU M4手册*提供了一个简单的经验法则，用于在宏调用中使用引号：对于宏调用中的每一层嵌套括号，都使用一层引号。
- en: Autoconf and M4
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Autoconf 和 M4
- en: 'The `autoconf` program is a rather simple shell script. About 80 percent of
    the shell code in the script exists simply to ensure that the shell is functional
    enough to perform the required tasks. The remaining 20 percent parses command
    line options. The last line of the script executes the `autom4te` program, a Perl
    script that acts as a wrapper around the `m4` utility. Ultimately, `autom4te`
    calls `m4` like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoconf`程序是一个相当简单的Shell脚本。脚本中大约80%的Shell代码仅用于确保Shell足够功能强大，可以执行所需的任务。剩下的20%用于解析命令行选项。脚本的最后一行执行`autom4te`程序，这是一个Perl脚本，它充当`m4`工具的包装器。最终，`autom4te`像这样调用`m4`：'
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, the three files that M4 is processing are */usr/share**/autoconf**/autoconf.m4f*,
    *aclocal.m4*, and *configure.ac*, in that order.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，M4 正在处理的三个文件是 */usr/share**/autoconf**/autoconf.m4f*、*aclocal.m4* 和 *configure.ac*，按此顺序。
- en: '**NOTE**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The* .m4f *extension on the master Autoconf macro file signifies a* frozen
    *M4 input file—a sort of precompiled version of the original* .m4 *file. When
    a frozen macro file is processed, it must be specified after a `--reload-state`
    option, in order to make M4 aware that it’s not a normal input file. State is
    built cumulatively within M4 over all input files, so any macros defined by* aclocal.m4,
    *for instance, are available during the processing of* configure.ac.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*主* .m4f *扩展名的 Autoconf 宏文件表示一个* 冻结的 *M4 输入文件——一种原始* .m4 *文件的预编译版本。当一个冻结的宏文件被处理时，必须在
    `--reload-state` 选项后指定，以便让 M4 知道它不是一个普通的输入文件。状态是通过 M4 在所有输入文件中逐步构建的，因此例如由 *aclocal.m4*
    定义的任何宏，都可以在处理 *configure.ac* 时使用。'
- en: The ellipsis between the two `--trace` options in the command line above is
    a placeholder for more than 100 such `--trace` options. It’s a good thing the
    shell can handle long command lines!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上面命令行中两个 `--trace` 选项之间的省略号是超过 100 个 `--trace` 选项的占位符。幸好 Shell 可以处理长命令行！
- en: The master Autoconf macro file, *autoconf.m4*, merely includes (using the `m4_include`
    macro) the other dozen or so Autoconf macro files, in the correct order, and then
    does a small amount of housekeeping before leaving M4 ready to process user input
    (via *configure.ac*). The *aclocal.m4* file is our project’s macro file, built
    originally by the `aclocal` utility or handwritten for projects that don’t use
    Automake. By the time *configure.ac* is processed, the M4 environment has been
    configured with hundreds of Autoconf macro definitions, which may be called as
    needed by *configure.ac*. This environment includes not only the recognized `AC_*`
    macros but also a few lower layers of Autoconf-provided macros that you may use
    to write your own macros.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 主 Autoconf 宏文件，*autoconf.m4*，只是包含了（使用`m4_include`宏）其他十几个 Autoconf 宏文件，并且按照正确的顺序排列，然后在离开
    M4 处理用户输入（通过 *configure.ac*）之前做一些小的整理工作。*aclocal.m4* 文件是我们项目的宏文件，最初由 `aclocal`
    工具构建，或者是为不使用 Automake 的项目手工编写的。当 *configure.ac* 被处理时，M4 环境已经配置了数百个 Autoconf 宏定义，这些宏可能在
    *configure.ac* 中按需调用。这个环境不仅包括了公认的 `AC_*` 宏，还包括了一些 Autoconf 提供的低层宏，你可以用它们来编写你自己的宏。
- en: One such lower layer is *m4sugar*,^([5](footnote.xhtml#ch16fn5)) which provides
    a nice clean namespace in which to define all of the Autoconf macros, as well
    as several improvements and additions to the existing M4 macros.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个低层宏是 *m4sugar*，^([5](footnote.xhtml#ch16fn5)) 它提供了一个干净的命名空间，用于定义所有 Autoconf
    宏，并对现有的 M4 宏做了若干改进和扩展。
- en: Autoconf modifies the M4 environment in a few ways. First, as mentioned earlier,
    it changes the default quote characters from the backtick and single quote characters
    to the open and close square bracket characters. In addition, it configures M4
    built-in macros such that most are prefixed with `m4_`, thereby creating a unique
    namespace for M4 macros. Thus, the M4 `define` macro becomes `m4_define`, and
    so on.^([6](footnote.xhtml#ch16fn6))
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf 以几种方式修改了 M4 环境。首先，如前所述，它将默认的引号字符从反引号和单引号字符更改为方括号字符。此外，它配置了 M4 内建宏，使得大多数宏都以
    `m4_` 为前缀，从而为 M4 宏创建了一个独特的命名空间。因此，M4 的 `define` 宏变成了 `m4_define`，以此类推。^([6](footnote.xhtml#ch16fn6))
- en: 'Autoconf provides its own version of `m4_define` called `AC_DEFUN`. You should
    use `AC_DEFUN` instead of `m4_define` because it ensures that certain environmental
    constraints important to Autoconf are in place when your macro is called. The
    `AC_DEFUN` macro supports a prerequisite framework, so you can specify which macros
    are required to have been called before your macro may be called. This framework
    is accessed by using the `AC_REQUIRE` macro to indicate your macro’s requirements
    at the beginning of your macro definition, like so:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf 提供了它自己版本的 `m4_define`，叫做 `AC_DEFUN`。你应该使用 `AC_DEFUN` 而不是 `m4_define`，因为它确保在调用你的宏时，某些对
    Autoconf 重要的环境约束已经到位。`AC_DEFUN` 宏支持一个先决条件框架，因此你可以指定在调用你的宏之前，哪些宏必须已经被调用。这个框架通过使用
    `AC_REQUIRE` 宏来访问，用以在你的宏定义开始时指明宏的要求，示例如下：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The rules for writing Autoconf macros using `AC_DEFUN` and the prerequisite
    framework are outlined in [Chapter 9](ch09.xhtml) of the *GNU Autoconf Manual*.
    Before you write your own macros, read [Chapters 8](ch08.xhtml) and [9](ch09.xhtml)
    of that manual.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`AC_DEFUN`和前提框架编写 Autoconf 宏的规则在*GNU Autoconf Manual*的[第9章](ch09.xhtml)中有详细介绍。在编写自己的宏之前，请先阅读该手册的[第8章](ch08.xhtml)和[第9章](ch09.xhtml)。
- en: Writing Autoconf Macros
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写 Autoconf 宏
- en: Why would we want to write Autoconf macros in the first place? One reason is
    that a project’s *configure.ac* file might contain several instances of similar
    sets of code and we need the `configure` script to perform the same set of high-level
    operations on multiple directories or file sets. By converting the process into
    a macro, we reduce the number of lines of code in the *configure.ac* file, thereby
    reducing the number of possible points of failure. Another reason might be that
    an easily encapsulated bit of *configure.ac* code could be useful in other projects,
    or even to other people.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们一开始要写 Autoconf 宏？其中一个原因是，项目的*configure.ac*文件可能包含多个类似的代码集合，我们需要`configure`脚本对多个目录或文件集执行相同的高级操作。通过将这个过程转换为宏，我们减少了*configure.ac*文件中的代码行数，从而减少了可能的故障点。另一个原因可能是，容易封装的*configure.ac*代码片段在其他项目或其他人那里也可能有用。
- en: '**NOTE**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The GNU Autoconf Archive provides many sets of related macros to solve common
    Autoconf problems. Anyone may contribute to the archive by emailing their macros
    to the project maintainer. There are frequent tarball releases available for free
    from the project website.*^([7](footnote.xhtml#ch16fn7))'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*GNU Autoconf Archive 提供了许多相关宏集，以解决常见的 Autoconf 问题。任何人都可以通过将他们的宏通过邮件提交给项目维护者来为该归档做贡献。该项目网站上经常提供免费的
    tarball 版本。*^([7](footnote.xhtml#ch16fn7))'
- en: '*Simple Text Replacement*'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*简单文本替换*'
- en: The simplest type of macro is one that replaces text verbatim, with no substitutions.
    An excellent example of this is found in the FLAIM project, where the flaim, xflaim,
    and sql projects’ `configure` scripts attempt to locate the ftk (FLAIM toolkit)
    project library and header file. Since I already discussed the operation of this
    code in [Chapter 14](ch14.xhtml), I’ll only cover it briefly here as it relates
    to writing Autoconf macros, but I provide the relevant bit of *configure.ac* code
    in [Listing 16-1](ch16.xhtml#ch16ex1) for convenience.^([8](footnote.xhtml#ch16fn8))
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的宏类型是直接替换文本而不做任何替换。一个很好的例子是 FLAIM 项目中的代码，flaim、xflaim 和 sql 项目的`configure`脚本尝试定位
    ftk（FLAIM 工具包）项目库和头文件。由于我已经在[第14章](ch14.xhtml)中讨论了这段代码的操作，在这里我仅简要介绍它与编写 Autoconf
    宏的关系，但为了方便，我提供了相关的*configure.ac*代码在[清单 16-1](ch16.xhtml#ch16ex1)中。^([8](footnote.xhtml#ch16fn8))
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 16-1:* xflaim/configure.ac: *The ftk search code from the xflaim project*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-1：* xflaim/configure.ac: *来自 xflaim 项目的 ftk 搜索代码*'
- en: This code is identical in flaim, xflaim, and sql, though it may be modified
    in the future for one reason or another, so keeping it embedded in all three *configure.ac*
    files is redundant and error prone.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在 flaim、xflaim 和 sql 中是相同的，尽管未来可能因为某些原因做修改，所以将它嵌入到所有三个*configure.ac*文件中是多余的且容易出错。
- en: Even if we were to convert this code to a macro, we’d still have to put a copy
    of the macro file into each of the projects’ *m4* directories. However, we could
    later edit only one of these macro files and copy it from the authoritative location
    into the other projects’ *m4* directories, or even use symlinks in git rather
    than copies to ensure there is truly only a single copy of the *.m4* file. This
    would be a better solution than having all of the code embedded in all three *configure.ac*
    files.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们将这段代码转换为宏，我们仍然需要将宏文件的副本放入每个项目的*m4*目录中。然而，我们可以之后只编辑其中一个宏文件，并将其从权威位置复制到其他项目的*m4*目录中，或者甚至使用
    Git 中的符号链接，而不是复制，以确保*.m4*文件只有一个副本。这比将所有代码嵌入到所有三个*configure.ac*文件中要更好。
- en: By converting this code to a macro, we can keep it in one place where portions
    of it cannot be confused for code that is not related to the process of locating
    the FLAIM toolkit library and header file. This happens quite often during later
    maintenance of a project’s *configure.ac* file, as additional code designed for
    other purposes is dropped between chunks of code belonging to sequences like this.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这段代码转换为宏，我们可以将其保留在一个地方，这样其中的部分内容就不会与与定位 FLAIM 工具包库和头文件无关的代码混淆。在项目的*configure.ac*文件的后期维护过程中，这种情况经常发生，因为为其他目的设计的额外代码会被插入到像这样的代码块之间。
- en: Let’s try converting this code into a macro. Our first attempt might look like
    [Listing 16-2](ch16.xhtml#ch16ex2). (I’ve omitted a large chunk in the middle
    that is identical to the original code, for the sake of brevity.)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将这段代码转换成一个宏。我们的第一次尝试可能会像[Listing 16-2](ch16.xhtml#ch16ex2)那样。（为了简洁起见，我省略了中间与原始代码相同的大部分内容。）
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 16-2:* xflaim/m4/flm_ftk_search.m4: *A first attempt at encapsulating
    ftk search code*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 16-2:* xflaim/m4/flm_ftk_search.m4: *封装ftk搜索代码的初次尝试*'
- en: In this pass, I’ve simply cut and pasted the entire *configure.ac* code sequence
    verbatim into the `macro-body` argument of a call to `AC_DEFUN`. The `AC_DEFUN`
    macro is defined by Autoconf and provides some additional functionality over the
    `m4_define` macro provided by M4\. This additional functionality is strictly related
    to the prerequisite framework provided by Autoconf.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一轮中，我只是简单地将整个*configure.ac*代码序列原封不动地复制粘贴到对`AC_DEFUN`调用的`macro-body`参数中。`AC_DEFUN`宏由Autoconf定义，并提供了比M4提供的`m4_define`宏更多的功能。这些额外的功能严格来说与Autoconf提供的前提框架相关。
- en: '**NOTE**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Be aware that *`AC_DEFUN`* must be used (rather than *`m4_define`*) in order
    for the macro definition to be found by *`aclocal`* in your external macro definition
    files. You must use *`AC_DEFUN`* if your macro definitions are in external files,
    but for simple macros defined within* configure.ac *itself, you can use* `m4_define`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，*`AC_DEFUN`*必须使用（而不是*`m4_define`*），才能让*`aclocal`*在外部宏定义文件中找到宏定义。如果你的宏定义在外部文件中，必须使用*`AC_DEFUN`*，但是对于在*configure.ac*文件中定义的简单宏，可以使用*`m4_define`*。'
- en: Notice the use of M4 quoting around both the macro name (`FLM_FTK _SEARCH`)
    and the entire macro body. To illustrate the problems with not using these quotes
    in this example, consider how M4 would process the macro definition without the
    quotes. If the macro name were left unquoted, not much damage would be done, unless
    the macro happened to already be defined. If the macro were already defined, M4
    would treat the macro name as a call with no parameters, and the existing definition
    would replace the macro name as M4 was reading the macro definition. (In this
    case, because of the unique name of the macro, there’s not much chance that it’s
    already defined, so I could have left the macro name unquoted with little effect,
    but it’s good to be consistent.)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在宏名称（`FLM_FTK _SEARCH`）和整个宏体周围使用了M4引号。为了说明在这个例子中不使用这些引号会遇到的问题，考虑一下M4在没有引号的情况下如何处理宏定义。如果宏名称没有加引号，通常不会造成太大问题，除非该宏已经被定义。如果宏已经定义，M4会把宏名称当作一个没有参数的调用来处理，而在读取宏定义时，现有的定义会替换掉宏名称。（在这种情况下，由于宏名称的唯一性，几乎没有机会已经被定义，所以我可以不加引号使用宏名称，但保持一致性是一个好习惯。）
- en: On the other hand, the macro body contains a fair amount of text and even Autoconf
    macro calls. Had we left the body unquoted, these macro calls would be expanded
    during the reading of the definition rather than during the later use of the macro,
    as we had intended.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，宏体包含了相当多的文本，甚至包括Autoconf宏调用。如果我们不加引号地留下宏体，那么这些宏调用会在定义被读取时展开，而不是在宏后续使用时按预期展开。
- en: Because the quotes are present, M4 stores the macro body as provided, with no
    additional processing during the reading of the definition other than to remove
    the outermost layer of quotes. Later, when the macro is called, the body text
    is inserted into the input stream in place of the macro call, with one layer of
    quotes removed, and only then are the embedded macros expanded.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有了引号，M4会按提供的方式存储宏体，在读取定义时不会进行额外的处理，除了去掉最外层的引号。稍后，当宏被调用时，宏体文本会替换宏调用并插入输入流中，去除一层引号后，只有在这时嵌套的宏才会展开。
- en: This macro requires no arguments because the same text is used identically in
    all three *configure.ac* files. The effect on *configure.ac* is to replace the
    entire chunk of code with the name of the macro, as shown in [Listing 16-3](ch16.xhtml#ch16ex3).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏不需要任何参数，因为相同的文本在所有三个*configure.ac*文件中都是相同的。对*configure.ac*的影响是用宏名称替换掉整个代码块，如[Listing
    16-3](ch16.xhtml#ch16ex3)所示。
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 16-3:* xflaim/configure.ac: *Replacing the ftk search code with the
    new macro call*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 16-3:* xflaim/configure.ac: *用新宏调用替换ftk搜索代码*'
- en: When writing a macro from existing code, consider the inputs to the existing
    chunk of code and the outputs provided by the code. Inputs will become possible
    macro arguments, and outputs will become documented effects. In [Listing 16-3](ch16.xhtml#ch16ex3),
    we have no inputs and thus no arguments, but what are the documentable effects
    of this code?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写来自现有代码的宏时，考虑现有代码块的输入和该代码提供的输出。输入将成为可能的宏参数，输出将成为文档化的效果。在 [Listing 16-3](ch16.xhtml#ch16ex3)
    中，我们没有输入，因此也没有参数，但这个代码的可记录效果是什么呢？
- en: The comment at ➊ over the macro call in [Listing 16-3](ch16.xhtml#ch16ex3) alludes
    to these effects. The `FTKLIB` and `FTKINC` variables are defined, and the `FTK_LTLIB`
    and `FTK_INCLUDE` variables are defined and substituted using `AC_SUBST`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 16-3](ch16.xhtml#ch16ex3) 中宏调用上方的注释提到了这些效果。`FTKLIB` 和 `FTKINC` 变量已经定义，而
    `FTK_LTLIB` 和 `FTK_INCLUDE` 变量则通过 `AC_SUBST` 定义并替换。'
- en: '*Documenting Your Macros*'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*记录你的宏*'
- en: A proper macro definition provides a header comment that documents possible
    arguments, results, and potential side effects of the macro, as shown in [Listing
    16-4](ch16.xhtml#ch16ex4).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个合适的宏定义应该提供一个头部注释，记录可能的参数、结果和宏的潜在副作用，如 [Listing 16-4](ch16.xhtml#ch16ex4) 中所示。
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 16-4:* xflaim/m4/flm_ftk_search.m4: *Adding a documentation header
    to the macro definition*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 16-4:* xflaim/m4/flm_ftk_search.m4: *为宏定义添加文档头部*'
- en: This header comment documents both the effects of this macro and the way it
    operates, giving the user a clear picture of the sort of functionality they’ll
    get when they call it. The *GNU Autoconf Manual* indicates that such macro definition
    header comments are stripped from the final output; if you search the `configure`
    script for some text in the comment header, you’ll see that it’s missing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个头部注释记录了该宏的效果以及它的操作方式，给用户提供了清晰的概念，让他们了解调用该宏时会获得什么样的功能。*GNU Autoconf 手册* 表示，这种宏定义头部注释会从最终输出中去除；如果你在
    `configure` 脚本中搜索注释头部的某些文本，你会发现它缺失了。
- en: Regarding coding style, the *GNU Autoconf Manual* suggests that it is good macro
    definition style to place the macro body’s closing square-bracket quote and the
    closing parenthesis alone on the last line of the macro definition, along with
    a comment containing only the name of the macro being defined, as shown in [Listing
    16-5](ch16.xhtml#ch16ex5).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 关于编码风格，*GNU Autoconf 手册* 建议，将宏体的闭合方括号引号和闭合括号单独放在宏定义的最后一行，并且注释中仅包含定义的宏名称，这是一种好的宏定义风格，如
    [Listing 16-5](ch16.xhtml#ch16ex5) 中所示。
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 16-5:* xflaim/m4/flm_ftk_search.m4: *Suggested macro body closing
    style*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 16-5:* xflaim/m4/flm_ftk_search.m4: *建议的宏体闭合样式*'
- en: The *GNU Autoconf Manual* also suggests that, if you don’t like the extra carriage
    return that the use of this format adds to the generated `configure` script, you
    can append the text `[]dnl` to the last line of the macro body, as shown at ➊
    in [Listing 16-5](ch16.xhtml#ch16ex5). The use of `dnl` causes the trailing carriage
    return to be ignored, and the open and close square brackets are simply empty
    Autoconf quotes that are stripped out during processing of later macro calls.
    The quotes (square brackets) are used to separate `fi` and `dnl` so they’re recognized
    by M4 as two separate words.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*GNU Autoconf 手册* 还建议，如果你不喜欢使用这种格式时，生成的 `configure` 脚本中多出的回车符，可以在宏体的最后一行附加
    `[]dnl` 文本，如 [Listing 16-5](ch16.xhtml#ch16ex5) 中的 ➊ 所示。使用 `dnl` 会使尾随的回车符被忽略，而方括号则是空的
    Autoconf 引号，在处理后续宏调用时会被剥离。方括号（`[]`）用于将 `fi` 和 `dnl` 分开，使 M4 能识别它们为两个独立的单词。'
- en: '**NOTE**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The* GNU Autoconf Manual *defines a very complete naming convention for macros
    and their containing files. I’ve chosen simply to prefix all macro names and their
    containing files that are strictly related to the project with a project-specific
    prefix—in this case, *`FLM_`* (*`flm_`*).*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*GNU Autoconf 手册* 定义了一个非常完整的宏及其包含文件的命名规范。我选择简单地为所有与项目严格相关的宏名称及其包含文件加上项目特定的前缀——在这种情况下是
    *`FLM_`* (*`flm_`*)。'
- en: '*M4 Conditionals*'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*M4 条件语句*'
- en: Now that you know how to write basic M4 macros, we’ll consider what it means
    to allow M4 to decide which text should be used to replace your macro call, based
    on arguments passed in the call.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何编写基本的 M4 宏，我们将考虑让 M4 决定应该使用哪些文本来替换你的宏调用，基于调用中传递的参数。
- en: Calling a Macro with and Without Arguments
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 调用带有和不带参数的宏
- en: Take a look at [Listing 16-6](ch16.xhtml#ch16ex6), which is my first attempt
    at writing the `FLM_PROG``_TRY_DOXYGEN` macro that was first used in [Chapter
    14](ch14.xhtml). This macro was designed with an optional argument, which isn’t
    apparent from its use in [Chapter 14](ch14.xhtml) because the FLAIM code called
    the macro without arguments. Let’s examine the definition of this macro. In the
    process, we’ll discover what it means to call it with and without arguments.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看[列表 16-6](ch16.xhtml#ch16ex6)，这是我第一次尝试编写`FLM_PROG_TRY_DOXYGEN`宏，该宏首次在[第14章](ch14.xhtml)中使用。这个宏设计时有一个可选参数，但从[第14章](ch14.xhtml)的使用来看并不明显，因为FLAIM代码调用宏时没有传递参数。让我们来查看一下这个宏的定义。在这个过程中，我们将发现传递有参数和没有参数时调用它的含义。
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 16-6:* ftk/m4/flm_prog_try_doxygen.m4: *A first attempt at `FLM_PROG_TRY_DOXYGEN`*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-6：* ftk/m4/flm_prog_try_doxygen.m4: *第一次尝试使用`FLM_PROG_TRY_DOXYGEN`*'
- en: First, we see a call to the `AC_ARG_VAR` macro at ➊, which is used to make the
    `DOXYGEN` variable precious to Autoconf. Making a variable precious causes Autoconf
    to display it within the `configure` script’s help text as an influential environment
    variable. The `AC_ARG_VAR` macro also makes the specified variable an Autoconf
    substitution variable. At ➋, we come to the heart of this macro—the call to `AC_CHECK_PROGS`.
    This macro checks for a `doxygen` program in the system search path, but it only
    looks for the program (passed in the second argument) if the variable (passed
    in the first argument) is empty. If this variable is not empty, `AC_CHECK_PROGS`
    assumes that the end user has already specified the proper program in the variable
    in the user’s environment, and it does nothing. In this case, the `DOXYGEN` variable
    is populated with *doxygen* if the `doxygen` program is found in the system search
    path. In either case, a reference to the `DOXYGEN` variable is substituted into
    template files by Autoconf. (Since we just called `AC_ARG_VAR` on `DOXYGEN`, this
    step is redundant but harmless.)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在➊处看到对`AC_ARG_VAR`宏的调用，它用于使`DOXYGEN`变量对Autoconf变得重要。将变量标记为“重要”会使Autoconf在`configure`脚本的帮助文本中显示它，作为一个有影响力的环境变量。`AC_ARG_VAR`宏还将指定的变量变为Autoconf替代变量。在➋处，我们来到了这个宏的核心——对`AC_CHECK_PROGS`的调用。该宏在系统搜索路径中检查`doxygen`程序，但只有在第一个参数传递的变量为空时，才会查找程序（传递给第二个参数）。如果该变量不为空，`AC_CHECK_PROGS`会假设最终用户已经在用户环境中为该变量指定了正确的程序，且不执行任何操作。在这种情况下，如果在系统搜索路径中找到`doxygen`程序，`DOXYGEN`变量将被填充为*doxygen*。无论如何，Autoconf会将对`DOXYGEN`变量的引用替换到模板文件中。（由于我们刚刚在`DOXYGEN`上调用了`AC_ARG_VAR`，这一步是多余的，但无害。）
- en: The call to `m4_ifval` at ➌ brings us to the point of this section. This is
    a conditional macro defined in Autoconf’s *m4sugar* layer—a layer of simple macros
    designed to make writing higher-level Autoconf macros easier. M4 conditional macros
    are designed to generate one block of text if a condition is true and another
    if the condition is false. The purpose of `m4_ifval` is to generate text based
    on whether its first argument is empty. If its first argument is not empty, the
    macro generates the text in its second argument. If its first argument is empty,
    the macro generates the text in its third argument.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在➌处对`m4_ifval`的调用引出了本节的重点。这是一个在Autoconf的*m4sugar*层中定义的条件宏——一个设计用来简化编写更高级别Autoconf宏的简单宏层。M4条件宏旨在根据条件生成一段文本，如果条件为真，则生成一段文本，如果条件为假，则生成另一段文本。`m4_ifval`的作用是根据其第一个参数是否为空来生成文本。如果第一个参数不为空，则宏会生成第二个参数中的文本。如果第一个参数为空，则宏会生成第三个参数中的文本。
- en: The `FLM_PROG_TRY_DOXYGEN` macro works with or without an argument. If no arguments
    are passed, `FLM_PROG_TRY_DOXYGEN` will print a warning message that the build
    is continuing without Doxygen support if the `doxygen` program is not in the system
    search path. On the other hand, if the `quiet` option is passed to `FLM_PROG_TRY_DOXYGEN`,
    no message will be printed if the `doxygen` program is not found.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`FLM_PROG_TRY_DOXYGEN`宏在有或没有参数的情况下都能工作。如果没有传递参数，`FLM_PROG_TRY_DOXYGEN`将打印一条警告消息，指出如果系统搜索路径中没有`doxygen`程序，构建将继续进行，但没有Doxygen支持。另一方面，如果将`quiet`选项传递给`FLM_PROG_TRY_DOXYGEN`，则如果找不到`doxygen`程序，将不会打印任何消息。'
- en: In [Listing 16-6](ch16.xhtml#ch16ex6), `m4_ifval` generates no text (the second
    argument is empty) if the first argument contains text. The first argument is
    `$1`, which refers to the contents of the first argument passed to `FLM_PROG_TRY_DOXGEN`.
    If no arguments are given to our macro, `$1` will be empty, and `m4_ifval` will
    generate the text in its third argument shown at ➍. On the other hand, if we pass
    `quiet` (or any text, for that matter) to `FLM_PROG_TRY_DOXYGEN`, `$1` will contain
    `quiet`, and `m4_ifval` will generate nothing.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 16-6](ch16.xhtml#ch16ex6)中，如果第一个参数包含文本，`m4_ifval`将不会生成文本（第二个参数为空）。第一个参数是`$1`，它指代传递给`FLM_PROG_TRY_DOXGEN`的第一个参数的内容。如果我们的宏没有传递任何参数，`$1`将为空，`m4_ifval`将生成其第三个参数中所示的文本（在➍处）。另一方面，如果我们传递`quiet`（或者任何文本）给`FLM_PROG_TRY_DOXYGEN`，`$1`将包含`quiet`，`m4_ifval`将不会生成任何内容。
- en: The shell code in the third argument (at ➍) checks to see if the `DOXYGEN` variable
    is still empty after the call to `AC_CHECK_PROGS`. If it is, it calls `AC_MSG_WARN`
    to display a configuration warning.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数中的Shell代码（在➍处）检查在调用`AC_CHECK_PROGS`之后，`DOXYGEN`变量是否仍然为空。如果是，它调用`AC_MSG_WARN`来显示配置警告。
- en: Adding Precision
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 增加精确度
- en: Autoconf provides a macro called `m4_if`, a renamed version of the M4 built-in
    `ifelse` macro. The `m4_if` macro is similar in nature to *m4sugar*’s `m4_ifval`.
    [Listing 16-7](ch16.xhtml#ch16ex7) shows how we might use `ifelse` in place of
    `m4_ifval`, if we didn’t have *m4sugar* macros to work with.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf提供了一个名为`m4_if`的宏，它是M4内建的`ifelse`宏的重命名版本。`m4_if`宏的本质与*m4sugar*的`m4_ifval`相似。[清单
    16-7](ch16.xhtml#ch16ex7)展示了如果没有*m4sugar*宏，我们如何使用`ifelse`来代替`m4_ifval`。
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 16-7: Using `ifelse` instead of `m4_ifval`*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-7: 使用`ifelse`代替`m4_ifval`*'
- en: 'The macros appear to be identical in function, but this appearance is only
    circumstantial; the parameters are used differently. In this case, if the first
    argument (`$1`) is the same as the second argument (the empty string), the contents
    of the third argument (`[if test -z ...]`) are generated. Otherwise, the contents
    of the fourth (nonexistent) argument are generated because omitted arguments are
    treated as if the empty string had been passed. Therefore, the following two macro
    invocations are identical:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏看起来在功能上是相同的，但这种相似性只是表面现象；参数的使用方式是不同的。在这种情况下，如果第一个参数（`$1`）与第二个参数（空字符串）相同，则会生成第三个参数的内容（`[if
    test -z ...]`）。否则，会生成第四个（不存在的）参数的内容，因为省略的参数会被当作传递了空字符串来处理。因此，以下两个宏调用是等效的：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`FLM_PROG_TRY_DOXYGEN` treats any text in its argument as if `quiet` was passed.
    In order to facilitate future enhancements to this macro, we should limit the
    allowed text in this argument to something that makes sense; otherwise, users
    could abuse this parameter and we’d be stuck supporting whatever they pass for
    the sake of backward compatibility. The `m4_if` macro can help us out here. This
    macro is quite powerful because it accepts an unlimited number of arguments. Here
    are its basic prototypes:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`FLM_PROG_TRY_DOXYGEN`将其参数中的任何文本视为传递了`quiet`。为了便于未来对这个宏的扩展，我们应该限制该参数中允许的文本为有意义的内容；否则，用户可能会滥用这个参数，而我们将不得不支持他们为了向后兼容所传递的任何内容。`m4_if`宏可以帮助我们解决这个问题。这个宏非常强大，因为它可以接受任意数量的参数。以下是它的基本原型：'
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If only one parameter is passed to `m4_if`, that parameter is treated as a comment
    because there’s not much that `m4_if` can do with one argument. If three or four
    arguments are passed, the description I gave for `ifelse` in [Listing 16-7](ch16.xhtml#ch16ex7)
    is also accurate for `m4_if`. However, if five or more arguments are passed, the
    fourth and fifth become the comparison strings for a second else-if clause. The
    last argument in an arbitrarily long set of triples is generated if the last two
    comparison strings are different.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只传递一个参数给`m4_if`，这个参数将被视为注释，因为`m4_if`对于一个参数几乎无法做任何事情。如果传递三个或四个参数，我在[清单 16-7](ch16.xhtml#ch16ex7)中对`ifelse`的描述同样适用于`m4_if`。然而，如果传递五个或更多参数，则第四和第五个参数将成为第二个else-if条件的比较字符串。如果最后两个比较字符串不同，则在任意长度的三元组中生成最后一个参数。
- en: We can use `m4_if` to ensure that `quiet` is the only acceptable option in the
    list of options accepted by `FLM_PROG_TRY_DOXYGEN`. [Listing 16-8](ch16.xhtml#ch16ex8)
    shows one possible implementation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`m4_if`来确保`quiet`是`FLM_PROG_TRY_DOXYGEN`接受的选项列表中唯一可接受的选项。[清单 16-8](ch16.xhtml#ch16ex8)展示了一种可能的实现方式。
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 16-8: Restricting the argument options allowed by `FLM_PROG_TRY_DOXYGEN`*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-8: 限制`FLM_PROG_TRY_DOXYGEN`允许的参数选项*'
- en: In this case, we want a message to be printed if `doxygen` is missing in all
    cases except when the `quiet` option is given as the first argument passed into
    our macro. In [Listing 16-8](ch16.xhtml#ch16ex8), I’ve given `FLM_PROG_TRY_DOXYGEN`
    the ability to detect cases when something other than `quiet` or the empty string
    is passed in this parameter and to do something specific in response. [Listing
    16-9](ch16.xhtml#ch16ex9) shows the resulting pseudocode generated by the expansion
    of `FLM_PROG_TRY_DOXYGEN`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们希望如果 `doxygen` 丢失，除非传入 `quiet` 选项作为宏的第一个参数，否则无论什么情况都要打印一条信息。在[列表16-8](ch16.xhtml#ch16ex8)中，我为
    `FLM_PROG_TRY_DOXYGEN` 添加了一个功能，当传入的参数是除 `quiet` 或空字符串之外的任何内容时，它能够检测到这一情况并做出特定响应。[列表16-9](ch16.xhtml#ch16ex9)显示了通过展开
    `FLM_PROG_TRY_DOXYGEN` 生成的伪代码。
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 16-9: Pseudocode for [Listing 16-8](ch16.xhtml#ch16ex8)’s use of the
    `m4_if` macro*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表16-9：伪代码用于[列表16-8](ch16.xhtml#ch16ex8)的 `m4_if` 宏使用*'
- en: Let’s examine exactly what’s going on in [Listing 16-8](ch16.xhtml#ch16ex8).
    If arguments one (`[$1]`) and two (`[]`) are the same, a warning message is generated
    when `doxygen` is not found. If arguments four (`[$1]`) and five (`[quiet]`) are
    the same, nothing is generated; otherwise, arguments four and five are different,
    and a fatal error (via `m4_fatal`) is generated by Autoconf when it’s executed
    against the calling *configure.ac* file. It’s very simple, once you see how it
    works *and* once you get the bugs worked out—which brings us nicely to our next
    topic.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看[列表16-8](ch16.xhtml#ch16ex8)中的内容。如果参数一（`[$1]`）和参数二（`[]`）相同，当未找到 `doxygen`
    时，会生成一条警告信息。如果参数四（`[$1]`）和参数五（`[quiet]`）相同，则不会生成任何内容；否则，参数四和五不同，当执行到调用的 *configure.ac*
    文件时，Autoconf 会生成一个致命错误（通过 `m4_fatal`）。一旦你了解它的工作原理，并且调试好 bug，整个过程就非常简单了——这也引出了我们的下一个话题。
- en: Diagnosing Problems
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题诊断
- en: 'One of the most significant stumbling blocks that people run into at this point
    is not so much a lack of understanding of how these macros work but a lack of
    attention to detail. There are several places where things can go wrong when writing
    even a simple macro like this. For example, you might have any of the following
    problems:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 人们在这一点上遇到的一个主要难题，并非缺乏对这些宏如何工作的理解，而是缺乏对细节的关注。在编写即使是一个简单的宏时，也有几个地方可能出问题。例如，你可能会遇到以下问题：
- en: Space between a macro name and the opening parenthesis
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏名称和左括号之间的空格
- en: Unbalanced brackets or parentheses
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不平衡的括号或圆括号
- en: The wrong number of parameters
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数个数错误
- en: A misspelled macro name
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏名称拼写错误
- en: Incorrectly quoted arguments to a macro
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误引用的宏参数
- en: A missing comma in a macro’s parameter list
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏参数列表中缺少逗号
- en: M4 is rather unforgiving of such mistakes. Worse, its error messages can be
    even more cryptic than those of `make`.^([9](footnote.xhtml#ch16fn9)) If you get
    strange errors and you think your macro should be working, your best diagnostic
    method is to scan the definition very carefully looking for the preceding conditions.
    These mistakes are easy to make, and in the end most problems come down to some
    combination of them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: M4 对此类错误非常不宽容。更糟糕的是，它的错误信息有时比 `make` 的错误信息还要难以理解。^([9](footnote.xhtml#ch16fn9))
    如果你遇到奇怪的错误，并且认为你的宏应该能正常工作，那么最好的诊断方法是仔细检查宏的定义，寻找可能存在的前置条件。这些错误很容易犯，最终大多数问题归结为这些条件的某种组合。
- en: 'Another very useful debugging tool is the `m4_traceon` and `m4_traceoff` macro
    pair. The macro signatures are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的调试工具是 `m4_traceon` 和 `m4_traceoff` 宏对。它们的宏签名如下：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: All arguments are optional. When given, the arguments should be a comma-separated
    list of macro names you’d like M4 to print to the output stream as these names
    are encountered in the input stream. If you omit the arguments, M4 will print
    the name of every macro it expands.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所有参数都是可选的。如果提供了参数，它们应该是一个逗号分隔的宏名称列表，当这些名称出现在输入流中时，M4 会将它们打印到输出流中。如果省略参数，M4 将打印它展开的每个宏的名称。
- en: 'A typical trace session in M4 looks something like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: M4 中一个典型的追踪会话看起来像这样：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The number between dashes in the output lines at ➊ and ➋ indicates the nesting
    level, which is usually 1\. The value of the trace facility is that you can easily
    see when the traced macros are expanded within the context of the output text
    generated. The M4 tracing facility can also be enabled from the command line with
    the `-t` or `--trace` option:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 输出行中➊和➋之间的数字表示嵌套级别，通常为1。追踪功能的价值在于，你可以轻松看到被追踪的宏在生成的输出文本中的展开位置。M4 的追踪功能也可以通过命令行启用，使用
    `-t` 或 `--trace` 选项：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Or more appropriately for this discussion:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更适合本讨论的是：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The latter has the added benefit of allowing you to specify a format for the
    trace output. For more insight into the use of the format portion of the option,
    try entering `autom4te --help` at the command prompt. For more information on
    the use of the M4 trace options, refer to [Chapter 7](ch07.xhtml) (specifically,
    Section 7.2) of the *GNU M4 Manual*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 后者的额外好处是允许你为追踪输出指定格式。要深入了解该选项格式部分的使用，尝试在命令行输入`autom4te --help`。有关M4追踪选项的更多信息，请参阅*GNU
    M4手册*的[第7章](ch07.xhtml)（特别是第7.2节）。
- en: '**NOTE**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The Autotools rely heavily on tracing for more than just debugging. Various
    of the Autotools and their supporting utilities use traces on* configure.ac *to
    gather information used in other stages of the configuration process. (Recall
    the 100+ trace options on the* m4 *command line.) For more information on tracing
    within Autoconf, refer to Section 3.4 of the* GNU Autoconf Manual, *titled “Using
    *`autoconf`* to Create *`configure`*.”*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*Autotools不仅仅依赖于追踪进行调试。许多Autotools及其支持工具在* configure.ac *中使用追踪，以收集在配置过程其他阶段使用的信息。（回想一下*m4*命令行上100多个追踪选项。）有关Autoconf中追踪的更多信息，请参阅*GNU
    Autoconf手册*的第3.4节，标题为“使用*`autoconf`*来创建*`configure`*。”*'
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Using M4 is deceptively complex. On the surface it appears simple, but as you
    get deeper into it, you find ways of using it that almost defy comprehension.
    Nonetheless, the complexities are not insurmountable. As you become proficient
    with M4, you’ll find that your way of thinking about certain problems changes.
    It’s worth gaining some M4 proficiency for that reason alone. It’s like adding
    a new tool to your software-engineering toolbox.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用M4表面上看起来很简单，实际上却很复杂。表面上它似乎简单，但当你深入研究时，会发现有些使用方式几乎让人难以理解。然而，这些复杂性并非不可克服。随着你对M4的熟练掌握，你会发现你对某些问题的思考方式发生了变化。仅仅为了这个原因，掌握M4是值得的。这就像是在你的软件工程工具箱中加入了一件新工具。
- en: A powerful M4 concept I did not cover, but that you should be aware of, is *iteration*.
    Normally, we think of iteration in terms of loops, but M4 has no actual looping
    constructs. Rather, iteration is managed through recursion. For details, refer
    to the manual’s discussion of the `forloop` and `foreach` macros.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有涵盖的一个强大的M4概念，但你应该了解的是*迭代*。通常，我们把迭代理解为循环，但M4没有实际的循环结构。相反，迭代是通过递归来管理的。有关详细信息，请参阅手册中关于`forloop`和`foreach`宏的讨论。
- en: Because the very foundation of Autoconf is M4, becoming proficient with M4 will
    give you more insight into Autoconf than you might think. The more about M4 you
    know, the more about Autoconf you’ll understand at a glance.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Autoconf的基础就是M4，精通M4将使你对Autoconf有比你想象的更深入的理解。你对M4了解得越多，你对Autoconf的理解也会越清晰。
