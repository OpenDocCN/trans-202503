<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" xml:lang="en" lang="en">
<head>
<title>8. Other Access Checking Use Cases</title>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="sbo-rt-content"><section aria-labelledby="ch8" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="CHAPTER" id="ch8">
<span class="CN"><span aria-label=" Page 265. " epub:type="pagebreak" id="pg_265" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">OTHER ACCESS CHECKING USE CASES</samp></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="386" src="../images/chapter.jpg" width="386"/></figure>
<p class="ChapterIntro">Access checks determine what access a caller should have when opening a kernel resource. However, we sometimes perform them for other reasons, as they can serve as additional security checks. This chapter details some examples of using access checks as a secondary security mechanism.</p>
<p class="TX">We’ll start by looking at traversal checking, which determines whether a caller has access to a hierarchy of resources. Next, we’ll discuss how access checks are used when a handle is duplicated. We’ll also consider how an access check can limit access to kernel information, such as process listings, from sandboxed applications. Finally, I’ll describe some additional PowerShell commands that automate the access checking of resources.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="h1-65"></span><span aria-label=" Page 266. " epub:type="pagebreak" id="pg_266" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_B_11">Traversal Checking</samp></h3>
<p class="TNI1">When accessing a hierarchical set of resources, such as an object directory tree, the user must traverse the hierarchy until they reach the target resource. For every directory or container in the hierarchy, the system performs an access check to determine whether the caller can proceed to the next container. This check is called a <i>traversal check</i>, and it’s performed whenever code looks up a path inside the I/O manager or object manager. For example, <a href="chapter8.xhtml#fig8-1">Figure 8-1</a> shows the traversal checks needed to access an OMNS object using the path <i>ABC\QRS\XYZ\OBJ</i>.</p>
<figure class="IMG"><img alt="" class="img1" height="314" id="fig8-1" src="../images/Figure8-1.jpg" width="1380"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: Traversal checks required to access</samp> <samp class="SANS_Futura_Std_Book_11">OBJ</samp></p></figcaption>
</figure>
<p class="TX">As you can see, three access checks must be performed before we can access <i>OBJ</i>. Each access check extracts the security descriptor from the container and then checks the type-specific access to see if traversal is allowed. Both the OMNS and file directories can grant or deny <samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp> access. If, for example, <i>QRS</i> denied <samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp> access to the caller, the traversal check would fail, as shown in <a href="chapter8.xhtml#fig8-2">Figure 8-2</a>.</p>
<figure class="IMG"><img alt="" class="img1" height="313" id="fig8-2" src="../images/Figure8-2.jpg" width="1380"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-2: Traversal checks blocked at</samp> <samp class="SANS_Futura_Std_Book_11">QRS</samp></p></figcaption>
</figure>
<p class="TX">Even if the caller would pass the access checks for <i>XYZ</i> and <i>OBJ</i>, because <i>QRS</i> now denies access via the traversal check, it’s no longer possible for them to access <i>OBJ</i> using the <i>ABC\QRS\XYZ\OBJ</i> path.</p>
<p class="TX">The traversal check prevents a user from accessing their resources if any parent container denies <samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp> access. This is unexpected behavior—why shouldn’t a user be able to access their own resources? It also introduces a performance concern. If a user must have access to every parent container to access their files, then the kernel must expend time and effort performing an access check for each container, when all that matters security-wise is whether the user has access to the resource they want to open.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="H2" id="sec2"><span id="h2-83"></span><span aria-label=" Page 267. " epub:type="pagebreak" id="pg_267" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The SeChangeNotifyPrivilege Privilege</samp></h4>
<p class="TNI1">To make the traversal check behavior closer to how you might expect it to work and reduce the performance impact, the SRM defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp> privilege, which almost every <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object has enabled by default. When this privilege is enabled, the system bypasses the entire traversal check and lets users access resources that an inaccessible parent would otherwise block. In <a href="chapter8.xhtml#Lis8-1">Listing 8-1</a>, we verify the privilege’s behavior using OMNS directory objects.</p>
<span id="Lis8-1"></span><pre><code>PS&gt; <b>$path = "\BaseNamedObjects\ABC\QRS\XYZ\OBJ"</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$os = New-NtMutant $path -CreateDirectories</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Enable-NtTokenPrivilege SeChangeNotifyPrivilege</b>
PS&gt; <b>Test-NtObject $path</b>
True

PS&gt; <b>$sd = New-NtSecurityDescriptor -EmptyDacl</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Set-NtSecurityDescriptor "\BaseNamedObjects\ABC\QRS" $sd Dacl</b>
PS&gt; <b>Test-NtObject $path</b>
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> True

<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> PS&gt; <b>Disable-NtTokenPrivilege SeChangeNotifyPrivilege</b>
PS&gt; <b>Test-NtObject $path</b>
False

<span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> PS&gt; <b>Test-NtObject "OBJ" -Root $os[1]</b>
True
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 8-1: Testing SeChangeNotifyPrivilege to bypass traversal checks</span></p>
<p class="TX">We first create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object and all its parent directories, automating the directory creation by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDirectories</samp> property <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We ensure the privilege is enabled <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> and then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtObject</samp> command to check whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object can be opened. In the output, we can see we’re able to open the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object.</p>
<p class="TX">We then set a security descriptor with an empty DACL on the <i>QRS</i> directory <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. This should block all access to the directory object, including <samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp> access. But when we check our access again, we see that we can still access the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object because we have the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp> privilege enabled <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">We now disable the privilege and try again to open the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. This time, the directory traversal fails. Without the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp> privilege or access to the <i>QRS</i> directory, we can no longer open the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object. However, our final check demonstrates that if we have access to a parent after <i>QRS</i>, such as <i>XYZ</i>, we can access the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object via a relative open by using the directory as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Root</samp> parameter <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="H2" id="sec3"><span id="h2-84"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Limited Checks</samp></h4>
<p class="TNI1">The kernel contains an additional performance improvement for traversal checks. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp> privilege is disabled, the kernel will <span aria-label=" Page 268. " epub:type="pagebreak" id="pg_268" role="doc-pagebreak"></span>call the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeFastTraverseCheck</samp> function, which performs a more limited check instead of a full access check. For completeness, I have reimplemented the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeFastTraverseCheck</samp> function in PowerShell so that we can explore its behavior in more detail. <a href="chapter8.xhtml#Lis8-2">Listing 8-2</a> shows the implementation.</p>
<span id="Lis8-2"></span><pre><code>function Get-FastTraverseCheck {
    Param(
      <span aria-label="annotation1" class="CodeAnnotationCode2">❶</span> $TokenFlags,
        $SecurityDescriptor,
        $AccessMask
    )

  <span aria-label="annotation2" class="CodeAnnotationCode2">❷</span> if ($SecurityDescriptor.DaclNull) {
        return $true
    }
  <span aria-label="annotation3" class="CodeAnnotationCode2">❸</span> if (($TokenFlags -band "IsFiltered, IsRestricted") -ne 0) {
        return $false
    }
    $sid = Get-Ntsid -KnownSid World
    foreach($ace in $SecurityDescriptor.Dacl) {
      <span aria-label="annotation4" class="CodeAnnotationCode2">❹</span> if ($ace.IsInheritedOnly -or !$ace.IsAccessGranted($AccessMask)) {
            continue
        }
      <span aria-label="annotation5" class="CodeAnnotationCode2">❺</span> if ($ace.IsDeniedAce) {
            return $false
        }
      <span aria-label="annotation6" class="CodeAnnotationCode2">❻</span> if ($ace.IsAllowedAce -and $ace.Sid -eq $sid) {
            return $true
        }
    }
  <span aria-label="annotation7" class="CodeAnnotationCode2">❼</span> return $false
}
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 8-2: A PowerShell implementation of SeFastTraverseCheck</span></p>
<p class="TX">First, we define the three parameters the function takes: the token’s flags, a directory object’s security descriptor, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp> access rights to check <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We specify the access rights because the object manager and the I/O manager use this function for <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> objects, and the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp> access right differs between the two object types; specifying the access as a parameter allows the check function to handle both cases.</p>
<p class="TX">Next, we check whether the security descriptor’s DACL is NULL, granting access if it is <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We follow this with a check on two token flags <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. If the flags indicate that the token is filtered or restricted, then the fast check fails. The kernel copies these flags from the caller’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object. We can get the flags from user mode using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp> property on a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object, as shown in <a href="chapter8.xhtml#Lis8-3">Listing 8-3</a>.</p>
<span id="Lis8-3"></span><pre><code>PS&gt; <b>$token = Get-NtToken -Pseudo -Primary</b>
PS&gt;<b> $token.Flags</b>
VirtualizeAllowed, IsFiltered, NotLow

<span aria-label=" Page 269. " epub:type="pagebreak" id="pg_269" role="doc-pagebreak"></span>PS&gt;<b> $token.ElevationType</b>
Limited
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 8-3: Querying token flags</span></p>
<p class="TX">Notice that the flags include <samp class="SANS_TheSansMonoCd_W5Regular_11">IsFiltered</samp>. If you’re not running in a restricted token sandbox, why would this flag be set? Querying the token elevation type shows that it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Limited</samp>, which means it’s the default token for a UAC administrator. To convert the full administrator token to the default token, LSASS uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp> system, which will set the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsFiltered</samp> flag but not <samp class="SANS_TheSansMonoCd_W5Regular_11">IsRestricted</samp>, as it’s only removing groups, not adding restricted SIDs. This means that while a UAC admin running code as the default user can never pass the fast traversal check, a normal user could. This behavior doesn’t have any security implication, but it does mean that if <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp> is disabled, resource lookup performance will suffer.</p>
<p class="TX">The final check in <a href="chapter8.xhtml#Lis8-3">Listing 8-3</a> consists of enumerating the DACL’s ACEs. If the ACE is inherit-only or doesn’t contain the required <samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp> access mask, it’s skipped <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. If it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp> ACE, the fast traverse check fails <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>, and the ACE’s SID is not checked at all. Finally, if the ACE is an <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp> ACE and the SID equals the <i>Everyone</i> group’s SID, the fast check succeeds <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. If there are no more ACEs, the check fails <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>.</p>
<p class="TX">Note that this fast check doesn’t consider whether the caller’s token has the <i>Everyone</i> group enabled. This is because typically the only way to remove the <i>Everyone</i> group would be to filter the token. The big exception to this is the anonymous token, which doesn’t have any groups but is also not filtered in any way.</p>
<p class="TX">Now let’s turn to another use for the access check: considering the granted access when assigning a duplicated handle.</p>
</section>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H1" id="sec4"><span id="h1-66"></span><samp class="SANS_Futura_Std_Bold_B_11">Handle Duplication Access Checks</samp></h3>
<p class="TNI1">The system always performs an access check when creating or opening a kernel resource that returns a handle. But what about when that handle is duplicated? In the simplest case, when the new handle has the same granted access mask as the original one, the system won’t perform any checks. It’s also possible to drop some parts of the granted access mask, and doing so won’t trigger an additional access check either. However, if you want to add additional access rights to the duplicated handle, the kernel will query the security descriptor from the object and perform a new access check to determine whether to allow the access.</p>
<p class="TX">When you duplicate a handle, you must specify both the source and destination process handles, and the access check occurs in the context of the destination process. This means the access check considers the destination process’s primary token, not the source process’s, which could be an issue if a privileged process tried to duplicate a handle to a less privileged process with additional access. Such an operation would fail with <samp class="SANS_TheSansMonoCd_W5Regular_11">Access Denied</samp>.</p>
<p class="TX"><a href="chapter8.xhtml#Lis8-4">Listing 8-4</a> demonstrates this handle duplication access check behavior.</p>
<span id="Lis8-4"></span><pre><code><span aria-label=" Page 270. " epub:type="pagebreak" id="pg_270" role="doc-pagebreak"></span>PS&gt; <b>$sd = New-NtSecurityDescriptor -EmptyDacl</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$m = New-NtMutant -Access ModifyState, ReadControl -SecurityDescriptor $sd</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Use-NtObject($m2 = Copy-NtObject -Object $m) {</b>
    <b>$m2.GrantedAccess</b>
<b>}</b>
ModifyState, ReadControl

PS&gt; <b>$mask = Get-NtAccessMask -MutantAccess ModifyState</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Use-NtObject($m2 = Copy-NtObject -Object $m -DesiredAccessMask $mask) {</b>
    <b>$m2.GrantedAccess</b>
<b>}</b>
ModifyState

<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>Use-NtObject($m2 = Copy-NtObject -Object $m -DesiredAccess GenericAll) {</b>
    <b>$m2.GrantedAccess</b>
<b>}</b>
Copy-NtObject : (0xC0000022) - {Access Denied}
A process has requested access to an object, ...
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 8-4: Testing the handle duplication access check behavior</span></p>
<p class="TX">We first create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object with an empty DACL and request only <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> access on the handle <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This will block all users from accessing the object, except for the owner, who can be granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp> access thanks to the owner check described in the previous chapter. We test the duplication by requesting the same access, which the new handle returns <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">Next, we request <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp> access only <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. As the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>’s DACL is empty, this access right wouldn’t be granted during an access check, and because we get <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp> on the new handle, we know that no access check took place. Finally, we try to increase our access by requesting <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp> access <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. An access check must now take place, as we’re requesting greater access rights than the handle currently has. This check results in an <samp class="SANS_TheSansMonoCd_W5Regular_11">Access Denied</samp> error.</p>
<p class="TX">If we hadn’t set a security descriptor when creating the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>, there would be no security associated with the object, and this last check would have succeeded, granting <samp class="SANS_TheSansMonoCd_W5Regular_11">Full Access</samp>. As mentioned in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>, you need to be careful when duplicating unnamed handles to less privileged processes if you’re dropping access; the destination process might be able to reduplicate the handle to one with more access. In <a href="chapter8.xhtml#Lis8-5">Listing 8-5</a>, we test the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtDuplicateObject NoRightsUpgrade</samp> flag to see how it affects handle duplication access checking.</p>
<span id="Lis8-5"></span><pre><code>PS&gt; <b>$m = New-NtMutant -Access ModifyState</b>
PS&gt; <b>Use-NtObject($m2 = Copy-NtObject -Object $m -DesiredAccess GenericAll) {</b>
    <b>$m2.GrantedAccess</b>
<b>}</b>
ModifyState, Delete, ReadControl, WriteDac, WriteOwner, Synchronize

PS&gt; <b>Use-NtObject($m2 = Copy-NtObject -Object $m -NoRightsUpgrade) {</b>
    <b>Use-NtObject($m3 = Copy-NtObject -Object $m2 -DesiredAccess GenericAll) {}</b>
<span aria-label=" Page 271. " epub:type="pagebreak" id="pg_271" role="doc-pagebreak"></span><b>}</b>
Copy-NtObject : (0xC0000022) - {Access Denied}
A process has requested access to an object, ...
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 8-5: Testing the NtDuplicateObject NoRightsUpgrade flag</span></p>
<p class="TX">We start by creating an unnamed <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object, which will have no associated security descriptor. We request the initial handle with <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp> access only. However, our attempt to duplicate a new handle with <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp> access succeeds, granting us complete access.</p>
<p class="TX">Now we test the <samp class="SANS_TheSansMonoCd_W5Regular_11">NoRightsUpgrade</samp> flag. Because we don’t specify any access mask, the handle will be duplicated with <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp> access. With the new handle, we then perform another duplication, this time requesting <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp> access. We can observe that the handle duplication fails. This isn’t due to an access check; instead, it’s because of a flag set on the handle entry in the kernel indicating that any request for more access should fail immediately. This prevents the handle from being used to gain additional access rights.</p>
<p class="TX">The incorrect handling of duplicate handles can lead to vulnerabilities; for example, CVE-2019-0943, an issue I discovered in a privileged service responsible for caching the details of font files on Windows. The service duplicated a <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object handle to a sandbox process with read-only access. However, the sandbox process could convert the handle back to a writable section handle, and the section could be mapped into memory as writable. This allowed the sandbox process to modify the state of the privileged service and escape the sandbox. Windows fixed the vulnerability by duplicating the handle using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NoRightsUpgrade</samp> flag.</p>
<aside aria-label="box-7" class="box">
<p class="BoxTitle" id="box-7"><samp class="SANS_Dogma_OT_Bold_B_11">THE THREAD PROCESS CONTEXT</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Every thread is associated with a process. Normally, when an access check occurs, the kernel extracts the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> <samp class="SANS_Futura_Std_Book_11">object from the calling thread’s object structure and uses it to look up the primary token for the access check. But the thread has a second</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> <samp class="SANS_Futura_Std_Book_11">object associated with it: the current</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">process context</samp><samp class="SANS_Futura_Std_Book_11">, which indicates the process in which the thread is currently executing code.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Normally, these objects are the same; however, the kernel sometimes switches the current process context to another process to save time during certain tasks, such as handle or virtual memory access. When a process switch has occurred, any access check on the thread will look up the primary token of the switched-to process rather than the token belonging to the process associated with the thread. Handle duplication operations make use of this process context switch: the kernel first queries the source process’s handle table, then switches the process context for the calling thread to the destination process to create the new handle in that process’s handle table.</samp></p>
<p class="BoxBodyLast"><span aria-label=" Page 272. " epub:type="pagebreak" id="pg_272" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Book_11">A process can abuse this behavior to duplicate a handle with more access to a less privileged process. If you call the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NtDuplicateObject</samp> <samp class="SANS_Futura_Std_Book_11">system call while impersonating your own token with access to the object, when the access check runs it will capture the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_SUBJECT_CONTEXT</samp> <samp class="SANS_Futura_Std_Book_11">for the thread, setting the primary token for the destination process. Crucially, though, it also sets the impersonation token to the identity being impersonated. The result is that the access check will run against the caller’s impersonation token rather than the destination process’s primary token. This allows a handle to be duplicated with additional granted access rights even if the destination process’s primary token could not pass an access check for those rights. You probably shouldn’t rely on this behavior in practice, though; it’s an implementation detail and might be subject to change.</samp></p>
</aside>
<p class="TX">The access checks that occur during traversal checking and handle duplication are typically hidden from view, but both relate to the security of an individual resource. Next, we’ll discuss how access checks limit the information we can extract and the operations we can perform for a group of resources. These restrictions occur based on the caller’s token, regardless of the individual access set for those resources.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H1" id="sec5"><span id="h1-67"></span><samp class="SANS_Futura_Std_Bold_B_11">Sandbox Token Checks</samp></h3>
<p class="TNI1">Beginning in Windows 8, Microsoft has tried to make it harder to compromise the system by escaping sandbox token restrictions. This is especially important for software such as web browsers and document readers, which process untrusted content from the internet.</p>
<p class="TX">The kernel implements two APIs that use an access check to determine whether the caller is in a sandbox: <samp class="SANS_TheSansMonoCd_W5Regular_11">ExIsRestrictedCaller</samp>, introduced in Windows 8, and <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlIsSandboxToken</samp>, introduced in Windows 10. These APIs produce equivalent results; the difference between them is that <samp class="SANS_TheSansMonoCd_W5Regular_11">ExIsRestrictedCaller</samp> checks the token of the caller, while <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlIsSandboxToken</samp> checks a specified <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object that doesn’t have to be the caller’s.</p>
<p class="TX">Internally, these APIs perform an access check for the token and grant access only if the token is not in a sandbox. <a href="chapter8.xhtml#Lis8-6">Listing 8-6</a> shows a reimplementation of this access check in PowerShell.</p>
<span id="Lis8-6"></span><pre><code>PS&gt; <b>$type = New-NtType -Name "Sandbox" -GenericRead 0x20000 </b>
<b>-GenericAll 0x1F0001</b>
PS&gt; <b>$sd = New-NtSecurityDescriptor -NullDacl -Owner "SY" -Group "SY" </b>
<b>-Type $type</b>
PS&gt; <b>Set-NtSecurityDescriptorIntegrityLevel $sd Medium -Policy NoReadUp</b>
PS&gt; <b>Get-NtGrantedAccess -SecurityDescriptor $sd -Access 0x20000 -PassResult</b>
Status               Granted Access Privileges
------               -------------- ----------
STATUS_SUCCESS       GenericRead    NONE

<span aria-label=" Page 273. " epub:type="pagebreak" id="pg_273" role="doc-pagebreak"></span>PS&gt; <b>Use-NtObject($token = Get-NtToken -Duplicate -IntegrityLevel Low) {</b>
    <b>Get-NtGrantedAccess -SecurityDescriptor $sd -Access 0x20000</b>
<b>-Token $token -PassResult</b>
<b>}</b>
Status               Granted Access Privileges
------               -------------- ----------
STATUS_ACCESS_DENIED None           NONE
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 8-6: An access check for a sandbox token</span></p>
<p class="TX">First, we need to define a dummy kernel object type using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtType</samp> command. This allows us to specify the generic mapping for the access check. We specify only the <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp> values, as write and execute access are not important in this context. Note that the new type is local to PowerShell; the kernel doesn’t know anything about it.</p>
<p class="TX">We then define a security descriptor with a NULL DACL and the owner and group SIDs set to the <i>SYSTEM</i> user. The use of a NULL DACL will deny access to lowbox tokens, as described in the previous chapter, but not to any other sandbox token type, such as restricted tokens.</p>
<p class="TX">To handle other token types, we add a <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> mandatory label ACE with a <samp class="SANS_TheSansMonoCd_W5Regular_11">NoReadUp</samp> policy. As a result, any token with an integrity level lower than <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> will be denied access to the mask specified in the generic mapping’s <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp> field. Lowbox tokens ignore the <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> mandatory label, but we’ve covered these tokens using the NULL DACL. Note that this security descriptor doesn’t consider restricted tokens with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> integrity level to be sandbox tokens. It’s not clear if this is an intentional oversight or a bug in the implementation.</p>
<p class="TX">We can now perform an access check with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp> command, using the current, non-sandboxed token. The access check succeeds, granting us <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp> access. If we repeat the check with a token that has a <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp> integrity level, the system denies us access, indicating that the token is sandboxed.</p>
<p class="TX">Behind the scenes, the kernel APIs call the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAccessCheck</samp> API, which will return an error if the caller has an Identification-level impersonation token. Therefore, the kernel will consider some impersonation tokens to be sandboxed even if the implementation in <a href="chapter8.xhtml#Lis8-6">Listing 8-6</a> would indicate otherwise.</p>
<p class="TX">When either API indicates that the caller is sandboxed, the kernel changes its behavior to do the following:</p>
<ul class="ul">
<li class="ListBullet">List only processes and threads that can be directly accessed.</li>
<li class="ListBullet">Block access to loaded kernel modules.</li>
<li class="ListBullet">Enumerate open handles and their kernel object addresses.</li>
<li class="ListBullet">Create arbitrary file and object manager symbolic links.</li>
<li class="ListBullet">Create a new restricted token with more access.</li>
</ul>
<p class="TX">For example, in <a href="chapter8.xhtml#Lis8-7">Listing 8-7</a>, we query for handles while impersonating a <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp> integrity level token and are denied access.</p>
<span id="Lis8-7"></span><pre><code><span aria-label=" Page 274. " epub:type="pagebreak" id="pg_274" role="doc-pagebreak"></span>PS&gt; <b>Invoke-NtToken -Current -IntegrityLevel Low {</b>
    <b>Get-NtHandle -ProcessId $pid</b>
<b>}</b>
Get-NtHandle : (0xC0000022) - {Access Denied}
A process has requested access to an object, ...
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 8-7: Querying for handle information while impersonating a Low integrity level token</span></p>
<p class="TX">While only kernel-mode code can access <samp class="SANS_TheSansMonoCd_W5Regular_11">ExIsRestrictedCaller</samp>, you can access <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlIsSandboxToken</samp> in user mode, as it’s also exported in <i>NTDLL</i>. This allows you to query the kernel using a token handle to find out whether the kernel thinks it is a sandbox token. The <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlIsSandboxToken</samp> API exposes its result in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">IsSandbox</samp> property, as shown in <a href="chapter8.xhtml#Lis8-8">Listing 8-8</a>.</p>
<span id="Lis8-8"></span><pre><code>PS&gt; <b>Use-NtObject($token = Get-NtToken) {</b>
    <b>$token.IsSandbox</b>
<b>}</b>
False

PS&gt; <b>Use-NtObject($token = Get-NtToken -Duplicate -IntegrityLevel Low) {</b>
    <b>$token.IsSandbox</b>
<b>}</b>
True
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 8-8: Checking the sandbox status of tokens</span></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> object returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp> has an <samp class="SANS_TheSansMonoCd_W5Regular_11">IsSandboxToken</samp> property. Internally, this property opens the process’s token and calls <samp class="SANS_TheSansMonoCd_W5Regular_11">IsSandbox</samp>. We can use this property to easily discover which processes are sandboxed, by using the script in <a href="chapter8.xhtml#Lis8-9">Listing 8-9</a>, for example.</p>
<span id="Lis8-9"></span><pre><code>PS&gt; <b>Use-NtObject($ps = Get-NtProcess -FilterScript {$_.IsSandboxToken}) {</b>
<b>    $ps | ForEach-Object {Write-Host "$($_.ProcessId) $($_.Name)"}</b>
<b>}</b>
7128 StartMenuExperienceHost.exe
7584 TextInputHost.exe
4928 SearchApp.exe
7732 ShellExperienceHost.exe
1072 Microsoft.Photos.exe
7992 YourPhone.exe
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 8-9: Enumerating all sandboxed processes for the current user</span></p>
<p class="TX">These sandbox checks are an important feature for limiting information disclosure and restricting dangerous functionality such as symbolic links, which improve an attacker’s chances of escaping the sandbox and gaining additional privileges. For example, blocking access to the handle table prevents the disclosure of kernel object addresses that could be used to exploit kernel memory corruption vulnerabilities.</p>
<p class="TX">We’ve now covered three uses of the access check for purposes not related to opening a resource. We’ll finish this chapter by describing some commands that simplify access checking over a range of individual resources.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="H1" id="sec6"><span id="h1-68"></span><span aria-label=" Page 275. " epub:type="pagebreak" id="pg_275" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_B_11">Automating Access Checks</samp></h3>
<p class="TNI1">The previous chapter provided a worked example that used <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp> to determine the granted access for a collection of kernel objects. If you want to check a different type of resource, such as files, you’ll need to modify that script to use file commands.</p>
<p class="TX">Because checking for the granted access across a range of resources is such a useful operation, the PowerShell module comes with several commands to automate the process. The commands are designed to allow you to quickly assess the security attack surface of available resources on a Windows system. They all start with <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Accessible</samp>, and you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Command</samp> to list them, as shown in <a href="chapter8.xhtml#Lis8-10">Listing 8-10</a>.</p>
<span id="Lis8-10"></span><pre><code>PS&gt; <b>Get-Command Get-Accessible* | Format-Wide</b>
Get-AccessibleAlpcPort                       Get-AccessibleDevice
Get-AccessibleEventTrace                     Get-AccessibleFile
Get-AccessibleHandle                         Get-AccessibleKey
Get-AccessibleNamedPipe                      Get-AccessibleObject
Get-AccessibleProcess                        Get-AccessibleScheduledTask
Get-AccessibleService                        Get-AccessibleToken
Get-AccessibleWindowStation                  Get-AccessibleWnf
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 8-10: Listing the Get-Accessible* commands</span></p>
<p class="TX">We’ll come back to some of these commands in later chapters. Here, we’ll focus on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp> command, which we can use to automate access checking over the entire OMNS. The command lets you specify an OMNS path to check, then enumerates the OMNS and reports either the maximum granted access or whether a specific access mask can be granted.</p>
<p class="TX">You can also specify what tokens to use for the access check. The command can source tokens from the following list:</p>
<ul class="ul">
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> objects</li>
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> objects</li>
<li class="ListBullet">Process names</li>
<li class="ListBullet">Process IDs</li>
<li class="ListBullet">Process command lines</li>
</ul>
<p class="TX">If you specify no options when running the command, it will use the current primary token. It will then enumerate all objects based on an OMNS path and perform an access check for every token specified. If the access check succeeds, then the command generates a structured object containing the details of the result. <a href="chapter8.xhtml#Lis8-11">Listing 8-11</a> shows an example.</p>
<span id="Lis8-11"></span><pre><code>PS&gt; <b>Get-AccessibleObject -Path "\"</b>
TokenId Access                     Name
------- ------                     ----
C5856B9 GenericExecute|GenericRead    \
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 8-11: Getting accessible objects from the OMNS root</span></p>
<p class="TX"><span aria-label=" Page 276. " epub:type="pagebreak" id="pg_276" role="doc-pagebreak"></span>Here, we run the command against the root of the OMNS, and we receive three columns in the output:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">TokenId  </samp>The unique identifier of the token used for the access check</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Access  </samp>The granted access, mapped to generic access rights</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Name  </samp>The name of the checked resource</p>
<p class="TX">We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">TokenId</samp> to distinguish the results for the different tokens specified to the command.</p>
<p class="TX">This output is only a subset of the result produced by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp> command. You can extract the rest of the information using commands like <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-List</samp>. You can also display the copy of the security descriptor used to perform the access check with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtSecurityDescriptor</samp> PowerShell command, as shown in <a href="chapter8.xhtml#Lis8-12">Listing 8-12</a>.</p>
<span id="Lis8-12"></span><pre><code>PS&gt; <b>Get-AccessibleObject -Path \ | Format-NtSecurityDescriptor -Summary</b>
&lt;Owner&gt; : BUILTIN\Administrators
&lt;Group&gt; : NT AUTHORITY\SYSTEM
&lt;DACL&gt;
Everyone: (Allowed)(None)(Query|Traverse|ReadControl)
NT AUTHORITY\SYSTEM: (Allowed)(None)(Full Access)
BUILTIN\Administrators: (Allowed)(None)(Full Access)
NT AUTHORITY\RESTRICTED: (Allowed)(None)(Query|Traverse|ReadControl)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 8-12: Displaying the security descriptor used for the access check</span></p>
<p class="TX">As we’ve run the command against a directory here, you might wonder if it will also list the objects contained within the directory. By default, no; the command opens the path as an object and does an access check. If you want to recursively check all objects in the directory, you need to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Recurse</samp> parameter. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp> command also accepts a <samp class="SANS_TheSansMonoCd_W5Regular_11">Depth</samp> parameter you can use to specify the maximum recursive depth. If you run a recursive check as a non-administrator user, you might see a lot of warnings, as in <a href="chapter8.xhtml#Lis8-13">Listing 8-13</a>.</p>
<span id="Lis8-13"></span><pre><code>PS&gt; <b>Get-AccessibleObject -Path "\" -Recurse</b>
WARNING: Couldn't access \PendingRenameMutex - Status: STATUS_ACCESS_DENIED
WARNING: Couldn't access \ObjectTypes - Status: STATUS_ACCESS_DENIED
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 8-13: Warnings when recursively enumerating objects</span></p>
<p class="TX">You can turn off the warnings by setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">WarningAction</samp> parameter to <samp class="SANS_TheSansMonoCd_W5Regular_11">Ignore</samp>, but keep in mind that they’re trying to tell you something. For the command to work, it needs to open each object and query its security descriptor. From user mode, this requires passing the access check during the opening; if you don’t have permission to open an object for <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> access, the command can’t perform an access check. For better results, you can run the command as an administrator, and for the best results, run it as the <i>SYSTEM</i> user by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Start-Win32ChildProcess</samp> command to start a <i>SYSTEM</i> PowerShell shell.</p>
<p class="TX"><span aria-label=" Page 277. " epub:type="pagebreak" id="pg_277" role="doc-pagebreak"></span>By default, the command will perform the access check using the caller’s token. But if you’re running the command as an administrator, you probably won’t want this behavior, as almost all resources will allow administrators full access. Instead, consider specifying arbitrary tokens to check against the resource. For example, when run as a UAC administrator, the following command recursively opens the resources using the administrator token but performs the access check with the non-administrator token from the Explorer process:</p>
<pre><code>PS&gt; <b>Get-AccessibleObject -Path \ -ProcessName explorer.exe -Recurse</b>
</code></pre>
<p class="TX">It’s common to want to filter the list of objects to check. You could run the access check against all the objects and then filter the list afterward, but this would require a lot of work that you’ll then just throw away. To save you some time, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp> command supports multiple filter parameters:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">TypeFilter  </samp>A list of NT type names to check</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Filter  </samp>A name filter used to restrict which objects are opened; can contain wildcards</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Include  </samp>A name filter used to determine which results to include in the output</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Exclude  </samp>A name filter used to determine which results to exclude from the output</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Access  </samp>An access mask used to limit the output to only objects with specific granted access</p>
<p class="TX">For example, the following command will find all the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> objects that can be opened with <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp> access:</p>
<pre><code>PS&gt; <b>Get-AccessibleObject -Path \ -TypeFilter Mutant -Access GenericAll -Recurse</b>
</code></pre>
<p class="TX">By default, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Access</samp> parameter requires that all access be granted before outputting a result. You can modify this by specifying <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowPartialAccess</samp>, which will output any result that partially matches the specified access. If you want to see all results regardless of the granted access, specify <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowEmptyAccess</samp>.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H1" id="sec7"><span id="h1-69"></span><samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp></h3>
<p class="TNI1">Let’s wrap up with some worked examples that use the commands you’ve learned about in this chapter.</p>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="H2" id="sec8"><span id="h2-85"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Simplifying an Access Check for an Object</samp></h4>
<p class="TNI1">In the previous chapter, we used the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp> command to automate an access check against kernel objects and determine their maximum <span aria-label=" Page 278. " epub:type="pagebreak" id="pg_278" role="doc-pagebreak"></span>granted access. To accomplish this, we first needed to query for an object’s security descriptor. We then passed this value to the command along with the type of kernel object to check.</p>
<p class="TX">If you have a handle to an object, you can simplify the call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp> command by specifying the object with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Object</samp> parameter, as shown in <a href="chapter8.xhtml#Lis8-14">Listing 8-14</a>.</p>
<span id="Lis8-14"></span><pre><code>PS&gt; <b>$key = Get-NtKey HKLM\Software -Win32Path -Access ReadControl</b>
PS&gt; <b>Get-NtGrantedAccess -Object $key</b>
QueryValue, EnumerateSubKeys, Notify, ReadControl
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 8-14: Running an access check on an object</span></p>
<p class="TX">Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Object</samp> parameter eliminates the need to manually extract the security descriptor from the object and will automatically select the correct generic mapping structure for the kernel object type. This reduces the risk that you’ll make mistakes when performing an object access check.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="H2" id="sec9"><span id="h2-86"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Writable Section Objects</samp></h4>
<p class="TNI1">The system uses <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> objects to share memory between processes. If a privileged process sets a weak security descriptor, it might be possible for a less privileged process to open and modify the contents of the section. This can lead to security issues if that section contains trusted parameters that can trick the privileged process into performing privileged operations.</p>
<p class="TX">I identified a vulnerability of this class, CVE-2014-6349, in Internet Explorer’s sandbox configuration. The configuration incorrectly secured a shared <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object, allowing sandboxed Internet Explorer processes to open it and disable the sandbox entirely. I discovered this issue by performing an access check for <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp> access on all named <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> objects. Once I had identified all sections with this access right, I manually determined whether any of them were exploitable from the sandbox. In <a href="chapter8.xhtml#Lis8-15">Listing 8-15</a>, we automate the discovery of writable sections using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp> command.</p>
<span id="Lis8-15"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$access = Get-NtAccessMask -SectionAccess MapWrite -AsGenericAccess</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$objs = Use-NtObject($token = Get-NtToken -Duplicate </b>
<b>-IntegrityLevel Low) {</b>
  <span aria-label="annotation3" class="CodeAnnotationCode2">❸</span> <b>Get-AccessibleObject -Win32Path "\" -Recurse -Token $token</b>
<b>-TypeFilter Section -Access $access</b>
<b>}</b>
PS&gt; <b>$objs | ForEach-Object {</b>
  <span aria-label="annotation4" class="CodeAnnotationCode2">❹</span> <b>Use-NtObject($sect = Get-NtSection -Path $_.Name) {</b>
      <b>Use-NtObject($map = Add-NtSection $sect -Protection ReadWrite </b>
<b>-ViewSize 4096) {</b>
         <b>Write-Host "$($sect.FullPath)"</b>
         <b>Out-HexDump -ShowHeader -ShowAscii -HideRepeating -Buffer $map | </b>
<b>Out-Host</b>
      <b>}</b>
    <b>}</b>
<b>}</b>
<span aria-label=" Page 279. " epub:type="pagebreak" id="pg_279" role="doc-pagebreak"></span>\Sessions\1\BaseNamedObjects\windows_ie_global_counters
00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  - 0123456789ABCDEF
-------------------------------------------------------------------
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  - ................
-&gt; REPEATED 1 LINES
00 00 00 00 00 00 00 00 00 00 00 00 1C 00 00 00  - ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  - ................
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 8-15: Enumerating writable Section objects for a Low integrity level token</span></p>
<p class="TX">We start by calculating the access mask for the <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp> access and converting it into a generic access enumeration <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp> command takes only generic access, as it doesn’t know ahead of time what objects you’re likely to want to check for. We then duplicate the current user’s token and set its integrity level to <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp>, producing a simple sandbox <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">We pass the token and access mask to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>, performing a recursive check in the user’s <i>BaseNamedObjects</i> directory by specifying a single path separator to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32Path</samp> parameter <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The results returned from the command should contain only sections that can be opened for <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp> access.</p>
<p class="TX">Finally, we enumerate the list of discovered sections, displaying their names and the initial contents of any discovered writable <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. We open each named section, map up to the first 4,096 bytes into memory, and then output the contents as a hex dump. We map the section as writable, as it’s possible the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object’s security descriptor grants <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp> access but that the section was created read-only. In this case, mapping <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp> will fail with an error.</p>
<p class="TX">You can use this script as is to find noteworthy writable sections. You don’t have to use a sandbox token; it can be interesting to see the sections available for a normal user that are owned by privileged processes. You can also use this as a template for performing the same check for any other kernel object type.</p>
</section>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H1" id="sec10"><span id="h1-70"></span><samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp></h3>
<p class="TNI1">In this chapter, we looked at some examples of the uses of access checking outside of opening a resource. We first considered traversal checks, which are used to determine if a user can traverse a hierarchical list of containers, such as object directories. Then we discussed how access checks are used when handles are duplicated between processes, including how this can create security issues if the object has no name or security descriptor configured.</p>
<p class="TX">Next, we explored how an access check can be used to determine if a caller’s token is sandboxed. The kernel does this to limit access to information or certain operations, to make it more difficult to exploit specific classes of security vulnerabilities. Finally, we saw how to automate access checks for various resource types with <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Accessible</samp> commands. We looked <span aria-label=" Page 280. " epub:type="pagebreak" id="pg_280" role="doc-pagebreak"></span>at the basic parameters common to all commands and how to use them to enumerate accessible named kernel objects.</p>
<p class="TX">That’s the end of our examination of the access check process. In the next chapter, we’ll cover the last remaining responsibility of the SRM: security auditing.</p>
</section>
</section>
</div></body>
</html>