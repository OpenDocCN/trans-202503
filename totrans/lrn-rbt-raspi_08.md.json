["```\npi@raspberrypi:~ $ raspistill -o test.jpg\nmmal: mmal_vc_component_enable: failed to enable component:\nENOSPC\nmmal: camera component couldn’t be enabled\nmmal: main: Failed to create camera component\nmmal: Failed to run camera app. Please check for firmware\nupdates\n```", "```\n➊ from picamera.array import PiRGBArray\n   from picamera import PiCamera\n   import cv2\n   import numpy as np\n   import gpiozero\n\n➋ camera = PiCamera()\n➌ image_width = 640\n   image_height = 480\n➍ camera.resolution = (image_width, image_height)\n   camera.framerate = 32\n   rawCapture = PiRGBArray(camera, size=(image_width, image_height))\n➎ center_image_x = image_width / 2\n   center_image_y = image_height / 2\n➏ minimum_area = 250\n   maximum_area = 100000\n```", "```\n   robot = gpiozero.Robot(left=(17,18), right=(27,22))\n➊ forward_speed = 0.3\n   turn_speed = 0.2\n\n➋ HUE_VAL = 28\n\n➌ lower_color = np.array([HUE_VAL-10,100,100])\n   upper_color = np.array([HUE_VAL+10,255,255])\n```", "```\n➊ for frame in camera.capture_continuous(rawCapture, format=\"bgr\", \n   use_video_port=True):\n\n    ➋ image = frame.array\n\n    ➌ hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    ➍ color_mask = cv2.inRange(hsv, lower_color, upper_color)\n\n    ➎ image2, countours, hierarchy = cv2.findContours(color_mask, \n       cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)\n```", "```\n➊ object_area = 0\n   object_x = 0\n   object_y = 0\n\n➋ for contour in contours:\n    ➌ x, y, width, height = cv2.boundingRect(contour)\n    ➍ found_area = width * height\n    ➎ center_x = x + (width / 2)\n       center_y = y + (height / 2)\n    ➏ if object_area < found_area:\n          object_area = found_area\n          object_x = center_x\n          object_y = center_y\n➐ if object_area > 0:\n       ball_location = [object_area, object_x, object_y]\n➑ else:\n    ball_location = None\n```", "```\n➊ if ball_location:\n    ➋ if (ball_location[0] > minimum_area) and (ball_location[0] \n       < maximum_area):\n        ➌ if ball_location[1] > (center_image_x + \n           (image_width/3)):\n               robot.right(turn_speed)\n               print(\"Turning right\")\n        ➍ elif ball_location[1] < (center_image_x - \n           (image_width/3)):\n               robot.left(turn_speed)\n               print(\"Turning left\")\n        ➎ else:\n               robot.forward(forward_speed)\n               print(\"Forward\")\n    ➏ elif (ball_location[0] < minimum_area):\n            robot.left(turn_speed)\n            print(\"Target isn't large enough, searching\")\n    ➐ else:\n           robot.stop()\n           print(\"Target large enough, stopping\")\n➑ else:\n       robot.left(turn_speed)\n       print(\"Target not found, searching\")\n\n    rawCapture.truncate(0)\n```"]