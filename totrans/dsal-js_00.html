<html><head></head><body>
<section epub:type="introduction" role="doc-introduction" aria-labelledby="int">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxv" aria-label="xxv"/>&#13;
<hgroup>&#13;
&#13;
<h1 class="CTINT" id="int"><span class="SANS_Dogma_OT_Bold_B_11">INTRODUCTION</span></h1>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">This book deals with two basic concepts in computer science: data structures and algorithms. It follows a structure similar to university curricula and adds examples taken from coding challenges and interview questions, using them to discuss the relative advantages and disadvantages of specific algorithms and data structures.</p>&#13;
<p class="TX">All examples are fully coded in JavaScript, with particular attention given to modern language features that simplify coding. Performance is also considered, from both a theoretical point of view (order of algorithms) and a practical one (scaffolding, measuring). Each chapter ends with a series of questions that amplify the concepts covered in the chapter and provide further examples for the reader to apply. The answers to the questions are provided at the end of the book.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxvi" aria-label="xxvi"/>&#13;
<h2 class="H1" id="sec1"><span id="h1-1"/><span class="SANS_Futura_Std_Bold_B_11">Who Should Read This Book?</span></h2>&#13;
<p class="TNI1">This book is geared toward three groups of readers. The first and main group is JavaScript frontend (web) and backend (Node.js) developers, as it explores how we can apply data structures and algorithms to solve and optimize complex problems.</p>&#13;
<p class="TX">The second group of readers is computer science (CS) students, as the book covers topics that appear in most CS courses. These students should be familiar with several programming languages, so the JavaScript focus shouldn’t be a hindrance. The algorithms don’t heavily depend on aspects of the language and can be translated into other languages with little difficulty.</p>&#13;
<p class="TX">Finally, the third group of readers includes programmers who are preparing for coding interviews or are interested in competitive programming. These readers will profit from actual implementation of algorithms and data structures and from seeing examples of the kinds of questions they’ll encounter.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h2 class="H1" id="sec2"><span id="h1-2"/><span class="SANS_Futura_Std_Bold_B_11">What’s the Book’s Approach?</span></h2>&#13;
<p class="TNI1">The book always takes a practical approach to real-life use cases. It considers common problems and discusses appropriate algorithms and data structures. We’ll explore multiple versions and optimizations and develop several implementation variants to provide a deeper understanding of alternative possible solutions.</p>&#13;
<p class="TX">All of the algorithms are programmed using JavaScript, as it’s a widely available language that could be applied for both frontend and backend work. JavaScript is also well known and commonly used today, and it should be applicable to all kinds of problems.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h2 class="H1" id="sec3"><span id="h1-3"/><span class="SANS_Futura_Std_Bold_B_11">What’s in the Book?</span></h2>&#13;
<p class="TNI1">The book is structured in three parts. <span class="Xref"><a href="part1.xhtml">Part I</a></span> covers the basics and highlights important aspects of JavaScript that are used throughout the rest of the book. We’ll explore functional programming to understand some design considerations that are applied in later chapters. We’ll also consider abstract data types (ADTs), which is a concept that involves data structures and algorithms. Finally, we’ll study the topic of performance as it relates to algorithms, which will be applied often in the rest of the book. The following chapters are in <span class="Xref"><a href="part1.xhtml">Part I</a></span>:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><b><a href="chapter1.xhtml">Chapter 1</a>: Using JavaScript </b>In this chapter we’ll cover important features of JavaScript that are used in the rest of the book, but we’ll just consider the highlights, as it is assumed you are already familiar with the language. Topics will include the current JavaScript version, transpilation, typing, arrow functions, spreading, destructuring, modules, and more. I’ll also introduce some of the many tools that are available to help you develop JavaScript code.</p>&#13;
<p class="RunInPara"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxvii" aria-label="xxvii"/><b><a href="chapter2.xhtml">Chapter 2</a>: Functional Programming in JavaScript </b>Here we’ll consider functional programming to highlight some design features that are used in the rest of the book. Topics will include what functional programming is, why you should use it, whether JavaScript is a functional programming language, the declarative programming style, side effects, and higher-order functions, among others.</p>&#13;
<p class="RunInPara"><b><a href="chapter3.xhtml">Chapter 3</a>: Abstract Data Types </b>In this chapter I’ll introduce the concept of abstract data types as a basis for considering data structures and their associated operations. In later chapters, all structures will be considered as ADTs to highlight their pros and cons as well as their performance. The key topics will include what ADTs are and how to implement them in JavaScript.</p>&#13;
<p class="RunInPara"><b><a href="chapter4.xhtml">Chapter 4</a>: Analyzing Algorithms </b>Here we’ll consider the performance aspects of algorithms in terms of both space and speed. We’ll discuss the concept of complexity classes and how (and when) it applies to the design of algorithms and data structures. The topics we’ll explore include what an algorithm’s performance is; the big <i>O</i> notation; complexity classes; the differences among best, average, worst, and amortized cases; how to measure performance; and time versus space trade-offs.</p>&#13;
</div>&#13;
<p class="TX"><span class="Xref"><a href="part2.xhtml">Part II</a></span> of the book focuses on algorithms, and it’s concerned with strategies for algorithm design. In particular, we’ll consider searching, sorting, shuffling, and sampling—all of which have well-known algorithms. The chapters in this part are as follows:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><b><a href="chapter5.xhtml">Chapter 5</a>: Designing Algorithms </b>In this chapter we’ll consider strategies for the design of algorithms and look at examples of each case. We’ll discuss general practices, recursion, brute-force search, greedy algorithms, divide-and-conquer algorithms, backtracking, dynamic programming, branch-and-bound, transform-and-conquer, and problem reduction.</p>&#13;
<p class="RunInPara"><b><a href="chapter6.xhtml">Chapter 6</a>: Sorting </b>Here we’ll discuss several common and important sorting algorithms to produce an ordered sequence of data out of unordered data. Some algorithms (such as heapsort) will receive only a brief mention, because they will be further analyzed in later chapters where the corresponding data structure is described. Topics include a description of the sorting problem, internal versus external sorting, JavaScript’s own sort function, comparison-based algorithms (such as bubblesort, selection sort, insertion sort, quicksort, and mergesort, among others), and comparison-less sorting algorithms (like bitmap sort, counting sort, and radix sort).</p>&#13;
<p class="RunInPara"><b><a href="chapter7.xhtml">Chapter 7</a>: Selecting </b>This chapter will show algorithms for just finding the <i>k</i>th smallest value in a list or array, as opposed to sorting where we wanted to order the complete set. We’ll discuss the selection problem in general, using JavaScript’s minimum and maximum functions; doing selection by sorting (or partial sorting); and several other algorithms like quickselect, Floyd-Rivest, median of medians, and sorting by selection.</p>&#13;
<p class="RunInPara"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxviii" aria-label="xxviii"/><b><a href="chapter8.xhtml">Chapter 8</a>: Shuffling and Sampling </b>This chapter can be considered a complement to <span class="runinpara_Xref"><a href="chapter6.xhtml">Chapter 6</a></span>. In this case we want to produce a random disordered sequence of data, instead of a totally ordered one, as might be needed for a computer card game or statistical sampling. We’ll look at the shuffling problem, how to do random sorting, the Fisher-Yates algorithm, random key sorting, and random sampling algorithms.</p>&#13;
<p class="RunInPara"><b><a href="chapter9.xhtml">Chapter 9</a>: Searching </b>Here we’ll consider several common searching algorithms meant to quickly answer whether a specific value is or isn’t included in some set of data. Some algorithms will just be introduced here, but we’ll explore them more thoroughly in later chapters where the corresponding data structures are described and analyzed. Topics in this chapter include a description of the searching problem, JavaScript’s own search functions, linear searching (with or without sentinels), jump searching, binary searching, and interpolation searching.</p>&#13;
</div>&#13;
<p class="TX"><span class="Xref"><a href="part3.xhtml">Part III</a></span> of the book is devoted to data structures, and it considers several data structure types, starting with simple, linear ones and finishing with more complex nonlinear structures. The following chapters are included in this part:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><b><a href="chapter10.xhtml">Chapter 10</a>: Lists </b>This chapter discusses the simplest structure, a linked list, which also includes several variants. We’ll delve into lists in detail (what they are; their various types; their ADT; single-, double-, and circular-linked lists), stacks (what they are and several implementations), queues (what queues are and what they’re used for, their ADT, and many implementations), and deques (their objective, ADT, and implementation).</p>&#13;
<p class="RunInPara"><b><a href="chapter11.xhtml">Chapter 11</a>: Bags, Sets, and Maps </b>Here we’ll discuss structures that let you represent sets (no repeated elements) and bags (repeated elements allowed), with maps (key/value pairs) as a special important case. We’ll see what bags and sets are and their implementation (including JavaScript’s own versions as well as array- and list-based versions), finishing with hashing and bitmaps.</p>&#13;
<p class="RunInPara"><b><a href="chapter12.xhtml">Chapter 12</a>: Binary Trees </b>This chapter considers binary trees, and in particular binary search trees (BSTs), which are the basis for many algorithms. We’ll discuss what a tree is, tree traversal (pre-, in-, and postorder algorithms), and using binary search trees for searching (including splay trees, balanced search trees like AVL and red-black trees, and randomized binary search trees).</p>&#13;
<p class="RunInPara"><b><a href="chapter13.xhtml">Chapter 13</a>: Trees and Forests </b>Here we’ll study more general variants of trees, including forests (sets of trees). Topics include what trees and forests are, how to represent them in several ways, traversal algorithms (breadth- and depth-first algorithms), B-trees and variants that are oriented for searching, and red-black trees as a variant of BSTs.</p>&#13;
<p class="RunInPara"><b><a href="chapter14.xhtml">Chapter 14</a>: Heaps </b>In this chapter we’ll consider heaps, a variant of binary trees that are stored without the need for dynamic memory and allow easy implementation of priority queues and sorting. We’ll discuss <span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxix" aria-label="xxix"/>what heaps are, binary heaps and variants (ternary or d-ary heaps), heapsort (a heap-based sorting algorithm), heap-based sampling algorithms, and treaps, a heap-related BST.</p>&#13;
<p class="RunInPara"><b><a href="chapter15.xhtml">Chapter 15</a>: Extended Heaps </b>This chapter expands on the concept of heaps, considering variants that allow extra operations such as changing (altering the value of a key) and melding or merging (joining two or more heaps into one). Topics include binomial heaps, lazy binomial heaps, Fibonacci heaps, and pairing heaps.</p>&#13;
<p class="RunInPara"><b><a href="chapter16.xhtml">Chapter 16</a>: Digital Search Trees </b>Here we’ll consider trees specially designed to search for strings, as in a common “dictionary” where we’d look up words. We’ll include tries, radix tries, ternary tries, and other variants of these structures.</p>&#13;
<p class="RunInPara"><b><a href="chapter17.xhtml">Chapter 17</a>: Graphs </b>In this chapter we’ll consider graphs, which are currently used in many applications, such as Google Maps or for calculating dependencies in a software project. Topics include what graphs are, different ways of representing them (such as adjacency lists or adjacency matrices), graph traversals and path finding (including shortest-path algorithms), and topological sorting.</p>&#13;
<p class="RunInPara"><b><a href="chapter18.xhtml">Chapter 18</a>: Immutability and Functional Data Structures </b>This final chapter will discuss the immutability aspect and explore how algorithms can be altered to avoid modifying the input structures, producing a new one instead. We’ll see what functional data structures are, what immutability means, object freezing, algorithms needed to avoid modifying data structures, and some examples of specific functional data structures such as lists, queues, and trees.</p>&#13;
</div>&#13;
<p class="TX">The book finishes with the answers to the questions found at the end of each chapter; sometimes answers are given in full, and other times hints or links to solutions are provided.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>All of the source code for this book is available at</i> <a href="https://github.com/fkereki/data-structures-and-algorithms-book">https://github.com/fkereki/data-structures-and-algorithms-book</a>.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>