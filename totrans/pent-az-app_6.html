<html><head></head><body>
<h2 class="h2b" id="ch07"><span epub:type="pagebreak" id="page_139" class="calibre1"/><strong class="calibre2"><span class="big">7</span></strong><br class="calibre9"/><strong class="calibre2">OTHER AZURE SERVICES</strong></h2>
<div class="image"><img src="../images/00015.jpeg" alt="image" class="calibre3"/></div>
<p class="noindent">There was a time when software release schedules were roughly aligned with the Olympics—a new version of your favorite operating system, productivity suite, or game would be released once every couple of years. Although there may have been some interim updates and service packs to fix bugs, users eager for new features had to count the months until they could stand in line to buy a cardboard box filled with disks or a CD. But the world has moved on from this paradigm, with radically shortened release schedules, new distribution methods, and even different ways for companies to monetize their products.</p>
<p class="indent">This new model is very apparent in Azure, with new service offerings coming online all the time. In the earlier chapters, I focused on the core services any enterprise that adopts Azure is likely to use. In this chapter, we explore some of the newer, lesser-used, or more unique Azure services, and examine the ones that are interesting from a security perspective.</p>
<p class="indent">We start by looking at Key Vault, a mechanism for the secure storage and retrieval of credentials such as passwords and certificates in the <span epub:type="pagebreak" id="page_140"/>cloud. Then, we discuss some notable aspects of Web Apps, the feature of Azure App Services for publishing websites. Finally, we close with Azure Automation, a service to automate management tasks both in the cloud and on the corporate network.</p>
<h3 class="h1" id="lev161"><strong class="calibre2">Best Practices: Key Vault</strong></h3>
<p class="noindent">When storing secrets in Key Vault, you can do several things to add an extra layer of security, such as tightly controlling access, pre-encrypting secrets, and using logging. Each of these makes an already-strong service considerably harder to attack.</p>
<p class="indent">First, any secret vaulting solution is only as secure as the user with the weakest security practices. For this reason, it is crucial to limit the number of people who can access the Key Vault. With role-based access control (RBAC), very specific, granular permissions can be granted to the Key Vault and its contents. However, even a very tight set of permissions to the Key Vault doesn’t help much if the vault resides in a subscription with dozens of users with owner permissions who don’t need access to the vault. After all, any of these users could leverage their subscription permissions to grant themselves access to the Key Vault. To prevent this, I encourage you to consider creating a separate subscription just for your Key Vault if it is going to hold particularly sensitive secrets. More details about Key Vault hardening are available at <em class="calibre7"><a href="https://docs.microsoft.com/en-us/azure/key-vault/key-vault-secure-your-key-vault/" class="calibre6">https://docs.microsoft.com/en-us/azure/key-vault/key-vault-secure-your-key-vault/</a></em>.</p>
<p class="indent">If you are using Key Vault to store secrets that won’t be used directly by another cloud service, it might be worth considering pre-encrypting secrets before putting them in Key Vault. Key Vault, of course, stores all of its data in an encrypted format; however, if an attacker compromises an account that is used to retrieve the secrets, they can retrieve the decrypted secrets. If you encrypt the secrets locally before uploading them (and store the decryption keys somewhere offline), an attacker who obtains an account with access to your vault will only be able to pull the encrypted values and won’t have the cleartext secret.</p>
<p class="indent">As with other services, logging is important for Key Vault too. When enabled, the logs contain information such as key enumeration, creation, reads, writes, and deletions. This includes details useful for identifying illegitimate access, such as the caller’s IP address and the account making the request. More details about Key Vault’s audit logs can be found at <em class="calibre7"><a href="https://docs.microsoft.com/en-us/azure/key-vault/key-vault-logging/" class="calibre6">https://docs.microsoft.com/en-us/azure/key-vault/key-vault-logging/</a></em>.</p>
<h3 class="h1" id="lev162"><strong class="calibre2">Examining Azure Key Vault</strong></h3>
<p class="noindent">Azure Key Vault is a service that allows a developer to securely store passwords, connection strings, storage keys, certificates, and so on, for use in other Azure services. As a penetration tester, I love Key Vault because I can use it as a recommendation to resolve many common pentest findings. And, if a user misconfigures a Key Vault instance, it can be another source of credentials to further my access into the target environment.</p>
<p class="indent"><span epub:type="pagebreak" id="page_141"/>It’s no exaggeration to say that I include Key Vault as a potential solution to findings in most of my reports. In “<a href="part0011.html#lev20" class="calibre6">Obtaining Credentials</a>” on <a href="part0011.html#page_15" class="calibre6">page 15</a>, I demonstrated how easy it can be to discover passwords and other secrets in source code repositories, errant configuration files, and even on developer workstations. Key Vault provides an API—with libraries and sample code for most major programming languages—that makes it easy for a developer to keep this sensitive information in a secured, access-controlled, auditable location. Although Key Vault doesn’t prevent every developer mistake, it’s excellent for cleaning up secret hygiene issues.</p>
<p class="indent">Three different types of storage are available in Key Vault: secrets, keys, and certificates. Each of these presents a different opportunity for a pentester, as detailed in the following sections.</p>
<h4 class="h2" id="lev163"><strong class="calibre2"><em class="calibre10">Displaying Secrets</em></strong></h4>
<p class="noindent">A secret is a key-value pair consisting of a name and a text value; the text value can be up to 25KB in size and supports version history. You can view the secret’s text value within the portal, using APIs, or in PowerShell—assuming your account has the correct permissions. Because secrets can be retrieved, Microsoft’s documentation recommends pre-encrypting secrets with a public key before saving them in Azure if they are particularly sensitive. The private key to decrypt the secret would be placed in Key Vault’s HSM storage, protecting the private key, and therefore the secret, from unauthorized access.</p>
<p class="indent">If you obtain an account you suspect might have access to Key Vault instances and their secrets, use PowerShell to enumerate them all at once. To do this, run the script shown in <a href="part0016.html#ch07list1" class="calibre6">Listing 7-1</a>.</p>
<p class="programs">PS C:\&gt; <span class="ent">➊</span> <span class="codestrong1">$keyvaults = Get-AzureRmKeyVault</span><br class="calibre5"/>PS C:\&gt; <span class="codestrong1">foreach ($keyvault in $keyvaults)</span><br class="calibre5"/>&gt;&gt; <span class="codestrong1">{</span><br class="calibre5"/>&gt;&gt;     <span class="codestrong1">$vault = $keyvault.VaultName</span><br class="calibre5"/>&gt;&gt;  <span class="ent">➋</span> <span class="codestrong1">$secrets = Get-AzureKeyVaultSecret</span> <span class="codestrong1">–VaultName $vault</span><br class="calibre5"/>&gt;&gt;     <span class="codestrong1">foreach ($secret in $secrets)</span><br class="calibre5"/>&gt;&gt;     <span class="codestrong1">{</span><br class="calibre5"/>&gt;&gt;         <span class="codestrong1">$value = Get-AzureKeyVaultSecret –VaultName $vault -Name $secret.Name</span><br class="calibre5"/>&gt;&gt;      <span class="ent">➌</span> <span class="codestrong1">Write-Output "$vault`: $($secret.Name) = $($value.SecretValueText)"</span><br class="calibre5"/>&gt;&gt;     <span class="codestrong1">}</span><br class="calibre5"/>&gt;&gt; <span class="codestrong1">}</span><br class="calibre5"/><br class="calibre5"/>shhh: BackendDbConStr = Server=mydb;Database=prod;User ID=admin;Password=1234<br class="calibre5"/>shhh: password = MyB@dPassw0rd</p>
<p class="listing" id="ch07list1"><em class="calibre7">Listing 7-1: Displaying Key Vault secrets</em></p>
<p class="indent">The script begins by getting a list of Key Vault instances in the subscription <span class="ent">➊</span>. Then, in each instance it retrieves a list of all secrets <span class="ent">➋</span>. Finally, for each secret, it outputs the secret in the format <span class="codeitalic1">Vault Name</span><span class="literal">:</span> <span class="codeitalic1">Secret Name</span> <span class="literal">=</span> <span class="codeitalic1">Secret Value</span> <span class="ent">➌</span>.</p>
<h4 class="h2" id="lev164"><span epub:type="pagebreak" id="page_142" class="calibre1"/><strong class="calibre2"><em class="calibre10">Displaying Keys</em></strong></h4>
<p class="noindent">Key storage allows users to generate or upload RSA asymmetric keys to Key Vault. Within the vault, the keys can be used to perform cryptographic operations, such as sign, verify, encrypt, and decrypt using Azure’s APIs. Once the keys are uploaded, Azure doesn’t allow users to export them, except in an encrypted backup form that can only be used to restore the keys back into Azure.</p>
<p class="indent">Because no one can export keys, the key storage section of Key Vault is somewhat less exciting to a pentester than the secret storage. However, if you have access to an account that has permission to call cryptographic APIs for keys, you might still be able to leverage them. But before you can leverage these keys, you’ll need to know how each one is used.</p>
<p class="indent">Azure requires each key to have a name, which may hint at its purpose. It also allows users to associate up to 15 <em class="calibre7">tags</em> (or 256-character name-value pairs) with each key. An organization chooses how to use these tags, and the tags may give you additional information about a key’s purpose. <a href="part0016.html#ch07list2" class="calibre6">Listing 7-2</a> shows how to display details about every key in every vault within a subscription using PowerShell.</p>
<p class="programs">   PS C:\&gt; <span class="codestrong1">$keyvaults = Get-AzureRmKeyVault</span><br class="calibre5"/>   PS C:\&gt; <span class="codestrong1">foreach($keyvault in $keyvaults)</span><br class="calibre5"/>   &gt;&gt; <span class="codestrong1">{</span><br class="calibre5"/>   &gt;&gt;     <span class="codestrong1">$vault = $keyvault.VaultName</span><br class="calibre5"/>   &gt;&gt;  <span class="ent">➊</span> <span class="codestrong1">$keys = Get-AzureKeyVaultKey</span> <span class="codestrong1">–VaultName $vault</span><br class="calibre5"/>   &gt;&gt;     <span class="codestrong1">foreach ($key in $keys)</span><br class="calibre5"/>   &gt;&gt;     <span class="codestrong1">{</span><br class="calibre5"/>   &gt;&gt;         <span class="codestrong1">Write-Output $key</span><br class="calibre5"/>   &gt;&gt;      <span class="ent">➋</span> <span class="codestrong1">Get-AzureKeyVaultKey –VaultName $vault -KeyName $key.Name</span><br class="calibre5"/>   &gt;&gt;     <span class="codestrong1">}</span><br class="calibre5"/>   &gt;&gt; <span class="codestrong1">}</span><br class="calibre5"/><br class="calibre5"/><span class="ent">➌</span> Vault Name     : shhh<br class="calibre5"/><span class="ent">➍</span> Name           : key1<br class="calibre5"/>   Version        :<br class="calibre5"/>   Id             : https://shhh.vault.azure.net:443/keys/key1<br class="calibre5"/>   Enabled        : True<br class="calibre5"/><span class="ent">➎</span> Expires        :<br class="calibre5"/>   Not Before     :<br class="calibre5"/>   Created        : 8/12/2018 4:54:07 AM<br class="calibre5"/>   Updated        : 8/13/2018 6:09:15 AM<br class="calibre5"/>   Purge Disabled : False<br class="calibre5"/><span class="ent">➏</span> Tags           : Name       Value<br class="calibre5"/>                    CreatedBy  Matt<br class="calibre5"/><br class="calibre5"/>   Attributes : Microsoft.Azure.Commands.KeyVault.Models.KeyAttributes<br class="calibre5"/>   Key        : {"kid":"https://shhh.vault.azure.net/keys/key1/<span class="codeitalic">Version</span>",<br class="calibre5"/>                 "kty":"RSA",<span class="ent">➐</span>"key_ops":["sign","verify","wrapKey",<br class="calibre5"/>                       "unwrapKey","encrypt","decrypt"],"n":"4vaUgZCV3OG...",<br class="calibre5"/>                       "e":"AQAB"}<br class="calibre5"/>   VaultName  : shhh<br class="calibre5"/>   Name       : key1<br class="calibre5"/><span epub:type="pagebreak" id="page_143"/>   Version    : ed2ebbdc51754d45b69bd6551d2d2052<br class="calibre5"/>   Id         : https://shhh.vault.azure.net:443/keys/key1/<span class="codeitalic">Version</span></p>
<p class="listing" id="ch07list2"><em class="calibre7">Listing 7-2: Displaying Key Vault key information</em></p>
<p class="indent">Like the secrets retrieval script, the key script starts by iterating over Key Vault instances. Within each instance, a list of keys is retrieved <span class="ent">➊</span> and then the details of each key are printed <span class="ent">➋</span>. The output includes the name of the vault instance <span class="ent">➌</span>, the key name <span class="ent">➍</span>, the key validity period <span class="ent">➎</span>, the tags <span class="ent">➏</span>, and what operations the key can be used to perform <span class="ent">➐</span>.</p>
<p class="indent">Once you’ve determined the key’s purpose, you could potentially use it for the same purpose. For example, if a key is used to sign documents for proof of authenticity, you could generate a forgery. Or, if it’s used for encrypting files, you could decrypt those files. There isn’t an easy way to do this in PowerShell, but Microsoft does offer the <span class="literal">KeyVaultClient</span> class in the <span class="literal">KeyVault</span> library, which supports these operations and is available for .NET and Java. You can find sample code at <em class="calibre7"><a href="https://www.microsoft.com/en-us/download/details.aspx?id=45343" class="calibre6">https://www.microsoft.com/en-us/download/details.aspx?id=45343</a></em>.</p>
<h4 class="h2" id="lev165"><strong class="calibre2"><em class="calibre10">Displaying Certificates</em></strong></h4>
<p class="noindent">Certificate storage is a special category under the “secrets” category of Key Vault. Users can upload PFX files or have Key Vault generate self-signed certificates or certificate requests. They can then use these certificates, for example, to secure the communications between users and a custom Azure application. The key and certificate features of Key Vault both deal with asymmetric cryptography, but their intended purpose is slightly different. Keys are used to submit cryptographic operations and have the operations performed using a private key within secure storage. Certificates can be used within different applications, such as website certificates that are used not only for encryption but also to confirm the name of the site (and other attributes and intended usage), and thus are usable even outside of Azure.</p>
<p class="indent">Key Vault will respect the export flags of certificates added to it. Therefore, if a user imports a certificate marked non-exportable, an attacker won’t be able to recover it. But if a key is marked exportable, it can be retrieved just like other Key Vault secrets. In fact, if a user doesn’t specify an export policy when creating a certificate in Key Vault, it defaults to exportable. <a href="part0016.html#ch07list3" class="calibre6">Listing 7-3</a> walks through listing certificates in Key Vault, viewing their details, and obtaining public keys, and, if accessible, private keys.</p>
<p class="programs">PS C:\temp&gt; <span class="codestrong1">$keyvaults = Get-AzureRmKeyVault</span><br class="calibre5"/>PS C:\temp&gt; <span class="codestrong1">foreach ($keyvault in $keyvaults)</span><br class="calibre5"/>&gt;&gt; <span class="codestrong1">{</span><br class="calibre5"/>&gt;&gt;     <span class="codestrong1">$vault = $keyvault.VaultName</span><br class="calibre5"/>&gt;&gt;     <span class="codestrong1">$certs = Get-AzureKeyVaultCertificate</span> <span class="codestrong1">–VaultName $vault</span><br class="calibre5"/>&gt;&gt;     <span class="codestrong1">foreach ($cert in $certs)</span><br class="calibre5"/>&gt;&gt;     <span class="codestrong1">{</span><br class="calibre5"/>&gt;&gt;         <span class="codestrong1">$cn = $cert.Name</span><br class="calibre5"/>&gt;&gt;      <span class="ent">➊</span>  <span class="codestrong1">$c = Get-AzureKeyVaultCertificate –VaultName $vault -Name $cn</span><br class="calibre5"/>&gt;&gt;         <span class="codestrong1">$x509 = $c.Certificate</span><br class="calibre5"/><span epub:type="pagebreak" id="page_144"/>&gt;&gt;         <span class="codestrong1">Write-Output $c</span><br class="calibre5"/>&gt;&gt;      <span class="ent">➋</span><span class="codestrong1">  </span><span class="codestrong1">$privkey = (Get-AzureKeyVaultSecret</span> <span class="codestrong1">-VaultName $vault</span> <br class="calibre5"/><span class="codestrong1">                   -Name $cn).SecretValueText</span><br class="calibre5"/>&gt;&gt;         <span class="codestrong1">Write-Output "Private Key:"</span><br class="calibre5"/>&gt;&gt;         <span class="codestrong1">Write-Output $privkey</span><br class="calibre5"/>&gt;&gt;         <span class="codestrong1">Write-Output ""</span><br class="calibre5"/>&gt;&gt;         <span class="codestrong1">Write-Output "Exporting Public Key to $cn.cer..."</span><br class="calibre5"/>&gt;&gt;      <span class="ent">➌</span>  <span class="codestrong1">Export-Certificate -Type CERT -Cert $x509 -FilePath "$cn.cer"</span><br class="calibre5"/>&gt;&gt;         <span class="codestrong1">Write-Output "Exporting Private Key to $cn.pfx..."</span><br class="calibre5"/>&gt;&gt;         <span class="codestrong1">$privbytes = [Convert]::FromBase64String($privkey)</span><br class="calibre5"/>&gt;&gt;      <span class="ent">➍</span>  <span class="codestrong1">[IO.File]::WriteAllBytes("$pwd\$cn.pfx", $privbytes)</span><br class="calibre5"/>&gt;&gt;         <span class="codestrong1">Write-Output "----------------------------------------------"</span><br class="calibre5"/>&gt;&gt;     <span class="codestrong1">}</span><br class="calibre5"/>&gt;&gt; <span class="codestrong1">}</span><br class="calibre5"/><br class="calibre5"/>Name        : devcertificate<br class="calibre5"/>Certificate : [Subject]<br class="calibre5"/>                CN=test.burrough.org<br class="calibre5"/>              [Issuer]<br class="calibre5"/>                CN=test.burrough.org<br class="calibre5"/>              [Serial Number]<br class="calibre5"/>                72AF4152C9F54651B9AE039730FB1AAD<br class="calibre5"/>              [Not Before]<br class="calibre5"/>                8/13/2018 11:06:23 PM<br class="calibre5"/>              [Not After]<br class="calibre5"/>                8/13/2019 11:16:23 PM<br class="calibre5"/>              [Thumbprint]<br class="calibre5"/>                9C5A0E244E353369560EFBE4EDB015D3FDE54635<br class="calibre5"/><br class="calibre5"/>Id          : https://shhh.vault.azure.net:443/certificates/devcertificate/<span class="codeitalic">Id</span><br class="calibre5"/>KeyId       : https://shhh.vault.azure.net:443/keys/devcertificate/<span class="codeitalic">Id</span><br class="calibre5"/>SecretId    : https://shhh.vault.azure.net:443/secrets/devcertificate/<span class="codeitalic">Id</span><br class="calibre5"/>Thumbprint  : 9C5A0E244E353369560EFBE4EDB015D3FDE54635<br class="calibre5"/>Tags        :<br class="calibre5"/>Enabled     : True<br class="calibre5"/>Created     : 8/14/2018 6:16:23 AM<br class="calibre5"/>Updated     : 8/14/2018 6:16:23 AM<br class="calibre5"/><br class="calibre5"/>Private Key:<br class="calibre5"/>MIIKTAIBAzCCCgwGCSqGSIb3DQEHAaCCCf0Eggn5MIIJ9TCCBhYGCSqGSIb3DQEHAaCCBgcEggYD<br class="calibre5"/>--<span class="codeitalic">snip</span>--<br class="calibre5"/>Exporting Public Key to devcertificate.cer...<br class="calibre5"/>LastWriteTime : 8/14/2018 9:23:48 PM<br class="calibre5"/>Length        : 834<br class="calibre5"/>Name          : devcertificate.cer<br class="calibre5"/><br class="calibre5"/>Exporting Private Key to devcertificate.pfx...<br class="calibre5"/>----------------------------------------------</p>
<p class="listing" id="ch07list3"><em class="calibre7">Listing 7-3: Displaying Key Vault certificates</em></p>
<p class="indent">This final Key Vault enumeration script begins as the others do—by iterating over Key Vault instances and then certificates. For each certificate, you need two calls to Azure in order to obtain the details. A call to <span epub:type="pagebreak" id="page_145"/><span class="literal">Get-AzureKeyVaultCertificate</span> retrieves public information about the certificate, including the subject, thumbprint, validity period, and public key <span class="ent">➊</span>. Then, a call to <span class="literal">Get-AzureKeyVaultSecret</span> obtains the private key part of the certificate, if it’s available <span class="ent">➋</span>. Next, the script exports the public key value to a certificate file (<em class="calibre7">Certificate Name.cer</em>) in the current working directory <span class="ent">➌</span>. Finally, a PFX file is created which contains the public key data, and the private key information if it was exportable <span class="ent">➍</span>.</p>
<div class="sidebar">
<p class="sidebart"><strong class="calibre4">DEFENDER’S TIP</strong></p>
<p class="spara">If you don’t intend to use a certificate outside of Key Vault, be sure to mark it as non-exportable. To do this, pass the <span class="literal1">-KeyNotExportable</span> switch to the <span class="literal1">New-AzureKeyVaultCertificatePolicy</span> cmdlet when creating the certificate. If you have a very sensitive certificate or key, take a look at Key Vault’s physical Hardware Security Module (HSM) option. Although this option is a bit more expensive than the software-based HSM version of Key Vault, the certificates are placed in an industry-standard cryptography device that’s designed to prevent private keys from being extracted once added to the device.</p>
</div>
<h4 class="h2" id="lev166"><strong class="calibre2"><em class="calibre10">Accessing Key Vault from Other Azure Services</em></strong></h4>
<p class="noindent">Users can configure Key Vault instances to allow access from virtual machines, Azure Resource Manager, and Azure Disk Encryption in the Advanced access policy settings in Azure portal, as shown in <a href="part0016.html#ch07fig1" class="calibre6">Figure 7-1</a>.</p>
<div class="image1"><a id="ch07fig1" class="calibre6"/><img src="../images/00051.jpeg" alt="image" class="calibre3"/></div>
<p class="figcap"><em class="calibre7">Figure 7-1: Advanced access policy for Azure Key Vault—enabling access from other services</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_146"/>Each of these settings has a purpose: virtual machines can store and access SSL certificates in Key Vault, Azure Resource Manager can create and deploy templates that need secrets (such as a local administrator password for a VM template), and Azure Disk Encryption uses Key Vault’s secret storage to keep its encryption keys for virtual hard disks (VHDs). These are all perfectly good uses for Key Vault, and are much better than checking these secrets into source control. However, it also means that a user who has permissions to administer a virtual machine or to modify and deploy templates may be able to gain access to Key Vault data they wouldn’t otherwise have rights to see.</p>
<div class="sidebar">
<p class="sidebart"><strong class="calibre4">DEFENDER’S TIP</strong></p>
<p class="spara">Because advanced access policies are set at the Key Vault instance level, all secrets within an instance are subject to the same policies. Therefore, it is a good idea to create multiple vaults and restrict access to each store to specific services. Each store should contain only those secrets that are intended to be used by <em class="calibre10">all</em> of the services that have access to the store.</p>
</div>
<h3 class="h1" id="lev167"><strong class="calibre2">Targeting Web Apps</strong></h3>
<p class="noindent">A subset of Azure App Services, Web Apps are websites designed to run on Azure PaaS (Platform as a Service). Developers can write Web Apps in a variety of languages—such as ASP.NET, PHP, JavaScript, Node.js, and Python—and run them within a Windows or Linux container. Identifying these sites is often easy because they have the URL <em class="calibre7">&lt;Site Name&gt;.azurewebsites.net</em> by default, but developers can give a Web App a custom domain name, if it’s deployed in a non-free service tier.</p>
<p class="indent">Web Apps are interesting targets for several reasons:</p>
<ul class="calibre8">
<li class="noindent1">They are public (internet) facing, so a defacement could cause reputational harm to a client.</li>
<li class="noindent1">They use deployment accounts that an attacker may find on developer workstations.</li>
<li class="noindent1">They are a popular Azure feature and used by many businesses.</li>
<li class="noindent1">Sites in the free tier are often developer test sites with minimal security planning, yet they may contain secrets for production sites.</li>
<li class="noindent1">Their code sometimes contains credentials to access other services, such as Azure SQL.</li>
</ul>
<p class="indent">For these reasons, a pentester should always include Web Apps in an Azure assessment.</p>
<h4 class="h2" id="lev168"><span epub:type="pagebreak" id="page_147" class="calibre1"/><strong class="calibre2"><em class="calibre10">Deployment Methods</em></strong></h4>
<p class="noindent">When a developer wants to publish their latest revision of a site to Azure, they must make two choices: what deployment method to use and what credentials they should use to authenticate. Web Apps support several different ways to load code into a site:</p>
<ul class="calibre8">
<li class="noindent1">FTP/FTPS</li>
<li class="noindent1">WebDeploy</li>
<li class="noindent1">Git Repository (local or on GitHub)</li>
<li class="noindent1">Deployment from an external service such as OneDrive, Dropbox, or Bitbucket</li>
</ul>
<p class="indent">It is good to be familiar with these methods; when you gain access to a developer workstation, it will help you identify which tools may have cached credentials or saved copies of source code available.</p>
<p class="indent">Web developers have traditionally used <em class="calibre7">File Transfer Protocol</em> (<em class="calibre7">FTP</em>) to push websites to servers, although it is not a good option because the user’s credentials and file contents are sent unencrypted. If you discover a developer using FTP, this should be a finding in and of itself!</p>
<p class="indent">Fortunately, Azure also supports <em class="calibre7">FTP Secure</em> (<em class="calibre7">FTPS</em>), which is encrypted and an acceptable choice. Anywhere you find a saved connection, look at the protocol before the server’s address to determine which type of connection is being used. Users connecting to FTP will have connections that begin with <em class="calibre7">ftp://</em> whereas secured connections will use <em class="calibre7">ftps://</em>.</p>
<p class="indent">Another common deployment method is WebDeploy, also called MSDeploy, which Visual Studio or the <em class="calibre7">msbuild.exe</em>/<em class="calibre7">msdeploy.exe</em> compiler tool pipeline can use to publish compiled projects. WebDeploy was first used not for publishing to Azure, but by developers deploying sites to Microsoft IIS web servers. Therefore, I’m not surprised that it seems to be commonly used for sites written in Microsoft’s ASP.NET language. WebDeploy is only available on Windows clients. You may also encounter users of a tool called <em class="calibre7">WAWSDeploy.exe</em>, which is a wrapper for WebDeploy that makes it easier to use.</p>
<p class="indent">For developers who use git to manage their source code, the ability to deploy straight from their git client is quite convenient. Given the growth in git’s popularity, I expect to see the number of developers using this method increase significantly. To use this method, the developer simply retrieves deployment credentials and a git repository URL from the Azure portal, and then uses git to push their site to the remote master branch. Developers don’t need any special utilities or libraries on their workstations.</p>
<p class="indent">Azure also supports an ever-growing list of external services that developers can use to stage content for Web Apps, such as Visual Studio Team Server, OneDrive, Bitbucket, and Dropbox. This feature is generically known as <em class="calibre7">cloud sync</em>, and it differs from the previous methods discussed. <span epub:type="pagebreak" id="page_148"/>All the other deployment methods are run on a developer’s system, use credentials obtained from Azure, and push the content into Azure; but cloud sync is a pull model. The developer authorizes Azure to access their online storage provider, and then Azure pulls the content into the Web App from a designated folder in the external service.</p>
<h4 class="h2" id="lev169"><strong class="calibre2"><em class="calibre10">Obtaining Deployment Credentials</em></strong></h4>
<p class="noindent">For every deployment method besides cloud sync, the Web App developer must provide a username and password when uploading files for their site. These deployment credentials are different from the user’s Azure portal login information—that account won’t work to deploy a site. Instead, the developer can choose to use either a user-specific deployment account or a site-specific account. Either account type will work for FTP, WebDeploy, and git deployments; the differences between the two credentials is who shares them and where they can be found.</p>
<h5 class="h3" id="lev170"><strong class="calibre2">User Deployment Credentials</strong></h5>
<p class="noindent">Each Azure user can create one deployment account to add, remove, or change files in any and every site they have permission to modify, across all subscriptions they can access. To create this account, or to reset its password, the user must do the following:</p>
<ol class="calibre16">
<li class="noindent1" value="1">Log in to the Azure portal and navigate to <strong class="calibre4">App Services</strong>.</li>
<li class="noindent1" value="2">Select any Web App in their subscription (or create a new one if none exists).</li>
<li class="noindent1" value="3">Click <strong class="calibre4">Deployment Credentials</strong>.</li>
<li class="noindent1" value="4">Specify a username and password.</li>
</ol>
<p class="indent">Once the account is created, the account holder can use it across any of their Web Apps, with only a slight variation between sites. To connect to each site, the user must enter the username in the format <em class="calibre7">&lt;Website Name&gt;\&lt;Username&gt;</em> and specify their password. For example, suppose the developer chose the username <em class="calibre7">webadmin</em> and specified <em class="calibre7">Awe5omeDev#</em> as their (relatively weak) password. To manage the website <em class="calibre7"><a href="http://azweb8426.azurewebsites.net/" class="calibre6">http://azweb8426.azurewebsites.net/</a></em>, the developer would enter <span class="literal">azweb8426\</span><span class="literal">webadmin</span> as the username in their chosen deployment tool and enter <span class="literal">Awe5omeDev#</span> as the password. If the developer later wanted to work on <em class="calibre7"><a href="http://bkunaenk.azurewebsites.net/" class="calibre6">http://bkunaenk.azurewebsites.net/</a></em>, they would enter <span class="literal">bkunaenk\webadmin</span> as the username and <span class="literal">Awe5omeDev#</span> as the password.</p>
<p class="indent">Because the same credentials are used broadly across all sites, an attacker who compromises it can modify any site this developer has access to—even unrelated sites that happen to be in the same subscription and have overly broad permissions. Consider a subscription with 50 administrators, where each administrator owns and manages one site, but none of <span epub:type="pagebreak" id="page_149"/>them has changed their site’s owner or contributor access permissions—so anyone with subscription access has permission to modify the site. A developer with just a personal blog might not put much effort into protecting their credentials, whereas another developer who runs the company’s home page may closely guard their password. In this scenario, the first developer’s credentials would be able to make changes to the latter’s site! This also applies to cases where a single developer owns multiple Web Apps, only some of which are important.</p>
<p class="indent">So, where can you find a user’s deployment credentials? This depends on the user, but in general, you might find them saved in FTP clients, password managers, or a git credential store file such as <em class="calibre7">.git-credentials</em> within the user’s home directory. But if the user is leveraging WebDeploy or FTP through Visual Studio, you’re probably out of luck. Visual Studio saves the user’s password in an encrypted blob within an XML file named <em class="calibre7">&lt;Website&gt;-&lt;Method&gt;.pubxml.user</em>, such as <em class="calibre7">bkunaenk-FTP.pubxml.user</em>. Additionally, this blob contains details about the workstation and user it’s associated with, so you won’t be able to use it in a different user’s session or on a different PC.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre7">You can reset the deployment account in the Azure portal without knowing the current password, so if you have portal access, you can always change the password to a different value. However, the user is likely to notice if their account suddenly stops working with the expected password. It should also be noted that the deployment account itself doesn’t grant access to the portal, only the ability to change Web App files.</em></p>
</div>
<h5 class="h3" id="lev171"><strong class="calibre2">App Deployment Credentials</strong></h5>
<p class="noindent">The other type of credentials for deployments is app specific. Each Web App gets a single deployment credential that is shared between all developers of that site, and they can use it in all the same places as a user deployment account: FTP, WebDeploy, and git.</p>
<p class="indent">This type of account presents a slightly lower risk than user deployment credentials, because if the credential is leaked, it can only be used to modify a single site. However, the credential is only as secure as the developer in possession of it with the worst security hygiene. Additionally, if an attacker compromises a credential that is accessible by multiple users, it may be hard to determine where the breach occurred. Finally, shared accounts are often not reset when an employee leaves, is fired, or changes roles, so a user’s access may persist longer than it should.</p>
<p class="indent">The Azure portal doesn’t display app deployment credentials. Instead, developers can obtain them by navigating to the Web App in the Azure portal and then clicking the <strong class="calibre4">Get publish profile</strong> button on the Overview tab, as shown in <a href="part0016.html#ch07fig2" class="calibre6">Figure 7-2</a>. If an administrator is concerned that an account is compromised, they can reset the credential using the <strong class="calibre4">Reset publish profile</strong> button on the same toolbar.</p>
<div class="image1"><span epub:type="pagebreak" id="page_150"/><a id="ch07fig2" class="calibre6"/><img src="../images/00052.jpeg" alt="image" class="calibre3"/></div>
<p class="figcap"><em class="calibre7">Figure 7-2: Obtaining a publish profile for a Web App</em></p>
<p class="indent">The <strong class="calibre4">Get publish profile</strong> button initiates a download of a file named <em class="calibre7">&lt;App Name&gt;.publishsettings</em>. You may recall Publish Settings files from <a href="part0011.html#ch02" class="calibre6">Chapter 2</a> (<a href="part0011.html#page_23" class="calibre6">page 23</a>), which are XML files that contain a management certificate for a subscription. These Publish Settings files are also XML documents, but in this case, they contain details about a Web App instead of a subscription. Each Web App’s Publish Settings file contains the following items:</p>
<ul class="calibre8">
<li class="noindent1">The Web App target URL</li>
<li class="noindent1">URLs to use for WebDeploy and FTP deployments</li>
<li class="noindent1">The app deployment username, which is always <em class="calibre7">&lt;App Name&gt;\&lt;App Name&gt;$</em></li>
<li class="noindent1">The app deployment password, which is a plaintext, 60-character, alphanumeric string</li>
</ul>
<p class="indent">The file may also have some optional data, such as connection strings for databases the app relies upon and the URL of the Azure portal.</p>
<p class="indent">Because the password for this account isn’t encrypted, another user can copy a Web App’s Publish Settings file and use it from a different computer. So, if you obtain access to a developer workstation or a code repository, search for these files because they’ll contain all the information needed to connect to the Web App server.</p>
<h4 class="h2" id="lev172"><strong class="calibre2"><em class="calibre10">Creating and Searching for Artifacts on Web App Servers</em></strong></h4>
<p class="noindent">Once you have access to an app server, there are a few things you might want to do. First, if you need to prove to your client that you gained access to the server, consider dropping a small text file with a <em class="calibre7">.config</em> extension stating you were there. This kind of flag is far better than making a publicly visible change, and because app servers don’t expose <em class="calibre7">.config</em> files to web browsers, users of the site won’t be able to see it; only administrators who log in to the server can.</p>
<p class="indent"><span epub:type="pagebreak" id="page_151"/>You can also use the server to try to capture credentials by modifying the Web App to covertly store logon information for you in a secure way. Alternatively, you could add a page to the site to use for phishing, which users would likely trust since it’s hosted on a legitimate site.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">WARNING</span></strong></p>
<p class="notep"><em class="calibre7">Always be sure that your rules of engagement allow for this kind of activity before modifying or adding pages on a public-facing site—especially if you’re adding code to exfiltrate user information or credentials. This is often off limits in penetration tests! If there’s even a little doubt, check with your client and attorney. As always, you should also make sure to record and account for any changes you make, in order to completely undo all changes at the end of your engagement.</em></p>
</div>
<p class="indent">My favorite thing to do when I compromise web servers is to look for secrets that aren’t exposed to the site’s users. For example, <em class="calibre7">.config</em>, <em class="calibre7">.asp</em>, <em class="calibre7">.aspx</em>, and <em class="calibre7">.php</em> files are usually not directly served to users if requested. Because .<em class="calibre7">config</em> files often contain secrets, they aren’t returned at all, whereas ASP and PHP files are rendered on the server first, with just the client-ready result returned. By accessing these files through FTP, you can view the original code with any embedded secrets intact. You can often then pivot further into database servers or other backend systems.</p>
<p class="indent">Aside from non-served files, app servers may contain files that are simply hard to find. For example, a developer may upload pages to the server but delay linking to them on other pages in the site until a specific time, such as when a new product is announced. And some developers might create pages intended for only those people who know how to find them, such as administrator logon forms. Discovering files like these might warrant a finding, if the information would harm the client when revealed or if the information is relying on “security through obscurity” for protection. Confidential data simply shouldn’t be accessible on a public-facing website, even if it isn’t easily discoverable.</p>
<h3 class="h1" id="lev173"><strong class="calibre2">Best Practices: Automation</strong></h3>
<p class="noindent">Azure Automation is a powerful tool for automating repetitive tasks both in the cloud and on-premises. However, its ability to perform a wide variety of tasks also makes it a security concern if used by a malicious actor. Here are some steps to help keep your Azure Automation jobs secure.</p>
<p class="indent">Begin by being cautious about what values, or <em class="calibre7">assets</em>, you place in Azure Automation’s variable storage. Automation gives users the ability to store things like credentials, which can then be used by jobs to access resources they need to do their work. Assets are stored encrypted, but since the running job needs to be able to use them, the decryption key is stored in a Key Vault that is accessible to Automation. This means that anyone who can create and run a job is able to retrieve the cleartext value of any asset, as described in “<a href="part0016.html#lev175" class="calibre6">Obtaining Automation Assets</a>” on <a href="part0016.html#page_152" class="calibre6">page 152</a>. If you’re storing <span epub:type="pagebreak" id="page_152"/>credentials as assets, be sure these credentials have the fewest rights possible to accomplish their task.</p>
<p class="indent">Next, if you plan to have Automation kick off tasks in your corporate environment, you’ll need to set up Hybrid Workers, which involves installing an agent onto on-premises systems, described in depth on <a href="part0016.html#page_157" class="calibre6">page 157</a>. By default, these agents will run jobs using the local system account on these servers, meaning the jobs will have full administrative access to the server where they’re run. Therefore, you should never configure a sensitive system as a Hybrid Worker. Although Hybrid Workers and the jobs they run will certainly need some level of access to resources to complete their tasks, make sure to create a good threat model and consider any risks that may come with this type of cloud-to-corporate access.</p>
<h3 class="h1" id="lev174"><strong class="calibre2">Leveraging Azure Automation</strong></h3>
<p class="noindent">One final service worth discussing is Azure Automation, which is essentially a sophisticated task scheduler for the cloud. Administrators create <em class="calibre7">runbooks</em>, or workflows of tasks, using PowerShell or a graphical editor in the Azure portal. A runbook can perform a wide variety of actions. For example, it might parse a log file every five minutes and then send an alert to an administrator if a critical error occurred. If a task is repetitive, uses cloud resources, and can be scripted in PowerShell, it’s a good candidate for automation.</p>
<p class="indent">Although Azure Automation is a complex service with many features, two components are of particular interest to a security professional: assets and Hybrid Workers. Automation assets are another location in Azure where users can keep secrets, similar to a Key Vault instance. Hybrid Workers allow a runbook to perform tasks using on-premises resources, not unlike some of the network bridging technologies in <a href="part0015.html#ch06" class="calibre6">Chapter 6</a>.</p>
<h4 class="h2" id="lev175"><strong class="calibre2"><em class="calibre10">Obtaining Automation Assets</em></strong></h4>
<p class="noindent">Anyone who has spent time working in system administration has likely written dozens, if not hundreds, of scripts to make their work more efficient and less tedious. Although such scripts vary considerably between authors, organizations, and target platforms, almost every script has variables and input data. Often, this includes the account that the script should use to perform its actions, a list of systems to target, and a location to log any output.</p>
<p class="indent">Azure Automation needs to allow such input so its runbooks can offer more than the most basic functionality. But unlike traditional scripts, runbooks are executed by Azure, not by a user from a command line. To address this gap, Azure Automation allows users to declare and save variables, credentials, connections, and certificates—generically referred to as <em class="calibre7">assets</em>—within <span epub:type="pagebreak" id="page_153"/>the Automation service. Runbooks can then reference those assets, but they aren’t runbook specific; they are shared between all runbooks within an Automation account. Although a subscription may have multiple Automation accounts, assets aren’t sharable across those accounts.</p>
<p class="indent">Let’s discuss each of the four asset classes, which are similar but have subtle differences:</p>
<p class="noindentt"><strong class="calibre4">Variables</strong></p>
<p class="indenta">When defining a variable, the developer provides a name, a data type, a value, and an optional description, and specifies if Automation should store the value encrypted. Variables can be any of the following types: Strings, Booleans, DateTimes, Integers, or Other (“Not Specified”). If the encrypted flag is set, the Azure portal won’t display the data type for that variable, and the value field will be displayed as asterisks. However, because runbooks need to be able to use the value, users can display variables, regardless of their encryption status, using the <span class="literal">Get-AutomationVariable</span> cmdlet within a runbook.</p>
<p class="noindentt"><strong class="calibre4">Connections</strong></p>
<p class="indenta">Connections are used to log in to Azure subscriptions within a runbook. Users can retrieve connections with the <span class="literal">Get-AutomationConnection</span> cmdlet, which returns a hash table with the values from the following keys inside: <span class="literal">SubscriptionId</span>, <span class="literal">ApplicationId</span>, <span class="literal">TenantId</span>, and <span class="literal">CertificateThumbprint</span>. Typically, these values are used in a subsequent call to <span class="literal">Add-AzureRMAccount</span> to connect to the desired subscription. Connection objects themselves don’t contain any secret data.</p>
<p class="noindentt"><strong class="calibre4">Credentials</strong></p>
<p class="indenta">In Azure Automation, credentials are stored in <span class="literal">PSCredential</span> objects and consist of an object name, a username, a password, and an optional description. Like encrypted variables, credentials are encrypted in Azure portal to protect their passwords. Even after using the <span class="literal">Get-AutomationPSCredential</span> cmdlet to retrieve the credential, Azure won’t display the value, because it expects developers to pass the entire returned <span class="literal">PSCredential</span> object to any system needing the account. However, users can display the password and username by calling the <span class="literal">GetNetworkCredential</span> function on the <span class="literal">PSCredential</span> object.</p>
<p class="noindentt"><strong class="calibre4">Certificates</strong></p>
<p class="indenta">Users can upload X.509 certificates in either <em class="calibre7">.cer</em> (public key only) or <em class="calibre7">.pfx</em> (public and private key) form to Azure Automation. When an Automation account is created, Azure provides an option to automatically populate the certificate store with two certificates that can be used to manage ASM and ARM resources: <span class="literal">AzureClassicRunAsCertificate</span> and <span class="literal">AzureRunAsCertificate</span>, respectively. If the user declines this option, Azure prompts them a second time to confirm, because these certificates are helpful for completing tasks in Azure. So, you should <span epub:type="pagebreak" id="page_154"/>expect to see these certificates in almost every Automation account you encounter. Although a user could upload certificates for any purpose, certificates in Automation are usually used in conjunction with connections to manage other Azure resources. You can retrieve certificates using the <span class="literal">Get-AutomationCertificate</span> cmdlet, which retrieves the certificate’s details, public key, and the private key, if present.</p>
<p class="indentt">Using the cmdlets and functions just discussed, you can create a runbook to collect asset values that may help further your infiltration into the client’s environment. Start by opening the Azure portal and selecting Azure Automation from the service list. In the Automation Accounts window, check for any existing Automation accounts, as shown in <a href="part0016.html#ch07fig3" class="calibre6">Figure 7-3</a>.</p>
<div class="image1"><a id="ch07fig3" class="calibre6"/><img src="../images/00053.jpeg" alt="image" class="calibre3"/></div>
<p class="figcap"><em class="calibre7">Figure 7-3: List of Azure Automation accounts</em></p>
<p class="indent">If none are listed, the target subscription isn’t using Automation and you can skip this section. If multiple accounts are listed, you’ll want to perform the steps in this section for each account. Click the name of an Automation account to open it. You should then see a view similar to <a href="part0016.html#ch07fig4" class="calibre6">Figure 7-4</a>.</p>
<p class="indent">Once a specific account is displayed, you can browse around to get an idea of how Automation is being used. Click <strong class="calibre4">Runbooks</strong> and review the names of the scripts. If any sound interesting, click them and then click <strong class="calibre4">Edit</strong> to view their source code—just be sure not to save any changes to them. You can also quickly browse the available assets by clicking the various tabs under the Shared Resources section in the menu on the left in <a href="part0016.html#ch07fig4" class="calibre6">Figure 7-4</a>, but Azure won’t display any secret values.</p>
<p class="indent">To display all of the assets, including passwords, encrypted variables, and certificate private keys, click <strong class="calibre4">Runbooks</strong> and then click <strong class="calibre4">Add a runbook</strong> at the top of the page. In the menu that appears, click <strong class="calibre4">Create a new runbook</strong> and then provide a name for the runbook and select <strong class="calibre4">PowerShell</strong> as the runbook type. Finally, click <strong class="calibre4">Create</strong>.</p>
<div class="image1"><span epub:type="pagebreak" id="page_155"/><a id="ch07fig4" class="calibre6"/><img src="../images/00054.jpeg" alt="image" class="calibre3"/></div>
<p class="figcap"><em class="calibre7">Figure 7-4: Main view of an Automation account</em></p>
<p class="indent">A blank runbook will appear. On the left side, a tree view provides a helpful list of available PowerShell cmdlets, other runbooks, and, most importantly, assets you can use. Expand the Assets object as well as each nested item, as shown in <a href="part0016.html#ch07fig5" class="calibre6">Figure 7-5</a>.</p>
<p class="indent">For every asset that sounds interesting, you can click the ellipsis menu next to the asset name and click <strong class="calibre4">Add to canvas</strong>. This will add a new line of code to the runbook that retrieves that asset. For variables and connections, this is sufficient to display the interesting parts of those elements. However, for credentials and certificates, you’ll need to add a few extra lines of code to get the passwords and private keys.</p>
<div class="image1"><a id="ch07fig5" class="calibre6"/><img src="../images/00055.jpeg" alt="image" class="calibre3"/></div>
<p class="figcap"><em class="calibre7">Figure 7-5: List of assets available for the runbook</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_156"/>For passwords, store the output of the <span class="literal">Get-AutomationPSCredential</span> credential in a variable and then use <span class="literal">GetNetworkCredential()</span> to get the username and password values, like so:</p>
<p class="programs">$cred = Get-AutomationPSCredential -Name '<span class="codeitalic">credential_name</span>'<br class="calibre5"/>$cred.GetNetworkCredential().username<br class="calibre5"/>$cred.GetNetworkCredential().password</p>
<p class="indent">When looking at a certificate, I like to display the certificate’s name and thumbprint, as well as its public and private keys as XML. This should be sufficient to import the certificate into a different system for use outside of Azure. To do this, put the following in the runbook:</p>
<p class="programs"><span class="ent">➊</span> $cert = Get-AutomationCertificate -Name '<span class="codeitalic">certificate_name</span>'<br class="calibre5"/><span class="ent">➋</span> $cert<br class="calibre5"/><span class="ent">➌</span> $cert.PrivateKey.ToXmlString($true)<br class="calibre5"/><span class="ent">➍</span> $cert.PublicKey.Key.ToXmlString($false)</p>
<p class="indent">This will save the certificate object into a variable <span class="ent">➊</span>, display its thumbprint and subject <span class="ent">➋</span>, and output its private key <span class="ent">➌</span> and public key <span class="ent">➍</span>. <a href="part0016.html#ch07fig6" class="calibre6">Figure 7-6</a> shows the completed runbook ready to execute.</p>
<div class="image1"><a id="ch07fig6" class="calibre6"/><img src="../images/00056.jpeg" alt="image" class="calibre3"/></div>
<p class="figcap"><em class="calibre7">Figure 7-6: Completed runbook to retrieve assets</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_157"/>Once you are satisfied with your runbook, click <strong class="calibre4">Save</strong> and then click <strong class="calibre4">Test pane</strong>. This will open a new view where you can click <strong class="calibre4">Start</strong> to execute the runbook. Once the runbook is finished, any output will be displayed in white, as shown in <a href="part0016.html#ch07fig7" class="calibre6">Figure 7-7</a>. If your runbook had any exceptions, error messages will be displayed in the output area in red.</p>
<div class="image1"><a id="ch07fig7" class="calibre6"/><img src="../images/00057.jpeg" alt="image" class="calibre3"/></div>
<p class="figcap"><em class="calibre7">Figure 7-7: Runbook Test pane with output</em></p>
<p class="indent">From the Test pane, you can see the completed runbook execution as well as the variable values, connection details, credential username and password, certificate details, and the public and private keys you requested. You can then use this information to pivot into subscriptions, services, or systems that may have been previously inaccessible.</p>
<h4 class="h2" id="lev176"><strong class="calibre2"><em class="calibre10">Hybrid Workers</em></strong></h4>
<p class="noindent">In addition to being able to automate tasks in the cloud, Azure Automation also has the ability to perform tasks on a corporate network. Azure provides a package that an administrator can install on several on-premises systems. These machines then become <em class="calibre7">Hybrid Workers</em> that receive commands from <span epub:type="pagebreak" id="page_158"/>Azure Automation and execute them on the corporate network. This is similar to the network bridging technologies discussed in <a href="part0015.html#ch06" class="calibre6">Chapter 6</a>; however, those services were designed for moving data between a company and the cloud, whereas Hybrid Workers are meant for sending management commands to corporate systems.</p>
<h5 class="h3" id="lev177"><strong class="calibre2">Hybrid Worker Mechanics</strong></h5>
<p class="noindent">Setting up a Hybrid Worker isn’t trivial. Administrators have to create an Operations Management Suite (OMS) account at <em class="calibre7"><a href="https://mms.microsoft.com/" class="calibre6">https://mms.microsoft.com/</a></em>, enable the Automation solution in the OMS portal, download and install a program called Microsoft Management Agent on the machines they want to be Hybrid Workers, and then run the <em class="calibre7">New-OnPremiseHybridWorker</em><em class="calibre7">.ps1</em> script on those systems—specifying which subscription and Automation account the worker should use. So, you aren’t likely to find a Hybrid Worker in every automation account—but those that do have one are likely making use of it. This is good news for a pentester because it means Hybrid Worker systems are often online and have access to interesting accounts and systems on their corporate networks.</p>
<p class="indent">Once installed, the Hybrid Worker operates by running the System Center Management Service host process, called <em class="calibre7">MonitoringHost.exe</em>, which polls an <em class="calibre7">azure-automation.net</em> server over HTTPS, looking for work. Once it finds a job, it spawns an instance of <em class="calibre7">Orchestrator.Sandbox.exe</em>, which then runs the runbook script. If needed, <em class="calibre7">Orchestrator.Sandbox.exe</em> may launch <em class="calibre7">conhost.exe</em> processes to run non-PowerShell commands. By default, all of these processes run as the <em class="calibre7">NT AUTHORITY\SYSTEM</em> account, which means that runbooks have administrative access to the system acting as a Hybrid Worker, but they don’t automatically have access to other systems on the domain. This is where <em class="calibre7">credential assets</em>—credentials stored within Azure automation for use within runbooks—come in; if a runbook needs to access a different system on the corporate domain—to copy files from a network share, for example—it needs to use an account with those privileges. Either the runbook developer can use the credential directly in the script with the <span class="literal">Get-AutomationPSCredential</span> cmdlet or they can set the Hybrid Worker to run all scripts in the context of a credential asset. Either way, the developer must store the credential in the Automation account.</p>
<h5 class="h3" id="lev178"><strong class="calibre2">Identifying Hybrid Workers</strong></h5>
<p class="noindent">Determining if an Automation account contains Hybrid Workers is easy: in the Azure portal, navigate to an Automation account instance and then click <strong class="calibre4">Hybrid worker groups</strong> in the account’s menu. There may be one or more worker groups listed; each group is a pool of one or more Hybrid Workers that can be assigned work. To see what machines are in a given group, click the group name. This will open the group, as shown in <a href="part0016.html#ch07fig8" class="calibre6">Figure 7-8</a>.</p>
<div class="image1"><span epub:type="pagebreak" id="page_159"/><a id="ch07fig8" class="calibre6"/><img src="../images/00058.jpeg" alt="image" class="calibre3"/></div>
<p class="figcap"><em class="calibre7">Figure 7-8: A Hybrid Worker group blade</em></p>
<p class="indent">From this pane, you can see the list of individual servers’ names in this group by clicking the <strong class="calibre4">Hybrid Workers</strong> tile. You can also see if the workers in this group are running as the default Local System account or using a credential asset by clicking <strong class="calibre4">Hybrid worker group settings</strong>, as shown in <a href="part0016.html#ch07fig9" class="calibre6">Figure 7-9</a>.</p>
<div class="image1"><a id="ch07fig9" class="calibre6"/><img src="../images/00059.jpeg" alt="image" class="calibre3"/></div>
<p class="figcap"><em class="calibre7">Figure 7-9: Hybrid worker group settings showing a custom credential being used</em></p>
<p class="indent">All Hybrid Workers in a given group run using the same credential.</p>
<h5 class="h3" id="lev179"><strong class="calibre2">Using Hybrid Workers</strong></h5>
<p class="noindent">When I find an Automation account with Hybrid Workers, I’m immediately curious what I can do with it. If you’re an outsider using Automation as your entry point into the network, you may not have any idea what the Hybrid Worker servers or the credential assets can access. A good way to get started is by reviewing any existing runbooks in the account. This way, you’ll learn how the subscription is using Automation, as well as at least a few systems <span epub:type="pagebreak" id="page_160"/>that can be used with the credential assets. To do this, select the <strong class="calibre4">Runbooks</strong> tab in the Automation account in Azure portal; then click any runbook and click the <strong class="calibre4">Edit</strong> button. This will show the source code.</p>
<p class="indent">In the Automation Account pane, you may also want to review the Activity Log and Schedules tabs. The Activity Log tab lets you review any jobs that have run recently, as well as see whether anyone has made any changes to runbooks, Hybrid Worker groups, or assets. The Schedules tab shows any upcoming runbook executions, which can be useful if you plan to modify an existing runbook and need to know which one will run next.</p>
<p class="indent">Once you have some knowledge of the Automation account, you might create or modify a runbook to get code running on a Hybrid Worker. To do this, follow the same steps for creating a runbook as we did in “<a href="part0016.html#lev175" class="calibre6">Obtaining Automation Assets</a>” on <a href="part0016.html#page_152" class="calibre6">page 152</a>. A good initial test runbook might look like this:</p>
<p class="programs">Write-Output "Hybrid Worker Computer Name: $env:COMPUTERNAME"<br class="calibre5"/>Write-Output "Worker running as: $(whoami)"<br class="calibre5"/>Write-Output $host</p>
<p class="indent">This runbook displays the assigned worker’s name, the account the script is running as, and some information about the host process.</p>
<p class="indent">Once the runbook is complete and you open the Test pane, you will see an option labeled <em class="calibre7">Run on</em>. Instead of Azure, select the <strong class="calibre4">Hybrid Worker</strong> button, and then from the <strong class="calibre4">Choose Hybrid Worker group</strong> drop-down list, select the group you want to execute the code. You can’t choose a specific worker for the runbook; Automation will assign the job based on its scheduler. Once you click <strong class="calibre4">Start</strong>, the job will be sent to a worker, and the results will be displayed in the Test pane—just as they were when the runbook ran on Azure, as shown in <a href="part0016.html#ch07fig10" class="calibre6">Figure 7-10</a>.</p>
<div class="image1"><a id="ch07fig10" class="calibre6"/><img src="../images/00060.jpeg" alt="image" class="calibre3"/></div>
<p class="figcap"><em class="calibre7">Figure 7-10: Completed runbook execution on a Hybrid Worker</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_161"/>At this point, you have a pretty ideal penetration testing setup. You have an externally accessible entry point into a private network, credentials for that network, and existing scripts to provide a starting point. From here, you can use your favorite PowerShell commands for post-exploitation to explore the network, pivot to other systems, collect loot, and more.</p>
<h3 class="h1" id="lev180"><strong class="calibre2">Summary</strong></h3>
<p class="noindent">In this chapter, we looked at three services that are unique to Azure: Key Vault, Web Apps, and Azure Automation. Each service offers both a challenge and an opportunity for information security professionals. Key Vault can solve many of the issues pentesters identify, but it can also have its own problems if misconfigured. Web Apps make development and deployment of new sites very easy, but with some risk of credential management problems. And while Azure Automation is a complicated service to learn, the most interesting components from a security perspective are similar to concepts you’ve seen used in other parts of Azure, such as Key Vault and Service Bus, with similar risks and threat models.</p>
<p class="indent">In the next chapter, we’ll switch gears and look at ways that Azure’s security monitoring features can detect and alert on illicit activities.<span epub:type="pagebreak" id="page_162"/></p>
</body></html>