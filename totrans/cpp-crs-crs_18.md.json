["```\nstd::basic_string<T, Traits=std::char_traits<T>, Alloc=std::allocator<T>>\n```", "```\n#include <string>\nTEST_CASE(\"std::string supports constructing\") {\n  SECTION(\"empty strings\") {\n    std::string cheese; ➊\n    REQUIRE(cheese.empty()); ➋\n  }\n  SECTION(\"repeated characters\") {\n    std::string roadside_assistance(3, 'A'); ➌\n    REQUIRE(roadside_assistance == \"AAA\"); ➍\n  }\n}\n```", "```\nTEST_CASE(\"std::string supports constructing substrings \") {\n  auto word = \"gobbledygook\"; ➊\n  REQUIRE(std::string(word) == \"gobbledygook\"); ➋\n  REQUIRE(std::string(word, 6) == \"gobble\"); ➌\n}\n```", "```\nTEST_CASE(\"std::string supports\") {\n  std::string word(\"catawampus\"); ➊\n  SECTION(\"copy constructing\") {\n    REQUIRE(std::string(word) == \"catawampus\"); ➋\n  }\n  SECTION(\"move constructing\") {\n    REQUIRE(std::string(move(word)) == \"catawampus\"); ➌\n  }\n  SECTION(\"constructing from substrings\") {\n    REQUIRE(std::string(word, 0, 3) == \"cat\"); ➍\n    REQUIRE(std::string(word, 4) == \"wampus\"); ➎\n  }\n}\n```", "```\nTEST_CASE(\"constructing a string with\") {\n  SECTION(\"std::string(char*) stops at embedded nulls\") {\n    std::string str(\"idioglossia\\0ellohay!\"); ➊\n    REQUIRE(str.length() == 11); ➋\n  }\n  SECTION(\"operator\\\"\\\"s incorporates embedded nulls\") {\n    using namespace std::string_literals; ➌\n    auto str_lit = \"idioglossia\\0ellohay!\"s; ➍\n    REQUIRE(str_lit.length() == 20); ➎\n  }\n}\n```", "```\nTEST_CASE(\"string's c_str method makes null-terminated strings\") {\n  std::string word(\"horripilation\"); ➊\n  auto as_cstr = word.c_str(); ➋\n  REQUIRE(as_cstr[0] ==  'h'); ➌\n  REQUIRE(as_cstr[1] ==  'o');\n  REQUIRE(as_cstr[11] == 'o');\n  REQUIRE(as_cstr[12] == 'n');\n  REQUIRE(as_cstr[13] == '\\0'); ➍\n}\n```", "```\n#include <string>\n#include <cstdio>\n\nint main() {\n  std::string word(\"pulchritudinous\");\n  printf(\"c_str: %s at 0x%p\\n\", word.c_str(), word.c_str()); ➊\n  printf(\"data:  %s at 0x%p\\n\", word.data(), word.data()); ➋\n}\n--------------------------------------------------------------------------\nc_str: pulchritudinous at 0x0000002FAE6FF8D0 ➊\ndata:  pulchritudinous at 0x0000002FAE6FF8D0 ➋\n```", "```\nTEST_CASE(\"std::string supports comparison with\") {\n  using namespace std::literals::string_literals; ➊\n  std::string word(\"allusion\"); ➋\n  SECTION(\"operator== and !=\") {\n    REQUIRE(word == \"allusion\"); ➌\n    REQUIRE(word == \"allusion\"s); ➍\n    REQUIRE(word != \"Allusion\"s); ➎\n    REQUIRE(word != \"illusion\"s); ➏\n    REQUIRE_FALSE(word == \"illusion\"s); ➐\n  }\n  SECTION(\"operator<\") {\n    REQUIRE(word < \"illusion\"); ➑\n    REQUIRE(word < \"illusion\"s); ➒\n    REQUIRE(word > \"Illusion\"s); ➓\n  }\n}\n```", "```\nTEST_CASE(\"std::string supports appending with\") {\n  std::string word(\"butt\"); ➊\n  SECTION(\"push_back\") {\n    word.push_back('e'); ➋\n    REQUIRE(word == \"butte\");\n  }\n  SECTION(\"operator+=\") {\n    word += \"erfinger\"; ➌\n REQUIRE(word == \"butterfinger\");\n  }\n  SECTION(\"append char\") {\n    word.append(1, 's'); ➍\n    REQUIRE(word == \"butts\");\n  }\n  SECTION(\"append char*\") {\n    word.append(\"stockings\", 5); ➎\n    REQUIRE(word == \"buttstock\");\n  }\n  SECTION(\"append (half-open range)\") {\n    std::string other(\"onomatopoeia\"); ➏\n    word.append(other.begin(), other.begin()+2); ➐\n    REQUIRE(word == \"button\");\n  }\n}\n```", "```\nTEST_CASE(\"std::string supports removal with\") {\n  std::string word(\"therein\"); ➊\n  SECTION(\"pop_back\") {\n    word.pop_back();\n    word.pop_back(); ➋\n    REQUIRE(word == \"there\");\n  }\n SECTION(\"clear\") {\n    word.clear(); ➌\n    REQUIRE(word.empty());\n  }\n  SECTION(\"erase using half-open range\") {\n    word.erase(word.begin(), word.begin()+3); ➍\n    REQUIRE(word == \"rein\");\n  }\n  SECTION(\"erase using an index and length\") {\n    word.erase(5, 2);\n    REQUIRE(word == \"there\"); ➎\n  }\n}\n```", "```\nTEST_CASE(\"std::string replace works with\") {\n  std::string word(\"substitution\"); ➊\n  SECTION(\"a range and a char*\") {\n    word.replace(word.begin()+9, word.end(), \"e\"); ➋\n    REQUIRE(word == \"substitute\");\n  }\n  SECTION(\"two ranges\") {\n    std::string other(\"innuendo\");\n    word.replace(word.begin(), word.begin()+3,\n                 other.begin(), other.begin()+2); ➌\n    REQUIRE(word == \"institution\");\n  }\n SECTION(\"an index/length and a string\") {\n    std::string other(\"vers\");\n    word.replace(3, 6, other); ➍\n    REQUIRE(word == \"subversion\");\n  }\n}\n```", "```\nTEST_CASE(\"std::string resize\") {\n  std::string word(\"shamp\"); ➊\n  SECTION(\"can remove elements\") {\n    word.resize(4); ➋\n    REQUIRE(word == \"sham\");\n  }\n  SECTION(\"can add elements\") {\n    word.resize(7, 'o'); ➌\n    REQUIRE(word == \"shampoo\");\n  }\n}\n```", "```\nTEST_CASE(\"std::string substr with\") {\n  std::string word(\"hobbits\"); ➊\n  SECTION(\"no arguments copies the string\") {\n REQUIRE(word.substr() == \"hobbits\"); ➋\n  }\n  SECTION(\"position takes the remainder\") {\n    REQUIRE(word.substr(3) == \"bits\"); ➌\n  }\n  SECTION(\"position/index takes a substring\") {\n    REQUIRE(word.substr(3, 3) == \"bit\"); ➍\n  }\n}\n```", "```\nTEST_CASE(\"std::string find\") {\n  using namespace std::literals::string_literals;\n  std::string word(\"pizzazz\"); ➊\n  SECTION(\"locates substrings from strings\") {\n    REQUIRE(word.find(\"zz\"s) == 2); // pi(z)zazz ➋\n  }\n  SECTION(\"accepts a position argument\") {\n    REQUIRE(word.find(\"zz\"s, 3) == 5); // pizza(z)z ➌\n  }\n SECTION(\"locates substrings from char*\") {\n    REQUIRE(word.find(\"zaz\") == 3); // piz(z)azz ➍\n  }\n  SECTION(\"returns npos when not found\") {\n    REQUIRE(word.find('x') == std::string::npos); ➎\n  }\n}\n```", "```\nTEST_CASE(\"std::string rfind\") {\n  using namespace std::literals::string_literals;\n  std::string word(\"pizzazz\"); ➊\n  SECTION(\"locates substrings from strings\") {\n    REQUIRE(word.rfind(\"zz\"s) == 5); // pizza(z)z ➋\n  }\n  SECTION(\"accepts a position argument\") {\n    REQUIRE(word.rfind(\"zz\"s, 3) == 2); // pi(z)zazz ➌\n  }\n  SECTION(\"locates substrings from char*\") {\n    REQUIRE(word.rfind(\"zaz\") == 3); // piz(z)azz ➍\n  }\n  SECTION(\"returns npos when not found\") {\n    REQUIRE(word.rfind('x') == std::string::npos); ➎\n  }\n}\n```", "```\nTEST_CASE(\"std::string find_first_of\") {\n  using namespace std::literals::string_literals;\n  std::string sentence(\"I am a Zizzer-Zazzer-Zuzz as you can plainly see.\"); ➊\n  SECTION(\"locates characters within another string\") {\n    REQUIRE(sentence.find_first_of(\"Zz\"s) == 7); // (Z)izzer ➋\n  }\n  SECTION(\"accepts a position argument\") {\n    REQUIRE(sentence.find_first_of(\"Zz\"s, 11) == 14); // (Z)azzer ➌\n  }\n  SECTION(\"returns npos when not found\") {\n    REQUIRE(sentence.find_first_of(\"Xx\"s) == std::string::npos); ➍\n  }\n}\n```", "```\nTEST_CASE(\"std::string\") {\n  using namespace std::literals::string_literals;\n  std::string sentence(\"I am a Zizzer-Zazzer-Zuzz as you can plainly see.\"); ➊\n  SECTION(\"find_last_of finds last element within another string\") {\n    REQUIRE(sentence.find_last_of(\"Zz\"s) == 24); // Zuz(z) ➋\n  }\n  SECTION(\"find_first_not_of finds first element not within another string\") {\n    REQUIRE(sentence.find_first_not_of(\" -IZaeimrz\"s) == 22); // Z(u)zz ➌\n  }\n  SECTION(\"find_last_not_of finds last element not within another string\") {\n    REQUIRE(sentence.find_last_not_of(\" .es\"s) == 43); // plainl(y) ➍\n     }\n}\n```", "```\nTEST_CASE(\"STL string conversion function\") {\n  using namespace std::literals::string_literals;\n  SECTION(\"to_string\") {\n    REQUIRE(\"8675309\"s == std::to_string(8675309)); ➊\n  }\n  SECTION(\"to_wstring\") {\n    REQUIRE(L\"109951.1627776\"s == std::to_wstring(109951.1627776)); ➋\n  }\n}\n```", "```\nTEST_CASE(\"STL string conversion function\") {\n  using namespace std::literals::string_literals;\n  SECTION(\"stoi\") {\n    REQUIRE(std::stoi(\"8675309\"s) == 8675309); ➊\n  }\n  SECTION(\"stoi\") {\n    REQUIRE_THROWS_AS(std::stoi(\"1099511627776\"s), std::out_of_range); ➋\n  }\n SECTION(\"stoul with all valid characters\") {\n    size_t last_character{};\n    const auto result = std::stoul(\"0xD3C34C3D\"s, &last_character, 16); ➌\n    REQUIRE(result == 0xD3C34C3D);\n    REQUIRE(last_character == 10);\n  }\n  SECTION(\"stoul\") {\n    size_t last_character{};\n    const auto result = std::stoul(\"42six\"s, &last_character); ➍\n    REQUIRE(result == 42);\n    REQUIRE(last_character == 2);\n  }\n  SECTION(\"stod\") {\n    REQUIRE(std::stod(\"2.7182818\"s) == Approx(2.7182818)); ➎\n  }\n}\n```", "```\nTEST_CASE(\"std::string_view supports\") {\n  SECTION(\"default construction\") {\n    std::string_view view; ➊\n    REQUIRE(view.data() == nullptr);\n    REQUIRE(view.size() == 0);\n    REQUIRE(view.empty());\n  }\n  SECTION(\"construction from string\") {\n    std::string word(\"sacrosanct\");\n    std::string_view view(word); ➋\n    REQUIRE(view == \"sacrosanct\");\n  }\n  SECTION(\"construction from C-string\") {\n    auto word = \"viewership\";\n    std::string_view view(word); ➌\n    REQUIRE(view == \"viewership\");\n  }\n  SECTION(\"construction from C-string and length\") {\n    auto word = \"viewership\";\n    std::string_view view(word, 4); ➍\n    REQUIRE(view == \"view\");\n  }\n}\n```", "```\nTEST_CASE(\"std::string_view is modifiable with\") {\n  std::string_view view(\"previewing\"); ➊\n  SECTION(\"remove_prefix\") {\n    view.remove_prefix(3); ➋\n    REQUIRE(view == \"viewing\");\n  }\n  SECTION(\"remove_suffix\") {\n    view.remove_suffix(3); ➌\n    REQUIRE(view == \"preview\");\n  }\n}\n```", "```\n#include <string_view>\n\nsize_t count_vees(std::string_view my_view➊) {\n  size_t result{};\n  for(auto letter : my_view) ➋\n    if (letter == 'v') result++; ➌\n  return result; ➍\n}\n```", "```\n#include <string>\n\nsize_t count_vees(const std::string& my_view) {\n--snip--\n}\n```", "```\n(\\w{2})?➊(\\d{5})➋(-\\d{4})?➌\n```", "```\n#include <regex>\n\nTEST_CASE(\"std::basic_regex constructs from a string literal\") {\n  std::regex zip_regex{ R\"((\\w{2})?(\\d{5})(-\\d{4})?)\" }; ➊\n  REQUIRE(zip_regex.mark_count() == 3); ➋\n}\n```", "```\nregex_match(beg, end, [mr], rgx, [flg])\nregex_match(str, [mr], rgx, [flg])\n```", "```\n#include <regex>\n#include <string>\n\nTEST_CASE(\"std::sub_match\") {\n  std::regex regex{ R\"((\\w{2})(\\d{5})(-\\d{4})?)\" }; ➊\n  std::smatch results; ➋\n  SECTION(\"returns true given matching string\") {\n    std::string zip(\"NJ07936-3173\");\n    const auto matched = std::regex_match(zip, results, regex); ➌\n    REQUIRE(matched); ➍\n    REQUIRE(results[0] == \"NJ07936-3173\"); ➎\n    REQUIRE(results[1] == \"NJ\"); ➏\n    REQUIRE(results[2] == \"07936\");\n    REQUIRE(results[3] == \"-3173\");\n  }\n  SECTION(\"returns false given non-matching string\") {\n    std::string zip(\"Iomega Zip 100\");\n    const auto matched = std::regex_match(zip, results, regex); ➐\n    REQUIRE_FALSE(matched); ➑\n    }\n}\n```", "```\nTEST_CASE(\"when only part of a string matches a regex, std::regex_ \") {\n  std::regex regex{ R\"((\\w{2})(\\d{5})(-\\d{4})?)\" }; ➊\n  std::string sentence(\"The string NJ07936-3173 is a ZIP Code.\"); ➋\n  SECTION(\"match returns false\") {\n    REQUIRE_FALSE(std::regex_match(sentence, regex)); ➌\n  }\n  SECTION(\"search returns true\") {\n    REQUIRE(std::regex_search(sentence, regex)); ➍\n  }\n}\n```", "```\nTEST_CASE(\"std::regex_replace\") {\n  std::regex regex{ \"[aeoiu]\" }; ➊\n  std::string phrase(\"queueing and cooeeing in eutopia\"); ➋\n  const auto result = std::regex_replace(phrase, regex, \"_\"); ➌\n  REQUIRE(result == \"q_____ng _nd c_____ng _n __t_p__\"); ➍\n}\n```", "```\n#include <string>\n#include <boost/algorithm/string/predicate.hpp>\n\nTEST_CASE(\"boost::algorithm\") {\n  using namespace boost::algorithm;\n  using namespace std::literals::string_literals;\n  std::string word(\"cymotrichous\"); ➊\n  SECTION(\"starts_with tests a string's beginning\") {\n    REQUIRE(starts_with(word, \"cymo\"s)); ➋\n  }\n  SECTION(\"istarts_with is case insensitive\") {\n    REQUIRE(istarts_with(word, \"cYmO\"s)); ➌\n  }\n}\n```", "```\nTEST_CASE(\"boost::algorithm::all evaluates a predicate for all elements\") {\n  using namespace boost::algorithm;\n  std::string word(\"juju\"); ➊\n  REQUIRE(all(word➋, [](auto c) { return c == 'j' || c =='u'; }➌));\n}\n```", "```\n#include <boost/algorithm/string/classification.hpp>\n\nTEST_CASE(\"boost::algorithm::is_alnum\") {\n  using namespace boost::algorithm;\n  const auto classifier = is_alnum(); ➊\n  SECTION(\"evaluates alphanumeric characters\") {\n    REQUIRE(classifier('a')); ➋\n    REQUIRE_FALSE(classifier('$')); ➌\n  }\n  SECTION(\"works with all\") {\n    REQUIRE(all(\"nostarch\", classifier)); ➍\n    REQUIRE_FALSE(all(\"@nostarch\", classifier)); ➎\n  }\n}\n```", "```\n#include <boost/algorithm/string/finder.hpp>\n\nTEST_CASE(\"boost::algorithm::nth_finder finds the nth occurrence\") {\n  const auto finder = boost::algorithm::nth_finder(\"na\", 1); ➊\n  std::string name(\"Carl Brutananadilewski\"); ➋\n  const auto result = finder(name.begin(), name.end()); ➌\n  REQUIRE(result.begin() == name.begin() + 12); ➍ // Brutana(n)adilewski\n  REQUIRE(result.end() == name.begin() + 14); ➎ // Brutanana(d)ilewski\n}\n```", "```\n#include <boost/algorithm/string/case_conv.hpp>\n\nTEST_CASE(\"boost::algorithm::to_upper\") {\n  std::string powers(\"difficulty controlling the volume of my voice\"); ➊\n  SECTION(\"upper-cases a string\") {\n    boost::algorithm::to_upper(powers); ➋\n    REQUIRE(powers == \"DIFFICULTY CONTROLLING THE VOLUME OF MY VOICE\"); ➌\n  }\n  SECTION(\"_copy leaves the original unmodified\") {\n    auto result = boost::algorithm::to_upper_copy(powers); ➍\n    REQUIRE(powers == \"difficulty controlling the volume of my voice\"); ➎\n    REQUIRE(result == \"DIFFICULTY CONTROLLING THE VOLUME OF MY VOICE\"); ➏\n  }\n}\n```", "```\n#include <boost/algorithm/string/replace.hpp>\n\nTEST_CASE(\"boost::algorithm::replace_first\") {\n  using namespace boost::algorithm;\n  std::string publisher(\"No Starch Press\"); ➊\n  SECTION(\"replaces the first occurrence of a string\") {\n    replace_first(publisher, \"No\", \"Medium\"); ➋\n    REQUIRE(publisher == \"Medium Starch Press\"); ➌\n  }\n  SECTION(\"has a case-insensitive variant\") {\n    auto result = ireplace_first_copy(publisher, \"NO\", \"MEDIUM\"); ➍\n    REQUIRE(publisher == \"No Starch Press\"); ➎\n    REQUIRE(result == \"MEDIUM Starch Press\"); ➏\n  }}\n```", "```\n#include <vector>\n#include <boost/algorithm/string/split.hpp>\n#include <boost/algorithm/string/classification.hpp>\n\nTEST_CASE(\"boost::algorithm::split splits a range based on a predicate\") {\n  using namespace boost::algorithm;\n  std::string publisher(\"No Starch Press\"); ➊\n  std::vector<std::string> tokens; ➋\n  split(tokens, publisher, is_space()); ➌\n  REQUIRE(tokens[0] == \"No\"); ➍\n  REQUIRE(tokens[1] == \"Starch\");\n  REQUIRE(tokens[2] == \"Press\");\n}\n```", "```\n#include <vector>\n#include <boost/algorithm/string/join.hpp>\n\nTEST_CASE(\"boost::algorithm::join staples tokens together\") {\n  std::vector<std::string> tokens{ \"We invited the strippers\",\n                                   \"JFK\", \"and Stalin.\" }; ➊\n  auto result = boost::algorithm::join(tokens, \", \"); ➋\n  REQUIRE(result == \"We invited the strippers, JFK, and Stalin.\"); ➌\n}\n```", "```\n#include <boost/algorithm/string/find.hpp>\n\nTEST_CASE(\"boost::algorithm::find_head computes the head\") {\n  std::string word(\"blandishment\"); ➊\n  const auto result = boost::algorithm::find_head(word, 5); ➋\n  REQUIRE(result.begin() == word.begin()); ➌ // (b)landishment\n  REQUIRE(result.end() == word.begin()+5); ➍ // bland(i)shment\n}\n```", "```\n#include<boost/tokenizer.hpp>\n#include<string>\n\nTEST_CASE(\"boost::tokenizer splits token-delimited strings\") {\n  std::string palindrome(\"A man, a plan, a canal, Panama!\"); ➊\n  boost::char_separator<char> comma{ \",\" }; ➋\n  boost::tokenizer<boost::char_separator<char>> tokens{ palindrome, comma }; ➌\n  auto itr = tokens.begin(); ➍\n REQUIRE(*itr == \"A man\"); ➎\n  itr++; ➏\n  REQUIRE(*itr == \" a plan\");\n  itr++;\n  REQUIRE(*itr == \" a canal\");\n  itr++;\n  REQUIRE(*itr == \" Panama!\");\n}\n```"]