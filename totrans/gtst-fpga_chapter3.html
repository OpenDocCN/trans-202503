<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>3 BOOLEAN ALGEBRA AND THE LOOK-UP TABLE</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:d7b1a4c0-49cb-46f7-b6a4-8fcfa081f00a" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch3" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch3">
<span class="CN"><span aria-label=" Page 31. " epub:type="pagebreak" id="pg_31" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">BOOLEAN ALGEBRA AND THE LOOK-UP TABLE</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="COS">Boolean algebra is a field of mathematics and logic essential to understanding how to work with devices like FPGAs. In Boolean algebra, the input and output values are all true or false, which we can equate with 1s and 0s, or high and low voltages. Instead of operations like multiplication and division, Boolean algebra has operations such as AND, OR, and NOT. Each of these operations takes in some number of 0s and 1s as input, evaluates them, and produces a 0 or 1 as an output. Algebra class would have been much simpler if it had been about Boolean algebra!</p>
<p class="TX">You may have encountered Boolean operations in other programming languages, such as C or Python. For example, you might want your program <span aria-label=" Page 32. " epub:type="pagebreak" id="pg_32" role="doc-pagebreak"/>to write to a file only if the user chooses to do so <i>and</i> the filename is valid. Similarly, inside an FPGA, you’ll often want to check multiple inputs to determine the state of an output. Let’s say you want to turn on an LED when either of two switches is pressed. An FPGA can make this happen using an OR operation: if either one switch <i>or</i> the other (or both) provides a 1 as an input, the FPGA provides a 1 as an output to the LED, and the LED lights up.</p>
<p class="TX">Boolean algebra makes tasks like this possible. But more importantly, Boolean algebra describes <i>all</i> the underlying operations on data in your FPGA. String together enough Boolean operations and you can do math, store data, and more. You can do a surprising amount by manipulating 1s and 0s.</p>
<p class="TX">In this chapter, we’ll explore how to represent simple Boolean operations with logic gates, and we’ll see how these gates can be combined into more complicated Boolean equations. Then we’ll explore how FPGAs actually perform logic operations by combining the functionality of different logic gates into a single device called a look-up table. As you’ll see, look-up tables are one of the most important components in an FPGA.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h-27"/><samp class="SANS_Futura_Std_Bold_B_11">Logic Gates and Their Truth Tables</samp></h2>
<p class="TNI1">When designing FPGAs, we represent simple Boolean operations with <i>logic gates</i>, devices that take in electrical signals as inputs, perform a Boolean operation on them, and produce the appropriate electrical signal as an output. There are different logic gates corresponding to all the different Boolean operations, such as AND, OR, NOT, XOR, and NAND. Each of these logic gates can be described with a <i>truth table</i>, a table that lists all the possible input combinations for a Boolean algebra equation and shows the corresponding outputs.</p>
<p class="TX">We’ll discuss some common logic gates and examine their truth tables next. But first, it’s important to understand what the 1s and 0s in the truth tables we’ll be looking at actually mean. Inside an FPGA, digital data is represented by voltages: 0 volts for a 0, and some higher-than-zero voltage, called the <i>core voltage</i>, for a 1. The core voltage depends on the specific FPGA, but often is around 0.8 to 1.2 volts. When we talk about a signal being <i>high</i>, we mean that the signal is at the core voltage and represents a data value of 1. Likewise, a <i>low</i> signal is at 0 volts and represents a data value of 0. With this in mind, let’s look at some logic gates.</p>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H2" id="sec2"><span id="h-28"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AND Gates</samp></h3>
<p class="TNI1">An <i>AND gate</i> is a logic gate whose output is high when all its inputs are high. We’ll use the example of a two-input AND gate, but AND gates can have any number of inputs. For a two-input AND gate, the output is high when input A <i>and</i> input B are both high, hence the name AND gate. <a href="#tab3-1">Table 3-1</a> shows the truth table for this AND gate. Notice that the output is a 1 only when both inputs are a 1.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab3-1"><span aria-label=" Page 33. " epub:type="pagebreak" id="pg_33" role="doc-pagebreak"/><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Truth Table for a Two-Input AND Gate</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Input B</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Output Q</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF_SHADE">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF_SHADE">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF_SHADE">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB_SHADE">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB_SHADE">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB_SHADE">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">In a truth table, the rows are usually arranged in increasing decimal order, based on the inputs. In the case of the AND truth table, the first row shows when input A = 0 and input B = 0, which is represented as <samp class="SANS_TheSansMonoCd_W5Regular_11">b00</samp>, which means <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> in binary, or 0 in decimal. Next comes <samp class="SANS_TheSansMonoCd_W5Regular_11">b01</samp> (decimal 1), then <samp class="SANS_TheSansMonoCd_W5Regular_11">b10</samp> (decimal 2), then <samp class="SANS_TheSansMonoCd_W5Regular_11">b11</samp> (decimal 3). If the AND gate had additional inputs, then there would be more rows in our truth table that we would have to fill out. In the case of a three-input AND gate, for example, there would be eight rows, going from <samp class="SANS_TheSansMonoCd_W5Regular_11">b000</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">b111</samp>, or 0 to 7 in decimal.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>The output of a logic gate is denoted with a Q. This convention comes from the English mathematician Alan Turing, who used the letter Q to denote states in his famous Turing machines. The Q stood for</i> <span class="Roman">quanta</span><i>, which is a discrete state (such as 0 or 1), rather than something that can have a continuous range of values.</i></p>
<p class="TX">Each logic gate has a distinctive symbol for use in schematics. A two-input AND gate is drawn as shown in <a href="#fig3-1">Figure 3-1</a>. The symbol depicts the inputs A and B going into the gate on the left, and the output Q emerging on the right.</p>
<figure class="IMG"><img alt="" class="img20" id="fig3-1" src="../images/Figure3-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: The AND gate symbol</samp></p></figcaption>
</figure>
<p class="TX">As we continue our exploration of logic gates, most of the gates we’ll look at will have two inputs and one output. As with AND gates, it’s possible that these other types of gates could have additional inputs, but for simplicity we’ll stick to the two-input versions. (The exception is the NOT gate, which can only have one input and one output.) For brevity, I’ll omit the words <i>two-input</i> from this point forward when referring to a given logic gate.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="H2" id="sec3"><span id="h-29"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">OR Gates</samp></h3>
<p class="TNI1">An <i>OR gate</i> (<a href="#fig3-2">Figure 3-2</a>) is a logic gate whose output is high when either of the inputs is high; that is, when either input A <i>or</i> input B is high.</p>
<span aria-label=" Page 34. " epub:type="pagebreak" id="pg_34" role="doc-pagebreak"/>
<figure class="IMG"><img alt="" class="img20" id="fig3-2" src="../images/Figure3-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: The OR gate symbol</samp></p></figcaption>
</figure>
<p class="TX"><a href="#tab3-2">Table 3-2</a> shows the truth table for an OR gate.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab3-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Truth Table for an OR Gate</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Input B</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Output Q</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">Notice that when both inputs are high, the OR gate’s output is high as well. All that matters to an OR gate is that at least one of the inputs is high, which is also the case when both inputs are high.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H2" id="sec4"><span id="h-30"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NOT Gates</samp></h3>
<p class="TNI1">A <i>NOT gate</i> (<a href="#fig3-3">Figure 3-3</a>) has a single input and a single output. This kind of gate simply inverts the input (the output is <i>not</i> the input), so it’s also known as an inverter.</p>
<figure class="IMG"><img alt="" class="img20" id="fig3-3" src="../images/Figure3-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: The NOT gate symbol</samp></p></figcaption>
</figure>
<p class="TX">Notice the bubble at the tip of the triangle in the NOT gate symbol, which indicates inversion. It also appears in the NAND gate, which we’ll look at later, and can even appear on some inputs. The truth table for a NOT gate is shown in <a href="#tab3-3">Table 3-3</a>.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab3-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Truth Table for a NOT Gate</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Output Q</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">As the truth table indicates, whatever the input value to the gate is, the output is the opposite.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H2" id="sec5"><span id="h-31"/><span aria-label=" Page 35. " epub:type="pagebreak" id="pg_35" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">XOR Gates</samp></h3>
<p class="TNI1">The output of an <i>XOR gate</i> (pronounced “ex-or,” short for <i>exclusive or</i>) is high when either of the inputs is high, but not both. In other words, the gate checks for exclusively one or the other input being high. The symbol for an XOR gate is shown in <a href="#fig3-4">Figure 3-4</a>.</p>
<figure class="IMG"><img alt="" class="img20" id="fig3-4" src="../images/Figure3-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-4: The XOR gate symbol</samp></p></figcaption>
</figure>
<p class="TX">The symbol looks like that of an OR gate, but the extra line on the left side of the gate sets it apart. <a href="#tab3-4">Table 3-4</a> shows the XOR gate’s truth table.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab3-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">Truth Table for an XOR Gate</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Input B</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Output Q</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">Though this type of gate might not seem particularly useful at first blush, it comes up more often than you might expect. For example, XOR gates are used for generating a <i>cyclic redundancy check (CRC)</i>, a way to validate data to verify the integrity of transmitted information.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="H2" id="sec6"><span id="h-32"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NAND Gates</samp></h3>
<p class="TNI1">A <i>NAND gate</i> (short for <i>not and</i>) has the opposite output of an AND gate. You can infer this from the NAND gate’s schematic symbol, shown in <a href="#fig3-5">Figure 3-5</a>: it looks exactly like an AND gate, except with a bubble on the output to indicate an inversion.</p>
<figure class="IMG"><img alt="" class="img20" id="fig3-5" src="../images/Figure3-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-5: The NAND gate symbol</samp></p></figcaption>
</figure>
<p class="TX">The output of the NAND gate is thus the same as an AND gate, but inverted. If both input A and input B are high, output Q will be low. In all other cases, output Q will be high. This is shown in the truth table in <a href="#tab3-5">Table 3-5</a>.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab3-5"><span aria-label=" Page 36. " epub:type="pagebreak" id="pg_36" role="doc-pagebreak"/><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">Truth Table for a NAND Gate</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Input B</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Output Q</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">NAND gates are commonly used in USB flash drives, solid state drives (SSDs), and other types of data storage devices. They also inspired the name of my website, <a href="https://nandland.com"><i>https://<wbr/>nandland<wbr/>.com</i></a>.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H2" id="sec7"><span id="h-33"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Other Gates</samp></h3>
<p class="TNI1">We’ve explored the most common types of logic gates here to give you an idea of how they work, but this isn’t an exhaustive list. There are other types as well, such as NOR (short for <i>not or</i>) and XNOR (<i>exclusive not or</i>) gates. Additionally, as mentioned previously, though we focused on the two-input versions here, all of these gates (with the exception of NOT) can have more than two inputs. This section was just intended to get you comfortable with the standard logic operations from Boolean algebra. Next, we’ll explore how these operations can be combined to make more complicated expressions.</p>
</section>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h2 class="H1" id="sec8"><span id="h-34"/><samp class="SANS_Futura_Std_Bold_B_11">Combining Gates with Boolean Algebra</samp></h2>
<p class="TNI1">You’ve seen how individual logic gates work. However, often you’ll want to write code that’s more complex than just a single logic operation. The good news is that you can chain together multiple logic gates to represent more elaborate Boolean equations, and use Boolean algebra to determine the outcome.</p>
<p class="TX">In Boolean algebra, each logic operation has its own symbol. One common set of symbols is shown in <a href="#tab3-6">Table 3-6</a>. For example, * represents an AND operation, and + represents an OR operation. These symbols make it easier to write more elaborate Boolean algebraic equations.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab3-6"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-6:</samp></span> <samp class="SANS_Futura_Std_Book_11">Boolean Algebra Symbols</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Symbol</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Meaning</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">*</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">AND</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB">+</p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">OR</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">′</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">NOT</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">^</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">XOR</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">Boolean algebra also has its own <i>order of operations</i>. To solve a Boolean equation, first you evaluate NOTs, then ANDs, and finally ORs. As in <span aria-label=" Page 37. " epub:type="pagebreak" id="pg_37" role="doc-pagebreak"/>conventional algebra, you can use parentheses to bypass the order of operations; anything in parentheses will be evaluated first.</p>
<p class="TX">You now know everything you need to write and evaluate Boolean equations with more than one logic operation, such as Q = A * B + A<samp class="SANS_Futura_Std_Book_11">′</samp>. In plain language, you’d read this as “The output Q equals A <i>and</i> B <i>or not</i> A.” <a href="#tab3-7">Table 3-7</a> shows the truth table for this equation.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab3-7"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-7:</samp></span> <samp class="SANS_Futura_Std_Book_11">Truth Table for A * B</samp> + <samp class="SANS_Futura_Std_Book_11">A′</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Input B</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Output Q</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX"><a href="#fig3-6">Figure 3-6</a> shows the circuit equivalent of this equation, created by combining logic gates.</p>
<figure class="IMG"><img alt="" class="img30" id="fig3-6" src="../images/Figure3-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-6: The circuit diagram for A * B</samp> + <samp class="SANS_Futura_Std_Book_Oblique_I_11">A</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">′</samp></p></figcaption>
</figure>
<p class="TX">As you can see, we still have only two inputs, but because those inputs go through three different logic operations, the possible outputs of our truth table are more interesting than they were for individual logic gates. Let’s consider what happens with this equation when both inputs are 0, the first row of our truth table. The equation has no parentheses, so first we look at NOT A, which evaluates to 1. Then we perform the AND operation of A and B, which evaluates to 0. Finally, we OR the results of both of those expressions, giving us an output of 1. Considering the other possible inputs, you should see that any time A is 0, or any time A and B are both 1, the output Q will be 1. Otherwise, the output will be 0.</p>
<p class="TX">While this example featured two inputs, it’s possible to have Boolean equations with any number of inputs. Each input increases the number of rows in the truth table by a factor of 2: for one input there are two truth table rows, for two inputs there are four rows, for three inputs there are eight rows, and so on. In mathematical terms, for <i>n</i> inputs, there are 2<i><sup>n</sup></i> truth table rows.</p>
<p class="TX">To demonstrate, let’s consider an example equation with three inputs: Q = A + (C * B′). Note that the parentheses indicate that the operation C AND NOT B occurs prior to the OR operation. In fact, that follows the regular Boolean algebra order of operations, but the parentheses make the equation a little easier to read. The truth table with three inputs is shown in <a href="#tab3-8">Table 3-8</a>.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab3-8"><span aria-label=" Page 38. " epub:type="pagebreak" id="pg_38" role="doc-pagebreak"/><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-8:</samp></span> <samp class="SANS_Futura_Std_Book_11">Truth Table for A</samp> + <samp class="SANS_Futura_Std_Book_11">(C * B′)</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Input B</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Input C</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Output Q</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">The corresponding circuit is shown in <a href="#fig3-7">Figure 3-7</a>.</p>
<figure class="IMG"><img alt="" class="img30" id="fig3-7" src="../images/Figure3-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-7: The circuit diagram for A</samp> + <samp class="SANS_Futura_Std_Book_Oblique_I_11">(C * B</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">′</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">)</samp></p></figcaption>
</figure>
<p class="TX">To generate this truth table, first we should perform the operation inside the parentheses. This is C AND NOT B. Within the parentheses, the highest precedence is the inversion applied to B, which is then ANDed with C. In all, the part of the equation in parentheses evaluates to high when C is high and B is low, and since the remainder of the equation is an OR operation, we also know that the overall output will be high when C is high and B is low. This case occurs on the second line of the truth table. It also occurs on the fifth line of the truth table, so we can fill those in with a 1. Finally, consider the A on the other side of the OR operation. When it’s high, as in the last four lines of the truth table, the output will be high. We can fill in the remaining lines with a 0 to complete the truth table.</p>
<p class="TX">Combining logic operations to perform more complicated functionality is common throughout programming. In FPGAs, this same capability is possible by chaining together simple logic gate functions.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h2 class="H1" id="sec9"><span id="h-35"/><samp class="SANS_Futura_Std_Bold_B_11">The Look-Up Table</samp></h2>
<p class="TNI1">So far we’ve been learning about individual logic gates, but it might surprise you to find out that these logic gates don’t physically exist inside an FPGA. There isn’t a bank of AND gates and OR gates that you can just pull from and wire together to create your Boolean algebra logic. Instead, there’s something much better: <i>look-up tables (LUTs)</i>. These are devices <span aria-label=" Page 39. " epub:type="pagebreak" id="pg_39" role="doc-pagebreak"/>that can be programmed to perform any Boolean algebra equation you can think of, regardless of the specific logic gate(s) involved. If you need an AND gate, a LUT can do it. If you need an XOR gate, a LUT can do that too. A single LUT can also evaluate an equation involving multiple logic gates, like the ones we considered in the previous section. Any truth table you can think of, a LUT can produce. This is the power of the look-up table.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>Early programmable logic devices like Programmable Array Logic (PAL) did actually have banks of AND and OR gates. With FPGAs, these have been superseded by the more capable LUTs.</i></p>
<p class="TX">LUTs are classified by the number of inputs they can accept. For example, there are two-, three-, four-, five-, and even six-input LUTs on the newest FPGAs. Most LUTs produce a single output. <a href="#fig3-8">Figure 3-8</a> shows what a three-input LUT (often referred to as LUT-3) looks like.</p>
<figure class="IMG"><img alt="" class="img30" id="fig3-8" src="../images/Figure3-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-8: A three-input LUT</samp></p></figcaption>
</figure>
<p class="TX">This LUT is a blank slate that can be programmed to perform any Boolean algebra operation with three inputs and one output. For example, look back at the circuit drawn in <a href="#fig3-7">Figure 3-7</a> to represent the Boolean equation Q = A + (C * B′). Drawing the circuit for that equation required three logic gates—a NOT gate, an AND gate, and an OR gate—but we can replace those three gates with our single three-input LUT. The same LUT could also be programmed to represent the equation Q = (A + B + C)′, or Q = (A + B)′ * C.</p>
<p class="TX">What happens if we have a Boolean algebra equation with more than three inputs? That’s just fine, as LUTs can be chained together to perform very long sequences of logic. In fact, the typical FPGA contains hundreds or even thousands of LUTs, all ready to be programmed to carry out whatever logic operations you need. This is why look-up tables are one of the two most important components to understand inside of an FPGA: they perform the logical operations of your code. The other key component is the flip-flop, which we’ll talk about in the next chapter.</p>
<p class="TX">Although we’ve been drawing truth tables and logic gate diagrams here, in the real world you’ll rarely define FPGA operations this way. Instead, you’ll write code. Often, the code you write is at a higher level than individual logic gates: you might write code to compare two numbers, or increment a counter, or check if a condition is true, and the synthesis tools then break down that code into the necessary Boolean logic operations and assign those operations to LUTs. However, the purpose of this book is to teach you how FPGAs work so you understand them, and at a fundamental level, FPGAs work by performing Boolean algebra. Once you know how <span aria-label=" Page 40. " epub:type="pagebreak" id="pg_40" role="doc-pagebreak"/>FPGAs work, you’ll be able to use Verilog or VHDL with a deeper understanding of what you’re creating with your code. This will help you create efficient and reliable FPGA designs.</p>
<aside aria-labelledby="box2" class="box">
<h3 class="BoxTitle" id="box2"><samp class="SANS_Dogma_OT_Bold_B_11">LOGIC MINIMIZATION</samp></h3>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">You’ll often hear about</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">logic minimization</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">techniques</samp> <samp class="SANS_Futura_Std_Book_11">such as De Morgan’s law, Karnaugh maps, and the Quine–McCluskey algorithm in connection to Boolean algebra. These are mathematical tricks to simplify Boolean algebra equations to take up fewer computing resources. I feel that knowing the ins and outs of these techniques isn’t necessary to begin learning about FPGAs, however. Yes, LUTs are limited and should be used optimally, but there are entire software tools responsible for minimizing logic resource usage for you. Specifically, synthesis tools, which we’ll discuss in more detail in <a href="chapter7.xhtml">Chapter 7</a>, perform this task so you don’t have to. I’ve spent weeks of my life learning about Karnaugh maps and performing Quine–McCluskey by hand, and I can tell you that I’ve never needed to use this knowledge as a professional FPGA engineer. All you need to do is write the VHDL or Verilog and let the software tools work their magic.</samp></p>
</aside>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h2 class="H1" id="sec10"><span id="h-36"/><span class="NoteHead"><samp class="SANS_Futura_Std_Heavy_B_21">Project #2: Lighting an LED with Logic Gates</samp></span></h2>
<p class="TNI1">You’re now ready to combine everything you’ve learned about Boolean logic and look-up tables in a real-world example on your FPGA development board. This project should illuminate an LED, but only when two switches are pushed at the same time. In other words, you’re using your first LUT by implementing an AND gate. <a href="#fig3-9">Figure 3-9</a> shows the block diagram for this project.</p>
<figure class="IMG"><img alt="" class="img40" id="fig3-9" src="../images/Figure3-9.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-9: The Project #2 block diagram</samp></p></figcaption>
</figure>
<p class="TX">This project turns the entire FPGA into one single AND gate. This might be overkill for a very capable FPGA, but it’s an excellent way to <span aria-label=" Page 41. " epub:type="pagebreak" id="pg_41" role="doc-pagebreak"/>visualize how a LUT works in the real world. <a href="#tab3-9">Table 3-9</a> shows the truth table corresponding to the project.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab3-9"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-9:</samp></span> <samp class="SANS_Futura_Std_Book_11">Truth Table for Project #2</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">SW1</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">SW2</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">D1</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">This truth table looks exactly like the one we created for the AND gate, but the column labels have been replaced to represent two switches and an LED on your development board. As expected, the output D1 is only high when inputs SW1 and SW2 are both high.</p>
<section aria-labelledby="sec11" epub:type="division">
<h3 class="H2" id="sec11"><span id="h-37"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Code</samp></h3>
<p class="TNI1">Implementing an AND gate uses very few resources: three connections (two input and one output) and a single LUT. Let’s look at the Verilog and VHDL to get that LED to light up:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>module And_Gate_Project
 (input i_Switch_1,
  input i_Switch_2,
  output o_LED_1);
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> assign o_LED_1 = i_Switch_1 &amp; i_Switch_2;
endmodule</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>library ieee;
use ieee.std_logic_1164.all;
entity And_Gate_Project is
  port (
    i_Switch_1 : in std_logic;
    i_Switch_2 : in std_logic;
    o_LED_1    : out std_logic);
end entity And_Gate_Project;
architecture RTL of And_Gate_Project is
begin
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> o_LED_1 &lt;= i_Switch_1 and i_Switch_2;
end RTL;</code></pre>
<p class="TX">We begin by defining our inputs as <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_2</samp>, and our output as <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>. Then we continuously assign the output with the AND of <span aria-label=" Page 42. " epub:type="pagebreak" id="pg_42" role="doc-pagebreak"/>the two inputs <span aria-label="annotation1" class="CodeAnnotation">❶</span>. In Verilog the symbol for an AND operation is <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp>, whereas in VHDL <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp> is a reserved keyword.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="H2" id="sec12"><span id="h-38"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building and Programming the FPGA</samp></h3>
<p class="TNI1">You’re now ready to run your Verilog or VHDL through the build process discussed in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>. The synthesis tool will generate a report outlining the resource utilization on your FPGA. Here’s the most interesting part of the report:</p>
<pre><code><var>--snip--</var>
Resource Usage Report for And_Gate_Project
Mapping to part: ice40hx1kvq100
Cell usage:
SB_LUT4         1 use
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> I/O ports: 3
I/O primitives: 3
SB_IO          3 uses
I/O Register bits:                  0
Register bits not including I/Os:   0 (0%)
Total load per clock:
Mapping Summary:
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> Total  LUTs: 1 (0%)</code></pre>
<p class="TX">This report tells us that three I/O ports (input/output ports, or pins, meaning connections to the outside world) on the FPGA have been used to implement our circuit design <span aria-label="annotation1" class="CodeAnnotation">❶</span> and, most importantly, that we’ve used a single LUT <span aria-label="annotation2" class="CodeAnnotation">❷</span>. That <samp class="SANS_TheSansMonoCd_W5Regular_11">(0%)</samp> on the last line is indicating the resource utilization on the FPGA. On this particular FPGA there are over 1,000 LUTs available for usage, and we’re only making use of 1 of them. Since the synthesis report is showing one LUT with 0 percent resource utilization, the tool must be doing some rounding down here (1 / 1,000 = 0.1).</p>
<p class="TX">Go ahead and program your development board, and notice that the LED only illuminates when the two switches are held down together. The LUT is working!</p>
<p class="TX">Feel free to change the code around to implement a different Boolean operation than AND. For example, you could create an OR gate or an XOR gate using the <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp> symbols in Verilog, or the <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp> keywords in VHDL. You could also try stringing together several operations to make the LED light up based on whatever crazy Boolean algebra equation you can think of, or try adding in more switch inputs or more LED outputs to implement more complicated truth tables. You can check that the synthesis tools are really generating the correct LUTs based on your code by writing out your own truth table using the switches as inputs and the LED as the output, then testing all possible switch combinations to see if they work as expected.</p>
</section>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h2 class="H1" id="sec13"><span id="h-39"/><span aria-label=" Page 43. " epub:type="pagebreak" id="pg_43" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<p class="TNI1">In this chapter you’ve learned about one of the two most important components of an FPGA: the look-up table. You’ve seen how a LUT can implement any Boolean algebra equation with a given number of inputs, from simple logic gates like AND, OR, NOT, XOR, and NAND to more complex equations that combine these gates. In the next chapter, we’ll focus on the other crucial FPGA component: the flip-flop.</p>
</section>
</section>
</body>
</html>