- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PATHS
    THROUGH GRAPHS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">图中的路径</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: The concept of a *path* through a graph is another foundational building block
    we’ll use throughout the book. For example, we may be interested in determining
    the lowest-cost path between two nodes (*shortest path algorithm*) or whether
    it is even possible to reach one node from another using any path at all. Multiple
    subsequent chapters are devoted to computing paths with different properties.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的*路径*概念是我们将在全书中使用的另一个基础性构建块。例如，我们可能对确定两个节点之间的最低成本路径（*最短路径算法*）感兴趣，或者我们可能关心是否可以通过任何路径到达一个节点。接下来的多个章节将专门讨论具有不同属性的路径计算。
- en: The general concept of a path mirrors its real-world counterpart. Just as the
    paths in your favorite park provide routes for moving from one place to the next,
    paths in graphs provide the same mechanism. They are sequences of nodes (or edges)
    that let us travel through the graph. When escaping a maze or navigating a road
    trip, we move from node to node using the graph’s edges.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 路径的概念与其现实世界的对应物相似。就像你最喜欢的公园中的路径为你提供了从一个地方到另一个地方的路线，图中的路径也提供了相同的机制。它们是节点（或边）的序列，允许我们在图中移动。当我们逃脱迷宫或进行公路旅行时，我们通过图的边从一个节点移动到另一个节点。
- en: This chapter formally defines what we mean by paths through a graph and looks
    at different ways we can represent these structures. Whether finding paths or
    using them as part of an algorithm, we need to be able to represent them efficiently
    and unambiguously. If you’ve ever asked for directions and been met by a vague
    wave and a statement like “Go that way and turn right when you get to either the
    third or fourth intersection. You’ll probably know it when you see it,” you’ve
    experienced working with an incomplete path.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章正式定义了我们所说的图中的路径，并探讨了表示这些结构的不同方式。无论是寻找路径还是将其作为算法的一部分，我们都需要能够高效且明确地表示它们。如果你曾经请求过指示，结果得到的是模糊的手势和类似“往那边走，到了第三个或第四个路口右转，你应该能看到的”这样的回答，那么你就体验到了使用不完整路径的情况。
- en: This chapter introduces three decidedly unambiguous representations. We also
    consider the properties of paths and a few tasks for which we can use them. We
    explore functions to check whether a path is valid and to compute the cost of
    a path in a weighted graph. Finally, we discuss how paths relate to the question
    of reachability in a graph.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了三种明确无误的表示方式。我们还考虑了路径的属性以及一些可以利用路径执行的任务。我们探讨了用于检查路径是否有效以及在加权图中计算路径成本的函数。最后，我们讨论了路径与图中可达性问题的关系。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Paths</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">路径</samp>
- en: 'A *path* through a graph is a sequence of nodes that are connected by edges.
    These are the waypoints we pass through when moving along the graph from one node
    to another. Just as we referred to the endpoints of individual edges as origins
    and destinations, we use those terms to describe the endpoints of an entire path:
    the first node in the path is the origin, and the last is the destination. [Figure
    3-1](#fig3-1) shows the path consisting of the nodes [0, 1, 3, 2, 4, 7]. Each
    adjacent pair of nodes along the list corresponds to an edge in the graph.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的*路径*是由边连接的一系列节点。这些是我们在图中从一个节点移动到另一个节点时经过的途径。就像我们将单个边的端点称为起点和终点一样，我们也用这些术语来描述整个路径的端点：路径中的第一个节点是起点，最后一个节点是终点。[图
    3-1](#fig3-1)展示了由节点[0, 1, 3, 2, 4, 7]组成的路径。路径中每一对相邻的节点对应图中的一条边。
- en: '![A graph with eight nodes has a path through it indicated by bolded edges
    from node 0 to node one, node one to node three, node three to node two, node
    two to node four, and node four to node seven.](../images/f03001.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![一张有八个节点的图，图中通过加粗的边从节点0到节点1，再从节点1到节点3，节点3到节点2，节点2到节点4，节点4到节点7，表示有一条路径。](../images/f03001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: A valid path from
    node 0 to node 7</samp>'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-1：从节点0到节点7的有效路径</samp>
- en: For the purposes of this book, we use the definition of a path (as a sequence
    of nodes) that is common in computer science and algorithm texts. This differs
    from the formal graph theory definition of a path, which does not allow for repeated
    nodes. In graph theory, a path allowing repeated nodes is called a *walk*. Using
    the more general definition of a path allows us both to stay consistent with the
    other algorithmic texts and to mirror the real-world paths.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中，我们采用了计算机科学和算法教材中常见的路径定义（作为节点序列）。这与图论中路径的正式定义不同，后者不允许重复节点。在图论中，允许重复节点的路径称为*游走*。采用更一般的路径定义使我们既能与其他算法文本保持一致，也能反映现实世界中的路径。
- en: Paths have directionality, even on undirected graphs. The list of nodes presents
    the order in which we travel the path. The path [0, 1, 2, 7] travels *from* node
    0 *to* node 1 *to* node 2 *to* node 7\. This directionality will be important
    in understanding the results of algorithms throughout the rest of this book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 路径具有方向性，即使在无向图中也是如此。节点列表展示了我们行进路径的顺序。路径[0, 1, 2, 7]从节点0*到*节点1*到*节点2*到*节点7。这种方向性将在理解本书中算法结果时非常重要。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Path Representation</samp>
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">路径表示</samp>
- en: There are a variety of ways to represent a path in code. As with all representations,
    we can tailor the data structures of a path to the problem or algorithm at hand.
    This section covers several approaches to storing paths in code, and their respective
    advantages and drawbacks. We also look at how each representation maps to a real-world
    counterpart in the context of planning a road trip.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中表示路径有多种方式。与所有表示法一样，我们可以根据当前的问题或算法来定制路径的数据结构。本节将介绍几种在代码中存储路径的方法，并讨论它们各自的优缺点。我们还将探讨每种表示法如何与规划公路旅行中的现实世界对应物相匹配。
- en: Throughout the section, we also use the problem of checking path validity to
    illustrate how the storage representation works and how code traverses it. For
    the purposes of the following code, we will consider empty paths, containing no
    nodes or edges, as valid. You can easily adapt the code to exclude these cases
    depending on the problem domain.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们还使用检查路径有效性的问题来说明存储表示如何工作以及代码如何遍历它。对于以下代码的目的，我们将空路径（不包含任何节点或边）视为有效。根据问题领域，你可以轻松调整代码，以排除这些情况。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Lists of Nodes</samp>
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">节点列表</samp>
- en: We typically use an ordered *list of nodes* to represent the path from a starting
    node to an ending node in the graph, a representation found in many computer science
    texts. We define the list of nodes inclusively, so <samp class="SANS_TheSansMonoCd_W5Regular_11">path[0]</samp>
    is the index of the starting node (path origin), while <samp class="SANS_TheSansMonoCd_W5Regular_11">path[N-1]</samp>
    is the index of the ending node (path destination) for a path of length <samp
    class="SANS_TheSansMonoCd_W5Regular_11">N</samp>. For example, we represent the
    path in [Figure 3-1](#fig3-1) as [0, 1, 3, 2, 4, 7]. This representation can be
    used for a single path with a fixed origin and destination.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用有序的*节点列表*来表示从起始节点到终止节点的路径，这种表示在许多计算机科学教材中都有。我们定义节点列表为闭区间，所以<samp class="SANS_TheSansMonoCd_W5Regular_11">path[0]</samp>是起始节点的索引（路径起点），而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">path[N-1]</samp>是路径长度为<samp class="SANS_TheSansMonoCd_W5Regular_11">N</samp>时，终止节点的索引（路径终点）。例如，我们可以将[图3-1](#fig3-1)中的路径表示为[0,
    1, 3, 2, 4, 7]。这种表示法适用于一个具有固定起点和终点的单一路径。
- en: On our road trip, the list-of-nodes representation is equivalent to listing
    each city we will visit along the way. Suppose we plan to travel from Boston to
    Philadelphia to Pittsburgh to Columbus to Indianapolis. If we stop at a tourist
    center in each city, including the origin and destination, and purchase a commemorative
    postcard, the complete stack of cards will sum up the exciting journey.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的公路旅行中，节点列表的表示法相当于列出我们沿途会访问的每个城市。假设我们计划从波士顿出发，途经费城、匹兹堡、哥伦布和印第安纳波利斯。如果我们在每个城市的旅游中心停留，并购买一张纪念明信片（包括起点和终点城市），那么这堆明信片就会总结我们这段激动人心的旅程。
- en: 'We check whether such a path is valid by iterating through the list of nodes
    and confirming that an edge exists between each pair, as shown in the following
    code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过遍历节点列表并确认每一对节点之间存在边来检查路径是否有效，如下代码所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">check_node_path_valid()</samp>
    function first checks whether the path is empty and, if so, returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    ❶ because we defined a path of zero nodes as valid.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">check_node_path_valid()</samp>
    函数首先检查路径是否为空，如果为空，则返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    ❶，因为我们定义了零个节点的路径为有效路径。
- en: If the path is not empty, the code retrieves the starting node of the path and
    checks that it is valid ❷. The code then loops through the remaining nodes on
    the path, using the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">step</samp>
    to track the current step under consideration. Since the code already tested the
    first node, it starts at the second node in the list (<samp class="SANS_TheSansMonoCd_W5Regular_11">step=1</samp>).
    For each new node, it uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_edge()</samp>
    function to check both that the node is valid and that there exists an edge from
    the previous node to this new node ❸. If the new node is invalid or no corresponding
    edge exists in the graph, the function immediately returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
    After checking the edge, the code proceeds to the next node in the path ❹. The
    function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> if
    it makes it through the entire path without finding any invalid nodes or edges.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路径不为空，代码会获取路径的起始节点，并检查它是否有效 ❷。然后，代码遍历路径中的其余节点，使用变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">step</samp>
    来跟踪当前正在检查的步骤。由于代码已经测试了第一个节点，所以从列表中的第二个节点开始（<samp class="SANS_TheSansMonoCd_W5Regular_11">step=1</samp>）。对于每个新节点，使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">is_edge()</samp> 函数来检查该节点是否有效，并且是否存在一条从前一个节点到该新节点的边
    ❸。如果新节点无效或图中没有相应的边，函数会立即返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。检查完边后，代码会继续检查路径中的下一个节点
    ❹。如果函数在遍历完整个路径时未发现任何无效节点或边，则返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。
- en: In the context of our road trip example, this code corresponds to iterating
    over the list of cities. We check that each city is a valid city and that there
    is a road directly from the previous city on the list (in other words, there is
    an edge). Given a list such as [Boston, New York, Philadelphia, Pittsburgh], we
    would return <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>, while
    [Boston, New York, Madrid, Philadelphia, Pittsburgh] would clearly return <samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的公路旅行示例中，这段代码对应于遍历城市列表。我们检查每个城市是否是有效城市，并且是否存在一条直接从前一个城市到当前城市的路（换句话说，是否存在一条边）。例如，对于列表
    [Boston, New York, Philadelphia, Pittsburgh]，我们会返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，而
    [Boston, New York, Madrid, Philadelphia, Pittsburgh] 显然会返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Lists of Edges</samp>
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">边的列表</samp>
- en: Another natural approach to representing paths is to use a *list of edges*.
    The origin and destination of the path correspond to the origin of the first edge
    and the destination of the last edge, respectively. Each edge in the list represents
    the transition between two nodes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种表示路径的自然方法是使用 *边的列表*。路径的起点和终点分别对应第一个边的起点和最后一个边的终点。列表中的每一条边表示两个节点之间的转换。
- en: 'This formulation requires the additional constraint that the origin of every
    edge (except the first one) equals the destination of the previous edge. We say
    that a set of edges [*e*[0], *e*[1], . . . , *e*k] is a valid path only if:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 该公式要求附加的约束条件，即每条边的起点（除了第一条边外）必须等于前一条边的终点。我们说只有当边集 [*e*[0], *e*[1], . . . , *e*k]
    满足以下条件时，它才是一个有效路径：
- en: '*e*[(]i [− 1)].<samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>
    = *e*i.<samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp> for all
    *i* > 0'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*e*[(]i [− 1)].<samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>
    = *e*i.<samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp> 对于所有 *i*
    > 0'
- en: 'This definition restricts paths to mirror their real-world counterparts in
    that the start of every segment (edge) needs to align with the ending point of
    the previous segment (edge). We do not allow the path to stop at one node and
    magically restart from a different one. If a friend gave you instructions for
    a road trip from Boston to Seattle in which day one is spent driving from Boston
    to Pittsburgh and day two is spent driving from Cincinnati to St. Louis, you would
    soon realize there was a problem: somehow the proposed route skips the majority
    of Ohio. The path shown in [Figure 3-2](#fig3-2), like our friend’s bad directions,
    is not valid.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该定义限制了路径，要求每个段（边）的起点必须与前一个段（边）的终点对齐，从而与现实世界的情况相符。我们不允许路径在一个节点停止后，从另一个不同的节点重新开始。如果朋友给你关于从波士顿到西雅图的公路旅行指示，其中第一天是从波士顿开车到匹兹堡，第二天是从辛辛那提开车到圣路易斯，你很快会意识到有问题：拟定的路线跳过了俄亥俄州的大部分地方。图
    [图 3-2](#fig3-2) 中的路径就像我们朋友的错误指示一样，是无效的。
- en: '![A graph with eight nodes has an invalid path indicated by bolded edges from
    node zero to node five, node three to node four, and node four to node seven.](../images/f03002.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图中有八个节点，显示了从节点零到节点五、从节点三到节点四、从节点四到节点七的无效路径，这些路径用加粗的边表示。](../images/f03002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: An invalid path
    through the graph</samp>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-2：图中无效路径</samp>
- en: When writing paths as a list of edges, we denote each edge as the tuple (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>)
    to mirror the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> objects.
    For example, the path in [Figure 3-1](#fig3-1) corresponds to [(0, 1), (1, 3),
    (3, 2), (2, 4), (4, 7)].
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在将路径表示为边的列表时，我们将每条边表示为元组（<samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>），以便与 <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>
    对象相对应。例如，[图 3-1](#fig3-1) 中的路径对应于 [(0, 1), (1, 3), (3, 2), (2, 4), (4, 7)]。
- en: 'We check whether such a path is valid by iterating through the list of edges
    and confirming both that the destination of the last edge matches the origin of
    the current edge and that the edge exists in the graph, as shown in the following
    code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过遍历边的列表来检查路径是否有效，并确认最后一条边的终点是否与当前边的起点匹配，并且边在图中是否存在，如以下代码所示：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">check_edge_path_valid()</samp>
    function first checks whether the path is empty and, if so, returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    ❶ because we previously defined a path of zero edges as valid. Otherwise, the
    code retrieves the starting node of the path as the origin of the first edge ❷.
    It checks that this node has a valid index and, if not, returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">check_edge_path_valid()</samp>
    函数首先检查路径是否为空，如果是，则返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    ❶，因为我们之前将零边的路径定义为有效。否则，代码将路径的起始节点作为第一条边的起点 ❷。它检查该节点是否具有有效的索引，如果没有，则返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。
- en: The code then loops through all the edges on the path. For each edge, it first
    checks that the origin of the edge matches the last edge’s destination ❸. It then
    extracts the index of the new destination node (<samp class="SANS_TheSansMonoCd_W5Regular_11">next_node</samp>)
    and uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_edge()</samp> function
    to check both that the node is valid and that this edge exists. If the new node
    is invalid, or no corresponding edge exists in the graph, the function immediately
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. After checking
    the edge, the code proceeds to the next edge along the path. The function returns
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> if it makes it through
    the entire path without finding any invalid nodes or edges.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码会遍历路径上的所有边。对于每一条边，它首先检查该边的起点是否与上一条边的终点相匹配 ❸。接着，它提取新的目标节点（<samp class="SANS_TheSansMonoCd_W5Regular_11">next_node</samp>）的索引，并使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">is_edge()</samp> 函数检查节点是否有效，并且该边是否存在。如果新节点无效，或者图中没有相应的边，函数将立即返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。检查完边之后，代码会继续处理路径上的下一条边。如果没有发现任何无效的节点或边，函数将返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Lists of Previous
    Nodes</samp>
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">前一个节点的列表</samp>
- en: For many of the algorithms in this book, we use a more specialized representation
    of paths as lists mapping nodes to the previous node along the path. This method
    lends itself well to how many of the algorithms in this book process the data
    by traveling from one node to the next. It has both significant advantages and
    significant disadvantages.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的许多算法采用一种更为专业的路径表示方法，将节点映射到路径上前一个节点的列表。这种方法非常适合本书中许多算法通过从一个节点到下一个节点来处理数据的方式。它既有显著的优点，也有显著的缺点。
- en: Consider the path [0, 1, 3, 2, 4, 7] shown in [Figure 3-3](#fig3-3). For each
    node along the path, we can indicate which node precedes it, as shown in the list
    <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>. The value <samp class="SANS_TheSansMonoCd_W5Regular_11">last[4]=2</samp>
    indicates that we get *to* node 4 *from* node 2\. We use the special value −1
    to indicate that a node does not have a preceding node. This can be due to the
    node either being the first node on the path (the origin of the path) or not being
    part of the path at all.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑路径[0, 1, 3, 2, 4, 7]，如[图3-3](#fig3-3)所示。对于路径中的每个节点，我们可以指示哪个节点在其之前，如列表<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>所示。值<samp class="SANS_TheSansMonoCd_W5Regular_11">last[4]=2</samp>表示我们是*从*节点2*到*节点4的。我们使用特殊值−1来表示一个节点没有前置节点。这可能是因为该节点要么是路径中的第一个节点（路径的起点），要么根本不属于路径。
- en: '![A graph with eight nodes has a path through it indicated by bolded arrows
    from node 0 to node one, node one to node three, node three to node two, node
    two to node four, and node four to node seven. Below the graph is an array labeled
    last and containing the values −1, 0, 3, 1, 2, −1, −1, 4.](../images/f03003.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含八个节点的图中，路径通过粗体箭头从节点0到节点1，从节点1到节点3，从节点3到节点2，从节点2到节点4，再从节点4到节点7。图下方是一个数组，标记为last，包含值−1，0，3，1，2，−1，−1，4。](../images/f03003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: A path through
    the graph and its representation as an array of previous nodes</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图3-3：图中的路径及其作为前置节点数组的表示</samp>
- en: The major disadvantage of this representation is that it limits the types of
    paths we can represent. Each node can have, at most, one preceding node. We cannot
    represent many paths that revisit nodes, such as [0, 1, 3, 0, 5, 3, 4, 7]. If
    we were to try to represent this path as an array of previous nodes, we would
    run into a problem with node 3’s <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    entry. Node 3 is preceded first by node 1 and then, later, by node 5\. While it
    is possible to define more complex lists of lists that handle these cases, we
    use the single list of indices because it is well suited to the algorithms in
    this book.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示方法的主要缺点是，它限制了我们可以表示的路径类型。每个节点最多只能有一个前置节点。我们无法表示许多会重新访问节点的路径，例如[0, 1, 3,
    0, 5, 3, 4, 7]。如果我们尝试将此路径表示为前置节点的数组，我们将遇到节点3的<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>条目的问题。节点3首先由节点1前置，随后又由节点5前置。虽然可以定义更复杂的列表来处理这些情况，但我们使用单一的索引列表，因为它非常适合本书中的算法。
- en: The major advantage of this representation is that it’s easy to update paths
    inside the algorithms because we need to change only a single index value. We
    will use this behavior again and again throughout later chapters to simplify the
    code. Another advantage is that this representation can capture multiple, branching
    paths. Unlike the previous two representations, which use a single fixed origin
    and destination nodes, the previous-node representation requires only a single
    fixed origin. The list can be used to extract a path from *any* destination node
    back to the origin.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示方法的主要优点是，更新路径非常容易，因为我们只需更改一个索引值。在后续章节中，我们将一遍又一遍地使用这种行为来简化代码。另一个优点是，这种表示方法可以捕捉多个分支路径。与前两种使用单一固定起点和终点节点的表示方法不同，前置节点表示法仅需要一个固定的起点。该列表可以用来从*任何*目标节点提取路径，回到起点。
- en: In the road trip analogy, the list-of-previous-nodes representation is equivalent
    to listing each city you *could* visit and the city from which you would travel
    to get there. If your plans change and you decide to visit Pittsburgh, you can
    follow the chain of previous nodes through Philadelphia and back to Boston. The
    list of previous visits provides information for all possible stops on trips out
    of the origin city.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在公路旅行类比中，前一个节点列表的表示相当于列出你*可能*访问的每个城市，以及你从哪个城市出发前往该城市。如果你的计划发生变化，决定访问匹兹堡，你可以通过费城和波士顿追踪前一个节点链。前一次访问的列表提供了从起始城市出发的所有可能停靠点的信息。
- en: Another useful analogy for this representation is the set of chalk marks that
    an adventurer makes while exploring a labyrinth, such as shown in [Figure 3-4](#fig3-4).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的类比是，冒险者在探索迷宫时所做的粉笔标记，如[图3-4](#fig3-4)所示。
- en: '![A maze constructed on a 4 × 4 grid. The start is at the top left corner and
    the exit is at the bottom left corner. Each grid cell contains an arrow pointing
    in the direction of the start.](../images/f03004.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![在一个4×4网格上构建的迷宫。起点位于左上角，出口位于左下角。每个网格单元中都有一个箭头，指向起点的方向。](../images/f03004.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-4: Chalk marks in
    a labyrinth indicating the direction you came from</samp>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图3-4：迷宫中的粉笔标记，指示你从哪里来</samp>
- en: Determined not to get lost, the adventurer draws a chalk arrow at every intersection,
    indicating the passage they used to get to the current room. These markings point
    backward along the path traveled. Such chalk marks have a distinct advantage over
    breadcrumbs in their overall information content, allowing the adventurer to find
    their way back to the start from any room in the dungeon. In particular, if they
    know the location of the exit, they can rebuild the path from the exit to the
    start.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不迷路，冒险者在每个交叉口画一个粉笔箭头，指示他们用来到达当前房间的通道。这些标记沿着走过的路径指向后方。这种粉笔标记相比面包屑具有明显的优势，因为它们的整体信息量更大，允许冒险者从地牢中的任何房间找到回到起点的路径。特别是，如果他们知道出口的位置，他们可以从出口重新构建回到起点的路径。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Translating a Previous-Node
    List into a List of Nodes</samp>
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">将前一个节点列表转换为节点列表</samp>
- en: 'To translate the previous-nodes representation into a list of nodes, we walk
    the pointers in the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    list backward from a given destination, as shown in the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将前一个节点的表示转化为节点列表，我们从给定的目标节点开始，倒着遍历<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>列表中的指针，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">make_node_path_from_last()</samp>
    function begins by compiling the path list in reverse and storing it in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">reverse_path</samp>, before reversing
    the order at the end. Initially, the code sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">reverse_path</samp>
    list as empty and starts at the end by setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp>
    node to the destination ❶. It uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop to traverse the path until it hits <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>,
    which indicates the lack of a previous node ❷. At each step in the loop, the code
    appends the current node to <samp class="SANS_TheSansMonoCd_W5Regular_11">reverse_path</samp>
    and moves to the preceding node as defined by <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    ❸. Finally, the code creates a reversed copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">reverse_path</samp>
    (the path in the correct order) and returns that list ❹.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">make_node_path_from_last()</samp>函数首先以反向的方式编译路径列表，并将其存储在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">reverse_path</samp>中，然后在最后将顺序反转。最初，代码将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">reverse_path</samp>列表设置为空，并从目标节点开始，设置<samp
    class="SANS_TheSansMonoCd_W5Regular_11">current</samp>节点为目标❶。它使用一个<samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环遍历路径，直到遇到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>，这表示没有前一个节点❷。在循环的每一步，代码将当前节点附加到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">reverse_path</samp>中，并根据<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>定义的前一个节点❸进行移动。最后，代码创建一个反向的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">reverse_path</samp>副本（即正确顺序的路径），并返回该列表❹。
- en: 'Let’s consider what happens when we apply the code to the graph in [Figure
    3-5(a)](#fig3-5) and a <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    array indicating paths starting from node 0:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑当我们将代码应用于 [图 3-5(a)](#fig3-5) 中的图，以及一个表示从节点 0 开始的路径的 <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    数组时会发生什么：
- en: '[−1, 0, 1, 2, 2, 0, 5, 0, 5, 8]'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[−1, 0, 1, 2, 2, 0, 5, 0, 5, 8]'
- en: '[Figure 3-5(b)](#fig3-5) shows the backward pointers on the graph. As we can
    see, the arrows point backward to the origin node. [Figure 3-5(c)](#fig3-5) reverses
    each point to demonstrate how we can reconstruct the forward path.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-5(b)](#fig3-5) 显示了图中的回溯指针。正如我们所见，箭头指向回到原点节点。[图 3-5(c)](#fig3-5) 反转每个点，以展示如何重建前向路径。'
- en: '![(A) shows an undirected graph with 10 nodes. (B) shows the same graph with
    arrows linking each node back a node closer to 0\. (C) shows the same graph as
    (B) with the arrows reversed.](../images/f03005.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![(A) 显示了一个具有 10 个节点的无向图。 (B) 显示了相同的图，箭头将每个节点连接回距离 0 更近的节点。 (C) 显示了与 (B) 相同的图，箭头被反转。](../images/f03005.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-5: An example graph
    (a), the last pointers created by a breadth-first search (b), and the corresponding
    forward paths through the graph (c)</samp>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-5：一个示例图（a），广度优先搜索创建的最后指针（b），以及通过图的相应前向路径（c）</samp>
- en: 'If we use node 9 as our destination (<samp class="SANS_TheSansMonoCd_W5Regular_11">dest=9</samp>),
    we build up the reverse path (represented as a list of nodes) as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将节点 9 作为目标节点（<samp class="SANS_TheSansMonoCd_W5Regular_11">dest=9</samp>），我们按以下方式构建反向路径（表示为节点列表）：
- en: '[9]'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[9]'
- en: '[9, 8]'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[9, 8]'
- en: '[9, 8, 5]'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[9, 8, 5]'
- en: '[9, 8, 5, 0]'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[9, 8, 5, 0]'
- en: The returned final path in this case is [0, 5, 8, 9].
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，返回的最终路径是 [0, 5, 8, 9]。
- en: As noted earlier, the previous-node representation allows us to represent paths
    from a single origin to all destinations in the graph. Because of this, it is
    often not possible to convert from a list-of-nodes or list-of-edges representation
    into a full list-of-previous-nodes representation. Returning to [Figure 3-5](#fig3-5),
    a list-of-nodes path from node 0 to node 3 would be [0, 1, 2, 3]. While this tells
    us everything we need to know about the path from node 0 to node 3, it does not
    tell us about paths from node 0 to any nodes that are *not* in the list. We could
    not use it to derive a path from node 0 to node 5.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，前节点表示法使我们能够表示从单个起始节点到图中所有目标节点的路径。因此，通常无法将节点列表或边列表表示法转换为完整的前节点列表表示法。回到 [图
    3-5](#fig3-5)，从节点 0 到节点 3 的节点列表路径为 [0, 1, 2, 3]。虽然这告诉我们从节点 0 到节点 3 的路径的所有信息，但它并没有告诉我们从节点
    0 到任何*不*在列表中的节点的路径。我们无法用它推导出从节点 0 到节点 5 的路径。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Checking the Validity of a
    Previous-Node List</samp>
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">检查前节点列表的有效性</samp>
- en: 'To test the validity of this type of path, we iterate over all entries in the
    list and check that either the previous node is −1, or the edge exists:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这种路径类型的有效性，我们遍历列表中的所有条目，并检查前节点是否为 −1，或者边是否存在：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">check_last_path_valid()</samp>
    code first checks that the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    list has the correct number of entries ❶. Even if all the entries are −1, there
    needs to be an entry for every node.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">check_last_path_valid()</samp>
    代码首先检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> 列表是否具有正确的条目数量
    ❶。即使所有条目都是 −1，仍然需要为每个节点提供一个条目。
- en: The code then iterates through the list using Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">enumerate()</samp>
    function, where <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp> is
    the index of <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> currently
    being examined and <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>
    is the corresponding value. The code checks that either <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>
    is –1, indicating that there is no previous node on the path, or that the combination
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>
    corresponds to a valid edge ❷. If neither case holds, the code immediately returns
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. If every entry in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> is valid, the code returns
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后代码使用Python的<samp class="SANS_TheSansMonoCd_W5Regular_11">enumerate()</samp>函数遍历列表，其中<samp
    class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>是当前正在检查的<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>的索引，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>是相应的值。代码检查是否<samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>为-1，表示路径上没有前一个节点，或者<samp
    class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>的组合对应有效边
    ❷。如果两者都不成立，代码立即返回<samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>中的每个条目都是有效的，代码返回<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。
- en: In the context of our road trip example, this function iterates over each city
    in our list and asks, “Can we get there directly from the listed previous city?”
    We would approve an entry for Pittsburgh that has a previous node of Philadelphia
    or Erie. However, we would soundly reject an entry for Boston with a previous
    node of Santa Fe.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的公路旅行示例中，这个函数遍历列表中的每个城市，并询问：“我们能直接从上一个城市到达那里吗？”我们会批准匹兹堡（Pittsburgh）的一个条目，该条目的前一个节点是费城（Philadelphia）或伊利（Erie）。然而，我们会坚决拒绝一个前一个节点为圣塔菲（Santa
    Fe）的波士顿（Boston）条目。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Calculating Path Cost</samp>
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">计算路径成本</samp>
- en: For many use cases, we may be interested not only in which edges to use to compose
    the path but also an overall measure of either the benefits or cost of the path
    as a whole. As we saw in [Chapter 1](chapter1.xhtml), we can use edge weights
    to capture the cost of traversing between two nodes, such as using them to model
    the distance between cities on our road trip. When planning a flight itinerary
    from Boston to Seattle, we might skip the edge from Boston to Miami because of
    its nearly 1,500-mile cost.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多使用案例，我们不仅可能对使用哪些边来构建路径感兴趣，还可能对路径整体的效益或成本有一个总体的度量。正如我们在[第一章](chapter1.xhtml)中看到的，我们可以使用边的权重来捕捉两个节点之间的遍历成本，例如在公路旅行中使用它们来模拟城市之间的距离。当我们规划从波士顿到西雅图的航班行程时，可能会跳过波士顿到迈阿密的边，因为它的成本接近1,500英里。
- en: 'We define the *cost of a path* in a weighted graph as the sum of the edge weights
    along that path. Formally, we say that for a path [*e*[0], *e*[1], . . . , *e*k]:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在加权图中定义*路径的成本*为沿路径的所有边权重的总和。形式上，我们说，对于一个路径[*e*[0], *e*[1], . . . , *e*k]：
- en: '*PathCost*([*e*[0], *e*[1], . . . , *e*k]) = *∑*i = [1] to k *e*i.<samp class="SANS_TheSansMonoCd_W5Regular_11">weight</samp>'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*PathCost*([*e*[0], *e*[1], . . . , *e*k]) = *∑*i = [1] to k *e*i.<samp class="SANS_TheSansMonoCd_W5Regular_11">weight</samp>'
- en: The cost of the path [0, 3, 4, 2] in [Figure 3-6](#fig3-6) would be 1.0 + 3.0
    + 5.0 = 9.0.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-6](#fig3-6)中路径[0, 3, 4, 2]的成本为1.0 + 3.0 + 5.0 = 9.0。'
- en: '![A graph with six nodes and weighted, directed edges. The arrow from node
    0 to node 3 is labeled 1.0\. The arrow from node 3 to node 4 is labeled 3.0\.
    The arrow from node 4 to node 2 is labeled 5.0.](../images/f03006.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![一个带有六个节点和加权有向边的图。箭头从节点 0 指向节点 3，标记为 1.0。箭头从节点 3 指向节点 4，标记为 3.0。箭头从节点 4 指向节点
    2，标记为 5.0。](../images/f03006.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-6: A weighted, directed
    graph with six nodes</samp>'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-6：带有六个节点的加权有向图</samp>
- en: For unweighted graphs, we often use a unit value of 1.0 for each edge and thus
    compute the cost as the number of edges used.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无权图，我们通常使用每条边的单位值1.0，因此计算成本为使用的边的数量。
- en: If we have a list of edges representing our path, we compute the cost of the
    path by iterating over those edges, as shown in [Listing 3-1](#list3-1).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个表示路径的边列表，我们可以通过遍历这些边来计算路径的成本，如[清单 3-1](#list3-1)中所示。
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-1: A function to
    compute the total path cost</samp>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-1：计算总路径成本的函数</samp>
- en: The code starts by checking that the path has at least one edge and, if not,
    returning a cost of <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp> ❶.
    It also initializes variables to track the total cost (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>)
    and the previous node seen (<samp class="SANS_TheSansMonoCd_W5Regular_11">prev_node</samp>).
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">prev_node</samp> variable is
    used to assess the validity of the path.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先检查路径是否至少包含一条边，如果没有，则返回成本 <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>
    ❶。它还初始化了用于跟踪总成本 (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>) 和之前看到的节点
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">prev_node</samp>) 的变量。<samp class="SANS_TheSansMonoCd_W5Regular_11">prev_node</samp>
    变量用于评估路径的有效性。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">compute_path_cost_from_edges()</samp>
    function computes the cost of a path iterating through each edge in the list.
    It checks that the origin of the current edge matches the last node ❷. If the
    nodes do not match, the path is invalid. For example, an edge list of [(0, 1),
    (2, 3), (3, 4)] would be invalid because you cannot jump from node 1 to node 2
    without an edge between the two nodes. If the transition is valid, the edge’s
    weight is added to the cost. If the transition is invalid, we use an infinite
    weight. Depending on the implementation, the programmer might want to raise an
    exception, exit the program, or use some other method to indicate an error. The
    code updates the <samp class="SANS_TheSansMonoCd_W5Regular_11">prev_node</samp>
    variable to track the new current location.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">compute_path_cost_from_edges()</samp>
    函数计算路径的成本，通过遍历列表中的每条边。它检查当前边的起点是否与最后一个节点匹配 ❷。如果节点不匹配，则路径无效。例如，边列表 [(0, 1), (2,
    3), (3, 4)] 就无效，因为没有一条边连接节点 1 和节点 2，无法直接从节点 1 跳到节点 2。如果转换有效，则将边的权重加到成本中。如果转换无效，则使用无穷大的权重。根据实现方式，程序员可能会选择抛出异常、退出程序或使用其他方法来表示错误。代码更新
    <samp class="SANS_TheSansMonoCd_W5Regular_11">prev_node</samp> 变量来跟踪新的当前位置。
- en: The code continues through the list, checking each edge and summing their weights.
    When it has finished each edge in the list, it returns the total cost with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">return cost</samp>.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 代码继续遍历列表，检查每条边并计算其权重的总和。当它完成列表中的每一条边时，它返回总成本，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">return
    cost</samp>。
- en: Unlike other functions in this chapter, we intentionally do not pass in a graph
    to this implementation to demonstrate how we can operate on a pure list of edges.
    The downside to this simplicity is that the function cannot validate the path
    against the graph itself. We could extend the function to perform an additional
    check by passing in the graph and using it to validate both the node indices and
    the edges’ existence. The code for these additional checks follows the approach
    shown in other functions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章其他函数不同，我们有意没有向此实现传递图，以演示如何仅在纯边列表上操作。这种简单性的缺点是该函数无法验证路径与图本身的一致性。我们可以通过传递图并使用它来验证节点索引和边的存在，扩展该函数以执行额外的检查。执行这些额外检查的代码遵循其他函数中的方法。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Reachability</samp>
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">可达性</samp>
- en: 'We can use the formulations of paths to formalize another important question
    on graphs: “Is node *v* reachable from node *u*?” This question is vital to a
    range of real-world problems. In a transportation network, it translates into
    the question, “Can we get to city *v* from city *u*?” In a social network, it
    translates into the question, “Can a rumor spread from person *u* to person *v*?”
    And in a dungeon labyrinth, it translates into the vital question, “Can I get
    from here to the exit?”'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用路径的公式化来形式化图中的另一个重要问题：“节点 *v* 是否可以从节点 *u* 到达？”这个问题对许多现实世界的问题至关重要。在交通网络中，它转化为问题：“我们能否从城市
    *u* 到达城市 *v*？”在社交网络中，它转化为问题：“谣言能否从人 *u* 传播到人 *v*？”在迷宫中，它转化为至关重要的问题：“我能从这里到达出口吗？”
- en: We say that node *v* is *reachable* from node *u* if there exists a path that
    starts at node *u* and ends at node *v*. Given a candidate path, we can use any
    one of our validity checkers from earlier in this chapter to test whether it is
    valid.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说节点 *v* 可以从节点 *u* 达到，当且仅当从节点 *u* 出发并到达节点 *v* 存在一条路径。给定一个候选路径，我们可以使用本章前面介绍的任何有效性检查器来测试该路径是否有效。
- en: Imagine you are trapped in a castle dungeon represented by the graph in [Figure
    3-7](#fig3-7). The edges indicate which adjacent rooms have an unlocked door between
    them. To escape from the evil wizard, you need to navigate to a room with a staircase
    to the upper floor. Here, the reachability question is vital. If you start in
    room 0 and need to navigate to node 15, you are out of luck. Node 15 is not reachable
    from node 0.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被困在图 [图 3-7](#fig3-7) 所表示的城堡地牢中。边表示相邻房间之间有无锁的门。为了逃离邪恶的巫师，你需要找到一间有通往楼上的楼梯的房间。在这里，可达性问题至关重要。如果你从房间
    0 出发并且需要到达节点 15，那你就不走运了。节点 15 无法从节点 0 到达。
- en: '![A graph with 16 nodes is arranged as a 4 × 4 square. The nodes 10, 11, 14,
    and 15 are connected to each other, but not to the other nodes.](../images/f03007.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含16个节点的图被安排为一个 4 × 4 的方形。节点 10、11、14 和 15 彼此相连，但与其他节点没有连接。](../images/f03007.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-7: A graph representing
    connectivity among rooms in a castle dungeon</samp>'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-7：表示城堡地牢中各房间连接关系的图</samp>
- en: 'In an undirected graph, we can divide the nodes into disjoint sets called *connected
    components* such that any node in a connected component is reachable from any
    other node. Given a subset of nodes *V*′ ⊆ *V*, we say that a connected component
    is a maximal set of nodes such that:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在无向图中，我们可以将节点划分为不相交的集合，称为*连通分量*，使得每个连通分量中的任意节点都可以从该分量中的其他节点到达。给定节点子集 *V*′ ⊆
    *V*，我们可以说一个连通分量是一个最大节点集，使得：
- en: '*reachable*(*u*, *v*) for all *u* ∈ *V*′ and *v* ∈ *V*′'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*reachable*(*u*, *v*) 对所有 *u* ∈ *V*′ 和 *v* ∈ *V*′成立'
- en: In the context of our dungeon example from [Figure 3-7](#fig3-7), the map consists
    of the two connected components {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 13} and {10,
    11, 14, 15}. We are okay if the stairs out of the dungeon are in the same connected
    component as our current room. Otherwise, we are trapped.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们来自 [图 3-7](#fig3-7) 的地牢示例中，地图由两个连通分量 {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 13}
    和 {10, 11, 14, 15} 组成。如果楼梯在与当前房间相同的连通分量中，我们就没问题。否则，我们就被困住了。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">为什么这很重要</samp>
- en: We will use the concept of paths throughout the book to solve problems spanning
    from path planning to optimizing flow through a capacity-limited network. Paths
    will be a fundamental unit of data used throughout many of the algorithms and
    will be one of the most common results computed by the functions. Concepts like
    reachability and path cost will be foundational in numerous algorithms, from finding
    strongly connected components in [Chapter 11](chapter11.xhtml) to performing matching
    on bipartite graphs in [Chapter 15](chapter15.xhtml).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用路径的概念来解决从路径规划到优化通过容量有限网络的流量等问题。路径将成为许多算法中使用的基本数据单元，并且是函数计算的最常见结果之一。诸如可达性和路径代价等概念将是众多算法的基础，从
    [第 11 章](chapter11.xhtml) 中找到强连通分量，到在 [第 15 章](chapter15.xhtml) 中对二分图进行匹配。
- en: In addition to their computational usefulness, paths can help us visualize the
    operation of algorithms in a real-world context. Instead of an abstract “sequence
    of edges,” it helps to visualize paths as their real-world counterparts. This
    chapter repeatedly made use of the road trip analogy to map edges to roads across
    the country. We can similarly imagine physically walking paths through many of
    the algorithms discussed in this book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在计算上的实用性，路径还可以帮助我们在现实世界的背景下可视化算法的操作。与其把路径看作抽象的“边的序列”，不如将路径想象成它们在现实世界中的对应物。本章反复使用公路旅行的类比，将边映射为跨越全国的道路。我们同样可以想象，通过本书讨论的许多算法物理地走过这些路径。
- en: The next chapter builds upon the concept of paths, considering multiple algorithms
    that explore graphs and return the paths taken. These paths provide important
    information about both the functionality of the search and the ability to navigate
    through the graph.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将在路径的概念基础上，探讨多种探索图并返回所经过路径的算法。这些路径提供了关于搜索功能和在图中导航能力的重要信息。
