<html><head></head><body>
<h2 class="h2" id="ch16"><span epub:type="pagebreak" id="page_523"/><strong><span class="big">16</span><br/>STREAMS</strong></h2>&#13;
<p class="quote"><em>Either write something worth reading or do something worth writing.<br/>—Benjamin Franklin</em></p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">This chapter introduces streams, the major concept that enables you to connect inputs from any kind of source and outputs to any kind of destination using a common framework. You’ll learn about the classes that form the base elements of this common framework, several built-in facilities, and how to incorporate streams into user-defined types.</p>&#13;
<h3 class="h3" id="ch16lev1sec1"><strong>Streams</strong></h3>&#13;
<p class="noindent">A <em>stream</em> models a <em>stream of data</em>. In a stream, data flows between objects, and those objects can perform arbitrary processing on the data. When you’re working with streams, output is data going into the stream and input is data coming out of the stream. These terms reflect the streams as viewed from the user’s perspective.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_524"/>In C++, streams are the primary mechanism for performing input and output (I/O). Regardless of the source or destination, you can use streams as the common language to connect inputs to outputs. The STL uses class inheritance to encode the relationships between various stream types. The primary types in this hierarchy are:</p>&#13;
<ul>&#13;
<li class="noindent">The <span class="literal">std::basic_ostream</span> class template in the <span class="literal">&lt;ostream&gt;</span> header that represents an output device</li>&#13;
<li class="noindent">The <span class="literal">std::basic_istream</span> class template in the <span class="literal">&lt;istream&gt;</span> header that represents an input device</li>&#13;
<li class="noindent">The <span class="literal">std::basic_iostream</span> class template in the <span class="literal">&lt;iostream</span><span class="literal">&gt;</span> header for devices that are input and output</li>&#13;
</ul>&#13;
<p class="indent">All three stream types require two template parameters. The first corresponds to the stream’s underlying data type and the second to a traits type.</p>&#13;
<p class="indent">This section covers streams from a user’s perspective rather than from a library implementer’s perspective. You’ll understand the streams interface and know how to interact with standard I/O, files, and strings using the STL’s built-in stream support. If you must implement a new kind of stream (for example, for a new library or framework), you’ll need a copy of the ISO C++ 17 Standard, some working examples, and an ample supply of coffee. I/O is complicated, and you’ll see this difficulty reflected in a stream implementation’s internal complexity. Fortunately, a well-designed stream class hides much of this complexity from users.</p>&#13;
<h4 class="h4" id="ch16lev2sec1"><strong><em>Stream Classes</em></strong></h4>&#13;
<p class="noindent">All STL stream classes that users interact with derive from <span class="literal">basic_istream, basic_ostream</span>, or both via <span class="literal">basic_iostream</span>. The headers that declare each type also provide <span class="literal">char</span> and <span class="literal">wchar_t</span> specializations for those templates, as outlined in <a href="ch16.xhtml#ch16tab01">Table 16-1</a>. These heavily used specializations are particularly useful when you’re working with human-language data input and output.</p>&#13;
<p class="tabcap" id="ch16tab01"><strong>Table 16-1:</strong> Template Specializations for the Primary Stream Templates</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Template</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Parameter</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Specialization</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Header</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">basic_istream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">char</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">istream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">&lt;istream&gt;</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">basic_ostream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">char</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">ostream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">&lt;ostream&gt;</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">basic_iostream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">char</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">iostream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">&lt;iostream&gt;</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">basic_istream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">wchar_t</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">wistream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">&lt;istream&gt;</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">basic_ostream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">wchar_t</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">wostream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">&lt;ostream&gt;</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">basic_iostream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">wchar_t</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">wiostream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">&lt;iostream&gt;</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The objects in <a href="ch16.xhtml#ch16tab01">Table 16-1</a> are abstractions that you can use in your programs to write generic code. Do you want to write a function that logs output to an arbitrary source? If so, you can accept an <span class="literal">ostream</span> reference <span epub:type="pagebreak" id="page_525"/>parameter and not deal with all the nasty implementation details. (Later in the “Output File Streams” on <a href="ch16.xhtml#page_542">page 542</a>, you’ll learn how to do this.)</p>&#13;
<p class="indent">Often, you’ll want to perform I/O with the user (or the program’s environment). Global stream objects provide a convenient, stream-based wrapper for you to work against.</p>&#13;
<h5 class="h5" id="ch16lev3sec1"><strong>Global Stream Objects</strong></h5>&#13;
<p class="noindent">The STL provides several <em>global stream objects</em> in the <span class="literal">&lt;iostream&gt;</span> header that wrap the input, output, and error streams stdin, stdout, and stderr. These implementation-defined standard streams are preconnected channels between your program and its executing environment. For example, in a desktop environment, stdin typically binds to the keyboard and stdout and stderr bind to the console.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Recall that in <a href="part01.xhtml#part01">Part I</a> you saw extensive use of <span class="literal">printf</span> to write to stdout.</em></p>&#13;
</div>&#13;
<p class="indent"><a href="ch16.xhtml#ch16tab02">Table 16-2</a> lists the global stream objects, all of which reside in the <span class="literal">std</span> namespace.</p>&#13;
<p class="tabcap" id="ch16tab02"><strong>Table 16-2:</strong> The Global Stream Objects</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Object</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Type</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Purpose</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">cout</span></p>&#13;
<p class="taba"><span class="literal">wcout</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">ostream</span></p>&#13;
<p class="taba"><span class="literal">wostream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Output, like a screen</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">cin</span></p>&#13;
<p class="taba"><span class="literal">wcin</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">istream</span></p>&#13;
<p class="taba"><span class="literal">wistream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Input, like a keyboard</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">cerr</span></p>&#13;
<p class="taba"><span class="literal">wcerr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">ostream</span></p>&#13;
<p class="taba"><span class="literal">wostream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Error output (unbuffered)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">clog</span></p>&#13;
<p class="taba"><span class="literal">wclog</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">ostream</span></p>&#13;
<p class="taba"><span class="literal">wostream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Error output (buffered)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">So how do you use these objects? Well, stream classes support operations that you can partition into two categories:</p>&#13;
<p class="bq"><strong>Formatted operations</strong> Might perform some preprocessing on their input parameters before performing I/O</p>&#13;
<p class="bq"><strong>Unformatted operations</strong> Perform I/O directly</p>&#13;
<p class="indent">The following sections explain each of these categories in turn.</p>&#13;
<h5 class="h5" id="ch16lev3sec2"><strong>Formatted Operations</strong></h5>&#13;
<p class="noindent">All formatted I/O passes through two functions: the <em>standard stream operators</em>, <span class="literal">operator&lt;&lt;</span> and <span class="literal">operator&gt;&gt;</span>. You’ll recognize these as the left and right shift operators from “Logical Operators” on <a href="ch07.xhtml#page_182">page 182</a>. Somewhat confusingly, streams overload the left and right shift operators with completely unrelated functionality. The semantic meaning of the expression <span class="literal">i &lt;&lt; 5</span> depends entirely on the type of <span class="literal">i</span>. If <span class="literal">i</span> is an integral type, this expression means <em>take</em> <span epub:type="pagebreak" id="page_526"/><span class="codeitalic">i</span> <em>and shift the bits to the left by five binary digits</em>. If <span class="literal">i</span> is not an integral type, it means <em>write the value 5 into</em> <span class="codeitalic">i</span>. Although this notational collision is unfortunate, in practice it doesn’t cause too much trouble. Just pay attention to the types you’re using and test your code well.</p>&#13;
<p class="indent">Output streams overload <span class="literal">operator&lt;&lt;</span>, which is referred to as the <em>output operator</em> or the <em>inserter</em>. The <span class="literal">basic_ostream</span> class template overloads the output operator for all fundamental types (except <span class="literal">void</span> and <span class="literal">nullptr_t</span>) and some STL containers, such as <span class="literal">basic_string, complex</span>, and <span class="literal">bitset</span>. As an <span class="literal">ostream</span> user, you need not worry about how these overloads translate objects into readable output.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16ex01">Listing 16-1</a> illustrates how to use the output operator to write various types into <span class="literal">cout</span>.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
#include &lt;bitset&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  bitset&lt;8&gt; s{ "01110011" };&#13;
  string str("Crying zeros and I'm hearing ");&#13;
  size_t num{ 111 };&#13;
  cout &lt;&lt; s; <span class="ent">➊</span>&#13;
  cout &lt;&lt; '\n'; <span class="ent">➋</span>&#13;
  cout &lt;&lt; str; <span class="ent">➌</span>&#13;
  cout &lt;&lt; num; <span class="ent">➍</span>&#13;
  cout &lt;&lt; "s\n"; <span class="ent">➎</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">01110011 <span class="ent">➊</span><span class="ent">➋</span></span>&#13;
<span class="color1">Crying zeros and I'm hearing 111s <span class="ent">➌</span><span class="ent">➍</span><span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch16ex01"/><em>Listing 16-1: Using <span class="literal">cout</span> and <span class="literal">operator&lt;&lt;</span> to write into stdout</em></p>&#13;
<p class="indent">You use the output <span class="literal">operator</span><span class="literal">&lt;&lt;</span> to write a <span class="literal">bitset</span> <span class="ent">➊</span>, a <span class="literal">char</span> <span class="ent">➋</span>, a <span class="literal">string</span> <span class="ent">➌</span>, a <span class="literal">size_t</span> <span class="ent">➍</span>, and a null-terminated string literal <span class="ent">➎</span> to stdout via <span class="literal">cout</span>. Even though you write five distinct types to the console, you never deal with serialization issues. (Consider the hoops you would have had to jump through to get <span class="literal">printf</span> to yield similar output given these types.)</p>&#13;
<p class="indent">One very nice feature of the standard stream operators is that they generally return a reference to the stream. Conceptually, overloads are typically defined along the following lines:</p>&#13;
<pre>ostream&amp; operator&lt;&lt;(ostream&amp;, char);</pre>&#13;
<p class="indent">This means you can chain output operators together. Using this technique, you can refactor <a href="ch16.xhtml#ch16ex01">Listing 16-1</a> so <span class="literal">cout</span> appears only once, as <a href="ch16.xhtml#ch16ex02">Listing 16-2</a> illustrates.</p>&#13;
<pre><span epub:type="pagebreak" id="page_527"/>#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
#include &lt;bitset&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  bitset&lt;8&gt; s{ "01110011" };&#13;
  string str("Crying zeros and I'm hearing ");&#13;
  size_t num{ 111 };&#13;
  cout &lt;&lt; s &lt;&lt; '\n' &lt;&lt; str &lt;&lt; num &lt;&lt; "s\n"; <span class="ent">➊</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">01110011</span>&#13;
<span class="color1">Crying zeros and I'm hearing 111s <span class="ent">➊</span></span></pre>&#13;
<p class="listing"><a id="ch16ex02"/><em>Listing 16-2: Refactoring <a href="ch16.xhtml#ch16ex01">Listing 16-1</a> by chaining output operators together</em></p>&#13;
<p class="indent">Because each invocation of <span class="literal">operator&lt;&lt;</span> returns a reference to the output stream (here, <span class="literal">cout</span>), you simply chain the calls together to obtain identical output <span class="ent">➊</span>.</p>&#13;
<p class="indent">Input streams overload <span class="literal">operator&gt;&gt;</span>, which is referred to as the <em>input operator</em> or the <em>extractor</em>. The <span class="literal">basic_istream</span> class has corresponding overloads for the input operator for all the same types as <span class="literal">basic_ostream</span>, and again as a user, you can largely ignore the deserialization details.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16ex03">Listing 16-3</a> illustrates how to use the input operator to read two <span class="literal">double</span> objects and a <span class="literal">string</span> from <span class="literal">cin</span>, then print the implied mathematical operation’s result to stdout.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  double x, y;&#13;
  cout &lt;&lt; "X: ";&#13;
  cin &gt;&gt; x; <span class="ent">➊</span>&#13;
  cout &lt;&lt; "Y: ";&#13;
  cin &gt;&gt; y; <span class="ent">➋</span>&#13;
&#13;
  string op;&#13;
  cout &lt;&lt; "Operation: ";&#13;
  cin &gt;&gt; op; <span class="ent">➌</span>&#13;
  if (op == "+") {&#13;
    cout &lt;&lt; x + y; <span class="ent">➍</span>&#13;
  } else if (op == "-") {&#13;
    cout &lt;&lt; x - y; <span class="ent">➎</span>&#13;
  } else if (op == "*") {&#13;
    cout &lt;&lt; x * y; <span class="ent">➏</span>&#13;
  } else if (op == "/") {&#13;
<span epub:type="pagebreak" id="page_528"/>    cout &lt;&lt; x / y; <span class="ent">➐</span>&#13;
  } else {&#13;
    cout &lt;&lt; "Unknown operation " &lt;&lt; op; <span class="ent">➑</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch16ex03"/><em>Listing 16-3: A primitive calculator program using <span class="literal">cin</span> and <span class="literal">operator&lt;&lt;</span> to collect input</em></p>&#13;
<p class="indent">Here, you collect two <span class="literal">double</span>s <span class="literal">x</span> <span class="ent">➊</span> and <span class="literal">y</span> <span class="ent">➋</span> followed by the <span class="literal">string op</span> <span class="ent">➌</span>, which encodes the desired operation. Using an <span class="literal">if</span> statement, you can output the specified operation’s result for addition <span class="ent">➍</span>, subtraction <span class="ent">➎</span>, multiplication <span class="ent">➏</span>, and division <span class="ent">➐</span>, or indicate to the user that <span class="literal">op</span> is unknown <span class="ent">➑</span>.</p>&#13;
<p class="indent">To use the program, you type the requested values into the console when directed. A newline will send the input (as stdin) to <span class="literal">cin</span>, as <a href="ch16.xhtml#ch16ex04">Listing 16-4</a> illustrates.</p>&#13;
<pre>X: 3959 <span class="ent">➊</span>&#13;
Y: 6.283185 <span class="ent">➋</span>&#13;
Operation: * <span class="ent">➌</span>&#13;
24875.1 <span class="ent">➍</span></pre>&#13;
<p class="listing"><a id="ch16ex04"/><em>Listing 16-4: A sample run of the program in <a href="ch16.xhtml#ch16ex03">Listing 16-3</a> that calculates the circumference of Earth in miles</em></p>&#13;
<p class="indent">You input the two <span class="literal">double</span> objects: the radius of Earth in miles, <span class="literal">3959</span> <span class="ent">➊</span> and 2π, 6.283185 <span class="ent">➋</span>, and you specify multiplication <span class="literal">*</span> <span class="ent">➌</span>. The result is Earth’s circumference in miles <span class="ent">➍</span>. Note that you don’t need to provide a decimal point for an integral value <span class="ent">➊</span>; the stream is smart enough to know that there’s an implicit decimal.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You might wonder what happens in <a href="ch16.xhtml#ch16ex04">Listing 16-4</a> if you input a non-numeric string for <span class="literal">X</span> <span class="ent">➊</span> or <span class="literal">Y</span> <span class="ent">➋</span>. The stream enters an error state, which you’ll learn about later in this chapter in the “Stream State” section on  <a href="ch16.xhtml#page_530">page 530</a>. In an error state, the stream ceases to accept input, and the program won’t accept any more input.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec3"><strong>Unformatted Operations</strong></h5>&#13;
<p class="noindent">When you’re working with text-based streams, you’ll usually want to use formatted operators; however, if you’re working with binary data or if you’re writing code that needs low-level access to streams, you’ll want to know about the unformatted operations. Unformatted I/O involves a lot of detail. For brevity, this section provides a summary of the relevant methods, so if you need to use unformatted operations, refer to [input.output].</p>&#13;
<p class="indent">The <span class="literal">istream</span> class has many unformatted input methods. These methods manipulate streams at the byte level and are summarized in <a href="ch16.xhtml#ch16tab03">Table 16-3</a>. In this table, <span class="literal">is</span> is of type <span class="literal">std::istream &lt;T&gt;, s</span> is a <span class="literal">char*, n</span> is a stream size, <span class="literal">pos</span> is a position type, and <span class="literal">d</span> is a delimiter of type <span class="literal">T</span>.</p>&#13;
<p class="tabcap" id="ch16tab03"><span epub:type="pagebreak" id="page_529"/><strong>Table 16-3:</strong> Unformatted Read Operations for <span class="literal">istream</span></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Method</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">is.</span><span class="literal">get([</span><span class="codestrong">c</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns next character or writes to character reference <span class="codestrong">c</span> if provided.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">is.</span><span class="literal">get(</span><span class="codestrong">s</span>,  <span class="codestrong">n</span>, <span class="literal">[</span><span class="codestrong">d</span><span class="literal">])</span></p>&#13;
<p class="taba"><span class="codestrong">is.</span><span class="literal">getline(</span><span class="codestrong">s</span>,  <span class="codestrong">n</span>, <span class="literal">[</span><span class="codestrong">d</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The operation <span class="literal">get</span> reads up to <span class="codestrong">n</span> characters into the buffer <span class="codestrong">s</span>, stopping if it encounters a newline, or <span class="codestrong">d</span> if provided. The operation <span class="literal">getline</span> is the same except it reads the newline character as well. Both write a terminating null character to <span class="codestrong">s</span>. You must ensure <span class="literal">s</span> has enough space.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">is.</span><span class="literal">read(</span><span class="codestrong">s</span>,  <span class="codestrong">n</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="codestrong">is.</span><span class="literal">readsome(</span><span class="codestrong">s</span>,  <span class="codestrong">n</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">The operation <span class="literal">read</span> reads up to <span class="codestrong">n</span> characters into the buffer <span class="codestrong">s</span>; encountering end of file is an error. The operation <span class="literal">readsome</span> is the same except it doesn’t consider end of file an error.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">is.</span><span class="literal">gcount()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the number of characters read by <span class="codestrong">is</span>’s last unformatted read operation.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">is.</span><span class="literal">ignore()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Extracts and discards a single character.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">is.</span><span class="literal">ignore(</span><span class="codestrong">n</span>, <span class="literal">[</span><span class="codestrong">d</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Extracts and discards up to <span class="codestrong">n</span> characters. If <span class="codestrong">d</span> is provided, <span class="literal">ignore</span> stops if <span class="codestrong">d</span> is found.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">is.</span><span class="literal">peek()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the next character to be read without extracting.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">is.</span><span class="literal">unget()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Puts the last extracted character back into the string.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">is.</span><span class="literal">putback(</span><span class="codestrong">c</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">If <span class="literal">c</span> is the last character extracted, executes <span class="literal">unget</span>. Otherwise, sets the <span class="literal">badbit</span>. Explained in the “Stream State” section.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Output streams have corollary unformatted write operations, which manipulate streams at a very low level, as summarized in <a href="ch16.xhtml#ch16tab04">Table 16-4</a>. In this table, <span class="literal">os</span> is of type <span class="literal">std::ostream &lt;T&gt;</span><span class="literal">, s</span> is a <span class="literal">char*</span>, and <span class="literal">n</span> is a stream size.</p>&#13;
<p class="tabcap" id="ch16tab04"><strong>Table 16-4:</strong> Unformatted Write Operations for <span class="literal">ostream</span></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Method</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">os.</span><span class="literal">put(</span><span class="codestrong">c</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Writes <span class="codestrong">c</span> to the stream</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">os.</span><span class="literal">write(</span><span class="codestrong">s</span>,  <span class="codestrong">n</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Writes <span class="codestrong">n</span> characters from <span class="codestrong">s</span> to the stream</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">os.</span><span class="literal">flush()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Writes all buffered data to the underlying device</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h5 class="h5" id="ch16lev3sec4"><strong>Special Formatting for Fundamental Types</strong></h5>&#13;
<p class="noindent">All fundamental types, in addition to <span class="literal">void</span> and <span class="literal">nullptr</span>, have input and output operator overloads, but some have special rules:</p>&#13;
<p class="bq"><span class="codestrong">char</span> <strong>and</strong> <span class="codestrong">wchar_t</span> The input operator skips whitespace when assigning character types.</p>&#13;
<p class="bq"><span class="codestrong">char*</span> <strong>and</strong> <span class="codestrong">wchar_t*</span> The input operator first skips whitespace and then reads the string until it encounters another whitespace or an end-of-file (EOF). You must reserve enough space for the input.</p>&#13;
<p class="bq"><span epub:type="pagebreak" id="page_530"/><span class="codestrong">void*</span> Address formats are implementation dependent for input and output operators. On desktop systems, addresses take hexadecimal literal form, such as <span class="literal">0x01234567</span> for 32-bit or <span class="literal">0x0123456789abcdef</span> for 64-bit.</p>&#13;
<p class="bq"><span class="codestrong">bool</span> The input and output operators treat Boolean values as numbers: 1 for <span class="literal">true</span> and 0 for <span class="literal">false</span>.</p>&#13;
<p class="bq"><strong>Numeric types</strong> The input operator requires that input begin with at least one digit. Badly formed input numbers yield a zero-valued result.</p>&#13;
<p class="indent">These rules might seem a bit strange at first, but they’re fairly straightforward once you get used to them.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Avoid reading into C-style strings, because it’s up to you to ensure that you’ve allocated enough space for the input data. Failure to perform adequate checking results in undefined behavior and possibly major security vulnerabilities. Use <span class="literal">std::string</span> instead.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch16lev2sec2"><strong><em>Stream State</em></strong></h4>&#13;
<p class="noindent">A stream’s state indicates whether I/O failed. Each stream type exposes the constant static members referred to collectively as its <em>bits</em>, which indicate a possible stream state: <span class="literal">goodbit, badbit, eofbit</span>, and <span class="literal">failbit</span>. To determine whether a stream is in a particular state, you invoke member functions that return a <span class="literal">bool</span> indicating whether the stream is in the corresponding state. <a href="ch16.xhtml#ch16tab05">Table 16-5</a> lists these member functions, the stream state corresponding to a <span class="literal">true</span> result, and the state’s meaning.</p>&#13;
<p class="tabcap" id="ch16tab05"><strong>Table 16-5:</strong> The Possible Stream States, Their Accessor Methods, and Their Meanings</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Method</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>State</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Meaning</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">good()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">goodbit</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">The stream is in a good working state.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">eof()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">eofbit</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The stream encountered an EOF.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">fail()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">failbit</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">An input or output operation failed, but the stream might still be in a good working state.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">bad()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">badbit</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">A catastrophic error occurred, and the stream is not in a good state.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>To reset a stream’s status to indicate a good working state, you can invoke its <span class="literal">clear()</span> method.</em></p>&#13;
</div>&#13;
<p class="indent">Streams implement an implicit bool conversion (<span class="literal">operator bool</span>), so you can check whether a stream is in a good working state simply and directly. For example, you can read input from stdin word by word until it encounters an EOF (or some other failure condition) using a simple <span class="literal">while</span> loop. <a href="ch16.xhtml#ch16ex05">Listing 16-5</a> illustrates a simple program that uses this technique to generate word counts from stdin.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
int main() {&#13;
  std::string word; <span class="ent">➊</span>&#13;
  size_t count{}; <span class="ent">➋</span>&#13;
  while (std::cin &gt;&gt; word) <span class="ent">➌</span>&#13;
    count++; <span class="ent">➍</span>&#13;
  std::cout &lt;&lt; "Discovered " &lt;&lt; count &lt;&lt; " words.\n"; <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="listing"><span epub:type="pagebreak" id="page_531"/><a id="ch16ex05"/><em>Listing 16-5: A program that counts words from stdin</em></p>&#13;
<p class="indent">You declare a <span class="literal">string</span> called <span class="literal">word</span> to receive words from stdin <span class="ent">➊</span>, and you initialize a <span class="literal">count</span> variable to zero <span class="ent">➋</span>. Within the <span class="literal">while</span> loop’s Boolean expression, you attempt to assign new input into <span class="literal">word</span> <span class="ent">➌</span>. When this succeeds, you increment <span class="literal">count</span> <span class="ent">➍</span>. Once it fails—for example, due to encountering an EOF—you cease incrementing and print the final tally <span class="ent">➎</span>.</p>&#13;
<p class="indent">You can try two methods to test <a href="ch16.xhtml#ch16ex05">Listing 16-5</a>. First, you can simply invoke the program, enter some input, and provide an EOF. How to send EOF depends on your operating system. In the Windows command line, you can enter EOF by pressing <small>CTRL</small>-Z and pressing enter. In Linux bash or in the OS X shell, you press <small>CTRL</small>-D. <a href="ch16.xhtml#ch16ex06">Listing 16-6</a> demonstrates how to invoke <a href="ch16.xhtml#ch16ex05">Listing 16-5</a> from the Windows command line.</p>&#13;
<pre>$ <span class="codestrong1">listing_16_5.exe</span> <span class="ent">➊</span>&#13;
<span class="codestrong1">Size matters not. Look at me. Judge me by my size, do you? Hmm? Hmm. And well&#13;
you should not. For my ally is the Force, and a powerful ally it is. Life&#13;
creates it, makes it grow. Its energy surrounds us and binds us. Luminous&#13;
beings are we, not this crude matter. You must feel the Force around you;&#13;
here, between you, me, the tree, the rock, everywhere, yes. <span class="ent">➋</span></span>&#13;
<span class="codestrong1">^Z</span> <span class="ent">➌</span>&#13;
Discovered 70 words. <span class="ent">➍</span></pre>&#13;
<p class="listing"><a id="ch16ex06"/><em>Listing 16-6: Invoking the program in <a href="ch16.xhtml#ch16ex05">Listing 16-5</a> by typing input into the console</em></p>&#13;
<p class="indent">First, you invoke your program <span class="ent">➊</span>. Next, enter some arbitrary text followed by a new line <span class="ent">➋</span>. Then issue EOF. The Windows command line shows the somewhat cryptic sequence <strong>^Z</strong> on the command line, after which you must press <small>ENTER</small>. This causes <span class="literal">std::cin</span> to enter the <span class="literal">eofbit</span> state, ending the <span class="literal">while</span> loop in <a href="ch16.xhtml#ch16ex05">Listing 16-5</a> <span class="ent">➌</span>. The program indicates that you’ve sent 70 words into stdin <span class="ent">➍</span>.</p>&#13;
<p class="indent">On Linux and Mac and in Windows PowerShell, you have another option. Rather than entering the input directly into the console, you can save the text to a file, say <em>yoda.txt</em>. The trick is to use <span class="literal">cat</span> to read the text file and then use the pipe operator <span class="literal">|</span> to send the contents to your program. The pipe operator “pipes” the stdout of the program to its left into the stdin of the program on the right. The following command illustrates this process:</p>&#13;
<pre>$ <span class="codestrong1">cat yoda.txt</span><span class="ent">➊</span> |<span class="ent">➋</span> <span class="codestrong1">./listing_15_4</span><span class="ent">➌</span>&#13;
Discovered 70 words.</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_532"/>The <span class="literal">cat</span> command reads the contents of <em>yoda.txt</em> <span class="ent">➊</span>. The pipe operator <span class="ent">➋</span> pipes the stdout of <span class="literal">cat</span> into stdin of <span class="literal">listing_15_4</span> <span class="ent">➌</span>. Because <span class="literal">cat</span> sends EOF when it encounters the end of <em>yoda.txt</em>, you don’t need to enter it manually.</p>&#13;
<p class="indent">Sometimes you’ll want streams to throw an exception when certain fail bits occur. You can do this easily with a stream’s <span class="literal">exceptions</span> method, which accepts a single argument corresponding to the bit you want to throw exceptions. If you desire multiple bits, you can simply join them together using Boolean OR (<span class="literal">|</span>).</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16ex07">Listing 16-7</a> illustrates how to refactor <a href="ch16.xhtml#ch16ex05">Listing 16-5</a> so it handles the <span class="literal">badbit</span> with exceptions and <span class="literal">eofbit</span>/<span class="literal">failbit</span> with the default handling.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  cin.exceptions(istream::badbit); <span class="ent">➊</span>&#13;
  string word;&#13;
  size_t count{};&#13;
  try { <span class="ent">➋</span>&#13;
    while(cin &gt;&gt; word) <span class="ent">➌</span>&#13;
      count++;&#13;
    cout &lt;&lt; "Discovered " &lt;&lt; count &lt;&lt; " words.\n"; <span class="ent">➍</span>&#13;
  } catch (const std::exception&amp; e) { <span class="ent">➎</span>&#13;
    cerr &lt;&lt; "Error occurred reading from stdin: " &lt;&lt; e.what(); <span class="ent">➏</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch16ex07"/><em>Listing 16-7: Refactoring <a href="ch16.xhtml#ch16ex05">Listing 16-5</a> to handle <span class="literal">badbit</span> with exceptions</em></p>&#13;
<p class="indent">You start the program by invoking the exceptions method on <span class="literal">std::cin</span> <span class="ent">➊</span>. Because <span class="literal">cin</span> is an <span class="literal">istream</span>, you pass <span class="literal">istream::badbit</span> as the argument of <span class="literal">exception</span>, indicating that you want <span class="literal">cin</span> to throw an exception any time it gets into a catastrophic state. To account for possible exceptions, you wrap the existing code in a <span class="literal">try</span>-<span class="literal">catch</span> block <span class="ent">➋</span>, so if <span class="literal">cin</span> sets <span class="literal">badbit</span> while it’s reading input <span class="ent">➌</span>, the user never receives a message about the word count <span class="ent">➍</span>. Instead, the program catches the resulting exception <span class="ent">➎</span> and prints the error message <span class="ent">➏</span>.</p>&#13;
<h4 class="h4" id="ch16lev2sec3"><strong><em>Buffering and Flushing</em></strong></h4>&#13;
<p class="noindent">Many <span class="literal">ostream</span> class templates involve operating system calls under the hood, for example, to write to a console, a file, or a network socket. Relative to other function calls, system calls are usually slow. Rather than invoking a system call for each output element, an application can wait for multiple elements and then send them all together to improve performance.</p>&#13;
<p class="indent">The queuing behavior is called <em>buffering</em>. When the stream empties the buffered output, it’s called <em>flushing</em>. Usually, this behavior is completely transparent to the user, but sometimes you want to manually flush the <span class="literal">ostream</span>. For this (and other tasks), you turn to manipulators.</p>&#13;
<h4 class="h4" id="ch16lev2sec4"><span epub:type="pagebreak" id="page_533"/><strong><em>Manipulators</em></strong></h4>&#13;
<p class="noindent"><em>Manipulators</em> are special objects that modify how streams interpret input or format output. Manipulators exist to perform many kinds of stream alterations. For example, <span class="literal">std::ws</span> modifies an <span class="literal">istream</span> to skip over whitespace. Here are some other manipulators that work on <span class="literal">ostreams</span>:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">std::flush</span> empties any buffered output directly to an <span class="literal">ostream</span>.</li>&#13;
<li class="noindent"><span class="literal">std::ends</span> sends a null byte.</li>&#13;
<li class="noindent"><span class="literal">std::endl</span> is like <span class="literal">std::flush</span> except it sends a newline before flushing.</li>&#13;
</ul>&#13;
<p class="indent"><a href="ch16.xhtml#ch16tab06">Table 16-6</a> summarizes the manipulators in the <span class="literal">&lt;istream&gt;</span> and <span class="literal">&lt;ostream&gt;</span> headers.</p>&#13;
<p class="tabcap" id="ch16tab06"><strong>Table 16-6:</strong> Four Manipulators in the <span class="literal">&lt;istream&gt;</span> and <span class="literal">&lt;ostream&gt;</span> Headers</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Manipulator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Class</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Behavior</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">ws</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">istream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Skips over all whitespaces</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">flush</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">ostream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Writes any buffered data to the stream by invoking its <span class="literal">flush</span> method</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">ends</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">ostream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Sends a null byte</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">endl</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">ostream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Sends a newline and flushes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">For example, you could replace <span class="ent">➍</span> in <a href="ch16.xhtml#ch16ex07">Listing 16-7</a> with the following:</p>&#13;
<pre>cout &lt;&lt; "Discovered " &lt;&lt; count &lt;&lt; " words." &lt;&lt; endl;</pre>&#13;
<p class="indent">This will print a newline and also flush output.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>As a general rule, use <span class="literal">std::endl</span> when your program has finished outputting text to the stream for a while and <span class="literal">\n</span> when you know your program will output more text soon.</em></p>&#13;
</div>&#13;
<p class="indent">The stdlib provides many other manipulators in the <span class="literal">&lt;ios&gt;</span> header. You can, for example, determine whether an <span class="literal">ostream</span> will represent Boolean values textually (<span class="literal">boolalpha</span>) or numerically (<span class="literal">noboolalpha</span>); integral values as octal (<span class="literal">oct</span>), decimal (<span class="literal">dec</span>), or hexadecimal (<span class="literal">hex</span>); and floating-point numbers as decimal notation (<span class="literal">fixed</span>) or scientific notation (<span class="literal">scientific</span>). Simply pass one of these manipulators to an <span class="literal">ostream</span> using <span class="literal">operator&lt;&lt;</span> and <em>all</em> subsequent insertions of the corresponding type will be manipulated (not just an immediately preceding operand).</p>&#13;
<p class="indent">You can also set a stream’s width parameter using the <span class="literal">setw</span> manipulator. A stream’s width parameter has varied effects, depending on the stream. For example, with <span class="literal">std::cout, setw</span> will fix the number of output characters allocated to the next output object. Additionally, for floating-point output, <span class="literal">setprecision</span> will set the following numbers’ precision.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_534"/><a href="ch16.xhtml#ch16ex08">Listing 16-8</a> illustrates how these manipulators perform functions similar to those of the various <span class="literal">printf</span> format specifiers.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;iomanip&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  cout &lt;&lt; "Gotham needs its " &lt;&lt; boolalpha &lt;&lt; true &lt;&lt; " hero."; <span class="ent">➊</span>&#13;
  cout &lt;&lt; "\nMark it " &lt;&lt; noboolalpha &lt;&lt; false &lt;&lt; "!"; <span class="ent">➋</span>&#13;
  cout &lt;&lt; "\nThere are " &lt;&lt; 69 &lt;&lt; "," &lt;&lt; oct &lt;&lt; 105 &lt;&lt; " leaves in here."; <span class="ent">➌</span>&#13;
  cout &lt;&lt; "\nYabba " &lt;&lt; hex &lt;&lt; 3669732608 &lt;&lt; "!"; <span class="ent">➍</span>&#13;
  cout &lt;&lt; "\nAvogadro's number: " &lt;&lt; scientific &lt;&lt; 6.0221415e-23; <span class="ent">➎</span>&#13;
  cout &lt;&lt; "\nthe Hogwarts platform: " &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; 9.750123; <span class="ent">➏</span>&#13;
  cout &lt;&lt; "\nAlways eliminate " &lt;&lt; 3735929054; <span class="ent">➐</span>&#13;
  cout &lt;&lt; setw(4) &lt;&lt; "\n"&#13;
       &lt;&lt; 0x1 &lt;&lt; "\n"&#13;
       &lt;&lt; 0x10 &lt;&lt; "\n"&#13;
       &lt;&lt; 0x100 &lt;&lt; "\n"&#13;
       &lt;&lt; 0x1000 &lt;&lt; endl; <span class="ent">➑</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Gotham needs its true hero. <span class="ent">➊</span></span>&#13;
<span class="color1">Mark it 0! <span class="ent">➋</span></span>&#13;
<span class="color1">There are 69,151 leaves in here. <span class="ent">➌</span></span>&#13;
<span class="color1">Yabba dabbad00! <span class="ent">➍</span></span>&#13;
<span class="color1">Avogadro's Number: 6.022142e-23 <span class="ent">➎</span></span>&#13;
<span class="color1">the Hogwarts platform: 9.75 <span class="ent">➏</span></span>&#13;
<span class="color1">Always eliminate deadc0de <span class="ent">➐</span></span>&#13;
<span class="color1">1</span>&#13;
<span class="color1">10</span>&#13;
<span class="color1">100</span>&#13;
<span class="color1">1000 <span class="ent">➑</span></span></pre>&#13;
<p class="listing"><a id="ch16ex08"/><em>Listing 16-8: A program illustrating some of the manipulators available in the <span class="literal">&lt;iomanip&gt;</span> header</em></p>&#13;
<p class="indent">The <span class="literal">boolalpha</span> manipulator in the first line causes Boolean values to print textually as <span class="literal">true</span> and <span class="literal">false</span> <span class="ent">➊</span>, whereas <span class="literal">noboolalpha</span> causes them to print as 1 and 0 instead <span class="ent">➋</span>. For integral values, you can print as octal with <span class="literal">oct</span> <span class="ent">➌</span> or hexadecimal with <span class="literal">hex</span> <span class="ent">➍</span>. For floating-point values, you can specify scientific notation with <span class="literal">scientific</span> <span class="ent">➎</span>, and you can set the number of digits to print with <span class="literal">setprecision</span> and specify decimal notation with <span class="literal">fixed</span> <span class="ent">➏</span>. Because manipulators apply to all subsequent objects you insert into a stream, when you print another integral value at the end of the program, the last integral manipulator (<span class="literal">hex</span>) applies, so you get a hexadecimal representation <span class="ent">➐</span>. Finally, you employ <span class="literal">setw</span> to set the field width for output to 4, and you print some integral values <span class="ent">➑</span>.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16tab07">Table 16-7</a> summarizes this sampling of common manipulators.</p>&#13;
<p class="tabcap" id="ch16tab07"><span epub:type="pagebreak" id="page_535"/><strong>Table 16-7:</strong> Many of the Manipulators Available in the <span class="literal">&lt;iomanip&gt;</span> Header</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Manipulator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Behavior</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">boolalpha</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Represents Booleans textually rather than numerically.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">noboolalpha</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Represents Booleans numerically rather than textually.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">oct</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Represents integral values as octal.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">dec</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Represents integral values as decimal.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">hex</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Represents integral values as hexadecimal.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">setw(</span><span class="codestrong">n</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Sets the width parameter of a stream to <span class="codestrong">n</span>. The exact effect depends on the stream.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">setprecision(</span><span class="codestrong">p</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Specifies floating-point precision as <span class="codestrong">p</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">fixed</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Represents floating-point numbers in decimal notation.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">scientific</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Represents floating-point numbers in scientific notation.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Refer to <a href="ch15.xhtml#ch15">Chapter 15</a> in <em>The C++ Standard Library</em>, 2nd Edition, by Nicolai M. Josuttis or [iostream.format].</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch16lev2sec5"><strong><em>User-Defined Types</em></strong></h4>&#13;
<p class="noindent">You can make user-defined types work with streams by implementing certain non-member functions. To implement the output operator for type <span class="literal">YourType</span>, the following function declaration serves most purposes:</p>&#13;
<pre>ostream&amp;<span class="ent">➊</span> operator&lt;&lt;(ostream&amp;<span class="ent">➋</span> s, const YourType&amp; m <span class="ent">➌</span>);</pre>&#13;
<p class="indent">For most cases, you’ll simply return <span class="ent">➊</span> the same <span class="literal">ostream</span> you receive <span class="ent">➋</span>. It’s up to you how to send output into the <span class="literal">ostream</span>. But typically, this involves accessing fields on <span class="literal">YourType</span> <span class="ent">➌</span>, optionally performing some formatting and transformations, and then using the output operator. For example, <a href="ch16.xhtml#ch16ex09">Listing 16-9</a> shows how to implement an output operator for <span class="literal">std::vector</span> to print its size, capacity, and elements.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;vector&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
template &lt;typename T&gt;&#13;
ostream&amp; operator&lt;&lt;(ostream&amp; s, vector&lt;T&gt; v) { <span class="ent">➊</span>&#13;
  s &lt;&lt; "Size: " &lt;&lt; v.size()&#13;
    &lt;&lt; "\nCapacity: " &lt;&lt; v.capacity()&#13;
    &lt;&lt; "\nElements:\n"; <span class="ent">➋</span>&#13;
  for (const auto&amp; element : v)&#13;
    s &lt;&lt; "\t" &lt;&lt; element &lt;&lt; "\n"; <span class="ent">➌</span>&#13;
  return s; <span class="ent">➍</span>&#13;
}&#13;
&#13;
<span epub:type="pagebreak" id="page_536"/>int main() {&#13;
  const vector&lt;string&gt; characters {&#13;
    "Bobby Shaftoe",&#13;
    "Lawrence Waterhouse",&#13;
    "Gunter Bischoff",&#13;
    "Earl Comstock"&#13;
  }; <span class="ent">➎</span>&#13;
  cout &lt;&lt; characters &lt;&lt; endl; <span class="ent">➏</span>&#13;
&#13;
  const vector&lt;bool&gt; bits { true, false, true, false }; <span class="ent">➐</span>&#13;
  cout &lt;&lt; boolalpha &lt;&lt; bits &lt;&lt; endl; <span class="ent">➑</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Size: 4</span>&#13;
<span class="color1">Capacity: 4</span>&#13;
<span class="color1">Elements: <span class="ent">➋</span></span>&#13;
<span class="color1">        Bobby Shaftoe <span class="ent">➌</span></span>&#13;
<span class="color1">        Lawrence Waterhouse <span class="ent">➌</span></span>&#13;
<span class="color1">        Gunter Bischoff <span class="ent">➌</span></span>&#13;
<span class="color1">        Earl Comstock <span class="ent">➌</span></span>&#13;
&#13;
<span class="color1">Size: 4</span>&#13;
<span class="color1">Capacity: 32</span>&#13;
<span class="color1">Elements: <span class="ent">➋</span></span>&#13;
<span class="color1">        true <span class="ent">➌</span></span>&#13;
<span class="color1">        false <span class="ent">➌</span></span>&#13;
<span class="color1">        true <span class="ent">➌</span></span>&#13;
<span class="color1">        false <span class="ent">➌</span></span></pre>&#13;
<p class="listing"><a id="ch16ex09"/><em>Listing 16-9: A program illustrating how to implement an output operator for a <span class="literal">vector</span></em></p>&#13;
<p class="indent">First, you define a custom output operator as a template, using the template parameter as the template parameter of <span class="literal">std::vector</span> <span class="ent">➊</span>. This allows you to use the output operator for many kinds of <span class="literal">vector</span>s (as long as the type <span class="literal">T</span> also supports the output operator). The first three lines of output give the size and capacity of <span class="literal">vector</span>, as well as the title <span class="literal">Elements</span> indicating that the elements of the <span class="literal">vector</span> follow <span class="ent">➋</span>. The following <span class="literal">for</span> loop iterates over each element in the <span class="literal">vector</span>, sending each on a separate line to the <span class="literal">ostream</span> <span class="ent">➌</span>. Finally, you return the stream reference <span class="literal">s</span> <span class="ent">➍</span>.</p>&#13;
<p class="indent">Within <span class="literal">main</span>, you initialize a <span class="literal">vector</span> called <span class="literal">characters</span> containing four strings <span class="ent">➎</span>. Thanks to your user-defined output operator, you can simply send <span class="literal">characters</span> to <span class="literal">cout</span> as if it were a fundamental type <span class="ent">➏</span>. The second example uses a <span class="literal">vector&lt;bool&gt;</span> called <span class="literal">bits</span>, which you also initialize with four elements <span class="ent">➐</span> and print to stdout <span class="ent">➑</span>. Notice that you use the <span class="literal">boolalpha</span> manipulator, so when your user-defined output operator runs, the <span class="literal">bool</span> elements print textually <span class="ent">➌</span>.</p>&#13;
<p class="indent">You can also provide user-defined input operators, which work similarly. A simple corollary is as follows:</p>&#13;
<pre>istream&amp;<span class="ent">➊</span> operator&gt;&gt;(istream&amp;<span class="ent">➋</span> s, YourType&amp; m <span class="ent">➌</span>);</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_537"/>As with the output operator, the input operator typically returns <span class="ent">➊</span> the same stream it receives <span class="ent">➋</span>. However, unlike with the output operator, the <span class="literal">YourType</span> reference will generally not be <span class="literal">const</span>, because you’ll want to modify the corresponding object using input from the stream <span class="ent">➌</span>.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16ex10">Listing 16-10</a> illustrates how to specify an input operator for <span class="literal">deque</span> so it pushes elements into the container until an insertion fails (for example, due to an EOF character).</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;deque&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
template &lt;typename T&gt;&#13;
istream&amp; operator&gt;&gt;(istream&amp; s, deque&lt;T&gt;&amp; t) { <span class="ent">➊</span>&#13;
  T element; <span class="ent">➋</span>&#13;
  while (s &gt;&gt; element) <span class="ent">➌</span>&#13;
    t.emplace_back(move(element)); <span class="ent">➍</span>&#13;
  return s; <span class="ent">➎</span>&#13;
}&#13;
&#13;
int main() {&#13;
  cout &lt;&lt; "Give me numbers: "; <span class="ent">➏</span>&#13;
  deque&lt;int&gt; numbers;&#13;
  cin &gt;&gt; numbers; <span class="ent">➐</span>&#13;
  int sum{};&#13;
  cout &lt;&lt; "Cumulative sum:\n";&#13;
  for(const auto&amp; element : numbers) {&#13;
    sum += element;&#13;
    cout &lt;&lt; sum &lt;&lt; "\n"; <span class="ent">➑</span>&#13;
  }&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Give me numbers: <span class="ent">➏</span> 1 2 3 4 5 <span class="ent">➐</span></span>&#13;
<span class="color1">Cumulative sum:</span>&#13;
<span class="color1">1  <span class="ent">➑</span></span>&#13;
<span class="color1">3  <span class="ent">➑</span></span>&#13;
<span class="color1">6  <span class="ent">➑</span></span>&#13;
<span class="color1">10 <span class="ent">➑</span></span>&#13;
<span class="color1">15 <span class="ent">➑</span></span></pre>&#13;
<p class="listing"><a id="ch16ex10"/><em>Listing 16-10: A program illustrating how to implement an input operator for a <span class="literal">deque</span></em></p>&#13;
<p class="indent">Your user-defined input operator is a function template so you can accept any <span class="literal">deque</span> containing a type that supports the input operator <span class="ent">➊</span>. First, you construct an element of type <span class="literal">T</span> so you can store input from the <span class="literal">istream</span> <span class="ent">➋</span>. Next, you use the familiar <span class="literal">while</span> construct to accept input from the <span class="literal">istream</span> until the input operation fails <span class="ent">➌</span>. (Recall from the “Stream State” section that streams can get into failed states in many ways, including reaching an EOF or encountering an I/O error.) After each insertion, you <span class="literal">move</span> the result into <span class="literal">emplace_back</span> on the <span class="literal">deque</span> to avoid unnecessary copies <span class="ent">➍</span>. Once you’re done inserting, you simply return the <span class="literal">istream</span> reference <span class="ent">➎</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_538"/>Within <span class="literal">main</span>, you prompt the user for numbers <span class="ent">➏</span> and then use the insertion operator on a newly initialized <span class="literal">deque</span> to insert elements from stdin. In this sample program run, you input the numbers 1 to 5 <span class="ent">➐</span>. For a bit of fun, you compute a cumulative sum by keeping a tally and iterating over each element, printing that iteration’s result <span class="ent">➑</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The preceding examples are simple user-defined implementations of input and output operators. You might want to elaborate these implementations in production code. For example, the implementations only work with <span class="literal">ostream</span> classes, which implies that they won’t work with any non-<span class="literal">char</span> sequences.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch16lev2sec6"><strong><em>String Streams</em></strong></h4>&#13;
<p class="noindent">The <em>string stream classes</em> provide facilities for reading from and writing to character sequences. These classes are useful in several situations. Input strings are especially useful if you want to parse string data into types. Because you can use the input operator, all the standard manipulator facilities are available to you. Output strings are excellent for building up strings from variable-length input.</p>&#13;
<h5 class="h5" id="ch16lev3sec5"><strong>Output String Streams</strong></h5>&#13;
<p class="noindent"><em>Output string streams</em> provide output-stream semantics for character sequences, and they all derive from the class template <span class="literal">std::basic_ostringstream</span> in the <span class="literal">&lt;sstream&gt;</span> header, which provides the following specializations:</p>&#13;
<pre>using ostringstream = basic_ostringstream&lt;char&gt;;&#13;
using wostringstream = basic_ostringstream&lt;wchar_t&gt;;</pre>&#13;
<p class="indent">The output string streams support all the same features as an <span class="literal">ostream</span>. Whenever you send input to the string stream, the stream stores this input into an internal buffer. You can think of this as functionally equivalent to the <span class="literal">append</span> operation of <span class="literal">string</span> (except that string streams are potentially more efficient).</p>&#13;
<p class="indent">Output string streams also support the <span class="literal">str()</span> method, which has two modes of operation. Given no argument, <span class="literal">str</span> returns a copy of the internal buffer as a <span class="literal">basic_string</span> (so <span class="literal">ostringstream</span> returns a <span class="literal">string</span>; <span class="literal">wostringstream</span> returns a <span class="literal">wstring</span>). Given a single <span class="literal">basic_string</span> argument, the string stream will replace its buffer’s current contents with the contents of the argument. <a href="ch16.xhtml#ch16ex11">Listing 16-11</a> illustrates how to use an <span class="literal">ostringstream</span>, send character data to it, build a <span class="literal">string</span>, reset its contents, and repeat.</p>&#13;
<pre>#include &lt;string&gt;&#13;
#include &lt;sstream&gt;&#13;
&#13;
TEST_CASE("ostringstream produces strings with str") {&#13;
  std::ostringstream ss; <span class="ent">➊</span>&#13;
  ss &lt;&lt; "By Grabthar's hammer, ";&#13;
  ss &lt;&lt; "by the suns of Worvan. ";&#13;
&#13;
  ss &lt;&lt; "You shall be avenged."; <span class="ent">➋</span>&#13;
  const auto lazarus = ss.str(); <span class="ent">➌</span>&#13;
&#13;
  ss.str("I am Groot."); <span class="ent">➍</span>&#13;
  const auto groot = ss.str(); <span class="ent">➎</span>&#13;
&#13;
  REQUIRE(lazarus == "By Grabthar's hammer, by the suns"&#13;
                     " of Worvan. You shall be avenged.");&#13;
  REQUIRE(groot == "I am Groot.");&#13;
}</pre>&#13;
<p class="listing"><span epub:type="pagebreak" id="page_539"/><a id="ch16ex11"/><em>Listing 16-11: Using an <span class="literal">ostringstream</span> to build strings</em></p>&#13;
<p class="indent">After declaring an <span class="literal">ostringstream</span> <span class="ent">➊</span>, you treat it just like any other <span class="literal">ostream</span> and use the output operator to send it three separate character sequences <span class="ent">➋</span>. Next, you invoke <span class="literal">str</span> without an argument, which produces a <span class="literal">string</span> called <span class="literal">lazarus</span> <span class="ent">➌</span>. Then you invoke <span class="literal">str</span> with the string literal <span class="literal">I am Groot</span> <span class="ent">➍</span>, which replaces the contents of <span class="literal">ostringstream</span> <span class="ent">➎</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Recall from “C-Style Strings” on <a href="ch02.xhtml#page_45">page 45</a> that you can place multiple string literals on consecutive lines and the compiler will treat them as one. This is done purely for source code–formatting purposes.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec6"><strong>Input String Streams</strong></h5>&#13;
<p class="noindent"><em>Input string streams</em> provide input stream semantics for character sequences, and they all derive from the class template <span class="literal">std::basic_istringstream</span> in the <span class="literal">&lt;sstream&gt;</span> header, which provides the following specializations:</p>&#13;
<pre>using istringstream = basic_istringstream&lt;char&gt;;&#13;
using wistringstream = basic_istringstream&lt;wchar_t&gt;;</pre>&#13;
<p class="indent">These are analogous to the <span class="literal">basic_ostringstream</span> specializations. You can construct input string streams by passing a <span class="literal">basic_string</span> with appropriate specialization (<span class="literal">string</span> for an <span class="literal">istringstream</span> and <span class="literal">wstring</span> for a <span class="literal">wistringstream</span>). <a href="ch16.xhtml#ch16ex12">Listing 16-12</a> illustrates by constructing an input string stream with a string containing three numbers and using the input operator to extract them. (Recall from “Formatted Operations” on <a href="ch16.xhtml#page_525">page 525</a> that whitespace is the appropriate delimiter for string data.)</p>&#13;
<pre>TEST_CASE("istringstream supports construction from a string") {&#13;
  std::string numbers("1 2.23606 2"); <span class="ent">➊</span>&#13;
  std::istringstream ss{ numbers }; <span class="ent">➋</span>&#13;
  int a;&#13;
  float b, c, d;&#13;
  ss &gt;&gt; a; <span class="ent">➌</span>&#13;
  ss &gt;&gt; b; <span class="ent">➍</span>&#13;
  ss &gt;&gt; c;&#13;
  REQUIRE(a == 1);&#13;
  REQUIRE(b == Approx(2.23606));&#13;
  REQUIRE(c == Approx(2));&#13;
  REQUIRE_FALSE(ss &gt;&gt; d); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="listing"><span epub:type="pagebreak" id="page_540"/><a id="ch16ex12"/><em>Listing 16-12: Using a <span class="literal">string</span> to build <span class="literal">istringstream</span> objects and extract numeric types</em></p>&#13;
<p class="indent">You construct a <span class="literal">string</span> from the literal <span class="literal">1 2.23606 2</span> <span class="ent">➊</span>, which you pass into the constructor of an <span class="literal">istringstream</span> called <span class="literal">ss</span> <span class="ent">➋</span>. This allows you to use the input operator to parse out <span class="literal">int</span> objects <span class="ent">➌</span> and <span class="literal">float</span> objects <span class="ent">➍</span> just like any other input stream. Once you’ve exhausted the stream and the output operator fails, <span class="literal">ss</span> converts to <span class="literal">false</span> <span class="ent">➎</span>.</p>&#13;
<h5 class="h5" id="ch16lev3sec7"><strong>String Streams Supporting Input and Output</strong></h5>&#13;
<p class="noindent">Additionally, if you want a string stream that supports input and output operations, you can use the <span class="literal">basic_stringstream</span>, which has the following specializations:</p>&#13;
<pre>using stringstream = basic_stringstream&lt;char&gt;;&#13;
using wstringstream = basic_stringstream&lt;wchar_t&gt;;</pre>&#13;
<p class="indent">This class supports the input and output operators, the <span class="literal">str</span> method, and construction from a string. <a href="ch16.xhtml#ch16ex13">Listing 16-13</a> illustrates how to use a combination of input and output operators to extract tokens from a string.</p>&#13;
<pre>TEST_CASE("stringstream supports all string stream operations") {&#13;
  std::stringstream ss;&#13;
  ss &lt;&lt; "Zed's DEAD"; <span class="ent">➊</span>&#13;
&#13;
  std::string who;&#13;
  ss &gt;&gt; who; <span class="ent">➋</span>&#13;
  int what;&#13;
  ss &gt;&gt; std::hex &gt;&gt; what; <span class="ent">➌</span>&#13;
&#13;
  REQUIRE(who == "Zed's");&#13;
  REQUIRE(what == 0xdead);&#13;
}</pre>&#13;
<p class="listing"><a id="ch16ex13"/><em>Listing 16-13: Using a <span class="literal">stringstream</span> for input and output</em></p>&#13;
<p class="indent">You create a <span class="literal">stringstream</span> and sent the <span class="literal">Zed's DEAD</span> with the output operator <span class="ent">➊</span>. Next, you parse <span class="literal">Zed's</span> out of the <span class="literal">stringstream</span> using the input operator <span class="ent">➋</span>. Because <span class="literal">DEAD</span> is a valid hexadecimal integer, you use the input operator and the <span class="literal">std::hex</span> manipulator to extract it into an <span class="literal">int</span> <span class="ent">➌</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>All string streams are moveable.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec8"><strong>Summary of String Stream Operations</strong></h5>&#13;
<p class="noindent"><a href="ch16.xhtml#ch16tab08">Table 16-8</a> provides a partial list of <span class="literal">basic_stringstream</span> operations. In this table, <span class="literal">ss, ss1</span>, and <span class="literal">ss2</span> are of type <span class="literal">std::basic_stringstream&lt;T&gt;</span>; <span class="literal">s</span> is a <span epub:type="pagebreak" id="page_541"/><span class="literal">std::basic_string&lt;</span><span class="literal">T</span><span class="literal">&gt;</span>; <span class="literal">obj</span> is a formatted object; <span class="literal">pos</span> is a position type; <span class="literal">dir</span> is a <span class="literal">std::ios_base::seekdir</span>; and <span class="literal">flg</span> is a <span class="literal">std::ios_base::iostate</span>.</p>&#13;
<p class="tabcap" id="ch16tab08"><strong>Table 16-8:</strong> A Partial List of <span class="literal">std::basic_stringstream</span> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">basic_stringstream&lt;</span><span class="codestrong">T</span><span class="literal">&gt;</span></p>&#13;
<p class="taba"><span class="literal">  { [</span><span class="codestrong">s</span><span class="literal">], [</span><span class="codestrong">om</span><span class="literal">] }</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Performs braced initialization of a newly constructed string stream. Defaults to empty string <span class="codestrong">s</span> and <span class="literal">in|out</span> open mode <span class="codestrong">om</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">basic_stringstream&lt;</span><span class="codestrong">T</span><span class="literal">&gt;</span></p>&#13;
<p class="taba"><span class="literal">  { move(</span><span class="codestrong">ss</span><span class="literal">) }</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Takes ownership of <span class="codestrong">ss</span>’s internal buffer.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">~basic_stringstream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Destructs internal buffer.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">ss.</span><span class="literal">rdbuf()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns raw string device object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">ss.</span><span class="literal">str()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Gets the contents of the string device object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">ss.</span><span class="literal">str(</span><span class="codestrong">s</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Sets the contents of the string device object to <span class="codestrong">s</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">ss</span>  <span class="literal">&gt;&gt;</span>  <span class="codestrong">obj</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Extracts formatted data from the string stream.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">ss</span>  <span class="literal">&lt;&lt;</span>  <span class="codestrong">obj</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Inserts formatted data into the string stream.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">ss.</span><span class="literal">tellg()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the input position index.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">ss.</span><span class="literal">seekg(</span><span class="codestrong">pos</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="codestrong">ss.</span><span class="literal">seekg(</span><span class="codestrong">pos</span>,  <span class="codestrong">dir</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Sets the input position indicator.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">ss.</span><span class="literal">flush()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Synchronizes the underlying device.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">ss.</span><span class="literal">good()</span></p>&#13;
<p class="taba"><span class="codestrong">ss.</span><span class="literal">eof()</span></p>&#13;
<p class="taba"><span class="codestrong">ss.</span><span class="literal">bad()</span></p>&#13;
<p class="taba"><span class="codestrong">!ss</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Inspects the string stream’s bits.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">ss.</span><span class="literal">exceptions(</span><span class="codestrong">flg</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Configures the string stream to throw an exception whenever a bit in <span class="codestrong">flg</span> gets set.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">ss1.</span><span class="literal">swap(</span><span class="codestrong">ss2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">swap(</span><span class="codestrong">ss1</span>,  <span class="codestrong">ss2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Exchanges each element of <span class="codestrong">ss1</span> with those of <span class="codestrong">ss2</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch16lev2sec7"><strong><em>File Streams</em></strong></h4>&#13;
<p class="noindent">The <em>file stream classes</em> provide facilities for reading from and writing to character sequences. The file stream class structure follows that of the string stream classes. File stream class templates are available for input, output, and both.</p>&#13;
<p class="indent">File stream classes provide the following major benefits over using native system calls to interact with file contents:</p>&#13;
<ul>&#13;
<li class="noindent">You get the usual stream interfaces, which provide a rich set of features for formatting and manipulating output.</li>&#13;
<li class="noindent">The file stream classes are RAII wrappers around the files, meaning it’s impossible to leak resources, such as files.</li>&#13;
<li class="noindent">File stream classes support move semantics, so you can have tight control over where files are in scope.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch16lev3sec9"><span epub:type="pagebreak" id="page_542"/><strong>Opening Files with Streams</strong></h5>&#13;
<p class="noindent">You have two options for opening a file with any file stream. The first option is the <span class="literal">open</span> method, which accepts a <span class="literal">const char* filename</span> and an optional <span class="literal">std::ios_base::openmode</span> bitmask argument. The <span class="literal">openmode</span> argument can be one of the many possible combinations of values listed in <a href="ch16.xhtml#ch16tab09">Table 16-9</a>.</p>&#13;
<p class="tabcap" id="ch16tab09"><strong>Table 16-9:</strong> Possible Stream States, Their Accessor Methods, and Their Meanings</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Flag</strong> (<strong>in</strong> <span class="literal">std::ios</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>File</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Meaning</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">in</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Must exist</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Read</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">out</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Created if doesn’t exist</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Erase the file; then write</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">app</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Created if doesn’t exist</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Append</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">in|out</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Must exist</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Read and write from beginning</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">in|app</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Created if doesn’t exist</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Update at end</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">out|app</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Created if doesn’t exist</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Append</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">out|trunc</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Created if doesn’t exist</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Erase the file; then read and write</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">in|out|app</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Created if doesn’t exist</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Update at end</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">in|out|trunc</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Created if doesn’t exist</p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Erase the file; then read and write</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Additionally, you can add the <span class="literal">binary</span> flag to any of these combinations to put the file in <em>binary mode</em>. In binary mode, the stream won’t convert special character sequences, like end of line (for example, a carriage return plus a line feed on Windows) or EOF.</p>&#13;
<p class="indent">The second option for specifying a file to open is to use the stream’s constructor. Each file stream provides a constructor taking the same arguments as the <span class="literal">open</span> method. All file stream classes are RAII wrappers around the file handles they own, so the files will be automatically cleaned up when the file stream destructs. You can also manually invoke the <span class="literal">close</span> method, which takes no arguments. You might want to do this if you know you’re done with the file but your code is written in such a way that the file stream class object won’t destruct for a while.</p>&#13;
<p class="indent">File streams also have default constructors, which don’t open any files. To check whether a file is open, invoke the <span class="literal">is_open</span> method, which takes no arguments and returns a Boolean.</p>&#13;
<h5 class="h5" id="ch16lev3sec10"><strong>Output File Streams</strong></h5>&#13;
<p class="noindent"><em>Output file streams</em> provide output stream semantics for character sequences, and they all derive from the class template <span class="literal">std::basic_ofstream</span> in the <span class="literal">&lt;fstream&gt;</span> header, which provides the following specializations:</p>&#13;
<pre>using ofstream = basic_ofstream&lt;char&gt;;&#13;
using wofstream = basic_ofstream&lt;wchar_t&gt;;</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_543"/>The default <span class="literal">basic_ofstream</span> constructor doesn’t open a file, and the non-default constructor’s second optional argument defaults to <span class="literal">ios::out</span>.</p>&#13;
<p class="indent">Whenever you send input to the file stream, the stream writes the data to the corresponding file. <a href="ch16.xhtml#ch16ex14">Listing 16-14</a> illustrates how to use <span class="literal">ofstream</span> to write a simple message to a text file.</p>&#13;
<pre>#include &lt;fstream&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  ofstream file{ "lunchtime.txt", ios::out|ios::app }; <span class="ent">➊</span>&#13;
  file &lt;&lt; "Time is an illusion." &lt;&lt; endl; <span class="ent">➋</span>&#13;
  file &lt;&lt; "Lunch time, " &lt;&lt; 2 &lt;&lt; "x so." &lt;&lt; endl; <span class="ent">➌</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
lunchtime.txt:&#13;
<span class="color1">Time is an illusion. <span class="ent">➋</span></span>&#13;
<span class="color1">Lunch time, 2x so. <span class="ent">➌</span></span></pre>&#13;
<p class="listing"><a id="ch16ex14"/><em>Listing 16-14: A program opening the file lunchtime.txt and appending a message to it. (The output corresponds to the contents of lunchtime.txt after a single program execution.)</em></p>&#13;
<p class="indent">You initialize an <span class="literal">ofstream</span> called <span class="literal">file</span> with the path <span class="literal">lunchtime.txt</span> and the flags <span class="literal">out</span> and <span class="literal">app</span> <span class="ent">➊</span>. Because this combination of flags appends output, any data you send through the output operator into this file stream gets appended to the end of the file. As expected, the file contains the message you passed to the output operator <span class="ent">➋</span><span class="ent">➌</span>.</p>&#13;
<p class="indent">Thanks to the <span class="literal">ios::app</span> flag, the program will append output to <em>lunchtime.txt</em> if it exists. For example, if you run the program again, you’ll get the following output:</p>&#13;
<pre>Time is an illusion.&#13;
Lunch time, 2x so.&#13;
Time is an illusion.&#13;
Lunch time, 2x so.</pre>&#13;
<p class="indent">The second iteration of the program added the same phrase to the end of the file.</p>&#13;
<h5 class="h5" id="ch16lev3sec11"><strong>Input File Streams</strong></h5>&#13;
<p class="noindent"><em>Input file streams</em> provide input stream semantics for character sequences, and they all derive from the class template <span class="literal">std::basic_ifstream</span> in the <span class="literal">&lt;fstream&gt;</span> header, which provides the following specializations:</p>&#13;
<pre>using ifstream = basic_ifstream&lt;char&gt;;&#13;
using wifstream = basic_ifstream&lt;wchar_t&gt;;</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_544"/>The default<span class="literal"> basic_ifstream</span> constructor doesn’t open a file, and the non-default constructor’s second optional argument defaults to <span class="literal">ios::in</span>.</p>&#13;
<p class="indent">Whenever you read from the file stream, the stream reads data from the corresponding file. Consider the following sample file, <em>numbers.txt</em>:</p>&#13;
<pre>-54&#13;
203&#13;
9000&#13;
0&#13;
99&#13;
-789&#13;
400</pre>&#13;
<p class="indent"><a href="ch16.xhtml#ch16ex15">Listing 16-15</a> contains a program that uses an <span class="literal">ifstream</span> to read from a text file containing integers and return the maximum. The output corresponds with invoking the program and passing the path of the file <em>numbers.txt</em>.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;fstream&gt;&#13;
#include &lt;limits&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  ifstream file{ "numbers.txt" }; <span class="ent">➊</span>&#13;
  auto maximum = numeric_limits&lt;int&gt;::min(); <span class="ent">➋</span>&#13;
  int value;&#13;
  while (file &gt;&gt; value) <span class="ent">➌</span>&#13;
    maximum = maximum &lt; value ? value : maximum; <span class="ent">➍</span>&#13;
  cout &lt;&lt; "Maximum found was " &lt;&lt; maximum &lt;&lt; endl; <span class="ent">➎</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Maximum found was 9000 <span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch16ex15"/><em>Listing 16-15: A program that reads the text file</em> numbers.txt <em>and prints its maximum integer</em></p>&#13;
<p class="indent">You first initialize an <span class="literal">istream</span> to open the <em>numbers.txt</em> text file <span class="ent">➊</span>. Next, you initialize the maximum variable with the minimum value an <span class="literal">int</span> can take <span class="ent">➋</span>. Using the idiomatic input stream and <span class="literal">while</span>-loop combination <span class="ent">➌</span>, you cycle through each integer in the file, updating the maximum as you find higher values <span class="ent">➍</span>. Once the file stream cannot parse any more integers, you print the result to stdout <span class="ent">➎</span>.</p>&#13;
<h5 class="h5" id="ch16lev3sec12"><strong>Handling Failure</strong></h5>&#13;
<p class="noindent">As with other streams, file streams fail silently. If you use a file stream constructor to open a file, you must check the <span class="literal">is_open</span> method to determine whether the stream successfully opened the file. This design differs from most other stdlib objects where invariants are enforced by exceptions. It’s hard to say why the library implementors chose this approach, but the fact is that you can opt into an exception-based approach fairly easily.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_545"/>You can make your own factory functions to handle file-opening failures with exceptions. <a href="ch16.xhtml#ch16ex16">Listing 16-16</a> illustrates how to implement an <span class="literal">ifstream</span> factory called <span class="literal">open</span>.</p>&#13;
<pre>#include &lt;fstream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
ifstream<span class="ent">➊</span> open(const char* path<span class="ent">➋</span>, ios_base::openmode mode = ios_base::in<span class="ent">➌</span>) {&#13;
  ifstream file{ path, mode }; <span class="ent">➍</span>&#13;
  if(!file.is_open()) { <span class="ent">➎</span>&#13;
    string err{ "Unable to open file " };&#13;
    err.append(path);&#13;
    throw runtime_error{ err }; <span class="ent">➏</span>&#13;
  }&#13;
  file.exceptions(ifstream::badbit);&#13;
  return file; <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch16ex16"/><em>Listing 16-16: A factory function for generating <span class="literal">ifstream</span>s that handle errors with exceptions rather than failing silently</em></p>&#13;
<p class="indent">Your factory function returns an <span class="literal">ifstream</span> <span class="ent">➊</span> and accepts the same arguments as a file stream’s constructor (and <span class="literal">open</span> method): a file <span class="literal">path</span> <span class="ent">➋</span> and an <span class="literal">openmode</span> <span class="ent">➌</span>. You pass these two arguments into the constructor of <span class="literal">ifstream</span> <span class="ent">➍</span> and then determine whether the file opened successfully <span class="ent">➎</span>. If it didn’t, you throw a <span class="literal">runtime_error</span> <span class="ent">➏</span>. If it did, you tell the resulting <span class="literal">ifstream</span> to throw an exception whenever its <span class="literal">badbit</span> gets set in the future <span class="ent">➐</span>.</p>&#13;
<h5 class="h5" id="ch16lev3sec13"><strong>Summary of File Stream Operations</strong></h5>&#13;
<p class="noindent"><a href="ch16.xhtml#ch16tab010">Table 16-10</a> provides a partial list of <span class="literal">basic_fstream</span> operations. In this table, <span class="literal">fs, fs1</span>, and <span class="literal">fs2</span> are of type <span class="literal">std:: basic_fstream &lt;T&gt;</span>; <span class="literal">p</span> is a C-style string, <span class="literal">std::string</span>, or a <span class="literal">std::filesystem::path</span>; <span class="literal">om</span> is an <span class="literal">std::ios_base::openmode</span>; <span class="literal">s</span> is a <span class="literal">std::basic_string&lt;</span><span class="literal">T</span><span class="literal">&gt;</span>; <span class="literal">obj</span> is a formatted object; <span class="literal">pos</span> is a position type; <span class="literal">dir</span> is a <span class="literal">std::ios_base::seekdir</span>; and <span class="literal">flg</span> is a <span class="literal">std::ios_base::iostate</span>.</p>&#13;
<p class="tabcap" id="ch16tab010"><strong>Table 16-10:</strong> A Partial List of <span class="literal">std::basic_fstream</span> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">basic_fstream&lt;</span><span class="codestrong">T</span><span class="literal">&gt;</span></p>&#13;
<p class="taba"><span class="literal"> { [</span><span class="codestrong">p</span><span class="literal">], [</span><span class="codestrong">om</span><span class="literal">] }</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Performs braced initialization of a newly constructed file stream. If <span class="codestrong">p</span> is provided, attempts to open file at path <span class="codestrong">p</span>. Defaults to not opened and <span class="literal">in|out</span> open mode.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">basic_fstream&lt;</span><span class="codestrong">T</span><span class="literal">&gt;</span></p>&#13;
<p class="taba"><span class="literal"> { move(</span><span class="codestrong">fs</span><span class="literal">) }</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Takes ownership of the internal buffer of <span class="codestrong">fs</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">~basic_fstream</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Destructs internal buffer.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">fs.</span><span class="literal">rdbuf()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns raw string device object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">fs.</span><span class="literal">str()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Gets the contents of the file device object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">fs.</span><span class="literal">str(</span><span class="codestrong">s</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Puts the contents of the file device object into <span class="codestrong">s</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><span epub:type="pagebreak" id="page_546"/><p class="taba"><span class="codestrong">fs</span> <span class="literal">&gt;&gt;</span> <span class="codestrong">obj</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Extracts formatted data from the file stream.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">fs</span> <span class="literal">&lt;&lt;</span> <span class="codestrong">obj</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Inserts formatted data into the file stream.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">fs.</span><span class="literal">tellg()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the input position index.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">fs.</span><span class="literal">seekg(</span><span class="codestrong">pos</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="codestrong">fs.</span><span class="literal">seekg(</span><span class="codestrong">pos</span>, <span class="codestrong">dir</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Sets the input position indicator.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">fs.</span><span class="literal">flush()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Synchronizes the underlying device.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">fs.</span><span class="literal">good()</span></p>&#13;
<p class="taba"><span class="codestrong">fs.</span><span class="literal">eof()</span></p>&#13;
<p class="taba"><span class="codestrong">fs.</span><span class="literal">bad()</span></p>&#13;
<p class="taba"><span class="literal">!</span><span class="codestrong">fs</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Inspects the file stream’s bits.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">fs.</span><span class="literal">exceptions(</span><span class="codestrong">flg</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Configures the file stream to throw an exception whenever a bit in <span class="codestrong">flg</span> gets set.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">fs1.</span><span class="literal">swap(</span><span class="codestrong">fs2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">swap(</span><span class="codestrong">fs1</span>, <span class="codestrong">fs2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Exchanges each element of <span class="codestrong">fs1</span> with one of <span class="codestrong">fs2</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch16lev2sec8"><strong><em>Stream Buffers</em></strong></h4>&#13;
<p class="noindent">Streams don’t read and write directly. Under the covers, they use stream buffer classes. At a high level, <em>stream buffer classes</em> are templates that send or extract characters. The implementation details aren’t important unless you’re planning on implementing your own stream library, but it’s important to know that they exist in several contexts. The way you obtain stream buffers is by using a stream’s <span class="literal">rdbuf</span> method, which all streams provide.</p>&#13;
<h5 class="h5" id="ch16lev3sec14"><strong>Writing Files to sdout</strong></h5>&#13;
<p class="noindent">Sometimes you just want to write the contents of an input file stream directly into an output stream. To do this, you can extract the stream buffer pointer from the file stream and pass it to the output operator. For example, you can dump the contents of a file to stdout using <span class="literal">cout</span> in the following way:</p>&#13;
<pre>cout &lt;&lt; my_ifstream.rdbuf()</pre>&#13;
<p class="indent">It’s that easy.</p>&#13;
<h5 class="h5" id="ch16lev3sec15"><strong>Output Stream Buffer Iterators</strong></h5>&#13;
<p class="noindent"><em>Output stream buffer iterators</em> are template classes that expose an output iterator interface that translates writes into output operations on the underlying stream buffer. In other words, these are adapters that allow you to use output streams as if they were output iterators.</p>&#13;
<p class="indent">To construct an output stream buffer iterator, use the <span class="literal">ostreambuf_iterator</span> template class in the <span class="literal">&lt;iterator&gt;</span> header. Its constructor takes a single output stream argument and a single template parameter corresponding to the <span epub:type="pagebreak" id="page_547"/>constructor argument’s template parameter (the character type). <a href="ch16.xhtml#ch16ex17">Listing 16-17</a> shows how to construct an output stream buffer iterator from <span class="literal">cout</span>.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;iterator&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  ostreambuf_iterator&lt;char&gt; itr{ cout }; <span class="ent">➊</span>&#13;
  *itr = 'H'; <span class="ent">➋</span>&#13;
  ++itr; <span class="ent">➌</span>&#13;
  *itr = 'i'; <span class="ent">➍</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">H<span class="ent">➋</span>i<span class="ent">➍</span></span></pre>&#13;
<p class="listing"><a id="ch16ex17"/><em>Listing 16-17: Writing the message <span class="literal">Hi</span> to stdout using the <span class="literal">ostreambuf_iterator</span> class</em></p>&#13;
<p class="indent">Here, you construct an output stream buffer iterator from <span class="literal">cout</span> <span class="ent">➊</span>, which you write to in the usual way for an output operator: assign <span class="ent">➋</span>, increment <span class="ent">➌</span>, assign <span class="ent">➍</span>, and so on. The result is character-by-character output to stdout. (Recall the procedures for handling output operators in “Output Iterators” on <a href="ch14.xhtml#page_464">page 464</a>.)</p>&#13;
<h5 class="h5" id="ch16lev3sec16"><strong>Input Stream Buffer Iterators</strong></h5>&#13;
<p class="noindent"><em>Input stream buffer iterators</em> are template classes that expose an input iterator interface that translates reads into read operations on the underlying stream buffer. These are entirely analogous to output stream buffer iterators.</p>&#13;
<p class="indent">To construct an input stream buffer iterator, use the <span class="literal">istreambuf_iterator</span> template class in the <span class="literal">&lt;iterator&gt;</span> header. Unlike <span class="literal">ostreambuf_iterator</span>, it takes a stream buffer argument, so you must call <span class="literal">rdbuf()</span> on whichever input stream you want to adapt. This argument is optional: the default constructor of <span class="literal">istreambuf_iterator</span> corresponds to the end-of-range iterator of input iterator. For example, <a href="ch16.xhtml#ch16ex18">Listing 16-18</a> illustrates how to construct a string from <span class="literal">std::cin</span> using the range-based constructor of <span class="literal">string</span>.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;iterator&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  istreambuf_iterator&lt;char&gt; cin_itr{ cin.rdbuf() } <span class="ent">➊</span>, end{} <span class="ent">➋</span>;&#13;
  cout &lt;&lt; "What is your name? "; <span class="ent">➌</span>&#13;
  const string name{ cin_itr, end }; <span class="ent">➍</span>&#13;
  cout &lt;&lt; "\nGoodbye, " &lt;&lt; name; <span class="ent">➎</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">What is your name? <span class="ent">➌</span></span><span class="codestrong1">josh</span> <span class="color1"><span class="ent">➍</span></span>&#13;
<span class="color1">Goodbye, josh<span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch16ex18"/><em>Listing 16-18: Constructing a string from <span class="literal">cin</span> using input stream buffer iterators</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_548"/>You construct an <span class="literal">istreambuf_iterator</span> from the stream buffer of <span class="literal">cin</span> <span class="ent">➊</span> as well as the end-of-range iterator <span class="ent">➋</span>. After sending a prompt to the program’s user <span class="ent">➌</span>, you construct the <span class="literal">string name</span> using its range-based constructor <span class="ent">➍</span>. When the user sends input (terminated by EOF), the string’s constructor copies it. You then bid the user farewell using their <span class="literal">name</span> <span class="ent">➎</span>. (Recall from “Stream State” on <a href="ch16.xhtml#page_530">page 530</a> that methods for sending EOF to the console differ by operating system.)</p>&#13;
<h4 class="h4" id="ch16lev2sec9"><strong><em>Random Access</em></strong></h4>&#13;
<p class="noindent">Sometimes you’ll want random access into a stream (especially a file stream). The input and output operators clearly don’t support this use case, so <span class="literal">basic_istream</span> and <span class="literal">basic_ostream</span> offer separate methods for random access. These methods keep track of the cursor or position, the index of the stream’s current character. The position indicates the next byte that an input stream will read or an output stream will write.</p>&#13;
<p class="indent">For input streams, you can use the two methods <span class="literal">tellg</span> and <span class="literal">seekg</span>. The <span class="literal">tellg</span> method takes no arguments and returns the position. The <span class="literal">seekg</span> method allows you to set the cursor position, and it has two overloads. Your first option is to provide a <span class="literal">pos_type</span> position argument, which sets the read position. The second is to provide an <span class="literal">off_type</span> offset argument plus an <span class="literal">ios_base::seekdir</span> direction argument. The <span class="literal">pos_type</span> and <span class="literal">off_type</span> are determined by the template arguments to the <span class="literal">basic_istream</span> or <span class="literal">basic_ostream</span>, but usually these convert to/from integer types. The <span class="literal">seekdir</span> type takes one of the following three values:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">ios_base::beg</span> specifies that the position argument is relative to the beginning.</li>&#13;
<li class="noindent"><span class="literal">ios_base::cur</span> specifies that the position argument is relative to the current position.</li>&#13;
<li class="noindent"><span class="literal">ios_base::end</span> specifies that the position argument is relative to the end.</li>&#13;
</ul>&#13;
<p class="indent">For output streams, you can use the two methods <span class="literal">tellp</span> and <span class="literal">seekp</span>. These are roughly analogous to the <span class="literal">tellg</span> and <span class="literal">seekg</span> methods of input streams: the <span class="literal">p</span> stands for put and the <span class="literal">g</span> stands for get.</p>&#13;
<p class="indent">Consider a file <em>introspection.txt</em> with the following contents:</p>&#13;
<pre>The problem with introspection is that it has no end.</pre>&#13;
<p class="indent"><a href="ch16.xhtml#ch16ex19">Listing 16-19</a> illustrates how to employ random access methods to reset the file cursor.</p>&#13;
<pre>#include &lt;fstream&gt;&#13;
#include &lt;exception&gt;&#13;
#include &lt;iostream&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
<span epub:type="pagebreak" id="page_549"/>ifstream open(const char* path, ios_base::openmode mode = ios_base::in) { <span class="ent">➊</span>&#13;
--<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
int main() {&#13;
  try {&#13;
    auto intro = open("introspection.txt"); <span class="ent">➋</span>&#13;
    cout &lt;&lt; "Contents: " &lt;&lt; intro.rdbuf() &lt;&lt; endl; <span class="ent">➌</span>&#13;
    intro.seekg(0); <span class="ent">➍</span>&#13;
    cout &lt;&lt; "Contents after seekg(0): " &lt;&lt; intro.rdbuf() &lt;&lt; endl; <span class="ent">➎</span>&#13;
    intro.seekg(-4, ios_base::end); <span class="ent">➏</span>&#13;
    cout &lt;&lt; "tellg() after seekg(-4, ios_base::end): "&#13;
                                                    &lt;&lt; intro.tellg() &lt;&lt; endl; <span class="ent">➐</span>&#13;
    cout &lt;&lt; "Contents after seekg(-4, ios_base::end): "&#13;
                                                    &lt;&lt; intro.rdbuf() &lt;&lt; endl; <span class="ent">➑</span>&#13;
  }&#13;
  catch (const exception&amp; e) {&#13;
    cerr &lt;&lt; e.what();&#13;
  }&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Contents: The problem with introspection is that it has no end. <span class="ent">➌</span></span>&#13;
<span class="color1">Contents after seekg(0): The problem with introspection is that it has no end. <span class="ent">➎</span></span>&#13;
<span class="color1">tellg() after seekg(-4, ios_base::end): 49 <span class="ent">➐</span></span>&#13;
<span class="color1">Contents after seekg(-4, ios_base::end): end. <span class="ent">➑</span></span></pre>&#13;
<p class="listing"><a id="ch16ex19"/><em>Listing 16-19: A program using random access methods to read arbitrary characters in a text file</em></p>&#13;
<p class="indent">Using the factory function in <a href="ch16.xhtml#ch16ex16">Listing 16-16</a> <span class="ent">➊</span>, you open the text file <em>introspection.txt</em> <span class="ent">➋</span>. Next, you print the contents to stdout using the <span class="literal">rdbuf</span> method <span class="ent">➌</span>, rewind the cursor to the first character <span class="ent">➍</span>, and print the contents again. Notice that these yield identical output (because the file hasn’t changed) <span class="ent">➎</span>. You then use the relative offset overload of <span class="literal">seekg</span> to navigate to the fourth character from the end <span class="ent">➏</span>. Using <span class="literal">tellg</span>, you learn that this is the 49th character (with zero-base indexing) <span class="ent">➐</span>. When you print the input file to stdout, the output is only <span class="literal">end.</span>, because these are the last four characters in the file <span class="ent">➑</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost offers an IOStream library with a rich set of additional features that stdlib doesn’t have, including facilities for memory mapped file I/O, compression, and filtering.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch16lev1sec2"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you learned about streams, the major concept that provides a common abstraction for performing I/O. You also learned about files as a primary source and destination for I/O. You first learned about the <span epub:type="pagebreak" id="page_550"/>fundamental stream classes in the stdlib and how to perform formatted and unformatted operations, inspect stream state, and handle errors with exceptions. You learned about manipulators and how to incorporate streams into user-defined types, string streams, and file streams. This chapter culminated with stream buffer iterators, which allow you to adapt a stream to an iterator.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>16-1.</strong> Implement an output operator that prints information about the <span class="literal">AutoBrake</span> from “An Extended Example: Taking a Brake” on <a href="ch10.xhtml#page_283">page 283</a>. Include the vehicle’s current collision threshold and speed.</p>&#13;
<p class="noindent"><strong>16-2.</strong> Write a program that takes output from stdin, capitalizes it, and writes the result to stdout.</p>&#13;
<p class="noindent"><strong>16-3.</strong> Read the introductory documentation for Boost IOStream.</p>&#13;
<p class="noindent"><strong>16-4.</strong> Write a program that accepts a file path, opens the file, and prints summary information about the contents, including word count, average word length, and a histogram of the characters.</p>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>Standard C++ IOStreams and Locales: Advanced Programmer’s Guide and Reference</em> by Angelika Langer (Addison-Wesley Professional, 2000)</li>&#13;
<li class="noindent"><em>ISO International Standard ISO/IEC (2017) — Programming Language C++</em> (International Organization for Standardization; Geneva, Switzerland;  <em><a href="https://isocpp.org/std/the-standard/">https://isocpp.org/std/the-standard/</a></em>)</li>&#13;
<li class="noindent"><em>The Boost C++ Libraries</em>, 2nd Edition, by Boris Schäling (XML Press, 2014)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>