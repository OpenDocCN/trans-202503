<html><head></head><body>
<h2 class="h2" id="ch16"><span epub:type="pagebreak" id="page_523"/><strong><span class="big">16</span><br/>STREAMS</strong></h2>&#13;
<p class="quote"><em>Either write something worth reading or do something worth writing.<br/>—Benjamin Franklin</em></p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">This chapter introduces streams, the major concept that enables you to connect inputs from any kind of source and outputs to any kind of destination using a common framework. You’ll learn about the classes that form the base elements of this common framework, several built-in facilities, and how to incorporate streams into user-defined types.</p>&#13;
<h3 class="h3" id="ch16lev1sec1"><strong>Streams</strong></h3>&#13;
<p class="noindent">A <em>stream</em> models a <em>stream of data</em>. In a stream, data flows between objects, and those objects can perform arbitrary processing on the data. When you’re working with streams, output is data going into the stream and input is data coming out of the stream. These terms reflect the streams as viewed from the user’s perspective.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_524"/>In C++, streams are the primary mechanism for performing input and output (I/O). Regardless of the source or destination, you can use streams as the common language to connect inputs to outputs. The STL uses class inheritance to encode the relationships between various stream types. The primary types in this hierarchy are:</p>&#13;
<ul>&#13;
<li class="noindent">The <code>std::basic_ostream</code> class template in the <code>&lt;ostream&gt;</code> header that represents an output device</li>&#13;
<li class="noindent">The <code>std::basic_istream</code> class template in the <code>&lt;istream&gt;</code> header that represents an input device</li>&#13;
<li class="noindent">The <code>std::basic_iostream</code> class template in the <code>&lt;iostream</code><code>&gt;</code> header for devices that are input and output</li>&#13;
</ul>&#13;
<p class="indent">All three stream types require two template parameters. The first corresponds to the stream’s underlying data type and the second to a traits type.</p>&#13;
<p class="indent">This section covers streams from a user’s perspective rather than from a library implementer’s perspective. You’ll understand the streams interface and know how to interact with standard I/O, files, and strings using the STL’s built-in stream support. If you must implement a new kind of stream (for example, for a new library or framework), you’ll need a copy of the ISO C++ 17 Standard, some working examples, and an ample supply of coffee. I/O is complicated, and you’ll see this difficulty reflected in a stream implementation’s internal complexity. Fortunately, a well-designed stream class hides much of this complexity from users.</p>&#13;
<h4 class="h4" id="ch16lev2sec1"><strong><em>Stream Classes</em></strong></h4>&#13;
<p class="noindent">All STL stream classes that users interact with derive from <code>basic_istream, basic_ostream</code>, or both via <code>basic_iostream</code>. The headers that declare each type also provide <code>char</code> and <code>wchar_t</code> specializations for those templates, as outlined in <a href="ch16.xhtml#ch16tab01">Table 16-1</a>. These heavily used specializations are particularly useful when you’re working with human-language data input and output.</p>&#13;
<p class="tabcap" id="ch16tab01"><strong>Table 16-1:</strong> Template Specializations for the Primary Stream Templates</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Template</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Parameter</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Specialization</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Header</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>basic_istream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>char</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>istream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>&lt;istream&gt;</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>basic_ostream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>char</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>ostream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>&lt;ostream&gt;</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>basic_iostream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>char</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>iostream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>&lt;iostream&gt;</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>basic_istream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>wchar_t</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>wistream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>&lt;istream&gt;</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>basic_ostream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>wchar_t</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>wostream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>&lt;ostream&gt;</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>basic_iostream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>wchar_t</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>wiostream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>&lt;iostream&gt;</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The objects in <a href="ch16.xhtml#ch16tab01">Table 16-1</a> are abstractions that you can use in your programs to write generic code. Do you want to write a function that logs output to an arbitrary source? If so, you can accept an <code>ostream</code> reference <span epub:type="pagebreak" id="page_525"/>parameter and not deal with all the nasty implementation details. (Later in the “Output File Streams” on <a href="ch16.xhtml#page_542">page 542</a>, you’ll learn how to do this.)</p>&#13;
<p class="indent">Often, you’ll want to perform I/O with the user (or the program’s environment). Global stream objects provide a convenient, stream-based wrapper for you to work against.</p>&#13;
<h5 class="h5" id="ch16lev3sec1"><strong>Global Stream Objects</strong></h5>&#13;
<p class="noindent">The STL provides several <em>global stream objects</em> in the <code>&lt;iostream&gt;</code> header that wrap the input, output, and error streams stdin, stdout, and stderr. These implementation-defined standard streams are preconnected channels between your program and its executing environment. For example, in a desktop environment, stdin typically binds to the keyboard and stdout and stderr bind to the console.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Recall that in <a href="part01.xhtml#part01">Part I</a> you saw extensive use of <code>printf</code> to write to stdout.</em></p>&#13;
</div>&#13;
<p class="indent"><a href="ch16.xhtml#ch16tab02">Table 16-2</a> lists the global stream objects, all of which reside in the <code>std</code> namespace.</p>&#13;
<p class="tabcap" id="ch16tab02"><strong>Table 16-2:</strong> The Global Stream Objects</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Object</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Type</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Purpose</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>cout</code></p>&#13;
<p class="taba"><code>wcout</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>ostream</code></p>&#13;
<p class="taba"><code>wostream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Output, like a screen</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>cin</code></p>&#13;
<p class="taba"><code>wcin</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>istream</code></p>&#13;
<p class="taba"><code>wistream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Input, like a keyboard</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>cerr</code></p>&#13;
<p class="taba"><code>wcerr</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>ostream</code></p>&#13;
<p class="taba"><code>wostream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Error output (unbuffered)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>clog</code></p>&#13;
<p class="taba"><code>wclog</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>ostream</code></p>&#13;
<p class="taba"><code>wostream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Error output (buffered)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">So how do you use these objects? Well, stream classes support operations that you can partition into two categories:</p>&#13;
<p class="bq"><strong>Formatted operations</strong> Might perform some preprocessing on their input parameters before performing I/O</p>&#13;
<p class="bq"><strong>Unformatted operations</strong> Perform I/O directly</p>&#13;
<p class="indent">The following sections explain each of these categories in turn.</p>&#13;
<h5 class="h5" id="ch16lev3sec2"><strong>Formatted Operations</strong></h5>&#13;
<p class="noindent">All formatted I/O passes through two functions: the <em>standard stream operators</em>, <code>operator&lt;&lt;</code> and <code>operator&gt;&gt;</code>. You’ll recognize these as the left and right shift operators from “Logical Operators” on <a href="ch07.xhtml#page_182">page 182</a>. Somewhat confusingly, streams overload the left and right shift operators with completely unrelated functionality. The semantic meaning of the expression <code>i &lt;&lt; 5</code> depends entirely on the type of <code>i</code>. If <code>i</code> is an integral type, this expression means <em>take</em> <span epub:type="pagebreak" id="page_526"/><span class="codeitalic">i</span> <em>and shift the bits to the left by five binary digits</em>. If <code>i</code> is not an integral type, it means <em>write the value 5 into</em> <span class="codeitalic">i</span>. Although this notational collision is unfortunate, in practice it doesn’t cause too much trouble. Just pay attention to the types you’re using and test your code well.</p>&#13;
<p class="indent">Output streams overload <code>operator&lt;&lt;</code>, which is referred to as the <em>output operator</em> or the <em>inserter</em>. The <code>basic_ostream</code> class template overloads the output operator for all fundamental types (except <code>void</code> and <code>nullptr_t</code>) and some STL containers, such as <code>basic_string, complex</code>, and <code>bitset</code>. As an <code>ostream</code> user, you need not worry about how these overloads translate objects into readable output.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16ex01">Listing 16-1</a> illustrates how to use the output operator to write various types into <code>cout</code>.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
#include &lt;bitset&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  bitset&lt;8&gt; s{ "01110011" };&#13;
  string str("Crying zeros and I'm hearing ");&#13;
  size_t num{ 111 };&#13;
  cout &lt;&lt; s; <span class="ent">➊</span>&#13;
  cout &lt;&lt; '\n'; <span class="ent">➋</span>&#13;
  cout &lt;&lt; str; <span class="ent">➌</span>&#13;
  cout &lt;&lt; num; <span class="ent">➍</span>&#13;
  cout &lt;&lt; "s\n"; <span class="ent">➎</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">01110011 <span class="ent">➊</span><span class="ent">➋</span></span>&#13;
<span class="color1">Crying zeros and I'm hearing 111s <span class="ent">➌</span><span class="ent">➍</span><span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch16ex01"/><em>Listing 16-1: Using <code>cout</code> and <code>operator&lt;&lt;</code> to write into stdout</em></p>&#13;
<p class="indent">You use the output <code>operator</code><code>&lt;&lt;</code> to write a <code>bitset</code> <span class="ent">➊</span>, a <code>char</code> <span class="ent">➋</span>, a <code>string</code> <span class="ent">➌</span>, a <code>size_t</code> <span class="ent">➍</span>, and a null-terminated string literal <span class="ent">➎</span> to stdout via <code>cout</code>. Even though you write five distinct types to the console, you never deal with serialization issues. (Consider the hoops you would have had to jump through to get <code>printf</code> to yield similar output given these types.)</p>&#13;
<p class="indent">One very nice feature of the standard stream operators is that they generally return a reference to the stream. Conceptually, overloads are typically defined along the following lines:</p>&#13;
<pre>ostream&amp; operator&lt;&lt;(ostream&amp;, char);</pre>&#13;
<p class="indent">This means you can chain output operators together. Using this technique, you can refactor <a href="ch16.xhtml#ch16ex01">Listing 16-1</a> so <code>cout</code> appears only once, as <a href="ch16.xhtml#ch16ex02">Listing 16-2</a> illustrates.</p>&#13;
<pre><span epub:type="pagebreak" id="page_527"/>#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
#include &lt;bitset&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  bitset&lt;8&gt; s{ "01110011" };&#13;
  string str("Crying zeros and I'm hearing ");&#13;
  size_t num{ 111 };&#13;
  cout &lt;&lt; s &lt;&lt; '\n' &lt;&lt; str &lt;&lt; num &lt;&lt; "s\n"; <span class="ent">➊</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">01110011</span>&#13;
<span class="color1">Crying zeros and I'm hearing 111s <span class="ent">➊</span></span></pre>&#13;
<p class="listing"><a id="ch16ex02"/><em>Listing 16-2: Refactoring <a href="ch16.xhtml#ch16ex01">Listing 16-1</a> by chaining output operators together</em></p>&#13;
<p class="indent">Because each invocation of <code>operator&lt;&lt;</code> returns a reference to the output stream (here, <code>cout</code>), you simply chain the calls together to obtain identical output <span class="ent">➊</span>.</p>&#13;
<p class="indent">Input streams overload <code>operator&gt;&gt;</code>, which is referred to as the <em>input operator</em> or the <em>extractor</em>. The <code>basic_istream</code> class has corresponding overloads for the input operator for all the same types as <code>basic_ostream</code>, and again as a user, you can largely ignore the deserialization details.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16ex03">Listing 16-3</a> illustrates how to use the input operator to read two <code>double</code> objects and a <code>string</code> from <code>cin</code>, then print the implied mathematical operation’s result to stdout.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  double x, y;&#13;
  cout &lt;&lt; "X: ";&#13;
  cin &gt;&gt; x; <span class="ent">➊</span>&#13;
  cout &lt;&lt; "Y: ";&#13;
  cin &gt;&gt; y; <span class="ent">➋</span>&#13;
&#13;
  string op;&#13;
  cout &lt;&lt; "Operation: ";&#13;
  cin &gt;&gt; op; <span class="ent">➌</span>&#13;
  if (op == "+") {&#13;
    cout &lt;&lt; x + y; <span class="ent">➍</span>&#13;
  } else if (op == "-") {&#13;
    cout &lt;&lt; x - y; <span class="ent">➎</span>&#13;
  } else if (op == "*") {&#13;
    cout &lt;&lt; x * y; <span class="ent">➏</span>&#13;
  } else if (op == "/") {&#13;
<span epub:type="pagebreak" id="page_528"/>    cout &lt;&lt; x / y; <span class="ent">➐</span>&#13;
  } else {&#13;
    cout &lt;&lt; "Unknown operation " &lt;&lt; op; <span class="ent">➑</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch16ex03"/><em>Listing 16-3: A primitive calculator program using <code>cin</code> and <code>operator&lt;&lt;</code> to collect input</em></p>&#13;
<p class="indent">Here, you collect two <code>double</code>s <code>x</code> <span class="ent">➊</span> and <code>y</code> <span class="ent">➋</span> followed by the <code>string op</code> <span class="ent">➌</span>, which encodes the desired operation. Using an <code>if</code> statement, you can output the specified operation’s result for addition <span class="ent">➍</span>, subtraction <span class="ent">➎</span>, multiplication <span class="ent">➏</span>, and division <span class="ent">➐</span>, or indicate to the user that <code>op</code> is unknown <span class="ent">➑</span>.</p>&#13;
<p class="indent">To use the program, you type the requested values into the console when directed. A newline will send the input (as stdin) to <code>cin</code>, as <a href="ch16.xhtml#ch16ex04">Listing 16-4</a> illustrates.</p>&#13;
<pre>X: 3959 <span class="ent">➊</span>&#13;
Y: 6.283185 <span class="ent">➋</span>&#13;
Operation: * <span class="ent">➌</span>&#13;
24875.1 <span class="ent">➍</span></pre>&#13;
<p class="listing"><a id="ch16ex04"/><em>Listing 16-4: A sample run of the program in <a href="ch16.xhtml#ch16ex03">Listing 16-3</a> that calculates the circumference of Earth in miles</em></p>&#13;
<p class="indent">You input the two <code>double</code> objects: the radius of Earth in miles, <code>3959</code> <span class="ent">➊</span> and 2π, 6.283185 <span class="ent">➋</span>, and you specify multiplication <code>*</code> <span class="ent">➌</span>. The result is Earth’s circumference in miles <span class="ent">➍</span>. Note that you don’t need to provide a decimal point for an integral value <span class="ent">➊</span>; the stream is smart enough to know that there’s an implicit decimal.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You might wonder what happens in <a href="ch16.xhtml#ch16ex04">Listing 16-4</a> if you input a non-numeric string for <code>X</code> <span class="ent">➊</span> or <code>Y</code> <span class="ent">➋</span>. The stream enters an error state, which you’ll learn about later in this chapter in the “Stream State” section on  <a href="ch16.xhtml#page_530">page 530</a>. In an error state, the stream ceases to accept input, and the program won’t accept any more input.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec3"><strong>Unformatted Operations</strong></h5>&#13;
<p class="noindent">When you’re working with text-based streams, you’ll usually want to use formatted operators; however, if you’re working with binary data or if you’re writing code that needs low-level access to streams, you’ll want to know about the unformatted operations. Unformatted I/O involves a lot of detail. For brevity, this section provides a summary of the relevant methods, so if you need to use unformatted operations, refer to [input.output].</p>&#13;
<p class="indent">The <code>istream</code> class has many unformatted input methods. These methods manipulate streams at the byte level and are summarized in <a href="ch16.xhtml#ch16tab03">Table 16-3</a>. In this table, <code>is</code> is of type <code>std::istream &lt;T&gt;, s</code> is a <code>char*, n</code> is a stream size, <code>pos</code> is a position type, and <code>d</code> is a delimiter of type <code>T</code>.</p>&#13;
<p class="tabcap" id="ch16tab03"><span epub:type="pagebreak" id="page_529"/><strong>Table 16-3:</strong> Unformatted Read Operations for <code>istream</code></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Method</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">is.</span><code>get([</code><span class="codestrong">c</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns next character or writes to character reference <span class="codestrong">c</span> if provided.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">is.</span><code>get(</code><span class="codestrong">s</span>,  <span class="codestrong">n</span>, <code>[</code><span class="codestrong">d</span><code>])</code></p>&#13;
<p class="taba"><span class="codestrong">is.</span><code>getline(</code><span class="codestrong">s</span>,  <span class="codestrong">n</span>, <code>[</code><span class="codestrong">d</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The operation <code>get</code> reads up to <span class="codestrong">n</span> characters into the buffer <span class="codestrong">s</span>, stopping if it encounters a newline, or <span class="codestrong">d</span> if provided. The operation <code>getline</code> is the same except it reads the newline character as well. Both write a terminating null character to <span class="codestrong">s</span>. You must ensure <code>s</code> has enough space.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">is.</span><code>read(</code><span class="codestrong">s</span>,  <span class="codestrong">n</span><code>)</code></p>&#13;
<p class="taba"><span class="codestrong">is.</span><code>readsome(</code><span class="codestrong">s</span>,  <span class="codestrong">n</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">The operation <code>read</code> reads up to <span class="codestrong">n</span> characters into the buffer <span class="codestrong">s</span>; encountering end of file is an error. The operation <code>readsome</code> is the same except it doesn’t consider end of file an error.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">is.</span><code>gcount()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the number of characters read by <span class="codestrong">is</span>’s last unformatted read operation.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">is.</span><code>ignore()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Extracts and discards a single character.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">is.</span><code>ignore(</code><span class="codestrong">n</span>, <code>[</code><span class="codestrong">d</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Extracts and discards up to <span class="codestrong">n</span> characters. If <span class="codestrong">d</span> is provided, <code>ignore</code> stops if <span class="codestrong">d</span> is found.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">is.</span><code>peek()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the next character to be read without extracting.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">is.</span><code>unget()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Puts the last extracted character back into the string.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">is.</span><code>putback(</code><span class="codestrong">c</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">If <code>c</code> is the last character extracted, executes <code>unget</code>. Otherwise, sets the <code>badbit</code>. Explained in the “Stream State” section.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Output streams have corollary unformatted write operations, which manipulate streams at a very low level, as summarized in <a href="ch16.xhtml#ch16tab04">Table 16-4</a>. In this table, <code>os</code> is of type <code>std::ostream &lt;T&gt;</code><code>, s</code> is a <code>char*</code>, and <code>n</code> is a stream size.</p>&#13;
<p class="tabcap" id="ch16tab04"><strong>Table 16-4:</strong> Unformatted Write Operations for <code>ostream</code></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Method</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">os.</span><code>put(</code><span class="codestrong">c</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Writes <span class="codestrong">c</span> to the stream</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">os.</span><code>write(</code><span class="codestrong">s</span>,  <span class="codestrong">n</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Writes <span class="codestrong">n</span> characters from <span class="codestrong">s</span> to the stream</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">os.</span><code>flush()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Writes all buffered data to the underlying device</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h5 class="h5" id="ch16lev3sec4"><strong>Special Formatting for Fundamental Types</strong></h5>&#13;
<p class="noindent">All fundamental types, in addition to <code>void</code> and <code>nullptr</code>, have input and output operator overloads, but some have special rules:</p>&#13;
<p class="bq"><span class="codestrong">char</span> <strong>and</strong> <span class="codestrong">wchar_t</span> The input operator skips whitespace when assigning character types.</p>&#13;
<p class="bq"><span class="codestrong">char*</span> <strong>and</strong> <span class="codestrong">wchar_t*</span> The input operator first skips whitespace and then reads the string until it encounters another whitespace or an end-of-file (EOF). You must reserve enough space for the input.</p>&#13;
<p class="bq"><span epub:type="pagebreak" id="page_530"/><span class="codestrong">void*</span> Address formats are implementation dependent for input and output operators. On desktop systems, addresses take hexadecimal literal form, such as <code>0x01234567</code> for 32-bit or <code>0x0123456789abcdef</code> for 64-bit.</p>&#13;
<p class="bq"><span class="codestrong">bool</span> The input and output operators treat Boolean values as numbers: 1 for <code>true</code> and 0 for <code>false</code>.</p>&#13;
<p class="bq"><strong>Numeric types</strong> The input operator requires that input begin with at least one digit. Badly formed input numbers yield a zero-valued result.</p>&#13;
<p class="indent">These rules might seem a bit strange at first, but they’re fairly straightforward once you get used to them.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Avoid reading into C-style strings, because it’s up to you to ensure that you’ve allocated enough space for the input data. Failure to perform adequate checking results in undefined behavior and possibly major security vulnerabilities. Use <code>std::string</code> instead.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch16lev2sec2"><strong><em>Stream State</em></strong></h4>&#13;
<p class="noindent">A stream’s state indicates whether I/O failed. Each stream type exposes the constant static members referred to collectively as its <em>bits</em>, which indicate a possible stream state: <code>goodbit, badbit, eofbit</code>, and <code>failbit</code>. To determine whether a stream is in a particular state, you invoke member functions that return a <code>bool</code> indicating whether the stream is in the corresponding state. <a href="ch16.xhtml#ch16tab05">Table 16-5</a> lists these member functions, the stream state corresponding to a <code>true</code> result, and the state’s meaning.</p>&#13;
<p class="tabcap" id="ch16tab05"><strong>Table 16-5:</strong> The Possible Stream States, Their Accessor Methods, and Their Meanings</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Method</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>State</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Meaning</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>good()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>goodbit</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">The stream is in a good working state.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>eof()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>eofbit</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The stream encountered an EOF.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>fail()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>failbit</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">An input or output operation failed, but the stream might still be in a good working state.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>bad()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>badbit</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">A catastrophic error occurred, and the stream is not in a good state.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>To reset a stream’s status to indicate a good working state, you can invoke its <code>clear()</code> method.</em></p>&#13;
</div>&#13;
<p class="indent">Streams implement an implicit bool conversion (<code>operator bool</code>), so you can check whether a stream is in a good working state simply and directly. For example, you can read input from stdin word by word until it encounters an EOF (or some other failure condition) using a simple <code>while</code> loop. <a href="ch16.xhtml#ch16ex05">Listing 16-5</a> illustrates a simple program that uses this technique to generate word counts from stdin.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
int main() {&#13;
  std::string word; <span class="ent">➊</span>&#13;
  size_t count{}; <span class="ent">➋</span>&#13;
  while (std::cin &gt;&gt; word) <span class="ent">➌</span>&#13;
    count++; <span class="ent">➍</span>&#13;
  std::cout &lt;&lt; "Discovered " &lt;&lt; count &lt;&lt; " words.\n"; <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="listing"><span epub:type="pagebreak" id="page_531"/><a id="ch16ex05"/><em>Listing 16-5: A program that counts words from stdin</em></p>&#13;
<p class="indent">You declare a <code>string</code> called <code>word</code> to receive words from stdin <span class="ent">➊</span>, and you initialize a <code>count</code> variable to zero <span class="ent">➋</span>. Within the <code>while</code> loop’s Boolean expression, you attempt to assign new input into <code>word</code> <span class="ent">➌</span>. When this succeeds, you increment <code>count</code> <span class="ent">➍</span>. Once it fails—for example, due to encountering an EOF—you cease incrementing and print the final tally <span class="ent">➎</span>.</p>&#13;
<p class="indent">You can try two methods to test <a href="ch16.xhtml#ch16ex05">Listing 16-5</a>. First, you can simply invoke the program, enter some input, and provide an EOF. How to send EOF depends on your operating system. In the Windows command line, you can enter EOF by pressing <small>CTRL</small>-Z and pressing enter. In Linux bash or in the OS X shell, you press <small>CTRL</small>-D. <a href="ch16.xhtml#ch16ex06">Listing 16-6</a> demonstrates how to invoke <a href="ch16.xhtml#ch16ex05">Listing 16-5</a> from the Windows command line.</p>&#13;
<pre>$ <span class="codestrong1">listing_16_5.exe</span> <span class="ent">➊</span>&#13;
<span class="codestrong1">Size matters not. Look at me. Judge me by my size, do you? Hmm? Hmm. And well&#13;
you should not. For my ally is the Force, and a powerful ally it is. Life&#13;
creates it, makes it grow. Its energy surrounds us and binds us. Luminous&#13;
beings are we, not this crude matter. You must feel the Force around you;&#13;
here, between you, me, the tree, the rock, everywhere, yes. <span class="ent">➋</span></span>&#13;
<span class="codestrong1">^Z</span> <span class="ent">➌</span>&#13;
Discovered 70 words. <span class="ent">➍</span></pre>&#13;
<p class="listing"><a id="ch16ex06"/><em>Listing 16-6: Invoking the program in <a href="ch16.xhtml#ch16ex05">Listing 16-5</a> by typing input into the console</em></p>&#13;
<p class="indent">First, you invoke your program <span class="ent">➊</span>. Next, enter some arbitrary text followed by a new line <span class="ent">➋</span>. Then issue EOF. The Windows command line shows the somewhat cryptic sequence <strong>^Z</strong> on the command line, after which you must press <small>ENTER</small>. This causes <code>std::cin</code> to enter the <code>eofbit</code> state, ending the <code>while</code> loop in <a href="ch16.xhtml#ch16ex05">Listing 16-5</a> <span class="ent">➌</span>. The program indicates that you’ve sent 70 words into stdin <span class="ent">➍</span>.</p>&#13;
<p class="indent">On Linux and Mac and in Windows PowerShell, you have another option. Rather than entering the input directly into the console, you can save the text to a file, say <em>yoda.txt</em>. The trick is to use <code>cat</code> to read the text file and then use the pipe operator <code>|</code> to send the contents to your program. The pipe operator “pipes” the stdout of the program to its left into the stdin of the program on the right. The following command illustrates this process:</p>&#13;
<pre>$ <span class="codestrong1">cat yoda.txt</span><span class="ent">➊</span> |<span class="ent">➋</span> <span class="codestrong1">./listing_15_4</span><span class="ent">➌</span>&#13;
Discovered 70 words.</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_532"/>The <code>cat</code> command reads the contents of <em>yoda.txt</em> <span class="ent">➊</span>. The pipe operator <span class="ent">➋</span> pipes the stdout of <code>cat</code> into stdin of <code>listing_15_4</code> <span class="ent">➌</span>. Because <code>cat</code> sends EOF when it encounters the end of <em>yoda.txt</em>, you don’t need to enter it manually.</p>&#13;
<p class="indent">Sometimes you’ll want streams to throw an exception when certain fail bits occur. You can do this easily with a stream’s <code>exceptions</code> method, which accepts a single argument corresponding to the bit you want to throw exceptions. If you desire multiple bits, you can simply join them together using Boolean OR (<code>|</code>).</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16ex07">Listing 16-7</a> illustrates how to refactor <a href="ch16.xhtml#ch16ex05">Listing 16-5</a> so it handles the <code>badbit</code> with exceptions and <code>eofbit</code>/<code>failbit</code> with the default handling.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  cin.exceptions(istream::badbit); <span class="ent">➊</span>&#13;
  string word;&#13;
  size_t count{};&#13;
  try { <span class="ent">➋</span>&#13;
    while(cin &gt;&gt; word) <span class="ent">➌</span>&#13;
      count++;&#13;
    cout &lt;&lt; "Discovered " &lt;&lt; count &lt;&lt; " words.\n"; <span class="ent">➍</span>&#13;
  } catch (const std::exception&amp; e) { <span class="ent">➎</span>&#13;
    cerr &lt;&lt; "Error occurred reading from stdin: " &lt;&lt; e.what(); <span class="ent">➏</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch16ex07"/><em>Listing 16-7: Refactoring <a href="ch16.xhtml#ch16ex05">Listing 16-5</a> to handle <code>badbit</code> with exceptions</em></p>&#13;
<p class="indent">You start the program by invoking the exceptions method on <code>std::cin</code> <span class="ent">➊</span>. Because <code>cin</code> is an <code>istream</code>, you pass <code>istream::badbit</code> as the argument of <code>exception</code>, indicating that you want <code>cin</code> to throw an exception any time it gets into a catastrophic state. To account for possible exceptions, you wrap the existing code in a <code>try</code>-<code>catch</code> block <span class="ent">➋</span>, so if <code>cin</code> sets <code>badbit</code> while it’s reading input <span class="ent">➌</span>, the user never receives a message about the word count <span class="ent">➍</span>. Instead, the program catches the resulting exception <span class="ent">➎</span> and prints the error message <span class="ent">➏</span>.</p>&#13;
<h4 class="h4" id="ch16lev2sec3"><strong><em>Buffering and Flushing</em></strong></h4>&#13;
<p class="noindent">Many <code>ostream</code> class templates involve operating system calls under the hood, for example, to write to a console, a file, or a network socket. Relative to other function calls, system calls are usually slow. Rather than invoking a system call for each output element, an application can wait for multiple elements and then send them all together to improve performance.</p>&#13;
<p class="indent">The queuing behavior is called <em>buffering</em>. When the stream empties the buffered output, it’s called <em>flushing</em>. Usually, this behavior is completely transparent to the user, but sometimes you want to manually flush the <code>ostream</code>. For this (and other tasks), you turn to manipulators.</p>&#13;
<h4 class="h4" id="ch16lev2sec4"><span epub:type="pagebreak" id="page_533"/><strong><em>Manipulators</em></strong></h4>&#13;
<p class="noindent"><em>Manipulators</em> are special objects that modify how streams interpret input or format output. Manipulators exist to perform many kinds of stream alterations. For example, <code>std::ws</code> modifies an <code>istream</code> to skip over whitespace. Here are some other manipulators that work on <code>ostreams</code>:</p>&#13;
<ul>&#13;
<li class="noindent"><code>std::flush</code> empties any buffered output directly to an <code>ostream</code>.</li>&#13;
<li class="noindent"><code>std::ends</code> sends a null byte.</li>&#13;
<li class="noindent"><code>std::endl</code> is like <code>std::flush</code> except it sends a newline before flushing.</li>&#13;
</ul>&#13;
<p class="indent"><a href="ch16.xhtml#ch16tab06">Table 16-6</a> summarizes the manipulators in the <code>&lt;istream&gt;</code> and <code>&lt;ostream&gt;</code> headers.</p>&#13;
<p class="tabcap" id="ch16tab06"><strong>Table 16-6:</strong> Four Manipulators in the <code>&lt;istream&gt;</code> and <code>&lt;ostream&gt;</code> Headers</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Manipulator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Class</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Behavior</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>ws</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>istream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Skips over all whitespaces</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>flush</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>ostream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Writes any buffered data to the stream by invoking its <code>flush</code> method</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>ends</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>ostream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Sends a null byte</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>endl</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>ostream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Sends a newline and flushes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">For example, you could replace <span class="ent">➍</span> in <a href="ch16.xhtml#ch16ex07">Listing 16-7</a> with the following:</p>&#13;
<pre>cout &lt;&lt; "Discovered " &lt;&lt; count &lt;&lt; " words." &lt;&lt; endl;</pre>&#13;
<p class="indent">This will print a newline and also flush output.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>As a general rule, use <code>std::endl</code> when your program has finished outputting text to the stream for a while and <code>\n</code> when you know your program will output more text soon.</em></p>&#13;
</div>&#13;
<p class="indent">The stdlib provides many other manipulators in the <code>&lt;ios&gt;</code> header. You can, for example, determine whether an <code>ostream</code> will represent Boolean values textually (<code>boolalpha</code>) or numerically (<code>noboolalpha</code>); integral values as octal (<code>oct</code>), decimal (<code>dec</code>), or hexadecimal (<code>hex</code>); and floating-point numbers as decimal notation (<code>fixed</code>) or scientific notation (<code>scientific</code>). Simply pass one of these manipulators to an <code>ostream</code> using <code>operator&lt;&lt;</code> and <em>all</em> subsequent insertions of the corresponding type will be manipulated (not just an immediately preceding operand).</p>&#13;
<p class="indent">You can also set a stream’s width parameter using the <code>setw</code> manipulator. A stream’s width parameter has varied effects, depending on the stream. For example, with <code>std::cout, setw</code> will fix the number of output characters allocated to the next output object. Additionally, for floating-point output, <code>setprecision</code> will set the following numbers’ precision.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_534"/><a href="ch16.xhtml#ch16ex08">Listing 16-8</a> illustrates how these manipulators perform functions similar to those of the various <code>printf</code> format specifiers.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;iomanip&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  cout &lt;&lt; "Gotham needs its " &lt;&lt; boolalpha &lt;&lt; true &lt;&lt; " hero."; <span class="ent">➊</span>&#13;
  cout &lt;&lt; "\nMark it " &lt;&lt; noboolalpha &lt;&lt; false &lt;&lt; "!"; <span class="ent">➋</span>&#13;
  cout &lt;&lt; "\nThere are " &lt;&lt; 69 &lt;&lt; "," &lt;&lt; oct &lt;&lt; 105 &lt;&lt; " leaves in here."; <span class="ent">➌</span>&#13;
  cout &lt;&lt; "\nYabba " &lt;&lt; hex &lt;&lt; 3669732608 &lt;&lt; "!"; <span class="ent">➍</span>&#13;
  cout &lt;&lt; "\nAvogadro's number: " &lt;&lt; scientific &lt;&lt; 6.0221415e-23; <span class="ent">➎</span>&#13;
  cout &lt;&lt; "\nthe Hogwarts platform: " &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; 9.750123; <span class="ent">➏</span>&#13;
  cout &lt;&lt; "\nAlways eliminate " &lt;&lt; 3735929054; <span class="ent">➐</span>&#13;
  cout &lt;&lt; setw(4) &lt;&lt; "\n"&#13;
       &lt;&lt; 0x1 &lt;&lt; "\n"&#13;
       &lt;&lt; 0x10 &lt;&lt; "\n"&#13;
       &lt;&lt; 0x100 &lt;&lt; "\n"&#13;
       &lt;&lt; 0x1000 &lt;&lt; endl; <span class="ent">➑</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Gotham needs its true hero. <span class="ent">➊</span></span>&#13;
<span class="color1">Mark it 0! <span class="ent">➋</span></span>&#13;
<span class="color1">There are 69,151 leaves in here. <span class="ent">➌</span></span>&#13;
<span class="color1">Yabba dabbad00! <span class="ent">➍</span></span>&#13;
<span class="color1">Avogadro's Number: 6.022142e-23 <span class="ent">➎</span></span>&#13;
<span class="color1">the Hogwarts platform: 9.75 <span class="ent">➏</span></span>&#13;
<span class="color1">Always eliminate deadc0de <span class="ent">➐</span></span>&#13;
<span class="color1">1</span>&#13;
<span class="color1">10</span>&#13;
<span class="color1">100</span>&#13;
<span class="color1">1000 <span class="ent">➑</span></span></pre>&#13;
<p class="listing"><a id="ch16ex08"/><em>Listing 16-8: A program illustrating some of the manipulators available in the <code>&lt;iomanip&gt;</code> header</em></p>&#13;
<p class="indent">The <code>boolalpha</code> manipulator in the first line causes Boolean values to print textually as <code>true</code> and <code>false</code> <span class="ent">➊</span>, whereas <code>noboolalpha</code> causes them to print as 1 and 0 instead <span class="ent">➋</span>. For integral values, you can print as octal with <code>oct</code> <span class="ent">➌</span> or hexadecimal with <code>hex</code> <span class="ent">➍</span>. For floating-point values, you can specify scientific notation with <code>scientific</code> <span class="ent">➎</span>, and you can set the number of digits to print with <code>setprecision</code> and specify decimal notation with <code>fixed</code> <span class="ent">➏</span>. Because manipulators apply to all subsequent objects you insert into a stream, when you print another integral value at the end of the program, the last integral manipulator (<code>hex</code>) applies, so you get a hexadecimal representation <span class="ent">➐</span>. Finally, you employ <code>setw</code> to set the field width for output to 4, and you print some integral values <span class="ent">➑</span>.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16tab07">Table 16-7</a> summarizes this sampling of common manipulators.</p>&#13;
<p class="tabcap" id="ch16tab07"><span epub:type="pagebreak" id="page_535"/><strong>Table 16-7:</strong> Many of the Manipulators Available in the <code>&lt;iomanip&gt;</code> Header</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Manipulator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Behavior</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>boolalpha</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Represents Booleans textually rather than numerically.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>noboolalpha</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Represents Booleans numerically rather than textually.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>oct</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Represents integral values as octal.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>dec</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Represents integral values as decimal.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>hex</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Represents integral values as hexadecimal.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>setw(</code><span class="codestrong">n</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Sets the width parameter of a stream to <span class="codestrong">n</span>. The exact effect depends on the stream.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>setprecision(</code><span class="codestrong">p</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Specifies floating-point precision as <span class="codestrong">p</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>fixed</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Represents floating-point numbers in decimal notation.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>scientific</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Represents floating-point numbers in scientific notation.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Refer to <a href="ch15.xhtml#ch15">Chapter 15</a> in <em>The C++ Standard Library</em>, 2nd Edition, by Nicolai M. Josuttis or [iostream.format].</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch16lev2sec5"><strong><em>User-Defined Types</em></strong></h4>&#13;
<p class="noindent">You can make user-defined types work with streams by implementing certain non-member functions. To implement the output operator for type <code>YourType</code>, the following function declaration serves most purposes:</p>&#13;
<pre>ostream&amp;<span class="ent">➊</span> operator&lt;&lt;(ostream&amp;<span class="ent">➋</span> s, const YourType&amp; m <span class="ent">➌</span>);</pre>&#13;
<p class="indent">For most cases, you’ll simply return <span class="ent">➊</span> the same <code>ostream</code> you receive <span class="ent">➋</span>. It’s up to you how to send output into the <code>ostream</code>. But typically, this involves accessing fields on <code>YourType</code> <span class="ent">➌</span>, optionally performing some formatting and transformations, and then using the output operator. For example, <a href="ch16.xhtml#ch16ex09">Listing 16-9</a> shows how to implement an output operator for <code>std::vector</code> to print its size, capacity, and elements.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;vector&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
template &lt;typename T&gt;&#13;
ostream&amp; operator&lt;&lt;(ostream&amp; s, vector&lt;T&gt; v) { <span class="ent">➊</span>&#13;
  s &lt;&lt; "Size: " &lt;&lt; v.size()&#13;
    &lt;&lt; "\nCapacity: " &lt;&lt; v.capacity()&#13;
    &lt;&lt; "\nElements:\n"; <span class="ent">➋</span>&#13;
  for (const auto&amp; element : v)&#13;
    s &lt;&lt; "\t" &lt;&lt; element &lt;&lt; "\n"; <span class="ent">➌</span>&#13;
  return s; <span class="ent">➍</span>&#13;
}&#13;
&#13;
<span epub:type="pagebreak" id="page_536"/>int main() {&#13;
  const vector&lt;string&gt; characters {&#13;
    "Bobby Shaftoe",&#13;
    "Lawrence Waterhouse",&#13;
    "Gunter Bischoff",&#13;
    "Earl Comstock"&#13;
  }; <span class="ent">➎</span>&#13;
  cout &lt;&lt; characters &lt;&lt; endl; <span class="ent">➏</span>&#13;
&#13;
  const vector&lt;bool&gt; bits { true, false, true, false }; <span class="ent">➐</span>&#13;
  cout &lt;&lt; boolalpha &lt;&lt; bits &lt;&lt; endl; <span class="ent">➑</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Size: 4</span>&#13;
<span class="color1">Capacity: 4</span>&#13;
<span class="color1">Elements: <span class="ent">➋</span></span>&#13;
<span class="color1">        Bobby Shaftoe <span class="ent">➌</span></span>&#13;
<span class="color1">        Lawrence Waterhouse <span class="ent">➌</span></span>&#13;
<span class="color1">        Gunter Bischoff <span class="ent">➌</span></span>&#13;
<span class="color1">        Earl Comstock <span class="ent">➌</span></span>&#13;
&#13;
<span class="color1">Size: 4</span>&#13;
<span class="color1">Capacity: 32</span>&#13;
<span class="color1">Elements: <span class="ent">➋</span></span>&#13;
<span class="color1">        true <span class="ent">➌</span></span>&#13;
<span class="color1">        false <span class="ent">➌</span></span>&#13;
<span class="color1">        true <span class="ent">➌</span></span>&#13;
<span class="color1">        false <span class="ent">➌</span></span></pre>&#13;
<p class="listing"><a id="ch16ex09"/><em>Listing 16-9: A program illustrating how to implement an output operator for a <code>vector</code></em></p>&#13;
<p class="indent">First, you define a custom output operator as a template, using the template parameter as the template parameter of <code>std::vector</code> <span class="ent">➊</span>. This allows you to use the output operator for many kinds of <code>vector</code>s (as long as the type <code>T</code> also supports the output operator). The first three lines of output give the size and capacity of <code>vector</code>, as well as the title <code>Elements</code> indicating that the elements of the <code>vector</code> follow <span class="ent">➋</span>. The following <code>for</code> loop iterates over each element in the <code>vector</code>, sending each on a separate line to the <code>ostream</code> <span class="ent">➌</span>. Finally, you return the stream reference <code>s</code> <span class="ent">➍</span>.</p>&#13;
<p class="indent">Within <code>main</code>, you initialize a <code>vector</code> called <code>characters</code> containing four strings <span class="ent">➎</span>. Thanks to your user-defined output operator, you can simply send <code>characters</code> to <code>cout</code> as if it were a fundamental type <span class="ent">➏</span>. The second example uses a <code>vector&lt;bool&gt;</code> called <code>bits</code>, which you also initialize with four elements <span class="ent">➐</span> and print to stdout <span class="ent">➑</span>. Notice that you use the <code>boolalpha</code> manipulator, so when your user-defined output operator runs, the <code>bool</code> elements print textually <span class="ent">➌</span>.</p>&#13;
<p class="indent">You can also provide user-defined input operators, which work similarly. A simple corollary is as follows:</p>&#13;
<pre>istream&amp;<span class="ent">➊</span> operator&gt;&gt;(istream&amp;<span class="ent">➋</span> s, YourType&amp; m <span class="ent">➌</span>);</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_537"/>As with the output operator, the input operator typically returns <span class="ent">➊</span> the same stream it receives <span class="ent">➋</span>. However, unlike with the output operator, the <code>YourType</code> reference will generally not be <code>const</code>, because you’ll want to modify the corresponding object using input from the stream <span class="ent">➌</span>.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16ex10">Listing 16-10</a> illustrates how to specify an input operator for <code>deque</code> so it pushes elements into the container until an insertion fails (for example, due to an EOF character).</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;deque&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
template &lt;typename T&gt;&#13;
istream&amp; operator&gt;&gt;(istream&amp; s, deque&lt;T&gt;&amp; t) { <span class="ent">➊</span>&#13;
  T element; <span class="ent">➋</span>&#13;
  while (s &gt;&gt; element) <span class="ent">➌</span>&#13;
    t.emplace_back(move(element)); <span class="ent">➍</span>&#13;
  return s; <span class="ent">➎</span>&#13;
}&#13;
&#13;
int main() {&#13;
  cout &lt;&lt; "Give me numbers: "; <span class="ent">➏</span>&#13;
  deque&lt;int&gt; numbers;&#13;
  cin &gt;&gt; numbers; <span class="ent">➐</span>&#13;
  int sum{};&#13;
  cout &lt;&lt; "Cumulative sum:\n";&#13;
  for(const auto&amp; element : numbers) {&#13;
    sum += element;&#13;
    cout &lt;&lt; sum &lt;&lt; "\n"; <span class="ent">➑</span>&#13;
  }&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Give me numbers: <span class="ent">➏</span> 1 2 3 4 5 <span class="ent">➐</span></span>&#13;
<span class="color1">Cumulative sum:</span>&#13;
<span class="color1">1  <span class="ent">➑</span></span>&#13;
<span class="color1">3  <span class="ent">➑</span></span>&#13;
<span class="color1">6  <span class="ent">➑</span></span>&#13;
<span class="color1">10 <span class="ent">➑</span></span>&#13;
<span class="color1">15 <span class="ent">➑</span></span></pre>&#13;
<p class="listing"><a id="ch16ex10"/><em>Listing 16-10: A program illustrating how to implement an input operator for a <code>deque</code></em></p>&#13;
<p class="indent">Your user-defined input operator is a function template so you can accept any <code>deque</code> containing a type that supports the input operator <span class="ent">➊</span>. First, you construct an element of type <code>T</code> so you can store input from the <code>istream</code> <span class="ent">➋</span>. Next, you use the familiar <code>while</code> construct to accept input from the <code>istream</code> until the input operation fails <span class="ent">➌</span>. (Recall from the “Stream State” section that streams can get into failed states in many ways, including reaching an EOF or encountering an I/O error.) After each insertion, you <code>move</code> the result into <code>emplace_back</code> on the <code>deque</code> to avoid unnecessary copies <span class="ent">➍</span>. Once you’re done inserting, you simply return the <code>istream</code> reference <span class="ent">➎</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_538"/>Within <code>main</code>, you prompt the user for numbers <span class="ent">➏</span> and then use the insertion operator on a newly initialized <code>deque</code> to insert elements from stdin. In this sample program run, you input the numbers 1 to 5 <span class="ent">➐</span>. For a bit of fun, you compute a cumulative sum by keeping a tally and iterating over each element, printing that iteration’s result <span class="ent">➑</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The preceding examples are simple user-defined implementations of input and output operators. You might want to elaborate these implementations in production code. For example, the implementations only work with <code>ostream</code> classes, which implies that they won’t work with any non-<code>char</code> sequences.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch16lev2sec6"><strong><em>String Streams</em></strong></h4>&#13;
<p class="noindent">The <em>string stream classes</em> provide facilities for reading from and writing to character sequences. These classes are useful in several situations. Input strings are especially useful if you want to parse string data into types. Because you can use the input operator, all the standard manipulator facilities are available to you. Output strings are excellent for building up strings from variable-length input.</p>&#13;
<h5 class="h5" id="ch16lev3sec5"><strong>Output String Streams</strong></h5>&#13;
<p class="noindent"><em>Output string streams</em> provide output-stream semantics for character sequences, and they all derive from the class template <code>std::basic_ostringstream</code> in the <code>&lt;sstream&gt;</code> header, which provides the following specializations:</p>&#13;
<pre>using ostringstream = basic_ostringstream&lt;char&gt;;&#13;
using wostringstream = basic_ostringstream&lt;wchar_t&gt;;</pre>&#13;
<p class="indent">The output string streams support all the same features as an <code>ostream</code>. Whenever you send input to the string stream, the stream stores this input into an internal buffer. You can think of this as functionally equivalent to the <code>append</code> operation of <code>string</code> (except that string streams are potentially more efficient).</p>&#13;
<p class="indent">Output string streams also support the <code>str()</code> method, which has two modes of operation. Given no argument, <code>str</code> returns a copy of the internal buffer as a <code>basic_string</code> (so <code>ostringstream</code> returns a <code>string</code>; <code>wostringstream</code> returns a <code>wstring</code>). Given a single <code>basic_string</code> argument, the string stream will replace its buffer’s current contents with the contents of the argument. <a href="ch16.xhtml#ch16ex11">Listing 16-11</a> illustrates how to use an <code>ostringstream</code>, send character data to it, build a <code>string</code>, reset its contents, and repeat.</p>&#13;
<pre>#include &lt;string&gt;&#13;
#include &lt;sstream&gt;&#13;
&#13;
TEST_CASE("ostringstream produces strings with str") {&#13;
  std::ostringstream ss; <span class="ent">➊</span>&#13;
  ss &lt;&lt; "By Grabthar's hammer, ";&#13;
  ss &lt;&lt; "by the suns of Worvan. ";&#13;
&#13;
  ss &lt;&lt; "You shall be avenged."; <span class="ent">➋</span>&#13;
  const auto lazarus = ss.str(); <span class="ent">➌</span>&#13;
&#13;
  ss.str("I am Groot."); <span class="ent">➍</span>&#13;
  const auto groot = ss.str(); <span class="ent">➎</span>&#13;
&#13;
  REQUIRE(lazarus == "By Grabthar's hammer, by the suns"&#13;
                     " of Worvan. You shall be avenged.");&#13;
  REQUIRE(groot == "I am Groot.");&#13;
}</pre>&#13;
<p class="listing"><span epub:type="pagebreak" id="page_539"/><a id="ch16ex11"/><em>Listing 16-11: Using an <code>ostringstream</code> to build strings</em></p>&#13;
<p class="indent">After declaring an <code>ostringstream</code> <span class="ent">➊</span>, you treat it just like any other <code>ostream</code> and use the output operator to send it three separate character sequences <span class="ent">➋</span>. Next, you invoke <code>str</code> without an argument, which produces a <code>string</code> called <code>lazarus</code> <span class="ent">➌</span>. Then you invoke <code>str</code> with the string literal <code>I am Groot</code> <span class="ent">➍</span>, which replaces the contents of <code>ostringstream</code> <span class="ent">➎</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Recall from “C-Style Strings” on <a href="ch02.xhtml#page_45">page 45</a> that you can place multiple string literals on consecutive lines and the compiler will treat them as one. This is done purely for source code–formatting purposes.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec6"><strong>Input String Streams</strong></h5>&#13;
<p class="noindent"><em>Input string streams</em> provide input stream semantics for character sequences, and they all derive from the class template <code>std::basic_istringstream</code> in the <code>&lt;sstream&gt;</code> header, which provides the following specializations:</p>&#13;
<pre>using istringstream = basic_istringstream&lt;char&gt;;&#13;
using wistringstream = basic_istringstream&lt;wchar_t&gt;;</pre>&#13;
<p class="indent">These are analogous to the <code>basic_ostringstream</code> specializations. You can construct input string streams by passing a <code>basic_string</code> with appropriate specialization (<code>string</code> for an <code>istringstream</code> and <code>wstring</code> for a <code>wistringstream</code>). <a href="ch16.xhtml#ch16ex12">Listing 16-12</a> illustrates by constructing an input string stream with a string containing three numbers and using the input operator to extract them. (Recall from “Formatted Operations” on <a href="ch16.xhtml#page_525">page 525</a> that whitespace is the appropriate delimiter for string data.)</p>&#13;
<pre>TEST_CASE("istringstream supports construction from a string") {&#13;
  std::string numbers("1 2.23606 2"); <span class="ent">➊</span>&#13;
  std::istringstream ss{ numbers }; <span class="ent">➋</span>&#13;
  int a;&#13;
  float b, c, d;&#13;
  ss &gt;&gt; a; <span class="ent">➌</span>&#13;
  ss &gt;&gt; b; <span class="ent">➍</span>&#13;
  ss &gt;&gt; c;&#13;
  REQUIRE(a == 1);&#13;
  REQUIRE(b == Approx(2.23606));&#13;
  REQUIRE(c == Approx(2));&#13;
  REQUIRE_FALSE(ss &gt;&gt; d); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="listing"><span epub:type="pagebreak" id="page_540"/><a id="ch16ex12"/><em>Listing 16-12: Using a <code>string</code> to build <code>istringstream</code> objects and extract numeric types</em></p>&#13;
<p class="indent">You construct a <code>string</code> from the literal <code>1 2.23606 2</code> <span class="ent">➊</span>, which you pass into the constructor of an <code>istringstream</code> called <code>ss</code> <span class="ent">➋</span>. This allows you to use the input operator to parse out <code>int</code> objects <span class="ent">➌</span> and <code>float</code> objects <span class="ent">➍</span> just like any other input stream. Once you’ve exhausted the stream and the output operator fails, <code>ss</code> converts to <code>false</code> <span class="ent">➎</span>.</p>&#13;
<h5 class="h5" id="ch16lev3sec7"><strong>String Streams Supporting Input and Output</strong></h5>&#13;
<p class="noindent">Additionally, if you want a string stream that supports input and output operations, you can use the <code>basic_stringstream</code>, which has the following specializations:</p>&#13;
<pre>using stringstream = basic_stringstream&lt;char&gt;;&#13;
using wstringstream = basic_stringstream&lt;wchar_t&gt;;</pre>&#13;
<p class="indent">This class supports the input and output operators, the <code>str</code> method, and construction from a string. <a href="ch16.xhtml#ch16ex13">Listing 16-13</a> illustrates how to use a combination of input and output operators to extract tokens from a string.</p>&#13;
<pre>TEST_CASE("stringstream supports all string stream operations") {&#13;
  std::stringstream ss;&#13;
  ss &lt;&lt; "Zed's DEAD"; <span class="ent">➊</span>&#13;
&#13;
  std::string who;&#13;
  ss &gt;&gt; who; <span class="ent">➋</span>&#13;
  int what;&#13;
  ss &gt;&gt; std::hex &gt;&gt; what; <span class="ent">➌</span>&#13;
&#13;
  REQUIRE(who == "Zed's");&#13;
  REQUIRE(what == 0xdead);&#13;
}</pre>&#13;
<p class="listing"><a id="ch16ex13"/><em>Listing 16-13: Using a <code>stringstream</code> for input and output</em></p>&#13;
<p class="indent">You create a <code>stringstream</code> and sent the <code>Zed's DEAD</code> with the output operator <span class="ent">➊</span>. Next, you parse <code>Zed's</code> out of the <code>stringstream</code> using the input operator <span class="ent">➋</span>. Because <code>DEAD</code> is a valid hexadecimal integer, you use the input operator and the <code>std::hex</code> manipulator to extract it into an <code>int</code> <span class="ent">➌</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>All string streams are moveable.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch16lev3sec8"><strong>Summary of String Stream Operations</strong></h5>&#13;
<p class="noindent"><a href="ch16.xhtml#ch16tab08">Table 16-8</a> provides a partial list of <code>basic_stringstream</code> operations. In this table, <code>ss, ss1</code>, and <code>ss2</code> are of type <code>std::basic_stringstream&lt;T&gt;</code>; <code>s</code> is a <span epub:type="pagebreak" id="page_541"/><code>std::basic_string&lt;</code><code>T</code><code>&gt;</code>; <code>obj</code> is a formatted object; <code>pos</code> is a position type; <code>dir</code> is a <code>std::ios_base::seekdir</code>; and <code>flg</code> is a <code>std::ios_base::iostate</code>.</p>&#13;
<p class="tabcap" id="ch16tab08"><strong>Table 16-8:</strong> A Partial List of <code>std::basic_stringstream</code> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>basic_stringstream&lt;</code><span class="codestrong">T</span><code>&gt;</code></p>&#13;
<p class="taba"><code>  { [</code><span class="codestrong">s</span><code>], [</code><span class="codestrong">om</span><code>] }</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Performs braced initialization of a newly constructed string stream. Defaults to empty string <span class="codestrong">s</span> and <code>in|out</code> open mode <span class="codestrong">om</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>basic_stringstream&lt;</code><span class="codestrong">T</span><code>&gt;</code></p>&#13;
<p class="taba"><code>  { move(</code><span class="codestrong">ss</span><code>) }</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Takes ownership of <span class="codestrong">ss</span>’s internal buffer.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>~basic_stringstream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Destructs internal buffer.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">ss.</span><code>rdbuf()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns raw string device object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">ss.</span><code>str()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Gets the contents of the string device object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">ss.</span><code>str(</code><span class="codestrong">s</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Sets the contents of the string device object to <span class="codestrong">s</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">ss</span>  <code>&gt;&gt;</code>  <span class="codestrong">obj</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Extracts formatted data from the string stream.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">ss</span>  <code>&lt;&lt;</code>  <span class="codestrong">obj</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Inserts formatted data into the string stream.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">ss.</span><code>tellg()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the input position index.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">ss.</span><code>seekg(</code><span class="codestrong">pos</span><code>)</code></p>&#13;
<p class="taba"><span class="codestrong">ss.</span><code>seekg(</code><span class="codestrong">pos</span>,  <span class="codestrong">dir</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Sets the input position indicator.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">ss.</span><code>flush()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Synchronizes the underlying device.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">ss.</span><code>good()</code></p>&#13;
<p class="taba"><span class="codestrong">ss.</span><code>eof()</code></p>&#13;
<p class="taba"><span class="codestrong">ss.</span><code>bad()</code></p>&#13;
<p class="taba"><span class="codestrong">!ss</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Inspects the string stream’s bits.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">ss.</span><code>exceptions(</code><span class="codestrong">flg</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Configures the string stream to throw an exception whenever a bit in <span class="codestrong">flg</span> gets set.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">ss1.</span><code>swap(</code><span class="codestrong">ss2</span><code>)</code></p>&#13;
<p class="taba"><code>swap(</code><span class="codestrong">ss1</span>,  <span class="codestrong">ss2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Exchanges each element of <span class="codestrong">ss1</span> with those of <span class="codestrong">ss2</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch16lev2sec7"><strong><em>File Streams</em></strong></h4>&#13;
<p class="noindent">The <em>file stream classes</em> provide facilities for reading from and writing to character sequences. The file stream class structure follows that of the string stream classes. File stream class templates are available for input, output, and both.</p>&#13;
<p class="indent">File stream classes provide the following major benefits over using native system calls to interact with file contents:</p>&#13;
<ul>&#13;
<li class="noindent">You get the usual stream interfaces, which provide a rich set of features for formatting and manipulating output.</li>&#13;
<li class="noindent">The file stream classes are RAII wrappers around the files, meaning it’s impossible to leak resources, such as files.</li>&#13;
<li class="noindent">File stream classes support move semantics, so you can have tight control over where files are in scope.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch16lev3sec9"><span epub:type="pagebreak" id="page_542"/><strong>Opening Files with Streams</strong></h5>&#13;
<p class="noindent">You have two options for opening a file with any file stream. The first option is the <code>open</code> method, which accepts a <code>const char* filename</code> and an optional <code>std::ios_base::openmode</code> bitmask argument. The <code>openmode</code> argument can be one of the many possible combinations of values listed in <a href="ch16.xhtml#ch16tab09">Table 16-9</a>.</p>&#13;
<p class="tabcap" id="ch16tab09"><strong>Table 16-9:</strong> Possible Stream States, Their Accessor Methods, and Their Meanings</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Flag</strong> (<strong>in</strong> <code>std::ios</code>)</p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>File</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Meaning</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>in</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Must exist</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Read</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>out</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Created if doesn’t exist</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Erase the file; then write</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>app</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Created if doesn’t exist</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Append</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>in|out</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Must exist</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Read and write from beginning</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>in|app</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Created if doesn’t exist</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Update at end</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>out|app</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Created if doesn’t exist</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Append</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>out|trunc</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Created if doesn’t exist</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Erase the file; then read and write</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>in|out|app</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Created if doesn’t exist</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Update at end</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>in|out|trunc</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Created if doesn’t exist</p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Erase the file; then read and write</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Additionally, you can add the <code>binary</code> flag to any of these combinations to put the file in <em>binary mode</em>. In binary mode, the stream won’t convert special character sequences, like end of line (for example, a carriage return plus a line feed on Windows) or EOF.</p>&#13;
<p class="indent">The second option for specifying a file to open is to use the stream’s constructor. Each file stream provides a constructor taking the same arguments as the <code>open</code> method. All file stream classes are RAII wrappers around the file handles they own, so the files will be automatically cleaned up when the file stream destructs. You can also manually invoke the <code>close</code> method, which takes no arguments. You might want to do this if you know you’re done with the file but your code is written in such a way that the file stream class object won’t destruct for a while.</p>&#13;
<p class="indent">File streams also have default constructors, which don’t open any files. To check whether a file is open, invoke the <code>is_open</code> method, which takes no arguments and returns a Boolean.</p>&#13;
<h5 class="h5" id="ch16lev3sec10"><strong>Output File Streams</strong></h5>&#13;
<p class="noindent"><em>Output file streams</em> provide output stream semantics for character sequences, and they all derive from the class template <code>std::basic_ofstream</code> in the <code>&lt;fstream&gt;</code> header, which provides the following specializations:</p>&#13;
<pre>using ofstream = basic_ofstream&lt;char&gt;;&#13;
using wofstream = basic_ofstream&lt;wchar_t&gt;;</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_543"/>The default <code>basic_ofstream</code> constructor doesn’t open a file, and the non-default constructor’s second optional argument defaults to <code>ios::out</code>.</p>&#13;
<p class="indent">Whenever you send input to the file stream, the stream writes the data to the corresponding file. <a href="ch16.xhtml#ch16ex14">Listing 16-14</a> illustrates how to use <code>ofstream</code> to write a simple message to a text file.</p>&#13;
<pre>#include &lt;fstream&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  ofstream file{ "lunchtime.txt", ios::out|ios::app }; <span class="ent">➊</span>&#13;
  file &lt;&lt; "Time is an illusion." &lt;&lt; endl; <span class="ent">➋</span>&#13;
  file &lt;&lt; "Lunch time, " &lt;&lt; 2 &lt;&lt; "x so." &lt;&lt; endl; <span class="ent">➌</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
lunchtime.txt:&#13;
<span class="color1">Time is an illusion. <span class="ent">➋</span></span>&#13;
<span class="color1">Lunch time, 2x so. <span class="ent">➌</span></span></pre>&#13;
<p class="listing"><a id="ch16ex14"/><em>Listing 16-14: A program opening the file lunchtime.txt and appending a message to it. (The output corresponds to the contents of lunchtime.txt after a single program execution.)</em></p>&#13;
<p class="indent">You initialize an <code>ofstream</code> called <code>file</code> with the path <code>lunchtime.txt</code> and the flags <code>out</code> and <code>app</code> <span class="ent">➊</span>. Because this combination of flags appends output, any data you send through the output operator into this file stream gets appended to the end of the file. As expected, the file contains the message you passed to the output operator <span class="ent">➋</span><span class="ent">➌</span>.</p>&#13;
<p class="indent">Thanks to the <code>ios::app</code> flag, the program will append output to <em>lunchtime.txt</em> if it exists. For example, if you run the program again, you’ll get the following output:</p>&#13;
<pre>Time is an illusion.&#13;
Lunch time, 2x so.&#13;
Time is an illusion.&#13;
Lunch time, 2x so.</pre>&#13;
<p class="indent">The second iteration of the program added the same phrase to the end of the file.</p>&#13;
<h5 class="h5" id="ch16lev3sec11"><strong>Input File Streams</strong></h5>&#13;
<p class="noindent"><em>Input file streams</em> provide input stream semantics for character sequences, and they all derive from the class template <code>std::basic_ifstream</code> in the <code>&lt;fstream&gt;</code> header, which provides the following specializations:</p>&#13;
<pre>using ifstream = basic_ifstream&lt;char&gt;;&#13;
using wifstream = basic_ifstream&lt;wchar_t&gt;;</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_544"/>The default<code> basic_ifstream</code> constructor doesn’t open a file, and the non-default constructor’s second optional argument defaults to <code>ios::in</code>.</p>&#13;
<p class="indent">Whenever you read from the file stream, the stream reads data from the corresponding file. Consider the following sample file, <em>numbers.txt</em>:</p>&#13;
<pre>-54&#13;
203&#13;
9000&#13;
0&#13;
99&#13;
-789&#13;
400</pre>&#13;
<p class="indent"><a href="ch16.xhtml#ch16ex15">Listing 16-15</a> contains a program that uses an <code>ifstream</code> to read from a text file containing integers and return the maximum. The output corresponds with invoking the program and passing the path of the file <em>numbers.txt</em>.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;fstream&gt;&#13;
#include &lt;limits&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  ifstream file{ "numbers.txt" }; <span class="ent">➊</span>&#13;
  auto maximum = numeric_limits&lt;int&gt;::min(); <span class="ent">➋</span>&#13;
  int value;&#13;
  while (file &gt;&gt; value) <span class="ent">➌</span>&#13;
    maximum = maximum &lt; value ? value : maximum; <span class="ent">➍</span>&#13;
  cout &lt;&lt; "Maximum found was " &lt;&lt; maximum &lt;&lt; endl; <span class="ent">➎</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Maximum found was 9000 <span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch16ex15"/><em>Listing 16-15: A program that reads the text file</em> numbers.txt <em>and prints its maximum integer</em></p>&#13;
<p class="indent">You first initialize an <code>istream</code> to open the <em>numbers.txt</em> text file <span class="ent">➊</span>. Next, you initialize the maximum variable with the minimum value an <code>int</code> can take <span class="ent">➋</span>. Using the idiomatic input stream and <code>while</code>-loop combination <span class="ent">➌</span>, you cycle through each integer in the file, updating the maximum as you find higher values <span class="ent">➍</span>. Once the file stream cannot parse any more integers, you print the result to stdout <span class="ent">➎</span>.</p>&#13;
<h5 class="h5" id="ch16lev3sec12"><strong>Handling Failure</strong></h5>&#13;
<p class="noindent">As with other streams, file streams fail silently. If you use a file stream constructor to open a file, you must check the <code>is_open</code> method to determine whether the stream successfully opened the file. This design differs from most other stdlib objects where invariants are enforced by exceptions. It’s hard to say why the library implementors chose this approach, but the fact is that you can opt into an exception-based approach fairly easily.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_545"/>You can make your own factory functions to handle file-opening failures with exceptions. <a href="ch16.xhtml#ch16ex16">Listing 16-16</a> illustrates how to implement an <code>ifstream</code> factory called <code>open</code>.</p>&#13;
<pre>#include &lt;fstream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
ifstream<span class="ent">➊</span> open(const char* path<span class="ent">➋</span>, ios_base::openmode mode = ios_base::in<span class="ent">➌</span>) {&#13;
  ifstream file{ path, mode }; <span class="ent">➍</span>&#13;
  if(!file.is_open()) { <span class="ent">➎</span>&#13;
    string err{ "Unable to open file " };&#13;
    err.append(path);&#13;
    throw runtime_error{ err }; <span class="ent">➏</span>&#13;
  }&#13;
  file.exceptions(ifstream::badbit);&#13;
  return file; <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch16ex16"/><em>Listing 16-16: A factory function for generating <code>ifstream</code>s that handle errors with exceptions rather than failing silently</em></p>&#13;
<p class="indent">Your factory function returns an <code>ifstream</code> <span class="ent">➊</span> and accepts the same arguments as a file stream’s constructor (and <code>open</code> method): a file <code>path</code> <span class="ent">➋</span> and an <code>openmode</code> <span class="ent">➌</span>. You pass these two arguments into the constructor of <code>ifstream</code> <span class="ent">➍</span> and then determine whether the file opened successfully <span class="ent">➎</span>. If it didn’t, you throw a <code>runtime_error</code> <span class="ent">➏</span>. If it did, you tell the resulting <code>ifstream</code> to throw an exception whenever its <code>badbit</code> gets set in the future <span class="ent">➐</span>.</p>&#13;
<h5 class="h5" id="ch16lev3sec13"><strong>Summary of File Stream Operations</strong></h5>&#13;
<p class="noindent"><a href="ch16.xhtml#ch16tab010">Table 16-10</a> provides a partial list of <code>basic_fstream</code> operations. In this table, <code>fs, fs1</code>, and <code>fs2</code> are of type <code>std:: basic_fstream &lt;T&gt;</code>; <code>p</code> is a C-style string, <code>std::string</code>, or a <code>std::filesystem::path</code>; <code>om</code> is an <code>std::ios_base::openmode</code>; <code>s</code> is a <code>std::basic_string&lt;</code><code>T</code><code>&gt;</code>; <code>obj</code> is a formatted object; <code>pos</code> is a position type; <code>dir</code> is a <code>std::ios_base::seekdir</code>; and <code>flg</code> is a <code>std::ios_base::iostate</code>.</p>&#13;
<p class="tabcap" id="ch16tab010"><strong>Table 16-10:</strong> A Partial List of <code>std::basic_fstream</code> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>basic_fstream&lt;</code><span class="codestrong">T</span><code>&gt;</code></p>&#13;
<p class="taba"><code> { [</code><span class="codestrong">p</span><code>], [</code><span class="codestrong">om</span><code>] }</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Performs braced initialization of a newly constructed file stream. If <span class="codestrong">p</span> is provided, attempts to open file at path <span class="codestrong">p</span>. Defaults to not opened and <code>in|out</code> open mode.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>basic_fstream&lt;</code><span class="codestrong">T</span><code>&gt;</code></p>&#13;
<p class="taba"><code> { move(</code><span class="codestrong">fs</span><code>) }</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Takes ownership of the internal buffer of <span class="codestrong">fs</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>~basic_fstream</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Destructs internal buffer.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">fs.</span><code>rdbuf()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns raw string device object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">fs.</span><code>str()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Gets the contents of the file device object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">fs.</span><code>str(</code><span class="codestrong">s</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Puts the contents of the file device object into <span class="codestrong">s</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><span epub:type="pagebreak" id="page_546"/><p class="taba"><span class="codestrong">fs</span> <code>&gt;&gt;</code> <span class="codestrong">obj</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Extracts formatted data from the file stream.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">fs</span> <code>&lt;&lt;</code> <span class="codestrong">obj</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Inserts formatted data into the file stream.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">fs.</span><code>tellg()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the input position index.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">fs.</span><code>seekg(</code><span class="codestrong">pos</span><code>)</code></p>&#13;
<p class="taba"><span class="codestrong">fs.</span><code>seekg(</code><span class="codestrong">pos</span>, <span class="codestrong">dir</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Sets the input position indicator.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">fs.</span><code>flush()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Synchronizes the underlying device.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">fs.</span><code>good()</code></p>&#13;
<p class="taba"><span class="codestrong">fs.</span><code>eof()</code></p>&#13;
<p class="taba"><span class="codestrong">fs.</span><code>bad()</code></p>&#13;
<p class="taba"><code>!</code><span class="codestrong">fs</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Inspects the file stream’s bits.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">fs.</span><code>exceptions(</code><span class="codestrong">flg</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Configures the file stream to throw an exception whenever a bit in <span class="codestrong">flg</span> gets set.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">fs1.</span><code>swap(</code><span class="codestrong">fs2</span><code>)</code></p>&#13;
<p class="taba"><code>swap(</code><span class="codestrong">fs1</span>, <span class="codestrong">fs2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Exchanges each element of <span class="codestrong">fs1</span> with one of <span class="codestrong">fs2</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch16lev2sec8"><strong><em>Stream Buffers</em></strong></h4>&#13;
<p class="noindent">Streams don’t read and write directly. Under the covers, they use stream buffer classes. At a high level, <em>stream buffer classes</em> are templates that send or extract characters. The implementation details aren’t important unless you’re planning on implementing your own stream library, but it’s important to know that they exist in several contexts. The way you obtain stream buffers is by using a stream’s <code>rdbuf</code> method, which all streams provide.</p>&#13;
<h5 class="h5" id="ch16lev3sec14"><strong>Writing Files to sdout</strong></h5>&#13;
<p class="noindent">Sometimes you just want to write the contents of an input file stream directly into an output stream. To do this, you can extract the stream buffer pointer from the file stream and pass it to the output operator. For example, you can dump the contents of a file to stdout using <code>cout</code> in the following way:</p>&#13;
<pre>cout &lt;&lt; my_ifstream.rdbuf()</pre>&#13;
<p class="indent">It’s that easy.</p>&#13;
<h5 class="h5" id="ch16lev3sec15"><strong>Output Stream Buffer Iterators</strong></h5>&#13;
<p class="noindent"><em>Output stream buffer iterators</em> are template classes that expose an output iterator interface that translates writes into output operations on the underlying stream buffer. In other words, these are adapters that allow you to use output streams as if they were output iterators.</p>&#13;
<p class="indent">To construct an output stream buffer iterator, use the <code>ostreambuf_iterator</code> template class in the <code>&lt;iterator&gt;</code> header. Its constructor takes a single output stream argument and a single template parameter corresponding to the <span epub:type="pagebreak" id="page_547"/>constructor argument’s template parameter (the character type). <a href="ch16.xhtml#ch16ex17">Listing 16-17</a> shows how to construct an output stream buffer iterator from <code>cout</code>.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;iterator&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  ostreambuf_iterator&lt;char&gt; itr{ cout }; <span class="ent">➊</span>&#13;
  *itr = 'H'; <span class="ent">➋</span>&#13;
  ++itr; <span class="ent">➌</span>&#13;
  *itr = 'i'; <span class="ent">➍</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">H<span class="ent">➋</span>i<span class="ent">➍</span></span></pre>&#13;
<p class="listing"><a id="ch16ex17"/><em>Listing 16-17: Writing the message <code>Hi</code> to stdout using the <code>ostreambuf_iterator</code> class</em></p>&#13;
<p class="indent">Here, you construct an output stream buffer iterator from <code>cout</code> <span class="ent">➊</span>, which you write to in the usual way for an output operator: assign <span class="ent">➋</span>, increment <span class="ent">➌</span>, assign <span class="ent">➍</span>, and so on. The result is character-by-character output to stdout. (Recall the procedures for handling output operators in “Output Iterators” on <a href="ch14.xhtml#page_464">page 464</a>.)</p>&#13;
<h5 class="h5" id="ch16lev3sec16"><strong>Input Stream Buffer Iterators</strong></h5>&#13;
<p class="noindent"><em>Input stream buffer iterators</em> are template classes that expose an input iterator interface that translates reads into read operations on the underlying stream buffer. These are entirely analogous to output stream buffer iterators.</p>&#13;
<p class="indent">To construct an input stream buffer iterator, use the <code>istreambuf_iterator</code> template class in the <code>&lt;iterator&gt;</code> header. Unlike <code>ostreambuf_iterator</code>, it takes a stream buffer argument, so you must call <code>rdbuf()</code> on whichever input stream you want to adapt. This argument is optional: the default constructor of <code>istreambuf_iterator</code> corresponds to the end-of-range iterator of input iterator. For example, <a href="ch16.xhtml#ch16ex18">Listing 16-18</a> illustrates how to construct a string from <code>std::cin</code> using the range-based constructor of <code>string</code>.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;iterator&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  istreambuf_iterator&lt;char&gt; cin_itr{ cin.rdbuf() } <span class="ent">➊</span>, end{} <span class="ent">➋</span>;&#13;
  cout &lt;&lt; "What is your name? "; <span class="ent">➌</span>&#13;
  const string name{ cin_itr, end }; <span class="ent">➍</span>&#13;
  cout &lt;&lt; "\nGoodbye, " &lt;&lt; name; <span class="ent">➎</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">What is your name? <span class="ent">➌</span></span><span class="codestrong1">josh</span> <span class="color1"><span class="ent">➍</span></span>&#13;
<span class="color1">Goodbye, josh<span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch16ex18"/><em>Listing 16-18: Constructing a string from <code>cin</code> using input stream buffer iterators</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_548"/>You construct an <code>istreambuf_iterator</code> from the stream buffer of <code>cin</code> <span class="ent">➊</span> as well as the end-of-range iterator <span class="ent">➋</span>. After sending a prompt to the program’s user <span class="ent">➌</span>, you construct the <code>string name</code> using its range-based constructor <span class="ent">➍</span>. When the user sends input (terminated by EOF), the string’s constructor copies it. You then bid the user farewell using their <code>name</code> <span class="ent">➎</span>. (Recall from “Stream State” on <a href="ch16.xhtml#page_530">page 530</a> that methods for sending EOF to the console differ by operating system.)</p>&#13;
<h4 class="h4" id="ch16lev2sec9"><strong><em>Random Access</em></strong></h4>&#13;
<p class="noindent">Sometimes you’ll want random access into a stream (especially a file stream). The input and output operators clearly don’t support this use case, so <code>basic_istream</code> and <code>basic_ostream</code> offer separate methods for random access. These methods keep track of the cursor or position, the index of the stream’s current character. The position indicates the next byte that an input stream will read or an output stream will write.</p>&#13;
<p class="indent">For input streams, you can use the two methods <code>tellg</code> and <code>seekg</code>. The <code>tellg</code> method takes no arguments and returns the position. The <code>seekg</code> method allows you to set the cursor position, and it has two overloads. Your first option is to provide a <code>pos_type</code> position argument, which sets the read position. The second is to provide an <code>off_type</code> offset argument plus an <code>ios_base::seekdir</code> direction argument. The <code>pos_type</code> and <code>off_type</code> are determined by the template arguments to the <code>basic_istream</code> or <code>basic_ostream</code>, but usually these convert to/from integer types. The <code>seekdir</code> type takes one of the following three values:</p>&#13;
<ul>&#13;
<li class="noindent"><code>ios_base::beg</code> specifies that the position argument is relative to the beginning.</li>&#13;
<li class="noindent"><code>ios_base::cur</code> specifies that the position argument is relative to the current position.</li>&#13;
<li class="noindent"><code>ios_base::end</code> specifies that the position argument is relative to the end.</li>&#13;
</ul>&#13;
<p class="indent">For output streams, you can use the two methods <code>tellp</code> and <code>seekp</code>. These are roughly analogous to the <code>tellg</code> and <code>seekg</code> methods of input streams: the <code>p</code> stands for put and the <code>g</code> stands for get.</p>&#13;
<p class="indent">Consider a file <em>introspection.txt</em> with the following contents:</p>&#13;
<pre>The problem with introspection is that it has no end.</pre>&#13;
<p class="indent"><a href="ch16.xhtml#ch16ex19">Listing 16-19</a> illustrates how to employ random access methods to reset the file cursor.</p>&#13;
<pre>#include &lt;fstream&gt;&#13;
#include &lt;exception&gt;&#13;
#include &lt;iostream&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
<span epub:type="pagebreak" id="page_549"/>ifstream open(const char* path, ios_base::openmode mode = ios_base::in) { <span class="ent">➊</span>&#13;
--<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
int main() {&#13;
  try {&#13;
    auto intro = open("introspection.txt"); <span class="ent">➋</span>&#13;
    cout &lt;&lt; "Contents: " &lt;&lt; intro.rdbuf() &lt;&lt; endl; <span class="ent">➌</span>&#13;
    intro.seekg(0); <span class="ent">➍</span>&#13;
    cout &lt;&lt; "Contents after seekg(0): " &lt;&lt; intro.rdbuf() &lt;&lt; endl; <span class="ent">➎</span>&#13;
    intro.seekg(-4, ios_base::end); <span class="ent">➏</span>&#13;
    cout &lt;&lt; "tellg() after seekg(-4, ios_base::end): "&#13;
                                                    &lt;&lt; intro.tellg() &lt;&lt; endl; <span class="ent">➐</span>&#13;
    cout &lt;&lt; "Contents after seekg(-4, ios_base::end): "&#13;
                                                    &lt;&lt; intro.rdbuf() &lt;&lt; endl; <span class="ent">➑</span>&#13;
  }&#13;
  catch (const exception&amp; e) {&#13;
    cerr &lt;&lt; e.what();&#13;
  }&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Contents: The problem with introspection is that it has no end. <span class="ent">➌</span></span>&#13;
<span class="color1">Contents after seekg(0): The problem with introspection is that it has no end. <span class="ent">➎</span></span>&#13;
<span class="color1">tellg() after seekg(-4, ios_base::end): 49 <span class="ent">➐</span></span>&#13;
<span class="color1">Contents after seekg(-4, ios_base::end): end. <span class="ent">➑</span></span></pre>&#13;
<p class="listing"><a id="ch16ex19"/><em>Listing 16-19: A program using random access methods to read arbitrary characters in a text file</em></p>&#13;
<p class="indent">Using the factory function in <a href="ch16.xhtml#ch16ex16">Listing 16-16</a> <span class="ent">➊</span>, you open the text file <em>introspection.txt</em> <span class="ent">➋</span>. Next, you print the contents to stdout using the <code>rdbuf</code> method <span class="ent">➌</span>, rewind the cursor to the first character <span class="ent">➍</span>, and print the contents again. Notice that these yield identical output (because the file hasn’t changed) <span class="ent">➎</span>. You then use the relative offset overload of <code>seekg</code> to navigate to the fourth character from the end <span class="ent">➏</span>. Using <code>tellg</code>, you learn that this is the 49th character (with zero-base indexing) <span class="ent">➐</span>. When you print the input file to stdout, the output is only <code>end.</code>, because these are the last four characters in the file <span class="ent">➑</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost offers an IOStream library with a rich set of additional features that stdlib doesn’t have, including facilities for memory mapped file I/O, compression, and filtering.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch16lev1sec2"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you learned about streams, the major concept that provides a common abstraction for performing I/O. You also learned about files as a primary source and destination for I/O. You first learned about the <span epub:type="pagebreak" id="page_550"/>fundamental stream classes in the stdlib and how to perform formatted and unformatted operations, inspect stream state, and handle errors with exceptions. You learned about manipulators and how to incorporate streams into user-defined types, string streams, and file streams. This chapter culminated with stream buffer iterators, which allow you to adapt a stream to an iterator.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>16-1.</strong> Implement an output operator that prints information about the <code>AutoBrake</code> from “An Extended Example: Taking a Brake” on <a href="ch10.xhtml#page_283">page 283</a>. Include the vehicle’s current collision threshold and speed.</p>&#13;
<p class="noindent"><strong>16-2.</strong> Write a program that takes output from stdin, capitalizes it, and writes the result to stdout.</p>&#13;
<p class="noindent"><strong>16-3.</strong> Read the introductory documentation for Boost IOStream.</p>&#13;
<p class="noindent"><strong>16-4.</strong> Write a program that accepts a file path, opens the file, and prints summary information about the contents, including word count, average word length, and a histogram of the characters.</p>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>Standard C++ IOStreams and Locales: Advanced Programmer’s Guide and Reference</em> by Angelika Langer (Addison-Wesley Professional, 2000)</li>&#13;
<li class="noindent"><em>ISO International Standard ISO/IEC (2017) — Programming Language C++</em> (International Organization for Standardization; Geneva, Switzerland;  <em><a href="https://isocpp.org/std/the-standard/">https://isocpp.org/std/the-standard/</a></em>)</li>&#13;
<li class="noindent"><em>The Boost C++ Libraries</em>, 2nd Edition, by Boris Schäling (XML Press, 2014)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>