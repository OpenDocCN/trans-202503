- en: '## **14'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **14'
- en: Basic Ghidra Scripting**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**基础 Ghidra 脚本编写**'
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: No application can meet every need of every user. It is just not possible to
    anticipate every potential use case that may arise. Ghidra’s open source model
    facilitates feature requests and innovative contributions by developers. However,
    sometimes you need to immediately address a problem at hand and can’t wait for
    someone else to implement new functionality. To support unanticipated use cases
    and programmatic control of Ghidra’s actions, Ghidra includes integrated scripting
    features.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何应用程序能够满足每个用户的所有需求。这是因为无法预见所有可能出现的使用情况。Ghidra 的开源模型鼓励开发者提出功能请求并进行创新贡献。然而，有时你需要立即解决眼前的问题，而不能等待其他人实现新功能。为了支持无法预见的使用案例和对
    Ghidra 操作的程序化控制，Ghidra 包含了集成脚本功能。
- en: Uses for scripts are infinite and can range from simple one-liners to full-blown
    programs that automate common tasks or perform complex analysis. In this chapter,
    we focus on the basic scripting that is provided through the CodeBrowser interface.
    We introduce the internal scripting environment, discuss script development using
    Java and Python, and then move on to other integrated scripting options in [Chapter
    15](ch15.xhtml#ch15).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的用途是无穷无尽的，既可以是简单的单行代码，也可以是完整的程序，自动化常见任务或执行复杂分析。本章我们将重点介绍通过 CodeBrowser 界面提供的基本脚本编写。我们将介绍内部脚本环境，讨论如何使用
    Java 和 Python 开发脚本，接着进入 [第15章](ch15.xhtml#ch15)中讨论的其他集成脚本选项。
- en: '### **Script Manager**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '### **脚本管理器**'
- en: The Ghidra Script Manager is available through the CodeBrowser menu. Choosing
    Window ▸ Script Manager opens the window shown in [Figure 14-1](ch14.xhtml#fig14_1).
    The window can also be opened using the Script Manager icon in the CodeBrowser
    toolbar (a green circle with an arrow inside, also shown in the top left of the
    Script Manager window).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 脚本管理器可以通过 CodeBrowser 菜单访问。选择“窗口 ▸ 脚本管理器”会打开如 [图14-1](ch14.xhtml#fig14_1)
    所示的窗口。也可以通过 CodeBrowser 工具栏中的脚本管理器图标（一个绿色圆圈，内有箭头，也出现在脚本管理器窗口的左上角）来打开该窗口。
- en: '![image](Images/fig14-1.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig14-1.jpg)'
- en: '*Figure 14-1: Script Manager window*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-1：脚本管理器窗口*'
- en: '***Script Manager Window***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***脚本管理器窗口***'
- en: In a new Ghidra installation, the Script Manager loads with over 240 scripts
    organized in a category tree, as seen on the left side of [Figure 14-1](ch14.xhtml#fig14_1).
    Some of the folders contain subfolders to provide even more detailed classification
    of the scripts. You can expand and collapse the folders to see the organization
    of the scripts. Selecting an individual folder or subfolder limits the display
    to the scripts within the selected folder. To populate this window, Ghidra locates
    and indexes all scripts in subdirectories named *ghidra_scripts* within the Ghidra
    distribution folder. Ghidra also looks for a *ghidra_scripts* directory within
    your home directory and indexes any scripts it finds there.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在全新安装的 Ghidra 中，脚本管理器加载时会包含超过 240 个脚本，这些脚本按类别树进行组织，如 [图14-1](ch14.xhtml#fig14_1)
    左侧所示。部分文件夹内包含子文件夹，以便对脚本进行更详细的分类。你可以展开或折叠这些文件夹，查看脚本的组织结构。选择一个文件夹或子文件夹将只显示该文件夹中的脚本。为了填充这个窗口，Ghidra
    会在 Ghidra 安装目录中的 *ghidra_scripts* 子目录内查找并索引所有脚本。Ghidra 还会查找用户主目录下的 *ghidra_scripts*
    目录，并索引其中的脚本。
- en: 'The default set of scripts covers a wide range of functionality. Some of the
    scripts are intended to demonstrate fundamental scripting concepts. The columns
    in the script list table provide additional detail about the purpose of each script.
    As with most Ghidra tables, you can control which columns are displayed as well
    as the sort order for individual columns. By default, all available fields for
    the table are displayed except Created and Path. The six information columns provide
    the following insight into a script:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的脚本集覆盖了广泛的功能。一些脚本旨在演示基本的脚本概念。脚本列表表格中的列提供了关于每个脚本用途的更多细节。与大多数 Ghidra 表格一样，你可以控制显示哪些列以及各列的排序方式。默认情况下，所有可用的字段都会显示，除了“创建时间”和“路径”之外。六个信息列为脚本提供了以下详细信息：
- en: '**Status** Indicates the status of the script. The field is generally blank
    but can contain a red icon to indicate an error in the script. If you have associated
    a toolbar icon with the script, the icon will appear in this column.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态** 显示脚本的状态。该字段通常为空，但可以显示一个红色图标，表示脚本中有错误。如果你已将工具栏图标与脚本关联，该图标将显示在这一列。'
- en: '**Name** Contains the filename of the script, including its extension.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称** 包含脚本的文件名及其扩展名。'
- en: '**Description** A description pulled from the metadata comment within the script.
    This field can be quite lengthy, but you can read the entire contents by hovering
    over the field. This field is discussed in more depth in “[Script Development](ch14.xhtml#ch14lev234)”
    on [page 289](ch14.xhtml#page_289).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '**Key** Indicates if there is a key binding assigned for running the script.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '**Category** Specifies the path at which the script will be listed in the Script
    Manager’s topic hierarchy. This is a logical hierarchy, *not* a filesystem directory
    hierarchy.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**Modified** The date the script was last saved. For the default scripts the
    date is the installation date of the Ghidra instance.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The filter field on the left side of the window searches through the script
    categories. The filter on the right searches the script names and descriptions.
    Finally, at the bottom, an additional window is initially empty. This window displays
    metadata about a selected script in an easy-to-process format that includes the
    field extracted from the metadata within the script. The format and meaning of
    the metadata fields are discussed in “[Writing Java Scripts (Not JavaScript!)](ch14.xhtml#ch14lev235)”
    on [page 289](ch14.xhtml#page_289).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: While the Script Manager provides a significant amount of information, the main
    power of this window comes from the toolbar it provides. An overview of the toolbar
    is provided in [Figure 14-2](ch14.xhtml#fig14_2).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '***Script Manager Toolbar***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Script Manager has no menus to help you manage your scripts. Instead, all
    script management actions are associated with tools on the Script Manager toolbar
    ([Figure 14-2](ch14.xhtml#fig14_2)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: While most of the menu options are pretty clear from the descriptions in [Figure
    14-2](ch14.xhtml#fig14_2), the Edit options merit additional discussion. Editing
    with Eclipse is covered in [Chapter 15](ch15.xhtml#ch15), as it facilitates more
    advanced scripting capabilities. The Edit Script option opens a primitive text
    editor window with its own toolbar, shown in [Figure 14-3](ch14.xhtml#fig14_3).
    The associated actions provide the basic functionality for editing files. With
    an editor in hand, we can get down to the business of writing actual scripts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig14-2.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Script Manager toolbar*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig14-3.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Edit Script toolbar*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '### **Script Development**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: There are several methods for developing scripts within Ghidra. In this chapter,
    we focus on scripting using Java and Python, as these are languages used by the
    existing scripts in the Script Manager window. Most of the 240+ system scripts
    are written in Java, so we begin with editing and developing scripts in Java.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '***Writing Java Scripts (Not JavaScript!)***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Ghidra, a script written in Java is actually a complete class specification
    designed to be seamlessly compiled, dynamically loaded into your running Ghidra
    instance, invoked, and finally unloaded. The class must extend the class `Ghidra.app.script.GhidraScript`,
    implement a `run()` method, and be annotated with comments that provide Javadoc-format
    metadata about the script. We’ll show the structure of a script file, describe
    the metadata requirements, look at some of the system scripts, and then move on
    to editing existing scripts and building our own scripts.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-4](ch14.xhtml#fig14_4) shows the script editor opened when the Create
    New Script option (refer to [Figure 14-2](ch14.xhtml#fig14_2)) is selected to
    create a new Java script. We have named the new script *CH14_NewScript*.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig14-4.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: A new, empty script*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the file are the metadata comments and tags used to produce the
    expected Javadoc information. This information is also used to populate the fields
    in the Script Manager window (refer to [Figure 14-1](ch14.xhtml#fig14_1)). Any
    comments starting with `//` before the class, field, or method declarations will
    become part of the Javadoc Description for the script. Additional comments can
    be embedded within the script and will not be included in the description. In
    addition, the following tags within the metadata comments are supported:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '@author Provides information about the author of the script. The information
    is provided at the discretion of the author and can include any pertinent details
    (for example, name, contact information, date of creation, and so on).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '@category Determines where the script appears within the category tree. This
    is the only mandatory tag and must be present in all Ghidra scripts. The period
    (dot) character acts as a path separator for category names (for example, `@category
    Ghidrabook.CH14`).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '@keybinding Documents a shortcut for accessing the script from the CodeBrowser
    window (for example, `@keybinding K`).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '@menupath Defines a period-delimited menu path for the script as well as provides
    a means to run the script from a CodeBrowser menu (for example, `@menupath File.Run.ThisScript`).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '@toolbar Associates an icon with the script. This icon is displayed as a toolbar
    button in the CodeBrowser window and may be used to run the script. If Ghidra
    cannot find the image in the script directory or the Ghidra installation, a default
    image will be used (for example, `@toolbar myImage.png`).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: When confronted with a new API (such as the Ghidra API), it may take some time
    before you’re comfortable writing scripts without constantly consulting available
    API documentation. Java in particular is very sensitive to classpath issues and
    the proper inclusion of required support packages. A time- and sanity-saving option
    is to edit an existing program rather than creating a new program. We adopt this
    approach in presenting a simple example of a script.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '***Edit Script Example: Regex Search***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编辑脚本示例：正则表达式搜索***'
- en: Assume that you are tasked with developing a script to accept a regular expression
    as input from the user and output matching strings to the console. Further, this
    script needs to appear in the Script Manager for a particular project. While Ghidra
    offers many ways to accomplish this task, you have been asked to produce a script.
    To find a script with similar functionality to use as a base, you look through
    the categories in the Script Manager and check the contents of the Strings and
    Search categories, and then filter for the term *strings* and find other options.
    Using filters produces a more comprehensive list of string-related scripts for
    your consideration. For this example, you will edit the first script in the list
    that shares some functionality with what you want your script to do—*CountAndSaveStrings.java*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的任务是开发一个脚本，接受用户输入的正则表达式并将匹配的字符串输出到控制台。此外，脚本需要在特定项目的脚本管理器中显示。虽然 Ghidra 提供了多种方法来完成这个任务，但你被要求编写一个脚本。为了找到一个具有相似功能的脚本作为基础，你查看了脚本管理器中的类别，检查了“字符串”和“搜索”类别的内容，然后筛选出包含
    *strings* 的选项。使用筛选器可以提供一个更全面的与字符串相关的脚本列表供你参考。在这个示例中，你将编辑列表中第一个与要实现功能相似的脚本——*CountAndSaveStrings.java*。
- en: Open the script in the editor to confirm that it’s a good starting point for
    our new functionality by right-clicking the desired script and selecting **Edit**
    with basic editor; then save this script with the new name, *FindStringsByRegex.java*,
    using the **Save As** option. Ghidra does not allow you to edit the system scripts
    provided as part of your Ghidra installation within the Script Manager window
    (although you can in Eclipse and other editors). You could also edit the file
    prior to using Save As since Ghidra prevents you from accidentally writing any
    modified content to the existing *CountAndSaveStrings.java* script.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中打开脚本，通过右键点击所需脚本并选择 **编辑**（使用基本编辑器）来确认它是否是我们新功能的良好起点；然后使用 **另存为** 选项保存该脚本并将其命名为
    *FindStringsByRegex.java*。Ghidra 不允许你在脚本管理器窗口中编辑作为 Ghidra 安装一部分提供的系统脚本（尽管你可以在
    Eclipse 和其他编辑器中编辑）。你也可以在使用“另存为”之前编辑该文件，因为 Ghidra 会防止你不小心将任何修改后的内容写入现有的 *CountAndSaveStrings.java*
    脚本。
- en: 'The original *CountAndSaveStrings.java* contains the following metadata:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 *CountAndSaveStrings.java* 包含以下元数据：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can leave, modify, or delete the licensing agreement ➊ for the script without
    impacting the execution of the script or the associated Javadoc. We’ll modify
    the description of the script ➋ so that the information displayed in Javadoc and
    the Script Manager accurately describes the script. The script author has included
    only one of the five available tags ➌, so we’ll add placeholders for the unpopulated
    tags and revise the description, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在不影响脚本执行或关联 Javadoc 的情况下，留下、修改或删除脚本的许可协议➊。我们将修改脚本的描述➋，以便 Javadoc 和脚本管理器中显示的信息能够准确描述该脚本。脚本作者只包含了五个可用标签中的一个➌，因此我们将为未填充的标签添加占位符，并修改描述，如下所示：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The category tag `Ghidrabook.CH14` will be added to the Script Manager’s tree
    display, as shown in [Figure 14-5](ch14.xhtml#fig14_5).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 类别标签 `Ghidrabook.CH14` 将添加到脚本管理器的树状显示中，如[图 14-5](ch14.xhtml#fig14_5)所示。
- en: 'The next portion of the original script contains Java `import` statements.
    Of the long list of imports Ghidra includes when you create a new script, as shown
    in [Figure 14-4](ch14.xhtml#fig14_4), only the following imports are necessary
    for string searching, so we’ll keep the same list as the original *CountAndSaveStrings.java*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 原始脚本的下一部分包含 Java `import` 语句。在创建新脚本时，Ghidra 会包含一个长列表的导入，如[图 14-4](ch14.xhtml#fig14_4)所示，只有以下导入对字符串搜索是必要的，因此我们将保留与原始
    *CountAndSaveStrings.java* 相同的导入列表：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Save the new script and then select it in the Script Manager to see the content
    shown in [Figure 14-5](ch14.xhtml#fig14_5). Our new category is included in the
    script tree, and the script’s metadata is displayed in the information window
    and script table. The table contains only one script, *Ghidrabook.CH14*, as it
    is the only script in the selected category.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 保存新脚本后，然后在脚本管理器中选择它，以查看[图 14-5](ch14.xhtml#fig14_5)中显示的内容。我们的新类别已包含在脚本树中，脚本的元数据显示在信息窗口和脚本表格中。该表格只包含一个脚本，*Ghidrabook.CH14*，因为它是所选类别中唯一的脚本。
- en: '![image](Images/fig14-5.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig14-5.jpg)'
- en: '*Figure 14-5: New script information displayed in the Script Manager window*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：脚本管理器窗口中显示的新脚本信息*'
- en: 'As this book is not intended to be a Java tutorial, we summarize the changes
    we made to the script rather than explaining Java syntax and functionality. The
    following list describes the behavior of *CountAndSaveStrings.java*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Get the program listing content to search.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the file to save results to.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Iterate through the program listing: count the number of qualifying strings
    and write each qualifying string to the file.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the file.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the number of qualifying strings to the console.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The functionality we desire in our modified script is described next:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Get the program listing content to search.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask the user for a regular expression (regex) to search for.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Iterate through the program listing: count the number of qualifying strings
    and write each qualifying string to the console.'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the number of qualifying strings to the console.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our new script will be significantly shorter than the original script, as there
    is no need to interact with the filesystem and perform associated error checking.
    Our implementation follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All Java scripts that you write for Ghidra must extend (inherit from) an existing
    class named `Ghidra.app.script.GhidraScript` ➊. After saving the final version
    of the script, select it from within the Script Manager and execute it. When the
    script executes, we see the prompt shown in [Figure 14-6](ch14.xhtml#fig14_6).
    This figure includes the regular expression that we will be searching for to test
    our script.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig14-6.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: New script prompt to enter a regex*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'The CodeBrowser console displays the following content when our new script
    has completed execution:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This simple example demonstrates the low barrier to entry of Ghidra’s extensive
    Java scripting capabilities. Existing scripts can be easily modified and new scripts
    can be built from the ground up using the Script Manager. We present some more
    complex Java scripting capabilities in [Chapters 15](ch15.xhtml#ch15) and [16](ch16.xhtml#ch16),
    but Java is just one of the scripting options provided by Ghidra. Ghidra also
    allows you to author scripts in Python.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Python Scripts***'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Of the 240+ scripts in the Script Manager, only a handful are written in Python.
    You can easily locate the Python scripts by filtering for the *.py* extension
    in the Script Manager. The majority of the Python scripts can be found in the
    Examples.Python category in the tree and includes a disclaimer similar to the
    one shown in [Figure 14-7](ch14.xhtml#fig14_7).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig14-7.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: Sample Python script with disclaimer*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Of the examples in this directory, the following three provide a good starting
    point if you prefer to use Python:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '***ghidra_basic.py*** This script includes examples of basic Python scripting
    as related to Ghidra.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '***python_basics.py*** This is a very basic introduction to many of the Python
    commands that you might want to use.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '***jython_basic.py*** This extends the basic Python commands to demonstrate
    content that is specific to Jython.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The Ghidra features demonstrated in these examples barely scratch the surface
    of the available Ghidra APIs. You’ll likely still need to spend some time reading
    through Ghidra’s library of Java examples before you’ll be ready to access Ghidra’s
    full Java API from your Python scripts.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: In addition to running Python scripts, Ghidra provides the Python Interpreter
    to allow you to use Python/Jython to directly access the Java objects associated
    with Ghidra, as shown in [Figure 14-8](ch14.xhtml#fig14_8).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '**GHIDRA’S PYTHON FUTURE**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Python is popular for creating scripts because of its simplicity and numerous
    available libraries. While the majority of the scripts in the Ghidra release are
    written in Java, the open source RE community likely will use Python as a primary
    scripting language within Ghidra. Ghidra is reliant on Jython for Python support
    (which provides the advantage of allowing direct access to Ghidra’s Java objects).
    Jython is compatible with Python 2 (specifically 2.7.1) but not Python 3\. Although
    Python 2 went end-of-life in January 2020, Python 2 scripts will continue to function
    within Ghidra, and any new Ghidra Python 2 scripts should be written in a way
    that makes them as portable as possible to Python 3.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig14-8.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: Python Interpreter* print *example*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The Python Interpreter is accessible through the CodeBrowser by selecting Windows
    ▸ Python. For more information about using the interpreter, see Ghidra Help. To
    get API information when using Python and the Python Interpreter, choose Help
    ▸ Ghidra API Help at the top left of the Interpreter window shown in [Figure 14-8](ch14.xhtml#fig14_8),
    which opens the Javadoc content on the `GhidraScript` class. Alternatively, Python
    has a built-in function, `help( )`, that has been modified in Ghidra to provide
    direct access to Ghidra’s Javadoc. To use the function, type `help(`object`)`
    in the interpreter, as shown in [Figure 14-9](ch14.xhtml#fig14_9). For example,
    `help(currentProgram)` displays the Ghidra Javadoc content describing the Ghidra
    API class `ProgramDB`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig14-9.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Python Interpreter Help example*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '***Support for Other Languages***'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, Ghidra can support scripts from languages other than Java and Python,
    which lets you bring existing scripts from your reverse engineering toolkit into
    your Ghidra workflow. This functionality is discussed further in Ghidra Help.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction to the Ghidra API**'
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, you have all the information required to edit and run Ghidra
    scripts. Now it’s time to use the Ghidra API to extend your scripting capabilities
    and interact more directly with Ghidra artifacts. Ghidra exposes its API in two
    rather different styles.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The *Program* API defines an object hierarchy, many levels deep, rooted at the
    top by the `Program` class. This API may change from one version of Ghidra to
    another. The *Flat* API flattens out the Program API by exposing all levels of
    that API from a single class, `FlatProgramAPI`. The Flat API is often the most
    convenient way to access many Ghidra constructs. Additionally, it is less likely
    to change from one version of Ghidra to the next.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*Program* API定义了一个对象层次结构，深度多层，最上层由`Program`类根本。这一API可能会随着Ghidra的版本不同而有所变化。*Flat*
    API通过暴露该API的所有层级，统一从一个类`FlatProgramAPI`中访问，从而将Program API进行扁平化。Flat API通常是访问许多Ghidra构造的最便捷方式。此外，它比Program
    API更不容易随着Ghidra版本的更新而发生变化。'
- en: For the remainder of the chapter, we highlight some of the more useful Flat
    API functionality. When necessary, we also provide detail about specific classes
    from the Program API. We use Java as the language for this discussion, as it is
    the native language of Ghidra.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将重点介绍一些更有用的Flat API功能。在必要时，我们还会提供有关Program API中特定类的详细信息。我们使用Java作为本讨论的语言，因为它是Ghidra的原生语言。
- en: The Ghidra API contains many packages, classes, and associated functions to
    interface with your Ghidra projects and associated files, all detailed in Javadoc-style
    documentation supplied with Ghidra that can be accessed by clicking the red plus
    in the Script Manager window. This documentation, in conjunction with the sample
    scripts supplied with Ghidra, is your primary reference about the APIs and how
    to use them. The most common way to figure out how to do something is to browse
    the Ghidra classes looking for one that, based on its name, appears to do what
    you need. As you gain more experience with Ghidra, your increased understanding
    of the naming conventions and file organization will help you identify appropriate
    classes more quickly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra API包含许多包、类及其相关函数，用于与Ghidra项目和相关文件交互，所有这些内容都在随Ghidra提供的Javadoc风格文档中详细说明，可以通过点击脚本管理器窗口中的红色加号访问。该文档与随Ghidra提供的示例脚本一起，是你了解API及其使用方法的主要参考资料。最常见的做法是浏览Ghidra类，查找那些从名称上看似乎能完成你需要的任务的类。随着你对Ghidra的理解不断加深，你对命名约定和文件组织结构的理解将帮助你更快地识别出合适的类。
- en: Ghidra adheres to the Java Swing *model-delegate* architecture in which data
    values and characteristics are stored in model objects and displayed by user interface
    delegate objects such as tree, list, and table views. Delegates handle events,
    such as mouse clicks, to update and refresh data and views. In the overwhelming
    majority of cases, your scripts will focus on the data encapsulated in the model
    classes used to represent various program and reverse engineering constructs.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra遵循Java Swing的*模型-委托*架构，其中数据值和特性存储在模型对象中，并由用户界面委托对象（如树视图、列表视图和表格视图）显示。委托对象处理事件，例如鼠标点击，来更新和刷新数据和视图。在绝大多数情况下，你的脚本将集中在表示各种程序和逆向工程构造的模型类所封装的数据上。
- en: The remainder of this section focuses on commonly used model classes, their
    relationships to each other, and useful APIs for interacting with them. We make
    no attempt to cover the entire Ghidra API, and many more functions and classes
    are available. The authoritative documentation for the entire Ghidra API is the
    Javadoc that ships with Ghidra, and ultimately the Java source code from which
    Ghidra is built.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分集中介绍常用的模型类、它们之间的关系，以及与之交互的有用API。我们并不打算涵盖整个Ghidra API，实际上还有许多其他的函数和类可以使用。整个Ghidra
    API的权威文档是随Ghidra提供的Javadoc，最终的参考资料是构建Ghidra的Java源代码。
- en: '***The Address Interface***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***地址接口***'
- en: The `Address` interface describes a model for an address within an address space.
    All addresses are represented by an offset up to 64 bits in size. Segmented addresses
    may be further qualified by a segment value. In many cases, an address’s offset
    is equivalent to a virtual address within a program listing. The `getOffset` method
    retrieves the `long` offset value from an `Address` instance. Many Ghidra API
    functions require `Address` objects as arguments or return an `Address` object
    as a result.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Address`接口描述了地址空间内地址的模型。所有地址通过一个最多为64位的偏移量表示。分段地址可能会通过段值进一步限定。在许多情况下，一个地址的偏移量相当于程序列表中的虚拟地址。`getOffset`方法从`Address`实例中检索`long`类型的偏移量值。许多Ghidra
    API函数要求以`Address`对象作为参数，或者返回`Address`对象作为结果。'
- en: '***The Symbol Interface***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***符号接口***'
- en: 'The `Symbol` interface defines properties common to all symbols. At a minimum,
    a symbol is composed of a name and an address. These attributes may be retrieved
    with the following member functions:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Symbol`接口定义了所有符号的共同属性。至少，一个符号由名称和地址组成。这些属性可以通过以下成员函数获取：'
- en: Address getAddress()
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Address getAddress()
- en: Returns the address of the `Symbol`
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`Symbol`的地址。
- en: String getName()
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: String getName()
- en: Returns the name of the `Symbol`
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`Symbol`的名称。
- en: '#### ***The Reference Interface***'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***引用接口***'
- en: 'A `Reference` models a cross-reference relationship (as described in [Chapter
    9](ch09.xhtml#ch09)) between a source address and a destination address and is
    characterized by a reference type. Useful functions associated with a `Reference`
    include these:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reference`表示源地址和目标地址之间的交叉引用关系（如[第9章](ch09.xhtml#ch09)所述），并且具有一个引用类型。与`Reference`相关的有用函数包括：'
- en: public Address getFromAddress()
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: public Address getFromAddress()
- en: Returns the source address for this reference
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 返回此引用的源地址。
- en: public Address getToAddress()
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: public Address getToAddress()
- en: Returns the destination address for this reference
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 返回此引用的目标地址。
- en: public RefType getReferenceType()
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: public RefType getReferenceType()
- en: Returns a `RefType` object that describes the nature of the link between the
    source and destination addresses
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个`RefType`对象，描述源地址和目标地址之间的链接性质。
- en: '***The GhidraScript Class***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***GhidraScript类***'
- en: Although this class doesn’t model a specific attribute in a binary, every script
    that you write must be a subclass of `GhidraScript`, which, in turn, is a subclass
    of `FlatProgramAPI`. As a result, your scripts have instantaneous access to the
    entire Flat API and your only obligation is to provide an implementation of
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个类并没有表示二进制文件中的某个特定属性，但你编写的每个脚本必须是`GhidraScript`类的子类，而`GhidraScript`又是`FlatProgramAPI`类的子类。因此，你的脚本可以即时访问整个Flat
    API，而你唯一的义务是提供实现。
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: which, hopefully, makes your script do something interesting. The remainder
    of the `GhidraScript` class gives you access to the most common resources for
    interacting with the Ghidra user and the program that is being analyzed. Some
    of the more useful functions and data members of this class (including some inherited
    from `FlatProgramAPI`) are summarized in the following sections.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这样， hopefully，你的脚本就能做一些有趣的事情。`GhidraScript`类的剩余部分为你提供了与Ghidra用户以及正在分析的程序交互的最常见资源的访问权限。该类的一些更有用的函数和数据成员（包括一些从`FlatProgramAPI`继承的）将在以下章节中总结。
- en: '**Useful Data Members**'
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**有用的数据成员**'
- en: 'The `GhidraScript` class provides convenient access to a number of objects
    commonly referenced in scripts, including the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`GhidraScript`类为你提供了方便访问在脚本中常用的多个对象，包括以下内容：'
- en: protected Program currentProgram;
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的Program currentProgram;
- en: This is the current open program. The `Program` class is discussed later. This
    data member is likely your gateway to retrieving more interesting information,
    such as instruction and symbol lists.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当前打开的程序。`Program`类将在后面讨论。这个数据成员可能是你获取更有趣信息（例如指令和符号列表）的通道。
- en: protected Address currentAddress;
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的Address currentAddress;
- en: This is the address of the current cursor location. The `Address` class is discussed
    later.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当前光标位置的地址。`Address`类将在后面讨论。
- en: protected ProgramLocation currentLocation;
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的ProgramLocation currentLocation;
- en: A `ProgramLocation` object that describes the current cursor location, including
    its address, cursor row, column, and other information.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`ProgramLocation`对象，描述当前光标位置，包括其地址、光标所在的行、列以及其他信息。
- en: protected ProgramSelection currentSelection;
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的ProgramSelection currentSelection;
- en: A `ProgramSelection` object representing a range of addresses selected in the
    Ghidra GUI.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`ProgramSelection`对象，表示在Ghidra图形界面中选择的一系列地址。
- en: protected TaskMonitor monitor;
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的TaskMonitor monitor;
- en: The `TaskMonitor` class updates the status of long-running tasks and checks
    to determine whether a long-running task has been cancelled by the user (`monitor.isCancelled()`).
    Any long-running loops that you write should incorporate a call to `monitor.isCancelled`
    as an additional termination condition to recognize that the user has attempted
    to cancel your script.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskMonitor`类更新长时间运行任务的状态，并检查是否有长时间运行的任务被用户取消（`monitor.isCancelled()`）。你编写的任何长时间运行的循环都应该包含调用`monitor.isCancelled`，作为附加的终止条件，以识别用户是否尝试取消你的脚本。'
- en: '**User Interface Functions**'
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**用户界面函数**'
- en: 'The GhidraScript class provides convenience functions for basic user interface
    operations, ranging from simple message output to more interactive dialog elements.
    Some of the more common user interface functions are described here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: public void println(String message)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Prints `message` followed by a linefeed to Ghidra’s console window. This function
    is useful for printing status messages or results of your scripts in a nonintrusive
    manner.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: public void printf(String message, Object... args)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Uses `message` as a Java format string and prints the resulting string of formatted
    `args` to Ghidra’s console window.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: public void popup(final String message)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Displays `message` in a pop-up dialog that requires the user to click OK before
    script execution can continue. This is a more intrusive way to display status
    messages to a user.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: public String askString(String title, String message)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: One of many available `ask` functions. `askString` displays a text input dialog,
    using `message` as a prompt, and returns the text entered by the user.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: public boolean askYesNo(String title, String question)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Uses a dialog to ask the user a yes-or-no `question`. Returns `true` for yes,
    and `false` for no.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: public Address askAddress(String title, String message)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Displays a dialog, using `message` as a prompt, that parses the user’s input
    into an `Address` object.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: public int askInt(String title, String message)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Displays a dialog, using `message` as a prompt, that parses the user’s input
    into an `int`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: public File askFile(final String title, final String approveButtonText)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Displays a system file chooser dialog and returns a Java `File` object representing
    the file selected by the user.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: public File askDirectory(final String title, final String approveButtonText)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Displays a system file chooser dialog and returns a Java `File` object representing
    the directory selected by the user.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: public boolean goTo(Address address)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Repositions all connected Ghidra disassembly windows to `address`. Overloaded
    versions of this function take a `Symbol` or a `Function` argument and navigate
    the displays accordingly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '**Address-Related Functions**'
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For a processor, an address is typically just a number that happens to refer
    to a memory location. Ghidra models addresses using the `Address` class. `GhidraScript`
    provides a wrapper function that offers easy conversion from numbers to Ghidra
    `Address` objects:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: public Address toAddr(long offset)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Convenience function to create an `Address` object in the default address space
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '**Reading Program Memory**'
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `Memory` class represents contiguous ranges of byte values, such as the
    contents of an executable file loaded into Ghidra. Within a `Memory` object, every
    byte value is associated with an address, though addresses may be tagged as uninitialized
    and have no value to retrieve. Ghidra throws a `MemoryAccessException` if you
    attempt to access a location within a memory object with an invalid address. Consult
    the documentation for the `Memory` class for a full description of available API
    functions. The following convenience functions expose some of the `Memory` class
    via the Flat API:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Memory` 类表示字节值的连续范围，例如加载到 Ghidra 中的可执行文件的内容。在 `Memory` 对象中，每个字节值都与一个地址关联，尽管地址可能被标记为未初始化，并且没有可获取的值。如果尝试访问
    `Memory` 对象中无效地址的内存位置，Ghidra 会抛出 `MemoryAccessException`。有关 `Memory` 类的完整 API
    函数说明，请查阅文档。以下便捷函数通过 Flat API 暴露了 `Memory` 类的一部分功能：'
- en: public byte getByte(Address addr)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: public byte getByte(Address addr)
- en: Returns the single byte value retrieved from `addr`. Data type `byte` is a signed
    type in Java, so this value will be in the range –128..127.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 返回从 `addr` 获取的单个字节值。数据类型 `byte` 在 Java 中是有符号类型，因此该值的范围为 -128..127。
- en: public byte[] getBytes(Address addr, int length)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: public byte[] getBytes(Address addr, int length)
- en: Returns `length` bytes from memory, beginning at `addr`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 返回从 `addr` 开始的 `length` 字节数据。
- en: public int getInt(Address addr)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: public int getInt(Address addr)
- en: Returns the 4-byte value, beginning at `addr`, as a Java `int`. This function
    is endianness-aware and respects the binary’s underlying architecture when reconstituting
    the `int` value.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 返回从 `addr` 开始的 4 字节值，作为 Java 的 `int` 类型。此函数会考虑字节序，并在重建 `int` 值时遵循二进制的底层架构。
- en: public long getLong(Address addr)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: public long getLong(Address addr)
- en: Returns the 8-byte value, beginning at `addr`, as a Java `long`. This function
    is endianness-aware and respects the binary’s underlying architecture when reconstituting
    the `long` value.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 返回从 `addr` 开始的 8 字节值，作为 Java 的 `long` 类型。此函数会考虑字节序，并在重建 `long` 值时遵循二进制的底层架构。
- en: '**Program Search Functions**'
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**程序搜索功能**'
- en: 'Ghidra’s search capabilities reside within different Program API classes according
    to the type of item being searched for. The `Memory` class contains raw byte search
    functionality. Code units (such as `Data` and `Instruction`), comment text, and
    associated iterators are obtained from the `Listing` class. Symbols/labels and
    associated iterators are accessed via the `SymbolTable` class. The following convenience
    functions expose some of the available search functionality via the Flat API:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 的搜索功能根据被搜索项的类型，分布在不同的 Program API 类中。`Memory` 类包含原始字节搜索功能。代码单元（如 `Data`
    和 `Instruction`）、注释文本及相关迭代器从 `Listing` 类中获取。符号/标签及相关迭代器通过 `SymbolTable` 类访问。以下便捷函数通过
    Flat API 暴露了部分可用的搜索功能：
- en: public Data getFirstData()
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: public Data getFirstData()
- en: Returns the first data item in the program.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 返回程序中的第一个数据项。
- en: public Data getDataAfter(Data data)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: public Data getDataAfter(Data data)
- en: Returns the next data item after `data`, or `null` if no such data exists.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `data` 后的下一个数据项，如果没有此数据项，则返回 `null`。
- en: public Data getDataAt(Address address)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: public Data getDataAt(Address address)
- en: Returns the data item at `address`, or `null` if no such data exists.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `address` 处的数据项，如果没有此数据项，则返回 `null`。
- en: public Instruction getFirstInstruction()
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: public Instruction getFirstInstruction()
- en: Returns the first instruction in the program.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 返回程序中的第一条指令。
- en: public Instruction getInstructionAfter(Instruction instruction)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: public Instruction getInstructionAfter(Instruction instruction)
- en: Returns the next instruction item after `instruction`, or `null` if no such
    instruction exists.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `instruction` 后的下一个指令项，如果没有此指令项，则返回 `null`。
- en: public Instruction getInstructionAt(Address address)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: public Instruction getInstructionAt(Address address)
- en: Returns the instruction at `address`, or `null` if no such instruction exists.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `address` 处的指令，如果不存在此指令，则返回 `null`。
- en: public Address find(String text)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: public Address find(String text)
- en: 'Searches for a `text` string within the Listing window. Listing components
    are searched in the following order:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Listing 窗口中搜索 `text` 字符串。Listing 组件按以下顺序进行搜索：
- en: Plate comments
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Plate 注释
- en: Pre comments
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pre 注释
- en: Labels
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标签
- en: Code unit mnemonics and operands
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码单元助记符和操作数
- en: EOL comments
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: EOL 注释
- en: Repeatable comments
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可重复注释
- en: Post comments
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Post 注释
- en: A successful search returns the address containing the match. Note that as a
    result of the search order, the returned address may *not* represent the first
    occurrence of text in the disassembly listing when considered in strictly increasing
    address order.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: public Address find(Address start, byte[] values);
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Searches memory, beginning at `addr`, for a specified sequence of byte `values`.
    When `addr` is `null`, the search begins at the lowest valid address in the binary.
    A successful search returns the address of the first byte in the matching sequence.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: public Address findBytes(Address start, String byteString)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Searches memory, beginning at `addr`, for a specified `byteString` that may
    contain regular expressions. When `addr` is `null`, the search begins at the lowest
    valid address in the binary. A successful search returns the address of the first
    byte in the matching sequence.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '**Manipulating Label and Symbols**'
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The need to manipulate named locations arises fairly often in scripts. The
    following functions are available for working with named locations in a Ghidra
    database:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: public Symbol getSymbolAt(Address address)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Returns the `Symbol` associated with the given address, or `null` if the location
    has no `Symbol`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: public Symbol createLabel(Address address, String name, boolean makePrimary)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Assigns the given `name` to the given `address`. Ghidra allows multiple names
    to be assigned to a single address. If `makePrimary` is `true`, the new name will
    become the primary name associated with `address`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: public List<Symbol> getSymbols(String name, Namespace namespace)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Returns a list of all symbols named `name` in `namespace`. When namespace is
    `null`, the global namespace is searched. If the result is empty, the named symbol
    does not exist. If the result contains only one element, the name is unique.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '**Working with Functions**'
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Many scripts are designed to analyze functions within a program. The following
    functions can be used to access information about program functions:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: public final Function getFirstFunction()
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Returns the first `Function` object in the program
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: public Function getGlobalFunctions(String name)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Returns the first `Function` object for the named function, or `null` if no
    such function exists
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: public Function getFunctionAt(Address entryPoint)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Returns the `Function` object for the function at `entryPoint`, or `null` if
    no such function exists
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: public Function getFunctionAfter(Function function)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Returns the `Function` object for the successor to `function`, or `null` if
    no such function exists
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: public Function getFunctionAfter(Address address)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Returns the `Function` object for the function that starts after address, or
    `null` if no such function exists
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '**Working with Cross-References**'
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Cross-references were covered in [Chapter 9](ch09.xhtml#ch09). In the Ghidra
    Program API, the top-level `Program` object contains a `ReferenceManager`, which,
    unsurprisingly, manages the references within the program. As with many other
    program constructs, the Flat API offers convenience functions for accessing cross-references,
    some of which are detailed here:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: public Reference[] getReferencesFrom(Address address)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Returns an array of all `Reference` objects originating from `address`
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: public Reference[] getReferencesTo(Address address)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Returns an array of all `Reference` objects terminating at `address`
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '**Program Manipulation Functions**'
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When automating your analysis tasks, you may find yourself wanting to add new
    information into a program. The Flat API provides a variety of functions for modifying
    the contents of a program, including the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: public final void clearListing(Address address)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Removes any instruction or data defined at `address`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: public void removeFunctionAt(Address address)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Removes the function at `address`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: public boolean disassemble(Address address)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Performs a recursive descent disassembly beginning at `address`. Returns `true`
    if the operation is successful.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: public Data createByte(Address address)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Converts the item at the specified address into a data byte. Also, `createWord`,
    `createDword`, `createQword`, and other data creation functions are available.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: public boolean setEOLComment(Address address, String comment)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Adds an EOL comment at the given `address`. Additional comment-related functions
    include `setPlateComment`, `setPreComment`, and `setPostComment`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: public Function createFunction(Address entryPoint, String name)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Creates a function with the given `name` at `entryPoint`. Ghidra attempts to
    automatically identify the end of the function by locating the function’s return
    instruction.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: public Data createAsciiString(Address address)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Creates a null-terminated ASCII string at `address`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: public Data createAsciiString(Address address, int length)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Creates an ASCII string of the specified `length` at `address`. If `length`
    is zero or less, Ghidra attempts to automatically locate the string’s null terminator.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: public Data createUnicodeString(Address address)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Creates a null-terminated Unicode string at `address`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '***The Program Class***'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Program` class represents the root of the Program API hierarchy and outermost
    layer of the data model of a binary file. You will commonly use a `Program` object
    (often `currentProgram`) to access the binary model. Commonly used `Program` class
    member functions include the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: public Listing getListing()
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Retrieves the `Listing` object for the current program.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: public FunctionManager getFunctionManager()
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Retrieves the program’s `FunctionManager`, which provides access to all of the
    functions that have been identified within the binary. This class provides the
    functionality to map an `Address` back to its containing `Function` (`Function`
    `getFunctionContaining (``Address` `addr)`). In addition, it provides a `FunctionIterator`,
    which is useful when you want to process every function in the program.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: public SymbolTable getSymbolTable()
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Retrieves the program’s `SymbolTable` object. Using a `SymbolTable`, you can
    work with individual symbols or iterate over every symbol in the program.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: public Memory getMemory()
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Retrieves the `Memory` object associated with this program, which allows you
    to work with raw program byte content.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: public ReferenceManager getReferenceManager()
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Retrieves the program’s `ReferenceManager` object. A `ReferenceManager` may
    be used to add and remove references as well as retrieve iterators for many types
    of references.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: public Address getMinAddress()
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Returns the lowest valid address within the program. This is most often the
    binary’s base memory address.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: public Address getMaxAddress()
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Returns the highest valid address within the program.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: public LanguageID getLanguageID()
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Returns the object representation of the binary’s language specification. The
    language specification itself may then be retrieved using the `getIdAsString()`
    function.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '***The Function Interface***'
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Function` interface defines the required Program API behaviors of function
    objects. Member functions provide access to various attributes commonly associated
    with functions and include the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: public String getPrototypeString(boolean formalSignature,
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: boolean includeCallingConvention)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Returns the `Function` object’s prototype as a string. The two arguments influence
    the format of the returned prototype string.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: public AddressSetView getBody()
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Returns the address set that contains the function’s body of code. An *address
    set* is composed of one or more address ranges, and allows for situations in which
    a function’s code is distributed among several noncontiguous ranges of memory.
    Obtain an `AddressIterator` to visit all addresses in the set or an `AddressRangeIterator`
    to iterate over each range. Note that you must use a `Listing` object to retrieve
    the actual instructions contained in the function’s body (see `getInstructions`).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: public StackFrame getStackFrame()
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Returns the stack frame associated with the function. The result may be used
    to retrieve detailed information about the layout of the function’s local variables
    and stack-based arguments.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '***The Instruction Interface***'
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Instruction` interface defines the required Program API behaviors of instruction
    objects. Member functions provide access to various attributes commonly associated
    with instructions and include the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: public String getMnemonicString()
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Returns the instruction’s mnemonic.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: public String getComment(int commentType)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Returns the `commentType` comment associated with the instruction or `null`
    if no comment of the given type is associated with the instruction. A `commentType`
    may be one of `EOL_COMMENT`, `PRE_COMMENT`, `POST_COMMENT`, or `REPEATABLE_COMMENT`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: public int getNumOperands()
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Returns the number of operands associated with this instruction.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: public int getOperandType(int opIndex)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Returns a bitmask of operand type flags defined in class `OperandType`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: public String toString()
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Returns the string representation of the instruction.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '**Ghidra Scripting Examples**'
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the remainder of the chapter, we present some fairly common situations in
    which a script can be used to answer a question about a program. For brevity,
    only the body of each script’s `run` function is shown.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '***Example 1: Enumerating Functions***'
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many scripts operate on individual functions. Examples include generating the
    call tree rooted at a specific function, generating the control flow graph of
    a function, and analyzing the stack frames of every function in a program. [Listing
    14-1](ch14.xhtml#exa14_1) iterates through every function in a program and prints
    basic information about each function, including the start and end addresses of
    the function, the size of the function’s arguments, and the size of the function’s
    local variables. All output is sent to the console window.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 14-1: Function enumeration script*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: The script uses Ghidra’s Flat API to iterate over all functions from the first
    ➊ and advancing through each in succession ➎. A reference to each function’s stack
    frame is obtained ➋, and the size of the local variables ➌ and the stack-based
    arguments ➍ retrieved. A summary for each function is printed before continuing
    the iteration.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '***Example 2: Enumerating Instructions***'
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Within a given function, you may want to enumerate every instruction. [Listing
    14-2](ch14.xhtml#exa14_2) counts the number of instructions contained in the function
    identified by the current cursor position:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 14-2: Instruction enumeration script*'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: The function begins by obtaining a reference to the function containing the
    cursor ➊. If a function is found, the next step is to use the program’s `Listing`
    object to obtain an `InstructionIterator` over the function ➋. The iteration loop
    counts the number of instructions retrieved, and the total is reported to the
    user with a pop-up message dialog ➌.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '***Example 3: Enumerating Cross-References***'
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Iterating through cross-references can be confusing because of the number of
    functions available for accessing cross-reference data and the fact that code
    cross-references are bidirectional. To get the data you want, you need to access
    the proper type of cross-reference for your situation.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: In our first cross-reference example, shown in [Listing 14-3](ch14.xhtml#exa14_3),
    we retrieve the list of all function calls made within a function by iterating
    through each instruction in the function to determine if the instruction calls
    another function. One method of doing this might be to parse the results of the
    `getMnemonicString` function to look for `call` instructions. This would not be
    a very portable or efficient solution because the instruction used to call a function
    varies among processor types, and additional parsing would be required to determine
    exactly which function was being called. Cross-references avoid each of these
    difficulties because they are processor-independent and directly inform us about
    the target of the cross-reference.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 14-3: Enumerating function calls*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '**DANGEROUS FUNCTIONS**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'The C functions `strcpy` and `sprintf` are considered dangerous to use because
    they allow unbounded copying into destination buffers. While each may be safely
    used by programmers who check the size of source and destination buffers, such
    checks are all too often forgotten by programmers unaware of the dangers of these
    functions. The `strcpy` function, for example, is declared as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `strcpy` function copies all characters up to and including the first null
    termination character encountered in the source buffer to the given destination
    buffer (`dest`). The fundamental problem is that there is no way to determine,
    at runtime, the size of any array, and `strcpy` can’t determine whether the capacity
    of the destination buffer is sufficient to hold all of the data to be copied from
    source. Such unchecked copy operations are a major cause of buffer overflow vulnerabilities.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: We begin by obtaining a reference to the function containing the cursor ➊. Next,
    we iterate through each instruction in the function ➋, and for each instruction,
    we iterate through each cross-reference from the instruction ➌. We are interested
    only in cross-references that call other functions, so we must test the return
    value of `getReferenceType` ➍ to determine whether `isCall` is `true`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '***Example 4: Finding Function Calls***'
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Cross-references are also useful for identifying every instruction that references
    a particular location. In [Listing 14-4](ch14.xhtml#exa14_4), we iterate across
    all of the cross-references *to* a particular symbol (as opposed to *from* in
    the previous example).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 14-4: Enumerating a function’s callers*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have written the helper function `getFunctions` ➏ to collect
    `Function` objects associated with our functions of interest. For each function
    of interest, we call a second helper function, `list_calls` ➊, to process all
    cross-references ➋ to the function. If the cross-reference type is determined
    to be a call-type cross-reference ➌, the calling function is retrieved ➍ and its
    name is displayed to the user ➎. Among other things, this approach could be used
    to create a low-budget security analyzer by highlighting all calls to functions
    such as `strcpy` and `sprintf`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '***Example 5: Emulating Assembly Language Behavior***'
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are a number of reasons you might need to write a script that emulates
    the behavior of a program you are analyzing. For example, the program you are
    studying may be self-modifying, as many malware programs are, or the program may
    contain some encoded data that gets decoded when needed at runtime. Without running
    the program and pulling the modified data out of the running process’s memory,
    how can you understand the behavior of the program?
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: If the decoding process is not terribly complex, you may be able to quickly
    write a script that performs the same actions that are performed by the program
    when it runs. Using a script to decode data in this way eliminates the need to
    run the program when you don’t know what the program does or you don’t have access
    to a platform on which you can run the program. For example, without a MIPS execution
    environment, you cannot execute a MIPS binary and observe any data decoding it
    might perform. You could, however, write a Ghidra script to mimic the behavior
    of the binary and make the required changes within your Ghidra project, all with
    no need for a MIPS execution environment.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: The following x86 code was extracted from a DEFCON Capture the Flag binary:^([1](footnotes.xhtml#ch14fn1))
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code decodes a private key that has been embedded within the program binary.
    Using the script in [Listing 14-5](ch14.xhtml#exa14_5), we can extract the private
    key without running the program.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 14-5: Emulating assembly language with a Ghidra script*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-5](ch14.xhtml#exa14_5) is a fairly literal translation of the preceding
    assembly language sequence generated according to the following mechanical rules:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: For each stack variable and register used in the assembly code, declare an appropriately
    typed script variable.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each assembly language statement, write a statement that mimics its behavior.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulate reading and writing stack variables by reading and writing the corresponding
    variable declared in your script.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulate reading from a nonstack location using the `getByte`, `getWord`, `getDword`,
    or `getQword` function, depending on the amount of data being read (1, 2, 4, or
    8 bytes).
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulate writing to a nonstack location using the `setByte`, `setWord`, `setDword`,
    or `setQword` function, depending on the amount of data being written.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the code contains a loop for which the termination condition is not immediately
    obvious, begin with an infinite loop such as `while(true){...}` and then insert
    a `break` statement when you encounter statements that cause the loop to terminate.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the assembly code calls functions, things get complicated. To properly
    simulate the behavior of the assembly code, you must mimic the behavior of the
    function that has been called, including providing a return value that makes sense
    within the context of the code being simulated.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the complexity of the assembly code increases, it becomes more challenging
    to write a script that emulates all aspects of an assembly language sequence,
    but you don’t have to fully understand how the code you are emulating works. Translate
    one or two instructions at a time. If each instruction has been correctly translated,
    the script as a whole should properly mimic the complete functionality of the
    original assembly code. After the script has been completed, you can use the script
    to better understand the underlying assembly. You will see this approach, and
    more generic emulation functionality, used again in [Chapter 21](ch21.xhtml#ch21)
    when we discuss the analysis of obfuscated binaries.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, once we translate the sample algorithm and spend some time considering
    how it works, we can shorten the emulation script as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once the script executes, you can see the decoded private key starting at address
    `0x804B880`. If you don’t want to modify the Ghidra database when emulating code,
    replace the `setByte` function call with a call to `printf`, which will output
    the results to the CodeBrowser console, or write the data to a disk file for binary
    data. Don’t forget that in addition to Ghidra’s Java API, you have access to all
    of the standard Java API classes as well as any other Java packages that you’ve
    chosen to install on your system.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scripting provides a powerful means for automating repetitive tasks and extending
    Ghidra’s capabilities. This chapter has introduced Ghidra’s functionality for
    editing and building new scripts using both Java and Python. The integrated ability
    to build, compile, and run Java-based scripts within the CodeBrowser environment
    lets you extend Ghidra’s capabilities without requiring an in-depth understanding
    of the underlying intricacies of the Ghidra development environment. [Chapters
    15](ch15.xhtml#ch15) and [16](ch16.xhtml#ch16) introduce Eclipse integration and
    the ability to run Ghidra in headless mode.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
