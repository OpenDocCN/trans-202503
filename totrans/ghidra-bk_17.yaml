- en: '## **14'
  prefs: []
  type: TYPE_NORMAL
- en: Basic Ghidra Scripting**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/com.jpg)'
  prefs: []
  type: TYPE_IMG
- en: No application can meet every need of every user. It is just not possible to
    anticipate every potential use case that may arise. Ghidra’s open source model
    facilitates feature requests and innovative contributions by developers. However,
    sometimes you need to immediately address a problem at hand and can’t wait for
    someone else to implement new functionality. To support unanticipated use cases
    and programmatic control of Ghidra’s actions, Ghidra includes integrated scripting
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Uses for scripts are infinite and can range from simple one-liners to full-blown
    programs that automate common tasks or perform complex analysis. In this chapter,
    we focus on the basic scripting that is provided through the CodeBrowser interface.
    We introduce the internal scripting environment, discuss script development using
    Java and Python, and then move on to other integrated scripting options in [Chapter
    15](ch15.xhtml#ch15).
  prefs: []
  type: TYPE_NORMAL
- en: '### **Script Manager**'
  prefs: []
  type: TYPE_NORMAL
- en: The Ghidra Script Manager is available through the CodeBrowser menu. Choosing
    Window ▸ Script Manager opens the window shown in [Figure 14-1](ch14.xhtml#fig14_1).
    The window can also be opened using the Script Manager icon in the CodeBrowser
    toolbar (a green circle with an arrow inside, also shown in the top left of the
    Script Manager window).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig14-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: Script Manager window*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Script Manager Window***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a new Ghidra installation, the Script Manager loads with over 240 scripts
    organized in a category tree, as seen on the left side of [Figure 14-1](ch14.xhtml#fig14_1).
    Some of the folders contain subfolders to provide even more detailed classification
    of the scripts. You can expand and collapse the folders to see the organization
    of the scripts. Selecting an individual folder or subfolder limits the display
    to the scripts within the selected folder. To populate this window, Ghidra locates
    and indexes all scripts in subdirectories named *ghidra_scripts* within the Ghidra
    distribution folder. Ghidra also looks for a *ghidra_scripts* directory within
    your home directory and indexes any scripts it finds there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default set of scripts covers a wide range of functionality. Some of the
    scripts are intended to demonstrate fundamental scripting concepts. The columns
    in the script list table provide additional detail about the purpose of each script.
    As with most Ghidra tables, you can control which columns are displayed as well
    as the sort order for individual columns. By default, all available fields for
    the table are displayed except Created and Path. The six information columns provide
    the following insight into a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Status** Indicates the status of the script. The field is generally blank
    but can contain a red icon to indicate an error in the script. If you have associated
    a toolbar icon with the script, the icon will appear in this column.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name** Contains the filename of the script, including its extension.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Description** A description pulled from the metadata comment within the script.
    This field can be quite lengthy, but you can read the entire contents by hovering
    over the field. This field is discussed in more depth in “[Script Development](ch14.xhtml#ch14lev234)”
    on [page 289](ch14.xhtml#page_289).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Key** Indicates if there is a key binding assigned for running the script.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Category** Specifies the path at which the script will be listed in the Script
    Manager’s topic hierarchy. This is a logical hierarchy, *not* a filesystem directory
    hierarchy.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modified** The date the script was last saved. For the default scripts the
    date is the installation date of the Ghidra instance.'
  prefs: []
  type: TYPE_NORMAL
- en: The filter field on the left side of the window searches through the script
    categories. The filter on the right searches the script names and descriptions.
    Finally, at the bottom, an additional window is initially empty. This window displays
    metadata about a selected script in an easy-to-process format that includes the
    field extracted from the metadata within the script. The format and meaning of
    the metadata fields are discussed in “[Writing Java Scripts (Not JavaScript!)](ch14.xhtml#ch14lev235)”
    on [page 289](ch14.xhtml#page_289).
  prefs: []
  type: TYPE_NORMAL
- en: While the Script Manager provides a significant amount of information, the main
    power of this window comes from the toolbar it provides. An overview of the toolbar
    is provided in [Figure 14-2](ch14.xhtml#fig14_2).
  prefs: []
  type: TYPE_NORMAL
- en: '***Script Manager Toolbar***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Script Manager has no menus to help you manage your scripts. Instead, all
    script management actions are associated with tools on the Script Manager toolbar
    ([Figure 14-2](ch14.xhtml#fig14_2)).
  prefs: []
  type: TYPE_NORMAL
- en: While most of the menu options are pretty clear from the descriptions in [Figure
    14-2](ch14.xhtml#fig14_2), the Edit options merit additional discussion. Editing
    with Eclipse is covered in [Chapter 15](ch15.xhtml#ch15), as it facilitates more
    advanced scripting capabilities. The Edit Script option opens a primitive text
    editor window with its own toolbar, shown in [Figure 14-3](ch14.xhtml#fig14_3).
    The associated actions provide the basic functionality for editing files. With
    an editor in hand, we can get down to the business of writing actual scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig14-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Script Manager toolbar*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig14-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Edit Script toolbar*'
  prefs: []
  type: TYPE_NORMAL
- en: '### **Script Development**'
  prefs: []
  type: TYPE_NORMAL
- en: There are several methods for developing scripts within Ghidra. In this chapter,
    we focus on scripting using Java and Python, as these are languages used by the
    existing scripts in the Script Manager window. Most of the 240+ system scripts
    are written in Java, so we begin with editing and developing scripts in Java.
  prefs: []
  type: TYPE_NORMAL
- en: '***Writing Java Scripts (Not JavaScript!)***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Ghidra, a script written in Java is actually a complete class specification
    designed to be seamlessly compiled, dynamically loaded into your running Ghidra
    instance, invoked, and finally unloaded. The class must extend the class `Ghidra.app.script.GhidraScript`,
    implement a `run()` method, and be annotated with comments that provide Javadoc-format
    metadata about the script. We’ll show the structure of a script file, describe
    the metadata requirements, look at some of the system scripts, and then move on
    to editing existing scripts and building our own scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-4](ch14.xhtml#fig14_4) shows the script editor opened when the Create
    New Script option (refer to [Figure 14-2](ch14.xhtml#fig14_2)) is selected to
    create a new Java script. We have named the new script *CH14_NewScript*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig14-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: A new, empty script*'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the file are the metadata comments and tags used to produce the
    expected Javadoc information. This information is also used to populate the fields
    in the Script Manager window (refer to [Figure 14-1](ch14.xhtml#fig14_1)). Any
    comments starting with `//` before the class, field, or method declarations will
    become part of the Javadoc Description for the script. Additional comments can
    be embedded within the script and will not be included in the description. In
    addition, the following tags within the metadata comments are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '@author Provides information about the author of the script. The information
    is provided at the discretion of the author and can include any pertinent details
    (for example, name, contact information, date of creation, and so on).'
  prefs: []
  type: TYPE_NORMAL
- en: '@category Determines where the script appears within the category tree. This
    is the only mandatory tag and must be present in all Ghidra scripts. The period
    (dot) character acts as a path separator for category names (for example, `@category
    Ghidrabook.CH14`).'
  prefs: []
  type: TYPE_NORMAL
- en: '@keybinding Documents a shortcut for accessing the script from the CodeBrowser
    window (for example, `@keybinding K`).'
  prefs: []
  type: TYPE_NORMAL
- en: '@menupath Defines a period-delimited menu path for the script as well as provides
    a means to run the script from a CodeBrowser menu (for example, `@menupath File.Run.ThisScript`).'
  prefs: []
  type: TYPE_NORMAL
- en: '@toolbar Associates an icon with the script. This icon is displayed as a toolbar
    button in the CodeBrowser window and may be used to run the script. If Ghidra
    cannot find the image in the script directory or the Ghidra installation, a default
    image will be used (for example, `@toolbar myImage.png`).'
  prefs: []
  type: TYPE_NORMAL
- en: When confronted with a new API (such as the Ghidra API), it may take some time
    before you’re comfortable writing scripts without constantly consulting available
    API documentation. Java in particular is very sensitive to classpath issues and
    the proper inclusion of required support packages. A time- and sanity-saving option
    is to edit an existing program rather than creating a new program. We adopt this
    approach in presenting a simple example of a script.
  prefs: []
  type: TYPE_NORMAL
- en: '***Edit Script Example: Regex Search***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Assume that you are tasked with developing a script to accept a regular expression
    as input from the user and output matching strings to the console. Further, this
    script needs to appear in the Script Manager for a particular project. While Ghidra
    offers many ways to accomplish this task, you have been asked to produce a script.
    To find a script with similar functionality to use as a base, you look through
    the categories in the Script Manager and check the contents of the Strings and
    Search categories, and then filter for the term *strings* and find other options.
    Using filters produces a more comprehensive list of string-related scripts for
    your consideration. For this example, you will edit the first script in the list
    that shares some functionality with what you want your script to do—*CountAndSaveStrings.java*.
  prefs: []
  type: TYPE_NORMAL
- en: Open the script in the editor to confirm that it’s a good starting point for
    our new functionality by right-clicking the desired script and selecting **Edit**
    with basic editor; then save this script with the new name, *FindStringsByRegex.java*,
    using the **Save As** option. Ghidra does not allow you to edit the system scripts
    provided as part of your Ghidra installation within the Script Manager window
    (although you can in Eclipse and other editors). You could also edit the file
    prior to using Save As since Ghidra prevents you from accidentally writing any
    modified content to the existing *CountAndSaveStrings.java* script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original *CountAndSaveStrings.java* contains the following metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can leave, modify, or delete the licensing agreement ➊ for the script without
    impacting the execution of the script or the associated Javadoc. We’ll modify
    the description of the script ➋ so that the information displayed in Javadoc and
    the Script Manager accurately describes the script. The script author has included
    only one of the five available tags ➌, so we’ll add placeholders for the unpopulated
    tags and revise the description, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The category tag `Ghidrabook.CH14` will be added to the Script Manager’s tree
    display, as shown in [Figure 14-5](ch14.xhtml#fig14_5).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next portion of the original script contains Java `import` statements.
    Of the long list of imports Ghidra includes when you create a new script, as shown
    in [Figure 14-4](ch14.xhtml#fig14_4), only the following imports are necessary
    for string searching, so we’ll keep the same list as the original *CountAndSaveStrings.java*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Save the new script and then select it in the Script Manager to see the content
    shown in [Figure 14-5](ch14.xhtml#fig14_5). Our new category is included in the
    script tree, and the script’s metadata is displayed in the information window
    and script table. The table contains only one script, *Ghidrabook.CH14*, as it
    is the only script in the selected category.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig14-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: New script information displayed in the Script Manager window*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As this book is not intended to be a Java tutorial, we summarize the changes
    we made to the script rather than explaining Java syntax and functionality. The
    following list describes the behavior of *CountAndSaveStrings.java*:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the program listing content to search.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the file to save results to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Iterate through the program listing: count the number of qualifying strings
    and write each qualifying string to the file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the number of qualifying strings to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The functionality we desire in our modified script is described next:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the program listing content to search.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask the user for a regular expression (regex) to search for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Iterate through the program listing: count the number of qualifying strings
    and write each qualifying string to the console.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the number of qualifying strings to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our new script will be significantly shorter than the original script, as there
    is no need to interact with the filesystem and perform associated error checking.
    Our implementation follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: All Java scripts that you write for Ghidra must extend (inherit from) an existing
    class named `Ghidra.app.script.GhidraScript` ➊. After saving the final version
    of the script, select it from within the Script Manager and execute it. When the
    script executes, we see the prompt shown in [Figure 14-6](ch14.xhtml#fig14_6).
    This figure includes the regular expression that we will be searching for to test
    our script.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig14-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: New script prompt to enter a regex*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CodeBrowser console displays the following content when our new script
    has completed execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This simple example demonstrates the low barrier to entry of Ghidra’s extensive
    Java scripting capabilities. Existing scripts can be easily modified and new scripts
    can be built from the ground up using the Script Manager. We present some more
    complex Java scripting capabilities in [Chapters 15](ch15.xhtml#ch15) and [16](ch16.xhtml#ch16),
    but Java is just one of the scripting options provided by Ghidra. Ghidra also
    allows you to author scripts in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Python Scripts***'
  prefs: []
  type: TYPE_NORMAL
- en: Of the 240+ scripts in the Script Manager, only a handful are written in Python.
    You can easily locate the Python scripts by filtering for the *.py* extension
    in the Script Manager. The majority of the Python scripts can be found in the
    Examples.Python category in the tree and includes a disclaimer similar to the
    one shown in [Figure 14-7](ch14.xhtml#fig14_7).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig14-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: Sample Python script with disclaimer*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of the examples in this directory, the following three provide a good starting
    point if you prefer to use Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '***ghidra_basic.py*** This script includes examples of basic Python scripting
    as related to Ghidra.'
  prefs: []
  type: TYPE_NORMAL
- en: '***python_basics.py*** This is a very basic introduction to many of the Python
    commands that you might want to use.'
  prefs: []
  type: TYPE_NORMAL
- en: '***jython_basic.py*** This extends the basic Python commands to demonstrate
    content that is specific to Jython.'
  prefs: []
  type: TYPE_NORMAL
- en: The Ghidra features demonstrated in these examples barely scratch the surface
    of the available Ghidra APIs. You’ll likely still need to spend some time reading
    through Ghidra’s library of Java examples before you’ll be ready to access Ghidra’s
    full Java API from your Python scripts.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to running Python scripts, Ghidra provides the Python Interpreter
    to allow you to use Python/Jython to directly access the Java objects associated
    with Ghidra, as shown in [Figure 14-8](ch14.xhtml#fig14_8).
  prefs: []
  type: TYPE_NORMAL
- en: '**GHIDRA’S PYTHON FUTURE**'
  prefs: []
  type: TYPE_NORMAL
- en: Python is popular for creating scripts because of its simplicity and numerous
    available libraries. While the majority of the scripts in the Ghidra release are
    written in Java, the open source RE community likely will use Python as a primary
    scripting language within Ghidra. Ghidra is reliant on Jython for Python support
    (which provides the advantage of allowing direct access to Ghidra’s Java objects).
    Jython is compatible with Python 2 (specifically 2.7.1) but not Python 3\. Although
    Python 2 went end-of-life in January 2020, Python 2 scripts will continue to function
    within Ghidra, and any new Ghidra Python 2 scripts should be written in a way
    that makes them as portable as possible to Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig14-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: Python Interpreter* print *example*'
  prefs: []
  type: TYPE_NORMAL
- en: The Python Interpreter is accessible through the CodeBrowser by selecting Windows
    ▸ Python. For more information about using the interpreter, see Ghidra Help. To
    get API information when using Python and the Python Interpreter, choose Help
    ▸ Ghidra API Help at the top left of the Interpreter window shown in [Figure 14-8](ch14.xhtml#fig14_8),
    which opens the Javadoc content on the `GhidraScript` class. Alternatively, Python
    has a built-in function, `help( )`, that has been modified in Ghidra to provide
    direct access to Ghidra’s Javadoc. To use the function, type `help(`object`)`
    in the interpreter, as shown in [Figure 14-9](ch14.xhtml#fig14_9). For example,
    `help(currentProgram)` displays the Ghidra Javadoc content describing the Ghidra
    API class `ProgramDB`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig14-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Python Interpreter Help example*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Support for Other Languages***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, Ghidra can support scripts from languages other than Java and Python,
    which lets you bring existing scripts from your reverse engineering toolkit into
    your Ghidra workflow. This functionality is discussed further in Ghidra Help.
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction to the Ghidra API**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, you have all the information required to edit and run Ghidra
    scripts. Now it’s time to use the Ghidra API to extend your scripting capabilities
    and interact more directly with Ghidra artifacts. Ghidra exposes its API in two
    rather different styles.
  prefs: []
  type: TYPE_NORMAL
- en: The *Program* API defines an object hierarchy, many levels deep, rooted at the
    top by the `Program` class. This API may change from one version of Ghidra to
    another. The *Flat* API flattens out the Program API by exposing all levels of
    that API from a single class, `FlatProgramAPI`. The Flat API is often the most
    convenient way to access many Ghidra constructs. Additionally, it is less likely
    to change from one version of Ghidra to the next.
  prefs: []
  type: TYPE_NORMAL
- en: For the remainder of the chapter, we highlight some of the more useful Flat
    API functionality. When necessary, we also provide detail about specific classes
    from the Program API. We use Java as the language for this discussion, as it is
    the native language of Ghidra.
  prefs: []
  type: TYPE_NORMAL
- en: The Ghidra API contains many packages, classes, and associated functions to
    interface with your Ghidra projects and associated files, all detailed in Javadoc-style
    documentation supplied with Ghidra that can be accessed by clicking the red plus
    in the Script Manager window. This documentation, in conjunction with the sample
    scripts supplied with Ghidra, is your primary reference about the APIs and how
    to use them. The most common way to figure out how to do something is to browse
    the Ghidra classes looking for one that, based on its name, appears to do what
    you need. As you gain more experience with Ghidra, your increased understanding
    of the naming conventions and file organization will help you identify appropriate
    classes more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Ghidra adheres to the Java Swing *model-delegate* architecture in which data
    values and characteristics are stored in model objects and displayed by user interface
    delegate objects such as tree, list, and table views. Delegates handle events,
    such as mouse clicks, to update and refresh data and views. In the overwhelming
    majority of cases, your scripts will focus on the data encapsulated in the model
    classes used to represent various program and reverse engineering constructs.
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of this section focuses on commonly used model classes, their
    relationships to each other, and useful APIs for interacting with them. We make
    no attempt to cover the entire Ghidra API, and many more functions and classes
    are available. The authoritative documentation for the entire Ghidra API is the
    Javadoc that ships with Ghidra, and ultimately the Java source code from which
    Ghidra is built.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Address Interface***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Address` interface describes a model for an address within an address space.
    All addresses are represented by an offset up to 64 bits in size. Segmented addresses
    may be further qualified by a segment value. In many cases, an address’s offset
    is equivalent to a virtual address within a program listing. The `getOffset` method
    retrieves the `long` offset value from an `Address` instance. Many Ghidra API
    functions require `Address` objects as arguments or return an `Address` object
    as a result.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Symbol Interface***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Symbol` interface defines properties common to all symbols. At a minimum,
    a symbol is composed of a name and an address. These attributes may be retrieved
    with the following member functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Address getAddress()
  prefs: []
  type: TYPE_NORMAL
- en: Returns the address of the `Symbol`
  prefs: []
  type: TYPE_NORMAL
- en: String getName()
  prefs: []
  type: TYPE_NORMAL
- en: Returns the name of the `Symbol`
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***The Reference Interface***'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Reference` models a cross-reference relationship (as described in [Chapter
    9](ch09.xhtml#ch09)) between a source address and a destination address and is
    characterized by a reference type. Useful functions associated with a `Reference`
    include these:'
  prefs: []
  type: TYPE_NORMAL
- en: public Address getFromAddress()
  prefs: []
  type: TYPE_NORMAL
- en: Returns the source address for this reference
  prefs: []
  type: TYPE_NORMAL
- en: public Address getToAddress()
  prefs: []
  type: TYPE_NORMAL
- en: Returns the destination address for this reference
  prefs: []
  type: TYPE_NORMAL
- en: public RefType getReferenceType()
  prefs: []
  type: TYPE_NORMAL
- en: Returns a `RefType` object that describes the nature of the link between the
    source and destination addresses
  prefs: []
  type: TYPE_NORMAL
- en: '***The GhidraScript Class***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although this class doesn’t model a specific attribute in a binary, every script
    that you write must be a subclass of `GhidraScript`, which, in turn, is a subclass
    of `FlatProgramAPI`. As a result, your scripts have instantaneous access to the
    entire Flat API and your only obligation is to provide an implementation of
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: which, hopefully, makes your script do something interesting. The remainder
    of the `GhidraScript` class gives you access to the most common resources for
    interacting with the Ghidra user and the program that is being analyzed. Some
    of the more useful functions and data members of this class (including some inherited
    from `FlatProgramAPI`) are summarized in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: '**Useful Data Members**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `GhidraScript` class provides convenient access to a number of objects
    commonly referenced in scripts, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: protected Program currentProgram;
  prefs: []
  type: TYPE_NORMAL
- en: This is the current open program. The `Program` class is discussed later. This
    data member is likely your gateway to retrieving more interesting information,
    such as instruction and symbol lists.
  prefs: []
  type: TYPE_NORMAL
- en: protected Address currentAddress;
  prefs: []
  type: TYPE_NORMAL
- en: This is the address of the current cursor location. The `Address` class is discussed
    later.
  prefs: []
  type: TYPE_NORMAL
- en: protected ProgramLocation currentLocation;
  prefs: []
  type: TYPE_NORMAL
- en: A `ProgramLocation` object that describes the current cursor location, including
    its address, cursor row, column, and other information.
  prefs: []
  type: TYPE_NORMAL
- en: protected ProgramSelection currentSelection;
  prefs: []
  type: TYPE_NORMAL
- en: A `ProgramSelection` object representing a range of addresses selected in the
    Ghidra GUI.
  prefs: []
  type: TYPE_NORMAL
- en: protected TaskMonitor monitor;
  prefs: []
  type: TYPE_NORMAL
- en: The `TaskMonitor` class updates the status of long-running tasks and checks
    to determine whether a long-running task has been cancelled by the user (`monitor.isCancelled()`).
    Any long-running loops that you write should incorporate a call to `monitor.isCancelled`
    as an additional termination condition to recognize that the user has attempted
    to cancel your script.
  prefs: []
  type: TYPE_NORMAL
- en: '**User Interface Functions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The GhidraScript class provides convenience functions for basic user interface
    operations, ranging from simple message output to more interactive dialog elements.
    Some of the more common user interface functions are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: public void println(String message)
  prefs: []
  type: TYPE_NORMAL
- en: Prints `message` followed by a linefeed to Ghidra’s console window. This function
    is useful for printing status messages or results of your scripts in a nonintrusive
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: public void printf(String message, Object... args)
  prefs: []
  type: TYPE_NORMAL
- en: Uses `message` as a Java format string and prints the resulting string of formatted
    `args` to Ghidra’s console window.
  prefs: []
  type: TYPE_NORMAL
- en: public void popup(final String message)
  prefs: []
  type: TYPE_NORMAL
- en: Displays `message` in a pop-up dialog that requires the user to click OK before
    script execution can continue. This is a more intrusive way to display status
    messages to a user.
  prefs: []
  type: TYPE_NORMAL
- en: public String askString(String title, String message)
  prefs: []
  type: TYPE_NORMAL
- en: One of many available `ask` functions. `askString` displays a text input dialog,
    using `message` as a prompt, and returns the text entered by the user.
  prefs: []
  type: TYPE_NORMAL
- en: public boolean askYesNo(String title, String question)
  prefs: []
  type: TYPE_NORMAL
- en: Uses a dialog to ask the user a yes-or-no `question`. Returns `true` for yes,
    and `false` for no.
  prefs: []
  type: TYPE_NORMAL
- en: public Address askAddress(String title, String message)
  prefs: []
  type: TYPE_NORMAL
- en: Displays a dialog, using `message` as a prompt, that parses the user’s input
    into an `Address` object.
  prefs: []
  type: TYPE_NORMAL
- en: public int askInt(String title, String message)
  prefs: []
  type: TYPE_NORMAL
- en: Displays a dialog, using `message` as a prompt, that parses the user’s input
    into an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: public File askFile(final String title, final String approveButtonText)
  prefs: []
  type: TYPE_NORMAL
- en: Displays a system file chooser dialog and returns a Java `File` object representing
    the file selected by the user.
  prefs: []
  type: TYPE_NORMAL
- en: public File askDirectory(final String title, final String approveButtonText)
  prefs: []
  type: TYPE_NORMAL
- en: Displays a system file chooser dialog and returns a Java `File` object representing
    the directory selected by the user.
  prefs: []
  type: TYPE_NORMAL
- en: public boolean goTo(Address address)
  prefs: []
  type: TYPE_NORMAL
- en: Repositions all connected Ghidra disassembly windows to `address`. Overloaded
    versions of this function take a `Symbol` or a `Function` argument and navigate
    the displays accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Address-Related Functions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For a processor, an address is typically just a number that happens to refer
    to a memory location. Ghidra models addresses using the `Address` class. `GhidraScript`
    provides a wrapper function that offers easy conversion from numbers to Ghidra
    `Address` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: public Address toAddr(long offset)
  prefs: []
  type: TYPE_NORMAL
- en: Convenience function to create an `Address` object in the default address space
  prefs: []
  type: TYPE_NORMAL
- en: '**Reading Program Memory**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `Memory` class represents contiguous ranges of byte values, such as the
    contents of an executable file loaded into Ghidra. Within a `Memory` object, every
    byte value is associated with an address, though addresses may be tagged as uninitialized
    and have no value to retrieve. Ghidra throws a `MemoryAccessException` if you
    attempt to access a location within a memory object with an invalid address. Consult
    the documentation for the `Memory` class for a full description of available API
    functions. The following convenience functions expose some of the `Memory` class
    via the Flat API:'
  prefs: []
  type: TYPE_NORMAL
- en: public byte getByte(Address addr)
  prefs: []
  type: TYPE_NORMAL
- en: Returns the single byte value retrieved from `addr`. Data type `byte` is a signed
    type in Java, so this value will be in the range –128..127.
  prefs: []
  type: TYPE_NORMAL
- en: public byte[] getBytes(Address addr, int length)
  prefs: []
  type: TYPE_NORMAL
- en: Returns `length` bytes from memory, beginning at `addr`.
  prefs: []
  type: TYPE_NORMAL
- en: public int getInt(Address addr)
  prefs: []
  type: TYPE_NORMAL
- en: Returns the 4-byte value, beginning at `addr`, as a Java `int`. This function
    is endianness-aware and respects the binary’s underlying architecture when reconstituting
    the `int` value.
  prefs: []
  type: TYPE_NORMAL
- en: public long getLong(Address addr)
  prefs: []
  type: TYPE_NORMAL
- en: Returns the 8-byte value, beginning at `addr`, as a Java `long`. This function
    is endianness-aware and respects the binary’s underlying architecture when reconstituting
    the `long` value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Program Search Functions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Ghidra’s search capabilities reside within different Program API classes according
    to the type of item being searched for. The `Memory` class contains raw byte search
    functionality. Code units (such as `Data` and `Instruction`), comment text, and
    associated iterators are obtained from the `Listing` class. Symbols/labels and
    associated iterators are accessed via the `SymbolTable` class. The following convenience
    functions expose some of the available search functionality via the Flat API:'
  prefs: []
  type: TYPE_NORMAL
- en: public Data getFirstData()
  prefs: []
  type: TYPE_NORMAL
- en: Returns the first data item in the program.
  prefs: []
  type: TYPE_NORMAL
- en: public Data getDataAfter(Data data)
  prefs: []
  type: TYPE_NORMAL
- en: Returns the next data item after `data`, or `null` if no such data exists.
  prefs: []
  type: TYPE_NORMAL
- en: public Data getDataAt(Address address)
  prefs: []
  type: TYPE_NORMAL
- en: Returns the data item at `address`, or `null` if no such data exists.
  prefs: []
  type: TYPE_NORMAL
- en: public Instruction getFirstInstruction()
  prefs: []
  type: TYPE_NORMAL
- en: Returns the first instruction in the program.
  prefs: []
  type: TYPE_NORMAL
- en: public Instruction getInstructionAfter(Instruction instruction)
  prefs: []
  type: TYPE_NORMAL
- en: Returns the next instruction item after `instruction`, or `null` if no such
    instruction exists.
  prefs: []
  type: TYPE_NORMAL
- en: public Instruction getInstructionAt(Address address)
  prefs: []
  type: TYPE_NORMAL
- en: Returns the instruction at `address`, or `null` if no such instruction exists.
  prefs: []
  type: TYPE_NORMAL
- en: public Address find(String text)
  prefs: []
  type: TYPE_NORMAL
- en: 'Searches for a `text` string within the Listing window. Listing components
    are searched in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Plate comments
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pre comments
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Labels
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code unit mnemonics and operands
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: EOL comments
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeatable comments
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Post comments
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A successful search returns the address containing the match. Note that as a
    result of the search order, the returned address may *not* represent the first
    occurrence of text in the disassembly listing when considered in strictly increasing
    address order.
  prefs: []
  type: TYPE_NORMAL
- en: public Address find(Address start, byte[] values);
  prefs: []
  type: TYPE_NORMAL
- en: Searches memory, beginning at `addr`, for a specified sequence of byte `values`.
    When `addr` is `null`, the search begins at the lowest valid address in the binary.
    A successful search returns the address of the first byte in the matching sequence.
  prefs: []
  type: TYPE_NORMAL
- en: public Address findBytes(Address start, String byteString)
  prefs: []
  type: TYPE_NORMAL
- en: Searches memory, beginning at `addr`, for a specified `byteString` that may
    contain regular expressions. When `addr` is `null`, the search begins at the lowest
    valid address in the binary. A successful search returns the address of the first
    byte in the matching sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '**Manipulating Label and Symbols**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The need to manipulate named locations arises fairly often in scripts. The
    following functions are available for working with named locations in a Ghidra
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: public Symbol getSymbolAt(Address address)
  prefs: []
  type: TYPE_NORMAL
- en: Returns the `Symbol` associated with the given address, or `null` if the location
    has no `Symbol`.
  prefs: []
  type: TYPE_NORMAL
- en: public Symbol createLabel(Address address, String name, boolean makePrimary)
  prefs: []
  type: TYPE_NORMAL
- en: Assigns the given `name` to the given `address`. Ghidra allows multiple names
    to be assigned to a single address. If `makePrimary` is `true`, the new name will
    become the primary name associated with `address`.
  prefs: []
  type: TYPE_NORMAL
- en: public List<Symbol> getSymbols(String name, Namespace namespace)
  prefs: []
  type: TYPE_NORMAL
- en: Returns a list of all symbols named `name` in `namespace`. When namespace is
    `null`, the global namespace is searched. If the result is empty, the named symbol
    does not exist. If the result contains only one element, the name is unique.
  prefs: []
  type: TYPE_NORMAL
- en: '**Working with Functions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Many scripts are designed to analyze functions within a program. The following
    functions can be used to access information about program functions:'
  prefs: []
  type: TYPE_NORMAL
- en: public final Function getFirstFunction()
  prefs: []
  type: TYPE_NORMAL
- en: Returns the first `Function` object in the program
  prefs: []
  type: TYPE_NORMAL
- en: public Function getGlobalFunctions(String name)
  prefs: []
  type: TYPE_NORMAL
- en: Returns the first `Function` object for the named function, or `null` if no
    such function exists
  prefs: []
  type: TYPE_NORMAL
- en: public Function getFunctionAt(Address entryPoint)
  prefs: []
  type: TYPE_NORMAL
- en: Returns the `Function` object for the function at `entryPoint`, or `null` if
    no such function exists
  prefs: []
  type: TYPE_NORMAL
- en: public Function getFunctionAfter(Function function)
  prefs: []
  type: TYPE_NORMAL
- en: Returns the `Function` object for the successor to `function`, or `null` if
    no such function exists
  prefs: []
  type: TYPE_NORMAL
- en: public Function getFunctionAfter(Address address)
  prefs: []
  type: TYPE_NORMAL
- en: Returns the `Function` object for the function that starts after address, or
    `null` if no such function exists
  prefs: []
  type: TYPE_NORMAL
- en: '**Working with Cross-References**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Cross-references were covered in [Chapter 9](ch09.xhtml#ch09). In the Ghidra
    Program API, the top-level `Program` object contains a `ReferenceManager`, which,
    unsurprisingly, manages the references within the program. As with many other
    program constructs, the Flat API offers convenience functions for accessing cross-references,
    some of which are detailed here:'
  prefs: []
  type: TYPE_NORMAL
- en: public Reference[] getReferencesFrom(Address address)
  prefs: []
  type: TYPE_NORMAL
- en: Returns an array of all `Reference` objects originating from `address`
  prefs: []
  type: TYPE_NORMAL
- en: public Reference[] getReferencesTo(Address address)
  prefs: []
  type: TYPE_NORMAL
- en: Returns an array of all `Reference` objects terminating at `address`
  prefs: []
  type: TYPE_NORMAL
- en: '**Program Manipulation Functions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When automating your analysis tasks, you may find yourself wanting to add new
    information into a program. The Flat API provides a variety of functions for modifying
    the contents of a program, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: public final void clearListing(Address address)
  prefs: []
  type: TYPE_NORMAL
- en: Removes any instruction or data defined at `address`.
  prefs: []
  type: TYPE_NORMAL
- en: public void removeFunctionAt(Address address)
  prefs: []
  type: TYPE_NORMAL
- en: Removes the function at `address`.
  prefs: []
  type: TYPE_NORMAL
- en: public boolean disassemble(Address address)
  prefs: []
  type: TYPE_NORMAL
- en: Performs a recursive descent disassembly beginning at `address`. Returns `true`
    if the operation is successful.
  prefs: []
  type: TYPE_NORMAL
- en: public Data createByte(Address address)
  prefs: []
  type: TYPE_NORMAL
- en: Converts the item at the specified address into a data byte. Also, `createWord`,
    `createDword`, `createQword`, and other data creation functions are available.
  prefs: []
  type: TYPE_NORMAL
- en: public boolean setEOLComment(Address address, String comment)
  prefs: []
  type: TYPE_NORMAL
- en: Adds an EOL comment at the given `address`. Additional comment-related functions
    include `setPlateComment`, `setPreComment`, and `setPostComment`.
  prefs: []
  type: TYPE_NORMAL
- en: public Function createFunction(Address entryPoint, String name)
  prefs: []
  type: TYPE_NORMAL
- en: Creates a function with the given `name` at `entryPoint`. Ghidra attempts to
    automatically identify the end of the function by locating the function’s return
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: public Data createAsciiString(Address address)
  prefs: []
  type: TYPE_NORMAL
- en: Creates a null-terminated ASCII string at `address`.
  prefs: []
  type: TYPE_NORMAL
- en: public Data createAsciiString(Address address, int length)
  prefs: []
  type: TYPE_NORMAL
- en: Creates an ASCII string of the specified `length` at `address`. If `length`
    is zero or less, Ghidra attempts to automatically locate the string’s null terminator.
  prefs: []
  type: TYPE_NORMAL
- en: public Data createUnicodeString(Address address)
  prefs: []
  type: TYPE_NORMAL
- en: Creates a null-terminated Unicode string at `address`.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Program Class***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Program` class represents the root of the Program API hierarchy and outermost
    layer of the data model of a binary file. You will commonly use a `Program` object
    (often `currentProgram`) to access the binary model. Commonly used `Program` class
    member functions include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: public Listing getListing()
  prefs: []
  type: TYPE_NORMAL
- en: Retrieves the `Listing` object for the current program.
  prefs: []
  type: TYPE_NORMAL
- en: public FunctionManager getFunctionManager()
  prefs: []
  type: TYPE_NORMAL
- en: Retrieves the program’s `FunctionManager`, which provides access to all of the
    functions that have been identified within the binary. This class provides the
    functionality to map an `Address` back to its containing `Function` (`Function`
    `getFunctionContaining (``Address` `addr)`). In addition, it provides a `FunctionIterator`,
    which is useful when you want to process every function in the program.
  prefs: []
  type: TYPE_NORMAL
- en: public SymbolTable getSymbolTable()
  prefs: []
  type: TYPE_NORMAL
- en: Retrieves the program’s `SymbolTable` object. Using a `SymbolTable`, you can
    work with individual symbols or iterate over every symbol in the program.
  prefs: []
  type: TYPE_NORMAL
- en: public Memory getMemory()
  prefs: []
  type: TYPE_NORMAL
- en: Retrieves the `Memory` object associated with this program, which allows you
    to work with raw program byte content.
  prefs: []
  type: TYPE_NORMAL
- en: public ReferenceManager getReferenceManager()
  prefs: []
  type: TYPE_NORMAL
- en: Retrieves the program’s `ReferenceManager` object. A `ReferenceManager` may
    be used to add and remove references as well as retrieve iterators for many types
    of references.
  prefs: []
  type: TYPE_NORMAL
- en: public Address getMinAddress()
  prefs: []
  type: TYPE_NORMAL
- en: Returns the lowest valid address within the program. This is most often the
    binary’s base memory address.
  prefs: []
  type: TYPE_NORMAL
- en: public Address getMaxAddress()
  prefs: []
  type: TYPE_NORMAL
- en: Returns the highest valid address within the program.
  prefs: []
  type: TYPE_NORMAL
- en: public LanguageID getLanguageID()
  prefs: []
  type: TYPE_NORMAL
- en: Returns the object representation of the binary’s language specification. The
    language specification itself may then be retrieved using the `getIdAsString()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Function Interface***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Function` interface defines the required Program API behaviors of function
    objects. Member functions provide access to various attributes commonly associated
    with functions and include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: public String getPrototypeString(boolean formalSignature,
  prefs: []
  type: TYPE_NORMAL
- en: boolean includeCallingConvention)
  prefs: []
  type: TYPE_NORMAL
- en: Returns the `Function` object’s prototype as a string. The two arguments influence
    the format of the returned prototype string.
  prefs: []
  type: TYPE_NORMAL
- en: public AddressSetView getBody()
  prefs: []
  type: TYPE_NORMAL
- en: Returns the address set that contains the function’s body of code. An *address
    set* is composed of one or more address ranges, and allows for situations in which
    a function’s code is distributed among several noncontiguous ranges of memory.
    Obtain an `AddressIterator` to visit all addresses in the set or an `AddressRangeIterator`
    to iterate over each range. Note that you must use a `Listing` object to retrieve
    the actual instructions contained in the function’s body (see `getInstructions`).
  prefs: []
  type: TYPE_NORMAL
- en: public StackFrame getStackFrame()
  prefs: []
  type: TYPE_NORMAL
- en: Returns the stack frame associated with the function. The result may be used
    to retrieve detailed information about the layout of the function’s local variables
    and stack-based arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Instruction Interface***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Instruction` interface defines the required Program API behaviors of instruction
    objects. Member functions provide access to various attributes commonly associated
    with instructions and include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: public String getMnemonicString()
  prefs: []
  type: TYPE_NORMAL
- en: Returns the instruction’s mnemonic.
  prefs: []
  type: TYPE_NORMAL
- en: public String getComment(int commentType)
  prefs: []
  type: TYPE_NORMAL
- en: Returns the `commentType` comment associated with the instruction or `null`
    if no comment of the given type is associated with the instruction. A `commentType`
    may be one of `EOL_COMMENT`, `PRE_COMMENT`, `POST_COMMENT`, or `REPEATABLE_COMMENT`.
  prefs: []
  type: TYPE_NORMAL
- en: public int getNumOperands()
  prefs: []
  type: TYPE_NORMAL
- en: Returns the number of operands associated with this instruction.
  prefs: []
  type: TYPE_NORMAL
- en: public int getOperandType(int opIndex)
  prefs: []
  type: TYPE_NORMAL
- en: Returns a bitmask of operand type flags defined in class `OperandType`.
  prefs: []
  type: TYPE_NORMAL
- en: public String toString()
  prefs: []
  type: TYPE_NORMAL
- en: Returns the string representation of the instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ghidra Scripting Examples**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the remainder of the chapter, we present some fairly common situations in
    which a script can be used to answer a question about a program. For brevity,
    only the body of each script’s `run` function is shown.
  prefs: []
  type: TYPE_NORMAL
- en: '***Example 1: Enumerating Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many scripts operate on individual functions. Examples include generating the
    call tree rooted at a specific function, generating the control flow graph of
    a function, and analyzing the stack frames of every function in a program. [Listing
    14-1](ch14.xhtml#exa14_1) iterates through every function in a program and prints
    basic information about each function, including the start and end addresses of
    the function, the size of the function’s arguments, and the size of the function’s
    local variables. All output is sent to the console window.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-1: Function enumeration script*'
  prefs: []
  type: TYPE_NORMAL
- en: The script uses Ghidra’s Flat API to iterate over all functions from the first
    ➊ and advancing through each in succession ➎. A reference to each function’s stack
    frame is obtained ➋, and the size of the local variables ➌ and the stack-based
    arguments ➍ retrieved. A summary for each function is printed before continuing
    the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '***Example 2: Enumerating Instructions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Within a given function, you may want to enumerate every instruction. [Listing
    14-2](ch14.xhtml#exa14_2) counts the number of instructions contained in the function
    identified by the current cursor position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-2: Instruction enumeration script*'
  prefs: []
  type: TYPE_NORMAL
- en: The function begins by obtaining a reference to the function containing the
    cursor ➊. If a function is found, the next step is to use the program’s `Listing`
    object to obtain an `InstructionIterator` over the function ➋. The iteration loop
    counts the number of instructions retrieved, and the total is reported to the
    user with a pop-up message dialog ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '***Example 3: Enumerating Cross-References***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Iterating through cross-references can be confusing because of the number of
    functions available for accessing cross-reference data and the fact that code
    cross-references are bidirectional. To get the data you want, you need to access
    the proper type of cross-reference for your situation.
  prefs: []
  type: TYPE_NORMAL
- en: In our first cross-reference example, shown in [Listing 14-3](ch14.xhtml#exa14_3),
    we retrieve the list of all function calls made within a function by iterating
    through each instruction in the function to determine if the instruction calls
    another function. One method of doing this might be to parse the results of the
    `getMnemonicString` function to look for `call` instructions. This would not be
    a very portable or efficient solution because the instruction used to call a function
    varies among processor types, and additional parsing would be required to determine
    exactly which function was being called. Cross-references avoid each of these
    difficulties because they are processor-independent and directly inform us about
    the target of the cross-reference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-3: Enumerating function calls*'
  prefs: []
  type: TYPE_NORMAL
- en: '**DANGEROUS FUNCTIONS**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The C functions `strcpy` and `sprintf` are considered dangerous to use because
    they allow unbounded copying into destination buffers. While each may be safely
    used by programmers who check the size of source and destination buffers, such
    checks are all too often forgotten by programmers unaware of the dangers of these
    functions. The `strcpy` function, for example, is declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `strcpy` function copies all characters up to and including the first null
    termination character encountered in the source buffer to the given destination
    buffer (`dest`). The fundamental problem is that there is no way to determine,
    at runtime, the size of any array, and `strcpy` can’t determine whether the capacity
    of the destination buffer is sufficient to hold all of the data to be copied from
    source. Such unchecked copy operations are a major cause of buffer overflow vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: We begin by obtaining a reference to the function containing the cursor ➊. Next,
    we iterate through each instruction in the function ➋, and for each instruction,
    we iterate through each cross-reference from the instruction ➌. We are interested
    only in cross-references that call other functions, so we must test the return
    value of `getReferenceType` ➍ to determine whether `isCall` is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Example 4: Finding Function Calls***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Cross-references are also useful for identifying every instruction that references
    a particular location. In [Listing 14-4](ch14.xhtml#exa14_4), we iterate across
    all of the cross-references *to* a particular symbol (as opposed to *from* in
    the previous example).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-4: Enumerating a function’s callers*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have written the helper function `getFunctions` ➏ to collect
    `Function` objects associated with our functions of interest. For each function
    of interest, we call a second helper function, `list_calls` ➊, to process all
    cross-references ➋ to the function. If the cross-reference type is determined
    to be a call-type cross-reference ➌, the calling function is retrieved ➍ and its
    name is displayed to the user ➎. Among other things, this approach could be used
    to create a low-budget security analyzer by highlighting all calls to functions
    such as `strcpy` and `sprintf`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Example 5: Emulating Assembly Language Behavior***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are a number of reasons you might need to write a script that emulates
    the behavior of a program you are analyzing. For example, the program you are
    studying may be self-modifying, as many malware programs are, or the program may
    contain some encoded data that gets decoded when needed at runtime. Without running
    the program and pulling the modified data out of the running process’s memory,
    how can you understand the behavior of the program?
  prefs: []
  type: TYPE_NORMAL
- en: If the decoding process is not terribly complex, you may be able to quickly
    write a script that performs the same actions that are performed by the program
    when it runs. Using a script to decode data in this way eliminates the need to
    run the program when you don’t know what the program does or you don’t have access
    to a platform on which you can run the program. For example, without a MIPS execution
    environment, you cannot execute a MIPS binary and observe any data decoding it
    might perform. You could, however, write a Ghidra script to mimic the behavior
    of the binary and make the required changes within your Ghidra project, all with
    no need for a MIPS execution environment.
  prefs: []
  type: TYPE_NORMAL
- en: The following x86 code was extracted from a DEFCON Capture the Flag binary:^([1](footnotes.xhtml#ch14fn1))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code decodes a private key that has been embedded within the program binary.
    Using the script in [Listing 14-5](ch14.xhtml#exa14_5), we can extract the private
    key without running the program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-5: Emulating assembly language with a Ghidra script*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-5](ch14.xhtml#exa14_5) is a fairly literal translation of the preceding
    assembly language sequence generated according to the following mechanical rules:'
  prefs: []
  type: TYPE_NORMAL
- en: For each stack variable and register used in the assembly code, declare an appropriately
    typed script variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each assembly language statement, write a statement that mimics its behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulate reading and writing stack variables by reading and writing the corresponding
    variable declared in your script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulate reading from a nonstack location using the `getByte`, `getWord`, `getDword`,
    or `getQword` function, depending on the amount of data being read (1, 2, 4, or
    8 bytes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulate writing to a nonstack location using the `setByte`, `setWord`, `setDword`,
    or `setQword` function, depending on the amount of data being written.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the code contains a loop for which the termination condition is not immediately
    obvious, begin with an infinite loop such as `while(true){...}` and then insert
    a `break` statement when you encounter statements that cause the loop to terminate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the assembly code calls functions, things get complicated. To properly
    simulate the behavior of the assembly code, you must mimic the behavior of the
    function that has been called, including providing a return value that makes sense
    within the context of the code being simulated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the complexity of the assembly code increases, it becomes more challenging
    to write a script that emulates all aspects of an assembly language sequence,
    but you don’t have to fully understand how the code you are emulating works. Translate
    one or two instructions at a time. If each instruction has been correctly translated,
    the script as a whole should properly mimic the complete functionality of the
    original assembly code. After the script has been completed, you can use the script
    to better understand the underlying assembly. You will see this approach, and
    more generic emulation functionality, used again in [Chapter 21](ch21.xhtml#ch21)
    when we discuss the analysis of obfuscated binaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, once we translate the sample algorithm and spend some time considering
    how it works, we can shorten the emulation script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Once the script executes, you can see the decoded private key starting at address
    `0x804B880`. If you don’t want to modify the Ghidra database when emulating code,
    replace the `setByte` function call with a call to `printf`, which will output
    the results to the CodeBrowser console, or write the data to a disk file for binary
    data. Don’t forget that in addition to Ghidra’s Java API, you have access to all
    of the standard Java API classes as well as any other Java packages that you’ve
    chosen to install on your system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scripting provides a powerful means for automating repetitive tasks and extending
    Ghidra’s capabilities. This chapter has introduced Ghidra’s functionality for
    editing and building new scripts using both Java and Python. The integrated ability
    to build, compile, and run Java-based scripts within the CodeBrowser environment
    lets you extend Ghidra’s capabilities without requiring an in-depth understanding
    of the underlying intricacies of the Ghidra development environment. [Chapters
    15](ch15.xhtml#ch15) and [16](ch16.xhtml#ch16) introduce Eclipse integration and
    the ability to run Ghidra in headless mode.
  prefs: []
  type: TYPE_NORMAL
