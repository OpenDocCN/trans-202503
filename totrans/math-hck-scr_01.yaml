- en: '**1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**What Computers Think About Numbers**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To do math, a computer needs a way of representing numbers. As it turns out,
    computers think about numbers pretty differently than humans do.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we like to think we can keep counting to higher and higher numbers
    forever, but computers have a limited amount of storage space. If they start counting,
    they eventually run out of room. There is no biggest number, but there *is* a
    biggest number your computer can represent in Scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we think about fractions and decimal numbers as matching up with
    points on a number line, with an infinite number of points fitting between any
    two whole numbers. But as we pack points more and more tightly together in the
    finite world of computers, eventually we run out of room to keep track of them.
    There is no smallest positive number, but there *is* a smallest positive number
    your computer can work with in Scratch.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll look at what’s going on behind your computer screen and
    how computers think about numbers. We’ll explore the limitations of what numbers
    Scratch can represent. It’s important to understand these limits so we can be
    sure the results we get from a program are accurate. You’ll also learn some hacks
    for getting around Scratch’s limits and tricking the computer into representing
    more numbers than would normally be possible.
  prefs: []
  type: TYPE_NORMAL
- en: What Are Numbers, Anyway?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Everybody *thinks* they know what numbers are, but there are many number systems
    to choose from, depending on what we want the numbers to do. We usually learn
    to count with numbers starting from 1, so we call those numbers *counting numbers*.
    Sometimes we want to start counting from 0, in which case the numbers are called
    *whole numbers*. When we go forward and backward, allowing negative numbers too,
    we generate the set of *integers*: { . . . , –3, –2, –1, 0, 1, 2, 3, . . . }.'
  prefs: []
  type: TYPE_NORMAL
- en: We can make an association with geometry and think of numbers as corresponding
    to points on a line, building the set of *real numbers*. We can also divide integers
    by other (nonzero) integers to make *rational numbers*. Here we use *rational*
    not to mean logical and making sense, but because the numbers are built from *ratios*.
    Sometimes rational numbers are called *fractions*, but this can be misleading.
    In common language, a *fraction* of something is only a portion of it, suggesting
    a part less than 1, whereas rational numbers like 3/2 and 4/3 can be bigger than
    1\. Also, fractions are usually thought of with a denominator of 2 or more (halves,
    thirds, and so on), but rational numbers sometimes have a denominator of 1, as
    in 2/1, 3/1, and so on. In this way, an integer is a special kind of rational
    number.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all these kinds of numbers, we use our intuition that when we name a particular
    number, we’re identifying one element of an infinite collection. That is, we expect
    numbers to go on forever: “To infinity and beyond,” as Buzz Lightyear says. There’s
    another way that numbers can be used, though, where they wrap around and recycle
    their values over and over, like the numbers on a clock. This way of working with
    numbers is useful for tracking things that happen regularly or repeatedly, and
    it has some interesting properties that we’ll explore in the next chapter when
    we look at modular arithmetic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first few chapters of this book, we’ll be most interested in counting
    numbers, also called *positive integers*. When we talk about numbers without being
    more specific, that’s the default interpretation to use. But so far, we’ve considered
    only what numbers are or aren’t included in a number system. There’s a whole other
    factor to consider as well: how those numbers are *represented*.'
  prefs: []
  type: TYPE_NORMAL
- en: Base 10? Base 2? You Pick!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *basis representation system* determines how numbers are broken down into
    groups for ease of counting and how many symbols are needed to represent those
    numbers. Probably because we have 10 fingers, humans typically think of numbers
    in *decimal*, a basis system that uses groups of 10\. We start counting one at
    a time and use a different symbol for each new number, 1 through 9\. When we run
    out of fingers, we group double handfuls of fingers and count by tens. When there
    are no units left over after separating groups of 10, we use the symbol 0, a closed
    fist, to show this. So we understand 34 as 3 tens and 4 ones, and 60 as 6 tens
    and 0 ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extend the pattern of grouping by 10 to represent increasingly large
    numbers with relatively few digits, introducing a third-place digit for 10 tens
    (100), a fourth place for 10 hundreds (1,000), and so on. It helps to use exponents
    to indicate the repeated multiplication. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg23_Image_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We always have the option of sorting out the grouping using expanded notation.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg23_Image_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since the decimal system hinges on powers of 10, it’s also called *base 10*.
    But while humans favor base 10, other ways of grouping are possible. For example,
    if you wanted to count using only the fingers on one hand, you could group by
    fives and have a *base 5* system. Base 5 numeration needs only the symbols 0,
    1, 2, 3, and 4\. The number five is written as 10, six as 11, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eggs and donuts are sold by the dozen, a group of 12, and we even have a word
    for a dozen dozen: a *gross*. *Base 12* numeration uses the symbols 0, 1, 2, 3,
    4, 5, 6, 7, 8, and 9 as usual, but it needs two extra single-digit symbols to
    represent the numbers ten and eleven. Usually we use T and E. If we need to specify
    the base, we can do it with a subscript, such as 15[10] to indicate that 15 is
    written in base 10\. This makes it easier to compare numbers written in different
    basis systems. For example, 15[10] = 13[12] = 30[5], which is to say that (1 ⋅
    10) + 5 = (1 ⋅ 12) + 3 = (3 ⋅ 5) + 0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most computers use a *base 2* system, also called *binary*, to represent numbers
    internally. This system has the advantage that it requires only two symbols, 0
    and 1\. This matters because 0 and 1 are easy to keep track of with the position
    of a switch: the switch is either off (0) or on (1). Having only two symbols is
    good for expressing logic, too, where the two possibilities could represent *false*
    and *true*. A drawback is that powers of 2 (1, 2, 4, 8, 16, . . .) grow more slowly
    than powers of 10 (1, 10, 100, 1,000, . . .), so it typically takes more digits
    to represent a number in binary than it does to represent the same number in decimal.
    We’ll talk more about this later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 1: What’s 77 in Binary?'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For a given positive integer, there’s a unique way of writing it in base 10,
    and it also has a unique representation in binary. In this project, we’ll write
    a Scratch program that converts from decimal to binary so we can see what the
    computer is seeing when it represents a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways we might approach this problem: strategies we can call *big-to-little*
    and *little-to-big*. According to the big-to-little strategy, we first find the
    largest power of 2 contained in a decimal number, to determine the leftmost digit
    of the base 2 representation. Then we subtract that power of 2 and find the largest
    power of 2 in the difference. We keep repeating this process to build up the binary
    representation, generating the digits from left to right. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg24_Image_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The big-to-little strategy matches the way most humans would approach doing
    a decimal-to-binary conversion in their heads, but the little-to-big strategy
    is much easier to code on a computer. Instead of searching for the largest power
    of 2 contained in a number, all we have to do is program a series of divisions
    by 2 and keep track of the remainders. This builds up the binary representation
    from right to left. [Figure 1-1](ch01.xhtml#ch1fig1) shows a Scratch program that
    uses the little-to-big approach.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg24_Image_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-1: A program to convert decimal (base 10) numbers into binary (base
    2)*'
  prefs: []
  type: TYPE_NORMAL
- en: We build up the binary version of a number in the `string` variable, which starts
    out blank at the beginning of the program. (A *string* is a sequence of characters;
    more on this in “Hacking the Code” on [page 5](ch01.xhtml#ch01lev5).) To get started,
    we use the `ask and wait` block to have Scratch Cat prompt the user for a number
    in base 10, storing the user’s `answer` in the `n` variable. Then we enter a `repeat
    until` loop ❶, where the real logic is.
  prefs: []
  type: TYPE_NORMAL
- en: '`n mod 2` returns the remainder of dividing `n` by `2`, which will be `1` if
    `n` is odd or `0` if `n` is even. Each time through the loop, this `mod` operation
    gives us one digit of the binary representation of the number, starting with the
    least significant (rightmost) digit. We use the `join` block to merge that digit
    with the contents already in the `string` variable, putting the result back in
    `string`. Then we divide `n` by `2` and use `floor` to round the result down to
    the nearest whole number. This removes the value of the binary digit we just accounted
    for from `n`. Then, the loop can start again to find the next binary digit.'
  prefs: []
  type: TYPE_NORMAL
- en: Once `n` gets down to `0`, we’ve built up the complete binary representation
    of the number from right to left. We then use some more `join` blocks to put together
    a meaningful sentence reporting the result, which Scratch Cat announces through
    the `say` block.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Run the program and try entering **77** when Scratch Cat asks for a number.
    You should get 1001101 as the result, as shown in [Figure 1-2](ch01.xhtml#ch1fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg25_Image_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-2: Converting 77[10] into base 2*'
  prefs: []
  type: TYPE_NORMAL
- en: Because of the way Scratch works, you’ll see a lot of figures in this book that
    combine different points from a program’s execution into one image, like this
    one. In this case, you can see Scratch Cat’s speech bubbles from both the `ask
    and wait` and `say` blocks, as well as the box for entering the base 10 number.
    The execution flow will be clear when you’re doing these experiments yourself,
    but when you’re looking at the figures in the book you might need to do a little
    interpretation of what happens when.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The program treats the decimal-to-binary conversion as a sequence of halvings.
    You could also think of it in reverse, as a sequence of doublings, with a +1 for
    each 1 in the binary representation and a +0 for each 0\. For example, we can
    represent the conversion of 77 mathematically as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg25_Image_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see the digits of the binary representation in red. Stacking up the
    multiplications in this way puts every binary digit with its appropriate power
    of 2.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to know about this program is that while the answer
    Scratch reports looks like a number, it’s actually a string. As I mentioned earlier,
    a string is just a list of characters. Usually those characters are letters of
    the alphabet strung together to form messages like `Hello` or `Tell me a number`,
    but in this case, the characters happen to be 0s and 1s. So even though the result
    looks like binary digits making up a number, Scratch has no idea that `1001101`
    is a binary number with a decimal value of 77.
  prefs: []
  type: TYPE_NORMAL
- en: We have to use strings because Scratch doesn’t have a built-in way to work directly
    with binary numbers. If we wanted Scratch to do binary arithmetic on base 2 numbers,
    we would have to write a custom program to teach it how. This is the first of
    many cases in this book where we’ll have to treat numbers as strings to “trick”
    Scratch into doing what we want.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  prefs: []
  type: TYPE_NORMAL
- en: '**1.1** Write a program that prompts for a base *b*, then prompts for a base
    10 number *n*, and then returns the number *n* written in the base *b*. You might
    limit the base *b* to be between 2 and 10, or go on to use the digits E and T
    to allow base 11 or 12.'
  prefs: []
  type: TYPE_NORMAL
- en: '**1.2** A popular computer-related base is base 16, *hexadecimal*, which usully
    uses the extra symbols A, B, C, D, E, and F to stand for 10, 11, 12, 13, 14, and
    15\. Extend your base converter to give hexadecimal representations. See if you
    can spot the trick for converting back and forth between binary and hexadecimal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 2: What’s 1001101 in Decimal?'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s try converting backward from a binary representation to a decimal
    one. [Figure 1-3](ch01.xhtml#ch1fig3) shows a Scratch program that does this.
  prefs: []
  type: TYPE_NORMAL
- en: We first ask the user for a string representing a binary value with an `ask
    and wait` block. Then we use a `repeat` loop and the `index` variable to look
    at the string one character at a time, from left to right, with `letter index
    of answer` accessing the current character. The variable `n` starts at `0`. For
    each digit in the binary representation, `n` is doubled and then has the value
    of the current digit (either `0` or `1`) added to it. When there are no more binary
    digits left, `n` holds the decimal representation of the number.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg27_Image_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-3: A program to convert binary (base 2) numbers into decimal (base
    10)*'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We know that 77 in binary is 1001101\. Try running the program and entering
    1001101 to see if it gives 77 back. [Figure 1-4](ch01.xhtml#ch1fig4) shows the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg27_Image_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-4: Converting 1001101[2] into base 10*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve worked a lot with 77, converting it to binary in [Figure 1-2](ch01.xhtml#ch1fig2)
    and then back to decimal again in [Figure 1-4](ch01.xhtml#ch1fig4). But what is
    the number 77 *really*? Whether we write it in binary or decimal, 77 represents
    the same quantity. How we choose to write a number might reveal interesting facts
    about it (for instance, if a number written in decimal ends in a 0, the number
    must be divisible by 10, and if a number written in binary ends in a 0, the number
    has to be divisible by 2), but it doesn’t change the value of the number at all.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One problem with our binary-to-decimal program is that it has no check to make
    sure it’s working with a string of binary digits. If you input something that
    isn’t a number in binary notation, Scratch Cat is happy to tell you nonsense,
    as the examples in [Figure 1-5](ch01.xhtml#ch1fig5) show.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg28_Image_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-5: Three outputs from the binary-to-decimal converter. There’s nothing
    to stop you from entering something other than a binary number!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could fix this by including a custom `Screen string` block to check the
    input. This block, shown in [Figure 1-6](ch01.xhtml#ch1fig6), makes sure the input
    is in the right form: a string of characters that includes only 0s and 1s.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg28_Image_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-6: Making sure only base 2 numbers are allowed*'
  prefs: []
  type: TYPE_NORMAL
- en: The block sets the logical (*Boolean*, or true/false) variable `binary string?`
    to `true` as long as the user didn’t input any other characters (like spaces,
    letters, or digits greater than 1). Otherwise, it sets `binary string?` to `false`.
    We can now use this block with an `if...else` statement so we don’t get any silly,
    incorrect answers, as shown in [Figure 1-7](ch01.xhtml#ch1fig7). The operator
    blocks that Scratch uses for Boolean tests are all green hexagons that you can
    plug into the test condition in control blocks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg29_Image_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-7: The binary-to-decimal converter done more carefully*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ve moved the original binary-to-decimal code inside the `if` branch
    of an `if...else` block so it runs only if the `binary string?` variable is `true`.
    Otherwise, Scratch Cat will inform the user that the input wasn’t a binary number.
  prefs: []
  type: TYPE_NORMAL
- en: You may be disappointed that the program is a little longer now than it was
    originally. Scratch makes it easy to write really compact programs, and it even
    encourages this by telling you how many blocks there are in the programming window.
    But sometimes, it’s better to be careful even if it makes your program a bit longer.
    If it’s possible to misunderstand something or make a mistake in the input, at
    some point someone will do that, so it’s better to be safe than sorry! Some programming
    languages have special commands to intercept errors and reroute them somewhere
    harmless (the syntax usually involves the keywords `try` and `catch`), but Scratch
    leaves it up to you to anticipate problems and guard against them, as we’ve done
    with the `Screen string` block.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenge'
  prefs: []
  type: TYPE_NORMAL
- en: '**1.3** Sometimes news stories talk about *exponential growth* as a general
    term to suggest rapid increase. Exponential growth means something specific in
    mathematics, where progression from one value in a sequence of numbers to the
    next value is done by multiplication using a fixed factor. For example, every
    number might be two times larger than the one before it. An alternative is *linear
    growth*, where the change happens by *adding* a fixed increment, such as when
    each number is two more than the previous one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write some Scratch code that prompts the user for a multiplier or an increment,
    and answers with a sequence of numbers that grows exponentially or linearly. Compare
    the growth: What happens if the user gives a number less than 1 for exponential
    growth? What happens if the user gives a number less than 0 for linear growth?
    Maybe this is a situation that calls for input screening.'
  prefs: []
  type: TYPE_NORMAL
- en: How Computers Represent Numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Computers can represent numbers internally in different ways, but they all involve
    some kind of compromise. Earlier I mentioned that humans think of number systems
    like integers and real numbers as being infinite. Computers aren’t built to handle
    infinite collections, though. They have to work within the confines of the architecture
    of their hardware or the logical structure of the programming language they’re
    running.
  prefs: []
  type: TYPE_NORMAL
- en: On the hardware side, central processing units (CPUs) typically have *registers*,
    which are areas of the CPU that can hold and operate on a certain number of binary
    digits, or *bits*, at once. Programming languages are designed to allocate a fixed
    number of bits to represent each number, so language designers need to make decisions
    about what exactly those bits mean (for example, whether some represent a base
    and others an exponent). They also need to make decisions about things like how
    to represent a number as negative or positive and what to do if a number takes
    up more than the available space. Should the computation halt with a warning or
    an error, or should the representation wrap back around without complaint, possibly
    leading to unexpected and incorrect results?
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, we can’t fit infinitely many numbers into a computer’s finite space
    of possibilities, so “most” numbers have to be left out. This means the developers
    of a computer language need to decide which numbers and what kinds of numbers
    are interesting and important enough to include. Some people need to represent
    tiny numbers, the size of subatomic particles, while others need to represent
    massive numbers, the size of the universe, and still others need everything in
    between. Different languages may be designed to fill some of these needs but not
    others.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond questions of how big or small the numbers are, language designers might
    also want to consider how the numbers will be used. For instance, sometimes numbers
    are used to count, answering questions about “How many?” In this case, the answer
    is often a whole number. (This comes up often enough that lots of programming
    languages give integers their own representation system, separate from other kinds
    of numbers.) Other times, numbers are used to measure, answering questions about
    “How much?” The answers to those questions are less likely to be whole numbers.
    Language designers need a way to represent those “in between” numbers, and they
    have to decide exactly how far “in between” to go.
  prefs: []
  type: TYPE_NORMAL
- en: The Point of Floating Point
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Floating-point notation* allows for “in between” numbers by including powers
    of the base smaller than 1\. In base 10, there’s a *decimal point*, with digits
    to the right of the decimal point representing a number between 0 and 1 with a
    combination of powers of 1/10, 1/100, and so on. For instance, the approximation
    of *π*, 3.14, indicates a number that’s a little more than 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg31_Image_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you need a closer approximation, you can include a few more digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg31_Image_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The same principle applies to floating-point notation for binary numbers, where
    digits to the right of the *binary point* (the binary equivalent of a decimal
    point) represent powers of 1/2\. You’re probably familiar with using binary fractions
    to represent numbers—even if you don’t realize it—if you’ve ever measured lengths
    with a ruler or tape measure (see [Figure 1-8](ch01.xhtml#ch1fig8)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg31_Image_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-8: Binary fractions on a tape measure*'
  prefs: []
  type: TYPE_NORMAL
- en: Inches are subdivided into halves (1/2), quarters (1/4), eighths (1/8), sixteenths
    (1/16), and so on. These are binary fractions in that each denominator is a power
    of 2\. You could measure 1 13/16 inches, for example, by going over 1, then 1/2,
    then 1/4, then 1/16, and write 1 13/16 with a binary representation of 1.1101.
  prefs: []
  type: TYPE_NORMAL
- en: Binary fractions give us a way to write non-whole numbers, but how many bits
    should be used to represent a number, and how should they be interpreted? Anyone
    who invents a computer language can make their own rules, but it’s better to have
    a standard that everyone agrees to use so there won’t be any confusion when switching
    from one language to another. One such standard is the IEEE Standard for Floating-Point
    Arithmetic, or IEEE 754\. The makers of Scratch chose to use this standard to
    represent all numbers, even whole numbers, whereas some languages use IEEE 754
    for floating-point numbers and a different standard for integers.
  prefs: []
  type: TYPE_NORMAL
- en: Double the Precision, Double the Fun
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: IEEE 754 uses *double precision*, meaning a floating-point number in binary
    will occupy 64 bits (unlike *single precision*, which allows for 32 bits per number).
    [Figure 1-9](ch01.xhtml#ch1fig9) shows how the 64 bits are allocated.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg32_Image_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-9: How bits are allocated in the IEEE 754 standard*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first bit, shown in cyan in the figure, is for the sign: 0 or 1 for plus
    or minus. The last 64 – 1 – 11 = 52 bits, shown in orange, represent a number,
    conventionally a value between 1 and 2, that is called the *mantissa*. Since a
    binary number between 1 and 2 always looks like a 1, then a binary point, then
    some other digits, we can save one binary digit by not writing the initial 1 explicitly.
    So instead of 52 bits of precision, we really have 53 bits. The 11 bits after
    the sign bit, colored in purple in the figure, are for the exponent, specifying
    a power of 2 used to multiply the mantissa. Sometimes the exponent is called the
    *characteristic*. Having 11 bits in the characteristic gives a range of 2^(11)
    possible exponents, which are interpreted as going from 2^(–1,023) to 2^(1,024),
    but the very top and bottom numbers are reserved for special use.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For a hands-on look at how IEEE 754 works, there are interactive online tools
    that let you change floating-point numbers bit by bit (literally) to see what
    happens. Some examples are the double-precision tools at* [https://float.exposed](https://float.exposed)
    *and* [http://evanw.github.io/float-toy/](http://evanw.github.io/float-toy/).'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that 53 digits of precision in binary doesn’t translate into 53
    digits of precision in decimal. For example, 2^(10) = 1,024, which is about the
    same as 10³ = 1,000\. This indicates that 10 binary digits convey about as much
    information as 3 decimal digits, so 53 binary digits can hold as much information
    as about 16 or 17 decimal digits. That’s still a lot—way more than you’re likely
    to see on a calculator screen—but it’s far from infinite.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we’re mainly interested in integers, so 16 decimal digits of precision
    means that a 16-digit number, somewhere in the low quadrillions, is the biggest
    number Scratch can be counted on to represent exactly as a counting number. When
    we test numbers for properties such as divisibility in future chapters, we’ll
    need to be sure all the digits of the numbers are reliably represented to get
    correct results. We’ll explore this limitation in our next project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 3: 2^(53) + 1 = ?'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Some languages give the largest integer that can be represented exactly in
    floating-point notation a special name, *flintmax*, which is an abbreviation for
    *floating-point integer maximum*. The value of flintmax in Scratch is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg33_Image_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 1-10](ch01.xhtml#ch1fig10) shows a little program illustrating how
    arithmetic goes awry when you try to work with numbers bigger than flintmax. Keep
    an eye on the variables as you run the program to see where the problem arises.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg33_Image_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-10: Integer arithmetic is unreliable above flintmax.*'
  prefs: []
  type: TYPE_NORMAL
- en: Subtracting 1 from flintmax works fine, but adding 1 to flintmax doesn’t give
    the expected result. The value of the variable `flintmax+1` is flintmax itself.
    You have to add 2 to change flintmax and get a correct answer.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s always interesting to test the limits and see where a computer language
    or other system breaks down. People who are interested in video games, for example,
    spend lots of time looking for glitches and locations that break the game’s underlying
    model or make the game’s objects behave weirdly. It’s part of the fun to see how
    things can go wrong and to conduct experiments to try to work out how the computer
    is handling itself.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, our program showed that when calculations in Scratch exceed flintmax,
    the results are suspect and may not correspond to exact integer arithmetic. We’ll
    need to keep that in mind as we design programs to explore integer arithmetic
    in Scratch. As long as the numbers, including intermediate results, remain under
    flintmax, though, the results will be exact. For instance, you can write a Scratch
    program that counts up starting from 1, and you’ll get all the way to flintmax
    before there’s a missing integer value.
  prefs: []
  type: TYPE_NORMAL
- en: Our program also showed that IEEE 754 can represent *some* integers above flintmax,
    such as flintmax + 2, correctly. In fact, it can represent even numbers (multiples
    of 2) above flintmax exactly for a while, but eventually it loses another digit
    of binary accuracy, after which point it represents only multiples of 4 exactly.
    You can try extending the program in [Figure 1-10](ch01.xhtml#ch1fig10) to illustrate
    this. What’s the largest integer *n* for which Scratch can correctly distinguish
    between *n* and *n* + 2? How does that value compare with flintmax? Likewise,
    what’s the largest integer *n* where there’s a difference between *n* and *n*
    + 4?
  prefs: []
  type: TYPE_NORMAL
- en: Another way that arithmetic can get broken in Scratch is when the result of
    a computation doesn’t match any numerical value. For example, Scratch reports
    `Infinity` when you try to divide by 0, as in [Figure 1-11](ch01.xhtml#ch1fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg34_Image_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-11: Sometimes the answer is* Infinity.'
  prefs: []
  type: TYPE_NORMAL
- en: But what happens when you try to subtract `Infinity` from `Infinity`? The answer
    reported in [Figure 1-12](ch01.xhtml#ch1fig12) is `NaN`, which means *not a number*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg35_Image_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-12: Sometimes the answer is not a number.*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll encounter these special values, `Infinity` and `NaN`, in the output of
    some of our programs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  prefs: []
  type: TYPE_NORMAL
- en: '**1.4** What’s the largest number that Scratch can represent, integer or not?
    What happens when that number is exceeded?'
  prefs: []
  type: TYPE_NORMAL
- en: '**1.5** Try using Scratch to create a floating-point simulator like the ones
    mentioned in the note on [page 12](ch01.xhtml#common1). You should be able to
    look at a 64-bit string of 0s and 1s and see the floating-point number associated
    with it, then change the bits to see how the number changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 4: A Million-Digit Number?'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this project, we’ll trick Scratch into doing exact integer arithmetic with
    many more digits of precision than flintmax provides. To get around the limits
    of the IEEE 754 standard for number representation, we’ll have to program our
    own alternative representation system for large numbers. We have a few different
    options here. For example, we could store decimal numbers one digit at a time
    in a list, in which case the only limit would be Scratch’s maximum list length
    of 200,000\. If we stored five digits at a time as list entries, we could get
    to one million digits!
  prefs: []
  type: TYPE_NORMAL
- en: Another option could be to store the numbers as strings. Strings can be very
    long, even millions of characters. Scratch doesn’t provide any built-in operations
    for performing arithmetic on strings, though, so if we wanted to work with numbers
    represented as strings we’d have to program the arithmetic operations ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-13](ch01.xhtml#ch1fig13) shows an example of a program that reliably
    performs calculations on numbers well beyond flintmax. The program prompts for
    an exponent *n* and then displays all the digits of 2^(*n*), both as a list of
    digits and as a string built by joining the digits together.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg36_Image_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-13: Calculating powers of 2 with extended precision*'
  prefs: []
  type: TYPE_NORMAL
- en: The program builds up 2^(*n*) as a list of digits from right to left. The list
    (called `Digits`) starts with just the number 1, which is 2⁰. Then we repeat the
    process of doubling `n` times, calculating the next highest power of 2 by stepping
    through each digit in the list (using the `i` variable) and doubling it ❶. A problem
    comes up for digits with values between 5 and 9, though, which double into two-digit
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, think about how addition works. In particular, consider
    how you’re taught to add multidigit numbers from right to left while keeping track
    of a *carry*. If you wanted to calculate 24 + 18, for example, you would start
    with the ones digit, so you would calculate 4 + 8 = 12, write down 2, and carry
    the 1\. Then you would look at the tens digit; you would calculate 2 + 1 = 3,
    add the carry to get 4, and then report the answer as 42\. The 1 that was carried
    in the first step was actually 10, so it counts as 1 ⋅ 10 when we keep track of
    the groups of 10 counted in the leftmost place.
  prefs: []
  type: TYPE_NORMAL
- en: The second nested repeat loop ➋ in [Figure 1-13](ch01.xhtml#ch1fig13) implements
    this carrying logic to limit every number in the list to a single digit. Calculating
    `floor of item i of Digits / 10` gives us `1` if the current number has two digits.
    We add that `1` to the next item in the list (item `i + 1`) to perform the carry,
    then take `item i of Digits mod 10` to limit the current number to just its ones
    digit. Before all this, we add a `0` to the end of the list in case the last item
    needs a carry operation. The `if...then` statement near the end of the program
    removes that `0` if it wasn’t needed.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It would be nice to see the answer reported so it looks like a number, not a
    digit-by-digit list. We can do that with the custom `To string` block shown in
    [Figure 1-14](ch01.xhtml#ch1fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg37_Image_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-14: Merging the list of digits into a string*'
  prefs: []
  type: TYPE_NORMAL
- en: This block joins the items of the list into a string, building it up from right
    to left, so the answer is exhibited in a more readable way.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Try testing the program on a bigger number than Scratch would normally be able
    to represent. For example, [Figure 1-15](ch01.xhtml#ch1fig15) shows a run of the
    program calculating 2^(106), which is flintmax squared.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg38_Image_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-15: Accurately calculating flintmax squared*'
  prefs: []
  type: TYPE_NORMAL
- en: All 32 digits are reported correctly (after Scratch finishes, you can scroll
    down through the list to see them all). Notice that `Digits` lists the digits
    starting from the ones place.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  prefs: []
  type: TYPE_NORMAL
- en: '**1.6** Modify the power of 2 code in [Figure 1-13](ch01.xhtml#ch1fig13) to
    calculate 3^(53).'
  prefs: []
  type: TYPE_NORMAL
- en: '**1.7** Modify the power of 2 code in [Figure 1-13](ch01.xhtml#ch1fig13) so
    it works on “digits” that are between 0 and 99,999\. That makes each list entry
    give five digits of the calculated power, allowing Scratch to hold up to one million
    digits.'
  prefs: []
  type: TYPE_NORMAL
- en: '**1.8** Program an extended precision addition, where Scratch Cat prompts for
    two large numbers entered as strings, resolves the numbers as lists of digits,
    and then adds the numbers using the same technique as the program in [Figure 1-13](ch01.xhtml#ch1fig13).
    Try to extend the code to handle multiplication as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we understand how Scratch keeps track of numbers, we can be sure to avoid
    generating errors by asking for more than Scratch can give us. This will be especially
    important for integer arithmetic, where we need all the digits of a number to
    correctly manage questions about divisibility and counting.
  prefs: []
  type: TYPE_NORMAL
- en: Scratch’s internal representation of numbers matches that of many modern programming
    languages, so the information in this chapter is widely applicable. Once we know
    the limits, we can figure out how to work around them to get more information
    out of a program than the language could normally provide. That’s the best hack
    of all!
  prefs: []
  type: TYPE_NORMAL
