- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network Communications
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sketch 48: Opening a Web Page'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A web page is really just a text file containing the description of that page
    in enough detail to draw it on the screen. A program called a browser reads and
    renders that file into a viewable page. The file itself resides on a computer
    somewhere on the internet, and in order to display it, we must first upload it
    to the user’s computer. The browser arranges for this to be done, but the file
    must have a unique name that identifies it—unique in the *whole world*, because
    the internet is a planetwide network. This unique name is called the Uniform (or
    Universal) Resource Locator, shortened to URL. Most people know this by the term
    web address, and an example is [https://www.microsoft.com](https://www.microsoft.com).
  prefs: []
  type: TYPE_NORMAL
- en: The URL contains the directions for how to find the web page, and it is the
    equivalent of a filename. Displaying the page is a complex operation, and browsers
    are very complicated software systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Processing opens and displays web pages using a function named `link()`, which
    accepts a URL as a parameter. This function passes the URL to the default browser
    on your computer, which opens and displays the page. So the following call will
    open the Microsoft page in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If the browser is already open, it may open a new tab.
  prefs: []
  type: TYPE_NORMAL
- en: Example A
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This sketch opens the Microsoft page as previously described 1. It does so when
    a mouse button is pressed while the cursor is within the display window.
  prefs: []
  type: TYPE_NORMAL
- en: Example B
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This sketch is a combination of Example A and Sketch 37\. The user types a URL,
    and the sketch builds a string from the characters being typed. When the user
    types ENTER, the sketch passes the URL to `link()`, and the browser will open
    and display the corresponding page.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user types a character, it is usually placed in the variable `key`,
    then added to the string. However, some keys do not produce characters, such as
    the arrow keys, or shift. In Processing, uppercase characters involve two key
    presses: the SHIFT key and the character. The Processing system refers to these
    as coded keys and treats them differently. If the `key` variable has the value
    `CODED`, then the key pressed was one of these special ones, and the `keyCode`
    variable indicates what key was pressed 1. The value `UP`, for example, indicates
    that the up-arrow key was pressed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this sketch, we’ll ignore all coded keys, because the shift key is needed
    to send uppercase letters and some punctuation (like the colon, “:”), but it should
    not be thought of as a key press. The `keyPressed()` function ignores coded keys
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Sketch 49: Loading Images from a Web Page'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since a web page is really just a text file, as you saw in Sketch 48, it should
    be possible to read that file and see what is inside. For example, it should be
    possible to identify any sound files (for example, MP3s) accessed by the page,
    or which images (.*jpg*, *.gif*, *.png*, and so on) will be a part of the page.
    This sketch will locate image files referenced in a web page and display them
    in the display window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is to read the page. It contains HTML, a language for
    describing the document, and reading it turns out to be easy: Processing allows
    URLs to be used just like filenames in the `loadStrings()` function. You can read
    the Mink Hollow Media web page as a text file by directly passing the URL to `loadStrings()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Or, as is done in this sketch, `loadStrings(url+"/"+file)`, where `url` is the
    web address and `file` is the name of the file that we want 1. At this point,
    the web page is available as a collection of strings in the array `webin`, one
    per line in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML uses what is called an `img` tag to display images in a page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The filename of an image follows the text `src="`, so the sketch should look
    for this sequence of characters within the strings in `webin`. If found, the following
    characters, up to the closing quote character (`"`), are the filename. We can
    locate a string within another string using the `indexOf()` function 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `indexOf()` searches the string `s` for the string `"src="`,
    starting at the character index `j`. It returns the index of the location where
    the string was found, or −1 if it was not found. If the string is found, we call
    the `getName()` function 3 to extract the filename itself from the string. The
    `getName()` function reads and saves characters until it encounters the terminal
    double quote and returns the filename as a string 4. This string is used as a
    filename for `loadImage()`, and if an image with that name can be loaded, then
    it is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many legal ways to specify a filename, and the code here also tries
    one other: it will take the URL and add a slash (`/`) and the filename 1 to see
    if that works. Some images will not be located using this method, and some files
    that are not images (like JavaScript, video, and audio) can be extracted. They
    will fail to display as images, and error messages will appear in the console.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 50: Client/Server Communication'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot of computer network communication is based on what is called a client/server
    model. It could just as easily be called a listener/speaker or receiver/sender
    model because it amounts to having one computer or process sending information
    across a network (the server) and another computer, or many other computers, receiving
    that data (the clients).
  prefs: []
  type: TYPE_NORMAL
- en: Here’s how client/server software should work. A server first announces to the
    world that it is active and sending data. It must have an address that can be
    used to identify it uniquely, and it must start sending data (bytes, for example).
    A client identifies a server that it wishes to collect data from by using the
    server’s address. If the address represents an active server, the client starts
    to read data from the server. The server must indicate when new data is available,
    and if data is requested and none has yet been sent, the client waits until data
    is present.
  prefs: []
  type: TYPE_NORMAL
- en: This example has a server sending character data and a client receiving and
    displaying the data, implemented as two different sketches. The server sends the
    message “This is a message from J Parker” repeatedly; the client reads characters
    from the server, constructs a string from them, and displays this string in the
    display window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Processing does not have a native ability to build client/server systems, but
    a library exists that enables it. Processing uses external libraries for many
    things, including video, audio, and various specific interfaces. For this example,
    we need to import the Network library at the beginning of both the client and
    server sketches 1, using this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the server code, the first step is to create a `Server` (part of the Network
    library) and assign it to the variable named `sender`, and then specify the port
    (in this case, port 5000), which is simply a number. A port is like a television
    channel, used to send or receive data, and all that matters here is that no other
    software is using this port. The server sends characters one at a time from a
    string to the outside world through the port by calling the `write` function 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`nextChar` is a character from the message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The client sketch first tries to connect to the server. The client must know
    the IP address of the server, which is its unique identifier (`***.***.***.***`
    in this case). The client connects to the server through the constructor using
    the same port 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The client reads characters, one at a time, using the `readChar()` function
    4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you have to start the server first and find out its IP address.
    You can use the `ipconfig` program on the computer where you are running the server
    sketch to find the IP address. Then you can start the client on some other computer
    on your network.
  prefs: []
  type: TYPE_NORMAL
