- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network Communications
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: 'Sketch 48: Opening a Web Page'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A web page is really just a text file containing the description of that page
    in enough detail to draw it on the screen. A program called a browser reads and
    renders that file into a viewable page. The file itself resides on a computer
    somewhere on the internet, and in order to display it, we must first upload it
    to the user’s computer. The browser arranges for this to be done, but the file
    must have a unique name that identifies it—unique in the *whole world*, because
    the internet is a planetwide network. This unique name is called the Uniform (or
    Universal) Resource Locator, shortened to URL. Most people know this by the term
    web address, and an example is [https://www.microsoft.com](https://www.microsoft.com).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The URL contains the directions for how to find the web page, and it is the
    equivalent of a filename. Displaying the page is a complex operation, and browsers
    are very complicated software systems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'Processing opens and displays web pages using a function named `link()`, which
    accepts a URL as a parameter. This function passes the URL to the default browser
    on your computer, which opens and displays the page. So the following call will
    open the Microsoft page in a browser:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If the browser is already open, it may open a new tab.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Example A
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This sketch opens the Microsoft page as previously described 1. It does so when
    a mouse button is pressed while the cursor is within the display window.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Example B
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This sketch is a combination of Example A and Sketch 37\. The user types a URL,
    and the sketch builds a string from the characters being typed. When the user
    types ENTER, the sketch passes the URL to `link()`, and the browser will open
    and display the corresponding page.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user types a character, it is usually placed in the variable `key`,
    then added to the string. However, some keys do not produce characters, such as
    the arrow keys, or shift. In Processing, uppercase characters involve two key
    presses: the SHIFT key and the character. The Processing system refers to these
    as coded keys and treats them differently. If the `key` variable has the value
    `CODED`, then the key pressed was one of these special ones, and the `keyCode`
    variable indicates what key was pressed 1. The value `UP`, for example, indicates
    that the up-arrow key was pressed.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'In this sketch, we’ll ignore all coded keys, because the shift key is needed
    to send uppercase letters and some punctuation (like the colon, “:”), but it should
    not be thought of as a key press. The `keyPressed()` function ignores coded keys
    using the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Sketch 49: Loading Images from a Web Page'
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since a web page is really just a text file, as you saw in Sketch 48, it should
    be possible to read that file and see what is inside. For example, it should be
    possible to identify any sound files (for example, MP3s) accessed by the page,
    or which images (.*jpg*, *.gif*, *.png*, and so on) will be a part of the page.
    This sketch will locate image files referenced in a web page and display them
    in the display window.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网页本质上只是一个文本文件，正如你在草图 48 中看到的，它应该是可以被读取并查看其中的内容。例如，它应该能够识别网页访问的任何声音文件（例如 MP3
    文件），或者网页中将包含哪些图片（如 *.jpg*、*.gif*、*.png* 等）。这个草图将定位网页中引用的图片文件，并将它们显示在显示窗口中。
- en: 'The first thing to do is to read the page. It contains HTML, a language for
    describing the document, and reading it turns out to be easy: Processing allows
    URLs to be used just like filenames in the `loadStrings()` function. You can read
    the Mink Hollow Media web page as a text file by directly passing the URL to `loadStrings()`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是读取网页。它包含 HTML，这是一种描述文档的语言，读取它其实很简单：Processing 允许像使用文件名一样在 `loadStrings()`
    函数中使用 URL。你可以通过直接将 URL 传递给 `loadStrings()` 来将 Mink Hollow Media 网页作为文本文件读取：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Or, as is done in this sketch, `loadStrings(url+"/"+file)`, where `url` is the
    web address and `file` is the name of the file that we want 1. At this point,
    the web page is available as a collection of strings in the array `webin`, one
    per line in the file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，正如在这个草图中所做的那样，使用 `loadStrings(url+"/"+file)`，其中 `url` 是网页地址，`file` 是我们想要的文件名
    1。此时，网页作为一组字符串存储在数组 `webin` 中，每行对应文件中的一行。
- en: 'HTML uses what is called an `img` tag to display images in a page:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 使用一种叫做 `img` 标签来在页面中显示图片：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The filename of an image follows the text `src="`, so the sketch should look
    for this sequence of characters within the strings in `webin`. If found, the following
    characters, up to the closing quote character (`"`), are the filename. We can
    locate a string within another string using the `indexOf()` function 2:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图片的文件名位于文本 `src="` 后面，因此草图应该在 `webin` 中的字符串内查找这一字符序列。如果找到，接下来的字符直到结束的双引号 (`"`)
    为止即为文件名。我们可以使用 `indexOf()` 函数 2 在一个字符串中查找另一个字符串：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, `indexOf()` searches the string `s` for the string `"src="`,
    starting at the character index `j`. It returns the index of the location where
    the string was found, or −1 if it was not found. If the string is found, we call
    the `getName()` function 3 to extract the filename itself from the string. The
    `getName()` function reads and saves characters until it encounters the terminal
    double quote and returns the filename as a string 4. This string is used as a
    filename for `loadImage()`, and if an image with that name can be loaded, then
    it is displayed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`indexOf()` 在字符串 `s` 中查找字符串 `"src="`，从字符索引 `j` 开始。它返回找到该字符串位置的索引，如果未找到则返回
    -1。如果找到该字符串，我们会调用 `getName()` 函数 3 来提取字符串中的文件名。`getName()` 函数读取并保存字符，直到遇到终止的双引号，并将文件名作为字符串
    4 返回。这个字符串会作为文件名传递给 `loadImage()`，如果能够加载到该文件名的图片，则会显示出来。
- en: 'There are many legal ways to specify a filename, and the code here also tries
    one other: it will take the URL and add a slash (`/`) and the filename 1 to see
    if that works. Some images will not be located using this method, and some files
    that are not images (like JavaScript, video, and audio) can be extracted. They
    will fail to display as images, and error messages will appear in the console.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多合法的方式可以指定文件名，这段代码也尝试了另一种方法：它会获取 URL，并加上斜杠 (`/`) 和文件名 1 来查看是否有效。某些图片通过这种方法可能无法定位，而一些非图片文件（如
    JavaScript、视频和音频文件）则可以提取出来。它们无法作为图片显示，控制台会出现错误信息。
- en: 'Sketch 50: Client/Server Communication'
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '草图 50: 客户端/服务器通信'
- en: A lot of computer network communication is based on what is called a client/server
    model. It could just as easily be called a listener/speaker or receiver/sender
    model because it amounts to having one computer or process sending information
    across a network (the server) and another computer, or many other computers, receiving
    that data (the clients).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 很多计算机网络通信都是基于所谓的客户端/服务器模型。它也可以叫做监听者/发言者模型或接收者/发送者模型，因为它实际上就是有一个计算机或进程通过网络发送信息（服务器），而另一个计算机或多个计算机接收这些数据（客户端）。
- en: Here’s how client/server software should work. A server first announces to the
    world that it is active and sending data. It must have an address that can be
    used to identify it uniquely, and it must start sending data (bytes, for example).
    A client identifies a server that it wishes to collect data from by using the
    server’s address. If the address represents an active server, the client starts
    to read data from the server. The server must indicate when new data is available,
    and if data is requested and none has yet been sent, the client waits until data
    is present.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: This example has a server sending character data and a client receiving and
    displaying the data, implemented as two different sketches. The server sends the
    message “This is a message from J Parker” repeatedly; the client reads characters
    from the server, constructs a string from them, and displays this string in the
    display window.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Processing does not have a native ability to build client/server systems, but
    a library exists that enables it. Processing uses external libraries for many
    things, including video, audio, and various specific interfaces. For this example,
    we need to import the Network library at the beginning of both the client and
    server sketches 1, using this line:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the server code, the first step is to create a `Server` (part of the Network
    library) and assign it to the variable named `sender`, and then specify the port
    (in this case, port 5000), which is simply a number. A port is like a television
    channel, used to send or receive data, and all that matters here is that no other
    software is using this port. The server sends characters one at a time from a
    string to the outside world through the port by calling the `write` function 2:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`nextChar` is a character from the message.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'The client sketch first tries to connect to the server. The client must know
    the IP address of the server, which is its unique identifier (`***.***.***.***`
    in this case). The client connects to the server through the constructor using
    the same port 3:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The client reads characters, one at a time, using the `readChar()` function
    4:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, you have to start the server first and find out its IP address.
    You can use the `ipconfig` program on the computer where you are running the server
    sketch to find the IP address. Then you can start the client on some other computer
    on your network.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
