- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 9 FILES AND DIRECTORIES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Many applications require you to read or write data to and from files. In this
    chapter, we’ll explore how to interact with files via PHP scripts. We’ll focus
    primarily on simple *.txt* files, though we’ll also touch on how PHP handles other
    common text file formats.
  prefs: []
  type: TYPE_NORMAL
- en: PHP provides many built-in functions for working with files. Some read or write
    files all in one go, while other, lower-level functions provide more granular
    control, allowing you to open and close files and selectively read or write at
    specific locations. Not all web applications will require you to work with external
    files, but knowing your way around these functions is still useful, in case the
    need arises. Outside of web applications, for example, you may find yourself needing
    to reformat the data inside files or to move and rename files and directories.
    With the functions we’ll discuss here, you can write a PHP script to automate
    that process.
  prefs: []
  type: TYPE_NORMAL
- en: '### Reading a File into a String'
  prefs: []
  type: TYPE_NORMAL
- en: If you know a file exists and you want to read all its contents into your script
    as a single string, you can do so in a single statement, simply by calling the
    built-in file_get_contents() function. To illustrate, let’s first create a file
    to be read in. [Listing 9-1](#lis9-1) shows a file containing a programming haiku
    by Jorge Suarez (found at *[http://selavo.lv/wiki/index.php/Programming_haiku](http://selavo.lv/wiki/index.php/Programming_haiku)*).
    Create a new file named *data.txt* containing these lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-1: The text file data.txt containing a programming poem'
  prefs: []
  type: TYPE_NORMAL
- en: This file contains three lines of text. The line breaks are a sign that the
    first two lines end with an invisible newline character.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a file to work with, we can write a script to read and print
    its contents. Create a *main.php* file in the same directory as *data.txt* and
    enter the code in [Listing 9-2](#lis9-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-2: A main.php script to read and print the contents of a file'
  prefs: []
  type: TYPE_NORMAL
- en: First, we declare a $file variable containing the path and filename for our
    text file. Since the text file and main script are in the same directory, we create
    this file location string by concatenating the __DIR__ magic constant (the path
    to the location of the main script) with a forward slash and the *data.txt* filename.
    We then use file_get_contents() to read the contents of the file into the $text
    variable. Finally, we print out the string containing the file contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the main script at the terminal and you should see the haiku printed across
    three lines, just as it appears in [Listing 9-1](#lis9-1). This is because the
    invisible newline characters in the file made it into the $text string, just like
    the visible characters. We can prove these invisible characters exist in a couple
    of ways: by checking the size of the text file or by replacing the newlines with
    visible characters in the string read from the file. To make it really easy to
    see how newline characters are part of a text file, let’s replace the contents
    of *data.txt* with that of [Listing 9-3](#lis9-3).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-3: A simplified data.txt file'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the file consists of just two characters, each on a separate line,
    we can more easily examine the contents of the file. Update *main.php* to match
    [Listing 9-4](#lis9-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-4: An updated main.php script to prove the existence of newline characters'
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, we first read the contents of the file into the $text variable.
    Then we read the size of the file with the built-in filesize() function, which
    returns the file’s number of bytes. In a text file with basic ASCII characters,
    each character (including invisible characters) takes up 1 byte, so we should
    expect the result to be 3. Next, we generate another string that replaces each
    newline character ("\n") in $text with a capital letter N, storing the result
    in the $newLinesChanged variable. Finally, we print the file size and the updated
    string. Here’s the output of running this script at the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line confirms that the file contains just three characters (bytes)
    of data: the letter a, a newline character, and the letter b. The second line
    is the string representing the contents of the file with the newlines made visible:
    aNb again confirms that the file contains just three characters, with a newline
    character between the two letters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Confirming that the newlines exist isn’t a trivial exercise: later in the chapter,
    we’ll explore functions that work with a file’s contents line by line. These functions
    rely on invisible newlines to know where one line ends and the next begins.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The* file_get_contents() *function can also read files from the web rather
    than from your local machine if you pass it a full URL to the file’s location.
    For example, try storing the URL* [https://filesamples.com/samples/document/txt/sample1.txt](https://filesamples.com/samples/document/txt/sample1.txt)
    *in the* $file *variable and then calling* file_get_contents($file) *as in [Listing
    9-2](#lis9-2). You should get back a string of nonsensical Latin text.*'
  prefs: []
  type: TYPE_NORMAL
- en: Confirming That a File Exists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The previous examples assume that a file named *data.txt* exists. In practice,
    however, it’s a good idea to test that a file exists before attempting to read
    its contents. Otherwise, if you attempt to open or read a file that can’t be found,
    you’ll get a runtime warning such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Execution will continue after the warning, which can lead to further warnings
    and errors if the script attempts to manipulate the contents of the nonexistent
    file. To make your code more robust and able to cope with a missing file, you
    can use the built-in file_exists() function. It returns a Boolean value confirming
    whether the provided file exists. Let’s try it out by updating *main.php* with
    the contents of [Listing 9-5](#lis9-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-5: An updated main.php script to confirm the existence of a file
    before reading it'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we add $file2, a second variable holding a path to a nonexistent file,
    *data2.txt*. Before attempting to read anything, we assign a default file not
    found message to the $text and $text2 variables. This way, these variables will
    still hold something, even if we fail to read the contents of a file. We next
    use the file_exists() function in two successive if statements to ensure that
    we attempt to read the contents of *data.txt* and *data2.txt* only if those files
    can be found. Then we print the contents of $text and $text2, each followed by
    a newline character. Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Since *data.txt* can be found, its contents have been read into $text (replacing
    the default file not found message) and printed out. Meanwhile, since *data2.txt*
    doesn’t exist, printing $text2 ends up displaying a message indicating that the
    file can’t be found.  #### “Touching” a File'
  prefs: []
  type: TYPE_NORMAL
- en: Linux and macOS have a touch file terminal command that either updates the last
    accessed or modified timestamp of the specified file to the current datetime or
    creates an empty file if that file doesn’t already exist. PHP offers the almost
    identical touch() function, which provides another way to ensure that a file exists
    before trying to access it. If you don’t mind a file’s contents being empty, you
    can replace the default file not found messages and if statements from [Listing
    9-5](#lis9-5) with simple touch() statements, as shown in [Listing 9-6](#lis9-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-6: An updated main.php script to “touch” files before reading them'
  prefs: []
  type: TYPE_NORMAL
- en: We now pass each filename to touch() before using file_read_contents() to read
    the files. This lets us safely read the files without if statements and file_exists(),
    since we know touch() will create the files (albeit empty ones) if they don’t
    already exist.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring That a Directory Exists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ve so far been working with files in the same directory as the executing
    script, but a file could also be in a different directory. In that case, it’s
    important to confirm that the directory exists (and perhaps create it if it doesn’t),
    since just like a missing file, a nonexistent directory will trigger a runtime
    warning. PHP has two built-in functions for this: is_dir() returns a Boolean value
    confirming whether a specified directory path can be found, and mkdir() attempts
    to create a directory at the specified path.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The* mkdir() *function will throw a runtime warning if the directory it’s
    trying to create already exists or if it can’t be created based on the current
    permissions settings. For more on permissions, see “Directory and File Permissions”
    on [page 163](#pg_163).*'
  prefs: []
  type: TYPE_NORMAL
- en: To try these functions, update the contents of *main.php* as shown in [Listing
    9-7](#lis9-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-7: An updated main.php script to create a directory if it doesn’t
    exist'
  prefs: []
  type: TYPE_NORMAL
- en: 'We break the desired path and filename into two variables: $dir holds the path
    to the directory where the file is to be read from, and $file holds the path plus
    the filename. We set $dir to the */var* subdirectory within the directory where
    our script is executing (__DIR__); this subdirectory doesn’t exist. The if (!is_dir($dir))
    statement checks whether $dir is *not* a valid directory path and calls mkdir()
    to create the directory if it isn’t. We’re then safe to call touch() on the file,
    since we now know the directory exists, and then to read the file, since touch()
    creates the file if it, too, doesn’t exist.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default option for mkdir() is that the function isn’t recursive: it will
    fail to create a directory if the parent of that directory doesn’t exist. However,
    the function has an optional recursive parameter; if it’s set to true, the function
    will create any missing parent directories as well. [Listing 9-8](#lis9-8) shows
    an example.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-8: An updated main.php script to recursively create directories if
    they’re missing'
  prefs: []
  type: TYPE_NORMAL
- en: The directory path now includes a */subsub* directory inside a */sub* directory
    inside the current directory of the executing script. Inside the if statement,
    we call mkdir() with the recursive argument set to true. This ensures that the
    function won’t create just the */subsub* directory but also its parent */sub*
    directory if necessary. We have to set recursive as a named argument, since mkdir()
    takes another optional argument to set the new directory’s permissions, and this
    argument comes before recursive in the function signature.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a String to a Text File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as you can use file_get_contents() to read the contents of a file into
    a string, you can write the contents of a string to a text file by using the reciprocal
    file_put_contents() function. This function automatically creates the file being
    written to if it doesn’t exist, so you don’t need to worry about testing the filename
    first. The updated *main.php* script in [Listing 9-9](#lis9-9) shows how it works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-9: A main.php script writing data from a string to a file'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we declare a three-line heredoc string, $content, using CONTENT as the
    delimiter. Then we set the $file variable to the current directory path plus the
    filename *newfile.txt*. Next, we call the file_put_contents() function, passing
    it the destination file and the text to write to that file. This should create
    a file *newfile.txt* containing the text from the $content heredoc. To confirm
    that the file has been created with the text content, we use file_get_contents()
    to read the text back out of the file and into the $text variable, which we then
    print. Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The output matches the original heredoc string, indicating we successfully wrote
    the string to *newfile.txt* and read it back out again.
  prefs: []
  type: TYPE_NORMAL
- en: If the file you’re trying to write to already exists, the default behavior of
    file_put_contents() is to completely replace (overwrite) the contents of that
    file. To avoid this, call the function with the FILE_APPEND option. This adds
    the new text to the end of the file after its existing content. [Listing 9-10](#lis9-10)
    shows an example, updated from [Listing 9-9](#lis9-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-10: A main.php script appending text to the end of a file'
  prefs: []
  type: TYPE_NORMAL
- en: 'This time we create a different heredoc string and add it to *newfile.txt*
    by calling file_put_contents() with FILE_APPEND as a third argument. This should
    append the string after the current contents of the file, as the output confirms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Try running the code in [Listing 9-10](#lis9-10) again without the FILE_APPEND
    option. You’ll find that only the text from $newContent appears in the output,
    since the existing text in the file is overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Files and Directories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Beyond reading from and writing to files, PHP offers functions to help manage
    existing files and directories. For example, you can delete a file with the unlink()
    function or delete a whole directory with rmdir(). Both functions return true
    if successful or false otherwise. As with reading files, it’s important to test
    for the existence of a file or directory before attempting to delete it. Otherwise,
    if you call unlink() or rmdir() on a file or directory that doesn’t exist, you’ll
    get a warning (but execution will continue). [Listing 9-11](#lis9-11) shows these
    functions in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-11: A main.php script to create and then delete a directory and a
    file'
  prefs: []
  type: TYPE_NORMAL
- en: As in some earlier examples, we declare the target directory and filename in
    two variables, $dir and $file. We then create the directory if it doesn’t already
    exist and touch() the file. At this point, we should be confident that a *data.txt*
    file exists in a */var* directory; we confirm this by var_dumping the results
    of calling is_dir() and file_exists(). Next, we use unlink($file) and rmdir($dir)
    to delete the file and its directory. Finally, we make the same var_dump() calls
    again to make sure that neither the directory nor the file exists when the script
    finishes execution. If you run this script, you should see true, true, false,
    false displayed, confirming that the directory and file existed and then were
    successfully deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful file-management function is rename(), which changes the name
    of a file or directory. For example, you could rename *oldfile.txt* to *newfile.txt*
    with this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You need to be careful with this function, testing that the old file or directory
    exists first. It’s also important to be mindful about the new file or directory.
    If you’re renaming a file and another file already exists with that name, it will
    be overwritten with no error or warning, which could be problematic if you need
    the contents of that overwritten file. If you’re renaming a directory and the
    new directory already exists, a warning will be generated, which is also not ideal,
    since it’s best to avoid warnings. If you’re renaming a file into a different
    directory, you also should ensure that the new directory exists and, if appropriate,
    is writable (which is required by Windows). See *[https://www.php.net/manual/en/function.rename.php](https://www.php.net/manual/en/function.rename.php)*
    for more about this function.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a File into an Array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PHP’s built-in file() function reads the contents of a file into an array rather
    than a single string, with one array element for each line in the file. This is
    useful when you want to perform an action for each line (such as displaying the
    line’s contents alongside its line number, as in the following example), or when
    each line represents one item in a set of data to be processed, such as the data
    in a comma-separated values (CSV) file. [Listing 9-12](#lis9-12) shows a main
    script demonstrating the file() function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-12: A main.php script to loop through and print each line of a text
    file'
  prefs: []
  type: TYPE_NORMAL
- en: 'We pass the file information (in the $file variable) to the file() function,
    which reads the contents of *data.txt* line by line into an array called $lines.
    Then we use a foreach loop to print each element of the array (a line from the
    file) individually, along with its numeric key. If *data.txt* contains the three-line
    haiku from [Listing 9-1](#lis9-1), the output should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can pass optional flags as a second argument to the file() function to,
    for example, exclude the newline character at the end of each line (FILE_IGNORE_NEW_LINES)
    or completely ignore empty lines in the file (FILE_SKIP_EMPTY_LINES).
  prefs: []
  type: TYPE_NORMAL
- en: Using Lower-Level File Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The file_get_contents() and file_put_contents() functions take care of all the
    steps of working with a file for you, such as opening the file, accessing its
    contents, and closing the file again. In most situations, those functions are
    all you need. Sometimes, however, you may need to work with files at a lower level,
    perhaps processing them one line, or even one character, at a time. In those cases,
    you might need to explicitly manage the various file-access steps in your code
    through a series of separate, lower-level function calls.
  prefs: []
  type: TYPE_NORMAL
- en: PHP’s lower-level file functions require you to work with a *filesystem pointer*
    (or just *file pointer*), a reference to a location in the file’s data. Internally,
    PHP treats a file as a *bytestream* (a resource object that can be read from and
    written to in a linear fashion), and the file pointer provides access to that
    stream. You obtain a file pointer by calling fopen() with a path to the file you
    want to access. You also have to pass in a string specifying *how* you want to
    interact with the file; for example, files can be opened only for reading, only
    for writing, for both reading and writing, and so on. [Table 9-1](#tab9-1) shows
    the strings for specifying some common fopen() modes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 9-1: Common fopen() Modes'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mode string | Description | Position of file pointer | Outcome if file doesn’t
    exist |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ''r'' | Read only | Beginning of file | Warning |'
  prefs: []
  type: TYPE_TB
- en: '| ''r+'' | Read and write (overwrite) | Beginning of file | Warning |'
  prefs: []
  type: TYPE_TB
- en: '| ''w'' | Write only (overwrite) | Beginning of file (and truncate the file
    by removing any existing content) | Attempt to create a file |'
  prefs: []
  type: TYPE_TB
- en: '| ''a'' | Write only (append) | End of file | Attempt to create a file |'
  prefs: []
  type: TYPE_TB
- en: 'The typical sequence of actions when working with a file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.   Open a file in the appropriate mode and get a file pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Change the location of the file pointer in the file if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Read or write at the location of the file pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Repeat steps 2 and 3 as required.
  prefs: []
  type: TYPE_NORMAL
- en: 5.   Close the file pointer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-13](#lis9-13) demonstrates this process. This script achieves the
    same results as [Listing 9-2](#lis9-2) (reading the contents of a file to a string)
    by using the lower-level fopen(), fread(), and fclose() functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-13: Using lower-level functions to read a file'
  prefs: []
  type: TYPE_NORMAL
- en: First, we use fopen() to open *data.txt*, using the string 'r' to specify read-only
    mode. The function returns a file pointer located at the beginning of the file,
    which we store in the $fileHandle variable. Next, we call filesize() to look up
    the size of the file (in bytes). We then call the fread() function, passing it
    the file pointer and the size of the file ($filesizeBytes) to read the entire
    contents of the file into the $text variable. If we wanted to read only part of
    the file, we could specify a different number of bytes as the second argument
    to the fread() function. (We’d also want to specify a different number of bytes
    if the file pointer were located somewhere other than the beginning of the file.)
    To finish up, we close the file by passing the file pointer to the fclose() function.
    Closing the file enables it to be used by other system processes and protects
    it from being corrupted if any errors occur in the script currently being executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example illustrates some of the most common low-level file functions,
    but PHP has many others. For example, fgets() reads one line of a file (up to
    the next newline) from the current file-pointer location, and fgetc() reads just
    one character from the current file-pointer location. The feof() function takes
    in a file pointer and returns true or false based on whether the pointer is at
    the end of the file. This is useful for loops such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here we use the NOT operator (!) to negate the result of feof(), so the loop
    will keep repeating until the pointer gets to the end of the file. Inside this
    kind of loop, we might read a line from the file with fgets(), read the next character
    with fgetc(), or read a fixed number of bytes with fread(). Logic in the loop
    would then process the data (if successfully read), and if we reach the end of
    the file while reading, the loop would terminate.
  prefs: []
  type: TYPE_NORMAL
- en: Some functions are just for working with and changing the file pointer. For
    example, rewind() moves the file pointer back to the beginning of the file, and
    ftell() returns the current location of the pointer, specified as the number of
    bytes from the start of the file. The fseek() function moves the file pointer
    to a given position in the file specified relative to its current position, the
    beginning or the end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Processing Multiple Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s combine a lot of what we’ve discussed so far in this chapter in a more
    sophisticated example that programmatically extracts data from multiple files
    and collects it all in a new summary file. We’ll attempt to gather the names and
    game scores of three players, each in a separate file (*joe.txt*, *matt.txt*,
    and *sinead.txt*), reformat the data, and write it to a single output file called
    *total.txt*. [Listings 9-14](#lis9-14) through [9-16](#lis9-16) show the three
    raw data files we want to process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-14: joe.txt'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-15: matt.txt'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-16: sinead.txt'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the content in each data file is a little messy, with randomly
    located blank lines: [Listing 9-15](#lis9-15) ends with a blank line, and [Listing
    9-16](#lis9-16) starts and ends with two blank lines. That said, each data file
    has the same sequence of content: a line containing the player’s first name, a
    line with their last name, and a line with their integer score.'
  prefs: []
  type: TYPE_NORMAL
- en: In the output file, we want to consolidate all the data about each player onto
    a single line, as well as display the total of all three players’ scores. [Listing
    9-17](#lis9-17) shows how the resulting *total.txt* file should appear.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-17: The consolidated total.txt file we want to create'
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this final result, we’ll need to handle each part of the data files
    differently, so we can’t simply load a whole file into a string with file_get_contents().
    It will be better to use file() to read in each file as an array of individual
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with multiple files, PHP’s oddly named glob() function is a powerful
    tool. It returns an array of file and directory paths that match a given pattern.
    This is particularly helpful for identifying and then looping through all the
    data files in a given location. For example, the following statement provides
    an array of paths to all *.txt* files in the */data* subfolder relative to the
    location of the executing script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The * is a wildcard representing any number of characters, so '/data/*.txt'
    will match any filename with a *.txt* extension in the given folder. That’s exactly
    what we’ll need to gather the player data files in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project and create a */data* subfolder containing the text files
    *joe.txt*, *matt.txt*, and *sinead.txt* shown previously in [Listings 9-14](#lis9-14)
    through [9-16](#lis9-16). Then, in the main project folder, create a *main.php*
    script with the contents of [Listing 9-18](#lis9-18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-18: A script processing multiple files'
  prefs: []
  type: TYPE_NORMAL
- en: We first assign the path to the */data* subfolder from the location of the executing
    script to the $dir variable, and the filename pattern string '*.txt' to $fileNamePattern,
    using the * wildcard to represent any *.txt* file. We then call glob() to get
    an array of all the files in $dir matching the pattern in $fileNamePattern, storing
    the result in the $files variable ❶. Thanks to glob(), we know that all the files
    in the $files array exist, so we can avoid the ordeal of checking whether they
    exist before trying to read them.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we assign a path to *total.txt* to the $outputFile variable. This file
    may or may not exist already, but we want a fresh output file each time we run
    the script. We therefore touch() the file, which creates it if it doesn’t exist
    already, and then use unlink() to delete the file. Now we can be sure that we’re
    writing to an empty file when it comes time to gather the data into *total.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: 'After initializing the $total variable to 0, we use a foreach loop ❷ to iterate
    over the filepaths in the $files array, storing each path in a temporary $file
    variable. For each file, we use file() to read the contents into an array called
    $lines. Calling the function with the FILE_IGNORE_NEW_LINES and FILE_SKIP_EMPTY_LINES
    flags ensures that end-of-line characters will be ignored and that empty lines
    will be excluded from the resulting array. Knowing what we know about each data
    file, this means that $lines should be a three-element array: the first element
    is the player’s first name, the second element is their last name, and the third
    element is their score (represented as a string). We read these values from the
    array into separate $firstName, $lastName, and $scoreString variables and use
    the built-in intval() function to convert the score from a string to an integer.'
  prefs: []
  type: TYPE_NORMAL
- en: Still within the foreach loop, we call fopen() to get a file pointer to the
    output file (*total.txt*) in write-append mode (specified with the 'a' mode string),
    meaning the pointer will be located at the end of the file. The first time through
    the loop, *total.txt* won’t exist, so fopen() will create the file. We then use
    fwrite() to append a string to the output file, summarizing the player’s name
    and score and ending with a newline character (\n) ❸. We close the output file
    with fclose() and add the current player’s score to the $total variable.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the foreach loop has completed, we once again access the output
    file in write-append mode and append a final string including the value of $total.
    Then, to make sure this has all worked, we call file_get _contents() to read the
    output file into a string and print the result ❹. Notice that we call the function
    directly from the print statement, instead of storing the string in a variable
    first.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the *main.php* script, you should get the *total.txt* file shown
    previously in [Listing 9-17](#lis9-17). In fact, you can run this script as many
    times as you want and the result will always be the same, since any existing *total.txt*
    file is deleted with the combination of the touch() and unlink() functions.
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, our *main.php* script isn’t the most efficient way to code
    the desired logic. We don’t need to open and close the output file each time during
    the foreach loop; we could open it just once before the loop and then close it
    once after appending the total score. However, opening it each time through the
    loop illustrates the value of write-append mode, which places the file pointer
    at the end of the file. This way, any new content written to the file is added
    after any existing content.
  prefs: []
  type: TYPE_NORMAL
- en: JSON and Other File Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PHP can work with more than *.txt* files. For example, it can also work with
    JavaScript Object Notation (JSON) and other text-based data formats. For JSON
    data, the built-in json_encode() function can turn a PHP array into a JSON string,
    and the json_decode() function does the opposite. This type of conversion is particularly
    smooth since JSON data, like PHP arrays, revolves around key/value pairs. [Listing
    9-19](#lis9-19) shows these functions in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-19: A script to convert an array to JSON, and vice versa'
  prefs: []
  type: TYPE_NORMAL
- en: We store a path to *data.json* in the $filePath variable. Then we declare a
    $data array that maps the values 'matt', 'E-042', and '086-111-2323' to the keys
    'name', 'office', and 'phone', respectively. Next, we use the json_encode() function
    to convert the array to a JSON-formatted string, storing the result in the $jsonString
    variable. We then use file_put_contents() to write the JSON string to the *data.json*
    file, just as we would use it to write to a *.txt* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the script goes through the same process in reverse. We use file_get_contents()
    to read the JSON data from the file into the $jsonStringFromFile variable, which
    we print out. The variable contains a JSON string, but we use json_decode() to
    convert the string into a PHP array, which we display using var_dump(). We need
    to provide true as a second argument to the json_decode() function, or the result
    will be a type of object rather than an array. Here’s the output of running this
    script at the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The first line shows the JSON string that we wrote into and read back out of
    the *data.json* file. The string consists of a JSON object, delimited by curly
    brackets, containing three key/value pairs separated by commas. The keys are set
    off from their corresponding values by colons. The rest of the output shows the
    contents of $jsonArrayFromFile, the array created by decoding the JSON data. Notice
    the direct correlation between the key/value pairs in the JSON object and the
    key/value pairs in the PHP array.
  prefs: []
  type: TYPE_NORMAL
- en: 'For YAML Ain’t Markup Language (YAML) text data files, PHP provides several
    functions. For example, yaml_parse() and yaml_emit() are similar to json_decode()
    and json_encode() but for converting between YAML strings and PHP arrays. PHP
    also has direct file-to-string and string-to-file YAML functions: yaml_parse_file()
    and yaml_emit_file().'
  prefs: []
  type: TYPE_NORMAL
- en: For CSV files, PHP has the direct file-to-string and string-to-file functions
    fgetcsv() and fputcsv(). The str_getcsv() function takes a string in CSV format
    and converts it to an array. However, the function has some flaws. It doesn’t
    escape newline characters, for example, so it can’t cope with typical CSV files
    from spreadsheets like Google Sheets or Microsoft Excel. Perhaps because of this
    nonstandard treatment of CSV data, PHP doesn’t have a reciprocal function to create
    a CSV-encoded string from an array.
  prefs: []
  type: TYPE_NORMAL
- en: Working with eXtensible Markup Language (XML) is a little more complex. PHP
    represents XML data with objects, so you need to be confident with the basics
    of object-oriented programming to use functions such as simplexml_load_file()
    and classes such as SimpleXMLElement. However, PHP provides several powerful ways
    to traverse and manipulate XML data once you know how to use these features of
    the language. We’ll discuss object-oriented PHP in [Part V](part5.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we worked with basic PHP functions like file_get_contents()
    and file_put_contents() for reading and writing data to and from external files.
    We also discussed the file() function, which reads the lines of a file into separate
    array elements, and low-level functions like fread() and fwrite() that let you
    traverse a file by using a pointer. We explored how to ensure that a file or directory
    exists (or doesn’t exist) before interacting with it, and how to use glob() to
    get a reference to all the files that match a certain criterion. Although we mostly
    worked with *.txt* files, we also touched on some PHP functions for interacting
    with JSON, YAML, CSV, and XML data formats.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Find a limerick online or write your own. Here’s one I found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Write a script that declares an array; each element of the array is a line from
    the limerick. Then write those lines to a text file named *limerick.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Find a sample JSON file online that’s accessible through a URL (for example,
    at *[https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com)*).
    Write a script that reads the JSON string from the URL, converts it to an array,
    and then uses var_dump() to display the array.
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Add a new data file for a game player and their high score in the *data*
    folder to be processed by the script in [Listing 9-18](#lis9-18). Run the main
    script, and you should see another line added to the output file and the new score
    added to the total.
  prefs: []
  type: TYPE_NORMAL
