<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch5">&#13;
<header>&#13;
<h1 class="CHAPTER" id="ch5">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_79" aria-label=" Page 79. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">IMAGE-LOAD AND REGISTRY NOTIFICATIONS</samp></span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.png" alt=""/>&#13;
</figure>&#13;
<p class="CO">The last two kinds of notification callback routines we’ll cover in this book are image-load notifications and registry notifications. An <i>image-load notification</i> occurs whenever an executable, DLL, or driver is loaded into memory on the system. A <i>registry notification</i> is triggered when specific operations in the registry occur, such as key creation or deletion.</p>&#13;
<p class="TX">In addition to these notification types, in this chapter we’ll also cover how EDRs commonly rely on image-load notifications for a technique called <i>KAPC injection</i>, which is used to inject their function-hooking DLLs. Lastly, we’ll discuss an evasion method that targets an EDR’s driver directly, potentially bypassing all the notification types we’ve discussed.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h-54"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_80" aria-label=" Page 80. "/><samp class="SANS_Futura_Std_Bold_B_11">How Image-Load Notifications Work</samp></h2>&#13;
<p class="TNI">By collecting image-load telemetry, we can gain extremely valuable information about a process’s dependencies. For example, offensive tools that use in-memory .NET assemblies, such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">execute-assembly</samp> command in Cobalt Strike’s Beacon, routinely load the common language runtime <i>clr.dll</i> into their processes. By correlating an image load of <i>clr.dll</i> with certain attributes in the process’s PE header, we can identify non-.NET processes that load <i>clr.dll</i>, potentially indicating malicious behavior.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H2" id="sec2"><span id="h-55"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Registering a Callback Routine</samp></h3>&#13;
<p class="TNI">The kernel facilitates these image-load notifications through the <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsSetLoadImageNotifyRoutine()</samp> API. If a driver wants to receive these events, the developers simply pass in their callback function as the only parameter to that API, as shown in <a href="#list5-1">Listing 5-1</a>.</p>&#13;
<pre id="list5-1"><code>NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObj, PUNICODE_STRING pRegPath)&#13;
{&#13;
    NTSTATUS status = STATUS_SUCCESS;&#13;
    <var>--snip--</var>&#13;
&#13;
    status = PsSetLoadImageNotifyRoutine(ImageLoadNotificationCallback);&#13;
&#13;
    <var>--snip--</var>&#13;
}&#13;
&#13;
void ImageLoadNotificationCallback(&#13;
    PUNICODE_STRING FullImageName,&#13;
    HANDLE ProcessId,&#13;
    PIMAGE_INFO ImageInfo)&#13;
{&#13;
    <var>--snip--</var>&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 5-1: Registering an image-load callback routine</span></p>&#13;
<p class="TX">Now the system will invoke the internal callback function <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageLoadNotificationCallback()</samp> each time a new image is loaded into a process.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H2" id="sec3"><span id="h-56"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Viewing the Callback Routines Registered on a System</samp></h3>&#13;
<p class="TNI">The system also adds a pointer to the function to an array, <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PspLoadImageNotifyRoutine()</samp>. We can traverse this array in the same way as the array used for process-notification callbacks discussed in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>. In <a href="#list5-2">Listing 5-2</a>, we do this to list the image-load callbacks registered on the system.</p>&#13;
<pre id="list5-2"><code>1: kd&gt; <b>dx ((void**[0x40])&amp;nt!PspLoadImageNotifyRoutine)</b>&#13;
<b>.Where(a =&gt; a != 0)</b>&#13;
<b>.Select(a =&gt; @$getsym(@$getCallbackRoutine(a).Function))</b><span role="doc-pagebreak" epub:type="pagebreak" id="pg_81" aria-label=" Page 81. "/>&#13;
    [0]        : WdFilter+0x467b0 (fffff803`4ade67b0)&#13;
    [1]        : ahcache!CitmpLoadImageCallback (fffff803`4c95eb20)</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 5-2: Enumerating image-load callbacks</span></p>&#13;
<p class="TX">There are notably fewer callbacks registered here than there were for process-creation notifications. Process notifications have more non-security uses than image loads, so developers are more interested in implementing them. Conversely, image loads are a critical datapoint for EDRs, so we can expect to see any EDRs loaded on the system here alongside Defender <samp class="SANS_TheSansMonoCd_W5Regular_11">[0]</samp> and the Customer Interaction Tracker <samp class="SANS_TheSansMonoCd_W5Regular_11">[1]</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H2" id="sec4"><span id="h-57"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Collecting Information from Image Loads</samp></h3>&#13;
<p class="TNI">When an image is loaded, the callback routine receives a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">IMAGE_INFO</samp> structure, defined in <a href="#list5-3">Listing 5-3</a>. The EDR can collect telemetry from it.</p>&#13;
<pre id="list5-3"><code>typedef struct _IMAGE_INFO {&#13;
  union {&#13;
    ULONG Properties;&#13;
    struct {&#13;
      ULONG ImageAddressingMode : 8;&#13;
      ULONG SystemModeImage : 1;&#13;
      ULONG ImageMappedToAllPids : 1;&#13;
      ULONG ExtendedInfoPresent : 1;&#13;
      ULONG MachineTypeMismatch : 1;&#13;
      ULONG ImageSignatureLevel : 4;&#13;
      ULONG ImageSignatureType : 3;&#13;
      ULONG ImagePartialMap : 1;&#13;
      ULONG Reserved : 12;&#13;
    };&#13;
  };&#13;
  PVOID ImageBase;&#13;
  ULONG ImageSelector;&#13;
  SIZE_T ImageSize;&#13;
  ULONG ImageSectionNumber;&#13;
} IMAGE_INFO, *PIMAGE_INFO;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 5-3: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">IMAGE_INFO</samp> structure definition</span></p>&#13;
<p class="TX">This structure has a few particularly interesting fields. First, <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemModeImage</samp> is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> if the image is mapped to user address space, such as in DLLs and EXEs. If this field is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, the image is a driver being loaded into kernel address space. This is useful to an EDR because malicious code that loads into kernel mode is generally more dangerous than code that loads into user mode.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageSignatureLevel</samp> field represents the signature level assigned to the image by Code Integrity, a Windows feature that validates digital signatures, among other things. This information is useful for systems that implement some type of software restriction policy. For example, an organization might require that certain systems in the enterprise run signed code <span role="doc-pagebreak" epub:type="pagebreak" id="pg_82" aria-label=" Page 82. "/>only. These signature levels are constants defined in the <i>ntddk.h</i> header and shown in <a href="#list5-4">Listing 5-4</a>.</p>&#13;
<pre id="list5-4"><code>#define SE_SIGNING_LEVEL_UNCHECKED        0x00000000&#13;
#define SE_SIGNING_LEVEL_UNSIGNED         0x00000001&#13;
#define SE_SIGNING_LEVEL_ENTERPRISE       0x00000002&#13;
#define SE_SIGNING_LEVEL_CUSTOM_1         0x00000003&#13;
#define SE_SIGNING_LEVEL_DEVELOPER        SE_SIGNING_LEVEL_CUSTOM_1&#13;
#define SE_SIGNING_LEVEL_AUTHENTICODE     0x00000004&#13;
#define SE_SIGNING_LEVEL_CUSTOM_2         0x00000005&#13;
#define SE_SIGNING_LEVEL_STORE            0x00000006&#13;
#define SE_SIGNING_LEVEL_CUSTOM_3         0x00000007&#13;
#define SE_SIGNING_LEVEL_ANTIMALWARE      SE_SIGNING_LEVEL_CUSTOM_3&#13;
#define SE_SIGNING_LEVEL_MICROSOFT        0x00000008&#13;
#define SE_SIGNING_LEVEL_CUSTOM_4         0x00000009&#13;
#define SE_SIGNING_LEVEL_CUSTOM_5         0x0000000A&#13;
#define SE_SIGNING_LEVEL_DYNAMIC_CODEGEN  0x0000000B&#13;
#define SE_SIGNING_LEVEL_WINDOWS          0x0000000C&#13;
#define SE_SIGNING_LEVEL_CUSTOM_7         0x0000000D&#13;
#define SE_SIGNING_LEVEL_WINDOWS_TCB      0x0000000E&#13;
#define SE_SIGNING_LEVEL_CUSTOM_6         0x0000000F</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 5-4: Image signature levels</span></p>&#13;
<p class="TX">The purpose of each value isn’t well documented, but some are self-explanatory. For instance, <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_SIGNING_LEVEL_UNSIGNED</samp> is for unsigned code, <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_SIGNING_LEVEL_WINDOWS</samp> indicates that the image is an operating system component, and <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_SIGNING_LEVEL_ANTIMALWARE</samp> has something to do with antimalware protections.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageSignatureType</samp> field, a companion to <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageSignatureLevel</samp>, defines the signature type with which Code Integrity has labeled the image to indicate how the signature was applied. The <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_IMAGE_SIGNATURE_TYPE</samp> enumeration that defines these values is shown in <a href="#list5-5">Listing 5-5</a>.</p>&#13;
<pre id="list5-5"><code>typedef enum _SE_IMAGE_SIGNATURE_TYPE&#13;
{&#13;
    SeImageSignatureNone = 0,&#13;
    SeImageSignatureEmbedded,&#13;
    SeImageSignatureCache,&#13;
    SeImageSignatureCatalogCached,&#13;
    SeImageSignatureCatalogNotCached,&#13;
    SeImageSignatureCatalogHint,&#13;
    SeImageSignaturePackageCatalog,&#13;
} SE_IMAGE_SIGNATURE_TYPE, *PSE_IMAGE_SIGNATURE_TYPE;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 5-5: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SE_IMAGE_SIGNATURE_TYPE</samp> enumeration</span></p>&#13;
<p class="TX">The Code Integrity internals related to these properties are outside the scope of this chapter, but the most commonly encountered are <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImageSignatureNone</samp> (meaning the file is unsigned), <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImageSignatureEmbedded</samp> (meaning the signature is embedded in the file), and <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImageSignatureCache</samp> (meaning the signature is cached on the system).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_83" aria-label=" Page 83. "/>If the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImagePartialMap</samp> value is nonzero, the image being mapped into the process’s virtual address space isn’t complete. This value, added in Windows 10, is set in cases such as when <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!MapViewOfFile()</samp> is invoked to map a small portion of a file whose size is larger than that of the process’s address space. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageBase</samp> field contains the base address into which the image will be mapped, in either user or kernel address space, depending on the image type.</p>&#13;
<p class="TX">It is worth noting that when the image-load notification reaches the driver, the image is already mapped. This means that the code inside the DLL is in the host process’s virtual address space and ready to be executed. You can observe this behavior with WinDbg, as demonstrated in <a href="#list5-6">Listing 5-6</a>.</p>&#13;
<pre id="list5-6"><code>0: kd&gt; <b>bp nt!PsCallImageNotifyRoutines</b>&#13;
0: kd&gt; <b>g</b>&#13;
Breakpoint 0 hit&#13;
nt!PsCallImageNotifyRoutines:&#13;
fffff803`49402bc0 488bc4          mov    rax,rsp&#13;
0: kd&gt; <b>dt _UNICODE_STRING @rcx</b>&#13;
ntdll!_UNICODE_STRING&#13;
  "\SystemRoot\System32\ntdll.dll"&#13;
    +0x000 Length           : 0x3c&#13;
    +0x002 MaximumLengthN   : 0x3e&#13;
    +0x008 Buffer           : 0xfffff803`49789b98 <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> "\SystemRoot\System32\ntdll.dll"</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 5-6: Extracting the image name from an image-load notification</span></p>&#13;
<p class="TX">We first set a breakpoint on the function responsible for traversing the array of registered callback routines. Then we investigate the RCX register when the debugger breaks. Remember that the first parameter passed to the callback routine, stored in RCX, is a Unicode string containing the name of the image being loaded <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">Once we have this image in our sights, we can view the current process’s VADs, shown in <a href="#list5-7">Listing 5-7</a>, to see which images have been loaded into the current process, where, and how.</p>&#13;
<pre id="list5-7"><code>0: kd&gt; <b>!vad</b>&#13;
VAD           Level Commit&#13;
<var>--snip--</var>&#13;
ffff9b8f9952fd80 0     0 Mapped READONLY Pagefile section, shared commit 0x1&#13;
ffff9b8f9952eca0 2     0 Mapped READONLY Pagefile section, shared commit 0x23&#13;
ffff9b8f9952d260 1     1 Mapped NO_ACCESS Pagefile section, shared commit 0xe0e&#13;
ffff9b8f9952c5e0 2     4 Mapped Exe EXECUTE_WRITECOPY \Windows\System32\notepad.exe&#13;
ffff9b8f9952db20 3     16 Mapped Exe EXECUTE_WRITECOPY \Windows\System32\ntdll.dll</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 5-7: Checking the VADs to find the image to be loaded</span></p>&#13;
<p class="TX">The last line of the output shows that the target of the image-load notification, <i>ntdll.dll</i> in our example, is labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">Mapped</samp>. In the case of EDR, this means that we know the DLL is located on disk and copied into memory. The loader needs to do a few things, such as resolving the DLL’s dependencies, before the <samp class="SANS_TheSansMonoCd_W5Regular_11">DllMain()</samp> function inside the DLL is called and its code <span role="doc-pagebreak" epub:type="pagebreak" id="pg_84" aria-label=" Page 84. "/>begins to execute. This is particularly relevant only in situations where the EDR is working in prevention mode and might take action to stop the DLL from executing in the target process.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h2 class="H1" id="sec5"><span id="h-58"/><samp class="SANS_Futura_Std_Bold_B_11">Evading Image-Load Notifications with Tunneling Tools</samp></h2>&#13;
<p class="TNI">An evasion tactic that has gained popularity over the past few years is to proxy one’s tooling rather than run it on the target. When an attacker avoids running post-exploitation tooling on the host, they remove many host-based indicators from the collection data, making detection extremely difficult for the EDR. Most adversary toolkits contain utilities that collect network information or act on other hosts in the environment. However, these tools generally require only a valid network path and the ability to authenticate to the system with which they want to interact. So attackers don’t have to execute them on a host in the target environment.</p>&#13;
<p class="TX">One way of staying off the host is by proxying the tools from an outside computer and then routing the tool’s traffic through the compromised host. Although this strategy has recently become more common for its usefulness in evading EDR solutions, the technique isn’t new, and most attackers have performed it for years by using the Metasploit Framework’s auxiliary modules, particularly when their complex tool sets won’t work on the target for some reason. For example, attackers sometimes wish to make use of the tools provided by Impacket, a collection of classes written in Python for working with network protocols. If a Python interpreter isn’t available on the target machine, the attackers need to hack together an executable file to drop and execute on the host. This creates a lot of headaches and limits the operational viability of many toolkits, so attackers turn to proxying instead.</p>&#13;
<p class="TX">Many command-and-control agents, such as Beacon and its <samp class="SANS_TheSansMonoCd_W5Regular_11">socks</samp> command, support some form of proxying. <a href="#fig5-1">Figure 5-1</a> shows a common proxying architecture.</p>&#13;
<figure class="IMG"><img id="fig5-1" class="img100" src="../images/Figure5-1.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: A generic proxying architecture</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">After deploying the command-and-control agent in the target environment, operators will start a proxy on their server and then associate the agent with the proxy. From thereon, all traffic routed through the proxy <span role="doc-pagebreak" epub:type="pagebreak" id="pg_85" aria-label=" Page 85. "/>will pass through a <i>bastion</i>, a host used to obfuscate the true location of the command-and-control server, to the deployed agent, allowing the operator to tunnel their tools into the environment. An operator may then use tools such as Proxychains or Proxifier to force their post-exploitation tooling, running on some external host, to ship its traffic through the proxy and act as if it were running on the internal environment.</p>&#13;
<p class="TX">There is, however, one significant downside to this tactic. Most offensive security teams use noninteractive sessions, which introduce a planned delay between the command-and-control agent’s check-ins with its server. This allows the beaconing behavior to blend into the system’s normal traffic by reducing the total volume of interactions and matching the system’s typical communications profile. For example, in most environments, you wouldn’t find much traffic between a workstation and a banking site. By increasing the interval between check-ins to a server posing as a legitimate banking service, attackers can blend into the background. But when proxying, this practice becomes a substantial headache, as many tools aren’t built to support high-latency channels. Imagine trying to browse a web page but only being allowed to make one request per hour (and then having to wait another hour for the results).</p>&#13;
<p class="TX">To work around this, many operators will reduce the check-in intervals to nearly zero, creating an interactive session. This lessens network latency, allowing the post-exploitation tooling to run without delay. However, because nearly all command-and-control agents use a single communications channel for check-ins, tasking, and the sending of output, the volume of traffic over this single channel can become significant, tipping off defenders that suspicious beaconing activity is taking place. This means attackers must make some trade-offs between host-based and network-based indicators with respect to their operating environment.</p>&#13;
<p class="TX">As EDR vendors enhance their ability to identify beaconing traffic, offensive teams and developers will continue to advance their tradecraft to evade detection. One of the next logical steps in accomplishing this is to use multiple channels for command-and-control tasking rather than only one, either by employing a secondary tool, such as gTunnel, or by building this support into the agent itself. <a href="#fig5-2">Figure 5-2</a> shows an example of how this could work.</p>&#13;
<figure class="IMG"><img id="fig5-2" class="img100" src="../images/Figure5-2.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-2: The gTunnel proxying architecture</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_86" aria-label=" Page 86. "/>In this example, we still use the existing command-and-control channel to control the agent deployed on the compromised host, but we also add a gTunnel channel that allows us to proxy our tooling. We execute the tooling on our attacker host, virtually eliminating the risk of host-based detection, and route the tool’s network traffic through gTunnel to the compromised system, where it continues as if it originated from the compromised host. This still leaves open the opportunity for defenders to detect the attack using network-based detections, but it greatly reduces the attacker’s footprint on the host.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h2 class="H1" id="sec6"><span id="h-59"/><samp class="SANS_Futura_Std_Bold_B_11">Triggering KAPC Injection with Image-Load Notifications</samp></h2>&#13;
<p class="TNI"><span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span> discussed how EDRs often inject function-hooking DLLs into newly created processes to monitor calls to certain functions of interest. Unfortunately for vendors, there is no formally supported way of injecting a DLL into a process from kernel mode. Ironically, one of their most common methods of doing so is a technique often employed by the malware they seek to detect: APC injection. Most EDR vendors use KAPC injection, a procedure that instructs the process being spawned to load the EDR’s DLL despite it not being explicitly linked to the image being executed.</p>&#13;
<p class="TX">To inject a DLL, EDRs can’t simply write the contents of the image into the process’s virtual address space however they wish. The DLL must be mapped in a manner that follows the PE format. To achieve this from kernel mode, the driver can use a pretty neat trick: relying on an image-load callback notification to watch for a newly created process loading <i>ntdll.dll</i>. Loading <i>ntdll.dll</i> is one of the first things a new process does, so if the driver can notice this happening, it can act on the process before the main thread begins its execution: a perfect time to place its hooks. This section walks you through the steps to inject a function-hooking DLL into a newly created 64-bit process.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h3 class="H2" id="sec7"><span id="h-60"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding KAPC Injection</samp></h3>&#13;
<p class="TNI">KAPC injection is relatively straightforward in theory and only gets murky when we talk about its actual implementation in a driver. The general gist is that we want to tell a newly created process to load the DLL we specify. In the case of EDRs, this will almost always be a function-hooking DLL. APCs, one of several methods of signaling a process to do something for us, wait until a thread is in an <i>alertable</i> state, such as when the thread executes <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!SleepEx()</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!WaitForSingleObjectEx()</samp>, to perform the task we requested.</p>&#13;
<p class="TX">KAPC injection queues this task from kernel mode, and unlike plain user-mode APC injection, the operating system doesn’t formally support it, making its implementation a bit hacky. The process consists of a few steps. First, the driver is notified of an image load, whether it be the process image (such as <i>notepad.exe</i>) or a DLL that the EDR is interested in. Because the notification occurs in the context of the target process, the driver then searches the currently loaded modules for the address of a function that <span role="doc-pagebreak" epub:type="pagebreak" id="pg_87" aria-label=" Page 87. "/>can load a DLL, specifically <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!LdrLoadDll()</samp>. Next, the driver initializes a few key structures, providing the name of the DLL to be injected into the process; initializes the KAPC; and queues it for execution into the process. Whenever a thread in the process enters an alertable state, the APC will be executed and the EDR driver’s DLL will be loaded.</p>&#13;
<p class="TX">To better understand this process, let’s step through each of these stages in greater detail.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H2" id="sec8"><span id="h-61"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Getting a Pointer to the DLL-Loading Function</samp></h3>&#13;
<p class="TNI">Before the driver can inject its DLL, it must get a pointer to the undocumented <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!LdrLoadDll()</samp> function, which is responsible for loading a DLL into a process, similarly to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!LoadLibrary()</samp>. This is defined in <a href="#list5-8">Listing 5-8</a>.</p>&#13;
<pre id="list5-8"><code>NTSTATUS&#13;
LdrLoadDll(IN PWSTR SearchPath OPTIONAL,&#13;
           IN PULONG DllCharacteristics OPTIONAL,&#13;
           IN PUNICODE_STRING DllName,&#13;
           OUT PVOID *BaseAddress)</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 5-8: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">LdrLoadDll()</samp> definition</span></p>&#13;
<p class="TX">Note that there is a difference between a DLL being loaded and it being fully mapped into the process. For this reason, a post-operation callback may be more favorable than a pre-operation callback for some drivers. This is because, when a post-operation callback routine is notified, the image is fully mapped, meaning that the driver can get a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!LdrLoadDll()</samp> in the mapped copy of <i>ntdll.dll</i>. Because the image is mapped into the current process, the driver also doesn’t need to worry about address space layout randomization (ASLR).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H2" id="sec9"><span id="h-62"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Preparing to Inject</samp></h3>&#13;
<p class="TNI">Once the driver gets a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!LdrLoadDll()</samp>, it has satisfied the most important requirement for performing KAPC injection and can start injecting its DLL into the new process. <a href="#list5-9">Listing 5-9</a> shows how an EDR’s driver might perform the initialization steps necessary to do so.</p>&#13;
<pre id="list5-9"><code>typedef struct _INJECTION_CTX&#13;
{&#13;
    UNICODE_STRING Dll;&#13;
    WCHAR Buffer[MAX_PATH];&#13;
} INJECTION_CTX, *PINJECTION_CTX&#13;
&#13;
void Injector()&#13;
{&#13;
    NTSTATUS status = STATUS_SUCCESS;&#13;
    PINJECTION_CTX ctx = NULL;&#13;
    const UNICODE_STRING DllName = RTL_CONSTANT_STRING(L"hooks.dll");&#13;
&#13;
    <var>--snip--</var><span role="doc-pagebreak" epub:type="pagebreak" id="pg_88" aria-label=" Page 88. "/>&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> status = ZwAllocateVirtualMemory(&#13;
        ZwCurrentProcess(),&#13;
        (PVOID *)&amp;ctx,&#13;
        0,&#13;
        sizeof(INJECTION_CTX),&#13;
        MEM_COMMIT | MEM_RESERVE,&#13;
        PAGE_READWRITE&#13;
    );&#13;
&#13;
    <var>--snip--</var>&#13;
&#13;
      RtlInitEmptyUnicodeString(&#13;
        &amp;ctx-&gt;Dll,&#13;
        ctx-&gt;Buffer,&#13;
        sizeof(ctx-&gt;Buffer)&#13;
      );&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> RtlUnicodeStringCopyString(&#13;
      &amp;ctx-&gt;Dll,&#13;
      DllName&#13;
    );&#13;
&#13;
    <var>--snip--</var>&#13;
&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 5-9: Allocating memory in the target process and initializing the context structure</span></p>&#13;
<p class="TX">The driver allocates memory inside the target process <span class="CodeAnnotation" aria-label="annotation1">❶</span> for a context structure containing the name of the DLL to be injected <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h3 class="H2" id="sec10"><span id="h-63"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the KAPC Structure</samp></h3>&#13;
<p class="TNI">After this allocation and initialization completes, the driver needs to allocate space for a <samp class="SANS_TheSansMonoCd_W5Regular_11">KAPC</samp> structure, as shown in <a href="#list5-10">Listing 5-10</a>. This structure holds the information about the routine to be executed in the target thread.</p>&#13;
<pre id="list5-10"><code>PKAPC pKapc = (PKAPC)ExAllocatePoolWithTag(&#13;
    NonPagedPool,&#13;
    sizeof(KAPC),&#13;
    'CPAK'&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 5-10: Allocating memory for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">KAPC</samp> structure</span></p>&#13;
<p class="TX">The driver allocates this memory in <samp class="SANS_TheSansMonoCd_W5Regular_11">NonPagedPool</samp>, a memory pool that guarantees the data will stay in physical memory rather than being paged out to disk as long as the object is allocated. This is important because the thread into which the DLL is being injected may be running at a high interrupt request level, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">DISPATCH_LEVEL</samp>, in which case it shouldn’t access memory in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PagedPool</samp>, as this causes a fatal error that usually results in an <samp class="SANS_TheSansMonoCd_W5Regular_11">IRQL_NOT_LESS_OR_EQUAL</samp> bug check (also known as the Blue Screen of Death).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_89" aria-label=" Page 89. "/>Next, the driver initializes the previously allocated <samp class="SANS_TheSansMonoCd_W5Regular_11">KAPC</samp> structure using the undocumented <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!KeInitializeApc()</samp> API, shown in <a href="#list5-11">Listing 5-11</a>.</p>&#13;
<pre id="list5-11"><code>VOID KeInitializeApc(&#13;
  PKAPC Apc,&#13;
  PETHREAD Thread,&#13;
  KAPC_ENVIRONMENT Environment,&#13;
  PKKERNEL_ROUTINE KernelRoutine,&#13;
  PKRUNDOWN_ROUTINE RundownRoutine,&#13;
  PKNORMAL_ROUTINE NormalRoutine,&#13;
  KPROCESSOR_MODE ApcMode,&#13;
  PVOID NormalContext&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 5-11: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!KeInitializeApc()</samp> definition</span></p>&#13;
<p class="TX">In our driver, the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!KeInitializeApc()</samp> would look something like what is shown in <a href="#list5-12">Listing 5-12</a>.</p>&#13;
<pre id="list5-12"><code>KeInitializeApc(&#13;
  pKapc,&#13;
  KeGetCurrentThread(),&#13;
  OriginalApcEnvironment,&#13;
  (PKKERNEL_ROUTINE)OurKernelRoutine,&#13;
  NULL,&#13;
  (PKNORMAL_ROUTINE)pfnLdrLoadDll,&#13;
  UserMode,&#13;
  NULL&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 5-12: The call to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!KeInitializeApc()</samp> with the details for DLL injection</span></p>&#13;
<p class="TX">This function first takes the pointer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">KAPC</samp> structure created previously, along with a pointer to the thread into which the APC should be queued, which can be the current thread in our case. Following these parameters is a member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">KAPC_ENVIRONMENT</samp> enumeration, which should be <samp class="SANS_TheSansMonoCd_W5Regular_11">OriginalApcEnvironment</samp> (<i>0</i>), to indicate that the APC will run in the thread’s process context.</p>&#13;
<p class="TX">The next three parameters, the routines, are where a bulk of the work happens. The <samp class="SANS_TheSansMonoCd_W5Regular_11">KernelRoutine</samp>, named <samp class="SANS_TheSansMonoCd_W5Regular_11">OurKernelRoutine()</samp> in our example code, is the function to be executed in kernel mode at <samp class="SANS_TheSansMonoCd_W5Regular_11">APC_LEVEL</samp> before the APC is delivered to user mode. Most often, it simply frees the <samp class="SANS_TheSansMonoCd_W5Regular_11">KAPC</samp> object and returns. The <samp class="SANS_TheSansMonoCd_W5Regular_11">RundownRoutine</samp> function is executed if the target thread is terminated before the APC was delivered. This should free the <samp class="SANS_TheSansMonoCd_W5Regular_11">KAPC</samp> object, but we’ve kept it empty in our example for the sake of simplicity. The <samp class="SANS_TheSansMonoCd_W5Regular_11">NormalRoutine</samp> function should execute in user mode at <samp class="SANS_TheSansMonoCd_W5Regular_11">PASSIVE_LEVEL</samp> when the APC is delivered. In our case, this should be the function pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!LdrLoadDll()</samp>. The last two parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">ApcMode</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NormalContext</samp>, are set to <samp class="SANS_TheSansMonoCd_W5Regular_11">UserMode</samp> (<i>1</i>) and the parameter passed as <samp class="SANS_TheSansMonoCd_W5Regular_11">NormalRoutine</samp>, respectively.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h3 class="H2" id="sec11"><span id="h-64"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_90" aria-label=" Page 90. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Queueing the APC</samp></h3>&#13;
<p class="TNI">Lastly, the driver needs to queue this APC. The driver calls the undocumented function <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!KeInsertQueueApc()</samp>, defined in <a href="#list5-13">Listing 5-13</a>.</p>&#13;
<pre id="list5-13"><code>BOOL KeInsertQueueApc(&#13;
  PRKAPC Apc,&#13;
  PVOID SystemArgument1,&#13;
  PVOID SystemArgument2,&#13;
  KPRIORITY Increment&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 5-13: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!KeInsertQueueApc()</samp> definition</span></p>&#13;
<p class="TX">This function is quite a bit simpler than the previous one. The first input parameter is the APC, which will be the pointer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">KAPC</samp> we created. Next are the arguments to be passed. These should be the path to the DLL to be loaded and the length of the string containing the path. Because these are the two members of our custom <samp class="SANS_TheSansMonoCd_W5Regular_11">INJECTION_CTX</samp> structure, we simply reference the members here. Finally, since we’re not incrementing anything, we can set <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.</p>&#13;
<p class="TX">At this point, the DLL is queued for injection into the new process whenever the current thread enters an alertable state, such as if it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!WaitForSingleObject()</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep()</samp>. After the APC completes, the EDR will start to receive events from the DLL containing its hooks, allowing it to monitor the execution of key APIs inside the injected function.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h2 class="H1" id="sec12"><span id="h-65"/><samp class="SANS_Futura_Std_Bold_B_11">Preventing KAPC Injection</samp></h2>&#13;
<p class="TNI">Beginning in Windows build 10586, processes may prevent DLLs not signed by Microsoft from being loaded into them via process and thread mitigation policies. Microsoft originally implemented this functionality so that browsers could prevent third-party DLLs from injecting into them, which could impact their stability.</p>&#13;
<p class="TX">The mitigation strategies work as follows. When a process is created via the user-mode process-creation API, a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">STARTUPINFOEX</samp> structure is expected to be passed as a parameter. Inside this structure is a pointer to an attribute list, <samp class="SANS_TheSansMonoCd_W5Regular_11">PROC_THREAD_ATTRIBUTE_LIST</samp>. This attribute list, once initialized, supports the attribute <samp class="SANS_TheSansMonoCd_W5Regular_11">PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY</samp>. When this attribute is set, the <samp class="SANS_TheSansMonoCd_W5Regular_11">lpValue</samp> member of the attribute may be a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">DWORD</samp> containing the <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON</samp> flag. If this flag is set, only DLLs signed by Microsoft will be permitted to load in the process. If a program tries to load a DLL not signed by Microsoft, a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_INVALID_IMAGE_HASH</samp> error will be returned. By leveraging this attribute, processes can prevent EDRs from injecting their function-hooking DLL, allowing them to operate without fear of function interception.</p>&#13;
<p class="TX">A caveat to this technique is that the flag is only passed to processes being created and does not apply to the current process. Because of this, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_91" aria-label=" Page 91. "/>it is best suited for command-and-control agents that rely on the fork&amp;run architecture for post-exploitation tasks, as each time the agent queues a task, the sacrificial process will be created and have the mitigation policy applied. If a malware author would like this attribute to apply to their original process, they could leverage the <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!SetProcessMitigationPolicy()</samp> API and its associated <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessSignaturePolicy</samp> policy. By the time the process would be able to make this API call, however, the EDR’s function-hooking DLL would be loaded in the process and its hooks placed, rendering this technique nonviable.</p>&#13;
<p class="TX">Another challenge with using this technique is that EDR vendors have begun to get their DLLs attestation-signed by Microsoft, as shown in <a href="#fig5-3">Figure 5-3</a>, allowing them to be injected into processes even if the flag was set.</p>&#13;
<figure class="IMG"><img id="fig5-3" class="img70" src="../images/Figure5-3.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-3: CrowdStrike Falcon’s DLL countersigned by Microsoft</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In his post “Protecting Your Malware with blockdlls and ACG,” Adam Chester describes using the <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON</samp> flag, commonly referred to as Arbitrary Code Guard (ACG), to prevent the modification of executable regions of memory, a requirement of placing function hooks. While this flag prevented function hooks from being placed, it also prevented many off-the-shelf command-and-control agents’ shellcode from executing during testing, as most rely on manually setting pages of memory to read-write-execute (RWX).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h2 class="H1" id="sec13"><span id="h-66"/><samp class="SANS_Futura_Std_Bold_B_11">How Registry Notifications Work</samp></h2>&#13;
<p class="TNI">Like most software, malicious tools commonly interact with the registry, such as by querying values and creating new keys. In order to capture these interactions, drivers can register notification callback routines that get alerted any time a process interacts with the registry, allowing the driver to prevent, tamper with, or simply log the event.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_92" aria-label=" Page 92. "/>Some offensive techniques rely heavily on the registry. We can often detect these through registry events, assuming we know what we’re looking for. <a href="#tab5-1">Table 5-1</a> shows a handful of different techniques, what registry keys they interact with, and their associated <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_NOTIFY_CLASS</samp> class (a value we’ll discuss later in this section).</p>&#13;
<figure class="table">&#13;
<table class="table">&#13;
<caption>&#13;
<p class="TT" id="tab5-1"><samp class="SANS_Futura_Std_Heavy_B_11">Table 5-1:</samp> <samp class="SANS_Futura_Std_Book_11">Attacker Tradecraft in the Registry and the Related</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_NOTIFY_CLASS</samp> <samp class="SANS_Futura_Std_Book_11">Members</samp></p>&#13;
</caption>&#13;
<thead>&#13;
<tr class="table">&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Technique</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Registry location</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">REG_NOTIFY_CLASS members</samp></p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table">&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Run-key persistence</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\Software\Microsoft\Windows\CurrentVersion\Run</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtCreateKey(Ex)</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Security Support Provider (SSP) persistence</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\SYSTEM\CurrentControlSet\Control\Lsa\Security Packages</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtSetValueKey</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Component Object Model (COM) hijack</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\SOFTWARE\Classes\CLSID\&lt;CLSID&gt;\</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtSetValueKey</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Service hijack</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\SYSTEM\CurrentControlSet\Services\&lt;ServiceName&gt;</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtSetValueKey</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Link-Local Multicast Name Resolution (LLMNR) poisoning</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\Software\Policies\Microsoft\Windows NT\DNSClient</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtQueryValueKey</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Security Account Manager dumping</samp></p>&#13;
</td>&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\SAM</samp></p>&#13;
</td>&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">RegNt(Pre/Post)SaveKey</samp></p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p class="TX">To explore how adversaries interact with the registry, consider the technique of service hijacking. On Windows, services are a way of creating long-running processes that can be started manually or on boot, similar to daemons on Linux. While the service control manager manages these services, their configurations are stored exclusively in the registry, under the <i>HKEY_LOCAL_MACHINE (HKLM)</i> hive. For the most part, services run as the privileged <i>NT AUTHORITY/SYSTEM</i> account, which gives them pretty much full control over the system and makes them a juicy target for attackers.</p>&#13;
<p class="TX">One of the ways that adversaries abuse services is by modifying the registry values that describe the configuration of a service. Inside a service’s configuration, there exists a value, <samp class="SANS_TheSansMonoCd_W5Regular_11">ImagePath</samp>, that contains the path to the service’s executable. If an attacker can change this value to the path for a piece of malware they’ve placed on the system, their executable will be run in this privileged context when the service is restarted (most often on system reboot).</p>&#13;
<p class="TX">Because this attack procedure relies on registry value modification, an EDR driver that is monitoring <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtSetValueKey</samp>-type events could detect the adversary’s activity and respond accordingly.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h3 class="H2" id="sec14"><span id="h-67"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Registering a Registry Notification</samp></h3>&#13;
<p class="TNI">To register a registry callback routine, drivers must use the <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!CmRegisterCallbackEx()</samp> function defined in <a href="#list5-14">Listing 5-14</a>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Cm</samp> prefix references the configuration manager, which is the component of the kernel that oversees the registry.</p>&#13;
<pre id="list5-14"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_93" aria-label=" Page 93. "/>NTSTATUS CmRegisterCallbackEx(&#13;
  PEX_CALLBACK_FUNCTION  Function,&#13;
  PCUNICODE_STRING       Altitude,&#13;
  PVOID                  Driver,&#13;
  PVOID                  Context,&#13;
  PLARGE_INTEGER         Cookie,&#13;
  PVOID                  Reserved&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 5-14: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!CmRegisterCallbackEx()</samp> prototype</span></p>&#13;
<p class="TX">Of the callbacks covered in this book, the registry callback type has the most complex registration function, and its required parameters are slightly different from those for the other functions. First, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Function</samp> parameter is the pointer to the driver’s callback. It must be defined as an <samp class="SANS_TheSansMonoCd_W5Regular_11">EX_CALLBACK_FUNCTION</samp>, according to Microsoft’s Code Analysis for Drivers and the Static Driver Verifier, and it returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp>. Next, as in object-notification callbacks, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Altitude</samp> parameter defines the callback’s position in the callback stack. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Driver</samp> is a pointer to the driver object, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Context</samp> is an optional value that can be passed to the callback function but is very rarely used. Lastly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Cookie</samp> parameter is a <samp class="SANS_TheSansMonoCd_W5Regular_11">LARGE_INTEGER</samp> passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!CmUnRegisterCallback()</samp> when unloading the driver.</p>&#13;
<p class="TX">When a registry event occurs, the system invokes the callback function. Registry callback functions use the prototype in <a href="#list5-15">Listing 5-15</a>.</p>&#13;
<pre id="list5-15"><code>NTSTATUS ExCallbackFunction(&#13;
  PVOID CallbackContext,&#13;
  PVOID Argument1,&#13;
  PVOID Argument2&#13;
)</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 5-15: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!ExCallbackFunction()</samp> prototype</span></p>&#13;
<p class="TX">The parameters passed to the function may be difficult to make sense of at first due to their vague names. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CallbackContext</samp> parameter is the value defined in the registration function’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Context</samp> parameter, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Argument1</samp> is a value from the <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_NOTIFY_CLASS</samp> enumeration that specifies the type of action that occurred, such as a value being read or a new key being created. While Microsoft lists 62 members of this enumeration, those with the member prefixes <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNt</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPre</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPost</samp> represent the same activity generating notifications at different times, so by deduplicating the list, we can identify 24 unique operations. These are shown in <a href="#tab5-2">Table 5-2</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_94" aria-label=" Page 94. "/>&#13;
<figure class="table">&#13;
<table class="table">&#13;
<caption>&#13;
<p class="TT" id="tab5-2"><samp class="SANS_Futura_Std_Heavy_B_11">Table 5-2:</samp> <samp class="SANS_Futura_Std_Book_11">Stripped</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_NOTIFY_CLASS</samp> <samp class="SANS_Futura_Std_Book_11">Members and Descriptions</samp></p>&#13;
</caption>&#13;
<thead>&#13;
<tr class="table">&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Registry operation</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table">&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteKey</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A registry key is being deleted.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">SetValueKey</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A value is being set for a key.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteValueKey</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A value is being deleted from a key.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">SetInformationKey</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Metadata is being set for a key.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">RenameKey</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A key is being renamed.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EnumerateKey</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Subkeys of a key are being enumerated.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EnumerateValueKey</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Values of a key are being enumerated.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">QueryKey</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A key’s metadata is being read.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">QueryValueKey</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A value in a key is being read.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">QueryMultipleValueKey</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Multiple values of a key are being queried.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">CreateKey</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A new key is being created.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">OpenKey</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A handle to a key is being opened.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">KeyHandleClose</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A handle to a key is being closed.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">CreateKeyEx</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A key is being created.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">OpenKeyEx</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A thread is trying to open a handle to an existing key.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">FlushKey</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A key is being written to disk.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">LoadKey</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A registry hive is being loaded from a file.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">UnLoadKey</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A registry hive is being unloaded.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">QueryKeySecurity</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A key’s security information is being queried.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">SetKeySecurity</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A key’s security information is being set.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">RestoreKey</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A key’s information is being restored.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">SaveKey</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A key’s information is being saved.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">ReplaceKey</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A key’s information is being replaced.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">QueryKeyName</samp></p>&#13;
</td>&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">The full registry path of a key is being queried.</samp></p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Argument2</samp> parameter is a pointer to a structure that contains information relevant to the operation specified in <samp class="SANS_TheSansMonoCd_W5Regular_11">Argument1</samp>. Each operation has its own associated structure. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPreCreateKeyEx</samp> operations use the <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_CREATE_KEY_INFORMATION</samp> structure. This information provides the relevant context for the registry operation that occurred on the system, allowing the EDR to extract the data it needs to make a decision on how to proceed.</p>&#13;
<p class="TX">Every pre-operation member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_NOTIFY_CLASS</samp> enumeration (those that begin with <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPre</samp> or simply <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNt</samp>) uses structures specific to the type of operation. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPreQueryKey</samp> operation uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_QUERY_KEY_INFORMATION</samp> structure. These pre-operation callbacks allow the driver to modify or prevent the request from completing before execution is handed off to the configuration manager. An example of this using the previous <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPreQueryKey</samp> member would be to modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyInformation</samp> member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_QUERY_KEY_INFORMATION</samp> structure to change the type of information returned to the caller.</p>&#13;
<p class="TX">Post-operation callbacks always use the <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_POST_OPERATION_INFORMATION</samp> structure, with the exception of <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPostCreateKey</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPostOpenKey</samp>, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_95" aria-label=" Page 95. "/>which use the <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_POST_CREATE_KEY_INFORMATION</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_POST_OPEN_KEY _INFORMATION</samp> structures, respectively. This post-operation structure consists of a few interesting members. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Object</samp> member is a pointer to the registry-key object for which the operation was completed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Status</samp> member is the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp> value that the system will return to the caller. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ReturnStatus</samp> member is an <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp> value that, if the callback routine returns <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS _CALLBACK_BYPASS</samp>, will be returned to the caller. Lastly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">PreInformation</samp> member contains a pointer to the structure used for the corresponding pre-operation callback. For example, if the operation being processed is <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPreQueryKey</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">PreInformation</samp> member would be a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">REG _QUERY_KEY_INFORMATION</samp> structure.</p>&#13;
<p class="TX">While these callbacks don’t allow the same level of control as pre-operation callbacks do, they still give the driver some influence over the value returned to the caller. For example, the EDR could collect the return value and log that data.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h3 class="H2" id="sec15"><span id="h-68"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Mitigating Performance Challenges</samp></h3>&#13;
<p class="TNI">One of the biggest challenges that EDRs face when receiving registry notifications is performance. Because the driver can’t filter the events, it receives every registry event that occurs on the system. If one driver in the callback stack performs some operation on the data received that takes an excessive amount of time, it can cause serious system performance degradation. For example, during one test, a Windows virtual machine performed nearly 20,000 registry operations per minute at an idle state, as shown in <a href="#fig5-4">Figure 5-4</a>. If a driver took some action for each of these events that lasted an additional millisecond, it would cause a nearly 30 percent degradation to system performance.</p>&#13;
<figure class="IMG"><img id="fig5-4" class="img100" src="../images/Figure5-4.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-4: A total of 19,833 registry events captured in one minute</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To reduce the risk of adverse performance impacts, EDR drivers must carefully select what they monitor. The most common way that they do <span role="doc-pagebreak" epub:type="pagebreak" id="pg_96" aria-label=" Page 96. "/>this is by monitoring only certain registry keys and selectively capturing event types. <a href="#list5-16">Listing 5-16</a> demonstrates how an EDR might implement this behavior.</p>&#13;
<pre id="list5-16"><code>NTSTATUS RegistryNotificationCallback(&#13;
    PVOID pCallbackContext,&#13;
    PVOID pRegNotifyClass,&#13;
    PVOID pInfo)&#13;
{&#13;
    NTSTATUS status = STATUS_SUCCESS;&#13;
&#13;
 <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> switch (((REG_NOTIFY_CLASS)(ULONG_PTR)pRegNotifyClass))&#13;
    {&#13;
        case RegNtPostCreateKey:&#13;
        {&#13;
        <span class="CodeAnnotation" aria-label="annotation2">❷</span> PREG_POST_OPERATION_INFORMATION pPostInfo =&#13;
              (PREG_POST_OPERATION_INFORMATION)pInfo;&#13;
            <var>--snip--</var>&#13;
            break;&#13;
        }&#13;
        case RegNtPostSetValueKey:&#13;
        {&#13;
            <var>--snip--</var>&#13;
            break;&#13;
        }&#13;
        default:&#13;
            break;&#13;
    }&#13;
&#13;
    return status;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 5-16: Scoping a registry callback notification routine to work with specific operations only</span></p>&#13;
<p class="TX">In this example, the driver first casts the <samp class="SANS_TheSansMonoCd_W5Regular_11">pRegNotifyClass</samp> input parameter to a <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_NOTIFY_CLASS</samp> structure for comparison <span class="CodeAnnotation" aria-label="annotation1">❶</span> using a switch case. This is to make sure it’s working with the correct structure. The driver then checks whether the class matches one that it supports (in this case, key creation and the setting of a value). If it does match, the <samp class="SANS_TheSansMonoCd_W5Regular_11">pInfo</samp> member is cast to the appropriate structure <span class="CodeAnnotation" aria-label="annotation2">❷</span> so that the driver can continue to parse the event notification data.</p>&#13;
<p class="TX">An EDR developer may want to limit its scope even further to lessen the performance hit the system will take. For instance, if a driver wants to monitor service creation via the registry, it would need to check for registry-key creation events in the <i>HKLM:\SYSTEM\CurrentControlSet\Services\</i> path only.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h2 class="H1" id="sec16"><span id="h-69"/><samp class="SANS_Futura_Std_Bold_B_11">Evading Registry Callbacks</samp></h2>&#13;
<p class="TNI">Registry callbacks have no shortage of evasion opportunities, most of which are due to design decisions aimed at improving system performance. When drivers reduce the number of registry events they monitor, they can <span role="doc-pagebreak" epub:type="pagebreak" id="pg_97" aria-label=" Page 97. "/>introduce blind spots in their telemetry. For example, if they’re only monitoring events in <i>HKLM</i>, the hive used for the configuration of items shared across the system, they won’t detect any per-user registry keys created in <i>HKCU</i> or <i>HKU</i>, the hives used to configure items specific to a single principal. And if they’re monitoring registry-key creation events only, they’ll miss registry-key restoration events. EDRs commonly use registry callbacks to help protect unauthorized processes from interacting with registry keys associated with its agent, so it’s safe to assume that some of the allowable performance overhead is tied up in that logic.</p>&#13;
<p class="TX">This means that there are likely coverage gaps in the sensor that attackers can abuse. For example, <a href="#list5-17">Listing 5-17</a> contains the decompilation of a popular endpoint security product’s driver to show how it handles a number of registry operations.</p>&#13;
<pre id="list5-17"><code>switch(RegNotifyClass) {&#13;
case RegNtDeleteKey:&#13;
    pObject = *RegOperationInfo;&#13;
    local_a0 = pObject;&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> CmSetCallbackObjectContext(pObject, &amp;g_RegistryCookie), NewContext, 0);&#13;
default:&#13;
    goto LAB_18000a2c2;&#13;
case RegNtDeleteValueKey:&#13;
    pObject = *RegOperationInfo;&#13;
    local_a0 = pObject;&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> NewContext = (undefined8 *)InternalGetNameFromRegistryObject(pObject);&#13;
    CmSetCallbackObjectContext(pObject, &amp;g_RegistryCookie, NewContext, 0);&#13;
    goto LAB_18000a2c2;&#13;
case RegNtPreEnumerateKey:&#13;
    iVar9 = *(int *)(RegOperationInfo + 2);&#13;
    pObject = RegOperationInfo[1];&#13;
    iVar8 = 1;&#13;
    local_b0 = 1;&#13;
    local_b4 = iVar9;&#13;
    local_a0 = pObject;&#13;
    break;&#13;
<var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 5-17: Registry callback routine disassembly</span></p>&#13;
<p class="TX">The driver uses a switch case to handle notifications related to different types of registry operations. Specifically, it monitors key-deletion, value-deletion, and key-enumeration events. On a matching case, it extracts certain values based on the operation type and then processes them. In some cases, it also applies a context to the object <span class="CodeAnnotation" aria-label="annotation1">❶</span> to allow for advanced processing. In others, it calls an internal function <span class="CodeAnnotation" aria-label="annotation2">❷</span> using the extracted data.</p>&#13;
<p class="TX">There are a few notable gaps in coverage here. For instance, <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPostSetValueKey</samp>, the operation of which the driver is notified whenever the <samp class="SANS_TheSansMonoCd_W5Regular_11">RegSetValue(Ex)</samp> API is called, is handled in a case much later in the switch statement. This case would detect an attempt to set a value in a registry key, such as to create a new service. If the attacker needs to create a new <span role="doc-pagebreak" epub:type="pagebreak" id="pg_98" aria-label=" Page 98. "/>registry subkey and set values inside it, they’ll need to find another method that the driver doesn’t cover. Thankfully for them, the driver doesn’t process the <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPreLoadKey</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPostLoadKey</samp> operations, which would detect a registry hive being loaded from a file as a subkey. So, the operator may be able to leverage the <samp class="SANS_TheSansMonoCd_W5Regular_11">RegLoadKey</samp> API to create and populate their service registry key, effectively creating a service without being detected.</p>&#13;
<p class="TX">Revisiting the post-notification call <samp class="SANS_TheSansMonoCd_W5Regular_11">RegNtPostSetValueKey</samp>, we can see that the driver exhibits some interesting behavior common among most products, shown in <a href="#list5-18">Listing 5-18</a>.</p>&#13;
<pre id="list5-18"><code><var>--snip--</var>&#13;
case RegNtPostSetValueKey:&#13;
  <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> RegOperationStatus = RegOperationInfo-&gt;Status;&#13;
  <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> pObject = RegOperationInfo-&gt;Object;&#13;
     iVar7 = 1;&#13;
     local_b0 = 1;&#13;
     pBuffer = puVar5;&#13;
     p = puVar5;&#13;
     local_b4 = RegOperationStatus;&#13;
     local_a0 = pObject;&#13;
}&#13;
if ((RegOperationStatus &lt; 0 || (pObject == (PVOID)0x0)) { <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span>&#13;
LAB_18000a252:&#13;
    if (pBuffer != (undefined8 *)0x0) {&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> ExFreePoolWithTag(pBuffer, 0);&#13;
        NewContext = (undefined8 *)0x0;&#13;
      }&#13;
}&#13;
else {&#13;
     if ((pBuffer != (undefined8 *)0x0 ||&#13;
   <span class="CodeAnnotationCode" aria-label="annotation5">❺</span> (pBuffer = (undefined8 *)InternalGetNameFromRegistryObject((longlong)pObject),&#13;
      NewContext = pBuffer, pBuffer != (undefined8 *)0x0) {&#13;
        uBufferSize = &amp;local_98;&#13;
        if (local_98 == 0) {&#13;
            uBufferSize = (ushort *)0x0;&#13;
        }&#13;
        local_80 = (undefined8 *)FUN_1800099e0(iVar7, (ushort *)pBuffer, uBufferSize);&#13;
        if (local_80 != (undefined8 *)0x0) {&#13;
            FUN_1800a3f0(local_80, (undefined8 *)0x0);&#13;
            local_b8 = 1;&#13;
        }&#13;
        goto LAB_18000a252;&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 5-18: Registry-notification processing logic</span></p>&#13;
<p class="TX">This routine extracts the <samp class="SANS_TheSansMonoCd_W5Regular_11">Status</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Object</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span> members from the associated <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_POST_OPERATION_INFORMATION</samp> structure and stores them as local variables. Then it checks that these values aren’t <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SUCCESS</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>, respectively <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If the values fail the check, the output buffer used for relaying messages to the user-mode client is freed <span class="CodeAnnotation" aria-label="annotation4">❹</span> and the context set for the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_99" aria-label=" Page 99. "/>object is nulled. This behavior may seem strange at first, but it relates to the internal function renamed <samp class="SANS_TheSansMonoCd_W5Regular_11">InternalGetNameFromRegistryObject()</samp> for clarity <span class="CodeAnnotation" aria-label="annotation5">❺</span>. <a href="#list5-19">Listing 5-19</a> contains the decompilation of this function.</p>&#13;
<pre id="list5-19"><code>void * InternalGetNameFromRegistryObject(longlong RegObject)&#13;
{&#13;
    NTSTATUS status;&#13;
    NTSTATUS status2;&#13;
    POBJECT_NAME_INFORMATION pBuffer;&#13;
    PVOID null;&#13;
    PVOID pObjectName;&#13;
    ulong pulReturnLength;&#13;
    ulong ulLength;&#13;
&#13;
    null = (PVOID)0x0;&#13;
    pulReturnLength = 0;&#13;
 <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> if (RegObject != 0) {&#13;
        status = ObQueryNameString(RegObject, 0, 0, &amp;pulReturnLength);&#13;
        ulLength = pulReturnLength;&#13;
        pObjectName = null;&#13;
        if ((status = -0x3ffffffc) &amp;&amp;&#13;
          (pBuffer = (POBJECT_NAME_INFORMATION)ExAllocatePoolWithTag(&#13;
                       PagedPool, (ulonglong)pReturnLength, 0x6F616D6C),&#13;
          pBuffer != (POBJECT_NAME_INFORMATION)0x0)) {&#13;
            memset(pBuffer, 0, (ulonglong)ulLength);&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> status2 = ObQueryNameString(RegObject, pBuffer, ulLength, &amp;pulReturnLength);&#13;
            pObjectName = pBuffer;&#13;
            if (status2 &lt; 0) {&#13;
                ExFreePoolWithTag(pBuffer, 0);&#13;
                pObjectName = null;&#13;
            }&#13;
        }&#13;
        return pObjectName;&#13;
    }&#13;
    return (void *)0x0;&#13;
}</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 5-19: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">InternalGetNameFromRegistryObject()</samp> disassembly</span></p>&#13;
<p class="TX">This internal function takes a pointer to a registry object, which is passed in as the local variable holding the <samp class="SANS_TheSansMonoCd_W5Regular_11">Object</samp> member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_POST_OPERATION_INFORMATION</samp> structure, and extracts the name of the registry key being acted on using <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!ObQueryNameString()</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The problem with this flow is that if the operation was unsuccessful (as in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Status</samp> member of the post-operation information structure isn’t <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SUCCESS</samp>), the registry object pointer is invalidated and the call to the object-name-resolution function won’t be able to extract the name of the registry key. This driver contains conditional logic to check for this condition <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>&#13;
<p class="NOTE-TXT"><i>This specific function isn’t the only API affected by this problem. We often see similar logic implemented for other functions that extract key-name information from registry objects, such as <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!CmCallbackGetKeyObjectIDEx()</samp>.</i></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_100" aria-label=" Page 100. "/>Operationally, this means that an unsuccessful attempt to interact with the registry won’t generate an event, or at least one with all the relevant details, from which a detection can be created, all because the name of the registry key is missing. Without the name of the object, the event would effectively read “this user attempted to perform this registry action at this time and it was unsuccessful”: not very actionable for defenders.</p>&#13;
<p class="TX">But for attackers, this detail is important because it can change the risk calculus involved in performing certain activities. If an action targeting the registry were to fail (such as an attempt to read a key that doesn’t exist or to create a new service with a mistyped registry path), it would likely go unnoticed. By checking for this logic when a driver is handling post-operation registry notifications, attackers can determine which unsuccessful actions would evade detection.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h2 class="H1" id="sec17"><span id="h-70"/><samp class="SANS_Futura_Std_Bold_B_11">Evading EDR Drivers with Callback Entry Overwrites</samp></h2>&#13;
<p class="TNI">In this chapter as well as <span class="Xref"><a href="chapter3.xhtml">Chapters 3</a> and <a href="chapter4.xhtml">4</a></span>, we covered many kinds of callback notifications and discussed various evasions geared at bypassing them. Due to the complexity of EDR drivers and their different vendor implementations, it isn’t possible to entirely evade detection using these means. Rather, by focusing on evading specific components of the driver, operators can reduce the likelihood of triggering an alert.</p>&#13;
<p class="TX">However, if an attacker either gains administrator access on the host, has the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeLoadDriverPrivilege</samp> token privilege, or encounters a vulnerable driver that allows them to write to arbitrary memory, they may choose to target the EDR’s driver directly.</p>&#13;
<p class="TX">This process most commonly involves finding the internal list of callback routines registered on the system, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PspCallProcessNotifyRoutines</samp> in the context of process notifications or <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsCallImageNotifyRoutines</samp> for image-load notifications. Researchers have publicly demonstrated this technique in many ways. <a href="#list5-20">Listing 5-20</a> shows the output of Benjamin Delpy’s Mimidrv.</p>&#13;
<pre id="list5-20"><code>mimikatz # <b>version</b>&#13;
Windows NT 10.0 build 19042 (arch x64)&#13;
msvc 150030729 207&#13;
&#13;
mimikatz # <b>!+</b>&#13;
[*] 'mimidrv' service not present&#13;
[*] 'mimidrv' service successfully registered&#13;
[*] 'mimidrv' service ACL to everyone&#13;
[*] 'mimidrv' service started&#13;
&#13;
mimikatz # <b>!notifProcess</b>&#13;
[00] 0xFFFFF80614B1C7A0 [ntoskrnl.exe + 0x31c7a0]&#13;
[00] 0xFFFFF806169F6C70 [cng.sys + 0x6c70]&#13;
[00] 0xFFFFF80611CB4550 [WdFilter.sys + 0x44550]&#13;
[00] 0xFFFFF8061683B9A0 [ksecdd.sys + 0x1b9a0]&#13;
[00] 0xFFFFF80617C245E0 [tcpip.sys + 0x45e0]<span role="doc-pagebreak" epub:type="pagebreak" id="pg_101" aria-label=" Page 101. "/>&#13;
[00] 0xFFFFF806182CD930 [iorate.sys + 0xd930]&#13;
[00] 0xFFFFF806183AE050 [appid.sys + 0x1e050]&#13;
[00] 0xFFFFF80616979C30 [CI.dll + 0x79c30]&#13;
[00] 0xFFFFF80618ABD140 [dxgkrnl.sys + 0xd140]&#13;
[00] 0xFFFFF80619048D50 [vm3dmp.sys + 0x8d50]&#13;
[00] 0xFFFFF80611843CE0 [peauth.sys + 0x43ce0]</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 5-20: Using Mimidrv to enumerate process-notification callback routines</span></p>&#13;
<p class="TX">Mimidrv searches for a byte pattern that indicates the start of the array holding the registered callback routines. It uses Windows build–specific offsets from functions inside <i>ntoskrnl.exe</i>. After locating the list of callback routines, Mimidrv determines the driver from which the callback originates by correlating the address of the callback function to the address space in use by the driver. Once it has located the callback routine in the target driver, the attacker can choose to overwrite the first byte at the entry point of the function with a <samp class="SANS_TheSansMonoCd_W5Regular_11">RETN</samp> instruction (<samp class="SANS_TheSansMonoCd_W5Regular_11">0xC3</samp>). This would cause the function to immediately return when execution is passed to the callback, preventing the EDR from collecting any telemetry related to the notification event or taking any preventive action.</p>&#13;
<p class="TX">While this technique is operationally viable, deploying it comes with significant technical hurdles. First, unsigned drivers can’t be loaded onto Windows 10 or later unless the host is put into test mode. Next, the technique relies on build-specific offsets, which introduces complexity and unreliability to the tooling, as newer versions of Windows could change these patterns. Lastly, Microsoft has heavily invested in making Hypervisor-Protected Code Integrity (HVCI) a default protection on Windows 10 and has enabled it by default on secured-core systems. HVCI reduces the ability to load malicious or known-vulnerable drivers by protecting the code-integrity decision-making logic, including <samp class="SANS_TheSansMonoCd_W5Regular_11">ci!g_CiOptions</samp>, which is commonly temporarily overwritten to allow an unsigned driver to be loaded. This drives up the complexity of overwriting a callback’s entry point, as only HVCI-compatible drivers could be loaded on the system, reducing the potential attack surface.</p>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec18">&#13;
<h2 class="H1" id="sec18"><span id="h-71"/><samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp></h2>&#13;
<p class="TNI">While not as straightforward as the previously discussed callback types, image-load and registry-notification callbacks provide just as much information to an EDR. Image-load notifications can tell us when images, whether they be DLLs, executables, or drivers, are being loaded, and they give the EDR a chance to log, act, or even signal to inject its function-hooking DLL. Registry notifications provide an unparalleled level of visibility into actions affecting the registry. To date, the strongest evasion strategies an adversary can employ when facing these sensors is either to abuse a gap in coverage or logical flaw in the sensor itself or to avoid it entirely, such as by proxying in their tooling.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>