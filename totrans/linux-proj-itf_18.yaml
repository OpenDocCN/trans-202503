- en: Chapter 18. Directories and Links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we conclude our discussion of file-related topics by looking
    at directories and links. After an overview of their implementation, we describe
    the system calls used to create and remove directories and links. We then look
    at library functions that allow a program to scan the contents of a single directory
    and to walk through (i.e., examine each file in) a directory tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each process has two directory-related attributes: a root directory, which
    determines the point from which absolute pathnames are interpreted, and a current
    working directory, which determines the point from which relative pathnames are
    interpreted. We look at the system calls that allow a process to change both of
    these attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: We finish the chapter with a discussion of library functions that are used to
    resolve pathnames and to parse them into directory and filename components.
  prefs: []
  type: TYPE_NORMAL
- en: Directories and (Hard) Links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *directory* is stored in the file system in a similar way to a regular file.
    Two things distinguish a directory from a regular file:'
  prefs: []
  type: TYPE_NORMAL
- en: A directory is marked with a different file type in its i-node entry ([I-nodes](ch14.html#i-nodes
    "I-nodes")).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A directory is a file with a special organization. Essentially, it is a table
    consisting of filenames and i-node numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On most native Linux file systems, filenames can be up to 255 characters long.
    The relationship between directories and i-nodes is illustrated in [Figure 18-1](ch18.html#relationship_between_i-node_and_director
    "Figure 18-1. Relationship between i-node and directory structures for the file
    /etc/passwd"), which shows the partial contents of the file system i-node table
    and relevant directory files that are maintained for an example file (`/etc/passwd`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although a process can open a directory, it can’t use *read()* to read the contents
    of a directory. To retrieve the contents of a directory, a process must instead
    use the system calls and library functions discussed later in this chapter. (On
    some UNIX implementations, it is possible to perform a *read()* on a directory,
    but this is not portable.) Nor can a process directly change a directory’s contents
    with *write()*; it can only indirectly (i.e., request the kernel to) change the
    contents using system calls such as *open()* (to create a new file), *link()*,
    *mkdir()*, *symlink()*, *unlink()*, and *rmdir()*. (All of these system calls
    are described later in this chapter, except *open()*, which was described in Section
    4.3.)
  prefs: []
  type: TYPE_NORMAL
- en: The i-node table is numbered starting at 1, rather than 0, because 0 in the
    i-node field of a directory entry indicates that the entry is unused. I-node 1
    is used to record bad blocks in the file system. The root directory (/) of a file
    system is always stored in i-node entry 2 (as shown in [Figure 18-1](ch18.html#relationship_between_i-node_and_director
    "Figure 18-1. Relationship between i-node and directory structures for the file
    /etc/passwd")), so that the kernel knows where to start when resolving a pathname.
  prefs: []
  type: TYPE_NORMAL
- en: '![Relationship between i-node and directory structures for the file /etc/passwd](figs/web/18-1_DIRS_LINKS-inodes-dirs.png.jpg)Figure 18-1. Relationship
    between i-node and directory structures for the file `/etc/passwd`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we review the list of information stored in a file i-node ([I-nodes](ch14.html#i-nodes
    "I-nodes")), we see that the i-node doesn’t contain a filename; it is only the
    mapping within a directory list that defines the name of a file. This has a useful
    consequence: we can create multiple names—in the same or in different directories—each
    of which refers to the same i-node. These multiple names are known as *links*,
    or sometimes as *hard links* to distinguish them from symbolic links, which we
    discuss shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All native Linux and UNIX file systems support hard links. However, many non-UNIX
    file systems (e.g., Microsoft’s VFAT) do not. (Microsoft’s NTFS file system does
    support hard links.)
  prefs: []
  type: TYPE_NORMAL
- en: 'From the shell, we can create new hard links to an existing file using the
    *ln* command, as shown in the following shell session log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The i-node numbers displayed (as the first column) by *ls -li* confirm what
    was already clear from the output of the *cat* command: the names `abc` and `xyz`
    refer to the same i-node entry, and hence to the same file. In the third field
    displayed by *ls -li*, we can see the link count for the i-node. After the *ln
    abc xyz* command, the link count of the i-node referred to by `abc` has risen
    to 2, since there are now two names referring to the file. (The same link count
    is displayed for the file `xyz`, since it refers to the same i-node.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If one of these filenames is removed, the other name, and the file itself,
    continue to exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The i-node entry and data blocks for the file are removed (deallocated) only
    when the i-node’s link count falls to 0—that is, when all of the names for the
    file have been removed. To summarize: the *rm* command removes a filename from
    a directory list, decrements the link count of the corresponding i-node by 1,
    and, if the link count thereby falls to 0, deallocates the i-node and the data
    blocks to which it refers.'
  prefs: []
  type: TYPE_NORMAL
- en: All of the names (links) for a file are equivalent—none of the names (e.g.,
    the first) has priority over any of the others. As we saw in the above example,
    after the first name associated with the file was removed, the physical file continued
    to exist, but it was then accessible only by the other name.
  prefs: []
  type: TYPE_NORMAL
- en: 'A question often asked in online forums is “How can I find the filename associated
    with the file descriptor X in my program?” The short answer is that we can’t—
    at least not portably and unambiguously—since a file descriptor refers to an i-node,
    and multiple filenames (or even, as described in [Creating and Removing (Hard)
    Links: *link*() and *unlink*()](ch18.html#creating_and_removing_open_parenthesis_h
    "Creating and Removing (Hard) Links: link() and unlink()"), none at all) may refer
    to this i-node.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On Linux, we can see which files a process currently has open by using *readdir()*
    ([Reading Directories: *opendir()* and *readdir()*](ch18.html#reading_directories_colon_opendir_open_p
    "Reading Directories: opendir() and readdir()")) to scan the contents of the Linux-specific
    `/proc/`*PID*`/fd` directory, which contains symbolic links for each of the file
    descriptors currently opened by the process. The *lsof(1)* and *fuser(1)* tools,
    which have been ported to many UNIX systems, can also be useful in this regard.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hard links have two limitations, both of which can be circumvented by the use
    of symbolic links:'
  prefs: []
  type: TYPE_NORMAL
- en: Because directory entries (hard links) refer to files using just an i-node number,
    and i-node numbers are unique only within a file system, a hard link must reside
    on the same file system as the file to which it refers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hard link can’t be made to a directory. This prevents the creation of circular
    links, which would confuse many system programs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Early UNIX implementations permitted the superuser to create hard links to directories.
    This was necessary because these implementations did not provide a *mkdir()* system
    call. Instead, a directory was created using *mknod()*, and then links for the
    `.` and `..` entries were created ([Vahalia, 1996]). Although this feature is
    no longer needed, some modern UNIX implementations retain it for backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: An effect similar to hard links on directories can be achieved using bind mounts
    ([Bind Mounts](ch14.html#bind_mounts "Bind Mounts")).
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic (Soft) Links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *symbolic link*, also sometimes called a *soft link*, is a special file type
    whose data is the name of another file. [Figure 18-2](ch18.html#representation_of_hard_and_symbolic_link
    "Figure 18-2. Representation of hard and symbolic links") illustrates the situation
    where two hard links, `/home/erena/this` and `/home/allyn/that`, refer to the
    same file, and a symbolic link, /`home/kiran/other`, refers to the name `/home/erena/this`.
  prefs: []
  type: TYPE_NORMAL
- en: From the shell, symbolic links are created using the *ln -s* command. The *ls
    -F* command displays a trailing `@` character at the end of symbolic links.
  prefs: []
  type: TYPE_NORMAL
- en: The pathname to which a symbolic link refers may be either absolute or relative.
    A relative symbolic link is interpreted relative to the location of the link itself.
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic links don’t have the same status as hard links. In particular, a symbolic
    link is not included in the link count of the file to which it refers. (Thus,
    the link count of i-node 61 in [Figure 18-2](ch18.html#representation_of_hard_and_symbolic_link
    "Figure 18-2. Representation of hard and symbolic links") is 2, not 3.) Therefore,
    if the filename to which the symbolic link refers is removed, the symbolic link
    itself continues to exist, even though it can no longer be dereferenced (followed).
    We say that it has become a *dangling link*. It is even possible to create a symbolic
    link to a filename that doesn’t exist at the time the link is created.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Symbolic links were introduced by 4.2BSD. Although they were not included in
    POSIX.1-1990, they were subsequently incorporated into SUSv1, and thus are in
    SUSv3.
  prefs: []
  type: TYPE_NORMAL
- en: '![Representation of hard and symbolic links](figs/web/18-2_DIRS_LINKS-links.png.jpg)Figure 18-2. Representation
    of hard and symbolic links'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since a symbolic link refers to a filename, rather than an i-node number, it
    can be used to link to a file in a different file system. Symbolic links also
    do not suffer the other limitation of hard links: we can create symbolic links
    to directories. Tools such as *find* and *tar* can tell the difference between
    hard and symbolic links, and either don’t follow symbolic links by default, or
    avoid getting trapped in circular references created using symbolic links.'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to chain symbolic links (e.g., `a` is a symbolic link to `b`,
    which is a symbolic link to `c`). When a symbolic link is specified in various
    file-related system calls, the kernel dereferences the series of links to arrive
    at the final file.
  prefs: []
  type: TYPE_NORMAL
- en: SUSv3 requires that an implementation allow at least `_POSIX_SYMLOOP_MAX` dereferences
    of each symbolic link component of a pathname. The specified value for `_POSIX_SYMLOOP_MAX`
    is 8\. However, before kernel 2.6.18, Linux imposed a limit of 5 dereferences
    when following a chain of symbolic links. Starting with kernel 2.6.18, Linux implements
    the SUSv3-specified minimum of 8 dereferences. Linux also imposes a total of 40
    dereferences for an entire pathname. These limits are required to prevent extremely
    long symbolic link chains, as well as symbolic link loops, from causing stack
    overflows in the kernel code that resolves symbolic links.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some UNIX file systems perform an optimization not mentioned in the main text
    nor shown in [Figure 18-2](ch18.html#representation_of_hard_and_symbolic_link
    "Figure 18-2. Representation of hard and symbolic links"). When the total length
    of the string forming the symbolic link’s contents is small enough to fit in the
    part of the i-node that would normally be used for data pointers, the link string
    is instead stored there. This saves allocating a disk block and also speeds access
    to the symbolic link information, since it is retrieved along with the file i-node.
    For example, *ext2*, *ext3*, and *ext4* employ this technique to fit short symbolic
    strings into the 60 bytes normally used for data block pointers. In practice,
    this can be a very effective optimization. Of the 20,700 symbolic links on one
    system checked by the author, 97% were 60 bytes or smaller.
  prefs: []
  type: TYPE_NORMAL
- en: Interpretation of symbolic links by system calls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many system calls dereference (follow) symbolic links and thus work on the file
    to which the link refers. Some system calls don’t dereference symbolic links,
    but instead operate directly on the link file itself. As each system call is covered,
    we describe its behavior with respect to symbolic links. This behavior is also
    summarized in [Table 18-1](ch18.html#interpretation_of_symbolic_links_by_vari
    "Table 18-1. Interpretation of symbolic links by various functions").
  prefs: []
  type: TYPE_NORMAL
- en: 'In a few cases where it is necessary to have similar functionality for both
    the file to which a symbolic link refers and for the symbolic link itself, alternative
    system calls are provided: one that dereferences the link and another that does
    not, with the latter prefixed by the letter *l*; for example, *stat()* and *lstat()*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One point generally applies: symbolic links in the directory part of a pathname
    (i.e., all of the components preceding the final slash) are always dereferenced.
    Thus, in the pathname `/somedir/somesubdir/file`, `somedir` and `somesubdir` will
    always be dereferenced if they are symbolic links, and `file` may be dereferenced,
    depending on the system call to which the pathname is passed.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Operating Relative to a Directory File Descriptor](ch18.html#operating_relative_to_a_directory_file_d
    "Operating Relative to a Directory File Descriptor"), we describe a set of system
    calls, added in Linux 2.6.16, that extend the functionality of some of the interfaces
    shown in [Table 18-1](ch18.html#interpretation_of_symbolic_links_by_vari "Table 18-1. Interpretation
    of symbolic links by various functions"). For some of these system calls, the
    behavior with respect to following symbolic links can be controlled by the *flags*
    argument to the call.
  prefs: []
  type: TYPE_NORMAL
- en: File permissions and ownership for symbolic links
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ownership and permissions of a symbolic link are ignored for most operations
    (symbolic links are always created with all permissions enabled). Instead, the
    ownership and permissions of the file to which the link refers are used in determining
    whether an operation is permitted. The ownership of a symbolic link is relevant
    only when the link itself is being removed or renamed in a directory with the
    sticky permission bit set ([Set-User-ID, Set-Group-ID, and Sticky Bits](ch15.html#set-user-id_comma_set-group-id_comma_and
    "Set-User-ID, Set-Group-ID, and Sticky Bits")).
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating and Removing (Hard) Links: *link*() and *unlink*()'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *link()* and *unlink()* system calls create and remove hard links.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: Table 18-1. Interpretation of symbolic links by various functions
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Follows links? | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *access()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *acct()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *bind()* | • | UNIX domain sockets have pathnames |'
  prefs: []
  type: TYPE_TB
- en: '| *chdir()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *chmod()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *chown()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *chroot()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *creat()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *exec()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *getxattr()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *lchown()* |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| *lgetxattr()* |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| *link()* |   | See [Creating and Removing (Hard) Links: *link*() and *unlink*()](ch18.html#creating_and_removing_open_parenthesis_h
    "Creating and Removing (Hard) Links: link() and unlink()") |'
  prefs: []
  type: TYPE_TB
- en: '| *listxattr()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *llistxattr()* |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| *lremovexattr()* |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| *lsetxattr()* |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| *lstat()* |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| *lutimes()* |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| *open()* | • | Unless O_NOFOLLOW or O_EXCL &#124; O_CREAT specified |'
  prefs: []
  type: TYPE_TB
- en: '| *opendir()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *pathconf()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *pivot_root()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *quotactl()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *readlink()* |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| *removexattr()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *rename()* |   | Links are not followed in either argument |'
  prefs: []
  type: TYPE_TB
- en: '| *rmdir()* |   | Fails with ENOTDIR if argument is a symbolic link |'
  prefs: []
  type: TYPE_TB
- en: '| *setxattr()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *stat()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *statfs(), statvfs()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *swapon(), swapoff()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *truncate()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *unlink()* |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| *uselib()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: '| *utime(), utimes()* | • |   |'
  prefs: []
  type: TYPE_TB
- en: Given the pathname of an existing file in *oldpath*, the *link()* system call
    creates a new link, using the pathname specified in *newpath*. If *newpath* already
    exists, it is not overwritten; instead, an error (`EEXIST`) results.
  prefs: []
  type: TYPE_NORMAL
- en: On Linux, the *link()* system call doesn’t dereference symbolic links. If *oldpath*
    is a symbolic link, then *newpath* is created as a new hard link to the same symbolic
    link file. (In other words, *newpath* is also a symbolic link to the same file
    to which *oldpath* refers.) This behavior doesn’t conform to SUSv3, which says
    that all functions that perform pathname resolution should dereference symbolic
    links unless otherwise specified (and there is no exception specified for *link()*).
    Most other UNIX implementations behave in the manner specified by SUSv3\. One
    notable exception is Solaris, which provides the same behavior as Linux by default,
    but provides SUSv3-conformant behavior if appropriate compiler options are used.
    The upshot of this inconsistency across implementations is that portable applications
    should avoid specifying a symbolic link for the *oldpath* argument.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SUSv4 recognizes the inconsistency across existing implementations and specifies
    that the choice of whether or not *link()* dereferences symbolic links is implementation-defined.
    SUSv4 also adds the specification of *linkat()*, which performs the same task
    as *link()*, but has a *flags* argument that can be used to control whether the
    call dereferences symbolic links. See [Operating Relative to a Directory File
    Descriptor](ch18.html#operating_relative_to_a_directory_file_d "Operating Relative
    to a Directory File Descriptor") for further details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *unlink()* system call removes a link (deletes a filename) and, if that
    is the last link to the file, also removes the file itself. If the link specified
    in *pathname* doesn’t exist, then *unlink()* fails with the error `ENOENT`.
  prefs: []
  type: TYPE_NORMAL
- en: We can’t use *unlink()* to remove a directory; that task requires *rmdir()*
    or *remove()*, which we look at in Section 18.6.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SUSv3 says that if *pathname* specifies a directory, then *unlink()* should
    fail with the error `EPERM`. However, on Linux, *unlink()* fails with the error
    `EISDIR` in this case. (LSB explicitly permits this deviation from SUSv3.) A portable
    application should be prepared to handle either value if checking for this case.
  prefs: []
  type: TYPE_NORMAL
- en: The *unlink()* system call doesn’t dereference symbolic links. If *pathname*
    is a symbolic link, the link itself is removed, rather than the name to which
    it points.
  prefs: []
  type: TYPE_NORMAL
- en: An open file is deleted only when all file descriptors are closed
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to maintaining a link count for each i-node, the kernel also counts
    open file descriptions for the file (see [Figure 5-2](ch05.html#relationship_between_file_descriptors_co
    "Figure 5-2. Relationship between file descriptors, open file descriptions, and
    i-nodes"), in [Duplicating File Descriptors](ch05.html#duplicating_file_descriptors
    "Duplicating File Descriptors")). If the last link to a file is removed and any
    processes hold open descriptors referring to the file, the file won’t actually
    be deleted until all of the descriptors are closed. This is a useful feature,
    because it permits us to unlink a file without needing to worry about whether
    some other process has it open. (However, we can’t reattach a name to an open
    file whose link count has fallen to 0.) In addition, we can perform tricks such
    as creating and opening a temporary file, unlinking it immediately, and then continuing
    to use it within our program, relying on the fact that the file is destroyed only
    when we close the file descriptor—either explicitly, or implicitly when the program
    exits. (This is what the *tmpfile()* function described in [Creating Temporary
    Files](ch05.html#creating_temporary_files "Creating Temporary Files") does.)
  prefs: []
  type: TYPE_NORMAL
- en: The program in [Example 18-1](ch18.html#removing_a_link_with_unlink_open_parenth
    "Example 18-1. Removing a link with unlink()") demonstrates that even when the
    last link to a file is removed, the file is deleted only when all open file descriptors
    that refer to it are closed.
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-1. Removing a link with *unlink()*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The program in [Example 18-1](ch18.html#removing_a_link_with_unlink_open_parenth
    "Example 18-1. Removing a link with unlink()") accepts two command-line arguments.
    The first argument identifies the name of a file that the program should create.
    The program opens this file and then immediately unlinks the filename. Although
    the filename disappears, the file itself continues to exist. The program then
    writes random blocks of data to the file. The number of these blocks is specified
    in the optional second command-line argument of the program. At this point, the
    program employs the *df(1)* command to display the amount of space used on the
    file system. The program then closes the file descriptor, at which the point the
    file is removed, and uses *df(1)* once more to show that the amount of disk space
    in use has decreased. The following shell session demonstrates the use of the
    program in [Example 18-1](ch18.html#removing_a_link_with_unlink_open_parenth "Example 18-1. Removing
    a link with unlink()"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Example 18-1](ch18.html#removing_a_link_with_unlink_open_parenth "Example 18-1. Removing
    a link with unlink()"), we use the *system()* function to execute a shell command.
    We describe *system()* in detail in Section 27.6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the Name of a File: *rename()*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *rename()* system call can be used both to rename a file and to move it
    into another directory on the same file system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *oldpath* argument is an existing pathname, which is renamed to the pathname
    given in *newpath*.
  prefs: []
  type: TYPE_NORMAL
- en: The *rename()* call just manipulates directory entries; it doesn’t move file
    data. Renaming a file doesn’t affect other hard links to the file, nor does it
    affect any processes that hold open descriptors for the file, since these descriptors
    refer to open file descriptions, which (after the *open()* call) have no connection
    with filenames.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following rules apply to the use of *rename()*:'
  prefs: []
  type: TYPE_NORMAL
- en: If *newpath* already exists, it is overwritten.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *newpath* and *oldpath* refer to the same file, then no changes are made
    (and the call succeeds). This is rather counterintuitive. Following from the previous
    point, we normally expect that if two filenames `x` and `y` exist, then the call
    *rename* (“x”, “y”) would remove the name `x`. This is not the case if `x` and
    `y` are links to the same file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rationale for this rule, which comes from the original BSD implementation,
    was probably to simplify the checks that the kernel must perform in order to guarantee
    that calls such as *rename(“x”, “x”)*, *rename(“x”, “./x”)*, and *rename(“x”,
    “somedir/../x”)* don’t remove the file.
  prefs: []
  type: TYPE_NORMAL
- en: The *rename()* system call doesn’t dereference symbolic links in either of its
    arguments. If *oldpath* is a symbolic link, then the symbolic link is renamed.
    If *newpath* is a symbolic link, then it is treated as a normal pathname to which
    *oldpath* is to be renamed (i.e., the existing *newpath* symbolic link is removed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If *oldpath* refers to a file other than a directory, then *newpath* can’t
    specify the pathname of a directory (the error is `EISDIR`). To rename a file
    to a location inside a directory (i.e., move the file to another directory), *newpath*
    must include the new filename. The following call both moves a file into a different
    directory and changes its name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Specifying the name of a directory in *oldpath* allows us to rename that directory.
    In this case, *newpath* either must not exist or must be the name of an empty
    directory. If *newpath* is an existing file or an existing, nonempty directory,
    then an error results (respectively, `ENOTDIR` and `ENOTEMPTY`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *oldpath* is a directory, then *newpath* can’t contain a directory prefix
    that is the same as *oldpath*. For example, we could not rename `/home/mtk` to
    `/home/mtk/bin` (the error is `EINVAL`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The files referred to by *oldpath* and *newpath* must be on the same file system.
    This is required because a directory is a list of hard links that refer to i-nodes
    in the same file system as the directory. As stated earlier, *rename()* is merely
    manipulating the contents of directory lists. Attempting to rename a file into
    a different file system fails with the error `EXDEV`. (To achieve the desired
    result, we must instead copy the contents of the file from one file system to
    another and then delete the old file. This is what the *mv* command does in this
    case.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Working with Symbolic Links: *symlink()* and *readlink()*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now look at the system calls used to create symbolic links and examine their
    contents.
  prefs: []
  type: TYPE_NORMAL
- en: The *symlink()* system call creates a new symbolic link, *linkpath*, to the
    pathname specified in *filepath*. (To remove a symbolic link, we use *unlink()*.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: If the pathname given in *linkpath* already exists, then the call fails (with
    *errno* set to `EEXIST`). The pathname specified in *filepath* may be absolute
    or relative.
  prefs: []
  type: TYPE_NORMAL
- en: The file or directory named in *filepath* doesn’t need to exist at the time
    of the call. Even if it exists at that time, there is nothing to prevent it from
    being removed later. In this case, *linkpath* becomes a *dangling link*, and attempts
    to dereference it in other system calls yield an error (usually `ENOENT`).
  prefs: []
  type: TYPE_NORMAL
- en: If we specify a symbolic link as the *pathname* argument to *open()*, it opens
    the file to which the link refers. Sometimes, we would rather retrieve the content
    of the link itself—that is, the pathname to which it refers. The *readlink()*
    system call performs this task, placing a copy of the symbolic link string in
    the character array pointed to by *buffer*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns number of bytes placed in *buffer* on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *bufsiz* argument is an integer used to tell *readlink()* the number of
    bytes available in *buffer*.
  prefs: []
  type: TYPE_NORMAL
- en: If no errors occur, then *readlink()* returns the number of bytes actually placed
    in *buffer*. If the length of the link exceeds *bufsiz*, then a truncated string
    is placed in *buffer* (and *readlink()* returns the size of that string—that is,
    *bufsiz*).
  prefs: []
  type: TYPE_NORMAL
- en: Because a terminating null byte is not placed at the end of *buffer*, there
    is no way to distinguish the case where *readlink()* returns a truncated string
    from that where it returns a string that exactly fills *buffer*. One way of checking
    if the latter has occurred is to reallocate a larger *buffer* array and call *readlink()*
    again. Alternatively, we can size *pathname* using the `PATH_MAX` constant (described
    in [System Limits](ch11.html#system_limits "System Limits")), which defines the
    length of the longest pathname that a program should have to accommodate.
  prefs: []
  type: TYPE_NORMAL
- en: We demonstrate the use of *readlink()* in [Example 18-4](ch18.html#read_and_resolve_a_symbolic_link
    "Example 18-4. Read and resolve a symbolic link").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SUSv3 defined a new limit, `SYMLINK_MAX`, that an implementation should define
    to indicate the maximum number of bytes that can be stored in a symbolic link.
    This limit is required to be at least 255 bytes. At the time of writing, Linux
    doesn’t define this limit. In the main text, we suggest the use of `PATH_MAX`
    because that limit should be at least as large as `SYMLINK_MAX`.
  prefs: []
  type: TYPE_NORMAL
- en: In SUSv2, the return type of *readlink()* was specified as *int*, and many current
    implementations (as well as older *glibc* versions on Linux) follow that specification.
    SUSv3 changed the return type to *ssize_t*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating and Removing Directories: *mkdir()* and *rmdir()*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *mkdir()* system call creates a new directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *pathname* argument specifies the pathname of the new directory. This pathname
    may be relative or absolute. If a file with this pathname already exists, then
    the call fails with the error `EEXIST`.
  prefs: []
  type: TYPE_NORMAL
- en: The ownership of the new directory is set according to the rules described in
    [Ownership of New Files](ch15.html#ownership_of_new_files "Ownership of New Files").
  prefs: []
  type: TYPE_NORMAL
- en: 'The *mode* argument specifies the permissions for the new directory. (We describe
    the meanings of the permission bits for directories in [Ownership of New Files](ch15.html#ownership_of_new_files
    "Ownership of New Files"), [Changing File Ownership: *chown()*, *fchown()*, and
    *lchown()*](ch15.html#changing_file_ownership_colon_chown_open "Changing File
    Ownership: chown(), fchown(), and lchown()"), and [Set-User-ID, Set-Group-ID,
    and Sticky Bits](ch15.html#set-user-id_comma_set-group-id_comma_and "Set-User-ID,
    Set-Group-ID, and Sticky Bits").) This bit-mask value may be specified by ORing
    (`|`) together constants from [Table 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits"), in [Permissions on Directories](ch15.html#permissions_on_directories
    "Permissions on Directories"), but, as with *open()*, it may also be specified
    as an octal number. The value given in *mode* is ANDed against the process umask
    ([The Process File Mode Creation Mask: *umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "The Process File Mode Creation Mask: umask()")). In addition, the set-user-ID
    bit (`S_ISUID`) is always turned off, since it has no meaning for directories.'
  prefs: []
  type: TYPE_NORMAL
- en: If the sticky bit (`S_ISVTX`) is set in *mode*, then it will be set on the new
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: The setting of the set-group-ID bit (`S_ISGID`) in *mode* is ignored. Instead,
    if the set-group-ID bit is set on the parent directory, then it will also be set
    on the newly created directory. In [Ownership of New Files](ch15.html#ownership_of_new_files
    "Ownership of New Files"), we noted that setting the set-group-ID permission bit
    on a directory causes new files created in the directory to take their group ID
    from the directory’s group ID, rather than the process’s effective group ID. The
    *mkdir()* system call propagates the set-group-ID permission bit in the manner
    described here so that all subdirectories under a directory will share the same
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: SUSv3 explicitly notes that the manner in which *mkdir()* treats the set-user-ID,
    set-group-ID, and sticky bits is implementation-defined. On some UNIX implementations,
    these 3 bits are always turned off on a new directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The newly created directory contains two entries: `.` (dot), which is a link
    to the directory itself, and `..` (dot-dot), which is a link to the parent directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SUSv3 doesn’t require directories to contain `.` and `..` entries. It requires
    only that an implementation correctly interpret `.` and `..` when they appear
    in pathnames. A portable application should not rely on the existence of these
    entries in a directory.
  prefs: []
  type: TYPE_NORMAL
- en: The *mkdir()* system call creates only the last component of *pathname*. In
    other words, the call *mkdir(“aaa/bbb/ccc”, mode)* will succeed only if the directories
    `aaa` and `aaa/bbb` already exist. (This corresponds to the default operation
    of the *mkdir(1)* command, but *mkdir(1)* also provides the *-p* option to create
    all of the intervening directory names if they don’t exist.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GNU C library provides the *mkdtemp(template)* function, which is the directory
    analog of the *mkstemp()* function. It creates a uniquely named directory with
    read, write, and execute permissions enabled for the owner, and no permissions
    allowed for any other users. Instead of returning a file descriptor as its result,
    *mkdtemp()* returns a pointer to a modified string containing the actual directory
    name in *template*. SUSv3 doesn’t specify this function, and it is not available
    on all UNIX implementations; it is specified in SUSv4.
  prefs: []
  type: TYPE_NORMAL
- en: The *rmdir()* system call removes the directory specified in *pathname*, which
    may be an absolute or a relative pathname.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: In order for *rmdir()* to succeed, the directory must be empty. If the final
    component of *pathname* is a symbolic link, it is not dereferenced; instead, the
    error `ENOTDIR` results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing a File or Directory: *remove()*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *remove()* library function removes a file or an empty directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: If *pathname* is a file, *remove()* calls *unlink()*; if *pathname* is a directory,
    *remove()* calls *rmdir()*.
  prefs: []
  type: TYPE_NORMAL
- en: Like *unlink()* and *rmdir()*, *remove()* doesn’t dereference symbolic links.
    If *pathname* is a symbolic link, *remove()* removes the link itself, rather than
    the file to which it refers.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to remove a file in preparation for creating a new file with the
    same name, then using *remove()* is simpler than code that checks whether a pathname
    refers to a file or directory and calls *unlink()* or *rmdir()*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *remove()* function was invented for the standard C library, which is implemented
    on both UNIX and non-UNIX systems. Most non-UNIX systems don’t support hard links,
    so removing files with a function named *unlink()* would not make sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading Directories: *opendir()* and *readdir()*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The library functions described in this section can be used to open a directory
    and retrieve the names of the files it contains one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The library functions for reading directories are layered on top of the *getdents()*
    system call (which is not part of SUSv3), but provide an interface that is easier
    to use. Linux also provides a *readdir(2)* system call (as opposed to the *readdir(3)*
    library function described here), which performs a similar task to, but is made
    obsolete by, *getdents()*.
  prefs: []
  type: TYPE_NORMAL
- en: The *opendir()* function opens a directory and returns a handle that can be
    used to refer to the directory in later calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns directory stream handle, or `NULL` on error
  prefs: []
  type: TYPE_NORMAL
- en: The *opendir()* function opens the directory specified by *dirpath* and returns
    a pointer to a structure of type *DIR*. This structure is a so-called *directory
    stream*, which is a handle that the caller passes to the other functions described
    below. Upon return from *opendir()*, the directory stream is positioned at the
    first entry in the directory list.
  prefs: []
  type: TYPE_NORMAL
- en: The *fdopendir()* function is like *opendir()*, except that the directory for
    which a stream is to be created is specified via the open file descriptor *fd*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns directory stream handle, or `NULL` on error
  prefs: []
  type: TYPE_NORMAL
- en: The *fdopendir()* function is provided so that applications can avoid the kinds
    of race conditions described in [Operating Relative to a Directory File Descriptor](ch18.html#operating_relative_to_a_directory_file_d
    "Operating Relative to a Directory File Descriptor").
  prefs: []
  type: TYPE_NORMAL
- en: After a successful call to *fdopendir()*, this file descriptor is under the
    control of the system, and the program should not access it in any way other than
    by using the functions described in the remainder of this section.
  prefs: []
  type: TYPE_NORMAL
- en: The *fdopendir()* function is specified in SUSv4 (but not in SUSv3).
  prefs: []
  type: TYPE_NORMAL
- en: The *readdir()* function reads successive entries from a directory stream.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns pointer to a statically allocated structure describing next directory
    entry, or `NULL` on end-of-directory or error
  prefs: []
  type: TYPE_NORMAL
- en: 'Each call to *readdir()* reads the next directory entry from the directory
    stream referred to by *dirp* and returns a pointer to a statically allocated structure
    of type *dirent*, containing the following information about the entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This structure is overwritten on each call to *readdir()*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have omitted various nonstandard fields in the Linux *dirent* structure from
    the above definition, since their use renders an application nonportable. The
    most interesting of these nonstandard fields is *d_type*, which is also present
    on BSD derivatives, but not on other UNIX implementations. This field holds a
    value indicating the type of the file named in *d_name*, such as `DT_REG` (regular
    file), `DT_DIR` (directory), `DT_LNK` (symbolic link), or `DT_FIFO` (FIFO). (These
    names are analogous to the macros in [Table 15-1](ch15.html#macros_for_checking_file_types_in_the_st
    "Table 15-1. Macros for checking file types in the st_mode field of the stat structure"),
    in [File size, blocks allocated, and optimal I/O block size](ch15.html#file_size_comma_blocks_allocated_comma_a
    "File size, blocks allocated, and optimal I/O block size").) Using the information
    in this field saves the cost of calling *lstat()* in order to discover the file
    type. Note, however, that, at the time of writing, this field is fully supported
    only on *Btrfs*, *ext2*, *ext3*, and *ext4*.
  prefs: []
  type: TYPE_NORMAL
- en: Further information about the file referred to by *d_name* can be obtained by
    calling *lstat()* (or *stat()*, if a symbolic link should be dereferenced) on
    the pathname constructed using the *dirpath* argument that was specified to *opendir()*
    concatenated with (a slash and) the value returned in the *d_name* field.
  prefs: []
  type: TYPE_NORMAL
- en: The filenames returned by *readdir()* are not in sorted order, but rather in
    the order in which they happen to occur in the directory (this depends on the
    order in which the file system adds files to the directory and how it fills gaps
    in the directory list after files are removed). (The command *ls -f* lists files
    in the same unsorted order that they would be retrieved by *readdir()*.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use the function *scandir(3)* to retrieve a sorted list of files matching
    programmer-defined criteria; see the manual page for details. Although not specified
    in SUSv3, *scandir()* is provided on most UNIX implementations. SUSv4 added a
    specification for *scandir()*.
  prefs: []
  type: TYPE_NORMAL
- en: 'On end-of-directory or error, *readdir()* returns `NULL`, in the latter case
    setting *errno* to indicate the error. To distinguish these two cases, we can
    write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If the contents of a directory change while a program is scanning it with *readdir()*,
    the program might not see the changes. SUSv3 explicitly notes that it is unspecified
    whether *readdir()* will return a filename that has been added to or removed from
    the directory since the last call to *opendir()* or *rewinddir()*. All filenames
    that have been neither added nor removed since the last such call are guaranteed
    to be returned.
  prefs: []
  type: TYPE_NORMAL
- en: The *rewinddir()* function moves the directory stream back to the beginning
    so that the next call to *readdir()* will begin again with the first file in the
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The *closedir()* function closes the open directory stream referred to by *dirp*,
    freeing the resources used by the stream.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: Two further functions, *telldir()* and *seekdir()*, which are also specified
    in SUSv3, allow random access within a directory stream. Refer to the manual pages
    for further information about these functions.
  prefs: []
  type: TYPE_NORMAL
- en: Directory streams and file descriptors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A directory stream has an associated file descriptor. The *dirfd()* function
    returns the file descriptor associated with the directory stream referred to by
    *dirp*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns file descriptor on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: We might, for example, pass the file descriptor returned by *dirfd()* to *fchdir()*
    ([The Current Working Directory of a Process](ch18.html#the_current_working_directory_of_a_proce
    "The Current Working Directory of a Process")) in order to change the current
    working directory of the process to the corresponding directory. Alternatively,
    we might pass the file descriptor as the *dirfd* argument of one of the functions
    described in [Operating Relative to a Directory File Descriptor](ch18.html#operating_relative_to_a_directory_file_d
    "Operating Relative to a Directory File Descriptor").
  prefs: []
  type: TYPE_NORMAL
- en: The *dirfd()* function also appears on the BSDs, but is present on few other
    implementations. It is not specified in SUSv3, but is specified in SUSv4.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it is worth mentioning that *opendir()* automatically sets the
    close-on-exec flag (`FD_CLOEXEC`) for the file descriptor associated with the
    directory stream. This ensures that the file descriptor is automatically closed
    when an *exec()* is performed. (SUSv3 requires this behavior.) We describe the
    close-on-exec flag in Section 27.4.
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 18-2](ch18.html#scanning_a_directory "Example 18-2. Scanning a directory")
    uses *opendir()*, *readdir()*, and *closedir()* to list the contents of each of
    the directories specified in its command line (or in the current working directory
    if no arguments are supplied). Here is an example of the use of this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Example 18-2. Scanning a directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The *readdir_r()* function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *readdir_r()* function is a variation on *readdir()*. The key semantic difference
    between *readdir_r()* and *readdir()* is that the former is reentrant, while the
    latter is not. This is because *readdir_r()* returns the file entry via the caller-allocated
    *entry* argument, while *readdir()* returns information via a pointer to a statically
    allocated structure. We discuss reentrancy in [Reentrant and Async-Signal-Safe
    Functions](ch21.html#reentrant_and_async-signal-safe_function "Reentrant and Async-Signal-Safe
    Functions") and [Thread Safety (and Reentrancy Revisited)](ch31.html#thread_safety_open_parenthesis_and_reent
    "Thread Safety (and Reentrancy Revisited)").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or a positive error number on error
  prefs: []
  type: TYPE_NORMAL
- en: Given *dirp*, which is a directory stream previously opened via *opendir()*,
    *readdir_r()* places information about the next directory entry into the *dirent*
    structure referred to by *entry*. In addition, a pointer to this structure is
    placed in *result*. If the end of the directory stream is reached, then `NULL`
    is placed in *result* instead (and *readdir_r()* returns 0). On error, *readdir_r()*
    doesn’t return -1, but instead returns a positive integer corresponding to one
    of the *errno* values.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Linux, the *d_name* field of the *dirent* structure is sized as an array
    of 256 bytes, which is long enough to hold the largest possible filename. Although
    several other UNIX implementations define the same size for *d_name*, SUSv3 leaves
    this point unspecified, and some UNIX implementations instead define the field
    as a 1-byte array, leaving the calling program with the task of allocating a structure
    of the correct size. When doing this, we should size the *d_name* field as one
    greater (for the terminating null byte) than the value of the constant `NAME_MAX`.
    Portable applications should thus allocate the *dirent* structure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Using the `offsetof()` macro (defined in `<stddef.h>`) avoids any implementation-specific
    dependencies on the number and size of fields in the *dirent* structure preceding
    the *d_name* field (which is always the last field in the structure).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `offsetof()` macro takes two arguments—a structure type and the name of
    a field within that structure—and returns a value of type *size_t* that is the
    offset in bytes of the field from the beginning of the structure. This macro is
    necessary because a compiler may insert padding bytes in a structure to satisfy
    alignment requirements for types such as *int*, with the result that a field’s
    offset within a structure may be greater than the sum of the sizes of the fields
    that precede it.
  prefs: []
  type: TYPE_NORMAL
- en: 'File Tree Walking: *nftw()*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *nftw()* function allows a program to recursively walk through an entire
    directory subtree performing some operation (i.e., calling some programmer-defined
    function) for each file in the subtree.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *nftw()* function is an enhancement of the older *ftw()* function, which
    performs a similar task. New applications should use *nftw()* (*new ftw*) because
    it provides more functionality, and predictable handling of symbolic links (SUSv3
    permits *ftw()* either to follow or not follow symbolic links). SUSv3 specifies
    both *nftw()* and *ftw()*, but the latter function is marked obsolete in SUSv4.
  prefs: []
  type: TYPE_NORMAL
- en: The GNU C library also provides the BSD-derived *fts* API (*fts_open()*, *fts_read()*,
    *fts_children()*, *fts_set()*, and *fts_close()*). These functions perform a similar
    task to *ftw()* and *nftw()*, but offer greater flexibility to an application
    walking the tree. However, this API is not standardized and is provided on few
    UNIX implementations other than BSD descendants, so we omit discussion of it here.
  prefs: []
  type: TYPE_NORMAL
- en: The *nftw()* function walks through the directory tree specified by *dirpath*
    and calls the programmer-defined function *func* once for each file in the directory
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 after successful walk of entire tree, or -1 on error, or the first
    nonzero value returned by a call to *func*
  prefs: []
  type: TYPE_NORMAL
- en: By default, *nftw()* performs an unsorted, preorder traversal of the given tree,
    processing each directory before processing the files and subdirectories within
    that directory.
  prefs: []
  type: TYPE_NORMAL
- en: While traversing the directory tree, *nftw()* opens at most one file descriptor
    for each level of the tree. The *nopenfd* argument specifies the maximum number
    of file descriptors that *nftw()* may use. If the depth of the directory tree
    exceeds this maximum, *nftw()* does some bookkeeping, and closes and reopens descriptors
    in order to avoid holding open more than *nopenfd* descriptors simultaneously
    (and consequently runs more slowly). The need for this argument was greater under
    older UNIX implementations, some of which had a limit of 20 open file descriptors
    per process. Modern UNIX implementations allow a process to open a large number
    of file descriptors, and thus we can specify a generous number here (say 10 or
    more).
  prefs: []
  type: TYPE_NORMAL
- en: 'The *flags* argument to *nftw()* is created by ORing (`|`) zero or more of
    the following constants, which modify the operation of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FTW_CHDIR`'
  prefs: []
  type: TYPE_NORMAL
- en: Do a *chdir()* into each directory before processing its contents. This is useful
    if *func* is designed to do some work in the directory in which the file specified
    by its *pathname* argument resides.
  prefs: []
  type: TYPE_NORMAL
- en: '`FTW_DEPTH`'
  prefs: []
  type: TYPE_NORMAL
- en: Do a postorder traversal of the directory tree. This means that *nftw()* calls
    *func* on all of the files (and subdirectories) within a directory before executing
    *func* on the directory itself. (The name of this flag is somewhat misleading—*nftw()*
    always does a depth-first, rather than a breadth-first, traversal of the directory
    tree. All that this flag does is convert the traversal from preorder to postorder.)
  prefs: []
  type: TYPE_NORMAL
- en: '`FTW_MOUNT`'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t cross over into another file system. Thus, if one of the subdirectories
    of the tree is a mount point, it is not traversed.
  prefs: []
  type: TYPE_NORMAL
- en: '`FTW_PHYS`'
  prefs: []
  type: TYPE_NORMAL
- en: By default, *nftw()* dereferences symbolic links. This flag tells it not to
    do so. Instead, a symbolic link is passed to *func* with a *typeflag* value of
    `FTW_SL`, as described below.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each file, *nftw()* passes four arguments when calling *func*. The first
    of these arguments, *pathname*, is the pathname of the file. This pathname may
    be absolute, if *dirpath* was specified as an absolute pathname, or relative to
    the current working directory of the calling process at the time of the call to
    *ntfw()*, if *dirpath* was expressed as a relative pathname. The second argument,
    *statbuf*, is a pointer to a *stat* structure ([Retrieving File Information: *stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "Retrieving File Information: stat()")) containing information about this file.
    The third argument, *typeflag*, provides further information about the file, and
    has one of the following symbolic values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FTW_D`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a directory.
  prefs: []
  type: TYPE_NORMAL
- en: '`FTW_DNR`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a directory that can’t be read (and so *nftw()* doesn’t traverse any
    of its descendants).
  prefs: []
  type: TYPE_NORMAL
- en: '`FTW_DP`'
  prefs: []
  type: TYPE_NORMAL
- en: We are doing a postorder traversal (`FTW_DEPTH`) of a directory, and the current
    item is a directory whose files and subdirectories have already been processed.
  prefs: []
  type: TYPE_NORMAL
- en: '`FTW_F`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a file of any type other than a directory or symbolic link.
  prefs: []
  type: TYPE_NORMAL
- en: '`FTW_NS`'
  prefs: []
  type: TYPE_NORMAL
- en: Calling *stat()* on this file failed, probably because of permission restrictions.
    The value in *statbuf* is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: '`FTW_SL`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a symbolic link. This value is returned only if *nftw()* is called with
    the `FTW_PHYS` flag.
  prefs: []
  type: TYPE_NORMAL
- en: '`FTW_SLN`'
  prefs: []
  type: TYPE_NORMAL
- en: This item is a dangling symbolic link. This value occurs only if `FTW_PHYS`
    was not specified in the *flags* argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth argument to *func*, *ftwbuf*, is a pointer to a structure defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The *base* field of this structure is the integer offset of the filename part
    (the component after the last `/`) of the *pathname* argument of *func*. The *level*
    field is the depth of this item relative to the starting point of the traversal
    (which is level 0).
  prefs: []
  type: TYPE_NORMAL
- en: Each time it is called, *func* must return an integer value, and this value
    is interpreted by *nftw()*. Returning 0 tells *nftw()* to continue the tree walk,
    and if all calls to *func* return 0, *nftw()* itself returns 0 to its caller.
    Returning a nonzero value tells *nftw()* to immediately stop the tree walk, in
    which case *nftw()* returns the same nonzero value as its return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because *nftw()* uses dynamically allocated data structures, the only way that
    a program should ever prematurely terminate a directory tree walk is by returning
    a nonzero value from *func*. Using *longjmp()* ([Performing a Nonlocal Goto: *setjmp()*
    and *long jmp()*](ch06.html#performing_a_nonlocal_goto_colon_setjmp "Performing
    a Nonlocal Goto: setjmp() and long jmp()")) to exit from *func* may lead to unpredictable
    results—at the very least, memory leaks in a program.'
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 18-3](ch18.html#using_nftw_open_parenthesis_close_parent "Example 18-3. Using
    nftw() to walk a directory tree") demonstrates the use of *nftw()*.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-3. Using *nftw()* to walk a directory tree
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The program in [Example 18-3](ch18.html#using_nftw_open_parenthesis_close_parent
    "Example 18-3. Using nftw() to walk a directory tree") displays an indented hierarchy
    of the filenames in a directory tree, one file per line, as well as the file type
    and i-node number. Command-line options can be used to specify settings for the
    *flags* argument used to call *nftw()*. The following shell session shows examples
    of what we see when we run this program. We first create a new empty subdirectory,
    which we populate with various types of files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use our program to invoke *nftw()* with a *flags* argument of 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the above output, we can see that the symbolic link `s1` was resolved.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then use our program to invoke *nftw()* with a *flags* argument containing
    `FTW_PHYS` and `FTW_DEPTH`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: From the above output, we can see that the symbolic link `s1` was not resolved.
  prefs: []
  type: TYPE_NORMAL
- en: The *nftw()* `FTW_ACTIONRETVAL` flag
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Starting with version 2.3.3, *glibc* permits an additional, nonstandard flag
    to be specified in *flags*. This flag, `FTW_ACTIONRETVAL`, changes the way that
    *nftw()* interprets the return value from calls to *func()*. When this flag is
    specified, *func()* should return one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FTW_CONTINUE`'
  prefs: []
  type: TYPE_NORMAL
- en: Continue processing entries in the directory tree, as with the traditional 0
    return from *func()*.
  prefs: []
  type: TYPE_NORMAL
- en: '`FTW_SKIP_SIBLINGS`'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t process any further entries in the current directory; resume processing
    in the parent directory.
  prefs: []
  type: TYPE_NORMAL
- en: '`FTW_SKIP_SUBTREE`'
  prefs: []
  type: TYPE_NORMAL
- en: If *pathname* is a directory (i.e., *typeflag* is `FTW_D`), then don’t call
    *func()* for entries under that directory. Processing resumes with the next sibling
    of this directory.
  prefs: []
  type: TYPE_NORMAL
- en: '`FTW_STOP`'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t process any further entries in the directory tree, as with the traditional
    nonzero return from *func()*. The value `FTW_STOP` is returned to the caller of
    *nftw()*.
  prefs: []
  type: TYPE_NORMAL
- en: The `_GNU_SOURCE` feature test macro must be defined in order to obtain the
    definition of `FTW_ACTIONRETVAL` from `<ftw.h>`.
  prefs: []
  type: TYPE_NORMAL
- en: The Current Working Directory of a Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A process’s *current working directory* defines the starting point for the resolution
    of relative pathnames referred to by the process. A new process inherits its current
    working directory from its parent.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the current working directory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A process can retrieve its current working directory using *getcwd()*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns *cwdbuf* on success, or `NULL` on error
  prefs: []
  type: TYPE_NORMAL
- en: The *getcwd()* function places a null-terminated string containing the absolute
    pathname of the current working directory into the allocated buffer pointed to
    by *cwdbuf*. The caller must allocate the *cwdbuf* buffer to be at least *size*
    bytes in length. (Normally, we would size *cwdbuf* using the `PATH_MAX` constant.)
  prefs: []
  type: TYPE_NORMAL
- en: On success, *getcwd()* returns a pointer to *cwdbuf* as its function result.
    If the pathname for the current working directory exceeds *size* bytes, then *getcwd()*
    returns `NULL`, with *errno* set to `ERANGE`.
  prefs: []
  type: TYPE_NORMAL
- en: On Linux/x86-32, *getcwd()* returns a maximum of 4096 (`PATH_MAX`) bytes. If
    the current working directory (and *cwdbuf* and *size*) exceeds this limit, then
    the pathname is silently truncated, removing complete directory prefixes from
    the *beginning* of the string (which is still null-terminated). In other words,
    we can’t use *getcwd()* reliably when the length of the absolute pathname for
    the current working directory exceeds this limit.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In fact, the Linux *getcwd()* system call internally allocates a virtual memory
    page for the returned pathname. On the x86-32 architecture, the page size is 4096
    bytes, but on architectures with larger page sizes (e.g., Alpha with a page size
    of 8192 bytes), *getcwd()* can return larger pathnames.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the *cwdbuf* argument is `NULL` and *size* is 0, then the *glibc* wrapper
    function for *getcwd()* allocates a buffer as large as required and returns a
    pointer to that buffer as its function result. To avoid memory leaks, the caller
    must later deallocate this buffer with *free()*. Reliance on this feature should
    be avoided in portable applications. Most other implementations provide a simpler
    extension of the SUSv3 specification: if *cwdbuf* is `NULL`, then *getcwd()* allocates
    *size* bytes and uses this buffer to return the result to the caller. The *glibc
    getcwd()* implementation also provides this feature.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GNU C library also provides two other functions for obtaining the current
    working directory. The BSD-derived *getwd(path)* function is vulnerable to buffer
    overruns, since it provides no method of specifying an upper limit for the size
    of the returned pathname. The *get_current_dir_name()* function returns a string
    containing the current working directory name as its function result. This function
    is easy to use, but it is not portable. For security and portability, *getcwd()*
    is preferred over these two functions (as long as we avoid using the GNU extensions).
  prefs: []
  type: TYPE_NORMAL
- en: With suitable permissions (roughly, we own the process or have the `CAP_SYS_PTRACE`
    capability), we can determine the current working directory of any process by
    reading (*readlink()*) the contents of the Linux-specific `/proc/`*PID*`/cwd`
    symbolic link.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the current working directory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *chdir()* system call changes the calling process’s current working directory
    to the relative or absolute pathname specified in *pathname* (which is dereferenced
    if it is a symbolic link).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *fchdir()* system call does the same as *chdir()*, except that the directory
    is specified via a file descriptor previously obtained by opening the directory
    with *open()*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use *fchdir()* to change the process’s current working directory to
    another location, and then later return to the original location, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent using *chdir()* is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Operating Relative to a Directory File Descriptor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting with kernel 2.6.16, Linux provides a range of new system calls that
    perform similar tasks to various traditional system calls, but provide additional
    functionality that is useful to some applications. These system calls are summarized
    in [Table 18-2](ch18.html#system_calls_that_use_a_directory_file_d "Table 18-2. System
    calls that use a directory file descriptor to interpret relative pathnames").
    We describe these system calls in this chapter because they provide variations
    on the traditional semantics of the process’s current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: Table 18-2. System calls that use a directory file descriptor to interpret relative
    pathnames
  prefs: []
  type: TYPE_NORMAL
- en: '| New interface | Traditional analog | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *faccessat()* | *access()* | Supports `AT_EACCESS` and `AT_SYMLINK_NOFOLLOW`
    flags |'
  prefs: []
  type: TYPE_TB
- en: '| *fchmodat()* | *chmod()* |   |'
  prefs: []
  type: TYPE_TB
- en: '| *fchownat()* | *chown()* | Supports `AT_SYMLINK_NOFOLLOW` flag |'
  prefs: []
  type: TYPE_TB
- en: '| *fstatat()* | *stat()* | Supports `AT_SYMLINK_NOFOLLOW` flag |'
  prefs: []
  type: TYPE_TB
- en: '| *linkat()* | *link()* | Supports (since Linux 2.6.18) `AT_SYMLINK_FOLLOW`
    flag |'
  prefs: []
  type: TYPE_TB
- en: '| *mkdirat()* | *mkdir()* |   |'
  prefs: []
  type: TYPE_TB
- en: '| *mkfifoat()* | *mkfifo()* | Library function layered on top of `mknodat()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| *mknodat()* | *mknod()* |   |'
  prefs: []
  type: TYPE_TB
- en: '| *openat()* | *open()* |   |'
  prefs: []
  type: TYPE_TB
- en: '| *readlinkat()* | *readlink()* |   |'
  prefs: []
  type: TYPE_TB
- en: '| *renameat()* | *rename()* |   |'
  prefs: []
  type: TYPE_TB
- en: '| *symlinkat()* | *symlink()* |   |'
  prefs: []
  type: TYPE_TB
- en: '| *unlinkat()* | *unlink()* | Supports `AT_REMOVEDIR` flag |'
  prefs: []
  type: TYPE_TB
- en: '| *utimensat()* | *utimes()* | Supports `AT_SYMLINK_NOFOLLOW` flag |'
  prefs: []
  type: TYPE_TB
- en: 'In order to describe these system calls, we’ll use a specific example: *openat()*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns file descriptor on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: 'The *openat()* system call is similar to the traditional *open()* system call,
    but adds an argument, *dirfd*, that is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If *pathname* specifies a relative pathname, then it is interpreted relative
    to the directory referred to by the open file descriptor *dirfd*, rather than
    relative to the process’s current working directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *pathname* specifies a relative pathname, and *dirfd* contains the special
    value `AT_FDCWD`, then *pathname* is interpreted relative to the process’s current
    working directory (i.e., the same behavior as *open(2)*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *pathname* specifies an absolute pathname, then *dirfd* is ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *flags* argument of *openat()* serves the same purpose as for *open()*.
    However, some of the system calls listed in [Table 18-2](ch18.html#system_calls_that_use_a_directory_file_d
    "Table 18-2. System calls that use a directory file descriptor to interpret relative
    pathnames") support a *flags* argument that is not provided by the corresponding
    traditional system call, and the purpose of this argument is to modify the semantics
    of the call. The most frequently provided flag is `AT_SYMLINK_NOFOLLOW`, which
    specifies that if *pathname* is a symbolic link, then the system call should operate
    on the link, rather than the file to which it refers. (The *linkat()* system call
    provides the `AT_SYMLINK_FOLLOW` flag, which performs the converse action, changing
    the default behavior of *linkat()* so that it dereferences *oldpath* if it is
    a symbolic link.) For details of the other flags, refer to the corresponding manual
    pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system calls listed in [Table 18-2](ch18.html#system_calls_that_use_a_directory_file_d
    "Table 18-2. System calls that use a directory file descriptor to interpret relative
    pathnames") are supported for two reasons (again, we explain using the example
    of *openat()*):'
  prefs: []
  type: TYPE_NORMAL
- en: Using *openat()* allows an application to avoid certain race conditions that
    can occur when *open()* is used to open files in locations other than the current
    working directory. These races can occur because some component of the directory
    prefix of *pathname* could be changed in parallel with the *open()* call. By opening
    a file descriptor for the target directory, and passing that descriptor to *openat()*,
    such races can be avoided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 29](ch29.html "Chapter 29. Threads: Introduction"), we’ll see that
    the working directory is a process attribute that is shared by all threads of
    the process. For some applications, it is useful for different threads to have
    different “virtual” working directories. An application can emulate this functionality
    using *openat()* in conjunction with directory file descriptors maintained by
    the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These system calls are not standardized in SUSv3, but are included in SUSv4\.
    In order to expose the declaration of each of these system calls, the `_XOPEN_SOURCE`
    feature test macro must be defined with a value greater than or equal to 700 before
    including the appropriate header file (e.g., `<fcntl.h>` for *open()*). Alternatively,
    the `_POSIX_C_SOURCE` macro can be defined with a value greater than or equal
    to 200809\. (Before *glibc* 2.10, the `_ATFILE_SOURCE` macro needed to be defined
    to expose the declarations of these system calls.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Solaris 9 and later provide versions of some of the interfaces listed in [Table 18-2](ch18.html#system_calls_that_use_a_directory_file_d
    "Table 18-2. System calls that use a directory file descriptor to interpret relative
    pathnames"), with slightly different semantics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the Root Directory of a Process: *chroot()*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every process has a *root directory*, which is the point from which absolute
    pathnames (i.e., those beginning with /) are interpreted. By default, this is
    the real root directory of the file system. (A new process inherits its parent’s
    root directory.) On occasion, it is useful for a process to change its root directory,
    and a privileged (`CAP_SYS_CHROOT`) process can do this using the *chroot()* system
    call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *chroot()* system call changes the process’s root directory to the directory
    specified by *pathname* (which is dereferenced if it is a symbolic link). Thereafter,
    all absolute pathnames are interpreted as starting from that location in the file
    system. This is sometimes referred to as setting up a *chroot* jail, since the
    program is then confined to a particular area of the file system.
  prefs: []
  type: TYPE_NORMAL
- en: SUSv2 contained a specification for *chroot()* (marked LEGACY), but this was
    removed in SUSv3\. Nevertheless, *chroot()* appears on most UNIX implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *chroot()* system call is employed by the *chroot* command, which enables
    us to execute shell commands in a *chroot* jail.
  prefs: []
  type: TYPE_NORMAL
- en: The root directory of any process can be found by reading (*readlink()*) the
    contents of the Linux-specific `/proc/`*PID*`/root` symbolic link.
  prefs: []
  type: TYPE_NORMAL
- en: The classic example of the use of *chroot()* is in the *ftp* program. As a security
    measure, when a user logs in anonymously under FTP, the *ftp* program uses *chroot()*
    to set the root directory for the new process to the directory specifically reserved
    for anonymous logins. After the chroot() call, the user is limited to the file-system
    subtree under their new root directory, so they can’t roam around the entire file
    system. (This relies on the fact that the root directory is its own parent; that
    is, `/..` is a link to `/`, so that changing directory to `/` and then attempting
    a *cd ..* leaves the user in the same directory.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some UNIX implementations (but not Linux) allow multiple hard links to a directory,
    so that it is possible to create a hard link within a subdirectory to its parent
    (or a further removed ancestor). On implementations permitting this, the presence
    of a hard link that reaches outside the jail directory tree compromises the jail.
    Symbolic links to directories outside the jail don’t pose a problem—because they
    are interpreted within the framework of the process’s new root directory, they
    can’t reach outside the *chroot* jail.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, we can’t execute arbitrary programs within a *chroot* jail. This is
    because most programs are dynamically linked against shared libraries. Therefore,
    we must either limit ourselves to executing statically linked programs, or replicate
    a standard set of system directories containing shared libraries (including, for
    example, `/lib` and `/usr/lib`) within the jail (in this regard, the bind mount
    feature described in [Bind Mounts](ch14.html#bind_mounts "Bind Mounts") can be
    useful).
  prefs: []
  type: TYPE_NORMAL
- en: The *chroot()* system call was not conceived as a completely secure jail mechanism.
    To begin with, there are various ways in which a privileged program can subsequently
    use a further *chroot()* call to break out of the jail. For example, a privileged
    (`CAP_MKNOD`) program can use *mknod()* to create a memory device file (similar
    to `/dev/mem`) giving access to the contents of RAM, and, from that point, anything
    is possible. In general, it is advisable not to include set-user-ID-*root* programs
    within a *chroot* jail file system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even with unprivileged programs, we must take care to prevent the following
    possible routes for breaking out of a *chroot* jail:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling *chroot()* doesn’t change the process’s current working directory. Thus,
    a call to *chroot()* is typically preceded or followed by a call to *chdir()*
    (e.g., *chdir*(“/”) after the *chroot()* call). If this is not done, then a process
    can use relative pathnames to access files and directories outside the jail. (Some
    BSD derivatives prevent this possibility—if the current working directory lies
    outside the new root directory tree, then it is changed by the *chroot()* call
    to be the same as the root directory.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If a process holds an open file descriptor for a directory outside the jail,
    then the combination of *fchdir()* plus *chroot()* can be used to break out of
    the jail, as shown in the following code sample:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To prevent this possibility, we must close all open file descriptors referring
    to directories outside the jail. (Some other UNIX implementations provide the
    *fchroot()* system call, which can be used to achieve a similar result to the
    above code snippet.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Even preventing the preceding possibilities is insufficient to stop an arbitrary
    unprivileged program (i.e., one whose operation we don’t have control over) from
    breaking out of the jail. The jailed process can still use a UNIX domain socket
    to receive a file descriptor (from another process) referring to a directory outside
    the jail. (We briefly explain the concept of passing file descriptors between
    processes via a socket in [Passing File Descriptors](ch61.html#passing_file_descriptors
    "Passing File Descriptors").) By specifying this file descriptor in a call to
    *fchdir()*, the program can set its current working directory outside the jail
    and then access arbitrary files and directories using relative pathnames.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some BSD derivatives provide a *jail()* system call, which addresses the points
    described above, as well as several others, to create a jail that is secure even
    for a privileged process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Resolving a Pathname: *realpath()*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *realpath()* library function dereferences all symbolic links in *pathname*
    (a null-terminated string) and resolves all references to /. and /.. to produce
    a null-terminated string containing the corresponding absolute pathname.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns pointer to resolved pathname on success, or `NULL` on error
  prefs: []
  type: TYPE_NORMAL
- en: The resulting string is placed in the buffer pointed to by *resolved_path*,
    which should be a character array of at least `PATH_MAX` bytes. On success, *realpath()*
    also returns a pointer to this resolved string.
  prefs: []
  type: TYPE_NORMAL
- en: The *glibc* implementation of *realpath()* allows the caller to specify *resolved_path*
    as `NULL`. In this case, *realpath()* allocates a buffer of up to `PATH_MAX` bytes
    for the resolved pathname and returns a pointer to that buffer as the function
    result. (The caller must deallocate this buffer using *free()*.) SUSv3 doesn’t
    specify this extension, but it is specified in SUSv4.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program in [Example 18-4](ch18.html#read_and_resolve_a_symbolic_link "Example 18-4. Read
    and resolve a symbolic link") uses *readlink()* and *realpath()* to read the contents
    of a symbolic link and to resolve the link to an absolute pathname. Here is an
    example of the use of this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Example 18-4. Read and resolve a symbolic link
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Parsing Pathname Strings: *dirname()* and *basename()*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *dirname()* and *basename()* functions break a pathname string into directory
    and filename parts. (These functions perform a similar task to the *dirname(1)*
    and *basename(1)* commands.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both return a pointer to a null-terminated (and possibly statically allocated)
    string
  prefs: []
  type: TYPE_NORMAL
- en: For example, given the pathname `/home/britta/prog.c`, *dirname()* returns `/home/britta`
    and *basename()* returns `prog.c`. Concatenating the string returned by *dirname()*,
    a slash (`/`), and the string returned by *basename()* yields a complete pathname.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following points regarding the operation of *dirname()* and *basename()*:'
  prefs: []
  type: TYPE_NORMAL
- en: Trailing slash characters in *pathname* are ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *pathname* doesn’t contain a slash, then *dirname()* returns the string `.`
    (dot) and *basename()* returns *pathname*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *pathname* consists of just a slash, then both *dirname()* and *basename()*
    return the string `/`. Applying the concatenation rule above to create a pathname
    from these returned strings would yield the string `///`. This *is* a valid pathname.
    Because multiple consecutive slashes are equivalent to a single slash, the pathname
    `///` is equivalent to the pathname `/`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *pathname* is a `NULL` pointer or an empty string, then both *dirname()*
    and *basename()* return the string `.` (dot). (Concatenating these strings yields
    the pathname `./.`, which is equivalent to `.`, the current directory.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Table 18-3](ch18.html#examples_of_strings_returned_by_dirname "Table 18-3. Examples
    of strings returned by dirname() and basename()") shows the strings returned by
    *dirname()* and *basename()* for various example pathnames.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 18-3. Examples of strings returned by *dirname()* and *basename()*
  prefs: []
  type: TYPE_NORMAL
- en: '| Pathname string | *dirname()* | *basename()* |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | `/` | `/` |'
  prefs: []
  type: TYPE_TB
- en: '| `/usr/bin/zip` | `/usr/bin` | `zip` |'
  prefs: []
  type: TYPE_TB
- en: '| `/etc/passwd////` | `/etc` | `passwd` |'
  prefs: []
  type: TYPE_TB
- en: '| `/etc////passwd` | `/etc` | `passwd` |'
  prefs: []
  type: TYPE_TB
- en: '| `etc/passwd` | `etc` | `passwd` |'
  prefs: []
  type: TYPE_TB
- en: '| `passwd` | `.` | `passwd` |'
  prefs: []
  type: TYPE_TB
- en: '| `passwd/` | `.` | `passwd` |'
  prefs: []
  type: TYPE_TB
- en: '| `..` | `.` | `..` |'
  prefs: []
  type: TYPE_TB
- en: '| `NULL` | `.` | `.` |'
  prefs: []
  type: TYPE_TB
- en: Example 18-5. Using *dirname()* and *basename()*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Both *dirname()* and *basename()* may modify the string pointed to by *pathname*.
    Therefore, if we wish to preserve a pathname string, we must pass copies of it
    to *dirname()* and *basename()*, as shown in [Example 18-5](ch18.html#using_dirname_open_parenthesis_close_par
    "Example 18-5. Using dirname() and basename()") (page 371). This program uses
    *strdup()* (which calls *malloc()*) to make copies of the strings to be passed
    to *dirname()* and *basename()*, and then uses *free()* to deallocate the duplicate
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, note that both *dirname()* and *basename()* can return pointers to
    statically allocated strings that may be modified by future calls to the same
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An i-node doesn’t contain a file’s name. Instead, files are assigned names via
    entries in directories, which are tables listing filename and i-node number correspondences.
    These directory entries are called (hard) links. A file may have multiple links,
    all of which enjoy equal status. Links are created and removed using *link()*
    and *unlink()*. A file can be renamed using the *rename()* system call.
  prefs: []
  type: TYPE_NORMAL
- en: 'A symbolic (or soft) link is created using *symlink()*. Symbolic links are
    similar to hard links in some respects, with the differences that symbolic links
    can cross file-system boundaries and can refer to directories. A symbolic link
    is just a file containing the name of another file; this name may be retrieved
    using *readlink()*. A symbolic link is not included in the (target) i-node’s link
    count, and it may be left dangling if the filename to which it refers is removed.
    Some system calls automatically dereference (follow) symbolic links; others do
    not. In some cases, two versions of a system call are provided: one that dereferences
    symbolic links and another that does not. Examples are *stat()* and *lstat()*.'
  prefs: []
  type: TYPE_NORMAL
- en: Directories are created with *mkdir()* and removed using *rmdir()*. To scan
    the contents of a directory, we can use *opendir()*, *readdir()*, and related
    functions. The *nftw()* function allows a program to walk an entire directory
    tree, calling a programmer-defined function to operate on each file in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: The *remove()* function can be used to remove a file (i.e., a link) or an empty
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Each process has a root directory, which determines the point from which absolute
    pathnames are interpreted, and a current working directory, which determines the
    point from which relative pathnames are interpreted. The *chroot()* and *chdir()*
    system calls are used to change these attributes. The *getcwd()* function returns
    a process’s current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: Linux provides a set of system calls (e.g., *openat()*) that behave like their
    traditional counterparts (e.g., *open()*), except that relative pathnames can
    be interpreted with respect to the directory specified by a file descriptor supplied
    to the call (instead of using the process’s current working directory). This is
    useful for avoiding certain types of race conditions and for implementing per-thread
    virtual working directories.
  prefs: []
  type: TYPE_NORMAL
- en: The *realpath()* function resolves a pathname—dereferencing all symbolic links
    and resolving all references to . and .. to corresponding directories—to yield
    a corresponding absolute pathname. The *dirname()* and *basename()* functions
    can be used to parse a pathname into directory and filename components.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [The *open() flags* Argument](ch04.html#the_open_open_parenthesis_close_parenthe
    "The open() flags Argument"), we noted that it is not possible to open a file
    for writing if it is currently being executed (*open()* returns -1, with *errno*
    set to `ETXTBSY`). Nevertheless, it is possible to do the following from the shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last command overwrites the existing executable of the same name. How is
    this possible? (For a clue, use *ls -li* to look at the i-node number of the executable
    file after each compilation.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Why does the call to *chmod()* in the following code fail?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implement *realpath()*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the program in [Example 18-2](ch18.html#scanning_a_directory "Example 18-2. Scanning
    a directory") (`list_files.c`) to use *readdir_r()* instead of *readdir()*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a function that performs the equivalent of *getcwd()*. A useful tip
    for solving this problem is that you can find the name of the current working
    directory by using *opendir()* and *readdir()* to walk through each of the entries
    in the parent directory (`..`) to find an entry with the same i-node and device
    number as the current working directory (i.e., respectively, the *st_ino* and
    *st_dev* fields in the *stat* structure returned by *stat()* and *lstat()*). Thus,
    it is possible to construct the directory path by walking up the directory tree
    (*chdir(“..”)*) one step at a time and performing such scans. The walk can be
    finished when the parent directory is the same as the current working directory
    (recall that `/..` is the same as `/`). The caller should be left in the same
    directory in which it started, regardless of whether your *getcwd()* function
    succeeds or fails (*open()* plus *fchdir()* are handy for this purpose).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the program in [Example 18-3](ch18.html#using_nftw_open_parenthesis_close_parent
    "Example 18-3. Using nftw() to walk a directory tree") (`nftw_dir_tree.c`) to
    use the `FTW_DEPTH` flag. Note the difference in the order in which the directory
    tree is traversed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program that uses *nftw()* to traverse a directory tree and finishes
    by printing out counts and percentages of the various types (regular, directory,
    symbolic link, and so on) of files in the tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement *nftw()*. (This will require the use of the *opendir()*, *readdir()*,
    *closedir()*, and *stat()* system calls, among others.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In [The Current Working Directory of a Process](ch18.html#the_current_working_directory_of_a_proce
    "The Current Working Directory of a Process"), we showed two different techniques
    (using *fchdir()* and *chdir()*, respectively) to return to the previous current
    working directory after changing the current working directory to another location.
    Suppose we are performing such an operation repeatedly. Which method do you expect
    to be more efficient? Why? Write a program to confirm your answer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
