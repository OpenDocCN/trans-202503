<html><head></head><body>
<h2 class="h2" id="ch11"><span class="big"><strong>11</strong></span><br/><strong>WRITING FUNCTIONS</strong></h2>&#13;
<div class="image"><img src="../images/common-01.jpg" alt="image"/></div>&#13;
<p class="noindent">Defining a function allows you to reuse a chunk of code without endlessly copying and pasting. It also allows other users to use your functions to carry out the same computations on their own data or objects. In this chapter, you’ll learn about writing your own R functions. You’ll learn how to define and use arguments, how to return output from a function, and how to specialize your functions in other ways.</p>&#13;
<h3 class="h3" id="ch11lev1sec36"><strong>11.1 The function Command</strong></h3>&#13;
<p class="noindent">To define a function, use the <code>function</code> command and assign the results to an object name. Once you’ve done this, you can call the function using that object name just like any other built-in or contributed function in the workspace. This section will walk you through the basics of function creation and discuss some associated issues, such as returning objects and specifying arguments.</p>&#13;
<h4 class="h4" id="ch11lev2sec97"><span epub:type="pagebreak" id="page_216"/><strong><em>11.1.1 Function Creation</em></strong></h4>&#13;
<p class="noindent">A function definition always follows this standard format:</p>&#13;
<pre><span class="codeitalic">functionname</span> &lt;- function(<span class="codeitalic">arg1</span>,<span class="codeitalic">arg2</span>,<span class="codeitalic">arg3</span>,...){<br/>    <span class="codeitalic">do any code in here when called</span><br/>    return(<span class="codeitalic">returnobject</span>)<br/>}</pre>&#13;
<p class="indent">The <code><span class="codeitalic">functionname</code></span> placeholder can be any valid R object name, which is what you’ll ultimately use to call the function. Assign to this <code><span class="codeitalic">functionname</code></span> a call to <code>function</code>, followed by parentheses with any arguments you want the function to have. The pseudocode includes three argument placeholders plus an ellipsis. Of course, the number of arguments, their tags, and whether to include an ellipsis all depend on the particular function you’re defining. If the function does not require any arguments, simply include empty parentheses: <code>()</code>. If you do include arguments in this definition, note that they are not objects in the workspace and they do not have any type or <code>class</code> attributes associated with them—they are merely a declaration of argument names that will be required by <code><span class="codeitalic">functionname</code></span>.</p>&#13;
<p class="indent">When the function is called, it runs the code in the braced area (also called the <em>function body</em> or <em>body code</em>). It can include <code>if</code> statements, loops, and even other function calls. When encountering an internal function call during execution, R follows the search rules discussed in <a href="ch09.xhtml#ch09">Chapter 9</a>. In the braced area, you can use <code><span class="codeitalic">arg1</code></span>, <code><span class="codeitalic">arg2</code></span>, and <code><span class="codeitalic">arg3</code></span>, and they are treated as objects in the function’s lexical environment.</p>&#13;
<p class="indent">Depending on how those declared arguments are used in the body code, each argument may require a certain data type and object structure. If you’re writing functions that you intend for others to use, it’s important to have sound documentation to say what the function expects.</p>&#13;
<p class="indent">Often, the function body will include one or more calls to the <code>return</code> command. When R encounters a <code>return</code> statement during execution, the function exits, returning control to the user at the command prompt. This mechanism is what allows you to pass results from operations in the function back to the user. This output is denoted in the pseudocode by <code><span class="codeitalic">returnobject</code></span>, which is typically assigned an object created or calculated earlier in the function body. If there is no <code>return</code> statement, the function will simply return the object created by the last executed expression (I’ll discuss this feature more in <a href="ch11.xhtml#ch11lev2sec98">Section 11.1.2</a>).</p>&#13;
<p class="indent">It’s time for an example. Let’s take the Fibonacci sequence generator from <a href="ch10.xhtml#ch10lev2sec96">Section 10.3.2</a> and turn it into a function in the editor.</p>&#13;
<pre>myfib &lt;- function(){<br/>    fib.a &lt;- 1<br/>    fib.b &lt;- 1<br/>    cat(fib.a,", ",fib.b,", ",sep="")<br/>    repeat{<br/>        temp &lt;- fib.a+fib.b<br/>        fib.a &lt;- fib.b<br/>        fib.b &lt;- temp<br/>        cat(fib.b,", ",sep="")<br/>        if(fib.b&gt;150){<br/>            cat("BREAK NOW...")<br/>            break<br/>        }<br/>    }<br/>}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_217"/>I’ve named the function <code>myfib</code>, and it doesn’t use or require any arguments. The body code is identical to the example in <a href="ch10.xhtml#ch10lev2sec96">Section 10.3.2</a>, except I’ve added the third line, <code>cat(fib.a,", ",fib.b,", ",sep="")</code>, to ensure the first two terms, 1 and 1, are also printed to the screen.</p>&#13;
<p class="indent">Before you can call <code>myfib</code> from the console, you have to send the function definition there. Highlight the code in the editor and press <small>CTRL</small>-R or <img class="middle" src="../images/common-02.jpg" alt="image"/>-<small>RETURN</small>.</p>&#13;
<pre>R&gt; myfib &lt;- function(){<br/>+   fib.a &lt;- 1<br/>+   fib.b &lt;- 1<br/>+   cat(fib.a,", ",fib.b,", ",sep="")<br/>+   repeat{<br/>+       temp &lt;- fib.a+fib.b<br/>+       fib.a &lt;- fib.b<br/>+       fib.b &lt;- temp<br/>+       cat(fib.b,", ",sep="")<br/>+       if(fib.b&gt;150){<br/>+           cat("BREAK NOW...")<br/>+           break<br/>+       }<br/>+   }<br/>+ }</pre>&#13;
<p class="indent">This imports the function into the workspace (if you enter <code>ls()</code> at the command prompt, <code>"myfib"</code> will now appear in the list of present objects). This step is required anytime you create or modify a function and want to use it from the command prompt.</p>&#13;
<p class="indent">Now you can call the function from the console.</p>&#13;
<pre>R&gt; myfib()<br/>1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, BREAK NOW...</pre>&#13;
<p class="indent">It computes and prints the Fibonacci sequence up to 250, just as instructed.</p>&#13;
<h5 class="h5" id="ch11lev3sec27"><span epub:type="pagebreak" id="page_218"/><strong>Adding Arguments</strong></h5>&#13;
<p class="noindent">Rather than printing a fixed set of terms, let’s add an argument to control how many Fibonacci numbers are printed. Consider the following new function, <code>myfib2</code>, with this modification:</p>&#13;
<pre>myfib2 &lt;- function(thresh){<br/>    fib.a &lt;- 1<br/>    fib.b &lt;- 1<br/>    cat(fib.a,", ",fib.b,", ",sep="")<br/>    repeat{<br/>        temp &lt;- fib.a+fib.b<br/>        fib.a &lt;- fib.b<br/>        fib.b &lt;- temp<br/>        cat(fib.b,", ",sep="")<br/>        if(fib.b&gt;thresh){<br/>            cat("BREAK NOW...")<br/>            break<br/>        }<br/>    }<br/>}</pre>&#13;
<p class="indent">This version now takes a single argument, <code>thresh</code>. In the body code, <code>thresh</code> acts as a threshold determining when to end the <code>repeat</code> procedure, halt printing, and complete the function—once a value of <code>fib.b</code> that is greater than <code>thresh</code> is calculated, the <code>repeat</code> statement will exit after encountering the call to <code>break</code>. Therefore, the output printed to the console will be the Fibonacci sequence up to and including the first <code>fib.b</code> value bigger than <code>thresh</code>. This means that <code>thresh</code> must be supplied as a single numeric value—supplying a character string, for example, would make no sense.</p>&#13;
<p class="indent">After importing the definition of <code>myfib2</code> into the console, note the same results as given by the original <code>myfib</code> when you set <code>thresh=150</code>.</p>&#13;
<pre>R&gt; myfib2(thresh=150)<br/>1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, BREAK NOW...</pre>&#13;
<p class="indent">But now you can print the sequence to any limit you want (this time using positional matching to specify the argument):</p>&#13;
<pre>R&gt; myfib2(1000000)<br/>1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584,<br/>4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811,<br/>514229, 832040, 1346269, BREAK NOW...</pre>&#13;
<h5 class="h5" id="ch11lev3sec28"><strong>Returning Results</strong></h5>&#13;
<p class="noindent">If you want to use the results of a function in future operations (rather than just printing output to the console), you need to return content to the user. <span epub:type="pagebreak" id="page_219"/>Continuing with the current example, here’s a Fibonacci function that stores the sequence in a vector and returns it:</p>&#13;
<pre>myfib3 &lt;- function(thresh){<br/>    fibseq &lt;- c(1,1)<br/>    counter &lt;- 2<br/>    repeat{<br/>        fibseq &lt;- c(fibseq,fibseq[counter-1]+fibseq[counter])<br/>        counter &lt;- counter+1<br/>        if(fibseq[counter]&gt;thresh){<br/>            break<br/>        }<br/>    }<br/>    return(fibseq)<br/>}</pre>&#13;
<p class="indent">First you create the vector <code>fibseq</code> and assign it the first two terms of the sequence. This vector will ultimately become the <code><span class="codeitalic">returnobject</code></span>. You also create a <code>counter</code> initialized to <code>2</code> to keep track of the current position in <code>fibseq</code>. Then the function enters a <code>repeat</code> statement, which overwrites <code>fibseq</code> with <code>c(fibseq,fibseq[counter-1]+fibseq[counter])</code>. That expression constructs a new <code>fibseq</code> by appending the sum of the most recent two terms to the contents of what is already stored in <code>fibseq</code>. For example, with <code>counter</code> starting at <code>2</code>, the first run of this line will sum <code>fibseq[1]</code> and <code>fibseq[2]</code>, appending the result as a third entry onto the original <code>fibseq</code>.</p>&#13;
<p class="indent">Next, <code>counter</code> is incremented, and the condition is checked. If the most recent value of <code>fibseq[counter]</code> is not greater than <code>thresh</code>, the loop repeats. If it is greater, the loop breaks, and you reach the final line of <code>myfib3</code>. Calling <code>return</code> ends the function and passes out the specified <code><span class="codeitalic">returnobject</code></span> (in this case, the final contents of <code>fibseq</code>).</p>&#13;
<p class="indent">After importing <code>myfib3</code>, consider the following code:</p>&#13;
<pre>R&gt; myfib3(150)<br/> [1]   1   1   2   3   5   8  13  21  34  55  89 144 233<br/>R&gt; foo &lt;- myfib3(10000)<br/>R&gt; foo<br/> [1]     1     1     2     3     5     8    13     21    34   55   89   144<br/>[13]   233   377   610   987  1597  2584  4181   6765 10946<br/>R&gt; bar &lt;- foo[1:5]<br/>R&gt; bar<br/>[1] 1 1 2 3 5</pre>&#13;
<p class="indent">Here, the first line calls <code>myfib3</code> with <code>thresh</code> assigned <code>150</code>. The output is still printed to the screen, but this isn’t the result of the <code>cat</code> command as it was earlier; it is the <code><span class="codeitalic">returnobject</code></span>. You can assign this <code><span class="codeitalic">returnobject</code></span> to a variable, such as <code>foo</code>, and <code>foo</code> is now just another R object in the global environment that you can manipulate. For example, you use it to create <code>bar</code> with a simple vector subset. This would not have been possible with either <code>myfib</code> or <code>myfib2</code>.</p>&#13;
<h4 class="h4" id="ch11lev2sec98"><span epub:type="pagebreak" id="page_220"/><strong><em>11.1.2 Using return</em></strong></h4>&#13;
<p class="noindent">If there’s no <code>return</code> statement inside a function, the function will end when the last line in the body code has been run, at which point it will return the most recently assigned or created object in the function. If nothing is created, such as in <code>myfib</code> and <code>myfib2</code> from earlier, the function returns <code>NULL</code>. To demonstrate this point, enter the following two dummy functions in the editor:</p>&#13;
<pre>dummy1 &lt;- function(){<br/>    aa &lt;- 2.5<br/>    bb &lt;- "string me along"<br/>    cc &lt;- "string 'em up"<br/>    dd &lt;- 4:8<br/>}<br/><br/>dummy2 &lt;- function(){<br/>    aa &lt;- 2.5<br/>    bb &lt;- "string me along"<br/>    cc &lt;- "string 'em up"<br/>    dd &lt;- 4:8<br/>    return(dd)<br/>}</pre>&#13;
<p class="indent">The first function, <code>dummy1</code>, simply assigns four different objects in its lexical environment (not the global environment) and doesn’t explicitly return anything. On the other hand, <code>dummy2</code> creates the same four objects and explicitly returns the last one, <code>dd</code>. If you import and run the two functions, both provide the same return object.</p>&#13;
<pre>R&gt; foo &lt;- dummy1()<br/>R&gt; foo<br/>[1] 4 5 6 7 8<br/>R&gt; bar &lt;- dummy2()<br/>R&gt; bar<br/>[1] 4 5 6 7 8</pre>&#13;
<p class="indent">A function will end as soon as it evaluates a <code>return</code> command, without executing any remaining code in the function body. To emphasize this, consider one more version of the dummy function:</p>&#13;
<pre>dummy3 &lt;- function(){<br/>    aa &lt;- 2.5<br/>    bb &lt;- "string me along"<br/>    return(aa)<br/>    cc &lt;- "string 'em up"<br/>    dd &lt;- 4:8<br/>    return(bb)<br/>}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_221"/>Here, <code>dummy3</code> has two calls to return: one in the middle and one at the end. But when you import and execute the function, it returns only one value.</p>&#13;
<pre>R&gt; baz &lt;- dummy3()<br/>R&gt; baz<br/>[1] 2.5</pre>&#13;
<p class="indent">Executing <code>dummy3</code> returns only the object <code>aa</code> because only the first instance of <code>return</code> is executed and the function exits immediately at that point. In the current definition of <code>dummy3</code>, the last three lines (the assignment of <code>cc</code> and <code>dd</code> and the <code>return</code> of <code>bb</code>) will never be executed.</p>&#13;
<p class="indent">Using <code>return</code> adds another function call to your code, so technically, it introduces a little extra computational expense. Because of this, some argue that <code>return</code> statements should be avoided unless absolutely necessary. But the additional computational cost of the call to <code>return</code> is small enough to be negligible for most purposes. Plus, <code>return</code> statements can make code more readable, making it easier to see where the author of a function intends it to complete and precisely what is intended to be supplied as output. I’ll use <code>return</code> throughout the remainder of this work.</p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch11exc1"/><strong>Exercise 11.1</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Write another Fibonacci sequence function, naming it <code>myfib4</code>. This function should provide an option to perform either the operations available in <code>myfib2</code>, where the sequence is simply printed to the console, or the operations in <code>myfib3</code>, where a vector of the sequence is formally returned. Your function should take two arguments: the first, <code>thresh</code>, should define the limit of the sequence (just as in <code>myfib2</code> or <code>myfib3</code>); the second, <code>printme</code>, should be a logical value. If <code>TRUE</code>, then <code>myfib4</code> should just print; if <code>FALSE</code>, then <code>myfib4</code> should return a vector. Confirm the correct results arise from the following calls:</p>&#13;
<p class="dash">– <code>myfib4(thresh=150,printme=TRUE)</code></p>&#13;
<p class="dash">– <code>myfib4(1000000,T)</code></p>&#13;
<p class="dash">– <code>myfib4(150,FALSE)</code></p>&#13;
<p class="dash">– <code>myfib4(1000000,printme=F)</code></p></li>&#13;
<li><p class="noindents">In <a href="ch10.xhtml#ch10exc4">Exercise 10.4</a> on <a href="ch10.xhtml#page_203">page 203</a>, you were tasked with writing a <code>while</code> loop to perform integer factorial calculations.</p>&#13;
<ol type="i">&#13;
<li><p class="noindents">Using your factorial <code>while</code> loop (or writing one if you didn’t do so earlier), write your own R function, <code>myfac</code>, to compute the factorial of an integer argument <code>int</code> (you may assume <code>int</code> <span epub:type="pagebreak" id="page_222"/>will always be supplied as a non-negative integer). Perform a quick test of the function by computing 5 factorial, which is 120; 12 factorial, which is 479,001,600; and 0 factorial, which is 1.</p></li>&#13;
<li><p class="noindents">Write another version of your factorial function, naming it <code>myfac2</code>. This time, you may still assume <code>int</code> will be supplied as an integer but not that it will be non-negative. If negative, the function should return <code>NaN</code>. Test <code>myfac2</code> on the same three values as previously, but also try using <code>int=-6</code>.</p></li>&#13;
</ol></li>&#13;
</ol>&#13;
</div>&#13;
<h3 class="h3" id="ch11lev1sec37"><strong>11.2 Arguments</strong></h3>&#13;
<p class="noindent">Arguments are an essential part of most R functions. In this section, you’ll consider how R evaluates arguments. You’ll also see how to write functions that have default argument values, how to make functions handle missing argument values, and how to pass extra arguments into an internal function call with ellipses.</p>&#13;
<h4 class="h4" id="ch11lev2sec99"><strong><em>11.2.1 Lazy Evaluation</em></strong></h4>&#13;
<p class="noindent">An important concept related to handling arguments in many high-level programming languages is <em>lazy evaluation</em>. Generally, this refers to the fact that expressions are evaluated only when they are needed. This applies to arguments in the sense that they are accessed and used only at the point they appear in the function body.</p>&#13;
<p class="indent">Let’s see exactly how R functions recognize and use arguments during execution. As a working example to be used throughout this section, you’ll write a function to search through a specified list for matrix objects and attempt to post-multiply each with another matrix specified as a second argument (refer back to <a href="ch03.xhtml#ch03lev2sec33">Section 3.3.5</a> for details on matrix multiplication). The function will store and return the result in a new list. If no matrices are in the supplied list or if no appropriate matrices (given the dimensions of the multiplying matrix) are present, the function should return a character string informing the user of these facts. You can assume that if there are matrices in the specified list, they will be numeric. Consider the following function, which I’ll call <code>multiples1</code>:</p>&#13;
<pre>multiples1 &lt;- function(x,mat,str1,str2){<br/>    matrix.flags &lt;- sapply(x,FUN=is.matrix)<br/><br/>    if(!any(matrix.flags)){<br/>        return(str1)<br/>    }<br/><br/>    indexes &lt;- which(matrix.flags)<br/>    counter &lt;- 0<br/>    result &lt;- list()<br/>    for(i in indexes){<br/>        temp &lt;- x[[i]]<br/>        if(ncol(temp)==nrow(mat)){<br/>            counter &lt;- counter+1<br/>            result[[counter]] &lt;- temp%*%mat<br/>        }<br/>    }<br/><br/>    if(counter==0){<br/>        return(str2)<br/>    } else {<br/>        return(result)<br/>    }<br/>}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_223"/>This function takes four arguments, with no default values assigned. The target list to search is intended to be supplied to <code>x</code>; the post-multiplying matrix is supplied to <code>mat</code>; and two other arguments, <code>str1</code> and <code>str2</code>, take character strings to return if <code>x</code> has no suitable members.</p>&#13;
<p class="indent">Inside the body code, a vector called <code>matrix.flags</code> is created with the <code>sapply</code> implicit looping function. This applies the function <code>is.matrix</code> to the list argument <code>x</code>. The result is a logical vector of equal length as <code>x</code>, with <code>TRUE</code> elements where the corresponding member of <code>x</code> is in fact a matrix. If there are no matrices in <code>x</code>, the function hits a <code>return</code> statement, which exits the function and outputs the argument <code>str1</code>.</p>&#13;
<p class="indent">If the function did not exit at that point, this means there are indeed matrices in <code>x</code>. The next step is to retrieve the matrix member indexes by applying <code>which</code> to <code>matrix.flags</code>. A <code>counter</code> is initialized to <code>0</code> to keep track of how many successful matrix multiplications are carried out, and an empty list (<code>result</code>) is created to store any results.</p>&#13;
<p class="indent">Next, you enter a <code>for</code> loop. For each member of <code>indexes</code>, the loop stores the matrix member at that position as <code>temp</code> and checks to see whether it’s possible to perform post-multiplication of <code>temp</code> by the argument <code>mat</code> (to perform the operation, <code>ncol(temp)</code> must equal <code>nrow(mat)</code>). If the matrices are compatible, <code>counter</code> is incremented, and this position of <code>result</code> is filled with the relevant calculation. If <code>FALSE</code>, nothing is done. The indexer, <code>i</code>, then takes on the next value of <code>indexes</code> and repeats until completion.</p>&#13;
<p class="indent">The final procedure in <code>multiples1</code> checks whether the <code>for</code> loop actually found any compatible matrix products. If no compatibility existed, the braced <code>if</code> statement code inside the <code>for</code> loop would never have been executed, and the <code>counter</code> would remain set to zero. So, if <code>counter</code> is still equal to zero upon completion of the loop, the function simply returns the <code>str2</code> argument. Otherwise, if compatible matrices were found, appropriate results will have been computed, and <code>multiples1</code> returns the <code>result</code> list, which would have at least one member.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_224"/>It’s time to import and then test the function. You’ll use the following three list objects:</p>&#13;
<pre>R&gt; foo &lt;- list(matrix(1:4,2,2),"not a matrix",<br/>               "definitely not a matrix",matrix(1:8,2,4),matrix(1:8,4,2))<br/>R&gt; bar &lt;- list(1:4,"not a matrix",c(F,T,T,T),"??")<br/>R&gt; baz &lt;- list(1:4,"not a matrix",c(F,T,T,T),"??",matrix(1:8,2,4))</pre>&#13;
<p class="indent">You’ll set the argument <code>mat</code> to the 2 × 2 identity matrix (post-multiplying any appropriate matrix by this will simply return the original matrix), and you’ll pass in appropriate string messages for <code>str1</code> and <code>str2</code>. Here’s how the function works on <code>foo</code>:</p>&#13;
<pre>R&gt; multiples1(x=foo,mat=diag(2),str1="no matrices in 'x'",<br/>              str2="matrices in 'x' but none of appropriate dimensions given<br/>              'mat'")<br/>[[1]]<br/>     [,1] [,2]<br/>[1,]    1    3<br/>[2,]    2    4<br/><br/>[[2]]<br/>     [,1] [,2]<br/>[1,]    1    5<br/>[2,]    2    6<br/>[3,]    3    7<br/>[4,]    4    8</pre>&#13;
<p class="indent">The function has returned <code>result</code> with the two compatible matrices of <code>foo</code> (members <code>[[1]]</code> and <code>[[5]]</code>). Now let’s try it on <code>bar</code> using the same arguments.</p>&#13;
<pre>R&gt; multiples1(x=bar,mat=diag(2),str1="no matrices in 'x'",<br/>              str2="matrices in 'x' but none of appropriate dimensions given<br/>              'mat'")<br/>[1] "no matrices in 'x'"</pre>&#13;
<p class="indent">This time, the value of <code>str1</code> has been returned. The initial check identified that there are no matrices in the list supplied to <code>x</code>, so the function has exited before the <code>for</code> loop. Finally, let’s try <code>baz</code>.</p>&#13;
<pre>R&gt; multiples1(x=baz,mat=diag(2),str1="no matrices in 'x'",<br/>              str2="matrices in 'x' but none of appropriate dimensions given<br/>              'mat'")<br/>[1] "matrices in 'x' but none of appropriate dimensions given 'mat'"</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_225"/>Here the value of <code>str2</code> was returned. Though there is a matrix in <code>baz</code> and the <code>for</code> loop in the body code of <code>multiples1</code> has been executed, the matrix is not compatible for post-multiplication by <code>mat</code>.</p>&#13;
<p class="indent">Notice that the string arguments <code>str1</code> and <code>str2</code> are used only when the argument <code>x</code> does not contain a matrix with the appropriate dimensions. When you applied <code>multiples1</code> to <code>x=foo</code>, for example, there was no need to use <code>str1</code> or <code>str2</code>. R evaluates the defined expressions lazily, dictating that argument values are sought only at the moment they are required during execution. In this function, <code>str1</code> and <code>str2</code> are required only when the input list doesn’t have suitable matrices, so you could lazily ignore providing values for these arguments when <code>x=foo</code>.</p>&#13;
<pre>R&gt; multiples1(x=foo,mat=diag(2))<br/>[[1]]<br/>     [,1] [,2]<br/>[1,]    1    3<br/>[2,]    2    4<br/><br/>[[2]]<br/>     [,1] [,2]<br/>[1,]    1    5<br/>[2,]    2    6<br/>[3,]    3    7<br/>[4,]    4    8</pre>&#13;
<p class="indent">This returns the same results as before with no problem whatsoever. Attempting this with <code>bar</code>, on the other hand, doesn’t work.</p>&#13;
<pre>R&gt; multiples1(x=bar,mat=diag(2))<br/>Error in multiples1(x = bar, mat = diag(2)) :<br/>  argument "str1" is missing, with no default</pre>&#13;
<p class="indent">Here we are quite rightly chastised by R because it requires the value for <code>str1</code>. It informs us that the value is missing and there is no default.</p>&#13;
<h4 class="h4" id="ch11lev2sec100"><strong><em>11.2.2 Setting Defaults</em></strong></h4>&#13;
<p class="noindent">The previous example shows one case where it’s useful to set default values for certain arguments. Default argument values are also sensible in many other situations, such as when the function has a large number of arguments or when arguments have natural values that are used more often than not. Let’s write a new version of the <code>multiples1</code> function from <a href="ch11.xhtml#ch11lev2sec99">Section 11.2.1</a>, <code>multiples2</code>, which now includes default values for <code>str1</code> and <code>str2</code>.</p>&#13;
<pre>multiples2 &lt;- function(x,mat,str1="no valid matrices",str2=str1){<br/>    matrix.flags &lt;- sapply(x,FUN=is.matrix)<br/><br/>    if(!any(matrix.flags)){<br/>        return(str1)<br/>    }<br/><br/>    indexes &lt;- which(matrix.flags)<br/>    counter &lt;- 0<br/>    result &lt;- list()<br/>    for(i in indexes){<br/>        temp &lt;- x[[i]]<br/>        if(ncol(temp)==nrow(mat)){<br/>            counter &lt;- counter+1<br/>            result[[counter]] &lt;- temp%*%mat<br/>        }<br/>    }<br/><br/>    if(counter==0){<br/>        return(str2)<br/>    } else {<br/>        return(result)<br/>    }<br/>}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_226"/>Here, you have given <code>str1</code> a default value of <code>"no valid matrices"</code> by assigning the string value in the formal definition of the arguments. You’ve also set a default for <code>str2</code> by assigning <code>str1</code> to it. If you import and execute this function again on the three lists, you no longer need to explicitly provide values for those arguments.</p>&#13;
<pre>R&gt; multiples2(foo,mat=diag(2))<br/>[[1]]<br/>     [,1] [,2]<br/>[1,]    1    3<br/>[2,]    2    4<br/><br/>[[2]]<br/>     [,1] [,2]<br/>[1,]    1    5<br/>[2,]    2    6<br/>[3,]    3    7<br/>[4,]    4    8<br/><br/>R&gt; multiples2(bar,mat=diag(2))<br/>[1] "no valid matrices"<br/>R&gt; multiples2(baz,mat=diag(2))<br/>[1] "no valid matrices"</pre>&#13;
<p class="indent">You can now call the function, whatever the outcome, without being required to specify every argument in full. If you don’t want to use the <span epub:type="pagebreak" id="page_227"/>default arguments in a specific call, you can still specify different values for those arguments when calling the function, and those values will overwrite the defaults.</p>&#13;
<h4 class="h4" id="ch11lev2sec101"><strong><em>11.2.3 Checking for Missing Arguments</em></strong></h4>&#13;
<p class="noindent">The <code>missing</code> function checks the arguments of a function to see if all required arguments have been supplied. It takes an argument tag and returns a single logical value of <code>TRUE</code> if the specified argument isn’t found. You can use <code>missing</code> to avoid the error you saw in an earlier call to <code>multiples1</code>, when <code>str1</code> was required but not supplied.</p>&#13;
<p class="indent">In some situations, the <code>missing</code> function can be particularly useful in the body code. Consider another modification to the example function:</p>&#13;
<pre>multiples3 &lt;- function(x,mat,str1,str2){<br/>    matrix.flags &lt;- sapply(x,FUN=is.matrix)<br/><br/>    if(!any(matrix.flags)){<br/>        if(missing(str1)){<br/>            return("'str1' was missing, so this is the message")<br/>        } else {<br/>            return(str1)<br/>        }<br/>    }<br/><br/>    indexes &lt;- which(matrix.flags)<br/>    counter &lt;- 0<br/>    result &lt;- list()<br/>    for(i in indexes){<br/>        temp &lt;- x[[i]]<br/>        if(ncol(temp)==nrow(mat)){<br/>            counter &lt;- counter+1<br/>            result[[counter]] &lt;- temp%*%mat<br/>        }<br/>    }<br/><br/>    if(counter==0){<br/>        if(missing(str2)){<br/>            return("'str2' was missing, so this is the message")<br/>        } else {<br/>            return(str2)<br/>        }<br/>    } else {<br/>        return(result)<br/>    }<br/>}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_228"/>The only differences between this version and <code>multiples1</code> are in the first and last <code>if</code> statements. The first <code>if</code> statement checks whether there are no matrices in <code>x</code>, in which case it returns a string message. In <code>multiples1</code>, that message was always <code>str1</code>, but now you use another <code>if</code> statement with <code>missing(str1)</code> to see whether the <code>str1</code> argument actually has a value first. If not, the function returns another character string saying that <code>str1</code> was <code>missing</code>. A similar alternative is defined for <code>str2</code>. Here it is once more importing the function and using <code>foo</code>, <code>bar</code>, and <code>baz</code>:</p>&#13;
<pre>R&gt; multiples3(foo,diag(2))<br/>[[1]]<br/>     [,1] [,2]<br/>[1,]    1    3<br/>[2,]    2    4<br/><br/>[[2]]<br/>     [,1] [,2]<br/>[1,]    1    5<br/>[2,]    2    6<br/>[3,]    3    7<br/>[4,]    4    8<br/><br/>R&gt; multiples3(bar,diag(2))<br/>[1] "'str1' was missing, so this is the message"<br/>R&gt; multiples3(baz,diag(2))<br/>[1] "'str2' was missing, so this is the message"</pre>&#13;
<p class="indent">Using <code>missing</code> this way permits arguments to be left unsupplied in a given function call. It is primarily used when it’s difficult to choose a default value for a certain argument, yet the function still needs to handle cases when that argument isn’t provided. In the current example, it makes more sense to define defaults for <code>str1</code> and <code>str2</code>, as you did for <code>multiples2</code>, and avoid the extra code required to implement <code>missing</code>.</p>&#13;
<h4 class="h4" id="ch11lev2sec102"><strong><em>11.2.4 Dealing with Ellipses</em></strong></h4>&#13;
<p class="noindent">In <a href="ch09.xhtml#ch09lev2sec86">Section 9.2.5</a>, I introduced the ellipsis, also called dot-dot-dot notation. The ellipsis allows you to pass in extra arguments without having to first define them in the argument list, and these arguments can then be passed to another function call within the code body. When included in a function definition, the ellipsis is often (but not always) placed in the last position because it represents a variable number of arguments.</p>&#13;
<p class="indent">Building on the <code>myfib3</code> function from <a href="ch11.xhtml#ch11lev2sec97">Section 11.1.1</a>, let’s use the ellipsis to write a function that can plot the specified Fibonacci numbers.</p>&#13;
<pre>myfibplot &lt;- function(thresh,plotit=TRUE,...){<br/>    fibseq &lt;- c(1,1)<br/>    counter &lt;- 2<br/>    repeat{<br/>        fibseq &lt;- c(fibseq,fibseq[counter-1]+fibseq[counter])<br/>        counter &lt;- counter+1<br/>        if(fibseq[counter]&gt;thresh){<br/>            break<br/>        }<br/>    }<br/><br/>    if(plotit){<br/>        plot(1:length(fibseq),fibseq,...)<br/>    } else {<br/>        return(fibseq)<br/>    }<br/>}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_229"/>In this function, an <code>if</code> statement checks to see whether the <code>plotit</code> argument is <code>TRUE</code> (which is the default value). If so, then you call <code>plot</code>, passing in <code>1:length(fibseq)</code> for the <em>x</em>-axis coordinates and the Fibonacci numbers themselves for the <em>y</em>-axis. After these coordinates, you also pass the ellipsis directly into <code>plot</code>. In this case, the ellipsis represents any additional arguments a user might pass in to control the execution of <code>plot</code>.</p>&#13;
<p class="indent">Importing <code>myfibplot</code> and executing the following line, the plot in <a href="ch11.xhtml#ch11fig1">Figure 11-1</a> pops up in a graphics device.</p>&#13;
<pre>R&gt; myfibplot(150)</pre>&#13;
<p class="indent">Here you used positional matching to assign <code>150</code> to <code>thresh</code>, leaving the default value for the <code>plotit</code> argument. The ellipsis is empty in this call.</p>&#13;
<div class="image"><img src="../images/f11-01.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch11fig1"/>Figure 11-1: The default plot produced by a call to</em> <code>myfibplot</code><em>, with</em> <code>thresh=150</code></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_230"/>Since you didn’t specify otherwise, R has simply followed the default behavior of <code>plot</code>. You can spruce things up by specifying more plotting options. The following line produces the plot in <a href="ch11.xhtml#ch11fig2">Figure 11-2</a>:</p>&#13;
<pre>R&gt; myfibplot(150,type="b",pch=4,lty=2,main="Terms of the Fibonacci sequence",<br/>             ylab="Fibonacci number",xlab="Term (n)")</pre>&#13;
<div class="image"><img src="../images/f11-02.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch11fig2"/>Figure 11-2: A plot produced by a call to</em> <code>myfibplot</code> <em>with graphical parameters passed in using the ellipsis</em></p>&#13;
<p class="indent">Here the ellipsis allows you to pass arguments to <code>plot</code> through the call to <code>myfibplot</code>, even though the particular graphical parameters are not explicitly defined arguments of <code>myfibplot</code>.</p>&#13;
<p class="indent">Ellipses can be convenient, but they require care. The ambiguous <code>...</code> can represent any number of mysterious arguments. Good function documentation is key to indicate the appropriate usage.</p>&#13;
<p class="indent">If you want to unpack the arguments passed in through an ellipsis, you can use the <code>list</code> function to convert those arguments into a list. Here’s an example:</p>&#13;
<pre>unpackme &lt;- function(...){<br/>    x &lt;- list(...)<br/>    cat("Here is ... in its entirety as a list:\n")<br/>    print(x)<br/>    cat("\nThe names of ... are:",names(x),"\n\n")<br/>    cat("\nThe classes of ... are:",sapply(x,class))<br/>}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_231"/>This dummy function simply takes an ellipsis and converts it to a list with <code>x &lt;- list(...)</code>. This subsequently allows the object <code>x</code> to be treated the same way as any other list. In this case, you can summarize the object by providing its <code>names</code> and <code>class</code> attributes. Here’s a sample run:</p>&#13;
<pre>R&gt; unpackme(aa=matrix(1:4,2,2),bb=TRUE,cc=c("two","strings"),<br/>            dd=factor(c(1,1,2,1)))<br/>Here is ... in its entirety as a list:<br/>$aa<br/>     [,1] [,2]<br/>[1,]    1    3<br/>[2,]    2    4<br/><br/>$bb<br/>[1] TRUE<br/><br/>$cc<br/>[1] "two"     "strings"<br/><br/>$dd<br/>[1] 1 1 2 1<br/>Levels: 1 2<br/><br/><br/>The names of ... are: aa bb cc dd<br/><br/><br/>The classes of ... are: matrix logical character factor</pre>&#13;
<p class="indent">Four tagged arguments, <code>aa</code>, <code>bb</code>, <code>cc</code>, and <code>dd</code>, are provided as the contents of the ellipsis, and they are explicitly identified within <code>unpackme</code> by using the simple <code>list(...)</code> operation. This construction can be useful for identifying or extracting specific arguments supplied through <code>...</code> in a given call.</p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch11exc2"/><strong>Exercise 11.2</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Accruing annual compound interest is a common financial benefit for investors. Given a principal investment amount <em>P</em>, an interest rate per annum <em>i</em> (expressed as a percentage), and a frequency of interest paid per year <em>t</em>, the final amount <em>F</em> after <em>y</em> years is given as follows:</p>&#13;
<div class="imagec"><img src="../images/f0231-01.jpg" alt="image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_232"/>Write a function that can compute <em>F</em> as per the following notes:</p>&#13;
<p class="dash">– Arguments must be present for <em>P</em>, <em>i</em>, <em>t</em>, and <em>y</em>. The argument for <em>t</em> should have a default value of 12.</p>&#13;
<p class="dash">– Another argument giving a logical value that determines whether to <code>plot</code> the amount <em>F</em> at each integer time should be included. For example, if <code>plotit=TRUE</code> (the default) and <em>y</em> is 5 years, the plot should show the amount <em>F</em> at <em>y</em> = 1,2,3,4,5.</p>&#13;
<p class="dash">– If this function is plotted, the plot should always be a step-plot, so <code>plot</code> should always be called with <code>type="s"</code>.</p>&#13;
<p class="dash">– If <code>plotit=FALSE</code>, the final amount <em>F</em> should be returned as a numeric vector corresponding to the same integer times, as shown earlier.</p>&#13;
<p class="dash">– An ellipsis should also be included to control other details of plotting, if it takes place.</p>&#13;
<p class="indent">Now, using your function, do the following:</p>&#13;
<ol type="i">&#13;
<li><p class="noindents">Work out the final amount after a 10-year investment of a principal of $5000, at an interest rate of 4.4 percent per annum compounded monthly.</p></li>&#13;
<li><p class="noindents">Re-create the following step-plot, which shows the result of $100 invested at 22.9 percent per annum, compounded monthly, for 20 years:</p>&#13;
<div class="image"><img src="../images/f0232-01.jpg" alt="image"/></div></li>&#13;
<li><p class="noindents">Perform another calculation based on the same parameters as in (ii), but this time, assume the interest is compounded annually. Return and store the results as a numeric vector. Then, use <code>lines</code> to add a second step-line, corresponding to this annually accrued amount, to the plot created previously. Use a different color or line type and make use of the <code>legend</code> function so the two lines can be differentiated.</p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">A <em>quadratic equation</em> in the variable <em>x</em> is often expressed in the following form:</p>&#13;
<p class="center"><em>k</em><sub>1</sub><em>x</em><sup>2</sup> + <em>k</em><sub>2</sub><em>x</em> + <em>k<sub>3</sub></em> = 0</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_233"/>Here, <em>k</em><sub>1</sub>, <em>k</em><sub>2</sub>, and <em>k<sub>3</sub></em> are constants. Given values for these constants, you can attempt to find up to two <em>real roots</em>—values of <em>x</em> that satisfy the equation. Write a function that takes <em>k</em><sub>1</sub>, <em>k</em><sub>2</sub>, and <em>k<sub>3</sub></em> as arguments and finds and returns any solutions (as a numeric vector) in such a situation. This is achieved as follows:</p>&#13;
<p class="dash">– Evaluate <img class="middle" src="../images/f0233-01.jpg" alt="image"/>. If this is negative, there are no solutions, and an appropriate message should be printed to the console.</p>&#13;
<p class="dash">– If <img class="middle" src="../images/f0233-01.jpg" alt="image"/> is zero, then there is one solution, computed by −<em>k</em><sub>2</sub>/2<em>k</em><sub>1</sub>.</p>&#13;
<p class="dash">– If <img class="middle" src="../images/f0233-01.jpg" alt="image"/> is positive, then there are two solutions, given by <img class="middle" src="../images/f0233-02.jpg" alt="image"/> and <img class="middle" src="../images/f0233-03.jpg" alt="image"/>.</p>&#13;
<p class="dash">– No default values are needed for the three arguments, but the function should check to see whether any are missing. If so, an appropriate character string message should be returned to the user, informing the user that the calculations are not possible.</p>&#13;
<p class="indent">Now, test your function.</p>&#13;
<ol type="i">&#13;
<li><p class="noindents">Confirm the following:</p>&#13;
<p class="d-star">* 2<em>x</em><sup>2</sup> − <em>x</em> − 5 has roots 1.850781 and −1.350781.</p>&#13;
<p class="d-star">* <em>x</em><sup>2</sup> + <em>x</em> + 1 has no real roots.</p></li>&#13;
<li><p class="noindents">Attempt to find solutions to the following quadratic equations:</p>&#13;
<p class="d-star">* 1.3<em>x</em><sup>2</sup> − 8<em>x</em> − 3.13</p>&#13;
<p class="d-star">* 2.25<em>x</em><sup>2</sup> − 3<em>x</em> + 1</p>&#13;
<p class="d-star">* 1.4<em>x</em><sup>2</sup> − 2.2<em>x</em> − 5.1</p>&#13;
<p class="d-star">* −5<em>x</em><sup>2</sup> + 10.11<em>x</em> − 9.9</p></li>&#13;
<li><p class="noindents">Test your programmed response in the function if one of the arguments is missing.</p></li>&#13;
</ol></li>&#13;
</ol>&#13;
</div>&#13;
<h3 class="h3" id="ch11lev1sec38"><strong>11.3 Specialized Functions</strong></h3>&#13;
<p class="noindent">In this section, you’ll look at three kinds of specialized user-defined R functions. First, you’ll look at helper functions, which are designed to be called multiple times by another function (and they can even be defined inside the body of a parent function). Next, you’ll look at disposable functions, which can be directly defined as an argument to another function call. Finally, you’ll look at recursive functions, which call themselves.</p>&#13;
<h4 class="h4" id="ch11lev2sec103"><strong><em>11.3.1 Helper Functions</em></strong></h4>&#13;
<p class="noindent">It is common for R functions to call other functions from within their body code. A <em>helper function</em> is a general term used to describe functions written and used specifically to facilitate the computations carried out by another <span epub:type="pagebreak" id="page_234"/>function. They’re a good way to improve the readability of complicated functions.</p>&#13;
<p class="indent">A helper function can be either defined internally (within another function definition) or externally (within the global environment). In this section, you’ll see an example of each.</p>&#13;
<h5 class="h5" id="ch11lev3sec29"><strong>Externally Defined</strong></h5>&#13;
<p class="noindent">Building on the <code>multiples2</code> function from <a href="ch11.xhtml#ch11lev2sec100">Section 11.2.2</a>, here’s a new version that splits the functionality over two separate functions, one of which is an externally defined helper function:</p>&#13;
<pre>multiples_helper_ext &lt;- function(x,matrix.flags,mat){<br/>    indexes &lt;- which(matrix.flags)<br/>    counter &lt;- 0<br/>    result &lt;- list()<br/>    for(i in indexes){<br/>        temp &lt;- x[[i]]<br/>        if(ncol(temp)==nrow(mat)){<br/>            counter &lt;- counter+1<br/>            result[[counter]] &lt;- temp%*%mat<br/>        }<br/>    }<br/>    return(list(result,counter))<br/>}<br/><br/>multiples4 &lt;- function(x,mat,str1="no valid matrices",str2=str1){<br/>    matrix.flags &lt;- sapply(x,FUN=is.matrix)<br/><br/>    if(!any(matrix.flags)){<br/>        return(str1)<br/>    }<br/><br/>    helper.call &lt;- multiples_helper_ext(x,matrix.flags,mat)<br/>    result &lt;- helper.call[[1]]<br/>    counter &lt;- helper.call[[2]]<br/><br/>    if(counter==0){<br/>        return(str2)<br/>    } else {<br/>        return(result)<br/>    }<br/>}</pre>&#13;
<p class="indent">If you import and execute this code on the sample lists from earlier, it behaves the same way as the previous version. All you’ve done here is moved the matrix-checking loop to an external function. The <code>multiples4</code> function now calls a helper function named <code>multiples_helper_ext</code>. Once the <span epub:type="pagebreak" id="page_235"/>code in <code>multiples4</code> makes sure that there are in fact matrices in the list <code>x</code> to be checked, it calls <code>multiples_helper_ext</code> to execute the required loop. This helper function is defined externally, meaning that it exists in the global environment for any other function to call, making it easier to reuse.</p>&#13;
<h5 class="h5" id="ch11lev3sec30"><strong>Internally Defined</strong></h5>&#13;
<p class="noindent">If the helper function is intended to be used for only one particular function, it makes more sense to define the helper function internally, within the lexical environment of the function that calls it. The fifth version of the matrix multiplication function does just that, shifting the definition to within the body code.</p>&#13;
<pre>multiples5 &lt;- function(x,mat,str1="no valid matrices",str2=str1){<br/>    matrix.flags &lt;- sapply(x,FUN=is.matrix)<br/><br/>    if(!any(matrix.flags)){<br/>        return(str1)<br/>    }<br/><br/>    multiples_helper_int &lt;- function(x,matrix.flags,mat){<br/>        indexes &lt;- which(matrix.flags)<br/>        counter &lt;- 0<br/>        result &lt;- list()<br/>        for(i in indexes){<br/>            temp &lt;- x[[i]]<br/>            if(ncol(temp)==nrow(mat)){<br/>                counter &lt;- counter+1<br/>                result[[counter]] &lt;- temp%*%mat<br/>            }<br/>        }<br/>        return(list(result,counter))<br/>    }<br/><br/>    helper.call &lt;- multiples_helper_int(x,matrix.flags,mat)<br/>    result &lt;- helper.call[[1]]<br/>    counter &lt;- helper.call[[2]]<br/><br/>    if(counter==0){<br/>        return(str2)<br/>    } else {<br/>        return(result)<br/>    }<br/>}</pre>&#13;
<p class="indent">Now the helper function <code>multiples_helper_int</code> is defined within <code>multiples5</code>. That means it’s visible only within the lexical environment as opposed to residing in the global environment like <code>multiples_helper_ext</code>. It <span epub:type="pagebreak" id="page_236"/>makes sense to internally define a helper function when (a) it’s used only by a single parent function, and (b) it’s called multiple times within the parent function. (Of course, <code>multiples5</code> satisfies only (a), and it’s provided here just for the sake of illustration.)</p>&#13;
<h4 class="h4" id="ch11lev2sec104"><strong><em>11.3.2 Disposable Functions</em></strong></h4>&#13;
<p class="noindent">Often, you may need a function that performs a simple, one-line task. For example, when you use <code>apply</code>, you’ll typically just want to pass in a short, simple function as an argument. That’s where <em>disposable</em> (or <em>anonymous</em>) functions come in—they allow you to define a function intended for use in a single instance without explicitly creating a new object in your global environment.</p>&#13;
<p class="indent">Say you have a numeric matrix whose columns you want to repeat twice and then sort.</p>&#13;
<pre>R&gt; foo &lt;- matrix(c(2,3,3,4,2,4,7,3,3,6,7,2),3,4)<br/>R&gt; foo<br/>     [,1] [,2] [,3] [,4]<br/>[1,]    2    4    7    6<br/>[2,]    3    2    3    7<br/>[3,]    3    4    3    2</pre>&#13;
<p class="indent">This is a perfect task for <code>apply</code>, which can apply a function to each column of the matrix. This function simply has to take in a vector, repeat it, and sort the result. Rather than define that short function separately, you can define a disposable function right in the argument of <code>apply</code> using the <code>function</code> command.</p>&#13;
<pre>R&gt; apply(foo,MARGIN=2,FUN=function(x){sort(rep(x,2))})<br/>     [,1] [,2] [,3] [,4]<br/>[1,]    2    2    3    2<br/>[2,]    2    2    3    2<br/>[3,]    3    4    3    6<br/>[4,]    3    4    3    6<br/>[5,]    3    4    7    7<br/>[6,]    3    4    7    7</pre>&#13;
<p class="indent">The function is defined in the standard format directly in the call to <code>apply</code>. This function is defined, called, and then immediately forgotten once <code>apply</code> is complete. It is disposable in the sense that it exists only for the one instance where it is actually used.</p>&#13;
<p class="indent">Using the <code>function</code> command this way is a shortcut more than anything else; plus, it avoids the unnecessary creation and storage of a function object in the global environment.</p>&#13;
<h4 class="h4" id="ch11lev2sec105"><span epub:type="pagebreak" id="page_237"/><strong><em>11.3.3 Recursive Functions</em></strong></h4>&#13;
<p class="noindent"><em>Recursion</em> is when a function calls itself. This technique isn’t commonly used in statistical analyses, but it pays to be aware of it. This section will briefly illustrate what it means for a function to call itself.</p>&#13;
<p class="indent">Suppose you want to write a function that takes a single positive integer argument <code>n</code> and returns the corresponding <em>n</em>th term of the Fibonacci sequence (where <em>n</em> = 1 and <em>n</em> = 2 correspond to the initial two terms 1 and 1, respectively). Earlier you built up the Fibonacci sequence in an <em>iterative</em> fashion by using a loop. In a recursive function, instead of using a loop to repeat an operation, the function calls itself multiple times. Consider the following:</p>&#13;
<pre>myfibrec &lt;- function(n){<br/>    if(n==1||n==2){<br/>        return(1)<br/>    } else {<br/>        return(myfibrec(n-1)+myfibrec(n-2))<br/>    }<br/>}</pre>&#13;
<p class="indent">The recursive <code>myfibrec</code> checks a single <code>if</code> statement that defines a <em>stopping condition</em>. If either <code>1</code> or <code>2</code> is supplied to the function (requesting the first or second Fibonacci number), then <code>myfibrec</code> directly returns <code>1</code>. Otherwise, the function returns the sum of <code>myfibrec(n-1)</code> and <code>myfibrec(n-2)</code>. That means if you call <code>myfibrec</code> with <code>n</code> greater than <code>2</code>, the function generates two more calls to <code>myfibrec</code>, using <code>n-1</code> and <code>n-2</code>. The recursion continues until it reaches a call for the 1st or 2nd term, triggering the stopping condition, <code>if(n==1||n==2)</code>, which simply returns <code>1</code>. Here’s a sample call that retrieves the fifth Fibonacci number:</p>&#13;
<pre>R&gt; myfibrec(5)<br/>[1] 5</pre>&#13;
<p class="indent"><a href="ch11.xhtml#ch11fig3">Figure 11-3</a> shows the structure of this recursive call.</p>&#13;
<p class="indent">Note that an accessible stopping rule is critical to any recursive function. Without one, recursion will continue indefinitely. For example, the current definition of <code>myfibrec</code> works as long as the user supplies a positive integer for the argument <code>n</code>. But if <code>n</code> is negative, the stopping rule condition will never be satisfied, and the function will recur indefinitely (though R has some automated safeguards to help prevent this and should just return an error message rather than getting stuck in an infinite loop).</p>&#13;
<p class="indent">Recursion is a powerful approach, especially when you don’t know ahead of time how many times a function needs be called to complete a task. For many sort and search algorithms, recursion provides the speediest and most efficient solution. But in simpler cases, such as the Fibonacci example here, the recursive approach often requires more computational expense than an iterative looping approach. For beginners, I recommended sticking with explicit loops unless recursion is strictly required.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_238"/><img src="../images/f11-03.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch11fig3"/>Figure 11-3: A visualization of the recursive calls made to</em> <code>myfibrec</code> <em>with</em> <code>n=5</code></p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch11exc3"/><strong>Exercise 11.3</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Given a list whose members are character string vectors of varying lengths, use a disposable function with <code>lapply</code> to paste an exclamation mark onto the end of each element of each member, with an empty string as the separation character (note that the default behavior of <code>paste</code> when applied to character vectors is to perform the concatenation on each element). Execute your line of code on the list given by the following:</p>&#13;
<pre>foo &lt;- list("a",c("b","c","d","e"),"f",c("g","h","i"))</pre></li>&#13;
<li><p class="noindents">Write a recursive version of a function implementing the non-negative integer factorial operator (see <a href="ch10.xhtml#ch10exc4">Exercise 10.4</a> on <a href="ch10.xhtml#page_203">page 203</a> for details of the factorial operator). The stopping rule should return the value <code>1</code> if the supplied integer is <code>0</code>. Confirm that your function produces the same results as earlier.</p>&#13;
<ol type="i">&#13;
<li><p class="noindents">5 factorial is 120.</p></li>&#13;
<li><p class="noindents">120 factorial is 479,001,600.</p></li>&#13;
<li><p class="noindents">0 factorial is 1.</p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">For this problem, I’ll introduce the <em>geometric mean</em>. The geometric mean is a particular measure of centrality, different from the more common arithmetic mean. Given <em>n</em> observations denoted <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ..., <em>x</em><sub>n</sub>, their geometric mean <img class="middle" src="../images/g.jpg" alt="image"/> is computed as follows:</p>&#13;
<div class="imagec"><img src="../images/f0238-01.jpg" alt="image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_239"/>For example, to find the geometric mean of the data 4.3, 2.1, 2.2, 3.1, calculate the following:</p>&#13;
<div class="imagec"><img src="../images/f0239-01.jpg" alt="image"/></div>&#13;
<p class="indent">(This is rounded to 1 d.p.)</p>&#13;
<p class="indent">Write a function named <code>geolist</code> that can search through a specified list and compute the geometric means of each member per the following guidelines:</p>&#13;
<p class="dash">– Your function must define and use an internal helper function that returns the geometric mean of a vector argument.</p>&#13;
<p class="dash">– Assume the list can only have numeric vectors or numeric matrices as its members. Your function should contain an appropriate loop to inspect each member in turn.</p>&#13;
<p class="dash">– If the member is a vector, compute the geometric mean of that vector, overwriting the member with the result, which should be a single number.</p>&#13;
<p class="dash">– If the member is a matrix, use an implicit loop to compute the geometric mean <em>of each row</em> of the matrix, overwriting the member with the results.</p>&#13;
<p class="dash">– The final list should be returned to the user.</p>&#13;
<p class="indent">Now, as a quick test, check that your function matches the following two calls:</p>&#13;
<ol type="i">&#13;
<li><p class="noindents"> </p>&#13;
<pre>R&gt; foo &lt;- list(1:3,matrix(c(3.3,3.2,2.8,2.1,4.6,4.5,3.1,9.4),4,2),<br/>               matrix(c(3.3,3.2,2.8,2.1,4.6,4.5,3.1,9.4),2,4))<br/>R&gt; geolist(foo)<br/>[[1]]<br/>[1] 1.817121<br/><br/>[[2]]<br/>[1] 3.896152 3.794733 2.946184 4.442972<br/><br/>[[3]]<br/>[1] 3.388035 4.106080</pre></li>&#13;
<li><p class="noindents"> </p>&#13;
<pre>R&gt; bar &lt;- list(1:9,matrix(1:9,1,9),matrix(1:9,9,1),matrix(1:9,3,3))<br/>R&gt; geolist(bar)<br/>[[1]]<br/>[1] 4.147166<br/><br/>[[2]]<br/>[1] 4.147166<br/><br/>[[3]]<br/>[1] 1 2 3 4 5 6 7 8 9<br/><br/>[[4]]<br/>[1] 3.036589 4.308869 5.451362</pre></li>&#13;
</ol></li>&#13;
</ol>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec31"><span epub:type="pagebreak" id="page_240"/><strong>Important Code in This Chapter</strong></h5>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Function/operator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Brief description</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>First occurrence</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>function</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Function creation</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch11.xhtml#ch11lev2sec97">Section 11.1.1</a>, <a href="ch11.xhtml#page_216">p. 216</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>return</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Function return objects</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch11.xhtml#ch11lev2sec97">Section 11.1.1</a>, <a href="ch11.xhtml#page_219">p. 219</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>missing</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Argument check</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch11.xhtml#ch11lev2sec101">Section 11.2.3</a>, <a href="ch11.xhtml#page_227">p. 227</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>...</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Ellipsis (as argument)</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch11.xhtml#ch11lev2sec102">Section 11.2.4</a>, <a href="ch11.xhtml#page_228">p. 228</a><span epub:type="pagebreak" id="page_241"/></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</body></html>