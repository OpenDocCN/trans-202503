- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 6 LOOPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter introduces the *loop*, a control structure that allows you to repeat
    a sequence of statements over and over again. Once you understand how to use loops,
    you’ll be able to easily create scripts to process large volumes of data and perform
    repetitive tasks with efficiently written code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover two main types of PHP loops: the while loop and the for loop. A
    while loop is used for repeating a series of actions until a specific condition
    is met, while a for loop is used for repeating a series of actions a fixed number
    of times. We’ll also look at do...while loops, a variation on while loops. A fourth
    type of PHP loop, the foreach loop, is specifically designed for looping through
    collections of data, such as arrays. We’ll look at foreach loops when we introduce
    arrays in [Chapter 7](chapter7.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: '### while Loops'
  prefs: []
  type: TYPE_NORMAL
- en: 'One kind of PHP loop is the while loop: a sequence of statements is repeatedly
    executed *while* a certain condition is true. [Figure 6-1](#fig6-1) illustrates
    how this works.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure6-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-1: The flow of logic for a while loop'
  prefs: []
  type: TYPE_NORMAL
- en: When a script features a while loop, some statements are typically executed
    before the loop begins. Then the PHP engine checks the condition controlling the
    loop. If the condition is false, the statements in the loop will never be executed,
    and the program skips ahead to the statements after the loop. If the condition
    is true, the statements in the loop are executed once, then the condition is checked
    a second time. If it’s still true, the statements in the loop are executed again.
    This cycle continues, with the PHP engine checking the condition before each new
    repetition until it’s found to be false, and the loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: To write a while loop, start with the while keyword, followed in parentheses
    by the Boolean condition that will control the loop. Then enclose the statement
    that should be repeated in curly brackets. If the loop contains only a single
    statement, the curly brackets are optional, but most programmers include them
    anyway to emphasize that the statement is part of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-1](#lis6-1) shows a script that uses a while loop to test the length
    of a password. The loop keeps prompting the user to enter a new password until
    the result is long enough.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-1: A while loop requesting a password of six characters or more'
  prefs: []
  type: TYPE_NORMAL
- en: Before the loop, we set the $password variable to an initial value of "cat".
    Then we declare the while loop, using strlen($password) < 6 as the condition.
    Before each repetition of the loop, PHP will check the length of $password. If
    it’s shorter than six characters, the condition is true, so the statement in the
    loop will execute. If it’s six or more characters, the condition is false, so
    the loop will end. Since $password starts out being three characters long, we
    know the loop will execute at least once.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the loop, we use the built-in readline() function to take in a password
    from the user. The function displays the string passed as an argument as a command
    line prompt, then reads whatever the user types at the command line before pressing
    ENTER. We store the result back into the $password variable, so now we’ll have
    a new value to check before the next repetition of the loop. Once the password
    is long enough and the loop ends, we confirm the new value of $password back to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This program is* not *a good example of secure password protocols since the
    password is being shown onscreen, where anyone could read it. But it’s a handy
    illustration of a* while *loop.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample run of this script. I’ve entered a few passwords
    that are too short before providing an acceptable one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what happens each time the PHP engine checks the strlen($password) <
    6 condition during this run of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.   $password contains "cat", so the condition is true. The loop executes once.
  prefs: []
  type: TYPE_NORMAL
- en: 2.   $password contains "dog", so the condition is still true. The loop executes
    a second time.
  prefs: []
  type: TYPE_NORMAL
- en: 3.   $password contains "whale", so the condition is still true. The loop executes
    a third time.
  prefs: []
  type: TYPE_NORMAL
- en: 4.   $password contains "catdog123", so the condition is false. The loop ends,
    and the final print statement executes.
  prefs: []
  type: TYPE_NORMAL
- en: In all, the PHP engine checks the loop’s condition four times and repeats the
    loop’s contents three times. There will always be one more check of the condition
    than there are repetitions of a while loop, since the condition check happens
    *before* the loop’s contents are executed. Try changing the initial value of $password
    to text at least six characters long and running the script again. You’ll find
    that the script skips straight to the final print statement, since the first check
    of the loop condition evaluates to false.
  prefs: []
  type: TYPE_NORMAL
- en: do...while Loops
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A do...while loop is an alternate form of a while loop: the condition check
    happens *after* each repetition of the loop, rather than before. This way, the
    statement(s) in the loop are guaranteed to be executed at least once, and the
    number of loop repetitions will match the number of times the condition is checked.
    [Figure 6-2](#fig6-2) shows how this works.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure6-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-2: The flow of logic for a do...while loop'
  prefs: []
  type: TYPE_NORMAL
- en: With a do...while loop, first we go once through the statements in the loop.
    Then we test the loop condition. If the condition is false, we move on to the
    statements after the loop, so the loop will have executed only the one time. If
    the condition is true, the loop statements are executed again, and so on until
    the condition is false.
  prefs: []
  type: TYPE_NORMAL
- en: To write a do...while loop, start with the do keyword, followed in curly brackets
    by the statements that should be repeated. After the closing curly bracket, write
    the while keyword, then the loop condition in parentheses. For example, [Listing
    6-2](#lis6-2) shows how to rewrite the password-checking script from [Listing
    6-1](#lis6-1) by using a do...while loop instead of a while loop. The changes
    are shown in black text.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-2: A modified version of [Listing 6-1](#lis6-1) using a do...while
    loop'
  prefs: []
  type: TYPE_NORMAL
- en: We begin the loop with the do keyword. Then, after our statement with the readline()
    function, on the same line as the closing curly bracket, we write the while keyword
    and then, inside parentheses, the same strlen ($password) < 6 loop condition we
    had before. Notice that we need to include a semicolon after the condition to
    end the statement.
  prefs: []
  type: TYPE_NORMAL
- en: The key difference between this and the previous version of the script is that
    we no longer need to set an initial value for the $password variable before entering
    the loop. Instead, we read in an initial password from the user during the first
    run of the loop before testing its value and deciding whether a repetition is
    necessary. In general, if you know you’ll want the statements in a loop to be
    executed at least once, a do...while loop may be a better choice than a while
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean Flags
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the logic governing whether to continue looping is more complex than a single
    condition, it’s often clearer to control the loop by using a Boolean variable
    known as a *flag*. Typically, you set the flag to true, then enter the loop, using
    the flag as the condition. The loop itself features logic (perhaps a series of
    if statements) to set the value of the flag to false when the loop is ready to
    end.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we want to repeatedly prompt the user for input until they
    type either *quit* or *q*. We could accomplish that with a while loop that starts
    this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The condition for this loop is borderline hard to read, and it would become
    even more convoluted if we wanted to watch for a third input. Controlling the
    loop with a Boolean flag clarifies the code, as shown in [Listing 6-3](#lis6-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-3: Using a Boolean flag variable as the loop condition'
  prefs: []
  type: TYPE_NORMAL
- en: We first create the Boolean flag variable $continueLooping and set it to true.
    Then we declare a while loop with this flag as the loop condition. Notice that
    this is much clearer than the compound condition shown earlier. Since the condition
    is initially true, we’ll enter the loop and execute the loop statement group at
    least once. After prompting the user for text and storing it in the $userInput
    variable, we use two if statements to check whether the variable contains 'quit'
    or 'q'. These if statements take the place of the original compound loop condition;
    both set the flag to false to end the loop when the user asks to quit. After the
    if statements, we print the user’s input. Then, outside the loop, we print a message
    confirming that the loop is over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sample run of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the script prints out whatever text the user enters. In this
    case, the loop ended after I typed *quit*, but it’ll also end if you type the
    letter *q*.
  prefs: []
  type: TYPE_NORMAL
- en: break Statements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The break keyword immediately exits a loop, without allowing any remaining statements
    in the loop to execute. In the previous script’s output, you may have noticed
    that when I typed *quit*, that word was repeated by the loop’s final print statement
    (you typed 'quit') before the loop terminated. With a break statement, we could
    immediately halt the loop as soon as the user enters *quit* or *q*, before that
    print statement runs.
  prefs: []
  type: TYPE_NORMAL
- en: Using break also eliminates the need for a Boolean flag. Instead, we can simply
    use the literal Boolean value true as the looping condition by writing while (true).
    Since true is always true, this loop will theoretically repeat forever, or at
    least until some conditional logic triggers a break statement. [Listing 6-4](#lis6-4)
    shows how to update our user input script with while (true) and break.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-4: An updated version of [Listing 6-3](#lis6-3), using break to exit
    a while (true) loop'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve deleted our $continueLooping Boolean flag and replaced the while loop’s
    condition with the literal true ❶. Inside the loop, we still have our two if statements
    testing whether $userInput contains the string 'quit' or 'q', but this time each
    if statement simply contains the break keyword to immediately exit the loop. This
    way, if either if statement passes, we’ll jump straight to the final print statement
    ❸, without executing the print statement inside the loop ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sample run of this updated version of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This time, when I enter the word *quit*, no you typed 'quit' message appears.
    Instead, the loop ends immediately, so the next message is --- I have left the
    loop! ---.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, it’s a matter of personal preference whether you use break statements
    or a Boolean flag in the loop condition to terminate a loop. If you’re coming
    from a language that doesn’t support break statements, Boolean flags might feel
    more natural. On the other hand, if lots of conditions are being tested to decide
    whether the loop should end, break statements can be more practical. When writing
    a code compiler or programming language tool, for example, tens or hundreds of
    tests might be included. Using break statements can save you from having to scroll
    through pages of code to see what might be happening in the later loop statements,
    after all the tests have been conducted.
  prefs: []
  type: TYPE_NORMAL
- en: for Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A for loop is a style of loop that repeats a set number of times. If you know
    exactly how many times you want to repeat a task (for example, giving a user three
    chances to enter the correct password, or testing students with exactly 10 questions
    selected randomly from a test bank), a for loop may be a better choice than a
    while loop. A for loop hinges around a *counter variable*, customarily called
    $i (short for *iterator*), that governs the number of repetitions. Declaring a
    for loop requires three expressions, all featuring this counter variable:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.   An expression initializing the counter to a starting value
  prefs: []
  type: TYPE_NORMAL
- en: 2.   An expression testing the counter’s value to determine when the loop should
    stop
  prefs: []
  type: TYPE_NORMAL
- en: 3.   An expression to increment (or decrement) the counter after each repetition
    of the loop
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a for loop, all three of these expressions are written in this sequence
    on a single line, immediately after the for keyword, enclosed in a set of parentheses.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here $i = 1 initializes the counter variable to 1. Then $i <= 5 sets the looping
    condition; as long as $i is less than or equal to 5, the loop will continue repeating.
    PHP will check this condition *before* each new repetition of the loop. Finally,
    $i++ uses the increment operator (++) to tell PHP to add 1 to $i *after* each
    pass through the loop. This way, $i gets a new value for each cycle of the loop
    that can be tested against the looping condition. In this case, $i will have a
    value of 1 the first time through, then 2 the second time through, and so on.
    The fifth time through the loop, when $i has a value of 5, the $i <= 5 condition
    still passes, but at the end of the fifth repetition, $i will be incremented to
    6. At this point, $i is no longer less than or equal to 5, so the loop ends after
    five repetitions.
  prefs: []
  type: TYPE_NORMAL
- en: To verify that the for loop works as we expect, let’s fill in the loop’s body
    with a simple print statement, as shown in [Listing 6-5](#lis6-5). This script
    should print the same message five times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-5: An example of a for loop'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare a for loop, using the same set of expressions with the looping variable
    $i we just discussed. Inside the curly brackets delineating the loop’s statement
    group, we write a print statement. Here’s the output of running the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the message indeed prints five times, thanks to the way the
    for loop’s counter variable increments from 1 until it’s no longer less than or
    equal to 5.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Counter in the Loop
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Part of the power of for loops is that the counter variable $i is available
    for use within the body of the loop. This can facilitate working with mathematical
    tasks, or with organized sets of data indexed or identified by a sequence of integers.
    For example, we might want to work with all the items in a database table whose
    IDs are a sequence of integers starting at 1 (see [Part VI](part6.xhtml) for more
    on databases). Or we might want to loop sequentially through all the elements
    of an integer-indexed array (see [Chapter 7](chapter7.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate, [Listing 6-6](#lis6-6) shows an updated version of our original
    for loop that incorporates the value of $i into the printed message. Since $i
    has a different value during each repetition of the loop, each message will now
    be unique.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-6: Using the counter variable $i within a for loop'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve updated the loop’s print statement to include the value of $i. Here’s
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the number in each output line changes based on the value of $i.
    The output helps illustrate how the counter variable is working: it starts at
    1 and increases by 1 with each repetition of the loop. Once $i gets to 6, the
    $i <=5 condition no longer passes, so the loop ends without printing I am repetition
    6 of a for loop.'
  prefs: []
  type: TYPE_NORMAL
- en: So far we’ve been initializing $i to 1, but you can initialize it to any value
    you want. In fact, you’ll find many examples of for loops using a counter variable
    that starts at 0. This is because for loops are often used in conjunction with
    arrays, collections of items that are numbered starting from 0\. We’ll discuss
    arrays, and how to loop through them, in [Chapter 7](chapter7.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you initialize the counter variable to 0, it’s also common to set the
    looping condition with the less-than operator (<) instead of with less-than-or-equal-to
    (<=), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This loop will run as long as $i is less than 3\. Since $i starts at 0, the
    loop will repeat three times, when $i equals 0, 1, and 2.
  prefs: []
  type: TYPE_NORMAL
- en: Skipping Loop Statements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The continue keyword stops the current repetition of a loop, but unlike the
    break keyword, it doesn’t end the loop entirely. Instead, the loop immediately
    jumps ahead to the next repetition. This is useful if you want to skip certain
    passes through a loop. For example, maybe you’re retrieving entries from a database
    and want to ignore certain values, or you want to use only certain numbers in
    a sequence, such as a random sample of every third item in a randomized collection
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-7](#lis6-7) shows an example of a for loop with a continue statement.
    Here we’re using continue to skip odd values of counter variable $i, so we end
    up printing only the even values. The listing also illustrates how a for loop
    can decrement the counter variable instead of incrementing it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-7: Skipping parts of a for loop with continue'
  prefs: []
  type: TYPE_NORMAL
- en: We declare a for loop with the $i counter variable starting at 8 and decreasing
    by 1 after each repetition, thanks to the $i-- decrementing expression. The loop
    will count down to 1, then stop when $i equals 0. Inside the loop, we use the
    modulo operator (%) to test whether the current value of $i is even or odd ❶.
    If even, $i % 2 will be 0, or if odd, $i % 2 will be 1. Either way, we store the
    result in the $odd variable, then use that variable as the condition of an if
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since an if statement requires a Boolean condition, $odd will be type-juggled
    to a Boolean: true for 1 or false for 0. This way, when the value of $i is odd,
    we’ll execute the if statement, which contains just the continue keyword to interrupt
    the current repetition of the loop and skip to the next one. When $i is even,
    we don’t execute the if statement body, allowing us to complete the current repetition
    of the loop by executing the print statement ❷. The net effect is that we print
    out only even values of $i, as the output shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We’ve successfully skipped the odd numbers thanks to our conditional logic triggering
    the continue statement in our loop.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The* continue *keyword works in* while *loops just as it does in* for *loops.
    Likewise, the* break *keyword also works to completely stop a* for *loop.*'
  prefs: []
  type: TYPE_NORMAL
- en: Handling the Last Iteration Differently
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes you might want to do something different during the final repetition
    of a loop. With a while or do...while loop, you can’t know if it’s the final repetition
    until the loop has already ended, but with a for loop, you can anticipate the
    last repetition with conditional logic and write code that treats that last repetition
    differently.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say we’re using a for loop to build up a string containing a list
    of items entered by the user, and we want to separate each item with a comma.
    We might be tempted to write something like [Listing 6-8](#lis6-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-8: A for loop creating a list of items, separated by commas'
  prefs: []
  type: TYPE_NORMAL
- en: 'We initialize a $message variable with the string "go to the market and buy:
    ". Then we assign $numItems the value 3. This will be the number of repetitions
    of our for loop. Next, we declare the for loop, where $i counts up from 1 to $numItems
    (3). Each time through the loop, we prompt the user to enter an item to buy, storing
    the input in the $item variable. We then append the value of $item to the $message
    string, followed by a comma and a space. When the loop ends, we print out the
    $message string that we’ve constructed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that we’re treating each repetition of the loop the same, so
    every item in the final message will have a comma after it, including the last
    one. You can see this in the following sample run of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Our script has built up a message including the three items entered at the command
    line, and unfortunately, a comma appears after the last item, apples. We can fix
    this by adding a test to determine whether we’re on the last repetition of the
    loop. Then we’ll add a comma only if it isn’t the last repetition. [Listing 6-9](#lis6-9)
    shows how to update the script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-9: Updating the script from [Listing 6-8](#lis6-8) to leave off the
    final comma'
  prefs: []
  type: TYPE_NORMAL
- en: This time we first append just the value of $item to the $message string, without
    a comma and space after it. Then we create the Boolean variable $lastIteration,
    giving it the value of the expression $i == $numItems. This expression will be
    true only the last time through the loop. Next, we have an if statement with !$lastIteration
    as the condition. Thanks to the NOT operator (!), this condition will be true
    for all repetitions except the final one. Inside the if statement, we append a
    comma and space to $message. This way, all but the last item in the list will
    have a comma after it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sample run of the updated script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We no longer have a comma after apples, the last item in the list, since we’re
    treating the final repetition of the for loop differently from the others.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Once we start working with arrays, we’ll be able to avoid this kind of last-repetition-is-special
    loop logic by using the built-in* implode() *function. It intelligently adds a
    separator between each item in a list, but not after the last item. We’ll discuss
    this in [Chapter 7](chapter7.xhtml).*'
  prefs: []
  type: TYPE_NORMAL
- en: Alternative Loop Syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PHP provides an alternative syntax for writing while and for loops, setting
    off the contents of the loop with a colon (:) rather than enclosed in curly brackets.
    Just like the alternative syntax for if statements we discussed in [Chapter 4](chapter4.xhtml),
    this other way of writing loops is often useful when combing PHP statements in
    a script with templating text such as HTML for web applications. To demonstrate,
    [Listing 6-10](#lis6-10) uses the alternative syntax to rewrite the password-setting
    while loop from [Listing 6-1](#lis6-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-10: An alternative syntax for the while loop from [Listing 6-1](#lis6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the line declaring the while loop ends with a colon rather than
    an opening curly bracket. In lieu of a closing curly bracket, we signal the end
    of the loop with the endwhile keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-11](#lis6-11) likewise shows the alternative syntax for the for
    loop from [Listing 6-6](#lis6-6).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-11: An alternative syntax for the for loop from [Listing 6-6](#lis6-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Again, notice the colon at the end of the line declaring the loop, and the endfor
    keyword to indicate the end of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*PHP has no alternative syntax for a* do...while *loop.*'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Infinite Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s all too easy to accidentally get trapped in an infinite loop that keeps
    repeating forever because the stopping condition is never met. To avoid this,
    it’s important to make sure the condition controlling the loop can and will be
    false when appropriate. One way to mistakenly write an infinite for loop is to
    set the increment expression to move in the wrong direction relative to the looping
    condition. For example, consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This increment expression adds 1 to $i after each repetition. Meanwhile, the
    looping condition tests whether $i is greater than 0. Since $i is growing with
    each repetition, it will always be greater than 0, so the loop will never end.
    The solution is to make $i decrement rather than increment, or to change the looping
    condition to some kind of less-than comparison.
  prefs: []
  type: TYPE_NORMAL
- en: With while and do...while loops, you can get stuck repeating forever if the
    variables in the loop condition don’t have a chance to be changed correctly in
    the loop statements. For example, say we want to write a script that totals up
    prices entered by the user until the total exceeds $100, then print out the result.
    We might accidentally create an infinite loop by writing something like [Listing
    6-12](#lis6-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-12: An unintentionally infinite do...while loop'
  prefs: []
  type: TYPE_NORMAL
- en: We set $total to 0, then enter a do...while loop that keeps repeating while
    $total is less than 100\. Inside the loop, we take in a line of input from the
    user and verify it’s numeric. If it is, we convert the input to a float and store
    the value in $total ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Do you see the problem? We should have used something like $total += floatval($costString);
    to add the latest input to the value already in $total, but we’ve used a regular
    assignment operator (=) rather than an addition assignment operator (+=). As a
    result, the value of $total will always be the last value entered. If the user
    ever enters a value greater than 100, the loop will end, and the print statement
    will echo back that last value. Otherwise, we’ll be stuck in an infinite loop,
    without really calculating a running total.
  prefs: []
  type: TYPE_NORMAL
- en: An infinite while loop also occurs when the variable tested in the loop condition
    never changes, so once the loop is entered, it’s never exited. Returning to [Listing
    6-12](#lis6-12), for example, we might use a $grandTotal variable to set the looping
    condition, as in while ($grandTotal < 100), but then increment the $total variable
    inside the loop instead of $grandTotal. This way, $grandTotal would never change,
    so the loop would run forever.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we examined while loops, do...while loops, and for loops, which
    all offer different methods of repeating a sequence of statements. The key to
    these looping control structures is determining how long the loop should keep
    repeating, either by setting a condition for when the loop should stop, as in
    a while or do...while loop, or by specifying a fixed number of repetitions, as
    in a for loop. In addition to the basic structure of these loops, we discussed
    break and continue statements, which provide a mechanism for abruptly ending an
    entire loop or the current repetition of a loop, respectively. Armed with control
    structures like loops and choice statements, you’ll be able to write sophisticated
    programs that perform repetitive tasks and make decisions in response to the current
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Use a do...while loop to keep taking in words input by the user until they
    enter one that begins with a capital letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Compare the string entered with the value returned by the ucfirst() function.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Use a break statement with a while (true) loop to keep taking in strings
    input by the user until one is numeric.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Use the is_numeric() function.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Use a continue statement in a for loop to print out all the multiples of
    3 up to 21 (3, 6, 9, and so on).
  prefs: []
  type: TYPE_NORMAL
