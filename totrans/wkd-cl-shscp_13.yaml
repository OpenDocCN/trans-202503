- en: '**12**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SHELL SCRIPT FUN AND GAMES**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Up to this point, we’ve focused on serious uses of shell scripts to improve
    your interaction with your system and make the system more flexible and powerful.
    But there’s another side to shell scripts that’s worth exploring: games.'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry—we’re not proposing that you write *Fallout 4* as a shell script.
    There just happen to be some simple games that are easily and informatively written
    as shell scripts. And wouldn’t you rather learn how to debug shell scripts with
    something fun than with some utility for suspending user accounts or analyzing
    Apache error logs?
  prefs: []
  type: TYPE_NORMAL
- en: For some of the scripts, you’ll need files from the book’s resources, found
    at *[http://www.nostarch.com/wcss2/](http://www.nostarch.com/wcss2/)*, so download
    that file now if you haven’t already.
  prefs: []
  type: TYPE_NORMAL
- en: '**TWO QUICK TRICKS**'
  prefs: []
  type: TYPE_NORMAL
- en: Here are two quick examples up front to show you what we mean. First off, old-school
    Usenet users know about *rot13*, a simple mechanism whereby off-color jokes and
    obscene text are obscured to make them a bit less easily read. It’s a *substitution
    cipher*, and it’s remarkably simple to accomplish in Unix.
  prefs: []
  type: TYPE_NORMAL
- en: To rot13 something, feed it through `tr`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To unwrap it, apply the same transform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A famous substitution cipher of this nature is associated with the movie *2001:
    A Space Odyssey*. Remember the computer’s name? Check it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Another short example is a palindrome checker. Enter something you believe is
    a palindrome, and the code will test it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A palindrome is a word that’s identical forward and backward, so the first step
    is to remove all non-alphabetic characters and ensure that all letters are lowercase.
    Then the Unix utility `rev` reverses the letters in a line of input. If the forward
    and backward versions are the same, we’ve got a palindrome; if they differ, we
    don’t.
  prefs: []
  type: TYPE_NORMAL
- en: The games in this chapter are only a bit more complex, but all will prove fun
    and worth adding to your system.
  prefs: []
  type: TYPE_NORMAL
- en: '**#83 Unscramble: A Word Game**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a basic anagram game. If you’ve seen the *Jumble* game in your newspaper
    or played word games at all, you’ll be familiar with the concept: a word is picked
    at random and then scrambled. Your task is to figure out what the original word
    is in the minimum number of turns. The full script for this game is in [Listing
    12-1](ch12.xhtml#ch12ex1), but to get the word list, you’ll also need to download
    the *long-words.txt* file from the book’s resources *[http://www.nostarch.com/wcss2/](http://www.nostarch.com/wcss2/)*
    and save it in the directory */usr/lib/games*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-1: The* `*unscramble*` *shell script game*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To randomly pick a single line from a file, this script uses `randomquote`
    ([Script #68](ch08.xhtml#ch08lev1sec07) on [page 213](ch08.xhtml#page_213)) ➊,
    even though that script was originally written to work with web pages (like many
    good Unix utilities, it turns out to be useful in contexts other than the one
    for which it was intended).'
  prefs: []
  type: TYPE_NORMAL
- en: The toughest part of this script was figuring out how to scramble a word. There’s
    no handy Unix utility for that, but it turns out that we can scramble the word
    differently and unpredictably each time if we go letter by letter through the
    correctly spelled word and randomly add each subsequent letter to either the beginning
    or the end of the scrambled sequence ➋.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice where `$scrambled` is located in the two lines: in the first line the
    added letter is appended, while in the second it is prepended.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise the main game logic should be easily understood: the outer `until`
    loop ➌ runs until the user enters `quit` as a guess, while the inner `while` loop
    ➍ runs until the user either guesses the word or types `next` to skip to the next
    word.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script has no arguments or parameters, so just enter the name and you’re
    ready to play!
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After running, the shell script presents scrambled words of various lengths
    to the user, keeping track of how many words the user has successfully unscrambled,
    as [Listing 12-2](ch12.xhtml#ch12ex2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-2: Running the* `*unscramble*` *shell script game*'
  prefs: []
  type: TYPE_NORMAL
- en: Clearly an inspired guess on that first one!
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some method of offering a clue would make this game more interesting, as would
    a flag that requests the minimum word length that is acceptable. To accomplish
    the former, perhaps the first *n* letters of the unscrambled word could be shown
    for a certain penalty in the scoring; each clue requested would show one additional
    letter. For the latter, you’d need to have an expanded word dictionary as the
    one included with the script has a minimum word length of 10 letters—tricky!
  prefs: []
  type: TYPE_NORMAL
- en: '**#84 Hangman: Guess the Word Before It’s Too Late**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A word game with a macabre metaphor, hangman is nonetheless an enjoyable classic.
    In the game, you guess letters that might be in the hidden word, and each time
    you guess incorrectly, the man hanging on the gallows has an additional body part
    drawn in. Make too many wrong guesses, and the man is fully illustrated, so not
    only do you lose but, well, you presumably die too. Rather draconian consequences!
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the game itself is fun, and writing it as a shell script proves surprisingly
    easy, as [Listing 12-3](ch12.xhtml#ch12ex3) shows. For this script, you again
    need the word list we used in [Script #83](ch12.xhtml#ch12lev1sec01) on [page
    275](ch12.xhtml#page_275): save the *long-words.txt* file from the book’s resources
    in the directory */usr/lib/games*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-3: The* `*hangman*` *shell script game*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The tests in this script are all interesting and worth examination. Consider
    the test at ➊ that checks whether the player has entered more than a single letter
    as a guess.
  prefs: []
  type: TYPE_NORMAL
- en: Why test for the value 2 rather than 1? Because the entered value has a carriage
    return from when the user hit ENTER (which is a character, `\n`), it has two letters
    if it’s correct, not one. The `sed` in this statement strips out all non-digit
    values, of course, to avoid any confusion with the leading tab that `wc` likes
    to emit.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for lowercase is straightforward ➋. Remove all lowercase letters from
    `guess` and see whether the result is zero (empty) or not.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to see whether the user has guessed the letter already, transform the
    guess such that any letters in `guess` that also appear in the `guessed` variable
    are removed. Is the result zero (empty) or not ➌?
  prefs: []
  type: TYPE_NORMAL
- en: Apart from all these tests, the trick behind getting `hangman` to work is to
    replace each guessed letter in the original word with a dash wherever that letter
    appears in the word and then compare the result to the original word in which
    no letters have been replaced by dashes ➍. If they’re different (that is, if one
    or more letters in the word are now dashes), the guessed letter is in the word.
    Guessing the letter *a*, for instance, when the word is *cat*, will result in
    the `guessed` variable holding your guess with a value of ‘-a-’.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key ideas that makes it possible to write hangman is that the partially
    filled-in word shown to the player, the variable `partial`, is rebuilt each time
    a correct guess is made. Because the variable `guessed` accumulates each letter
    guessed by the player, a `sed` transformation that translates into a dash each
    letter in the original word that is *not* in the `guessed` string does the trick
    ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The hangman game has one optional argument: if you specify a numeric value
    as a parameter, the code will use that as the number of incorrect guesses allowed,
    rather than the default of 6\. [Listing 12-4](ch12.xhtml#ch12ex4) shows playing
    the `hangman` script with no arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-4: Playing the* `*hangman*` *shell script game*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Obviously it’s difficult to have the guy-hanging-on-the-gallows graphic with
    a shell script, so we use the alternative of counting “steps to the gallows.”
    If you were motivated, however, you could probably have a series of predefined
    “text” graphics, one for each step, and output them as the game proceeds. Or you
    could choose a nonviolent alternative of some sort!
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is possible to pick the same word twice, but with the default word
    list containing 2,882 different words, there’s not much chance of that. If this
    is a concern, however, the line where the word is chosen could also save all previous
    words in a variable and screen against them to ensure that there aren’t any repeats.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you’re motivated, it’d be nice to have the guessed-letters list
    sorted alphabetically. There are a couple of approaches to this, but we’d use
    `sed|sort`.
  prefs: []
  type: TYPE_NORMAL
- en: '**#85 A State Capitals Quiz**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have a tool for choosing a line randomly from a file, there’s no limit
    to the types of quiz games you can write. We’ve pulled together a list of the
    capitals of all 50 states in the United States, available for download from *[http://www.nostarch.com/wcss2/](http://www.nostarch.com/wcss2/)*.
    Save the file *state.capitals.txt* in your */usr/lib/games* directory. The script
    in [Listing 12-5](ch12.xhtml#ch12ex5) randomly chooses a line from the file, shows
    the state, and asks the user to enter the matching capital.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-5: The* `*states*` *trivia game shell script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For such an entertaining game, `states` involves very simple scripting. The
    data file contains state/capital pairs, with all spaces in the state and capital
    names replaced with dashes and the two fields separated by a single space. As
    a result, extracting the city and state names from the data is easy ➊.
  prefs: []
  type: TYPE_NORMAL
- en: Each guess is compared against both the all-lowercase version of the city name
    (`match`) and the correctly capitalized city name to see whether it’s correct.
    If not, the guess is compared against the two command words `next` and `quit`.
    If either matches, the script shows the answer and either prompts for another
    state or quits, as appropriate. If there are no matches, the guess is considered
    incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script has no arguments or command flags. Just start it up and play!
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ready to quiz yourself on state capitals? [Listing 12-6](ch12.xhtml#ch12ex6)
    shows our state capital trivia skills in action!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-6: Running the* `*states*` *trivia game shell script*'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the game tracks only ultimately correct guesses, not how many incorrect
    guesses you made or whether you popped over to Google to get the answer!
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Probably the greatest weakness in this game is that it’s picky about spelling.
    A useful modification would be to add code to allow fuzzy matching, so that the
    user entry of `Juneu` might match Juneau, for example. This could be done using
    a modified *Soundex algorithm*, in which vowels are removed and doubled letters
    are squished down to a single letter (for example, Annapolis would transform to
    `npls`). This might be too forgiving for your tastes, but the general concept
    is worth considering.
  prefs: []
  type: TYPE_NORMAL
- en: As with other games, a hint function would be useful, too. Perhaps it would
    show the first letter of the correct answer when requested and keep track of how
    many hints are used as the play proceeds.
  prefs: []
  type: TYPE_NORMAL
- en: Although this game is written for state capitals, it would be trivial to modify
    the script to work with any sort of paired data file. For example, with a different
    file, you could create an Italian vocabulary quiz, a country/currency match, or
    a politician/political party quiz. As we’ve seen repeatedly in Unix, writing something
    that is reasonably general purpose allows it to be reused in useful and occasionally
    unexpected ways.
  prefs: []
  type: TYPE_NORMAL
- en: '**#86 Is That Number a Prime?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prime numbers are numbers that are divisible only by themselves, for example,
    7\. On the other hand, 6 and 8 are not prime numbers. Recognizing prime numbers
    is easy with single digits, but it gets more complicated when we jump up to bigger
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: There are different mathematical approaches to figuring out whether a number
    is prime, but let’s stick with the brute-force method of trying all possible divisors
    to see whether any have a remainder of zero, as [Listing 12-7](ch12.xhtml#ch12ex7)
    shows.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-7: The* `*isprime*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The heart of this script is in the `while` loop, so take a look at that more
    closely at ➊. If we were trying a `number` of 77, the conditional statement would
    be testing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously this is false: 77 does not divide evenly by 2\. Each time the code
    tests a potential divisor (`$counter`) and finds that it doesn’t divide evenly,
    it calculates the remainder (`$number % $counter)` and increments the `$counter`
    by 1\. Ploddingly, it proceeds.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s pick a few numbers that seem like they could be prime and test them in
    [Listing 12-8](ch12.xhtml#ch12ex8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-8: Running the* `*isprime*` *shell script on some numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re curious, uncomment out the `echo` statement in the `while` loop to
    see the calculations and get a sense of how quickly—or slowly—the script finds
    a divisor that divides evenly into the number without a remainder. In fact, let’s
    do just that and test 77, as shown in [Listing 12-9](ch12.xhtml#ch12ex9).
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-9: Running the* `*isprime*` *script with debug lines uncommented*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are some inefficiencies in the implementation of the mathematical formula
    in this script that slow it way down. For example, consider the `while` loop conditional.
    We keep calculating `$(expr $number / 2)` when we can just calculate that value
    once and use the calculated value for each subsequent iteration, saving the need
    to spawn a subshell and invoking `expr` to find out that the value hasn’t changed
    one iota since the last iteration.
  prefs: []
  type: TYPE_NORMAL
- en: There are also some far smarter algorithms to test for prime numbers, and these
    are worth exploring, including the delightfully named sieve of Eratosthenes, along
    with more modern formulas such as the sieve of Sundaram and the rather more complicated
    sieve of Atkin. Check them out online and test whether your phone number (without
    dashes!) is a prime or not.
  prefs: []
  type: TYPE_NORMAL
- en: '**#87 Let’s Roll Some Dice**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a handy script for anyone who enjoys tabletop games, especially role-playing
    games like *Dungeons & Dragons*.
  prefs: []
  type: TYPE_NORMAL
- en: The common perception of these games is that they’re just a lot of dice rolling,
    and that’s actually accurate. It’s all about probabilities, so sometimes you’re
    rolling a 20-sided die and other times you’re rolling six 6-sided dice. Dice are
    such an easy random number generator that a huge number of games use them, whether
    it’s one die, two (think *Monopoly* or *Trouble*), or more.
  prefs: []
  type: TYPE_NORMAL
- en: They all turn out to be easy to model, and that’s what the script in [Listing
    12-10](ch12.xhtml#ch12ex10) does, letting the user specify how many of what kind
    of dice are needed, then “rolling” them all, and offering a sum.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-10: The* `*rolldice*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script revolves around a simple line of code that invokes the bash random
    number generator through the expedient shortcut of referencing `$RANDOM` ➌. That’s
    the key line; everything else is just window dressing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other interesting segment is where the dice description is broken down
    ➊, because the script supports all three of these notations: `3d8`, `d6`, and
    `20`. This is a standard gaming notation, for convenience: number of dice + *d*
    + sides the die should have. For example, `2d6` means two 6-sided dice. See if
    you can figure out how each is processed.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s a fair bit of output for such a simple script. You’ll probably want
    to adjust this to your own preferences, but here you can see that the statement
    is just a handy way to verify that it parsed the die or dice request properly.
  prefs: []
  type: TYPE_NORMAL
- en: Oh, and the `cut` invocation ➋? Remember that `-d` indicates the field delimiter,
    so `-dd` simply says to use the letter *d* as that delimiter, as needed for this
    particular dice notation.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s start easy: in [Listing 12-11](ch12.xhtml#ch12ex11), we’ll use two 6-sided
    dice, as if we were playing *Monopoly*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-11: Testing the* `*rolldice*` *script with a pair of six-sided
    dice*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the first time it “rolled” the two dice, they came up 6 and 2, but
    the second time they came up 4 and 2.
  prefs: []
  type: TYPE_NORMAL
- en: How about a quick *Yahtzee* roll? Easy enough. We’ll roll five six-sided dice
    in [Listing 12-12](ch12.xhtml#ch12ex12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-12: Testing the* `*rolldice*` *script with five six-sided dice*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Not a very good roll: 1, 2, 2, 3, 5\. If we were playing *Yahtzee*, we’d keep
    the pair of 2s and reroll everything else.'
  prefs: []
  type: TYPE_NORMAL
- en: This gets more interesting when you have a more complicated set of dice to roll.
    In [Listing 12-13](ch12.xhtml#ch12ex13), let’s try two 18-sided dice, one 37-sided
    die, and a 3-sided die (since we don’t have to worry about the limitations of
    3D geometric shapes).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-13: Running the* `*rolldice*` *script with an assortment of dice
    types*'
  prefs: []
  type: TYPE_NORMAL
- en: Cool, eh? A few additional rolls of this motley set of dice yielded 22, 49,
    and 47\. Now you know, gamers!
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s not much to hack in this script since the task is so easy. The only
    thing we would recommend is fine-tuning the amount of output that the program
    produces. For example, a notation like `5d6: 2 3 1 3 7 = 16` would be more space
    efficient.'
  prefs: []
  type: TYPE_NORMAL
- en: '**#88 Acey Deucey**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For our last script in this chapter, we’ll create the card game Acey Deucey,
    which means we’ll need to figure out how to create and “shuffle” a deck of playing
    cards to get randomized results. This is tricky, but the functions you write for
    this game will give you a general purpose solution you can use to make a more
    complicated game like blackjack or even rummy or Go Fish.
  prefs: []
  type: TYPE_NORMAL
- en: 'The game is simple: deal two cards, and then bet whether the next card you’re
    going to flip up ranks between the two existing cards. Suit is irrelevant; it’s
    all about the card rank, and a tie loses. Thus, if you flip up a 6 of hearts and
    a 9 of clubs and the third card is a 6 of diamonds, it’s a loss. A 4 of spades
    is also a loss. But a 7 of clubs is a win.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So there are two tasks here: the entire card deck simulation and the logic
    of the game itself, including asking the user whether they want to make a bet.
    Oh, and one more thing: if you deal two cards that have the same rank, there’s
    no point betting because you can’t win.'
  prefs: []
  type: TYPE_NORMAL
- en: That’ll make an interesting script. Ready? Then go to [Listing 12-14](ch12.xhtml#ch12ex14).
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-14: The* `*aceydeucey*` *script game*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Simulating a deck of shuffled playing cards is not easy. There’s the question
    of how to portray the cards themselves and of how to “shuffle” or randomly organize
    an otherwise neatly ordered deck.
  prefs: []
  type: TYPE_NORMAL
- en: 'To address this, we create two arrays of 52 elements: `deck[]` ➊ and `newdeck[]`
    ➋. The former is an array of the ordered cards where each value is replaced by
    a `-1` as it’s “selected” and put into a random slot of `newdeck[]`. The `newdeck[]`
    array, then, is the “shuffled” deck. While in this game we only ever use the first
    three cards, the general solution is far more interesting to consider than the
    specific one.'
  prefs: []
  type: TYPE_NORMAL
- en: That means this script is overkill. But hey, it’s interesting. ![image](../images/common1.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s step through the functions to see how things work. First off, initializing
    the deck is really simple, as you can see if you flip back and examine the `initializeDeck`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, `shuffleDeck` is surprisingly straightforward because all the work
    is really done in the `pickCard` function. But `shuffleDeck` simply steps through
    the 52 slots in `deck[]`, randomly picks a value that hasn’t yet been picked,
    and saves it in the *n*th array space of `newdeck[]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at `pickCard` ➌ because that’s where the heavy lifting of the shuffle
    occurs. The function is broken into two blocks: the first attempts to randomly
    pick an available card, giving it `$threshold` tries to succeed. As the function
    is called again and again, the first calls always succeed at this, but later in
    the process, once 50 cards are already moved over into the `newdeck[]`, it’s quite
    possible that 10 random guesses all yield a fail. That’s the `while` block of
    code at ➍.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `$errcount` is equal to `$threshold`, we basically give up on this strategy
    in the interest of performance and move to the second block of code: stepping
    through the deck card by card until we find an available card. That’s the block
    at ➎.'
  prefs: []
  type: TYPE_NORMAL
- en: If you think about the implications of this strategy, you’ll realize that the
    lower you set the threshold, the more likely that `newdeck` will be sequential,
    particularly later in the deck. At the extreme, `threshold = 1` would yield an
    ordered deck where `newdeck[]` = `deck[]`. Is 10 the right value? That’s a bit
    beyond the scope of this book, but we’d welcome email from someone who wanted
    to experimentally ascertain the best balance of randomness and performance!
  prefs: []
  type: TYPE_NORMAL
- en: The `showCard` function is long, but most of those lines are really just about
    making the results pretty. The core of the entire deck simulation is captured
    in the two lines at ➏.
  prefs: []
  type: TYPE_NORMAL
- en: For this game, suit is irrelevant, but you can see that for a given card value,
    the rank is going to be 0–12 and the suit would be 0–3\. The cards’ qualities
    just need to be mapped to user-friendly values. To make debugging easy, a 6 of
    clubs has a rank 6, and an ace has rank 1\. A king has a default rank of 0, but
    we adjust it to rank 13 so the math works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dealCards` function ➐ is where the actual Acey Deucey game comes into
    play: all the previous functions are dedicated to implementing the useful set
    of functions for any card game. The `dealCards` function deals out all three cards
    required for the game, even though the third card is hidden until after the player
    places their bet. This just makes life easier—it’s not so that the computer can
    cheat! Here you can also see that the separately stored rank values (`$rank1`,
    `$rank2`, and `$rank3`) are fixed for the king = 13 scenario. Also to make life
    easier, the top two cards are sorted so that the lower-rank card always comes
    first. That’s the `if` chunk at ➑.'
  prefs: []
  type: TYPE_NORMAL
- en: At ➒, it’s time to show what’s dealt. The last step is to present the cards,
    check whether the ranks match (in which case we’ll skip the prompt that lets the
    user decide whether to bet), and then test whether the third card is between the
    first two. This test is done in the code block at ➓.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the result of the bet is tricky. If you bet that the drawn card will
    be between the first two cards and it is, or you bet that it won’t be and it isn’t,
    you’re a winner. Otherwise you lose. This result is figured out in the final block.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Specify any starting parameter and the game will give you a rudimentary explanation
    of how to play. Otherwise, you just jump in.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the intro in [Listing 12-15](ch12.xhtml#ch12ex15).
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-15: Playing the* `*aceydeucey*` *script game*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s the lingering question of whether the deck is shuffled adequately with
    a threshold of 10; that’s one area that can definitely be improved. It’s also
    not clear whether showing the spread (the difference between the ranks of the
    two cards) is beneficial. Certainly you wouldn’t do that in a real game; the player
    would need to figure it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then again, you could go in the opposite direction and calculate the odds of
    having a card between two arbitrary card values. Let’s think about this: the odds
    of any given card being drawn is 1 out of 52\. If there are 50 cards left in the
    deck because two have already been dealt, the odds of any given card coming up
    is 1 out of 50\. Since suit is irrelevant, there are 4 out of 50 chances that
    any different rank comes up. Therefore, the odds of a given spread are (the number
    of cards in that possible spread × 4) out of 50\. If a 5 and a 10 are dealt, the
    spread is 4, since the possible winning cards are a 6, 7, 8, or 9\. So the odds
    of winning are 4 × 4 out of 50\. See what we mean?'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as with every command line–based game, the interface could do with
    some work. We’ll leave that up to you. We’ll also leave you the question of what
    other games to explore with this handy library of playing-card functions.
  prefs: []
  type: TYPE_NORMAL
