- en: '**12**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**12**'
- en: '**SHELL SCRIPT FUN AND GAMES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**SHELL脚本趣味与游戏**'
- en: '![image](../images/common4.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common4.jpg)'
- en: 'Up to this point, we’ve focused on serious uses of shell scripts to improve
    your interaction with your system and make the system more flexible and powerful.
    But there’s another side to shell scripts that’s worth exploring: games.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们关注的是Shell脚本的严肃应用，旨在改善你与系统的互动，并使系统更具灵活性和强大功能。但是，Shell脚本还有另一个值得探索的方面：游戏。
- en: Don’t worry—we’re not proposing that you write *Fallout 4* as a shell script.
    There just happen to be some simple games that are easily and informatively written
    as shell scripts. And wouldn’t you rather learn how to debug shell scripts with
    something fun than with some utility for suspending user accounts or analyzing
    Apache error logs?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心——我们并不是提议你把*Fallout 4*写成Shell脚本。只是有一些简单的游戏，非常适合用Shell脚本来编写，并且具有很高的可读性。你不希望通过一些有趣的脚本来学习如何调试Shell脚本，而不是通过一些暂停用户帐户或分析Apache错误日志的工具吗？
- en: For some of the scripts, you’ll need files from the book’s resources, found
    at *[http://www.nostarch.com/wcss2/](http://www.nostarch.com/wcss2/)*, so download
    that file now if you haven’t already.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其中的一些脚本，你需要从书籍资源中获取文件，文件可以在*[http://www.nostarch.com/wcss2/](http://www.nostarch.com/wcss2/)*找到，如果你还没有下载文件，现在就去下载。
- en: '**TWO QUICK TRICKS**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**两个快速技巧**'
- en: Here are two quick examples up front to show you what we mean. First off, old-school
    Usenet users know about *rot13*, a simple mechanism whereby off-color jokes and
    obscene text are obscured to make them a bit less easily read. It’s a *substitution
    cipher*, and it’s remarkably simple to accomplish in Unix.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个快速示例，向你展示我们的意思。首先，老派的Usenet用户知道*rot13*，这是一种简单的机制，通过这种机制，黄色笑话和猥亵文字会被模糊化，使它们稍微不那么容易被读取。这是一种*替代加密*，在Unix中非常容易实现。
- en: To rot13 something, feed it through `tr`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要对某个内容进行rot13编码，可以通过`tr`命令来处理。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s an example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To unwrap it, apply the same transform:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要解开它，应用相同的转换：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A famous substitution cipher of this nature is associated with the movie *2001:
    A Space Odyssey*. Remember the computer’s name? Check it out:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种著名的替代加密方法与电影*2001太空漫游*有关。还记得计算机的名字吗？来看一下：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Another short example is a palindrome checker. Enter something you believe is
    a palindrome, and the code will test it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个简短的示例是回文检测器。输入你认为是回文的内容，代码将对其进行测试。
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A palindrome is a word that’s identical forward and backward, so the first step
    is to remove all non-alphabetic characters and ensure that all letters are lowercase.
    Then the Unix utility `rev` reverses the letters in a line of input. If the forward
    and backward versions are the same, we’ve got a palindrome; if they differ, we
    don’t.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 回文是一个前后相同的单词，因此第一步是去除所有非字母字符，并确保所有字母都是小写字母。然后，Unix工具`rev`会反转输入行中的字母。如果正向和反向版本相同，那么就是回文；如果不同，则不是回文。
- en: The games in this chapter are only a bit more complex, but all will prove fun
    and worth adding to your system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的游戏只是稍微复杂一点，但都非常有趣，值得添加到你的系统中。
- en: '**#83 Unscramble: A Word Game**'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#83 解谜：文字游戏**'
- en: 'This is a basic anagram game. If you’ve seen the *Jumble* game in your newspaper
    or played word games at all, you’ll be familiar with the concept: a word is picked
    at random and then scrambled. Your task is to figure out what the original word
    is in the minimum number of turns. The full script for this game is in [Listing
    12-1](ch12.xhtml#ch12ex1), but to get the word list, you’ll also need to download
    the *long-words.txt* file from the book’s resources *[http://www.nostarch.com/wcss2/](http://www.nostarch.com/wcss2/)*
    and save it in the directory */usr/lib/games*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的字谜游戏。如果你曾在报纸上玩过*Jumble*游戏，或者玩过任何文字游戏，你应该熟悉这个概念：随机挑选一个单词并将其打乱。你的任务是在最少的回合内找出原始单词。这个游戏的完整脚本在[清单12-1](ch12.xhtml#ch12ex1)中，但要获取单词列表，你还需要从书籍资源中下载*long-words.txt*文件，网址是*[http://www.nostarch.com/wcss2/](http://www.nostarch.com/wcss2/)*，并将其保存在目录*/usr/lib/games*中。
- en: '***The Code***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 12-1: The* `*unscramble*` *shell script game*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单12-1：* `*unscramble*` *Shell脚本游戏*'
- en: '***How It Works***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'To randomly pick a single line from a file, this script uses `randomquote`
    ([Script #68](ch08.xhtml#ch08lev1sec07) on [page 213](ch08.xhtml#page_213)) ➊,
    even though that script was originally written to work with web pages (like many
    good Unix utilities, it turns out to be useful in contexts other than the one
    for which it was intended).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '要从文件中随机选取一行，脚本使用了 `randomquote` （参见 [Script #68](ch08.xhtml#ch08lev1sec07)
    ，[第 213 页](ch08.xhtml#page_213)） ➊，即使该脚本最初是为处理网页而编写的（就像许多优秀的 Unix 工具一样，事实上，它在其他场景中也非常有用）。'
- en: The toughest part of this script was figuring out how to scramble a word. There’s
    no handy Unix utility for that, but it turns out that we can scramble the word
    differently and unpredictably each time if we go letter by letter through the
    correctly spelled word and randomly add each subsequent letter to either the beginning
    or the end of the scrambled sequence ➋.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本最难的部分是弄清楚如何打乱单词。虽然没有直接可用的 Unix 工具，但事实证明，如果我们按字母逐个检查正确拼写的单词，并随机将每个后续字母加到打乱序列的开头或结尾，那么我们每次都能以不同且不可预测的方式打乱单词
    ➋。
- en: 'Notice where `$scrambled` is located in the two lines: in the first line the
    added letter is appended, while in the second it is prepended.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `$scrambled` 在两行中的位置：在第一行中，添加的字母被追加，而在第二行中，它被放置在开头。
- en: 'Otherwise the main game logic should be easily understood: the outer `until`
    loop ➌ runs until the user enters `quit` as a guess, while the inner `while` loop
    ➍ runs until the user either guesses the word or types `next` to skip to the next
    word.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，游戏的主要逻辑应该很容易理解：外层的 `until` 循环 ➌ 会一直运行，直到用户输入 `quit` 作为猜测，而内层的 `while` 循环
    ➍ 会一直运行，直到用户猜出单词或输入 `next` 跳到下一个单词。
- en: '***Running the Script***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This script has no arguments or parameters, so just enter the name and you’re
    ready to play!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本没有参数或选项，所以只需输入名称即可开始游戏！
- en: '***The Results***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: After running, the shell script presents scrambled words of various lengths
    to the user, keeping track of how many words the user has successfully unscrambled,
    as [Listing 12-2](ch12.xhtml#ch12ex2) shows.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后，脚本会将各种长度的打乱单词呈现给用户，并跟踪用户成功解开的单词数量，如 [Listing 12-2](ch12.xhtml#ch12ex2) 所示。
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 12-2: Running the* `*unscramble*` *shell script game*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-2: 运行* `*unscramble*` *shell 脚本游戏*'
- en: Clearly an inspired guess on that first one!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 显然第一个猜测非常有灵感！
- en: '***Hacking the Script***'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: Some method of offering a clue would make this game more interesting, as would
    a flag that requests the minimum word length that is acceptable. To accomplish
    the former, perhaps the first *n* letters of the unscrambled word could be shown
    for a certain penalty in the scoring; each clue requested would show one additional
    letter. For the latter, you’d need to have an expanded word dictionary as the
    one included with the script has a minimum word length of 10 letters—tricky!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 提供某种线索的方式会让这个游戏更加有趣，如果能有一个提示最小可接受单词长度的标志，那就更好了。为了实现前者，或许可以将未打乱单词的前 *n* 个字母展示出来，作为一种在得分中扣除的惩罚；每次请求提示时，都会展示一个额外的字母。对于后者，你需要一个扩展的单词字典，因为脚本中包含的字典的最小单词长度为
    10 个字母——这有点难！
- en: '**#84 Hangman: Guess the Word Before It’s Too Late**'
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#84 刽子手：在为时已晚之前猜出单词**'
- en: A word game with a macabre metaphor, hangman is nonetheless an enjoyable classic.
    In the game, you guess letters that might be in the hidden word, and each time
    you guess incorrectly, the man hanging on the gallows has an additional body part
    drawn in. Make too many wrong guesses, and the man is fully illustrated, so not
    only do you lose but, well, you presumably die too. Rather draconian consequences!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**“刽子手”**是一个带有恐怖隐喻的文字游戏，尽管如此，它依然是一个令人愉快的经典游戏。在这个游戏中，你需要猜测隐藏单词中的字母，每次猜错时，吊在绞刑架上的人就会多出一部分身体。如果你猜错太多次，那个“人”就会被完全画出，这样不仅你会失败，嗯，你大概也会死。后果相当严苛！'
- en: 'However, the game itself is fun, and writing it as a shell script proves surprisingly
    easy, as [Listing 12-3](ch12.xhtml#ch12ex3) shows. For this script, you again
    need the word list we used in [Script #83](ch12.xhtml#ch12lev1sec01) on [page
    275](ch12.xhtml#page_275): save the *long-words.txt* file from the book’s resources
    in the directory */usr/lib/games*.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，游戏本身很有趣，且将其编写为 shell 脚本证明意外地简单，如 [Listing 12-3](ch12.xhtml#ch12ex3) 所示。对于这个脚本，你仍然需要我们在
    [Script #83](ch12.xhtml#ch12lev1sec01) 中使用的单词列表，该文件位于 [第 275 页](ch12.xhtml#page_275)：将书中的
    *long-words.txt* 文件保存在目录 */usr/lib/games* 中。'
- en: '***The Code***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 12-3: The* `*hangman*` *shell script game*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-3: The* `*hangman*` *shell 脚本游戏*'
- en: '***How It Works***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: The tests in this script are all interesting and worth examination. Consider
    the test at ➊ that checks whether the player has entered more than a single letter
    as a guess.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本中的测试都很有趣，值得仔细检查。考虑一下在 ➊ 处的测试，它检查玩家是否输入了多个字母作为猜测。
- en: Why test for the value 2 rather than 1? Because the entered value has a carriage
    return from when the user hit ENTER (which is a character, `\n`), it has two letters
    if it’s correct, not one. The `sed` in this statement strips out all non-digit
    values, of course, to avoid any confusion with the leading tab that `wc` likes
    to emit.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么测试值是 2 而不是 1？因为输入的值包含了用户按下 ENTER 键时产生的回车符（即字符 `\n`），如果正确输入，它将有两个字母，而不是一个。这个语句中的
    `sed` 会去除所有非数字字符，当然是为了避免与 `wc` 喜欢输出的前导制表符产生混淆。
- en: Testing for lowercase is straightforward ➋. Remove all lowercase letters from
    `guess` and see whether the result is zero (empty) or not.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 测试小写字母是否正确非常简单 ➋。去除`guess`中的所有小写字母，看看结果是否为零（空）。
- en: Finally, to see whether the user has guessed the letter already, transform the
    guess such that any letters in `guess` that also appear in the `guessed` variable
    are removed. Is the result zero (empty) or not ➌?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了检查用户是否已经猜过某个字母，将猜测转换为：将`guess`中与`guessed`变量中已出现的字母去除。结果是零（空）还是其他 ➌？
- en: Apart from all these tests, the trick behind getting `hangman` to work is to
    replace each guessed letter in the original word with a dash wherever that letter
    appears in the word and then compare the result to the original word in which
    no letters have been replaced by dashes ➍. If they’re different (that is, if one
    or more letters in the word are now dashes), the guessed letter is in the word.
    Guessing the letter *a*, for instance, when the word is *cat*, will result in
    the `guessed` variable holding your guess with a value of ‘-a-’.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些测试，成功让 `hangman` 游戏运行的关键在于：将原始单词中每个已猜字母的位置替换为短横线，然后将结果与原始单词进行比较，原始单词中没有任何字母被替换成短横线
    ➍。如果它们不同（即单词中的一个或多个字母现在变成了短横线），则猜测的字母在单词中。举个例子，当单词是*cat*时，猜测字母*a*，`guessed`变量的值将是‘-a-’。
- en: One of the key ideas that makes it possible to write hangman is that the partially
    filled-in word shown to the player, the variable `partial`, is rebuilt each time
    a correct guess is made. Because the variable `guessed` accumulates each letter
    guessed by the player, a `sed` transformation that translates into a dash each
    letter in the original word that is *not* in the `guessed` string does the trick
    ➎.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 编写“猜单词”游戏的关键思想之一是，每次玩家做出正确猜测时，显示给玩家的部分填充单词变量`partial`都会被重建。由于变量`guessed`会累积玩家猜测的每个字母，`sed`转换将原单词中不在`guessed`字符串中的字母替换为短横线，就能完成这个操作
    ➎。
- en: '***Running the Script***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: 'The hangman game has one optional argument: if you specify a numeric value
    as a parameter, the code will use that as the number of incorrect guesses allowed,
    rather than the default of 6\. [Listing 12-4](ch12.xhtml#ch12ex4) shows playing
    the `hangman` script with no arguments.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: “猜单词”游戏有一个可选参数：如果指定一个数字值作为参数，代码将使用该值作为允许的错误猜测次数，而不是默认的 6 次。[Listing 12-4](ch12.xhtml#ch12ex4)
    显示了没有参数的情况下运行 `hangman` 脚本。
- en: '***The Results***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 12-4: Playing the* `*hangman*` *shell script game*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-4：玩* `*hangman*` *shell 脚本游戏*'
- en: '***Hacking the Script***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: Obviously it’s difficult to have the guy-hanging-on-the-gallows graphic with
    a shell script, so we use the alternative of counting “steps to the gallows.”
    If you were motivated, however, you could probably have a series of predefined
    “text” graphics, one for each step, and output them as the game proceeds. Or you
    could choose a nonviolent alternative of some sort!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，使用 shell 脚本很难展示悬挂图形，所以我们采用了另一种方式，即计算“到达绞刑架的步骤”。不过，如果你有足够的动力，你可以预定义一系列“文本”图形，每一步一个，然后随着游戏进行逐步输出。或者，你也可以选择某种非暴力的替代方式！
- en: Note that it is possible to pick the same word twice, but with the default word
    list containing 2,882 different words, there’s not much chance of that. If this
    is a concern, however, the line where the word is chosen could also save all previous
    words in a variable and screen against them to ensure that there aren’t any repeats.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管可以选择两次相同的单词，但由于默认的单词列表包含 2,882 个不同的单词，发生这种情况的几率不大。不过，如果这是一个问题，选择单词的那一行也可以将所有以前的单词保存在一个变量中，并进行筛选，以确保没有重复的单词。
- en: Finally, if you’re motivated, it’d be nice to have the guessed-letters list
    sorted alphabetically. There are a couple of approaches to this, but we’d use
    `sed|sort`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你有动力的话，把猜测的字母列表按字母顺序排序会更好。有几种方法可以实现，但我们会使用 `sed|sort`。
- en: '**#85 A State Capitals Quiz**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#85 州府问答游戏**'
- en: Once you have a tool for choosing a line randomly from a file, there’s no limit
    to the types of quiz games you can write. We’ve pulled together a list of the
    capitals of all 50 states in the United States, available for download from *[http://www.nostarch.com/wcss2/](http://www.nostarch.com/wcss2/)*.
    Save the file *state.capitals.txt* in your */usr/lib/games* directory. The script
    in [Listing 12-5](ch12.xhtml#ch12ex5) randomly chooses a line from the file, shows
    the state, and asks the user to enter the matching capital.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了从文件中随机选择一行的工具，就没有限制可以编写什么类型的问答游戏了。我们已经整理了美国所有50个州的州府列表，可以从 *[http://www.nostarch.com/wcss2/](http://www.nostarch.com/wcss2/)*
    下载。将文件 *state.capitals.txt* 保存到你的 */usr/lib/games* 目录中。[列表 12-5](ch12.xhtml#ch12ex5)
    中的脚本会从文件中随机选择一行，显示州名，然后要求用户输入匹配的首府。
- en: '***The Code***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 12-5: The* `*states*` *trivia game shell script*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-5：* `*states*` *问答游戏脚本*'
- en: '***How It Works***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: For such an entertaining game, `states` involves very simple scripting. The
    data file contains state/capital pairs, with all spaces in the state and capital
    names replaced with dashes and the two fields separated by a single space. As
    a result, extracting the city and state names from the data is easy ➊.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个有趣的游戏，`states` 只涉及非常简单的脚本编写。数据文件包含州名/首府对，州名和首府名称中的所有空格都被破折号替换，两个字段之间由一个空格分隔。因此，从数据中提取城市和州名非常简单
    ➊。
- en: Each guess is compared against both the all-lowercase version of the city name
    (`match`) and the correctly capitalized city name to see whether it’s correct.
    If not, the guess is compared against the two command words `next` and `quit`.
    If either matches, the script shows the answer and either prompts for another
    state or quits, as appropriate. If there are no matches, the guess is considered
    incorrect.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每次猜测都会与城市名的小写版本（`match`）和正确大写的城市名进行比较，看看是否正确。如果不正确，则该猜测会与两个命令字 `next` 和 `quit`
    进行比较。如果其中一个匹配，脚本会显示答案并根据需要提示下一个州或退出。如果都不匹配，猜测将被认为是错误的。
- en: '***Running the Script***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This script has no arguments or command flags. Just start it up and play!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本没有参数或命令标志。只需启动它并开始游戏！
- en: '***The Results***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: Ready to quiz yourself on state capitals? [Listing 12-6](ch12.xhtml#ch12ex6)
    shows our state capital trivia skills in action!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好挑战自己，测试州府知识了吗？[列表 12-6](ch12.xhtml#ch12ex6)展示了我们的州府知识技能！
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 12-6: Running the* `*states*` *trivia game shell script*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-6：运行 `*states*` 问答游戏脚本*'
- en: Fortunately, the game tracks only ultimately correct guesses, not how many incorrect
    guesses you made or whether you popped over to Google to get the answer!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个游戏只跟踪最终正确的猜测，而不是你猜错了多少次，或者你是否跳到 Google 查找答案！
- en: '***Hacking the Script***'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: Probably the greatest weakness in this game is that it’s picky about spelling.
    A useful modification would be to add code to allow fuzzy matching, so that the
    user entry of `Juneu` might match Juneau, for example. This could be done using
    a modified *Soundex algorithm*, in which vowels are removed and doubled letters
    are squished down to a single letter (for example, Annapolis would transform to
    `npls`). This might be too forgiving for your tastes, but the general concept
    is worth considering.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏最大的弱点可能就是它对拼写非常挑剔。一个有用的修改是添加代码来允许模糊匹配，例如，用户输入 `Juneu` 时能匹配到 Juneau。这可以通过修改过的
    *Soundex 算法* 实现，在该算法中元音被移除，重复的字母被压缩成一个字母（例如，Annapolis 会变成 `npls`）。这可能对你来说有些过于宽容，但这个概念值得考虑。
- en: As with other games, a hint function would be useful, too. Perhaps it would
    show the first letter of the correct answer when requested and keep track of how
    many hints are used as the play proceeds.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他游戏一样，提供提示功能也很有用。也许在请求时，提示功能会显示正确答案的第一个字母，并在游戏进行过程中记录使用的提示次数。
- en: Although this game is written for state capitals, it would be trivial to modify
    the script to work with any sort of paired data file. For example, with a different
    file, you could create an Italian vocabulary quiz, a country/currency match, or
    a politician/political party quiz. As we’ve seen repeatedly in Unix, writing something
    that is reasonably general purpose allows it to be reused in useful and occasionally
    unexpected ways.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个游戏是为州首府设计的，但修改脚本以处理任何类型的配对数据文件将是微不足道的。例如，使用不同的文件，你可以创建一个意大利词汇测验、一个国家/货币配对测试，或者一个政治家/政党配对测试。正如我们在Unix中反复看到的，编写一些合理通用的程序可以让它以有用的甚至是意想不到的方式被重复使用。
- en: '**#86 Is That Number a Prime?**'
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#86 这个数字是质数吗？**'
- en: Prime numbers are numbers that are divisible only by themselves, for example,
    7\. On the other hand, 6 and 8 are not prime numbers. Recognizing prime numbers
    is easy with single digits, but it gets more complicated when we jump up to bigger
    numbers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 质数是只能被自身整除的数字，例如7。另一方面，6和8不是质数。识别单一数字的质数很简单，但当我们处理更大的数字时，情况就变得复杂起来。
- en: There are different mathematical approaches to figuring out whether a number
    is prime, but let’s stick with the brute-force method of trying all possible divisors
    to see whether any have a remainder of zero, as [Listing 12-7](ch12.xhtml#ch12ex7)
    shows.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种数学方法可以判断一个数字是否是质数，但我们还是坚持使用暴力法，尝试所有可能的除数，看看是否有余数为零，正如[列表 12-7](ch12.xhtml#ch12ex7)所示。
- en: '***The Code***'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 12-7: The* `*isprime*` *script*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-7：* `*isprime*` *脚本*'
- en: '***How It Works***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: 'The heart of this script is in the `while` loop, so take a look at that more
    closely at ➊. If we were trying a `number` of 77, the conditional statement would
    be testing this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的核心在于`while`循环，所以请更仔细地查看它在➊的位置。如果我们尝试的`number`是77，那么条件语句将测试以下内容：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Obviously this is false: 77 does not divide evenly by 2\. Each time the code
    tests a potential divisor (`$counter`) and finds that it doesn’t divide evenly,
    it calculates the remainder (`$number % $counter)` and increments the `$counter`
    by 1\. Ploddingly, it proceeds.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 很显然这是错误的：77不能被2整除。每次代码测试一个潜在的除数（`$counter`），如果发现它不能整除，就会计算余数（`$number % $counter`），并将`$counter`递增1。脚本按部就班地继续执行。
- en: '***Running the Script***'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: Let’s pick a few numbers that seem like they could be prime and test them in
    [Listing 12-8](ch12.xhtml#ch12ex8).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选几个看起来像是质数的数字，在[列表 12-8](ch12.xhtml#ch12ex8)中进行测试。
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 12-8: Running the* `*isprime*` *shell script on some numbers*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-8：运行* `*isprime*` *Shell脚本并对一些数字进行测试*'
- en: If you’re curious, uncomment out the `echo` statement in the `while` loop to
    see the calculations and get a sense of how quickly—or slowly—the script finds
    a divisor that divides evenly into the number without a remainder. In fact, let’s
    do just that and test 77, as shown in [Listing 12-9](ch12.xhtml#ch12ex9).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，可以在`while`循环中取消注释`echo`语句，查看计算过程，并感受脚本在找出一个能整除该数字且没有余数的除数时的速度——是多快还是多慢。事实上，我们就做这个测试，看看77的情况，正如在[列表
    12-9](ch12.xhtml#ch12ex9)中所示。
- en: '***The Results***'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 12-9: Running the* `*isprime*` *script with debug lines uncommented*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-9：运行* `*isprime*` *脚本并取消注释调试行*'
- en: '***Hacking the Script***'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: There are some inefficiencies in the implementation of the mathematical formula
    in this script that slow it way down. For example, consider the `while` loop conditional.
    We keep calculating `$(expr $number / 2)` when we can just calculate that value
    once and use the calculated value for each subsequent iteration, saving the need
    to spawn a subshell and invoking `expr` to find out that the value hasn’t changed
    one iota since the last iteration.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本中实现数学公式的方式有一些低效的地方，导致它执行得非常慢。例如，考虑`while`循环的条件。我们一直在计算`$(expr $number /
    2)`，而实际上可以只计算一次这个值，并在每次后续迭代中使用计算出来的结果，避免每次都启动一个子shell并调用`expr`来得出与上次迭代相同的结果。
- en: There are also some far smarter algorithms to test for prime numbers, and these
    are worth exploring, including the delightfully named sieve of Eratosthenes, along
    with more modern formulas such as the sieve of Sundaram and the rather more complicated
    sieve of Atkin. Check them out online and test whether your phone number (without
    dashes!) is a prime or not.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些更智能的算法可以用来测试质数，这些算法值得探索，包括那种非常有趣的埃拉托斯特尼筛法，以及更现代的筛法如桑达拉姆筛法和更复杂的阿特金筛法。可以在线查看它们，并测试一下你的电话号码（没有破折号！）是否是质数。
- en: '**#87 Let’s Roll Some Dice**'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#87 骰子游戏**'
- en: This is a handy script for anyone who enjoys tabletop games, especially role-playing
    games like *Dungeons & Dragons*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个对任何喜欢桌面游戏的人来说都很有用的脚本，特别是像*龙与地下城*这样的角色扮演游戏。
- en: The common perception of these games is that they’re just a lot of dice rolling,
    and that’s actually accurate. It’s all about probabilities, so sometimes you’re
    rolling a 20-sided die and other times you’re rolling six 6-sided dice. Dice are
    such an easy random number generator that a huge number of games use them, whether
    it’s one die, two (think *Monopoly* or *Trouble*), or more.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些游戏的普遍看法是它们只是不断地掷骰子，实际上这个看法是正确的。这一切都与概率有关，因此有时你会掷一个20面骰子，其他时候你会掷六个6面骰子。骰子是如此简单的随机数生成器，以至于很多游戏都使用它们，不管是一个骰子、两个（想想*大富翁*或*麻烦*），还是更多。
- en: They all turn out to be easy to model, and that’s what the script in [Listing
    12-10](ch12.xhtml#ch12ex10) does, letting the user specify how many of what kind
    of dice are needed, then “rolling” them all, and offering a sum.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都很容易建模，这正是[清单 12-10](ch12.xhtml#ch12ex10)中脚本的作用，允许用户指定需要多少什么样的骰子，然后“掷”出它们，并提供一个总和。
- en: '***The Code***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 12-10: The* `*rolldice*` *script*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-10：* `*rolldice*` *脚本*'
- en: '***How It Works***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: This script revolves around a simple line of code that invokes the bash random
    number generator through the expedient shortcut of referencing `$RANDOM` ➌. That’s
    the key line; everything else is just window dressing.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本围绕一行简单的代码展开，它通过引用`$RANDOM` ➌来调用bash的随机数生成器。这是关键行；其他的只是点缀。
- en: 'The other interesting segment is where the dice description is broken down
    ➊, because the script supports all three of these notations: `3d8`, `d6`, and
    `20`. This is a standard gaming notation, for convenience: number of dice + *d*
    + sides the die should have. For example, `2d6` means two 6-sided dice. See if
    you can figure out how each is processed.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的部分是骰子描述被拆解的地方 ➊，因为脚本支持这三种表示法：`3d8`、`d6` 和 `20`。这是标准的游戏表示法，为了方便：骰子的数量 +
    *d* + 骰子应有的面数。例如，`2d6`意味着两个6面骰子。看看你能否弄明白每种是如何处理的。
- en: There’s a fair bit of output for such a simple script. You’ll probably want
    to adjust this to your own preferences, but here you can see that the statement
    is just a handy way to verify that it parsed the die or dice request properly.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这么一个简单的脚本，输出还挺多的。你可能想根据自己的喜好调整它，但在这里你可以看到这个语句只是一个方便的方式来验证它是否正确解析了骰子或骰子请求。
- en: Oh, and the `cut` invocation ➋? Remember that `-d` indicates the field delimiter,
    so `-dd` simply says to use the letter *d* as that delimiter, as needed for this
    particular dice notation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，还有那个`cut`调用 ➋？记住，`-d`表示字段分隔符，因此`-dd`只是告诉它使用字母*d*作为分隔符，这是该骰子表示法所需的。
- en: '***Running the Script***'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: 'Let’s start easy: in [Listing 12-11](ch12.xhtml#ch12ex11), we’ll use two 6-sided
    dice, as if we were playing *Monopoly*.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的开始：在[清单 12-11](ch12.xhtml#ch12ex11)中，我们将使用两个6面骰子，就像我们在玩*大富翁*一样。
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 12-11: Testing the* `*rolldice*` *script with a pair of six-sided
    dice*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-11：用一对六面骰子测试* `*rolldice*` *脚本*'
- en: Notice that the first time it “rolled” the two dice, they came up 6 and 2, but
    the second time they came up 4 and 2.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到第一次“掷”这两个骰子时，它们分别掷出了6和2，但第二次却是4和2。
- en: How about a quick *Yahtzee* roll? Easy enough. We’ll roll five six-sided dice
    in [Listing 12-12](ch12.xhtml#ch12ex12).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么样，来一局快速的*雅兹*掷骰吗？够简单的。我们将在[清单 12-12](ch12.xhtml#ch12ex12)中掷五个六面骰子。
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 12-12: Testing the* `*rolldice*` *script with five six-sided dice*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-12：用五个六面骰子测试* `*rolldice*` *脚本*'
- en: 'Not a very good roll: 1, 2, 2, 3, 5\. If we were playing *Yahtzee*, we’d keep
    the pair of 2s and reroll everything else.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不算很好的掷骰结果：1、2、2、3、5。如果我们在玩*雅兹*，我们会保留一对2，然后重新掷其他所有的。
- en: This gets more interesting when you have a more complicated set of dice to roll.
    In [Listing 12-13](ch12.xhtml#ch12ex13), let’s try two 18-sided dice, one 37-sided
    die, and a 3-sided die (since we don’t have to worry about the limitations of
    3D geometric shapes).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要掷一组更复杂的骰子时，事情变得更加有趣。在[清单 12-13](ch12.xhtml#ch12ex13)中，让我们尝试两个18面骰子，一个37面骰子和一个3面骰子（因为我们不必担心3D几何形状的限制）。
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 12-13: Running the* `*rolldice*` *script with an assortment of dice
    types*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-13：用各种骰子类型运行* `*rolldice*` *脚本*'
- en: Cool, eh? A few additional rolls of this motley set of dice yielded 22, 49,
    and 47\. Now you know, gamers!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷吧？几次掷骰子后，这一堆杂七杂八的骰子分别掷出了22、49和47。现在你知道了，玩家们！
- en: '***Hacking the Script***'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: 'There’s not much to hack in this script since the task is so easy. The only
    thing we would recommend is fine-tuning the amount of output that the program
    produces. For example, a notation like `5d6: 2 3 1 3 7 = 16` would be more space
    efficient.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '这个脚本中没有太多可以修改的地方，因为任务本身非常简单。我们唯一的建议是微调程序输出的量。例如，像`5d6: 2 3 1 3 7 = 16`这样的表示方式会更节省空间。'
- en: '**#88 Acey Deucey**'
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#88 Acey Deucey**'
- en: For our last script in this chapter, we’ll create the card game Acey Deucey,
    which means we’ll need to figure out how to create and “shuffle” a deck of playing
    cards to get randomized results. This is tricky, but the functions you write for
    this game will give you a general purpose solution you can use to make a more
    complicated game like blackjack or even rummy or Go Fish.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一个脚本中，我们将创建纸牌游戏Acey Deucey，这意味着我们需要弄清楚如何创建并“洗牌”一副扑克牌，以得到随机化的结果。这很棘手，但你为这个游戏写的函数将为你提供一个通用的解决方案，可以用来制作像21点、或者甚至是打扑克和“捉鱼”之类的更复杂游戏。
- en: 'The game is simple: deal two cards, and then bet whether the next card you’re
    going to flip up ranks between the two existing cards. Suit is irrelevant; it’s
    all about the card rank, and a tie loses. Thus, if you flip up a 6 of hearts and
    a 9 of clubs and the third card is a 6 of diamonds, it’s a loss. A 4 of spades
    is also a loss. But a 7 of clubs is a win.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏很简单：发两张牌，然后赌下一张翻出来的牌是否在这两张牌的之间。花色无关紧要；只看牌面大小，平局算输。因此，如果你翻出来的是一张红桃6和一张黑桃9，而第三张牌是方块6，那就是失败。黑桃4也是失败。但梅花7则是胜利。
- en: 'So there are two tasks here: the entire card deck simulation and the logic
    of the game itself, including asking the user whether they want to make a bet.
    Oh, and one more thing: if you deal two cards that have the same rank, there’s
    no point betting because you can’t win.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里有两个任务：整个牌组的模拟和游戏本身的逻辑，包括询问用户是否要下注。哦，还有一件事：如果发出的两张牌是相同的牌面大小，那就没有意义下注，因为你无法获胜。
- en: That’ll make an interesting script. Ready? Then go to [Listing 12-14](ch12.xhtml#ch12ex14).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个有趣的脚本。准备好了吗？那么请访问[列表 12-14](ch12.xhtml#ch12ex14)。
- en: '***The Code***'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 12-14: The* `*aceydeucey*` *script game*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-14：* `*aceydeucey*` *脚本游戏*'
- en: '***How It Works***'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: Simulating a deck of shuffled playing cards is not easy. There’s the question
    of how to portray the cards themselves and of how to “shuffle” or randomly organize
    an otherwise neatly ordered deck.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟一副洗牌后的扑克牌并不容易。问题在于如何呈现这些牌本身，以及如何“洗牌”或者将原本整齐有序的牌组随机排序。
- en: 'To address this, we create two arrays of 52 elements: `deck[]` ➊ and `newdeck[]`
    ➋. The former is an array of the ordered cards where each value is replaced by
    a `-1` as it’s “selected” and put into a random slot of `newdeck[]`. The `newdeck[]`
    array, then, is the “shuffled” deck. While in this game we only ever use the first
    three cards, the general solution is far more interesting to consider than the
    specific one.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们创建了两个包含52个元素的数组：`deck[]` ➊ 和 `newdeck[]` ➋。前者是一个有序的卡牌数组，每个值在“被选中”并放入`newdeck[]`的随机位置时都会被替换为`-1`。然后，`newdeck[]`数组就是“洗牌”后的牌组。虽然在这个游戏中我们只会使用前三张牌，但相较于特定的解法，一般的解法更值得探讨。
- en: That means this script is overkill. But hey, it’s interesting. ![image](../images/common1.jpg)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这个脚本有些大材小用。不过，嘿，它很有趣。 ![image](../images/common1.jpg)
- en: Let’s step through the functions to see how things work. First off, initializing
    the deck is really simple, as you can see if you flip back and examine the `initializeDeck`
    function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步查看这些函数，了解它们是如何工作的。首先，初始化牌组非常简单，正如你翻回去查看`initializeDeck`函数时看到的那样。
- en: Similarly, `shuffleDeck` is surprisingly straightforward because all the work
    is really done in the `pickCard` function. But `shuffleDeck` simply steps through
    the 52 slots in `deck[]`, randomly picks a value that hasn’t yet been picked,
    and saves it in the *n*th array space of `newdeck[]`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`shuffleDeck`出奇地简单，因为所有的工作实质上都是在`pickCard`函数中完成的。`shuffleDeck`仅仅是遍历`deck[]`中的52个位置，随机选择一个尚未被选中的值，并将其保存到`newdeck[]`的*n*位置。
- en: 'Let’s look at `pickCard` ➌ because that’s where the heavy lifting of the shuffle
    occurs. The function is broken into two blocks: the first attempts to randomly
    pick an available card, giving it `$threshold` tries to succeed. As the function
    is called again and again, the first calls always succeed at this, but later in
    the process, once 50 cards are already moved over into the `newdeck[]`, it’s quite
    possible that 10 random guesses all yield a fail. That’s the `while` block of
    code at ➍.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一下 `pickCard` ➌，因为这部分是洗牌的关键。这个函数分为两个块：第一个尝试随机选择一张可用的牌，并给它 `$threshold` 次机会成功。随着函数的反复调用，最初的调用总是会成功，但在过程中，一旦
    50 张牌已经移入 `newdeck[]`，可能会出现 10 次随机猜测都失败的情况。这就是 ➍ 处的 `while` 代码块。
- en: 'Once `$errcount` is equal to `$threshold`, we basically give up on this strategy
    in the interest of performance and move to the second block of code: stepping
    through the deck card by card until we find an available card. That’s the block
    at ➎.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `$errcount` 等于 `$threshold`，为了提高性能，我们基本上放弃了这个策略，转而使用第二块代码：逐张检查牌堆，直到找到一张可用的牌。这就是
    ➎ 处的代码块。
- en: If you think about the implications of this strategy, you’ll realize that the
    lower you set the threshold, the more likely that `newdeck` will be sequential,
    particularly later in the deck. At the extreme, `threshold = 1` would yield an
    ordered deck where `newdeck[]` = `deck[]`. Is 10 the right value? That’s a bit
    beyond the scope of this book, but we’d welcome email from someone who wanted
    to experimentally ascertain the best balance of randomness and performance!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑这个策略的含义，你会意识到，阈值设置得越低，`newdeck` 的顺序性就越高，特别是在牌堆后期。极端情况下，`threshold = 1`
    将会得到一个有序的牌堆，其中 `newdeck[]` = `deck[]`。10 是正确的值吗？这有点超出了本书的范围，但如果有人想通过实验找出最合适的随机性与性能平衡，我们欢迎他们通过邮件联系我们！
- en: The `showCard` function is long, but most of those lines are really just about
    making the results pretty. The core of the entire deck simulation is captured
    in the two lines at ➏.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`showCard` 函数很长，但其中大部分行其实只是为了让结果更漂亮。整个牌堆模拟的核心部分包含在 ➏ 处的两行代码中。'
- en: For this game, suit is irrelevant, but you can see that for a given card value,
    the rank is going to be 0–12 and the suit would be 0–3\. The cards’ qualities
    just need to be mapped to user-friendly values. To make debugging easy, a 6 of
    clubs has a rank 6, and an ace has rank 1\. A king has a default rank of 0, but
    we adjust it to rank 13 so the math works.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个游戏，花色无关紧要，但你可以看到，对于每一张牌的数值，等级会是 0–12，花色会是 0–3。牌的属性只是需要映射到易于用户理解的值上。为了方便调试，梅花
    6 的等级是 6，王牌的等级是 1。国王的默认等级是 0，但我们将其调整为等级 13，这样计算才能正确。
- en: 'The `dealCards` function ➐ is where the actual Acey Deucey game comes into
    play: all the previous functions are dedicated to implementing the useful set
    of functions for any card game. The `dealCards` function deals out all three cards
    required for the game, even though the third card is hidden until after the player
    places their bet. This just makes life easier—it’s not so that the computer can
    cheat! Here you can also see that the separately stored rank values (`$rank1`,
    `$rank2`, and `$rank3`) are fixed for the king = 13 scenario. Also to make life
    easier, the top two cards are sorted so that the lower-rank card always comes
    first. That’s the `if` chunk at ➑.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`dealCards` 函数 ➐ 是实际的 Acey Deucey 游戏逻辑所在：之前的所有函数都致力于为任何扑克牌游戏实现有用的功能集。`dealCards`
    函数发出游戏所需的所有三张牌，尽管第三张牌在玩家下注之前是隐藏的。这只是为了简化操作——并不是为了让计算机作弊！在这里，你也可以看到为国王 = 13 的场景单独存储的等级值（`$rank1`，`$rank2`
    和 `$rank3`）。为了简化操作，前两张牌会被排序，使得较低等级的牌总是排在前面。这就是 ➑ 处的 `if` 代码块。'
- en: At ➒, it’s time to show what’s dealt. The last step is to present the cards,
    check whether the ranks match (in which case we’ll skip the prompt that lets the
    user decide whether to bet), and then test whether the third card is between the
    first two. This test is done in the code block at ➓.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➒，是时候展示已经发出的牌了。最后一步是展示牌，检查排名是否匹配（如果匹配，我们会跳过提示，让用户决定是否下注），然后测试第三张牌是否在前两张牌之间。这项测试在
    ➓ 的代码块中完成。
- en: Finally, the result of the bet is tricky. If you bet that the drawn card will
    be between the first two cards and it is, or you bet that it won’t be and it isn’t,
    you’re a winner. Otherwise you lose. This result is figured out in the final block.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，下注结果是棘手的。如果你赌抽到的牌会在前两张牌之间，结果确实如此，或者你赌它不会在两张牌之间且它没有，那么你就是赢家。否则，你就输了。这个结果会在最后的代码块中得出。
- en: '***Running the Script***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: Specify any starting parameter and the game will give you a rudimentary explanation
    of how to play. Otherwise, you just jump in.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 指定任何起始参数，游戏会给你一个简单的玩法说明。否则，你只需直接跳入游戏。
- en: Let’s look at the intro in [Listing 12-15](ch12.xhtml#ch12ex15).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看[示例 12-15](ch12.xhtml#ch12ex15)中的介绍。
- en: '***The Results***'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 12-15: Playing the* `*aceydeucey*` *script game*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-15：玩* `*aceydeucey*` *脚本游戏*'
- en: '***Hacking the Script***'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: There’s the lingering question of whether the deck is shuffled adequately with
    a threshold of 10; that’s one area that can definitely be improved. It’s also
    not clear whether showing the spread (the difference between the ranks of the
    two cards) is beneficial. Certainly you wouldn’t do that in a real game; the player
    would need to figure it out.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 关于是否以10为阈值足够充分地洗牌这个问题依然存在疑问；这是一个可以明确改进的地方。另一个不确定的地方是是否显示分差（两张卡牌的排名差异）是有益的。当然，在真正的游戏中你是不会这样做的；玩家需要自己弄清楚。
- en: 'Then again, you could go in the opposite direction and calculate the odds of
    having a card between two arbitrary card values. Let’s think about this: the odds
    of any given card being drawn is 1 out of 52\. If there are 50 cards left in the
    deck because two have already been dealt, the odds of any given card coming up
    is 1 out of 50\. Since suit is irrelevant, there are 4 out of 50 chances that
    any different rank comes up. Therefore, the odds of a given spread are (the number
    of cards in that possible spread × 4) out of 50\. If a 5 and a 10 are dealt, the
    spread is 4, since the possible winning cards are a 6, 7, 8, or 9\. So the odds
    of winning are 4 × 4 out of 50\. See what we mean?'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以朝相反的方向进行，计算两张任意卡牌之间的概率。我们来思考一下：任意一张卡牌被抽到的概率是1/52。如果牌堆中剩下50张卡，因为已经发了两张牌，那么任意一张卡被抽到的概率是1/50。由于花色无关，所以任意不同排名的卡牌出现的机会是4/50。因此，某一特定分差的概率是（该分差中的卡牌数量
    × 4）/50。如果发了5和10，那么分差为4，因为可能的获胜牌是6、7、8或9。所以获胜的概率是4 × 4 / 50。明白我们的意思了吗？
- en: Finally, as with every command line–based game, the interface could do with
    some work. We’ll leave that up to you. We’ll also leave you the question of what
    other games to explore with this handy library of playing-card functions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，像所有基于命令行的游戏一样，界面也可以做得更好。我们将这部分留给你来处理。我们还会留给你一个问题：你可以探索这个方便的扑克牌功能库来开发其他哪些游戏。
