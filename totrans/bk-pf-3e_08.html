<html><head></head><body><section class="chapter" epub:type="chapter" id="redundancy_and_resource_availability" title="Chapter&#xA0;8.&#xA0;Redundancy and Resource Availability"><div class="titlepage"><div><div><h2 class="title">Chapter 8. Redundancy and Resource Availability</h2></div></div></div><div class="mediaobject"><a id="med_id00014"/><img alt="Redundancy and Resource Availability" src="httpatomoreillycomsourcenostarchimages2127149.png.jpg"/></div><p><a class="indexterm" id="iddle1123"/><a class="indexterm" id="iddle1753"/><span class="emphasis"><em>High availability</em></span> and <span class="emphasis"><em>uninterrupted service</em></span> have been both marketing buzzwords and coveted goals for real-world IT professionals and network administrators as long as most of us can remember. To meet this perceived need and solve a few related problems, <span class="emphasis"><em>CARP</em></span> and <span class="emphasis"><em>pfsync</em></span> were added as two highly anticipated features in OpenBSD 3.5. With these tools, OpenBSD and the other operating systems that adopted them came a long way toward offering what other operating systems refer to as general purpose <span class="emphasis"><em>clustering</em></span> functionality. The terminology used by OpenBSD and its sister BSDs differs from what other products use, but as you will see in this chapter, CARP, pfsync, and related tools offer high availability functionality equivalent to what a variety of proprietary systems tend to offer only as costly optional extras.</p><p>This chapter covers how to use these tools as found in your base system to manage resource availability—or, in other words, how to use them to make sure resources and services in your care stay available even in adverse conditions.</p><div class="sect1" title="Redundancy and Failover: CARP and pfsync"><div class="titlepage"><div><div><h2 class="title" id="redundancy_and_failover_carp_and_pfsync" style="clear: both">Redundancy and Failover: CARP and pfsync</h2></div></div></div><p><a class="indexterm" id="iddle1227"/><a class="indexterm" id="iddle1360"/><a class="indexterm" id="iddle1760"/><a class="indexterm" id="iddle2025"/><a class="indexterm" id="iddle2031"/>The Common Address Redundancy Protocol (CARP) was developed as a non-patent-encumbered alternative to the Virtual Router Redundancy Protocol (VRRP), which was far along the track to becoming an IETF-sanctioned standard, even though possible patent issues haven’t been resolved.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch08fn01" id="ch08fn01">42</a>]</sup> One of the main purposes of CARP is to ensure that the network will keep functioning as usual, even when a firewall or other service goes down due to errors or planned maintenance activities, such as upgrades. Not content to just make a clone of the patent-encumbered protocol, the OpenBSD developers decided to go one better on several fronts. CARP features authenticated redundancy—it’s address-family independent and comes with state synchronization features. Complementing CARP, the pfsync protocol is designed to handle synchronization of PF states between redundant packet-filtering nodes or gateways. Both protocols are intended to ensure redundancy for essential network features with automatic failover.</p><p>CARP is based on setting up a group of machines as one <span class="emphasis"><em>master</em></span> and one or more redundant <span class="emphasis"><em>backups</em></span>, all equipped to handle a common IP address. If the master goes down, one of the backups will inherit the IP address. The handover from one CARP host to another may be authenticated, essentially by setting a shared secret (in practice, much like a password).</p><p>In the case of PF firewalls, pfsync can be set up to handle the synchronization, and if the synchronization via pfsync has been properly set up, active connections will be handed over without noticeable interruption. In essence, pfsync is a type of virtual network interface specially designed to synchronize state information between PF firewalls. Its interfaces are assigned to physical interfaces with <code class="literal">ifconfig</code>.</p><p>Even if it’s technically possible to lump pfsync traffic together with other traffic on a regular interface, it’s strongly recommended that you set up pfsync on a separate network, or even VLAN. pfsync does no authentication on its synchronization partners, so the only way to guarantee correct synchronization is to use dedicated interfaces for your pfsync traffic.</p><div class="sect2" title="The Project Specification: A Redundant Pair of Gateways"><div class="titlepage"><div><div><h3 class="title" id="project_specification_a_redundant_pair_o">The Project Specification: A Redundant Pair of Gateways</h3></div></div></div><p>To illustrate a useful failover setup with CARP and pfsync, we’ll examine a network with one gateway to the world. Our goals for the reconfigured network are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The network should keep functioning much the same way it did before we introduced redundancy.</p></li><li class="listitem"><p>We should have better availability without noticeable downtime.</p></li><li class="listitem"><p>The network should experience graceful failover with no interruption of active connections.</p></li></ul></div><p><a class="indexterm" id="iddle1761"/>We’ll begin with the relatively simple network from <a class="xref" href="ch03.html" title="Chapter 3. Into the Real World">Chapter 3</a>, as shown in <a class="xref" href="ch08.html#network_with_a_single_gateway-id00010" title="Figure 8-1. Network with a single gateway">Figure 8-1</a>.</p><div class="figure"><a id="network_with_a_single_gateway-id00010"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00015"/><img alt="Network with a single gateway" src="httpatomoreillycomsourcenostarchimages2127161.png.jpg"/></div></div><div class="figure-title">Figure 8-1. Network with a single gateway</div></div><p>We replace the single gateway with a redundant pair of gateways that share a private network for state-information updates over pfsync. The result is shown in <a class="xref" href="ch08.html#network_with_redundant_gateways" title="Figure 8-2. Network with redundant gateways">Figure 8-2</a>.</p><div class="figure"><a id="network_with_redundant_gateways"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00016"/><img alt="Network with redundant gateways" src="httpatomoreillycomsourcenostarchimages2127163.png.jpg"/></div></div><div class="figure-title">Figure 8-2. Network with redundant gateways</div></div><p><a class="indexterm" id="iddle1116"/><a class="indexterm" id="iddle1117"/><a class="indexterm" id="iddle1124"/><a class="indexterm" id="iddle1229"/><a class="indexterm" id="iddle1230"/><a class="indexterm" id="iddle1366"/><a class="indexterm" id="iddle1754"/>CARP addresses are virtual addresses, and unless you have console access to all machines in your CARP group, you should almost always assign an IP address to the physical interfaces. With a unique IP address for each physical interface, you’ll be able to communicate with the host and be sure of which machine you’re interacting with. Without IP addresses assigned to physical interfaces, you could find yourself with a setup where the backup gateways are unable to communicate (except with hosts in networks where the physical interfaces have addresses assigned) until they become the master in the redundancy group and take over the virtual IP addresses.</p><p>It’s reasonable to assume that the IP address assigned to the physical interface will belong in the same subnet as the virtual, shared IP address. It’s also important to be aware that this is, in fact, not a requirement—it’s even possible to configure CARP where the physical interface hasn’t been assigned an address. If you don’t specify a specific physical interface for the CARP interface, the kernel will try to assign the CARP address to a physical interface that’s already configured with an address in the same subnet as the CARP address. Even if it may not be required in simpler configurations, it’s generally useful to make the interface selection explicit via the <code class="literal">carpdev</code> option in the <code class="literal">ifconfig</code> command string that you use to set up the CARP interface.</p><div class="warning" epub:type="warning" title="Warning"><h3 class="title"><a id="ch08note01"/>Warning</h3><p><span class="emphasis"><em>If when you reconfigure your network, the default gateway address goes from fixed to a specific interface and from host to a virtual address, it’s nearly impossible to avoid a temporary loss of connectivity.</em></span></p></div></div><div class="sect2" title="Setting Up CARP"><div class="titlepage"><div><div><h3 class="title" id="setting_up_carp">Setting Up CARP</h3></div></div></div><p>Most CARP setup lies in cabling (according to the schematic for your network), setting <code class="literal">sysctl</code> values, and issuing <code class="literal">ifconfig</code> commands. Also, on some systems, you’ll need to make sure that your kernel is set up with the required devices compiled in.</p><div class="sect3" title="Checking Kernel Options"><div class="titlepage"><div><div><h4 class="title" id="checking_kernel_options">Checking Kernel Options</h4></div></div></div><p>On OpenBSD, both the CARP and pfsync devices are in the default GENERIC and GENERIC.MP kernel configurations. Unless you’re running a custom kernel without these options, no kernel reconfiguration is necessary. If you’re running FreeBSD, make sure that the kernel has the CARP and pfsync devices compiled in because the default GENERIC kernel lacks these options. (See the <span class="emphasis"><em>FreeBSD Handbook</em></span> to learn how to compile and install a custom kernel with these options.)</p><p>NetBSD should check that the kernel has pseudo-device CARP compiled in because NetBSD’s default GENERIC kernel configuration doesn’t have it. (You’ll find the relevant line commented out in the GENERIC configuration file.) As of this writing, NetBSD doesn’t support pfsync due to claimed protocol-numbering issues.</p></div><div class="sect3" title="Setting sysctl Values"><div class="titlepage"><div><div><h4 class="title" id="setting_sysctl_values">Setting sysctl Values</h4></div></div></div><p><a class="indexterm" id="iddle1058"/><a class="indexterm" id="iddle1118"/><a class="indexterm" id="iddle1119"/><a class="indexterm" id="iddle1231"/><a class="indexterm" id="iddle1232"/><a class="indexterm" id="iddle1921"/>On all CARP-capable systems, the basic functions are governed by a handful of <code class="literal">sysctl</code> variables. The main one is <code class="literal">net.inet.carp.allow</code>, and it’s enabled by default. On a typical OpenBSD system, you’ll see:</p><a id="pro_id00295"/><pre class="programlisting">$ <span class="strong"><strong>sysctl net.inet.carp.allow</strong></span> &#13;
net.inet.carp.allow=1</pre><p>This means that your system comes equipped for CARP.</p><p>If your kernel isn’t configured with a CARP device, this command should produce something like the following on FreeBSD:</p><a id="pro_id00296"/><pre class="programlisting">sysctl: unknown oid 'net.inet.carp.allow'</pre><p>Or it could produce something like this on NetBSD:</p><a id="pro_id00297"/><pre class="programlisting">sysctl: third level name 'carp' in 'net.inet.carp.allow' is invalid</pre><p>Use this <code class="literal">sysctl</code> command to view all CARP-related variables:</p><a id="pro_id00298"/><pre class="programlisting">$ <span class="strong"><strong>sysctl net.inet.carp</strong></span> &#13;
net.inet.carp.allow=1&#13;
net.inet.carp.preempt=0&#13;
net.inet.carp.log=2</pre><div class="note" title="Note"><h3 class="title"><a id="ch08note02"/>Note</h3><p><span class="emphasis"><em>On FreeBSD, you’ll also encounter the read-only status variable <code class="literal">net.inet.carp.suppress_preempt</code>, which indicates whether preemption is possible. On systems with CARP code based on OpenBSD 4.2 or earlier, you’ll also see <code class="literal">net.inet.carp.arpbalance</code>, which is used to enable CARP ARP balancing to offer some limited load balancing for hosts on a local network.</em></span></p></div><p>To enable the graceful failover between the gateways in our setup, we need to set the <code class="literal">net.inet.carp.preempt</code> variable so that on hosts with more than one network interface (like our gateways), all CARP interfaces will move between master and backup status concurrently. This setting must be identical on all hosts in the CARP group, and it should be repeated on all hosts during setup.</p><a id="pro_id00299"/><pre class="programlisting">$ <span class="strong"><strong>sudo sysctl net.inet.carp.preempt=1</strong></span></pre><p>The <code class="literal">net.inet.carp.log</code> variable sets the debug level for CARP logging between 0 and 7. The default of 2 means only CARP state changes are logged.</p></div><div class="sect3" title="Setting Up Network Interfaces with ifconfig"><div class="titlepage"><div><div><h4 class="title" id="setting_up_network_interfaces_with_ifcon">Setting Up Network Interfaces with ifconfig</h4></div></div></div><p>Notice in the network diagram shown in <a class="xref" href="ch08.html#network_with_redundant_gateways" title="Figure 8-2. Network with redundant gateways">Figure 8-2</a> that the local network uses addresses in the 192.168.12.0 network, while the Internet-facing <a class="indexterm" id="iddle1125"/><a class="indexterm" id="iddle2022"/><a class="indexterm" id="iddle2026"/><a class="indexterm" id="iddle2032"/>interface is in the 192.0.2.0 network. With these address ranges and the CARP interface’s default behavior in mind, the commands for setting up the virtual interfaces are actually quite straightforward.</p><p>In addition to the usual network parameters, CARP interfaces require one additional parameter: the <span class="emphasis"><em>virtual host ID (<code class="literal">vhid</code>)</em></span>, which uniquely identifies the interfaces that will share the virtual IP address.</p><div class="warning" epub:type="warning" title="Warning"><h3 class="title"><a id="ch08note03"/>Warning</h3><p><span class="emphasis"><em>The <code class="literal">vhid</code> is an 8-bit value that must be set uniquely within the network’s broadcast domain. Setting the <code class="literal">vhid</code> to the wrong value can lead to network problems that can be hard to debug, and there’s even anecdotal evidence that ID collisions with otherwise unrelated systems can occur and cause disruption on redundancy and load-balancing systems based on VRRP, which uses a virtual node identification scheme similar to CARP’s.</em></span></p></div><p>Run these commands on the machine that will be the initial master for the group:</p><a id="pro_id00300"/><pre class="programlisting">$ <span class="strong"><strong>sudo ifconfig carp0 192.0.2.19 vhid 1</strong></span> &#13;
$ <span class="strong"><strong>sudo ifconfig carp1 192.168.1.1 vhid 2</strong></span></pre><p>We don’t need to explicitly set the physical interface because the <code class="literal">carp0</code> and <code class="literal">carp1</code> virtual interfaces will bind themselves to the physical interfaces that are already configured with addresses in the same subnets as the assigned CARP address.</p><div class="note" title="Note"><h3 class="title"><a id="ch08note04"/>Note</h3><p><span class="emphasis"><em>On systems that offer the <code class="literal">carpdev</code> option to <code class="literal">ifconfig</code>, it’s recommended to use the <code class="literal">carpdev</code> option for all CARP interface setups, even if it isn’t strictly required. The <code class="literal">carpdev</code> option becomes indispensable in cases where the choice of physical network device for the CARP interface isn’t obvious from the existing network configuration, and adding a <code class="literal">carpdev interface</code> string to the <code class="literal">ifconfig</code> commands can make the difference between a nonfunctional setup and a working one. This can be particularly useful in some nonintuitive configurations and where the number of free IP addresses in the relevant network is severely limited. The FreeBSD port of CARP offers the <code class="literal">carpdev</code> option starting with FreeBSD 10.0.</em></span></p></div><p>Use <code class="literal">ifconfig</code> to make sure that each CARP interface is properly configured and pay particular attention to the <code class="literal">carp:</code> line, which indicates <code class="literal">MASTER</code> status, as shown here:</p><a id="pro_id00301"/><pre class="programlisting">$ <span class="strong"><strong>ifconfig carp0</strong></span> &#13;
carp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500&#13;
        lladdr 00:00:5e:00:01:01&#13;
        carp: MASTER carpdev ep0 vhid 1 advbase 1 advskew 0&#13;
        groups: carp&#13;
        inet 192.0.2.19 netmask 0xffffff00 broadcast 192.0.2.255&#13;
        inet6 fe80::200:5eff:fe00:101%carp0 prefixlen 64 scopeid 0x5</pre><p><a class="indexterm" id="iddle1016"/><a class="indexterm" id="iddle1017"/><a class="indexterm" id="iddle1177"/>The setup is almost identical on the backup except that you add the <code class="literal">advskew</code> parameter, which indicates how much <span class="emphasis"><em>less preferred</em></span> it is for the specified machine to take over than the current master.</p><a id="pro_id00302"/><pre class="programlisting">$ <span class="strong"><strong>sudo ifconfig carp0 192.0.2.19 vhid 1 advskew 100</strong></span> &#13;
$ s<span class="strong"><strong>udo ifconfig carp1 192.168.1.1 vhid 2 advskew 100</strong></span></pre><p>The <code class="literal">advskew</code> parameter and its companion value, <code class="literal">advbase</code>, are used to calculate the interval between the current host’s announcements of its master status once it’s taken over. The default value for <code class="literal">advbase</code> is 1, and the default for <code class="literal">advskew</code> is 0. In the preceding example, the master would announce every second (1 + 0/256), while the backup would wait for 1 + 100/256 seconds.</p><p>With <code class="literal">net.inet.carp.preempt=1</code> on all hosts in the failover group, when the master stops announcing or announces that it isn’t available, the backups take over, and the new master starts announcing at its configured rate. Smaller <code class="literal">advskew</code> values mean shorter announcement intervals and a higher likelihood that the host becomes the new master. If more hosts have the same <code class="literal">advskew</code>, the one that’s already master will keep its master status.</p><p>On OpenBSD 4.1 and higher, one more factor in the equation determines which host takes over CARP master duty. The <span class="emphasis"><em>demotion counter</em></span> is a value each CARP host announces for its interface group as a measure of readiness for its CARP interfaces. When the demotion counter value is 0, the host is in complete readiness; higher values indicate measures of degradation. You can set the demotion counter from the command line using <code class="literal">ifconfig -g</code>, but the value is usually set by the system itself, with higher values typically during the boot process. All other things being equal, the host with the lowest demotion counter will win the contest to take over as the CARP master.</p><div class="note" title="Note"><h3 class="title"><a id="ch08note05"/>Note</h3><p><span class="emphasis"><em>As of this writing, FreeBSD CARP versions earlier than FreeBSD 10 don’t support setting the demotion counter.</em></span></p></div><p>On the backup, use <code class="literal">ifconfig</code> once again to check that each CARP interface is properly configured:</p><a id="pro_id00303"/><pre class="programlisting">$ <span class="strong"><strong>ifconfig carp0</strong></span> &#13;
carp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500&#13;
        lladdr 00:00:5e:00:01:01&#13;
        carp: BACKUP carpdev ep0 vhid 1 advbase 1 advskew 100&#13;
        groups: carp&#13;
        inet 192.0.2.19 netmask 0xffffff00 broadcast 192.0.2.255&#13;
        inet6 fe80::200:5eff:fe00:101%carp0 prefixlen 64 scopeid 0x5</pre><p><a class="indexterm" id="iddle1234"/><a class="indexterm" id="iddle1505"/><a class="indexterm" id="iddle1506"/><a class="indexterm" id="iddle1665"/><a class="indexterm" id="iddle1755"/><a class="indexterm" id="iddle1906"/><a class="indexterm" id="iddle1965"/>The output here is only slightly different from what you’ve just seen on the master. Notice that the <code class="literal">carp:</code> line indicates <code class="literal">BACKUP</code> status along with the <code class="literal">advbase</code> and <code class="literal">advskew</code> parameters.</p><p>For actual production use, you should add a measure of security against unauthorized CARP activity by configuring the members of the CARP group with a shared, secret passphrase, such as the following:<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch08fn02" id="ch08fn02">43</a>]</sup></p><a id="pro_id00304"/><pre class="programlisting">$ <span class="strong"><strong>sudo ifconfig carp0 pass mekmitasdigoat 192.0.2.19 vhid 1</strong></span>&#13;
$ <span class="strong"><strong>sudo ifconfig carp1 pass mekmitasdigoat 192.168.1.1 vhid 2</strong></span></pre><div class="note" title="Note"><h3 class="title"><a id="ch08note06"/>Note</h3><p><span class="emphasis"><em>As with any other password, the passphrase will become a required ingredient in all CARP traffic in your setup. Be sure to configure all CARP interfaces in a failover group with the same passphrase (or none).</em></span></p></div><p>Once you’ve figured out the appropriate settings, preserve them through future system reboots by putting them in the proper files in <span class="emphasis"><em>/etc</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>On OpenBSD, put the proper <code class="literal">ifconfig</code> parameters into <span class="emphasis"><em>hostname.carp0</em></span> and <span class="emphasis"><em>hostname.carp1</em></span>.</p></li><li class="listitem"><p>On FreeBSD and NetBSD, put the relevant lines in your <span class="emphasis"><em>rc.conf</em></span> file as contents of the <code class="literal">ifconfig_carp0=</code> and <code class="literal">ifconfig_carp1=</code> variables.</p></li></ul></div></div></div><div class="sect2" title="Keeping States Synchronized: Adding pfsync"><div class="titlepage"><div><div><h3 class="title" id="keeping_states_synchronized_adding_pfsyn">Keeping States Synchronized: Adding pfsync</h3></div></div></div><p>As the final piece of configuration, set up state-table synchronization between the hosts in your redundancy group to prevent traffic disruption during failover. This feat is accomplished through a set of pfsync interfaces. (As noted earlier, as of this writing, NetBSD doesn’t support pfsync.)</p><p>Configuring pfsync interfaces requires planning and a few <code class="literal">ifconfig</code> commands. You can set up pfsync on any configured network interface, but it’s best to set up a separate network for the synchronization. The sample configuration in <a class="xref" href="ch08.html#network_with_redundant_gateways" title="Figure 8-2. Network with redundant gateways">Figure 8-2</a> shows a tiny network set aside for the purpose. A crossover cable connects the two Ethernet interfaces, but in configurations with more than two hosts in the failover group, you may want a setup with a separate switch, hub, or VLAN. The interfaces to be used for the synchronization have been assigned the IP addresses 10.0.12.16 and 10.0.12.17, respectively.</p><p>With the basic TCP/IP configuration in place, the complete pfsync setup for each synchronization partner interface is</p><a id="pro_id00305"/><pre class="programlisting">$ <span class="strong"><strong>sudo ifconfig pfsync0 syncdev ep2</strong></span></pre><p><a class="indexterm" id="iddle1235"/><a class="indexterm" id="iddle1384"/><a class="indexterm" id="iddle1756"/><a class="indexterm" id="iddle1924"/>The pfsync protocol itself offers little in the way of security features: It has no authentication mechanism and, by default, communicates via IP multicast traffic. However, in cases where a physically separate network isn’t feasible, you can tighten up your pfsync security by setting up pfsync to synchronize only with a specified <code class="literal">syncpeer</code>:</p><a id="pro_id00306"/><pre class="programlisting">$ <span class="strong"><strong>sudo ifconfig pfsync0 syncpeer 10.0.12.16 syncdev ep2</strong></span></pre><p>This produces a configured interface that shows up in <code class="literal">ifconfig</code> output like this:</p><a id="pro_id00307"/><pre class="programlisting">pfsync0: flags=41&lt;UP,RUNNING&gt; mtu 1500&#13;
        priority: 0&#13;
        pfsync: syncdev: ep2 syncpeer: 10.0.12.16 maxupd: 128 defer: off&#13;
        groups: carp pfsync</pre><p>Another option is to set up an IPsec tunnel and use that to protect the sync traffic. In this case, the <code class="literal">ifconfig</code> command is</p><a id="pro_id00308"/><pre class="programlisting">$ <span class="strong"><strong>sudo ifconfig pfsync0 syncpeer 10.0.12.16 syncdev enc0</strong></span></pre><p>This means that the <code class="literal">syncdev</code> device becomes the <code class="literal">enc0</code> encapsulating interface instead of the physical interface.</p><div class="note" title="Note"><h3 class="title"><a id="ch08note07"/>Note</h3><p><span class="emphasis"><em>If possible, set up synchronization across a physically separate, dedicated network or a separate VLAN because any lost pfsync updates could lead to less than clean failover.</em></span></p></div><p>One very useful way to check that your PF state synchronization is running properly is to watch the state table on your synchronized hosts using <span class="strong"><strong><code class="literal">systat states</code></strong></span> on each machine. The command gives you a live display of states, showing updates happening in bulk on the sync targets. Between the synchronizations, states should display identically on all hosts. (Traffic counters—such as the number of packets and bytes passed—are the exception; they display updates only on the host that handles the actual connection.)</p><p>This takes us to the end of the basic network configuration for CARP-based failover. In the next section, we’ll discuss what to keep in mind when writing rule sets for redundant configurations.</p></div><div class="sect2" title="Putting Together a Rule Set"><div class="titlepage"><div><div><h3 class="title" id="putting_together_a_rule_set">Putting Together a Rule Set</h3></div></div></div><p>After all the contortions we’ve been through in order to configure basic networking, you may be wondering what it will take to migrate the rules you use in your current <span class="emphasis"><em>pf.conf</em></span> to the new setup. Fortunately, not much. The main change we’ve introduced is essentially invisible to the rest of the world, and a well-designed rule set for a single gateway configuration will generally work well for a redundant setup, too.</p><p><a class="indexterm" id="iddle1559"/><a class="indexterm" id="iddle1881"/>That said, we’ve introduced two additional protocols (CARP and pfsync), and you’ll probably need to make some relatively minor changes to your rule set in order for the failover to work properly. Basically, you need to pass the CARP and pfsync traffic to the appropriate interfaces. The simplest way to handle the CARP traffic is to introduce a macro definition for your <code class="literal">carpdevs</code> that includes all physical interfaces that will handle CARP traffic. You’ll also introduce an accompanying <code class="literal">pass</code> rule, like the following one, in order to pass CARP traffic on the appropriate interfaces:</p><a id="pro_id00309"/><pre class="programlisting">pass on $carpdevs proto carp</pre><p>Similarly, for pfsync traffic, you can introduce a macro definition for your <code class="literal">syncdev</code> and an accompanying <code class="literal">pass</code> rule:</p><a id="pro_id00310"/><pre class="programlisting">pass on $syncdev proto pfsync</pre><p>Skipping the pfsync interfaces entirely for filtering is cheaper performance-wise than filtering and passing. To take the pfsync device out of the filtering equation altogether, use this rule:</p><a id="pro_id00311"/><pre class="programlisting">set skip on $syncdev</pre><p>You should also consider the roles of the virtual CARP interface and its address versus the physical interface. As far as PF is concerned, all traffic will pass through the physical interfaces, but the traffic may have the CARP interface’s IP addresses as source or destination addresses.</p><p>You may find that you have rules in your configuration that you don’t want to bother to synchronize in case of a failover, such as connections to services that run on the gateway itself. One prime example is the typical rule to allow SSH in for the administrator:</p><a id="pro_id00312"/><pre class="programlisting">pass in on $int_if from $ssh_allowed to self</pre><p>For rules like these, you could use the state option <code class="literal">no-sync</code> to prevent synchronizing state changes for connections that really aren’t relevant once failover has occurred:</p><a id="pro_id00313"/><pre class="programlisting">pass in on $int_if from $ssh_allowed to self keep state (no-sync)</pre><p>With this configuration, you’ll be able to schedule operating system upgrades and formerly downtime-producing activities on members of your CARPed group of systems at times when they’re most convenient, with no noticeable downtime for the users of your services.</p><div class="sidebar"><a id="ifstatedcomma_the_interface_state_daemon"/><div class="sidebar-title">Ifstated, the Interface State Daemon</div><p><a class="indexterm" id="iddle1059"/><a class="indexterm" id="iddle1120"/><a class="indexterm" id="iddle1371"/><a class="indexterm" id="iddle1377"/><a class="indexterm" id="iddle1437"/><a class="indexterm" id="iddle1470"/><a class="indexterm" id="iddle1757"/>In properly CARPed setups, basic networking functionality is well provided for, but your setup may include elements that need special attention when the network configuration changes on a host. For example, some services might need to be started or stopped when a specific interface goes down or restarts, or you may want to run specific commands or scripts in response to interface state changes. If this sounds familiar, <code class="literal">ifstated</code> is for you.</p><p>The <code class="literal">ifstated</code> tool was introduced in OpenBSD 3.5 to trigger actions based on changes in the state of network interfaces. You’ll find it in the base system on OpenBSD and via the ports system as <span class="emphasis"><em>net/ifstated</em></span> on FreeBSD. On OpenBSD, the file <span class="emphasis"><em>/etc/ifstated.conf</em></span> (or <span class="emphasis"><em>/usr/local/etc/ifstated.conf</em></span> if you installed the port on FreeBSD) contains an almost-ready-to-run configuration with a few pointers on how to set up <code class="literal">ifstated</code> for a CARPed environment.</p><p>The main controlling objects are interfaces and their states—for example, <code class="literal">carp0.link.up</code> is the state where the <code class="literal">carp0</code> interface has become master—and you perform actions in response to state changes.</p><p>The states and actions to perform whenever the state of an interface changes are specified in a straightforward scripting language with basic features like variables, macros, and simple logical conditionals. (See <code class="literal">man ifstated</code> and <code class="literal">man ifstated.conf</code> as well as the default <span class="emphasis"><em>ifstated.conf</em></span> sample file supplied in your base system install for more on this topic and on implementing CARP-based clustering features in your environment.)</p></div></div><div class="sect2" title="CARP for Load Balancing"><div class="titlepage"><div><div><h3 class="title" id="carp_for_load_balancing">CARP for Load Balancing</h3></div></div></div><p>Redundancy by failover is nice, but sometimes it’s less attractive to have hardware sitting around in case of failure and better to create a configuration that spreads the network load over several hosts.</p><p>In addition to ARP balancing (which works by calculating hashes based on the source MAC address on incoming connections), CARP in OpenBSD 4.3 and higher supports several varieties of IP-based load balancing, with traffic allocated based on hashes calculated from the connections’ source and destination IP addresses. Because ARP balancing is based on the source MAC address, it’ll work only for hosts in the directly connected network segment. On the other hand, the IP-based methods are appropriate for load-balancing connections to and from the Internet at large.</p><p>The choice of method for your application will depend on the specifications of the rest of the network equipment you need to work with. The basic <code class="literal">ip</code> balancing mode uses a multicast MAC address to have the directly connected switch forward traffic to all hosts in the load-balancing cluster.</p><p><a class="indexterm" id="iddle1018"/><a class="indexterm" id="iddle1121"/><a class="indexterm" id="iddle1122"/><a class="indexterm" id="iddle1233"/><a class="indexterm" id="iddle1367"/><a class="indexterm" id="iddle1438"/><a class="indexterm" id="iddle1439"/><a class="indexterm" id="iddle1758"/><a class="indexterm" id="iddle1759"/><a class="indexterm" id="iddle1920"/>Unfortunately, the combination of a unicast IP address and a multicast MAC address isn’t supported by some systems. In those cases, you may need to configure your load balancing in <code class="literal">ip-unicast</code> mode, which uses a unicast MAC address, and configure your switch to forward to the appropriate hosts. Or you may need to configure your load balancing in <code class="literal">ip-stealth</code> mode, which doesn’t use the multicast MAC address at all. As usual, the devil is in the details, and the answers are found in man pages and other documentation, most likely with a bit of experimentation thrown in.</p><div class="note" title="Note"><h3 class="title"><a id="ch08note08"/>Note</h3><p><span class="emphasis"><em>Traditionally, <code class="literal">relayd</code> has been used to do intelligent load balancing as the frontend for servers that offer services to the rest of the world. In OpenBSD 4.7, <code class="literal">relayd</code> acquired the ability to track available uplinks and alter the system’s routing tables based on link health, with the functionality wrapped in a bundle with the <code class="literal">router</code> keyword. For setups with several possible uplinks or various routing tables, you can set up <code class="literal">relayd</code> to choose your uplink or, with a little help from the <code class="literal">sysctl</code> variables <code class="literal">net.inet.ip.multipath</code> and <code class="literal">net.inet6.ip6.multipath</code>, perform load balancing across available routes and uplinks. The specifics will vary with your networking environment. The <code class="literal">relayd.conf</code> man page contains a complete example to get you started.</em></span></p></div><div class="sect3" title="CARP in Load-Balancing Mode"><div class="titlepage"><div><div><h4 class="title" id="carp_in_load-balancing_mode">CARP in Load-Balancing Mode</h4></div></div></div><p>In load-balancing mode, the CARP concept is extended by letting each CARP interface be a member of multiple failover groups and as many load-balancing groups as there are physical hosts that will share the virtual address. In contrast with the failover case, where there can be only one master, each node in a load-balancing cluster <span class="emphasis"><em>must</em></span> be the master of its own group so that it can receive traffic. The choice of group—and by extension, physical host—that ends up handling a given connection is determined by CARP via a hash value calculation. This calculation is based on the connection’s source MAC address in the ARP-balancing case and on the source and destination IP address in the IP-balancing case as well as actual availability. The downside to this scheme is that each group consumes one virtual host ID, so you’ll run out of these IDs quite a bit more quickly in a load-balancing configuration than when using failover only. In fact, there’s a hard upper limit to the number of CARP-based load-balancing <span class="emphasis"><em>clusters</em></span> of 32 virtual host IDs.</p><p>The <code class="literal">advskew</code> parameter plays a similar role in load-balancing configurations as in the failover ones, but the <code class="literal">ifconfig</code> (and <span class="emphasis"><em>hostname.carpN</em></span>) syntax for CARP load balancing is slightly different from that of the failover case.</p></div><div class="sect3" title="Setting Up CARP Load Balancing"><div class="titlepage"><div><div><h4 class="title" id="setting_up_carp_load_balancing">Setting Up CARP Load Balancing</h4></div></div></div><p>Changing the CARP failover group built over the previous sections to a load-balancing cluster is as simple as editing the configuration files and reloading. In the following example, we choose an IP load-balancing scheme. If you choose a different scheme, the configuration itself differs only in the keyword for mode selection.</p><p>On the first host, we change <span class="emphasis"><em>/etc/hostname.carp0</em></span> to</p><a id="pro_id00314"/><pre class="programlisting">pass mekmitasdigoat 192.0.2.19 balancing ip carpnodes 5:100,6:0</pre><p>This says that on this host, the <code class="literal">carp0</code> interface is a member of the group with <code class="literal">vhid 5</code> (with an <code class="literal">advskew</code> of <code class="literal">100</code>) as well as the interface with <code class="literal">vhid 6</code>, where it’s the prime candidate for becoming initial master (with an <code class="literal">advskew</code> set to <code class="literal">0</code>).</p><p>Next, we change <span class="emphasis"><em>/etc/hostname.carp1</em></span> to this:</p><a id="pro_id00315"/><pre class="programlisting">pass mekmitasdigoat 192.168.12.1 balancing ip carpnodes 3:100,4:0</pre><p>For <code class="literal">carp1</code>, the memberships are <code class="literal">vhid</code>s <code class="literal">3</code> and <code class="literal">4</code>, with <code class="literal">advskew</code> values of <code class="literal">100</code> and <code class="literal">0</code>, respectively.</p><p>For the other host, the <code class="literal">advskew</code> values are reversed, but the configuration is otherwise predictably similar. Here, <span class="emphasis"><em>/etc/hostname.carp0</em></span> reads:</p><a id="pro_id00316"/><pre class="programlisting">pass mekmitasdigoat 192.0.2.19 balancing ip carpnodes 5:0,6:100</pre><p>This means that the <code class="literal">carp0</code> interface is a member of <code class="literal">vhid 5</code> with <code class="literal">advskew 0</code> and a member of <code class="literal">vhid 6</code> with <code class="literal">advskew 100</code>. Complementing this is the <span class="emphasis"><em>/etc/ hostname.carp1</em></span> file that reads:</p><a id="pro_id00317"/><pre class="programlisting">pass mekmitasdigoat 192.168.12.1 balancing ip carpnodes 3:0,4:100</pre><p>Again, <code class="literal">carp1</code> is a member of <code class="literal">vhid 3</code> and <code class="literal">4</code>, with <code class="literal">advskew 0</code> in the first and <code class="literal">100</code> in the other.</p><p>The <code class="literal">ifconfig</code> output for the <code class="literal">carp</code> interface group on the first host looks like this:</p><a id="pro_id00318"/><pre class="programlisting">$ <span class="strong"><strong>ifconfig carp</strong></span> &#13;
carp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500&#13;
        lladdr 01:00:5e:00:01:05&#13;
        priority: 0&#13;
        carp: carpdev vr0 advbase 1 balancing ip&#13;
                state MASTER vhid 5 advskew 0&#13;
                state BACKUP vhid 6 advskew 100&#13;
        groups: carp&#13;
        inet 192.0.2.19 netmask 0xffffff00 broadcast 192.0.2.255&#13;
        inet6 fe80::200:24ff:fecb:1c10%carp0 prefixlen 64 scopeid 0x7&#13;
carp1: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500&#13;
        lladdr 01:00:5e:00:01:03&#13;
        priority: 0&#13;
        carp: carpdev vr1 advbase 1 balancing ip&#13;
                state MASTER vhid 3 advskew 0&#13;
                state BACKUP vhid 4 advskew 100&#13;
        groups: carp&#13;
        inet 192.168.12.1 netmask 0xffffff00 broadcast 192.168.12.255&#13;
        inet6 fe80::200:24ff:fecb:1c10%carp1 prefixlen 64 scopeid 0x8&#13;
pfsync0: flags=41&lt;UP,RUNNING&gt; mtu 1500&#13;
        priority: 0&#13;
        pfsync: syncdev: vr2 syncpeer: 10.0.12.17 maxupd: 128 defer: off&#13;
        groups: carp pfsync</pre><p><a class="indexterm" id="iddle1925"/>The other host has this <code class="literal">ifconfig</code> output:</p><a id="pro_id00319"/><pre class="programlisting">$ <span class="strong"><strong>ifconfig carp</strong></span> &#13;
carp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500&#13;
        lladdr 01:00:5e:00:01:05&#13;
        priority: 0&#13;
        carp: carpdev vr0 advbase 1 balancing ip&#13;
                state BACKUP vhid 5 advskew 100&#13;
                state MASTER vhid 6 advskew 0&#13;
        groups: carp&#13;
        inet 192.0.2.19 netmask 0xffffff00 broadcast 192.0.2.255&#13;
        inet6 fe80::200:24ff:fecb:1c18%carp0 prefixlen 64 scopeid 0x7&#13;
carp1: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500&#13;
        lladdr 01:00:5e:00:01:03&#13;
        priority: 0&#13;
        carp: carpdev vr1 advbase 1 balancing ip&#13;
                state BACKUP vhid 3 advskew 100&#13;
                state MASTER vhid 4 advskew 0&#13;
        groups: carp&#13;
        inet 192.168.12.1 netmask 0xffffff00 broadcast 192.168.12.255&#13;
        inet6 fe80::200:24ff:fecb:1c18%carp1 prefixlen 64 scopeid 0x8&#13;
pfsync0: flags=41&lt;UP,RUNNING&gt; mtu 1500&#13;
        priority: 0&#13;
        pfsync: syncdev: vr2 syncpeer: 10.0.12.16 maxupd: 128 defer: off&#13;
        groups: carp pfsync</pre><p>If we had three nodes in our load-balancing scheme, each <code class="literal">carp</code> interface would need to be a member of an additional group, for a total of three groups. In short, for each physical host you introduce in the load-balancing group, each <code class="literal">carp</code> interface becomes the member of an additional group.</p><p>Once you’ve set up the load-balancing cluster, check the flow of connections by running <span class="strong"><strong><code class="literal">systat states</code></strong></span> on each of the hosts in your load-balancing cluster for a few minutes to make sure that the system works as expected and to see that all the effort you put in has been worth it.</p></div></div></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.ch08fn01"><p><sup>[<a class="para" href="#ch08fn01">42</a>] </sup>VRRP is described in RFC 2281 and RFC 3768. The patents involved are held by Cisco, IBM, and Nokia. See the RFCs for details.</p></div><div class="footnote" epub:type="footnote" id="ftn.ch08fn02"><p><sup>[<a class="para" href="#ch08fn02">43</a>] </sup>This particular passphrase has a very specific meaning. A Web search will reveal its significance and why it’s <span class="emphasis"><em>de rigeur</em></span> for modern networking documentation. The definitive answer can be found via the <span class="emphasis"><em>openbsd-misc</em></span> mailing list archives.</p></div></div></section></body></html>