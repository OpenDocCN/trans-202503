- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL Data Types
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll look at all of the available MySQL data types. You’ve
    already seen that `int` and `varchar` can be used for integer and character data,
    but MySQL also has data types to store dates, times, and even binary data. You’ll
    explore how to choose the best data types for your columns and the pros and cons
    of each type.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a table, you define each column’s data type based on the kind
    of data you’ll store in that column. For example, you wouldn’t use a data type
    that allows only numbers for a column that stores names. You might additionally
    consider the range of values that the column will have to accommodate. If a column
    needs to store a value like 3.1415, you should use a data type that allows decimal
    values with four positions after the decimal point. Lastly, if more than one data
    type can handle the values your column will need to store, you should choose the
    one that uses the least amount of storage.
  prefs: []
  type: TYPE_NORMAL
- en: Say you want to create a table, `solar_eclipse`, that includes data about solar
    eclipses, including the date of the eclipse, the time it occurs, the type of eclipse,
    and its magnitude. Your raw data might look like [Table 4-1](#table4-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-1](#tableanchor4-1): Data on Solar Eclipses'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Eclipse date** | **Time of greatest eclipse** | **Eclipse type** | **Magnitude**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2022-04-30 | 20:42:36 | Partial | 0.640 |'
  prefs: []
  type: TYPE_TB
- en: '| 2022-10-25 | 11:01:20 | Partial | 0.862 |'
  prefs: []
  type: TYPE_TB
- en: '| 2023-04-20 | 04:17:56 | Hybrid | 1.013 |'
  prefs: []
  type: TYPE_TB
- en: 'In order to store this data in a MySQL database, you’ll create a table with
    four columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this table, each of the four columns has been defined with a different data
    type. Since the `eclipse_date` column will store dates, you use the `date` data
    type. The `time` data type, which is designed to store time data, is applied to
    the `time_of_greatest_eclipse` column.
  prefs: []
  type: TYPE_NORMAL
- en: For the `eclipse_type` column, you use the `varchar` data type because you need
    to store variable-length character data. You don’t expect these values to be long,
    so you use `varchar(10)` to set the maximum number of characters to 10.
  prefs: []
  type: TYPE_NORMAL
- en: For the `magnitude` column, you use the `decimal` data type and specify that
    the values will have four digits total and three digits after the decimal point.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at these and several other data types in more depth, and explore
    when it’s appropriate to use each one.
  prefs: []
  type: TYPE_NORMAL
- en: String Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *string* is a set of characters, including letters, numbers, whitespace characters
    like spaces and tabs, and symbols like punctuation marks. For values that include
    only numbers, you should use a numeric data type rather than a string data type.
    You would use a string data type for a value like `I love MySQL 8.0!` but a numeric
    data type for a value like `8.0`.
  prefs: []
  type: TYPE_NORMAL
- en: This section will examine MySQL’s string data types.
  prefs: []
  type: TYPE_NORMAL
- en: char
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `char` data type is used for *fixed-length* strings—that is, strings that
    hold an exact number of characters. To define a column within a `country_code`
    table to store three-letter country codes like `USA`, `GBR`, and `JPN`, use `char(3)`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When defining columns with the `char` data type, you specify the length of the
    string inside the parentheses. The `char` data type defaults to one character
    if you leave out the parentheses, though in cases where you want only one character,
    it’s clearer to specify `char(1)` than just `char`.
  prefs: []
  type: TYPE_NORMAL
- en: The length of the string cannot exceed the length defined within the parentheses.
    If you tried to insert `JAPAN` into the `country_code` column, MySQL would reject
    the value because the column has been defined to store a maximum of three characters.
    However, MySQL will allow you to insert a string with fewer than three characters,
    such as `JP`; it simply adds a space to the end of `JP` and saves the value in
    the column.
  prefs: []
  type: TYPE_NORMAL
- en: You can define a `char` data type with up to 255 characters. If you try to define
    a column with a data type of `char(256)` you’ll get an error message because it’s
    out of `char`’s range.
  prefs: []
  type: TYPE_NORMAL
- en: varchar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `varchar` data type, which you’ve seen before, is for *variable-length*
    strings, or strings that can hold *up to* a specified number of characters. It’s
    useful when you need to store strings but aren’t sure exactly how long they will
    be. For example, to create an `interesting_people` table and then define a column
    called `interesting_name` that stores various names, you need to be able to accommodate
    short names like `Jet Li` as well as long names like `Hubert Blaine Wolfeschlegelsteinhausenbergerdorff`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the parentheses, you define a character limit of 100 for the `interesting_name`
    column because you don’t anticipate that anybody’s name in the database will be
    over 100 characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of characters that `varchar` can accept depends on your MySQL configuration.
    Your database administrator (DBA) can help you, or you can use this quick hack
    to determine your maximum. Write a `create table` statement with a column that
    has an absurdly long `varchar` maximum value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `create table` statement will fail, giving you an error message like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The table was not created because the `varchar` definition was too large, but
    the error message told you that the maximum number of characters that `varchar`
    can accept in this environment is 16,383, or `varchar(16383)`.
  prefs: []
  type: TYPE_NORMAL
- en: The `varchar` data type is mostly used for small strings. When you’re storing
    more than 5,000 characters, I recommend using the `text` data type instead (we’ll
    get to it momentarily).
  prefs: []
  type: TYPE_NORMAL
- en: enum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `enum` data type, short for *enumeration*, lets you create a list of values
    that you want to allow in a string column. Here’s how to create a table called
    `student` with a `student_class` column that can accept only one of the following
    values—`Freshman`, `Sophomore`, `Junior`, or `Senior`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you try to add a value to the column other than the ones in the list of permitted
    values, it will be rejected. You can add only one of the permitted values to the
    `student_class` column; a student can’t be both a freshman and a sophomore.
  prefs: []
  type: TYPE_NORMAL
- en: set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `set` data type is similar to the `enum` data type, but `set` allows you
    to select multiple values. In the following `create table` statement, you define
    a list of languages for a `language_spoken` column in a table called `interpreter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `set` data type allows you to add any or all of the languages in the set
    to the `language_spoken` column, as someone might speak one or more of these languages.
    If you try to add any value to the column other than the ones in the list, however,
    they will be rejected.
  prefs: []
  type: TYPE_NORMAL
- en: tinytext, text, mediumtext, and longtext
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MySQL includes four text data types that store variable-length strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `tinytext` | Stores up to 255 characters |'
  prefs: []
  type: TYPE_TB
- en: '| `` `text` `` | Stores up to 65,535 characters, which is approximately 64KB
    |'
  prefs: []
  type: TYPE_TB
- en: '| `mediumtext` | Stores up to 16,777,215 characters, approximately 16MB |'
  prefs: []
  type: TYPE_TB
- en: '| `longtext` | Stores up to 4,294,967,295 characters, approximately 4GB |'
  prefs: []
  type: TYPE_TB
- en: 'The following `create table` statement creates a table named `book` that contains
    four columns. The last three columns, `author_bio`, `book_proposal`, and `entire_book`,
    all use text data types of different sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You use the `tinytext` data type for the `author_bio` column because you don’t
    anticipate any author biographies larger than 255 characters. This also forces
    users to make sure their bios have fewer than 255 characters. You choose the `text`
    data type for the `book_proposal` column because you aren’t expecting any book
    proposals of over 64KB. Finally, you choose the `mediumtext` data type for the
    `entire_book` column to limit the size of books to 16MB.
  prefs: []
  type: TYPE_NORMAL
- en: Binary Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL provides data types to store *binary* data, or raw data in byte format
    that is not human-readable.
  prefs: []
  type: TYPE_NORMAL
- en: tinyblob, blob, mediumblob, and longblob
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *binary large object (BLOB)* is a variable-length string of bytes. You can
    use BLOBs to store binary data like images, PDF files, and videos. BLOB data types
    come in the same sizes as the text data types. While `tinytext` can store up to
    255 characters, `tinyblob` can store up to 255 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '| `tinyblob` | Stores up to 255 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| `` `blob` `` | Stores up to 65,535 bytes, approximately 64KB |'
  prefs: []
  type: TYPE_TB
- en: '| `mediumblob` | Stores up to 16,777,215 bytes, approximately 16MB |'
  prefs: []
  type: TYPE_TB
- en: '| `longblob` | Stores up to 4,294,967,295 bytes, approximately 4GB |'
  prefs: []
  type: TYPE_TB
- en: binary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `binary` data type is for fixed-length binary data. It’s similar to the
    `char` data type, except that it’s used for strings of binary data rather than
    character strings. You specify the size of the byte string within the parentheses
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For the column called `encryption_key` in the `encryption` table, you set the
    maximum size of the byte string to 50 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: varbinary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `varbinary` data type is for variable-length binary data. You specify the
    maximum size of the byte string within the parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, you’re creating a column called `signature` (in a table of the same name)
    with a maximum size of 400 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: bit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the lesser-used data types, `bit` is used for storing bit values. You
    can specify how many bits you want to store, up to a maximum of 64\. A definition
    of `bit(15)` allows you to store up to 15 bits.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL provides data types to store numbers of different sizes. The numeric type
    to use also depends upon whether the numbers you want to store contain decimal
    points.
  prefs: []
  type: TYPE_NORMAL
- en: tinyint, smallint, mediumint, int, and bigint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Integers are whole numbers without a fraction or decimal. Integer values can
    be positive, negative, or zero. MySQL includes the following integer data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `tinyint` | Stores integer values that range from –128 to 127, or 1 byte
    of storage |'
  prefs: []
  type: TYPE_TB
- en: '| `smallint` | Stores integer values ranging from –32,768 to 32,767, or 2 bytes
    of storage |'
  prefs: []
  type: TYPE_TB
- en: '| `mediumint` | Stores integer values ranging from –8,388,608 to 8,388,607,
    or 3 bytes of storage |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | Stores integer values from –2,147,483,648 to 2,147,483,647, or 4
    bytes of storage |'
  prefs: []
  type: TYPE_TB
- en: '| `bigint` | Stores integer values that range from –9,223,372,036,854,775,808
    to 9,223,372,036,854,775,807, or 8 bytes of storage |'
  prefs: []
  type: TYPE_TB
- en: How do you know which integer type is right for your data? Take a look at the
    `planet_stat` table in [Listing 4-1](#listing4-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-1: Creating a table on planet statistics'
  prefs: []
  type: TYPE_NORMAL
- en: This table contains statistics about planets using `varchar(20)` to store the
    planet’s name, `bigint` to store its distance from Earth in miles, and `mediumint`
    for the planet’s diameter (in kilometers).
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the results, you can see that Neptune is 2,703,959,966 miles from
    Earth. In this case, `bigint` is the appropriate choice for that column, as `int`
    wouldn’t have been large enough for that value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Considering that `int` takes 4 bytes of storage and `bigint` takes 8 bytes,
    using `bigint` for a column where `int` would have been large enough means taking
    up more disk space than necessary. In small tables, using `int` where a `smallint`
    or a `mediumint` would have sufficed won’t cause any problems. But if your table
    has 20 million rows, it pays to take the time to size the columns correctly—those
    extra bytes add up.
  prefs: []
  type: TYPE_NORMAL
- en: One technique you can use for space efficiency is defining integer data types
    as `unsigned`. By default, the integer data types allow you to store negative
    and positive integers. If you won’t need any negative numbers, you can use `unsigned`
    to prevent negative values and increase the number of positive numbers. For example,
    the `tinyint` data type gives you a default range of values between –128 and 127,
    but if you specify `unsigned`, your range becomes 0 to 255.
  prefs: []
  type: TYPE_NORMAL
- en: If you specify `smallint` as `unsigned`, your range becomes 0 to 65,535\. Specifying
    the `mediumint` data type gives you a range of 0 to 16,777,215, and specifying
    `int` changes the range to 0 through 4,294,967,295.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Listing 4-1](#listing4-1), you defined the `miles_from_earth` column as
    a `bigint`, but if you take advantage of the larger `unsigned` upper range values,
    you can fit the values into an `int` data type instead. You can be confident using
    `unsigned` for this column, as it will never need to store a negative number—no
    planet will ever be less than zero miles away from Earth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: By defining the column as `unsigned`, you can use the more compact `int` type
    and save disk space.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Boolean values have only two states: true or false; on or off; 1 or 0\. Technically,
    MySQL doesn’t have a data type to capture boolean values; they’re stored in MySQL
    as `tinyint(1)`. You can use the synonym `bool` to create columns to store boolean
    values. When you define a column as `bool`, it creates a `tinyint(1)` column behind
    the scenes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This table called `food` has two boolean columns, `organic_flag` and `gluten_free_flag`,
    to tell you whether a food is organic or gluten-free:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It’s common practice to add the suffix `_flag` to columns that contain boolean
    values, such as `organic_flag`, because setting the value to `true` or `false`
    can be compared to raising or lowering a flag, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: To view the structure of a table, you can use the `describe`, or `desc`, command.
    [Figure 4-1](#figure4-1) shows the result of running `desc food;` in MySQL Workbench.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c04/f04001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-1: Describing the `food` table in MySQL Workbench'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that, although the `organic_flag` and `gluten_free_flag` columns
    were created with the `bool` synonym, the data type that was used to create those
    columns is `tinyint(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: Decimal Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For numbers that contain decimal points, MySQL provides the `decimal`, `float`,
    and `double` data types. Whereas `decimal` stores exact values, `float` and `double`
    store approximate values. For that reason, if you are storing values that can
    be handled equally well by `decimal`, `float`, or `double`, I recommend using
    the `decimal` data type.
  prefs: []
  type: TYPE_NORMAL
- en: '**`decimal`**'
  prefs: []
  type: TYPE_NORMAL
- en: The `decimal` data type allows you to define precision and scale. *Precision*
    is the total number of digits that you can store, and *scale* is the number of
    digits after the decimal point. The `decimal` data type is often used for monetary
    values with a scale of 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, if you define a `price` column as `decimal(5,2)`, you can store
    values between –999.99 and 999.99\. A precision of `5` means you can store five
    total digits, and a scale of `2` means you can store two digits after the decimal
    point.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following synonyms are available for the `decimal` type: `numeric(5,2)`,
    `dec(5,2)`, and `fixed(5,2)`. All of these are equivalent and create a data type
    of `decimal(5,2)`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**`float`**'
  prefs: []
  type: TYPE_NORMAL
- en: The `float` data type stores numeric data with a floating-point decimal. Unlike
    the `decimal` data type, where the scale is defined, a floating-point number has
    a decimal point that isn’t always in the same location—the decimal point can *float*
    within the number. A `float` data type could represent the number 1.234, 12.34,
    or 123.4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`double`**'
  prefs: []
  type: TYPE_NORMAL
- en: The `double` data type, short for `double precision`, also allows you to store
    a number with an undefined scale that has a decimal point someplace in the number.
    The `double` data type is similar to `float` except that `double` can store numbers
    more accurately. In MySQL, storing a `float` uses 4 bytes and storing a `double`
    uses 8\. For floating-point numbers with many digits, use the `double` data type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Date and Time Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For dates and times, MySQL provides the `date`, `time`, `datetime`, `timestamp`,
    and `year` data types.
  prefs: []
  type: TYPE_NORMAL
- en: '**`date`**'
  prefs: []
  type: TYPE_NORMAL
- en: The `date` data type stores dates in `YYYY-MM-DD` format (year, month, and day,
    respectively).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`time`**'
  prefs: []
  type: TYPE_NORMAL
- en: The `time` data type stores times in `hh:mm:ss` format, representing hours,
    minutes, and seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`datetime`**'
  prefs: []
  type: TYPE_NORMAL
- en: The `datetime` data type is for storing both the date and time in one value
    with the format `YYYY-MM-DD hh:mm:ss`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`timestamp`**'
  prefs: []
  type: TYPE_NORMAL
- en: The `timestamp` data type also stores the date and the time in one value with
    the same format `YYYY-MM-DD hh:mm:ss`, though `timestamp` stores the *current*
    date and time, while `datetime` is designed for other date and time values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The range of values that `timestamp` accepts is smaller; dates must be between
    the year 1970 and 2038\. The `datetime` data type accepts a wider range of dates,
    from the years 1000 to 9999\. You should use `timestamp` only when you want to
    stamp the current date and time value, such as to save the date and time that
    a row was updated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**`year`**'
  prefs: []
  type: TYPE_NORMAL
- en: The `year` data type stores the year in the `YYYY` format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The json Data Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*JavaScript Object Notation (JSON)* is a popular format for sending data between
    computers. MySQL provides the `json` data type to allow you to store and retrieve
    entire JSON documents in your database. MySQL will check that a JSON document
    contains valid JSON before allowing it to be saved in a `json` column.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple JSON document might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: JSON documents contain key/value pairs. In this example, `department` is a key
    and `Marketing` is a value. These keys and values don’t correspond to rows and
    columns in your table; instead, the entire JSON document can be saved in a column
    that has the `json` data type. Later, you can extract properties from the JSON
    document using MySQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: Spatial Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL provides data types for representing geographical location data, or *geodata*.
    This type of data helps answer questions like “What city am I in?” or “How many
    Chinese restaurants are within 5 miles of my location?”
  prefs: []
  type: TYPE_NORMAL
- en: '| `geometry` | Stores location values of any geographical type, including `point`,
    `linestring`, and `polygon` types |'
  prefs: []
  type: TYPE_TB
- en: '| `point` | Represents a location with a particular latitude and longitude,
    like your current location |'
  prefs: []
  type: TYPE_TB
- en: '| `linestring` | Represents points and the curve between them, such as the
    location of a highway |'
  prefs: []
  type: TYPE_TB
- en: '| `polygon` | Represents a boundary, such as around a country or city |'
  prefs: []
  type: TYPE_TB
- en: '| `multipoint` | Stores an unordered collection of `point` types |'
  prefs: []
  type: TYPE_TB
- en: '| `multilinestring` | Stores a collection of `linestring` types |'
  prefs: []
  type: TYPE_TB
- en: '| `emultipolygon` | Stores a collection of `polygon` typess |'
  prefs: []
  type: TYPE_TB
- en: '| `geometrycollection` | Stores a collection of `geometry` types |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you explored the available MySQL data types and when to use
    them. In the next chapter, you’ll look at ways to retrieve data from multiple
    tables using different MySQL join types, and display that data in a single result
    set.
  prefs: []
  type: TYPE_NORMAL
