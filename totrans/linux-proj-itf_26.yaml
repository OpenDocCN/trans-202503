- en: Chapter 26. Monitoring Child Processes
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第26章. 监控子进程
- en: 'In many application designs, a parent process needs to know when one of its
    child processes changes state—when the child terminates or is stopped by a signal.
    This chapter describes two techniques used to monitor child processes: the *wait()*
    system call (and its variants) and the use of the `SIGCHLD` signal.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用设计中，父进程需要知道其某个子进程的状态何时发生变化——当子进程终止或被信号停止时。本章描述了监控子进程的两种技术：*wait()* 系统调用（及其变体）和使用
    `SIGCHLD` 信号。
- en: Waiting on a Child Process
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待子进程
- en: In many applications where a parent creates child processes, it is useful for
    the parent to be able to monitor the children to find out when and how they terminate.
    This facility is provided by *wait()* and a number of related system calls.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多父进程创建子进程的应用程序中，父进程能够监控子进程，了解子进程何时以及如何终止是非常有用的。这个功能由 *wait()* 及一些相关系统调用提供。
- en: The *wait()* System Call
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*wait()* 系统调用'
- en: The *wait()* system call waits for one of the children of the calling process
    to terminate and returns the termination status of that child in the buffer pointed
    to by *status*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*wait()* 系统调用会等待调用进程的一个子进程终止，并将该子进程的终止状态返回到 *status* 指向的缓冲区中。'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns process ID of terminated child, or -1 on error
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 返回已终止子进程的进程 ID，或在出错时返回 -1
- en: 'The *wait()* system call does the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*wait()* 系统调用执行以下操作：'
- en: If no (previously unwaited-for) child of the calling process has yet terminated,
    the call blocks until one of the children terminates. If a child has already terminated
    by the time of the call, *wait()* returns immediately.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果调用进程的任何（先前未等待过的）子进程尚未终止，则该调用会阻塞，直到一个子进程终止。如果在调用时某个子进程已经终止，*wait()* 会立即返回。
- en: If *status* is not `NULL`, information about how the child terminated is returned
    in the integer to which *status* points. We describe the information returned
    in *status* in [The Wait Status Value](ch26.html#the_wait_status_value "The Wait
    Status Value").
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 *status* 不是 `NULL`，关于子进程如何终止的信息将返回到 *status* 指向的整数中。我们在[等待状态值](ch26.html#the_wait_status_value
    "等待状态值")中描述 *status* 返回的信息。
- en: The kernel adds the process CPU times ([Process Time](ch10.html#process_time
    "Process Time")) and resource usage statistics ([Process Resource Usage](ch36.html#process_resource_usage
    "Process Resource Usage")) to running totals for all children of this parent process.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内核将进程的 CPU 时间（[进程时间](ch10.html#process_time "进程时间")）和资源使用统计信息（[进程资源使用情况](ch36.html#process_resource_usage
    "进程资源使用情况")）添加到该父进程所有子进程的总数中。
- en: As its function result, *wait()* returns the process ID of the child that has
    terminated.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为其功能结果，*wait()* 返回已终止子进程的进程 ID。
- en: 'On error, *wait()* returns -1\. One possible error is that the calling process
    has no (previously unwaited-for) children, which is indicated by the *errno* value
    `ECHILD`. This means that we can use the following loop to wait for all children
    of the calling process to terminate:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当出错时，*wait()* 返回 -1。一个可能的错误是调用进程没有（先前未等待过的）子进程，这通过 *errno* 值 `ECHILD` 来指示。这意味着我们可以使用以下循环来等待调用进程的所有子进程终止：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Example 26-1](ch26.html#creating_and_waiting_for_multiple_childr "Example 26-1. Creating
    and waiting for multiple children") demonstrates the use of *wait()*. This program
    creates multiple child processes, one per (integer) command-line argument. Each
    child sleeps for the number of seconds specified in the corresponding command-line
    argument and then exits. In the meantime, after all children have been created,
    the parent process repeatedly calls *wait()* to monitor the termination of its
    children. This loop continues until *wait()* returns -1. (This is not the only
    approach: we could alternatively exit the loop when the number of terminated children,
    *numDead*, matches the number of children created.) The following shell session
    log shows what happens when we use the program to create three children:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 26-1](ch26.html#creating_and_waiting_for_multiple_childr "示例 26-1. 创建并等待多个子进程")
    演示了 *wait()* 的使用。该程序创建多个子进程，每个子进程对应一个（整数）命令行参数。每个子进程会根据相应命令行参数中指定的秒数休眠，然后退出。同时，在所有子进程创建后，父进程会反复调用
    *wait()* 来监控子进程的终止。该循环会持续到 *wait()* 返回 -1。（这并不是唯一的方法：我们也可以选择在已终止的子进程数量 *numDead*
    与创建的子进程数量相等时退出循环。）以下 shell 会话日志显示了当我们使用该程序创建三个子进程时发生的情况：'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If there are multiple terminated children at a particular moment, SUSv3 leaves
    unspecified the order in which these children will be reaped by a sequence of
    *wait()* calls; that is, the order depends on the implementation. Even across
    versions of the Linux kernel, the behavior varies.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个时刻有多个已终止的子进程，SUSv3没有指定这些子进程将由一系列*wait()*调用按什么顺序回收；也就是说，顺序取决于实现。即使在不同版本的Linux内核中，行为也有所不同。
- en: Example 26-1. Creating and waiting for multiple children
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 26-1. 创建并等待多个子进程
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The *waitpid()* System Call
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*waitpid()* 系统调用'
- en: 'The *wait()* system call has a number of limitations, which *waitpid()* was
    designed to address:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*wait()*系统调用有许多限制，*waitpid()*旨在解决这些问题：'
- en: If a parent process has created multiple children, it is not possible to *wait()*
    for the completion of a specific child; we can only wait for the next child that
    terminates.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果父进程创建了多个子进程，则无法*wait()*指定某个特定子进程的完成；我们只能等待下一个终止的子进程。
- en: If no child has yet terminated, *wait()* always blocks. Sometimes, it would
    be preferable to perform a nonblocking wait so that if no child has yet terminated,
    we obtain an immediate indication of this fact.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有子进程终止，*wait()*将始终阻塞。有时，执行非阻塞等待会更为合适，这样如果没有子进程终止，我们可以立即获得这一事实的反馈。
- en: Using *wait()*, we can find out only about children that have terminated. It
    is not possible to be notified when a child is stopped by a signal (such as `SIGSTOP`
    or `SIGTTIN`) or when a stopped child is resumed by delivery of a `SIGCONT` signal.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*wait()*，我们只能获知已终止的子进程。无法在子进程因信号（如`SIGSTOP`或`SIGTTIN`）被停止，或被`SIGCONT`信号恢复时收到通知。
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns process ID of child, 0 (see text), or -1 on error
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 返回子进程的进程ID、0（见文中说明）或出错时返回-1
- en: 'The return value and *status* arguments of *waitpid()* are the same as for
    *wait()*. (See [The Wait Status Value](ch26.html#the_wait_status_value "The Wait
    Status Value") for an explanation of the value returned in *status*.) The *pid*
    argument enables the selection of the child to be waited for, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*waitpid()*的返回值和*status*参数与*wait()*相同。（请参阅[等待状态值](ch26.html#the_wait_status_value
    "The Wait Status Value")，了解*status*中返回值的解释。）*pid*参数使我们能够选择要等待的子进程，具体如下：'
- en: If *pid* is greater than 0, wait for the child whose *process ID* equals *pid*.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*pid*大于0，等待进程ID等于*pid*的子进程。
- en: If *pid* equals 0, wait for any child in the *same process group as the caller*
    (parent). We describe process groups in Section 34.2.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*pid*等于0，等待与调用者（父进程）在*同一进程组*中的任何子进程。我们在第34.2节描述了进程组。
- en: If *pid* is less than -1, wait for any child whose *process group* identifier
    equals the absolute value of *pid*.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*pid*小于-1，等待任何*进程组*标识符等于*pid*绝对值的子进程。
- en: If *pid* equals -1, wait for *any* child. The call *wait(&status)* is equivalent
    to the call *waitpid(-1, &status, 0)*.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*pid*等于-1，等待*任何*子进程。调用*wait(&status)*等价于调用*waitpid(-1, &status, 0)*。
- en: 'The *options* argument is a bit mask that can include (OR) zero or more of
    the following flags (all of which are specified in SUSv3):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*options*参数是一个位掩码，可以包含（或）零个或多个以下标志（所有这些标志在SUSv3中有说明）：'
- en: '`WUNTRACED`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`WUNTRACED`'
- en: In addition to returning information about terminated children, also return
    information when a child is *stopped* by a signal.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了返回有关已终止子进程的信息外，还会在子进程被信号*停止*时返回信息。
- en: '`WCONTINUED` (since Linux 2.6.10)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`WCONTINUED`（自Linux 2.6.10起）'
- en: Also return status information about stopped children that have been resumed
    by delivery of a `SIGCONT` signal.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 还会返回关于已被`SIGCONT`信号恢复的停止子进程的状态信息。
- en: '`WNOHANG`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`WNOHANG`'
- en: If no child specified by *pid* has yet changed state, then return immediately,
    instead of blocking (i.e., perform a “poll”). In this case, the return value of
    *waitpid()* is 0\. If the calling process has no children that match the specification
    in *pid*, *waitpid()* fails with the error `ECHILD`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由*pid*指定的子进程尚未改变状态，则立即返回，而不是阻塞（即执行“轮询”）。在这种情况下，*waitpid()*的返回值为0。如果调用进程没有与*pid*规格匹配的子进程，*waitpid()*会因错误`ECHILD`而失败。
- en: We demonstrate the use of *waitpid()* in [Example 26-3](ch26.html#using_waitpid_open_parenthesis_close_par
    "Example 26-3. Using waitpid() to retrieve the status of a child process").
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[示例 26-3](ch26.html#using_waitpid_open_parenthesis_close_par "示例 26-3. 使用waitpid()获取子进程状态")中演示了*waitpid()*的使用。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In its rationale for *waitpid()*, SUSv3 notes that the name `WUNTRACED` is
    a historical artifact of this flag’s origin in BSD, where a process could be stopped
    in one of two ways: as a consequence of being traced by the *ptrace()* system
    call, or by being stopped by a signal (i.e., not being traced). When a child is
    being traced by *ptrace()*, then delivery of *any* signal (other than `SIGKILL`)
    causes the child to be stopped, and a `SIGCHLD` signal is consequently sent to
    the parent. This behavior occurs even if the child is ignoring the signal. However,
    if the child is blocking the signal, then it is not stopped (unless the signal
    is `SIGSTOP`, which can’t be blocked).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在*SUSv3*对*waitpid()*的说明中指出，`WUNTRACED`这个名称是这个标志在BSD中起源的历史遗留物，在BSD中，一个进程可以通过两种方式停止：作为被*ptrace()*系统调用跟踪的结果，或者通过信号停止（即未被跟踪）。当一个子进程被*ptrace()*跟踪时，*任何*信号（除了`SIGKILL`）的传递都会导致子进程停止，并因此向父进程发送`SIGCHLD`信号。即使子进程正在忽略信号，这种行为仍然会发生。然而，如果子进程正在屏蔽该信号，则不会停止（除非信号是`SIGSTOP`，该信号无法被屏蔽）。
- en: The Wait Status Value
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 等待状态值
- en: 'The *status* value returned by *wait()* and *waitpid()* allows us to distinguish
    the following events for the child:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*wait()*和*waitpid()*返回的*status*值可以帮助我们区分子进程的以下事件：'
- en: The child terminated by calling _*exit()* (or *exit()*), specifying an integer
    *exit status*.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子进程通过调用_*exit()*（或*exit()*）终止，并指定一个整数*exit status*（退出状态）。
- en: The child was terminated by the delivery of an unhandled signal.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子进程通过未处理的信号终止。
- en: The child was stopped by a signal, and *waitpid()* was called with the `WUNTRACED`
    flag.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子进程由于信号被停止，并且*waitpid()*使用了`WUNTRACED`标志。
- en: The child was resumed by a `SIGCONT` signal, and *waitpid()* was called with
    the `WCONTINUED` flag.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子进程通过`SIGCONT`信号恢复，且*waitpid()*使用了`WCONTINUED`标志。
- en: We use the term *wait status* to encompass all of the above cases. The designation
    *termination status* is used to refer to the first two cases. (In the shell, we
    can obtain the termination status of the last command executed by examining the
    contents of the variable *$?*.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用*wait status*一词来涵盖上述所有情况。*termination status*（终止状态）用于指代前两种情况。（在shell中，我们可以通过检查变量*$?*的内容来获取最后执行的命令的终止状态。）
- en: Although defined as an *int*, only the bottom 2 bytes of the value pointed to
    by *status* are actually used. The way in which these 2 bytes are filled depends
    on which of the above events occurred for the child, as depicted in [Figure 26-1](ch26.html#value_returned_in_the_status_argument_of
    "Figure 26-1. Value returned in the status argument of wait() and waitpid()").
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管被定义为一个*int*类型，但只有*status*指向值的底部两个字节实际被使用。这两个字节的填充方式取决于子进程发生的上述事件，如[图 26-1](ch26.html#value_returned_in_the_status_argument_of
    "图 26-1. wait()和waitpid()中*status*参数返回的值")所示。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '[Figure 26-1](ch26.html#value_returned_in_the_status_argument_of "Figure 26-1. Value
    returned in the status argument of wait() and waitpid()") shows the layout of
    the wait status value for Linux/x86-32\. The details vary across implementations.
    SUSv3 doesn’t specify any particular layout for this information, or even require
    that it is contained in the bottom 2 bytes of the value pointed to by *status*.
    Portable applications should always use the macros described in this section to
    inspect this value, rather than directly inspecting its bit-mask components.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 26-1](ch26.html#value_returned_in_the_status_argument_of "图 26-1. wait()和waitpid()中*status*参数返回的值")展示了Linux/x86-32平台上等待状态值的布局。具体细节会根据实现有所不同。*SUSv3*并没有指定这种信息的特定布局，甚至没有要求它包含在*status*指向的值的底部两个字节中。可移植的应用程序应始终使用本节中描述的宏来检查此值，而不是直接检查其位掩码组件。'
- en: '![Value returned in the status argument of wait() and waitpid()](figs/web/26-1_PROCEXEC-wait-status.png.jpg)Figure 26-1. Value
    returned in the *status* argument of *wait()* and *waitpid()*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![wait()和waitpid()中*status*参数返回的值](figs/web/26-1_PROCEXEC-wait-status.png.jpg)图 26-1. *wait()*和*waitpid()*中*status*参数返回的值'
- en: The `<sys/wait.h>` header file defines a standard set of macros that can be
    used to dissect a wait status value. When applied to a *status* value returned
    by *wait()* or *waitpid()*, only one of the macros in the list below will return
    true. Additional macros are provided to further dissect the *status* value, as
    noted in the list.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`<sys/wait.h>`头文件定义了一组标准宏，可以用来解构等待状态值。当应用于*wait()*或*waitpid()*返回的*status*值时，下面列表中的宏只有一个会返回`true`。还提供了额外的宏来进一步解构*status*值，如列表中所述。'
- en: '`WIFEXITED(status)`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`WIFEXITED(status)`'
- en: 'This macro returns true if the child process exited normally. In this case,
    the macro `WEXITSTATUS(status)` returns the exit status of the child process.
    (As noted in [Terminating a Process: *_exit()* and *exit()*](ch25.html#terminating_a_process_colon__underscore
    "Terminating a Process: _exit() and exit()"), only the least significant byte
    of the child’s exit status is available to the parent.)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子进程正常退出，则该宏返回 true。在这种情况下，宏`WEXITSTATUS(status)`返回子进程的退出状态。（如[终止进程：*_exit()*
    和 *exit()*](ch25.html#terminating_a_process_colon__underscore "终止进程：_exit() 和
    exit()")中所述，父进程只能访问子进程退出状态的最低有效字节。）
- en: '`WIFSIGNALED(status)`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`WIFSIGNALED(status)`'
- en: This macro returns true if the child process was killed by a signal. In this
    case, the macro `WTERMSIG(status)` returns the number of the signal that caused
    the process to terminate, and the macro `WCOREDUMP(status)` returns true if the
    child process produced a core dump file. The `WCOREDUMP()` macro is not specified
    by SUSv3, but is available on most UNIX implementations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子进程是被信号杀死的，则该宏返回 true。在这种情况下，宏`WTERMSIG(status)`返回导致进程终止的信号号，宏`WCOREDUMP(status)`返回
    true，如果子进程生成了核心转储文件。`WCOREDUMP()`宏并未在 SUSv3 中指定，但在大多数 UNIX 实现中可用。
- en: '`WIFSTOPPED(status)`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`WIFSTOPPED(status)`'
- en: This macro returns true if the child process was stopped by a signal. In this
    case, the macro `WSTOPSIG(status)` returns the number of the signal that stopped
    the process.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子进程被信号停止，则该宏返回 true。在这种情况下，宏`WSTOPSIG(status)`返回停止进程的信号号。
- en: '`WIFCONTINUED(status)`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`WIFCONTINUED(status)`'
- en: This macro returns true if the child was resumed by delivery of `SIGCONT`. This
    macro is available since Linux 2.6.10.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子进程是通过发送`SIGCONT`信号恢复的，则该宏返回 true。此宏自 Linux 2.6.10 起可用。
- en: Note that although the name *status* is also used for the argument of the above
    macros, they expect a plain integer, rather than a pointer to an integer as required
    by *wait()* and *waitpid()*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管*status*这个名称也用于上述宏的参数，但它们期望的是一个普通的整数，而不是像*wait()*和*waitpid()*所要求的整数指针。
- en: Example program
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: The *printWaitStatus()* function of [Example 26-2](ch26.html#displaying_the_status_value_returned_by
    "Example 26-2. Displaying the status value returned by wait() and related calls")
    uses all of the macros described above. This function dissects and prints the
    contents of a wait status value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 26-2](ch26.html#displaying_the_status_value_returned_by "示例 26-2. 显示由 wait()
    和相关调用返回的状态值")中的*printWaitStatus()*函数使用了上述所有宏。该函数解析并打印等待状态值的内容。'
- en: Example 26-2. Displaying the status value returned by *wait()* and related calls
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 26-2. 显示由*wait()*和相关调用返回的状态值
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The *printWaitStatus()* function is used in [Example 26-3](ch26.html#using_waitpid_open_parenthesis_close_par
    "Example 26-3. Using waitpid() to retrieve the status of a child process"). This
    program creates a child process that either loops continuously calling *pause()*
    (during which time signals can be sent to the child) or, if an integer command-line
    argument was supplied, exits immediately using this integer as the exit status.
    In the meantime, the parent monitors the child via *waitpid()*, printing the returned
    status value and passing this value to *printWaitStatus()*. The parent exits when
    it detects that the child has either exited normally or been terminated by a signal.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*printWaitStatus()*函数在[示例 26-3](ch26.html#using_waitpid_open_parenthesis_close_par
    "示例 26-3. 使用 waitpid() 获取子进程的状态")中使用。该程序创建一个子进程，该子进程要么持续循环调用*pause()*（此期间可以向子进程发送信号），要么如果提供了整数命令行参数，则立即使用该整数作为退出状态退出。与此同时，父进程通过*waitpid()*监控子进程，打印返回的状态值，并将该值传递给*printWaitStatus()*。当父进程检测到子进程正常退出或被信号终止时，父进程退出。'
- en: 'The following shell session shows a few example runs of the program in [Example 26-3](ch26.html#using_waitpid_open_parenthesis_close_par
    "Example 26-3. Using waitpid() to retrieve the status of a child process"). We
    begin by creating a child that immediately exits with a status of 23:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 shell 会话展示了[示例 26-3](ch26.html#using_waitpid_open_parenthesis_close_par "示例
    26-3. 使用 waitpid() 获取子进程的状态")中程序的一些示例运行。我们首先创建一个立即以状态 23 退出的子进程：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the next run, we start the program in the background, and then send `SIGSTOP`
    and `SIGCONT` signals to the child:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的运行中，我们将程序放在后台运行，然后向子进程发送`SIGSTOP`和`SIGCONT`信号：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The last two lines of output will appear only on Linux 2.6.10 and later, since
    earlier kernels don’t support the *waitpid()* `WCONTINUED` option. (This shell
    session is made slightly hard to read by the fact that output from the program
    executing in the background is in some cases intermingled with the prompt produced
    by the shell.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后两行只会在Linux 2.6.10及更高版本中出现，因为早期内核不支持*waitpid()*的`WCONTINUED`选项。（由于后台执行的程序输出有时与Shell提示符混合，因此这个Shell会话稍显难以阅读。）
- en: 'We continue the shell session by sending a `SIGABRT` signal to terminate the
    child:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过向子进程发送`SIGABRT`信号来终止它，继续Shell会话：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Although the default action of `SIGABRT` is to produce a core dump file and
    terminate the process, no core file was produced. This is because core dumps were
    disabled—the `RLIMIT_CORE` soft resource limit ([Details of Specific Resource
    Limits](ch36.html#details_of_specific_resource_limits "Details of Specific Resource
    Limits")), which specifies the maximum size of a core file, was set to 0, as shown
    by the *ulimit* command above.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`SIGABRT`的默认行为是产生核心转储文件并终止进程，但并未生成核心文件。这是因为核心转储被禁用了——`RLIMIT_CORE`软资源限制（[具体资源限制详情](ch36.html#details_of_specific_resource_limits
    "Details of Specific Resource Limits")），它指定了核心文件的最大大小，已被设置为0，如上所示的*ulimit*命令所示。
- en: 'We repeat the same experiment, but this time enabling core dumps before sending
    `SIGABRT` to the child:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重复相同的实验，但这次在发送`SIGABRT`信号给子进程之前启用了核心转储：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Example 26-3. Using *waitpid()* to retrieve the status of a child process
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 示例26-3. 使用*waitpid()*获取子进程的状态
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Process Termination from a Signal Handler
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从信号处理程序终止进程
- en: 'As shown in [Table 20-1](ch20.html#linux_signals "Table 20-1. Linux signals")
    (in [Changing Signal Dispositions: *signal()*](ch20.html#changing_signal_dispositions_colon_signa
    "Changing Signal Dispositions: signal()")), some signals terminate a process by
    default. In some circumstances, we may wish to have certain cleanup steps performed
    before a process terminates. For this purpose, we can arrange to have a handler
    catch such signals, perform the cleanup steps, and then terminate the process.
    If we do this, we should bear in mind that the termination status of a process
    is available to its parent via *wait()* or *waitpid()*. For example, calling *_exit(EXIT_SUCCESS)*
    from the signal handler will make it appear to the parent process that the child
    terminated successfully.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '如[表20-1](ch20.html#linux_signals "Table 20-1. Linux signals")所示（在[更改信号处置：*signal()*](ch20.html#changing_signal_dispositions_colon_signa
    "Changing Signal Dispositions: signal()")中），某些信号默认会终止进程。在某些情况下，我们可能希望在进程终止之前执行某些清理步骤。为此，我们可以安排处理程序捕获这些信号，执行清理步骤，然后终止进程。如果我们这样做，我们应当记住，进程的终止状态可以通过*wait()*或*waitpid()*传递给其父进程。例如，从信号处理程序调用*_exit(EXIT_SUCCESS)*将使父进程看到子进程成功终止。'
- en: 'If the child needs to inform the parent that it terminated because of a signal,
    then the child’s signal handler should first disestablish itself, and then raise
    the same signal once more, which this time will terminate the process. The signal
    handler would contain code such as the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子进程需要通知父进程它是因为信号而终止的，那么子进程的信号处理程序应该首先取消自身的注册，然后再次发送相同的信号，这次会终止进程。信号处理程序将包含如下代码：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The *waitid()* System Call
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*waitid()*系统调用'
- en: Like *waitpid()*, *waitid()* returns the status of child processes. However,
    *waitid()* provides extra functionality that is unavailable with *waitpid()*.
    This system call derives from System V, but is now specified in SUSv3\. It was
    added to Linux in kernel 2.6.9.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于*waitpid()*，*waitid()*返回子进程的状态。然而，*waitid()*提供了*waitpid()*所没有的额外功能。这个系统调用源自System
    V，但现在在SUSv3中被指定。它在Linux内核2.6.9中被加入。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before Linux 2.6.9, a version of *waitid()* was provided via an implementation
    in *glibc*. However, because a full implementation of this interface requires
    kernel support, the *glibc* implementation provided no more functionality than
    was available using *waitpid()*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux 2.6.9之前，*waitid()*的一个版本通过*glibc*中的实现提供。然而，由于该接口的完整实现需要内核支持，*glibc*实现提供的功能与使用*waitpid()*时的功能相同。
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success or if `WNOHANG` was specified and there were no children
    to wait for, or -1 on error
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，或者如果指定了`WNOHANG`且没有子进程需要等待，则返回0；如果出错，则返回-1。
- en: 'The *idtype* and *id* arguments specify which child(ren) to wait for, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*idtype*和*id*参数指定要等待的子进程，如下所示：'
- en: If *idtype* is `P_ALL`, wait for any child; *id* is ignored.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*idtype*是`P_ALL`，则等待任何子进程；*id*被忽略。
- en: If *idtype* is `P_PID`, wait for the child whose process ID equals *id*.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *idtype* 为 `P_PID`，则等待进程 ID 等于 *id* 的子进程。
- en: If *idtype* is `P_PGID`, wait for any child whose process group ID equals *id*.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *idtype* 为 `P_PGID`，则等待任何进程组 ID 等于 *id* 的子进程。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Note that unlike *waitpid()*, it is not possible to specify 0 in id to mean
    any process in the same process group as the caller. Instead, we must explicitly
    specify the caller’s process group ID using the value returned by *getpgrp()*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与 *waitpid()* 不同，不能在 *id* 中指定 0 来表示与调用者处于同一进程组的任何进程。相反，我们必须明确指定调用者的进程组 ID，使用
    *getpgrp()* 返回的值。
- en: 'The most significant difference between *waitpid()* and *waitid()* is that
    *waitid()* provides more precise control of the child events that should be waited
    for. We control this by ORing one or more of the following flags in *options*:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*waitpid()* 和 *waitid()* 之间最显著的区别是，*waitid()* 提供了更精确的控制，可以指定应该等待的子进程事件。我们可以通过将以下一个或多个标志与
    *options* 进行 OR 运算来控制这一点：'
- en: '`WEXITED`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`WEXITED`'
- en: Wait for children that have terminated, either normally or abnormally.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 等待已经终止的子进程，无论是正常终止还是异常终止。
- en: '`WSTOPPED`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`WSTOPPED`'
- en: Wait for children that have been stopped by a signal.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 等待被信号停止的子进程。
- en: '`WCONTINUED`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`WCONTINUED`'
- en: Wait for children that have been resumed by a `SIGCONT` signal.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 等待那些已通过 `SIGCONT` 信号恢复的子进程。
- en: 'The following additional flags may be ORed in *options*:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下附加标志可以与 *options* 进行 OR 运算：
- en: '`WNOHANG`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`WNOHANG`'
- en: This flag has the same meaning as for *waitpid()*. If none of the children matching
    the specification in id has status information to return, then return immediately
    (a poll). In this case, the return value of *waitid()* is 0\. If the calling process
    has no children that match the specification in *id*, *waitid()* instead fails
    with the error `ECHILD`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标志的含义与 *waitpid()* 中的相同。如果没有任何符合 *id* 中规格的子进程状态信息可以返回，则立即返回（轮询）。在这种情况下，*waitid()*
    的返回值为 0。如果调用进程没有符合 *id* 规格的子进程，*waitid()* 会返回错误 `ECHILD`。
- en: '`WNOWAIT`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`WNOWAIT`'
- en: Normally, once a child has been waited for using *waitid()*, then that “status
    event” is consumed. However, if `WNOWAIT` is specified, then the child status
    is returned, but the child remains in a waitable state, and we can later wait
    for it again to retrieve the same information.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一旦子进程被 *waitid()* 等待，那么该“状态事件”会被消耗。然而，如果指定了 `WNOWAIT`，则子进程的状态将被返回，但子进程将保持在可等待状态，之后我们可以再次等待它以获取相同的信息。
- en: 'On success, *waitid()* returns 0, and the *siginfo_t* structure ([The `SA_SIGINFO`
    Flag](ch21.html#the_sa_underscore_siginfo_flag "The SA_SIGINFO Flag")) pointed
    to by *infop* is updated to contain information about the child. The following
    fields are filled in the *siginfo_t* structure:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，*waitid()* 返回 0，并且由 *infop* 指向的 *siginfo_t* 结构（[`SA_SIGINFO` 标志](ch21.html#the_sa_underscore_siginfo_flag
    "The SA_SIGINFO Flag")）将被更新，以包含有关子进程的信息。以下字段将在 *siginfo_t* 结构中填充：
- en: '*si_code*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*si_code*'
- en: 'This field contains one of the following values: `CLD_EXITED`, indicating that
    the child terminated by calling *_exit()*; `CLD_KILLED`, indicating that the child
    was killed by a signal; `CLD_STOPPED`, indicating that the child was stopped by
    a signal; or `CLD_CONTINUED`, indicating that the (previously stopped) child resumed
    execution as a consequence of receiving a (`SIGCONT`) signal.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段包含以下值之一：`CLD_EXITED`，表示子进程通过调用 *_exit()* 终止；`CLD_KILLED`，表示子进程被信号杀死；`CLD_STOPPED`，表示子进程被信号停止；或
    `CLD_CONTINUED`，表示子进程（之前被停止）因接收到 (`SIGCONT`) 信号而恢复执行。
- en: '*si_pid*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*si_pid*'
- en: This field contains the process ID of the child whose state has changed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段包含子进程的进程 ID，表示其状态已发生变化。
- en: '*si_signo*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*si_signo*'
- en: This field is always set to `SIGCHLD`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段始终设置为 `SIGCHLD`。
- en: '*si_status*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*si_status*'
- en: This field contains either the exit status of the child, as passed to *_exit()*,
    or the signal that caused the child to stop, continue, or terminate. We can determine
    which type of information is in this field by examining the *si_code* field.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段包含子进程的退出状态，作为传递给 *_exit()* 的参数，或者导致子进程停止、继续或终止的信号。我们可以通过检查 *si_code* 字段来确定该字段中的信息类型。
- en: '*si_uid*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*si_uid*'
- en: This field contains the real user ID of the child. Most other UNIX implementations
    don’t set this field.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段包含子进程的真实用户 ID。大多数其他 UNIX 实现不会设置这个字段。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: 'On Solaris, two additional fields are filled in: *si_stime* and *si_utime*.
    These contain the system and user CPU time used by the child, respectively. SUSv3
    doesn’t require these fields to be set by *waitid()*.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Solaris 上，另外两个字段会被填充：*si_stime* 和 *si_utime*。这两个字段分别包含子进程使用的系统 CPU 时间和用户 CPU
    时间。SUSv3 并不要求 *waitid()* 设置这些字段。
- en: 'One detail of the operation of *waitid()* needs further clarification. If `WNOHANG`
    is specified in *options*, then a 0 return value from *waitid()* can mean one
    of two things: a child had already changed state at the time of the call (and
    information about the child is returned in the *siginfo_t* structure pointed to
    by *infop*), or there was no child whose state has changed. For the case where
    no child has changed state, some UNIX implementations (including Linux), zero
    out the returned *siginfo_t* structure. This provides a method of distinguishing
    the two possibilities: we can check whether the value in *si_pid* is 0 or nonzero.
    Unfortunately, this behavior is not required by SUSv3, and some UNIX implementations
    leave the *siginfo_t* structure unchanged in this case. (A future corrigendum
    to SUSv4 is likely to add a requirement that *si_pid* and *si_signo* are zeroed
    in this case.) The only portable way to distinguish these two cases is to zero
    out the *siginfo_t* structure before calling *waitid()*, as in the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*waitid()* 的一个操作细节需要进一步澄清。如果在 *options* 中指定了 `WNOHANG`，那么 *waitid()* 返回的 0
    值可能有两种含义：一个是子进程在调用时已经更改了状态（关于子进程的信息会返回在 *siginfo_t* 结构体中，*infop* 指向该结构体），另一个是没有子进程的状态发生变化。在没有子进程状态发生变化的情况下，一些
    UNIX 实现（包括 Linux）会将返回的 *siginfo_t* 结构体清零。这提供了一种区分这两种情况的方法：我们可以检查 *si_pid* 的值是否为
    0 或非零。不幸的是，这种行为并不是 SUSv3 所要求的，某些 UNIX 实现会在这种情况下保持 *siginfo_t* 结构体不变。（未来 SUSv4
    的修正可能会要求在这种情况下将 *si_pid* 和 *si_signo* 清零。）区分这两种情况的唯一可移植方法是在调用 *waitid()* 前清零 *siginfo_t*
    结构体，示例如下：'
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The *wait3()* and *wait4()* System Calls
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*wait3()* 和 *wait4()* 系统调用'
- en: The *wait3()* and *wait4()* system calls perform a similar task to *waitpid()*.
    The principal semantic difference is that *wait3()* and *wait4()* return *resource
    usage* information about the terminated child in the structure pointed to by the
    *rusage* argument. This information includes the amount of CPU time used by the
    process and memory-management statistics. We defer detailed discussion of the
    *rusage* structure until [Process Resource Usage](ch36.html#process_resource_usage
    "Process Resource Usage"), where we describe the *getrusage()* system call.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*wait3()* 和 *wait4()* 系统调用执行的任务与 *waitpid()* 类似。主要的语义差异在于，*wait3()* 和 *wait4()*
    会在 *rusage* 参数指向的结构中返回已终止子进程的 *资源使用* 信息。该信息包括进程使用的 CPU 时间和内存管理统计数据。我们将在 [进程资源使用](ch36.html#process_resource_usage
    "Process Resource Usage") 中详细讨论 *rusage* 结构，并描述 *getrusage()* 系统调用。'
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return process ID of child, or -1 on error
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都返回子进程的进程 ID，或者在出错时返回 -1
- en: 'Excluding the use of the *rusage* argument, a call to *wait3()* is equivalent
    to the following *waitpid()* call:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除去使用 *rusage* 参数的情况，调用 *wait3()* 相当于以下的 *waitpid()* 调用：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Similarly, *wait4()* is equivalent to the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，*wait4()* 相当于以下调用：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In other words, *wait3()* waits for any child, while *wait4()* can be used to
    select a specific child or children upon which to wait.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，*wait3()* 会等待任何子进程，而 *wait4()* 可以用来选择等待特定的子进程或子进程组。
- en: On some UNIX implementations, *wait3()* and *wait4()* return resource usage
    information only for terminated children. On Linux, resource usage information
    can also be retrieved for stopped children if the `WUNTRACED` flag is specified
    in *options*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些 UNIX 实现中，*wait3()* 和 *wait4()* 仅在子进程已终止时返回资源使用信息。在 Linux 中，如果在 *options*
    中指定了 `WUNTRACED` 标志，则也可以获取已停止子进程的资源使用信息。
- en: The names for these two system calls refer to the number of arguments they each
    take. Both system calls originated in BSD, but are now available on most UNIX
    implementations. Neither is standardized in SUSv3\. (SUSv2 did specify *wait3()*,
    but marked it LEGACY.)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个系统调用的名称指的是它们各自接受的参数数量。两个系统调用都起源于 BSD，但现在大多数 UNIX 实现中都有提供。它们都没有在 SUSv3 中标准化。（SUSv2
    确实指定了 *wait3()*，但将其标记为遗留功能。）
- en: We usually avoid the use of *wait3()* and *wait4()* in this book. Typically,
    we don’t need the extra information returned by these calls. Also, lack of standardization
    limits their portability.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们通常避免使用 *wait3()* 和 *wait4()*。通常，我们不需要这些调用返回的额外信息。此外，缺乏标准化限制了它们的可移植性。
- en: Orphans and Zombies
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 孤儿进程和僵尸进程
- en: 'The lifetimes of parent and child processes are usually not the same—either
    the parent outlives the child or vice versa. This raises two questions:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 父进程和子进程的生命周期通常不相同——父进程比子进程更长寿，或者反之。由此产生了两个问题：
- en: Who becomes the parent of an *orphaned* child? The orphaned child is adopted
    by *init*, the ancestor of all processes, whose process ID is 1\. In other words,
    after a child’s parent terminates, a call to *getppid()* will return the value
    1\. This can be used as a way of determining if a child’s true parent is still
    alive (this assumes a child that was created by a process other than *init*).
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁成为*孤儿*子进程的父进程？孤儿子进程会被*init*进程收养，*init*是所有进程的祖先，其进程 ID 为 1。换句话说，当一个子进程的父进程终止后，调用*getppid()*将返回值
    1。这可以作为判断子进程的真实父进程是否仍然存活的一种方法（假设该子进程是由一个非*init*进程创建的）。
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注：
- en: Using the `PR_SET_PDEATHSIG` operation of the Linux-specific *prctl()* system
    call, it is possible to arrange that a process receives a specified signal when
    it becomes an orphan.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Linux 特有的*prctl()* 系统调用的 `PR_SET_PDEATHSIG` 操作，可以安排在进程成为孤儿时接收到指定的信号。
- en: What happens to a child that terminates before its parent has had a chance to
    perform a *wait()*? The point here is that, although the child has finished its
    work, the parent should still be permitted to perform a *wait()* at some later
    time to determine how the child terminated. The kernel deals with this situation
    by turning the child into a *zombie*. This means that most of the resources held
    by the child are released back to the system to be reused by other processes.
    The only part of the process that remains is an entry in the kernel’s process
    table recording (among other things) the child’s process ID, termination status,
    and resource usage statistics ([Process Resource Usage](ch36.html#process_resource_usage
    "Process Resource Usage")).
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个子进程在父进程还没有机会执行*wait()*时就终止了，会发生什么情况？关键在于，虽然子进程已经完成了工作，但父进程仍然应该被允许在稍后的某个时间执行*wait()*，以便确定子进程是如何终止的。内核通过将子进程转变为*zombie*来处理这种情况。这意味着子进程占用的大部分资源将被释放回系统，供其他进程重用。唯一保留下来的部分是内核进程表中的一项记录，记录了（除了其他信息外）子进程的进程
    ID、终止状态以及资源使用统计信息（[进程资源使用](ch36.html#process_resource_usage "进程资源使用")）。
- en: Regarding zombies, UNIX systems imitate the movies—a zombie process can’t be
    killed by a signal, not even the (silver bullet) `SIGKILL`. This ensures that
    the parent can always eventually perform a *wait()*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 关于僵尸进程，UNIX 系统模仿了电影中的情节——一个僵尸进程无法通过信号被杀死，甚至连（银弹）`SIGKILL`也不行。这确保了父进程最终总是能够执行*wait()*。
- en: When the parent does perform a *wait()*, the kernel removes the zombie, since
    the last remaining information about the child is no longer required. On the other
    hand, if the parent terminates without doing a *wait()*, then the *init* process
    adopts the child and automatically performs a *wait()*, thus removing the zombie
    process from the system.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当父进程执行*wait()*时，内核会移除僵尸进程，因为关于子进程的最后一条信息不再需要。另一方面，如果父进程在没有执行*wait()*的情况下终止，则*init*进程会收养该子进程并自动执行*wait()*，从而将僵尸进程从系统中移除。
- en: If a parent creates a child, but fails to perform a *wait()*, then an entry
    for the zombie child will be maintained indefinitely in the kernel’s process table.
    If a large number of such zombie children are created, they will eventually fill
    the kernel process table, preventing the creation of new processes. Since the
    zombies can’t be killed by a signal, the only way to remove them from the system
    is to kill their parent (or wait for it to exit), at which time the zombies are
    adopted and waited on by *init*, and consequently removed from the system.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果父进程创建了一个子进程，但没有执行*wait()*，那么该僵尸子进程的条目将会在内核进程表中被永久保留。如果创建了大量这样的僵尸子进程，它们最终会填满内核进程表，阻止新的进程创建。由于僵尸进程无法通过信号被杀死，唯一的方式是杀死它们的父进程（或等待它退出），到那时，僵尸进程将会被*init*进程收养并等待，从而被从系统中移除。
- en: These semantics have important implications for the design of long-lived parent
    processes, such as network servers and shells, that create numerous children.
    To put things another way, in such applications, a parent process should perform
    *wait()* calls in order to ensure that dead children are always removed from the
    system, rather than becoming long-lived zombies. The parent may perform such *wait()*
    calls either synchronously, or asynchronously, in response to delivery of the
    `SIGCHLD` signal, as described in [Establishing a Handler for `SIGCHLD`](ch26.html#establishing_a_handler_for_sigchld
    "Establishing a Handler for SIGCHLD").
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 26-4](ch26.html#creating_a_zombie_child_process "Example 26-4. Creating
    a zombie child process") demonstrates the creation of a zombie and that a zombie
    can’t be killed by `SIGKILL`. When we run this program, we see the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the above output, we see that *ps(1)* displays the string `<defunct>` to
    indicate a process in the zombie state.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The program in [Example 26-4](ch26.html#creating_a_zombie_child_process "Example 26-4. Creating
    a zombie child process") uses the *system()* function to execute the shell command
    given in its character-string argument. We describe *system()* in detail in Section
    27.6.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Example 26-4. Creating a zombie child process
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `SIGCHLD` Signal
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The termination of a child process is an event that occurs asynchronously.
    A parent can’t predict when one of its child will terminate. (Even if the parent
    sends a `SIGKILL` signal to the child, the exact time of termination is still
    dependent on when the child is next scheduled for use of a CPU.) We have already
    seen that the parent should use *wait()* (or similar) in order to prevent the
    accumulation of zombie children, and have looked at two ways in which this can
    be done:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The parent can call *wait()*, or *waitpid()* without specifying the `WNOHANG`
    flag, in which case the call will block if a child has not already terminated.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parent can periodically perform a nonblocking check (a poll) for dead children
    via a call to *waitpid()* specifying the `WNOHANG` flag.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of these approaches can be inconvenient. On the one hand, we may not want
    the parent to be blocked waiting for a child to terminate. On the other hand,
    making repeated nonblocking *waitpid()* calls wastes CPU time and adds complexity
    to an application design. To get around these problems, we can employ a handler
    for the `SIGCHLD` signal.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Establishing a Handler for `SIGCHLD`
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `SIGCHLD` signal is sent to a parent process whenever one of its children
    terminates. By default, this signal is ignored, but we can catch it by installing
    a signal handler. Within the signal handler, we can use *wait()* (or similar)
    to reap the zombie child. However, there is a subtlety to consider in this approach.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: In [The Signal Mask (Blocking Signal Delivery)](ch20.html#the_signal_mask_open_parenthesis_blockin
    "The Signal Mask (Blocking Signal Delivery)") and [Signals Are Not Queued](ch20.html#signals_are_not_queued
    "Signals Are Not Queued"), we observed that when a signal handler is called, the
    signal that caused its invocation is temporarily blocked (unless the *sigaction()*
    `SA_NODEFER` flag was specified), and also that standard signals, of which `SIGCHLD`
    is one, are not queued. Consequently, if a second and third child terminate in
    quick succession while a `SIGCHLD` handler is executing for an already terminated
    child, then, although `SIGCHLD` is generated twice, it is queued only once to
    the parent. As a result, if the parent’s `SIGCHLD` handler called *wait()* only
    once each time it was invoked, the handler might fail to reap some zombie children.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to loop inside the `SIGCHLD` handler, repeatedly calling *waitpid()*
    with the `WNOHANG` flag until there are no more dead children to be reaped. Often,
    the body of a `SIGCHLD` handler simply consists of the following code, which reaps
    any dead children without checking their status:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The above loop continues until *waitpid()* returns either 0, indicating no more
    zombie children, or -1, indicating an error (probably `ECHILD`, meaning that there
    are no more children).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Design issues for `SIGCHLD` handlers
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose that, at the time we establish a handler for `SIGCHLD`, there is already
    a terminated child for this process. Does the kernel then immediately generate
    a `SIGCHLD` signal for the parent? SUSv3 leaves this point unspecified. Some System
    V-derived implementations do generate a `SIGCHLD` in these circumstances; other
    implementations, including Linux, do not. A portable application can make this
    difference invisible by establishing the `SIGCHLD` handler before creating any
    children. (This is usually the natural way of doing things, of course.)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: A further point to consider is the issue of reentrancy. In [Reentrant and Async-Signal-Safe
    Functions](ch21.html#reentrant_and_async-signal-safe_function "Reentrant and Async-Signal-Safe
    Functions"), we noted that using a system call (e.g., *waitpid()*) from within
    a signal handler may change the value of the global variable *errno*. Such a change
    could interfere with attempts by the main program to explicitly set *errno* (see,
    for example, the discussion of *getpriority()* in [Process Priorities (Nice Values)](ch35.html#process_priorities_open_parenthesis_nice
    "Process Priorities (Nice Values)")) or check its value after a failed system
    call. For this reason, it is sometimes necessary to code a `SIGCHLD` handler to
    save *errno* in a local variable on entry to the handler, and then restore the
    *errno* value just prior to returning. An example of this is shown in [Example 26-5](ch26.html#reaping_dead_children_via_a_handler_for
    "Example 26-5. Reaping dead children via a handler for SIGCHLD").
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 26-5](ch26.html#reaping_dead_children_via_a_handler_for "Example 26-5. Reaping
    dead children via a handler for SIGCHLD") provides an example of a more complex
    `SIGCHLD` handler. This handler displays the process ID and wait status of each
    reaped child ![](figs/web/U001.png). In order to see that multiple `SIGCHLD` signals
    are not queued while the handler is already invoked, execution of the handler
    is artificially lengthened by a call to *sleep()* ![](figs/web/U002.png). The
    main program creates one child process for each (integer) command-line argument
    ![](figs/web/U004.png). Each of these children sleeps for the number of seconds
    specified in the corresponding command-line argument and then exits ![](figs/web/U005.png).
    In the following example of the execution of this program, we see that even though
    three children terminate, `SIGCHLD` is only queued twice to the parent:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note the use of *sigprocmask()* to block the SIGCHLD signal before any children
    are created in [Example 26-5](ch26.html#reaping_dead_children_via_a_handler_for
    "Example 26-5. Reaping dead children via a handler for SIGCHLD") ![](figs/web/U003.png).
    This is done to ensure correct operation of the *sigsuspend()* loop in the parent.
    If we failed to block `SIGCHLD` in this way, and a child terminated between the
    test of the value of *numLiveChildren* and the execution of the *sigsuspend()*
    call (or alternatively a *pause()* call), then the *sigsuspend()* call would block
    forever waiting for a signal that has already been caught ![](figs/web/U006.png).
    The requirement for dealing with this type of race condition was detailed in Section
    22.9.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Example 26-5. Reaping dead children via a handler for `SIGCHLD`
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Delivery of `SIGCHLD` for Stopped Children
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as *waitpid()* can be used to monitor stopped children, so is it possible
    for a parent process to receive the `SIGCHLD` signal when one of its children
    is stopped by a signal. This behavior is controlled by the `SA_NOCLDSTOP` flag
    when using *sigaction()* to establish a handler for the `SIGCHLD` signal. If this
    flag is omitted, a `SIGCHLD` signal is delivered to the parent when one of its
    children stops; if the flag is present, `SIGCHLD` is not delivered for stopped
    children. (The implementation of *signal()* given in [Implementation and Portability
    of *signal()*](ch22.html#implementation_and_portability_of_signal "Implementation
    and Portability of signal()") doesn’t specify `SA_NOCLDSTOP`.)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since `SIGCHLD` is ignored by default, the `SA_NOCLDSTOP` flag has a meaning
    only if we are establishing a handler for `SIGCHLD`. Furthermore, `SIGCHLD` is
    the only signal for which the `SA_NOCLDSTOP` flag has an effect.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: SUSv3 also allows for a parent to be sent a `SIGCHLD` signal if one of its stopped
    children is resumed by being sent a `SIGCONT` signal. (This corresponds to the
    `WCONTINUED` flag for *waitpid()*.) This feature is implemented in Linux since
    kernel 2.6.9.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring Dead Child Processes
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a further possibility for dealing with dead child processes. Explicitly
    setting the disposition of `SIGCHLD` to `SIG_IGN` causes any child process that
    subsequently terminates to be immediately removed from the system instead of being
    converted into a zombie. In this case, since the status of the child process is
    simply discarded, a subsequent call to *wait()* (or similar) can’t return any
    information for the terminated child.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种处理死掉子进程的可能性。显式将`SIGCHLD`的处理方式设置为`SIG_IGN`会导致任何随后终止的子进程立即从系统中移除，而不是转变为僵尸进程。在这种情况下，由于子进程的状态会被丢弃，随后对*wait()*（或类似函数）的调用将无法返回任何已终止子进程的信息。
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that even though the default disposition for `SIGCHLD` is to be ignored,
    explicitly setting the disposition to `SIG_IGN` causes the different behavior
    described here. In this respect, `SIGCHLD` is treated uniquely among signals.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管`SIGCHLD`的默认处理方式是被忽略，但显式将其设置为`SIG_IGN`会导致此处描述的不同行为。在这方面，`SIGCHLD`在信号中具有独特的处理方式。
- en: On Linux, as on many UNIX implementations, setting the disposition of `SIGCHLD`
    to `SIG_IGN` doesn’t affect the status of any existing zombie children, which
    must still be waited upon in the usual way. On some other UNIX implementations
    (e.g., Solaris 8), setting the disposition of `SIGCHLD` to `SIG_IGN` *does* remove
    existing zombie children.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，和许多UNIX实现一样，将`SIGCHLD`的处理方式设置为`SIG_IGN`不会影响任何现有僵尸子进程的状态，这些僵尸进程仍然需要按照常规方式进行等待。在其他一些UNIX实现（例如Solaris
    8）中，将`SIGCHLD`的处理方式设置为`SIG_IGN`*确实*会移除现有的僵尸子进程。
- en: The `SIG_IGN` semantics for `SIGCHLD` have a long history, deriving from System
    V. SUSv3 specifies the behavior described here, but these semantics were left
    unspecified in the original POSIX.1 standard. Thus, on some older UNIX implementations,
    ignoring `SIGCHLD` has no effect on the creation of zombies. The only completely
    portable way of preventing the creation of zombies is to call *wait()* or *waitpid()*,
    possibly from within a handler established for `SIGCHLD`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIG_IGN`对`SIGCHLD`的语义有着悠久的历史，源自System V。SUSv3规定了此处描述的行为，但这些语义在最初的POSIX.1标准中并未明确规定。因此，在一些较旧的UNIX实现中，忽略`SIGCHLD`对僵尸进程的创建没有任何影响。防止僵尸进程创建的唯一完全可移植的方法是调用*wait()*或*waitpid()*，可能是在为`SIGCHLD`设置的处理程序内进行调用。'
- en: Deviations from SUSv3 in older Linux kernels
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 旧版Linux内核与SUSv3的偏差
- en: SUSv3 specifies that if the disposition of `SIGCHLD` is set to `SIG_IGN`, the
    resource usage information for the child should be discarded and not included
    in the totals returned when the parent makes a call to *getrusage()* specifying
    the `RUSAGE_CHILDREN` flag ([Process Resource Usage](ch36.html#process_resource_usage
    "Process Resource Usage")). However, on Linux versions before kernel 2.6.9, the
    CPU times and resources used by the child *are* recorded and are visible in calls
    to *getrusage()*. This nonconformance is fixed in Linux 2.6.9 and later.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3规定，如果`SIGCHLD`的处理方式设置为`SIG_IGN`，则应丢弃子进程的资源使用信息，并且在父进程调用*getrusage()*并指定`RUSAGE_CHILDREN`标志时，这些信息不应包含在返回的总计中（[进程资源使用](ch36.html#process_resource_usage
    "进程资源使用")）。然而，在Linux内核版本低于2.6.9时，子进程使用的CPU时间和资源*会*被记录，并且在调用*getrusage()*时可见。这种不符合规定的行为在Linux
    2.6.9及之后的版本中已被修正。
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Setting the disposition of `SIGCHLD` to `SIG_IGN` should also prevent the child
    CPU times from being included in the structure returned by *times()* ([Process
    Time](ch10.html#process_time "Process Time")). However, on Linux kernels before
    2.6.9, a similar nonconformance applies for the information returned by *times()*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将`SIGCHLD`的处理方式设置为`SIG_IGN`还应防止子进程的CPU时间被包含在*times()*返回的结构中（[进程时间](ch10.html#process_time
    "进程时间")）。然而，在Linux内核版本低于2.6.9时，*times()*返回的信息也存在类似的不符合规定的行为。
- en: SUSv3 specifies that if the disposition of `SIGCHLD` is set to `SIG_IGN`, and
    the parent has no terminated children that have been transformed into zombies
    and have not yet been waited for, then a call to *wait()* (or *waitpid()*) should
    block until *all* of the parent’s children have terminated, at which point the
    call should terminate with the error `ECHILD`. Linux 2.6 conforms to this requirement.
    However, in Linux 2.4 and earlier, *wait()* blocks only until the *next* child
    terminates, and then returns the process ID and status of that child (i.e., the
    behavior is the same as if the disposition of `SIGCHLD` had not been set to `SIG_IGN`).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The *sigaction()*`SA_NOCLDWAIT` flag
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SUSv3 specifies the `SA_NOCLDWAIT` flag, which can be used when setting the
    disposition of the `SIGCHLD` signal using *sigaction()*. This flag produces behavior
    similar to that when the disposition of `SIGCHLD` is set to `SIG_IGN`. This flag
    was not implemented in Linux 2.4 and earlier, but is implemented in Linux 2.6.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The principal difference between setting the disposition of `SIGCHLD` to `SIG_IGN`
    and employing `SA_NOCLDWAIT` is that, when establishing a handler with `SA_NOCLDWAIT`,
    SUSv3 leaves it unspecified whether or not a `SIGCHLD` signal is sent to the parent
    when a child terminates. In other words, an implementation is permitted to deliver
    `SIGCHLD` when `SA_NOCLDWAIT` is specified, and an application could catch this
    signal (although the `SIGCHLD` handler would not be able to reap the child status
    using *wait()*, since the kernel has already discarded the zombie). On some UNIX
    implementations, including Linux, the kernel does generate a `SIGCHLD` signal
    for the parent process. On other UNIX implementations, `SIGCHLD` is not generated.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When setting the `SA_NOCLDWAIT` flag for the `SIGCHLD` signal, older Linux kernels
    demonstrate the same details of nonconformance to SUSv3 as were described above
    for setting the disposition of `SIGCHLD` to `SIG_IGN`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The System V `SIGCLD` signal
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On Linux, the name SIGCLD is provided as a synonym for the `SIGCHLD` signal.
    The reason for the existence of both names is historical. The `SIGCHLD` signal
    originated on BSD, and this name was adopted by POSIX, which largely standardized
    on the BSD signal model. System V provided the corresponding `SIGCLD` signal,
    with slightly different semantics.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The key difference between BSD `SIGCHLD` and System V `SIGCLD` lies in what
    happens when the disposition of the signal was set to `SIG_IGN`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: On historical (and some contemporary) BSD implementations, the system continues
    to generate zombies for unwaited-for children, even when `SIGCHLD` is ignored.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On System V, using *signal()* (but not *sigaction()*) to ignore `SIGCLD` has
    the result that zombies are not generated when children died.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As already noted, the original POSIX.1 standard left the result of ignoring
    `SIGCHLD` unspecified, thus permitting the System V behavior. Nowadays, this System
    V behavior is specified as part of SUSv3 (which nevertheless holds to the name
    `SIGCHLD`). Modern System V derivatives use the standard name `SIGCHLD` for this
    signal, but continue to provide the synonym `SIGCLD`. Further details on `SIGCLD`
    can be found in [Stevens & Rago, 2005].
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using *wait()* and *waitpid()* (and other related functions), a parent process
    can obtain the status of its terminated and stopped children. This status indicates
    whether a child process terminated normally (with an exit status indicating either
    success or failure), terminated abnormally, was stopped by a signal, or was resumed
    by a `SIGCONT` signal.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: If a child’s parent terminates, the child becomes an orphan and is adopted by
    the *init* process, whose process ID is 1.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: When a child process terminates, it becomes a zombie, and is removed from the
    system only when its parent calls *wait()* (or similar) to retrieve the child’s
    status. Long-running programs such as shells and daemons should be designed so
    that they always reap the status of the child processes they create, since a process
    in the zombie state can’t be killed, and unreaped zombies will eventually clog
    the kernel process table.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: A common way of reaping dead child processes is to establish a handler for the
    `SIGCHLD` signal. This signal is delivered to a parent process whenever one of
    its children terminates, and optionally when a child is stopped by a signal. Alternatively,
    but somewhat less portably, a process may elect to set the disposition of `SIGCHLD`
    to `SIG_IGN`, in which case the status of terminated children is immediately discarded
    (and thus can’t later be retrieved by the parent), and the children don’t become
    zombies.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Further information
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Refer to the sources of further information listed in Section 24.6.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a program to verify that when a child’s parent terminates, a call to *getppid()*
    returns 1 (the process ID of *init*).
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Suppose that we have three processes related as grandparent, parent, and child,
    and that the grandparent doesn’t immediately perform a *wait()* after the parent
    exits, so that the parent becomes a zombie. When do you expect the grandchild
    to be adopted by *init* (so that *getppid()* in the grandchild returns 1): after
    the parent terminates or after the grandparent does a *wait()*? Write a program
    to verify your answer.'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the use of *waitpid()* with *waitid()* in [Example 26-3](ch26.html#using_waitpid_open_parenthesis_close_par
    "Example 26-3. Using waitpid() to retrieve the status of a child process") (`child_status.c`).
    The call to *printWaitStatus()* will need to be replaced by code that prints relevant
    fields from the *siginfo_t* structure returned by *waitid()*.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Example 26-4](ch26.html#creating_a_zombie_child_process "Example 26-4. Creating
    a zombie child process") (`make_zombie.c`) uses a call to *sleep()* to allow the
    child process a chance to execute and terminate before the parent executes *system()*.
    This approach produces a theoretical race condition. Modify the program to eliminate
    the race condition by using signals to synchronize the parent and child.'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[示例 26-4](ch26.html#creating_a_zombie_child_process "示例 26-4. 创建僵尸子进程") (`make_zombie.c`)
    使用了调用 *sleep()* 来让子进程有机会执行并终止，然后父进程再执行 *system()*。这种方法会产生一个理论上的竞态条件。修改程序，使用信号来同步父进程和子进程，从而消除竞态条件。'
