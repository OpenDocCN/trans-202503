<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Credential Storage"><div class="titlepage"><div><div><h1 class="title"><a id="credential_storage"/>Chapter 7. Credential Storage</h1></div></div></div><p>The previous chapter introduced PKI and the challenges involved in managing trust. While the most prevalent use of PKI is for authenticating the entity you connect to (<span class="emphasis"><em>server authentication</em></span>), it’s also used to authenticate you to those entities (<span class="emphasis"><em>client authentication</em></span>). Client authentication is mostly found in enterprise environments, where it is used for everything from desktop logon to remotely accessing company servers. PKI-based client authentication requires the client to prove that it possesses an authentication key (typically an RSA private key) by performing certain cryptographic operations that the server can verify independently. Therefore, the security of client authentication relies heavily on protecting authentication keys from unauthorized use.</p><p>Most operating systems provide a system service that applications can use to securely store and access authentication keys without having to implement key protection themselves. Android has had such a service since version 1.6, and it has improved significantly since Android 4.0.</p><p><a id="iddle1344" class="indexterm"/><a id="iddle1440" class="indexterm"/><a id="iddle1441" class="indexterm"/><a id="iddle1675" class="indexterm"/><a id="iddle1682" class="indexterm"/><a id="iddle1686" class="indexterm"/><a id="iddle1771" class="indexterm"/><a id="iddle2377" class="indexterm"/><a id="iddle2486" class="indexterm"/><a id="iddle2505" class="indexterm"/><a id="iddle3084" class="indexterm"/><a id="iddle3085" class="indexterm"/><a id="iddle3103" class="indexterm"/><a id="iddle3104" class="indexterm"/>Android’s credential store can be used to store credentials for built-in features such as Wi-Fi and VPN connectivity, as well as for third-party apps. Apps can access the credential store via standard SDK APIs and use it to manage their keys securely. Recent Android versions feature hardware-backed key storage, which provides enhanced key protection. This chapter discusses the architecture and implementation of Android’s credential store and introduces the public APIs that it provides.</p><div class="sect1" title="VPN and Wi-Fi EAP Credentials"><div class="titlepage"><div><div><h1 class="title"><a id="vpn_and_wi-fi_eap_credentials"/>VPN and Wi-Fi EAP Credentials</h1></div></div></div><p><span class="emphasis"><em>Virtual Private Networks (VPNs)</em></span> are the preferred way to offer remote access to private enterprise services. We’ll discuss VPNs and related technologies in more detail in <a class="xref" href="ch09.html" title="Chapter 9. Enterprise Security">Chapter 9</a>, but simply put, a VPN allows a remote client to join a private network by creating an encrypted tunnel between it and a public tunnel endpoint. VPN implementations differ in their use of tunneling technology, but all need to authenticate the client before they establish a secure connection. While some VPNs use a shared key or password for authentication, enterprise solutions often rely on PKI-based client authentication.</p><p><span class="emphasis"><em>Extensible Authentication Protocol (EAP)</em></span> is an authentication framework frequently used in wireless networks and point-to-point (P2P) connections. (EAP is discussed in more detail in <a class="xref" href="ch09.html" title="Chapter 9. Enterprise Security">Chapter 9</a>.) Like VPN, EAP can use many different authentication methods, but EAP-Transport Layer Security (EAP-TLS) is preferred in enterprise environments, especially when a company PKI has already been deployed.</p><div class="sect2" title="Authentication Keys and Certificates"><div class="titlepage"><div><div><h2 class="title"><a id="authentication_keys_and_certificates"/>Authentication Keys and Certificates</h2></div></div></div><p>In the case of both EAP-TLS and PKI-based VPNs, clients have an authentication key and are issued a matching certificate, often by the company certificate authority (CA). Keys are sometimes stored in a portable, tamper-resistant device such as a smart card or USB token. This greatly increases security because keys cannot be exported or extracted from the device and thus authentication requires both physical possession of the token and the knowledge of the associated PIN or passphrase.</p><p>When the security policy allows using authentication keys that are not protected by a hardware device, keys and associated certificates are typically stored in the standard PKCS#12 file format. Private keys stored in PKCS#12 files are encrypted with a symmetric key derived from a user-supplied password, and thus extracting the keys requires knowledge of the password. Some applications use PKCS#12 files as secure containers and only extract keys and certificates into memory when required, but typically they’re imported into a system- or application-specific credential storage before use. This is how Android works as well.</p><p><a id="iddle1442" class="indexterm"/><a id="iddle1683" class="indexterm"/><a id="iddle2890" class="indexterm"/><a id="iddle3086" class="indexterm"/><a id="iddle3105" class="indexterm"/>The user-facing implementation of importing credentials on Android is rather simple: to import an authentication key and related certificates, users copy their PKCS#12 files (and, if necessary, any related CA certificates) to the device’s external storage (often an SD card) and select <span class="strong"><strong>Install from storage</strong></span> from the <span class="strong"><strong>Security</strong></span> system settings screen. Android searches the root of the external storage for matching files (with the <span class="emphasis"><em>.pfx</em></span> or <span class="emphasis"><em>.p12</em></span> extensions) and presents an import dialog (see <a class="xref" href="ch07.html#pkcshash12_file_password_dialog" title="Figure 7-1. PKCS#12 file password dialog">Figure 7-1</a>). If the correct password is supplied, keys are extracted from the PKCS#12 file and imported into the system credential store.</p></div><div class="sect2" title="The System Credential Store"><div class="titlepage"><div><div><h2 class="title"><a id="system_credential_store"/>The System Credential Store</h2></div></div></div><p>The system credential store is a system service that encrypts imported credentials before storing them on disk. The encryption key is derived from a user-supplied password: a dedicated credential store protection password in pre-4.0 versions, or the device unlock swipe pattern, PIN, or password in post-4.0 versions of Android. Additionally, the credential store system service regulates access to stored credentials and guarantees that only apps explicitly granted access can access keys.</p><p>The original credential store was introduced in Android 1.6 and was limited to storing VPN and Wi-Fi EAP credentials. Only the system—not third-party apps—could access stored keys and certificates. Additionally, the only supported way to import credentials was to go through the system settings UI outlined in the previous section, and no public APIs for credential store management were available.</p><p>APIs for accessing the system credential store were first introduced in Android 4.0. The system credential store was later extended to support hardware-backed credential storage and to offer not only shared system keys, but app-private keys as well. <a class="xref" href="ch07.html#credential_store_feature_progression" title="Table 7-1. Credential Store Feature Progression">Table 7-1</a> shows a summary of the major credential store enhancements added in each Android version. We’ll introduce these enhancements and the related APIs in the following sections.</p><div class="figure"><a id="pkcshash12_file_password_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00022"/><img src="figs/web/07fig01.png.jpg" alt="PKCS#12 file password dialog"/></div></div><p class="title">Figure 7-1. PKCS#12 file password dialog</p></div><div class="table"><a id="credential_store_feature_progression"/><p class="title">Table 7-1. Credential Store Feature Progression</p><div class="table-contents"><table summary="Credential Store Feature Progression" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><a id="iddle1268" class="indexterm"/><a id="iddle1437" class="indexterm"/><a id="iddle2127" class="indexterm"/>Android version</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>API level</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>Credential store changes</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>1.6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>4</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Added credential store for VPN and Wi-Fi.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>4.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>14</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Added public API for credential store (<code class="literal">KeyChain</code> API).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>4.1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>16</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Added the ability to generate and use keys without exporting them. Introduced keymaster HAL module and initial support for hardware-backed RSA key storage.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>4.3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>18</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Added support for generating and accessing app-private keys using the <span class="emphasis"><em>AndroidKeyStore</em></span> JCA provider, and APIs to check whether the device supports hardware-backed key storage for RSA keys.</p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p>4.4</p></td><td style="border-right: 0.5pt solid ; " valign="top"><p>19</p></td><td style="" valign="top"><p>Added ECDSA and DSA support to the <span class="emphasis"><em>AndroidKeyStore</em></span> JCA provider.</p></td></tr></tbody></table></div></div></div></div><div class="sect1" title="Credential Storage Implementation"><div class="titlepage"><div><div><h1 class="title"><a id="credential_storage_implementation"/>Credential Storage Implementation</h1></div></div></div><p>We now know that Android can encrypt imported credentials and manage access to them. Let’s see how this is implemented under the hood.</p><div class="sect2" title="The keystore Service"><div class="titlepage"><div><div><h2 class="title"><a id="keystore_service"/>The keystore Service</h2></div></div></div><p>Credential storage management in Android was originally implemented by a single native daemon called <span class="emphasis"><em>keystore</em></span>. Its functionality was initially limited to storing arbitrary blobs in encrypted form and verifying the credential store password, but it was extended with new features as Android evolved. It offered a local socket-based interface to its clients, and each client was responsible for managing their own state and socket connections. The <span class="emphasis"><em>key-store</em></span> daemon was replaced with a centralized Binder service in Android 4.3 in order to better integrate it with other framework services and facilitate extension. Let’s see how this <span class="emphasis"><em>keystore</em></span> service works.</p><p>The <span class="emphasis"><em>keystore</em></span> service is defined in <span class="emphasis"><em>init.rc</em></span>, as shown in <a class="xref" href="ch07.html#keystore_service_definition_in_initdotrc" title="Example 7-1. keystore service definition in init.rc">Example 7-1</a>.</p><div class="example"><a id="keystore_service_definition_in_initdotrc"/><p class="title">Example 7-1. <span class="roman">keystore</span> service definition in <span class="roman">init.rc</span></p><div class="example-contents"><pre class="programlisting">service keystore /system/bin/keystore /data/misc/keystore
    class main
    user keystore
    group keystore drmrpc</pre></div></div><p>As you can see, the <span class="emphasis"><em>keystore</em></span> service runs as a dedicated <span class="emphasis"><em>keystore</em></span> user and stores its files in <span class="emphasis"><em>/data/misc/keystore/</em></span>. Let’s peek into <span class="emphasis"><em>/data/misc/keystore/</em></span> first. If you’re using a single-user device, such as a phone, you will only find a single <span class="emphasis"><em>user_0/</em></span> directory inside the <span class="emphasis"><em>keystore/</em></span> directory (see <a class="xref" href="ch07.html#sample_contents_of_the_keystore_director" title="Example 7-2. Sample contents of the keystore directory on a single-user device">Example 7-2</a>, timestamps removed), but on multi-user enabled devices you should find one directory for each Android user.</p><div class="example"><a id="sample_contents_of_the_keystore_director"/><p class="title">Example 7-2. Sample contents of the <span class="roman">keystore</span> directory on a single-user device</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>ls -la /data/misc/keystore/user_0</strong></span>
-rw------- keystore keystore       84 .masterkey
-rw------- keystore keystore      980 1000_CACERT_cacert
-rw------- keystore keystore      756 1000_USRCERT_test
-rw------- keystore keystore      884 1000_USRPKEY_test
-rw------- keystore keystore      724 10019_USRCERT_myKey
-rw------- keystore keystore      724 10019_USRCERT_myKey1</pre></div></div><p><a id="iddle1117" class="indexterm"/><a id="iddle1954" class="indexterm"/><a id="iddle2001" class="indexterm"/><a id="iddle2066" class="indexterm"/><a id="iddle2196" class="indexterm"/>In this example, each file name consists of the UID of the app that created it (1000 is <span class="emphasis"><em>system</em></span>), the entry type (CA certificate, user certificate, or private key), and the key name (alias), all connected with underscores. Since Android 4.3, system and app-private keys are supported as well, and the UID reflects the Android user ID as well as the app ID. On multi-user devices the user ID is <code class="literal">UID / 100000</code>, as discussed in <a class="xref" href="ch04.html" title="Chapter 4. User Management">Chapter 4</a>.</p><p>In addition to system or app-owned key blobs, there is also a single <span class="emphasis"><em>.masterkey</em></span> file, which we’ll discuss shortly. When an app that owns store-managed keys is uninstalled for a user, only keys created by that user are deleted. If an app is completely removed from the system, its keys are deleted for all users. Because key access is tied to the app ID, this feature prevents a different app that happens to get the same UID from accessing an uninstalled app’s keys. (Keystore reset, which deletes both key files and the master key, also affects only the current user.)</p><p>In the default software-based implementation, these files have the following contents (contents may be different for hardware-backed implementations; instead of encrypted key material, they often store only a reference to hardware-managed key objects):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The master key (stored in <span class="emphasis"><em>.masterkey</em></span>) is encrypted with a 128-bit AES key derived from the screen unlock password by applying the <span class="emphasis"><em>PBKDF2</em></span> key derivation function with 8192 iterations and a randomly generated 128-bit salt. The salt is stored in the <span class="emphasis"><em>.masterkey</em></span> file’s info header.</p></li><li class="listitem"><p>All other files store key blobs. A <span class="emphasis"><em>key blob</em></span> (binary large object) contains a serialized, optionally encrypted key along with some data that describes the key (metadata). Each keystore key blob contains a metadata header, the initial vector (IV) used for encryption, and a concatenation of an MD5 hash value of the data with the data itself, encrypted with the 128-bit AES master key in CBC mode. Or more concisely: <code class="literal">metadata || Enc(MD5(data) || data)</code>.</p></li></ul></div><p>In practice, this architecture means that the Android keystore is pretty secure for a software solution. Even if you had access to a rooted device and managed to extract the key blobs, you would still need the keystore password to derive the master key. Trying different passwords in an attempt to decrypt the master key would require at least 8192 iterations to derive a key, which is prohibitively expensive. In addition, because the derivation function is seeded with a 128-bit random number, pre-calculated password tables cannot be used. However, the MD5-based integrity mechanism used <a id="iddle1433" class="indexterm"/><a id="iddle1435" class="indexterm"/><a id="iddle1436" class="indexterm"/><a id="iddle2067" class="indexterm"/><a id="iddle2110" class="indexterm"/><a id="iddle2179" class="indexterm"/><a id="iddle2202" class="indexterm"/><a id="iddle2946" class="indexterm"/><a id="iddle2949" class="indexterm"/><a id="iddle2950" class="indexterm"/><a id="iddle2951" class="indexterm"/>does not employ a standard Message Authentication Code (MAC) algorithm such as HMAC and is a remnant of the original implementation. It’s kept for backward compatibility, but may be replaced in a future version.</p></div><div class="sect2" title="Key Blob Versions and Types"><div class="titlepage"><div><div><h2 class="title"><a id="key_blob_versions_and_types"/>Key Blob Versions and Types</h2></div></div></div><p>Beginning with Android 4.1, two fields were added to key blobs: <span class="emphasis"><em>version</em></span> and <span class="emphasis"><em>type</em></span>. The current version (as of Android 4.4) is <span class="emphasis"><em>2</em></span> and keys blobs are automatically upgraded to the latest version when an application first accesses them. As of this writing, the following key types are defined:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">TYPE_ANY</code></p></li><li class="listitem"><p><code class="literal">TYPE_GENERIC</code></p></li><li class="listitem"><p><code class="literal">TYPE_MASTER_KEY</code></p></li><li class="listitem"><p><code class="literal">TYPE_KEY_PAIR</code></p></li></ul></div><p><code class="literal">TYPE_ANY</code> is a meta key type that matches any key type. <code class="literal">TYPE_GENERIC</code> is used for key blobs that are saved using the original get/put interface, which stores arbitrary binary data, and <code class="literal">TYPE_MASTER_KEY</code> is, of course, only used for the keystore master key. The <code class="literal">TYPE_KEY_PAIR</code> type is used for key blobs created using the <code class="literal">generate_keypair</code> and <code class="literal">import_keypair</code> operations, newly introduced in Android 4.1. We’ll discuss these in the “<a class="xref" href="ch07.html#keymaster_module_and_keystore_service_im" title="keymaster Module and keystore Service Implementation">keymaster Module and keystore Service Implementation</a>” section.</p><p>Android 4.3 is the first version to use the <code class="literal">flags</code> field of key blobs. It uses this field to distinguish encrypted (the default) from non-encrypted key blobs. Key blobs that are protected by a hardware-based implementation (available on some devices) are stored without additional encryption.</p></div><div class="sect2" title="Access Restrictions"><div class="titlepage"><div><div><h2 class="title"><a id="access_restrictions"/>Access Restrictions</h2></div></div></div><p>Key blobs are owned by the <span class="emphasis"><em>keystore</em></span> user, so on a regular (not rooted) device, you need to go through the <span class="emphasis"><em>keystore</em></span> service in order to access them. The <span class="emphasis"><em>keystore</em></span> service applies the following access restrictions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>root</em></span> user cannot lock or unlock the keystore, but can access system keys.</p></li><li class="listitem"><p>The <span class="emphasis"><em>system</em></span> user can perform most keystore management operations (like initialization, reset, and so on) in addition to storing keys. However, the <span class="emphasis"><em>system</em></span> user cannot use or retrieve other users’ keys.</p></li><li class="listitem"><p>Non-system users can insert, delete, and access keys, but can only see their own keys.</p></li></ul></div><p>Now that we know what the <span class="emphasis"><em>keystore</em></span> service does, let’s look at the actual implementation.</p></div><div class="sect2" title="keymaster Module and keystore Service Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="keymaster_module_and_keystore_service_im"/>keymaster Module and keystore Service Implementation</h2></div></div></div><p>While the original daemon-based implementation included both key blob management and encryption in a single binary, Android 4.1 introduced a <a id="iddle1533" class="indexterm"/><a id="iddle1536" class="indexterm"/><a id="iddle1616" class="indexterm"/><a id="iddle1671" class="indexterm"/><a id="iddle1696" class="indexterm"/><a id="iddle1706" class="indexterm"/><a id="iddle1846" class="indexterm"/><a id="iddle1873" class="indexterm"/><a id="iddle1917" class="indexterm"/><a id="iddle1950" class="indexterm"/><a id="iddle2835" class="indexterm"/><a id="iddle3062" class="indexterm"/>new <span class="emphasis"><em>keymaster Hardware Abstraction Layer (HAL)</em></span> system module responsible for generating asymmetric keys and signing/verifying data without the need to export the keys first.</p><p>The <span class="emphasis"><em>keymaster</em></span> module is meant to decouple the <span class="emphasis"><em>keystore</em></span> service from the underlying asymmetric key operations implementation and to allow for easier integration of device-specific, hardware-backed implementations. A typical implementation would use a vendor-provided library to communicate with the crypto-enabled hardware and provide a “glue” HAL library, which the <span class="emphasis"><em>keystore</em></span> daemon links with.</p><p>Android also comes with a default <span class="emphasis"><em>softkeymaster</em></span> module that performs all key operations in software only (using the system OpenSSL library). This module is used on the emulator and included in devices that lack dedicated cryptographic hardware. The key size of generated keys was initially fixed at 2048 bits and only RSA keys were supported. Android 4.4 added support for specifying key size, as well as the Digital Signature Algorithm (DSA) and Elliptic Curve DSA (ECDSA) algorithms and their respective keys.</p><p>As of this writing, the default <span class="emphasis"><em>softkeymaster</em></span> module supports RSA and DSA keys with sizes between 512 and 8192 bits. If the key size is not explicitly specified, DSA keys default to 1024 bits, and RSA ones to 2048 bits. For EC keys, the key size is mapped to a standard curve with the respective field size. For example, when 384 is specified as the key size, the <span class="emphasis"><em>secp384r1</em></span> curve is used to generate keys. Currently the following standard curves are supported: <span class="emphasis"><em>prime192v1</em></span>, <span class="emphasis"><em>secp224r1</em></span>, <span class="emphasis"><em>prime256v1</em></span>, <span class="emphasis"><em>secp384r1</em></span>, and <span class="emphasis"><em>secp521r1</em></span>. Keys for each of the supported algorithms can be imported as well if they are converted to the standard PKCS#8 format.</p><p>The HAL module interface is defined in <span class="emphasis"><em>hardware/keymaster.h</em></span> and defines the operations listed below.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">generate_keypair</code></p></li><li class="listitem"><p><code class="literal">import_keypair</code></p></li><li class="listitem"><p><code class="literal">sign_data</code></p></li><li class="listitem"><p><code class="literal">verify_data</code></p></li><li class="listitem"><p><code class="literal">get_keypair_public</code></p></li><li class="listitem"><p><code class="literal">delete_keypair</code></p></li><li class="listitem"><p><code class="literal">delete_all</code></p></li></ul></div><p>All asymmetric key operations exposed by the <span class="emphasis"><em>keystore</em></span> service are implemented by calling the system <span class="emphasis"><em>keymaster</em></span> module. Thus if the <span class="emphasis"><em>keymaster</em></span> HAL module is backed by a hardware cryptographic device, all upper-level commands and APIs that use the <span class="emphasis"><em>keystore</em></span> service interface automatically get to use hardware crypto. Aside from asymmetric key operations, all other credential store operations are implemented by the <span class="emphasis"><em>keystore</em></span> system service and do not depend on HAL modules. The service registers itself to Android’s <code class="literal">ServiceManager</code> with the <span class="emphasis"><em>android.security.keystore</em></span> name and is started at boot. Unlike most Android services, it is implemented in C++ and the implementation resides in <span class="emphasis"><em>system/security/keystore/</em></span>.</p></div><div class="sect2" title="Nexus 4 Hardware-Backed Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="nexus_4_hardware-backed_implementation"/>Nexus 4 Hardware-Backed Implementation</h2></div></div></div><p><a id="iddle1438" class="indexterm"/><a id="iddle1845" class="indexterm"/><a id="iddle1949" class="indexterm"/><a id="iddle2296" class="indexterm"/><a id="iddle2551" class="indexterm"/><a id="iddle2834" class="indexterm"/><a id="iddle2850" class="indexterm"/><a id="iddle2896" class="indexterm"/>To give some perspective to the whole “hardware-backed” idea, let’s briefly discuss how it’s implemented on the Nexus 4. The Nexus 4 is based on Qualcomm’s Snapdragon S4 Pro APQ8064 system on a chip (SoC). Like most recent ARM SoCs, it is TrustZone-enabled, with Qualcomm’s Secure Execution Environment (QSEE) implemented on top of that.</p><p>ARM’s TrustZone technology provides two virtual processors backed by hardware-based access control, which allows a SoC system to be partitioned into two virtual “worlds”: the <span class="emphasis"><em>Secure world</em></span> for the security subsystem, and the <span class="emphasis"><em>Normal world</em></span> for everything else. Applications running in the Secure world are referred to as <span class="emphasis"><em>trusted applications</em></span> and can only be accessed by Normal world applications (which the Android OS and apps run in) through a limited interface that they explicitly expose. <a class="xref" href="ch07.html#trustzone_software_architecture" title="Figure 7-2. TrustZone software architecture">Figure 7-2</a> shows a typical software configuration for a TrustZone-enabled system.</p><div class="figure"><a id="trustzone_software_architecture"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00023"/><img src="figs/web/07fig02.png.jpg" alt="TrustZone software architecture"/></div></div><p class="title">Figure 7-2. TrustZone software architecture</p></div><p>As usual, implementation details are quite scarce, but on the Nexus 4 the only way to interact with trusted applications is through the controlled interface that the <span class="emphasis"><em>/dev/qseecom</em></span> device provides. Android applications that wish to interact with the QSEE load the proprietary <span class="emphasis"><em>libQSEEComAPI.so</em></span> library and use its functions to send commands to the QSEE.</p><p>As with most other SEEs, the <span class="emphasis"><em>QSEECom</em></span> communication API is quite low level and basically only allows for exchanging opaque blobs (typically commands and replies), the contents of which depend entirely on the secure app you’re communicating with. In the case of the Nexus 4 <span class="emphasis"><em>keymaster</em></span>, the commands used are: <code class="literal">GENERATE_KEYPAIR</code>, <code class="literal">IMPORT_KEYPAIR</code>, <code class="literal">SIGN_DATA</code>, and <a id="iddle2058" class="indexterm"/><a id="iddle2082" class="indexterm"/><a id="iddle2680" class="indexterm"/><a id="iddle2765" class="indexterm"/><a id="iddle2925" class="indexterm"/><a id="iddle2935" class="indexterm"/><a id="iddle2942" class="indexterm"/><a id="iddle3061" class="indexterm"/><code class="literal">VERIFY_DATA</code>. The <span class="emphasis"><em>keymaster</em></span> implementation merely creates command structures, sends them via the <span class="emphasis"><em>QSEECom</em></span> API, and parses the replies. It does not contain any cryptographic code.</p><p>One interesting detail is that the QSEE <span class="emphasis"><em>keystore</em></span> trusted app (which may not be a dedicated app, but part of a more general-purpose trusted application) doesn’t return simple references to protected keys; it uses proprietary encrypted key blobs. In this model, the only thing that is actually protected by hardware is some form of master key-encryption key (KEK); user-generated keys are only indirectly protected by being encrypted with the KEK.</p><p>This method allows for a practically unlimited number of protected keys, but it has the disadvantage that if the KEK is compromised, all externally stored key blobs are compromised as well. (Of course, the actual implementation might generate a dedicated KEK for each key blob created, or the key can be fused in hardware; either way no details are available about the internal implementation.) That said, Qualcomm <span class="emphasis"><em>keymaster</em></span> key blobs are defined in AOSP code (shown in <a class="xref" href="ch07.html#qsee_keymaster_blob_definition_left_pare" title="Example 7-3. QSEE keymaster blob definition (for Nexus 4)">Example 7-3</a>) and the definition suggests that private exponents are encrypted using AES ➊, most probably in CBC mode, with an added HMAC-SHA256 ➋ to check encrypted data integrity.</p><div class="example"><a id="qsee_keymaster_blob_definition_left_pare"/><p class="title">Example 7-3. QSEE <span class="roman">keymaster</span> blob definition (for Nexus 4)</p><div class="example-contents"><pre class="programlisting">#define KM_MAGIC_NUM     (0x4B4D4B42)    /* "KMKB" Key Master Key Blob in hex */
#define KM_KEY_SIZE_MAX  (512)           /* 4096 bits */
#define KM_IV_LENGTH     (16)           ➊/* AES128 CBC IV */
#define KM_HMAC_LENGTH   (32)           ➋/* SHA2 will be used for HMAC */

struct qcom_km_key_blob {
  uint32_t magic_num;
  uint32_t version_num;
  uint8_t modulus[KM_KEY_SIZE_MAX];➌
  uint32_t modulus_size;
  uint8_t public_exponent[KM_KEY_SIZE_MAX];➍
  uint32_t public_exponent_size;
  uint8_t iv[KM_IV_LENGTH];➎
  uint8_t encrypted_private_exponent[KM_KEY_SIZE_MAX];➏
  uint32_t encrypted_private_exponent_size;
  uint8_t hmac[KM_HMAC_LENGTH];➐
};</pre></div></div><p>As you can see in <a class="xref" href="ch07.html#qsee_keymaster_blob_definition_left_pare" title="Example 7-3. QSEE keymaster blob definition (for Nexus 4)">Example 7-3</a>, the QSEE key blob contains the key modulus ➌, public exponent ➍, the IV ➎ used for private exponent encryption, the private exponent itself ➏, and the HMAC value ➐.</p><p>Since the QSEE used in the Nexus 4 is implemented using the TrustZone functions of the processor, in this case the “hardware” of the hardware-backed credential store is simply the ARM SoC. Are other implementations possible? Theoretically, a hardware-backed <span class="emphasis"><em>keymaster</em></span> implementation does not need to be based on TrustZone. Any dedicated device that can generate and store keys securely can be used, with the usual candidates being embedded Secure Elements (SE) and Trusted Platform Modules (TPMs). <a id="iddle1434" class="indexterm"/><a id="iddle1828" class="indexterm"/><a id="iddle2351" class="indexterm"/><a id="iddle2837" class="indexterm"/><a id="iddle2955" class="indexterm"/><a id="iddle2972" class="indexterm"/>We’ll discuss SEs and other tamper-resistant devices in <a class="xref" href="ch11.html" title="Chapter 11. NFC and Secure Elements">Chapter 11</a>, but as of this writing no mainstream Android devices have dedicated TPMs and recent flagship devices have begun shipping without embedded SEs. Therefore, implementations using dedicated hardware are unlikely to show up in mainstream devices.</p><div class="note" title="Note"><h3 class="title"><a id="ch07note01"/>Note</h3><p><span class="emphasis"><em>Of course, all mobile devices have some form of</em></span> Universal Integrated Circuit Card (UICC)<span class="emphasis"><em>, colloquially known as a SIM card, which typically can generate and store keys, but Android still doesn’t have a standard API to access the UICC even though vendor firmware often includes one. So while one could theoretically implement a UICC-based</em></span> keymaster <span class="emphasis"><em>module, it would only work on custom Android builds and would depend on network operators to include support in their UICCs.</em></span></p></div></div><div class="sect2" title="Framework Integration"><div class="titlepage"><div><div><h2 class="title"><a id="framework_integration"/>Framework Integration</h2></div></div></div><p>While managing credentials securely is the key feature of Android’s credential storage, its main purpose is to provide this service seamlessly to the rest of the system. Let’s briefly discuss how it integrates with the rest of Android before presenting the public APIs that are available for third-party apps.</p><p>Because the <span class="emphasis"><em>keystore</em></span> service is a standard Binder service, in order to use it potential clients only need to get a reference to it from the <code class="literal">ServiceManager</code>. The Android framework provides the singleton <code class="literal">android.security.KeyStore</code> hidden class, which is responsible for obtaining a reference to the <span class="emphasis"><em>keystore</em></span> service and serves as a proxy to the <code class="literal">IKeystoreService</code> interface it exposes. Most system applications, such as the PKCS#12 file importer (see <a class="xref" href="ch07.html#pkcshash12_file_password_dialog" title="Figure 7-1. PKCS#12 file password dialog">Figure 7-1</a>), and the implementations of some of the public APIs use the <code class="literal">KeyStore</code> proxy class to communicate with the <span class="emphasis"><em>keystore</em></span> service.</p><p>In the case of lower-level libraries that are not part of the Android framework, such as native libraries and JCA classes in the core Java library, integration with the system credential store is provided indirectly through an OpenSSL engine called the <span class="emphasis"><em>Android keystore engine</em></span>.</p><p>An OpenSSL engine is a pluggable cryptographic module implemented as a dynamic shared library. The <span class="emphasis"><em>keystore</em></span> engine is one such module that implements all of its operations by calling the system <span class="emphasis"><em>keymaster</em></span> HAL module. It supports only loading and signing with RSA, DSA, or EC private keys, but that’s enough to implement key-based authentication (such as SSL client authentication). The <span class="emphasis"><em>keystore</em></span> engine makes it possible for native code that uses OpenSSL APIs to use private keys saved in the system credential store without the need for code modifications. It also has a Java wrapper (<code class="literal">OpenSSLEngine</code>), which is used to implement access to keystore-managed private keys in the JCA framework.</p></div></div><div class="sect1" title="Public APIs"><div class="titlepage"><div><div><h1 class="title"><a id="public_apis"/>Public APIs</h1></div></div></div><p><a id="iddle1430" class="indexterm"/><a id="iddle1445" class="indexterm"/><a id="iddle1446" class="indexterm"/><a id="iddle2071" class="indexterm"/><a id="iddle2072" class="indexterm"/><a id="iddle2078" class="indexterm"/><a id="iddle2124" class="indexterm"/>While system applications can access the <span class="emphasis"><em>keystore</em></span> daemon AIDL interface directly or through the <code class="literal">android.security.KeyStore</code> proxy class, those interfaces are too closely coupled with the implementation to be part of the public API. Android provides higher-level abstractions for third-party apps with the <code class="literal">KeyChain</code> API and the <span class="emphasis"><em>AndroidKeyStoreProvider</em></span> JCA provider. We’ll show how these APIs are used and provide some implementation details in the following sections.</p><div class="sect2" title="The KeyChain API"><div class="titlepage"><div><div><h2 class="title"><a id="keychain_api"/>The KeyChain API</h2></div></div></div><p>Android has offered a system-wide credential store since version 1.6, but it was only usable by built-in VPN and Wi-Fi EAP clients. It was possible to install a private key/certificate pair using the Settings app, but the installed keys were not accessible by third-party applications.</p><p>Android 4.0 introduced SDK APIs for both trusted certificate management and secure credential storage via the <code class="literal">KeyChain</code> class. This feature was extended in Android 4.3 to support the newly introduced hardware-backed features. We’ll discuss how it’s used and review its implementation in the following sections.</p><div class="sect3" title="The KeyChain Class"><div class="titlepage"><div><div><h3 class="title"><a id="keychain_class"/>The KeyChain Class</h3></div></div></div><p>The <code class="literal">KeyChain</code> class is quite simple: it offers six public static methods, which are sufficient for most certificate- and key-related tasks. We’ll look at how to install a private key/certificate pair and then use that pair to access the credential-store-managed private key.</p><p>The <code class="literal">KeyChain</code> API lets you install a private key/certificate pair bundled in a PKCS#12 file. The <code class="literal">KeyChain.createInstallIntent()</code> factory method is the gateway to this functionality. It takes no parameters and returns a system intent that can parse and install keys and certificates. (This is actually the same intent that is used internally by the Settings system app.)</p></div><div class="sect3" title="Installing a PKCS#12 File"><div class="titlepage"><div><div><h3 class="title"><a id="installing_a_pkcshash12_file"/>Installing a PKCS#12 File</h3></div></div></div><p>To install a PKCS#12 file, you have to read it to a byte array, store it under the <code class="literal">EXTRA_PKCS12</code> key in the intent’s extras, and start the associated activity (see <a class="xref" href="ch07.html#installing_a_pkcshash12_file_using_the_k" title="Example 7-4. Installing a PKCS#12 file using the KeyChain API">Example 7-4</a>):</p><div class="example"><a id="installing_a_pkcshash12_file_using_the_k"/><p class="title">Example 7-4. Installing a PKCS#12 file using the <code class="literal">KeyChain</code> API</p><div class="example-contents"><pre class="programlisting">Intent intent = KeyChain.createInstallIntent();
byte[] p12 = readFile("keystore-test.pfx");
intent.putExtra(KeyChain.EXTRA_PKCS12, p12);
startActivity(intent);</pre></div></div><div class="figure"><a id="private_key_and_certificate_import_dialo"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00024"/><img src="figs/web/07fig03.png.jpg" alt="Private key and certificate import dialog"/></div></div><p class="title">Figure 7-3. Private key and certificate import dialog</p></div><p><a id="iddle1375" class="indexterm"/><a id="iddle1449" class="indexterm"/><a id="iddle2075" class="indexterm"/><a id="iddle2515" class="indexterm"/>This should prompt you for the PKCS#12 password in order to extract and parse the key and certificate. If the password is correct, you should be prompted for a certificate name, as shown in <a class="xref" href="ch07.html#private_key_and_certificate_import_dialo" title="Figure 7-3. Private key and certificate import dialog">Figure 7-3</a>. If the PKCS#12 has a friendly name attribute, it will be shown as the default; if not, you’ll just get a long hexadecimal hash string. The string you enter here is the key or certificate alias you can use later to look up and access keys via the <code class="literal">KeyChain</code> API. You should be prompted to set a lock screen PIN or password to protect the credential storage if you haven’t already set one.</p></div><div class="sect3" title="Using a Private Key"><div class="titlepage"><div><div><h3 class="title"><a id="using_a_private_key"/>Using a Private Key</h3></div></div></div><p>To use a private key stored in the system credential store, you need to obtain a reference to the key using its alias and request key access permission from the user. If you’ve never accessed a key before and don’t know its alias, you need to first call <code class="literal">KeyChain.choosePrivateKeyAlias()</code> and provide a callback implementation that receives the selected alias as shown in <a class="xref" href="ch07.html#using_a_private_key_stored_in_the_system" title="Example 7-5. Using a private key stored in the system credential store">Example 7-5</a>.</p><div class="example"><a id="using_a_private_key_stored_in_the_system"/><p class="title">Example 7-5. Using a private key stored in the system credential store</p><div class="example-contents"><pre class="programlisting">public class KeystoreTest extends Activity implements OnClickListener,
KeyChainAliasCallback {
   @Override
   public void onClick(View v) {
       KeyChain.choosePrivateKeyAlias(➊this, ➋(KeyChainAliasCallback)this,
          ➌new String[] { "RSA" }, ➍null, ➎null, ➏-1, ➐null);
   }
   @Override
   public void alias(final String alias) {➑
       Log.d(TAG, "Thread: " + Thread.currentThread().getName());
       Log.d(TAG, "selected alias: " + alias);
   }
}</pre></div></div><p>The first parameter ➊ is the current context; the second ➋ is the callback to invoke; and the third and fourth specify the acceptable keys ➌ (<code class="literal">RSA</code>, <code class="literal">DSA</code>, or <code class="literal">null</code> for any) and acceptable certificate issuers ➍ for the certificate <a id="iddle1308" class="indexterm"/><a id="iddle1345" class="indexterm"/><a id="iddle1444" class="indexterm"/><a id="iddle1785" class="indexterm"/><a id="iddle1859" class="indexterm"/><a id="iddle1881" class="indexterm"/><a id="iddle2070" class="indexterm"/>matching the private key. The next two parameters are the host ➎ and port number ➏ of the server requesting a certificate, and the last one ➐ is the alias to preselect in the key selection dialog. We leave all but the key type as unspecified (<code class="literal">null</code> or <code class="literal">-1</code>) here in order to be able to select from all available certificates. Note that the <code class="literal">alias()</code> ➑ callback will not be called on the main thread, so don’t try to directly manipulate the UI from it. (It’s called on a binder thread.)</p><p>Using the key requires user authorization, so Android should display a key selection dialog (see <a class="xref" href="ch07.html#key_selection_dialog" title="Figure 7-4. Key selection dialog">Figure 7-4</a>) which also serves to grant access to the selected key. Once the user has granted key access to an app, it can look up that key directly without going through the key selection dialog.</p><div class="figure"><a id="key_selection_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00025"/><img src="figs/web/07fig04.png.jpg" alt="Key selection dialog"/></div></div><p class="title">Figure 7-4. Key selection dialog</p></div><p><a class="xref" href="ch07.html#getting_a_key_instance_and_its_certifica" title="Example 7-6. Getting a key instance and its certificate chain">Example 7-6</a> shows how to use the <code class="literal">KeyChain</code> API to obtain a reference to a private key managed by the system keystore.</p><div class="example"><a id="getting_a_key_instance_and_its_certifica"/><p class="title">Example 7-6. Getting a key instance and its certificate chain</p><div class="example-contents"><pre class="programlisting">PrivateKey pk =  KeyChain.getPrivateKey(context, alias);➊
X509Certificate[] chain =  KeyChain.getCertificateChain(context, alias);➋</pre></div></div><p>To get a reference to a private key, you need to call the <code class="literal">KeyChain.getPrivateKey()</code> ➊ method, passing it the key alias name received in the previous step. If you try to call this method on the main thread, you’ll get an exception, so make sure to call it from a background thread like the one created by the <code class="literal">AsyncTask</code> utility class. The <code class="literal">getCertificateChain()</code> ➋ method returns the certificate chain associated with the private key (see <a class="xref" href="ch07.html#getting_a_key_instance_and_its_certifica" title="Example 7-6. Getting a key instance and its certificate chain">Example 7-6</a>). If a key or certificate with the specified alias doesn’t exist, the <code class="literal">getPrivateKey()</code> and <code class="literal">getCertificateChain()</code> methods will return <code class="literal">null</code>.</p></div><div class="sect3" title="Installing a CA Certificate"><div class="titlepage"><div><div><h3 class="title"><a id="installing_a_ca_certificate"/>Installing a CA Certificate</h3></div></div></div><p>Installing a CA certificate is not very different from installing a PKCS#12 file. To do so, load the certificate in a byte array and pass it as an extra to the install intent under the <code class="literal">EXTRA_CERTIFICATE</code> key, as shown in <a class="xref" href="ch07.html#installing_a_ca_certificate_using_the_ke" title="Example 7-7. Installing a CA certificate using the KeyChain API">Example 7-7</a>.</p><div class="example"><a id="installing_a_ca_certificate_using_the_ke"/><p class="title">Example 7-7. Installing a CA certificate using the <code class="literal">KeyChain</code> API</p><div class="example-contents"><pre class="programlisting">Intent intent = KeyChain.createInstallIntent();
intent.putExtra(KeyChain.EXTRA_CERTIFICATE, cert);
startActivity(intent);</pre></div></div><p>Android parses the certificate, and if its <span class="emphasis"><em>Basic Constraints</em></span> extension is set to <code class="literal">CA:TRUE</code>, considers it a CA certificate and imports it into the user trust store. You need to authenticate in order to import the certificate.</p><p>Unfortunately, the import dialog (see <a class="xref" href="ch07.html#ca_certificate_import_dialog-id00013" title="Figure 7-5. CA certificate import dialog">Figure 7-5</a>) shows neither the certificate DN nor its hash value. The user has no way of knowing what they’re importing until it’s done. Very few people bother to check a certificate’s validity, so this could be a potential security threat because malicious applications could trick people into installing rogue certificates.</p><p>After the certificate is imported, it should show up in the Trusted credentials screen’s User tab (Settings ▸Security ▸Trusted credentials). Tap the certificate entry to display a details dialog where you can check the subject, issuer, validity period, serial number, and SHA-1/SHA-256 fingerprints. To remove a certificate, press the <span class="strong"><strong>Remove</strong></span> button (see <a class="xref" href="ch07.html#certificate_details_dialog" title="Figure 7-6. Certificate details dialog">Figure 7-6</a>).</p><div class="figure"><a id="ca_certificate_import_dialog-id00013"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00026"/><img src="figs/web/07fig05.png.jpg" alt="CA certificate import dialog"/></div></div><p class="title">Figure 7-5. CA certificate import dialog</p></div><div class="figure"><a id="certificate_details_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00027"/><img src="figs/web/07fig06.png.jpg" alt="Certificate details dialog"/></div></div><p class="title">Figure 7-6. Certificate details dialog</p></div></div><div class="sect3" title="Deleting Keys and User Certificates"><div class="titlepage"><div><div><h3 class="title"><a id="deleting_keys_and_user_certificates"/>Deleting Keys and User Certificates</h3></div></div></div><p><a id="iddle1342" class="indexterm"/><a id="iddle1443" class="indexterm"/><a id="iddle1447" class="indexterm"/><a id="iddle1448" class="indexterm"/><a id="iddle1991" class="indexterm"/><a id="iddle1995" class="indexterm"/><a id="iddle2069" class="indexterm"/><a id="iddle2073" class="indexterm"/><a id="iddle2074" class="indexterm"/><a id="iddle2076" class="indexterm"/><a id="iddle2079" class="indexterm"/>While you can delete individual CA certificates, there is no way to delete individual keys and user certificates, although the Clear credentials option in the Credential Storage section of the security settings will delete all keys and user certificates.</p><div class="note" title="Note"><h3 class="title"><a id="ch07note02"/>Note</h3><p><span class="emphasis"><em>As long as you have keys in the credential store, you can’t remove the screen lock because it is used to protect access to the keystore.</em></span></p></div></div><div class="sect3" title="Getting Information about Supported Algorithms"><div class="titlepage"><div><div><h3 class="title"><a id="getting_information_about_supported_algo"/>Getting Information about Supported Algorithms</h3></div></div></div><p>Android 4.3 added two methods to the <code class="literal">KeyChain</code> class related to the newly introduced hardware support. According to the API documentation, <code class="literal">isBoundKeyAlgorithm(String algorithm)</code> “returns <code class="literal">true</code> if the current device’s <code class="literal">KeyChain</code> implementation binds any <code class="literal">PrivateKey</code> of the given algorithm to the device once imported or generated.” In other words, if you pass the string <span class="emphasis"><em>RSA</em></span> to this method, it should return <code class="literal">true</code> if generated or imported RSA keys have hardware protection and cannot simply be copied off the device. The <code class="literal">isKeyAlgorithmSupported(String algorithm)</code> method should return <code class="literal">true</code> if the current <code class="literal">KeyChain</code> implementation supports keys of the specified type (RSA, DSA, EC, and so on).</p><p>We’ve introduced the main features of the <code class="literal">KeyChain</code> API. Now let’s look at the underlying Android implementation.</p></div></div><div class="sect2" title="KeyChain API Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="keychain_api_implementation"/>KeyChain API Implementation</h2></div></div></div><p>The public <code class="literal">KeyChain</code> class and supporting interfaces reside in the <code class="literal">android.security</code> Java package. The package also contains two hidden AIDL files: <code class="literal">IKeyChainService.aidl</code> and <code class="literal">IKeyChainAliasCallback</code>. This is a hint that the actual keystore functionality, like most Android OS services, is implemented as a remote service to which the public APIs bind. The interface <code class="literal">IKeyChainAliasCallback</code> is called when you select a key via <code class="literal">KeyStore.choosePrivateKeyAlias()</code>, so it’s of little interest. <code class="literal">IKeyChainService.aidl</code> defines the actual system interface that services use, so we’ll describe it in more detail.</p><p>The <code class="literal">IKeyChainService</code> interface has one implementation, the <code class="literal">KeyChainService</code> class in the <code class="literal">KeyChain</code> system application. In addition to <code class="literal">KeyChainService</code>, the application includes an activity, <code class="literal">KeyChain</code>, and a broadcast receiver, <code class="literal">KeyChainBroadcastReceiver</code>. The <code class="literal">KeyChain</code> application has its <code class="literal">sharedUserId</code> is set to <span class="emphasis"><em>android.uid.system</em></span> and therefore inherits all privileges of the <span class="emphasis"><em>system</em></span> user. This allows its components to send management commands to the native <span class="emphasis"><em>keystore</em></span> service. Let’s examine the service first.</p><p>The <code class="literal">KeyChainService</code> is a wrapper for the <code class="literal">android.security.KeyStore</code> proxy class that directly communicates with the native <span class="emphasis"><em>keystore</em></span> service. It provides four main services:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Keystore management: methods for getting private keys and certificates.</p></li><li class="listitem"><p>Trust store management: methods for installing and deleting CA certificates in the user trust store.</p></li><li class="listitem"><p><a id="iddle1376" class="indexterm"/><a id="iddle1432" class="indexterm"/><a id="iddle1860" class="indexterm"/><a id="iddle1882" class="indexterm"/>Key and trust store initialization: a <code class="literal">reset()</code> method that deletes all key-store entries, including the master key, thus returning the keystore to an uninitialized state; it also removes all user-installed trusted certificates.</p></li><li class="listitem"><p>Methods for querying and adding entries to the key access grant database.</p></li></ul></div></div><div class="sect2" title="Controlling Access to the Keystore"><div class="titlepage"><div><div><h2 class="title"><a id="controlling_access_to_the_keystore"/>Controlling Access to the Keystore</h2></div></div></div><p>Since the <code class="literal">KeyChain</code> application runs as the <span class="emphasis"><em>system</em></span> user, any process that binds to its remote interface would technically be able to perform all key and trust store operations. To prevent this, the <code class="literal">KeyChainService</code> imposes additional access control on its users by controlling access to credential store operations based on the caller’s UID and using a key access grant database to regulate access to individual keys. Only the <span class="emphasis"><em>system</em></span> user can delete a CA certificate and reset the key and trust stores (operations typically called via the Settings app’s UI, which runs as <span class="emphasis"><em>system</em></span>). By the same token, only the <span class="emphasis"><em>system</em></span> user or the certificate installer application (<code class="literal">com.android.certinstaller</code> package) can install a trusted CA certificate.</p><p>Controlling access to individual keys in the credential store is a little bit more interesting than operation restrictions. The <code class="literal">KeyChainService</code> maintains a grants database (in <span class="emphasis"><em>/data/data/com.android.keychain/databases/grants.db</em></span>) that maps UIDs to the key aliases they are allowed to use. Let’s have a look inside in <a class="xref" href="ch07.html#schema_and_contents_of_the_grants_databa" title="Example 7-8. Schema and contents of the grants database">Example 7-8</a>.</p><div class="example"><a id="schema_and_contents_of_the_grants_databa"/><p class="title">Example 7-8. Schema and contents of the <span class="roman">grants</span> database</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>sqlite3 grants.db</strong></span>
sqlite&gt; .schema
.schema
CREATE TABLE android_metadata (locale TEXT);
CREATE TABLE grants (alias STRING NOT NULL, uid INTEGER NOT NULL, UNIQUE (alias,uid));
sqlite&gt; select * from grants;
select * from grants;
➊test|10044➋
➌key1|10044</pre></div></div><p>In this example, the application with UID <span class="emphasis"><em>10044</em></span> ➋ is granted access to the keys with the <code class="literal">test</code> ➊ and <code class="literal">key1</code> ➌ aliases.</p><p>Each call to <code class="literal">getPrivateKey()</code> or <code class="literal">getCertificate()</code> is subject to a check against the grants database, and results in an exception if a grant for the required alias is not found. As stated before, <code class="literal">KeyChainService</code> has APIs for adding and querying grants, and only the <span class="emphasis"><em>system</em></span> user can call them. But who is responsible for actually granting and revoking access?</p><p>Remember the private key selection dialog (<a class="xref" href="ch07.html#key_selection_dialog" title="Figure 7-4. Key selection dialog">Figure 7-4</a>)? When you call <code class="literal">KeyChain.choosePrivateKeyAlias()</code>, it starts the <code class="literal">KeyChainActivity</code> (introduced above), which checks to see if the keystore is unlocked; if so, <code class="literal">KeyChainActivity</code> shows the key selection dialog. Clicking the <span class="strong"><strong>Allow</strong></span> button returns to the <code class="literal">KeyChainActivity</code>, which then calls <code class="literal">KeyChainService.setGrant()</code> with the selected <a id="iddle1450" class="indexterm"/><a id="iddle2077" class="indexterm"/><a id="iddle2407" class="indexterm"/><a id="iddle2777" class="indexterm"/><a id="iddle2934" class="indexterm"/>alias, adding it to the grants database. Thus, even if the activity requesting access to a private key has the needed permissions, the user must unlock the keystore and explicitly authorize access to each individual key.</p><p>Besides controlling private key storage, the <code class="literal">KeyChainService</code> also offers trust store management by using the newly added <code class="literal">TrustedCertificateStore</code> class (part of <span class="emphasis"><em>libcore</em></span>). This class provides both the ability to add user-installed trusted CA certificates and remove (mark as not trusted) system (preinstalled) CAs. <a class="xref" href="ch06.html" title="Chapter 6. Network Security and PKI">Chapter 6</a> discusses the details of its implementation.</p><div class="sect3" title="KeyChainBroadcastReceiver"><div class="titlepage"><div><div><h3 class="title"><a id="keychainbroadcastreceiver"/>KeyChainBroadcastReceiver</h3></div></div></div><p>The last component of the <code class="literal">KeyChain</code> app is the <code class="literal">KeyChainBroadcastReceiver</code>. It listens for the <code class="literal">android.intent.action.PACKAGE_REMOVED</code> system broadcast and simply forwards control to the <code class="literal">KeyChainService</code>. On receiving the <code class="literal">PACKAGE_REMOVED</code> action, the service does some grant database maintenance: it goes through all entries and deletes any referencing packages that are no longer available (that is, ones that have been uninstalled).</p></div><div class="sect3" title="Credential and Trust Store Summary"><div class="titlepage"><div><div><h3 class="title"><a id="credential_and_trust_store_summary"/>Credential and Trust Store Summary</h3></div></div></div><p>Android 4.0 introduces a new service that grants access to both the system keystore (managed by the <span class="emphasis"><em>keystore</em></span> system service) and the trust store (managed by the <code class="literal">TrustedCertificateStore</code> class) that backs the <code class="literal">KeyChain</code> API exposed in the public SDK. This feature makes it possible to control access to keys based on both the calling process’s UID and the key access grant database, thus allowing for fine-grained, user-driven control over which keys each application can access. The components of Android’s credential and trust store and their relationship are presented in <a class="xref" href="ch07.html#system_credential_store_components" title="Figure 7-7. System credential store components">Figure 7-7</a>.</p><div class="figure"><a id="system_credential_store_components"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00028"/><img src="figs/web/07fig07.png" alt="System credential store components"/></div></div><p class="title">Figure 7-7. System credential store components</p></div></div></div><div class="sect2" title="Android Keystore Provider"><div class="titlepage"><div><div><h2 class="title"><a id="android_keystore_provider"/>Android Keystore Provider</h2></div></div></div><p><a id="iddle1138" class="indexterm"/><a id="iddle1439" class="indexterm"/><a id="iddle2114" class="indexterm"/><a id="iddle2125" class="indexterm"/><a id="iddle2531" class="indexterm"/>While the <code class="literal">KeyChain</code> API introduced in Android 4.0 allows applications to import keys into the system credential store, those keys are owned by the <span class="emphasis"><em>system</em></span> user and any application can request access to them. Android 4.3 adds support for <span class="emphasis"><em>app-private</em></span> keys, which allows any app to generate and save private keys that can only be accessed and used by itself and are not visible to other apps.</p><p>Instead of introducing yet another Android-specific API, keystore access is exposed via standard JCA APIs, namely <code class="literal">java.security.KeyPairGenerator</code> and <code class="literal">java.security.KeyStore</code>. Both are backed by a new Android JCA provider, <span class="emphasis"><em>AndroidKeyStoreProvider</em></span>, and are accessed by passing <span class="emphasis"><em>AndroidKeyStore</em></span> as the <code class="literal">type</code> parameter of the respective factory methods. <a class="xref" href="ch07.html#generating_and_accessing_rsa_keys_using" title="Example 7-9. Generating and accessing RSA keys using the AndroidKeyStoreProvider">Example 7-9</a> shows how to generate and access RSA keys using the <span class="emphasis"><em>AndroidKeyStoreProvider.</em></span></p><div class="example"><a id="generating_and_accessing_rsa_keys_using"/><p class="title">Example 7-9. Generating and accessing RSA keys using the <span class="roman">AndroidKeyStoreProvider</span></p><div class="example-contents"><pre class="programlisting">// generate a key pair
Calendar notBefore = Calendar.getInstance()
Calendar notAfter = Calendar.getInstance(); notAfter.add(1, Calendar.YEAR);
KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(ctx) .setAlias("key1")
                .setKeyType("RSA")
                .setKeySize(2048)
                .setSubject(new X500Principal("CN=test"))
                .setSerialNumber(BigInteger.ONE).setStartDate(notBefore.getTime())
                .setEndDate(notAfter.getTime()).build();➊
KeyPairGenerator kpGenerator = KeyPairGenerator.getInstance("RSA",
                              "AndroidKeyStore");
kpGenerator.initialize(spec);➋
KeyPair kp = kpGenerator.generateKeyPair();➌
// in another part of the app, access the keys
KeyStore ks = KeyStore.getInstance("AndroidKeyStore");
ks.load(null);
KeyStore.PrivateKeyEntry keyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry("key1", null);➍
RSAPublic pubKey = (RSAPublicKey)keyEntry.getCertificate().getPublicKey();
RSAPrivateKey privKey = (RSAPrivateKey) keyEntry.getPrivateKey();</pre></div></div><p>First ➊ you create a <code class="literal">KeyPairGeneratorSpec</code> describing the keys you want to generate and the automatically created self-signed certificate each key is associated with. You can specify the key type (<span class="emphasis"><em>RSA</em></span>, <span class="emphasis"><em>DSA</em></span>, or <span class="emphasis"><em>EC</em></span>) using the <code class="literal">setKeyType()</code> method, and key size with the <code class="literal">setKeySize()</code> method.</p><div class="note" title="Note"><h3 class="title"><a id="ch07note03"/>Note</h3><p><span class="emphasis"><em>Each <code class="literal">PrivateKeyEntry</code> managed by a <code class="literal">KeyStore</code> object needs to be associated with a certificate chain. Android automatically creates a self-signed certificate when you generate a key, but you can replace the default certificate with one signed by a CA later.</em></span></p></div><p><a id="iddle1868" class="indexterm"/><a id="iddle2115" class="indexterm"/><a id="iddle2116" class="indexterm"/>Next, you initialize a <code class="literal">KeyPairGenerator</code> ➋ with the <code class="literal">KeyPairGeneratorSpec</code> instance and then generate the keys by calling <code class="literal">generateKeyPair()</code> ➌.</p><p>The most important parameter is the alias. You pass the alias to <code class="literal">KeyStore.getEntry()</code> ➍ in order to get a reference to the generated keys later. The returned key object does not contain the actual key material; it is only a pointer to a hardware-managed key object. Therefore, it is not usable with cryptographic providers that rely on key material being directly accessible.</p><p>If the device has a hardware-backed keystore implementation, keys will be generated outside the Android OS and won’t be directly accessible even to the system (or <span class="emphasis"><em>root</em></span>) user. If the implementation is software only, keys will be encrypted with a per-user key-encryption master key derived from the unlock PIN or password.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00014"/>Summary</h1></div></div></div><p>As you’ve learned in this chapter, Android has a system credential store that can be used to store credentials for built-in features such as Wi-Fi and VPN connectivity, as well as for use by third-party apps. Android 4.3 and later versions provide standard JCA APIs for generating and accessing app-private keys, which makes it easier for non-system apps to store their keys securely without needing to implement key protection themselves. Hardware-backed key storage, which is available on supported devices, guarantees that even apps with <span class="emphasis"><em>system</em></span> or <span class="emphasis"><em>root</em></span> privileges cannot extract the keys. Most current hardware-backed credential storage implementations are based on ARM’s TrustZone technology and do not use dedicated tamper-resistant hardware.</p></div></div></body></html>