- en: '![Image](../images/common1.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common1.jpg)'
- en: '**7**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7**'
- en: '**TIME TRAVEL**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间旅行**'
- en: Okay, so we won’t actually build a time machine in this chapter, but you’ll
    measure time by making a binary clock and a clock that can speak. We’ll also conduct
    an experiment to test how well your micro:bit can keep time. All the experiments
    and projects in this chapter use MicroPython only.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，虽然我们在本章中不会真正建造时光机，但你将通过制作一个二进制时钟和一个可以说话的时钟来衡量时间。我们还将进行一个实验来测试你的micro:bit保持时间的能力。本章中的所有实验和项目仅使用MicroPython。
- en: '**EXPERIMENT 9: KEEPING TIME**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实验9：保持时间**'
- en: '![Image](../images/common2.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common2.jpg)'
- en: The aim of this experiment is to make a micro:bit clock that keeps good time.
    That means programming the micro:bit to tick at precisely one-second intervals.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验的目的是制作一个能够精确计时的micro:bit时钟。也就是说，编程让micro:bit每秒精确地滴答一次。
- en: '![Image](../images/f0166-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0166-01.jpg)'
- en: One way to do this would be to use the `sleep` function, as in the code shown
    here. Note that this code is not a full program, so don’t try to run it. The `sleep`
    command stops the micro:bit from doing anything for however long you specify.
    In our case, the delay is 1,000 milliseconds (1 second).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一种实现方式是使用`sleep`函数，如这里展示的代码。请注意，这段代码不是一个完整的程序，因此不要尝试运行它。`sleep`命令会让micro:bit在指定的时间内什么都不做。在我们的例子中，延迟是1000毫秒（1秒）。
- en: seconds = 0
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: seconds = 0
- en: 'while True:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: sleep(1000)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: sleep(1000)
- en: seconds += 1
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: seconds += 1
- en: In this example, after each 1 second delay, the program adds 1 to the `seconds`
    variable, which counts the number of seconds that have passed. This loop repeats
    indefinitely and, as a way of marking time, works for a bit.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每过1秒，程序就会将`seconds`变量加1，记录经过的秒数。这个循环会无限重复，作为标记时间的一种方式，它能工作一段时间。
- en: The problem is that the clock will gradually fall behind because we haven’t
    accounted for the time it takes the micro:bit to add 1 to the `seconds` variable.
    In this example, adding 1 to the variable won’t take much time at all, but if
    the program got any longer—for example, by telling the clock to also display the
    time or even speak the time, which we’ll try later—then the delay could become
    significant. It would also be unpredictable, as the time lost may not be the same
    every time the program loops.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，时钟会逐渐滞后，因为我们没有考虑到micro:bit为`seconds`变量加1所花费的时间。在这个例子中，给变量加1几乎不花时间，但如果程序变得更长——例如，要求时钟同时显示时间，甚至说出时间（我们稍后会尝试）——那么延迟可能变得显著。这也是不可预测的，因为每次程序循环时丢失的时间可能不同。
- en: Therefore, a better way to keep time is to use the `running_time` function.
    This function returns the number of milliseconds that have passed since the micro:bit
    was last reset, and it’s not affected by how long other parts of your code take
    to do things.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个更好的保持时间的方法是使用`running_time`函数。该函数返回自micro:bit上次重置以来经过的毫秒数，且不受代码其他部分执行时间的影响。
- en: In this experiment, we’ll use the `running_time` function to calculate just
    how slow or fast our micro:bit clock runs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们将使用`running_time`函数来计算我们的micro:bit时钟运行得有多慢或多快。
- en: '**What You’ll Need**'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**你需要的材料**'
- en: 'To carry out this experiment, you just need two things:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行这个实验，你只需要两样东西：
- en: '**Micro:bit**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**Micro:bit**'
- en: '**USB cable**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**USB电缆**'
- en: '**Construction**'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**构造**'
- en: Find the code at *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*.
    The Python file for this experiment is *Experiment_09.py*. Open the program in
    Mu and flash it onto your micro:bit.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*查找代码。这个实验的Python文件是*Experiment_09.py*。打开程序并通过Mu闪存到你的micro:bit上。
- en: Once you’ve successfully programmed the micro:bit, press button **B**. You should
    find that the micro:bit sets the seconds to 0 and starts counting up from there.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你成功编程micro:bit，按下按钮**B**。你应该会发现micro:bit将秒数设置为0，并从0开始计数。
- en: Set a timer on your phone or another device for exactly 16 minutes 40 seconds.
    Start the timer and, at the same time, press button **B** to reset the micro:bit’s
    second count. At the end of the timed period, press button **A** to freeze the
    clock and make a note of the number of seconds displayed.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置手机或其他设备上的计时器，精确到16分钟40秒。启动计时器的同时，按下按钮**B**重置micro:bit的秒数计数。在计时结束时，按下按钮**A**冻结时钟并记录显示的秒数。
- en: 'Because this experiment is all about timing, it’s important to start the timer
    at exactly the same time that button B is pressed and to press button A as soon
    as the timer sounds. This will be easier if a friend helps: one of you can operate
    the timer, while the other operates the micro:bit.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个实验涉及的是计时，所以重要的是在按下B按钮时准确启动计时器，并在计时器响起时立刻按下A按钮。如果有朋友帮助，会更容易：你们可以一人操作计时器，另一人操作micro:bit。
- en: The reason for setting the timer to 16 minutes 40 seconds is that this is 1,000
    seconds. If the micro:bit’s second count is greater than 1,000, then the clock
    is running fast, and if the count is less than 1,000, the clock is running slow.
    My micro:bit’s second count was 989, indicating that the micro:bit’s internal
    clock was running about 11 parts in 1,000 too slow.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 设置计时器为16分钟40秒的原因是因为这正好是1,000秒。如果micro:bit的秒数大于1,000，说明时钟走得太快；如果秒数小于1,000，说明时钟走得太慢。我的micro:bit的秒数为989，表明micro:bit的内部时钟比正常时间慢了大约每千分之一的11个部分。
- en: Make a note of your micro:bit’s second count. You’ll use it in the projects
    in this chapter to make your clock more accurate.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 记下你的micro:bit的秒数。在本章的项目中，你将用它来提高时钟的准确性。
- en: '**Code**'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**代码**'
- en: 'Here is the MicroPython code for Experiment 9:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实验9的MicroPython代码：
- en: from microbit import *
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: from microbit import *
- en: seconds = 0
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: seconds = 0
- en: last_time = 0
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: last_time = 0
- en: 'while True:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: now = running_time()
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: now = running_time()
- en: elapsed_ms = now - last_time
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: elapsed_ms = now - last_time
- en: 'if elapsed_ms >= 1000:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 'if elapsed_ms >= 1000:'
- en: seconds += 1
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: seconds += 1
- en: last_time = now
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: last_time = now
- en: 'if button_a.was_pressed():'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 'if button_a.was_pressed():'
- en: display.scroll(str(seconds))
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: display.scroll(str(seconds))
- en: 'if button_b.was_pressed():'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 'if button_b.was_pressed():'
- en: seconds = 0
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: seconds = 0
- en: display.show("0")
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: display.show("0")
- en: sleep(100)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: sleep(100)
- en: display.clear()
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: display.clear()
- en: 'The program uses two variables:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用了两个变量：
- en: '`last_time` Keeps track of the last time that the clock ticked'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`last_time` 用来跟踪时钟上次滴答的时间'
- en: '`seconds` Keeps track of the number of seconds that have passed since the micro:bit
    was last reset and the clock started running'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`seconds` 用来跟踪自micro:bit上次重置并开始计时以来已过去的秒数'
- en: I find it useful to think of the clock *ticking*, like a regular clock. That
    is, it does something at regular intervals.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得将时钟*滴答*作响就像普通时钟一样是有用的。也就是说，它会在固定的间隔时间内做一些事情。
- en: The main `while` loop uses the `running_time` function to find out how long
    the micro:bit has been running in milliseconds. It stores that number in a variable
    called `now`. It then calculates how many milliseconds have elapsed since the
    last tick by subtracting `last_time` from `now`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 主`while`循环使用`running_time`函数来计算micro:bit已运行的毫秒数。它将这个数字存储在一个名为`now`的变量中。然后，通过将`now`减去`last_time`来计算自上次计时以来经过了多少毫秒。
- en: If the number of milliseconds elapsed is greater than or equal to 1,000—in other
    words, greater than or equal to 1 second—then the `seconds` variable increases
    by 1\. Then we reset the number of milliseconds elapsed to 0 so we can count elapsed
    time over again.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果经过的毫秒数大于或等于1,000——换句话说，大于或等于1秒——那么`seconds`变量将增加1。然后，我们将已过的毫秒数重置为0，以便重新开始计时。
- en: We use two `if` statements to program button A and button B. If you press button
    A, the micro:bit will display `seconds`, or the time that’s passed since the program
    started running. If you press button B, the seconds count will reset to 0.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用两个`if`语句来编程A按钮和B按钮。如果按下A按钮，micro:bit会显示`seconds`，即自程序开始运行以来经过的时间。如果按下B按钮，秒数计数会重置为0。
- en: '**How It Works: Keeping Time**'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**工作原理：保持时间**'
- en: The micro:bit’s processor uses a crystal oscillator (an electronic component
    used to keep time accurately) that should be accurate to better than 30 parts
    per million. However, for my micro:bit, it was inaccurate by 11,000 parts per
    million for some reason.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: micro:bit的处理器使用晶体振荡器（用于精确计时的电子元件），其精度应当达到每百万分之30。然而，在我的micro:bit上，它由于某种原因不准确，偏差为每百万分之11,000。
- en: To get a truly accurate clock, you’d need to use a dedicated RTC (Real Time
    Clock) chip and separate crystal oscillator. At the time of writing, no RTC chips
    are available specifically for the micro:bit. Although they can be made to work
    with the micro:bit, this is a fairly tricky process. Therefore, it’s probably
    best not to rely too much on either of the clocks you’ll build in this chapter,
    but these projects are fun and will teach you important skills.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得一个真正精确的时钟，你需要使用专用的RTC（实时时钟）芯片和独立的晶体振荡器。在写本文时，尚未推出专门针对micro:bit的RTC芯片。虽然可以通过一定的手段让它与micro:bit配合使用，但这个过程相当复杂。因此，最好不要过于依赖本章中构建的任何一个时钟，但这些项目很有趣，并且会教会你重要的技能。
- en: '**PROJECT: BINARY CLOCK**'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目：二进制时钟**'
- en: '![Image](../images/common3.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common3.jpg)'
- en: '*Difficulty: Easy*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*难度：简单*'
- en: 'In this project, shown in [Figure 7-1](ch07.xhtml#ch7fig1), you’ll create a
    clock that shows you the time in *binary*. Binary is a numbering system used in
    computers. You can learn more about it in the “How It Works: Telling the Time
    in Binary” on [page 176](ch07.xhtml#page_176). A binary clock displays hours,
    minutes, and seconds as separate binary numbers on the micro:bit’s LED display.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，如[图7-1](ch07.xhtml#ch7fig1)所示，你将创建一个显示*二进制*时间的时钟。二进制是计算机使用的一种计数系统。你可以在[第176页](ch07.xhtml#page_176)的《工作原理：用二进制告诉时间》一节中了解更多关于它的信息。二进制时钟在micro:bit的LED显示器上分别以二进制数字显示小时、分钟和秒数。
- en: '![Image](../images/07fig01.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig01.jpg)'
- en: '*Figure 7-1: The binary clock in the Kitronik MI:Pro case*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：Kitronik MI:Pro外壳中的二进制时钟*'
- en: '[Figure 7-2](ch07.xhtml#ch7fig2) shows the binary numbering system on the micro:bit.
    It might seem confusing at first, like a random pattern of LEDs, but I’ll explain
    how it works shortly. Plus, the Mad Scientist loves to show off their skill at
    reading binary clocks to impress their friends!'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-2](ch07.xhtml#ch7fig2)展示了micro:bit上的二进制计数系统。一开始它看起来可能有点困惑，就像一组随机的LED图案，但我会很快解释它是如何工作的。而且，疯狂的科学家喜欢通过展示自己读取二进制时钟的技巧来给朋友们留下深刻印象！'
- en: '![Image](../images/07fig02.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig02.jpg)'
- en: '*Figure 7-2: Reading the binary clock*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-2：读取二进制时钟*'
- en: '**How to Read the Binary Clock**'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**如何读取二进制时钟**'
- en: Our binary clock is a 24-hour clock. To read the clock, start at the top row
    of LEDs, shown in [Figure 7-2](ch07.xhtml#ch7fig2). This row represents the hours.
    Each column of LEDs stands for a number. From right to left, the columns represent
    the numbers 1, 2, 4, 8, and 16\. By adding these five numbers, you can create
    every possible value between 1 and 24\. To work out the hour, add the column numbers
    for the LEDs that are lit. In the case of [Figure 7-2](ch07.xhtml#ch7fig2), that’s
    1, 2, and 8, which add up to 11\. So, the hour is 11.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的二进制时钟是一个24小时制时钟。要读取时钟，从[图7-2](ch07.xhtml#ch7fig2)所示的顶部LED行开始。这一行代表小时。每一列的LED代表一个数字。从右到左，这些列分别代表数字1、2、4、8和16。通过将这五个数字相加，你可以创建从1到24之间的每个可能的值。要计算小时数，请加上那些亮着的LED列对应的数字。在[图7-2](ch07.xhtml#ch7fig2)中，亮着的列是1、2和8，它们加起来是11。所以，时间是11点。
- en: The next two rows represent the number of minutes, and the bottom two rows represent
    the number of seconds. Both minutes and seconds are indicated by a row with the
    same 1, 2, 4, 8, and 16 LEDs. However, since we need to be able to count all the
    way to 60 for minutes and seconds, these values are indicated by an additional
    LED (worth 32) on the preceding row. As shown in [Figure 7-2](ch07.xhtml#ch7fig2),
    the 32 LED for minutes is the leftmost LED on the second row from the top, and
    the 32 LED for seconds is the leftmost LED on the fourth row from the top.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行表示分钟数，底部的两行表示秒数。分钟和秒数通过具有相同1、2、4、8和16个LED的行来表示。然而，由于我们需要能够计算到60（分钟和秒），这些值通过前一行的一个附加LED（值为32）来指示。如[图7-2](ch07.xhtml#ch7fig2)所示，分钟的32个LED是从顶部数起第二行最左边的LED，而秒钟的32个LED是从顶部数起第四行最左边的LED。
- en: In [Figure 7-2](ch07.xhtml#ch7fig2), the 4 and 1 minute LEDs are lit, indicating
    5 minutes. The 2 and 1 second LEDs are lit, indicating 3 seconds. All together,
    this display is saying the time is 11:05:03.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图7-2](ch07.xhtml#ch7fig2)中，4和1分钟的LED亮着，表示5分钟。2和1秒钟的LED亮着，表示3秒钟。合起来，这个显示表示的时间是11:05:03。
- en: Holding down button A will make the numbers on the clock advance very quickly,
    allowing you to set the time. You just need to be ready to stop the clock as soon
    as it reaches the correct time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 按住A按钮将使时钟上的数字迅速前进，允许你设置时间。你只需要准备好在时钟显示正确时间时立即停止它。
- en: You can see a video of the clock in operation, including how the time is set,
    at *[https://www.youtube.com/watch?v=v26gYo5OG0g](https://www.youtube.com/watch?v=v26gYo5OG0g)*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以观看这个时钟运作的视频，包括如何设置时间，视频链接是 *[https://www.youtube.com/watch?v=v26gYo5OG0g](https://www.youtube.com/watch?v=v26gYo5OG0g)*。
- en: '**What You’ll Need**'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**你需要的材料**'
- en: For this project, all you need is your micro:bit and a power source.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你只需要你的 micro:bit 和一个电源。
- en: If you plan to keep your clock running constantly, then you should use a USB
    power adapter or other long-term power source for the micro:bit (see the [appendix](app01.xhtml))
    to save on batteries. You might also want to get a case for the micro:bit to make
    your clock look nicer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划让时钟持续运行，那么应该为 micro:bit 使用 USB 电源适配器或其他长期电源（参见[附录](app01.xhtml)），以节省电池。你可能还想为
    micro:bit 配一个外壳，让时钟看起来更漂亮。
- en: Remember that the clock won’t keep perfect time, so you’ll need to reset it
    fairly often.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，时钟不会保持完美的时间，所以你需要相对频繁地重置它。
- en: '**Construction**'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**构建**'
- en: The code for this project is in MicroPython, because the math required would
    be extremely tricky to do in the Blocks code. Download the code from *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*.
    The file for this project is *ch_07_Binary_Clock.py*.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个项目的代码是用 MicroPython 编写的，因为所需的数学运算用 Blocks 代码实现起来会非常复杂。你可以从 *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*
    下载代码。这个项目的文件是 *ch_07_Binary_Clock.py*。
- en: Before loading the program onto your micro:bit, open it in Mu and change the
    current time so it’s accurate. You should probably set it to a few minutes before
    the current time, just to be safe. You can adjust it later by holding down button
    A.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将程序加载到你的 micro:bit 上之前，请在 Mu 中打开它并更改当前时间，以确保它准确无误。你应该将其设置为当前时间之前的几分钟，以确保安全。稍后你可以通过按住
    A 键来调整时间。
- en: Change the time by altering the following lines. Remember that this is a 24-hour
    clock, so, for example, 6:00 PM is 12 + 6 or 18 hours.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过修改以下几行来更改时间。记住，这是 24 小时制的时钟，所以，例如，晚上 6:00 是 12 + 6 或 18 小时。
- en: hours = 8
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: hours = 8
- en: minutes = 25
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: minutes = 25
- en: You should also change the value of the `adjust` variable to the number of parts
    per thousand by which your micro:bit’s clock is slow or fast. My micro:bit ran
    slow by 11 seconds in 1,000, so I set `adjust` to –11 to speed it up a little
    (note the negative sign). If the micro:bit had run fast by, say, 10 seconds per
    1,000, then I would have set `adjust` to 10 to slow things down a tiny amount.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你还应该将 `adjust` 变量的值更改为你的 micro:bit 时钟慢或快的千分之一。我的 micro:bit 在 1,000 次中慢了 11 秒，所以我将
    `adjust` 设置为 -11 来稍微加快它（注意负号）。如果 micro:bit 比如每 1,000 次快 10 秒，那么我会将 `adjust` 设置为
    10，以略微减慢它的速度。
- en: '**Code**'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**代码**'
- en: This project involves quite a lot of math. We’ll also use some more advanced
    programming features, such as *two-dimensional arrays*, which are much easier
    to implement in Python than in Blocks code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目涉及了相当多的数学。我们还会使用一些更高级的编程特性，例如*二维数组*，在 Python 中比在 Blocks 代码中更容易实现。
- en: 'Let’s break the code into chunks, starting with the lines that assign the correct
    binary values to each LED:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将代码分成几个部分，首先是为每个 LED 分配正确的二进制值的几行代码：
- en: hhhhh
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: hhhhh
- en: m
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: m
- en: mmmmm
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mmmmm
- en: s
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: s
- en: sssss
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sssss
- en: sec_leds = [[4, 4], [3, 4], [2, 4], [1, 4], [0, 4], [0, 3]]
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: sec_leds = [[4, 4], [3, 4], [2, 4], [1, 4], [0, 4], [0, 3]]
- en: min_leds = [[4, 2], [3, 2], [2, 2], [1, 2], [0, 2], [0, 1]]
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: min_leds = [[4, 2], [3, 2], [2, 2], [1, 2], [0, 2], [0, 1]]
- en: hour_leds = [[4, 0], [3, 0], [2, 0], [1, 0], [0, 0]]
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: hour_leds = [[4, 0], [3, 0], [2, 0], [1, 0], [0, 0]]
- en: adjust = -11
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: adjust = -11
- en: The first four lines of code aren’t actually part of the program. They’re *comment
    lines*, or notes, reminding you which LEDs display the hours, minutes, and seconds.
    These can serve as a useful reference when setting the LED coordinates in the
    arrays that follow.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的前四行其实并不是程序的一部分。它们是*注释行*，或者说是提示，提醒你哪些 LED 显示的是小时、分钟和秒。这些注释可以作为设置后续数组中 LED
    坐标的有用参考。
- en: The next three lines are the two-dimensional arrays mentioned earlier. These
    assign the proper LED coordinates to the seconds, minutes, and hours. Remember
    that arrays are like variables, except they hold multiple elements. The arrays
    we’re using here are called *two dimensional* because their elements are also
    arrays. For example, the first element in the first array, `sec_leds`, is [4,
    4]. This identifies the first LED used to display the number of seconds as the
    LED with an x coordinate of 4 and a y coordinate of 4\. That’s the LED in the
    bottom right corner of the display. [Figure 7-3](ch07.xhtml#ch7fig3) shows the
    coordinates of the individual LEDs that make up the display.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三行是前面提到的二维数组。这些数组将适当的LED坐标分配给秒、分钟和小时。记住，数组就像变量，只不过它们包含多个元素。我们这里使用的数组被称为*二维*数组，因为它们的元素也是数组。例如，第一个数组`sec_leds`的第一个元素是[4,
    4]。这表示用于显示秒数的第一个LED的坐标是x=4和y=4，也就是显示器右下角的那个LED。[图7-3](ch07.xhtml#ch7fig3)展示了构成显示的单个LED的坐标。
- en: '![Image](../images/07fig03.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig03.jpg)'
- en: '*Figure 7-3: LED display coordinates*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：LED显示坐标*'
- en: As you can see, the top left LED has the coordinates [0, 0] and the bottom right
    [4, 4].
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，左上角的LED坐标是[0, 0]，右下角是[4, 4]。
- en: '![Image](../images/f0174-01.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0174-01.jpg)'
- en: 'Next, we have the `hours`, `minutes`, and `seconds` variables to keep the current
    time:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`hours`、`minutes`和`seconds`变量来保持当前时间：
- en: hours = 8
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: hours = 8
- en: minutes = 25
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: minutes = 25
- en: seconds = 1
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: seconds = 1
- en: adjust = -11
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: adjust = -11
- en: We’ll use the `adjust` variable to correct the clock’s speed. See “Construction”
    on [page 167](ch07.xhtml#page_167) if you’re not sure how to do this.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`adjust`变量来修正时钟的速度。如果你不确定如何操作，可以参考[第167页](ch07.xhtml#page_167)中的“构造”部分。
- en: 'Here is the function that turns the LEDs on or off to indicate a value in binary:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个将LED灯开关控制为二进制显示的函数：
- en: 'def display_binary(value, num_bits, leds):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 'def display_binary(value, num_bits, leds):'
- en: v = value
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: v = value
- en: 'for i in range(0, num_bits):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(0, num_bits):'
- en: v_bit = v % 2
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: v_bit = v % 2
- en: display.set_pixel(leds[i][0], leds[i][1], int(v_bit * 9))
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: display.set_pixel(leds[i][0], leds[i][1], int(v_bit * 9))
- en: v = int(v / 2)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: v = int(v / 2)
- en: We have three separate binary numbers (hours, minutes, and seconds) to display,
    and the `display_binary` function works for all of them. It takes a number to
    display (`value`), the number of LEDs to use in displaying the number (`num_bits`),
    and an array of LEDs to use (`leds`). It uses these three values to display the
    three parts of the time—the seconds, minutes, and hours—on the micro:bit.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个单独的二进制数字（小时、分钟和秒）需要显示，`display_binary`函数适用于所有这些。它接受一个要显示的数字（`value`）、显示数字所用的LED数量（`num_bits`）和LED的数组（`leds`）。它使用这三个值来在micro:bit上显示时间的三个部分——秒、分钟和小时。
- en: 'To keep track of the time, you use two variables:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪时间，使用了两个变量：
- en: last_time = 0
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: last_time = 0
- en: tick = 1000 + adjust
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: tick = 1000 + adjust
- en: The variable `last_time` records the last time that the clock ticked, and the
    variable `tick` holds the duration of the clock’s tick in milliseconds. The default
    value for `tick` is `1,000 + adjust`, but this value will change when you press
    button A to set the time.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`last_time`记录时钟上次滴答的时间，变量`tick`保存时钟滴答的时长（毫秒）。`tick`的默认值是`1,000 + adjust`，但当你按下A按钮设置时间时，这个值会发生变化。
- en: 'Here is the code to update the time:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更新时间的代码：
- en: 'def update_time():'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update_time():'
- en: global hours, minutes, seconds
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: global hours, minutes, seconds
- en: seconds += 1
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: seconds += 1
- en: 'if seconds > 59:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 'if seconds > 59:'
- en: seconds = 0
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: seconds = 0
- en: minutes += 1
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: minutes += 1
- en: 'if minutes > 59:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 'if minutes > 59:'
- en: minutes = 0
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: minutes = 0
- en: hours += 1
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: hours += 1
- en: 'if hours > 23:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 'if hours > 23:'
- en: hours = 0
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: hours = 0
- en: The function `update_time` adds 1 to the number of seconds every time it is
    called. When the `seconds` count gets past 59, it resets to 0 and increases the
    number of `minutes`. It does the same thing for the `hours`. We use nested `if`
    statements to accomplish this.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_time`函数每次调用时会将秒数增加1。当`seconds`超过59时，秒数会重置为0，分钟数加1。对小时数也是如此。我们通过嵌套的`if`语句来实现这个功能。'
- en: 'This is the code to display the hours, minutes, and seconds in binary:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是以二进制方式显示小时、分钟和秒数的代码：
- en: 'def display_time():'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'def display_time():'
- en: display_binary(seconds, 6, sec_leds)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: display_binary(seconds, 6, sec_leds)
- en: display_binary(minutes, 6, min_leds)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: display_binary(minutes, 6, min_leds)
- en: display_binary(hours, 5, hour_leds)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: display_binary(hours, 5, hour_leds)
- en: We put this code inside the `display_time` function, which calls the `display_binary`
    function defined earlier.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这段代码放入`display_time`函数中，该函数调用之前定义的`display_binary`函数。
- en: Here is the main `while` loop that makes the clock run quickly when someone
    presses button A and normally otherwise. It also contains the code to keep time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主要的 `while` 循环，它使时钟在按下按钮 A 时快速运行，其他情况下正常运行。它还包含保持时间的代码。
- en: 'while True:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'if button_a.is_pressed():'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `button_a.is_pressed()`：
- en: tick = 10
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`tick = 10`'
- en: 'else:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: tick = 1000 + adjust
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`tick = 1000 + adjust`'
- en: now = running_time()
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`now = running_time()`'
- en: elapsed_ms = now - last_time
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`elapsed_ms = now - last_time`'
- en: 'if elapsed_ms >= tick:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `elapsed_ms` 大于或等于 `tick`：
- en: update_time()
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 更新时间()
- en: display_time()
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: display_time()
- en: The first part of the loop checks whether button A is being pressed. If it is,
    the code reduces `tick` to 10 milliseconds. Otherwise, it sets it to `1000 + adjust`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的第一部分检查是否按下了按钮 A。如果按下，则代码将 `tick` 设置为 10 毫秒。否则，将其设置为 `1000 + adjust`。
- en: 'Finally, we write the code that allows the clock to keep time. The function
    `running_time` returns the number of milliseconds since you last reset your micro:bit.
    Each time the program loops, we calculate how much time has elapsed since the
    clock last ticked. The loop does the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们编写了使时钟保持运行的代码。`running_time` 函数返回自上次重置 micro:bit 后经过的毫秒数。每次程序循环时，我们计算自上次时钟滴答声以来已过去的时间。循环执行以下操作：
- en: Gets the current `running_time` and stores it in a variable called `now`
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取当前的 `running_time` 并将其存储在名为 `now` 的变量中
- en: Calculates the value for `elapsed_ms` by figuring out the difference between
    the variables `now` and `last_time`
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过计算 `now` 和 `last_time` 之间的差值来得出 `elapsed_ms` 的值
- en: Updates the time if `elapsed_time` is greater than our `tick` time of 1 second
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `elapsed_time` 大于我们的 `tick` 时间（1 秒），则更新时间
- en: Sets `last_time` to `now`, resetting the millisecond count to zero
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `last_time` 设置为 `now`，重置毫秒计数为零
- en: '**How It Works: Telling the Time in Binary**'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**工作原理：用二进制表示时间**'
- en: Using this binary clock to tell the time is a little tricky. It’s especially
    hard to figure out the seconds, which are likely to have changed before the code
    has calculated them. But there’s a reason the binary system exists.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个二进制时钟来查看时间有点棘手。尤其是秒数，可能在代码计算出来之前就已经改变了。但是，二进制系统之所以存在是有原因的。
- en: Most of us are familiar with the decimal system of writing numbers. *Decimal*
    is the Latin word for 10, and in the decimal system, we use 10 different symbols
    (the digits 0 through 9). If we need to write a number greater than 9—say 15—then
    we use two digits. Because of the position of the 1 in the number 15, we know
    that it actually represents the number 10.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数人都熟悉十进制数字系统。*十进制*是拉丁语中表示 10 的词，在十进制系统中，我们使用 10 个不同的符号（数字 0 到 9）。如果我们需要写一个大于
    9 的数字——比如 15——那么我们就用两位数字。因为数字 15 中 1 的位置，我们知道它实际上代表的是 10。
- en: The following table shows the numbers from 0 to 10 in binary. Note that in decimal,
    we don’t write *leading zeros*. We wouldn’t write 15 as 0015, for example. In
    binary, however, it’s customary to write numbers with the leading zeros to give
    the numbers the same number of digits. That’s just the way computer scientists
    roll. So in this case, all the binary numbers are four digits long.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了从 0 到 10 的二进制数。注意，在十进制中，我们不写*前导零*。例如，我们不会将 15 写成 0015。但在二进制中，习惯上会加上前导零，使数字长度一致。这就是计算机科学家的一种做法。所以在这种情况下，所有二进制数都是四位数。
- en: '|  **Decimal**  | **Binary** |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|  **十进制**  | **二进制** |'
- en: '| --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | 0000 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0000 |'
- en: '| 1 | 0001 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0001 |'
- en: '| 2 | 0010 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0010 |'
- en: '| 3 | 0011 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 0011 |'
- en: '| 4 | 0100 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 0100 |'
- en: '| 5 | 0101 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 0101 |'
- en: '| 6 | 0110 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 0110 |'
- en: '| 7 | 0111 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 0111 |'
- en: '| 8 | 1000 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 1000 |'
- en: '| 9 | 1001 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 1001 |'
- en: '| 10 | 1010 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 1010 |'
- en: In theory, computers could store numbers like this by using 10 different voltages
    to represent the digits 0 to 9, but they don’t. Instead, computers use a system
    called binary. Rather than having 10 possible values for a digit, a binary digit
    (also called a *bit*) can represent either a 0 or a 1\. Computers use binary because
    the *transistors* they are made with are really good at being either off (0) or
    on (1). That means they have only 2 possible states, which is much easier than
    giving them 10 possible states. Also, the math behind binary logic means that
    a computer can do reliable arithmetic on binary numbers far more easily than it
    were dealing with numbers in decimal.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，计算机可以使用 10 种不同的电压来表示数字 0 到 9，但它们并不这么做。相反，计算机使用一种叫做二进制的系统。二进制中的数字（也叫做 *比特*）只有两种可能的状态，可以是
    0 或 1。计算机使用二进制是因为它们使用的 *晶体管* 很擅长表现“关（0）”或“开（1）”的状态。也就是说，晶体管只有 2 种状态，这比给它们提供 10
    种状态要容易得多。而且，二进制逻辑背后的数学原理使得计算机在处理二进制数字时能够进行可靠的算术运算，比起处理十进制数字要轻松得多。
- en: Just as in the familiar decimal system, the binary system combines digits to
    represent bigger numbers. Whereas each digit position in a decimal number increases
    by a factor of 10—going from 1, to 10, to 100—each binary digit increases by a
    factor of 2—from 1, to 2, to 4, and so on. For example, the four-digit binary
    number 1010 has 1s in the 16- and 2-digit positions and 0s in the other positions.
    In decimal, it’s 16 + 2, or 18.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 就像熟悉的十进制系统一样，二进制系统通过组合数字来表示更大的数字。而在十进制中，每个数字的位置是按 10 的倍数增加的——从 1 到 10，再到 100——而二进制中的每个数字则按
    2 的倍数增加——从 1 到 2，再到 4，以此类推。例如，四位二进制数 1010 在 16 位和 2 位位置上是 1，在其他位置上是 0。换算成十进制，就是
    16 + 2，等于 18。
- en: It turns out that you don’t need very many binary digits to represent some pretty
    big numbers. For example, eight binary digits put together (called a *byte*) can
    represent a decimal number anywhere between 0 and 255\. Make that 16 bits, and
    the number goes up to 65,535\. A computer with 64 bits is able to do everything
    using those binary 64 digits, and it can represent a number between 0 and 18,446,744,073,709,551,615\.
    Incidentally, a micro:bit has a 32-bit processor, able to represent numbers between
    0 and a very respectable 4,294,967,295\. The MicroPython function `running_time`
    that we’ve been using uses a 32-bit number. This means that it will not run out
    of numbers for 4,294,967,295 ÷ 1,000 ÷ 60 ÷ 60 ÷ 24 = 49.7 days.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，你并不需要很多二进制数字就能表示一些非常大的数字。例如，八位二进制数字组合在一起（称为 *字节*）可以表示从 0 到 255 之间的十进制数。如果是
    16 位，那么数字范围可以达到 65,535。如果是 64 位的计算机，它能使用这 64 位数字做所有的运算，并且能够表示 0 到 18,446,744,073,709,551,615
    之间的数字。顺便提一下，micro:bit 拥有一颗 32 位处理器，能够表示 0 到非常可观的 4,294,967,295 之间的数字。我们一直在使用的
    MicroPython 函数 `running_time` 使用的是 32 位数字。这意味着它在 4,294,967,295 ÷ 1,000 ÷ 60 ÷
    60 ÷ 24 = 49.7 天内不会用完数字。
- en: '**PROJECT: TALKING CLOCK**'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目：会说话的时钟**'
- en: '![Image](../images/common3.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common3.jpg)'
- en: '*Difficulty: Easy*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*难度：简单*'
- en: Sometimes the Mad Scientist is so busy with test tubes and chemicals and alarming
    plumes of smoke that they can’t check the time. And then they forget to eat! That’s
    when a talking clock comes in handy. This project ([Figure 7-4](ch07.xhtml#ch7fig4))
    announces the time every hour, or whenever you press button A.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候疯狂科学家忙于试管、化学品和浓烟，以至于无法查看时间。然后他们忘记吃饭！这时，一款会说话的时钟就派上用场了。这个项目（[图 7-4](ch07.xhtml#ch7fig4)）每小时报一次时间，或者当你按下
    A 按钮时也会报时。
- en: '![Image](../images/07fig04.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig04.jpg)'
- en: '*Figure 7-4: A talking clock*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：会说话的时钟*'
- en: You can see this project in action at *[https://www.youtube.com/watch?v=iNjXEK8RUtU](https://www.youtube.com/watch?v=iNjXEK8RUtU)*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *[https://www.youtube.com/watch?v=iNjXEK8RUtU](https://www.youtube.com/watch?v=iNjXEK8RUtU)*
    上看到这个项目的实际效果。
- en: '**What You’ll Need**'
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**你需要的东西**'
- en: 'For this project, you’ll need the following items:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你需要以下物品：
- en: '**Micro:bit**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**Micro:bit**'
- en: '**3 × Alligator clip cables** To connect the micro:bit to the speaker'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**3 根鳄鱼夹电缆** 用于将 micro:bit 连接到扬声器'
- en: '**Speaker for micro:bit** To play the sounds (Use a Monk Makes Speaker or see
    [Chapter 2](ch02.xhtml#ch02) for other speaker options.)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**micro:bit 扬声器** 用于播放声音（可以使用 Monk Makes 扬声器，或者参考 [第 2 章](ch02.xhtml#ch02)
    了解其他扬声器选项。）'
- en: '**Power adapter** See the [appendix](app01.xhtml) for options on keeping your
    micro:bit powered without batteries.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**电源适配器** 参见 [附录](app01.xhtml)，了解如何使用不需要电池的方式为 micro:bit 供电。'
- en: If you’re planning to keep your clock running, then use a USB power adapter
    or another long-term power solution to save on batteries.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算保持时钟运行，那么使用 USB 电源适配器或其他长期电源解决方案，以节省电池。
- en: You may want to build a case for the clock or attach the micro:bit and speaker
    to the same piece of cardboard you used for the light-controlled guitar project
    from [Chapter 3](ch03.xhtml#ch03).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想为时钟制作一个外壳，或者将micro:bit和扬声器固定在你用于[第3章](ch03.xhtml#ch03)光控吉他项目的同一块纸板上。
- en: '**Construction**'
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**构建**'
- en: The code for this project is in MicroPython, as the speech library is not currently
    available in the Blocks code. Download the code from *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*.
    The file for this project is *ch_07_Talking_Clock.py*.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个项目的代码是用MicroPython编写的，因为在Blocks代码中当前无法使用语音库。从*[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*下载代码。此项目的文件是*ch_07_Talking_Clock.py*。
- en: Before loading the program onto your micro:bit, open the file in Mu and change
    the hours and minutes to your current time. Also change `adjust` to the amount
    by which you want to adjust your clock. See “Construction” on [page 167](ch07.xhtml#page_167)
    of the binary clock project if you’re not sure how to do this.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将程序加载到你的micro:bit之前，打开Mu文件并将小时和分钟更改为当前时间。还要将`adjust`更改为你想调整时钟的时间量。如果你不确定如何操作，请参见[第167页](ch07.xhtml#page_167)二进制时钟项目中的“构建”部分。
- en: Connect a speaker to the micro:bit with one alligator clip on pin 0 and the
    other alligator clip on the pin marked IN on the speaker. Use the other two clips
    to provide power to the speaker, as shown in [Figure 7-4](ch07.xhtml#ch7fig4).
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个鳄鱼夹将扬声器连接到micro:bit的0号引脚，另一个鳄鱼夹连接到扬声器上的IN引脚。使用另外两个夹子为扬声器提供电源，如[图7-4](ch07.xhtml#ch7fig4)所示。
- en: Wait for the time you set in step 2 to arrive. Then connect the micro:bit to
    a power source. Note that for this project, there is no other mechanism to set
    the time.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待步骤2中设置的时间到达。然后将micro:bit连接到电源。请注意，在这个项目中，没有其他机制来设置时间。
- en: '**Code**'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**代码**'
- en: For clarity, we’ll work through this code in sections.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地说明，我们将分段处理这段代码。
- en: Here’s the code that does the time keeping—in other words, that makes sure the
    hours and minutes are correct. It’s almost the same as the time-keeping code from
    the previous project. The main difference is that, instead of showing the time
    on the LED display, the code will speak the current time.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是做时间保持的代码——换句话说，它确保小时和分钟是正确的。它几乎与上一个项目中的时间保持代码相同。主要的区别是，代码不会在LED显示屏上显示时间，而是通过语音播报当前时间。
- en: digits = ["no", "1", "2", "3", "4", "5", "6", "7", "8", "9",
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: digits = ["no", "1", "2", "3", "4", "5", "6", "7", "8", "9",
- en: '"ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen",'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '"ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen"'
- en: '"sixteen", "seventeen", "eighteen", "nienteen"]'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '"sixteen", "seventeen", "eighteen", "nienteen"'
- en: tens = ["no", "no", "twenty", "thirty", "forty", "fifty"]
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: tens = ["no", "no", "twenty", "thirty", "forty", "fifty"]
- en: preamble = "The time is "
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: preamble = "The time is "
- en: am = "aye em"
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: am = "aye em"
- en: pm = "pee em"
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: pm = "pee em"
- en: We use several variables and arrays to hold a set of words that the micro:bit
    will speak.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用多个变量和数组来保存micro:bit将要说的一组词。
- en: The speech library contains recordings of some common words. It can say single
    digits like 1, 2, or 3, but for numbers 10 and over, it pronounces each digit
    separately, which is not what we want our talking clock to do. That’s why we have
    to spell out numbers greater than 10\. Notice that *nineteen* is misspelled as
    *nienteen* to make it sound right when the synthesized voice says it. The array
    called `digits` holds the text for each number up to 19\. The clock should never
    speak the 0 digit, so we just set it to the word `no`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 语音库包含一些常见单词的录音。它可以说出1、2或3这样的单个数字，但对于10及以上的数字，它会分别发音每个数字，这不是我们希望时钟说的方式。因此，我们必须拼写出大于10的数字。注意，*nineteen*被拼写成*nienteen*，这样在合成语音说出时才听起来正确。名为`digits`的数组保存了0到19的每个数字的文本。时钟永远不会读出0，所以我们将它设置为单词`no`。
- en: The `tens` array does a similar job with numbers that are multiples of 10\.
    We already accounted for all the numbers up to 19 with the digits array, so we
    don’t need to worry about the first two elements in the `tens` array, which will
    never be spoken. We set these to `no` as well.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`tens`数组在处理10的倍数时做类似的工作。我们已经通过digits数组考虑了所有小于19的数字，因此我们不需要担心`tens`数组中的前两个元素，它们永远不会被说出来。我们将它们也设置为`no`。'
- en: The `preamble` variable contains the text that the micro:bit will speak before
    it announces each time. The `am` and `pm` variables contain phonetic versions
    of the AM/PM indicator. The micro:bit will speak one of these after reading the
    time.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`preamble` 变量包含在micro:bit每次播报时间之前会说的文本。`am` 和 `pm` 变量包含AM/PM指示符的音标版本。在读取时间后，micro:bit将说出这些中的一个。'
- en: Here’s the code with the function that actually speaks the time. Appropriately
    enough, it’s called `speak_the_time`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有实际说出时间的函数的代码。它的名字非常贴切，叫做`speak_the_time`。
- en: 'def speak_the_time():'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'def speak_the_time():'
- en: h = hours
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: h = hours
- en: am_pm = am
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: am_pm = am
- en: 'if h >= 12:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 'if h >= 12:'
- en: am_pm = pm
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: am_pm = pm
- en: 'if h > 12:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'if h > 12:'
- en: h = h - 12
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: h = h - 12
- en: 'if minutes == 0:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 'if minutes == 0:'
- en: '# The time is twelve pm exactly'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '# 当前时间是十二点整'
- en: speech.say(preamble + digits[h] + " "
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: speech.say(preamble + digits[h] + " "
- en: + am_pm + " exactly")
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: + am_pm + " exactly")
- en: 'else:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: 'if minutes < 10:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 'if minutes < 10:'
- en: '# The time is twelve o four pm'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '# 当前时间是十二点四分下午'
- en: speech.say(preamble + digits[h] + " o "
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: speech.say(preamble + digits[h] + " o "
- en: + digits[minutes] + " " + am_pm)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: + digits[minutes] + " " + am_pm)
- en: 'elif minutes < 20:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif minutes < 20:'
- en: '# The time is twelve eighteen pm'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '# 当前时间是十二点十八分下午'
- en: speech.say(preamble + digits[h] + " "
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: speech.say(preamble + digits[h] + " "
- en: + digits[minutes] + " " + am_pm)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: + digits[minutes] + " " + am_pm)
- en: 'else:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: mins_tens = int(minutes / 10)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: mins_tens = int(minutes / 10)
- en: mins_units = minutes % 10
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: mins_units = minutes % 10
- en: 'if mins_units == 0:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'if mins_units == 0:'
- en: '# The time is twelve twenty pm'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '# 当前时间是十二点二十分钟下午'
- en: speech.say(preamble + digits[h] + " "
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: speech.say(preamble + digits[h] + " "
- en: + tens[mins_tens] + " " + am_pm)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: + tens[mins_tens] + " " + am_pm)
- en: 'else:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: '# The time is twelve twenty four pm'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '# 当前时间是十二点二十四分下午'
- en: speech.say(preamble + digits[h] + " "
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: speech.say(preamble + digits[h] + " "
- en: + tens[mins_tens] + " " + digits[mins_units] + " " + am_pm)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: + tens[mins_tens] + " " + digits[mins_units] + " " + am_pm)
- en: This function is fairly complex, as it has to account for our different ways
    of expressing the time.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数相当复杂，因为它必须处理我们表达时间的不同方式。
- en: This clock speaks in the 12-hour format but stores the hours in 24-hour format,
    so the first thing `speak_the_time` does is decide whether the time is AM or PM.
    It subtracts 12 from the `hour` variable once `hour` reaches 13.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个时钟使用12小时制语音播报，但以24小时制存储小时，因此`start_the_time`函数首先会判断当前时间是AM还是PM。当`hour`值大于或等于13时，它会从`hour`中减去12。
- en: 'Next, the nested `if` statements cover the following possible cases:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，嵌套的`if`语句处理以下几种情况：
- en: '![Image](../images/play.jpg)  If the time is exactly on the hour, say something
    like `The time is twelve pm exactly`.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/play.jpg)  如果时间正好整点，可以说类似`当前时间是十二点整`。'
- en: '![Image](../images/play.jpg)  Otherwise, if the minutes are less than 10, add
    an *o*, to say something like `The time is twelve o four pm`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/play.jpg)  否则，如果分钟数小于10，可以在分钟前加上*o*，说出类似`当前时间是十二点四分下午`的内容。'
- en: '![Image](../images/play.jpg)  For two-digit minutes less than 20, use the `digits`
    array and say something like `The time is twelve eighteen pm`.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/play.jpg)  对于小于20的两位数分钟，可以使用`digits`数组并说出类似`当前时间是十二点十八分下午`的内容。'
- en: '![Image](../images/play.jpg)  For other two-digit minutes of 20 or over that
    are multiples of 10, use the `tens` array to say something like `The time is twelve
    twenty pm`.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/play.jpg)  对于其他大于20的两位数分钟，可以使用`tens`数组说出类似`当前时间是十二点二十分下午`的内容。'
- en: '![Image](../images/play.jpg)  And, where the minutes are not multiples of 10,
    say something like `The time is twelve twenty four pm`.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/play.jpg)  如果分钟数不是10的倍数，应该说类似`当前时间是十二点二十四分下午`的内容。'
- en: 'Last comes the main `while` loop:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是主`while`循环：
- en: 'while True:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'if button_b.is_pressed():'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 'if button_b.is_pressed():'
- en: speak_the_time()
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: speak_the_time()
- en: now = running_time()
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: now = running_time()
- en: elapsed_ms = now - last_time
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: elapsed_ms = now - last_time
- en: 'if elapsed_ms >= tick:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 'if elapsed_ms >= tick:'
- en: elapsed_seconds = int(elapsed_ms / tick)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: elapsed_seconds = int(elapsed_ms / tick)
- en: update_time(elapsed_seconds)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: update_time(elapsed_seconds)
- en: blink()
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: blink()
- en: last_time = now
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: last_time = now
- en: This loop checks whether button B has been pressed or an hour has passed and
    speaks the time if either event has occurred. It also calls a function called
    `blink`. That flashes the heart icon on the screen to reassure you that the clock
    is working, even if it is silent most of the time.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环会检查是否按下了B按钮或一小时已经过去，如果发生其中任何一个事件，就会播报时间。它还调用了一个叫做`blink`的函数，用于闪烁屏幕上的心形图标，提醒你时钟正在运行，即使大部分时间它保持沉默。
- en: '**How It Works: Teaching the Micro:bit to Speak**'
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**它是如何工作的：教 Micro:bit 说话**'
- en: The MicroPython speech library opens up all sorts of possibilities in your projects,
    as you saw back in [Chapter 6](ch06.xhtml#ch06). The sound quality isn’t perfect,
    but it does add loads of fun to your projects.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: MicroPython语音库为你的项目提供了各种可能性，正如你在[第6章](ch06.xhtml#ch06)中看到的那样。音质虽然不是完美的，但它确实为你的项目增添了许多乐趣。
- en: 'The speech library itself is based on the concept of *phonemes*: building blocks
    of sound. When you use the `say` function, the text to be spoken is first translated
    into a series of phonemes. Because of the strangeness of spoken language, this
    often doesn’t work perfectly—hence the misspelling of *nineteen* in the code for
    this project to help the `say` function pronounce the word more accurately.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 语音库本身基于*音素*的概念：声音的构建块。当你使用`say`函数时，要说的文本首先会被转换成一系列音素。由于口语语言的特殊性，这个过程常常不能完美执行——因此在这个项目的代码中，*nineteen*这个词的拼写被故意更改，以帮助`say`函数更准确地发音。
- en: You can read much more about this speech library at *[https://microbit-micropython.readthedocs.io/en/latest/tutorials/speech.html](https://microbit-micropython.readthedocs.io/en/latest/tutorials/speech.html)*.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*[https://microbit-micropython.readthedocs.io/en/latest/tutorials/speech.html](https://microbit-micropython.readthedocs.io/en/latest/tutorials/speech.html)*上阅读更多关于这个语音库的内容。
- en: '**SUMMARY**'
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Hopefully you now have a good sense of how to make a clock using a micro:bit
    and use it to display or literally tell you the time.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你现在已经对如何使用micro:bit制作时钟并用它来显示或直接告诉你时间有了一个很好的理解。
- en: In the next chapter, the Mad Scientist turns their attention to psychological
    experiments.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，疯子科学家将把注意力转向心理学实验。
