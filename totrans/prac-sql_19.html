<html><head></head><body><div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" title="387" id="Page_387"/>19</span><br/>&#13;
<span class="ChapterTitle">Maintaining Your Database</span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img src="Images/chapterart.png" alt="" width="200" height="200"/>&#13;
</figure>&#13;
<p class="ChapterIntro">To wrap up our exploration of SQL, we’ll look at key database maintenance tasks and options for customizing PostgreSQL. In this chapter, you’ll learn how to track and conserve space in your databases, how to change system settings, and how to back up and restore databases. How often you’ll need to perform these tasks depends on your current role and interests. If you want to be a <em>database administrator</em> or a <em>backend developer</em>, the topics covered here are vital.</p>&#13;
<p>It’s worth noting that database maintenance and performance tuning are large enough topics that they often occupy entire books, and this chapter mainly serves as an introduction to a handful of essentials. If you want to learn more, a good place to begin is with the resources in the appendix.</p>&#13;
<p>Let’s start with the PostgreSQL <code>VACUUM</code> feature, which lets you shrink the size of tables by removing unused rows.</p>&#13;
<h2 id="h1-501065c19-0001"><span epub:type="pagebreak" title="388" id="Page_388"/>Recovering Unused Space with VACUUM</h2>&#13;
<p class="BodyFirst">The PostgreSQL <code>VACUUM</code> command helps manage the size of a database, which—as discussed in “Improving Performance When Updating Large Tables” in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>—can grow as a result of routine operations.</p>&#13;
<p>For example, when you update a row value, the database creates a new version of that row with the updated value and retains (but hides) the old version of the row. The PostgreSQL documentation refers to these rows that you can’t see as <em>dead tuples</em>, with <em>tuples</em>—an ordered list of elements—being the name for the internal implementation of rows in a PostgreSQL database. The same thing happens when you delete a row. Though the row is no longer visible to you, it lives on as a dead row in the table.</p>&#13;
<p>This is by design so the database can provide certain features in environments where multiple transactions are occurring, and an old version of a row might be needed by transactions other than the current one.</p>&#13;
<p>The <code>VACUUM</code> command cleans up these dead rows. Running <code>VACUUM</code> on its own designates the space occupied by dead rows as available for the database to use again (assuming that any transactions using the rows have been completed). In most cases, <code>VACUUM</code> doesn’t return the space to your system’s disk; it just flags that space as available for new data. To actually shrink the size of the data file, you can run <code>VACUUM FULL</code>, which rewrites the table to a new version that doesn’t include the dead row space. It drops the old version.</p>&#13;
<p>Although <code>VACUUM FULL</code> frees space on your system’s disk, there are a couple of caveats to keep in mind. First, <code>VACUUM FULL</code> takes more time to complete than <code>VACUUM</code>. Second, it must have exclusive access to the table while rewriting it, which means that no one can update data during the operation. The regular <code>VACUUM</code> command can run while updates and other operations are happening. Finally, not all dead space in a table is bad. In many cases, having available space to put new tuples instead of needing to ask the operating system for more disk space can improve performance.</p>&#13;
<p>You can run either <code>VACUUM</code> or <code>VACUUM FULL</code> on demand, but PostgreSQL by default runs an<em> autovacuum</em> background process that monitors the database and runs <code>VACUUM</code> as needed. Later in this chapter, I’ll show you how to monitor autovacuum as well as run the <code>VACUUM</code> command manually. But first, let’s look at how a table grows as a result of updates and how you can track this growth.</p>&#13;
<h3 id="h2-501065c19-0001">Tracking Table Size</h3>&#13;
<p class="BodyFirst">We’ll create a small test table and monitor its growth as we fill it with data and perform an update. The code for this exercise, as with all resources for the book, is available at <a href="https://nostarch.com/practical-sql-2nd-edition/" class="LinkURL">https://nostarch.com/practical-sql-2nd-edition/</a>.</p>&#13;
<h4 id="h3-501065c19-0001">Creating a Table and Checking Its Size</h4>&#13;
<p class="BodyFirst"><a href="#listing19-1" id="listinganchor19-1">Listing 19-1</a> creates a <code>vacuum_test</code> table with a single column to hold an integer. Run the code, and then we’ll measure the table’s size.</p>&#13;
<pre><code><span epub:type="pagebreak" title="389" id="Page_389"/>CREATE TABLE vacuum_test (&#13;
    integer_column integer&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing19-1">Listing 19-1</a>: Creating a table to test vacuuming</p>&#13;
<p>Before we fill the table with test data, let’s check how much space it occupies on disk to establish a reference point. We can do so in two ways: check the table properties via the pgAdmin interface or run queries using PostgreSQL administrative functions. In pgAdmin, click once on a table to highlight it, and then click the <b>Statistics</b> tab. Table size is one of about two dozen indicators in the list.</p>&#13;
<p>I’ll focus on the running queries technique here because knowing these queries is helpful if for some reason pgAdmin isn’t available or you’re using another graphical user interface (GUI). <a href="#listing19-2" id="listinganchor19-2">Listing 19-2</a> shows how to check the <code>vacuum_test</code> table size using PostgreSQL functions.</p>&#13;
<pre><code>SELECT <span class="CodeAnnotation" aria-label="annotation1">1</span>pg_size_pretty(&#13;
           <span class="CodeAnnotation" aria-label="annotation2">2</span>pg_total_relation_size('vacuum_test')&#13;
       );</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing19-2">Listing 19-2</a>: Determining the size of <code>vacuum_test</code></p>&#13;
<p>The outermost function, <code>pg_size_pretty()</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, converts bytes to a more easily understandable format in kilobytes, megabytes, or gigabytes. Wrapped inside is the <code>pg_total_relation_size()</code> function <span class="CodeAnnotation" aria-label="annotation2">2</span>, which reports how many bytes a table, its indexes, and any offline compressed data takes up on disk. Because the table is empty at this point, running the code in pgAdmin should return a value of <code>0 bytes</code>, like this:</p>&#13;
<pre><code> pg_size_pretty&#13;
----------------&#13;
 0 bytes</code></pre>&#13;
<p>You can get the same information using the command line. Launch <code>psql</code> as you learned in <span class="xref" itemid="xref_target_Chapter 18">Chapter 18</span>. Then, at the prompt, enter the meta-command <code class="bold">\dt+ vacuum_test</code>, which should display the following information including table size (I’ve omitted one column for space):</p>&#13;
<pre><code>                      List of relations&#13;
 Schema |    Name     | Type  |  Owner   | Persistence |  Size&#13;
--------+-------------+-------+----------+-------------+---------&#13;
 public | vacuum_test | table | postgres | permanent   | 0 bytes</code></pre>&#13;
<p>Again, the current size of the <code>vacuum_test</code> table should display <code>0 bytes</code>.</p>&#13;
<h4 id="h3-501065c19-0002">Checking Table Size After Adding New Data</h4>&#13;
<p class="BodyFirst">Let’s add some data to the table and then check its size again. We’ll use the <code>generate_series()</code> function introduced in <span class="xref" itemid="xref_target_Chapter 12">Chapter 12</span> to fill the table’s <code>integer_column</code> with 500,000 rows. Run the code in <a href="#listing19-3" id="listinganchor19-3">Listing 19-3</a> to do this.</p>&#13;
<pre><code><span epub:type="pagebreak" title="390" id="Page_390"/>INSERT INTO vacuum_test&#13;
SELECT * FROM generate_series(1,500000);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing19-3">Listing 19-3</a>: Inserting 500,000 rows into <code>vacuum_test</code></p>&#13;
<p>This standard <code>INSERT INTO</code> statement adds the results of <code>generate_series()</code>, which is a series of values from 1 to 500,000, as rows to the table. After the query completes, rerun the query in <a href="#listing19-2">Listing 19-2</a> to check the table size. You should see the following output:</p>&#13;
<pre><code> pg_size_pretty&#13;
----------------&#13;
 17 MB</code></pre>&#13;
<p>The query reports that the <code>vacuum_test</code> table, now with a single column of 500,000 integers, uses 17MB of disk space.</p>&#13;
<h4 id="h3-501065c19-0003">Checking Table Size After Updates</h4>&#13;
<p class="BodyFirst">Now, let’s update the data to see how that affects the table size. We’ll use the code in <a href="#listing19-4" id="listinganchor19-4">Listing 19-4</a> to update every row in the <code>vacuum_test</code> table by adding <code>1</code> to the <code>integer_column</code> values, replacing the existing value with a number that’s one greater.</p>&#13;
<pre><code>UPDATE vacuum_test&#13;
SET integer_column = integer_column + 1;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing19-4">Listing 19-4</a>: Updating all rows in <code>vacuum_test</code></p>&#13;
<p>Run the code, and then test the table size again.</p>&#13;
<pre><code> pg_size_pretty&#13;
----------------&#13;
 35 MB</code></pre>&#13;
<p>The table size doubled from 17MB to 35MB! The increase seems excessive, because the <code>UPDATE</code> simply replaced existing numbers with values of a similar size. As you might have guessed, the reason for this increase in table size is that for every updated value, PostgreSQL creates a new row, and the dead row remains in the table. Even though you see only 500,000 rows, the table has double that number. This behavior can lead to surprises for database owners who don’t monitor disk space.</p>&#13;
<p>Before looking at how using <code>VACUUM</code> and <code>VACUUM FULL</code> affects the table’s size on disk, let’s review the process that runs <code>VACUUM</code> automatically as well as how to check on statistics related to table vacuums.</p>&#13;
<h3 id="h2-501065c19-0002">Monitoring the Autovacuum Process</h3>&#13;
<p class="BodyFirst">PostgreSQL’s autovacuum process monitors the database and launches <code>VACUUM</code> automatically when it detects a large number of dead rows in a table. Although autovacuum is enabled by default, you can turn it on or off and <span epub:type="pagebreak" title="391" id="Page_391"/>configure it using the settings I’ll cover later in “Changing Server Settings.” Because autovacuum runs in the background, you won’t see any immediately visible indication that it’s working, but you can check its activity by querying data that PostgreSQL collects about system performance.</p>&#13;
<p>PostgreSQL has its own <em>statistics collector</em> that tracks database activity and usage. You can look at the statistics by querying one of several views the system provides. (See a complete list of views for monitoring the state of the system in the PostgreSQL documentation under “The Statistics Collector”: <a href="https://www.postgresql.org/docs/current/monitoring-stats.html" class="LinkURL">https://www.postgresql.org/docs/current/monitoring-stats.html</a>.) To check the activity of autovacuum, we query the <code>pg_stat_all_tables</code> view, as shown in <a href="#listing19-5" id="listinganchor19-5">Listing 19-5</a>.</p>&#13;
<pre><code>SELECT <span class="CodeAnnotation" aria-label="annotation1">1</span>relname,&#13;
       <span class="CodeAnnotation" aria-label="annotation2">2</span>last_vacuum,&#13;
       <span class="CodeAnnotation" aria-label="annotation3">3</span>last_autovacuum,&#13;
       <span class="CodeAnnotation" aria-label="annotation4">4</span>vacuum_count,&#13;
       <span class="CodeAnnotation" aria-label="annotation5">5</span>autovacuum_count&#13;
FROM pg_stat_all_tables&#13;
WHERE relname = 'vacuum_test';</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing19-5">Listing 19-5</a>: Viewing autovacuum statistics for <code>vacuum_test</code></p>&#13;
<p>As you learned in <span class="xref" itemid="xref_target_Chapter 17">Chapter 17</span>, a view provides the results of a stored query. The query stored by the view <code>pg_stat_all_tables</code> returns a column called <code>relname</code><span class="CodeAnnotation" aria-label="annotation1">1</span>, which is the name of the table, plus columns with statistics related to index scans, rows inserted and deleted, and other data. For this query, we’re interested in <code>last_vacuum</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> and <code>last_autovacuum</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>, which contain the last time the table was vacuumed manually and automatically, respectively. We also ask for <code>vacuum_count</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> and <code>autovacuum_count</code> <span class="CodeAnnotation" aria-label="annotation5">5</span>, which show the number of times the vacuum was run manually and automatically.</p>&#13;
<p>By default, autovacuum checks tables every minute. So, if a minute has passed since you last updated <code>vacuum_test</code>, you should see details of vacuum activity when you run the query in <a href="#listing19-5">Listing 19-5</a>. Here’s what my system shows (note that I’ve removed the seconds from the time to save space here):</p>&#13;
<pre><code>   relname   | last_vacuum | last_autovacuum  | vacuum_count | autovacuum_count&#13;
-------------+-------------+------------------+--------------+------------------&#13;
 vacuum_test |             | 2021-09-02 14:46 |            0 |                1</code></pre>&#13;
<p>The table shows the date and time of the last autovacuum, and the <code>autovacuum_count</code> column shows one occurrence. This result indicates that autovacuum executed a <code>VACUUM</code> command on the table once. However, because we’ve not vacuumed manually, the <code>last_vacuum</code> column is empty, and the <code>vacuum_count</code> is <code>0</code>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	The autovacuum process also runs the <code>ANALYZE</code> command, which gathers data on the contents of tables. PostgreSQL stores this information and uses it to execute queries efficiently in the future. You can run <code>ANALYZE</code> manually if needed.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p><span epub:type="pagebreak" title="392" id="Page_392"/>Recall that <code>VACUUM</code> designates dead rows as available for the database to reuse but typically doesn’t reduce the size of the table on disk. You can confirm this by rerunning the code in <a href="c17.xhtml#listing17-2" id="listinganchor17-2">Listing 17-2</a>, which shows the table remains at 35MB even after the automatic vacuum.</p>&#13;
<h3 id="h2-501065c19-0003">Running VACUUM Manually</h3>&#13;
<p class="BodyFirst">To run <code>VACUUM</code> manually, you can use the single line of code in <a href="#listing19-6" id="listinganchor19-6">Listing 19-6</a>.</p>&#13;
<pre><code>VACUUM vacuum_test;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing19-6">Listing 19-6</a>: Running <code>VACUUM</code> manually</p>&#13;
<p>This command should return the message <code>VACUUM</code> from the server. Now when you fetch statistics again using the query in <a href="c17.xhtml#listing17-5" id="listinganchor17-5">Listing 17-5</a>, you should see that the <code>last_vacuum</code> column reflects the date and time of the manual vacuum you just ran, and the number in the <code>vacuum_count</code> column should increase by one.</p>&#13;
<p>In this example, we executed <code>VACUUM</code> on our test table, but you can also run <code>VACUUM</code> on the entire database by omitting the table name. In addition, you can add the <code>VERBOSE</code> keyword to return information such as the number of rows found in a table and the number of rows removed, among other information.</p>&#13;
<h3 id="h2-501065c19-0004">Reducing Table Size with VACUUM FULL</h3>&#13;
<p class="BodyFirst">Next, we’ll run <code>VACUUM</code> with the <code>FULL</code> option, which actually returns the space taken up by dead tuples back to disk. It does this by creating a new version of a table with the dead rows discarded.</p>&#13;
<p>To see how <code>VACUUM FULL</code> works, run the command in <a href="#listing19-7" id="listinganchor19-7">Listing 19-7</a>.</p>&#13;
<pre><code>VACUUM FULL vacuum_test;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing19-7">Listing 19-7</a>: Using <code>VACUUM FULL</code> to reclaim disk space</p>&#13;
<p>After the command executes, test the table size again. It should be back down to 17MB, the size it was when we first inserted data.</p>&#13;
<p>It’s never prudent or safe to run out of disk space, so minding the size of your database files as well as your overall system space is a worthwhile routine to establish. Using <code>VACUUM</code> to prevent database files from growing bigger than they have to is a good start.</p>&#13;
<h2 id="h1-501065c19-0002">Changing Server Settings</h2>&#13;
<p class="BodyFirst">You can alter the settings for your PostgreSQL server by editing values in <em>postgresql.conf</em>, one of several configuration text files that control server settings. Other files include <em>pg_hba.conf</em>, which controls connections to the server, and <em>pg_ident.conf</em>, which database administrators can use to map usernames on a network to usernames in PostgreSQL. See the PostgreSQL documentation on these files for details; here we’ll just cover <em>postgresql.conf</em> <span epub:type="pagebreak" title="393" id="Page_393"/>because it contains settings you may likely want to change. Most of the values in the file are set to defaults you may never need to adjust, but it’s worth exploring in case you’re fine-tuning your system. Let’s start with the basics.</p>&#13;
<h3 id="h2-501065c19-0005">Locating and Editing postgresql.conf</h3>&#13;
<p class="BodyFirst">The location of <em>postgresql.conf</em> varies depending on your operating system and install method. You can run the command in <a href="#listing19-8" id="listinganchor19-8">Listing 19-8</a> to locate the file.</p>&#13;
<pre><code>SHOW config_file;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing19-8">Listing 19-8</a>: Showing the location of <em>postgresql.conf</em></p>&#13;
<p>When I run the command on macOS, it shows the path to the file, as shown here:</p>&#13;
<pre><code>/Users/anthony/Library/Application Support/Postgres/var-13/postgresql.conf</code></pre>&#13;
<p>To edit <em>postgresql.conf</em>, navigate in your file system to the directory displayed by <code>SHOW config_file;</code> and open the file using a text editor. Don’t use a rich-text editor like Microsoft Word, as it may add additional formatting to the file.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	It’s a good idea to save an unaltered copy of <em>postgresql.conf</em> for reference in case you make a change that breaks the system and you need to revert to the original version.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>When you open the file, the first several lines should read as follows: </p>&#13;
<pre><code># -----------------------------&#13;
# PostgreSQL configuration file&#13;
# -----------------------------&#13;
#&#13;
# This file consists of lines of the form:&#13;
#&#13;
#   name = value&#13;
<var>--snip--</var></code></pre>&#13;
<p>The <em>postgresql.conf</em> file is organized into sections that specify settings for file locations, security, logging of information, and other processes. Many lines begin with a hash mark (<code>#</code>), which indicates the line is commented out and the setting shown is the active default.</p>&#13;
<p>For example, in the <em>postgresql.conf</em> file section “Autovacuum Parameters,” the default is for autovacuum to be turned on (which is a good, standard practice). The hash mark (<code>#</code>) in front of the line means that the line is commented out and the default value is in effect:</p>&#13;
<pre><code>#autovacuum = on               # Enable autovacuum subprocess?  'on'</code></pre>&#13;
<p>To change this or other default settings, you would remove the hash mark, adjust the setting value, and save <em>postgresql.conf</em>. Some changes, such <span epub:type="pagebreak" title="394" id="Page_394"/>as to memory allocations, require a restart of the server; they’re noted in <em>postgresql.conf</em>. Other changes require only a reload of settings files. You can reload settings files by running the function <code>pg_reload_conf()</code> under an account with superuser permissions or by executing the <code>pg_ctl</code> command, which we’ll cover in the next section.</p>&#13;
<p><a href="#listing19-9" id="listinganchor19-9">Listing 19-9</a> shows settings you may want to change, excerpted from the <em>postgresql.conf</em> section “Client Connection Defaults.” Use your text editor to search the file for the following.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> datestyle = 'iso, mdy'&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> timezone = 'America/New_York'&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> default_text_search_config = 'pg_catalog.english'</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing19-9">Listing 19-9</a>: Sample <em>postgresql.conf</em> settings</p>&#13;
<p>You can use the <code>datestyle</code> setting <span class="CodeAnnotation" aria-label="annotation1">1</span> to specify how PostgreSQL displays dates in query results. This setting takes two parameters separated by a comma: the output format and the ordering of month, day, and year. The default for the output format is the ISO format <var>YYYY-MM-DD</var> we’ve used throughout this book, which I recommend for its cross-national portability. However, you can also use the traditional SQL format <var>MM/DD/YYYY</var>, the expanded Postgres format <code>Sun Nov 12 22:30:00 2023 EST</code>, or the German format <var>DD.MM.YYYY</var> with dots between the date, month, and year (<code>12.11.2023</code>). To specify the format using the second parameter, arrange <var>m</var>, <var>d</var>, and <var>y</var> in the order you prefer.</p>&#13;
<p>The <code>timezone</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> parameter sets the server time zone. <a href="#listing19-9">Listing 19-9</a> shows the value <code>America/New_York</code>, which reflects the time zone on my machine when I installed PostgreSQL. Yours should vary based on your location. When setting up PostgreSQL for use as the backend to a database application or on a network, administrators often set this value to <code>UTC</code> and use that as a standard on machines across multiple locations.</p>&#13;
<p>The <code>default_text_search_config</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> value sets the language used by the full-text search operations. Here, mine is set to <code>english</code>. Depending on your needs, you can set this to <code>spanish</code>, <code>german</code>, <code>russian</code>, or another language of your choice.</p>&#13;
<p>These three examples represent only a handful of settings available for adjustment. Unless you end up deep in system tuning, you probably won’t have to tweak much else. Also, use caution when changing settings on a network server used by multiple people or applications; changes can have unintended consequences, so it’s worth communicating with colleagues first.</p>&#13;
<p>Next, let’s look at how to use <code>pg_ctl</code> to make changes take effect.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	The PostgreSQL <code>ALTER SYSTEM</code> command can also be used to update settings. The command creates settings in the file <em>postgresql.auto.conf</em> that will override values in <em>postgresql.conf</em>. See <a href="https://www.postgresql.org/docs/current/sql-altersystem.html" class="LinkURL">https://www.postgresql.org/docs/current/sql-altersystem.html</a> for details.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h3 id="h2-501065c19-0006"><span epub:type="pagebreak" title="395" id="Page_395"/>Reloading Settings with pg_ctl</h3>&#13;
<p class="BodyFirst">The command line utility <code>pg_ctl</code> allows you to perform actions on a PostgreSQL server, such as starting and stopping it and checking its status. Here, we’ll use the utility to reload the settings files so the changes we make will take effect. Running the command reloads all settings files at once.</p>&#13;
<p>You’ll need to open and configure a command line prompt the same way you did in <span class="xref" itemid="xref_target_Chapter 18">Chapter 18</span> when you learned how to set up and use <code>psql</code>. After you launch a command prompt, use one of the following commands to reload, replacing the path with the path to the PostgreSQL data directory:</p>&#13;
<ol class="none">&#13;
<li>On Windows, use <code>pg_ctl reload -D "</code><var>C:\path\to\data\directory\</var><code>"</code>.</li>&#13;
<li>On macOS or Linux, use <code>pg_ctl reload -D '</code><var>/path/to/data/directory/</var><code>'</code>.</li>&#13;
</ol>&#13;
<p>To find the location of your PostgreSQL data directory, run the query in <a href="#listing19-10" id="listinganchor19-10">Listing 19-10</a>.</p>&#13;
<pre><code>SHOW data_directory;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing19-10">Listing 19-10</a>: Showing the location of the data directory</p>&#13;
<p>Place the path after the <code>-D</code> argument, between double quotes on Windows and single quotes on macOS or Linux. You run this command on your system’s command prompt, not inside the <code>psql</code> application. Enter the command and press <span class="KeyCaps">enter</span>; it should respond with the message <code>server signaled</code>. The settings files will be reloaded, and changes should take effect.</p>&#13;
<p>If you’ve changed settings that require a server restart, replace <code>reload</code> in <a href="#listing19-10">Listing 19-10</a> with <code>restart</code>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	On Windows, you may need to run Command Prompt with administrator privileges to execute <code>pg_ctl</code> statements. Navigate to Command Prompt in your Start menu, right-click, and select <b>Run as Administrator</b>.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="h1-501065c19-0003">Backing Up and Restoring Your Database</h2>&#13;
<p class="BodyFirst">You might want to back up your entire database either for safekeeping or for transferring data to a new or upgraded server. PostgreSQL offers command line tools that make backup and restore operations easy. The next few sections show examples of how to export data from a database or a single table to a file, as well as how to restore data from an export files.</p>&#13;
<h3 id="h2-501065c19-0007">Using pg_dump to Export a Database or Table</h3>&#13;
<p class="BodyFirst">The PostgreSQL command line tool <code>pg_dump</code> creates an output file that contains all the data from your database; SQL commands for re-creating tables, views, functions, and other database objects; and commands for loading the data into tables. You can also use <code>pg_dump</code> to save only selected tables in your database. By default, <code>pg_dump</code> outputs a text file; I’ll discuss an alternate custom compressed format first and then discuss other options.</p>&#13;
<p><span epub:type="pagebreak" title="396" id="Page_396"/>To export the <code>analysis</code> database we’ve used for our exercises to a file, run the command in <a href="#listing19-11" id="listinganchor19-11">Listing 19-11</a> at your system’s command prompt (not in <code>psql</code>).</p>&#13;
<pre><code>pg_dump -d analysis -U <var>user_name</var> -Fc -v -f analysis_backup.dump</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing19-11">Listing 19-11</a>: Exporting the <code>analysis</code> database with <code>pg_dump</code></p>&#13;
<p>Here, we start the command with <code>pg_dump</code> and use similar connection arguments as with <code>psql</code>. We specify the database to export with the <code>-d</code> argument, followed by the <code>-U</code> argument and your username. Next, we use the <code>-Fc</code> argument to specify that we want to generate this export in a custom PostgreSQL compressed format and the <code>-v</code> argument to generate verbose output. Then we use the <code>-f</code> argument to direct the output of <code>pg_dump</code> to a text file named <em>analysis_backup.dump</em>. To place the file in a directory other than the one your terminal prompt is currently open to, you can specify the complete directory path before the filename.</p>&#13;
<p>When you execute the command, depending on your installation, you might see a password prompt. Fill in that password, if prompted. Then, depending on the size of your database, the command could take a few minutes to complete. You’ll see a series of messages about the objects the command is reading and outputting. When it’s done, it should return you to a new command prompt, and you should see a file named <em>analysis_backup.dump</em> in your current directory.</p>&#13;
<p>To limit the export to one or more tables that match a particular name, use the <code>-t</code> argument followed by the name of the table in single quotes. For example, to back up just the <code>train_rides</code> table, use the following command:</p>&#13;
<pre><code>pg_dump -t 'train_rides' -d analysis -U <var>user_name</var> -Fc -v -f train_backup.dump</code></pre>&#13;
<p>Now let’s look at how to restore the data from the export file, and then we’ll explore additional <code>pg_dump</code> options.</p>&#13;
<h3 id="h2-501065c19-0008">Restoring a Database Export with pg_restore</h3>&#13;
<p class="BodyFirst">The <code>pg_restore</code> utility restores data from your exported database file. You might need to restore your database when migrating data to a new server or when upgrading to a new major version of PostgreSQL. To restore the <code>analysis</code> database (assuming you’re on a server where <code>analysis</code> doesn’t exist), at the command prompt, run the command in <a href="#listing19-12" id="listinganchor19-12">Listing 19-12</a>.</p>&#13;
<pre><code>pg_restore -C -v -d postgres -U <var>user_name</var> analysis_backup.dump</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing19-12">Listing 19-12</a>: Restoring the <code>analysis</code> database with <code>pg_restore</code></p>&#13;
<p>After <code>pg_restore</code>, you add the <code>-C</code> argument, which tells the utility to create the <code>analysis</code> database on the server. (It gets the database name from the export file.) Then, as you saw previously, the <code>-v</code> argument provides verbose output, and <code>-d</code> specifies the name of the database to connect to, followed by the <code>-U</code> argument and your username. Press <span class="KeyCaps">enter</span>, and the restore will <span epub:type="pagebreak" title="397" id="Page_397"/>begin. When it’s done, you should be able to view your restored database via <code>psql</code> or in pgAdmin.</p>&#13;
<h3 id="h2-501065c19-0009">Exploring Additional Backup and Restore Options</h3>&#13;
<p class="BodyFirst">You can configure <code>pg_dump</code> with multiple options to include or exclude certain database objects, such as tables matching a name pattern, or to specify the output format. For example, when we backed up the <code>analysis</code> database, we specified the <code>-Fc</code> argument with <code>pg_dump</code> to generate the backup in a custom PostgreSQL compressed format. By excluding the <code>-Fc</code> argument, the utility will output in plain text, and you can view the contents of the backup with a text editor. For details, check the full <code>pg_dump</code> documentation at <a href="https://www.postgresql.org/docs/current/app-pgdump.html" class="LinkURL">https://www.postgresql.org/docs/current/app-pgdump.html</a>. For corresponding restore options, check the <code>pg_restore</code> documentation at <a href="https://www.postgresql.org/docs/current/app-pgrestore.html" class="LinkURL">https://www.postgresql.org/docs/current/app-pgrestore.html</a>.</p>&#13;
<p>You also may want to explore the <code>pg_basebackup</code> command, which can back up multiple databases running on a PostgreSQL server. See <a href="https://www.postgresql.org/docs/current/app-pgbasebackup.html" class="LinkURL">https://www.postgresql.org/docs/current/app-pgbasebackup.html</a> for details. An even more robust backup solution is pgBackRest (<a href="https://pgbackrest.org/" class="LinkURL">https://pgbackrest.org/</a>), a free, open source application with options such as cloud integration for storage and the ability to create full, incremental, or differential backups.</p>&#13;
<h2 id="h1-501065c19-0004">Wrapping Up</h2>&#13;
<p class="BodyFirst">In this chapter, you learned how to track and conserve space in your databases using the <code>VACUUM</code> feature in PostgreSQL. You also learned how to change system settings as well as back up and restore databases using other command line tools. You may not need to perform these tasks every day, but the maintenance tricks you learned here can help enhance the performance of your databases. Note that this is not a comprehensive overview of the topic; see the appendix for more resources on database maintenance.</p>&#13;
<p>In the next and final chapter of this book, I’ll share guidelines for identifying hidden trends and telling an effective story using your data.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>Try It Yourself</h2>&#13;
<p class="BoxBodyFirst">Using the techniques you learned in this chapter and earlier in the book, create a database and add a small table and some data. Then back up the database, delete it, and restore it using <code>pg_dump</code> and <code>pg_restore</code>.</p>&#13;
<p>If you make your backup using the default text format instead of compressed, you can use a text editor to explore the file created by <code>pg_dump</code> to examine how it organizes the statements to create objects and insert data.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div></body></html>