<html><head></head><body><div id="sbo-rt-content"><span epub:type="pagebreak" id="page_443"/>
<h2 class="h2" id="ch20"><strong><span class="big">20</span><br/>COMPILER VARIATIONS</strong></h2>
<div class="image1"><img src="Images/com.jpg" alt="Image" width="204" height="204"/></div>
<p class="noindent"><span class="big1">At this point, if we have done our job properly, you now possess the essential skills to use Ghidra effectively and, more importantly, to bend it to your will. The next step is to learn to adapt to the challenges that binaries (as opposed to Ghidra) will throw at you. Depending</span> on your motives for staring at assembly language, either you may be very familiar with what you are looking at or you may never know what you are going to be faced with. If you spend all of your time examining code that was compiled using <code>gcc</code> on a Linux platform, you’ll become quite familiar with the style of code that it generates, but you may be baffled by a debug version of a program compiled using the Microsoft C/C++ compiler. If you are a malware analyst, you may see code created using <code>gcc</code>, clang, Microsoft's C++ compiler, Delphi, and others, all in the same afternoon.</p>
<p class="indent">Like you, Ghidra is more familiar with the output of some compilers than other compilers, and familiarity with code generated by one compiler in no way guarantees that you will recognize high-level constructs compiled using an entirely different compiler (or even different versions of the same <span epub:type="pagebreak" id="page_444"/>compiler family). Rather than relying entirely on Ghidra’s analysis capabilities to recognize commonly used code and data constructs, you should always be prepared to utilize your own skills: your familiarity with a given assembly language, your knowledge of compilers, and your research skills to properly interpret a disassembly.</p>
<p class="indent">In this chapter, we cover some of the ways that compiler differences manifest themselves in disassembly listings. We primarily use compiled C code for our examples, as the variability of C compilers and target platforms provides foundational concepts that can be extended to other compiled languages.</p>
<h3 class="h3" id="ch20lev362"><strong>High-Level Constructs</strong></h3>
<p class="noindent">In some cases, the differences between compilers may just be cosmetic, but in other cases, they are much more significant. In this section, we look at high-level language constructs and demonstrate how different compilers and compiler options may significantly impact the resulting disassembly listing. We begin with <code>switch</code> statements and the two mechanisms most commonly employed to resolve <code>switch</code> case selection. Following that, we look at the way that compiler options affect code generation for common expressions before moving on to discuss how different compilers implement C++-specific constructs and handle program startup.</p>
<h4 class="h4" id="ch20lev363"><strong><em>switch Statements</em></strong></h4>
<p class="noindent">The C <code>switch</code> statement is a frequent target for compiler optimizations. The goal of these optimizations is to match the <code>switch</code> variable to a valid case label in the most efficient manner possible, but the distribution of the <code>switch</code> statement’s case labels constrains the type of search that can be used.</p>
<p class="indent">Since the efficiency of a search is measured by the number of comparisons required to find the correct case, we can trace the logic a compiler might use to determine the best way to represent a <code>switch</code> table. A constant time algorithm, such as a table lookup, is the most efficient.<sup><a id="ch20fn1a" href="footnotes.xhtml#ch20fn1">1</a></sup> At the other end of the continuum is linear search, which, in the worst case, requires comparing the <code>switch</code> variable against every case label before finding a match or resolving to the default and thus is the least efficient.<sup><a id="ch20fn2a" href="footnotes.xhtml#ch20fn2">2</a></sup> The efficiency of a binary search is much better, on average, than linear search but introduces additional constraints, as it requires a sorted list.<sup><a id="ch20fn3a" href="footnotes.xhtml#ch20fn3">3</a></sup></p>
<p class="indent">In order to select the most efficient implementation for a particular <code>switch</code> statement, it helps to understand how the case label distribution affects the compiler’s decision-making process. When case labels are closely clustered, as in the source code in <a href="ch20.xhtml#exa20_1">Listing 20-1</a>, compilers generally resolve <span epub:type="pagebreak" id="page_445"/>the <code>switch</code> variable by performing a table lookup to match the <code>switch</code> variable to the address of its associated case—specifically by using a jump table.</p>
<pre>switch (a) {<br/>
/** NOTE: case bodies omitted for brevity **/<br/>
    case 1:  /*...*/ break;<br/>
    case 2:  /*...*/ break;<br/>
    case 3:  /*...*/ break;<br/>
    case 4:  /*...*/ break;<br/>
    case 5:  /*...*/ break;<br/>
    case 6:  /*...*/ break;<br/>
    case 7:  /*...*/ break;<br/>
    case 8:  /*...*/ break;<br/>
    case 9:  /*...*/ break;<br/>
    case 10: /*...*/ break;<br/>
    case 11: /*...*/ break;<br/>
    case 12: /*...*/ break;<br/>
}</pre>
<p class="ex-caption" id="exa20_1"><em>Listing 20-1: A</em> <code>switch</code> <em>statement with consecutive case labels</em></p>
<p class="indent">A <em>jump table</em> is an array of pointers, with each pointer in the array referencing a possible jump target. At runtime, a dynamic index into the table chooses one of the many potential jumps each time the jump table is referenced. Jump tables work well when <code>switch</code> case labels are closely spaced (dense), with most of the cases falling into a consecutive number sequence. Compilers take this into account when deciding whether to utilize a jump table. For any <code>switch</code> statement, we can compute the minimum number of entries an associated jump table will contain as follows:</p>
<pre>num_entries = max_case_value – min_case_value + 1</pre>
<p class="indent">The <em>density</em>, or utilization rate, of the jump tables can then be computed as follows:</p>
<pre>density = num_cases / num_entries</pre>
<p class="indent">A completely contiguous list with every value represented would have a density value of 100 percent (1.0). Finally, the total amount of space required to store the jump table is as follows:</p>
<pre>table_size = num_entries * sizeof(void*)</pre>
<p class="indent">A <code>switch</code> statement with 100 percent density will be implemented using a jump table. A set of cases with a density of 30 percent might not be implemented using a jump table, since jump table entries would still need to be allocated for the absent cases, which would be 70 percent of the jump table. If <code>num_entries</code> is 30, the jump table would contain entries for 21 unreferenced case labels. On a 64-bit system, this is 168 of the 240 bytes allocated to the table, which is not a lot of overhead, but if <code>num_entries</code> jumps to 300, then the overhead becomes 1680 bytes, which may not be worth the trade-off for <span epub:type="pagebreak" id="page_446"/>90 possible cases. A compiler that is optimizing for speed may favor jump table implementations, while a compiler that is optimizing for size may choose an alternative implementation with lower memory overhead: binary search.</p>
<p class="indent"><em>Binary search</em> is efficient when the case labels are widely spread (low density), as seen in <a href="ch20.xhtml#exa20_2">Listing 20-2</a> (density 0.0008).<sup><a id="ch20fn4a" href="footnotes.xhtml#ch20fn4">4</a></sup> Because binary search works only on sorted lists, the compiler must ensure that the case labels are ordered before it begins the search with the median value. This may result in the reordering of case blocks when viewed in a disassembly, as compared to the order they appear in the corresponding source.<sup><a id="ch20fn5a" href="footnotes.xhtml#ch20fn5">5</a></sup></p>
<pre>switch (a) {<br/>
/** NOTE: case bodies omitted for brevity **/<br/>
    case 1:     /*...*/ break;<br/>
    case 211:   /*...*/ break;<br/>
    case 295:   /*...*/ break;<br/>
    case 462:   /*...*/ break;<br/>
    case 528:   /*...*/ break;<br/>
    case 719:   /*...*/ break;<br/>
    case 995:   /*...*/ break;<br/>
    case 1024:  /*...*/ break;<br/>
    case 8000:  /*...*/ break;<br/>
    case 13531: /*...*/ break;<br/>
    case 13532: /*...*/ break;<br/>
    case 15027: /*...*/ break;<br/>
}</pre>
<p class="ex-caption" id="exa20_2"><em>Listing 20-2: Sample</em> <code>switch</code> <em>statement with nonconsecutive case labels</em></p>
<p class="indent"><a href="ch20.xhtml#exa20_3">Listing 20-3</a> shows an outline for a non-iterative binary search through a fixed number of constant values. This is the rough framework that the compiler uses to implement the <code>switch</code> from <a href="ch20.xhtml#exa20_2">Listing 20-2</a>.</p>
<pre>if (value &lt; median) {<br/>
    // value is in [0-50) percentile<br/>
    if (value &lt; lower_half_median) {<br/>
        // value is in [0-25) percentile<br/>
        // ... continue successive halving until value is resolved<br/>
    } else {<br/>
        // value is in [25-50) percentile<br/>
        // ... continue successive halving until value is resolved<br/>
   }<br/>
} else {<br/>
    // value is in [50-100) percentile<br/>
    if (value &lt; upper_half_median) {<br/>
        // value is in [50-75) percentile<br/>
<span epub:type="pagebreak" id="page_447"/>
        // ... continue successive halving until value is resolved<br/>
    } else {<br/>
        // value is in [75-100) percentile<br/>
        // ... continue successive halving until value is resolved<br/>
    }<br/>
}</pre>
<p class="ex-caption" id="exa20_3"><em>Listing 20-3: Non-iterative binary search through a fixed number of constant values</em></p>
<p class="indent">Compilers are also capable of performing more fine-grained optimizations across a range of case labels. For example, when confronted with the case labels</p>
<pre>label_set = [1, 2, 3, 4, 5, 6, 7, 8, 50, 80, 200, 500, 1000, 5000, 10000]</pre>
<p class="noindent">a less aggressive compiler might see a density of 0.0015 here and generate a binary search through all 15 cases. A more aggressive compiler might emit a jump table to resolve cases 1 to 8, and a binary search for the remaining cases, achieving optimal performance for over half of the cases.</p>
<p class="indent">Before we look at the disassembled versions of <a href="ch20.xhtml#exa20_1">Listings 20-1</a> and <a href="ch20.xhtml#exa20_2">20-2</a>, let’s look at the Ghidra Function Graph windows corresponding to the listings, shown side by side in <a href="ch20.xhtml#fig20_1">Figure 20-1</a>.</p>
<div class="image"><img src="Images/fig20-1.jpg" alt="image" width="550" height="637"/></div>
<p class="figcap" id="fig20_1"><em>Figure 20-1: Ghidra Function Graph</em> <code>switch</code> <em>statement examples</em></p>
<span epub:type="pagebreak" id="page_448"/>
<p class="indent">On the left, the graph for <a href="ch20.xhtml#exa20_1">Listing 20-1</a> shows a nice vertical stack of cases. Each stacked code block resides at the same nesting depth, as is true for cases in a <code>switch</code> statement. The stack suggests that we can use an index to quickly select one block from the many (think array access). This is precisely how jump table resolution works, and the left-hand graph provides us with a visual hint that this is the case, even before we have looked at a single line of the disassembly.</p>
<p class="indent">The right-hand graph is Ghidra’s result based solely on its understanding of the disassembly of <a href="ch20.xhtml#exa20_2">Listing 20-2</a>. The lack of a jump table makes it much more challenging to identify this as a <code>switch</code> statement. What you are seeing is a visual representation of the <code>switch</code> statement using Ghidra’s Nested Code Layout. This is the default layout for function graphs in Ghidra and is intended to represent the flow structures in a program. The horizontal branching in this graph suggests conditional execution (<code>if</code>/<code>else</code>) branching to mutually exclusive alternatives. The vertical symmetry suggests that the alternative execution paths have been very carefully balanced to place equal numbers of blocks in each vertical half of the graph. Finally, the distance that the graph traverses horizontally is an indicator of the depth reached by the search, which in turn is dictated by the total number of case labels present in the <code>switch</code>. For a binary search, this depth will always be on the order of <code>log<sub>2</sub></code><code>(num_cases)</code>. The similarity between the indentation of the graphical representation and the algorithm outlined in <a href="ch20.xhtml#exa20_3">Listing 20-3</a> is easily observable.</p>
<p class="indent">Turning our attention to the Decompiler window, <a href="ch20.xhtml#fig20_2">Figure 20-2</a> shows the partial decompilation of the functions displayed in <a href="ch20.xhtml#fig20_1">Figure 20-1</a>. On the left is the decompiled version of <a href="ch20.xhtml#exa20_1">Listing 20-1</a>. As with the graph, the presence of a jump table in the binary helps Ghidra identify the code as a <code>switch</code> statement.</p>
<p class="indent">On the right is the decompiled version of <a href="ch20.xhtml#exa20_2">Listing 20-2</a>. The decompiler has presented the <code>switch</code> statement as a nested <code>if</code>/<code>else</code> structure consistent with a binary search, and similar in structure to <a href="ch20.xhtml#exa20_3">Listing 20-3</a>. You can see that first comparison is against 719, the median value in the list, and that subsequent comparisons continue to divide the search space in half. Referring to <a href="ch20.xhtml#fig20_1">Figure 20-1</a> (as well as <a href="ch20.xhtml#exa20_3">Listing 20-3</a>), we can again observe that the graphical representations of each function closely correspond to the indentation patterns observed in the Decompiler window.</p>
<p class="indent">Now that you have an idea of what is happening from a high level, let’s look inside the binaries and investigate what is happening at a low level. Since our objective in this chapter is to observe differences between compilers, we present this example as a series of comparisons between two compilers, <code>gcc</code> and Microsoft C/C++.<sup><a id="ch20fn6a" href="footnotes.xhtml#ch20fn6">6</a></sup></p>
<span epub:type="pagebreak" id="page_449"/>
<div class="image"><img src="Images/fig20-2.jpg" alt="image" width="843" height="651"/></div>
<p class="figcap" id="fig20_2"><em>Figure 20-2: Ghidra decompiled</em> <code>switch</code> <em>statement examples</em></p>
<h4 class="h4" id="ch20lev364"><strong><em>Example: Comparing gcc with Microsoft C/C++ Compiler</em></strong></h4>
<p class="noindent">In this example, we compare two 32-bit x86 binaries generated for <a href="ch20.xhtml#exa20_1">Listing 20-1</a> by two distinct compilers. We will attempt to identify components of a <code>switch</code> statement in each binary, locate the associated jump table in each binary, and point out significant differences between the two binaries. Let’s start by looking at the <code>switch</code>-related components for <a href="ch20.xhtml#exa20_1">Listing 20-1</a> in the binary built with <code>gcc</code>:</p>
<pre>0001075a  CMP<span class="ent">➊</span>  dword ptr [EBP + value],12<br/>
0001075e  JA     switchD_00010771::caseD_0<span class="ent">➋</span><br/>
00010764  MOV    EAX,dword ptr [EBP + a]<br/>
00010767  SHL    EAX,0x2<br/>
0001076a  ADD    EAX,switchD_00010771::switchdataD_00010ee0       = 00010805<br/>
0001076f  MOV    EAX,dword ptr [EAX]=&gt;-&gt;switchD_00010771::caseD_0 = 00010805<br/>
        switchD_00010771::switchD<br/>
00010771  JMP    EAX<br/>
        switchD_00010771::caseD_1<span class="ent">➌</span>             XREF[2]:      00010771(j), 00010ee4(*)<br/>
<span epub:type="pagebreak" id="page_450"/>
00010773  MOV    EDX,dword ptr [EBP + a]<br/>
00010776  MOV    EAX,dword ptr [EBP + b]<br/>
00010779  ADD    EAX,EDX<br/>
0001077b  MOV    dword ptr [EBP + result],EAX<br/>
0001077e  JMP    switchD_00010771::caseD_0<br/>
;--<span class="codeitalic1">content omitted for remaining cases</span>--<br/>
       switchD_00010771::switchdataD_00010ee0<span class="ent">➋</span>  XREF[2]: switch_version_1:0001076a(*),<br/>
                                                          switch_version_1:0001076f(R)<br/>
00010ee0  addr    switchD_00010771::caseD_0<span class="ent">➎</span><br/>
00010ee4  addr    switchD_00010771::caseD_1<br/>
00010ee8  addr    switchD_00010771::caseD_2<br/>
00010eec  addr    switchD_00010771::caseD_3<br/>
00010ef0  addr    switchD_00010771::caseD_4<br/>
00010ef4  addr    switchD_00010771::caseD_5<br/>
00010ef8  addr    switchD_00010771::caseD_6<br/>
00010efc  addr    switchD_00010771::caseD_7<br/>
00010f00  addr    switchD_00010771::caseD_8<br/>
00010f04  addr    switchD_00010771::caseD_9<br/>
00010f08  addr    switchD_00010771::caseD_a<br/>
00010f0c  addr    switchD_00010771::caseD_b<br/>
00010f10  addr    switchD_00010771::caseD_c</pre>
<p class="indent">Ghidra recognizes the switch bounds test <span class="ent">➊</span>, the jump table <span class="ent">➍</span>, and individual case blocks by value, such as the one at <code>switchD_00010771::caseD_1</code> <span class="ent">➌</span>. The compiler generated a jump table with 13 entries, although <a href="ch20.xhtml#exa20_1">Listing 20-1</a> contained only 12 cases. The additional case, case 0 (the first entry <span class="ent">➎</span> in the jump table), shares a target address with every value outside the range 1 to 12. In other words, case 0 is part of the default case. While it may seem that negative numbers are being excluded from the default, the <code>CMP,</code> <code>JA</code> sequence works as a comparison on unsigned values; thus, <code>-1</code> (<code>0xFFFFFFFF</code>) would be seen as <code>4294967295</code>, which is much larger than 12 and therefore excluded from the valid range for indexing the jump table. The <code>JA</code> instruction directs all such cases to the default location: <code>switchD_00010771::caseD_0</code> <span class="ent">➋</span>.</p>
<p class="indent">Now that we understand the basic components of the code generated by the <code>gcc</code> compiler, let’s shift our focus to the same components in code generated by the Microsoft C/C++ compiler in debug mode:</p>
<pre>00411e88  MOV    ECX,dword ptr [EBP + local_d4]<br/>
00411e8e  SUB<span class="ent">➊</span>  ECX,0x1<br/>
00411e91  MOV    dword ptr [EBP + local_d4],ECX<br/>
00411e97  CMP<span class="ent">➋</span>  dword ptr [EBP + local_d4],11<br/>
00411e9e  JA     switchD_00411eaa::caseD_c<br/>
00411ea4  MOV    EDX,dword ptr [EBP + local_d4]<br/>
        switchD_00411eaa::switchD<br/>
00411eaa  JMP    dword ptr [EDX*0x4 + -&gt;switchD_00411eaa::caseD      = 00411eb1<br/>
        switchD_00411eaa::caseD_1                XREF[2]: 00411eaa(j), 00411f4c(*)<br/>
00411eb1  MOV    EAX,dword ptr [EBP + param_1]<br/>
00411eb4  ADD    EAX,dword ptr [EBP + param_2]<br/>
<span epub:type="pagebreak" id="page_451"/>
00411eb7  MOV    dword ptr [EBP + local_c],EAX<br/>
00411eba  JMP    switchD_00411eaa::caseD_c<br/>
;--<span class="codeitalic1">content omitted for remaining cases</span>--<br/>
        switchD_00411eaa::switchdataD_00411f4c   XREF[1]: switch_version_1:00411eaa(R)<br/>
00411f4c  addr   switchD_00411eaa::caseD_1<span class="ent">➌</span><br/>
00411f50  addr   switchD_00411eaa::caseD_2<br/>
00411f54  addr   switchD_00411eaa::caseD_3<br/>
00411f58  addr   switchD_00411eaa::caseD_4<br/>
00411f5c  addr   switchD_00411eaa::caseD_5<br/>
00411f60  addr   switchD_00411eaa::caseD_6<br/>
00411f64  addr   switchD_00411eaa::caseD_7<br/>
00411f68  addr   switchD_00411eaa::caseD_8<br/>
00411f6c  addr   switchD_00411eaa::caseD_9<br/>
00411f70  addr   switchD_00411eaa::caseD_a<br/>
00411f74  addr   switchD_00411eaa::caseD_b<br/>
00411f78  addr   switchD_00411eaa::caseD_c</pre>
<p class="indent">Here, the <code>switch</code> variable (<code>local_d4</code> in this case) is decremented <span class="ent">➊</span> to shift the range of valid values from 0 to 11 <span class="ent">➋</span>, eliminating the need for a dummy table entry for the value 0. As a result, the first entry (or 0 index entry) in the jump table <span class="ent">➌</span> actually refers to the code for switch case 1.</p>
<p class="indent">Another, perhaps more subtle difference between the two listings is the location of the jump table within the file. The <code>gcc</code> compiler places switch jump tables in the read-only data (<code>.rodata</code>) section of the binary, providing a logical separation between the code associated with the <code>switch</code> statement and the data required to implement the jump table. The Microsoft C/C++ compiler, on the other hand, inserts jump tables into the <code>.text</code> section, immediately following the function containing the associated <code>switch</code> statement. Positioning the jump table in this manner has little effect on the behavior of the program. In this example, Ghidra is able to recognize the <code>switch</code> statements for both compilers and uses the term <code>switch</code> within the associated labels.</p>
<p class="indent">One of the key points here is that there is no single correct way to compile source to assembly. As a result, you cannot assume that something is not a <code>switch</code> statement simply because Ghidra fails to label it as such. Understanding the <code>switch</code> statement characteristics that factor into the compiler implementation can help you make a more accurate inference about the original source code.</p>
<h3 class="h3" id="ch20lev365"><strong>Compiler Build Options</strong></h3>
<p class="noindent">A compiler converts high-level code that solves a particular problem into low-level code that solves the same problem. Multiple compilers may solve the same problem in rather different ways. Further, a single compiler may solve a problem very differently based on the associated compiler options. In this section, we look at the assembly language code that results from using different compilers and different command line options. (Some differences will have a clear explanation; others will not.)</p>
<span epub:type="pagebreak" id="page_452"/>
<p class="indent">Microsoft’s Visual Studio can build either debug or release versions of program binaries.<sup><a id="ch20fn7a" href="footnotes.xhtml#ch20fn7">7</a></sup> To see how the two versions are different, compare the build options specified for each. Release versions are generally optimized, while debug versions are not, and debug versions are linked with additional symbol information and debugging versions of the runtime library, while release versions are not.<sup><a id="ch20fn8a" href="footnotes.xhtml#ch20fn8">8</a></sup> Debugging-related symbols allow debuggers to map assembly language statements back to their source code counterparts and to determine the names of local variables (such information is otherwise lost during the compilation process). The debugging versions of Microsoft’s runtime libraries have also been compiled with debugging symbols included, optimizations disabled, and additional safety checks enabled to verify that some function parameters are valid.</p>
<p class="indent">When disassembled using Ghidra, debug builds of Visual Studio projects look significantly different from release builds. This is a result of compiler and linker options specified only in debug builds, such as basic runtime checks (<code>/RTCx</code>), which introduce extra code into the resulting binary.<sup><a id="ch20fn9a" href="footnotes.xhtml#ch20fn9">9</a></sup> Let’s jump right in and look at some of these differences in disassemblies.</p>
<h4 class="h4" id="ch20lev366"><strong><em>Example 1: Modulo Operator</em></strong></h4>
<p class="noindent">We begin our examples with a simple mathematical operation, modulo. The following listing contains the source code for a program whose only goal is to accept an integer value from the user and demonstrate integer division and the modulo operator:</p>
<pre>int main(int argc, char **argv) {<br/>
    int x;<br/>
    printf("Enter an integer: ");<br/>
    scanf("%d", &amp;x);<br/>
    printf("%d %% 10 = %d\n", x, x % 10);<br/>
}</pre>
<p class="indent">Let’s investigate how the disassembly varies across compilers for the modulo operator in this example.</p>
<span epub:type="pagebreak" id="page_453"/>
<h5 class="h5" id="ch20lev367"><strong>Modulo with Microsoft C/C++ Win x64 Debug</strong></h5>
<p class="noindent">The following listing shows the code that Visual Studio generates when configured to build a debug version of the binary:</p>
<pre>1400119c6 MOV    EAX,dword ptr [RBP + local_f4]<br/>
1400119c9 CDQ<br/>
1400119ca MOV    ECX,0xa<br/>
1400119cf IDIV<span class="ent">➊</span> ECX<br/>
1400119d1 MOV    EAX,EDX<br/>
1400119d3 MOV<span class="ent">➋</span>  R8D,EAX<br/>
1400119d6 MOV    EDX,dword ptr [RBP + local_f4]<br/>
1400119d9 LEA    RCX,[s_%d_%%_10_=_%d_140019d60]<br/>
1400119e0 CALL   printf</pre>
<p class="indent">A straightforward x86 <code>IDIV</code> instruction <span class="ent">➊</span> leaves the quotient in <code>EAX</code> and the remainder of the division in <code>EDX</code>. The result is then moved to lower 32 bits of <code>R8</code> (<code>R8D</code>) <span class="ent">➋</span>, which is the third argument in the call to <code>printf</code>.</p>
<h5 class="h5" id="ch20lev368"><strong>Modulo with Microsoft C/C++ Win x64 Release</strong></h5>
<p class="noindent">Release builds optimize software for speed and size in order to enhance performance and minimize storage requirements. When optimizing for speed, compiler writers may resort to non-obvious implementations of common operations. The following listing shows us how Visual Studio generates the same modulo operation in a release binary:</p>
<pre>140001136 MOV    ECX,dword ptr [RSP + local_18]<br/>
14000113a MOV    EAX,0x66666667<br/>
14000113f IMUL<span class="ent">➊</span> ECX<br/>
140001141 MOV    R8D,ECX<br/>
140001144 SAR    EDX,0x2<br/>
140001147 MOV    EAX,EDX<br/>
140001149 SHR    EAX,0x1f<br/>
14000114c ADD    EDX,EAX<br/>
14000114e LEA    EAX,[RDX + RDX*0x4]<br/>
140001151 MOV    EDX,ECX<br/>
140001153 ADD    EAX,EAX<br/>
140001155 LEA    RCX,[s_%d_%%_10_=_%d_140002238]<br/>
14000115c SUB<span class="ent">➋</span>  R8D,EAX<br/>
14000115f CALL<span class="ent">➌</span> printf</pre>
<p class="indent">In this case, multiplication <span class="ent">➊</span> is used rather than division, and after a long sequence of arithmetic operations, what must be the result of the modulo operation ends up in <code>R8D</code> <span class="ent">➋</span> (again the third argument in the call to <code>printf</code> <span class="ent">➌</span>). Intuitive, right? An explanation of this code follows our next example.</p>
<h5 class="h5" id="ch20lev369"><strong>Modulo with gcc for Linux x64</strong></h5>
<p class="noindent">We’ve seen how differently one compiler can behave simply by changing the compile-time options used to generate a binary. We might expect that <span epub:type="pagebreak" id="page_454"/>a completely unrelated compiler would generate entirely different code yet again. The following disassembly shows us the <code>gcc</code> version of the same modulus operation, and it turns out to look somewhat familiar:</p>
<pre>00100708  MOV    ECX,dword ptr [RBP + x]<br/>
0010070b  MOV    EDX,0x66666667<br/>
00100710  MOV    EAX,ECX<br/>
00100712  IMUL<span class="ent">➊</span> EDX<br/>
00100714  SAR    EDX,0x2<br/>
00100717  MOV    EAX,ECX<br/>
00100719  SAR    EAX,0x1f<br/>
0010071c  SUB    EDX,EAX<br/>
0010071e  MOV    EAX,EDX<br/>
00100720  SHL    EAX,0x2<br/>
00100723  ADD    EAX,EDX<br/>
00100725  ADD    EAX,EAX<br/>
00100727  SUB    ECX,EAX<br/>
00100729  MOV<span class="ent">➋</span>  EDX,ECX</pre>
<p class="indent">The code is very similar to the assembly produced by the Visual Studio release version. We again see multiplication <span class="ent">➊</span> rather than division followed by a sequence of arithmetic operations that eventually leaves the result in <code>EDX</code> <span class="ent">➋</span> (where it is eventually used as the third argument to <code>printf</code>).</p>
<p class="indent">The code is using a multiplicative inverse to perform division by multiplying because hardware multiplication is faster than hardware division. You may also see multiplication implemented using a series of additions and arithmetic shifts, as each of these operations is significantly faster in hardware than multiplication.</p>
<p class="indent">Your ability to recognize this code as modulo 10 depends on your experience, patience, and creativity. If you’ve seen similar code sequences in the past, you are probably more apt to recognize what’s taking place here. Lacking that experience, you might instead work through the code manually with sample values, hoping to recognize a pattern in the results. You might even take the time to extract the assembly language, wrap it in a C test harness, and do some high-speed data generation to assist you. Ghidra’s decompiler can be another useful resource for reducing complex or unusual code sequences to their more recognizable C equivalents.</p>
<p class="indent">As a last resort, or first resort (don’t be ashamed), you might turn to the internet for answers. But what should you be searching for? Usually, unique, specific searches yield the most relevant results, and the most unique feature in the sequence of code is the integer constant <code>0x66666667</code>. When we searched for this constant, the top three results were all helpful, but one in particular was worth bookmarking: <em><a href="http://flaviojslab.blogspot.com/2008/02/integer-division.html">http://flaviojslab.blogspot.com/2008/02/integer-division.html</a></em>. Unique constants are also used rather frequently in cryptographic algorithms, and a quick internet search may be all it takes to identify exactly what crypto routine you are staring at.</p>
<span epub:type="pagebreak" id="page_455"/>
<h4 class="h4" id="ch20lev370"><strong><em>Example 2: The Ternary Operator</em></strong></h4>
<p class="noindent">The ternary operator evaluates an expression and then yields one of two possible results, depending on the boolean value of that expression. Conceptually, the ternary operator can be thought of as an <code>if</code>/<code>else</code> statement (and can even be replaced with an <code>if</code>/<code>else</code> statement). The following intentionally unoptimized source code demonstrates the use of this operator:</p>
<pre>int main() {<br/>
    volatile int x = 3;<br/>
    volatile int y = x * 13;<br/>
  <span class="ent">➊</span> volatile int z = y == 30 ? 0 : -1;<br/>
}</pre>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The <span class="codeitalic">volatile</span> keyword asks the compiler not to optimize code involving the associated variables. Without its use here, some compilers will optimize away the entire body of this function since none of the statements contribute to the function’s result. This is one of the challenges you might face when coding examples for yourself or for others.</em></p>
</div>
<p class="indent">As for the behavior of the unoptimized code, the assignment into variable <code>z</code> <span class="ent">➊</span> could be replaced with the following <code>if</code>/<code>else</code> statement without changing the semantics of the program:</p>
<pre>    if (y == 30) {<br/>
        z = 0;<br/>
    } else {<br/>
        z = -1;<br/>
    }</pre>
<p class="indent">Let’s see how the ternary operator code is handled by different compilers and different compiler options.</p>
<h5 class="h5" id="ch20lev371"><strong>Ternary Operator with gcc on Linux x64</strong></h5>
<p class="noindent"><code>gcc</code>, with no options, generated the following assembly for the initialization of <code>z</code>:</p>
<pre>00100616  MOV    EAX,dword ptr [RBP + y]<br/>
00100619  CMP<span class="ent">➊</span>  EAX,0x1e<br/>
0010061c  JNZ    LAB_00100625<br/>
0010061e  MOV    EAX,0x0<br/>
00100623  JMP    LAB_0010062a<br/>
        LAB_00100625<br/>
00100625  MOV    EAX,0xffffffff<br/>
        LAB_0010062a<br/>
0010062a  MOV<span class="ent">➋</span>  dword ptr [RBP + z],EAX</pre>
<span epub:type="pagebreak" id="page_456"/>
<p class="indent">This code uses the <code>if</code>/<code>else</code> implementation. Local variable <code>y</code> is compared to <code>30</code> <span class="ent">➊</span> to decide whether to set <code>EAX</code> to <code>0</code> or <code>0xffffffff</code> in opposing branches of the <code>if</code>/<code>else</code> before assigning the result into <code>z</code> <span class="ent">➋</span>.</p>
<h5 class="h5" id="ch20lev372"><strong>Ternary Operator with Microsoft C/C++ Win x64 Release</strong></h5>
<p class="noindent">Visual Studio yields a very different implementation of the statement containing the ternary operator. Here, the compiler recognizes that a single instruction can be used to conditionally generate either <code>0</code> or <code>-1</code> (and no other possible value) and uses this instruction in lieu of the <code>if</code>/<code>else</code> construct we saw earlier:</p>
<pre>140001013 MOV    EAX,dword ptr [RSP + local_res8]<br/>
140001017 SUB<span class="ent">➊</span>  EAX,0x1e<br/>
14000101a NEG<span class="ent">➋</span>  EAX<br/>
14000101c SBB<span class="ent">➌</span>  EAX,EAX<br/>
14000101e MOV    dword ptr [RSP + local_res8],EAX</pre>
<p class="indent">The <code>SBB</code> instruction <span class="ent">➌</span> (<em>subtract with borrow</em>) subtracts the second operand from the first operand and then subtracts the carry flag, <code>CF</code> (which can be only 0 or 1). The equivalent arithmetic expression to <code>SBB EAX,EAX</code> is <code>EAX – EAX – CF</code>, which reduces to <code>0 – CF</code>. This, in turn, can result only in <code>0</code> (when <code>CF == 0</code>) or <code>-1</code> (when <code>CF == 1</code>). For this trick to work, the compiler must set the carry properly prior to executing the <code>SBB</code> instruction. This is accomplished by comparing <code>EAX</code> to the constant <code>0x1e</code> (<code>30</code>) <span class="ent">➊</span> using a subtraction that leaves <code>EAX</code> equal to <code>0</code> only when <code>EAX</code> was initially <code>0x1e</code>. The <code>NEG</code> instruction <span class="ent">➋</span> then sets the carry flag for the <code>SBB</code> instruction that follows.<sup><a id="ch20fn10a" href="footnotes.xhtml#ch20fn10">10</a></sup></p>
<h5 class="h5" id="ch20lev373"><strong>Ternary Operator with gcc on Linux x64 (Optimized)</strong></h5>
<p class="noindent">When we ask <code>gcc</code> to try a little harder by optimizing its code (<code>-O2</code>), the result is not unlike the Visual Studio code in the previous example:</p>
<pre>00100506  MOV    EAX,dword ptr [RSP + y]<br/>
0010050a  CMP    EAX,0x1e<br/>
0010050d  SETNZ<span class="ent">➊</span>AL<br/>
00100510  MOVZX  EAX,AL<br/>
00100513  NEG<span class="ent">➋</span>  EAX<br/>
00100515  MOV<span class="ent">➌</span>  dword ptr [RSP + z],EAX</pre>
<p class="indent">In this case, <code>gcc</code> uses <code>SETNZ</code> <span class="ent">➊</span> to conditionally set the <code>AL</code> register to either 0 or 1 based on the state of the zero flag resulting from the preceding comparison. The result is then negated <span class="ent">➋</span> to become either <code>0</code> or <code>-1</code> before assignment into variable <code>z</code> <span class="ent">➌</span>.</p>
<span epub:type="pagebreak" id="page_457"/>
<h4 class="h4" id="ch20lev374"><strong><em>Example 3: Function Inlining</em></strong></h4>
<p class="noindent">When a programmer marks a function <code>inline</code>, they are suggesting to the compiler that any calls to the function should be replaced with a copy of the entire function body. The intent is to speed up the function call by eliminating parameter and stack frame setup and teardown. The trade-off is that many copies of an inlined function make the binary larger. Inlined functions can be very difficult to recognize in binaries because the distinctive <code>call</code> instruction is eliminated.</p>
<p class="indent">Even when the <code>inline</code> keyword has not been used, compilers may elect to inline a function on their own initiative. In our third example, we are making a call to the following function:</p>
<pre>int maybe_inline() {<br/>
    return 0x12abcdef;<br/>
}<br/>
int main() {<br/>
    int v = maybe_inline();<br/>
    printf("after maybe_inline: v = %08x\n", v);return 0;<br/>
}</pre>
<h5 class="h5" id="ch20lev375"><strong>Function Call with gcc on Linux x86</strong></h5>
<p class="noindent">After building a Linux x86 binary using <code>gcc</code> with no optimizations, we disassemble it to see the following listing:</p>
<pre>00010775  PUSH   EBP<br/>
00010776  MOV    EBP,ESP<br/>
00010778  PUSH   ECX<br/>
00010779  SUB    ESP,0x14<br/>
0001077c  CALL<span class="ent">➊</span> maybe_inline<br/>
00010781  MOV    dword ptr [EBP + local_14],EAX<br/>
00010784  SUB    ESP,0x8<br/>
00010787  PUSH   dword ptr [EBP + local_14]<br/>
0001078a  PUSH   s_after_maybe_inline:_v_=_%08x_000108e2<br/>
0001078f  CALL   printf</pre>
<p class="indent">We can clearly see the call <span class="ent">➊</span> to the <code>maybe_inline</code> function in this disassembly, even though it is just a single line of code returning a constant value.</p>
<h5 class="h5" id="ch20lev376"><strong>Optimized Function Call with gcc on Linux x86</strong></h5>
<p class="noindent">Next, we look at an optimized (<code>-O2</code>) version of the same source code:</p>
<pre>0001058a  PUSH   EBP<br/>
0001058b  MOV    EBP,ESP<br/>
0001058d  PUSH   ECX<br/>
0001058e  SUB    ESP,0x8<br/>
00010591  PUSH<span class="ent">➊</span> 0x12abcdef<br/>
00010596  PUSH   s_after_maybe_inline:_v_=_%08x_000108c2<br/>
0001059b  PUSH   0x1<br/>
0001059d  CALL   __printf_chk</pre>
<span epub:type="pagebreak" id="page_458"/>
<p class="indent">Contrasting this code with the unoptimized code, we see that the call to <code>maybe_inline</code> has been eliminated, and the constant value <span class="ent">➊</span> returned by <code>maybe_inline</code> is pushed directly onto the stack to be used as an argument for the call to <code>printf</code>. This optimized version of the function call is identical to what you would see if the function had been designated inline.</p>
<p class="indent">Having examined some of the ways that optimizations can influence the code generated by compilers, let’s turn our attention to the different ways that compiler designers choose to implement language-specific features when language designers leave implementation details to the compiler writers.</p>
<h3 class="h3" id="ch20lev377"><strong>Compiler-Specific C++ Implementation</strong></h3>
<p class="noindent">Programming languages are designed by programmers for programmers. Once the dust of the design process has settled, it’s up to compiler writers to build the tools that faithfully translate programs written in the new high-level language into semantically equivalent machine language programs. When a language permits a programmer to do A, B, and C, it’s up to the compiler writers to find a way to make these things possible.</p>
<p class="indent">C++ gives us three excellent examples of behaviors required by the language, but whose implementation details were left to the compiler writer to sort out:</p>
<ul>
<li><p class="noindent">Within a nonstatic member function of a class, programmers may refer to a variable named <code>this</code>, which is never explicitly declared anywhere. (See <a href="ch06.xhtml#ch06">Chapters 6</a> and <a href="ch08.xhtml#ch08">8</a> for compilers’ treatment of <code>this</code>.)</p></li>
<li><p class="noindent">Function overloading is allowed. Programmers are free to reuse function names as often as they like, subject to restrictions on their parameter lists.</p></li>
<li><p class="noindent">Type introspection is supported through the use of the <code>dynamic_cast</code> and <code>typeid</code> operators.</p></li>
</ul>
<h4 class="h4" id="ch20lev378"><strong><em>Function Overloading</em></strong></h4>
<p class="noindent">Function overloading in C++ allows programmers to name functions identically, with the caveat that any two functions that share a name must have different parameter sequences. Name mangling, introduced in <a href="ch08.xhtml#ch08">Chapter 8</a>, is the under-the-hood mechanism that allows overloading to work by ensuring that no two symbols share the same name by the time the linker is asked to do its job.</p>
<p class="indentb">Often, one of the earliest signs that you are working with a C++ binary is the presence of mangled names. The two most popular name mangling schemes are Microsoft’s and the Intel Itanium ABI.<sup><a id="ch20fn11a" href="footnotes.xhtml#ch20fn11">11</a></sup> The Intel standard <span epub:type="pagebreak" id="page_459"/>has been widely adopted by other Unix compilers such as <code>g++</code> and clang. The following shows a C++ function name and the mangled version of that name under both the Microsoft and Intel schemes:</p>
<p class="uln-indent"><strong>Function</strong> <code>void SubClass::vfunc1()</code></p>
<p class="uln-indent"><strong>Microsoft scheme</strong> <code>?vfunc1@SubClass@@UAEXXZ</code></p>
<p class="uln-indent"><strong>Intel scheme</strong> <code>_ZN8SubClass6vfunc1Ev</code></p>
<p class="indenta">Most languages that permit overloading, including Objective-C, Swift, and Rust, incorporate some form of name mangling at the implementation level. A passing familiarity with name-mangling styles can provide you with clues about a program’s original source language as well as the compiler used to build the program.</p>
<h4 class="h4" id="ch20lev379"><strong><em>RTTI Implementations</em></strong></h4>
<p class="noindent">In <a href="ch08.xhtml#ch08">Chapter 8</a>, we discussed C++ Runtime Type Identification (RTTI) and the lack of a standard for implementing RTTI by a compiler. In fact, runtime type identification is not mentioned anywhere in the C++ standard, so it should be no surprise that implementations differ. To support the <code>dynamic_cast</code> operator, RTTI data structures record not only a class’s name, but its entire inheritance hierarchy, including any multiple inheritance relationships. Locating RTTI data structures can be extremely useful in recovering the object model of a program. Automatic recognition of RTTI-related constructs within a binary is another area in which Ghidra’s capabilities vary across compilers.</p>
<p class="indent">Microsoft C++ programs contain no embedded symbol information, but Microsoft’s RTTI data structures are well understood, and Ghidra will locate them when present. Any RTTI-related information Ghidra does locate will be summarized in the Symbol Tree’s <em>Classes</em> folder, which will contain an entry for each class that Ghidra locates using its RTTI analyzer.</p>
<p class="indent">Programs built with <code>g++</code> include symbol table information unless they have been stripped. For unstripped <code>g++</code> binaries, Ghidra relies exclusively on the mangled names it finds in the binary, and it uses those names to identify RTTI-related data structures and the classes they are associated with. As with Microsoft binaries, any RTTI-related information will be included in the Symbol Tree’s <em>Classes</em> folder.</p>
<p class="indent">One strategy for understanding how a specific compiler embeds type information for C++ classes is to write a simple program that uses classes containing virtual functions. After compiling the program, you can load the resulting executable into Ghidra and search for instances of strings that contain the names of classes used in the program. Regardless of the compiler used to build a binary, one thing that RTTI data structures have in common is that they all reference, in some manner, a string containing the mangled name of the class that they represent. Using extracted strings and data cross-references, it should be possible to locate candidate RTTI-related data structures within the binary. The last step is to link a candidate RTTI structure back to the associated class’s vftable, which is best accomplished <span epub:type="pagebreak" id="page_460"/>by following data cross-references backward from the candidate RTTI structure until a table of function pointers (the vftable) is reached. Let’s walk through an example that uses this method.</p>
<h5 class="h5" id="ch20lev380"><strong>Example: Locating RTTI Information in a Linux x86-64 g++ Binary</strong></h5>
<p class="noindent">To demonstrate these concepts, we created a small program with a <code>BaseClass</code>, a <code>SubClass</code>, a <code>SubSubClass</code>, and a collection of virtual functions unique to each. The following listing shows part of the main program we used to reference our classes and functions:</p>
<pre>    BaseClass *bc_ptr_2;<br/>
    srand(time(0));<br/>
    if (rand() % 2) {<br/>
        bc_ptr_2 = dynamic_cast&lt;SubClass*&gt;(new SubClass());<br/>
    }<br/>
    else {<br/>
        bc_ptr_2 = dynamic_cast&lt;SubClass*&gt;(new SubSubClass());<br/>
    }</pre>
<p class="indent">We compiled the program using <code>g++</code> to build a 64-bit Linux binary with symbols. After we analyze the program, the Symbol Tree provides the information shown in <a href="ch20.xhtml#fig20_3">Figure 20-3</a>.</p>
<div class="image"><img src="Images/fig20-3.jpg" alt="image" width="470" height="391"/></div>
<p class="figcap" id="fig20_3"><em>Figure 20-3: Symbol Tree classes for an unstripped binary</em></p>
<p class="indent">The <em>Classes</em> folder contains entries for all three of our classes. The expanded <em>SubClass</em> entry reveals additional information that Ghidra has uncovered about it. The stripped version of the same binary contains a lot less information, as shown in <a href="ch20.xhtml#fig20_4">Figure 20-4</a>.</p>
<span epub:type="pagebreak" id="page_461"/>
<div class="image"><img src="Images/fig20-4.jpg" alt="image" width="453" height="254"/></div>
<p class="figcap" id="fig20_4"><em>Figure 20-4: Symbol Tree classes for a stripped binary</em></p>
<p class="indent">In this case, we might, incorrectly, assume that the binary contains no C++ classes of interest, although it is likely a C++ binary based on the reference to a core C++ class (<code>basic_ostream</code>). Since stripping removes only symbol information, we may still be able to find RTTI information by searching for class names in the program’s strings and walking our way back to any RTTI data structure. A string search yields the results shown in <a href="ch20.xhtml#fig20_5">Figure 20-5</a>.</p>
<div class="image"><img src="Images/fig20-5.jpg" alt="image" width="772" height="240"/></div>
<p class="figcap" id="fig20_5"><em>Figure 20-5: String Search results revealing class names</em></p>
<p class="indent">If we click the <code>"8SubClass"</code> string, we are taken to this portion of the Listing window:</p>
<pre>        s_8SubClass_00101818               XREF[1]:   00301d20(*)<br/>
00101818  ds "8SubClass"</pre>
<p class="indent">In <code>g++</code> binaries, RTTI-related structures contain references to the corresponding class name string. If we follow the cross-reference on the first line to its source, we arrive at the following section of the disassembly listing:</p>
<pre>           PTR___gxx_personality_v0_00301d18  XREF[2]: FUN_00101241:00101316(*)<span class="ent">➊</span>,<br/>
                                                       00301d10(*)<span class="ent">➋</span><br/>
<span class="ent">➌</span> 00301d18  addr   __gxx_personality_v0      = ??<br/>
<span class="ent">➍</span> 00301d20  addr   s_8SubClass_00101818      = "8SubClass"<br/>
   00301d28  addr   PTR_time_00301d30         = 00303028</pre>
<span epub:type="pagebreak" id="page_462"/>
<p class="indent">The source of the cross-reference <span class="ent">➍</span> is the second field within <code>SubClass</code>’s <code>typeinfo</code> structure, which starts at address <code>00301d18</code> <span class="ent">➌</span>. Unfortunately, unless you are willing to dive into the source code for <code>g++</code>, structure layouts like this are just something you need to learn by experience. Our last remaining task is to locate <code>SubClass</code>’s vftable. In this example, if we follow the lone cross-reference to the <code>typeinfo</code> structure that originates from a data region <span class="ent">➋</span> (the other cross-reference <span class="ent">➊</span> originates from a function and can’t possibly be the vftable), we hit a dead end. A little math tells us that the cross-reference originates from the location immediately preceding the <code>typeinfo</code> struct (<code>00301d18</code> – <code>8</code> == <code>00301d10</code>). Under normal circumstances, a cross-reference would exist from the vftable to the <code>typeinfo</code> structure; however, lacking symbols, Ghidra fails to create that reference. Since we know that another pointer to our <code>typeinfo</code> structure must exist somewhere, we can ask Ghidra for help. With the cursor positioned at the start of the structure <span class="ent">➌</span>, we can use the menu option Search ▸ For Direct References, which asks Ghidra to find the current address in memory for us. The results are shown in <a href="ch20.xhtml#fig20_6">Figure 20-6</a>.</p>
<div class="image"><img src="Images/fig20-6.jpg" alt="image" width="694" height="242"/></div>
<p class="figcap" id="fig20_6"><em>Figure 20-6: Results of direct reference search</em></p>
<p class="indent">Ghidra has found two additional references to this <code>typeinfo</code> structure. Investigating each of them finally leads us to a vftable:</p>
<pre><span class="ent">➊</span> 00301c60       ??      18h                 ?<span class="ent">➋</span> -&gt; 00301d18<br/>
  00301c61       ??      1Dh<br/>
  00301c62       ??      30h                 0<br/>
  00301c63       ??      00h<br/>
  00301c64       ??      00h<br/>
  00301c65       ??      00h<br/>
  00301c66       ??      00h<br/>
  00301c67       ??      00h<br/>
          PTR_FUN_00301c68                 XREF[2]: FUN_00101098:001010b0(*),<br/>
                                                    FUN_00101098:001010bb(*)<br/>
<span class="ent">➌</span> 00301c68  addr   FUN_001010ea<br/>
  00301c70  addr   FUN_00100ff0<br/>
  00301c78  addr   FUN_00101122<br/>
  00301c80  addr   FUN_00101060<br/>
  00301c88  addr   FUN_0010115a</pre>
<span epub:type="pagebreak" id="page_463"/>
<p class="indent">Ghidra has not formatted the source <span class="ent">➊</span> of the <code>typeinfo</code> cross-reference as a pointer (which explains the lack of a cross-reference), but it does provide an EOL comment that hints at it being a pointer <span class="ent">➋</span>. The vftable itself begins 8 bytes later <span class="ent">➌</span> and contains five pointers to virtual functions belonging to <code>SubClass</code>. The table contains no mangled names because the binary has been stripped.</p>
<p class="indent">In the next section, we apply this “follow the bread crumbs” analysis technique to help identify the <code>main</code> function in C binaries generated by several compilers.</p>
<h3 class="h3" id="ch20lev381"><strong>Locating the main Function</strong></h3>
<p class="noindent">From a programmer’s perspective, program execution typically begins with the <code>main</code> function, so it’s not a bad strategy to start analyzing a binary from the <code>main</code> function. However, compilers and linkers (and the use of libraries) add code that executes before <code>main</code> is reached. Thus, it’s often inaccurate to assume that the entry point of a binary corresponds to the <code>main</code> function written by the program’s author. In fact, the notion that all programs have a <code>main</code> function is a C/C++ compiler convention rather than a hard-and-fast rule for writing programs. If you have ever written a Windows GUI application, you may be familiar with the <code>WinMain</code> variation on <code>main</code>. Once you step away from C/C++, you may find that other languages use other names for their primary entry-point function. We refer to this function generically as the <code>main</code> function.</p>
<p class="indent">If there is a symbol named <code>main</code> in your binary, you can simply ask Ghidra to take you there, but if you happen to be analyzing a stripped binary, you will be dropped at the file header and have to find <code>main</code> on your own. With a little understanding of how executables operate, and a little experience, this shouldn’t prove too daunting a task.</p>
<p class="indent">All executables must designate an address within the binary as the first instruction to execute after the binary file has been mapped into memory. Ghidra refers to this address as <code>entry</code> or <code>_start</code>, depending on the file type and the availability of symbols. Most executable file formats specify this address within the file’s header region, and Ghidra loaders know exactly how to find it. In an ELF file, the entry point address is specified in a field named <code>e_entry</code>, while PE files contain a field named <code>AddressOfEntryPoint</code>. A compiled C program, regardless of the platform the executable is running on, has code at the entry point, inserted by the compiler, to make the transition from a brand-new process to a running C program. Part of this transition involves ensuring that arguments and environment variables provided to the kernel at process creation are gathered and provided to <code>main</code> utilizing the C calling convention.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Your operating system kernel neither knows nor cares in what language any executable was written. Your kernel knows exactly one way to pass parameters to a new process, and that way may not be compatible with your program’s entry function. It is the compiler’s job to bridge this gap.</em></p>
</div>
<span epub:type="pagebreak" id="page_464"/>
<p class="indent">Now that we know that execution begins at a published entry point and eventually reaches the <code>main</code> function, we can take a look at some compiler-specific code for effecting this transition.</p>
<h4 class="h4" id="ch20lev382"><strong><em>Example 1: _start to main with gcc on Linux x86-64</em></strong></h4>
<p class="noindent">By examining the start code in an unstripped executable, we can learn exactly how <code>main</code> is reached for a given compiler on a given operating system. Linux <code>gcc</code> offers one of the simpler approaches for this:</p>
<pre>     _start<br/>
004003b0  XOR    EBP,EBP<br/>
004003b2  MOV    R9,RDX<br/>
004003b5  POP    RSI<br/>
004003b6  MOV    RDX,RSP<br/>
004003b9  AND    RSP,-0x10<br/>
004003bd  PUSH   RAX<br/>
004003be  PUSH   RSP=&gt;local_10<br/>
004003bf  MOV    R8=&gt;__libc_csu_fini,__libc_csu_fini<br/>
004003c6  MOV    RCX=&gt;__libc_csu_init,__libc_csu_init<br/>
004003cd  MOV    RDI=&gt;main,main<span class="ent">➊</span><br/>
004003d4  CALL<span class="ent">➋</span> qword ptr [-&gt;__libc_start_main]</pre>
<p class="indent">The address of <code>main</code> is loaded into <code>RDI</code> <span class="ent">➊</span> immediately before a call <span class="ent">➋</span> is made to a library function named <code>__libc_start_main</code>, which means that the address of <code>main</code> is passed as the first argument to <code>__libc_start_main</code>. Armed with this knowledge, we can easily locate <code>main</code> in a stripped binary. The following listing shows the lead-up to the call to <code>__libc_start_main</code> in a stripped binary:</p>
<pre>004003bf  MOV    R8=&gt;FUN_004008a0,FUN_004008a0<br/>
004003c6  MOV    RCX=&gt;FUN_00400830,FUN_00400830<br/>
004003cd  MOV    RDI=&gt;FUN_0040080a,FUN_0040080a<span class="ent">➊</span><br/>
004003d4  CALL   qword ptr [-&gt;__libc_start_main]</pre>
<p class="indent">Though the code contains references to three generically named functions, we conclude that <code>FUN_0040080a</code> must be <code>main</code> because it is being passed as the first argument to <code>__libc_start_main</code> <span class="ent">➊</span>.</p>
<h4 class="h4" id="ch20lev383"><strong><em>Example 2: _start to main with clang on FreeBSD x86-64</em></strong></h4>
<p class="noindent">On current versions of FreeBSD, clang is the default C compiler, and the <code>_start</code> function is somewhat more substantial and harder to follow than the simple Linux <code>_start</code> stub. To keep things simple, we’ll use Ghidra’s decompiler to look at the tail end of <code>_start</code>.</p>
<span epub:type="pagebreak" id="page_465"/>
<pre>    //~40 lines of code omitted for brevity<br/>
    atexit((__func *)cleanup);<br/>
    handle_static_init(argc,ap,env);<br/>
    argc = main((ulong)pcVar2 &amp; 0xffffffff,ap,env);<br/>
                    /* WARNING: Subroutine does not return */<br/>
    exit(argc);<br/>
}</pre>
<p class="indent">In this case, <code>main</code> is the penultimate function called in <code>_start</code>, and the return value from <code>main</code> is immediately passed to <code>exit</code> to terminate the program. Using Ghidra’s decompiler on a stripped version of the same binary yields the following listing:</p>
<pre>    // 40 lines of code omitted for brevity<br/>
    atexit(param_2);<br/>
    FUN_00201120(uVar2 &amp; 0xffffffff,ppcVar5,puVar4);<br/>
    __status = FUN_00201a80(uVar2 &amp; 0xffffffff,ppcVar5,puVar4)<span class="ent">➊</span>;<br/>
                    /* WARNING: Subroutine does not return */<br/>
    exit(__status);<br/>
}</pre>
<p class="indent">Once again, we can pick <code>main</code> <span class="ent">➊</span> out of the crowd, even when the binary has been stripped. If you are wondering why this listing shows two function names that have not been stripped, the reason is that this particular binary is dynamically linked. The functions <code>atexit</code> and <code>exit</code> are not symbols in the binary; they are external dependencies. These external dependencies remain, even after stripping, and continue to be visible in the decompiled code. The corresponding code for a statically linked, stripped version of this binary is shown here:</p>
<pre>    FUN_0021cc70();<br/>
    FUN_0021c120(uVar2 &amp; 0xffffffff,ppcVar13,puVar11);<br/>
    uVar7 = FUN_0021caa0(uVar2 &amp; 0xffffffff,ppcVar13,puVar11);<br/>
                    /* WARNING: Subroutine does not return */<br/>
    FUN_00266d30((ulong)uVar7);<br/>
}</pre>
<h4 class="h4" id="ch20lev384"><strong><em>Example 3: _start to main with Microsoft’s C/C++ compiler</em></strong></h4>
<p class="noindent">The Microsoft C/C++ compiler’s startup stub is a bit more complicated because the primary interface to the Windows kernel is via <em>kernel32.dll</em> (rather than <em>libc</em> on most Unix systems), which provides no C library functions. As a result, the compiler often statically links many C library functions directly into executables. The startup stub uses these and other functions to interface with the kernel to set up your C program’s runtime environment.</p>
<p class="indent">However, in the end, the startup stub still needs to call <code>main</code> and exit after it returns. Tracking down <code>main</code> among all of the startup code is usually a matter of identifying a three-argument function (<code>main</code>) whose return value <span epub:type="pagebreak" id="page_466"/>is passed to a one-argument function (<code>exit</code>). The following excerpt from this type of binary contains calls to the two functions we are looking for:</p>
<pre>140001272 CALL   _amsg_exit<span class="ent">➊</span><br/>
140001277 MOV    R8,qword ptr [DAT_14000d310]<br/>
14000127e MOV    qword ptr [DAT_14000d318],R8<br/>
140001285 MOV    RDX,qword ptr [DAT_14000d300]<br/>
14000128c MOV    ECX,dword ptr [DAT_14000d2fc]<br/>
140001292 CALL<span class="ent">➋</span> FUN_140001060<br/>
140001297 MOV    EDI,EAX<br/>
140001299 MOV    dword ptr [RSP + Stack[-0x18]],EAX<br/>
14000129d TEST   EBX,EBX<br/>
14000129f JNZ    LAB_1400012a8<br/>
1400012a1 MOV    ECX,EAX<br/>
1400012a3 CALL<span class="ent">➌</span> FUN_140002b30</pre>
<p class="indent">Here, <code>FUN_140001060</code> <span class="ent">➋</span> is the three-argument function that turns out to be <code>main</code>, and <code>FUN_140002b30</code> <span class="ent">➌</span> is the one-argument <code>exit</code>. Note that Ghidra has been able to recover the name <span class="ent">➊</span> of one of the statically linked functions called by the startup stub because the function matches an FidDb entry. We can use clues provided by any identified symbols to save some time in our search for <code>main</code>.</p>
<h3 class="h3" id="ch20lev385"><strong>Summary</strong></h3>
<p class="noindent">The sheer volume of compiler-specific behaviors is too numerous to cover in a single chapter (or even a single book, for that matter). Among other behaviors, compilers differ in the algorithms they select to implement various high-level constructs and the manner in which they optimize generated code. Because a compiler’s behavior is heavily influenced by the arguments supplied to the compiler during the build process, it is possible for one compiler to generate radically different binaries when fed the same source with different build options selected.</p>
<p class="indent">Unfortunately, coping with all of these variations only comes with experience, and it is often very difficult to search for help on specific assembly language constructs, as it is very difficult to craft search expressions that will yield results applicable to your particular case. When this happens, your best resource is generally a forum dedicated to reverse engineering in which you can post code and benefit from the knowledge of others who have had similar experiences.</p>
</div>



  </body></html>