<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2-h" id="ch06"><span class="color2"><strong>6</strong></span></h2>&#13;
<h2 class="h2-hd"><span epub:type="pagebreak" id="page_101"/><strong>Making Codes, and Cracking Them Too</strong></h2>&#13;
<div class="imagec"><img src="../images/common.jpg" alt="Image" width="167" height="189"/></div>&#13;
<p class="noindent">Say you have a secret that you want to share with a friend. You could write it down and pass them a note, but somebody else might see it. Or you could whisper it to them, but somebody might overhear. Think how much better it would be if anyone else who intercepted your message couldn’t make sense of it. A secret code!</p>&#13;
<p class="indent">In this chapter, we’ll use Scratch to practice <em>cryptography</em>, the art of secret codes. We’ll write programs with a few different cryptographic techniques, consider their strengths and weaknesses, and use them to encode messages. Writing a message in code is only half the job, though. There has to be a way to undo the code, or else <em>nobody</em> will be able to read it, not even the people you want. We’ll look at the other side of the story too, and see how to decode secret messages.</p>&#13;
<h3 class="h3a" id="ch06lev1">Caesar’s Shifty Cipher</h3>&#13;
<p class="noindent">Secret codes are important in military applications because commanders need a way to let soldiers in the field know their battle plans, preferably without revealing them to the enemy if they fall into the wrong hands. The Roman general Julius Caesar is credited with devising one of the earliest known methods of encoding messages, for <span epub:type="pagebreak" id="page_102"/>just this purpose. As the story goes, when communicating with his soldiers Caesar used a simple replacement system in which all the letters in the messages (written in Latin, I suppose) were shifted three places to the right. So if there was an A in the message, it was replaced by a D, each B was replaced by an E, and so on. This approach of creating a coded message by shifting the letters in the alphabet is now known as the <em>Caesar cipher</em>. The shift doesn’t have to be by three; a shift by any number of places will turn a readable message into total gibberish.</p>&#13;
<p class="indent"><em>Cipher</em> is an old-fashioned word for a procedure or a puzzle. It used to be that doing arithmetic was called <em>ciphering</em> because the way numbers get manipulated in big multiplication problems or long division looks like an intricate puzzle. The process of converting a message into a disguised form (<em>encrypting</em>) and recovering the original message from its encrypted form (<em>decrypting</em>) is also like solving a puzzle, so today <em>cipher</em> more commonly refers to a code.</p>&#13;
<p class="indent">The puzzle for the Caesar cipher can be solved with a two-row table. One row shows the alphabet from A to Z, and the other shows the alphabet shifted over by the appropriate number of places:</p>&#13;
<div class="imagec"><img src="../images/pg122_Image_144.jpg" alt="Image" width="599" height="65"/></div>&#13;
<p class="indent">It can help to wrap the rows of the table around in a circle to indicate that when we get to the end of the alphabet, we wrap around to the beginning again. Imagine two circles, with an inner alphabet and an outer alphabet, as shown in <a href="ch06.xhtml#ch6fig1">Figure 6-1</a>.</p>&#13;
<div class="image"><img id="ch6fig1" src="../images/pg122_Image_145.jpg" alt="Image" width="639" height="639"/></div>&#13;
<p class="figcap"><em>Figure 6-1: Shifting around a circle</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_103"/>If the circles can rotate independently, then they can be used to illustrate the Caesar cipher with different shifts. You can make a tool like this and use it to encrypt and decrypt messages by hand, one letter a time. But why do all that work when Scratch can do it for you?</p>&#13;
<h4 class="h4" id="ch06lev2">Project 22: Encryption by a Caesar Shift</h4>&#13;
<p class="noindent">In this project, we’ll use Scratch to automate the process of encrypting a message with the Caesar cipher. First, we’ll put the alphabet into a list, using the custom block shown in <a href="ch06.xhtml#ch6fig2">Figure 6-2</a>. That way, we can work with the letters by using the numbers that index them in the list.</p>&#13;
<div class="image"><img id="ch6fig2" src="../images/pg123_Image_146.jpg" alt="Image" width="548" height="798"/></div>&#13;
<p class="figcap"><em>Figure 6-2: Putting the alphabet in a list</em></p>&#13;
<p class="indent">The custom <code>Alphabet</code> block builds a list called <code>alphabet</code>, adding letters one at a time. If you want, you can extend the alphabet to include other symbols, like maybe spaces, numbers, and punctuation, but for now we’ll keep it to the 26 letters from A to Z.</p>&#13;
<p class="indent">Next, we’ll create a custom block called <code>Initialize</code> to set up the program (see <a href="ch06.xhtml#ch6fig3">Figure 6-3</a>).</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_104"/><img id="ch6fig3" src="../images/pg124_Image_147.jpg" alt="Image" width="417" height="654"/></div>&#13;
<p class="figcap"><em>Figure 6-3: The setup code for the Caesar cipher</em></p>&#13;
<p class="indent">In this block, after we call <code>Alphabet</code>, we define <code>size</code> based on the number of characters in the alphabet chosen. Next, we prompt the user for a shift size and a message to encrypt. We then build a scrambled alphabet based on the chosen shift size using the custom <code>Scramble</code> block, shown in <a href="ch06.xhtml#ch6fig4">Figure 6-4</a>.</p>&#13;
<div class="image"><img id="ch6fig4" src="../images/pg124_Image_148.jpg" alt="Image" width="881" height="527"/></div>&#13;
<p class="figcap"><em>Figure 6-4: Building a scrambled alphabet</em></p>&#13;
<p class="indent">The <code>Scramble</code> block builds a list called <code>scrambled</code> by applying the shift to the original <code>alphabet</code> list, one letter at a time. In theory, the letter at index <code>i</code> in the <code>scrambled</code> <span epub:type="pagebreak" id="page_105"/>list should be the same as the letter at index <code>shift + i</code> in the <code>alphabet</code> list. It’s not quite that simple, though, since at some point we need to wrap back around to the start of the alphabet. The custom <code>Wrap</code> block, also shown in <a href="ch06.xhtml#ch6fig4">Figure 6-4</a>, uses <code>mod</code> to recalculate the index when necessary. Because modular arithmetic expects to start from a minimum value of 0 but Scratch wants lists to be indexed starting with 1, we need to subtract 1 before taking the <code>mod</code>, then add 1 again before using the resulting index.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The scrambling code is broken out into a separate block to make it easy for us to modify the encryption technique in later programs. All we’ll have to do is change how the scrambled encrypting alphabet is constructed.</em></p>&#13;
</div>&#13;
<p class="indent"><a href="ch06.xhtml#ch6fig5">Figure 6-5</a> shows the main program stack.</p>&#13;
<div class="image"><img id="ch6fig5" src="../images/pg125_Image_149.jpg" alt="Image" width="762" height="797"/></div>&#13;
<p class="figcap"><em>Figure 6-5: The main code for the Caesar cipher</em></p>&#13;
<p class="indent">After calling <code>Initialize</code>, we loop through the provided message one character at a time. The <code>if...else</code> block checks if the current message character is included in <code>alphabet</code>. If it is, the program looks up the equivalent shifted character and joins it to the encoded message in the <code>encrypted</code> variable. If the character isn’t in the alphabet—for example, if it’s a space or punctuation mark—then the program just passes that character through to the encoded message unchanged.</p>&#13;
<h5 class="h5" id="ch06lev3"><span epub:type="pagebreak" id="page_106"/>The Results</h5>&#13;
<p class="noindent"><a href="ch06.xhtml#ch6fig6">Figure 6-6</a> shows the results of two sample runs of the program.</p>&#13;
<div class="image"><img id="ch6fig6" src="../images/pg126_Image_150.jpg" alt="Image" width="469" height="149"/></div>&#13;
<p class="figcap"><em>Figure 6-6: Encrypting and decrypting a message</em></p>&#13;
<p class="indent">On the left, we’ve specified a shift of 3 to encode the message “hello!” Scratch keeps track of its characters in uppercase, so when each letter is advanced by 3 we get the encrypted message “KHOOR!” The way we wrote the program, the punctuation doesn’t change.</p>&#13;
<p class="indent">A convenient feature of this program (and of the Caesar cipher itself) is that it can be used to decrypt as well as encrypt. The output on the right shows how we can take the encoded message “KHOOR!” and shift it by 23 to recover our original message of “HELLO!” (now in all caps). Since the alphabet size was 26, an additional shift of 23 after the initial shift of 3 gets us back to 26, which is no shift at all. It would also have worked to enter the second shift as –3 instead of 23 because modulo 26 we get to the same place by going 3 steps backward or 23 steps forward.</p>&#13;
<h5 class="h5" id="ch06lev4">Hacking the Code</h5>&#13;
<p class="noindent">Because non-alphabet characters aren’t encrypted, our code preserves the spaces between words, even as the words themselves are scrambled. This can sometimes be a giveaway, providing clues about the contents of the original message: a one-letter word, for example, is likely <em>a</em> or <em>I</em>, and <em>the</em> and <em>and</em> are some of the most common three-letter words. Including a space character in the alphabet will help disguise such clues in the encrypted message by making the original word breaks less obvious. (In addition, some encryption techniques are more effective if the alphabet size is a prime number; this is another reason why adding a space and a couple of other punctuation characters to the alphabet may be a good idea!)</p>&#13;
<p class="indent">Fortunately, we’ve written the code in such a way that it works no matter the length of the alphabet, so adding extra characters is easy. The modular arithmetic needed to wrap back around to the start of the alphabet relies on the <code>size</code> variable, which is set based on the length of the <code>Alphabet</code> list at the start of the program. This way, the modulus will be adjusted automatically if the alphabet changes.</p>&#13;
<p class="indent">Here’s another possible improvement: after a few encryptions and decryptions, you may find that you’d like to have a history of the work that Scratch has done. It’s easy to add a <em>log</em> to hold a record of all of the program’s input and output in one place. All you need to do is define a list called <code>log</code>, then add a few blocks (shown in <a href="ch06.xhtml#ch6fig7">Figure 6-7</a>) to the program to write data to the list. Since the contents of a list can be saved to a file, keeping this log makes it easy to copy the encoded messages into another program, such as a text editor or email client, or back into the input field in the Scratch program for further processing.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_107"/><img id="ch6fig7" src="../images/pg127_Image_151.jpg" alt="Image" width="374" height="494"/></div>&#13;
<p class="figcap"><em>Figure 6-7: Adding a logfile</em></p>&#13;
<p class="indent">To create a logfile, add the first two block stacks shown in <a href="ch06.xhtml#ch6fig7">Figure 6-7</a>, logging the values of <code>shift</code> and <code>message</code>, to the end of the <code>Initialize</code> block (<a href="ch06.xhtml#ch6fig3">Figure 6-3</a>). Then, add the third stack, logging the encrypted message, to the end of the main program stack (<a href="ch06.xhtml#ch6fig5">Figure 6-5</a>). The last stack in <a href="ch06.xhtml#ch6fig7">Figure 6-7</a> erases the log when you press the down arrow key. You can use this feature to cover your tracks, or to reset the log if it starts to get too long.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch6fig8">Figure 6-8</a> shows what the log looks like when we decrypt “KHOOR!” by shifting by –3 instead of 23.</p>&#13;
<div class="image"><img id="ch6fig8" src="../images/pg127_Image_152.jpg" alt="Image" width="743" height="553"/></div>&#13;
<p class="figcap"><em>Figure 6-8: Another decryption of “HELLO!”</em></p>&#13;
<p class="indent">Because the <code>log</code> list resets only when you press the down arrow key, it will continue to store values over multiple runs of the program, even as the values of <code>shift</code>, <code>message</code>, and <code>encrypted</code> are overwritten.</p>&#13;
<h4 class="h4" id="ch06lev5"><span epub:type="pagebreak" id="page_108"/>Project 23: Cracking the Caesar Cipher</h4>&#13;
<p class="noindent">Caesar’s cipher was effective in its time, perhaps because most people couldn’t read that well anyway. But in truth, it isn’t a very secure method of encryption. If you have a message and you know it’s been encrypted by shifting, all you have to do is pass the message through every possible shift factor, and one of them will give you the decrypted text. The number of possible shifts is only the size of the alphabet—in this case, 26. As we’ll see in this project, Scratch can work through all the possibilities almost instantaneously.</p>&#13;
<p class="indent">To create a program for automatically decrypting messages encrypted with a Caesar shift, keep the supporting blocks from the previous project, but modify the main <code>when clicked</code> program stack as shown in <a href="ch06.xhtml#ch6fig9">Figure 6-9</a>. This updated code will produce a list applying all possible shifts to the encrypted message. When you scroll through the list, the appropriate shift and decoding should jump right out at you.</p>&#13;
<div class="image"><img id="ch6fig9" src="../images/pg128_Image_153.jpg" alt="Image" width="761" height="1055"/></div>&#13;
<p class="figcap"><em>Figure 6-9: Making all possible shifts</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_109"/>We start with an initial <code>shift</code> of <code>1</code> <span class="ent">❶</span> and use a loop to gradually shift through the entire alphabet. Then, we use an inner loop to cycle through the letters of the message and decode them using the current shift factor. At the end of the inner loop, we have a possible decrypted message, which we add to the <code>Shifts</code> list. As in the previous project, we use an <code>if ... else</code> block to pass characters through unchanged if they aren’t in the alphabet <span class="ent">➋</span>.</p>&#13;
<div class="image"><img id="ch6fig10" src="../images/pg129_Image_154.jpg" alt="Image" width="442" height="548"/></div>&#13;
<p class="figcap"><em>Figure 6-10: Initializing the cracking program</em></p>&#13;
<p class="indent">We also need to modify the <code>Initialize</code> block from the previous project, as shown in <a href="ch06.xhtml#ch6fig10">Figure 6-10</a>.</p>&#13;
<p class="indent">This updated <code>Initialize</code> block manages the <code>Shifts</code> list by deleting its previous contents <span class="ent">❶</span>. We still prompt for a message, but we no longer have to bother with prompting for a shift, since the code generates all possible shifts anyway.</p>&#13;
<h5 class="h5" id="ch06lev6">The Results</h5>&#13;
<p class="noindent">Suppose you intercept the message “UVA CLYF DLSS OPKKLU, DHZ PA?” Plug it into the decrypting program (you can copy-paste it or enter it by hand) to discover the message in <a href="ch06.xhtml#ch6fig11">Figure 6-11</a>.</p>&#13;
<p class="indent">The decrypted message is in line 19 of the <code>Shifts</code> list, which tells us that a shift of 19 was needed to recover the message. So the original message must have been encrypted with a shift of 26 – 19 = 7. With a shift of 7, N becomes U, O becomes V, T becomes A (after wrapping), and so on.</p>&#13;
<div class="image"><img id="ch6fig11" src="../images/pg129_Image_155.jpg" alt="Image" width="740" height="544"/></div>&#13;
<p class="figcap"><em>Figure 6-11: Uncovering a shifted message</em></p>&#13;
<div class="side-b">&#13;
<p class="centerb"><span epub:type="pagebreak" id="page_110"/><img class="middle" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenges</p>&#13;
<p class="indentib"><span class="blue"><strong>6.1</strong></span> Use the graphics in Scratch to design a magic decoder ring using a Caesar cipher. The program should animate a ring like the one in <a href="ch06.xhtml#ch6fig1">Figure 6-1</a> so that shifted letters line up with the corresponding unshifted letters.</p>&#13;
<p class="indentib"><span class="blue"><strong>6.2</strong></span> In the movie <em>2001: A Space Odyssey</em>, the sentient computer HAL controlling a spaceship carrying two astronauts on a mission to Jupiter attempts to murder the crew. Apply a Caesar shift of 1 to “HAL” to see if there might be a secret message there about who built him.</p>&#13;
<p class="indentib"><span class="blue"><strong>6.3</strong></span> A Caesar shift can translate between different languages, if you’re lucky! Apply a shift of 16 to “yes” to translate it into French.</p>&#13;
<p class="indentib"><span class="blue"><strong>6.4</strong></span> Find the Caesar shift to decrypt the message “DROBO GSVV LO K RYD DSWO SX DRO YVN DYGX DYXSQRD!”</p>&#13;
</div>&#13;
<h3 class="h3" id="ch06lev7">More Substitution Ciphers</h3>&#13;
<p class="noindent">The Caesar cipher is an example of a <em>substitution cipher</em>, where each letter of the alphabet is substituted for some other letter of the alphabet. In effect, a substitution cipher scrambles the alphabet, making once-readable words look unfamiliar. With the Caesar cipher, we do the scrambling by shifting all the letters by a set number of positions, but any other scrambling technique would work just as well for encrypting a text. In fact, a nice thing about our original Caesar cipher program is that its main stack (the code in <a href="ch06.xhtml#ch6fig5">Figure 6-5</a>) can work with any scrambled alphabet, not just one generated through shifting. We can modify the <code>Scramble</code> block (<a href="ch06.xhtml#ch6fig4">Figure 6-4</a>) to build the <code>scrambled</code> list in some other way, and the program will encode messages accordingly.</p>&#13;
<p class="indent">If we don’t limit ourselves to shifts, how many possibilities for scrambling are there? Well, we have 26 choices for what the letter A becomes, then 25 choices for what B becomes, 24 choices for C, and so on. In all, that gives us 26! (26 factorial) permutations, or over 400 septillion (4 ⋅ 10<sup>26</sup>) ways to scramble the alphabet. The Caesar cipher considers only 25 of these permutations (assuming you don’t want to use a shift of 0).</p>&#13;
<p class="indent">The advantage of the Caesar cipher is that it takes only one number, the shift factor, to determine the scrambled alphabet. In other words, if you want to give a friend the key for decoding your shifted messages, all you have to do is whisper that one number to them. Encryption is essentially an addition by the shift factor, and decryption involves undoing the addition. You can undo a shift of <em>s</em> by subtracting <em>s</em> or by adding 26 – <em>s</em>. By contrast, to let your friend in on some other <span epub:type="pagebreak" id="page_111"/>scrambling scheme (perhaps chosen randomly from the 26! possible permutations), you’d need to provide 25 separate pieces of information before they’d know how to decode your messages. You’d have to say what each letter from A to Y becomes, after which Z has to go in the only slot left. That’s a lot of extra information to keep track of!</p>&#13;
<h4 class="h4o" id="ch06lev8">Encryption by Modular Multiplication</h4>&#13;
<p class="noindent">Here’s a different idea. The Caesar cipher scrambles the alphabet by shifting, which can be thought of as addition modulo 26. What if we scramble the alphabet by <em>multiplication</em> modulo 26 rather than addition? That is, we can take each letter’s position in the alphabet and multiply it by some number modulo 26 to get the position of the letter it should be replaced with. To get us started, <a href="ch06.xhtml#ch6fig12">Figure 6-12</a> shows an operation table for mod 26 multiplication. (You can generate this table yourself using the code from <a href="ch05.xhtml#ch05lev13">Project 21</a> in <a href="ch05.xhtml#ch05">Chapter 5</a>.)</p>&#13;
<div class="image"><img id="ch6fig12" src="../images/pg131_Image_156.jpg" alt="Image" width="1013" height="480"/></div>&#13;
<p class="figcap"><em>Figure 6-12: Multiplication mod 26</em></p>&#13;
<p class="indent">This table gives all possible products of two numbers modulo 26. For example, to multiply 9 by 5, look at row 9 and column 5. The entry where they intersect is 19, so 9 ⋅ 5 is 19 mod 26. That makes sense, since we know that 9 ⋅ 5 is “really” 45, and 45 leaves a remainder of 19 when it’s divided by 26.</p>&#13;
<p class="indent">For a row (or column) of this table to lead to a successful scrambling of the alphabet, it needs to include every number from 0 to 25—that is, it must be a permutation (or reordering) of the table’s index. Not every row works. For example, row 4 begins (0, 4, 8, . . .) and starts repeating itself at column 13. Meanwhile, the values in row 13 simply alternate back and forth between 0 and 13, which would turn all the letters in a message into either As or Ns. Not very useful!</p>&#13;
<p class="indent">The usable rows (and columns) are the ones indexed by numbers that are relatively prime to 26, meaning they share no common factors with 26 other than 1. There are 12 of them: rows 1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, and 25. These rows all <span epub:type="pagebreak" id="page_112"/>contain permutations of the numbers between 0 and 25. For example, multiplying the letters of the alphabet by 3 mod 26 would give the following cipher:</p>&#13;
<div class="imagec"><img src="../images/pg132_Image_157.jpg" alt="Image" width="599" height="65"/></div>&#13;
<p class="noindent">You could build the scrambled row by counting ahead by three letters each time (A B <strong>C</strong>, D E <strong>F</strong>, G H <strong>I</strong>, . . .), wrapping around at Z to begin again, until the entire alphabet has been assigned.</p>&#13;
<p class="indent">To implement a multiplication-based cipher using our code from <a href="ch06.xhtml#ch06lev2">Project 22</a>, all we have to do is make one small change to our <code>Scramble</code> block from earlier, as illustrated in <a href="ch06.xhtml#ch6fig13">Figure 6-13</a>.</p>&#13;
<div class="image"><img id="ch6fig13" src="../images/pg132_Image_158.jpg" alt="Image" width="545" height="75"/></div>&#13;
<p class="figcap"><em>Figure 6-13: Multiply, don’t add!</em></p>&#13;
<p class="indent">By changing <code>+</code> to <code>*</code>, we tell the program to encrypt messages using modular multiplication rather than modular addition.</p>&#13;
<h4 class="h4o" id="ch06lev9">Decryption by Modular Multiplication</h4>&#13;
<p class="noindent">Now let’s consider decrypting. We decrypted a Caesar shift by undoing the addition. To undo a shift of 3 letters to the right, for example, we shifted 3 letters to the left (or 26 – 3 = 23 more to the right, since the arithmetic is mod 26). To undo a multiplication by 3, we need to divide by 3, but there’s no room for fractions or decimal places in modular arithmetic. If the original modular multiplication by 3 gave a result of 14, we can’t turn around and divide by 3 to say we want letter 4.66 of the alphabet.</p>&#13;
<p class="indent">Fortunately, there’s still a way to undo the multiplication. We have to find the modular inverse of the multiplier and use that as the decryption key. The <em>modular inverse</em> is the multiplicative inverse, where the multiplication is interpreted using modular arithmetic. Given a modulus <em>m</em>—in this case, 26—multiplying a number by its modular inverse yields 1 mod <em>m</em>. For example, notice in the multiplication table in <a href="ch06.xhtml#ch6fig12">Figure 6-12</a> that there’s a 1 in row 3, located at column 9. This tells us that 9 is the modular inverse of 3 mod 26. To prove it, check the math: 3 ⋅ 9 = 27, and 27 mod 26 = 1.</p>&#13;
<p class="indent">If you’re used to arithmetic giving a multiplicative inverse as a fraction, it may seem strange to see a multiplicative inverse that’s an integer, let alone an integer that’s greater than the original number. Shouldn’t the multiplicative inverse be something small? After all, in ordinary arithmetic the multiplicative inverse of 3 is 1/3, since 3 ⋅ 1/3 is 1. All that matters for an inverse, though, is that the product is 1. With ordinary arithmetic, you get 1 by multiplying <em>n</em> by 1/<em>n</em>. With modular arithmetic, you get 1 by multiplying <em>n</em> by some other integer.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_113"/>Since 9 is the multiplicative inverse of 3 mod 26, we can use a multiplier of 9 to decrypt a message that was encrypted with a multiplier of 3. The log shown in <a href="ch06.xhtml#ch6fig14">Figure 6-14</a> confirms this.</p>&#13;
<div class="image"><img id="ch6fig14" src="../images/pg133_Image_159.jpg" alt="Image" width="775" height="507"/></div>&#13;
<p class="figcap"><em>Figure 6-14: Uncovering a multiplied message</em></p>&#13;
<p class="indent">First, we use a multiplier of 3 to encrypt the message “Hello!” Then, we use 9, the modular inverse of 3 mod 26, to “encrypt” the result, which restores the original message.</p>&#13;
<h4 class="h4" id="ch06lev10">Project 24: The Modular Inverse Is the Key</h4>&#13;
<p class="noindent">We’ve established that to recover a message encrypted through modular multiplication, we need the modular inverse. In this project, we’ll look at how to find a modular inverse to aid in the decryption process.</p>&#13;
<p class="indent">One way to find a modular inverse is to just look for it: study the operation table for multiplication mod <code>alphabet size</code> and see what multiple of <em>m</em> gives the answer 1. That multiple is the modular inverse. That’s the approach we took in the last section, examining the mod 26 multiplication table in <a href="ch06.xhtml#ch6fig12">Figure 6-12</a> to determine that the modular inverse of 3 is 9. Now let’s automate that process with Scratch so we can easily find the modular inverse for any number and any modulus. <a href="ch06.xhtml#ch6fig15">Figure 6-15</a> shows how.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_114"/><img id="ch6fig15" src="../images/pg134_Image_160.jpg" alt="Image" width="773" height="1137"/></div>&#13;
<p class="figcap"><em>Figure 6-15: Finding a modular inverse</em></p>&#13;
<p class="indent">The program first prompts for a modulus and a number to invert. These two values must be relatively prime in order for the number to have a modular inverse. We test for this using the custom <code>gcd</code> block we built for <a href="ch02.xhtml#ch02lev14">Project 9</a> back in <a href="ch02.xhtml#ch02">Chapter 2</a> (see <a href="ch02.xhtml#ch2fig17">Figure 2-17</a> <a href="ch02.xhtml#page_38">page 38</a>). If the GCD is <code>1</code>, the values are relatively prime, so we use a loop to test every possible inverse, starting from <code>1</code>, until we find the one where <code>x * inverse mod modulus = 1</code> <span class="ent">❶</span>. This is the programmatic equivalent of scanning a row of the operation table until we find the column with a 1 in it.</p>&#13;
<h5 class="h5" id="ch06lev11"><span epub:type="pagebreak" id="page_115"/>The Results</h5>&#13;
<p class="noindent"><a href="ch06.xhtml#ch6fig16">Figure 6-16</a> shows some output demonstrating how the code works.</p>&#13;
<div class="image"><img id="ch6fig16" src="../images/pg135_Image_161.jpg" alt="Image" width="777" height="471"/></div>&#13;
<p class="figcap"><em>Figure 6-16: Modular inverse calculations</em></p>&#13;
<p class="indent">The program confirms that 9 is the inverse of 3 mod 26. It also correctly concludes that 4 mod 26 has no modular inverse, since 4 and 26 aren’t relatively prime.</p>&#13;
<h5 class="h5" id="ch06lev12">Hacking the Code</h5>&#13;
<p class="noindent">The trial-and-error approach in our modular inverse program isn’t bad for a small alphabet (and, by extension, a small modulus), but it would be better to have a more focused algorithm to quickly calculate the modular inverse of any number for any modulus. As with the <code>gcd</code> block, we can reuse part of a program we wrote earlier for this: the calculation of the greatest common divisor via Euclid’s algorithm from <a href="ch02.xhtml#ch02lev14">Project 9</a> in <a href="ch02.xhtml#ch02">Chapter 2</a>.</p>&#13;
<p class="indent">Remember that Euclid’s algorithm worked to calculate the GCD <em>d</em> of two given numbers <em>b</em> and <em>a</em> with a sequence of divisions, ending with the GCD as the last nonzero remainder. To use this algorithm to find a modular inverse, set <em>b</em> to the modulus and <em>a</em> to the number whose inverse you want to find. Work through the algorithm as usual, keeping track of the arithmetic of the divisions. Then, step through it backward, looking for an equation that puts 1 on one side and both <em>a</em> and <em>b</em> on the other.</p>&#13;
<p class="indent">For example, if we wanted to find the modular inverse of 3 mod 26, we could first pass those numbers through Euclid’s algorithm:</p>&#13;
<div class="imagec"><img src="../images/pg135_Image_162.jpg" alt="Image" width="193" height="105"/></div>&#13;
<p class="noindent">The last nonzero remainder, 1, is the GCD. Next, we need to unwind the steps to find a combination of 26 and 3 that equals 1. Rewriting the middle equation in the algorithm, we get 1 = 3 – 2. Rewriting the top equation in the algorithm, we get 2 = 26 – 8 ⋅ 3. Then, substituting 26 – 8 ⋅ 3 for the 2 in the middle equation, we get <span epub:type="pagebreak" id="page_116"/>1 = 3 – (26 – 8 ⋅ 3). Overall, the right side of this equation has one 3 and then eight more 3s in the parentheses, so 1 + 8 = 9 of them in all, along with –1 ⋅ 26. We can combine the pieces to see 1 = 9 ⋅ 3 – 26. This tells us that 1 = 9 ⋅ 3 mod 26, so 9 is the modular inverse of 3. There’s a programming challenge coming up to make this approach work in general.</p>&#13;
<h3 class="h3" id="ch06lev13">More Encryption Options with Linear Transformations</h3>&#13;
<p class="noindent">You might think we haven’t gained much by switching from modular addition to modular multiplication. After all, for an alphabet of size 26 there were 26 possible shifted alphabets, and there are only 12 possible multiplied alphabets. However, we can get a much bigger set of scrambled alphabets by combining both approaches: multiply <em>and</em> shift. That is, we can apply any of the 26 possible shifts to each of the 12 scrambled alphabets obtained through multiplication, giving us 26 ⋅ 12 = 312 potential alphabets. That’s many more possibilities to hide a message.</p>&#13;
<p class="indent">The general rule for this combined approach is that we scramble the alphabet by replacing the letter whose index is <em>i</em> with the letter whose index is <em>m</em> ⋅ <em>i</em> + <em>s</em>. In other words, we multiply the index by <em>m</em>, then add a constant <em>s</em>. If we picked values for <em>m</em> and <em>s</em> and graphed the results of this formula for every value of <em>i</em>, we’d find that the graph shows a straight line with a slope of <em>m</em>. For example, say we set <em>m</em> to 2 and <em>s</em> to 3. If we graph the function 2<em>i</em> + 3, the line passes through the points (0, 3), (1, 5), (2, 7), (3, 9), (4, 11), (5, 13), and (6, 15), as shown in <a href="ch06.xhtml#ch6fig17">Figure 6-17</a>.</p>&#13;
<div class="image"><img id="ch6fig17" src="../images/pg136_Image_163.jpg" alt="Image" width="453" height="703"/></div>&#13;
<p class="figcap"><em>Figure 6-17: A graph of 2</em>i <em>+ 3</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_117"/>Because they produce straight lines, “multiply plus a constant” formulas like <em>m</em> ⋅ <em>i</em> + <em>s</em> are known as <em>linear functions</em>. By extension, a “multiply and shift” encryption process is called a <em>linear transformation</em>. As long as the multiplier <em>m</em> is chosen to be relatively prime to the alphabet size, the encryption will work.</p>&#13;
<h4 class="h4" id="ch06lev14">Project 25: Encryption by a Linear Transformation</h4>&#13;
<p class="noindent">Let’s adapt our Caesar cipher code from <a href="ch06.xhtml#ch06lev2">Project 22</a> to handle linear transformations. First, we’ll update the <code>Initialize</code> block as shown in <a href="ch06.xhtml#ch6fig18">Figure 6-18</a>.</p>&#13;
<div class="image"><img id="ch6fig18" src="../images/pg137_Image_164.jpg" alt="Image" width="425" height="972"/></div>&#13;
<p class="figcap"><em>Figure 6-18: Linear transformation encryption</em></p>&#13;
<p class="indent">We now prompt for both a shift and a multiplier, instead of just a shift like before. Notice also the extra code to maintain the <code>log</code> list. Next, we’ll modify the <code>Scramble</code> block to match <a href="ch06.xhtml#ch6fig19">Figure 6-19</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_118"/><img id="ch6fig19" src="../images/pg138_Image_165.jpg" alt="Image" width="565" height="504"/></div>&#13;
<p class="figcap"><em>Figure 6-19: Wrapping with a linear transformation</em></p>&#13;
<p class="indent">This updated <code>Scramble</code> block still uses the original <code>Wrap</code> block from <a href="ch06.xhtml#ch6fig4">Figure 6-4</a>. The input to <code>Wrap</code> implements the <em>m</em> ⋅ <em>i</em> + <em>s</em> linear function to scramble the alphabet.</p>&#13;
<h5 class="h5" id="ch06lev15">The Results</h5>&#13;
<p class="noindent"><a href="ch06.xhtml#ch6fig20">Figure 6-20</a> shows an example of the linear transformation program in action. It encrypts the message “TOP SECRET!” using a multiplier of 3 and a shift of 5.</p>&#13;
<div class="image"><img id="ch6fig20" src="../images/pg138_Image_166.jpg" alt="Image" width="389" height="161"/></div>&#13;
<p class="figcap"><em>Figure 6-20: Encrypting with a linear transformation</em></p>&#13;
<p class="indent">To decrypt the resulting message, we need to undo both the shift and the multiplication. Undoing the shift is easy: for an original shift of <em>s</em>, we instead perform a shift of –<em>s</em>. And as we’ve discussed, to undo a multiplication by <em>m</em>, we can multiply by the modular inverse of <em>m</em>. We’ll perform these operations separately, by running the encrypted message through the linear transformation program twice: once for the shift and once for the multiplication.</p>&#13;
<p class="indent">First, we undo the shift of 5 with a shift of –5, as shown in <a href="ch06.xhtml#ch6fig21">Figure 6-21</a>. We use a multiplier of 1, meaning we’re effectively doing no multiplication at all.</p>&#13;
<div class="image"><img id="ch6fig21" src="../images/pg138_Image_167.jpg" alt="Image" width="383" height="170"/></div>&#13;
<p class="figcap"><em>Figure 6-21: Undoing the shift</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_119"/>Next, we need to take the result and feed it back into the linear transformation program to undo the multiplication. We know that the modular inverse of 3 mod 26 is 9, so that’s the multiplier we use in <a href="ch06.xhtml#ch6fig22">Figure 6-22</a>. This time, we use a shift of 0 to focus just on reversing the multiplication. The result is the original message.</p>&#13;
<div class="image"><img id="ch6fig22" src="../images/pg139_Image_168.jpg" alt="Image" width="391" height="162"/></div>&#13;
<p class="figcap"><em>Figure 6-22: Undoing the multiplication</em></p>&#13;
<p class="indent">In all, only two numbers determine an encryption by linear transformation: the shift and the multiplier. Likewise, only two numbers are needed to decrypt the message. It’s a pretty compact secret key!</p>&#13;
<div class="side-b">&#13;
<p class="centerb"><img class="inline" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenges</p>&#13;
<p class="indentib"><span class="blue"><strong>6.5</strong></span> You’ve seen how to decrypt a linear transformation cipher in two separate steps, first undoing the shift and then undoing the multiplication. Is it possible to combine these into a single step? For example, could you decrypt the message MXA JTNGTM!” from <a href="ch06.xhtml#ch6fig20">Figure 6-20</a> by running the linear transformation program once, with a shift of –5 and a multiplier of 9? As it turns out, this won’t work, but there’s a different shift factor that will. Think about what it could be, and why.</p>&#13;
<p class="indentib"><span class="blue"><strong>6.6</strong></span> Use what you’ve learned from Challenge 6.5 to write a Scratch program that takes in a multiplier and shift for a linear transformation encryption and calculates the modular inverse and appropriate shift to perform the decryption in one step.</p>&#13;
<p class="indentib"><span class="blue"><strong>6.7</strong></span> What goes wrong in a linear transformation encryption if the multiplier isn’t relatively prime to the alphabet size?</p>&#13;
<p class="indentib"><span class="blue"><strong>6.8</strong></span> Modify the <a href="ch06.xhtml#ch06lev5">Project 23</a> code for cracking a Caesar shift (<a href="ch06.xhtml#ch6fig9">Figure 6-9</a>) so the program lists all possible decryptions for all 312 possible linear transformation ciphers.</p>&#13;
<p class="indentib"><span class="blue"><strong>6.9</strong></span> Any permutation or scrambling of the alphabet can be the key for a substitution cipher. Write a Scratch program that will generate a random scrambling of the alphabet. The <code>pick random</code> operator block might come in handy for this.</p>&#13;
<p class="indentib1"><span epub:type="pagebreak" id="page_120"/><span class="blue"><strong>6.10</strong></span> Write a program to calculate modular inverses using Euclid’s algorithm, as discussed in “Hacking the Code” on <a href="ch06.xhtml#ch06lev12">page 115</a>. You’ll probably want to keep track of quotients and remainders as lists and work your way backward up the lists to unwind the steps.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch06lev16">Unbreakable One-Time Pad Ciphers</h3>&#13;
<p class="noindent">A <em>one-time pad cipher</em> is a technique that uses one text (the key) to encrypt or decrypt another text (the message). The encryption takes the first character of the message and shifts it by the position of the first character in the key. It then shifts the second character by the position of the second character in the key, and so on. Every character in the message uses its own encryption scheme, with the alphabet essentially being rescrambled for each letter.</p>&#13;
<p class="indent">To illustrate, let’s say we want to encrypt the message “Hello” using the word “Scratch” as a key. (The key should always be at least as long as, if not longer than, the message.) The first letter of the key, S, is the 19th letter of the alphabet, so we should shift the first letter in the message, H, by 19 positions, yielding the letter A (after wrapping around at Z). The second letter of the key, C, is the third letter of the alphabet, so we should shift the second letter of the message, E, by 3 positions, yielding the letter H. If we keep going like this, we’ll end up with “AHDMI” as the coded message. Using the key to do the shifts in reverse decrypts the message.</p>&#13;
<p class="indent">Typically, one-time pads are used to share longer coded messages, using correspondingly longer keys. The key might be a literal notepad, with a long handwritten sequence of random letters determining the shifts to be used. Or it could be any other text that the sender and recipient of the message agree to share, such as the lyrics of a song, a passage in a book, or an article posted on the internet. The important thing is to keep the key a secret.</p>&#13;
<p class="indent">One-time pads are much stronger codes than the simpler ciphers we discussed earlier in the chapter. In fact, if you use a truly random sequence of characters for the key and you never use the same key twice (hence <em>one-time</em> pad), your coded messages will be impossible to crack. The same cannot be said about any secret code based on a fixed permutation of the alphabet, whether it’s a Caesar cipher, a linear transformation, or any other scrambling algorithm. This is because, as mentioned earlier, the English language has patterns and regularities in it that provide clues about the message.</p>&#13;
<p class="indent">Even if we remove the spaces between words to conceal obvious giveaways like one-letter words (almost certain <em>I</em> or <em>a</em>) and recurring three-letter words (quite possibly <em>the</em> or <em>and</em>), there are other patterns that can shine through in a scrambled alphabet. For example, only certain letters commonly appear twice in a row in English: there are plenty of words with double Es, Ss, and Ts, far fewer with double As or double Zs, and virtually none with double Qs or double Js. Two-letter sequences like TH and CK are also common.</p>&#13;
<p class="indent">More broadly, letters like E and A occur much more often in a given English text than letters like Q and Z, so counting the <em>frequency</em>, meaning the number of <span epub:type="pagebreak" id="page_121"/>occurrences, of each letter in an encrypted message—especially a long message—can give a good clue about the encryption scheme. To prove it, we’ll write a program to calculate letter frequencies and test it on a text encrypted with a Caesar shift. Then we’ll write a program to implement a one-time pad cipher and test its result as well. We should see that the one-time pad cipher eliminates any regular patterns.</p>&#13;
<h4 class="h4" id="ch06lev17">Project 26: Frequency Analysis for Cracking Codes</h4>&#13;
<p class="noindent">The goal for this project is to create a program that counts how many times each letter is used in an encrypted message, potentially providing clues about the encryption scheme based on how many times different letters are used in a typical unencrypted English text. We’ll need to take advantage of Scratch’s text processing capabilities for this. In particular, we’ll use the green <code>length of</code> and <code>letter of</code> blocks together in a loop to examine a text one character at a time. <a href="ch06.xhtml#ch6fig23">Figure 6-23</a> shows the program.</p>&#13;
<div class="image"><img id="ch6fig23" src="../images/pg141_Image_169.jpg" alt="Image" width="822" height="930"/></div>&#13;
<p class="figcap"><em>Figure 6-23: Counting how many times each letter is used</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_122"/>We use two separate lists: <code>alphabet</code>, which is built up at the start of the program with the same <code>Alphabet</code> block first defined in <a href="ch06.xhtml#ch6fig2">Figure 6-2</a>, and <code>frequency</code>, where we store the number of occurrences of each letter of the alphabet. To begin, we fill <code>frequency</code> with 26 0s. Then we take in a text to process from the user and loop through it one character at a time. The <code>item # of letter i of text in alphabet</code> does a reverse lookup of the <em>i</em>th character of the text in <code>alphabet</code>. For example, if the character is C, this will give us <code>3</code>, C’s position in the <code>alphabet</code> list. We add <code>1</code> to the entry at the same position in the <code>frequency</code> list to count that character <span class="ent">❶</span>.</p>&#13;
<h5 class="h5" id="ch06lev18">Hacking the Code</h5>&#13;
<p class="noindent">The code in <a href="ch06.xhtml#ch6fig24">Figure 6-24</a> is a nice little addition to the program that adds labels to the <code>frequency</code> list. Place it at the end, after the <code>repeat</code> loop.</p>&#13;
<div class="image"><img id="ch6fig24" src="../images/pg142_Image_170.jpg" alt="Image" width="1021" height="253"/></div>&#13;
<p class="figcap"><em>Figure 6-24: Adding a label to each entry in the</em> <span class="codeitalic">frequency</span> <em>list</em></p>&#13;
<p class="indent">After all the counting is done, this extra code labels each entry in the <code>frequency</code> list with the letter of the alphabet it represents. This way, you won’t have to remind yourself that letter A is 1, letter B is 2, and so on.</p>&#13;
<h5 class="h5" id="ch06lev19">The Results</h5>&#13;
<p class="noindent">Let’s put the frequency analysis program to work. We’ll start with a reasonably sized unencrypted text, the first chapter of <em>Alice’s Adventures in Wonderland</em>, to get a feel for the normal frequencies of letters in ordinary English. You don’t have to type the whole text out yourself; just look it up online and copy-paste it when Scratch Cat asks for your input. <a href="ch06.xhtml#ch6fig25">Figure 6-25</a> shows the results.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_123"/><img id="ch6fig25" src="../images/pg143_Image_171.jpg" alt="Image" width="799" height="604"/></div>&#13;
<p class="figcap"><em>Figure 6-25: Analyzing character frequencies in an unencrypted text (down the rabbit hole . . .)</em></p>&#13;
<p class="indent">As you can see, the text contains lots of Es and As, but only one J. If you scroll to the bottom of the list, you’ll find there’s one Q and no Xs or Zs. This is a pretty typical distribution of letters for an English-language text.</p>&#13;
<p class="indent">Now try using our original Caesar cipher program from <a href="ch06.xhtml#ch06lev2">Project 22</a> to encrypt the same <em>Alice’s Adventures in Wonderland</em> chapter, shifting the alphabet by three places. Plug the encrypted text into the frequency analysis program. <a href="ch06.xhtml#ch6fig26">Figure 6-26</a> shows the result.</p>&#13;
<div class="image"><img id="ch6fig26" src="../images/pg143_Image_172.jpg" alt="Image" width="798" height="595"/></div>&#13;
<p class="figcap"><em>Figure 6-26: Analyzing character frequencies in a shifted text</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_124"/>I can’t read the encrypted message, but I do notice that the word <em>DQG</em> appears lots of times, which is a clue. More importantly, there’s still a strong pattern in the frequencies of letters that suggests how the most common letters have been encoded. Of course, the pattern matches the original message perfectly, shifted three places: you can see the original frequency for A showing up at D, the original frequency for E showing up at H, and so on. The zeros at A and C are from X and Z wrapped around. Looking at this output, even if I didn’t know what the original text was, I could make a good guess as to which letter is E.</p>&#13;
<p class="indent">In theory, a one-time pad cipher should eliminate these patterns, causing every letter in the encrypted text to appear with roughly the same frequency. We’ll find out in the next project.</p>&#13;
<h4 class="h4" id="ch06lev20">Project 27: Encryption with a One-Time Pad</h4>&#13;
<p class="noindent">We can program a one-time pad encryption in Scratch by making just a few changes to the encryption programs we’ve written so far. <a href="ch06.xhtml#ch6fig27">Figure 6-27</a> shows the <code>Initialize</code> block.</p>&#13;
<div class="image"><img id="ch6fig27" src="../images/pg144_Image_173.jpg" alt="Image" width="433" height="945"/></div>&#13;
<p class="figcap"><em>Figure 6-27: Setup code for the one-time pad</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_125"/>This block asks for the encoding key and the message. It also asks if the user wants to encrypt or decrypt <span class="ent">❶</span>, so we can use the same program for both operations. Depending on the answer, the variable <code>action</code> is assigned a value of <code>1</code> or <code>-1</code>. This value is incorporated into the arithmetic of the shift, such that encryption involves adding the shift and decryption involves subtracting it.</p>&#13;
<p class="indent">Notice that the <code>Initialize</code> block sets up a log so we can scroll through a history of the program’s use. It also calls a custom <code>Trim key</code> block, which is defined in <a href="ch06.xhtml#ch6fig28">Figure 6-28</a>.</p>&#13;
<div class="image"><img id="ch6fig28" src="../images/pg145_Image_174.jpg" alt="Image" width="707" height="545"/></div>&#13;
<p class="figcap"><em>Figure 6-28: Trimming the key</em></p>&#13;
<p class="indent">In the <code>Trim key</code> block, we take the text that will be used to encrypt the message and remove any characters (like spaces or punctuation) that aren’t in the alphabet. The variable <code>trimmed_key</code> starts out empty. Then, the <code>repeat</code> loop steps through the key character by character; it ignores characters that aren’t in the <code>alphabet</code> list and puts the rest of the characters into <code>trimmed_key</code>.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch6fig29">Figure 6-29</a> shows the main program code.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_126"/><img id="ch6fig29" src="../images/pg146_Image_175.jpg" alt="Image" width="891" height="1093"/></div>&#13;
<p class="figcap"><em>Figure 6-29: The main code for one-time pad encryption (and decryption)</em></p>&#13;
<p class="indent">In this stack, we move character by character through the message (using index <code>i</code>) and the trimmed key (using index <code>j</code>), determining the shift for the current character in the message based on the current character in the key. We use an <code>if</code> statement <span class="ent">❶</span> to wrap back around to the start of the trimmed key if there are more characters in the message than in the key. As I mentioned earlier in the chapter, though, it’s best to use a key that’s at least as long as the message. A shorter key is a vulnerability: if the key starts to repeat, frequency analysis can reveal information about the key length and encoding phrase. A one-character key, for example, is equivalent to a Caesar shift!</p>&#13;
<p class="indent">The real work is done in the <code>set</code> block <span class="ent">➋</span>. It builds the encrypted message one character at a time by shifting the original character by an amount determined by the corresponding character in the key. We use the original <code>Wrap</code> block from <a href="ch06.xhtml#ch6fig4">Figure 6-4</a> to get the index for the appropriate letter. Notice also that we multiply <span epub:type="pagebreak" id="page_127"/>by <code>action</code> (either <code>1</code> or <code>-1</code>) when setting the value of <code>shift</code>. As mentioned previously, this allows the program to work for encryption and decryption by shifting either forward or backward.</p>&#13;
<h5 class="h5" id="ch06lev21">The Results</h5>&#13;
<p class="noindent">To see how secure one-time pad encryption is compared to simple alphabet scramblings like the Caesar cipher, let’s use our program to encrypt the same <em>Alice’s Adventures in Wonderland</em> chapter as before. For that, we need to choose a key. I’ll use the nonsense poem “Jabberwocky,” shown in <a href="ch06.xhtml#ch6fig30">Figure 6-30</a>, to keep in the Lewis Carroll spirit.</p>&#13;
<div class="image"><img id="ch6fig30" src="../images/pg147_Image_176.jpg" alt="Image" width="785" height="130"/></div>&#13;
<p class="figcap"><em>Figure 6-30: The one-time pad key</em></p>&#13;
<p class="indent">Encode the <em>Alice</em> chapter using the one-time pad program in encryption mode, find the encrypted text in the log, and copy-paste it into the frequency analysis program from the previous project. The result should look something like <a href="ch06.xhtml#ch6fig31">Figure 6-31</a>.</p>&#13;
<div class="image"><img id="ch6fig31" src="../images/pg147_Image_177.jpg" alt="Image" width="800" height="605"/></div>&#13;
<p class="figcap"><em>Figure 6-31: Analyzing character frequencies in text encrypted with a one-time pad</em></p>&#13;
<p class="indent">As you can see, the distribution of letters is now much flatter: no one letter stands out as being used much more (or less) frequently than the others, so frequency analysis doesn’t provide any clues for cracking the code. What’s more, the one-time pad has also eliminated regular patterns from the encrypted text itself. Whereas the Caesar-shifted version (<a href="ch06.xhtml#ch6fig26">Figure 6-26</a>) showed <em>DQG</em> at every instance of the word <em>and</em>, now each occurrence of <em>and</em> is encoded differently: first <em>ZKI</em>, then <span epub:type="pagebreak" id="page_128"/><em>JFH</em>, and so on. Without the key, decrypting the text seems like an impossible task; there are no clues to help you. And just imagine if spaces and punctuation were included in the alphabet and scrambled along with the letters—the encoded message would look like letter soup!</p>&#13;
<div class="side-b">&#13;
<p class="centerb"><img class="inline" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenges</p>&#13;
<p class="indentib1"><span class="blue"><strong>6.11</strong></span> A <em>cryptogram</em> is a word puzzle based on a scrambled alphabet, not necessarily a Caesar shift or a linear transformation. Write a Scratch program to help solve cryptograms by keeping track of letters as they’re guessed and showing progress with a partial decryption. Here’s an example of a cryptogram for you to solve. As a clue to help you get started, this cryptogram uses M to stand for S. You can look at patterns and letter frequencies to guess the other letters.</p>&#13;
<div class="imagec"><img src="../images/pg148_Image_178.jpg" alt="Image" width="601" height="449"/></div>&#13;
<p class="indentib1"><span class="blue"><strong>6.12</strong></span> Write a Scratch program to remove spaces and punctuation from a text string so all that’s left is a string of letters and numbers. This could be useful to remove word-break clues from an encrypted message.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch06lev22">Conclusion</h3>&#13;
<p class="noindent">Scratch isn’t just for processing numbers; it’s just as good at processing text. Any transformation rule that’s reversible can be the basis of an encryption algorithm for sharing secrets, but some rules (like using a one-time pad) are better than others (like basic shifts) for keeping secrets safe. You can always use techniques like frequency analysis to look for clues about how to decode a message.</p>&#13;
</div>
</div>
</body></html>