<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Appendix A: Jargon</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c2f206e1-36e8-4f89-b533-508263d6ec16" name="Adept.expected.resource"/>
</head>
<body>
<section><header>
<h1 class="Appendix"><span class="AppendixNumber"><span epub:type="pagebreak" id="Page_373" title="373"/>A</span><br/>
<span class="AppendixTitle">Jargon</span></h1>
</header>
<p class="ChapterIntro"><span class="dropCap">T</span>his was never intended to be a technical book for engineers who love all the geeky details. Instead, it’s supposed to be a book for everyone who is interested in the meteoric rise of a business and technology, and of the people behind that effort.</p>
<p>But when these people write code and create highly technical things that lead to that result, it’s difficult to not get lost in the techy weeds every now and then. So when I’m explaining, for example, that Ficus Kirkpatrick enjoyed working on drivers at the lower levels of the system, or that Brian Swetland worked on the kernel at Danger and Android, or that the engineers at Be and PalmSource were creating a platform and APIs for software developers, it’s necessary to use terms that might lose or confuse the non-engineers in the audience.</p>
<p>In an attempt to keep the techy noise to a minimum, I’m cramming many of the explanations of that stuff into this appendix. Hopefully this brief section will help explain the salient terms and, more important, how the different pieces of the system relate to each other.</p>
<h2 id="h1-502680b01-0001">First, a System Overview</h2>
<p class="BodyFirst">It is typical in my industry, when discussing platform software, to end up at the whiteboard drawing what we call a “layer cake diagram,” which shows the relationship of the various components of the system to each other. This diagram typically shows the components going down toward the hardware. At the top of the diagram, we see the pieces that users interact with, and at the bottom we see the components that talk directly to the hardware. All the pieces in between are layers of software written by the engineers to get from the higher-level user actions (for example, clicking a button) to the hardware (for example, displaying the button in a pressed state, launching an application, firing the nukes, whatever).</p>
<p><span epub:type="pagebreak" id="Page_374" title="374"/>Here’s a (very simplified) diagram for the Android operating system:</p>
<figure class="graphic">
<img alt="b01001" src="image_fi/502680b01/b01001.png"/></figure>

<p>There’s actually nothing specific to Android here; this is a very typical view of most operating systems. Android obviously has elements that are unique to that OS, which are explained elsewhere. But in general, the Android platform is similar to most other operating systems.</p>
<p>Let’s walk through the diagram from the top to the bottom to talk about what these pieces are and how they work together.</p>
<h3 id="h2-502680b01-0001">Apps</h3>
<p class="BodyFirst">The <em>apps</em> on Android are the main entry points for users. Users launch apps from their icons, they interact with the buttons, lists, and other pieces inside of apps, they click on links in apps that launch other apps, and so on. This is basically the world in which users live, interacting with the apps directly, while accessing all of the platform functionality only indirectly, through what these apps expose.</p>
<p>Note that the system-provided functionality of the home screen, the navigation bar, the status bar, and the lock screen are all considered apps. Even though they are provided by the platform (either Android itself, or in some cases by a manufacturer like Samsung, which provides its own system apps), they’re still just apps.</p>
<h3 id="h2-502680b01-0002">APIs</h3>
<p class="BodyFirst"><em>Application programming interfaces (APIs)</em> are the pieces of functionality in the platform that applications interact with. The platform APIs are the functions, variables, and other code pieces that are public-facing in the platform. For example, if an application needs to compute a square root, they might <span epub:type="pagebreak" id="Page_375" title="375"/>call a square root API function provided by the platform. Or if the application wants to display a button to the user, they might use a button API to handle its functionality and visuals.</p>
<p>The APIs are the tip of the iceberg for the platform. Although there are thousands of APIs in Android, they are really just the entry point to the platform functionality, most of which is embedded in the code that implements these APIs. So, for example, an application may create a button by calling a couple of API functions to do that, but under the hood the platform is doing a lot of work to satisfy all of the details that a button entails (including how to display it, how to handle click events on the screen, and how to draw the text for the button’s label).</p>
<h3 id="h2-502680b01-0003">Framework</h3>
<p class="BodyFirst">The <em>framework</em> is the large layer of system software that handles all the functionality exposed through the public APIs. That is, the framework is responsible for both the APIs as well as the implementation of those APIs. In the previous example, this is where the button functionality lives, among other bits. The framework encompasses, really, everything that the entire platform is capable of, like location services, data storage, telephony, graphics, UI, and, well, everything. The UI toolkit for Android is a subset of framework functionality that is specific to user interface APIs and implementation.</p>
<h3 id="h2-502680b01-0004">System</h3>
<p class="BodyFirst">The system piece in the diagram above denotes software that is running that is not directly accessible by applications, but that is responsible for the device's overall functionality. For example, on Android, the <em>window manager</em> is responsible for displaying applications in their own windows and navigating between those windows as different applications are launched. There is also a service running that handles low-memory situations by killing applications that have not been used recently so that more recently used applications can have the memory they need. All of those things are running indirectly, on the user’s behalf.</p>
<p>The system calls public APIs for various pieces of necessary framework functionality, but the system may also call functions in the framework directly (which is why it is shown in the diagram beside, rather than on top of, the APIs layer).</p>
<h3 id="h2-502680b01-0005"><span epub:type="pagebreak" id="Page_376" title="376"/>Kernel</h3>
<p class="BodyFirst">The <em>kernel</em>, with its device drivers, is the lowest level of software running on the device. It handles the fundamental capabilities of the device that the overall system needs. For example, each application runs in a <em>process</em>; the management of the many processes running on the device (isolating them from each other and scheduling time for them to run on the CPU) is the kernel's responsibility. The kernel is also responsible for loading and executing the drivers on the system. All of the software we’ve talked about so far is generic to any device, but drivers are specific to particular pieces of hardware. For example, to receive clicks on a button, a piece of hardware in the device is able to turn touches on the screen into information about where those touches occurred. A driver in the kernel does this, routing the information from hardware-specific data into events that are then sent into the framework for processing. Similarly, there are drivers for storage, sensors, display, camera, and any other hardware that a device may have. The kernel loads these drivers when the device boots and communicates to these pieces of hardware through the drivers when necessary.</p>
<h3 id="h2-502680b01-0006">Platform</h3>
<p class="BodyFirst">Finally, I use the term <em>platform</em> to encompass everything here except the applications. It’s a very generic term, and I use it broadly to refer to everything that Android provides for application developers and for users. The platform software for Android is all of the stuff that provides facilities for developers writing applications as well as everything that the device needs overall to display the basic UI and functionality to users. So when I talk about the platform team on Android, it’s basically everyone that works on all of the stuff above other than the applications: the engineers working on the kernel, the framework, the system software, and the APIs. </p>
<h2 id="h1-502680b01-0002">Other Geeky Terms</h2>
<p class="BodyFirst">In addition to everything that fit conveniently in the previous diagram, a few other technical terms used in the book are also worth explaining. I’m sure I’ll miss a few. If only there were some kind of “search engine” capability on the internet so that readers could easily look up terms that I inadvertently forgot to include. . . .</p>
<h3 id="h2-502680b01-0007"><span epub:type="pagebreak" id="Page_377" title="377"/>Changelist</h3>
<p class="BodyFirst"><em>Changelist (CL)</em> refers to the code change required to fix a bug, implement a new feature, update the docs—whatever. A CL can be as little as a one-line fix or as much as thousands of lines of code to implement a large swath of new APIs and capabilities. Peer developers far prefer the former because one-liners are easy to review and approve. Woe be unto the developer that leans on their team to review a 10,000-line CL when everyone is under the gun already to deliver their own fixes and features.</p>
<p>Changelist is apparently a term used primarily by Google engineering. Other software systems use terms like <em>patch</em> or <em>PR</em> (pull request) to mean the same thing.</p>
<h3 id="h2-502680b01-0008">Emulator</h3>
<p class="BodyFirst">An <em>emulator</em> is a software program that mimics a hardware device. Developers use emulators (in particular, they use the Android emulator) to make it easier to run and test their programs on the host computer they are using to write their applications. Instead of requiring a physical device to test an app (and perhaps to suffer delays downloading the program to the device every time it is recompiled), they can simply run a virtual device on their powerful desktop computer instead.</p>
<p>There is a difference between an <em>emulator</em> and a <em>simulator</em>; an emulator actually mimics everything happening on a real device, down to the CPU and the instructions running on it. A simulator is usually a simpler (and, often, faster) program because it does not bother emulating everything on a device, but rather just enough to make it work essentially like a device. A simulator is good enough for testing basic functionality of a program but might miss out on enough important details (such as how the hardware sensors work), so a developer is better off using an emulator or a real device to validate the actual functionality in the real world. Android had a simulator in the very early days, but eventually stopped maintaining it and switched to having only an emulator.</p>
<h3 id="h2-502680b01-0009">IDE</h3>
<p class="BodyFirst">An <em>IDE (integrated development environment)</em> is a suite of tools that programmers use for writing, building, running, debugging, and testing their applications. This includes things like a text editor—which is usually knowledgeable <span epub:type="pagebreak" id="Page_378" title="378"/>about the language(s) that programmers use, with shortcuts for formatting and highlighting code written in that language, plus other features like code completion and linking—as well as a compiler for building the application. For example, Android Studio (the IDE provided to developers by the Android team) includes a large and growing suite of tools, including various editors (for Java, XML, and C/C++), the compiler for building the code into an Android application, a debugger for stepping through the program as it runs on a device, and various other specific utilities for analyzing performance, monitoring memory usage, and building UI assets.</p>
<h3 id="h2-502680b01-0010">Java ME/J2ME</h3>
<p class="BodyFirst">Java ME (or J2ME,<sup class="FootnoteReference"><a href="#b01-footnote-1" id="b01-footnoteref-1">1</a></sup> during the early days of Android development) is short for Java Platform, Micro Edition, a software platform for early mobile devices. Java ME used the Java programming language and provided functionality that application developers needed to write apps for those devices.</p>
<p>J2ME promised something in the mobile space that developers desperately wanted: a common platform that would allow them to write applications for many different devices, as opposed to having to re-tune their apps for vastly different hardware.</p>
<p>However, unlike the desktop or server versions of Java, Java ME came in a large variety of versions, called <em>profiles</em>, which meant that the capabilities of any particular implementation of Java ME on a device did not necessarily match that of another device, so Java ME developers had to deal with device variety issues after all.</p>
<h3 id="h2-502680b01-0011">OEM</h3>
<p class="BodyFirst">An<em> OEM (original equipment manufacturer)</em> is a company that makes the actual hardware.</p>
<h3 id="h2-502680b01-0012">Object-Oriented Programming: Classes, Fields, and Methods</h3>
<p class="BodyFirst">The software used to write the Android platform, and to write Android applications, uses an approach called <em>object-oriented programming (OOP)</em>. <span epub:type="pagebreak" id="Page_379" title="379"/>Most popular/modern languages use a similar approach, including Java, C++, Kotlin, and more. In an OOP system, there are functional blocks called <em>classes</em> that present an API for doing a particular set of things. For example, Android has a <code>String</code> class for performing operations on text strings. </p>
<p>Each class may contain a set of <em>fields</em> or <em>properties</em>, which hold values. For example, a <code>String</code> object might hold the value of a text string, such as <code>"I want a sandwich."</code></p>
<p>Each class may also contain a set of <em>methods</em> or <em>functions</em> that perform operations on that class (and potentially on other classes as well). For example, Android’s <code>String</code> class has a method named <code>toUpperCase()</code>, which does exactly what it says. So our sandwich string from before, if called with <code>toUpperCase()</code>, would return a value of <code>"I WANT A SANDWICH."</code></p>
<p>Classes, with their various methods and fields, can be bundled together to create a <em>library</em>. The classes, fields, and methods in that library represent the API of that library, which applications (or other libraries) can call from their code to perform the operations that the library’s API offers.</p>
<h3 id="h2-502680b01-0013">SDK</h3>
<p class="BodyFirst">An <em>SDK (software development kit)</em> contains the pieces a programmer needs to write programs for a given platform. This includes the APIs they can call to perform functionality on the platform as well as the libraries that implement those APIs. Using an SDK, a programmer can write their application. Then using tools (usually supplied with the SDK), they can build the application (compile it into a form that is understandable by devices running the platform). Finally, they can run and debug their program on a device (or emulator) that is compatible with their compiled application.</p>
<h3 id="h2-502680b01-0014">Toolkit</h3>
<p class="BodyFirst"><em>Toolkit</em> overlaps in meaning, and usage, with framework, library, and APIs. In general, toolkit is used to mean a framework that is specific to user interface (UI) components. On Android, the toolkit is synonymous with the <em>UI</em><em> toolkit</em>, or the APIs and implementation for the user interface technology of Android. It is considered a part of the overall Android framework, specifically the subset of the framework that deals with most of the visual aspects of the framework.</p>
<h3 id="h2-502680b01-0015"><span epub:type="pagebreak" id="Page_380" title="380"/>View</h3>
<p class="BodyFirst">All UI platforms have the concept of some kind of UI element, for things like buttons, or checkboxes, or sliders, or text, or containers of all of these objects. But the way that they refer to those things differs between platforms, so it’s confusing to tell what platform developers are talking about because they use different terms. Java’s Swing toolkit called them <em>components</em>, some platforms call them <em>elements</em> or <em>widgets</em>. On Android, UI elements are referred to as <em>Views</em>, named for the class that all of these elements inherit from (View). The container of Views (including other containers) is a view called ViewGroup. Finally, a <em>View hierarchy</em> is, well, it’s what it sounds like; a hierarchy of Views and ViewGroups, descending from the top-level parent ViewGroup, with its set of children, and down into any ViewGroups contained therein with their child Views, and so on.</p>
</section>
<section class="footnotes">
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#b01-footnoteref-1" id="b01-footnote-1">1.</a></sup>  J2ME = Java 2 Platform, Micro Edition. The naming switch between Java and Java 2 was also confusing on the inside of the company (Sun Microsystems) that was responsible for those names.</p></aside>
</section>
</body>
</html>