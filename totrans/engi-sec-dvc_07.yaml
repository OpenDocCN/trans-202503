- en: '**5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: CONFIDENTIAL DATA STORAGE AND SECURE MEMORY**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**机密数据存储和安全内存**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: Embedded systems store and process a variety of data. Some of this data is trivial
    because it is the same on many platforms or can be guessed or derived easily.
    However, a certain amount of data, usually known as *sensitive*, *secret*, or
    *confidential* data, requires careful treatment.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统存储和处理各种数据。其中一些数据是无关紧要的，因为它们在许多平台上相同，或者可以很容易地猜测或推导出来。然而，某些数据通常被称为*敏感*、*机密*或*保密*数据，需要谨慎处理。
- en: The information that this data carries is valuable, and its disclosure would
    likely lead to negative consequences. One example is *intellectual property* forged
    into software algorithms, proprietary protocols, and application content. Further,
    *cryptographic material* like secret keys and passwords contain critical information
    by nature. A device’s *lifetime data* like sensor data, log entries, and sent
    or received messages might also fit into this category.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据所携带的信息具有价值，其披露可能会导致负面后果。一个例子是*知识产权*，如嵌入到软件算法、专有协议和应用内容中的内容。此外，*加密材料*，如密钥和密码，天生就包含了关键信息。设备的*生命周期数据*，如传感器数据、日志条目和发送或接收的消息，也可能属于这一类。
- en: This chapter starts by looking at data that should be stored in a confidential
    manner and the dilemma of how to keep secrets in embedded systems. Next, I’ll
    describe your options for storing confidential data from the OS level to the hardware
    to obfuscated software, and the corresponding pros and cons. A case study in this
    chapter will then walk through using encrypted file containers on an embedded
    system running Linux.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先讨论应以保密方式存储的数据以及在嵌入式系统中如何保持机密的困境。接下来，我将描述从操作系统级别到硬件再到混淆软件的存储机密数据的选项及其相应的优缺点。本章中的案例研究将通过使用加密文件容器在运行Linux的嵌入式系统上进行演示。
- en: '**Confidential Data**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**机密数据**'
- en: The identification of confidential data and the awareness of related threats
    is always the first step toward its protection. The following examples are meant
    to create the necessary mindset.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 识别机密数据并意识到相关威胁始终是保护数据的第一步。以下示例旨在帮助建立必要的思维方式。
- en: Imagine that your research department invents a superefficient engine-control
    algorithm that runs a car on significantly less fuel than competing products.
    Although you probably filed a patent, that might not be enough to protect your
    device from piracy and copycats. The value of the invention becomes reality only
    if you implement it in your control device. There, it’s likely available as a
    compiled software executable or maybe as part of a kernel module. Both are stored
    in the device’s filesystem, and if an attacker can read the filesystem, they can
    reverse engineer your algorithm and directly benefit from your research investment.
    This situation is clearly one you’ll want to avoid, which means you must protect
    the confidentiality of the control algorithm’s implementation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您的研究部门发明了一种超高效的发动机控制算法，能够使汽车的燃油消耗远低于竞争产品。虽然您可能已经申请了专利，但这可能不足以保护您的设备免受盗版和模仿者的侵害。发明的价值只有在您将其实施到控制设备中时才会实现。在此，它很可能作为一个已编译的软件可执行文件，或者作为内核模块的一部分存储。两者都存储在设备的文件系统中，如果攻击者能够读取文件系统，他们就能逆向工程您的算法，并直接从您的研究投资中获益。这种情况显然是您想避免的，这意味着您必须保护控制算法实现的机密性。
- en: Some household and consumer devices contain a lot of media content like pictures
    and videos, and their production is anything but cheap. Storing them in plain
    sight in a device’s filesystem is rarely a good idea. Attackers might copy them,
    upload them to their favorite online platform, and reuse them for their own purposes,
    which could not only cause financial losses but also damage the reputation of
    your product and company.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一些家庭和消费设备包含大量的媒体内容，如图片和视频，它们的制作成本非常高。将它们存储在设备文件系统中显而易见的位置通常不是一个好主意。攻击者可能会复制这些内容，将它们上传到他们喜欢的在线平台，并为了自己的目的重用它们，这不仅可能造成经济损失，还可能损害您的产品和公司的声誉。
- en: At first glance, the need to protect cryptographic material seems to go without
    saying. However, many devices store the private keys corresponding to their certificate-based
    authentication in their standard filesystems. Reading and copying these keys opens
    the door for impersonation attacks. In addition, especially on the application
    level, the passwords that control user authentication are sometimes stored in
    plaintext within configuration files or software binaries. Of course, extracting
    a password allows an adversary to authenticate successfully with the device because
    the credential wasn’t stored in a way that protects confidentiality.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，保护加密材料似乎是显而易见的。然而，许多设备将与其证书基础身份验证对应的私钥存储在标准文件系统中。读取和复制这些密钥为冒充攻击打开了大门。此外，特别是在应用层，控制用户身份验证的密码有时会以明文形式存储在配置文件或软件二进制文件中。当然，提取密码会让攻击者成功地进行身份验证，因为凭证并没有以保护机密性的方式存储。
- en: In some cases, the really interesting data is generated during a device’s lifetime.
    Think, for example, of the privacy implications for biometric data that a product
    may collect through fingerprint readers or location data that creates movement
    profiles of users. This information often has a high confidentiality requirement,
    maybe even by laws like the European GDPR. Failure of protection can lead to fines
    up to €20 million or 4 percent of a company’s total global turnover.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，真正有趣的数据是在设备的生命周期中生成的。例如，考虑产品通过指纹识别器收集的生物特征数据或通过位置数据创建用户移动档案的隐私影响。这些信息通常有很高的保密要求，甚至可能受到如欧洲通用数据保护条例（GDPR）等法律的约束。如果保护措施失败，可能会导致高达2000万欧元或公司全球总营业额的4%的罚款。
- en: Stored data history in a device can reveal even more. For example, in industrial
    production environments, the data history might allow attackers to reconstruct
    machine utilization and output figures, which could be valuable information for
    competitors. Again, confidentiality protection would be a crucial device feature.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 设备中存储的数据历史甚至可能揭示更多内容。例如，在工业生产环境中，数据历史可能允许攻击者重建机器使用率和产出数据，这些可能是竞争对手所看重的有价值信息。同样，保密保护将是设备的重要特性。
- en: Almost every modern device contains data that deserves confidentiality protection.
    Make sure to keep that in mind when doing your threat and risk analysis.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个现代设备都包含值得保护的机密数据。在进行威胁和风险分析时，请务必牢记这一点。
- en: '**The Dilemma of Keeping Secrets on Embedded Systems**'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**嵌入式系统中的保密困境**'
- en: Embedded systems often include a toxic combination of properties. First, they
    have to be able to boot and run without user interaction, which means that everything
    relevant for correct operation has to be stored within the device, including all
    secrets. Second, attackers can usually obtain a device for themselves and analyze
    it thoroughly. This analysis includes not only network-based investigations but
    also physical eavesdropping on communication lines within the product and the
    extraction of nonvolatile memory contents like firmware images and filesystem
    partitions for reverse-engineering purposes. From a theoretical point of view,
    confidentiality protection for secrets in a device that can be analyzed on all
    levels can’t be guaranteed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统通常包含一种有毒的属性组合。首先，它们必须能够在没有用户交互的情况下启动并运行，这意味着所有与正确操作相关的信息必须存储在设备内部，包括所有的机密数据。其次，攻击者通常可以获得设备并对其进行彻底分析。这种分析不仅包括基于网络的调查，还包括对产品内部通信线路的物理窃听，以及提取如固件镜像和文件系统分区等非易失性存储内容进行逆向工程。
    从理论上讲，对于可以在所有层面进行分析的设备，其机密性保护是无法得到保证的。
- en: However, from a more pragmatic perspective, the question always is, “How much
    effort does an adversary have to spend to reach a comprehensive understanding
    of the device at hand, including its secrets?”
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从更实际的角度来看，问题始终是：“攻击者需要花费多少努力才能全面了解设备及其机密数据？”
- en: Let’s consider the intellectual property example I mentioned previously. Imagine
    you’re responsible for keeping the software implementation of a highly sophisticated
    algorithm secret, although it has to be stored and used within your device. Some
    people might immediately think that reading the firmware from flash memory, identifying
    the executable, and reverse engineering the algorithm is highly complicated, so
    they assume they don’t need any protection measures.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下我之前提到的知识产权示例。假设你负责保守一个高度复杂算法的软件实现的秘密，尽管它必须存储并在你的设备上使用。有些人可能会立即认为，从闪存读取固件、识别可执行文件并进行算法的逆向工程非常复杂，因此他们认为不需要任何保护措施。
- en: That assumption might be true for attackers like script kiddies. However, consider
    criminals seeking financial gain. For them, dumping flash memory and mounting
    a filesystem doesn’t seem like too much work. Further, free and open source tools
    like Radare2 and Ghidra enable everybody with interest to do at least basic software
    reverse engineering. If confidentiality has an increased priority in your product,
    these attackers should definitely be in scope.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个假设对于像脚本小子这样的攻击者可能是成立的。然而，考虑到那些寻求经济利益的罪犯，对他们来说，转储闪存和挂载文件系统似乎并不算太多工作。此外，像Radare2和Ghidra这样的免费开源工具使得任何有兴趣的人都可以进行至少基本的软件逆向工程。如果机密性在你的产品中具有更高的优先级，那么这些攻击者绝对应该列入考虑范围。
- en: Of course, some cases are much simpler to attack. For devices that store their
    firmware on removable media like a microSD card that many off-the-shelf laptops
    can read, flash dumping isn’t even necessary. If the confidential information,
    such as an RSA private key, is stored in a directly reusable format like Privacy-Enhanced
    Mail (PEM), an “attack” could be performed in no time, even by a script kiddie.
    Also, not every executable even needs to be reverse engineered. *Code lifting
    attacks*, for example, just take the binary as is, copy it to another device,
    and run it. If it fulfills its purpose, there’s no need to access its proprietary
    details.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有些情况攻击起来要简单得多。对于那些将固件存储在可移动介质（如许多现成笔记本电脑可以读取的microSD卡）上的设备，甚至不需要进行闪存转储。如果机密信息（如RSA私钥）以像隐私增强邮件（PEM）这样的可直接重用格式存储，那么“攻击”可以在短时间内完成，甚至由一个脚本小子来做。而且，并不是每个可执行文件都需要逆向工程。例如，*代码提取攻击*只需将二进制文件原封不动地复制到另一台设备上并运行。如果它实现了预期功能，就不需要访问其专有的细节。
- en: '**Secure Filesystem Approaches**'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安全文件系统方法**'
- en: 'At this point, you might wonder, “Is there such a thing as an encrypted file-system?
    That would solve all our problems.” There is, but it doesn’t make the problem
    go away completely. Three common options are available that provide confidentiality
    protection for files: encrypted stacked filesystems, native filesystem encryption,
    and encrypted block devices.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，你可能会想：“是否存在加密文件系统？那将解决我们所有的问题。”确实存在，但它并不能完全解决问题。有三种常见的选项可用，它们为文件提供机密性保护：加密堆叠文件系统、原生文件系统加密和加密块设备。
- en: '***Encrypted Stacked Filesystems***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加密堆叠文件系统***'
- en: A *stacked filesystem* is an additional filesystem structure on top of an existing
    one, which means that standard filesystems like ext3 aren’t touched and the encryption
    happens in a layer above. In this case, the content and the names of files are
    encrypted—for example, for all files in a specific directory. However, the number
    of files and their metadata is readable.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*堆叠文件系统*是在现有文件系统之上增加的一个额外文件系统结构，这意味着像ext3这样的标准文件系统不会被修改，加密发生在其上层。在这种情况下，文件的内容和名称会被加密——例如，对于特定目录中的所有文件。然而，文件的数量及其元数据是可以读取的。'
- en: Stacking filesystems also comes with a certain performance overhead, and filenames
    might be subject to additional restrictions. For years, EncFS, which uses the
    Filesystem in Userspace (FUSE) framework, has been a popular and easy-to-use example
    of this approach, but it seems that development has stalled. An aspiring successor
    might be gocryptfs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠文件系统也会带来一定的性能开销，并且文件名可能会受到额外的限制。多年来，使用用户空间文件系统（FUSE）框架的EncFS一直是这一方法的流行且易于使用的示例，但似乎开发已经停滞。一个有潜力的继任者可能是gocryptfs。
- en: A competitor that operates in kernel space is eCryptfs. While eCryptfs might
    be a bit harder to configure, it exhibits better performance in certain cases.
    However, its development is also stalled. File-based encryption (FBE) with stacked
    filesystems seems to be out of fashion.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个在内核空间运行的竞争者是 eCryptfs。虽然 eCryptfs 可能配置起来稍微复杂一些，但在某些情况下它表现出更好的性能。然而，它的开发也停滞不前。基于文件的加密（FBE）与堆叠文件系统似乎已经不再流行。
- en: '***Native Filesystem Encryption***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原生文件系统加密***'
- en: Today, filesystems like ext4, F2FS, and UBIFS directly support the encrypted
    storage of files. Compared to filesystem stacking, this allows for more efficient
    integration and operation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，像 ext4、F2FS 和 UBIFS 这样的文件系统直接支持文件的加密存储。与文件系统堆叠相比，这允许更高效的集成和操作。
- en: Popular users of this native FBE approach include the Android and Chrome OSs.
    The underlying features are implemented in the Linux kernel and use the kernel’s
    crypto API for encryption. The user-space tool for configuring and managing encrypted
    directories is called `fscrypt`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种原生 FBE 方法的流行用户包括 Android 和 Chrome OS。其底层功能已在 Linux 内核中实现，并使用内核的加密 API 进行加密。用于配置和管理加密目录的用户空间工具叫做
    `fscrypt`。
- en: '***Encrypted Block Devices***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加密块设备***'
- en: File-based approaches always leave folder structures and metadata unencrypted.
    A common way to avoid this information leakage is *full-disk encryption (FDE)*.
    In Linux, this means that the encryption layer lies below the filesystem, on the
    block device level. It doesn’t matter whether this block device is a whole disk,
    a partition, or a file container; it’s encrypted as a whole, and its content isn’t
    distinguishable from random information.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文件的方法总是将文件夹结构和元数据保留为未加密状态。一种常见的避免信息泄露的方式是*全盘加密（FDE）*。在 Linux 中，这意味着加密层位于文件系统下方，位于块设备级别。无论该块设备是整个磁盘、分区还是文件容器，它都会作为一个整体进行加密，其内容与随机信息无法区分。
- en: The most common representative of this class for Linux is `dm-crypt`, which
    is based on the device mapper infrastructure and uses the kernel’s crypto API.
    The `cryptsetup` user-space tool can create encrypted volumes, and it supports
    the popular Linux Unified Key Setup (LUKS) container format that enables various
    key-management functionalities for encrypted volumes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux 来说，这类加密技术最常见的代表是 `dm-crypt`，它基于设备映射器基础设施，并使用内核的加密 API。`cryptsetup`
    用户空间工具可以创建加密卷，并且支持流行的 Linux 统一密钥设置（LUKS）容器格式，该格式为加密卷提供了多种密钥管理功能。
- en: The TrueCrypt successor VeraCrypt is another popular tool, which, for example,
    also enables the chaining of two ciphers to enhance decryption resistance.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: TrueCrypt 的继任者 VeraCrypt 是另一个流行的工具，例如，它还支持将两种密码算法串联起来，以增强解密的抗性。
- en: '***Recommendations***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***建议***'
- en: Encrypted data storage clearly doesn’t have a lack of options. Whether FDE or
    FBE fits your needs largely depends on your device and its corresponding security
    requirements.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 加密数据存储显然不缺少选择。FDE 或 FBE 是否适合你的需求，主要取决于你的设备及其相应的安全要求。
- en: If, from your point of view, the location, number, and size of files already
    convey sensitive information to an attacker, FDE is probably the solution that
    leads to the highest possible security. However, FBE offers more flexibility—for
    example, for hosting a heterogeneous set of files within the same filesystem so
    that some data is always available and readable to all processes, but confidential
    data is decrypted selectively per directory. It could also have application-specific
    keys, which allows for more fine-grained confidentiality protection.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从你的角度来看，文件的位置、数量和大小已经向攻击者透露了敏感信息，那么 FDE 可能是带来最高安全性的解决方案。然而，FBE 提供了更多的灵活性——例如，在同一文件系统内托管异构文件集，以便某些数据始终可以被所有进程访问和读取，但机密数据则按目录选择性解密。它还可以具有应用特定的密钥，从而实现更细粒度的机密性保护。
- en: '***The Passphrase***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***密码短语***'
- en: 'No matter which implementation you choose, one big problem will always remain:
    all the tools require a passphrase to either directly unlock protected directories
    and volumes or to unlock a key file subsequently used to unlock encrypted data.
    Even the word *passphrase* indicates that this concept is meant for users to enter
    credentials as we do on our PCs at boot time.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种实现方式，一个大问题始终存在：所有工具都需要一个密码短语，以直接解锁受保护的目录和卷，或解锁用于解密数据的密钥文件。即使是“密码短语”一词也表明这一概念是让用户像我们在
    PC 启动时输入凭证一样使用的。
- en: However, most embedded systems don’t have active users sitting in front of them,
    able to enter a passphrase to unlock hard-disk encryption when booting up. The
    usual next question is, “Where to hide the secret that unlocks encryption?”
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数嵌入式系统并没有活跃的用户在其面前，能够在启动时输入密码短语来解锁硬盘加密。接下来通常会问：“在哪里隐藏解锁加密的密钥？”
- en: '**Secure Memory in Hardware**'
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**硬件中的安全内存**'
- en: Every now and then, I hear people (and companies) say that *secure memory* implemented
    in hardware is the solution to the embedded system credentials problem. However,
    that’s only partially true.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我时常听到一些人（和公司）说，硬件实现的*安全内存*是解决嵌入式系统凭证问题的方案。然而，这只是部分正确。
- en: One advantage of hardware-based secure memory is that it implements a strong
    physical segmentation between the classic nonvolatile memory, where the firmware
    is stored, and a dedicated security module, which can be reached only by a specific
    interface. Further, it allows for tamper detection or resistance, and the stored
    bits might be buried deep inside a chip, making hardware attacks difficult and
    requiring sophisticated equipment.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件实现的安全内存的一个优势在于，它在经典的非易失性内存（存储固件的位置）和专用的安全模块之间实现了强有力的物理分隔，而该安全模块只能通过特定的接口访问。此外，它还支持篡改检测或抗篡改功能，并且存储的位数据可能深埋在芯片内部，这使得硬件攻击变得困难，并且需要复杂的设备。
- en: However, this approach also has downsides. Most obviously, only small amounts
    of data, usually cryptographic keys, can be stored in such protected memory. In
    addition, these secrets often *have to leave* the security module to serve their
    purpose, like unlocking a LUKS container. In such cases, attackers might capture
    the keys on their way over a communication line.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法也有其缺点。最明显的是，这种受保护的内存通常只能存储少量数据，通常是加密密钥。此外，这些密钥通常*必须离开*安全模块才能发挥作用，比如解锁
    LUKS 容器。在这种情况下，攻击者可能会在通信线路上传输过程中捕获这些密钥。
- en: In the past, this issue has been practically exploited when external security
    modules transferred secrets to a main CPU and adversaries eavesdropped on the
    physical PCB traces. Other attacks actively communicate with the secure memory
    and, for example, ask it to encrypt, decrypt, or sign arbitrary data for an attacker.
    So merely *having* a secure memory doesn’t enhance your device’s security significantly;
    it also must be *integrated* securely.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，当外部安全模块将密钥传递给主 CPU 时，攻击者通过窃听物理 PCB 路径来利用这一问题。其他攻击则主动与安全内存进行通信，例如要求它为攻击者加密、解密或签名任意数据。因此，仅仅*拥有*一个安全内存并不会显著提升设备的安全性；它还必须*安全集成*。
- en: As usual, whether the use of secure memory makes sense depends on the specific
    application and implementation details. Often, it at least adds another layer
    of required attacker knowledge—namely, observing secure memory communication at
    device runtime instead of “only” extracting secrets from firmware or filesystems.
    Let’s consider the options regarding secure memory.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，是否使用安全内存是否合理取决于具体的应用场景和实现细节。通常，它至少为攻击者添加了另一层需要了解的知识——即观察设备运行时的安全内存通信，而不仅仅是从固件或文件系统中提取机密信息。让我们来考虑一下与安全内存相关的选项。
- en: '***External Secure Memory***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***外部安全内存***'
- en: The “traditional” way of adding a secure memory device to your design is by
    integrating a dedicated microchip to your device’s PCB and connecting it to the
    main microprocessor. The most prominent player in this area is the Trusted Platform
    Module (TPM).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将“传统”方式添加安全内存设备到设计中的方法是将一个专用微芯片集成到设备的 PCB 上，并将其连接到主微处理器。这个领域中最突出的代表是受信平台模块（TPM）。
- en: You can purchase discrete TPMs from a variety of manufacturers like Infineon,
    NXP, and ST. They’re well established in the PC world because Microsoft Windows
    made them a hard requirement. A basic use case is that a user can unlock a TPM
    key, which is then used to unlock volumes protected by BitLocker. Of course, this
    is a simplified view of the process, and that’s where the problem comes in.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从多个制造商那里购买离散的 TPM 设备，比如英飞凌、NXP 和 ST。它们在 PC 世界中已经得到了广泛应用，因为微软的 Windows 系统要求它们作为硬件必备组件。一个基本的用例是，用户可以解锁一个
    TPM 密钥，然后该密钥用来解锁由 BitLocker 保护的卷。当然，这只是该过程的简化视图，问题也正是出在这里。
- en: A TPM is much more than secure memory. It comes with authorization layers, with
    key hierarchies, and with a specification that’s more than 1,000 pages for the
    current TPM version. Although tools are available to make use of TPMs under Linux,
    like `tpm2-tools` and `ibm-tss`, using a TPM seems to be too complex for average
    products and development teams.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: TPM远不止是安全内存。它包括授权层、密钥层级，并且当前TPM版本的规范超过1000页。尽管Linux下有可用工具来使用TPM，如`tpm2-tools`和`ibm-tss`，但使用TPM对普通产品和开发团队来说似乎太复杂。
- en: Fortunately, secure microcontroller manufacturers provide interesting alternatives
    that target automotive, industrial, and IoT applications. Similar to a TPM, products
    like Infineon’s OPTIGA Trust X, NXP’s Edge-Lock SE050 family, and Microchip’s
    ATECC608B come with a broad set of crypto algorithms, from symmetric ciphers like
    AES, to hash functions and HMACs, to asymmetric crypto like RSA and ECDSA. Of
    course, they also provide secure memory for cryptographic keys. Their promise
    is that these devices require much less integration effort for IoT products.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，安全微控制器制造商提供了针对汽车、工业和物联网应用的有趣替代方案。类似TPM的产品，如英飞凌的OPTIGA Trust X、NXP的Edge-Lock
    SE050系列和微芯的ATECC608B，配备了广泛的加密算法，从对称密码（如AES）、哈希函数和HMAC，到非对称加密（如RSA和ECDSA）。当然，它们也提供用于加密密钥的安全内存。它们的承诺是，这些设备需要的集成工作量远低于物联网产品。
- en: In summary, a TPM used only as secure memory is like breaking a butterfly on
    a wheel. Leaner alternatives might be more suitable for the embedded system world.
    However, when deciding whether to use a dedicated hardware security module, you
    should also consider the topics of secure device identity and secure communication,
    as discussed in [Chapters 6](ch06.xhtml#ch06) and [7](ch07.xhtml#ch07). In any
    case, make sure you understand the implications that secret keys might be communicated
    over interfaces accessible to physical attackers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，单纯将TPM用作安全内存就像是用大锤打蝴蝶。对于嵌入式系统而言，更精简的替代方案可能更为合适。然而，在决定是否使用专用硬件安全模块时，你还应考虑到安全设备身份和安全通信等主题，正如在[第6章](ch06.xhtml#ch06)和[第7章](ch07.xhtml#ch07)中所讨论的那样。无论如何，确保你理解可能通过接口与物理攻击者可接触的渠道传输秘密密钥的含义。
- en: '**NOTE**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The TPM 2.0 specification provides a means to encrypt the communication between
    host CPU and TPM, which adds complexity for attackers but also for engineers.*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*TPM 2.0规范提供了一种加密主机CPU与TPM之间通信的方式，这为攻击者和工程师都增加了复杂性。*'
- en: '***Internal Secure Memory***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内部安全内存***'
- en: In contrast to discrete hardware components that have to be designed in and
    soldered to a PCB, security modules and secure storage facilities are already
    deeply integrated into the main CPU of a device.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与需要设计并焊接到PCB上的离散硬件组件相比，安全模块和安全存储设施已经深度集成到设备的主CPU中。
- en: Known as *integrated TPMs* or *firmware TPMs*, these alternatives to dedicated
    hardware TPMs are offered by chip vendors like AMD and Intel. Besides reduced
    PCB integration costs, the striking advantage of this concept is that on-chip
    communication is much harder to capture than signals running across a PCB. Of
    course, the complexity issue of TPMs stays the same.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为*集成TPM*或*固件TPM*的这些TPM替代方案，由AMD和Intel等芯片厂商提供。除了降低PCB集成成本外，这一概念的显著优势是片上通信比PCB上运行的信号更难以捕获。当然，TPM的复杂性问题依然存在。
- en: On the other side, modern SoCs often offer one-time programmable (OTP) memory
    that can be used to store at least a master key. A common example is the cascaded
    encryption concept of NXP’s i.MX series. There, an OTP master key (OTPMK) is programmed
    to the device during production. Subsequently, this key is used to encrypt a data
    encryption key (DEK) to obtain a so-called DEK *binary large object (BLOB)*. In
    turn, developers can then use the DEK to encrypt application data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，现代SoC通常提供一次性可编程（OTP）内存，可用于存储至少一个主密钥。一个常见的例子是NXP i.MX系列的级联加密概念。在这里，主密钥（OTPMK）在生产过程中被编程到设备中。随后，使用此密钥来加密数据加密密钥（DEK），以获取所谓的DEK
    *二进制大对象（BLOB）*。然后，开发人员可以使用DEK来加密应用程序数据。
- en: '[Figure 5-1](ch05.xhtml#ch05fig01) shows the procedure running on a device
    from the master key OTP reading to the application data decryption.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-1](ch05.xhtml#ch05fig01)展示了从主密钥OTP读取到应用数据解密的过程。'
- en: '![Image](../images/05fig01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05fig01.jpg)'
- en: '*Figure 5-1: The decryption cascade from NXP’s i.MX series*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：NXP i.MX 系列的解密级联*'
- en: This procedure adds security to a device because keys and confidential data
    are not stored in plaintext and, at the same time, the necessary keys are loaded
    directly to the device’s cryptographic acceleration and assurance module (CAAM)
    where the decryption is performed, which means only the decrypted user data leaves
    this internal module at runtime.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程为设备增加了安全性，因为密钥和机密数据不会以明文形式存储，同时，必要的密钥直接加载到设备的加密加速和保障模块（CAAM），在这里进行解密，这意味着只有解密后的用户数据在运行时离开这个内部模块。
- en: '**Secrets in Application Code**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**应用程序代码中的秘密**'
- en: Additional hardware or security-enhanced main CPUs are not always an option
    because of their cost or because legacy hardware can no longer be upgraded. Is
    storing the keys in plain view inevitable? Not necessarily.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于成本或旧硬件无法再升级，额外的硬件或安全增强型主CPU并非总是可行的。将密钥明文存储是不可避免的吗？不一定。
- en: We can still move keys from the structured field of a filesystem into the more
    crowded form of an executable. Again, this approach demands further capability
    from potential attackers—namely, binary reverse engineering. Even if adversaries
    learn that a specific executable is responsible for unlocking an encrypted volume,
    they can’t extract the unlocking key immediately.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以将密钥从文件系统的结构化字段移到更为拥挤的可执行文件形式中。同样，这种方法要求潜在攻击者具备更高的能力——即二进制逆向工程。即使对手得知某个特定的可执行文件负责解锁加密的卷，他们也无法立即提取解锁密钥。
- en: '**NOTE**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Yes, security by obscurity is actually appearing in a security engineering
    book. At some point in real-world device engineering, you have to clutch at straws.*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*是的，安全通过模糊化实际上出现在一本安全工程书中。在现实世界的设备工程中，你确实有时需要抓住一根稻草。*'
- en: 'The term that describes such countermeasures is *obfuscation*. Its sole purpose
    is to make software reverse engineering harder, and this can be accomplished in
    several ways:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 描述这种对策的术语是*混淆*。其唯一目的是使软件逆向工程更加困难，可以通过多种方式实现：
- en: Replace common operations with complex but equivalent ones
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用复杂但等效的操作替代常见操作
- en: Overcomplicate control flow by rearranging command order without breaking functionality
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过重新排列命令顺序来使控制流更加复杂，但不破坏功能
- en: Insert redundant, unnecessary code and data
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入冗余、不必要的代码和数据
- en: Store parts of the code or data in encrypted or encoded form and decrypt or
    decode it only at runtime
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将部分代码或数据以加密或编码形式存储，并仅在运行时解密或解码
- en: Add randomness to data structures and control flows
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向数据结构和控制流中添加随机性
- en: Integrate anti-debugging measures that thwart analysis
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成防调试措施，以阻碍分析
- en: Split secrets into multiple parts, store them in different places, and assemble
    them only at runtime
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将密钥拆分成多个部分，存储在不同的位置，并仅在运行时组合它们
- en: This list isn’t comprehensive, and each bullet point can be implemented in a
    variety of ways and with many degrees of creativity. If you can’t do it yourself,
    tools are available that provide automatic code obfuscation functionality. However,
    such tools must be treated with caution because each given obfuscation tool might
    also have a corresponding counterpart, a *deobfuscation* tool, that reverts the
    added complexity and leaves attackers with code they can analyze much more efficiently.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表并不全面，每个要点都可以通过多种方式实施，并具有多种创造性。如果你自己做不到，也可以使用提供自动代码混淆功能的工具。不过，使用这些工具时必须小心，因为每种混淆工具可能也有对应的对立工具，即*反混淆*工具，它可以还原添加的复杂性，使攻击者能够更高效地分析代码。
- en: In 2002, an idea called *white-box cryptography* appeared in academic discussions
    as a way to overcome the problem of hiding secrets in software. This approach
    aims to perform cryptographic operations in software without revealing the underlying
    secret. That means the used cryptographic key diffuses into the operations of
    a crypto algorithm.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 2002年，名为*白盒加密*的概念出现在学术讨论中，作为解决在软件中隐藏秘密问题的一种方法。这种方法旨在在软件中执行加密操作，而不揭示底层的秘密。这意味着使用的加密密钥会扩散到加密算法的操作中。
- en: The first concepts of white-box cryptography transformed ciphers with hardcoded
    keys into key-dependent table lookups and injected random values into the internal
    calculations that would mask data at some point and demask it later. However,
    not surprisingly, this led to significant overhead in binary size and performance,
    and those implementations were also broken by cryptanalysis. Although academia
    has not yet found a perfect solution to the problem, many software companies use
    some kind of white-box cryptography in their products—for example, in mobile apps
    allowing users to download the binary and analyze it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒加密的最初概念将硬编码密钥的加密算法转变为基于密钥的表查找，并将随机值注入内部计算中，这些值在某些时候会掩盖数据，并在之后揭示出来。然而，毫不奇怪，这导致了二进制文件大小和性能上的显著开销，并且这些实现也被密码分析攻破了。虽然学术界尚未找到完美的解决方案，但许多软件公司在其产品中使用了某种形式的白盒加密——例如，在允许用户下载二进制文件并进行分析的移动应用中。
- en: 'No matter whether you apply custom obfuscation, commercial tools, or academic
    white-box crypto approaches, you should always keep in mind one attacker approach
    when hiding secrets in software binaries: code lifting. In these cases, binaries
    are used “as is”—for example, to unlock a LUKS container. The secret key itself
    isn’t of interest to attackers if they just have to use the executable as a key
    to an encrypted vault. This might happen in place, or the file of interest might
    be extracted and executed in an attacker-controlled environment.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用自定义的混淆技术、商业工具，还是学术领域的白盒加密方法，在将秘密信息隐藏在软件二进制文件中的时候，你始终应该牢记一种攻击者的方式：代码提升。在这种情况下，二进制文件“按原样”使用——例如，解锁一个LUKS容器。如果攻击者只是需要将可执行文件作为加密保险库的密钥，那么密钥本身对攻击者来说并不重要。这可能发生在原地，或者感兴趣的文件可能会被提取并在攻击者控制的环境中执行。
- en: '**Secure Password Storage**'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安全的密码存储**'
- en: 'Password-based authentication is a common method for verifying legitimate users
    at login, but it’s also used to unlock encrypted volumes and containers. Naturally,
    passwords are confidential data. Storing them in plaintext within a file or an
    executable for comparison during verification makes an attacker’s life easy. Once
    extracted, they can be used successfully to access confidential data. However,
    traditional encryption, as discussed as a protection measure for other classes
    of data, is usually not appropriate here. The specific verification process of
    passwords allows for implementing a different secure storage approach: *password
    hashes*.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 基于密码的身份验证是验证合法用户登录的常见方法，但它也用于解锁加密的卷和容器。自然，密码是机密数据。将它们以明文存储在文件或可执行文件中以便在验证过程中进行比对，会让攻击者变得很容易。一旦密码被提取，它们就可以被成功地用于访问机密数据。然而，如同我们讨论的其他数据保护措施一样，传统的加密通常并不适用于这里。密码的特定验证过程允许实现一种不同的安全存储方式：*密码哈希*。
- en: The one-way property of hash functions is useful in prohibiting attackers from
    retrieving a password from its hash value, even if extracted from the device.
    The verification still works because a given password can be efficiently hashed
    and compared to the stored value. However, in this trivial case, attackers could
    precompute *rainbow tables*, which are large collections of hash values for millions
    of passwords, maybe even all possible passwords with, for example, 10 characters.
    To protect against such attacks, a random *salt* is added to the password-hashing
    process that makes every hash unique and renders all rainbow tables useless.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数的单向特性对于防止攻击者从哈希值中恢复出密码非常有用，即使哈希值已从设备中提取。验证过程仍然有效，因为给定的密码可以高效地进行哈希计算，并与存储的值进行比较。然而，在这种简单的情况下，攻击者可能会预计算*彩虹表*，这是一个包含数百万个密码哈希值的大型集合，甚至可能包括所有可能的10个字符的密码。为了防止此类攻击，会在密码哈希过程中添加一个随机的*盐*，使每个哈希值都独一无二，并使所有彩虹表失效。
- en: Linux currently, still by default, uses a function based on SHA-512 hashes to
    generate salted user-password hashes. Also, the Password-Based Key Derivation
    Function 2 (PBKDF2) was standardized more than 20 years ago in RFC 2898\. It’s
    based on HMACs using hash functions like SHA-1, SHA-256, or SHA-512\. Both approaches
    are definitely better than plaintext password storage, but modern attackers use
    graphics processing units (GPUs), FPGAs, and dedicated application-specific integrated
    circuits (ASICs) to break password hashes literally with brute force.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Linux目前仍默认使用基于SHA-512哈希的函数来生成加盐的用户密码哈希。此外，基于密码的密钥派生函数2（PBKDF2）在20多年前已经在RFC 2898中标准化。它基于HMAC，使用像SHA-1、SHA-256或SHA-512这样的哈希函数。两种方法无疑比明文密码存储要好，但现代攻击者使用图形处理单元（GPU）、现场可编程门阵列（FPGA）和专用的应用特定集成电路（ASIC）通过暴力破解密码哈希。
- en: Therefore, for future-proof products, the use of modern representatives of this
    field is recommended. Typical examples are scrypt, standardized in RFC 7914 from
    2016; its successor yescrypt; and Argon2, which won the Password Hashing Competition
    in 2015\. These algorithms share the common goal of enhancing cracking resistance
    by parameterizable password-hashing algorithms that consider dimensions like computation
    time, necessary memory, and required number of parallel CPU threads, which is
    meant to discourage even attackers who have access to a variety of hardware resources
    and computing capacity.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了使产品具备未来保障，建议使用该领域的现代代表。典型的例子有scrypt，它在2016年被标准化为RFC 7914；它的继任者yescrypt；以及在2015年赢得密码哈希竞赛的Argon2。这些算法的共同目标是通过可参数化的密码哈希算法增强破解抗性，这些算法考虑了计算时间、所需内存和并行CPU线程数量等维度，旨在阻止那些即使拥有多种硬件资源和计算能力的攻击者。
- en: '**NOTE**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Even if confidentiality is the main protection goal for a password, the consequences
    of someone being able to change it are severe. Replacing the password hash of
    the root user with one of a known password is a pretty common attack that opens
    all doors for an adversary. You should seriously consider integrity protection
    for password storage, as discussed in [Chapter 8](ch08.xhtml#ch08).*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*即使保密性是密码的主要保护目标，但如果有人能够更改密码，后果将非常严重。用已知密码的哈希替换root用户的密码哈希是一个相当常见的攻击，它为对手打开了所有大门。你应该认真考虑对密码存储的完整性保护，如[第8章](ch08.xhtml#ch08)中讨论的那样。*'
- en: '**Case Study: Encrypted File Containers on Linux**'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**案例研究：Linux上的加密文件容器**'
- en: In this case study, let’s assume that one of your legacy devices doesn’t have
    any secure storage for confidential data implemented. While visiting an international
    fair, members of your engineering team recognize that a currently unknown competitor
    uses one of your proprietary GUI applications and the associated media content
    that you produced with great effort to fit the needs of your target audience.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例研究中，假设你的一个遗留设备没有实现任何安全存储来保护机密数据。在参加一个国际展会时，你的工程团队成员注意到一个目前未知的竞争对手使用了你们的一款专有GUI应用程序和你们精心制作的相关媒体内容，满足了目标受众的需求。
- en: Back home, you discuss the issue with your team and management. After an initial
    investigation, it becomes clear that stealing the data required nothing more than
    opening your device and reading the contents from flash memory, which your competitor
    obviously succeeded in doing. To limit future damages, you decide to establish
    at least a basic protection by using LUKS containers. Your current flash memory
    device has a capacity of 256MB. The basic Linux system and all associated tools
    occupy roughly 136MB. Your proprietary executables together with their data and
    configuration files sum up to roughly 19MB, while the high-quality video content
    consumes 73MB.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 回到家后，你与团队和管理层讨论了这个问题。经过初步调查，显然，窃取数据所需的只是打开设备并从闪存中读取内容，而你的竞争对手显然已经成功做到了这一点。为了限制未来的损失，你决定通过使用LUKS容器至少建立一个基本的保护措施。你当前的闪存设备容量为256MB。基本的Linux系统及所有相关工具大约占用136MB。你的专有可执行文件及其数据和配置文件大约占19MB，而高质量的视频内容占用73MB。
- en: You want to protect the latter two classes of data. Because memory requirements
    are rather tight on your platform and you’d like to separate code from media,
    you plan on creating a 25MB container for executables and files containing intellectual
    property, and a 90MB container for video files.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你想保护后两类数据。由于平台上的内存需求相当紧张，而且你希望将代码与媒体分开，你计划创建一个25MB的容器用于可执行文件和包含知识产权的文件，以及一个90MB的容器用于视频文件。
- en: '***Crypto Benchmarking***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加密基准测试***'
- en: As a first step, you add `cryptsetup` to your device’s root filesystem to be
    able to work with LUKS containers. You also enable `CONFIG_CRYPTO_SERPENT` and
    `CONFIG_CRYPTO_TWOFISH` in your Linux kernel config because you’ve heard that
    `cryptsetup` supports them and you wonder whether they might outperform AES on
    your STM32MP157F SoC. [Listing 5-1](ch05.xhtml#ch05list01) shows the results of
    `cryptsetup`’s own performance-benchmarking tool.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，你将 `cryptsetup` 添加到设备的根文件系统中，以便能够使用 LUKS 容器。你还在 Linux 内核配置中启用了 `CONFIG_CRYPTO_SERPENT`
    和 `CONFIG_CRYPTO_TWOFISH`，因为你听说 `cryptsetup` 支持它们，并且想知道它们是否能在你的 STM32MP157F SoC
    上超越 AES。[清单 5-1](ch05.xhtml#ch05list01) 显示了 `cryptsetup` 自带性能基准测试工具的结果。
- en: '[PRE0]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 5-1: The benchmarking results offered by* cryptsetup'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-1：由* cryptsetup 提供的基准测试结果'
- en: 'At first, this output shows that multiple functions for password storage are
    analyzed to give you an idea about which parameters of the specific function might
    be reasonable choices for your device. You want to set parameters like iteration
    count to values that lead to acceptable performance on your device (for example,
    unlocking within two seconds) but leave an attacker with maximum cracking effort.
    In this case, since you don’t have specific requirements, you stick with the default
    of LUKS2 volumes: Argon2.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，这个输出显示了多个密码存储功能的分析，帮助你了解哪些特定功能的参数可能是你设备的合理选择。你希望将像迭代次数这样的参数设置为可以在你的设备上提供可接受性能的值（例如，解锁时间在两秒内），同时让攻击者的破解工作量最大化。在这种情况下，由于没有特定的需求，你选择保持
    LUKS2 卷的默认设置：Argon2。
- en: The encryption/decryption benchmark shows that AES is the fastest algorithm
    no matter whether you use it in CBC mode or XTS (XEX-Based Tweaked-Codebook Mode
    with Ciphertext Stealing). It also seems that AES-CBC performance is accelerated
    by the STM32MP157F crypto hardware. On the other hand, XTS is the default and
    recommended operation mode for `cryptsetup` and hard disk encryption in general.
    Since you highly value performance and don’t want the container encryption to
    impact any device functionality, you choose AES-CBC, and since there’s practically
    no difference between 128-bit and 256-bit keys, you go with a 256-bit key.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 加密/解密基准测试显示，无论是使用 AES 的 CBC 模式还是 XTS（基于 XEX 的调整密码本模式带有密文盗取），AES 都是最快的算法。AES-CBC
    性能似乎还得到了 STM32MP157F 加密硬件的加速。另一方面，XTS 是 `cryptsetup` 和硬盘加密的一般推荐默认操作模式。由于你非常重视性能，并且不希望容器加密影响任何设备功能，你选择了
    AES-CBC，并且由于 128 位和 256 位密钥几乎没有差异，你选择了 256 位密钥。
- en: '**NOTE**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You might wonder how XTS can use 512-bit keys with AES. In short, it doesn’t!
    It requires two keys (in this case, two 256-bit keys, which add up to 512 bits),
    but the security level is 256-bit.*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能会好奇 XTS 如何使用 512 位密钥与 AES 配合使用。简而言之，它并没有！它需要两个密钥（在这种情况下是两个 256 位密钥，总共加起来是
    512 位），但安全级别仍然是 256 位。*'
- en: '***Container Creation***'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***容器创建***'
- en: After determining the crypto parameters, you can start by creating random files
    and corresponding key files for your two containers. The container for executables
    takes 25MB, and the one for media is based on a 90MB file, as shown in [Listing
    5-2](ch05.xhtml#ch05list02). Both keys are initialized with 32 bytes, which equals
    256 bits.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定加密参数后，你可以开始为你的两个容器创建随机文件和相应的密钥文件。用于可执行文件的容器占用 25MB，媒体容器则基于一个 90MB 的文件，如 [清单
    5-2](ch05.xhtml#ch05list02) 所示。两个密钥都初始化为 32 字节，即 256 位。
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 5-2: A random initialization of containers and key files*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-2：容器和密钥文件的随机初始化*'
- en: In the next step, as shown in [Listing 5-3](ch05.xhtml#ch05list03), you use
    `cryptsetup` to provide the basic structure of a LUKS container via the `luksFormat`
    command.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步，如 [清单 5-3](ch05.xhtml#ch05list03) 所示，你使用 `cryptsetup` 通过 `luksFormat` 命令提供
    LUKS 容器的基本结构。
- en: '[PRE2]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 5-3: The creation of LUKS2 containers*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-3：LUKS2 容器的创建*'
- en: Since you want to use Argon2 for passphrase verification, and you’d like to
    enjoy the robustness that comes with a second header copy in LUKS2, you select
    the second version of the header format with `--type luks2`. The earlier choice
    of AES in CBC mode with encrypted salt-sector initialization vector (ESSIV) is
    configured using `--cipher=aes-cbc-essiv:sha256`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你希望使用 Argon2 进行密码验证，并且想要享受 LUKS2 中第二个头部副本带来的鲁棒性，你选择使用 `--type luks2` 来选择第二版本的头部格式。之前选择的基于
    AES 的 CBC 模式并带有加密盐扇区初始化向量（ESSIV）的配置，通过 `--cipher=aes-cbc-essiv:sha256` 进行配置。
- en: At this point, the containers and their structures are ready, but you can’t
    store anything in these virtual vaults yet. The file containers need to be unlocked
    by `luksOpen` to create an ext3 filesystem inside. Note that after unlocking the
    LUKS container, as shown in [Listing 5-4](ch05.xhtml#ch05list04), it is mapped
    to the device */dev/mapper/dm_exec_enc*, which is then mounted to the newly created
    directory */mnt/exec_enc*. The same can be done for the encrypted media container
    with device */dev/mapper/dm_media_enc* and mount point */mnt/media _enc*, respectively.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，容器及其结构已经准备好，但你还不能在这些虚拟金库中存储任何东西。需要通过 `luksOpen` 解锁文件容器，以在其中创建 ext3 文件系统。注意，解锁
    LUKS 容器后，如[清单 5-4](ch05.xhtml#ch05list04)所示，它会映射到设备 */dev/mapper/dm_exec_enc*，然后挂载到新创建的目录
    */mnt/exec_enc*。同样的操作也可以用于加密的媒体容器，其设备为 */dev/mapper/dm_media_enc*，挂载点为 */mnt/media_enc*。
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 5-4: Unlocking a container for filesystem creation and mounting*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-4：解锁容器以创建文件系统并挂载*'
- en: It seems like you’re almost finished. Let’s use `luksDump`, as shown for the
    executables’ container in [Listing 5-5](ch05.xhtml#ch05list05), to check whether
    the right properties are set.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来你已经快完成了。让我们使用 `luksDump`，如[清单 5-5](ch05.xhtml#ch05list05)所示，来检查是否设置了正确的属性。
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 5-5: Double-checking container properties*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-5：再次检查容器属性*'
- en: The output completely matches our requirements.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 输出完全符合我们的要求。
- en: '***Efficiency Analysis***'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***效率分析***'
- en: Before you start populating the filesystem, let’s take one last glance at the
    efficiency of this construction. The `fdisk` and `df` tools will help you understand
    how much memory is lost for the LUKS header and how much overhead is introduced
    by the ext3 filesystem. [Listing 5-6](ch05.xhtml#ch05list06) has the details.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始填充文件系统之前，让我们最后检查一下这个构建的效率。`fdisk` 和 `df` 工具将帮助你了解 LUKS 头部损失了多少内存，以及 ext3
    文件系统引入了多少开销。[清单 5-6](ch05.xhtml#ch05list06)中有详细信息。
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 5-6: An efficiency check regarding memory usage*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-6：关于内存使用效率的检查*'
- en: Unfortunately, this didn’t turn out as planned. The 25MB container has only
    4MB of space left to store data, and the other one with a size of 90MB leaves
    you with 62MB. It’s clearly visible that the difference between the sizes of the
    containers and their corresponding devices in the device mapper infrastructure
    is approximately 16MB. Actually, if you had studied the LUKS documentation thoroughly,
    you’d have known that the headers of LUKS1 and LUKS2 consume 2MB and 16MB, respectively.
    While that’s not an issue for hard disks with hundreds of gigabytes, it might
    turn out to be a pain point for memory-constrained embedded systems.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这并没有按计划进行。25MB 的容器只剩下 4MB 的空间来存储数据，而另一个大小为 90MB 的容器则剩余 62MB。明显可以看到，容器大小与其在设备映射器基础设施中的相应设备之间的差异大约为
    16MB。实际上，如果你仔细研究过 LUKS 文档，你会知道 LUKS1 和 LUKS2 的头部分别消耗了 2MB 和 16MB。虽然这对几百GB的硬盘来说不是问题，但对于内存受限的嵌入式系统来说，这可能会成为一个痛点。
- en: You can solve the issue by using LUKS1 headers and going without the LUKS2 improvements,
    which would be acceptable in practice, or even by using the “plain mode” of `cryptsetup`
    that doesn’t store any metadata in memory. The latter choice might be the most
    efficient but comes with significant management limitations. LUKS1 would probably
    be a reasonable choice.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 LUKS1 头部而不启用 LUKS2 的改进来解决这个问题，这在实际操作中是可以接受的，或者甚至使用不在内存中存储任何元数据的 `cryptsetup`
    的“纯模式”。后者可能是最有效的选择，但也带来了显著的管理限制。LUKS1 可能是一个合理的选择。
- en: '[Listing 5-6](ch05.xhtml#ch05list06) also shows that the ext3 filesystem reduces
    the available memory because of necessary allocation tables and journal data.
    However, for static storage of executables, configuration files, and media content,
    journaling might not be necessary, and you could also deploy an ext2 filesystem
    to squeeze out more bytes of available memory.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-6](ch05.xhtml#ch05list06)还显示，ext3 文件系统由于需要分配表和日志数据，会减少可用内存。然而，对于静态存储可执行文件、配置文件和媒体内容，日志记录可能不是必需的，你也可以部署
    ext2 文件系统以释放更多可用内存。'
- en: After repeating the whole process while changing `luks2` to `luks1` and `ext3`
    to `ext2`, the situation looks different, as shown in [Listing 5-7](ch05.xhtml#ch05list07).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 `luks2` 更改为 `luks1` 和 `ext3` 更改为 `ext2` 后重复整个过程，情况有所不同，如[清单 5-7](ch05.xhtml#ch05list07)所示。
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 5-7: The memory usage efficiency with LUKS1 and ext2*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-7：LUKS1 和 ext2 的内存使用效率*'
- en: A loss of 4MB and 13MB, respectively, still occurs, but the remaining space
    just fulfills the requirements of this case study.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 分别损失4MB和13MB的情况仍然发生，但剩余的空间足以满足本案例的需求。
- en: '**NOTE**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意事项**'
- en: '*If you find yourself in a similar situation in real life but can’t reach your
    requirements, you can still think about switching to native filesystem encryption
    (for example, with ext4), or you can use compressed read-only filesystems like
    CramFS and SquashFS.*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你在现实生活中遇到类似情况，但无法满足你的需求，你仍然可以考虑切换到本地文件系统加密（例如使用ext4），或者使用压缩的只读文件系统，如CramFS和SquashFS。*'
- en: After solving these unexpected, non-security-related problems, the final question
    of how to securely unlock the created containers remains. Since you don’t have
    a secure element within your device and your main CPU doesn’t provide OTP memory
    for this purpose, you may decide to hide the unlocking process in an executable
    within your *initramfs*, which is executed at boot. To be clear, you won’t win
    a prize for “security by design” with such an approach, but it might set the bar
    higher for successful attacks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些与安全无关的意外问题后，最后一个问题是如何安全地解锁已创建的容器。由于你的设备中没有安全元素，且主CPU也没有为此提供OTP内存，你可能决定将解锁过程隐藏在*initramfs*中的可执行文件里，该文件在启动时执行。需要明确的是，采用这种方法并不会为你赢得“安全设计”奖项，但它可能会提高成功攻击的门槛。
- en: You can consider including hardware-based system identifiers, as described in
    [Chapter 6](ch06.xhtml#ch06), to derive a device-unique unlocking secret instead
    of a global software-only solution that can be emulated easily off-device. Further,
    you might implement secret sharing methods like splitting the key-file contents
    into multiple pieces and dynamically combining them to obtain the final secret
    at runtime, which at least hampers simple static analysis attacks. In any case,
    you have to be aware that an attacker who obtained root privileges is able to
    circumvent all of that and access the decrypted filesystem at runtime. And for
    the next product generation, you’ll make secure storage a priority from day one.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以考虑包括硬件基础的系统标识符，如[第6章](ch06.xhtml#ch06)中所述，以衍生出设备唯一的解锁密钥，而不是仅依赖于容易在设备外部仿真的全球性软件解决方案。此外，你还可以实现秘密共享方法，例如将密钥文件内容拆分成多个部分，并在运行时动态组合它们以获得最终的密钥，这至少能够阻碍简单的静态分析攻击。无论如何，你必须意识到，获得root权限的攻击者能够绕过所有这些措施，并在运行时访问解密后的文件系统。对于下一代产品，你将从第一天起就将安全存储作为优先事项。
- en: '**Read-Out Protection as a Low-Cost Solution**'
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**读取保护作为低成本解决方案**'
- en: Some small embedded systems are low cost, don’t have a secure memory, aren’t
    able to run Linux, and can’t afford external secure elements at all. These devices
    might be based on microcontrollers running a real-time operating system (RTOS)
    or even only bare-metal software.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一些小型嵌入式系统成本低廉，缺乏安全内存，无法运行Linux，且完全无法承担外部安全元素。这些设备可能基于运行实时操作系统（RTOS）的微控制器，甚至仅运行裸机软件。
- en: However, even those cases might have data that deserves a certain level of confidentiality
    protection. Since these devices often store all their code and data within internal
    flash memory, restricting read access to flash memory might be a simple yet effective
    measure to protect sensitive information. The activation of *read-out protection*—for
    example, by burning the corresponding fuses—leads to a device that can execute
    the internally stored code but denies requests to extract its nonvolatile memory
    contents.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使是这些情况，也可能有数据需要一定级别的机密性保护。由于这些设备通常将所有代码和数据存储在内部闪存中，限制对闪存的读取访问可能是一种简单但有效的保护敏感信息的措施。启用*读取保护*——例如，通过烧录相应的熔丝——将使设备能够执行内部存储的代码，但拒绝提取其非易失性存储器内容的请求。
- en: Even so, be aware that physical attackers with suitable equipment can circumvent
    these basic protection features of low-cost microcontrollers and get access to
    your confidential data.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 即便如此，仍需注意，配备合适设备的物理攻击者能够绕过低成本微控制器的基本保护功能，从而访问你的机密数据。
- en: '**Summary**'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter covered several classes of data that might require confidentiality
    protection, from intellectual property to media content to cryptographic secrets.
    Unfortunately, no perfect solution exists for storing such sensitive data in embedded
    systems. One reason for this dilemma is that, in comparison to a PC, embedded
    systems have no active users who keep the master secrets in their brains to enter
    them whenever needed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了可能需要保密保护的几类数据，从知识产权到媒体内容，再到加密密钥。遗憾的是，对于在嵌入式系统中存储此类敏感数据，目前没有完美的解决方案。导致这一困境的一个原因是，与PC相比，嵌入式系统没有主动的用户，他们会将主密钥记在脑中并在需要时输入。
- en: Since all secrets have to be available in the same device at all times, the
    only thing we can do is hide those secrets in well-protected places, like secure
    elements, internal OTP memory, or within obfuscated software. All these solutions
    aim to increase the barriers an attacker has to break down for a successful compromise,
    but each comes with its own advantages and drawbacks.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有的秘密必须始终在同一设备上可用，我们能做的唯一事情就是将这些秘密隐藏在经过良好保护的地方，比如安全元件、内部OTP内存或加密软件中。所有这些解决方案的目标是增加攻击者需要突破的障碍，以实现成功的攻击，但每个方案都有其自身的优点和缺点。
- en: Many approaches push secret disclosure and usage to the runtime phase of a device,
    which requires an adversary to take control of certain parts of a running device
    or even to execute custom code. Therefore, the quality and success of confidentiality
    protection have a strong relation to the runtime integrity of a device, which
    we’ll discuss in [Chapter 8](ch08.xhtml#ch08).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 许多方法将秘密的披露和使用推向设备的运行时阶段，这要求攻击者控制设备某些部分，甚至执行自定义代码。因此，保密保护的质量和成功与设备的运行时完整性有着密切关系，我们将在[第8章](ch08.xhtml#ch08)中讨论这一点。
