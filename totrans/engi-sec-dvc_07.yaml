- en: '**5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CONFIDENTIAL DATA STORAGE AND SECURE MEMORY**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Embedded systems store and process a variety of data. Some of this data is trivial
    because it is the same on many platforms or can be guessed or derived easily.
    However, a certain amount of data, usually known as *sensitive*, *secret*, or
    *confidential* data, requires careful treatment.
  prefs: []
  type: TYPE_NORMAL
- en: The information that this data carries is valuable, and its disclosure would
    likely lead to negative consequences. One example is *intellectual property* forged
    into software algorithms, proprietary protocols, and application content. Further,
    *cryptographic material* like secret keys and passwords contain critical information
    by nature. A device’s *lifetime data* like sensor data, log entries, and sent
    or received messages might also fit into this category.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter starts by looking at data that should be stored in a confidential
    manner and the dilemma of how to keep secrets in embedded systems. Next, I’ll
    describe your options for storing confidential data from the OS level to the hardware
    to obfuscated software, and the corresponding pros and cons. A case study in this
    chapter will then walk through using encrypted file containers on an embedded
    system running Linux.
  prefs: []
  type: TYPE_NORMAL
- en: '**Confidential Data**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The identification of confidential data and the awareness of related threats
    is always the first step toward its protection. The following examples are meant
    to create the necessary mindset.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that your research department invents a superefficient engine-control
    algorithm that runs a car on significantly less fuel than competing products.
    Although you probably filed a patent, that might not be enough to protect your
    device from piracy and copycats. The value of the invention becomes reality only
    if you implement it in your control device. There, it’s likely available as a
    compiled software executable or maybe as part of a kernel module. Both are stored
    in the device’s filesystem, and if an attacker can read the filesystem, they can
    reverse engineer your algorithm and directly benefit from your research investment.
    This situation is clearly one you’ll want to avoid, which means you must protect
    the confidentiality of the control algorithm’s implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Some household and consumer devices contain a lot of media content like pictures
    and videos, and their production is anything but cheap. Storing them in plain
    sight in a device’s filesystem is rarely a good idea. Attackers might copy them,
    upload them to their favorite online platform, and reuse them for their own purposes,
    which could not only cause financial losses but also damage the reputation of
    your product and company.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, the need to protect cryptographic material seems to go without
    saying. However, many devices store the private keys corresponding to their certificate-based
    authentication in their standard filesystems. Reading and copying these keys opens
    the door for impersonation attacks. In addition, especially on the application
    level, the passwords that control user authentication are sometimes stored in
    plaintext within configuration files or software binaries. Of course, extracting
    a password allows an adversary to authenticate successfully with the device because
    the credential wasn’t stored in a way that protects confidentiality.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the really interesting data is generated during a device’s lifetime.
    Think, for example, of the privacy implications for biometric data that a product
    may collect through fingerprint readers or location data that creates movement
    profiles of users. This information often has a high confidentiality requirement,
    maybe even by laws like the European GDPR. Failure of protection can lead to fines
    up to €20 million or 4 percent of a company’s total global turnover.
  prefs: []
  type: TYPE_NORMAL
- en: Stored data history in a device can reveal even more. For example, in industrial
    production environments, the data history might allow attackers to reconstruct
    machine utilization and output figures, which could be valuable information for
    competitors. Again, confidentiality protection would be a crucial device feature.
  prefs: []
  type: TYPE_NORMAL
- en: Almost every modern device contains data that deserves confidentiality protection.
    Make sure to keep that in mind when doing your threat and risk analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Dilemma of Keeping Secrets on Embedded Systems**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Embedded systems often include a toxic combination of properties. First, they
    have to be able to boot and run without user interaction, which means that everything
    relevant for correct operation has to be stored within the device, including all
    secrets. Second, attackers can usually obtain a device for themselves and analyze
    it thoroughly. This analysis includes not only network-based investigations but
    also physical eavesdropping on communication lines within the product and the
    extraction of nonvolatile memory contents like firmware images and filesystem
    partitions for reverse-engineering purposes. From a theoretical point of view,
    confidentiality protection for secrets in a device that can be analyzed on all
    levels can’t be guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: However, from a more pragmatic perspective, the question always is, “How much
    effort does an adversary have to spend to reach a comprehensive understanding
    of the device at hand, including its secrets?”
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider the intellectual property example I mentioned previously. Imagine
    you’re responsible for keeping the software implementation of a highly sophisticated
    algorithm secret, although it has to be stored and used within your device. Some
    people might immediately think that reading the firmware from flash memory, identifying
    the executable, and reverse engineering the algorithm is highly complicated, so
    they assume they don’t need any protection measures.
  prefs: []
  type: TYPE_NORMAL
- en: That assumption might be true for attackers like script kiddies. However, consider
    criminals seeking financial gain. For them, dumping flash memory and mounting
    a filesystem doesn’t seem like too much work. Further, free and open source tools
    like Radare2 and Ghidra enable everybody with interest to do at least basic software
    reverse engineering. If confidentiality has an increased priority in your product,
    these attackers should definitely be in scope.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, some cases are much simpler to attack. For devices that store their
    firmware on removable media like a microSD card that many off-the-shelf laptops
    can read, flash dumping isn’t even necessary. If the confidential information,
    such as an RSA private key, is stored in a directly reusable format like Privacy-Enhanced
    Mail (PEM), an “attack” could be performed in no time, even by a script kiddie.
    Also, not every executable even needs to be reverse engineered. *Code lifting
    attacks*, for example, just take the binary as is, copy it to another device,
    and run it. If it fulfills its purpose, there’s no need to access its proprietary
    details.
  prefs: []
  type: TYPE_NORMAL
- en: '**Secure Filesystem Approaches**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, you might wonder, “Is there such a thing as an encrypted file-system?
    That would solve all our problems.” There is, but it doesn’t make the problem
    go away completely. Three common options are available that provide confidentiality
    protection for files: encrypted stacked filesystems, native filesystem encryption,
    and encrypted block devices.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Encrypted Stacked Filesystems***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *stacked filesystem* is an additional filesystem structure on top of an existing
    one, which means that standard filesystems like ext3 aren’t touched and the encryption
    happens in a layer above. In this case, the content and the names of files are
    encrypted—for example, for all files in a specific directory. However, the number
    of files and their metadata is readable.
  prefs: []
  type: TYPE_NORMAL
- en: Stacking filesystems also comes with a certain performance overhead, and filenames
    might be subject to additional restrictions. For years, EncFS, which uses the
    Filesystem in Userspace (FUSE) framework, has been a popular and easy-to-use example
    of this approach, but it seems that development has stalled. An aspiring successor
    might be gocryptfs.
  prefs: []
  type: TYPE_NORMAL
- en: A competitor that operates in kernel space is eCryptfs. While eCryptfs might
    be a bit harder to configure, it exhibits better performance in certain cases.
    However, its development is also stalled. File-based encryption (FBE) with stacked
    filesystems seems to be out of fashion.
  prefs: []
  type: TYPE_NORMAL
- en: '***Native Filesystem Encryption***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Today, filesystems like ext4, F2FS, and UBIFS directly support the encrypted
    storage of files. Compared to filesystem stacking, this allows for more efficient
    integration and operation.
  prefs: []
  type: TYPE_NORMAL
- en: Popular users of this native FBE approach include the Android and Chrome OSs.
    The underlying features are implemented in the Linux kernel and use the kernel’s
    crypto API for encryption. The user-space tool for configuring and managing encrypted
    directories is called `fscrypt`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Encrypted Block Devices***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: File-based approaches always leave folder structures and metadata unencrypted.
    A common way to avoid this information leakage is *full-disk encryption (FDE)*.
    In Linux, this means that the encryption layer lies below the filesystem, on the
    block device level. It doesn’t matter whether this block device is a whole disk,
    a partition, or a file container; it’s encrypted as a whole, and its content isn’t
    distinguishable from random information.
  prefs: []
  type: TYPE_NORMAL
- en: The most common representative of this class for Linux is `dm-crypt`, which
    is based on the device mapper infrastructure and uses the kernel’s crypto API.
    The `cryptsetup` user-space tool can create encrypted volumes, and it supports
    the popular Linux Unified Key Setup (LUKS) container format that enables various
    key-management functionalities for encrypted volumes.
  prefs: []
  type: TYPE_NORMAL
- en: The TrueCrypt successor VeraCrypt is another popular tool, which, for example,
    also enables the chaining of two ciphers to enhance decryption resistance.
  prefs: []
  type: TYPE_NORMAL
- en: '***Recommendations***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Encrypted data storage clearly doesn’t have a lack of options. Whether FDE or
    FBE fits your needs largely depends on your device and its corresponding security
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: If, from your point of view, the location, number, and size of files already
    convey sensitive information to an attacker, FDE is probably the solution that
    leads to the highest possible security. However, FBE offers more flexibility—for
    example, for hosting a heterogeneous set of files within the same filesystem so
    that some data is always available and readable to all processes, but confidential
    data is decrypted selectively per directory. It could also have application-specific
    keys, which allows for more fine-grained confidentiality protection.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Passphrase***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'No matter which implementation you choose, one big problem will always remain:
    all the tools require a passphrase to either directly unlock protected directories
    and volumes or to unlock a key file subsequently used to unlock encrypted data.
    Even the word *passphrase* indicates that this concept is meant for users to enter
    credentials as we do on our PCs at boot time.'
  prefs: []
  type: TYPE_NORMAL
- en: However, most embedded systems don’t have active users sitting in front of them,
    able to enter a passphrase to unlock hard-disk encryption when booting up. The
    usual next question is, “Where to hide the secret that unlocks encryption?”
  prefs: []
  type: TYPE_NORMAL
- en: '**Secure Memory in Hardware**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every now and then, I hear people (and companies) say that *secure memory* implemented
    in hardware is the solution to the embedded system credentials problem. However,
    that’s only partially true.
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of hardware-based secure memory is that it implements a strong
    physical segmentation between the classic nonvolatile memory, where the firmware
    is stored, and a dedicated security module, which can be reached only by a specific
    interface. Further, it allows for tamper detection or resistance, and the stored
    bits might be buried deep inside a chip, making hardware attacks difficult and
    requiring sophisticated equipment.
  prefs: []
  type: TYPE_NORMAL
- en: However, this approach also has downsides. Most obviously, only small amounts
    of data, usually cryptographic keys, can be stored in such protected memory. In
    addition, these secrets often *have to leave* the security module to serve their
    purpose, like unlocking a LUKS container. In such cases, attackers might capture
    the keys on their way over a communication line.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, this issue has been practically exploited when external security
    modules transferred secrets to a main CPU and adversaries eavesdropped on the
    physical PCB traces. Other attacks actively communicate with the secure memory
    and, for example, ask it to encrypt, decrypt, or sign arbitrary data for an attacker.
    So merely *having* a secure memory doesn’t enhance your device’s security significantly;
    it also must be *integrated* securely.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, whether the use of secure memory makes sense depends on the specific
    application and implementation details. Often, it at least adds another layer
    of required attacker knowledge—namely, observing secure memory communication at
    device runtime instead of “only” extracting secrets from firmware or filesystems.
    Let’s consider the options regarding secure memory.
  prefs: []
  type: TYPE_NORMAL
- en: '***External Secure Memory***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The “traditional” way of adding a secure memory device to your design is by
    integrating a dedicated microchip to your device’s PCB and connecting it to the
    main microprocessor. The most prominent player in this area is the Trusted Platform
    Module (TPM).
  prefs: []
  type: TYPE_NORMAL
- en: You can purchase discrete TPMs from a variety of manufacturers like Infineon,
    NXP, and ST. They’re well established in the PC world because Microsoft Windows
    made them a hard requirement. A basic use case is that a user can unlock a TPM
    key, which is then used to unlock volumes protected by BitLocker. Of course, this
    is a simplified view of the process, and that’s where the problem comes in.
  prefs: []
  type: TYPE_NORMAL
- en: A TPM is much more than secure memory. It comes with authorization layers, with
    key hierarchies, and with a specification that’s more than 1,000 pages for the
    current TPM version. Although tools are available to make use of TPMs under Linux,
    like `tpm2-tools` and `ibm-tss`, using a TPM seems to be too complex for average
    products and development teams.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, secure microcontroller manufacturers provide interesting alternatives
    that target automotive, industrial, and IoT applications. Similar to a TPM, products
    like Infineon’s OPTIGA Trust X, NXP’s Edge-Lock SE050 family, and Microchip’s
    ATECC608B come with a broad set of crypto algorithms, from symmetric ciphers like
    AES, to hash functions and HMACs, to asymmetric crypto like RSA and ECDSA. Of
    course, they also provide secure memory for cryptographic keys. Their promise
    is that these devices require much less integration effort for IoT products.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, a TPM used only as secure memory is like breaking a butterfly on
    a wheel. Leaner alternatives might be more suitable for the embedded system world.
    However, when deciding whether to use a dedicated hardware security module, you
    should also consider the topics of secure device identity and secure communication,
    as discussed in [Chapters 6](ch06.xhtml#ch06) and [7](ch07.xhtml#ch07). In any
    case, make sure you understand the implications that secret keys might be communicated
    over interfaces accessible to physical attackers.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The TPM 2.0 specification provides a means to encrypt the communication between
    host CPU and TPM, which adds complexity for attackers but also for engineers.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Internal Secure Memory***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In contrast to discrete hardware components that have to be designed in and
    soldered to a PCB, security modules and secure storage facilities are already
    deeply integrated into the main CPU of a device.
  prefs: []
  type: TYPE_NORMAL
- en: Known as *integrated TPMs* or *firmware TPMs*, these alternatives to dedicated
    hardware TPMs are offered by chip vendors like AMD and Intel. Besides reduced
    PCB integration costs, the striking advantage of this concept is that on-chip
    communication is much harder to capture than signals running across a PCB. Of
    course, the complexity issue of TPMs stays the same.
  prefs: []
  type: TYPE_NORMAL
- en: On the other side, modern SoCs often offer one-time programmable (OTP) memory
    that can be used to store at least a master key. A common example is the cascaded
    encryption concept of NXP’s i.MX series. There, an OTP master key (OTPMK) is programmed
    to the device during production. Subsequently, this key is used to encrypt a data
    encryption key (DEK) to obtain a so-called DEK *binary large object (BLOB)*. In
    turn, developers can then use the DEK to encrypt application data.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-1](ch05.xhtml#ch05fig01) shows the procedure running on a device
    from the master key OTP reading to the application data decryption.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: The decryption cascade from NXP’s i.MX series*'
  prefs: []
  type: TYPE_NORMAL
- en: This procedure adds security to a device because keys and confidential data
    are not stored in plaintext and, at the same time, the necessary keys are loaded
    directly to the device’s cryptographic acceleration and assurance module (CAAM)
    where the decryption is performed, which means only the decrypted user data leaves
    this internal module at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '**Secrets in Application Code**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Additional hardware or security-enhanced main CPUs are not always an option
    because of their cost or because legacy hardware can no longer be upgraded. Is
    storing the keys in plain view inevitable? Not necessarily.
  prefs: []
  type: TYPE_NORMAL
- en: We can still move keys from the structured field of a filesystem into the more
    crowded form of an executable. Again, this approach demands further capability
    from potential attackers—namely, binary reverse engineering. Even if adversaries
    learn that a specific executable is responsible for unlocking an encrypted volume,
    they can’t extract the unlocking key immediately.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Yes, security by obscurity is actually appearing in a security engineering
    book. At some point in real-world device engineering, you have to clutch at straws.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The term that describes such countermeasures is *obfuscation*. Its sole purpose
    is to make software reverse engineering harder, and this can be accomplished in
    several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Replace common operations with complex but equivalent ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overcomplicate control flow by rearranging command order without breaking functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insert redundant, unnecessary code and data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store parts of the code or data in encrypted or encoded form and decrypt or
    decode it only at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add randomness to data structures and control flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate anti-debugging measures that thwart analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Split secrets into multiple parts, store them in different places, and assemble
    them only at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list isn’t comprehensive, and each bullet point can be implemented in a
    variety of ways and with many degrees of creativity. If you can’t do it yourself,
    tools are available that provide automatic code obfuscation functionality. However,
    such tools must be treated with caution because each given obfuscation tool might
    also have a corresponding counterpart, a *deobfuscation* tool, that reverts the
    added complexity and leaves attackers with code they can analyze much more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: In 2002, an idea called *white-box cryptography* appeared in academic discussions
    as a way to overcome the problem of hiding secrets in software. This approach
    aims to perform cryptographic operations in software without revealing the underlying
    secret. That means the used cryptographic key diffuses into the operations of
    a crypto algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The first concepts of white-box cryptography transformed ciphers with hardcoded
    keys into key-dependent table lookups and injected random values into the internal
    calculations that would mask data at some point and demask it later. However,
    not surprisingly, this led to significant overhead in binary size and performance,
    and those implementations were also broken by cryptanalysis. Although academia
    has not yet found a perfect solution to the problem, many software companies use
    some kind of white-box cryptography in their products—for example, in mobile apps
    allowing users to download the binary and analyze it.
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter whether you apply custom obfuscation, commercial tools, or academic
    white-box crypto approaches, you should always keep in mind one attacker approach
    when hiding secrets in software binaries: code lifting. In these cases, binaries
    are used “as is”—for example, to unlock a LUKS container. The secret key itself
    isn’t of interest to attackers if they just have to use the executable as a key
    to an encrypted vault. This might happen in place, or the file of interest might
    be extracted and executed in an attacker-controlled environment.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Secure Password Storage**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Password-based authentication is a common method for verifying legitimate users
    at login, but it’s also used to unlock encrypted volumes and containers. Naturally,
    passwords are confidential data. Storing them in plaintext within a file or an
    executable for comparison during verification makes an attacker’s life easy. Once
    extracted, they can be used successfully to access confidential data. However,
    traditional encryption, as discussed as a protection measure for other classes
    of data, is usually not appropriate here. The specific verification process of
    passwords allows for implementing a different secure storage approach: *password
    hashes*.'
  prefs: []
  type: TYPE_NORMAL
- en: The one-way property of hash functions is useful in prohibiting attackers from
    retrieving a password from its hash value, even if extracted from the device.
    The verification still works because a given password can be efficiently hashed
    and compared to the stored value. However, in this trivial case, attackers could
    precompute *rainbow tables*, which are large collections of hash values for millions
    of passwords, maybe even all possible passwords with, for example, 10 characters.
    To protect against such attacks, a random *salt* is added to the password-hashing
    process that makes every hash unique and renders all rainbow tables useless.
  prefs: []
  type: TYPE_NORMAL
- en: Linux currently, still by default, uses a function based on SHA-512 hashes to
    generate salted user-password hashes. Also, the Password-Based Key Derivation
    Function 2 (PBKDF2) was standardized more than 20 years ago in RFC 2898\. It’s
    based on HMACs using hash functions like SHA-1, SHA-256, or SHA-512\. Both approaches
    are definitely better than plaintext password storage, but modern attackers use
    graphics processing units (GPUs), FPGAs, and dedicated application-specific integrated
    circuits (ASICs) to break password hashes literally with brute force.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, for future-proof products, the use of modern representatives of this
    field is recommended. Typical examples are scrypt, standardized in RFC 7914 from
    2016; its successor yescrypt; and Argon2, which won the Password Hashing Competition
    in 2015\. These algorithms share the common goal of enhancing cracking resistance
    by parameterizable password-hashing algorithms that consider dimensions like computation
    time, necessary memory, and required number of parallel CPU threads, which is
    meant to discourage even attackers who have access to a variety of hardware resources
    and computing capacity.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Even if confidentiality is the main protection goal for a password, the consequences
    of someone being able to change it are severe. Replacing the password hash of
    the root user with one of a known password is a pretty common attack that opens
    all doors for an adversary. You should seriously consider integrity protection
    for password storage, as discussed in [Chapter 8](ch08.xhtml#ch08).*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Case Study: Encrypted File Containers on Linux**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case study, let’s assume that one of your legacy devices doesn’t have
    any secure storage for confidential data implemented. While visiting an international
    fair, members of your engineering team recognize that a currently unknown competitor
    uses one of your proprietary GUI applications and the associated media content
    that you produced with great effort to fit the needs of your target audience.
  prefs: []
  type: TYPE_NORMAL
- en: Back home, you discuss the issue with your team and management. After an initial
    investigation, it becomes clear that stealing the data required nothing more than
    opening your device and reading the contents from flash memory, which your competitor
    obviously succeeded in doing. To limit future damages, you decide to establish
    at least a basic protection by using LUKS containers. Your current flash memory
    device has a capacity of 256MB. The basic Linux system and all associated tools
    occupy roughly 136MB. Your proprietary executables together with their data and
    configuration files sum up to roughly 19MB, while the high-quality video content
    consumes 73MB.
  prefs: []
  type: TYPE_NORMAL
- en: You want to protect the latter two classes of data. Because memory requirements
    are rather tight on your platform and you’d like to separate code from media,
    you plan on creating a 25MB container for executables and files containing intellectual
    property, and a 90MB container for video files.
  prefs: []
  type: TYPE_NORMAL
- en: '***Crypto Benchmarking***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As a first step, you add `cryptsetup` to your device’s root filesystem to be
    able to work with LUKS containers. You also enable `CONFIG_CRYPTO_SERPENT` and
    `CONFIG_CRYPTO_TWOFISH` in your Linux kernel config because you’ve heard that
    `cryptsetup` supports them and you wonder whether they might outperform AES on
    your STM32MP157F SoC. [Listing 5-1](ch05.xhtml#ch05list01) shows the results of
    `cryptsetup`’s own performance-benchmarking tool.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-1: The benchmarking results offered by* cryptsetup'
  prefs: []
  type: TYPE_NORMAL
- en: 'At first, this output shows that multiple functions for password storage are
    analyzed to give you an idea about which parameters of the specific function might
    be reasonable choices for your device. You want to set parameters like iteration
    count to values that lead to acceptable performance on your device (for example,
    unlocking within two seconds) but leave an attacker with maximum cracking effort.
    In this case, since you don’t have specific requirements, you stick with the default
    of LUKS2 volumes: Argon2.'
  prefs: []
  type: TYPE_NORMAL
- en: The encryption/decryption benchmark shows that AES is the fastest algorithm
    no matter whether you use it in CBC mode or XTS (XEX-Based Tweaked-Codebook Mode
    with Ciphertext Stealing). It also seems that AES-CBC performance is accelerated
    by the STM32MP157F crypto hardware. On the other hand, XTS is the default and
    recommended operation mode for `cryptsetup` and hard disk encryption in general.
    Since you highly value performance and don’t want the container encryption to
    impact any device functionality, you choose AES-CBC, and since there’s practically
    no difference between 128-bit and 256-bit keys, you go with a 256-bit key.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You might wonder how XTS can use 512-bit keys with AES. In short, it doesn’t!
    It requires two keys (in this case, two 256-bit keys, which add up to 512 bits),
    but the security level is 256-bit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Container Creation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After determining the crypto parameters, you can start by creating random files
    and corresponding key files for your two containers. The container for executables
    takes 25MB, and the one for media is based on a 90MB file, as shown in [Listing
    5-2](ch05.xhtml#ch05list02). Both keys are initialized with 32 bytes, which equals
    256 bits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-2: A random initialization of containers and key files*'
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, as shown in [Listing 5-3](ch05.xhtml#ch05list03), you use
    `cryptsetup` to provide the basic structure of a LUKS container via the `luksFormat`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-3: The creation of LUKS2 containers*'
  prefs: []
  type: TYPE_NORMAL
- en: Since you want to use Argon2 for passphrase verification, and you’d like to
    enjoy the robustness that comes with a second header copy in LUKS2, you select
    the second version of the header format with `--type luks2`. The earlier choice
    of AES in CBC mode with encrypted salt-sector initialization vector (ESSIV) is
    configured using `--cipher=aes-cbc-essiv:sha256`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the containers and their structures are ready, but you can’t
    store anything in these virtual vaults yet. The file containers need to be unlocked
    by `luksOpen` to create an ext3 filesystem inside. Note that after unlocking the
    LUKS container, as shown in [Listing 5-4](ch05.xhtml#ch05list04), it is mapped
    to the device */dev/mapper/dm_exec_enc*, which is then mounted to the newly created
    directory */mnt/exec_enc*. The same can be done for the encrypted media container
    with device */dev/mapper/dm_media_enc* and mount point */mnt/media _enc*, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-4: Unlocking a container for filesystem creation and mounting*'
  prefs: []
  type: TYPE_NORMAL
- en: It seems like you’re almost finished. Let’s use `luksDump`, as shown for the
    executables’ container in [Listing 5-5](ch05.xhtml#ch05list05), to check whether
    the right properties are set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-5: Double-checking container properties*'
  prefs: []
  type: TYPE_NORMAL
- en: The output completely matches our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '***Efficiency Analysis***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before you start populating the filesystem, let’s take one last glance at the
    efficiency of this construction. The `fdisk` and `df` tools will help you understand
    how much memory is lost for the LUKS header and how much overhead is introduced
    by the ext3 filesystem. [Listing 5-6](ch05.xhtml#ch05list06) has the details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-6: An efficiency check regarding memory usage*'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this didn’t turn out as planned. The 25MB container has only
    4MB of space left to store data, and the other one with a size of 90MB leaves
    you with 62MB. It’s clearly visible that the difference between the sizes of the
    containers and their corresponding devices in the device mapper infrastructure
    is approximately 16MB. Actually, if you had studied the LUKS documentation thoroughly,
    you’d have known that the headers of LUKS1 and LUKS2 consume 2MB and 16MB, respectively.
    While that’s not an issue for hard disks with hundreds of gigabytes, it might
    turn out to be a pain point for memory-constrained embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: You can solve the issue by using LUKS1 headers and going without the LUKS2 improvements,
    which would be acceptable in practice, or even by using the “plain mode” of `cryptsetup`
    that doesn’t store any metadata in memory. The latter choice might be the most
    efficient but comes with significant management limitations. LUKS1 would probably
    be a reasonable choice.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-6](ch05.xhtml#ch05list06) also shows that the ext3 filesystem reduces
    the available memory because of necessary allocation tables and journal data.
    However, for static storage of executables, configuration files, and media content,
    journaling might not be necessary, and you could also deploy an ext2 filesystem
    to squeeze out more bytes of available memory.'
  prefs: []
  type: TYPE_NORMAL
- en: After repeating the whole process while changing `luks2` to `luks1` and `ext3`
    to `ext2`, the situation looks different, as shown in [Listing 5-7](ch05.xhtml#ch05list07).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-7: The memory usage efficiency with LUKS1 and ext2*'
  prefs: []
  type: TYPE_NORMAL
- en: A loss of 4MB and 13MB, respectively, still occurs, but the remaining space
    just fulfills the requirements of this case study.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you find yourself in a similar situation in real life but can’t reach your
    requirements, you can still think about switching to native filesystem encryption
    (for example, with ext4), or you can use compressed read-only filesystems like
    CramFS and SquashFS.*'
  prefs: []
  type: TYPE_NORMAL
- en: After solving these unexpected, non-security-related problems, the final question
    of how to securely unlock the created containers remains. Since you don’t have
    a secure element within your device and your main CPU doesn’t provide OTP memory
    for this purpose, you may decide to hide the unlocking process in an executable
    within your *initramfs*, which is executed at boot. To be clear, you won’t win
    a prize for “security by design” with such an approach, but it might set the bar
    higher for successful attacks.
  prefs: []
  type: TYPE_NORMAL
- en: You can consider including hardware-based system identifiers, as described in
    [Chapter 6](ch06.xhtml#ch06), to derive a device-unique unlocking secret instead
    of a global software-only solution that can be emulated easily off-device. Further,
    you might implement secret sharing methods like splitting the key-file contents
    into multiple pieces and dynamically combining them to obtain the final secret
    at runtime, which at least hampers simple static analysis attacks. In any case,
    you have to be aware that an attacker who obtained root privileges is able to
    circumvent all of that and access the decrypted filesystem at runtime. And for
    the next product generation, you’ll make secure storage a priority from day one.
  prefs: []
  type: TYPE_NORMAL
- en: '**Read-Out Protection as a Low-Cost Solution**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some small embedded systems are low cost, don’t have a secure memory, aren’t
    able to run Linux, and can’t afford external secure elements at all. These devices
    might be based on microcontrollers running a real-time operating system (RTOS)
    or even only bare-metal software.
  prefs: []
  type: TYPE_NORMAL
- en: However, even those cases might have data that deserves a certain level of confidentiality
    protection. Since these devices often store all their code and data within internal
    flash memory, restricting read access to flash memory might be a simple yet effective
    measure to protect sensitive information. The activation of *read-out protection*—for
    example, by burning the corresponding fuses—leads to a device that can execute
    the internally stored code but denies requests to extract its nonvolatile memory
    contents.
  prefs: []
  type: TYPE_NORMAL
- en: Even so, be aware that physical attackers with suitable equipment can circumvent
    these basic protection features of low-cost microcontrollers and get access to
    your confidential data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter covered several classes of data that might require confidentiality
    protection, from intellectual property to media content to cryptographic secrets.
    Unfortunately, no perfect solution exists for storing such sensitive data in embedded
    systems. One reason for this dilemma is that, in comparison to a PC, embedded
    systems have no active users who keep the master secrets in their brains to enter
    them whenever needed.
  prefs: []
  type: TYPE_NORMAL
- en: Since all secrets have to be available in the same device at all times, the
    only thing we can do is hide those secrets in well-protected places, like secure
    elements, internal OTP memory, or within obfuscated software. All these solutions
    aim to increase the barriers an attacker has to break down for a successful compromise,
    but each comes with its own advantages and drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Many approaches push secret disclosure and usage to the runtime phase of a device,
    which requires an adversary to take control of certain parts of a running device
    or even to execute custom code. Therefore, the quality and success of confidentiality
    protection have a strong relation to the runtime integrity of a device, which
    we’ll discuss in [Chapter 8](ch08.xhtml#ch08).
  prefs: []
  type: TYPE_NORMAL
