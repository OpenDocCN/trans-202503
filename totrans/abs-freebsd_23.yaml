- en: '**23**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**23**'
- en: THE FRINGE OF FREEBSD
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: FREEBSD的边缘领域
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: If you hang around the FreeBSD community for any length of time, you’ll hear
    mention of all sorts of things that can be done if you know how. People build
    embedded FreeBSD devices and ship them to customers all over the world, who don’t
    even know that they have a Unix-like server inside the little box running their
    air conditioner or radio relay station. People run FreeBSD on machines without
    hard drives, supporting hundreds or thousands of diskless workstations from a
    single server. You’ll find bootable CDs and USB devices that contain complete
    FreeBSD systems, including all the installed software you could ever want. These
    things aren’t difficult to do, once you know the tricks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在FreeBSD社区待上一段时间，你会听到各种可以通过了解技术来实现的事情。人们构建嵌入式FreeBSD设备，并将它们运送到全球客户手中，而这些客户甚至不知道他们的空调或无线电中继站里有一台类Unix服务器。人们还在没有硬盘的机器上运行FreeBSD，从单台服务器支持数百或数千个无盘工作站。你会发现可以启动的CD和USB设备，里面包含完整的FreeBSD系统，包括你可能需要的所有已安装软件。一旦你掌握了技巧，这些事情并不难做。
- en: In this chapter, we’re headed into the fringes of FreeBSD—the really cool things
    that are done by FreeBSD users but aren’t necessarily supported by the mainstream
    FreeBSD Project. While you can find support and assistance through the usual channels,
    you must be prepared to debug and troubleshoot everything in this chapter even
    more than usual.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进入FreeBSD的边缘领域——由FreeBSD用户完成的真正酷的事情，这些事情并不一定是FreeBSD主流项目所支持的。虽然你可以通过常规渠道获得支持和帮助，但你必须做好比平时更多的准备，来调试和排查本章中的所有内容。
- en: '**Terminals**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**终端**'
- en: A *terminal* is the device that people can log in on. The keyboard, video, and
    mouse make up a terminal that’s also called a *console*. When you SSH into your
    host, it provides a *virtual terminal*. Terminal configuration is overwhelmingly
    automatic, but you might need to tweak it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*终端*是人们可以登录的设备。键盘、显示器和鼠标组成了一个终端，也叫做*控制台*。当你通过SSH登录到主机时，它提供的是*虚拟终端*。终端配置通常是自动的，但你可能需要进行一些调整。'
- en: 'The file */etc/ttys* controls how and where users may log into your FreeBSD
    system. Do console logins work? How about virtual terminals? What about logging
    in over serial lines? FreeBSD systems offer four standard terminals: the console,
    virtual terminals, dial-up terminals, and pseudoterminals.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*/etc/ttys*控制着用户如何以及在哪里登录到你的FreeBSD系统。控制台登录是否有效？虚拟终端呢？通过串行线路登录怎么样？FreeBSD系统提供了四种标准终端：控制台、虚拟终端、拨号终端和伪终端。
- en: The *console* is the only device available in single-user mode. On most FreeBSD
    systems, this is either a video console that includes the monitor and keyboard
    or a serial console accessed from another system. Once the system hits multiuser
    mode, the console is usually attached to a virtual terminal instead. The console
    device is */dev/console*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*控制台*是单用户模式下唯一可用的设备。在大多数FreeBSD系统中，这通常是一个视频控制台，包括显示器和键盘，或者是从另一台系统访问的串行控制台。一旦系统进入多用户模式，控制台通常会连接到一个虚拟终端。控制台设备是*/dev/console*。'
- en: A *virtual terminal* is attached to the physical monitor and keyboard. You can
    have multiple terminals on your one physical terminal. Switch between them with
    ALT and the function keys. The next time you’re at the keyboard, hit ALT-F2\.
    You’ll see a fresh login screen, with `ttyv1` after the hostname. This is the
    second virtual terminal. Hitting ALT-F1 takes you back to the main virtual terminal.
    By default, FreeBSD has eight virtual terminals and reserves a ninth for X Windows.
    You can use the eight virtual text terminals even when you’re in X, and some X
    desktops provide multiple X virtual terminals. The virtual terminals are the */dev/ttyv*
    devices.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟终端*连接到物理显示器和键盘。你可以在一个物理终端上拥有多个虚拟终端。通过ALT和功能键在它们之间切换。下次你坐到键盘前，按下ALT-F2。你会看到一个新的登录屏幕，主机名后面是`ttyv1`。这就是第二个虚拟终端。按ALT-F1则回到主虚拟终端。默认情况下，FreeBSD有八个虚拟终端，并为X
    Windows保留了第九个。即使在X环境下，你也可以使用这八个虚拟文本终端，并且一些X桌面提供多个X虚拟终端。这些虚拟终端是*/dev/ttyv*设备。'
- en: A *dial-up terminal* is connected via serial line. You can attach modems directly
    to your serial ports and let users dial into your server. This isn’t so common
    these days, but the same functionality supports logging in over a serial console.
    Dial-up terminals are the */dev/ttyu* devices.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*拨号终端*通过串行线连接。你可以将调制解调器直接连接到你的串口，并让用户拨号连接到你的服务器。虽然现在这种方式不太常见，但相同的功能也支持通过串行控制台登录。拨号终端就是*/dev/ttyu*设备。'
- en: Finally, a *pseudoterminal* is implemented entirely in software. When you SSH
    into your server, you don’t need any actual hardware, but the software still needs
    a device node for your session. Pseudoterminals are the device nodes in */dev/pts/*.
    You don’t configure pseudoterminals; they’re automatically negotiated when you
    log in.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*伪终端*完全由软件实现。当你通过SSH登录到服务器时，你不需要任何实际的硬件，但软件仍然需要为你的会话创建一个设备节点。伪终端是*/dev/pts/*中的设备节点。你不需要配置伪终端；它们会在你登录时自动协商。
- en: Configure access to the console, virtual terminals, and dial-up terminals in
    */etc/ttys*. You can enable serial access, require or disable passwords, and more.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 配置对控制台、虚拟终端和拨号终端的访问权限，配置文件为*/etc/ttys*。你可以启用串行访问、要求或禁用密码等设置。
- en: '***/etc/ttys Format***'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***/etc/ttys 格式***'
- en: 'A typical entry in */etc/ttys* looks like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/ttys*中的典型条目如下所示：'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first field is the terminal’s device node. In this case, `ttyv0` is the
    first virtual terminal on the system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字段是终端的设备节点。在这种情况下，`ttyv0`是系统中的第一个虚拟终端。
- en: The second field is the program that’s spawned to process login requests on
    this terminal. FreeBSD uses getty(8), but if you have a preferred terminal management
    program, you can use it instead. You’ll find several in packages. This field takes
    one argument, the terminal configuration. The file */etc/gettytab* contains all
    the terminal configurations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个字段是用于处理此终端登录请求的程序。FreeBSD使用getty(8)，但如果你有偏好的终端管理程序，可以使用它代替。你可以在软件包中找到几个这样的程序。这个字段接受一个参数，即终端配置。文件*/etc/gettytab*包含了所有的终端配置。
- en: The third entry is the terminal type. The file */etc/termcap* describes all
    the innumerable terminal types FreeBSD supports. For really small systems, FreeBSD
    provides */etc/termcap.small* with only the most vital entries. Almost everything
    modern works with either `xterm` or `vt100`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个条目是终端类型。文件*/etc/termcap*描述了FreeBSD支持的所有终端类型。对于真正的小型系统，FreeBSD提供了*/etc/termcap.small*，其中仅包含最重要的条目。几乎所有现代终端都可以与`xterm`或`vt100`兼容。
- en: The fourth entry determines whether the terminal is available for logins or
    not. This could be `on` for accepting logins or `off` for not allowing them. The
    `onifconsole` setting permits logins on a serial port if the kernel configured
    the port as a console.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个条目决定了终端是否可以接受登录。可以设置为`on`以接受登录，或`off`以禁止登录。`onifconsole`设置允许在内核将端口配置为控制台时在串行端口上进行登录。
- en: Last, we have the options. This example has the option `secure` set, which tells
    getty(8) that root may log into this console.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一些选项。这个示例设置了`secure`选项，这告诉getty(8)，root可以登录该控制台。
- en: Offering terminals is a low-level system task handled directly by init(8). Changes
    to */etc/ttys* don’t take effect until you tell init(8) to reread its configuration
    file. Init is always PID 1.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 提供终端是一个低级的系统任务，直接由init(8)处理。对*/etc/ttys*的更改不会生效，直到你告诉init(8)重新读取其配置文件。Init始终是PID
    1。
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***Insecure Console***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***不安全的控制台***'
- en: When you boot FreeBSD in single-user mode, you get a root command prompt. This
    is fine for your laptop and works nicely for servers in your corporate data center,
    but what about machines in untrusted facilities? If you have a server in a colocation
    center, for example, you probably don’t want just anyone to be able to get root-level
    access to a machine. You can tell FreeBSD that the physical console is insecure
    and make it require the root password to enter single-user mode. The system will
    then boot from power-on to multiuser mode without requiring a password, but it’ll
    require the password when you explicitly boot in single-user mode.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以单用户模式启动FreeBSD时，你会得到一个root命令提示符。这对于你的笔记本电脑来说没问题，并且在公司数据中心的服务器上也能很好地工作，但对于不可信的设施中的机器呢？例如，如果你有一台在合租数据中心的服务器，你可能不希望任何人都能够获得root级别的访问权限。你可以告诉FreeBSD物理控制台不安全，并要求进入单用户模式时需要root密码。然后系统会从开机启动到多用户模式而不需要密码，但在你明确选择以单用户模式启动时，会要求输入密码。
- en: Requiring a password in single-user mode doesn’t completely protect your data,
    but it does raise the bar considerably. A lone tech working late, when nobody’s
    looking, could boot your system into single-user mode and add an account for himself
    in only 15 minutes or so. Dismantling your machine, removing the hard drives,
    mounting them into another machine, making changes, and bringing your server back
    online requires much more time, is far more intrusive, and is much more likely
    to be noticed by colocation management.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在单用户模式下要求密码并不能完全保护你的数据，但它确实大大提高了安全门槛。一个孤单的技术人员在深夜、没人注意时，可以将你的系统启动到单用户模式，并在大约15分钟内为自己添加一个账户。而拆卸你的机器，移除硬盘，将它们安装到另一台机器上，进行修改并将服务器重新上线，需要更多时间，侵入性更强，且更有可能被托管管理人员注意到。
- en: 'Find the console entry in */etc/ttys*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在*/etc/ttys*中找到控制台条目：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You’ll see that the console terminal isn’t as full-featured as other terminals;
    it doesn’t run getty(8) and uses the generic `unknown` terminal type. The console
    is intended for use only in single-user mode and when attached to a physical terminal,
    however, so that’s fine.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，控制台终端不像其他终端那样功能丰富；它不运行getty(8)，并使用通用的`unknown`终端类型。然而，控制台仅限在单用户模式下使用，并且当连接到物理终端时，这样是可以的。
- en: To make the console require a root login when booted into single-user mode,
    change `secure` to `insecure`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要使控制台在启动到单用户模式时要求root登录，请将`secure`更改为`insecure`。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Password-protecting the console dissuades casual mischief. It won’t even slow
    a knowledgeable intruder with physical access to the machine.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为控制台设置密码保护可以阻止随便的恶作剧行为，但它甚至无法减缓那些拥有物理访问权限的熟练入侵者。
- en: '**Managing Cloudy FreeBSD**'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**管理云端FreeBSD**'
- en: Clusters of hundreds or thousands of servers are growing increasingly common.
    Automation systems like Ansible and Puppet somehow let us maintain these systems
    in a semblance of order. Unix wasn’t designed to be operated that way, however.
    Primordial UNIX was written to be administered by a highly skilled operator who
    had no problem handling the vagaries of countless different command output formats
    and even more configuration file styles.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 数百台或上千台服务器的集群变得越来越常见。像Ansible和Puppet这样的自动化系统，某种程度上让我们能够保持这些系统的基本秩序。然而，Unix并不是为了这样操作而设计的。最初的UNIX是为了由一个高度熟练的操作员来管理，他能轻松应对各种不同命令输出格式以及更多配置文件样式的怪癖。
- en: FreeBSD is attacking the problems of cloud-scale management with libXo and universal
    configuration language (UCL).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD正在通过libXo和通用配置语言(UCL)解决云规模管理的问题。
- en: '***LibXo***'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***LibXo***'
- en: While automated monitoring is a necessity and can alert you to issues, when
    it comes to in-depth troubleshooting, nothing replaces logging into a host, running
    a command, and interpreting the result. I’ve lost track of how many scripts I’ve
    written to parse the output of some obscure combination of ps(1) flags so that
    I could feed a number to the monitoring software. I’ve also lost track of how
    many hours I’ve spent debugging those scripts or explaining why the script I wrote
    to process one netstat(1) flag is irrelevant to the flags we’re interested in
    right now.^([1](footnote.xhtml#ch23fn1)) Multiply this by those hundreds or thousands
    of servers, and getting information out of software quickly becomes a serious
    problem.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自动化监控是必需的，可以提醒你出现问题，但当涉及到深入的故障排除时，没有什么能替代登录主机、运行命令并解释结果。我已经忘记了写了多少脚本来解析一些晦涩的ps(1)标志组合的输出，这样我就能将数字传递给监控软件。我也已经忘记了我花了多少小时调试这些脚本，或者解释为什么我写的处理一个netstat(1)标志的脚本与我们现在感兴趣的标志无关。^([1](footnote.xhtml#ch23fn1))
    如果将这个问题扩展到数百台或上千台服务器，那么从软件中快速获取信息就变成了一个严重的问题。
- en: FreeBSD has cut down this problem space with libXo.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD通过libXo减少了这个问题的复杂性。
- en: LibXo is a library that helps commands provide output not only in text form
    but also in XML, JSON, and even HTML. Instead of using grep(1) and awk(1) and
    whatever appalling combination of shell or Perl or Python you’ve brewed up to
    find desired information, you can have a parser extract data from a tagged format.
    You can dump command output straight to a web page.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: LibXo是一个库，帮助命令提供不仅是文本形式的输出，还能生成XML、JSON，甚至HTML。与其使用grep(1)和awk(1)，或者你用过的任何令人不安的Shell、Perl或Python组合来查找所需的信息，不如让一个解析器从标记格式中提取数据。你还可以将命令输出直接导出到网页上。
- en: Not all programs support libXo, but support is continually added to more programs.
    The man page declares whether a program supports libXo, but if you’re too lazy
    to read it, you can try the command with the `--libxo` flag. All commands that
    support libXo use that command line option. You must also specify the output format,
    either text, XML, JSON, or HTML. Here, I run `arp -an` and identify JSON as the
    output format.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有程序都支持libXo，但越来越多的程序正在添加支持。手册页会声明一个程序是否支持libXo，如果你懒得阅读，可以尝试使用`--libxo`标志运行命令。所有支持libXo的命令都使用该命令行选项。你还必须指定输出格式，文本、XML、JSON或HTML。这里，我运行`arp
    -an`并将JSON设置为输出格式。
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How do you use this? Many of us won’t. But if you’re running dozens or hundreds
    of servers, you probably have the expertise in-house to painlessly parse this.
    Hundreds of tools can select tagged data, and your application developer probably
    has their preferred software already installed on your hosts. And while the output
    of arp(8) is fairly consistent, libXo also handles any arbitrary combination of
    flags to netstat(1), vmstat(8), and more. Learn to grab tagged data from the output
    once, and you’re done writing those horrible scripts *forever*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用这个？我们中的许多人可能不会使用。但如果你正在管理数十台或数百台服务器，你可能拥有足够的专业知识来轻松解析这个。数百种工具可以选择标记数据，而你的应用开发人员可能已经在主机上安装了他们首选的软件。虽然`arp(8)`的输出结果相对一致，但libXo也能处理netstat(1)、vmstat(8)等命令的任何任意标志组合。学会一次性抓取标记数据，你就可以*永远*告别那些可怕的脚本编写。
- en: '***Universal Configuration Language***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通用配置语言***'
- en: Unix systems have a pretty standard configuration file format. Hash marks are
    comments. There are variables. Maybe the presence of the variable in a config
    file is enough to activate a feature, or perhaps you have to set the variable
    to a value. They’re all a little bit different, though. Some programs can pull
    in configuration snippets from a primary file and the files in a directory, like
    cron(8) does with */etc/crontab* and */etc/cron.d/*. Others can’t. Some use braces
    to set aside chunks of configuration, where others use . . . whatever the programmer
    thought was a good idea 30 years ago. The result is that nobody looks at *syslog.conf*
    and thinks it looks like *pkg.conf*, even though they share common underlying
    concepts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Unix系统有一种相当标准的配置文件格式。井号（#）是注释。存在变量。也许变量在配置文件中的存在足以激活某个功能，或者你需要将变量设置为某个值。尽管如此，它们都有些不同。有些程序可以从主文件和目录中的文件中提取配置片段，就像cron(8)从*/etc/crontab*和*/etc/cron.d/*中提取一样。其他程序则不行。有些使用大括号来划分配置块，而有些则使用……无论是30年前程序员认为好的主意。结果是，没人看*syslog.conf*会觉得它看起来像*pkg.conf*，尽管它们共享相似的基础概念。
- en: The *universal configuration language (UCL)* aims to change that. If all of
    these programs have a similar syntax, why not use a single parsing library for
    each? And if you have a parsing library, why not let it parse multiple formats?
    UCL lets you provide configuration files in classic Unix style, JSON, or YAML,
    ideal for automated management. It can extract configuration settings in shell
    code, UCL, JSON, or YAML.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*通用配置语言（UCL）*旨在改变这一现状。如果这些程序的语法类似，为什么不为每个程序使用一个统一的解析库呢？如果你已经有了一个解析库，为什么不让它解析多种格式呢？UCL允许你提供经典Unix风格、JSON或YAML格式的配置文件，非常适合自动化管理。它可以从shell代码、UCL、JSON或YAML中提取配置设置。'
- en: At the time I write this, FreeBSD uses UCL for pkg(8). Support for other utilities,
    such as bhyve(8), is slowly happening. If you’re managing large numbers of servers,
    check to see the status of UCL in your release.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我写这篇文章时，FreeBSD为pkg(8)使用了UCL。对其他工具的支持，例如bhyve(8)，正在慢慢推进。如果你正在管理大量服务器，请查看你的发行版中UCL的支持状态。
- en: '**Diskless FreeBSD**'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**无盘FreeBSD**'
- en: While FreeBSD isn’t difficult to manage, dozens or hundreds of nearly identical
    systems can become quite a burden. One way to reduce your maintenance overhead
    is to use *diskless* systems. Diskless systems aren’t forbidden to have hard drives;
    rather, they load their kernel and operating system from an NFS server elsewhere
    on the network.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管FreeBSD并不难管理，但数十台或数百台几乎相同的系统可能会变得相当沉重。减少维护负担的一种方法是使用*无盘*系统。无盘系统并不是禁止使用硬盘，而是它们从网络上的NFS服务器加载内核和操作系统。
- en: Why use a diskless system for your server farm? Multiple systems can boot off
    of a single NFS server, centralizing all patch and package management. This is
    excellent for collections of terminals, computation clusters, and other environments
    where you have large numbers of identical systems. Rolling out an operating system
    update becomes a simple matter of replacing files on the NFS server. Similarly,
    when you discover that an update has problems, reverting it is as simple as restoring
    files on the NFS server. In either case, the only thing you have to do at the
    client side is reboot. As the clients have read-only access to the server, untrusted
    users can’t make any changes to the operating system. If you have only a couple
    of systems running, diskless is probably too much work for you, but any more than
    that and diskless is a clear winner.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要为你的服务器集群使用无盘系统？多个系统可以从单一的 NFS 服务器启动，集中管理所有的补丁和软件包。这对于终端机集合、计算集群以及其他有大量相同系统的环境非常适用。发布操作系统更新变得非常简单，只需在
    NFS 服务器上替换文件。同样，当你发现更新有问题时，恢复它也只是简单地恢复 NFS 服务器上的文件。在这两种情况下，客户端所需做的唯一事情就是重启。由于客户端对服务器只有只读访问权限，未经授权的用户无法对操作系统做出任何更改。如果你只运行少量系统，无盘系统可能会显得过于复杂，但如果系统数量超过几个，无盘系统无疑是一个明确的赢家。
- en: Before you can run diskless systems, you must have an NFS server, a DHCP server,
    a TFTP server, and hardware that supports diskless booting. Let’s go through each
    and see how to set it up.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在你运行无盘系统之前，你必须拥有一个 NFS 服务器、一个 DHCP 服务器、一个 TFTP 服务器以及支持无盘启动的硬件。让我们逐一查看并了解如何进行设置。
- en: '**TEST, TEST, TEST!**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试，测试，测试！**'
- en: 'Your first diskless setup will be much like your first firewall setup: error-prone,
    troublesome, and infuriating. I strongly suggest that you test each step of the
    preparation so that you can find and fix problems more easily. Test instructions
    are provided for each required service.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第一次无盘设置将很像你第一次设置防火墙：容易出错、麻烦且令人恼火。我强烈建议你测试准备工作的每一步，这样你可以更容易地发现并解决问题。每个必需服务的测试说明都会提供。
- en: '***Diskless Clients***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***无盘客户端***'
- en: 'Machines that run diskless must have enough smarts to find their boot loader
    and operating system over the network. There are two standard ways of doing this:
    BOOTP and PXE. *BOOTP*, the internet Bootstrap Protocol, is an older standard
    that fell out of favor long ago. *PXE*, Intel’s Preboot Execution Environment,
    has been supported on almost every new machine for years now, so we’ll concentrate
    on that.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 运行无盘的机器必须具备足够的智能，通过网络找到它们的引导加载程序和操作系统。实现这一目标的有两种标准方式：BOOTP 和 PXE。*BOOTP*（互联网引导协议）是一个较老的标准，早已被淘汰。*PXE*（英特尔预启动执行环境）已在几乎所有的新机器上得到支持多年，因此我们将专注于此。
- en: Boot your diskless client machine and go into the BIOS setup. Somewhere in the
    BIOS, you’ll find an option to set the boot device order. If the machine supports
    PXE, one of those options will be the network. Enable that option and have the
    machine try it first.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 启动你的无盘客户端机器并进入 BIOS 设置。在 BIOS 中，你会找到一个选项来设置启动设备顺序。如果机器支持 PXE，其中一个选项将是网络。启用该选项并让机器首先尝试网络启动。
- en: Your diskless client is ready. Now let’s get the server ready.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你的无盘客户端已经准备好了。现在让我们准备服务器。
- en: '***DHCP Server Setup***'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***DHCP 服务器设置***'
- en: While most people think of DHCP as a way to assign IP addresses to clients,
    it can provide much more than that. You can configure your DHCP server to provide
    the locations of a TFTP server, an NFS server, and other network resources. Diskless
    systems make extensive use of DHCP, and you’ll find that we use DHCP options you’ve
    never tried before.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数人将 DHCP 看作是为客户端分配 IP 地址的方式，但它能提供的不止这些。你可以配置 DHCP 服务器来提供 TFTP 服务器、NFS 服务器和其他网络资源的位置。无盘系统广泛使用
    DHCP，你会发现我们使用了一些你从未尝试过的 DHCP 选项。
- en: OpenBSD’s DHCP server won’t support FreeBSD diskless clients; you must use ISC’s
    DHCP server or some other more full-featured version. Configuring the ISC DHCP
    server to handle diskless systems is pretty straightforward once you have the
    MAC address of your diskless workstation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 的 DHCP 服务器不支持 FreeBSD 无盘客户端；你必须使用 ISC 的 DHCP 服务器或其他功能更全的版本。一旦你获得了无盘工作站的
    MAC 地址，配置 ISC DHCP 服务器来处理无盘系统就非常直接了。
- en: '**MAC Address**'
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**MAC 地址**'
- en: To assign configuration information to a DHCP client, you need the MAC address
    of that client’s network card. Some BIOS implementations provide the MAC addresses
    of integrated network cards, and some server-grade hardware has labels with the
    MAC address printed on them. Those options, however, are too easy, so we’ll try
    the hard way.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要为DHCP客户端分配配置信息，您需要该客户端网卡的MAC地址。某些BIOS实现提供集成网卡的MAC地址，某些服务器级硬件则有打印着MAC地址的标签。然而，这些选项过于简单，所以我们将尝试更复杂的方法。
- en: When a machine tries to boot off the network, it makes a DHCP request for its
    configuration information. While you don’t have a diskless configuration yet,
    any DHCP server logs the MAC address of clients. You can get the client information
    from the leases file, */var/db/dhcpd.leases*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当一台机器尝试从网络启动时，它会发出DHCP请求以获取其配置信息。虽然您还没有配置无盘配置，但任何DHCP服务器都会记录客户端的MAC地址。您可以从租约文件*/var/db/dhcpd.leases*获取客户端信息。
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This client has a MAC address of 08:00:27:d8:c1:1c ➋ and has been offered IP
    address 198.51.100.10 ➊. Given this information, we can create a DHCP configuration
    to assign this host a static IP address and provide its boot information.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该客户端的MAC地址为08:00:27:d8:c1:1c➋，并已被分配IP地址198.51.100.10➊。根据这些信息，我们可以创建一个DHCP配置来为此主机分配静态IP地址，并提供其启动信息。
- en: '**DHCP Configuration: Specific Diskless Hosts**'
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**DHCP配置：特定无盘主机**'
- en: We configured basic DHCP services in [Chapter 20](ch20.xhtml#ch20). Here’s a
    sample dhcpd(8) configuration for a diskless client. This doesn’t go inside a
    subnet statement but is a top-level statement on its own, even if it’s on a subnet
    shared with nondiskless DHCP clients.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第20章](ch20.xhtml#ch20)中配置了基本的DHCP服务。下面是一个适用于无盘客户端的dhcpd(8)配置示例。这些配置不应该放在子网声明中，而是独立作为顶层声明，即使它与非无盘DHCP客户端共享同一子网。
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We define a group called `diskless` ➊. This definition will allow us to assign
    certain parameters to the group and then just add hosts to the group. Every host
    in the group gets those same parameters.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`diskless`的组➊。这个定义将允许我们为该组分配特定的参数，然后只需将主机添加到该组中。组中的每个主机都会得到相同的参数。
- en: The `next-server` setting ➋ tells the DHCP clients the IP address of a TFTP
    server, and the `filename` option ➌ tells clients the name of the boot loader
    file to request from that TFTP server. Remember from [Chapter 4](ch04.xhtml#ch04)
    that the boot loader is the software that finds and loads the kernel. Finally,
    `option root-path` ➍ tells the boot loader where to find the root directory for
    this machine. All of these options and settings are given to all clients in the
    diskless group.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`next-server`设置➋告知DHCP客户端TFTP服务器的IP地址，`filename`选项➌告诉客户端从该TFTP服务器请求的引导加载程序文件的名称。记得在[第4章](ch04.xhtml#ch04)中提到，引导加载程序是找到并加载内核的软件。最后，`option
    root-path` ➍告诉引导加载程序在哪里找到该机器的根目录。所有这些选项和设置都会提供给无盘组中的所有客户端。'
- en: We then assign our diskless client to the diskless group using the `host` statement
    and the hostname of this system ➎. Our first client is called `compute1`. This
    client is identified by its MAC address ➏ and is assigned a static IP ➐. It also
    receives the standard configuration for this group.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`host`语句和此系统的主机名➎将无盘客户端分配到无盘组中。我们的第一个客户端被称为`compute1`。此客户端通过其MAC地址➏进行标识，并被分配了一个静态IP➐。它还接收此组的标准配置。
- en: Create additional host entries just like this for every diskless host on your
    network.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为网络上的每个无盘主机创建类似的主机条目。
- en: Restart dhcpd(8) to make this configuration take effect. Now reboot your diskless
    client. The DHCP log should show that you’ve offered this client its static address.
    However, the DHCP client can’t boot any further without a boot loader, which means
    you need a TFTP server.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重启dhcpd(8)使此配置生效。现在重新启动您的无盘客户端。DHCP日志应该会显示您已为该客户端分配了静态地址。然而，DHCP客户端在没有引导加载程序的情况下无法继续启动，这意味着您需要一个TFTP服务器。
- en: '**DHCP Configuration: Diskless Farms**'
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**DHCP配置：无盘集群**'
- en: Perhaps you have a large number of identical diskless hosts, such as thin clients
    in a terminal room. It’s perfectly sensible not to want to make a static DHCP
    entry for each thin client. Let these hosts get their boot information from the
    DHCP server, but without specifying a host address. They’ll just take an address
    out of the DHCP pool. Many clustering solutions include client services that register
    new hosts with whatever “cluster manager” they’re using, so hardcoded addresses
    aren’t so important.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你有大量相同的无盘主机，比如终端机房中的瘦客户端。完全可以理解你不希望为每个瘦客户端都做一个静态的 DHCP 条目。让这些主机从 DHCP 服务器获取它们的引导信息，但不指定主机地址。它们将从
    DHCP 池中获取一个地址。许多集群解决方案包括客户端服务，它们会将新主机注册到它们正在使用的“集群管理器”中，因此硬编码的地址就不那么重要了。
- en: You can also specifically identify hosts that are requesting DHCP information
    from PXE and assign those hosts to a specific group of addresses. A host booting
    with PXE identifies itself to the DHCP server as a client of type `PXEclient`.
    You can write specific rules to match clients of that type and configure them
    appropriately. Look in the DHCP manual for information on how to match on `vendor-class-identifier`
    and `dhcp-client-identifier`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以特别识别那些请求 DHCP 信息的 PXE 主机，并将这些主机分配给一个特定的地址组。使用 PXE 引导的主机会将自己标识为 `PXEclient`
    类型的客户端，向 DHCP 服务器报告。你可以编写特定的规则来匹配这种类型的客户端，并进行适当配置。有关如何匹配 `vendor-class-identifier`
    和 `dhcp-client-identifier`，请查阅 DHCP 手册。
- en: '***tftpd and the Boot Loader***'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***tftpd 和引导加载程序***'
- en: We covered configuring a TFTP server in [Chapter 20](ch20.xhtml#ch20). The TFTP
    server must provide the *pxeboot* file for your diskless clients. FreeBSD provides
    *pxeboot* in the */boot* directory.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 20 章](ch20.xhtml#ch20)中介绍了如何配置 TFTP 服务器。TFTP 服务器必须为你的无盘客户端提供 *pxeboot*
    文件。FreeBSD 将 *pxeboot* 提供在 */boot* 目录下。
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Try to download *pxeboot* via TFTP from your workstation. If that works, reboot
    your diskless client and watch it try to boot. The console should show a message
    like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过 TFTP 从你的工作站下载*pxeboot*。如果成功，重启你的无盘客户端并观察它尝试启动。控制台应该会显示类似以下的信息：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You’ve seen this message before, when a regular FreeBSD boots off its hard drive.
    Your diskless client will identify the PXE version, print the memory, and declare
    that it’s running the bootstrap loader. At that point, it’ll circle endlessly
    trying to load the kernel. It can’t load the kernel because we haven’t yet set
    up the NFS server.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前可能见过这个消息，当一个常规的 FreeBSD 从硬盘启动时。你的无盘客户端将识别 PXE 版本，打印内存，并声明它正在运行引导加载程序。此时，它将无限循环，尝试加载内核。它无法加载内核，因为我们还没有设置
    NFS 服务器。
- en: '***Diskless Security***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***无盘安全性***'
- en: Diskless systems run over NFS and have all of NFS’s security issues. Even if
    you deploy Kerberos to encrypt NFS traffic, the initial network boot and mounting
    of the root filesystem is always unencrypted. Don’t run diskless nodes on the
    open internet.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 无盘系统通过 NFS 运行，并且具有所有 NFS 的安全问题。即使你部署 Kerberos 来加密 NFS 流量，初始网络引导和根文件系统的挂载始终是未加密的。不要在开放的互联网中运行无盘节点。
- en: You can somewhat protect your NFS server by assigning a different user for the
    NFS root account. Running `find /diskless/1 -user 0 -exec chown nfsroot {} \;`
    changes the owner of all files owned by root to be owned by the user nfsroot.
    You can then edit the *exports* file to map root to the nfsroot user. You’d need
    to revert that to run freebsd-update(8), however, and then restore it after applying
    patches. But when you’re first learning, don’t get fancy. Get a basic userland
    working first.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过为 NFS 根账户分配一个不同的用户来在某种程度上保护你的 NFS 服务器。运行 `find /diskless/1 -user 0 -exec
    chown nfsroot {} \;` 会将所有 root 拥有的文件的所有者更改为 nfsroot 用户。然后你可以编辑 *exports* 文件，将
    root 映射到 nfsroot 用户。然而，要运行 freebsd-update(8) 时，你需要还原它，并在应用补丁后恢复。但是在你刚开始学习时，不要太复杂。先让基本的用户空间工作起来。
- en: '***The NFS Server and the Diskless Client Userland***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***NFS 服务器和无盘客户端用户空间***'
- en: Many tutorials on diskless operation suggest using the server’s userland and
    root partition for diskless clients. That might be easy to do, but it’s not even
    vaguely secure. Your diskless server probably has programs on it that you don’t
    want the clients to have access to, and it certainly has sensitive security information
    that you don’t want to hand out to a whole bunch of workstations. Providing a
    separate userland is a much wiser option.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 许多关于无盘操作的教程建议使用服务器的用户空间和根分区作为无盘客户端。这可能很容易做到，但这根本不安全。你的无盘服务器上可能有你不希望客户端访问的程序，而且它肯定包含了你不希望泄露给一大堆工作站的敏感安全信息。提供一个独立的用户空间是一个更明智的选择。
- en: While you can provide a separate userland in many ways, I find that the simplest
    is to slightly modify the jail(8) construction process from [Chapter 22](ch22.xhtml#ch22).
    First, make a dataset, UFS filesystem, or directory for our diskless clients to
    use as their root directory, and then install a userland and kernel in that directory.
    Extract the *base.txz* and *kernel.txz* distribution files for the version of
    FreeBSD in that directory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以通过多种方式提供一个独立的用户空间，但我发现最简单的方式是稍微修改[第22章](ch22.xhtml#ch22)中的jail(8)构建过程。首先，为我们的无盘客户端创建一个数据集、UFS文件系统或目录作为它们的根目录，然后在该目录中安装用户空间和内核。将*base.txz*和*kernel.txz*分发文件提取到该目录中。
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you’ve built a FreeBSD you want to run, that works too. Here, we install
    a locally built userland in */diskless/1*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你构建了一个FreeBSD并希望运行它，这也是可以的。在这里，我们将一个本地构建的用户空间安装到*/diskless/1*：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now tell your NFS server about this directory. I intend to install several
    diskless systems on this network, so I offer this directory via NFS to my entire
    subnet. The clients don’t need write access to the NFS root, so I export it read-only.
    The following */etc/exports* line does this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将这个目录告诉你的NFS服务器。我打算在这个网络上安装几台无盘系统，所以我通过NFS将这个目录共享给整个子网。客户端不需要对NFS根目录有写权限，因此我将其设置为只读。下面的*/etc/exports*行实现了这一点：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Restart mountd(8) to make this share available, and try to mount it from a workstation.
    Confirm that the directory contains a basic userland visible from the client and
    that clients can’t write to the filesystem.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动mountd(8)以使这个共享可用，并尝试从工作站进行挂载。确认该目录包含一个从客户端可见的基本用户空间，并且客户端无法写入文件系统。
- en: Your diskless host needs a root password. Set it using chroot(8) and passwd(1).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你的无盘主机需要设置一个根密码。使用chroot(8)和passwd(1)来设置它。
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You’ll need to tell the host that its root filesystem is read-only. Create */diskless/1/etc/rc.conf*
    and set `root_rw_mount` to NO. While you’re in that directory, also create a *resolv.conf*
    for your client.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要告诉主机它的根文件系统是只读的。创建*/diskless/1/etc/rc.conf*并将`root_rw_mount`设置为NO。在该目录下，还需要为你的客户端创建一个*resolv.conf*文件。
- en: Now reboot your diskless client and see what happens. It should find the kernel
    and boot into an unconfigured multiuser mode. Depending on the server, client,
    and network speed, this might take a while to complete.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重启你的无盘客户端，看看会发生什么。它应该能够找到内核并启动到一个未配置的多用户模式。根据服务器、客户端和网络速度的不同，这可能需要一些时间来完成。
- en: At this point, you could configure your userland to specifically match your
    single diskless client. You could make changes in */etc*, such as creating */etc/fstab*
    that reflects your needs, and copy password files into place. That suffices for
    one diskless client, but FreeBSD has infrastructure designed specifically to support
    dozens or hundreds of hosts off the same filesystem. Let’s look into how this
    is done.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可以配置你的用户空间，以特定匹配你的单个无盘客户端。你可以在*/etc*中进行修改，例如创建反映你需求的*/etc/fstab*文件，并将密码文件复制到相应位置。这对一个无盘客户端来说足够了，但FreeBSD有专门的基础设施来支持从同一个文件系统启动几十或几百台主机。我们来看看这是如何做到的。
- en: '**Diskless Farm Configuration**'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**无盘工作站农场配置**'
- en: One of the benefits of diskless systems is that multiple machines can share
    the same filesystem. However, even on machines that are mostly identical, you’ll
    probably find that you must make certain configuration files slightly different.
    FreeBSD includes a mechanism for offering personalized configuration files on
    top of a uniform userland by *remounting* directories on tmpfs(5) temporary filesystems
    and copying custom files to these partitions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 无盘系统的一个好处是多个机器可以共享同一个文件系统。然而，即使是大多数相同的机器，你也会发现必须让某些配置文件略有不同。FreeBSD提供了一种机制，通过在tmpfs(5)临时文件系统上*重新挂载*目录，并将自定义文件复制到这些分区上，从而在统一的用户空间上提供个性化的配置文件。
- en: FreeBSD’s default diskless setup lets you configure diskless workstations across
    multiple networks and subnets—an invaluable feature on large networks. If you
    have only a few diskless systems, however, you might find it slightly cumbersome
    at first. Over time, however, you’ll find that you make more and more use of it.
    Diskless systems are a convenient solution to many problems.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD的默认无盘设置允许你跨多个网络和子网配置无盘工作站——这是大型网络中的一个宝贵特性。然而，如果你只有少数几台无盘系统，刚开始你可能会觉得它有点繁琐。但是随着时间的推移，你会发现它会越来越有用。无盘系统是解决许多问题的便捷方案。
- en: A booting FreeBSD system uses the `vfs.nfs.diskless_valid` to see whether it’s
    running diskless. If the sysctl equals `0`, it’s running off a hard drive; otherwise,
    it’s running diskless. On diskless systems, FreeBSD runs the */etc/rc.initdiskless*
    script to parse and deploy the hierarchical diskless configuration.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 启动中的 FreeBSD 系统使用 `vfs.nfs.diskless_valid` 来判断它是否在无盘运行。如果 sysctl 等于 `0`，则说明它从硬盘运行；否则，它是在无盘模式下运行。在无盘系统上，FreeBSD
    会运行 */etc/rc.initdiskless* 脚本来解析并部署层次化的无盘配置。
- en: '***Configuration Hierarchy***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置层次结构***'
- en: Configure your diskless farm in the diskless host’s */conf*. The */conf* directory
    can have a whole bunch of directories in it. The two critical ones are */conf/base*
    and */conf/default*, but you might also have separate directories for subnets
    and/or individual IP addresses. Diskless systems use the contents of these directories
    to build tmpfs filesystems on top of the mounted root partition so individual
    hosts can have unique settings and read-write filesystems. You can make any directory
    a tmpfs filesystem and populate it from this hierarchy, but every host needs a
    read-write */etc* directory, so we’ll use that as our example.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在无盘主机的 */conf* 目录中配置你的无盘农场。*/conf* 目录中可能包含很多目录。两个关键的目录是 */conf/base* 和 */conf/default*，但你可能也会有单独的子网和/或个别
    IP 地址的目录。无盘系统使用这些目录中的内容在挂载的根分区上构建 tmpfs 文件系统，以便每台主机可以拥有独特的设置和读写文件系统。你可以将任何目录都作为
    tmpfs 文件系统，并从这个层次结构中填充它，但每台主机都需要一个读写的 */etc* 目录，所以我们将以此为例。
- en: The */conf/base* directory contains base system files that need to be mounted
    read-write on the diskless client. Create */conf/base/etc* and populate it with
    a set of */etc* files, and the diskless host can use them as the base of its tmpfs
    */etc*. (It can also recycle the diskless root’s */etc*, as we’ll see later.)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*/conf/base* 目录包含需要在无盘客户端上以读写方式挂载的基础系统文件。创建 */conf/base/etc* 并将一组 */etc* 文件填充其中，无盘主机就可以将它们作为其
    tmpfs */etc* 的基础。（如我们稍后所见，它也可以回收无盘根目录的 */etc*）。'
- en: The */conf/default* directory contains defaults for your environment. Perhaps
    every host in your environment needs an */etc/fstab* that directs it to mount
    a shared data store. You’d create */conf/defaults/etc/fstab*, and the diskless
    system would copy that to every host on top of the base system from */conf/base/etc*.
    I’d also distribute your environment’s generic *rc.conf* in the default directory.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*/conf/default* 目录包含你环境的默认设置。也许你环境中的每一台主机都需要一个指向挂载共享数据存储的 */etc/fstab* 文件。你可以创建
    */conf/defaults/etc/fstab*，然后无盘系统会将其复制到每台主机，覆盖基础系统中的 */conf/base/etc*。我还会在默认目录中分发你环境的通用
    *rc.conf*。'
- en: You can also have per-subnet directories. Name that directory after the subnet’s
    broadcast address, the top address in the network. My diskless farm runs on the
    subnet 198.51.100.0/24, with a broadcast address of 198.51.100.255\. If I created
    */conf/198.51.100.255/etc/rc.conf*, every host in that subnet would get that *rc.conf*.
    If I had a special */etc/fstab* for diskless hosts on that subnet, I could put
    it in */conf/198.51.100.255/etc/fstab* and it would overwrite the default. I’d
    also add files in */etc/rc.conf.d/* for special services that run only on that
    subnet.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建每个子网的目录。将该目录命名为子网的广播地址，即网络中的最高地址。我的无盘农场运行在子网 198.51.100.0/24 上，广播地址是 198.51.100.255。如果我创建了
    */conf/198.51.100.255/etc/rc.conf*，该子网中的每台主机都会获得这个 *rc.conf* 文件。如果我为该子网中的无盘主机有一个特殊的
    */etc/fstab*，我可以将其放入 */conf/198.51.100.255/etc/fstab*，它将覆盖默认设置。我还会在 */etc/rc.conf.d/*
    中添加为仅在该子网上运行的特殊服务的文件。
- en: Finally, I could have per-host directories. If I created */conf/198.51.100.101/etc/rc.conf.d/apache*,
    the host 198.51.100.101—and only that host—would get that file. If that particular
    host needed a truly unique */etc/fstab*, I could put it in */conf/198.51.100.101/etc/fstab*,
    and it would overwrite both the default and the subnet */etc/fstab*.^([2](footnote.xhtml#ch23fn2))
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我可以为每个主机创建独立的目录。如果我创建了 */conf/198.51.100.101/etc/rc.conf.d/apache*，那么主机 198.51.100.101—仅这台主机—会获得这个文件。如果这台主机需要一个真正独特的
    */etc/fstab*，我可以将其放入 */conf/198.51.100.101/etc/fstab*，它会覆盖默认的以及子网的 */etc/fstab*。^([2](footnote.xhtml#ch23fn2))
- en: This hierarchical configuration gets deployed through a process called *diskless
    remounting*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种层次化配置通过一个叫做 *无盘重挂载* 的过程进行部署。
- en: '***Diskless Remounting /etc***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***无盘重挂载 /etc***'
- en: The diskless system checks the file */conf/base/etc/diskless_remount* for a
    list of directories it should mount as memory filesystems. Without this file,
    no memory filesystems get created, and your diskless host shares a single read-only
    userland with all of the other diskless hosts. The `diskless_remount` file contains
    a list of filesystems to be remounted.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 无磁盘系统检查文件*/conf/base/etc/diskless_remount*，以获取它应该作为内存文件系统挂载的目录列表。如果没有这个文件，就不会创建内存文件系统，并且你的无磁盘主机与所有其他无磁盘主机共享一个只读的用户空间。`diskless_remount`文件包含需要重新挂载的文件系统列表。
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This tells FreeBSD to build an MFS */etc* and copy the diskless root’s existing
    */etc* onto it, giving us a base to work from.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉FreeBSD构建一个MFS */etc*并将无磁盘根目录现有的*/etc*复制到其中，为我们提供一个基础来工作。
- en: You don’t necessarily want all of the files in the diskless root’s */etc* on
    your diskless host’s */etc*. It’s a memory filesystem, so why waste memory holding
    stuff you don’t need? You also don’t want to imply to junior sysadmins that the
    hosts support functions that they don’t. Diskless systems shouldn’t keep logs
    locally, so they don’t need *newsyslog* or */etc/newsyslog.conf*. You don’t back
    up diskless clients, so */etc/dumpdates* is also unnecessary. Browsing */etc*
    will reveal quite a few files irrelevant to diskless hosts. If you remove too
    much, however, your system won’t boot, and the list of necessary files isn’t intuitive.
    For example, if you remove */etc/mtree*, the machine will hang in single-user
    mode because it can’t repopulate the MFS */var* partition.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你不一定希望无磁盘根目录中的所有文件都出现在无磁盘主机的*/etc*目录中。这是一个内存文件系统，所以为什么要浪费内存存放你不需要的东西？你也不想让初级系统管理员误以为主机支持它们并不具备的功能。无磁盘系统不应在本地保存日志，因此它们不需要*newsyslog*或*/etc/newsyslog.conf*。你也不需要备份无磁盘客户端，因此*/etc/dumpdates*也是不必要的。浏览*/etc*将揭示出许多与无磁盘主机无关的文件。然而，如果你删除得太多，系统将无法启动，而且所需文件的列表并不直观。例如，如果你删除了*/etc/mtree*，机器将在单用户模式下挂起，因为它无法重新填充MFS
    */var*分区。
- en: Put the full paths to your unwanted files and directories in the file */conf/base/etc.remove*.
    For example, the following entries remove the */etc/gss* and */etc/bluetooth*
    directories as well as the syslog and backup files discussed earlier. You don’t
    need to copy over */etc/resolv.conf*. FreeBSD’s */etc/rc.d/resolv* startup script
    creates one from the original DHCP response that booted the host.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将你不需要的文件和目录的完整路径放入文件*/conf/base/etc.remove*中。例如，以下条目会删除*/etc/gss*和*/etc/bluetooth*目录，以及之前提到的syslog和备份文件。你不需要复制*/etc/resolv.conf*。FreeBSD的*/etc/rc.d/resolv*启动脚本会从启动主机时的原始DHCP响应中创建一个。
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Not so hard, is it?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这不难，是吗？
- en: Now let’s put some things back into our configuration.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将一些内容添加回我们的配置中。
- en: '**Finalizing Setup**'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**完成设置**'
- en: Now that you have an installed system, let’s do some fine-tuning. Diskless clients
    need third-party packages and assorted configuration files. The easiest and safest
    way to finish setting up your client is through using the chroot(8) program, which
    locks you into a subdirectory of the filesystem. By using chroot(8) on the NFS
    server, you can get read-write access to the filesystem almost exactly as it will
    exist on the diskless client.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经有了一个安装好的系统，让我们做一些微调。无磁盘客户端需要第三方软件包和各种配置文件。完成客户端设置最简单和最安全的方法是使用chroot(8)程序，它将你锁定在文件系统的一个子目录中。通过在NFS服务器上使用chroot(8)，你几乎可以获得对文件系统的读写访问，就像它在无磁盘客户端上存在一样。
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Yes, */etc* still has hierarchical overrides, but other parts of the system
    exist exactly as the diskless client sees them. Any changes you make while chrooted
    will be coherent to the client.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，*/etc*仍然具有层次化的覆盖，但系统的其他部分存在的方式完全符合无磁盘客户端所看到的样子。你在chroot后所做的任何更改都将对客户端保持一致。
- en: '***Installing Packages***'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安装软件包***'
- en: Use pkg(8) to install software on a diskless client. Use the `-c` flag to specify
    the diskless root directory and have pkg(8) chroot into it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pkg(8)在无磁盘客户端上安装软件。使用`-c`标志来指定无磁盘根目录，并让pkg(8)切换到该目录。
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You now have the package tools, database, and repository information on your
    diskless client.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在无磁盘客户端上有了软件包工具、数据库和仓库信息。
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Install any software you need this way.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式安装你需要的软件。
- en: '***SSH Keys***'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SSH 密钥***'
- en: Perhaps the most annoying thing about diskless clients is the host’s SSH keys.
    In normal operation, every host needs unique SSH keys. If you’re running on a
    private network, you might decide to have all the diskless clients share the same
    SSH key. You might decide to have each host autogenerate new SSH keys at boot
    time. As */etc* exists on tmpfs, those keys will vanish at shutdown, but users
    will quickly grow accustomed to the “host key has changed” messages. That’s not
    something you want users to grow accustomed to, though.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 也许关于无盘客户端最令人烦恼的事情就是主机的 SSH 密钥。在正常操作中，每台主机都需要唯一的 SSH 密钥。如果你运行在一个私有网络中，你可能会决定让所有无盘客户端共享相同的
    SSH 密钥。你也可能决定让每台主机在启动时自动生成新的 SSH 密钥。由于*/etc*位于tmpfs上，这些密钥将在关机时消失，但用户会很快习惯“主机密钥已更改”的消息。然而，你并不希望用户习惯这个。
- en: Establishing persistent, unique host keys for each diskless client, however,
    isn’t hard. Create a */conf* directory for each host.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为每个无盘客户端建立持久的、唯一的主机密钥并不困难。为每台主机创建一个*/conf*目录。
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this directory, create the SSH keys for each algorithm your version of SSH
    uses. While ssh-keygen(1) includes the `-A` flag to autogenerate missing keys,
    it places those keys in */etc/ssh*. That won’t work for your diskless userland
    or even in a chroot. You’ll need to create those keys the old-fashioned way.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在此目录中，为你的 SSH 版本使用的每种算法创建 SSH 密钥。虽然 ssh-keygen(1) 包含 `-A` 标志以自动生成缺失的密钥，但它会将这些密钥放在*/etc/ssh*中。这对你的无盘用户环境甚至在
    chroot 中都不起作用。你需要通过传统的方式来创建这些密钥。
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You’ll need to substitute the name of the cryptographic algorithm twice, in
    lowercase. For example, here’s how you’d create a DSA SSH key:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将加密算法的名称替换为小写两次。例如，这里是如何创建一个 DSA SSH 密钥：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Today, OpenSSH creates keys for RSA, ECDSA, and ED25519\. Create each of those.
    Key creation is easily scriptable. See */etc/rc.d/sshd* for examples.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，OpenSSH 为 RSA、ECDSA 和 ED25519 创建密钥。为每种算法创建密钥。密钥创建非常容易脚本化。查看*/etc/rc.d/sshd*中的示例。
- en: Diskless clients let you easily run thousands of nearly identical machines.
    Now let’s look at protecting just one.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 无盘客户端让你轻松地运行成千上万几乎相同的机器。现在我们来看看如何保护其中的一台。
- en: '**Storage Encryption**'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**存储加密**'
- en: FreeBSD supports two different disk encryption methods, GBDE and GELI. Both
    tools work very differently, support different cryptographic algorithms, and are
    designed for different threat models. People talk about encrypting disks all the
    time, but you rarely hear discussions of what disk encryption is supposed to protect
    the disk from.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 支持两种不同的磁盘加密方法，GBDE 和 GELI。两种工具工作方式完全不同，支持不同的加密算法，并针对不同的威胁模型设计。人们常常谈论加密磁盘，但很少有人讨论磁盘加密到底是为了保护磁盘免受什么样的威胁。
- en: '*GBDE*, or *Geom-Based Disk Encryption*, has specific features for high-security
    environments where protecting the user is just as important as concealing the
    data. In addition to a cryptographic key provided by the user, GBDE uses keys
    stored in particular sectors on the hard drive. If either key is unavailable,
    the partition can’t be decrypted. Why is this important? If a secure data center
    (say, in an embassy) comes under attack, the operator might have a moment or two
    to destroy the keys on the hard drive and render the data unrecoverable. If the
    bad guys have a gun to my head and tell me to “enter the passphrase or else,”
    I want the disk system to say, `The passphrase is correct, but the keys have been
    destroyed`. I don’t want a generic error saying, `Cannot decrypt disk`. In the
    first situation, I still have value as a blubbering hostage; in the latter, either
    I’m dead or the attackers get unpleasantly creative.^([3](footnote.xhtml#ch23fn3))'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*GBDE*（基于几何的磁盘加密）在高安全性环境中具有特定的功能，在这些环境中，保护用户与隐藏数据同样重要。除了用户提供的加密密钥外，GBDE 还使用存储在硬盘特定扇区中的密钥。如果任一密钥不可用，则无法解密分区。为什么这很重要？如果一个安全数据中心（例如在大使馆）遭到攻击，操作员可能会有一两分钟的时间来摧毁硬盘上的密钥并使数据无法恢复。如果坏人把枪指着我的头，告诉我“输入密码，否则怎样”，我希望磁盘系统能说：“密码正确，但密钥已被销毁”。我不想要一个泛泛的错误提示：“无法解密磁盘”。在第一种情况下，我仍然作为一个支离破碎的人质有一定价值；在后一种情况下，我要么死了，要么攻击者会变得非常有创意。^([3](footnote.xhtml#ch23fn3))'
- en: GELI is much more flexible, but it won’t protect me from bodily harm the way
    GBDE might. If someone might steal my laptop for the confidential documents on
    it, or if an untrusted system user might snoop my swap space to steal secrets,
    GELI suffices. GELI doesn’t try to protect my person, just my data. As I won’t
    take any job that poses a higher than average risk of exposure to firearms (keeping
    in mind that I live in Detroit), that’s perfectly fine with me. GELI also uses
    FreeBSD’s cryptographic device driver, which means that if your server has a hardware
    cryptographic accelerator, GELI takes advantage of it transparently.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: GELI更加灵活，但它不像GBDE那样能保护我免受身体伤害。如果有人可能因为我笔记本上的机密文件而偷走我的电脑，或者如果一个不受信任的系统用户可能窥探我的交换空间来窃取秘密，GELI足够用了。GELI并不试图保护我的人身安全，只保护我的数据。由于我不会从事任何可能增加暴露于枪支的工作（考虑到我住在底特律），这对我来说完全没问题。GELI还使用FreeBSD的加密设备驱动程序，这意味着如果你的服务器有硬件加速器，GELI会透明地利用它。
- en: I should mention that people lose more data to encryption misconfiguration or
    lost keys than to laptop theft. When I hear someone say, “I’ve encrypted my whole
    hard drive!” I have a nearly psychic vision of the future where that same person
    is saying, “I’ve lost access to everything on my hard drive!” More often than
    not, I’m correct. Consider carefully whether you really, truly *need* disk encryption.
    If you do need it, also back your files up. Those government spooks aren’t going
    to crack the encryption on your laptop. They’re going to wait for you to decrypt
    it yourself—and then they’ll break in.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该提到，人们因为加密配置错误或丢失密钥而损失的数据，远多于因为笔记本被盗。当我听到有人说“我已经加密了整个硬盘！”时，我几乎能预见未来那个同一个人会说：“我丢失了对硬盘上所有内容的访问！”通常我没错。仔细考虑一下你是否真的*需要*磁盘加密。如果你确实需要它，也要备份你的文件。那些政府特工不会破解你笔记本上的加密，他们会等你自己解密——然后他们才会入侵。
- en: If you want to encrypt your laptop, use the FreeBSD installer to do so. You
    should still read this section so you understand how the disk encryption works,
    but if the installer wants to do the work for you, let it. We’ll walk through
    using GELI to encrypt a disk partition on */dev/da0*, storing the cryptographic
    keys on the USB storage device mounted on */media*. You might find it more sensible
    to use a filesystem in a file (see [Chapter 13](ch13.xhtml#ch13)) as an encrypted
    partition. Very few people actually need to encrypt their entire hard drive, and
    in certain circumstances, doing so might raise suspicions. I have enough trouble
    explaining to airport security why my computer “looks so weird.” In their minds,
    a boot prompt that says, `Insert cryptographic key and enter cryptographic passphrase`
    is only one step away from `This man is a` `dangerou``s lunatic who requires a
    very thorough body cavity search`. If you really do need to encrypt certain documents,
    chances are they total only a few megabytes. That’s a perfect application for
    a filesystem in a file or a flash drive.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想加密你的笔记本，使用FreeBSD安装程序来完成这项工作。你仍然应该阅读这一节，以便理解磁盘加密是如何工作的，但如果安装程序愿意为你做这项工作，就让它去做。我们将通过使用GELI加密*/dev/da0*上的磁盘分区，并将加密密钥存储在挂载于*/media*的USB存储设备上。你可能会觉得使用文件系统中的文件（见[第13章](ch13.xhtml#ch13)）作为加密分区更为合理。实际上很少有人需要加密整个硬盘，在某些情况下，加密整个硬盘可能会引起怀疑。我已经够麻烦地向机场安检解释我的电脑“看起来如此奇怪”了。在他们看来，一个显示`插入加密密钥并输入加密密码`的启动提示，离`此人是`
    `一个危险`的疯子，可能需要进行非常彻底的身体检查`只有一步之遥。如果你真的需要加密某些文件，通常它们的总大小只有几兆字节。那正是使用文件系统中的文件或闪存驱动器的完美应用场景。
- en: Note that you must load the *geom_eli.ko* kernel module before working with
    GELI.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你必须在使用GELI之前加载*geom_eli.ko*内核模块。
- en: '***Generating and Using a Cryptographic Key***'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***生成和使用加密密钥***'
- en: GELI lets you use a key file and/or a passphrase as cryptographic keys for an
    encrypted device. We’ll use both. To generate your cryptographic key file, use
    dd(1) to grab a suitable amount of data from */dev/random* and write it to a file.
    Remember, */media* is where our USB device is mounted. If you really want to protect
    your data, create your key directly on the USB device and don’t leave it on your
    filesystem where a hypothetical intruder could recover it. (Even deleting the
    file still leaves remnants that a skilled attacker could conceivably extract.)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: GELI 允许你使用密钥文件和/或密码短语作为加密设备的加密密钥。我们将同时使用这两者。要生成你的加密密钥文件，使用 `dd(1)` 从 */dev/random*
    获取适量的数据并写入到文件中。记住，*/media* 是我们的 USB 设备挂载点。如果你真的想保护你的数据，最好直接在 USB 设备上创建密钥，而不是把它保存在你的文件系统中，以防假设的入侵者恢复它。（即使删除文件，依然会留下痕迹，熟练的攻击者有可能提取这些残留数据。）
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The 64 bytes of data constitute a 512-bit key. You can increase the size of
    the key if you like, at the cost of extra processor overhead when accessing the
    encrypted filesystem. Don’t forget that your passphrase also increases key complexity.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这 64 字节的数据构成了一个 512 位的密钥。如果你愿意，可以增加密钥的大小，但这会在访问加密文件系统时增加额外的处理器负载。别忘了，你的密码短语也会增加密钥的复杂性。
- en: To assign a passphrase to the key, use `geli init`. The `-s` flag tells geli(8)
    the desired sector size on the encrypted filesystem; 4,096 bytes, or 4KB, is usually
    a decent sector size for this application. The `-K` indicates the key file. You
    must also specify the device to be encrypted.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要为密钥分配密码短语，使用 `geli init`。`-s` 标志告诉 geli(8) 加密文件系统所需的扇区大小；通常，4,096 字节或 4KB 是一个合适的扇区大小。`-K`
    表示密钥文件。你还必须指定要加密的设备。
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A passphrase is much like a password except that it can contain spaces and be
    of any length. If you really want to protect your data, I recommend using a passphrase
    that is several words long, contains nonalphanumeric characters, and is not a
    phrase in your native language.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 密码短语与密码类似，只不过它可以包含空格并且长度没有限制。如果你真的想保护你的数据，我建议使用一个由多个单词组成、包含非字母数字字符的密码短语，并且不要使用你母语中的常见短语。
- en: Now that you have a key, attach it to the device to be encrypted.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个密钥，将它附加到要加密的设备上。
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: GELI now knows that */dev/da0p1* is an encrypted disk and that the file */media/da0p1.key*
    contains the key file. Once you enter the passphrase, you can access the decrypted
    contents of the encrypted disk at the new device node, */dev/da0p1.eli*. Of course,
    you need a filesystem to put any data on that disk.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: GELI 现在知道 */dev/da0p1* 是一个加密磁盘，并且文件 */media/da0p1.key* 包含密钥文件。一旦你输入密码短语，你就可以通过新的设备节点
    */dev/da0p1.eli* 访问加密磁盘的解密内容。当然，你还需要一个文件系统来存储数据。
- en: '***Filesystems on Encrypted Devices***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加密设备上的文件系统***'
- en: 'Before you build a filesystem on your encrypted device, purge the disk of any
    lingering data. Programs like newfs(8) and zpool(8) don’t actually overwrite most
    of the bits in a new partition; they simply add superblocks that indicate the
    location of inodes. If you’ve used this disk before, an intruder would be able
    to see chunks of old files on the disk. Worse, he’d see chunks of encrypted data
    placed there by GELI. Before you put a filesystem on the disk, it’s best to cover
    the disk with a deceptive film of randomness to make it much more difficult for
    an intruder to identify which blocks contain data and which do not. Use dd(1)
    again:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在你为加密设备构建文件系统之前，先清除磁盘上任何残留的数据。像 newfs(8) 和 zpool(8) 这样的程序并不会真正覆盖新分区中的大部分数据位；它们仅仅添加了超块，标明
    inode 的位置。如果你之前使用过这块磁盘，入侵者将能够看到磁盘上的旧文件残片。更糟的是，他还会看到 GELI 放置在其中的加密数据块。在为磁盘创建文件系统之前，最好覆盖磁盘一层伪装的随机数据，这样可以让入侵者更难识别哪些块包含数据，哪些不包含数据。再次使用
    `dd(1)`：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: FreeBSD has an infinite supply of chaos—or, in technical terms, */dev/random*
    is nonblocking. The amount of time needed to cover the whole disk with high-quality
    randomness depends on your storage system. It might take a day.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 拥有无限的混乱——或者用技术术语说，*/dev/random* 是非阻塞的。用高质量的随机数覆盖整个磁盘所需的时间取决于你的存储系统。可能需要一天时间。
- en: Now that your disk is full of garbage, put a filesystem on it and attach it
    to your system. I’ll often use UFS on such encrypted devices.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的磁盘充满了垃圾数据，在它上面创建文件系统并将其附加到系统上。我通常会在这种加密设备上使用 UFS 文件系统。
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Your encrypted disk device is now available on */mnt*. Store your confidential
    files there.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你的加密磁盘设备现在可以在 */mnt* 中访问。将你的机密文件存储在那里。
- en: 'Encrypted disks have many more possibilities. Either read geli(8) or check
    out my book *FreeBSD Mastery: Storage Essentials* (Tilted Windmill Press, 2014).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 加密磁盘有更多的可能性。要么阅读 geli(8)，要么查看我的书籍《FreeBSD 精通：存储基础》（Tilted Windmill Press, 2014）。
- en: This takes you through some of FreeBSD’s murkier corners. Now let’s see what
    to do when things go *really* wrong . . . .
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引导你了解 FreeBSD 中一些较为晦涩的部分。现在让我们看看当事情*真的*出错时该怎么办。。。
