- en: Chapter 3. Game Logic
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we’ve created an intro screen with a New Game button and a single
    bubble that a player can fire off the screen. In this chapter, we’ll turn the
    *Bubble Shooter* into more of a game. You’ll learn how to draw the game board
    and display the level to the player, and then learn about collision detection.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '*Collisions* are central to many games and happen when sprites touch. Once
    you can detect collisions, you can write code that makes the sprites react to
    them. In the *Bubble Shooter*, collisions occur when a fired bubble slams into
    a bubble in the game grid. We’ll implement two reactions: the fired bubble will
    stick to the board if it doesn’t form a color group of three or more bubbles,
    or it will cause a valid group to fall from the board.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: But before we can calculate collisions, we need an object for a bubble to collide
    with. The first section of this chapter discusses drawing the initial board and
    setting up the game state. To do so, we’ll need to follow a process containing
    a number of steps, shown in [Figure 3-1](ch03.html#game_loop_starts_by_drawing_the_board_an
    "Figure 3-1. The game loop starts by drawing the board and ends by showing the
    score.").
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![The game loop starts by drawing the board and ends by showing the score.](httpatomoreillycomsourcenostarchimages2184509.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1. The game loop starts by drawing the board and ends by showing the
    score.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: We’ll draw the game board first and then add collision detection to the bubble
    that’s been fired. In the next chapter, we’ll implement the mechanism to pop groups
    of bubbles based on matching color.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Let’s work through the steps and turn them into code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the Game Board
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The game board has a similar structure for every level, and each board contains
    rows of bubbles in four different colors. Alternate rows contain either an odd
    or even number of bubbles depending on whether the row is odd or even. We’ll store
    all this state information in a `Board` object and store the current board as
    a variable in the `Game` object.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'The object structure you choose should vary depending on the game design, but
    the goals should be the same as when you’re deciding how to structure code in
    web applications: group objects that perform similar operations, and strike a
    balance with how much common functions are abstracted. Don’t define several classes
    that contain very little code, but don’t create too few classes with long code
    listings that will be difficult to read and understand. Game developers often
    base initial structural decisions on instinct and experience as well as on hard-and-fast
    rules. Always be prepared to refactor code if you think your original choices
    are no longer valid.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The rows that make up the board will be an array of `Bubble` objects. We’ll
    create this array when we instantiate the `Board` object. Later, we’ll transfer
    the drawing of the board elements to the DOM from within *ui.js*. Ending up with
    a large mass of code within a `Game` class is easy to do but undesirable; therefore,
    take the opportunity to hand off responsibilities to other classes whenever possible,
    especially when rendering objects to the screen.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 组成棋盘的行将是一个`Bubble`对象的数组。当我们实例化`Board`对象时，会创建这个数组。稍后，我们将把棋盘元素的绘制从*ui.js*转移到DOM中。将大量代码放入`Game`类中很容易，但这并不是我们想要的；因此，尽可能将职责交给其他类，特别是在将对象渲染到屏幕时。
- en: 'In *game.js*, we need to create a variable to hold the board and a new instance
    of a `Board` object. The board is generated when the New Game button is clicked.
    Add the following new code to *game.js*:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在*game.js*中，我们需要创建一个变量来存储棋盘和一个新的`Board`对象实例。当点击“新游戏”按钮时，棋盘会被生成。将以下新代码添加到*game.js*中：
- en: '*game.js*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`Board` is a new constructor that we need to make. Create a new file called
    *board.js* and add it to the list of files to load in `Modernizr.load` in *index.html*.
    Add the following code to the new file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`Board`是我们需要创建的一个新构造函数。创建一个名为*board.js*的新文件，并将其添加到`Modernizr.load`在*index.html*中的加载文件列表中。将以下代码添加到新文件中：'
- en: '*board.js*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*board.js*'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`NUM_ROWS` ➊ and `NUM_COLS` ➋ are constants that determine the number of rows
    and columns that make up the bubble board grid. The number of columns may seem
    high, since we certainly won’t have 32 bubbles in a row. The reason for such a
    large column value is that we’ll create a grid entry for every half bubble width,
    because odd and even rows are offset on the game board. This design decision results
    in a more visually appealing layout, making it look like bubbles are stacking
    on top of each other. It also creates more interesting angles for the player to
    fire at.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`NUM_ROWS` ➊ 和 `NUM_COLS` ➋ 是常量，决定了气泡棋盘网格的行数和列数。列数可能看起来很大，因为我们肯定不会在一行中放32个气泡。设置这么大的列数的原因是，我们将为每个气泡的半宽度创建一个网格项，因为奇数行和偶数行在棋盘上是错开的。这一设计决策使得布局更具视觉吸引力，看起来像气泡堆叠在一起。它还为玩家提供了更多有趣的角度来射击。'
- en: 'All the bubbles on the first row and every subsequent odd row will have odd
    *y*-coordinates, and those on even rows will have even *y*-coordinates. The rows
    increment in integer steps, but the array we’ll use starts with an index of zero:
    the first row will be at index 0, the second will be at index 1, and so on. Thus,
    the bubble coordinates (*x*,*y*), starting from the top-left corner of the bubble
    board, will be labeled as shown in [Figure 3-2](ch03.html#coordinates_of_the_bubbles_in_the_game_g
    "Figure 3-2. Coordinates of the bubbles in the game grid"). Specifying coordinates
    this way and having a half-populated grid avoids having to work with half values
    and decimal points. In addition, we can store the layout of the board in arrays
    indexed by integers. Working with integers rather than decimals doesn’t change
    the process we’ll follow to calculate collisions, but it does make the code more
    readable.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行和每个随后的奇数行上的所有气泡将具有奇数的*y*坐标，而偶数行上的气泡将具有偶数的*y*坐标。行数以整数步进增加，但我们将使用的数组从零开始索引：第一行在索引0，第二行在索引1，以此类推。因此，气泡坐标(*x*,*y*)，从气泡棋盘的左上角开始，标记如下图[图3-2](ch03.html#coordinates_of_the_bubbles_in_the_game_g
    "图3-2. 游戏网格中气泡的坐标")所示。通过这种方式指定坐标并使用半填充的网格，避免了使用半值和小数点。此外，我们可以将棋盘布局存储在由整数索引的数组中。使用整数而不是小数并不会改变我们计算碰撞时的过程，但它确实使代码更具可读性。
- en: '![Coordinates of the bubbles in the game grid](httpatomoreillycomsourcenostarchimages2184511.png.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![游戏网格中气泡的坐标](httpatomoreillycomsourcenostarchimages2184511.png.jpg)'
- en: Figure 3-2. Coordinates of the bubbles in the game grid
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-2. 游戏网格中气泡的坐标
- en: 'In the code, we’ll now call the `createLayout` function ➌, which returns a
    two-dimensional array of rows and columns. We provide public access to this array
    in the next line ➍. Once we have a `Board` object, we can retrieve the bubble
    at any specific row and column position. For example, to access a bubble at coordinate
    (4,1) we would write:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们现在将调用`createLayout`函数 ➌，它返回一个二维的行列数组。在下一行 ➍ 中，我们提供了对这个数组的公共访问。一旦我们拥有了`Board`对象，就可以检索到任何特定行列位置的气泡。例如，要访问坐标(4,1)处的气泡，我们可以写：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Bubbles are accessed by row and then column number. First, we grab all the rows
    with `board.getRows`, and then we store the first row from the board as `row`.
    Next, we access the fourth bubble within `row` by its column number. Because the
    `row` array is only half populated, all odd entries in even-indexed rows (starting
    at zero) and all even entries in odd rows will be null.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The `createLayout` function contains a loop ➎. For each row we want to create,
    `startCol` ➏ calculates whether to start on column 1 or 0 depending on whether
    the row is odd or even, respectively. Then another loop increments to the maximum
    column number, creates a new `Bubble` object ➐, and adds it to the row array,
    which is returned on completion.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: For this function to work, we need to adapt the `Bubble` class to accept row
    and column input coordinates, and we need to make a change to the `Bubble.create`
    method. Also, if a `Bubble` object knows its position in the grid by storing its
    coordinates, that information will be useful when we need to calculate groups
    to pop. When we know a bubble’s position, we can access that bubble, as it’s stored
    within the `Board` object. Then given a bubble, we can interrogate it to determine
    its position. Each bubble will have a `type` property, which corresponds to its
    color, and the property will be determined at creation time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: When you start coding your own game ideas, the decisions about where to store
    data and how to access it are critical. Your solution will depend on the type
    of game you’re building. In *Bubble Shooter*, we store a relatively small number
    of `Bubbles` within a `Board` object. To find out information about a particular
    bubble, we can access the data that the `Board` stores by retrieving data from
    the `rows` array.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how we need to use that bubble data, this method might not be the
    most elegant solution. For example, imagine we want to find all of the red bubbles
    in the game. Currently, we would have to loop over every space on the board, check
    whether the bubble is red, and then store the outcome. The game grid is small,
    so modern processors can perform this operation quickly. As long as we don’t run
    the color check too many times a second, the current code structure should work.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'But now imagine *thousands* of bubbles on the screen. Looping over all the
    bubbles just to find red ones would consume too much processing power. Instead,
    we might want to store bubbles in multiple arrays—one for all the red bubbles,
    one for all the green bubbles, and so on—for instant access to all bubbles of
    each color. However, there would still be a tradeoff: to check whether a given
    space on the board is occupied by a bubble, regardless of color, we would have
    to look at multiple arrays.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: When you have only a rough sense of how fast a processor can run an operation,
    it’s best to make your code clear and simple. If your game is playable and runs
    sufficiently fast, you won’t need to experiment with different ways to access
    data. Alternatively, if you identify bottlenecks, you’ll then have to refactor
    some sections to increase their speed. Game development is an iterative process;
    you’ll revisit existing lines of code as much as you write new ones.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'How you design objects and where you store their data will vary from game to
    game. But remember this: if the `Game` object needs to use that data, one way
    or another you must allow the object to access it. Whether data is stored directly
    in a variable or in an array within `Game`, or is accessed through an intermediate
    object that `Game` has access to (such as the `Board` object in *Bubble Shooter*),
    the code will need to access that object’s state if it needs to make decisions
    about that object.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'To support a bubble storing its position on the board and its color, amend
    *bubble.js* as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '*bubble.js*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Bubble` now takes grid coordinates and a bubble type as well as the sprite
    object ➊, where type corresponds to colors that were specified in *game.css*.
    The Bubble.create method accepts the same parameters ➋; if type isn’t passed ➌,
    one of the four types (colors) is chosen at random ➍.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a `Board` object, plenty of bubbles, and their types and positions.
    But all this information is entirely in memory and is stored within the `Board`
    object’s `rows` property. Next, we’ll render the level using this information
    so players can see the game board.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the Level
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drawing the level is a perfect job for the `ui` class, because `ui` represents
    the game state but doesn’t affect that state.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Separating the code that calculates an object’s position from the code that
    renders that object to the screen is a principle you should apply in all of your
    game ideas. Not only does it separate rendering code from game logic, thereby
    improving readability, but it also allows you to more easily change how objects
    are rendered. For example, if the *Bubble Shooter* board was larger and didn’t
    fit on the screen but we wanted to implement a zoom or pan feature, we could change
    the code that renders the board to either offset the rendering position or to
    scale up or down to draw a different size board. The power of separating rendering
    from game logic will become apparent when we switch from DOM-based sprites to
    drawing onto the HTML `canvas` element in [Chapter 6](ch06.html "Chapter 6. Rendering
    Canvas Sprites").
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the creation of a `bubble` object involves creating a DOM sprite element,
    the rendering process needs to place this element in the document and position
    it correctly. These simple steps follow:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Loop over all the rows and columns and pull out each `bubble` object.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the bubble’s HTML into the DOM.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the bubble in the correct position.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next piece of code you add will apply these steps. Open *ui.js*, add a
    new method (`drawBoard`) after `fireBubble`, and then add a new `ROW_HEIGHT` constant
    at the top:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '*ui.js*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `drawBoard` method retrieves the board rows and columns ➊ and loops over
    them ➋. If there’s a bubble ➌ (recall that every other *x*-coordinate position
    is `null` due to the sparse grid system), `drawBoard` grabs the `sprite` object
    ➍, appends it to the board ➎, and calculates its coordinates before setting its
    position ➏.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine a bubble’s position, `drawBoard` first calculates the left coordinate,
    which is the bubble’s column number multiplied by half its width. To calculate
    the top coordinate, we’ll use a value slightly smaller than the `BUBBLE_DIMS`
    height. The odd and even rows are staggered, and we want the bubbles to look like
    they fit together. To create the stacking effect, the vertical separation will
    be slightly less than the horizontal distance. At the top of *ui.js*, `ROW_HEIGHT`
    has been set to 40, which is 4 pixels less than the height. This value was determined
    through trial and error rather than geometrical calculation: adjust the numbers
    until the bubble grid looks pleasing to you.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Reload and click **New Game**; you should see a nicely rendered board. You can
    even fire a bubble at the rest of the board; unfortunately, it should just go
    straight through without hitting anything and continue off the screen as before.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Because we have only one bubble, we need to refresh to retry the process. Before
    we begin working on collision detection, we’ll make sure we can keep firing one
    bubble after another.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The Bubble Queue
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the player will have only a finite number of bubbles to fire, the game
    needs to provide those bubbles in a constant stream. Therefore, we’ll need to
    add a function that creates a new bubble, adds it to the DOM, and queues up the
    next bubble as soon as the user fires the first one.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'In *game.js*, add the following variables and functions and change the initialization
    for `curBubble` to call a new `getNextBubble` function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '*game.js*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The new code first creates a variable ➊ to store the number of bubbles the player
    has fired. Because the number of fired bubbles is an integer—a basic data type—we’ll
    store it as a variable in `Game`. If, for example, we had a time limit that a
    level had to be completed within, we might create an object to store time remaining
    along with bubbles remaining rather than continuing to create variables in `Game`.
    As it is, the variable suits our purpose.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The code also sets a constant for the maximum number of bubbles ➋ the player
    can fire. When a level is started, it sets the number of bubbles remaining to
    the value of `MAX_BUBBLES` ➌ and calls a new function in *ui.js* to display the
    number of remaining bubbles on the screen ➍. Finally, the code calls `getNextBubble`
    ➎ each time a bubble is fired to prepare a new one.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'We also want to show the player the number of remaining bubbles available to
    fire within a level, so create the `drawBubblesRemaining` method in *ui.js*, appending
    this new function to the `ui` object:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '*ui.js*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Additionally, we need to display the number of remaining bubbles, so add a
    new element in *index.html*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '*index.html*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add some styling for the `bubbles_remaining` div into *main.css*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '*main.css*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now refresh the game. You should be able to fire bubbles into the distance,
    get a new one as soon as the first is fired (until you’ve used 70 bubbles, or
    whatever value you used for `MAX_BUBBLES`), and be able to fire that new bubble
    immediately.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Often, you can break down a game into a repeating *turn loop*. The loop is usually
    initiated by a player action and then closed when that action has been resolved.
    In *Bubble Shooter*, the loop commences when the player clicks the screen to fire
    the button and completes when the next bubble is ready to fire. At this point
    we have the basic turn loop, but to create the game, we need to flesh out the
    middle part of the loop to calculate where to stop a bubble and whether to pop
    bubbles.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Collisions
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although you can now fire bubbles, they pass straight through the board without
    affecting the bubble grid. The game design calls for them to collide with the
    board and either become part of the board or cause groups of bubbles that are
    the same color to pop. The next task is to work out where collisions occur.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'We can calculate collisions in two ways:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Move a sprite forward a few pixels for each frame and then try to detect any
    overlaps with other sprites. If there’s an overlap, we know we’ve hit another
    bubble.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use geometry to calculate where the sprite might collide with another bubble
    before it even starts moving.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In fast-paced arcade games, you might choose the first option, as long as there’s
    no chance objects will pass through each other without a collision being detected.
    These pass-throughs can happen when objects move at high speeds, and collision
    checks occur after an object has moved numerous pixels since the previous check.
    For example, in a game in which you fire a bullet at a one-foot-thick wall, the
    bullet would only be guaranteed to collide with the wall if you check for collisions
    every foot. If you checked for collisions every two feet instead, you might check
    for a collision just before the bullet should hit and find no wall. Then two feet
    further along when you check again, the bullet would be past the wall, again resulting
    in no collision.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'To work around the fast-moving-object problem, we could make sure the steps
    are always small enough that pass-throughs never happen; however, that requires
    more calculations, which may not be possible without significant computing power.
    This problem is more likely to surface in a browser environment: because we never
    know the specs of the end user’s computer, we can’t take processing power for
    granted.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option, using geometry, is more accurate if it’s feasible. Fortunately,
    our game design has fairly simplistic geometric properties. Unfortunately, this
    option isn’t possible in games in which sprites have more complex shapes. In that
    case, you’d have to check whether pixels overlap on a frame-by-frame basis and
    test thoroughly to ensure you don’t see any side effects. For *Bubble Shooter*,
    we’ll use a geometrical approach because we have the following advantages:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用几何方法，如果可行的话，它更为准确。幸运的是，我们的游戏设计具有相对简单的几何特性。不幸的是，在精灵具有更复杂形状的游戏中，这种方法不可行。在这种情况下，您必须逐帧检查像素是否重叠，并进行彻底测试以确保不会出现任何副作用。对于*Bubble
    Shooter*（气泡射手），我们将采用几何方法，因为我们具备以下优势：
- en: The game is on a regular grid.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏使用规则网格。
- en: All the objects (the bubbles) are identical.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有物体（气泡）都是相同的。
- en: We’re working in only two dimensions.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只在二维空间中进行工作。
- en: The player moves only one object.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家只移动一个物体。
- en: All the objects are simple geometric shapes (circles), so the calculation of
    where edges meet is easy.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的物体都是简单的几何形状（圆形），因此计算边缘相交的位置非常简单。
- en: These conditions make geometric calculations for collisions relatively straightforward.
    Because game development often involves a lot of geometry, having a good grounding
    in trigonometry and vectors is essential. The next section discusses the geometry
    involved in this game. Then we’ll turn that geometry into code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些条件使得碰撞的几何计算相对简单。由于游戏开发通常涉及大量的几何学，因此掌握三角学和向量是至关重要的。下一部分将讨论游戏中的几何形状，然后我们将把这些几何形状转化为代码。
- en: Collision Geometry
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞几何
- en: When you need to calculate collisions, draw the geometry on a piece of paper
    before you write the detection code. You’ll then be able to visualize the values
    you’ll need to calculate, as shown in [Figure 3-3](ch03.html#visualizing_the_geometry_behind_a_bubble
    "Figure 3-3. Visualizing the geometry behind a bubble collision").
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要计算碰撞时，先在纸上画出几何图形，然后再编写检测代码。这样，您将能够可视化您需要计算的值，如[图 3-3](ch03.html#visualizing_the_geometry_behind_a_bubble
    "图 3-3。可视化气泡碰撞背后的几何形状")所示。
- en: '![Visualizing the geometry behind a bubble collision](httpatomoreillycomsourcenostarchimages2184513.png.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![可视化气泡碰撞背后的几何形状](httpatomoreillycomsourcenostarchimages2184513.png.jpg)'
- en: Figure 3-3. Visualizing the geometry behind a bubble collision
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-3。可视化气泡碰撞背后的几何形状
- en: The bubble being fired should cause a collision when its center passes within
    2*R* (where *R* is a bubble’s radius) of another bubble’s center, meaning that
    the two circumferences are touching. Because the intersection point will always
    be normal (at 90 degrees) to the colliding bubble’s edge and the edge of the bubble
    being hit, we need to check for a collision only if the path of the moving bubble’s
    center comes within 2*R* of another bubble’s center.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当发射气泡的中心距离另一个气泡的中心小于 2*R*（其中 *R* 是气泡的半径）时，应该发生碰撞，这意味着两个气泡的圆周接触。由于交点总是与碰撞气泡的边缘以及被撞气泡的边缘成
    90 度垂直，因此我们只需要检查当移动气泡的中心路径距离另一个气泡的中心小于 2*R* 时，是否发生碰撞。
- en: To determine where collisions occur, we need to check every other bubble on
    the board to determine whether the fired bubble’s path passes through it. If it
    overlaps with multiple bubbles, as it does in [Figure 3-4](ch03.html#fired_bubble_may_be_on_a_path_to_collide
    "Figure 3-4. The fired bubble may be on a path to collide with multiple other
    bubbles."), we need to make sure that the struck bubble we pick is the first collision
    that occurs, which will be the one in which the firing bubble has traveled the
    least distance.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定碰撞发生的位置，我们需要检查棋盘上的每个其他气泡，判断发射的气泡的路径是否经过它。如果它与多个气泡重叠，就像在[图 3-4](ch03.html#fired_bubble_may_be_on_a_path_to_collide
    "图 3-4。发射的气泡可能会与多个其他气泡发生碰撞。")中所示，我们需要确保我们选中的撞击气泡是第一个发生碰撞的气泡，也就是发射气泡行进距离最短的那个。
- en: '![The fired bubble may be on a path to collide with multiple other bubbles.](httpatomoreillycomsourcenostarchimages2184515.png.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![发射的气泡可能会与多个其他气泡发生碰撞。](httpatomoreillycomsourcenostarchimages2184515.png.jpg)'
- en: Figure 3-4. The fired bubble may be on a path to collide with multiple other
    bubbles.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-4。发射的气泡可能会与多个其他气泡发生碰撞。
- en: Detecting a collision is equivalent to detecting when a vector drawn from the
    center line of the bubble we’re firing intersects with a circle with a radius
    double that of our bubbles. This will be known as a bubble’s *hitbox*. [Figure 3-5](ch03.html#if_the_fired_bubbleapostrophes_travel_pa
    "Figure 3-5. If the fired bubble’s travel path intersects a stationary bubble’s
    circular hitbox, a collision occurs.") shows how we can redraw this concept to
    help us think about it in a way that’s easier to compute.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![If the fired bubble’s travel path intersects a stationary bubble’s circular
    hitbox, a collision occurs.](httpatomoreillycomsourcenostarchimages2184517.png.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: Figure 3-5. If the fired bubble’s travel path intersects a stationary bubble’s
    circular hitbox, a collision occurs.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: In this diagram, the small filled circle marks the center of the bubble being
    fired. The bubble it will collide with is the inner circle, and the intersection
    with the bubble’s hitbox (the point marked with the arrow 2*R*, which is double
    a bubble’s radius) is where the bubble will stop.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Turning the diagram into a mathematical formula means using vectors. Rather
    than working through the math before showing any code, let’s go straight into
    the necessary JavaScript, which includes explanatory annotations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying Hitboxes
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Because we are working with circles, creating a hitbox is simpler than it might
    be if you were dealing with, for example, a figure that runs and jumps, as in
    a platform game. In that case, you might not want to detect collisions just by
    checking whether pixels overlap because of possible performance issues; instead,
    you could simplify the geometry of the main character and create a rectangular
    hitbox to check against. Not all games lend themselves to this approach. However,
    if you can reduce complex character outlines to simple geometrical shapes, you
    can detect collisions with much greater precision and less processing power than
    by checking whether pixels have overlapped. Always look for creative, efficient
    solutions to avoid brute-force techniques that monopolize resources.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'The calculation is a large block of code with a specific function, so we’ll
    put it in its own file. Create a file called *collision-detector.js* and add it
    to the `Modernizr.load` call in *index.html*. Type in the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '*collision-detector.js*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In a moment I’ll break down the code in *collision-detector.js*. But first,
    notice the call to a new method in *bubble.js* called `getCoords` ➊, which returns
    the center (*x*,*y*) coordinate of a bubble based on its position in the row/column
    hierarchy. You’ll need to amend the bubble class to add the new method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '*bubble.js*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The game coordinates of a bubble are simple to calculate: you start by finding
    each top-left corner coordinate. The *x*-coordinate (left) is the column number
    ➊ multiplied by half the bubble sprite’s width ➋. The *y*-coordinate (top) is
    the row number ➌ multiplied by the row height ➍, which is slightly less than the
    bubble’s full height. To find the center of a bubble, just add half the bubble’s
    dimensions ➎ to both *x* and *y*.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: When you’re developing game logic, the center coordinates of an object are more
    often the focus, whereas for rendering purposes, you’ll usually specify the top-left
    corner along with a width and a height. Building a handy method into the object
    that converts from one to the other will save you from writing out the math each
    time you need to switch.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Collision Detection Logic
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s walk through the entire `findIntersection` routine in *CollisionDetector.js*
    block by block. If you don’t want to dig into the math right now, you can skip
    this breakdown—it’s purely the math of detecting collisions and doesn’t contain
    any new HTML5 or game development concepts. However, know that in almost every
    game you write, you’ll break down the complexities of how objects interact into
    a model that you can manipulate with relatively simple mathematics.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Starting Position and Direction Vector
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first part added to *collision-detector.js* is the standard library intro:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We’ve created an object called `CollisionDetector`. Now let’s look at the first
    method on that object:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When you call `CollisionDetector`, you’ll use `BubbleShoot.CollisionDetector.findIntersection`.
    It accepts the parameters `curBubble` (an instance of the `Bubble` class), the
    `board` variable (an instance of `Board`), and the angle at which the bubble is
    being fired, giving the function everything it needs to know about the starting
    situation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, examine the first variables within `findIntersection`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We’ll loop over each row to check for collisions, so let’s grab the board rows
    into a local variable. Assuming there’s no collision by default, this will be
    the state returned by the function if no intersections occur. As a result, if
    the fired bubble doesn’t hit another bubble, it will keep moving forward.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'The starting value of `collision` is `null` instead of `false` because if an
    intersection occurs, it will hold the bubble that’s been collided with, plus some
    other information, rather than a Boolean that indicates whether or not a collision
    has occurred. We need to know that a collision has occurred (which would be a
    “true” or “false” result), but more important, we need to send back information
    about what was collided with and where the collision occurred:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next pair of variables retrieves the bubble’s starting position (on the
    screen) as an object with top and left properties:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, `dx` and `dy` define how much a bubble moves left or right (`dx`)
    or up (`dy`) relative to the total distance the bubble will move. With those variables
    defined, we can loop through the rows and columns of the game board:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We’ll start at the top left of the game board and work our way down and to the
    right. Because we only fire bubbles upward, we know that a bubble will never collide
    with another from the top of the game board. We also know that if multiple collision
    candidates are present along the bubble’s path, we want to grab the one where
    the bubble has traveled the least distance—that is, the collision that happened
    first. Remember that because columns are sparsely populated (every other entry
    is null), we also need to make sure we’re actually looking at a bubble before
    we try to do anything with it—hence the `if(bubble)` check.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Calculating Collisions
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next we need to use some geometry to check whether the fired bubble’s hitbox
    collided with another bubble. We’ll determine where the vector defined by (*dx*,*dy*),
    which begins at the center of the fired bubble, intersects with the circle drawn
    in [Figure 3-4](ch03.html#fired_bubble_may_be_on_a_path_to_collide "Figure 3-4. The
    fired bubble may be on a path to collide with multiple other bubbles."). Let’s
    start with the equation of a circle:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: (*x* – *c*[x])² + (*y* – *c*[y])² = *r*²
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Here, *x* and *y* are the points on the circle’s circumference, *c*[x] and *c*[y]
    are the center points of the circle, and *r* is the radius of the circle. We’ll
    need those points to find the distance to the starting bubble.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This part of the loop contains a bubble to check a collision against, so let’s
    get *c*[x] and *c*[y], the center coordinates of the bubble (`coords` in the preceding
    code), and calculate the distance between this point and the fired bubble’s coordinates.
    We don’t yet know whether or not a collision will occur.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'The bubble being fired follows a set of coordinates defined by the equations:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '| *p*[x] = | *e*[x] + *td*[x] |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| *p*[y] = | *e*[y] + *td*[y] |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: 'where *p*[x] and *p*[y] are points on the trajectory of the bubble’s center
    point. The calculation of *p*[x] and *p*[y] happens in jQuery’s `animate` method
    and is the standard equation for moving a point along a line. Next, we’ll calculate
    *t* at the closest point on this line to the center of the bubble that we’re checking
    against:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This line tells us at what proportion of the fired bubble’s total movement
    it will be closest to the candidate bubble’s center. From this, we can calculate
    the screen coordinates where this happens:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With these coordinates, we can find the distance of *e* (the closest point
    on the fired bubble’s center line to the center of the candidate bubble):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If the distance `distEC` is less than double the candidate bubble’s radius,
    a collision occurs. If not, the fired bubble will not collide with this candidate
    bubble.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Trial and Error vs. Calculation
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Note that although `BubbleShoot.ui.BUBBLE_DIMS` gives the width and height of
    the sprite, we’re checking `distEC` against a bubble image that is actually slightly
    smaller. Multiplying the `BUBBLE_DIMS` value by 0 .75 (obtained from a bit of
    trial and error) gives a diameter for a bubble that works in the game.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: We can arrive at a more precise value for `distEC` by measuring the width of
    the bubble, which is 44 pixels in the images in this book. Dividing by the `BUBBLE_DIMS`
    of 50 pixels, the result is a multiplier of 0 .88\. Although this larger value
    might be more exact, it requires the player to be more accurate when trying to
    fire bubbles through gaps. Therefore, 0 .75 just feels better to the player, because
    it gives them more chances to make shots that they would find very difficult if
    the math were precise.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Often in game development, you’ll make decisions based on trial and error as
    much as by calculation. In this case, by using a slightly smaller value, you give
    the player the opportunity to fire bubbles through small gaps in the game board.
    Players won’t notice the lax enforcement of the laws of physics, and they’ll enjoy
    the game more.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'If `distEC` is less than three-quarters of the bubble sprite width, we know
    that the fired bubble’s travel path intersects the candidate bubble’s hitbox at
    some point:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Most likely, a second intersection point will occur where the line exits the
    bubble’s hitbox (see [Figure 3-5](ch03.html#if_the_fired_bubbleapostrophes_travel_pa
    "Figure 3-5. If the fired bubble’s travel path intersects a stationary bubble’s
    circular hitbox, a collision occurs."), which shows the center line of the fired
    bubble passing through the hitbox at two points), but we only want the first.
    Two calculations will ensure that we have the correct intersection. Let’s look
    at the first calculation:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we find the distance between the center of the struck bubble and the
    closest point on the fired bubble’s path. The second calculation follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The points on the line that cross the stationary bubble’s center are calculated
    here as offsets from the fired bubble’s path at point `t`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Correct Collision Point
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we want to choose which intersection we’ll encounter first—that is, which
    point is closest to where we’re firing `curBubble` from—so we need the distances
    to each potential collision point:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we’ll choose the correct collision point and calculate where `curBubble`
    needs to stop by adding the starting coordinates back into the system:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Most of the time, if the center of the bubble being fired collides with the
    edge of another bubble, it’ll cross twice: once on the way in and once on the
    way out. In the rare cases where it just brushes past and only a single collision
    point occurs, we’ll get two identical results, so it doesn’t matter which one
    we choose.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the function will loop over every bubble in the display and check
    for collisions; however, we don’t want to know about *every* collision—just the
    *nearest* one that occurs earliest in `curBubble`’s movement path.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'To store the current best-match collision, we use the `collision` variable,
    which was set to `null` before the loop started. Then, each time we find a collision,
    we check to see if the new collision is closer than the previous best. If no previous
    collision happened, the first one we find will be the best. The `collision` object
    stores a reference to the stationary bubble that the fired bubble collides with,
    the distance to the collision, and the coordinates where it happened:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now the `findIntersection` function will return an object with all the data
    we need if a collision is found or `null` if no collision occurs. All of these
    calculations happen before the bubble has even started moving.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Reacting to Collisions
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now need to use the collision coordinates we have in an amended version of
    `clickGameScreen` in *game.js* so we can fire and stop bubbles. We’ve written
    the first step in detecting a collision by resolving what the bubble has collided
    with (which may be *nothing*!). Now, `Game` needs to decide how to react to that
    information.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we check for a collision. If one occurs, we move the bubble to wherever
    the collision occurred. If one doesn’t occur, we fire the bubble off the screen.
    Change the existing `clickGameScreen` function in *game.js* to the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '*game.js*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If the distance the bubble moves has changed due to a collision, the time it
    needs to get there should also change, so all bubbles fire at the same velocity.
    We’ll use the collision data to recalculate that duration ➊.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Reload the game and fire a bubble. The bubble should stop when it hits the
    main group. But it still doesn’t look quite right. The bubble stops, but it doesn’t
    integrate itself into the board. It just sticks wherever it hits. Also, if you
    fire more bubbles, they just pile on top of each other; new bubbles won’t collide
    with previously fired bubbles. The problem is that the board state doesn’t change
    to synchronize with the display state, so we’ll correct this using two steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Add the fired bubble to the board state in the correct row and column.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the fired bubble stops, lock it into a tidy grid position.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second step will use information from the first.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Adding the bubble Object to the Board
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `bubble` object, `curBubble`, is in the DOM and should end up close to the
    correct position on the screen, so we can add it to the board’s row/column array
    when we know where it should fit.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the row number, we divide the *y*-coordinate by the height of rows
    and round down the result. Calculating the column number is similar, except we
    need to snap to either odd column numbers on even rows (including zero) or even
    column numbers on odd rows. Finally, we can add the bubble to the `rows` property
    of the `Board` object, because `Board` is where we’re storing positional information
    for all of the bubbles.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'The function to add the fired bubble is trivial, so we’ll put that in *board.js*.
    Within the definition of the board class and after the `getRows` method, add the
    following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '*board.js*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note that as well as adding the bubble into the correct row-column position
    in `rows[][]` ➊, we’re also passing the calculated row ➋ and column ➌ numbers
    to the `bubble` object so it knows its location relative to the other bubbles.
    We don’t have those method calls yet, so let’s create them now in *bubble.js*
    in the `Bubble` class definition:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '*bubble.js*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, amend *game.js* to call this new method in `clickGameScreen`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '*game.js*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Reload the game and shoot a few bubbles. They should start to pile up, although
    some may still overlap because they don’t quite settle properly into the grid.
    It’s progress, but we want the bubbles to line up nicely when they collide—that’s
    what we’ll do next.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Locking the bubble Object into the Grid
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the fired bubbles collide with the rest of the board, we want to lock them
    in place rather than just having them stop wherever they hit. The current movement
    works well, but we need to add another step that locks the bubble into position
    when it reaches its destination.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: After `board.addBubble` has been run, the `bubble` object knows which row and
    column it’s located in; therefore, calling its `getCoords` method (which calculates
    based on row and column) will retrieve the coordinates where it should be rather
    than the coordinates where it actually stopped. To nudge it into place, we’ll
    add a `complete` function that can be set as part of a jQuery `animate` call and
    use the information the bubble already has. As a result, we can fire the bubble
    and forget about it rather than creating a process to tidy up bubbles as they
    land. jQuery’s `complete` callback function is a useful place to put code that
    needs to run when an animation has finished. For example, in a game with an explosion
    effect, the frames of the animation could run, and when the animation finishes,
    the DOM elements that formed the explosion could be removed from the screen.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'The `complete` property is called when the animation has ended. In *ui.js*
    amend `fireBubble` as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '*ui.js*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When you reload, the bubbles you fire should settle into the grid system. Note
    that we use `getRow` to check whether a collision has occurred ➊, because `getRow`
    should return `null` for a bubble that misses all other bubbles and moves off
    the screen.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that fired bubbles collide with the others on the board, *Bubble Shooter*
    is starting to act more like a game. We’ve moved sprites across the screen using
    jQuery, made the game react to the player’s input, and set up some of the basic
    game logic. However, currently there’s no way to pop bubbles, and it won’t be
    much of a game without that functionality. Popping logic and displaying an animation
    are the subjects of the next chapter.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Further Practice
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each row of the game board is offset to form a staggered pattern. Change the
    code in `createLayout` so the bubbles form a regular grid. How will this change
    the game?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you can make `createLayout` build a different grid pattern, write code
    to generate an entirely new layout. For example, you could draw only every alternate
    column or build a more creative layout.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Bubble Shooter* has a simple object structure that consists of a `Game`, a
    `Board`, and a set of `Bubbles`. What sort of objects would you need if you were
    building a game like *Angry Birds*, *Bejeweled*, or *Candy Crush*?'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
