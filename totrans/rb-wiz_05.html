<html><head></head><body>
  <div class="chapter" title="Chapter&#xA0;6.&#xA0;The (Chunky) Bacon to Ruby&#x2019;s Hash">&#13;
    <div class="titlepage">&#13;
      <h1 class="title" id="heading_id_2"><a id="left_parenthesischunkyright_parenthesis"/>Chapter 6. The (Chunky) Bacon to Ruby’s Hash</h1>&#13;
    </div>&#13;
&#13;
    <div class="sect1" title="Symbols!">&#13;
      <div class="titlepage">&#13;
        <h1 class="title" id="heading_id_3"><a id="symbolsexclamation_mark"/>Symbols!</h1>&#13;
      </div>&#13;
&#13;
      <p><a class="indexterm" id="iddle1861"/>“That hash was amazing!” Scarlet said. Ruben nodded vigorously as he shoveled another helping of eggs and hash into his mouth.</p>&#13;
&#13;
      <p>“I’m glad you liked it!” said Big Hank. “But that mid-morning rush’ll be here any minute, and we need to get cracking if we’re going to be ready for it.”</p>&#13;
&#13;
      <div class="informalfigure">&#13;
        <a id="med_id00028a"/>&#13;
&#13;
        <div class="mediaobject"><a id="med_id00028"/><img alt="image with no caption" src="../Images/httpatomoreillycomsourcenostarchimages2160011.png.jpg"/></div>&#13;
      </div>&#13;
&#13;
      <p>Scarlet jumped down from her stool. “We have eggs to fry up, potatoes to grate, sausages to cook, breakfast gravy to make, and biscuits to bake. Anything else?”</p>&#13;
&#13;
      <p><a class="indexterm" id="iddle1371"/>Hank twirled his mustache. “I’m not sure,” he said. “Let’s have a look at that menu you kids and Squeaky Jim cooked up.”</p>&#13;
&#13;
      <p>“Sure!” Scarlet said, and she called up the Hashery menu on the kitchen’s Computing Contraption:</p><a id="pro_id00132"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">hashery_menu</span></strong></span>&#13;
=&gt; { :eggs =&gt; 2, :hash =&gt; 3,&#13;
     :jam =&gt; 1,&#13;
     :sausage =&gt; 2,&#13;
     :biscuit =&gt; 1..3 }&#13;
</pre>&#13;
&#13;
      <p>“This looks good—each order of food is associated with its price in a hash,” said Big Hank, “but we should put our breakfast beverages on there, too. Can you add a key with an array as a value to my menu hash?”</p>&#13;
&#13;
      <p>“Of course,” Scarlet said. “What drinks should we put in it?”</p>&#13;
&#13;
      <p>“We’ve got coffee, orange juice, and tea,” said Hank.</p>&#13;
&#13;
      <p>“Okay!” Scarlet said. She typed:</p><a id="pro_id00133"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">hashery_menu['drinks'] = ['coffee', 'orange juice', 'tea']</span></strong></span>&#13;
=&gt; ["coffee", "orange juice", "tea"]&#13;
</pre>&#13;
&#13;
      <p>“Aha! So that’s how you add a key to a hash,” Hank said.</p>&#13;
&#13;
      <p>“Yup!” Scarlet replied. “You just type the hash name, then the key name between square brackets—here, we’re using <code class="literal">'drinks'</code>—and set the whole thing equal to whatever value you like. See how we updated the <code class="literal">hashery_menu</code>?”</p><a id="pro_id00134"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">hashery_menu</span></strong></span>&#13;
=&gt; {:eggs=&gt;2, :hash=&gt;3, :jam=&gt;1, :sausage=&gt;2, :biscuit=&gt;1..3,&#13;
"drinks"=&gt;["coffee", "orange juice", "tea"]}&#13;
</pre>&#13;
&#13;
      <p>“Cool!” said Ruben, who had finally finished eating his eggs and hash. “Now we have a list of drinks on the menu.” He leaned in close to the glowing screen of the Computing Contraption. “But it looks like the <code class="literal">drinks</code> hash key is a string, and the rest are symbols. Does that make a difference?”</p>&#13;
&#13;
      <p>“Oh boy, <span class="emphasis"><em>does</em></span> it!” said Squeaky Jim, who had been opening bags of potatoes and cleaning the Hashery’s enormous Grate-O-Matic. He pushed his paper hat farther back on his head and leaned against the machine. “You see—” he began, but as he started to speak, his elbow pushed down the machine’s huge switch, turning it on. It roared to life, scaring the sweet peas out of Squeaky Jim and nearly causing him to fall over multiple times as he scrambled to turn it back off.</p>&#13;
&#13;
      <div class="informalfigure">&#13;
        <a id="med_id00029a"/>&#13;
&#13;
        <div class="mediaobject"><a id="med_id00029"/><img alt="image with no caption" src="../Images/httpatomoreillycomsourcenostarchimages2160013.png.jpg"/></div>&#13;
      </div>&#13;
&#13;
      <p>“You see,” Jim squeaked after he finally shut down the Grate-O-Matic, “even though I’m not very good at Ruby, I <span class="emphasis"><em>have</em></span> tried to program the kitchen’s Computing Contraption every now and again. One morning, the Hashery was unbelievably busy—one of the biggest mid-morning rushes I’d ever seen!”</p>&#13;
&#13;
      <p>“I remember that one,” Big Hank said, pulling an armful of sausage links out of a shiny red refrigerator. “Not only did we have a ton of customers, but we were doing a Build Your Own Menu day.”</p>&#13;
&#13;
      <p>“Build Your Own Menu day?” Ruben asked, scratching his head.</p>&#13;
&#13;
      <p>Big Hank nodded and began yanking sausages off the long chain of links and tossing them into an enormous skillet. “Yup. We let customers create their own personal menus, so they could <a class="indexterm" id="iddle1015"/><a class="indexterm" id="iddle1067"/><a class="indexterm" id="iddle1196"/><a class="indexterm" id="iddle1515"/><a class="indexterm" id="iddle1579"/><a class="indexterm" id="iddle1842"/><a class="indexterm" id="iddle1863"/><a class="indexterm" id="iddle1866"/><a class="indexterm" id="iddle1900"/>order anything they wanted. We were okay at first—people were building their menus, ordering food, and getting served. But as the morning wore on, the program got slower and slower. By the peak of the rush, we could barely get any orders through! We had to shut down the kitchen’s Computing Contraption and do all the orders by hand. It was chaos.”</p>&#13;
&#13;
      <p>Squeaky Jim nodded. “And I think I know why!”</p>&#13;
&#13;
      <p>Hank stopped pulling apart sausage links. “You do?”</p>&#13;
&#13;
      <p>“Yup!” Jim said. “I was reading up on Ruby the other day to try to get a bit better at running the kitchen, and I found out that Ruby symbols use up less memory than strings. We were using strings for all the keys in our hashes during Build Your Own Menu day, and as the program went on and on, it used more and more memory until it didn’t have enough to do its job.”</p>&#13;
&#13;
      <p>“Back up a bit,” said the King, who was chewing thoughtfully on a raw potato. “What exactly <span class="emphasis"><em>are</em></span> these Ruby symbols? And what do you mean when you say they use less memory than strings?”</p>&#13;
    </div>&#13;
&#13;
    <div class="sect1" title="The Skinny on Symbols">&#13;
      <div class="titlepage">&#13;
        <h1 class="title" id="heading_id_4"><a id="skinny_on_symbols"/>The Skinny on Symbols</h1>&#13;
      </div>&#13;
&#13;
      <p>While Squeaky Jim tries to explain Ruby symbols to the group, I’ll give you the rundown. Basically, a Ruby symbol is just a <span class="emphasis"><em>name</em></span>. For instance, if I’m talking about the King and Scarlet is talking about the King, we’re both talking about the very same thing—the King! When we talk about symbols (that is, names) in Ruby, we write them with a colon in front, like <code class="literal">:the_king</code>. You’ll often see the <span class="emphasis"><em>underscore</em></span> (<code class="literal">_</code>) in symbol names because, just like variable names, they aren’t allowed to have spaces in them.</p>&#13;
&#13;
      <p>So how is a symbol different from a string, like <code class="literal">'The_King'</code>? Well, think back to the King’s string from <a class="xref" href="../Text/ch02.html" title="Chapter 2. The King and His String">Chapter 2</a>. Now imagine that the King has <span class="emphasis"><em>two</em></span> strings with <span class="emphasis"><em>exactly</em></span> the same beads and trinkets on them. While they might have the same <span class="emphasis"><em>contents</em></span>, they aren’t the <span class="emphasis"><em>exact same thing</em></span>. But when we both talk about the King, we’re not talking about two kings who look exactly like each other: we’re talking about <span class="emphasis"><em>one and the same</em></span> king!</p>&#13;
&#13;
      <p><a class="indexterm" id="iddle1390"/><a class="indexterm" id="iddle1619"/><a class="indexterm" id="iddle1941"/>If you’re still a bit confused, never fear: I’ve got a couple of code examples that should help clear things right up. Fire up IRB and try this on for size:</p><a id="pro_id00135"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">string_one = 'The King'</span></strong></span>&#13;
=&gt; "The King"&#13;
&gt;&gt; <span class="strong"><strong><span class="red">string_two = 'The King'</span></strong></span>&#13;
=&gt; "The King"&#13;
&gt;&gt; <span class="strong"><strong><span class="red">string_one.object_id</span></strong></span>&#13;
=&gt; 2184370320&#13;
&gt;&gt; <span class="strong"><strong><span class="red">string_two.object_id</span></strong></span>&#13;
=&gt; 2184365180&#13;
</pre>&#13;
&#13;
      <p>Here we’re setting two <span class="emphasis"><em>different</em></span> variables to the <span class="emphasis"><em>same</em></span> string value of <code class="literal">'The King'</code>. Then, when you use the <code class="literal">object_id</code> method on these two variables, you’re asking Ruby to provide the unique number it uses to keep track of every object in a running Ruby program. It’s a kind of ID number that Ruby uses to tell objects apart, and no two objects have exactly the same one. On the flip side, if two variables have the same object ID number, they <span class="emphasis"><em>must</em></span> be talking about the very same object.</p>&#13;
&#13;
      <p>The object ID numbers you see in IRB won’t be <span class="emphasis"><em>quite</em></span> the same as mine, but that’s okay! Object IDs get reassigned every time you start a new Ruby program. The important thing is that <code class="literal">string_one</code> and <code class="literal">string_two</code>, even though they’re both equal to <code class="literal">'The King'</code>, are <span class="emphasis"><em>different objects</em></span>. Their contents are exactly the same, but just as with our example of the King’s string, we’re talking about two completely different strings that just happen to have the same thing inside.</p>&#13;
&#13;
      <p>Now check <span class="emphasis"><em>this</em></span> out:</p><a id="pro_id00136"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">symbol_one = :the_king</span></strong></span>&#13;
=&gt; :the_king&#13;
&gt;&gt; <span class="strong"><strong><span class="red">symbol_two = :the_king</span></strong></span>&#13;
=&gt; :the_king&#13;
&gt;&gt; <span class="strong"><strong><span class="red">symbol_one.object_id</span></strong></span>&#13;
=&gt; 466088&#13;
&gt;&gt; <span class="strong"><strong><span class="red">symbol_two.object_id</span></strong></span>&#13;
=&gt; 466088&#13;
</pre>&#13;
&#13;
      <p><a class="indexterm" id="iddle1036"/><a class="indexterm" id="iddle1297"/><a class="indexterm" id="iddle1382"/><a class="indexterm" id="iddle1869"/>Here we’re setting two different variables, <code class="literal">symbol_one</code> and <code class="literal">symbol_two</code>, to the symbol <code class="literal">:the_king</code>. Again, your object IDs won’t be exactly the numbers just shown, but when you compare your object IDs for <code class="literal">symbol_one</code> and <code class="literal">symbol_two</code>, you’ll see that they’re the exact same number! Just like how when we’re talking about the King, we’re talking about the very same person, both <code class="literal">symbol_one</code> and <code class="literal">symbol_two</code> are talking about the exact same object, <code class="literal">:the_king</code>.</p>&#13;
&#13;
      <p>Because symbols are simply names you can toss around, you don’t assign values to them. While you can definitely say:</p><a id="pro_id00137"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">variable_name = :my_fancy_symbol</span></strong></span>&#13;
=&gt; :my_fancy_symbol&#13;
</pre>&#13;
&#13;
      <p>you <span class="emphasis"><em>can’t</em></span> say:</p><a id="pro_id00138"/>&#13;
      <pre class="programlisting">&#13;
<span class="ash">:my_fancy_symbol = some_value</span>&#13;
</pre>&#13;
&#13;
      <p>If you try this, you’ll get a <code class="literal">SyntaxError</code>. Just as you can’t assign a different value to a string or a number by putting it on the left-hand side of the equal sign, you can’t assign a different value to a symbol, either.</p>&#13;
&#13;
      <p>The only time you’ll have symbols on the left-hand side is when you use them in hashes, like this:</p><a id="pro_id00139"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">fancy_words = { bloviate: 'To talk at length' }</span></strong></span>&#13;
=&gt; {:bloviate=&gt;"To talk at length"}&#13;
</pre>&#13;
&#13;
      <p>Remember, we don’t need to start our <code class="literal">bloviate</code> key with a colon if we use the newer hash syntax. If we want to use the older hash rockets (<code class="literal">=&gt;</code>), we start the symbol with a colon:</p><a id="pro_id00140"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">fancy_words = { :bloviate =&gt; 'To talk at length' }</span></strong></span>&#13;
=&gt; {:bloviate=&gt;"To talk at length"}&#13;
</pre>&#13;
&#13;
      <p>But yes! I <span class="emphasis"><em>do</em></span> go on. What you’re probably wondering is: what are symbols good for? How is it that they use less memory than strings?</p>&#13;
&#13;
      <p>Because a symbol always has only one object ID, it gets created only one time in any given Ruby program. That means you could have a thousand million billion variables that are all set to <a class="indexterm" id="iddle1384"/><a class="indexterm" id="iddle1865"/>a certain symbol, and only <span class="emphasis"><em>one</em></span> symbol object gets created. If you were to do that with strings, they’d all have different object IDs, so you’d get <span class="emphasis"><em>a thousand million billion different strings</em></span>. Just like you, Ruby has only a certain amount of memory and can keep track of only so many things at once. If you create a huge number of strings, Ruby will start to run out of memory as it tries to juggle them all, and it will slow way down. Your program might even crash! If you use symbols, Ruby will create fewer objects and use less memory, so programs that use symbols for things like hash keys can run faster than equivalent programs that use strings. This brings us to the thousand-million-billion-dollar question: when should you take advantage of the savings symbols offer?</p>&#13;
&#13;
      <p>Basically, any time you need to use a name over and over but don’t want to create a brand-new string each time, symbols are the way to go. They’re very good for hash keys, and they’re also useful for referring to method names. We’ll talk about using symbols for method names very soon!</p>&#13;
&#13;
      <div class="informalfigure">&#13;
        <a id="med_id00030a"/>&#13;
&#13;
        <div class="mediaobject"><a id="med_id00030"/><img alt="image with no caption" src="../Images/httpatomoreillycomsourcenostarchimages2160015.png.jpg"/></div>&#13;
      </div>&#13;
&#13;
      <p>Speaking of soon, I’m pretty sure Squeaky Jim is about to wrap up his explanation of Ruby symbols. Let’s see if Ruben, Scarlet, the King, and Big Hank have as good an understanding of them as you do!</p>&#13;
    </div>&#13;
&#13;
    <div class="sect1" title="Symbols and Hashes, Together at Last">&#13;
      <div class="titlepage">&#13;
        <h1 class="title" id="heading_id_5"><a id="symbols_and_hashescomma_together_at_last"/>Symbols and Hashes, Together at Last</h1>&#13;
      </div>&#13;
&#13;
      <p>“I think I get it,” Ruben said. “Symbols are just names that Ruby uses to refer to one particular object, so if we use symbols as keys in hashes, we’re really just referring to the same object over and over.”</p>&#13;
&#13;
      <p><a class="indexterm" id="iddle1841"/><a class="indexterm" id="iddle1864"/><a class="indexterm" id="iddle1887"/>“That’s exactly right!” said Squeaky Jim. “Now you see why we had such a terrible time using strings instead of symbols in our Build Your Own Menu hashes.”</p>&#13;
&#13;
      <p>“Of course!” Scarlet said. “Each time a customer made a new menu, it made a whole bunch of new strings.”</p>&#13;
&#13;
      <p>“We had hundreds of customers,” Big Hank sighed. “No wonder our Ruby program ran out of memory!”</p>&#13;
&#13;
      <p>“Well, I certainly don’t want to start adding strings into the menu <span class="emphasis"><em>now</em></span>,” Scarlet said. “How can we change the string key to a symbol?” She typed <code class="literal">hashery_menu</code> into the Computing Contraption to call up the Hashery menu’s contents:</p><a id="pro_id00141"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">hashery_menu</span></strong></span>&#13;
=&gt; { :eggs =&gt; 2, :hash =&gt; 3,&#13;
     :jam =&gt; 1,&#13;
     :sausage =&gt; 2,&#13;
     :biscuit =&gt; 1..3,&#13;
     "drinks" =&gt; ["coffee", "orange juice", "tea"] }&#13;
</pre>&#13;
&#13;
      <p>“Hmm,” said the King. “Can we just change the string key to a symbol key?”</p>&#13;
&#13;
      <p>“I don’t think so,” said Squeaky Jim. “From what I’ve read, I think the best thing we can do is to delete the string key, then replace it with a symbol key.”</p>&#13;
&#13;
      <p>“You may be right,” Ruben said, “but programming is all about experimenting. I’ve heard that Ruby has a <code class="literal">to_sym</code> method that will turn a string into a symbol. Should we give it a try?”</p>&#13;
&#13;
      <p>“Sure thing,” Scarlet said, and she typed:</p><a id="pro_id00142"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">hashery_menu.keys.last.to_sym</span></strong></span>&#13;
=&gt; :drinks&#13;
</pre>&#13;
&#13;
      <p>“It looks like it worked!” Ruben said. “Can you bring up the hash again to be sure?”</p>&#13;
&#13;
      <p>Scarlet nodded and brought up the Hashery menu again.</p><a id="pro_id00143"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">hashery_menu</span></strong></span>&#13;
=&gt; { :eggs =&gt; 2, :hash =&gt; 3,&#13;
     :jam =&gt; 1,&#13;
     :sausage =&gt; 2,&#13;
     :biscuit =&gt; 1..3,&#13;
     "drinks" =&gt; ["coffee", "orange juice", "tea"] }&#13;
</pre>&#13;
&#13;
      <p><a class="indexterm" id="iddle1234"/>“Darn!” Ruben said. “Ruby returned a symbolized version of the string <code class="literal">'drinks'</code>, but it didn’t actually change the key in the hash.”</p>&#13;
&#13;
      <p>“That’s probably just as well,” said Big Hank. “I’ve been thinking about our breakfast beverages, and I realized we don’t have their prices in the array at all!”</p>&#13;
&#13;
      <p>Scarlet slapped her forehead. “That’s right!” she said. “We need to have the drinks <span class="emphasis"><em>and</em></span> the prices in there.” She thought for a minute. “Wait—if we’re associating drinks and their prices, that’s just like associating each food item with its price. Can we put a hash inside another hash?”</p>&#13;
&#13;
      <p>“Nothing to do but experiment!” said the King. “Why don’t you go ahead and delete the <code class="literal">"drinks"</code> key like Jim suggested, and then try adding a symbol key with a hash as the value?”</p>&#13;
&#13;
      <p>“Okay!” said Scarlet. “Jim, do you know how to delete a key from a hash?”</p>&#13;
&#13;
      <p>“I think so,” Jim said, and he reached over and began typing into the Computing Contraption:</p><a id="pro_id00144"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">hashery_menu.delete('drinks')</span></strong></span>&#13;
=&gt; ["coffee", "orange juice", "tea"]&#13;
</pre>&#13;
&#13;
      <p>“Whoa, what was that?” said Ruben. “When you deleted the key, it gave you the value back!”</p>&#13;
&#13;
      <p>Jim nodded. “That’s what the <code class="literal">delete</code> method does!” he said. “That way, if we had wanted to use the value of the deleted key for something, we could have saved it into a variable, like this:</p><a id="pro_id00145"/>&#13;
      <pre class="programlisting">&#13;
<span class="ash">menu_drinks = hashery_menu.delete('drinks')</span>&#13;
</pre>&#13;
&#13;
      <p>“But,” Jim said, “we <span class="emphasis"><em>can’t</em></span> do that now, because the <code class="literal">'drinks'</code> key is gone. See?” He typed again:</p><a id="pro_id00146"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">hashery_menu</span></strong></span>&#13;
=&gt; { :eggs =&gt; 2, :hash =&gt; 3,&#13;
     :jam =&gt; 1,&#13;
     :sausage =&gt; 2,&#13;
     :biscuit =&gt; 1..3 }&#13;
</pre>&#13;
&#13;
      <p>“Nice work!” Scarlet said. “Now all we have to do is test whether we can put a hash inside a hash. Big Hank, what are the prices I should use for the drinks?”</p>&#13;
&#13;
      <p>“It’s a dollar for coffee, two for orange juice, and one for tea,” Hank said. Scarlet typed into the Computing Contraption:</p><a id="pro_id00147"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">hashery_menu[:drinks] = { :coffee =&gt; 1, :orange_juice =&gt; 2,</span></strong></span>&#13;
<span class="strong"><strong><span class="red">:tea =&gt; 1 }</span></strong></span>&#13;
=&gt; { :coffee =&gt; 1, :orange_juice =&gt; 2, :tea =&gt; 1 }&#13;
</pre>&#13;
&#13;
      <p>“It worked!” shouted the King. “Great work, everyone!”</p>&#13;
&#13;
      <p>“And just in the nick of time!” boomed Big Hank. The group had been so busy crowding around the Computing Contraption and working on getting the Hashery menu just right, they hadn’t noticed a steadily growing din. Voices filled the air as customers crowded into the Hashery, and even Big Hank had to shout to be heard above them all: “Spin up the Grate-O-Matic! Attend to the skillets! Bake biscuits like your lives depend on it! The mid-morning rush is upon us, and they’re hungry!”</p>&#13;
&#13;
      <p>“Aye aye, Hank!” said Squeaky Jim, who not only <span class="emphasis"><em>didn’t</em></span> squeak but spun up the Grate-O-Matic and began churning out hash like he’d done it all his life. “Let’s get that new menu out to all the customers!”</p>&#13;
&#13;
      <p>“The menu! I almost forgot,” Hank said. “We do have one more addition to today’s specials.” And he typed:</p><a id="pro_id00148"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">hashery_menu[:chunky_bacon] = 1</span></strong></span>&#13;
=&gt; 1&#13;
</pre>&#13;
&#13;
      <p>“Chunky bacon?” Scarlet and Ruben asked together.</p>&#13;
&#13;
      <div class="informalfigure">&#13;
        <a id="quotation_markbaconquotation_mark"/>&#13;
&#13;
        <div class="mediaobject"><a id="med_id00031"/><img alt="image with no caption" src="../Images/httpatomoreillycomsourcenostarchimages2160017.png.jpg"/></div>&#13;
      </div>&#13;
&#13;
      <p>Hank smiled and shrugged. “Friend of mine used to come in all the time and order it,” he said. “Haven’t seen him in a while, so I haven’t had it on the menu. But who knows?” He looked out at the growing crowd of hungry Hashery customers. “Maybe today’s the day he’ll come back.”</p>&#13;
    </div>&#13;
&#13;
    <div class="sect1" title="The Mid-morning Rush">&#13;
      <div class="titlepage">&#13;
        <h1 class="title" id="heading_id_6"><a id="mid-morning_rush"/>The Mid-morning Rush</h1>&#13;
      </div>&#13;
&#13;
      <p>Now that you know all about symbols, you can handle a mid-morning rush of any size and not worry about slowing down your Ruby program or running low on memory. In fact, you’re such a wizard with Ruby symbols that Big Hank and Squeaky Jim have given you a mission that they’ve so far found impossible: transforming their old Build Your Own Menus so that they use symbols for keys instead of strings!</p>&#13;
&#13;
      <p>This may sound like an odd idea at first, but it’s just to help make sure you’re comfortable using Ruby hashes; you don’t have to change all your keys to symbols every time you use them. Hashes are great for storing information like our Hashery menu, and you’ll use them time and again whenever you write Ruby—not just for the code in this book.</p>&#13;
&#13;
      <p>Earlier, we saw that we couldn’t just call <code class="literal">to_sym</code> on a hash key and expect it to magically change; instead, we had to delete the key and replace it.</p>&#13;
&#13;
      <p><a class="indexterm" id="iddle1372"/><a class="indexterm" id="iddle1846"/>That works okay for a single string key, but Hank and Jim are talking about a thousand million billion strings in hundreds of customer menus—you could never convert them one at a time, even if you wanted to! But what if we could <span class="emphasis"><em>automatically</em></span> run through a hash and do exactly that: grab each string key, delete it, save the key’s value, and assign that value to a new symbol key?</p>&#13;
&#13;
      <p>Let’s make a new file called <span class="bolditalic red">strings_to_symbols.rb</span>. (As always, peek back at <a class="xref" href="../Text/ch01.html" title="Chapter 1. What This Book’s About">Chapter 1</a> if you don’t remember how to do this, or ask the nearest adult to help you.) Then open your file with your text editor, and type the following:</p><a id="pro_id00149"/>&#13;
      <pre class="programlisting">&#13;
my_own_menu = { 'tater_tots' =&gt; 2,&#13;
  'fancy_toast' =&gt; 3,&#13;
  'omelette' =&gt; 3,&#13;
  'tiny_burger' =&gt; 4,&#13;
  'chunky_bacon' =&gt; 1,&#13;
  'root_beer_float' =&gt; 2,&#13;
  'egg_nog' =&gt; 2&#13;
}&#13;
</pre>&#13;
&#13;
      <p>Here, we’re creating a brand-new hash called <code class="literal">my_own_menu</code> and assigning some values (the prices, which are numbers) to some keys (the menu items, which are strings). Keep on adding to the program; we’re not done yet!</p><a id="pro_id00150"/>&#13;
      <pre class="programlisting">&#13;
puts "Object ID before: #{my_own_menu.object_id}"&#13;
</pre>&#13;
&#13;
      <p>Next, we’ll print out the object ID of our menu hash. This is so we can later confirm that although we’ve made some changes to our hash, it’s still the same object; after we make changes to our keys and values, if the ID is the same as it was before, we’re talking about the very same hash, just with some different information in it.</p>&#13;
&#13;
      <p>Let’s keep adding to <span class="emphasis"><em>strings_to_symbols.rb</em></span>. We’ve got strings for hash keys now, but what we really want are symbols! We’ll need to add a bit more code to change our string keys to symbol keys.</p><a id="pro_id00151"/>&#13;
      <pre class="programlisting">&#13;
my_own_menu.keys.each do |key|&#13;
  my_own_menu[key.to_sym] = my_own_menu.delete(key)&#13;
end&#13;
&#13;
puts "Object ID after: #{my_own_menu.object_id}"&#13;
&#13;
puts my_own_menu&#13;
</pre>&#13;
&#13;
      <p><a class="indexterm" id="iddle1235"/><a class="indexterm" id="iddle1616"/><a class="indexterm" id="iddle1888"/>Okay, that does it. We call the <code class="literal">keys</code> method on the <code class="literal">my_own_menu</code> hash to get our keys, then immediately call <code class="literal">each</code> on those keys to iterate over them. (Remember that from <a class="xref" href="../Text/ch05.html" title="Chapter 5. Array of Sunshine and Hash on the Range">Chapter 5</a>? Feel free to look back if you need a reminder.)</p>&#13;
&#13;
      <p>Here’s the really cool part: for each key in the hash, we call <code class="literal">delete</code> on the key (which removes it from the hash), but since <code class="literal">delete</code> returns the value associated with the key that was deleted, we immediately set this equal to calling <code class="literal">to_sym</code> on the key. This is an amazing double whammy: it deletes the original key from the hash while immediately adding the value to a <span class="emphasis"><em>new</em></span> key, and that new key is just the original one turned into a symbol. The result? You change all the keys in your hash from strings to symbols!</p>&#13;
&#13;
      <p>We can even prove it’s the very same hash, not a copy: we <code class="literal">puts</code> the hash’s object ID before and after iterating over it, and you’ll see in the output that the object ID is the very same both times. That’s right—<span class="emphasis"><em>every</em></span> object in Ruby has an object ID, including the hash itself !</p>&#13;
&#13;
      <p>Your complete code should look like this:</p>&#13;
&#13;
      <p><span class="bolditalic red">strings_to_symbols.rb</span></p><a id="pro_id00152"/>&#13;
      <pre class="programlisting">&#13;
my_own_menu = { 'tater_tots' =&gt; 2,&#13;
  'fancy_toast' =&gt; 3,&#13;
  'omelette' =&gt; 3,&#13;
  'tiny_burger' =&gt; 4,&#13;
  'chunky_bacon' =&gt; 1,&#13;
  'root_beer_float' =&gt; 2,&#13;
  'egg_nog' =&gt; 2&#13;
}&#13;
puts "Object ID before: #{my_own_menu.object_id}"&#13;
&#13;
my_own_menu.keys.each do |key|&#13;
  my_own_menu[key.to_sym] = my_own_menu.delete(key)&#13;
end&#13;
&#13;
puts "Object ID after: #{my_own_menu.object_id}"&#13;
&#13;
puts my_own_menu&#13;
</pre>&#13;
&#13;
      <p><a class="indexterm" id="iddle1375"/><a class="indexterm" id="iddle1862"/>Go ahead and run your code—type <span class="strong"><strong><span class="red"><code class="literal">ruby strings_to_symbols.rb</code></span></strong></span> and press <span class="smaller">ENTER</span>. The output should look like this:</p><a id="pro_id00153"/>&#13;
      <pre class="programlisting">&#13;
Object ID before: 2174149520&#13;
Object ID after: 2174149520&#13;
{:tater_tots=&gt;2, :fancy_toast=&gt;3, :omelette=&gt;3, :tiny_burger=&gt;4,&#13;
:chunky_bacon=&gt;1, :root_beer_float=&gt;2, :egg_nog=&gt;2}&#13;
</pre>&#13;
&#13;
      <p>You should see the very same object ID printed twice, then a beautiful printout of your hash, complete with symbols for keys instead of strings.</p>&#13;
    </div>&#13;
&#13;
    <div class="sect1" title="What Else Can You Do with Symbols?">&#13;
      <div class="titlepage">&#13;
        <h1 class="title" id="heading_id_7"><a id="what_else_can_you_do_with_symbolsquestio"/>What Else Can You Do with Symbols?</h1>&#13;
      </div>&#13;
&#13;
      <p>Now that you can solve all of Big Hank and Squeaky Jim’s menu woes with ease, you might be wondering what else you can do. As Ruben said, experimenting is a huge part of programming, and there’s a lot of experimentation you can do with hashes and symbols. For example, what happens if you call <code class="literal">to_sym</code> on a string that contains a space? (You’ll still get a symbol, but it will look weird—try it!)</p>&#13;
&#13;
      <p>We can also explore hashes within hashes. Remember, we can access a value in a hash like this:</p><a id="pro_id00154"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">hash_name[:key]</span></strong></span>&#13;
=&gt; value&#13;
</pre>&#13;
&#13;
      <p><a class="indexterm" id="iddle1370"/><a class="indexterm" id="iddle1885"/><a class="indexterm" id="iddle1890"/><a class="indexterm" id="iddle1938"/>So how might you go about accessing the value of a hash <span class="emphasis"><em>inside</em></span> a hash? Here’s a hint—for our original menu:</p><a id="pro_id00155"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">hashery_menu</span></strong></span>&#13;
=&gt; { :eggs =&gt; 2, :hash =&gt; 3,&#13;
     :jam =&gt; 1,&#13;
     :sausage =&gt; 2,&#13;
     :biscuit =&gt; (1..3),&#13;
     :drinks =&gt; { :coffee =&gt; 1, :orange_juice =&gt; 2, :tea =&gt; 1 } }&#13;
</pre>&#13;
&#13;
      <p>what do you think <code class="literal">hashery_menu[:drinks][:orange_juice]</code> will give us back?</p>&#13;
&#13;
      <p>Finally, strings have a <code class="literal">to_sym</code> method that turns them into symbols, but symbols <span class="emphasis"><em>also</em></span> have a <code class="literal">to_s</code> method (short for “to string”) that turns them into strings. How might you update this program to change symbol keys to strings?</p>&#13;
    </div>&#13;
&#13;
    <div class="sect1" title="You Know This!">&#13;
      <div class="titlepage">&#13;
        <h1 class="title" id="heading_id_8"><a id="you_know_thisexclamation_mark-id00005"/>You Know This!</h1>&#13;
      </div>&#13;
&#13;
      <p>We only really talked about hashes and symbols in this chapter, but since they’re not as easy to understand as numbers or strings (or even arrays), they’re worth going over one more time. (Heck, I’ve been writing Ruby for years, and I <span class="emphasis"><em>still</em></span> think symbols are weird!)</p>&#13;
&#13;
      <p>First, we looked at how to add a key and a value to a hash, which is as easy as setting a key in square brackets (<code class="literal">[]</code>) equal to a value:</p><a id="pro_id00156"/>&#13;
      <pre class="programlisting">&#13;
my_hash[:key] = value&#13;
</pre>&#13;
&#13;
      <p>Next, we introduced symbols, which are basically just names; you don’t assign values to them, but you can store them in variables if you want to.</p>&#13;
&#13;
      <p>For example, this is okay:</p><a id="pro_id00157"/>&#13;
      <pre class="programlisting">&#13;
my_variable = :my_symbol&#13;
</pre>&#13;
&#13;
      <p>But <span class="emphasis"><em>this</em></span> will cause an error:</p><a id="pro_id00158"/>&#13;
      <pre class="programlisting">&#13;
:my_symbol = some_value&#13;
</pre>&#13;
&#13;
      <p>The only time symbols can appear on the left-hand side is when we’re using them as hash keys, like so:</p><a id="pro_id00159"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">my_hash = { ninjas: 'awesome',</span></strong></span>&#13;
&gt;&gt;   <span class="strong"><strong><span class="red">wizards: 'pretty rad',</span></strong></span>&#13;
&gt;&gt;   <span class="strong"><strong><span class="red">warrior_princesses: 'super tough'</span></strong></span>&#13;
&gt;&gt; <span class="strong"><strong><span class="red">}</span></strong></span>&#13;
=&gt; {:ninjas=&gt;"awesome", :wizards=&gt;"pretty rad", :warrior_&#13;
princesses=&gt;"super tough"}&#13;
</pre>&#13;
&#13;
      <p>When you’re talking about the King or your teacher or Abraham Lincoln, you’re always talking about <span class="emphasis"><em>exactly</em></span> the same person; likewise, symbols always refer to <span class="emphasis"><em>exactly</em></span> the same object. This means they use less memory than strings, because whenever you create a new string—even if it’s <span class="emphasis"><em>all the same</em></span> letters as another string—it’s a separate object with its own object ID:</p><a id="pro_id00160"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">symbol_one = :the_king</span></strong></span>&#13;
=&gt; :the_king&#13;
&gt;&gt; <span class="strong"><strong><span class="red">symbol_two = :the_king</span></strong></span>&#13;
=&gt; :the_king&#13;
&gt;&gt; <span class="strong"><strong><span class="red">symbol_one.object_id</span></strong></span>&#13;
=&gt; 466088&#13;
&gt;&gt; <span class="strong"><strong><span class="red">symbol_two.object_id</span></strong></span>&#13;
=&gt; 466088 # The same!&#13;
&gt;&gt; <span class="strong"><strong><span class="red">string_one = 'The King'</span></strong></span>&#13;
=&gt; "The King"&#13;
&gt;&gt; <span class="strong"><strong><span class="red">string_two = 'The King'</span></strong></span>&#13;
=&gt; "The King"&#13;
&gt;&gt; <span class="strong"><strong><span class="red">string_one.object_id</span></strong></span>&#13;
=&gt; 2184370320&#13;
&gt;&gt; <span class="strong"><strong><span class="red">string_two.object_id</span></strong></span>&#13;
=&gt; 2184365180 # Different!&#13;
</pre>&#13;
&#13;
      <p>In general, symbols are good for when you need to use a name over and over, mostly for hash keys and a couple of other neat tricks (which we’ll talk more about in later chapters). <a class="indexterm" id="iddle1236"/><a class="indexterm" id="iddle1620"/><a class="indexterm" id="iddle1845"/><a class="indexterm" id="iddle1867"/><a class="indexterm" id="iddle1886"/><a class="indexterm" id="iddle1889"/>When you care about the <span class="emphasis"><em>content</em></span> of something, you want a string; when you care about the <span class="emphasis"><em>name</em></span> of a thing, you want a symbol.</p>&#13;
&#13;
      <p>If you’re ever unsure whether two objects are the same or different, you can always use the <code class="literal">object_id</code> method (which works on any Ruby object) to get an object’s ID number. Every object has its very own ID number, which is how Ruby keeps track of which object is which during a program:</p><a id="pro_id00161"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">'The King'.object_id</span></strong></span>&#13;
=&gt; 2187090900&#13;
&gt;&gt; <span class="strong"><strong><span class="red">{ :eggs =&gt; 2, :hash =&gt; 3 }.object_id</span></strong></span>&#13;
=&gt; 2187097060&#13;
&gt;&gt; <span class="strong"><strong><span class="red">['eeny', 'meeny', 'miny', 'moe'].object_id</span></strong></span>&#13;
=&gt; 2187104080&#13;
</pre>&#13;
&#13;
      <p>Remember, your object IDs won’t be exactly the same as the ones shown here, but they should all be different from one another on your computer.</p>&#13;
&#13;
      <p>Converting between symbols and strings is a snap! You can use the <code class="literal">to_sym</code> method to turn a string into a symbol:</p><a id="pro_id00162"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">'drinks'.to_sym</span></strong></span>&#13;
=&gt; :drinks&#13;
</pre>&#13;
&#13;
      <p>And you can use the <code class="literal">to_s</code> method to turn a symbol into a string:</p><a id="pro_id00163"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; :<span class="strong"><strong><span class="red">drinks.to_s</span></strong></span>&#13;
=&gt; "drinks"&#13;
</pre>&#13;
&#13;
      <p>When it comes to deleting keys from hashes, you not only saw that you can do it with the <code class="literal">delete</code> method, but you also learned that <code class="literal">delete</code> both removes the key-value pair from the hash <span class="emphasis"><em>and</em></span> returns the value, so you can save it in a variable if you want:</p><a id="pro_id00164"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">simple_hash = { :one =&gt; 1, :two =&gt; 2 }</span></strong></span>&#13;
=&gt; { :one =&gt; 1, :two =&gt; 2 }&#13;
&gt;&gt; <span class="strong"><strong><span class="red">saved_value_from_hash = simple_hash.delete(:two)</span></strong></span>&#13;
=&gt; 2&#13;
&gt;&gt; <span class="strong"><strong><span class="red">simple_hash</span></strong></span>&#13;
=&gt; { :one =&gt; 1 }&#13;
&gt;&gt; <span class="strong"><strong><span class="red">saved_value_from_hash</span></strong></span>&#13;
=&gt; 2&#13;
</pre>&#13;
&#13;
      <p><a class="indexterm" id="iddle1376"/>Finally, you learned that it’s 100 percent allowed to store a hash inside another hash, like so:</p><a id="pro_id00165"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="strong"><strong><span class="red">fancy_hash = { :number_key =&gt; 42,</span></strong></span>&#13;
&gt;&gt;   <span class="strong"><strong><span class="red">:hash_key =&gt; { :first_value =&gt; 1,</span></strong></span>&#13;
&gt;&gt;     <span class="strong"><strong><span class="red">:second_value =&gt; 2</span></strong></span>&#13;
&gt;&gt;   <span class="strong"><strong><span class="red">}</span></strong></span>&#13;
&gt;&gt; <span class="strong"><strong><span class="red">}</span></strong></span>&#13;
=&gt; {:number_key=&gt;42, :hash_key=&gt;{:first_value=&gt;1, :second_value=&gt;2}}&#13;
</pre>&#13;
&#13;
      <p>You’re well into the thick of Ruby now! The good news is that it’s pretty much all smooth sailing from here. While there <span class="emphasis"><em>are</em></span> a few tricky concepts ahead, once you’ve mastered the basic Ruby objects (like numbers, strings, arrays, and hashes), learned how to use a bunch of their methods, and become a whiz at topics like control flow (using <code class="literal">if</code>/<code class="literal">elsif</code>/<code class="literal">else</code>, loops, and iterators), you’ve covered most of the language. Don’t worry if you don’t feel perfectly comfortable with Ruby yet; while it doesn’t take long to learn the basics, you can take as much time as you want to explore the depths. And that’s where we’re going next: deeper into the heart of Ruby, where strange-sounding (but powerful!) creatures await.</p>&#13;
    </div>&#13;
  </div>&#13;
</body></html>