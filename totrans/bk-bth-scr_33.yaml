- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 30 ODDS AND ENDS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Throughout this book, I’ve endeavored to write short, concise chapters about
    pointed topics, while introducing a few related commands along the way. In this
    chapter, I’ll discuss a few interesting topics that couldn’t find a home in any
    of the other chapters and were too short to constitute chapters of their own,
    but these topics are no less important or helpful than the others.
  prefs: []
  type: TYPE_NORMAL
- en: With these odds and ends, you’ll learn how to sort files and interrogate the
    registry for useful information. You’ll also learn how to retrieve and set the
    attributes of files and directories, and I’ll discuss bit manipulation to round
    out the book’s coverage of Batch arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The sort command does exactly what you would likely expect it to do; it sorts
    input files into output files. To demonstrate, consider a small file containing
    the names of the first eight future captains of the starship *Enterprise*, listed
    in the order in which they’ll serve in the post. The first 15 bytes contain a
    first name, followed by one byte for a middle initial (if they use a middle initial,
    and only one does). The last name starts in byte 17 and may or may not be followed
    by a few trailing spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '(*Star Trek* is famous for its alternate universes and timelines, but this
    is the list for *our* universe with one significant omission. Spock, or Mr. Spock,
    was left off the list for two reasons. First and foremost, he has only one name,
    which is neither a first nor a last name, but sometimes treated as either, hopelessly
    complicating the format of the data file. Second, he was captain for only about
    three minutes of screen time at the beginning of *Star Trek II: The Wrath of Khan*.
    As seriously as I take getting every fact about Batch as accurate as possible,
    I also strive to stay true to the *Star Trek* canon.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command accepts the file as its first argument, and the /O option
    precedes and defines the *output* file that follows it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The command very easily sorts the small input file into an output file of the
    same size. Here’s the complete contents of the *SortedByName.txt* file following
    the execution of the prior command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The captains are sorted by their first names, because the sort command starts
    sorting at the first byte of the record by default. If two captains had shared
    the same first name, they would have been sorted on middle initials and finally
    on last names, but we can alter the initial character of the sort easily with
    the /+ option. The following command starts sorting in byte 17 where the last
    name starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The *SortedByLastName.txt* file is sorted by last name, as its name more than
    suggests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The command has a few other useful options for customizing sorts. The /R option
    *reverses* the order of the sort, so Pike would have come first and April last
    if you had added /R to the last command. The /UNIQ option writes out only *unique*
    lines, which is another way of saying that it drops duplicate records. If some
    records in the input file might exceed the default maximum length of 4,096 bytes,
    use /REC to define a different maximum *record* length up to 65,535 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*I must state my displeasure with any option, parameter, or setting denoted
    by a single letter O; users will invariably enter a zero by mistake. After a blunder
    in my coding youth, I stay away from this and other ambiguous characters (I and
    l), but unfortunately, this is what we have with the sort command.*'
  prefs: []
  type: TYPE_NORMAL
- en: The performance of the sort command is far from great on large files, and you
    can’t define multiple sort fields, but the command offers an easy way to perform
    simple sorts on small-to-medium-sized files.
  prefs: []
  type: TYPE_NORMAL
- en: Commercially available sort utilities are much faster and offer far more functionality
    than the sort command. With a little effort, you can set up a bat file to execute
    one or the other depending on whether a utility is registered on a machine. For
    instance, the bat file can execute a commercial sort utility, such as Syncsort,
    if it exists; if not, it will execute the slower but still functional sort command.
    In this way, you’ll reap the benefits of the faster sort utility on the machines
    where it’s registered, but the primary challenge in this plan is determining whether
    the utility is installed and registered on a particular machine. Conveniently,
    this leads directly to our next topic.
  prefs: []
  type: TYPE_NORMAL
- en: The Windows Registry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Windows Registry is a hierarchical database storing configuration settings
    and options for the operating system and all installed applications. It’s structured
    similarly to Windows itself with what looks like a folder structure, but each
    apparent folder is really a registry key one or more levels beneath a root key
    or hive.
  prefs: []
  type: TYPE_NORMAL
- en: If an application is installed on a particular computer, you can find information
    about that application in the registry. The existence or lack of that information
    on other machines indicates whether the application is installed on that particular
    computer, and we can determine this with a few lines of Batch code.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if Syncsort is installed on a Windows computer, it has a registry
    key in the registry, and eventually we’ll interrogate the registry for that key
    associated with the application with some Batch code. If we find it, Syncsort
    is installed; if we don’t find it, it isn’t installed. But before we can use that
    logic, we need to know the registry key associated with the application. The best
    way to find the key is to look for it in the registry of a computer where you
    know the software (in this example, Syncsort) is installed.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Registry
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The regedit command, which stands for *Registry Editor*, offers a portal into
    the registry that looks a bit like Windows Explorer. At the command prompt, enter
    the following and press ENTER:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The Registry Editor should open.
  prefs: []
  type: TYPE_NORMAL
- en: WARNING
  prefs: []
  type: TYPE_NORMAL
- en: '*On second thought, hold off a minute. When first using this editor, I felt
    as though I had stumbled into a secret room behind a trapdoor in an old mansion,
    but the potential to do some damage exists. There’s no need to be paralyzed with
    fear, but unless you have a deep understanding of the registry, don’t delete or
    modify anything from inside the Registry Editor. Caution is a must, but investigating
    the registry can be illuminating even if much of the data is cryptic.*'
  prefs: []
  type: TYPE_NORMAL
- en: All of the software loaded onto a computer is in the registry under *HKEY_LOCAL_MACHINE\SOFTWARE*,
    so this is the first place to look for an application. If one of the many keys
    under the *SOFTWARE* key isn’t obviously for the product in question, you can
    also right-click the *HKEY _LOCAL_MACHINE* root key or hive, select **FIND**,
    enter the application name or any other search string, and press ENTER. The first
    key to match the string appears, and pressing F3 takes you to the next matching
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of this demonstration, assume that we find the following registry
    key for the application in question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The regedit command is one of the few commands you’ll find in this book that’s
    used almost exclusively at the command prompt and is of little use inside a bat
    file. If you were to use it in a bat file, it would simply open the Registry Editor
    and pause the execution of the bat file until a human closes the Editor. But with
    this command and a little work, we now have the registry key. What we need next
    is some Batch code that can determine whether this key exists in the registry
    of other computers.
  prefs: []
  type: TYPE_NORMAL
- en: Querying the Registry
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this challenge is the reg command, which simply stands for *registry*.
    From a bat file, the reg command can do quite a bit of damage in the registry
    in its own right. If you go to the help for this command, you’ll see that it sports
    several operations that can manipulate the registry, including add, delete, copy,
    and import, that someone with ill intent could easily exploit to build a bat virus.
    It’s important to know that these commands exist but use them only if you truly
    and fully understand the registry and any possible impacts of your actions. I’ll
    be strictly focusing on reading from or querying the registry—that is, performing
    the query operation of the reg command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most basic reg query command accepts a possible registry key as an argument.
    Conveniently, Batch allows us to abbreviate the HKEY_LOCAL_MACHINE root key as
    HKLM. This command is looking for Syncsort in the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This command returns a list of the argument’s registry key values and other
    registry keys immediately subordinate to it. More important for our purposes,
    if this command finds the argument key in the registry, it sets errorlevel to
    0; if it doesn’t find it, the value returned is 1. With this in mind, consider
    this code using the same command with conditional execution to set a boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After this executes, you can reference the boolean elsewhere in the process
    flow to determine whether the particular application is installed and available.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also interrogate the registry for other types of information. For instance,
    the following command uses the /V option to look for one specific registry key
    *value*, ProductName, of the current version of Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Without the /V option, the command will likely write many key values and subordinate
    keys to stdout, but with this option in place, it writes precisely two lines of
    output if it finds the key value. One example might be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The registry key in the argument is the first line of output, and the desired
    information about the ProductName is contained in the second.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following for /F command nicely parses out the Windows version and assigns
    it to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since the for /F command processes two lines of text and we care only about
    the second, the if command isolates just the line containing ProductName as the
    first token. (We also could have ignored the first line with the skip=1 clause
    from [Chapter 19](chapter19.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: Because of the asterisk in the tokens clause, the third token, %%k, contains
    everything, including embedded spaces, after the unused and discarded second token.
    Thus, the value of winVersion becomes Windows 10 Home. If you were to run this
    on a different machine, this code might assign Windows 7 Enterprise to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: Much more can and has been written about the registry. I’ve just touched on
    it here from the perspective of Batch to show how you can safely interrogate it
    for some very useful information. The help for the reg command provides far more
    information for the curious.
  prefs: []
  type: TYPE_NORMAL
- en: File Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as you can use the reg command for evil as well as good, you can do the
    same with another interesting command, the attrib command. Its name is short for
    *attribute*, and it both retrieves and assigns file and directory attributes.
    Ne’er-do-wells can use this command to create and hide malignant files on a computer
    for any number of nefarious purposes, although such actions do violate the Batch
    coders’ oath to use their powers only for good.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving Attributes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If the command’s only argument is a file, it returns the file’s attributes.
    Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This command writes the following result to stdout if the file is, from left
    to right, ready to archive (A, byte 1), a system file (S, byte 4), hidden (H,
    byte 5), and read-only (R, byte 6):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The second and third bytes are always blank.
  prefs: []
  type: TYPE_NORMAL
- en: Each position in the string represents a predefined attribute. For instance,
    the value of H in the fifth byte means that the file is hidden or that you can’t
    see it in Windows Explorer, at least by default. In contrast, a space in that
    position means that the file isn’t hidden.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine whether a particular file is read-only, the following for /F command
    uses the attrib command as its input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The logic in the code block sets the bReadOnly boolean to true or false based
    on the existence or nonexistence of the file attribute associated with the sixth
    byte.
  prefs: []
  type: TYPE_NORMAL
- en: A file mask with wildcards can return results for multiple files. The /S option
    matches the filename or mask on all files in the directory and all of its subdirectories,
    giving the results for each. Also, the /D option handles directory attributes
    in lieu of the attributes of a file.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Attributes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The command’s real power comes in its ability to reset attributes. A negative
    sign in front of the attribute character turns the attribute off, and a plus sign
    turns it on. For instance, the following command ensures that the file isn’t a
    system file (-S) and not a hidden file (-H), while also being read-only (+R):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This can be very useful. If you create a Batch process that creates or modifies
    a file where users might have access to it and if those users are not to be trusted
    with the file, you can protect and hide it when not in use with the attrib command.
    To make the file accessible, run the command with the -H -R argument string just
    before updating the file, followed by another command with the +H +R argument
    string after the update, thus leaving the file hidden and read-only until the
    code needs it again. It’s the digital equivalent of unlocking the shed, getting
    and using the mower, putting it away, and relocking the shed until the lawn grows
    long again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, the attrib command fails to set attributes when a file is a
    system file or a hidden file—except for the actual system and hidden file attributes
    themselves. Thus, if a file is hidden and you use +R alone in the argument string,
    the attrib command fails to set the file to read-only. However, the previous command
    with the -S -H +R argument string ensures that these two file attributes are not
    set, thus enabling the use of the last attribute. If need be, you can execute
    a second attrib command to reset the system and/or hidden attributes: +S +H. You’ll
    find the full set of attributes that you can set and unset with the help command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate a final use, the del command ([Chapter 7](chapter7.xhtml)) does
    a great job of deleting a particular file, but not of deleting everything *but*
    a particular file. Assuming that your work directory doesn’t have any hidden files,
    these three lines of code delete everything except the lone file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first attrib command flips the *Noah.txt* file to hidden; then the del command
    deletes everything in the directory that isn’t hidden thanks to the /A-H option.
    Finally, the second attrib command restores the file to its prior state without
    a scratch on it and without any other files in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve mastered the art of manipulating the attributes of a file, you can
    move on to the manipulation of bits.
  prefs: []
  type: TYPE_NORMAL
- en: Bit Manipulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 6](chapter6.xhtml), I promised to return to the last remaining
    arithmetic operators supported in Batch: three bitwise operators and two logical
    shift operators. These operators work on the bit level, so you need to make a
    cognitive shift to the binary world to understand their behavior. A *nibble*,
    or half of a byte, is comprised of four bits, each representing a decreasing power
    of two. Setting a bit’s value to 1 turns it on, and setting its value to 0 turns
    it off.'
  prefs: []
  type: TYPE_NORMAL
- en: When you turn on the first or leftmost of the four bits, it represents the decimal
    8—the second bit is 4, the third bit is 2, and the final bit is 1\. Therefore,
    the binary number 0001 equals the decimal number of 1, and binary 1000 is equivalent
    to decimal 8.
  prefs: []
  type: TYPE_NORMAL
- en: You can derive other numbers by turning on a combination of bits. Binary 1111
    is equivalent to decimal 15—that is, 8 + 4 + 2 + 1\. The complete byte consisting
    of two nibbles has 256 unique values, but for this discussion, I’ll stay with
    the much more manageable nibble and its 16 unique values for most of the upcoming
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise Operations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *bitwise and* operation accepts two operands and returns a 1 in each bit
    position for which the corresponding bits of both operands are set to 1\. For
    this example, consider the decimal numbers 3 and 6\. The decimal number 3 equals
    binary 0011, having the bits for 2 and 1 turned on, and the decimal 6 equals the
    binary 0110, having the bits for 4 and 2 turned on. The only common bit set to
    1 is the third bit, which has a value of 2, so the result of a bitwise and of
    3 and 6 is binary 0010 or decimal 2.
  prefs: []
  type: TYPE_NORMAL
- en: The *bitwise or* operator looks for bits being set to 1 in *either* operand.
    There are three such bits between 3 and 6, resulting in binary 0111 or decimal
    7\. The *bitwise exclusive or* turns on the bits that *differ* in the two operands.
    Using the same numbers, only the second and fourth bits differ, so the result
    is binary 0101 or decimal 5 (that is, 4 + 1).
  prefs: []
  type: TYPE_NORMAL
- en: This is much easier to visualize in tabular form. [Table 30-1](#tab30-1) also
    introduces the Batch operator for each bitwise arithmetic operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 30-1: Bitwise Arithmetic and Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Operator | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Bitwise and | & | 3 & 6 = 0011 & 0110 = 0010 = 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Bitwise or | &#124; | 3 &#124; 6 = 0011 &#124; 0110 = 0111 = 7 |'
  prefs: []
  type: TYPE_TB
- en: '| Bitwise exclusive or | ^ | 3 ^ 6 = 0011 ^ 0110 = 0101 = 5 |'
  prefs: []
  type: TYPE_TB
- en: After grasping the machinations of bitwise logic, you might balk at the choice
    of operators. One ampersand usually terminates a command, the caret is an escape
    character, and the character used for the bitwise or is most often used to pipe
    data from one command to another (and I haven’t even mentioned conditional execution).
    Surely, you can’t use these characters in arithmetic calculations?
  prefs: []
  type: TYPE_NORMAL
- en: 'You can, but you need to take some action to ensure that these characters don’t
    trigger their other uses. There are actually three different methods, all of which
    I show in these three functionally equivalent examples of bitwise and arithmetic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: My preference is to encase just the arithmetic in double quotes as demonstrated
    in the first example. You can also use double quotes to surround the variable
    name, the equality operator, and the arithmetic, as shown in the second example.
    Finally, you can escape the operator with a caret.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following demonstrates all three bitwise arithmetic operations using my
    preferred method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After these commands execute, bitAnd, bitOr, and bitXOr contain the values 2,
    7, and 5, respectively, the same results calculated earlier.
  prefs: []
  type: TYPE_NORMAL
- en: This is where I usually detail the many uses for what I’ve just discussed, but
    I can’t say that I manipulate bits on a daily basis. Actually, I’ve never used
    any of the bitwise operators in Batch. In the early days of computing, coders
    would often concatenate a set of flags at the bit level to create just one condensed
    field. They could then set and retrieve the individual bits representing individual
    flags with bit manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cheap and plentiful memory has made this technique a distant memory, but I
    can still share one use. The following code determines whether a particular number
    is a power of two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Only if nbr equals 0, 1, 2, 4, 8, 16, and so on, does the echo command write
    its message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any number that’s a power of 2 has exactly one bit turned on, and the number
    one less than it has that bit turned off with all the bits to its right turned
    on. For instance, decimal 8 = binary 1000, and 7 = 0111\. The result of a bitwise
    and operation on these two operands is 0, because there are no common bits turned
    on or set to 1\. But if a number isn’t a power of 2, at least one corresponding
    bit is turned on in both it and the number one less than it. For instance, 6 =
    0110, and 5 = 0101; the second bit is turned on in both numbers, so the result
    of the bitwise and operation is nonzero: 4 = 0100.'
  prefs: []
  type: TYPE_NORMAL
- en: Logical Shift Operations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Batch has two more tools for manipulating bits. The *logical left shift* operator
    shifts all of the bits in the first operand to the left by an amount dictated
    by the right operand, replacing the bits on the right with zeros. The *logical
    right shift* operator behaves similarly except that it shifts to the right and
    replaces the vacated bits on the left with zeros while discarding the same number
    of bits on the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the logical shift operators, both with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Operator | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Logical left shift | << | 3 << 2 = 0011 → 1100 = 12 |'
  prefs: []
  type: TYPE_TB
- en: '| Logical right shift | >> | 9 >> 1 = 1001 → 0100 = 4 |'
  prefs: []
  type: TYPE_TB
- en: The bits that the logical shift inserted into the result are shown in bold.
    The first command appends two zeros after shifting the bits two places to the
    left. The second command prepends one zero after shifting the bits one place to
    the right, while also dropping the rightmost 1 in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two commands implement both of these examples in Batch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: (To handle the less-than and greater-than signs, we either need escape characters
    or one of the two double-quote techniques mentioned in reference to the bitwise
    operators.)
  prefs: []
  type: TYPE_NORMAL
- en: 'I’m equally nonplussed attempting to find logical shift applications because
    I’ve never used these operators in the real world. However, since Batch doesn’t
    support exponentials, we can use the logical left shift to raise a number to a
    power ... if that base is two. Think of it as a very narrowly defined power function.
    Consider these examples that compute 23 and 29:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Every bit in a nibble (and a byte) represents a power of 2, so the first command
    shifts 0001 to the left 3 bits, resulting in 1000 or the decimal number 8, which
    is two cubed. The trailing set command writes the following to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The second command uses more than one nibble in its calculation. Notice that
    a binary 1 followed by 9 zeros equals 512 or two to the ninth power.
  prefs: []
  type: TYPE_NORMAL
- en: If you have used these operators in the wild, drop me a line and I’ll see about
    adding your application to the next edition of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I discussed a set of topics that I simply had to share even
    though they’re too short for chapters of their own. You learned how to sort small-to-medium-sized
    data files and how to customize that sort. I gave a brief overview of the Windows
    Registry and demonstrated how to interrogate it with a couple interesting commands.
    You also learned how to set and retrieve file attributes and how to manipulate
    bits with the bitwise and logical shift operators.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter might be the most important and, eventually, the most referenced
    in this book. Troubleshooting tips and testing techniques are important in any
    language, but especially in a scripting language without a compiler—and without
    an animator or debugger.
  prefs: []
  type: TYPE_NORMAL
