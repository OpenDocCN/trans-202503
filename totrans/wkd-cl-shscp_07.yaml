- en: '**6**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6**'
- en: '**SYSTEM ADMINISTRATION: SYSTEM MAINTENANCE**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统管理：系统维护**'
- en: '![image](../images/common4.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common4.jpg)'
- en: 'The most common use of shell scripts is to help with Unix or Linux system administration.
    There’s an obvious reason for this, of course: administrators are often the most
    knowledgeable users of the system, and they also are responsible for ensuring
    that things run smoothly. But there might be an additional reason for the emphasis
    on shell scripts within the system administration world. Our theory? That system
    administrators and other power users are the people most likely to be having fun
    with their system, and shell scripts are quite fun to develop within a Unix environment!'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: shell 脚本最常见的用途是帮助 Unix 或 Linux 系统管理。对此当然有明显的原因：管理员通常是系统中最了解的人，他们也负责确保系统平稳运行。但系统管理领域中强调
    shell 脚本的原因可能还有另一个。我们的猜测是：系统管理员和其他高级用户是最有可能享受与系统互动的人，而在 Unix 环境下开发 shell 脚本非常有趣！
- en: And with that, let’s continue to explore how shell scripts can help you with
    system administration tasks.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续探索 shell 脚本如何帮助你进行系统管理任务。
- en: '**#45 Tracking Set User ID Applications**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#45 跟踪设置用户 ID 应用程序**'
- en: There are quite a few ways that ruffians and digital delinquents can break into
    a Linux system, whether they have an account or not, and one of the easiest is
    finding an improperly protected `setuid` or `setgid` command. As discussed in
    previous chapters, these commands change the effective user for any subcommands
    they invoke, as specified in the configuration, so a regular user might run a
    script where the commands in that script are run as the root or superuser. Bad.
    Dangerous!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 不论黑客是否拥有账户，都有很多方式可以侵入 Linux 系统，其中最简单的一种是找到没有正确保护的 `setuid` 或 `setgid` 命令。如前几章所讨论的，这些命令会改变它们调用的任何子命令的有效用户身份，具体由配置文件指定，因此普通用户可能会运行一个脚本，其中脚本中的命令以
    root 或超级用户身份执行。糟糕。危险！
- en: In a `setuid` shell script, for example, adding the following code can create
    a `setuid` root shell for the bad guy once the code is invoked by an unsuspecting
    admin logged in as root.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个 `setuid` shell 脚本中，添加以下代码可以为坏人创建一个 `setuid` root shell，一旦代码被一个不知情的管理员作为
    root 登录时触发。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once this script is inadvertently run by root, a copy of */bin/sh* is surreptitiously
    copied into */tmp* with the name *.rootshell* and is made `setuid` root for the
    cracker to exploit at will. Then the script causes itself to be rewritten to remove
    the conditional code (hence the `# REMOVEME` at the end of each line), leaving
    essentially no trace of what the cracker did.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个脚本被 root 不小心运行，一份 */bin/sh* 会偷偷地复制到 */tmp* 目录，并命名为 *.rootshell*，并且被设置为 `setuid`
    root，供黑客随意利用。然后，脚本会导致自己被重写，删除条件代码（因此每行末尾有 `# REMOVEME`），几乎没有留下黑客所做的痕迹。
- en: The code snippet just shown would also be exploitable in any script or command
    that runs with an effective user ID of root; hence the critical need to ensure
    that you know and approve of all `setuid` root commands on your system. Of course,
    you should never have scripts with any sort of `setuid` or `setgid` permission
    for just this reason, but it’s still smart to keep an eye on things.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示的代码片段也可以在任何以 root 身份有效用户 ID 运行的脚本或命令中被利用；因此，确保你了解并批准系统中所有 `setuid` root
    命令的必要性是至关重要的。当然，出于这个原因，你绝不应该让脚本拥有任何形式的 `setuid` 或 `setgid` 权限，但保持警觉始终是明智的。
- en: More useful than showing you how to crack a system, however, is showing how
    to identify all the shell scripts on your system that are marked `setuid` or `setgid`!
    [Listing 6-1](ch06.xhtml#ch6ex1) details how to accomplish this.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，比起向你展示如何破解系统，更有用的是展示如何识别系统中所有标记为 `setuid` 或 `setgid` 的 shell 脚本！[清单 6-1](ch06.xhtml#ch6ex1)
    详细说明了如何实现这一点。
- en: '***The Code***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 6-1: The* `*findsuid*` *script*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-1：* `*findsuid*` *脚本*'
- en: '***How It Works***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原理***'
- en: This script checks all `setuid` commands on the system to see whether they’re
    group or world writable and whether they’ve been modified in the last `$mtime`
    days. To accomplish this, we use the `find` command ➊ with arguments specifying
    the types of permissions on files to search for. If the user requests verbose
    output, every script with `setuid` permissions will be listed, regardless of read/write
    permission and modification date.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本检查系统中所有 `setuid` 命令，查看它们是否对组或全体用户可写，并且检查它们是否在过去的 `$mtime` 天内被修改。为此，我们使用
    `find` 命令 ➊，并指定搜索文件权限类型的参数。如果用户请求详细输出，所有具有 `setuid` 权限的脚本将被列出，无论其读/写权限和修改日期如何。
- en: '***Running the Script***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: 'This script has one optional argument: `-v` produces verbose output that lists
    every `setuid` program encountered by the script. This script should be run as
    root, but it can be run as any user since everyone should have basic access to
    the key directories.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本有一个可选参数：`-v` 会生成详细输出，列出脚本遇到的每个 `setuid` 程序。这个脚本应该以root身份运行，但任何用户都可以运行，因为每个人都应该对关键目录有基本访问权限。
- en: '***The Results***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: We’ve dropped a vulnerable script somewhere in the system. Let’s see if `findsuid`
    can find it in [Listing 6-2](ch06.xhtml#ch6ex2).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在系统中某个地方放置了一个漏洞脚本。让我们看看 `findsuid` 能否在[列表 6-2](ch06.xhtml#ch6ex2)中找到它。
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 6-2: Running the* `*findsuid*` *shell script and finding a backdoor
    shell script*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-2：运行* `*findsuid*` *shell脚本并找到反向门shell脚本*'
- en: There it is ([Listing 6-3](ch06.xhtml#ch6ex3))!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 就在这里（[列表 6-3](ch06.xhtml#ch6ex3)）！
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 6-3: The* `*ls*` *output of the backdoor, showing an* `*s*` *in the
    permissions, which means it is* `*setuid*`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-3：* `*ls*` *反向门的输出，显示权限中的* `*s*`，这意味着它是* `*setuid*`*'
- en: That’s a huge hole just waiting for someone to exploit. Glad we found it!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个巨大的漏洞，随时等待有人来利用。很高兴我们找到了它！
- en: '**#46 Setting the System Date**'
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#46 设置系统日期**'
- en: 'Conciseness is at the heart of Linux and its Unix predecessors and has affected
    Linux’s evolution dramatically. But there are some areas where this succinctness
    can drive a sysadmin batty. One of the most common annoyances is the format required
    for resetting the system date, as shown by the `date` command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 简洁性是Linux及其Unix前身的核心，这一特点对Linux的发展产生了深远影响。但在某些领域，这种简洁性会让系统管理员抓狂。最常见的烦恼之一就是重置系统日期所需的格式，如`date`命令所示：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Trying to figure out all the square brackets can be baffling, without even
    talking about what you do or don’t need to specify. We’ll explain: you can enter
    just minutes; or minutes and seconds; or hours, minutes, and seconds; or the month
    plus all that—or you can add the year and even the century. Yeah, crazy! Instead
    of trying to figure that out, use a shell script like the one in [Listing 6-4](ch06.xhtml#ch6ex4),
    which prompts for each relevant field and then builds the compressed date string.
    It’s a sure sanity saver.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试弄清楚所有方括号可能让人困惑，更不用说你需要或不需要指定什么了。我们来解释一下：你可以只输入分钟；或者分钟和秒；或者小时、分钟和秒；或者加上月份再加所有这些——或者你也可以加上年份，甚至是世纪。是的，疯狂！与其费劲去弄清楚这些，不如使用像[列表
    6-4](ch06.xhtml#ch6ex4)中的脚本，它会提示每个相关字段的输入，然后构建压缩日期字符串。这真的是一个保持理智的好帮手。
- en: '***The Code***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 6-4: The* `*setdate*` *script*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-4：* `*setdate*` *脚本*'
- en: '***How It Works***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: To make this script as succinct as possible, we use the `eval` function at ➋
    to accomplish two things. First, this line sets the current date and time values,
    using a `date` format string. Second, it sets the values of the variables `nyear`,
    `nmon`, `nday`, `nhr`, and `nmin`, which are then used in the simple `askvalue()`
    function ➊ to prompt for and test values entered. Using the `eval` function to
    assign values to the variables also sidesteps any potential problem of the date
    rolling over or otherwise changing between separate invocations of the `askvalue()`
    function, which would leave the script with inconsistent data. For example, if
    `askvalue` got month and day values at 23:59.59 and then hour and minute values
    at 0:00:02, the system date would actually be set back 24 hours—not at all the
    desired result.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能简洁地编写这个脚本，我们在 ➋ 使用了 `eval` 函数来完成两件事。首先，这一行使用 `date` 格式字符串设置当前的日期和时间值。其次，它设置了变量
    `nyear`、`nmon`、`nday`、`nhr` 和 `nmin` 的值，这些值随后会被用于简单的 `askvalue()` 函数 ➊ 来提示和测试输入的值。通过使用
    `eval` 函数为变量赋值，还可以避免在多次调用 `askvalue()` 函数之间日期发生变化或溢出的潜在问题，否则脚本中的数据将不一致。例如，如果 `askvalue`
    在 23:59.59 获取了月份和日期的值，然后在 0:00:02 获取了小时和分钟的值，那么系统日期实际上会回滚24小时——这显然不是我们希望的结果。
- en: We also need to ensure we use the correct date format string for our system,
    since, for instance, OS X requires a specific format when setting the date and
    Linux requires a slightly different format. By default, this script uses the OS
    X date format, but notice in the comments that a format string for Linux is also
    provided at ➌.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保使用适合我们系统的正确日期格式字符串，因为例如，OS X 在设置日期时要求使用特定的格式，而 Linux 则要求使用稍微不同的格式。默认情况下，这个脚本使用的是
    OS X 日期格式，但请注意，在注释中还提供了一个适用于 Linux 的格式字符串，见 ➌。
- en: This is one of the subtle problems with working with the `date` command. With
    this script, if you specify the exact time during the prompts but then have to
    enter a `sudo` password, you could end up setting the system time to a few seconds
    in the past. It’s probably not a problem, but this is one reason why network-connected
    systems should be working with Network Time Protocol (NTP) utilities to synchronize
    their system against an official timekeeping server. You can start down the path
    of network time synchronization by reading up on `timed(8)` on your Linux or Unix
    system.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `date` 命令时遇到的一个微妙问题。使用这个脚本时，如果你在提示过程中指定了确切的时间，但随后必须输入 `sudo` 密码，你可能会将系统时间设置为过去几秒钟的时间。这可能不会造成问题，但这也是为什么网络连接的系统应该使用网络时间协议（NTP）工具来与官方时间服务器同步的原因之一。你可以通过查阅你
    Linux 或 Unix 系统上的 `timed(8)` 来开始了解网络时间同步。
- en: '***Running the Script***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: Notice that this script uses the `sudo` command to run the actual date reset
    as root, as [Listing 6-5](ch06.xhtml#ch6ex5) shows. By entering an incorrect password
    to `sudo`, you can experiment with this script without worrying about any strange
    results.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，脚本中使用 `sudo` 命令以 root 身份运行实际的日期重置操作，正如 [Listing 6-5](ch06.xhtml#ch6ex5)
    所示。通过输入错误的 `sudo` 密码，你可以在不担心出现奇怪结果的情况下尝试这个脚本。
- en: '***The Results***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 6-5: Testing the interactive* `*setdate*` *script*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-5: 测试交互式 `*setdate*` 脚本*'
- en: '**#47 Killing Processes by Name**'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#47 根据名称终止进程**'
- en: Linux and some Unixes have a helpful command called `killall`, which allows
    you to kill all running applications that match a specified pattern. It can be
    quite useful when you want to kill nine `mingetty` daemons, or even just to send
    a `SIGHUP` signal to `xinetd` to prompt it to reread its configuration file. Systems
    that don’t have `killall` can emulate it in a shell script built around `ps` for
    identification of matching processes and `kill` to send the specified signal.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 和一些 Unix 系统有一个有用的命令 `killall`，它允许你终止所有与指定模式匹配的运行中的应用程序。当你需要终止九个 `mingetty`
    守护进程，或者仅仅是想给 `xinetd` 发送一个 `SIGHUP` 信号来促使它重新读取配置文件时，这个命令非常有用。没有 `killall` 的系统可以通过基于
    `ps` 来识别匹配的进程，并通过 `kill` 发送指定信号来模拟该命令。
- en: 'The trickiest part of the script is that the output format from `ps` varies
    significantly from OS to OS. For example, consider how differently FreeBSD, Red
    Hat Linux, and OS X show running processes in the default `ps` output. First take
    a look at the output of FreeBSD:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本中最棘手的部分是 `ps` 的输出格式在不同操作系统之间差异显著。例如，考虑一下 FreeBSD、Red Hat Linux 和 OS X 在默认的
    `ps` 输出中如何显示运行中的进程。首先看一下 FreeBSD 的输出：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Compare this output to that of Red Hat Linux:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个输出与 Red Hat Linux 的输出进行比较：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And finally, compare to the output of OS X:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，比较一下 OS X 的输出：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Worse, rather than model its `ps` command after a typical Unix command, the
    GNU `ps` command accepts BSD-style flags, SYSV-style flags, *and* GNU-style flags.
    A complete mishmash!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，GNU 的 `ps` 命令没有像典型的 Unix 命令那样模仿 `ps`，它接受 BSD 风格的标志、SYSV 风格的标志、*以及* GNU
    风格的标志。真是一个混乱的局面！
- en: Fortunately, some of these inconsistencies can be sidestepped in this particular
    script by using the `cu` flag, which produces far more consistent output that
    includes the owner of the process, the full command name, and—what we’re really
    interested in—the process ID.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，通过使用 `cu` 标志，一些这些不一致的问题在这个特定脚本中可以被规避，它会生成更一致的输出，包括进程的拥有者、完整的命令名称以及——我们真正感兴趣的——进程
    ID。
- en: 'This is also the first script where we’re really using all the power of the
    `getopts` command, which lets us work with lots of different command-line options
    and even pull in optional values. The script in [Listing 6-6](ch06.xhtml#ch6ex6)
    has four starting flags, three of which have required arguments: `-s *SIGNAL*`,
    `-u *USER*`, `-t *TTY*`, and `-n`. You’ll see them in the first block of code.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是第一个我们真正使用 `getopts` 命令的脚本，它让我们可以处理许多不同的命令行选项，甚至传入可选值。 [Listing 6-6](ch06.xhtml#ch6ex6)
    中的脚本有四个起始标志，其中三个需要参数：`-s *SIGNAL*`，`-u *USER*`，`-t *TTY*` 和 `-n`。你将在代码的第一部分看到它们。
- en: '***The Code***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 6-6: The* `*killall*` *script*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-6: `*killall*` 脚本*'
- en: '***How It Works***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: Because this script is so aggressive and potentially dangerous, we’ve put extra
    effort into minimizing false pattern matches so that a pattern like `sh` won’t
    match output from `ps` that contains `bash` or `vi crashtest.c` or other values
    that embed the pattern. This is done by the pattern-match prefix on the `awk`
    command (➊, ➋, ➌).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个脚本非常强大且潜在危险，我们做了额外的努力来最小化错误的模式匹配，以防像`sh`这样的模式匹配到`ps`输出中的`bash`或`vi crashtest.c`等值。这是通过在`awk`命令上加上模式匹配前缀来实现的（➊，➋，➌）。
- en: '*Left-rooting* the specified pattern, `$1`, with a leading space and *right-rooting*
    the pattern with a trailing `$` causes the script to search for the specified
    pattern `''sh''` in `ps` output as `'' sh$''`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*左根模式* `$1`，前面加一个空格并且*右根模式* 后面加上`$`，使得脚本能够在`ps`输出中将指定模式`''sh''`匹配为`'' sh$''`。'
- en: '***Running the Script***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This script has a variety of starting flags that let you modify its behavior.
    The `-s *SIGNAL*` flag allows you to specify a signal other than the default interrupt
    signal, `SIGINT`, to send to the matching process or processes. The `-u *USER*`
    and `-t *TTY*` flags are useful primarily to the root user in killing all processes
    associated with a specified user or TTY device, respectively. And the `-n` flag
    gives you the option of having the script report what it would do without actually
    sending any signals. Finally, a process name pattern must be specified.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本有多种启动标志，可以让你修改它的行为。`-s *SIGNAL*`标志允许你指定一个不同于默认中断信号`SIGINT`的信号，发送到匹配的进程。`-u
    *USER*`和`-t *TTY*`标志主要对root用户有用，分别用于杀死与指定用户或TTY设备相关的所有进程。而`-n`标志则让你选择是否仅报告脚本将要执行的操作，而不实际发送任何信号。最后，必须指定一个进程名称模式。
- en: '***The Results***'
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: To kill all the `csmount` processes on OS X, you can now use the `killall` script,
    as [Listing 6-7](ch06.xhtml#ch6ex7) shows.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要在OS X上杀死所有`csmount`进程，你现在可以使用`killall`脚本，如[清单6-7](ch06.xhtml#ch6ex7)所示。
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 6-7: Running the* `*killall*` *script on any* `*csmount*` *processes*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-7：在任何`*csmount*`进程上运行`*killall*`脚本*'
- en: '***Hacking the Script***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: There’s an unlikely, though not impossible, bug that could surface while running
    this script. To match only the specified pattern, the `awk` invocation outputs
    the process IDs of processes that match the pattern, plus a leading space that
    occurs at the end of the input line. But it’s theoretically possible to have two
    processes running—say, one called `bash` and the other `emulate bash`. If `killall`
    is invoked with `bash` as the pattern, both of these processes will be matched,
    although only the former is a true match. Solving this to give consistent cross-platform
    results would prove quite tricky.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不太可能，但在运行这个脚本时可能会出现一个不太可能的错误。为了仅匹配指定的模式，`awk`调用会输出匹配该模式的进程ID，并且输入行的末尾会有一个前置空格。但理论上有可能有两个进程同时运行——例如，一个叫`bash`，另一个叫`emulate
    bash`。如果用`bash`作为模式调用`killall`，这两个进程都会被匹配，尽管只有前者是真正的匹配。解决这个问题并确保跨平台的一致性结果会非常棘手。
- en: If you’re motivated, you could also write a script based heavily on the `killall`
    script that would let you `renice` jobs by name, rather than just by process ID.
    The only change required would be to invoke `renice` rather than `kill`. Invoking
    `renice` lets you change the relative priority of programs, allowing you, for
    example, to lower the priority of a long file transfer while increasing the priority
    of the video editor that the boss is running.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有动力，你还可以编写一个基于`killall`脚本的脚本，允许你通过名称而不仅仅是通过进程ID来`renice`任务。唯一需要更改的就是调用`renice`而不是`kill`。调用`renice`可以让你改变程序的相对优先级，比如，你可以降低长时间文件传输的优先级，同时提高老板正在运行的视频编辑器的优先级。
- en: '**#48 Validating User crontab Entries**'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#48 验证用户crontab条目**'
- en: One of the most helpful facilities in the Linux universe is `cron`, with its
    ability to schedule jobs at arbitrary times in the future or have them run automatically
    every minute, every few hours, monthly, or even annually. Every good system administrator
    has a Swiss Army knife of scripts running from the `crontab` file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux世界中，最有用的工具之一就是`cron`，它能够在将来的任意时间安排任务，或者让任务每分钟、每几个小时、每月甚至每年自动运行。每个优秀的系统管理员都有一把来自`crontab`文件的瑞士军刀式的脚本。
- en: However, the format for entering `cron` specifications is a bit tricky, and
    the `cron` fields have numeric values, ranges, sets, and even mnemonic names for
    days of the week or months. What’s worse is that the `crontab` program generates
    cryptic error messages when it encounters problems in a user or system `cron`
    file.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，输入`cron`规范的格式有点复杂，而`cron`字段具有数字值、范围、集合，甚至是星期几或月份的助记名称。更糟糕的是，当`crontab`程序遇到用户或系统`cron`文件中的问题时，会生成难以理解的错误信息。
- en: 'For example, if you specify a day of the week with a typo, `crontab` reports
    an error similar to the one shown here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你指定一个有拼写错误的星期几，`crontab`会报告类似下面的错误：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In fact, there’s a second error in the sample input file, on line 12, but `crontab`
    is going to force us to take the long way around to find it in the script because
    of its poor error-checking code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，示例输入文件的第12行存在第二个错误，但由于`crontab`的错误检查代码很差，它将迫使我们在脚本中采取较长的方式来查找该错误。
- en: Instead of error checking the way `crontab` wants you to, a somewhat lengthy
    shell script (see [Listing 6-8](ch06.xhtml#ch6ex8)) can step through the `crontab`
    files, checking the syntax and ensuring that values are within reasonable ranges.
    One of the reasons that this validation is possible in a shell script is that
    sets and ranges can be treated as individual values. So to test whether `3-11`
    or `4`, `6`, and `9` are acceptable values for a field, simply test `3` and `11`
    in the former case and `4`, `6`, and `9` in the latter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与其按照`crontab`要求的方式进行错误检查，不如使用一个稍长的Shell脚本（见[列表 6-8](ch06.xhtml#ch6ex8)），它可以逐步检查`crontab`文件，检查语法并确保值在合理的范围内。这种验证能够在Shell脚本中实现的原因之一是，集合和范围可以作为单独的值来处理。因此，要测试`3-11`或`4`、`6`和`9`是否是某个字段的有效值，只需要测试前者的`3`和`11`，以及后者的`4`、`6`和`9`。
- en: '***The Code***'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 6-8: The* `*verifycron*` *script*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-8：* `*verifycron*` *脚本*'
- en: '***How It Works***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: The greatest challenge in getting this script to work is sidestepping problems
    with the shell wanting to expand the asterisk field value (`*`). An asterisk is
    perfectly acceptable in a `cron` entry and is actually quite common, but if you
    give one to a subshell via a `$( )` sequence or pipe, the shell will automatically
    expand it to a list of files in the current directory—definitely not the desired
    result. Rather than puzzle through the combination of single and double quotes
    necessary to solve this problem, it proves quite a bit simpler to replace each
    asterisk with an `X`, which is what the `fixvars` function ➊ does as it splits
    things into separate variables for later testing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个脚本正常工作面临的最大挑战是避免由于Shell扩展星号字段值（`*`）而产生的问题。在`cron`条目中，星号是完全可以接受的，实际上也非常常见，但如果你通过`$(
    )`序列或管道将其传递给子Shell，Shell会自动将其扩展为当前目录中的文件列表——显然这不是我们想要的结果。与其为了解决这个问题而纠结于单引号和双引号的组合，不如将每个星号替换为一个`X`，这就是`fixvars`函数➊所做的，它会将内容分割成独立的变量，供后续测试使用。
- en: 'Also worthy of note is the simple solution to processing comma- and dash-separated
    lists of values. The punctuation is simply replaced with spaces, and each value
    is tested as if it were a stand-alone numeric value. That’s what the `$( )` sequence
    does in the `for` loops at ➋, ➌, ➍, ➎, and ➏:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另外值得注意的是，处理以逗号和破折号分隔的值列表的简单解决方案。标点符号会被空格替换，每个值会像独立的数字值一样进行测试。这就是在➋、➌、➍、➎和➏的`for`循环中，`$(
    )`序列所做的事情：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This makes it simple to step through all numeric values, ensuring that each
    and every value is valid and within the range for that specific `crontab` field
    parameter.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得逐一检查所有数字值变得简单，确保每个值都是有效的，并且在该特定`crontab`字段参数的范围内。
- en: '***Running the Script***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: 'This script is easy to run: just specify the name of a `crontab` file as its
    only argument. To work with an existing `crontab` file, see [Listing 6-9](ch06.xhtml#ch6ex9).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本非常易于运行：只需将`crontab`文件的名称作为唯一参数指定即可。要处理现有的`crontab`文件，请参见[列表 6-9](ch06.xhtml#ch6ex9)。
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 6-9: Running the* `*verifycron*` *script after exporting the current*
    `*cron*` *file*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-9：在导出当前* `*cron*` *文件后运行* `*verifycron*` *脚本*'
- en: '***The Results***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: Using a sample `crontab` file that has two errors and lots of comments, the
    script produces the results shown in [Listing 6-10](ch06.xhtml#ch6ex10).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个包含两个错误和大量注释的示例`crontab`文件，脚本将生成在[列表 6-10](ch06.xhtml#ch6ex10)中显示的结果。
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 6-10: Running the* `*verifycron*` *script on a* `*cron*` *file with
    invalid entries*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-10：在含有无效条目的* `*cron*` *文件上运行* `*verifycron*` *脚本*'
- en: The sample `crontab` file with the two errors, along with all the shell scripts
    explored in this book, are available at *[http://www.nostarch.com/wcss2/](http://www.nostarch.com/wcss2/)*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 包含两个错误的示例`crontab`文件，以及本书中探讨的所有 shell 脚本，可以在*[http://www.nostarch.com/wcss2/](http://www.nostarch.com/wcss2/)*上找到。
- en: '***Hacking the Script***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: A few enhancements would potentially be worth adding to this script. Validating
    the compatibility of month and day combinations would ensure that users don’t
    schedule a `cron` job to run on, for example, 31 February. It could also be useful
    to check whether the command being invoked can actually be found, but that would
    entail parsing and processing a `PATH` variable (that is, a list of directories
    within which to look for commands specified in the script), which can be set explicitly
    within a `crontab` file. That could be quite tricky. . . . Lastly, you could add
    support for values such as `@hourly` or `@reboot`, special values in `cron` used
    to denote the common times scripts can run.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些增强功能可能值得添加到这个脚本中。验证月份和日期组合的兼容性可以确保用户不会调度`cron`作业在例如 2 月 31 日运行。检查被调用的命令是否能实际找到也是有用的，但这需要解析和处理`PATH`变量（即用于查找脚本中指定的命令的目录列表），该变量可以在`crontab`文件中显式设置。这可能会非常棘手……最后，你还可以添加对诸如`@hourly`或`@reboot`等特殊值的支持，它们是`cron`中用于表示常见脚本运行时间的特殊值。
- en: '**#49 Ensuring that System cron Jobs Are Run**'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#49 确保系统 cron 作业被执行**'
- en: 'Until recently, Linux systems were all designed to run as servers—up 24 hours
    a day, 7 days a week, forever. You can see that implicit expectation in the design
    of the `cron` facility: there’s no point in scheduling jobs for 2:17 AM every
    Thursday if the system is shut down at 6:00 PM every night.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，Linux 系统都设计为作为服务器运行——全天候 24 小时，每周 7 天，永远不停。你可以在`cron`工具的设计中看到这种隐性预期：如果系统每天晚上
    6 点关机，那么在每周四凌晨 2:17 调度任务就没有意义。
- en: Yet many modern Unix and Linux users are running on desktops and laptops and
    therefore do shut down their systems at the end of the day. It can be quite alien
    to OS X users, for example, to leave their systems running overnight, let alone
    over a weekend or holiday.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多现代 Unix 和 Linux 用户正在使用桌面电脑和笔记本电脑，因此他们在一天结束时会关闭系统。例如，对于 OS X 用户来说，系统过夜运行是相当陌生的，更别提在周末或假期中运行了。
- en: This isn’t a big deal with user `crontab` entries, because those that don’t
    run due to shutdown schedules can be tweaked to ensure that they do eventually
    get invoked. The problem arises when the daily, weekly, and monthly system `cron`
    jobs that are part of the underlying system are not run at the specified times.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于用户的`crontab`条目来说不是大问题，因为那些由于关机计划未能执行的条目可以调整，以确保最终能够被调用。问题出现在系统中日常、每周和每月的`cron`作业上，它们是底层系统的一部分，但未能在指定的时间执行。
- en: 'That’s the purpose of the script in [Listing 6-11](ch06.xhtml#ch6ex11): to
    allow the administrator to invoke the daily, weekly, or monthly jobs directly
    from the command line, as needed.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是[示例 6-11](ch06.xhtml#ch6ex11)中脚本的目的：允许管理员根据需要直接从命令行调用日常、每周或每月作业。
- en: '***The Code***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 6-11: The* `*docron*` *script*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 6-11: `*docron*` 脚本*'
- en: '***How It Works***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: 'The `cron` jobs located in */etc/daily*, */etc/weekly*, and */etc/monthly*
    (or */etc/cron.daily*, */etc/cron.weekly*, and */etc/cron.monthly*) are set up
    completely differently from user `crontab` files: each is a directory that contains
    a set of scripts, one per job, that are run by the `crontab` facility, as specified
    in the */etc/crontab* file. To make this even more confusing, the format of the
    */etc/crontab* file is different too, because it adds an additional field that
    indicates what effective user ID should run the job.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 位于*/etc/daily*、*/etc/weekly*和*/etc/monthly*（或*/etc/cron.daily*、*/etc/cron.weekly*和*/etc/cron.monthly*）中的`cron`作业与用户的`crontab`文件设置方式完全不同：每个目录包含一组脚本，每个作业对应一个脚本，这些脚本由`crontab`工具根据*/etc/crontab*文件中的设置执行。更让人困惑的是，*/etc/crontab*文件的格式也不同，因为它添加了一个额外的字段，用于指示应该由哪个有效的用户
    ID 来执行作业。
- en: 'The */etc/crontab* file specifies the hour of the day (in the second column
    of the output that follows) at which to run the daily, weekly, and monthly jobs
    in a format that’s completely different from what you’ve seen as a regular Linux
    user, as shown here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/crontab*文件指定了每天、每周和每月作业的运行时间（在下列输出的第二列中），其格式与作为普通 Linux 用户所见的完全不同，如下所示：'
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What happens to the daily, weekly, and monthly jobs if this system isn’t running
    at 3:15 AM every night, at 4:30 AM on Saturday morning, and at 5:30 AM on the
    first of each month? Nothing. They just don’t run.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个系统没有在每天凌晨3:15、每周六早晨4:30、以及每月1日早晨5:30运行，那么日常、每周和每月的任务会发生什么？什么也不发生。它们就是不会运行。
- en: Rather than trying to force `cron` to run the jobs, the script we’ve written
    identifies the jobs in this file ➊ and runs them directly with the `eval` on the
    very last line ➋. The only difference between invoking the jobs found from this
    script and invoking them as part of a `cron` job is that when jobs are run from
    `cron`, their output stream is automatically turned into an email message, whereas
    this script displays the output stream on the screen.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与其强行让`cron`运行任务，我们编写的脚本会在此文件中识别任务 ➊，并通过最后一行的`eval`直接运行它们 ➋。从这个脚本调用任务和作为`cron`任务调用任务的唯一区别在于，当任务从`cron`运行时，它们的输出流会自动转为电子邮件消息，而这个脚本则会在屏幕上显示输出流。
- en: 'You could, of course, duplicate `cron`’s email behavior by invoking the script
    as shown here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以通过如下方式调用脚本，复制`cron`的电子邮件行为：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***Running the Script***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This script must be run as root and has one parameter—either `daily`, `weekly`,
    or `monthly`—to indicate which group of system `cron` jobs you want to run. As
    usual, we highly recommend using `sudo` to run any script as root.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本必须以root身份运行，并且有一个参数——`daily`、`weekly`或`monthly`——用于指示你想运行哪个组的系统`cron`任务。像往常一样，我们强烈推荐使用`sudo`来以root身份运行任何脚本。
- en: '***The Results***'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: This script has essentially no direct output and displays only results from
    scripts run in the `crontab`, unless an error is encountered either within the
    script or within one of the jobs spawned by the `cron` scripts.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本基本没有直接输出，只会显示在`crontab`中运行的脚本结果，除非在脚本本身或由`cron`脚本启动的某个任务中遇到错误。
- en: '***Hacking the Script***'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: Some jobs shouldn’t be run more than once a week or once a month, so there really
    should be some sort of check in place to ensure they aren’t run more often. Furthermore,
    sometimes the recurring system jobs might well run from `cron`, so we can’t make
    a blanket assumption that if `docron` hasn’t run, the jobs haven’t run.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有些任务不应该每周或每月运行超过一次，因此确实应该有某种检查机制来确保它们不会更频繁地运行。此外，有时系统的定期任务可能会从`cron`运行，所以我们不能笼统地假设如果`docron`没有运行，任务就没有运行。
- en: 'One solution would be to create three empty timestamp files, one each for daily,
    weekly, and monthly jobs, and then to add new entries to the */etc/daily*, */etc/weekly*,
    and */etc/monthly* directories that update the last-modified date of each timestamp
    file with `touch`. This would solve half the problem: `docron` could then check
    the last time the recurring `cron` job was invoked and quit if an insufficient
    amount of time had passed to justify the job’s being run again.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是创建三个空的时间戳文件，分别用于日常、每周和每月任务，然后在*/etc/daily*、*/etc/weekly*和*/etc/monthly*目录中添加新条目，通过`touch`更新每个时间戳文件的最后修改日期。这将解决一半的问题：`docron`可以检查上次调用定期`cron`任务的时间，并在经过的时间不足以证明任务应该重新运行时退出。
- en: 'The situation this solution doesn’t handle is this: six weeks after the monthly
    `cron` job last ran, the admin runs `docron` to invoke the monthly jobs. Then
    four days later, someone forgets to shut off their computer, and the monthly `cron`
    job is invoked. How can that job know that it’s not necessary to run the monthly
    jobs after all?'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案没有处理的情况是：在上次每月`cron`任务运行后的六周，管理员运行`docron`来调用每月任务。然后四天后，有人忘记关闭电脑，每月的`cron`任务被再次调用。那时，如何确保这个任务知道不再需要执行每月任务呢？
- en: 'Two scripts can be added to the appropriate directory. One script must run
    first from `run-script` or `periodic` (the standard ways to invoke `cron` jobs)
    and can then turn off the executable bit on all other scripts in the directory
    except its partner script, which turns the executable bit back on after `run-script`
    or `periodic` has scanned and ascertained that there’s nothing to do: none of
    the files in the directory appear to be executable, and therefore `cron` doesn’t
    run them. This is not a great solution, however, because there’s no guarantee
    of script evaluation order, and if we can’t guarantee the order in which the new
    scripts will be run, the entire solution fails.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将两个脚本添加到适当的目录中。第一个脚本必须首先通过`run-script`或`periodic`运行（这是调用`cron`任务的标准方式），然后可以关闭目录中所有其他脚本的可执行权限，除了其配对脚本外，后者会在`run-script`或`periodic`扫描并确认没有需要执行的任务后，将可执行权限恢复。这种方法并不是一个理想的解决方案，因为无法保证脚本的执行顺序，如果我们不能确保新脚本的执行顺序，整个解决方案就会失败。
- en: There might not be a complete solution to this dilemma, actually. Or it might
    involve writing a wrapper for `run-script` or `periodic` that would know how to
    manage timestamps to ensure that jobs weren’t executed too frequently. Or maybe
    we’re worrying about something that’s not really that big a deal in the big picture.
    ![image](../images/common1.jpg)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，可能没有一个完美的解决方案来解决这个困境。或者它可能涉及编写一个`run-script`或`periodic`的包装器，能够管理时间戳，确保任务不会执行得过于频繁。也许我们只是担心了一些从大局来看并不那么严重的事情。![image](../images/common1.jpg)
- en: '**#50 Rotating Log Files**'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#50 轮转日志文件**'
- en: Users who don’t have much experience with Linux can be quite surprised by how
    many commands, utilities, and daemons log events to system log files. Even on
    a computer with lots of disk space, it’s important to keep an eye on the size
    of these files—and, of course, on their contents.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有太多Linux经验的用户来说，系统日志文件中记录事件的命令、工具和守护进程的数量可能会让他们感到惊讶。即使是在磁盘空间充足的计算机上，也需要注意这些文件的大小——当然，也需要关注它们的内容。
- en: 'As a result, many sysadmins have a set of instructions that they place at the
    top of their log file analysis utilities, similar to the commands shown here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，许多系统管理员会在其日志文件分析工具的顶部放置一组指令，类似于这里展示的命令：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If run weekly, this would produce a rolling one-month archive of log file information
    divided into week-size portions of data. However, it’s just as easy to create
    a script that accomplishes this for all log files in the */var/log* directory
    at once, thereby relieving any log file analysis scripts of the burden and managing
    logs even in months when the admin doesn’t analyze anything.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每周运行一次，这将生成一个滚动的一个月日志文件信息归档，将数据分成按周划分的部分。然而，同样容易创建一个脚本，可以一次性处理*/var/log*目录中的所有日志文件，从而减轻任何日志文件分析脚本的负担，并且在管理员没有进行任何分析的月份也能管理日志。
- en: The script in [Listing 6-12](ch06.xhtml#ch6ex12) steps through each file in
    the */var/log* directory that matches a particular set of criteria, checking each
    matching file’s rotation schedule and last-modified date to see whether it’s time
    for the file to be rotated. If it is time for a rotation, the script does just
    that.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-12](ch06.xhtml#ch6ex12)中的脚本逐一处理*/var/log*目录中符合特定标准的每个文件，检查每个匹配文件的轮转计划和最后修改日期，以确定是否需要轮转该文件。如果需要轮转，脚本会执行轮转操作。'
- en: '***The Code***'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 6-12: The* `*rotatelogs*` *script*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-12：`*rotatelogs*` 脚本*'
- en: To be maximally useful, the script works with a configuration file that lives
    in */var/log*, allowing the administrator to specify different rotation schedules
    for different log files. The contents of a typical configuration file are shown
    in [Listing 6-13](ch06.xhtml#ch6ex13).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大程度地发挥作用，脚本与一个配置文件一起工作，该配置文件位于*/var/log*中，允许管理员为不同的日志文件指定不同的轮转计划。一个典型配置文件的内容如[列表
    6-13](ch06.xhtml#ch6ex13)所示。
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 6-13: An example configuration file for the* `*rotatelogs*` *script*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-13：`*rotatelogs*` 脚本的示例配置文件*'
- en: '***How It Works***'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: The heart of this script, and certainly the most gnarly part, is the `find`
    statement at ➊. The `find` statement creates a loop, returning all files in the
    */var/log* directory that are greater than zero characters in size, don’t contain
    a number in their name, don’t start with a period (OS X in particular dumps a
    lot of oddly named log files in this directory—they all need to be skipped), and
    don’t end with *conf* (we don’t want to rotate out the *rotatelogs.conf* file,
    for obvious reasons). `maxdepth 1` ensures that `find` doesn’t step into subdirectories,
    and the `sed` invocation at the very end removes any leading `./` sequences from
    the matches.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本的核心部分，也是最棘手的部分，是 ➊ 处的 `find` 语句。`find` 语句创建了一个循环，返回所有在 */var/log* 目录下，大小大于零字符的文件，这些文件名中不包含数字、不以点号开头（特别是
    OS X 会在该目录下产生许多奇怪命名的日志文件——这些都需要跳过），并且不以 *conf* 结尾（显而易见，我们不想轮转 *rotatelogs.conf*
    文件）。`maxdepth 1` 确保 `find` 不会进入子目录，最后的 `sed` 调用则移除了匹配结果中的任何前导 `./` 序列。
- en: '**NOTE**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Lazy is good! The* `*rotatelogs*` *script demonstrates a fundamental concept
    in shell script programming: the value of avoiding duplicate work. Rather than
    have each log analysis script rotate logs, a single log rotation script centralizes
    the task and makes modifications easy.*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*懒是好事！* `*rotatelogs*` *脚本展示了 Shell 脚本编程中的一个基本概念：避免重复工作的价值。与其让每个日志分析脚本单独轮转日志，不如由一个单一的日志轮转脚本来集中处理这一任务，从而使修改变得更简单。*'
- en: '***Running the Script***'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This script doesn’t accept any arguments, but it does print messages on which
    logs are being rotated and why. It should also be run as root.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本不接受任何参数，但它会打印出正在轮转哪些日志以及为什么要这样做的信息。它也应以 root 身份运行。
- en: '***The Results***'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: The `rotatelogs` script is simple to use, as shown in [Listing 6-14](ch06.xhtml#ch6ex14),
    but beware that depending on file permissions, it might need to be run as root.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotatelogs` 脚本易于使用，如 [列表 6-14](ch06.xhtml#ch6ex14) 所示，但请注意，根据文件权限，它可能需要以 root
    身份运行。'
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 6-14: Running the* `*rotatelogs*` *script as root to rotate the logs
    in* /var/log'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-14：以 root 身份运行 `*rotatelogs*` 脚本以轮转 /var/log 中的日志。*'
- en: Notice that only three log files matched the specified `find` criteria in this
    invocation. Of these, only `lastlog` hadn’t been backed up sufficiently recently,
    according to the duration values in the configuration file. Run `rotatelogs` again,
    however, and nothing’s done, as [Listing 6-15](ch06.xhtml#ch6ex15) shows.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此调用中，只有三个日志文件符合指定的 `find` 条件。根据配置文件中的持续时间值，其中只有 `lastlog` 文件最近没有得到足够的备份。然而，再次运行
    `rotatelogs` 后，什么也没有发生，如 [列表 6-15](ch06.xhtml#ch6ex15) 所示。
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 6-15: Running the* `*rotatelogs*` *again shows that no more logs need
    to be rotated.*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-15：再次运行 `*rotatelogs*` 显示无需再轮转其他日志。*'
- en: '***Hacking the Script***'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: 'One way to make this script even more useful is to have the oldest archive
    file, the old `$back4` file, emailed or copied to a cloud storage site before
    it’s overwritten by the `mv` command. For the simple case of email, the script
    might just look like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让这个脚本更有用的一种方法是，在 `$back4` 文件被 `mv` 命令覆盖之前，将最旧的存档文件通过电子邮件发送或复制到云存储网站上。对于电子邮件的简单情况，脚本可能就像这样：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Another useful enhancement to `rotatelogs` would be to compress all rotated
    logs to further save on disk space; this would require that the script recognize
    and work properly with compressed files as it proceeded.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `rotatelogs` 的另一个有用增强是将所有轮转的日志压缩，以进一步节省磁盘空间；这将要求脚本在执行时能够识别并正确处理压缩文件。
- en: '**#51 Managing Backups**'
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#51 管理备份**'
- en: Managing system backups is a task that all system administrators are familiar
    with, and it’s about as thankless as a job can be. No one ever says, “Hey, that
    backup’s working—nice job!” Even on a single-user Linux computer, some sort of
    backup schedule is essential. Unfortunately, it’s usually only after you’ve been
    burned once, losing both data and files, that you realize the value of a regular
    backup. One of the reasons so many Linux systems neglect backups is that many
    of the backup tools are crude and difficult to understand.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 管理系统备份是所有系统管理员都熟悉的任务，而且这是一个几乎得不到任何感谢的工作。没有人会说：“嘿，那个备份正常工作——干得好！”即便是在单用户的 Linux
    计算机上，也需要某种备份计划。不幸的是，通常只有在数据和文件丢失后，你才会意识到定期备份的重要性。许多 Linux 系统忽视备份的原因之一是许多备份工具原始且难以理解。
- en: A shell script can solve this problem! The script in [Listing 6-16](ch06.xhtml#ch6ex16)
    backs up a specified set of directories, either incrementally (that is, only those
    files that have changed since the last backup) or as a full backup (all files).
    The backup is compressed on the fly to minimize disk space used, and the script
    output can be directed to a file, a tape device, a remotely mounted NFS partition,
    a cloud backup service (like we set up later in the book), or even a DVD.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 shell 脚本可以解决这个问题！[清单 6-16](ch06.xhtml#ch6ex16) 中的脚本备份指定的一组目录，可以选择增量备份（即，仅备份自上次备份以来发生变化的文件）或完整备份（所有文件）。备份会实时压缩，以最小化磁盘空间的使用，脚本输出可以定向到文件、磁带设备、远程挂载的
    NFS 分区、云备份服务（例如我们在书中稍后设置的服务），甚至是 DVD。
- en: '***The Code***'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 6-16: The* `*backup*` *script*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-16：* `*backup*` *脚本*'
- en: '***How It Works***'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: For a full system backup, the `pax` command at ➊ and ➋ does all the work, piping
    its output to a compression program (`bzip2` by default) and then to an output
    file or device. An incremental backup is a bit trickier, because the standard
    version of `tar` doesn’t include any sort of modification time test, unlike the
    GNU version of `tar`. The list of files modified since the previous backup is
    built with `find` and saved in the `inclist` temporary file. That file, emulating
    the `tar` output format for increased portability, is then fed to `pax` directly.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的系统备份，➊ 和 ➋ 中的 `pax` 命令完成所有工作，将其输出通过管道传递给压缩程序（默认是 `bzip2`），然后输出到文件或设备。增量备份则稍微复杂一些，因为标准版本的
    `tar` 不包括任何修改时间测试，这与 GNU 版本的 `tar` 不同。自上次备份以来修改过的文件列表是通过 `find` 构建的，并保存在 `inclist`
    临时文件中。该文件模仿 `tar` 的输出格式，以提高便携性，然后直接传递给 `pax`。
- en: Choosing when to mark the timestamp for a backup is an area in which many backup
    programs get messed up, typically marking the “last backup time” as when the program
    has finished the backup, rather than when it started. Setting the timestamp to
    the time of backup completion can be a problem if any files are modified during
    the backup process, which becomes more likely as individual backups take longer
    to complete. Because files modified under this scenario would have a last-modified
    date older than the timestamp date, they would not be backed up the next time
    an incremental backup is run, which would be bad.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 选择何时标记备份的时间戳是许多备份程序容易出错的地方，通常将“最后备份时间”标记为程序完成备份时，而不是开始备份时。如果将时间戳设置为备份完成时的时间，当备份过程中有文件被修改时可能会出现问题，这种情况随着单个备份完成时间的延长而变得更有可能。因为在这种情况下修改过的文件，其最后修改时间会比时间戳日期更早，所以下次进行增量备份时，它们将不会被备份，这将是一个问题。
- en: 'But hold on, because setting the timestamp to *before* the backup takes place
    is wrong too: if the backup fails for some reason, there’s no way to reverse the
    updated timestamp.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，因为将时间戳设置为*备份发生之前*也是错误的：如果备份因某种原因失败，无法撤销更新时间戳。
- en: Both of these problems can be avoided by saving the date and time before the
    backup starts (in the `timestamp` variable) but waiting to apply the value of
    `$timestamp` to `$tsfile` using the `-t` flag to `touch` only *after* the backup
    has succeeded. Subtle, eh?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在备份开始之前（在 `timestamp` 变量中）保存日期和时间，并等待在备份成功后再通过 `-t` 标志将 `$timestamp` 应用到 `$tsfile`（使用
    `touch`）来解决这两个问题。微妙吧？
- en: '***Running the Script***'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This script has a number of options, all of which can be ignored to perform
    the default incremental backup based on which files have been modified since the
    last time the script was run (that is, since the timestamp from the last incremental
    backup). Starting parameters allow you to specify a different output file or device
    (`-o output`), to choose a full backup (`-f`), to actively choose an incremental
    backup (`-i`) even though it is the default, or to prevent the timestamp file
    from being updated in the case of an incremental backup (`-n`).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本有多个选项，所有选项都可以忽略，从而执行基于自上次脚本运行以来修改过的文件的默认增量备份（即，自上次增量备份的时间戳以来）。启动参数允许你指定不同的输出文件或设备（`-o
    output`），选择完整备份（`-f`），即使默认是增量备份，也可以主动选择增量备份（`-i`），或在进行增量备份时防止更新时间戳文件（`-n`）。
- en: '***The Results***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: The `backup` script requires no arguments and is simple to run, as [Listing
    6-17](ch06.xhtml#ch6ex17) details.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`backup` 脚本无需任何参数，运行起来很简单，具体细节参见[清单 6-17](ch06.xhtml#ch6ex17)。'
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 6-17: Running the* `*backup*` *script requires no arguments and prints
    the results to screen.*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-17：运行* `*backup*` *脚本无需任何参数，并将结果输出到屏幕上。*'
- en: As you would expect, the output of a backup program isn’t very scintillating.
    But the resulting compressed file is sufficiently large that it shows plenty of
    data is within, as you can see in [Listing 6-18](ch06.xhtml#ch6ex18).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预期的那样，备份程序的输出并不十分引人注目。但生成的压缩文件足够大，足以显示里面有大量数据，正如你在[清单 6-18](ch06.xhtml#ch6ex18)中所看到的。
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 6-18: Displaying the backed-up file with* `*ls*`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-18：使用* `*ls*` *命令显示已备份文件*'
- en: '**#52 Backing Up Directories**'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#52 备份目录**'
- en: Related to the task of backing up entire filesystems is the user-centric task
    of taking a snapshot of a specific directory or directory tree. The simple script
    in [Listing 6-19](ch06.xhtml#ch6ex19) allows users to create a compressed `tar`
    archive of a specified directory for archival or sharing purposes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与备份整个文件系统的任务相关的是一个以用户为中心的任务，即为特定目录或目录树拍摄快照。[清单 6-19](ch06.xhtml#ch6ex19)中的简单脚本允许用户创建一个指定目录的压缩
    `tar` 归档，以便备份或共享。
- en: '***The Code***'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 6-19: The* `*archivedir*` *script*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-19：* `*archivedir*` *脚本*'
- en: '***How It Works***'
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: This script is almost all error-checking code, to ensure that it never causes
    a loss of data or creates an incorrect snapshot. In addition to using the typical
    tests to validate the presence and appropriateness of the starting argument, this
    script forces the user to be in the parent directory of the subdirectory to be
    compressed and archived, ensuring that the archive file is saved in the proper
    place upon completion. The test `if [ ! -w . ]` ➊ verifies that the user has write
    permission on the current directory. And this script even warns users before archiving
    if the resultant backup file would be unusually large.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本几乎完全由错误检查代码组成，以确保它永远不会造成数据丢失或生成不正确的快照。除了使用典型的测试来验证起始参数的存在性和适当性外，该脚本还强制用户位于要压缩和归档的子目录的父目录中，确保归档文件在完成时保存到正确的位置。测试
    `if [ ! -w . ]` ➊ 用于验证用户是否对当前目录具有写权限。即使在归档前，该脚本也会在备份文件异常大的情况下发出警告。
- en: Finally, the actual command that archives the specified directory is `tar` ➋.
    The return code of this command is tested to ensure that the script never deletes
    the directory if an error of any sort occurs.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，实际执行归档指定目录的命令是 `tar` ➋。此命令的返回码会被测试，以确保在发生任何错误时脚本不会删除该目录。
- en: '***Running the Script***'
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This script should be invoked with the name of the desired directory to archive
    as its only argument. To ensure that the script doesn’t try to archive itself,
    it requires that a subdirectory of the current directory be specified as the argument,
    rather than `.`, as [Listing 6-20](ch06.xhtml#ch6ex20) shows.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本应当以要归档的目录名作为唯一参数来调用。为了确保脚本不会尝试归档自身，它要求指定当前目录的一个子目录作为参数，而不是`.`，正如[清单 6-20](ch06.xhtml#ch6ex20)所示。
- en: '***The Results***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 6-20: Running the* `*archivedir*` *script on the* scripts *directory,
    but canceling*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-20：在* `*archivedir*` *脚本中运行* `scripts` *目录，但取消操作*'
- en: This seemed as though it might be a big archive, so we hesitated to create it,
    but after thinking about it, we decided there’s no reason not to proceed after
    all.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来这可能是一个较大的归档，我们犹豫是否创建它，但在深思熟虑之后，我们决定没有理由不继续执行。
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here are the results:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结果：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**NOTE**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Here’s a tip for developers: when actively working on a project, use* `*archivedir*`
    *in a* `*cron*` *job to automatically take a snapshot of your working code each
    night for archival purposes.*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是一个开发者的小贴士：在积极进行项目开发时，将* `*archivedir*` *脚本用于* `*cron*` *任务，每晚自动为你的工作代码拍摄快照以备份。*'
