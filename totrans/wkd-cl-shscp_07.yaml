- en: '**6**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SYSTEM ADMINISTRATION: SYSTEM MAINTENANCE**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The most common use of shell scripts is to help with Unix or Linux system administration.
    There’s an obvious reason for this, of course: administrators are often the most
    knowledgeable users of the system, and they also are responsible for ensuring
    that things run smoothly. But there might be an additional reason for the emphasis
    on shell scripts within the system administration world. Our theory? That system
    administrators and other power users are the people most likely to be having fun
    with their system, and shell scripts are quite fun to develop within a Unix environment!'
  prefs: []
  type: TYPE_NORMAL
- en: And with that, let’s continue to explore how shell scripts can help you with
    system administration tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '**#45 Tracking Set User ID Applications**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are quite a few ways that ruffians and digital delinquents can break into
    a Linux system, whether they have an account or not, and one of the easiest is
    finding an improperly protected `setuid` or `setgid` command. As discussed in
    previous chapters, these commands change the effective user for any subcommands
    they invoke, as specified in the configuration, so a regular user might run a
    script where the commands in that script are run as the root or superuser. Bad.
    Dangerous!
  prefs: []
  type: TYPE_NORMAL
- en: In a `setuid` shell script, for example, adding the following code can create
    a `setuid` root shell for the bad guy once the code is invoked by an unsuspecting
    admin logged in as root.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once this script is inadvertently run by root, a copy of */bin/sh* is surreptitiously
    copied into */tmp* with the name *.rootshell* and is made `setuid` root for the
    cracker to exploit at will. Then the script causes itself to be rewritten to remove
    the conditional code (hence the `# REMOVEME` at the end of each line), leaving
    essentially no trace of what the cracker did.
  prefs: []
  type: TYPE_NORMAL
- en: The code snippet just shown would also be exploitable in any script or command
    that runs with an effective user ID of root; hence the critical need to ensure
    that you know and approve of all `setuid` root commands on your system. Of course,
    you should never have scripts with any sort of `setuid` or `setgid` permission
    for just this reason, but it’s still smart to keep an eye on things.
  prefs: []
  type: TYPE_NORMAL
- en: More useful than showing you how to crack a system, however, is showing how
    to identify all the shell scripts on your system that are marked `setuid` or `setgid`!
    [Listing 6-1](ch06.xhtml#ch6ex1) details how to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-1: The* `*findsuid*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script checks all `setuid` commands on the system to see whether they’re
    group or world writable and whether they’ve been modified in the last `$mtime`
    days. To accomplish this, we use the `find` command ➊ with arguments specifying
    the types of permissions on files to search for. If the user requests verbose
    output, every script with `setuid` permissions will be listed, regardless of read/write
    permission and modification date.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This script has one optional argument: `-v` produces verbose output that lists
    every `setuid` program encountered by the script. This script should be run as
    root, but it can be run as any user since everyone should have basic access to
    the key directories.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve dropped a vulnerable script somewhere in the system. Let’s see if `findsuid`
    can find it in [Listing 6-2](ch06.xhtml#ch6ex2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-2: Running the* `*findsuid*` *shell script and finding a backdoor
    shell script*'
  prefs: []
  type: TYPE_NORMAL
- en: There it is ([Listing 6-3](ch06.xhtml#ch6ex3))!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-3: The* `*ls*` *output of the backdoor, showing an* `*s*` *in the
    permissions, which means it is* `*setuid*`'
  prefs: []
  type: TYPE_NORMAL
- en: That’s a huge hole just waiting for someone to exploit. Glad we found it!
  prefs: []
  type: TYPE_NORMAL
- en: '**#46 Setting the System Date**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conciseness is at the heart of Linux and its Unix predecessors and has affected
    Linux’s evolution dramatically. But there are some areas where this succinctness
    can drive a sysadmin batty. One of the most common annoyances is the format required
    for resetting the system date, as shown by the `date` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to figure out all the square brackets can be baffling, without even
    talking about what you do or don’t need to specify. We’ll explain: you can enter
    just minutes; or minutes and seconds; or hours, minutes, and seconds; or the month
    plus all that—or you can add the year and even the century. Yeah, crazy! Instead
    of trying to figure that out, use a shell script like the one in [Listing 6-4](ch06.xhtml#ch6ex4),
    which prompts for each relevant field and then builds the compressed date string.
    It’s a sure sanity saver.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-4: The* `*setdate*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To make this script as succinct as possible, we use the `eval` function at ➋
    to accomplish two things. First, this line sets the current date and time values,
    using a `date` format string. Second, it sets the values of the variables `nyear`,
    `nmon`, `nday`, `nhr`, and `nmin`, which are then used in the simple `askvalue()`
    function ➊ to prompt for and test values entered. Using the `eval` function to
    assign values to the variables also sidesteps any potential problem of the date
    rolling over or otherwise changing between separate invocations of the `askvalue()`
    function, which would leave the script with inconsistent data. For example, if
    `askvalue` got month and day values at 23:59.59 and then hour and minute values
    at 0:00:02, the system date would actually be set back 24 hours—not at all the
    desired result.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to ensure we use the correct date format string for our system,
    since, for instance, OS X requires a specific format when setting the date and
    Linux requires a slightly different format. By default, this script uses the OS
    X date format, but notice in the comments that a format string for Linux is also
    provided at ➌.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the subtle problems with working with the `date` command. With
    this script, if you specify the exact time during the prompts but then have to
    enter a `sudo` password, you could end up setting the system time to a few seconds
    in the past. It’s probably not a problem, but this is one reason why network-connected
    systems should be working with Network Time Protocol (NTP) utilities to synchronize
    their system against an official timekeeping server. You can start down the path
    of network time synchronization by reading up on `timed(8)` on your Linux or Unix
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice that this script uses the `sudo` command to run the actual date reset
    as root, as [Listing 6-5](ch06.xhtml#ch6ex5) shows. By entering an incorrect password
    to `sudo`, you can experiment with this script without worrying about any strange
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-5: Testing the interactive* `*setdate*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '**#47 Killing Processes by Name**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linux and some Unixes have a helpful command called `killall`, which allows
    you to kill all running applications that match a specified pattern. It can be
    quite useful when you want to kill nine `mingetty` daemons, or even just to send
    a `SIGHUP` signal to `xinetd` to prompt it to reread its configuration file. Systems
    that don’t have `killall` can emulate it in a shell script built around `ps` for
    identification of matching processes and `kill` to send the specified signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The trickiest part of the script is that the output format from `ps` varies
    significantly from OS to OS. For example, consider how differently FreeBSD, Red
    Hat Linux, and OS X show running processes in the default `ps` output. First take
    a look at the output of FreeBSD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare this output to that of Red Hat Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, compare to the output of OS X:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Worse, rather than model its `ps` command after a typical Unix command, the
    GNU `ps` command accepts BSD-style flags, SYSV-style flags, *and* GNU-style flags.
    A complete mishmash!
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, some of these inconsistencies can be sidestepped in this particular
    script by using the `cu` flag, which produces far more consistent output that
    includes the owner of the process, the full command name, and—what we’re really
    interested in—the process ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also the first script where we’re really using all the power of the
    `getopts` command, which lets us work with lots of different command-line options
    and even pull in optional values. The script in [Listing 6-6](ch06.xhtml#ch6ex6)
    has four starting flags, three of which have required arguments: `-s *SIGNAL*`,
    `-u *USER*`, `-t *TTY*`, and `-n`. You’ll see them in the first block of code.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-6: The* `*killall*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because this script is so aggressive and potentially dangerous, we’ve put extra
    effort into minimizing false pattern matches so that a pattern like `sh` won’t
    match output from `ps` that contains `bash` or `vi crashtest.c` or other values
    that embed the pattern. This is done by the pattern-match prefix on the `awk`
    command (➊, ➋, ➌).
  prefs: []
  type: TYPE_NORMAL
- en: '*Left-rooting* the specified pattern, `$1`, with a leading space and *right-rooting*
    the pattern with a trailing `$` causes the script to search for the specified
    pattern `''sh''` in `ps` output as `'' sh$''`.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script has a variety of starting flags that let you modify its behavior.
    The `-s *SIGNAL*` flag allows you to specify a signal other than the default interrupt
    signal, `SIGINT`, to send to the matching process or processes. The `-u *USER*`
    and `-t *TTY*` flags are useful primarily to the root user in killing all processes
    associated with a specified user or TTY device, respectively. And the `-n` flag
    gives you the option of having the script report what it would do without actually
    sending any signals. Finally, a process name pattern must be specified.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To kill all the `csmount` processes on OS X, you can now use the `killall` script,
    as [Listing 6-7](ch06.xhtml#ch6ex7) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-7: Running the* `*killall*` *script on any* `*csmount*` *processes*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s an unlikely, though not impossible, bug that could surface while running
    this script. To match only the specified pattern, the `awk` invocation outputs
    the process IDs of processes that match the pattern, plus a leading space that
    occurs at the end of the input line. But it’s theoretically possible to have two
    processes running—say, one called `bash` and the other `emulate bash`. If `killall`
    is invoked with `bash` as the pattern, both of these processes will be matched,
    although only the former is a true match. Solving this to give consistent cross-platform
    results would prove quite tricky.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re motivated, you could also write a script based heavily on the `killall`
    script that would let you `renice` jobs by name, rather than just by process ID.
    The only change required would be to invoke `renice` rather than `kill`. Invoking
    `renice` lets you change the relative priority of programs, allowing you, for
    example, to lower the priority of a long file transfer while increasing the priority
    of the video editor that the boss is running.
  prefs: []
  type: TYPE_NORMAL
- en: '**#48 Validating User crontab Entries**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most helpful facilities in the Linux universe is `cron`, with its
    ability to schedule jobs at arbitrary times in the future or have them run automatically
    every minute, every few hours, monthly, or even annually. Every good system administrator
    has a Swiss Army knife of scripts running from the `crontab` file.
  prefs: []
  type: TYPE_NORMAL
- en: However, the format for entering `cron` specifications is a bit tricky, and
    the `cron` fields have numeric values, ranges, sets, and even mnemonic names for
    days of the week or months. What’s worse is that the `crontab` program generates
    cryptic error messages when it encounters problems in a user or system `cron`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you specify a day of the week with a typo, `crontab` reports
    an error similar to the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In fact, there’s a second error in the sample input file, on line 12, but `crontab`
    is going to force us to take the long way around to find it in the script because
    of its poor error-checking code.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of error checking the way `crontab` wants you to, a somewhat lengthy
    shell script (see [Listing 6-8](ch06.xhtml#ch6ex8)) can step through the `crontab`
    files, checking the syntax and ensuring that values are within reasonable ranges.
    One of the reasons that this validation is possible in a shell script is that
    sets and ranges can be treated as individual values. So to test whether `3-11`
    or `4`, `6`, and `9` are acceptable values for a field, simply test `3` and `11`
    in the former case and `4`, `6`, and `9` in the latter.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-8: The* `*verifycron*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The greatest challenge in getting this script to work is sidestepping problems
    with the shell wanting to expand the asterisk field value (`*`). An asterisk is
    perfectly acceptable in a `cron` entry and is actually quite common, but if you
    give one to a subshell via a `$( )` sequence or pipe, the shell will automatically
    expand it to a list of files in the current directory—definitely not the desired
    result. Rather than puzzle through the combination of single and double quotes
    necessary to solve this problem, it proves quite a bit simpler to replace each
    asterisk with an `X`, which is what the `fixvars` function ➊ does as it splits
    things into separate variables for later testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also worthy of note is the simple solution to processing comma- and dash-separated
    lists of values. The punctuation is simply replaced with spaces, and each value
    is tested as if it were a stand-alone numeric value. That’s what the `$( )` sequence
    does in the `for` loops at ➋, ➌, ➍, ➎, and ➏:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This makes it simple to step through all numeric values, ensuring that each
    and every value is valid and within the range for that specific `crontab` field
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This script is easy to run: just specify the name of a `crontab` file as its
    only argument. To work with an existing `crontab` file, see [Listing 6-9](ch06.xhtml#ch6ex9).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-9: Running the* `*verifycron*` *script after exporting the current*
    `*cron*` *file*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using a sample `crontab` file that has two errors and lots of comments, the
    script produces the results shown in [Listing 6-10](ch06.xhtml#ch6ex10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-10: Running the* `*verifycron*` *script on a* `*cron*` *file with
    invalid entries*'
  prefs: []
  type: TYPE_NORMAL
- en: The sample `crontab` file with the two errors, along with all the shell scripts
    explored in this book, are available at *[http://www.nostarch.com/wcss2/](http://www.nostarch.com/wcss2/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A few enhancements would potentially be worth adding to this script. Validating
    the compatibility of month and day combinations would ensure that users don’t
    schedule a `cron` job to run on, for example, 31 February. It could also be useful
    to check whether the command being invoked can actually be found, but that would
    entail parsing and processing a `PATH` variable (that is, a list of directories
    within which to look for commands specified in the script), which can be set explicitly
    within a `crontab` file. That could be quite tricky. . . . Lastly, you could add
    support for values such as `@hourly` or `@reboot`, special values in `cron` used
    to denote the common times scripts can run.
  prefs: []
  type: TYPE_NORMAL
- en: '**#49 Ensuring that System cron Jobs Are Run**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Until recently, Linux systems were all designed to run as servers—up 24 hours
    a day, 7 days a week, forever. You can see that implicit expectation in the design
    of the `cron` facility: there’s no point in scheduling jobs for 2:17 AM every
    Thursday if the system is shut down at 6:00 PM every night.'
  prefs: []
  type: TYPE_NORMAL
- en: Yet many modern Unix and Linux users are running on desktops and laptops and
    therefore do shut down their systems at the end of the day. It can be quite alien
    to OS X users, for example, to leave their systems running overnight, let alone
    over a weekend or holiday.
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t a big deal with user `crontab` entries, because those that don’t
    run due to shutdown schedules can be tweaked to ensure that they do eventually
    get invoked. The problem arises when the daily, weekly, and monthly system `cron`
    jobs that are part of the underlying system are not run at the specified times.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s the purpose of the script in [Listing 6-11](ch06.xhtml#ch6ex11): to
    allow the administrator to invoke the daily, weekly, or monthly jobs directly
    from the command line, as needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-11: The* `*docron*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `cron` jobs located in */etc/daily*, */etc/weekly*, and */etc/monthly*
    (or */etc/cron.daily*, */etc/cron.weekly*, and */etc/cron.monthly*) are set up
    completely differently from user `crontab` files: each is a directory that contains
    a set of scripts, one per job, that are run by the `crontab` facility, as specified
    in the */etc/crontab* file. To make this even more confusing, the format of the
    */etc/crontab* file is different too, because it adds an additional field that
    indicates what effective user ID should run the job.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The */etc/crontab* file specifies the hour of the day (in the second column
    of the output that follows) at which to run the daily, weekly, and monthly jobs
    in a format that’s completely different from what you’ve seen as a regular Linux
    user, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What happens to the daily, weekly, and monthly jobs if this system isn’t running
    at 3:15 AM every night, at 4:30 AM on Saturday morning, and at 5:30 AM on the
    first of each month? Nothing. They just don’t run.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than trying to force `cron` to run the jobs, the script we’ve written
    identifies the jobs in this file ➊ and runs them directly with the `eval` on the
    very last line ➋. The only difference between invoking the jobs found from this
    script and invoking them as part of a `cron` job is that when jobs are run from
    `cron`, their output stream is automatically turned into an email message, whereas
    this script displays the output stream on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could, of course, duplicate `cron`’s email behavior by invoking the script
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script must be run as root and has one parameter—either `daily`, `weekly`,
    or `monthly`—to indicate which group of system `cron` jobs you want to run. As
    usual, we highly recommend using `sudo` to run any script as root.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script has essentially no direct output and displays only results from
    scripts run in the `crontab`, unless an error is encountered either within the
    script or within one of the jobs spawned by the `cron` scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some jobs shouldn’t be run more than once a week or once a month, so there really
    should be some sort of check in place to ensure they aren’t run more often. Furthermore,
    sometimes the recurring system jobs might well run from `cron`, so we can’t make
    a blanket assumption that if `docron` hasn’t run, the jobs haven’t run.
  prefs: []
  type: TYPE_NORMAL
- en: 'One solution would be to create three empty timestamp files, one each for daily,
    weekly, and monthly jobs, and then to add new entries to the */etc/daily*, */etc/weekly*,
    and */etc/monthly* directories that update the last-modified date of each timestamp
    file with `touch`. This would solve half the problem: `docron` could then check
    the last time the recurring `cron` job was invoked and quit if an insufficient
    amount of time had passed to justify the job’s being run again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The situation this solution doesn’t handle is this: six weeks after the monthly
    `cron` job last ran, the admin runs `docron` to invoke the monthly jobs. Then
    four days later, someone forgets to shut off their computer, and the monthly `cron`
    job is invoked. How can that job know that it’s not necessary to run the monthly
    jobs after all?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Two scripts can be added to the appropriate directory. One script must run
    first from `run-script` or `periodic` (the standard ways to invoke `cron` jobs)
    and can then turn off the executable bit on all other scripts in the directory
    except its partner script, which turns the executable bit back on after `run-script`
    or `periodic` has scanned and ascertained that there’s nothing to do: none of
    the files in the directory appear to be executable, and therefore `cron` doesn’t
    run them. This is not a great solution, however, because there’s no guarantee
    of script evaluation order, and if we can’t guarantee the order in which the new
    scripts will be run, the entire solution fails.'
  prefs: []
  type: TYPE_NORMAL
- en: There might not be a complete solution to this dilemma, actually. Or it might
    involve writing a wrapper for `run-script` or `periodic` that would know how to
    manage timestamps to ensure that jobs weren’t executed too frequently. Or maybe
    we’re worrying about something that’s not really that big a deal in the big picture.
    ![image](../images/common1.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: '**#50 Rotating Log Files**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Users who don’t have much experience with Linux can be quite surprised by how
    many commands, utilities, and daemons log events to system log files. Even on
    a computer with lots of disk space, it’s important to keep an eye on the size
    of these files—and, of course, on their contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, many sysadmins have a set of instructions that they place at the
    top of their log file analysis utilities, similar to the commands shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If run weekly, this would produce a rolling one-month archive of log file information
    divided into week-size portions of data. However, it’s just as easy to create
    a script that accomplishes this for all log files in the */var/log* directory
    at once, thereby relieving any log file analysis scripts of the burden and managing
    logs even in months when the admin doesn’t analyze anything.
  prefs: []
  type: TYPE_NORMAL
- en: The script in [Listing 6-12](ch06.xhtml#ch6ex12) steps through each file in
    the */var/log* directory that matches a particular set of criteria, checking each
    matching file’s rotation schedule and last-modified date to see whether it’s time
    for the file to be rotated. If it is time for a rotation, the script does just
    that.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-12: The* `*rotatelogs*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: To be maximally useful, the script works with a configuration file that lives
    in */var/log*, allowing the administrator to specify different rotation schedules
    for different log files. The contents of a typical configuration file are shown
    in [Listing 6-13](ch06.xhtml#ch6ex13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-13: An example configuration file for the* `*rotatelogs*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The heart of this script, and certainly the most gnarly part, is the `find`
    statement at ➊. The `find` statement creates a loop, returning all files in the
    */var/log* directory that are greater than zero characters in size, don’t contain
    a number in their name, don’t start with a period (OS X in particular dumps a
    lot of oddly named log files in this directory—they all need to be skipped), and
    don’t end with *conf* (we don’t want to rotate out the *rotatelogs.conf* file,
    for obvious reasons). `maxdepth 1` ensures that `find` doesn’t step into subdirectories,
    and the `sed` invocation at the very end removes any leading `./` sequences from
    the matches.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Lazy is good! The* `*rotatelogs*` *script demonstrates a fundamental concept
    in shell script programming: the value of avoiding duplicate work. Rather than
    have each log analysis script rotate logs, a single log rotation script centralizes
    the task and makes modifications easy.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script doesn’t accept any arguments, but it does print messages on which
    logs are being rotated and why. It should also be run as root.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `rotatelogs` script is simple to use, as shown in [Listing 6-14](ch06.xhtml#ch6ex14),
    but beware that depending on file permissions, it might need to be run as root.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-14: Running the* `*rotatelogs*` *script as root to rotate the logs
    in* /var/log'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that only three log files matched the specified `find` criteria in this
    invocation. Of these, only `lastlog` hadn’t been backed up sufficiently recently,
    according to the duration values in the configuration file. Run `rotatelogs` again,
    however, and nothing’s done, as [Listing 6-15](ch06.xhtml#ch6ex15) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-15: Running the* `*rotatelogs*` *again shows that no more logs need
    to be rotated.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One way to make this script even more useful is to have the oldest archive
    file, the old `$back4` file, emailed or copied to a cloud storage site before
    it’s overwritten by the `mv` command. For the simple case of email, the script
    might just look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Another useful enhancement to `rotatelogs` would be to compress all rotated
    logs to further save on disk space; this would require that the script recognize
    and work properly with compressed files as it proceeded.
  prefs: []
  type: TYPE_NORMAL
- en: '**#51 Managing Backups**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Managing system backups is a task that all system administrators are familiar
    with, and it’s about as thankless as a job can be. No one ever says, “Hey, that
    backup’s working—nice job!” Even on a single-user Linux computer, some sort of
    backup schedule is essential. Unfortunately, it’s usually only after you’ve been
    burned once, losing both data and files, that you realize the value of a regular
    backup. One of the reasons so many Linux systems neglect backups is that many
    of the backup tools are crude and difficult to understand.
  prefs: []
  type: TYPE_NORMAL
- en: A shell script can solve this problem! The script in [Listing 6-16](ch06.xhtml#ch6ex16)
    backs up a specified set of directories, either incrementally (that is, only those
    files that have changed since the last backup) or as a full backup (all files).
    The backup is compressed on the fly to minimize disk space used, and the script
    output can be directed to a file, a tape device, a remotely mounted NFS partition,
    a cloud backup service (like we set up later in the book), or even a DVD.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-16: The* `*backup*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For a full system backup, the `pax` command at ➊ and ➋ does all the work, piping
    its output to a compression program (`bzip2` by default) and then to an output
    file or device. An incremental backup is a bit trickier, because the standard
    version of `tar` doesn’t include any sort of modification time test, unlike the
    GNU version of `tar`. The list of files modified since the previous backup is
    built with `find` and saved in the `inclist` temporary file. That file, emulating
    the `tar` output format for increased portability, is then fed to `pax` directly.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing when to mark the timestamp for a backup is an area in which many backup
    programs get messed up, typically marking the “last backup time” as when the program
    has finished the backup, rather than when it started. Setting the timestamp to
    the time of backup completion can be a problem if any files are modified during
    the backup process, which becomes more likely as individual backups take longer
    to complete. Because files modified under this scenario would have a last-modified
    date older than the timestamp date, they would not be backed up the next time
    an incremental backup is run, which would be bad.
  prefs: []
  type: TYPE_NORMAL
- en: 'But hold on, because setting the timestamp to *before* the backup takes place
    is wrong too: if the backup fails for some reason, there’s no way to reverse the
    updated timestamp.'
  prefs: []
  type: TYPE_NORMAL
- en: Both of these problems can be avoided by saving the date and time before the
    backup starts (in the `timestamp` variable) but waiting to apply the value of
    `$timestamp` to `$tsfile` using the `-t` flag to `touch` only *after* the backup
    has succeeded. Subtle, eh?
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script has a number of options, all of which can be ignored to perform
    the default incremental backup based on which files have been modified since the
    last time the script was run (that is, since the timestamp from the last incremental
    backup). Starting parameters allow you to specify a different output file or device
    (`-o output`), to choose a full backup (`-f`), to actively choose an incremental
    backup (`-i`) even though it is the default, or to prevent the timestamp file
    from being updated in the case of an incremental backup (`-n`).
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `backup` script requires no arguments and is simple to run, as [Listing
    6-17](ch06.xhtml#ch6ex17) details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-17: Running the* `*backup*` *script requires no arguments and prints
    the results to screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: As you would expect, the output of a backup program isn’t very scintillating.
    But the resulting compressed file is sufficiently large that it shows plenty of
    data is within, as you can see in [Listing 6-18](ch06.xhtml#ch6ex18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-18: Displaying the backed-up file with* `*ls*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**#52 Backing Up Directories**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Related to the task of backing up entire filesystems is the user-centric task
    of taking a snapshot of a specific directory or directory tree. The simple script
    in [Listing 6-19](ch06.xhtml#ch6ex19) allows users to create a compressed `tar`
    archive of a specified directory for archival or sharing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-19: The* `*archivedir*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script is almost all error-checking code, to ensure that it never causes
    a loss of data or creates an incorrect snapshot. In addition to using the typical
    tests to validate the presence and appropriateness of the starting argument, this
    script forces the user to be in the parent directory of the subdirectory to be
    compressed and archived, ensuring that the archive file is saved in the proper
    place upon completion. The test `if [ ! -w . ]` ➊ verifies that the user has write
    permission on the current directory. And this script even warns users before archiving
    if the resultant backup file would be unusually large.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the actual command that archives the specified directory is `tar` ➋.
    The return code of this command is tested to ensure that the script never deletes
    the directory if an error of any sort occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script should be invoked with the name of the desired directory to archive
    as its only argument. To ensure that the script doesn’t try to archive itself,
    it requires that a subdirectory of the current directory be specified as the argument,
    rather than `.`, as [Listing 6-20](ch06.xhtml#ch6ex20) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-20: Running the* `*archivedir*` *script on the* scripts *directory,
    but canceling*'
  prefs: []
  type: TYPE_NORMAL
- en: This seemed as though it might be a big archive, so we hesitated to create it,
    but after thinking about it, we decided there’s no reason not to proceed after
    all.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Here’s a tip for developers: when actively working on a project, use* `*archivedir*`
    *in a* `*cron*` *job to automatically take a snapshot of your working code each
    night for archival purposes.*'
  prefs: []
  type: TYPE_NORMAL
