- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 9 AGENT-BASED ALGORITHMS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9 基于智能体的算法
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/icon.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/icon.jpg)'
- en: 'In this chapter, we’ll continue to explore NIAs, focusing on two algorithms
    based on the collective behavior of social animals: particle swarm optimization
    and ant colony systems. These algorithms are designed for agent-based models,
    in which a swarm of simple agents work together and interact with their surroundings
    to create outcomes that benefit the whole colony.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续探讨NIAs，重点介绍两种基于社会动物集体行为的算法：粒子群优化算法和蚁群系统。这些算法设计用于基于智能体的模型，其中一群简单的智能体协作并与周围环境互动，从而创造出对整个群体有益的结果。
- en: We’ll explain the key concepts and principles behind these algorithms and implement
    them using pseudocode. We’ll also put these algorithms to the test by developing
    two Kotlin applications to solve real-world problems. The first is function minimization,
    which uses particle swarm optimization to find the global minimum of a given function.
    The second is the traveling salesman problem, which uses ant colony systems to
    find the shortest route that connects a large number of cities.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解释这些算法背后的关键概念和原理，并通过伪代码实现它们。我们还将通过开发两个Kotlin应用来测试这些算法，以解决现实世界的问题。第一个是函数最小化问题，它使用粒子群优化算法找到给定函数的全局最小值。第二个是旅行商问题，它使用蚁群系统寻找连接多个城市的最短路径。
- en: '### An Overview of Particle Swarm Optimization'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### 粒子群优化概述'
- en: The particle swarm optimization (PSO) algorithm has been used to solve a wide
    range of optimization problems. PSO has a few similarities with the genetic algorithm.
    Both methods involve working with a population (of chromosomes or particles),
    members of which help us look for an optimal solution until a stopping condition
    is met. Both methods are also stochastic and rely on underlying processes with
    built-in elements of randomness.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子群优化（PSO）算法已被广泛用于解决各种优化问题。PSO与遗传算法有一些相似之处。两者都涉及到一个种群（染色体或粒子），其成员共同寻找最佳解，直到满足停止条件。两者也都是随机算法，并依赖于具有内在随机性的过程。
- en: That’s where the similarities end. Unlike the genetic algorithm, the PSO algorithm
    does not depend on genetic operators such as selection, crossover, and mutation.
    Instead, it is driven by autonomous agents that update their positions in the
    decision space based on their current and past positions, as well as the best
    position identified by the swarm. PSO involves a deliberate effort to continuously
    move toward a better solution, which is very different from the passive selection-driven
    upgrading of chromosomes in the genetic algorithm. Individual chromosomes do not
    have any ability to sense their neighborhood or make decisions to update their
    composition as the particles do in PSO. Further, PSO is conceptually simpler and
    easier to implement, involves fewer parameters, and tends to converge more quickly
    on the global optima, compared with the genetic algorithm.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 相似之处到此为止。与遗传算法不同，PSO算法不依赖于遗传算子，如选择、交叉和变异。相反，它是由自主智能体驱动的，智能体根据当前位置、历史位置以及群体识别出的最佳位置更新它们在决策空间中的位置。PSO算法通过不断朝更好的解推进，进行有意识的努力，这与遗传算法中被动选择驱动的染色体升级截然不同。个体染色体没有感知其周围环境或做出决策来更新其组成的能力，而PSO中的粒子却具备这种能力。此外，PSO在概念上更简单，更容易实现，涉及的参数较少，并且相比遗传算法，通常能更快地收敛到全局最优解。
- en: 'At its core, the PSO algorithm consists of three key steps:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: PSO算法的核心包含三个关键步骤：
- en: 1.  Initialize the position and velocity of the particles.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  初始化粒子的位置信息和速度。
- en: 2.  Proceed through the time steps, and update particle velocities based on
    the current velocity, the best-so-far individual position, and the global best
    position identified by the swarm up to that time step.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  按照时间步长推进，并根据当前速度、最优个体位置和当前时刻由群体识别出的全局最优位置更新粒子的速度。
- en: 3.  Update the current position by moving to a better position.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  通过移动到更好的位置来更新当前位置。
- en: These steps are repeated for a set number of times or until a stopping condition
    is met.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤会重复执行若干次，或者直到满足停止条件。
- en: Let ***x***i⁰ and ***v***i⁰ be the position and velocity vectors at time *t*
    = 0, where *i* ∈ **I** denotes the *i*th particle in a swarm of size N (**I**
    = [1, 2, . . . , N]). Also, let ***x***max and ***x***min be the upper and lower
    bounds for the position vector and *r* be a random value between 0 and 1 selected
    from a uniform distribution.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 设***x***i⁰和***v***i⁰分别为在时间*t* = 0时的位置和速度向量，其中*i* ∈ **I**表示群体中第*i*个粒子，群体的大小为N（**I**
    = [1, 2, . . . , N]）。另外，设***x***max和***x***min分别为位置向量的上界和下界，*r*为从均匀分布中选择的介于0和1之间的随机值。
- en: The first step of PSO is to initialize the position and velocity vectors as
    shown in Equations 9.1 and 9.2.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: PSO的第一步是初始化位置和速度向量，如方程式9.1和9.2所示。
- en: $Equation$ (9.1)$Equation$ (9.2) ![](../images/eq9-1-2.jpg)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (9.1)$Equation$ (9.2) ![](../images/eq9-1-2.jpg)
- en: In Equation 9.2, for the purposes of this chapter, we set the initial velocities
    to zero. The alternative is to set them to small random values. In most cases,
    the swarm will quickly move away from the randomly assigned initial position,
    and the choice of initial velocity will not have a noticeable impact on the convergence
    rate as long as the magnitude of the velocity stays within the decision space.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在方程9.2中，出于本章的目的，我们将初始速度设置为零。另一种选择是将其设置为小的随机值。在大多数情况下，群体会迅速摆脱随机分配的初始位置，且只要速度的大小保持在决策空间内，初始速度的选择对收敛速率不会产生显著影响。
- en: 'The second step of PSO is to update the velocity vector $Equation$ ![](../images/pg347-in-1.jpg)
    for the particles by using the following equation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: PSO的第二步是通过使用以下方程来更新粒子的速度向量$Equation$ ![](../images/pg347-in-1.jpg)：
- en: $Equation$ (9.3) ![](../images/eq9-3.jpg)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (9.3) ![](../images/eq9-3.jpg)
- en: 'The variables and parameters in Equation 9.3 stand for the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 方程9.3中的变量和参数代表以下含义：
- en: '*w*             Inertia factor'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*w*            惯性因子'
- en: c1            Particle memory/cognitive factor
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: c1            粒子记忆/认知因子
- en: c2            Swarm memory/social factor
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: c2            群体记忆/社会因子
- en: r1, r2       Random values between 0 and 1 chosen from a uniform distribution
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: r1, r2       从均匀分布中选择的介于0和1之间的随机值
- en: $Equation$ ![](../images/pg347-in-2.jpg)            Best position vector found
    by particle *i* up to time *t*
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ ![](../images/pg347-in-2.jpg)            粒子*i*在时间*t*之前找到的最佳位置向量
- en: $Equation$ ![](../images/pg347-in-3.jpg)            Best position vector found
    by the swarm up to time *t*
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ ![](../images/pg347-in-3.jpg)            群体在时间*t*之前找到的最佳位置向量
- en: $Equation$ ![](../images/pg347-in-4.jpg) Velocity vectors of particle *i* at
    time *t* and *t* + 1, respectively
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ ![](../images/pg347-in-4.jpg) 粒子*i*在时间*t*和*t* + 1时的速度向量
- en: $Equation$ ![](../images/pg347-in-5.jpg)            Position vector of particle
    *i* at time *t*
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ ![](../images/pg347-in-5.jpg)            粒子*i*在时间*t*的当前位置向量
- en: '[Figure 9-1](chapter9.xhtml#fig9-1) provides a visual and more intuitive interpretation
    of Equation 9.3.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-1](chapter9.xhtml#fig9-1)提供了方程9.3的视觉和更直观的解释。'
- en: '![](../images/Figure9-1.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-1.jpg)'
- en: 'Figure 9-1: A graphical representation of the strategy for updating velocity
    in PSO'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-1：更新速度策略在PSO中的图示表示
- en: Let’s consider an arbitrary particle *i* whose current position is $Equation$
    ![](../images/pg347-in-6.jpg) (for simplicity’s sake, we’ll consider a one-dimensional
    problem). Because of inertia, the particle will tend to move toward the direction
    of its current velocity, $Equation$ ![](../images/pg347-in-7.jpg). However, PSO
    relies on learning from both particle- and swarm-level best solutions found so
    far—$Equation$ ![](../images/pg347-in-8.jpg) and $Equation$ ![](../images/pg347-in-9.jpg).
    As a result, the particle incorporates this information by moving a bit toward
    $Equation$ ![](../images/pg347-in-10.jpg) ❶ and then toward $Equation$ ![](../images/pg347-in-11.jpg)
    ❷, as well as toward its own velocity $Equation$ ![](../images/pg347-in-12.jpg)
    ❸. [Figure 9-1](chapter9.xhtml#fig9-1) shows the result of all these movements
    as $Equation$ ![](../images/pg347-in-13.jpg). Equation 9.3 captures the same movements
    symbolically in multiple dimensions, along with the relative weights assigned
    to each of these components.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个任意粒子 *i*，其当前的位置为 $方程$ ![](../images/pg347-in-6.jpg)（为了简化，我们考虑一个一维问题）。由于惯性，粒子会倾向于朝着当前速度的方向运动，$方程$
    ![](../images/pg347-in-7.jpg)。然而，PSO 依赖于从粒子级别和群体级别的最佳解中学习—$方程$ ![](../images/pg347-in-8.jpg)
    和 $方程$ ![](../images/pg347-in-9.jpg)。因此，粒子通过稍微朝着 $方程$ ![](../images/pg347-in-10.jpg)
    ❶ 移动，然后朝着 $方程$ ![](../images/pg347-in-11.jpg) ❷ 移动，同时朝着它自己的速度 $方程$ ![](../images/pg347-in-12.jpg)
    ❸ 移动。[图 9-1](chapter9.xhtml#fig9-1) 显示了这些所有运动的结果，如 $方程$ ![](../images/pg347-in-13.jpg)
    所示。方程 9.3 用符号表示了这些在多个维度上的运动，并结合了分配给这些组件的相对权重。
- en: The inertia factor *w* is typically assigned a value between 0 and 1, where
    a value of 0 would imply no impact of $Equation$ ![](../images/pg347-in-14.jpg)
    on $Equation$ ![](../images/pg347-in-15.jpg) and 1 would imply full impact. It
    is also possible to adjust the value of *w* over time, which can lead to better
    convergence properties. This scheme is implemented by initially setting *w* to
    ≥ 1 and gradually decreasing it per Equation 9.4.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 惯性因子 *w* 通常赋值在 0 到 1 之间，其中 0 表示 $方程$ ![](../images/pg347-in-14.jpg) 对 $方程$ ![](../images/pg347-in-15.jpg)
    没有影响，而 1 表示完全影响。也可以随着时间的推移调整 *w* 的值，这可能会导致更好的收敛性能。此方案通过将 *w* 初始设置为 ≥ 1，并按方程 9.4
    逐渐减小来实现。
- en: $Equation$ (9.4) ![](../images/eq9-4.jpg)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: $方程$ (9.4) ![](../images/eq9-4.jpg)
- en: The c1 and c2 factors in Equation 9.3 are also called *acceleration coefficients*.
    Along with the random variables r1 and r2, these coefficients determine the degree
    of influence of the particle-best and swarm-best positions on the updated velocity
    of a particle.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 方程 9.3 中的 c1 和 c2 系数也被称为*加速度系数*。与随机变量 r1 和 r2 一起，这些系数决定了粒子最佳位置和群体最佳位置对粒子更新速度的影响程度。
- en: As is evident from Equation 9.3, when both c1 and c2 = 0, particles will keep
    moving at constant velocities until they hit the boundaries of the decision space.
    If c1 > 0 and c2 = 0, particles will behave as if they’re independent (no information
    gathered from the swarm). When c1 = 0 and c2 > 0, the entire swarm will move toward
    the best position found collectively so far.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从方程 9.3 可以看出，当 c1 和 c2 都为 0 时，粒子将保持恒定速度运动，直到撞击决策空间的边界。如果 c1 > 0 且 c2 = 0，粒子将表现得像是独立的（没有从群体中获取信息）。当
    c1 = 0 且 c2 > 0 时，整个群体将朝着迄今为止共同找到的最佳位置移动。
- en: 'While the optimal values for these parameters are likely to be problem specific,
    the commonly used values found in the literature range from 0.5 to 2.5 for both
    c1 and c2\. It is also common practice to keep c1 equal to c2 and ensure both
    values are relatively small to allow for a thorough exploration of the decision
    space without causing *velocity explosion*, which refers to excessive velocity
    and large jumps across the decision space. To avoid this, an upper limit for the
    velocity of particle *i* along dimension *j* is set as follows (for all time steps):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些参数的最优值可能与具体问题相关，但文献中常用的 c1 和 c2 的值通常在 0.5 到 2.5 之间。通常做法是将 c1 设置为等于 c2，并确保这两个值相对较小，以便能够充分探索决策空间，而不至于造成*速度爆炸*，即速度过大，导致在决策空间中大幅跳跃。为了避免这种情况，粒子
    *i* 在第 *j* 维度上的速度上限设置如下（适用于所有时间步）：
- en: $Equation$ (9.5) ![](../images/eq9-5.jpg)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: $方程$ (9.5) ![](../images/eq9-5.jpg)
- en: where
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: $Equation$ (9.6) ![](../images/eq9-6.jpg)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: $方程$ (9.6) ![](../images/eq9-6.jpg)
- en: 'The final step for PSO is to update the position vector of particle *i* for
    the next time step *t* + 1 as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: PSO 的最后一步是更新粒子 *i* 在下一个时间步 *t* + 1 的位置向量，如下所示：
- en: $Equation$ (9.7) ![](../images/eq9-7.jpg)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: $方程$ (9.7) ![](../images/eq9-7.jpg)
- en: As with velocities, the updated position vectors will also have to be checked
    against the specified bounds for the decision variables.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与速度一样，更新后的位移向量也必须与决策变量的指定边界进行比较。
- en: Implementing PSO for Function Minimization
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现PSO进行函数最小化
- en: We can use the PSO algorithm to either maximize or minimize a function. In this
    chapter, we’ll apply PSO to function minimization. Consequently, when aiming to
    minimize a multivariate function by using this implementation, we don’t need to
    multiply the objective function value by –1, as we did for function minimization
    in [Chapter 8](chapter8.xhtml).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用PSO算法来最大化或最小化一个函数。在本章中，我们将应用PSO进行函数最小化。因此，当我们使用此实现来最小化一个多变量函数时，我们无需像在[第8章](chapter8.xhtml)中进行函数最小化时那样将目标函数值乘以-1。
- en: In contrast to the other algorithms covered in this book, the PSO algorithm
    involves more interlinked steps, which makes it difficult to understand and code
    the algorithm without a thorough overview of the entire process. To address this,
    I’ll provide pseudocode outlining the entire process to guide us through actual
    code development. *Pseudocode* is a high-level description of an algorithm or
    a computer program. It’s written in plain language that closely resembles the
    structure of a programming language, but it is not meant to be executed on a computer.
    It allows programmers to plan out and communicate the logic of a program without
    getting bogged down in the details of a specific programming language.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中介绍的其他算法不同，PSO算法涉及更多互相关联的步骤，这使得在没有对整个过程的透彻了解的情况下理解和编码算法变得困难。为了解决这个问题，我将提供一个概述整个过程的伪代码，以指导我们进行实际代码开发。*伪代码*是算法或计算机程序的高级描述。它采用接近编程语言结构的自然语言编写，但并不是为了在计算机上执行。它允许程序员在不被特定编程语言细节困扰的情况下规划和沟通程序的逻辑。
- en: Here’s the pseudocode for the PSO algorithm. Notice that we’ve used boldface
    to mark where loops and conditional blocks begin and end, as well as to emphasize
    specific tasks carried out by code segments.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是PSO算法的伪代码。请注意，我们使用粗体标记了循环和条件块的开始和结束，并强调了代码段执行的特定任务。
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ll follow this pseudocode closely as we develop the code for implementing
    the PSO algorithm in the next project.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一项目中，我们将在开发实现PSO算法的代码时严格按照这个伪代码进行。
- en: 'Project 36: Optimize a Multivariate Function with a Particle Swarm'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 项目36：使用粒子群优化多变量函数
- en: For this project, we’ll revisit the Eggholder function optimization problem
    defined in [Chapter 8](chapter8.xhtml), this time solving it with the PSO algorithm
    rather than with the genetic algorithm.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本项目，我们将重新审视在[第8章](chapter8.xhtml)中定义的Eggholder函数优化问题，这次我们将使用PSO算法来解决它，而不是使用遗传算法。
- en: The Code
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: 'We’ll develop the code for the PSO algorithm following the pseudocode provided
    earlier and discuss its implementation in four segments: problem definition and
    global parameters, initializing the swarm, the runPSO() driver function, and the
    main() function.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照先前提供的伪代码开发PSO算法的代码，并在四个部分中讨论其实现：问题定义与全局参数、初始化粒子群、runPSO()驱动函数和main()函数。
- en: Problem Definition and Global Parameters
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题定义与全局参数
- en: This segment is composed of an import block, a collection of classes, global
    variables and parameters, and lists to save particle states and best solutions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分由一个导入块、一个类集合、全局变量和参数、以及用于保存粒子状态和最佳解的列表组成。
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first block in the code snippet imports a number of math functions from
    the standard Kotlin library. The next two blocks define the data classes used
    for this project. The Solution() class is used to store particle-best and swarm-best
    solutions ❶. The Particle() class is the primary class that is used to create
    a swarm ❷. Each particle has an identification number (id), position and velocity
    vectors (pos and vel), a fitness property, and a Solution property. The latter
    is used to store information on the best solution identified by the particle up
    to a certain point in time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段中的第一块导入了多个来自标准Kotlin库的数学函数。接下来的两块定义了用于本项目的数据类。Solution()类用于存储粒子最优解和粒子群最优解
    ❶。Particle()类是用于创建粒子群的主要类 ❷。每个粒子都有一个标识符（id），位置和速度向量（pos和vel），一个适应度属性，以及一个Solution属性。后者用于存储粒子在某一时刻识别出的最佳解的信息。
- en: The next code block defines the eggHolder function ❸ and its dimensions in nDim
    (equal to 2 for the Eggholder function). It also defines the bounds and ranges
    for pos and vel and then defines vMax per Equation 9.5 to ensure that updated
    velocities remain within the set bounds.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码块定义了eggHolder函数❸及其在nDim中的维度（对于EggHolder函数，nDim等于2）。它还定义了pos和vel的边界和范围，然后根据公式9.5定义了vMax，以确保更新后的速度保持在设定的边界内。
- en: The final code block defines PSO-specific global parameters. Currently, the
    maximum number of time steps (iterations) is set to 50, and the swarm size is
    set to 30\. We’ll also dynamically adjust the inertia factor *w* per Equation
    9.4 for which wmax and wmin have been set to 1.2 and 0.5, respectively. The cognitive
    and social factors c1 and c2 have been set to 2.0\. These parameter values were
    chosen based on the recommendations found in the relevant literature.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的代码块定义了PSO特定的全局参数。目前，最大时间步数（迭代次数）设置为50，群体大小设置为30。我们还将根据公式9.4动态调整惯性因子*w*，其中wmax和wmin分别设置为1.2和0.5。认知因子和社会因子c1和c2已设置为2.0。这些参数值是根据相关文献中的推荐值选择的。
- en: The code block ends by creating a mutable list (swarm) and initializing BestSolution,
    which we’ll use to store the swarm-best solution. Since we’re framing the problem
    as a minimization problem, the fitness value of the BestSolution has been set
    to Double.MAX_VALUE, which is the maximum possible of type Double.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块的结尾创建了一个可变列表（swarm）并初始化了BestSolution，我们将用它来存储群体最佳解。由于我们将问题框定为一个最小化问题，因此BestSolution的适应度值已被设置为Double.MAX_VALUE，这是Double类型的最大可能值。
- en: Initializing the Swarm
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 初始化群体
- en: The initSwarm() function is responsible for initializing the PSO algorithm by
    creating and initializing individual particles and adding them to the collection
    of particles (the swarm).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: initSwarm()函数负责通过创建和初始化个体粒子并将其添加到粒子集合（群体）中，从而初始化PSO算法。
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The function begins by printing a message indicating the start of the initialization
    process. It then iterates using a for loop over a specified swarm size (SWARMSIZE)
    ❶, creating individual particles with random initial positions within predefined
    bounds for each dimension ❷. The initial velocities for each particle are set
    to zero, per Equation 9.2.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 函数开始时打印一条消息，表示初始化过程的开始。然后，它使用for循环迭代指定的群体大小（SWARMSIZE）❶，为每个粒子创建具有预定义维度边界的随机初始位置❷。每个粒子的初始速度根据公式9.2设置为零。
- en: The getFitness function allows us to calculate the fitness value for each particle
    ❸. Notice that during initialization, the personal best fitness is the same as
    its current fitness, meaning that pBest initially has the same position and fitness
    as the particle. These particles are characterized by identification number (id),
    position (pos) and velocity (vel) vectors, a fitness value (fitness), and a personal
    best solution (pBest). We use these attributes to create the particles and add
    them to the swarm ❹.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: getFitness函数使我们能够计算每个粒子的适应度值❸。注意，在初始化过程中，个人最佳适应度与当前适应度相同，这意味着pBest最初与粒子的当前位置和适应度相同。这些粒子由标识号（id）、位置（pos）和速度（vel）向量、适应度值（fitness）以及个人最佳解（pBest）来表征。我们使用这些属性来创建粒子并将它们添加到群体中❹。
- en: The best solution across the entire swarm is updated if a particle’s fitness
    is better than the current best ❺. After initialization, the function prints the
    best solution.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个粒子的适应度比当前最佳适应度更好，则整个群体中的最佳解会被更新❺。初始化后，函数会打印出最佳解。
- en: The Driver Function
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 驱动函数
- en: The code block for the runPSO() driver function carries out all the core tasks
    of PSO, including updating the velocity and position vectors and tracking the
    personal- and swarm-level best solutions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: runPSO()驱动函数的代码块执行PSO的所有核心任务，包括更新速度和位置向量，并跟踪个人和群体的最佳解。
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Unlike the runGA() function for implementing the genetic algorithm, the runPSO()
    function is self-sufficient and doesn’t rely on any helper functions other than
    getFitness(), which simply calculates the value of the function being minimized.
    It iterates over a fixed number of time steps (TMAX) ❶, beginning each iteration
    by initializing the inertia factor (w) and the random factors r1 and r2.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与实现遗传算法的runGA()函数不同，runPSO()函数是自给自足的，除了getFitness()函数外，不依赖任何其他辅助函数，getFitness()仅用于计算被最小化的函数值。它会迭代固定的时间步数（TMAX）❶，每次迭代开始时，初始化惯性因子（w）以及随机因子r1和r2。
- en: For each time step, the code loops over each particle in the swarm ❷ and updates
    its velocity and position vectors according to the PSO formula. The code also
    implements bounds for the velocity and position values, using the minimum and
    maximum values defined in the arrays vMax and xBbounds.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个时间步，代码遍历群体中的每个粒子❷，并根据PSO公式更新其速度和位置向量。代码还实现了速度和位置值的边界，使用数组vMax和xBbounds中定义的最小值和最大值。
- en: The code evaluates the fitness of each particle by using the getFitness() function
    ❸, which takes the position vector as an input and returns the corresponding fitness
    as a scalar value.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过使用getFitness()函数❸来评估每个粒子的适应度，该函数以位置向量作为输入，并返回相应的适应度标量值。
- en: The code then compares each particle’s current fitness with its personal best
    fitness (pBest) and updates the latter if the former is lower ❹. It also compares
    the current fitness with the global best fitness (BestSolution) and updates the
    latter if the former is lower ❺. The personal and global best solutions store
    both the position and the fitness values.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将每个粒子的当前适应度与其个人最佳适应度（pBest）进行比较，如果当前适应度较低，则更新后者❹。它还将当前适应度与全局最佳适应度（BestSolution）进行比较，如果当前适应度较低，则更新后者❺。个人和全局最佳解都存储位置和适应度值。
- en: The function terminates when it completes TMAX iterations. It doesn’t return
    anything, since the best overall solution is saved as the global object BestSolution.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数在完成TMAX次迭代后终止。它不返回任何值，因为最佳整体解作为全局对象BestSolution保存。
- en: The main() Function
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: main()函数
- en: This function is a short code block that prints values of key global parameters,
    calls other functions to initialize the swarm and run the PSO driver function,
    and prints the best solution found.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是一个简短的代码块，打印关键全局参数的值，调用其他函数初始化群体并运行PSO驱动函数，并打印找到的最佳解。
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The main() function is the entry point of the program that uses PSO to perform
    real-valued function optimization. It prints some information about the problem
    parameters, such as the function dimensions, the swarm size, the maximum time
    steps, and the PSO coefficients.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: main()函数是程序的入口点，使用PSO执行实值函数优化。它会打印一些关于问题参数的信息，如函数维度、群体大小、最大时间步数和PSO系数。
- en: The function then calls two other functions, initSwarm() and runPSO(). The first
    function initializes the swarm of particles with random positions and velocities
    and evaluates their initial fitness values. The second function runs the PSO algorithm
    for a fixed number of iterations, updating the particles’ velocities, positions,
    and fitness values, as well as the personal and global best solutions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数随后调用两个其他函数，initSwarm()和runPSO()。第一个函数初始化粒子群，赋予随机的位置和速度，并评估它们的初始适应度值。第二个函数在固定的迭代次数内运行PSO算法，更新粒子的速度、位置和适应度值，以及个人和全局最佳解。
- en: The main() function finally prints the best solution found by the PSO algorithm
    after the specified number of iterations, showing both the position vector and
    the fitness value of the global best solution.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: main()函数最终打印出PSO算法在指定迭代次数后找到的最佳解，显示全局最佳解的位置向量和适应度值。
- en: The Result
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: 'I’ve deliberately kept the output of the PSO program brief and to the point.
    By now, you should be comfortable with writing your own additional lines of code
    to print or save other intermediate results for further analysis or visualization.
    If you run the code with the same parameters used in this example, the output
    might look like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意保持PSO程序的输出简洁明了。现在，你应该已经能够编写自己的额外代码行，用于打印或保存其他中间结果，以便进一步分析或可视化。如果你使用与本示例中相同的参数运行代码，输出可能如下所示：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first segment of the output shows the values of key global parameters. Next,
    it shows the best solutions at the start and the end of the iterations. The PSO
    algorithm achieved a near-optimal solution for the Eggholder function within the
    given decision space, matching the result obtained by the genetic algorithm in
    [Chapter 8](chapter8.xhtml).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一部分显示了关键全局参数的值。接下来，显示了迭代开始和结束时的最佳解。PSO算法在给定的决策空间内为Eggholder函数实现了近似最优解，这一结果与在[第8章](chapter8.xhtml)中通过遗传算法获得的结果相匹配。
- en: '[Figure 9-2](chapter9.xhtml#fig9-2) shows the convergence behavior of the PSO
    algorithm over time when applied to the Eggholder function. Unlike the genetic
    algorithm discussed in [Chapter 8](chapter8.xhtml), PSO achieves optimal solutions
    more rapidly, requiring fewer iterations.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-2](chapter9.xhtml#fig9-2)显示了PSO算法在应用于Eggholder函数时随时间变化的收敛行为。与[第8章](chapter8.xhtml)中讨论的遗传算法不同，PSO能够更快速地达到最优解，所需的迭代次数更少。'
- en: '![](../images/Figure9-2.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-2.jpg)'
- en: 'Figure 9-2: The convergence pattern for the Eggholder function, using the particle
    swarm algorithm'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-2：使用粒子群算法对Eggholder函数的收敛模式
- en: PSO seems to have an advantage over the genetic algorithm for this problem.
    Though the PSO algorithm had a worse initial global best fitness value of around
    –742, compared to –810 for the genetic algorithm, it reached the global optimum
    in about 40 iterations, while the genetic algorithm took 117 iterations. This
    suggests that the PSO algorithm can explore and exploit the search space more
    efficiently than the genetic algorithm for the Eggholder function. This efficiency
    likely stems from PSO’s unique approach to exploring the solution space through
    collaborative particle interactions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: PSO在这个问题上似乎比遗传算法更具优势。尽管PSO算法的初始全局最佳适应度值约为-742，相比之下，遗传算法为-810，但它在大约40次迭代后达到了全局最优解，而遗传算法则需要117次迭代。这表明，PSO算法能够比遗传算法更高效地探索和利用搜索空间，特别是在求解Eggholder函数时。这种高效性可能源自PSO通过粒子间的协作交互来探索解空间的独特方法。
- en: I encourage you to use this code to solve other known test problems and further
    investigate how the PSO algorithm performs vis-à-vis the genetic algorithm.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你使用这段代码来解决其他已知的测试问题，并进一步研究PSO算法与遗传算法的表现对比。
- en: Ant Colony Optimization
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蚁群优化
- en: Ant colony optimization (ACO) refers to a family of algorithms that are based
    on lessons learned from real-world ants, especially from their foraging behavior.
    The original algorithm, known as the ant system (AS), was proposed by Marco Dorigo
    in 1992\. Since then, the algorithm has been modified several times to help it
    more effectively solve a class of problems that requires finding the least-cost
    tour through all nodes of a weighted graph. In discrete mathematics, a graph is
    a set of nodes or vertices that are related, and the imaginary or real line connecting
    a pair of nodes is called an *edge*. (You can revisit [Chapter 7](chapter7.xhtml)
    for a review of graphs and conventional graph-search algorithms.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 蚁群优化（ACO）指的是一类基于真实蚂蚁行为，尤其是觅食行为的启发式算法。最初的算法，称为蚁群系统（AS），由Marco Dorigo于1992年提出。从那时起，该算法经过多次修改，以帮助其更有效地解决需要在加权图的所有节点之间寻找最小成本路径的问题。在离散数学中，图是由一组相关节点或顶点组成的，而连接一对节点的虚拟或实际线条称为*边*。（你可以回顾[第7章](chapter7.xhtml)，了解图和传统的图搜索算法。）
- en: To demonstrate the basic concept of ACO, let’s review the simple illustration
    in [Figure 9-3](chapter9.xhtml#fig9-3) of ants exploring the best paths to a source
    of food.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示ACO的基本概念，让我们回顾一下[图9-3](chapter9.xhtml#fig9-3)中蚂蚁探索最佳食物路径的简单示意图。
- en: '![](../images/Figure9-3.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-3.jpg)'
- en: 'Figure 9-3: Ants exploring different trails leading to the food source'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-3：蚂蚁探索通向食物源的不同路径
- en: When ants start looking for a food source, they initially disperse randomly
    in all directions, as shown in [Figure 9-3(a)](chapter9.xhtml#fig9-3). As they
    move, they lay down a scent (pheromone) to mark their trails. Once an ant finds
    a food source, it picks up a piece of food and brings that back to the nest by
    following its scent mark. It also lays down more pheromones as it returns to the
    nest.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当蚂蚁开始寻找食物源时，它们最初会随机分散向各个方向，如[图9-3(a)](chapter9.xhtml#fig9-3)所示。它们在移动时会留下气味（信息素）来标记它们的路径。一旦蚂蚁找到食物源，它会捡起一块食物并沿着气味标记带回巢穴。在返回巢穴的过程中，它还会留下更多的信息素。
- en: In the meantime, other ants notice the trail. Given more than one source, each
    trail will develop a scent mark of greater or lesser intensity, depending on how
    many ants are traveling back and forth along that trail and how far the source
    is from the nest. In general, the stronger the scent mark of a trail, the greater
    the number of ants following that trail will be. Once a food source is found,
    ants will therefore follow the most well-defined trails, as shown in [Figure 9-3(b)](chapter9.xhtml#fig9-3).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，其他蚂蚁注意到这条轨迹。给定多个源，每条轨迹将发展出不同强度的气味标记，这取决于有多少蚂蚁在这条轨迹上来回穿梭，以及源与巢穴的距离有多远。通常情况下，轨迹的气味标记越强，跟随该轨迹的蚂蚁数量就越多。一旦找到食物源，蚂蚁便会沿着最明确的轨迹前进，如[图
    9-3(b)](chapter9.xhtml#fig9-3)所示。
- en: Crucially, pheromones are not permanent—they tend to decay or evaporate over
    time. If a trail is not frequently visited, it gradually becomes less traceable
    and eventually is forgotten. Additionally, the closest food source will take the
    least amount of time to visit, which means the corresponding trail will be traveled
    more frequently, which will result in a stronger concentration of pheromone—which
    will create a positive feedback loop and attract even more ants to choose the
    shortest route. Over time, most of the ants will start to use this shortest route
    (the optimal path), as shown in [Figure 9-3(c)](chapter9.xhtml#fig9-3). The ant
    colony will have used a very simple rule to solve a very difficult combinatorial
    optimization problem!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于，信息素不是永久的——它们会随着时间的推移而衰减或蒸发。如果一条轨迹不经常被访问，它会逐渐变得不那么显眼，最终被遗忘。此外，离得最近的食物源所需的访问时间最少，这意味着相应的轨迹将被更频繁地走过，从而导致信息素浓度更强——这将创造出一个正反馈循环，吸引更多的蚂蚁选择最短的路径。随着时间的推移，大多数蚂蚁将开始使用这条最短的路径（最优路径），如[图
    9-3(c)](chapter9.xhtml#fig9-3)所示。蚁群通过一个非常简单的规则解决了一个非常复杂的组合优化问题！
- en: In this ingenious natural scheme, individual agents (ants) do not have any idea
    about the impact of their actions on the entire colony. And yet by repeating their
    simple routine, they enable the colony to find its food sources as efficiently
    as if the whole search process were centrally coordinated.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个巧妙的自然方案中，个体代理（蚂蚁）并不了解它们的行动对整个蚁群的影响。然而，通过不断重复它们的简单日常行为，它们使蚁群能够以一种类似于中央协调的方式高效地寻找食物源。
- en: '#### The ACS Algorithm'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ACS算法'
- en: Based on the conceptual model presented in the previous section, we can envision
    the key components of ACO as creating a colony of artificial ants, moving ants
    from one node to the next based on pheromone intensity and the distance between
    the nodes, and updating the pheromone trails until the shortest route is found.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前一节中提出的概念模型，我们可以设想ACO的关键组成部分是：创建一个人工蚂蚁群体，根据信息素浓度和节点之间的距离，将蚂蚁从一个节点移动到另一个节点，并不断更新信息素轨迹，直到找到最短路径。
- en: 'In this chapter, we’ll explore an enhanced version of ACO called the ant colony
    system (ACS). The ACS algorithm is implemented in three key steps: constructing
    a tour, updating a local pheromone trail, and updating a global pheromone trail.
    We’ll discuss each of these steps in detail shortly.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一种增强版的蚁群优化算法，称为蚁群系统（ACS）。ACS算法通过三个关键步骤实现：构建路径、更新局部信息素轨迹和更新全局信息素轨迹。我们将很快详细讨论这每一个步骤。
- en: We’ll use the ACS algorithm to solve a particular case of the traveling salesman
    problem (TSP), which belongs to a class of hard-to-solve problems called the NP-hard
    problems. Mathematically speaking, a problem is *NP-hard* if it is at least as
    hard as the hardest problem in NP, a class of problems for which a solution can
    be verified in polynomial time. It is beyond the scope of this book to discuss
    the NP-hard problems further; instead, we will focus on how to use ACS to solve
    TSPs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用ACS算法来解决一个特定的旅行商问题（TSP），它属于一类难以解决的问题，称为NP难问题。从数学角度讲，一个问题是*NP难*的，如果它至少和NP中最难的问题一样难，NP类问题的解决方案可以在多项式时间内验证。讨论NP难问题超出了本书的范围；我们将专注于如何使用ACS来解决TSP。
- en: 'Solving a TSP entails answering the following question:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 解决TSP问题意味着要回答以下问题：
- en: Given a list of nodes and the distances between every pair of those nodes, what
    is the shortest possible route a traveler can take that passes through each node
    exactly once and brings the traveler back to the start node?
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定一组节点和每一对节点之间的距离，旅行者经过每个节点一次且仅一次，最终返回起始节点，最短的可能路径是什么？
- en: In other words, we’re looking for a closed-loop solution that goes through each
    node and has the shortest possible length. Notice that it is theoretically possible
    for multiple routes to have the same shortest length of travel.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们在寻找一个封闭路径解，它经过每个节点，并且具有最短的可能长度。请注意，从理论上讲，多个路径可能具有相同的最短旅行长度。
- en: 'We’ll make two additional assumptions regarding the form of TSP we’ll try to
    solve:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对我们尝试解决的TSP问题做出两个额外的假设：
- en: The network of nodes (graph) is fully connected, meaning a traveler can visit
    from any particular node to all other remaining nodes (during implementation,
    we’ll exclude the nodes that have already been visited).
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络节点（图）是完全连接的，这意味着旅行者可以从任意特定节点访问所有其他剩余节点（在实现过程中，我们将排除已经访问过的节点）。
- en: The distance between any pair of nodes is symmetric, meaning the distance does
    not change with the direction of travel (a pair of nodes are connected by a single,
    unique path—an edge).
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任意一对节点之间的距离是对称的，这意味着距离与旅行方向无关（一对节点通过一条唯一的路径—即一条边—连接）。
- en: Symbols and Their Meanings
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 符号及其含义
- en: ACS is a fairly complex algorithm with many parameters and variables, listed
    in [Table 9-1](chapter9.xhtml#tab9-1) along with the symbols used to represent
    them.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ACS是一个相当复杂的算法，具有许多参数和变量，列在[表9-1](chapter9.xhtml#tab9-1)中，并附有用于表示它们的符号。
- en: 'Table 9-1: Symbols Used in the ACS Algorithm'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 表9-1：ACS算法中使用的符号
- en: '| Symbol | Interpretation |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 解释 |'
- en: '| --- | --- |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ![](../images/pg358-in-1.jpg) | The neighborhood of ant k when it is at node
    i; it is a set of nodes that an ant is allowed to visit given its current location.
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| ![](../images/pg358-in-1.jpg) | 蚂蚁k在节点i时的邻域；它是一组蚂蚁在当前位置允许访问的节点。 |'
- en: '| τij | The pheromone intensity of edge [i, j] connecting node i to node j.
    |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| τij | 连接节点i和节点j的边[i, j]的信息素强度。 |'
- en: '| τ0 | Initial pheromone level for all edges, set to 1/(nCnn); n is the total
    number of nodes in the nearest-neighbor tour and Cnn is the tour length. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| τ0 | 所有边的初始信息素水平，设置为1/(nCnn)；n是最近邻路径中的节点总数，Cnn是路径长度。 |'
- en: '| dij | The length of the edge from node i to node j (distance between these
    nodes). Also, dij = dji. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| dij | 从节点i到节点j的边的长度（这两个节点之间的距离）。同时，dij = dji。 |'
- en: '| ηij | Heuristic information defined as 1/dij. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| ηij | 启发式信息，定义为1/dij。 |'
- en: '| α | Parameter, set to 1 for ACS. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| α | 参数，ACS中设置为1。 |'
- en: '| ß | Parameter [2.0–5.0], used as the exponent of η. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| ß | 参数[2.0–5.0]，用于η的指数。 |'
- en: '| q | A uniformly distributed random variable in [0, 1]. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| q | 在[0, 1]区间内均匀分布的随机变量。 |'
- en: '| q0 | A parameter in (0, 1); an ant explores the learned knowledge based on
    the intensity of pheromone trails and heuristics when q ≤ q0. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| q0 | 范围在(0, 1)之间的参数；当q ≤ q0时，蚂蚁基于信息素轨迹的强度和启发式进行知识探索。 |'
- en: '| pij | The normalized probability for choosing edge [i, j] during roulette
    wheel selection if q > q0. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| pij | 在轮盘选择中，若q > q0时，选择边[i, j]的标准化概率。 |'
- en: '| ζ | Parameter, set to a small value such as 0.005; used as the weighting
    factor for updating the local pheromone trail. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| ζ | 参数，设置为如0.005这样的小值；用于更新局部信息素轨迹的加权因子。 |'
- en: '| ρ | Parameter, set to the recommended value of 0.1 for ACS; used as the weighting
    factor for updating the best-so-far global pheromone trail. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| ρ | 参数，ACS中设置为推荐值0.1；用于更新最优全局信息素轨迹的加权因子。 |'
- en: '| Cnn | Tour length for the nearest-neighbor tour used for estimating initial
    pheromone concentration. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| Cnn | 用于估算初始信息素浓度的最近邻路径的路径长度。 |'
- en: '| Cbs | Tour length for the best-so-far solution or tour. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| Cbs | 目前为止最优解或路径的路径长度。 |'
- en: '| T bs | The best-so-far tour (collection of edges that constitute the tour).
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| T bs | 目前为止最优的路径（构成路径的边集合）。 |'
- en: In addition to listing the parameters and variables, [Table 9-1](chapter9.xhtml#tab9-1)
    also provides short descriptions of those elements. (You may need to revisit these
    descriptions as you read the rest of this section.)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 除了列出参数和变量，[表9-1](chapter9.xhtml#tab9-1)还提供了这些元素的简短描述。（在阅读本节其余部分时，您可能需要回过头来查看这些描述。）
- en: The Steps of ACS
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ACS的步骤
- en: 'In this section, we’ll explore the key steps of the ACS algorithm, expressed
    mathematically. This will include three steps: tour construction, updating the
    local pheromone trail, and updating the global pheromone trail.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索ACS算法的关键步骤，以数学形式表达。这将包括三个步骤：路径构建、更新局部信息素轨迹，以及更新全局信息素轨迹。
- en: 'Step 1: Tour Construction'
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 步骤1：路径构建
- en: The first step of ACS entails applying a pseudorandom proportional rule used
    by an ant to choose its next location *j* given its current location *i*, defined
    in Equation 9.8.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ACS 的第一步是应用一个伪随机比例规则，蚂蚁根据当前的位置 *i* 来选择它的下一个位置 *j*，该规则在公式 9.8 中定义。
- en: $Equation$ (9.8) ![](../images/eq9-8.jpg)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: $公式$ (9.8) ![](../images/eq9-8.jpg)
- en: The *argmax* function in Equation 9.8 chooses an argument *l* from the feasible
    set of nodes that can be visited from node *i*, for which the expression inside
    the curly brackets is maximized. This value of *l* is set to *j* as the next destination
    for the ant provided *q* ≤ *q*[0]. The parameter *q*[0] allows us to control the
    degree to which learned knowledge (pheromone trails and heuristics) is prioritized
    over random exploration of new routes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 公式 9.8 中的 *argmax* 函数从可以从节点 *i* 访问的可行节点集合中选择一个参数 *l*，使得大括号内的表达式最大化。当 *q* ≤ *q*[0]
    时，这个 *l* 的值被设置为 *j*，作为蚂蚁的下一个目标。参数 *q*[0] 允许我们控制已学习的知识（信息素轨迹和启发式）与对新路径的随机探索之间的优先级。
- en: 'When *q* > *q*[0], the next node *j* is set to *J*, which is a random variable
    selected using a roulette wheel scheme. Equation 9.9 estimates the normalized
    probabilities for the feasible paths from node *i* to node *j* for ant *k*:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *q* > *q*[0] 时，下一个节点 *j* 将设置为 *J*，它是通过轮盘赌选择法随机选择的变量。公式 9.9 估计了蚂蚁 *k* 从节点 *i*
    到节点 *j* 的可行路径的标准化概率：
- en: $Equation$ (9.9) ![](../images/eq9-9.jpg)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: $公式$ (9.9) ![](../images/eq9-9.jpg)
- en: For a refresher on the roulette wheel scheme, please review “Selection” on [page
    312](chapter8.xhtml#pg_312) in [Chapter 8](chapter8.xhtml). This time, we’ll implement
    the scheme in our final coding project.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如需回顾轮盘赌选择法，请查阅 [第 312 页](chapter8.xhtml#pg_312)中的“选择”部分，在[第 8 章](chapter8.xhtml)中。此次，我们将在最终的编码项目中实现该方案。
- en: 'Step 2: Updating the Local Pheromone Trail'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 步骤 2：更新局部信息素轨迹
- en: As soon as an ant moves from node *i* to node *j*, the weighted average scheme
    in Equation 9.10 is applied to update the local pheromone trail.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦蚂蚁从节点 *i* 移动到节点 *j*，公式 9.10 中的加权平均方案将被应用于更新局部信息素轨迹。
- en: $Equation$ (9.10) ![](../images/eq9-10.jpg)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: $公式$ (9.10) ![](../images/eq9-10.jpg)
- en: In the original ACO, no local updates occur, which allows one to implement the
    tour construction either sequentially or concurrently. When tours are built concurrently
    (in parallel), they can result in significant computational time savings for large
    real-world problems. Due to the local updating rule of ACS, it is implied that
    the process will be implemented sequentially. This is because the tour created
    by a specific ant is influenced by the preceding ants’ local updates to the pheromone
    trails.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始的 ACO 中，不进行局部更新，这使得可以按顺序或并行地构建路径。当路径并行构建时（即并行处理），可以为大规模的实际问题带来显著的计算时间节省。由于
    ACS 的局部更新规则，意味着该过程将按顺序执行。这是因为特定蚂蚁所创建的路径会受到前面蚂蚁对信息素轨迹的局部更新的影响。
- en: 'Step 3: Updating the Global Pheromone Trail'
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 步骤 3：更新全局信息素轨迹
- en: Once all ants are done building their tours, the global pheromone update rule
    is applied once per iteration and only along the edges of the best-so-far tour,
    *T*^(bs), as shown in Equation 9.11.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有蚂蚁完成了它们的路径构建，全球信息素更新规则将在每次迭代时应用，并且仅沿着当前最佳路径*T*^(bs)的边缘进行，如公式 9.11 所示。
- en: $Equation$ (9.11) ![](../images/eq9-11.jpg)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: $公式$ (9.11) ![](../images/eq9-11.jpg)
- en: Equation 9.11 implies that *T*^(bs) will need to be compared with the best solution
    identified by the colony at the end of each iteration and then be updated as needed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 公式 9.11 表示，在每次迭代结束时，*T*^(bs) 需要与蚁群识别的最佳解进行比较，并根据需要进行更新。
- en: The Pseudocode
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 伪代码
- en: 'The following pseudocode shows how the components of the ACS algorithm come
    together to form a sophisticated heuristic algorithm:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下伪代码展示了 ACS 算法的各个组件如何结合在一起，形成一个复杂的启发式算法：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We’ll follow this pseudocode to develop a complete ACS application in Kotlin
    in the next project.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个项目中按照此伪代码使用 Kotlin 开发一个完整的 ACS 应用程序。
- en: 'Project 37: Solve the Traveling Salesman Problem with an Ant Colony System'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 37：使用蚁群系统解决旅行商问题
- en: In this project, we’ll solve the well-known test problem Berlin52\. This is
    a combinatorial optimization problem that involves finding the shortest route
    through 52 destinations in Berlin, Germany. The dataset for this problem was retrieved
    from TSPLIB, which is a collection of traveling salesman problems with known global
    optimal solutions. See “Resources” on [page 377](#pg_377) for the download link
    for these problems, which you can try solving by using the ACS algorithm and other
    NIAs discussed in this book.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，我们将解决著名的测试问题 Berlin52。这个问题是一个组合优化问题，旨在找到穿越德国柏林 52 个目的地的最短路径。此问题的数据集来自
    TSPLIB，它是一个包含已知全局最优解的旅行商问题集合。有关这些问题的下载链接，请参见 [第 377 页](#pg_377) 的“资源”部分，你可以尝试使用
    ACS 算法和本书中讨论的其他 NIA 来解决它们。
- en: The Code
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: The Berlin52 TSP requires datasets for 52 different locations. It’s more convenient
    to create a separate datafile for this project (for example, a file in CSV format)
    and read the location data from the file at runtime. So we’ll adopt that approach
    for this project.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Berlin52 TSP 需要 52 个不同位置的数据集。为了方便起见，可以为本项目创建一个单独的数据文件（例如，CSV 格式的文件），并在运行时从文件中读取位置数据。因此，我们将在本项目中采用这种方法。
- en: 'We’ll discuss the code segments in four primary blocks: problem definition
    and global parameters, the main() block, the runACS() driver function and its
    helper functions, and additional intermediate and postprocessing of results.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论代码段的四个主要模块：问题定义和全局参数，main() 模块，runACS() 驱动函数及其辅助函数，以及额外的中间处理和结果后处理。
- en: '##### Problem Definition and Global Declarations'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 问题定义和全局声明'
- en: This segment specifies the import block and defines the input file location,
    global variables and parameters, and a collection of classes, lists, and arrays
    required to implement the ASC algorithm.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分指定了导入模块，并定义了输入文件的位置、全局变量和参数，以及实现 ASC 算法所需的类、列表和数组集合。
- en: '[PRE7]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code segment begins by importing the required methods from the standard
    Kotlin and Java libraries. We’ll use java.io.File to read data from an input file
    from a specified location (in this case, from *berlin52.csv*) ❶. (The input file
    you’ll use will likely have a different location, so you must change the input
    file location as needed.)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 代码段首先从标准 Kotlin 和 Java 库中导入所需的方法。我们将使用 java.io.File 从指定位置读取输入文件中的数据（在这种情况下，从
    *berlin52.csv* 读取）❶。（你使用的输入文件可能位于不同位置，因此你需要根据需要更改输入文件的位置。）
- en: 'The input file for the Berlin52 TSP follows a set format. The first value in
    the initial line contains a brief title describing the problem, while subsequent
    values serve as column headers for the data points. From the second line to the
    last, city-specific information is presented in groups of four comma-separated
    values (hence the file extension *.csv*): city name, city identification, x-coordinate,
    and y-coordinate, respectively. Each row contains data for a particular city or
    location.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Berlin52 TSP 的输入文件遵循一套固定格式。初始行中的第一个值包含一个简短的标题，用于描述问题，而后续的值则作为数据点的列标题。从第二行到最后一行，每行包含四个逗号分隔的值（因此文件扩展名为
    *.csv*）：城市名称、城市编号、x 坐标和 y 坐标。每行包含一个特定城市或位置的数据。
- en: In this case, the datafile consists of 53 lines, including the introductory
    line that provides descriptive information. [Table 9-2](chapter9.xhtml#tab9-2)
    shows how the file will look when you open it with Microsoft Excel or another
    spreadsheet program.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，数据文件包含 53 行，其中包括提供描述信息的引导行。[表 9-2](chapter9.xhtml#tab9-2) 显示了当你使用 Microsoft
    Excel 或其他电子表格程序打开该文件时的样子。
- en: 'Table 9-2: Input File Format for the Berlin52 TSP'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-2：Berlin52 TSP 输入文件格式
- en: '| Berlin52 | ID | X | Y |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| Berlin52 | ID | X | Y |'
- en: '| --- | --- | --- | --- |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| C1 | 0 | 565 | 575 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| C1 | 0 | 565 | 575 |'
- en: '| C2 | 1 | 25 | 185 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| C2 | 1 | 25 | 185 |'
- en: '| C3 | 2 | 345 | 750 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| C3 | 2 | 345 | 750 |'
- en: '| C4 | 3 | 945 | 685 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| C4 | 3 | 945 | 685 |'
- en: '| C5 | 4 | 845 | 655 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| C5 | 4 | 845 | 655 |'
- en: '| C6 | 5 | 880 | 660 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| C6 | 5 | 880 | 660 |'
- en: '| ... | ... | ... | ... |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| ... | ... | ... | ... |'
- en: '| C50 | 49 | 595 | 360 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| C50 | 49 | 595 | 360 |'
- en: '| C51 | 50 | 1340 | 725 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| C51 | 50 | 1340 | 725 |'
- en: '| C52 | 51 | 1740 | 245 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| C52 | 51 | 1740 | 245 |'
- en: The next code block declares all the global parameters ❷. For example, the number
    of cities (numCities) is set to 52, the number of ants (numAnts) is set to 30,
    the maximum number of iterations per round (iterMax) is set to 300, and the number
    of times the entire process is repeated (maxRounds) is set to 50\. The comments
    next to the parameters indicate suggested ranges or values for these parameters.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码块声明了所有的全局参数 ❷。例如，城市数（numCities）设置为 52，蚂蚁数（numAnts）设置为 30，每轮最大迭代次数（iterMax）设置为
    300，整个过程重复次数（maxRounds）设置为 50。参数旁边的注释指出了这些参数的建议范围或值。
- en: Next, we define the classes and collections used in this project ❸. The City
    data class stores information on the locations to visit, including their names,
    ID numbers, and coordinates.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了在此项目中使用的类和集合 ❸。City 数据类存储了要访问的地点信息，包括它们的名称、ID 编号和坐标。
- en: The Ant class is used to create the ant colony, which is at the heart of ACS.
    The Ant class has several properties required for managing and monitoring ant
    movements. In particular, citiesToVisit dynamically keeps track of the remaining
    cities to visit, pathNodes stores the start and the end nodes for each path (edge)
    already traversed, and pathSegments stores the corresponding edge lengths. This
    class also has a method called setCitiesToVisit() that defines the initial list
    of cities each ant can visit.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Ant 类用于创建蚂蚁群体，这是 ACS 的核心。Ant 类具有若干属性，用于管理和监控蚂蚁的移动。特别地，citiesToVisit 动态跟踪剩余的要访问的城市，pathNodes
    存储每条已遍历路径（边）的起始节点和结束节点，pathSegments 存储相应的边长。该类还有一个名为 setCitiesToVisit() 的方法，定义了每只蚂蚁可以访问的初始城市列表。
- en: The ArgMax class is used during the tour construction phase. The Solution class
    stores information on completed tours, including the nodes and edges comprising
    a tour and its fitness value (length of the tour).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ArgMax 类在旅行构建阶段使用。Solution 类存储已完成的旅行信息，包括组成旅行的节点和边以及其适应度值（旅行长度）。
- en: These classes are followed by a block that initializes a number of collections,
    arrays, and parameters. For example, cities is used to build a list of locations
    to visit, and ants is used to create the ant colony. Others are used to store
    ant solutions (antSolutions), best solutions (bestSolutions), and the best overall
    tour (bestOverallTour).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类后面跟着一个初始化多个集合、数组和参数的代码块。例如，cities 用于构建一个访问地点的列表，ants 用于创建蚂蚁群体。其他变量用于存储蚂蚁的解（antSolutions）、最佳解（bestSolutions）和最佳总体旅行（bestOverallTour）。
- en: We use two-dimensional arrays to store information on the edges (edges) and
    corresponding pheromone levels (pheromone) and edge probabilities (prob). The
    final two lines set the default values for the best overall fitness (bestOverallFitness)
    and the counter variable optimaCount.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用二维数组来存储边的信息（edges）、相应的费洛蒙水平（pheromone）和边的概率（prob）。最后两行设置了最佳整体适应度（bestOverallFitness）和计数变量
    optimaCount 的默认值。
- en: The main() Block
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: main() 块
- en: The main() block is a minimal block with a few function calls and print functionalities.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: main() 块是一个最小的代码块，包含少量的函数调用和打印功能。
- en: '[PRE8]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The function starts by printing a problem-specific message on the console and
    then moves on to the preprocessing block. It calls the readCities() function to
    read off the location data from the input file. The calculateEdges() function
    uses the location coordinates to estimate the distances between pairs of nodes.
    The calculatePheromone0() function finds the nearest-neighbor tour length *C*^(nn)
    and uses that to estimate the initial pheromone levels *τ*[0] for all edges.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先在控制台打印出一个特定问题的消息，然后进入预处理块。它调用 readCities() 函数从输入文件中读取地点数据。calculateEdges()
    函数使用地点坐标估算节点对之间的距离。calculatePheromone0() 函数找到最近邻旅行长度 *C*^(nn)，并利用该长度估算所有边的初始费洛蒙水平
    *τ*[0]。
- en: Next, we introduce a for loop ❶ to carry out the entire ACS process a set number
    of times (maxRounds). The Berlin52 TSP is a challenging problem, and the ACS algorithm
    may not be able to locate the global optimal solution during each round of the
    ACS process, which involves iterMax attempts.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们引入了一个 for 循环 ❶ 来执行整个 ACS 过程若干次（maxRounds）。Berlin52 TSP 是一个具有挑战性的问题，ACS
    算法在每轮 ACS 过程中可能无法找到全局最优解，这个过程涉及 iterMax 次尝试。
- en: Inside the for loop, the initializePheromone() function ❷ sets the initial pheromone
    level for all edges of the graph. Next, the driver function runACS() carries out
    the search for the optimal route. The processInterimResults() function updates
    the best overall fitness and best overall tour values, then prints the best solution
    for each round of search. Finally, the list of best solutions is cleared before
    starting the next round ❸.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for 循环内部，initializePheromone() 函数❷为图的所有边设置初始的信息素水平。接下来，驱动函数 runACS() 执行最优路径的搜索。processInterimResults()
    函数更新最佳整体适应度和最佳整体路线值，然后打印每轮搜索的最佳解。最后，在开始下一轮搜索前清空最佳解列表❸。
- en: The success rate of the ACS algorithm depends on the combination of global parameter
    values and the random initialization of the ants and their start nodes (in addition
    to the random selection of edges that happens during the implementation of the
    algorithm). In general, when a heuristic algorithm gets stuck at a local optimum
    even after attempting to find the global optimal solution a reasonable number
    of times, it may be beneficial to restart the entire process by resetting the
    initial conditions and changing the global parameters if needed, rather than increasing
    the number of iterations. The for loop in the main() block helps us automatically
    reset and restart the ACS process and carry it out maxRounds times.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ACS 算法的成功率取决于全局参数值的组合、蚂蚁及其起始节点的随机初始化（除了在算法实现过程中发生的随机边选择）。一般来说，当启发式算法即使在尝试了合理次数的全局最优解搜索后仍卡在局部最优解时，重启整个过程可能是有益的，方法是重置初始条件并根据需要调整全局参数，而不是增加迭代次数。main()
    块中的 for 循环帮助我们自动重置并重新启动 ACS 过程，并执行 maxRounds 次。
- en: Notice that we need to read the input data, calculate edge lengths, and calculate
    the initial pheromone level only once. Thus, those tasks are completed before
    initiating the for loop inside the main() block. However, we need to reset the
    pheromone levels to *τ*[0] each time we call the runACS() function.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只需要读取输入数据、计算边长并计算初始信息素水平一次。因此，这些任务在启动 main() 块中的 for 循环之前已经完成。然而，每次调用
    runACS() 函数时，我们需要重置信息素水平为 *τ*[0]。
- en: The main() block ends with printing the best overall fitness and tour (from
    all rounds and iterations). It also prints the number of times the algorithm was
    successful in finding the global optimal solution.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: main() 块以打印最佳整体适应度和路线（来自所有轮次和迭代）结束。它还会打印算法成功找到全局最优解的次数。
- en: The readCities() Function
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: readCities() 函数
- en: The sole purpose of this function is to read the location data from an input
    file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的唯一目的是从输入文件中读取位置信息。
- en: '[PRE9]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Java File class ❶ opens the input file from a location specified in the
    datafile string. The entire content of the datafile is read into memory as an
    array of strings (lines) ❷. We are applying .filterNot{it.isEmpty()} to file.readLines()
    to make reading the file safer with respect to empty lines.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的 File 类❶从 datafile 字符串指定的位置打开输入文件。数据文件的全部内容作为字符串数组（每行）❷被读取到内存中。我们应用 .filterNot{it.isEmpty()}
    来确保文件读取过程不会因为空行而出现问题。
- en: Then, each line is split by using a comma (,) as the separator ❸ (recall that
    the input file was created as a comma-separated value, or CSV, file). Finally,
    different parts of the split line are used to create a list of nodes (cities)
    by using the City class ❹.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每一行通过使用逗号（,）作为分隔符进行拆分❸（回想一下，输入文件是以逗号分隔值（CSV）文件格式创建的）。最后，使用 City 类❹将拆分后的不同部分创建为节点（城市）列表。
- en: The calculateEdges() Function
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: calculateEdges() 函数
- en: The purpose of this function is to calculate and save the edge lengths (path
    segments) of a tour.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的目的是计算并保存一个旅行路径的边长（路径段）。
- en: '[PRE10]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The edge lengths are saved in a two-dimensional array, where the diagonal elements
    (i = j) are set to 0.0 ❶ (the distance of a node from itself is zero), and the
    off-diagonal elements are set to Euclidian distances between a pair of nodes ❷.
    We’re assuming that a pair of nodes is connected by a single edge or path. This
    allows us to calculate only the upper triangle of the matrix and set the lower
    triangle values by using the property of symmetry ❸.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 边的长度保存在一个二维数组中，其中对角线元素（i = j）设置为 0.0❶（一个节点到自身的距离为零），而非对角线元素设置为节点对之间的欧几里得距离❷。我们假设一对节点通过一条单一的边或路径连接。这使我们可以仅计算矩阵的上三角，并通过利用对称性❸来设置下三角的值。
- en: The calculatePheromone0() Function
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: calculatePheromone0() 函数
- en: This function calculates the nearest-neighbor tour length *C*^(nn) and uses
    that to estimate the initial pheromone level, pheromone0.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数计算最近邻旅行的长度*C*^(nn)，并用该值估算初始信息素水平pheromone0。
- en: '[PRE11]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function finds the nearest-neighbor tour by starting the tour from node
    0 ❶ and moving to the nearest nodes with a while loop ❷ until all nodes or cities
    are visited. At each step, the shortest edge is identified and added to the nearest-neighbor
    tour length ❸. Once the node is added to the tour, it is removed from the list
    of cities to visit ❹. The tour is closed by connecting the last node visited to
    the start node and adding the corresponding edge length to the total tour length
    ❺. Finally, the initial pheromone level pheromone0 is calculated as equal to 1/(*nC*^(nn))
    ❻.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数通过从节点0 ❶开始并通过while循环 ❷移动到最近的节点，直到访问完所有节点或城市，来找到最近邻旅行。在每一步，识别出最短的边并将其加入到最近邻旅行的总长度中❸。一旦节点被加入到旅行中，它将从待访问城市列表中移除❹。通过将最后访问的节点与起始节点连接并将相应的边长度加入到总旅行长度中来闭合旅行❺。最后，初始信息素水平pheromone0被计算为1/(*nC*^(nn))
    ❻。
- en: The initializePheromone() Function
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: initializePheromone()函数
- en: This function sets initial pheromone levels for all edges of the graph to pheromone0.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将图中所有边的初始信息素水平设置为pheromone0。
- en: '[PRE12]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The pheromone levels are stored in a two-dimensional array (a matrix), and the
    property of symmetry is used to calculate the lower triangle elements of the matrix
    by setting *τ*ji = *τ*ij. Notice that when *i* = *j*, the node is simply referring
    to itself, and the corresponding diagonal elements are set to 0.0\. These values
    are not required or used by the ACS algorithm.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 信息素水平存储在一个二维数组（矩阵）中，利用对称性属性通过设置*τ*ji = *τ*ij来计算矩阵的下三角元素。注意，当*i* = *j*时，节点只是指向自身，相应的对角元素设置为0.0。这些值在ACS算法中不需要也不会使用。
- en: The runACS() Function
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: runACS()函数
- en: The runACS() function creates the ant colony, coordinates the tour construction
    for individual ants, saves intermediate results, and implements the global pheromone
    update rule. We’ll begin by providing an overview of the key elements of this
    function, which will be followed by discussions on the individual helper functions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: runACS()函数创建蚁群，协调各个蚂蚁的旅行构建，保存中间结果，并实现全局信息素更新规则。我们将首先提供该函数关键元素的概述，随后讨论各个辅助函数。
- en: '[PRE13]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code segment begins by setting the iteration counter iter to 1. A while
    loop is used to repeat the search iterMax times. Inside the loop, initializeAnts()
    creates the ant colony for a specific iteration ❶.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 代码段开始时将迭代计数器iter设置为1。使用while循环重复搜索iterMax次。在循环内部，initializeAnts()为特定的迭代创建蚁群❶。
- en: Once the ant colony is initiated, a tour for each ant is constructed inside
    a for loop. The process starts with setting a list of cities to visit for each
    ant ❷ by invoking the setCitiesToVisit() method of the Ant class. The actual tour
    is built by the buildAntTour() function ❸.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦蚁群被初始化，就会在for循环中为每只蚂蚁构建旅行。这个过程从为每只蚂蚁设置待访问城市列表开始❷，通过调用Ant类的setCitiesToVisit()方法。实际的旅行是通过buildAntTour()函数构建的❸。
- en: Once the optimal tour for an individual ant is completed, relevant information
    is saved in antSolutions ❹. The best of all ant solutions (for the current iteration)
    is found by using the minWith() function of Kotlin ❺, which is then added to the
    bestSolutions list ❻. At this stage, the globalPheromoneUpdate() function is called
    to apply the global pheromone update rule ❼. Next, ants and antSolutions are cleared
    in preparation for the next iteration. Finally, iter is incremented by 1 ❽; the
    process will exit the while loop when iter > iterMax.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦某只蚂蚁完成了最优旅行，相关信息就会保存在antSolutions中❹。通过使用Kotlin的minWith()函数找到所有蚂蚁解（当前迭代）的最佳解❺，然后将其添加到bestSolutions列表中❻。此时，调用globalPheromoneUpdate()函数应用全局信息素更新规则❼。接下来，清空蚂蚁和antSolutions，为下一次迭代做准备。最后，iter加1❽；当iter
    > iterMax时，过程将退出while循环。
- en: The initializeAnts() Function
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: initializeAnts()函数
- en: The code snippet for the initializeAnts() function is very short.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: initializeAnts()函数的代码片段非常简短。
- en: '[PRE14]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code begins by creating a list of indices, each designating a city or node.
    Next, it creates the ants one by one and assigns each ant a start node selected
    randomly from the list of cities to visit.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码首先创建一个索引列表，每个索引代表一个城市或节点。接下来，依次创建蚂蚁，并为每只蚂蚁随机从待访问城市列表中选择一个起始节点。
- en: This scheme allows multiple ants to have the same start node, while some nodes
    may not have any ants assigned to them. This flexibility is beneficial when the
    number of ants differs from the number of nodes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方案允许多只蚂蚁拥有相同的起始节点，而有些节点可能没有任何蚂蚁分配给它们。这种灵活性在蚂蚁数量与节点数量不一致时非常有用。
- en: '##### The buildAntTour() Function'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '##### `buildAntTour()` 函数'
- en: This function identifies the next node to visit, updates relevant ant properties
    to reflect that choice, and recursively builds the entire tour. It also calculates
    the ant fitness when the tour is complete and applies the local pheromone update
    for each edge traveled.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数确定下一步访问的节点，更新相关的蚂蚁属性以反映这个选择，并递归地构建整个旅行。当旅行完成时，它还会计算蚂蚁的适应度，并对每一段经过的边应用局部信息素更新。
- en: '[PRE15]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The function starts with setting the current location index i to the ant’s currentNode
    property (which is initially the same as startNode) ❶. Subsequent nodes to visit
    are found by using a while loop until the list of cities to visit is exhausted.
    The process of selecting the next node is quite involved and is implanted by selectNodeToVisit()
    ❷, a function we’ll discuss in more detail shortly.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先将当前地点索引i设置为蚂蚁的`currentNode`属性（最初与`startNode`相同）❶。随后的待访问节点通过使用while循环找到，直到待访问城市列表用尽。选择下一个节点的过程非常复杂，并由`selectNodeToVisit()`实现❷，这个函数我们稍后将详细讨论。
- en: After locating nextNode, the local pheromone update rule is applied ❸, and the
    currentNode property of the ant is set to nextNode. At this time, relevant ant
    properties are updated based on the move from node i to nextNode. Before repeating
    the iteration for the next node or city to visit, the current node index i is
    updated to currentNode (that is, to the most recent nextNode) and then nextNode
    is removed from the list of cities to visit ❹.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定`nextNode`之后，会应用局部信息素更新规则❸，并将蚂蚁的`currentNode`属性设置为`nextNode`。此时，基于从节点i到`nextNode`的移动，相关的蚂蚁属性会被更新。在为下一个节点或城市执行迭代之前，当前节点索引i会更新为`currentNode`（即最新的`nextNode`），然后`nextNode`会从待访问城市列表中移除❹。
- en: Once the ant is done visiting all the cities it is allowed to visit, the tour
    is closed by connecting the last city visited to the city from which the ant started
    its tour. This is done by updating the ant’s pathNodes and pathSegments properties.
    When the tour is complete, its fitness (length) is calculated ❺, and the local
    pheromone update rule is applied one more time for the last segment of the tour
    ❻.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦蚂蚁完成了所有允许访问的城市，旅行就通过将最后访问的城市与蚂蚁开始旅行的城市连接起来结束。这是通过更新蚂蚁的`pathNodes`和`pathSegments`属性来实现的。当旅行完成时，会计算其适应度（长度）❺，并对旅行的最后一段应用局部信息素更新规则❻。
- en: The selectNodeToVisit() Function
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`selectNodeToVisit()` 函数'
- en: This function implements the most mathematically involved part of the ACS algorithm
    that uses both an argmax type function and the roulette wheel scheme to decide
    which node to visit next.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数实现了ACS算法中最复杂的数学部分，它同时使用了argmax类型的函数和轮盘赌方案来决定下一步访问的节点。
- en: '[PRE16]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The function first creates local variables for saving the chosen node (chosenNode,
    initially set to an unlikely value) and a mutable list to which an argmax operation
    will be applied per Equation 9.8\. Next, edge-specific raw probabilities are calculated
    inside the first for loop ❶. This loop also populates the argmaxList, which stores
    the possible destination node index *j* as its index property and the corresponding
    prob[i][j] (before being normalized) as its value. The second for loop ❷ converts
    the raw probabilities to normalized probabilities.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先创建局部变量来保存选择的节点（`chosenNode`，初始设置为一个不太可能的值）和一个可变列表，该列表将对每个根据公式9.8进行argmax操作。接下来，在第一个for循环❶内计算边的原始概率。这个循环还填充了`argmaxList`，该列表将可能的目标节点索引*j*作为其索引属性，并将对应的`prob[i][j]`（在归一化之前）作为其值。第二个for循环❷将原始概率转换为归一化概率。
- en: After the initial processing, a random number *q* is drawn from a uniform distribution
    ❸. If *q* <= *q*[0], the argmax rule is used to choose the next node index ❹.
    Otherwise, Equation 9.9 is used to find the next node index by using the roulette
    wheel scheme ❺. In particular, when the spin value is less than or equal to the
    sum of normalized probabilities up to index *j*, we set chosenNode equal to *j*
    ❻ and break out of the loop. Finally, the value of chosenNode is returned ❼.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The globalPheromoneUpdate() Function
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This function applies the global pheromone update rule once all ants finish
    building their tours for a particular iteration.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This function has two key steps. First, it identifies the best-so-far solution
    since the beginning of the iterations inside the while loop of runACS(). Next,
    pheromone levels are updated only for the edges (path segments) that belong to
    the best-so-far tour.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Other Functions in the main() Block
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The other functions in the main() block are not part of the ACS algorithm. Instead,
    we use these functions to monitor the convergence of the algorithm and to print
    final values of the best overall fitness and corresponding solution at the end.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The processInterimResults() function helps save and print intermediate results
    after the completion of each round of calculations inside the for loop of the
    main() function.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This function first sorts the bestSolutions to find the best-so-far solution
    based on the fitness values of the solutions ❶. Next, it updates the value of
    bestOverallFitness, the best fitness found from all rounds up to this point ❷.
    The current number of rounds, the iteration number, and the antID are then printed
    along with the best-so-far fitness ❸. This helps us monitor how the algorithm
    is doing as it proceeds through the number of rounds (as mentioned earlier, the
    maximum number of rounds is set by maxRounds).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we check to see if the fitness of bestSoFar matches the known global
    optimal fitness for the Berlin52 problem (7544.3659) and count the number of such
    matches ❹ (which is later printed from the main() function).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The final function called from main() is printBestOverallFitnessAndTour(), which
    prints the optimal function value and solution found by the ACS algorithm.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first line inside the function prints the value of the best overall fitness.
    The optimal solution in this case is a list of Pairs, where each pair consists
    of the start and the end nodes for the edges that belong to the best overall tour.
    We use a for loop and an if statement to print five pairs of nodes per line so
    that the entire solution can be examined easily in the console.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: The Result
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Following is a sample output from a test run of the ACS application. I encourage
    you to compare this output with the various print statements and functions used
    in the entire ACS code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can see that on this occasion, the first instance of global optima was found
    in the second round (during iter = 105 and by ant number 0). A near-optimal solution
    with a fitness of 7548.99 was found multiple times (not shown). The best overall
    solution had a fitness of 7544.3659, which is the known shortest tour length for
    the Berlin52 problem.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这次全球最优解第一次出现在第二轮（在iter = 105时，由蚂蚁编号0找到）。一个接近最优的解，适应度为7548.99，找到了多次（未显示）。最佳的整体解适应度为7544.3659，这是已知的Berlin52问题的最短路径长度。
- en: All the nodes that belong to the optimal (best overall) tour are also shown
    in the output. Notice that the optimal tour is a closed loop, and it returns to
    the same node it starts from. The sequence of the nodes in the optimal solution
    may differ when you run the code. This will not affect the tour length (therefore,
    its fitness will remain the same).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中还展示了所有属于最优（总体最佳）旅行路径的节点。请注意，最优旅行路径是一个闭环，并且它会返回到起始节点。最优解中节点的顺序可能会有所不同，每次运行代码时都会有变化。这不会影响旅行路径的长度（因此其适应度保持不变）。
- en: The final item in the output, optimaCount, indicates that during the entire
    process, the global optimal solution was found 5 times out of 50 rounds (although
    each of those rounds might have found the global optimal solution more than once).
    If you plot the nodes that belong to the best overall tour by using their x- and
    y-coordinates, the optimal tour will look like the path shown in [Figure 9-4](chapter9.xhtml#fig9-4).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的最后一项，optimaCount，表示在整个过程中，全球最优解在50轮中被找到5次（尽管每一轮可能都找到过全球最优解不止一次）。如果你使用节点的x和y坐标绘制出属于最佳整体旅行路径的节点，最优旅行路径将呈现出[图9-4](chapter9.xhtml#fig9-4)中所示的路径。
- en: '![](../images/Figure9-4.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-4.jpg)'
- en: 'Figure 9-4: The optimal tour for the Berlin52 traveling salesman problem'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-4：Berlin52旅行商问题的最优路径
- en: To visualize the convergence patterns for the rounds that found the global optima,
    you can add a few additional lines of code to save the relevant data from intermediate
    steps and plot the data. A typical convergence plot will look like the patterns
    shown in [Figure 9-5](chapter9.xhtml#fig9-5).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化找到全局最优解的轮次的收敛模式，你可以添加几行额外的代码，保存中间步骤的相关数据并绘制该数据。典型的收敛图将呈现出像[图9-5](chapter9.xhtml#fig9-5)所示的模式。
- en: '![](../images/Figure9-5.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-5.jpg)'
- en: 'Figure 9-5: Convergence patterns for the Berlin52 problem'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-5：Berlin52问题的收敛模式
- en: Before concluding this project, I want to make a couple of points regarding
    the success rate of the ACS algorithm and the accuracy of the solution generated
    by the code we developed. These comments will clarify some questions that you
    may have when you run the code on your device or compare the results with the
    same published elsewhere.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本项目之前，我想提出几个关于ACS算法成功率以及我们开发的代码生成的解的准确性的观点。这些评论将澄清你在运行代码时可能遇到的一些问题，或者在将结果与其他地方发布的结果进行比较时可能产生的疑问。
- en: First, recalling that the NIAs used in this book are stochastic, the optimaCount
    will vary each time you run the program. For the given set of values for the global
    parameters, I found the average optimaCount to be around 5 (based on 10 runs).
    However, if you change the values of the global parameters, this average success
    rate will change. I encourage you to play with those parameters to develop an
    understanding of their relative influence in finding the global optima.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，回顾一下本书中使用的NIA（自然启发算法）是随机的，optimaCount每次运行程序时会有所不同。在给定全局参数值的情况下，我发现平均的optimaCount大约为5（基于10次运行）。但是，如果你改变全局参数的值，这一平均成功率会发生变化。我鼓励你尝试调整这些参数，以帮助理解它们在寻找全局最优解时的相对影响。
- en: Second, you may find in the literature that the optimal (shortest) tour length
    for the Berlin52 problem is 7542, which is slightly different from the optimal
    value we found, 7544.3659\. This does not indicate any issues with the ACS algorithm
    or with the code developed in this project; it is due to the fact that some algorithms
    convert the nodal (intercity) distances to the nearest integer values before solving
    the problem, for mathematical efficiency. Therefore, those methods essentially
    solve a slightly different problem. However, our ACS application has identified
    the exact same optimal route as reported in the literature.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，你可能会在文献中发现，柏林52问题的最优（最短）路径长度是7542，稍微不同于我们所找到的最优值7544.3659。这个差异并不表明ACS算法或本项目开发的代码存在问题；这是因为一些算法在解决问题之前会将节点（城市间）距离转换为最接近的整数值，以提高数学效率。因此，这些方法实际上解决的是一个略有不同的问题。然而，我们的ACS应用程序已经找出了与文献中报告的完全相同的最优路线。
- en: Ant colony optimization is an area of active research, just like other NIAs.
    New modifications are being proposed and tested to improve the convergence and
    accuracy of this algorithm. I strongly encourage you to consult recently published
    literature if you are interested in using ACS or similar algorithms to solve large
    real-world routing problems.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 蚁群优化是一个活跃的研究领域，和其他自然启发算法（NIA）一样，不断有新的修改方案被提出并测试，以提高该算法的收敛性和精度。如果你有兴趣使用蚁群算法（ACS）或类似算法解决大型实际路线规划问题，我强烈建议你查阅最近发布的文献。
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter completes your introduction to the fascinating world of NIAs and
    their applications. You discovered two more powerful tools—particle swarm optimization
    and ant colony systems—and you learned how to harness the power of these algorithms
    in Kotlin. You put your skills to the test with two real-world optimization problems:
    finding the global minimum of a complex mathematical function and solving the
    traveling salesman problem for a network of 52 locations in Berlin. You explored
    how the algorithms converged to the optimal solutions over time and how to measure
    their performance. And of course, you challenged yourself with exercises to reinforce
    your learning.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成了你对自然启发算法（NIA）及其应用的介绍。你了解了两个更强大的工具——粒子群优化和蚁群系统——并且学会了如何在Kotlin中利用这些算法的强大功能。你通过解决两个实际的优化问题来测试你的技能：为柏林52个地点的旅行商问题找到全局最小值，并解决一个复杂数学函数的全局最小值问题。你探索了算法如何随着时间推移收敛到最优解，并学习了如何衡量它们的性能。当然，你也通过练习挑战了自己，加深了学习效果。
- en: Resources
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源
- en: 'Brownlee, Jason. *Clever Algorithms: Nature-Inspired Programming Recipes*.
    Electronic version, June 16, 2012\. *[https://github.com/clever-algorithms/CleverAlgorithms](https://github.com/clever-algorithms/CleverAlgorithms)*.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Brownlee, Jason. *巧妙算法：自然启发的编程秘诀*。电子版，2012年6月16日。*[https://github.com/clever-algorithms/CleverAlgorithms](https://github.com/clever-algorithms/CleverAlgorithms)*。
- en: 'Clerc, Maurice. *Particle Swarm Optimization*. London: ISTE, 2006.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Clerc, Maurice. *粒子群优化*。伦敦：ISTE出版社，2006年。
- en: 'Dorigo, Marco, and Thomas Stützle. *Ant Colony Optimization*. Cambridge, MA:
    MIT Press, 2004.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Dorigo, Marco 和 Thomas Stützle. *蚁群优化*。美国马萨诸塞州剑桥市：麻省理工学院出版社，2004年。
- en: 'Olsson, Andrea E., ed. *Particle Swarm Optimization: Theory, Techniques and
    Applications*. New York: Nova Science, 2011.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Olsson, Andrea E., 主编. *粒子群优化：理论、技术与应用*。纽约：Nova Science出版社，2011年。
- en: 'Parsopoulos, Konstantinos E. “Particle Swarm Methods.” In *Handbook of Heuristics*,
    edited by Rafael Martí, Panos M. Pardalos, and Mauricio G. C. Resende, 639–685\.
    Cham, Switzerland: Springer, 2018.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Parsopoulos, Konstantinos E. “粒子群方法。” 见 *启发式手册*，由Rafael Martí、Panos M. Pardalos和Mauricio
    G. C. Resende编辑，第639-685页。瑞士琅勃拉邦：施普林格出版社，2018年。
- en: 'Solnon, Christine. *Ant Colony Optimization and Constraint Programming*. London:
    ISTE, 2013.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Solnon, Christine. *蚁群优化与约束编程*。伦敦：ISTE出版社，2013年。
- en: TSPLIB. Symmetric Traveling Salesman Problem (TSP). Accessed June 15, 2024\.
    *[http://<wbr>comopt<wbr>.ifi<wbr>.uni<wbr>-heidelberg<wbr>.de<wbr>/software<wbr>/TSPLIB95<wbr>/](http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/)*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: TSPLIB. 对称旅行商问题（TSP）。访问日期：2024年6月15日。*[http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/](http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/)*。
- en: 'Yang, Xin-She. *Nature-Inspired Optimization Algorithms*. 2nd ed. London: Academic
    Press, 2021.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Yang, Xin-She. *自然启发优化算法*。第二版。伦敦：学术出版社，2021年。
