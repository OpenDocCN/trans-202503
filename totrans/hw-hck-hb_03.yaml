- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: 'Casing the Joint: Identifying Components and Gathering Information'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 查探目标：识别组件和收集信息
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Frank Herbert wrote in *Dune*, “A beginning is a very delicate time.” As you
    likely know, the way you begin a project sets the tone for its success. Operating
    on false assumptions or overlooking a small bit of information can derail a project
    and burn precious time. Thus, with any reverse engineering or research project
    (hardware being no different), gathering and reviewing as much information as
    possible in the early phases of your investigation into a target system is critical.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 弗兰克·赫伯特在《沙丘》中写道：“开始是一个非常微妙的时刻。”正如你可能知道的，项目的开始方式为其成功奠定了基调。基于错误假设进行操作或忽视一些小信息，可能会使项目偏离轨道并浪费宝贵的时间。因此，无论是进行逆向工程还是研究项目（硬件项目也不例外），在调查目标系统的早期阶段收集并审查尽可能多的信息至关重要。
- en: Most hardware-based projects start with a curiosity and fact-gathering stage,
    and this chapter is meant to assist with that phase. If you’re performing a target
    system review without design files, specifications, or a bill of materials (BOM),
    you naturally start by opening the device and seeing what’s inside. That’s the
    fun part! This chapter outlines techniques for identifying interesting components
    or interfaces and shares ideas for gathering information and specifications for
    a device and its components.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数基于硬件的项目都从好奇心和事实收集阶段开始，本章旨在帮助这一阶段。如果你在没有设计文件、规格说明书或物料清单（BOM）的情况下进行目标系统审查，你自然会从拆开设备并查看里面的内容开始。这就是最有趣的部分！本章概述了识别有趣组件或接口的技术，并分享了收集设备及其组件信息和规格的想法。
- en: This information-gathering phase isn’t linear. You’ll find a variety of puzzle
    pieces. In this chapter, we show ways to find the pieces, and it’s up to you to
    put them together, in whatever order, to make the picture sufficiently complete.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个信息收集阶段并非线性进行。你会发现各种各样的拼图碎片。在本章中，我们展示了找到这些碎片的方法，而将它们以任何顺序拼凑起来，使得图像足够完整，就由你自己决定了。
- en: Information Gathering
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信息收集
- en: '*Info gathering*, *doxing*, *recon*, *getting developer Joe to spill the beans*—however
    you express it, this is an important time-saving step. Plenty of information is
    available if you know where to look. We begin with the least effort, which is
    at the keyboard, and later we’ll reach for the screwdriver and other tools.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*信息收集*、*个人信息搜集*、*侦察*、*让开发者Joe泄密*——无论你怎么表达，这都是一个节省时间的重要步骤。如果你知道该去哪里找，很多信息是可以获取的。我们从最简单的方式开始，也就是在键盘前，之后我们将使用螺丝刀和其他工具。'
- en: Before delving into the deeper recesses of the internet, you might consider
    just searching for the given product name along with the keyword *teardown*. It’s
    common to have teardowns of popular products posted in numerous sources; the iFixit
    website([https://www.ifixit.com/](https://www.ifixit.com/)), for example, has
    many popular teardowns, including detailed annotations of the products. For consumer
    goods, watch for multiple generations of the products. The Nest Protect smart
    smoke alarm second-generation device is very different internally from the first-generation
    device, for example. It’s common that companies won’t actually differentiate such
    generations, as they simply stop selling the older generation devices, so you
    may need to figure that out from model numbers or similar.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入网络的更深处之前，你或许可以先搜索给定产品名称加上关键词*拆解*。常常会在多个来源中找到热门产品的拆解；例如，iFixit网站([https://www.ifixit.com/](https://www.ifixit.com/))上就有许多流行产品的拆解，并附有详细的产品注释。对于消费品，注意查看产品的多个代际版本。例如，Nest
    Protect智能烟雾报警器第二代设备在内部结构上与第一代设备有很大不同。公司通常不会区分这些代际产品，因为他们会停止销售旧一代设备，所以你可能需要通过型号或类似的信息来判断。
- en: Federal Communications Commission Filings
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 美国联邦通信委员会档案
- en: The *Federal Communications Commission (FCC)* is a US government agency responsible
    for everything from imposing fines for exposing specific body parts on TV to ensuring
    that the latest high-speed wireless devices don’t interfere with each other. It
    sets regulations that manufacturers of any digital device sold in the US must
    follow. These regulations are designed to ensure that a given device doesn’t generate
    excessive amounts of interference (for example, your whiz-bang 5000 causing your
    neighbor’s TV reception to drop out) and continues to operate even in the presence
    of some level of electromagnetic (EM) interference.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*联邦通信委员会 (FCC)* 是美国的一个政府机构，负责从对电视上暴露特定身体部位罚款到确保最新的高速无线设备不会相互干扰等一切事务。它制定了美国市场上任何数字设备制造商必须遵守的规定。这些规定旨在确保设备不会产生过量的干扰（例如，你那款超炫的
    5000 型设备导致邻居电视信号中断），并能在一定程度的电磁（EM）干扰下继续正常工作。'
- en: Other countries have similar agencies and rules. The FCC is interesting because
    the US is such a large market, so most products have been designed and/or tested
    to meet FCC rules, and the FCC makes the database of filed information publicly
    available.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 其他国家也有类似的机构和规定。FCC 特别有趣的是，因为美国是一个非常大的市场，所以大多数产品都是为了符合 FCC 规定而设计和/或测试的，并且 FCC
    将备案信息数据库公开提供。
- en: About FCC Filings
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关于 FCC 备案
- en: Any digital device that emits radio waves, known as an intentional radiator,
    requires testing. The FCC requires manufacturers to test their devices’ emissions
    carefully and provide documentation proving devices meet FCC rules. It’s a very
    expensive process, and the FCC needs to ensure that it is easy for the public
    to check compliance. This is why, for instance, the open source flash-drive-sized
    computer called the *USB armory Mk I* is labeled as a development platform that
    “may cause interference to electrical or electronic devices in close proximity.”
    Proving that this label may be unjustified is expensive.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 任何发射无线电波的数字设备，称为有意辐射源，都需要进行测试。FCC 要求制造商仔细测试设备的辐射，并提供文档证明设备符合 FCC 规定。这是一个非常昂贵的过程，FCC
    需要确保公众能够轻松检查合规性。因此，像 *USB armory Mk I* 这样的开源闪存驱动器大小的计算机，标明它是一个开发平台，“可能会对附近的电气或电子设备造成干扰。”证明该标签可能不合理是非常昂贵的。
- en: For compliance checking by the public, an intentional radiator must publish
    something known as its *FCC ID*, which is printed on the device’s label. You can
    search for this ID on the FCC website and confirm that the device did indeed pass
    compliance testing. This also means detecting fake FCC labels is easy because
    anybody can check the status, not just FCC agents.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让公众进行合规性检查，有意辐射源必须公布一个称为 *FCC ID* 的标识，印在设备标签上。你可以在 FCC 网站上搜索该 ID，并确认该设备确实通过了合规性测试。这也意味着检测假冒
    FCC 标签变得很容易，因为任何人都可以检查状态，而不仅仅是 FCC 的工作人员。
- en: A device’s FCC label may be inside a battery cover. [Figure 3-1](#figure3-1)
    shows an example of the label on a D-Link router.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 设备的 FCC 标签可能位于电池盖内部。[图 3-1](#figure3-1) 显示了 D-Link 路由器标签的一个例子。
- en: '![f03001](image_fi/278748c03/f03001.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![f03001](image_fi/278748c03/f03001.png)'
- en: 'Figure 3-1: D-Link FCC label'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1：D-Link FCC 标签
- en: If a device isn’t an intentional radiator, it still must have the FCC compliance
    logo, but it won’t have an FCC ID. These unintentional radiators have less strict
    reporting requirements, and the test documentation is often not available.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备不是有意辐射源，它仍然必须有 FCC 合规标志，但不会有 FCC ID。这些无意辐射源的报告要求较少，测试文档通常也不公开。
- en: Finding FCC Filings
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找 FCC 备案
- en: 'As an example, the wireless router’s label in [Figure 3-1](#figure3-1) shows
    that the FCC ID is KA2IR818LA1, which you can find on the FCC ID Search website.
    The search tool separates the ID into two parts: the grantee code and the product
    code. The FCC assigns the grantee code, and it’s always the same for a given company.
    This code was previously only the first three characters of the FCC ID, but as
    of May 1, 2013, it can be either three or five characters. The company assigns
    the product code, which can be anything from 1 to 14 characters.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，[图 3-1](#figure3-1) 中无线电路由器的标签显示 FCC ID 为 KA2IR818LA1，你可以在 FCC ID 搜索网站上找到该
    ID。搜索工具将该 ID 分为两部分：授权代码和产品代码。FCC 分配授权代码，并且对于某个特定公司来说，这个代码始终是相同的。此前，该代码只有 FCC ID
    的前三个字符，但自 2013 年 5 月 1 日起，它可以是三位或五位字符。公司分配产品代码，长度可以从 1 到 14 个字符不等。
- en: Going back to the router, the grantee code is KA2, and the product code is IR818LA1\.
    Entering this information into the search box gives the results shown in . This
    device has three filings, because it has multiple frequency bands in which it
    can operate. The Detail link provides reports and letters, including external
    and internal product photos—normally photos of the board(s) as well as details
    about the integrated circuits.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 回到路由器，授权代码是KA2，产品代码是IR818LA1。将这些信息输入搜索框后，会显示出如图所示的结果。该设备有三个备案，因为它可以在多个频段中工作。点击详细链接可查看报告和信函，包括外部和内部产品照片——通常是电路板的照片以及集成电路的详细信息。
- en: Pulling up the internal photos based on the FCC ID KA2IR818LA1, you should easily
    be able to identify the main processor as an RTL8881AB. You can also see some
    sort of header, which is most likely serial-based, as it has around four pins
    and a number of test points on the printed circuit board (PCB). You’ve found all
    of this information without even touching a screwdriver.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 基于FCC ID KA2IR818LA1调出内部照片后，你应该能轻松识别出主处理器是RTL8881AB。你还可以看到某种类型的头针，这很可能是串行接口，因为它有大约四个引脚，并且电路板（PCB）上有多个测试点。你在没有动用螺丝刀的情况下就找到了所有这些信息。
- en: '![f03002](image_fi/278748c03/f03002.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![f03002](image_fi/278748c03/f03002.png)'
- en: 'Figure 3-2: FCC ID search results'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-2：FCC ID搜索结果
- en: FCC Equivalents
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: FCC 等效项
- en: The Nest doorbell in [Figure 3-3](#figure3-3) shows no FCC ID. Why? Colin bought
    this device, and he’s located in Canada, so the device doesn’t require an FCC
    ID. Instead, it’s marked only with the Industry Canada (IC) code, which allows
    you to search the Industry Canada “Radio Equipment List (REL)” database for a
    matching “certification number.”
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-3中的Nest门铃没有显示FCC ID。为什么？Colin购买了这款设备，并且他位于加拿大，所以该设备不需要FCC ID。相反，它只标有加拿大工业（IC）代码，这允许你在加拿大工业“无线设备列表（REL）”数据库中搜索匹配的“认证号”。
- en: '![f03003](image_fi/278748c03/f03003.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![f03003](image_fi/278748c03/f03003.png)'
- en: 'Figure 3-3: Nest doorbell'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-3：Nest门铃
- en: Searching the IC REL database for 9754A-NC51 provides more information, but
    no detailed internal photos are available on the public website. The product code
    part of the reference (NC51) is shared between the FCC ID and the IC designator,
    so a quick way to find more information is to do a partial search at [https://FCCID.io/](https://FCCID.io/)
    for NC51\. We found that the FCC ID is ZQANC51, which allowed us to find the internal
    photos.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在IC REL数据库中搜索9754A-NC51会提供更多信息，但公共网站上没有详细的内部照片。参考资料中的产品代码部分（NC51）在FCC ID和IC设计标识符之间是共享的，因此快速查找更多信息的方法是到[https://FCCID.io/](https://FCCID.io/)进行部分搜索，查找NC51。我们发现FCC
    ID是ZQANC51，这让我们找到了内部照片。
- en: Patents
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 专利
- en: Patents are effectively licenses given to product developers to sue companies
    who sell a product that copies the well-defined operation of the original product,
    in a specific geographic area, for a limited period of time. Patents, in theory,
    are issued only if that well-defined operation is something novel. The goal is
    to protect inventions, and since this chapter is about information gathering and
    not politics, we’ll leave it at that.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 专利实际上是授予产品开发者的许可证，使其能够起诉在特定地理区域内销售复制原始产品运行方式的产品的公司，且在有限的时间内有效。理论上，专利只有在该明确的操作是新颖的情况下才会被授予。专利的目标是保护发明，由于本章讨论的是信息收集而非政治，我们就此打住。
- en: 'Most companies like patents since they can use them to stop a competitor from
    releasing a product using some new technology or design. But there is a catch:
    patents must explain how that new technology works. The idea is that in exchange
    for giving away precious details about the new technology, the legal system can
    stop anyone else from using those details to compete with the inventor for that
    limited period of time.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数公司喜欢专利，因为他们可以利用专利来阻止竞争对手发布使用某种新技术或设计的产品。但有一个前提：专利必须解释该新技术如何运作。其背后的理念是，作为交换，为了透露关于新技术的宝贵细节，法律系统可以阻止任何人使用这些细节与发明者在有限的时间内进行竞争。
- en: Finding Patents
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找专利
- en: When researching a device, you might find that patents provide useful information
    about how security or other aspects of the design were handled. For example, in
    researching a password-protected hard drive, we found a patent that describes
    a method of securing hard drives by scrambling the partition table.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究设备时，你可能会发现专利提供了关于如何处理设计中安全性或其他方面的有用信息。例如，在研究一个密码保护的硬盘时，我们找到了一项专利，描述了一种通过打乱分区表来保护硬盘的方法。
- en: Products or manuals might be stamped with some sort of statement like “Protected
    by US Patent 7,324,123.” You can easily look up this patent number on the United
    States Patent and Trademark Office (USPTO) website or on a third-party website,
    such as Google Patents. We recommend Google Patents, as it searches multiple databases
    and also contains an easily navigated search tool for general-purpose use.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 产品或手册上可能会有类似“受美国专利7,324,123保护”的声明。你可以轻松地在美国专利商标局（USPTO）网站或第三方网站（如Google Patents）上查找该专利号。我们推荐使用Google
    Patents，因为它可以搜索多个数据库，并且包含一个易于导航的通用搜索工具。
- en: Often products are labeled “Patent Pending,” or you may find only references
    to patents in the product literature. This normally means the company has simply
    applied for a patent; it might not even be publicly viewable yet. In that case,
    the only reasonable method of searching for those patents is by company name.
    Determine to whom the patent is likely assigned; for example, a patent might be
    owned by the manufacturer of a chip inside the device and not the manufacturer
    of the device itself. Often you can find related patents issued to the company
    and then search by the company’s law firm or even patents by other related inventors.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 产品上常常标有“专利申请中”字样，或者你可能只会在产品文献中找到专利的引用。这通常意味着公司已经提交了专利申请，但该专利可能尚未公开。在这种情况下，搜索这些专利的唯一合理方法是通过公司名称来查找。确定专利可能归属的公司；例如，一个专利可能属于设备内部芯片的制造商，而不是设备本身的制造商。通常你可以找到授予该公司相关专利，并进一步通过该公司的律师事务所或其他相关发明人的专利进行搜索。
- en: If you find a patent (or patent application), the actual published application
    isn’t all the information you can use. A system called the USPTO Public PAIR allows
    you to review almost all correspondence between the USPTO and patent applicant.
    Those documents are not indexed by search engines, so you won’t find them without
    using the USPTO Public PAIR system. You can see, for example, if the USPTO has
    been fighting against an application in cases where patents are pending, or you
    can find supporting documentation that applicants may have uploaded. Sometimes
    you can find earlier versions of a patent or an applicant’s arguments, including
    additional information you won’t find on Google Patents.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你找到了一项专利（或专利申请），实际发布的申请并不是你可以使用的所有信息。有一个名为USPTO Public PAIR的系统，可以让你查看几乎所有USPTO与专利申请人之间的通信。这些文件不会被搜索引擎索引，所以如果不使用USPTO
    Public PAIR系统，你是找不到这些文件的。例如，你可以看到USPTO是否在专利待审的情况下与申请人争论，或者你可以找到申请人可能上传的支持文档。有时你还可以找到专利的早期版本或申请人的论点，其中包含一些在Google
    Patents上找不到的额外信息。
- en: 'Some examples of interesting uses of patents for reverse engineering include
    the Thangrycat attack by Red Balloon Security, detailed in a DEF CON presentation
    titled “100 Seconds of Solitude: Defeating Cisco Trust Anchor with FPGA Bitstream
    Shenanigans.” In this attack, Red Balloon Security defeated the Cisco root of
    trust, which used an electronic component called a *field-programmable gate array
    (FPGA)*. Details of the architecture were helpfully explained in US Patent 9,830,456,
    which provided insights that otherwise would have required considerable effort
    to reverse engineer.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '一些有趣的专利逆向工程应用案例包括Red Balloon Security的Thangrycat攻击，详细内容见DEF CON报告《100 Seconds
    of Solitude: 利用FPGA比特流恶作剧突破思科信任锚》。在这次攻击中，Red Balloon Security突破了思科的信任根，它使用了一种名为*现场可编程门阵列（FPGA）*的电子组件。美国专利9,830,456详细解释了架构，这些信息原本需要大量的逆向工程工作才能获得。'
- en: 'Another example where patents were useful for hardware hackers is a presentation
    at Black Hat USA titled “GOD MODE UNLOCKED: Hardware Backdoors in x86 CPUs,” by
    Christopher Domas. Here, US Patent 8,296,528 explained how a separate processor
    could be connected to the main x86 core and hinted at details that resulted in
    a complete compromise of the core’s security mechanism.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '另一个专利对硬件黑客有用的例子是在Black Hat USA上的一个报告，标题为“GOD MODE UNLOCKED: x86 CPU中的硬件后门”，由Christopher
    Domas主讲。在这里，美国专利8,296,528解释了如何将一个独立的处理器连接到主x86核心，并暗示了一些细节，这些细节最终导致了核心安全机制的完全被攻破。'
- en: Patents may even list details about secure devices. For example, a Square credit
    card reader contains an anti-tamper “mesh” integrated into a plastic cover for
    the secure section of the microcontroller. [Figure 3-4](#figure3-4) shows the
    four large square pads (we’ll talk more about PCB features later in this chapter)
    with oval sections that will connect to the tamper mesh cover.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 专利甚至可能列出关于安全设备的详细信息。例如，Square信用卡读卡器包含一个集成在微控制器安全部分塑料外壳中的防篡改“网格”。[图3-4](#figure3-4)显示了四个大方形垫片（我们将在本章后面讨论更多PCB特征），这些垫片上有椭圆形区域，能够与防篡改网格外壳连接。
- en: '[Figure 3-5](#figure3-5) shows the underside of the tamper mesh cover that
    mates to the PCB shown in [Figure 3-4](#figure3-4).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-5](#figure3-5)显示了与[图3-4](#figure3-4)中所示的PCB连接的防篡改网格外壳的底部。'
- en: '![f03004](image_fi/278748c03/f03004.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![f03004](image_fi/278748c03/f03004.png)'
- en: 'Figure 3-4: The Square credit card reader internals with four tamper shield
    connectors near each corner'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-4：Square信用卡读卡器内部结构，四个防篡改保护连接器位于每个角落附近
- en: '![f03005](image_fi/278748c03/f03005.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![f03005](image_fi/278748c03/f03005.png)'
- en: 'Figure 3-5: The Square reader’s tamper shield; the exposed connections will
    mate with the PCB shown in [Figure 3-4](#figure3-4)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-5：Square读卡器的防篡改保护罩；暴露的连接将与[图3-4](#figure3-4)中显示的PCB连接。
- en: When you remove the mesh, the device will stop working, so reverse engineering
    the device quickly becomes expensive. If you search Google Patents for US10251260B1,
    however, you’ll find details about how the mesh works. Try that now and see if
    you can match the photos from Figures 3-4 and 3-5 to patent figures. If you haven’t
    worked with PCBs before, come back to these figures again after you finish this
    chapter, as we’ll explain some of the PCB features you can see here.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你移除网格时，设备将停止工作，因此对设备进行逆向工程会迅速变得非常昂贵。然而，如果你在Google专利中搜索US10251260B1，你会找到有关网格工作原理的详细信息。现在试试，看看能否将图3-4和图3-5的照片与专利图纸进行匹配。如果你以前没有接触过PCB，等你完成本章后再回来看这些图，我们会解释一些你可以在这里看到的PCB特征。
- en: Datasheets and Schematics
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Datasheet 和原理图
- en: Manufacturers publish datasheets (either publicly or under NDA) so designers
    can learn how to use their components, but they usually don’t publish complete
    schematics. Instead, you usually can find publicly shared *logical* designs that
    show how components are interconnected. For instance, a PCB layout shows the physical
    design—that is, where all components are placed and how the wires are routed,
    but it’s usually not publicly available.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 制造商发布datasheet（无论是公开的还是在保密协议下）以便设计师了解如何使用他们的组件，但他们通常不发布完整的原理图。相反，你通常可以找到公开共享的*逻辑*设计，展示组件如何互联。例如，PCB布局展示了物理设计——即所有组件的放置位置以及电线如何布置，但它通常不会公开。
- en: Try finding a datasheet online for your favorite device or development board,
    such as for a Raspberry Pi computer module or an Intel 8086 processor, or a random
    datasheet for flash or DRAM memory. Or, if you want to go analog, find a level-shifter
    datasheet. Usually, you just need to do a simple internet search for product IDs
    or other identifiers, as mentioned earlier. Websites like findchips ([https://www.findchips.com/](https://www.findchips.com/))
    also are helpful for locating current products.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在线查找你最喜欢的设备或开发板的datasheet，例如树莓派计算模块或英特尔8086处理器，或者随机查找闪存或DRAM内存的datasheet。或者，如果你想了解模拟电路，可以找一个电平转换器的datasheet。通常，你只需要根据前面提到的产品ID或其他标识符进行简单的互联网搜索。像findchips这样的网页([https://www.findchips.com/](https://www.findchips.com/))也有助于定位当前产品。
- en: 'Datasheets for a specific part may be a bit harder to find. For components,
    first determine the part number (see the “Identifying ICs on the Board” section
    on page 86). The part number often appears to be a random-looking collection of
    letters and numbers, but they encode the available various configurations of a
    part. For instance, the datasheet for the MT29F4G08AAAWP breaks the part number
    down as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 查找特定零件的 datasheet 可能会有些困难。对于组件，首先确定零件号（请参见第86页的“识别电路板上的IC”部分）。零件号通常看起来像是随机的字母和数字组合，但它们编码了零件的各种配置。例如，MT29F4G08AAAWP的datasheet将零件号分解如下：
- en: MT stands for Micron Technology.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MT代表美光科技。
- en: 29F is the product family of NAND flash memory.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29F是NAND闪存的产品系列。
- en: 4G indicates a 4GB storage capacity.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4G表示4GB存储容量。
- en: 08 indicates an 8-bit device.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 08表示一个8位设备。
- en: First “A” means one die, one command pin, and one device status pin.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个“A”表示一个芯片，一个命令引脚和一个设备状态引脚。
- en: Second “A” indicates an operating voltage of 3.3 V.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个“A”表示工作电压为3.3V。
- en: Third “A” is a listed feature set.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个“A”是列出的特性集。
- en: WP indicates that the component is a 48-pin thin small outline package (TSOP).
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WP表示该组件是一个48引脚薄小型外形封装（TSOP）。
- en: When searching, simply type in any part number you find on the die. If you can’t
    find the exact number, trim off some of the last characters and search again or
    allow your search engine to suggest some nearly matching names.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索时，只需输入你在芯片上找到的任何零件编号。如果找不到精确的编号，可以去掉一些最后的字符再试，或者让你的搜索引擎建议一些相似的名称。
- en: Oftentimes you’ll have too many matches, because on very small parts, a full
    part number isn’t printed, but only a shorter *marking code*. Unfortunately, searching
    the marking code will return hundreds of unrelated matches. For example, a particular
    part on a board may simply be labeled *UP9*, which is almost unsearchable. If
    you search the marking code along with the package type, you will often get more
    useful hits. In this example, we had identified the package as being an SOT-353
    package type (we discuss package types later in this chapter). For marking codes
    specifically, you can find SMD (surface-mount device) marking code databases,
    such as [https://smd.yooneed.one/](https://smd.yooneed.one/) and [http://www.s-manuals.com/smd/](http://www.s-manuals.com/smd/),
    which, combined with your knowledge of the package, can lead you to the device
    (in this case, a Diodes, Inc., 74LVC1G14SE).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你会遇到过多的匹配结果，因为在一些非常小的元件上，完整的零件编号没有打印出来，只有一个较短的*标记代码*。不幸的是，搜索标记代码时，可能会返回成百上千个不相关的结果。例如，某个板上的特定元件可能仅仅标记为*UP9*，这几乎无法搜索。如果你将标记代码与封装类型一起搜索，通常会得到更有用的结果。在这个例子中，我们已经确认该封装为SOT-353封装类型（我们将在本章后面讨论封装类型）。针对标记代码，您可以找到SMD（表面贴装设备）标记代码数据库，例如[https://smd.yooneed.one/](https://smd.yooneed.one/)和[http://www.s-manuals.com/smd/](http://www.s-manuals.com/smd/)，结合您对封装的了解，能够帮助你找到该设备（在此案例中是Diodes,
    Inc.的74LVC1G14SE）。
- en: 'After looking at a few datasheets, you’ll find they have something in common.
    They seldom contain interesting information from a security viewpoint. We’re mainly
    concerned with interacting with a device, which means discovering how it works
    and how to connect to it. The introductory blurb will contain the functionality:
    it’s a CPU, a flash device, or whatever. To connect to it, we look for the pinout
    and any parameters describing the pins, such as functionality, protocol, or voltage
    levels. You’ll almost certainly find some of the interfaces discussed in Chapter
    2.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在查阅了几个数据手册后，你会发现它们有一些共同点。它们很少包含从安全角度有趣的信息。我们主要关心的是如何与设备互动，这意味着要了解它如何工作以及如何连接到它。引言部分会包含功能说明：它是一个CPU、闪存设备或其他什么设备。要连接到它，我们需要查看引脚排列图以及任何描述引脚的参数，例如功能、协议或电压等级。你几乎肯定会找到一些在第二章中讨论的接口。
- en: 'Information Search Example: The USB Armory Device'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信息搜索示例：USB Armory设备
- en: 'Let’s look for information on the USB armory Mk I device from Inverse Path
    (acquired by F-Secure) as an example. It’s an open source piece of hardware, so
    we’ll be able to access plenty of detail. Before reading all the spoilers here,
    try researching it yourself. Go find the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Inverse Path（被F-Secure收购）的USB Armory Mk I设备为例来查找信息。它是一个开源硬件，因此我们可以访问很多细节。在阅读这里的所有内容之前，尝试自己进行研究。去查找以下内容：
- en: The manufacturer and part number of the main System-on-Chip (SoC), as well as
    the datasheet for it.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主系统芯片（SoC）的制造商、零件编号，以及其数据手册。
- en: The GPIO and UART on the PCB.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PCB上的GPIO和UART。
- en: Any JTAG ports exposed on the board.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 板上暴露的任何JTAG端口。
- en: The power supply wires and voltage on the PCB.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PCB上的电源线和电压。
- en: The external clock crystal wires and frequency.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部时钟晶体线和频率。
- en: Where the I2C interface from the main SoC connects to another IC, and what the
    protocol is.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主SoC上的I2C接口连接到另一个IC的位置以及该协议。
- en: The boot configuration pins on the SoC, where they are connected on the PCB,
    and what boot mode and configurations this selects.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SoC上的启动配置引脚，它们在PCB上的连接方式，以及选择的启动模式和配置。
- en: Manufacturer, Part Number, and Datasheet
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 制造商、零件编号和数据手册
- en: 'From the USB armory GitHub pages and wiki ([https://inversepath.com/usbarmory_mark-one.html](https://inversepath.com/usbarmory_mark-one.html)),
    we can see that the USB armory is based on an NXP i.MX53 ARM Cortex-A8\. The datasheet
    is called *IMX53IEC.pdf* and is available in several places. When searching for
    “imx53 vulnerability,” we found a known X.509 vulnerability on the Quarkslab blog.
    If you dig further, you may be able to find an advisory titled “Security Advisory:
    High Assurance Boot (HABv4) Bypass,” which notes these vulnerabilities are not
    present in the Mk II.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '从 USB armory 的 GitHub 页面和 Wiki（[https://inversepath.com/usbarmory_mark-one.html](https://inversepath.com/usbarmory_mark-one.html)）上，我们可以看到
    USB armory 基于 NXP i.MX53 ARM Cortex-A8。数据表名为 *IMX53IEC.pdf*，可以在多个地方找到。当搜索“imx53
    vulnerability”时，我们在 Quarkslab 博客上找到了已知的 X.509 漏洞。如果继续深入查找，可能会找到一份名为“Security Advisory:
    High Assurance Boot (HABv4) Bypass”的公告，指出这些漏洞在 Mk II 中不存在。'
- en: The GPIO and UART on the PCB
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PCB 上的 GPIO 和 UART
- en: Searching for “USB armory GPIO,” we arrive at its GitHub wiki ([https://github.com/f-secure-foundry/usbarmory/wiki/GPIOs/](https://github.com/f-secure-foundry/usbarmory/wiki/GPIOs/)),
    which provides the GPIO detail. In the datasheet sourced in the previous section,
    we can find all of the i.MX53’s GPIO, UART, I2C, and SPI pins. Any of those communications
    ports would be interesting to monitor; they will surely transport console or debug
    output.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索“USB armory GPIO”，我们找到了其 GitHub Wiki（[https://github.com/f-secure-foundry/usbarmory/wiki/GPIOs/](https://github.com/f-secure-foundry/usbarmory/wiki/GPIOs/)），该页面提供了
    GPIO 的详细信息。在前一节中提到的数据表中，我们可以找到所有 i.MX53 的 GPIO、UART、I2C 和 SPI 引脚。任何一个通信端口都很有趣，值得监控；它们肯定会传输控制台或调试输出。
- en: JTAG Ports
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JTAG 端口
- en: JTAG, if not locked down, should provide low-level access to the chip via ARM’s
    debugging facilities, so we want information about any JTAG ports exposed on the
    board. Exploring the GitHub pages a bit more yields the JTAG page specific for
    the Mk I ([https://github.com/f-secure-foundry/usbarmory/wiki/JTAG-(Mk-I)/](https://github.com/f-secure-foundry/usbarmory/wiki/JTAG-(Mk-I)/)),
    which includes a PCB photo (see [Figure 3-6](#figure3-6)).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有被锁定，JTAG 应该能够通过 ARM 的调试功能提供对芯片的低级访问，因此我们需要了解任何暴露在板上的 JTAG 端口。进一步探索 GitHub
    页面可以找到专门针对 Mk I 的 JTAG 页面（[https://github.com/f-secure-foundry/usbarmory/wiki/JTAG-(Mk-I)/](https://github.com/f-secure-foundry/usbarmory/wiki/JTAG-(Mk-I)/)），该页面包含了
    PCB 照片（见 [图 3-6](#figure3-6)）。
- en: '![f03006](image_fi/278748c03/f03006.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![f03006](image_fi/278748c03/f03006.png)'
- en: 'Figure 3-6: USB armory JTAG connector pins'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-6：USB armory JTAG 连接器引脚
- en: '[Figure 3-6](#figure3-6) shows the standard TCK, TMS, TDI, TDO, nTRST, and
    GND (ground) JTAG connections. The 2v8 pad provides a 2.8 V supply, but what about
    the MOD pad? The datasheet is not very clear about that. The JTAG_MOD/sjc_MOD
    is in the i.MX53 pinout list, but there’s no explanation of its meaning. A bit
    of searching for related products yields an explanation on the i.MX6 computer
    module datasheet (search for “IMX6DQ6SDLHDG.pdf”; the original NXP site requires
    a sign-in, but the PDF is mirrored in other places). This datasheet explains that
    *low* adds all system test access ports (TAPs) to the chain, whereas *high* makes
    it IEEE1149.1- compliant (only useful for boundary scan, which we’ll discuss in
    the section “Using the JTAG Boundary Scan for Mapping” on page 106). Reading the
    schematic at the bottom of the Mk I JTAG page, you’re advised to tie it to ground
    via a pulldown resistor; this pulls it *low* to enable system TAPs. As you can
    see, sometimes synthesizing different information sources completes the picture.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-6](#figure3-6) 显示了标准的 TCK、TMS、TDI、TDO、nTRST 和 GND（地）JTAG 连接。2v8 引脚提供 2.8V
    电源，但 MOD 引脚怎么样呢？数据表对此没有明确说明。JTAG_MOD/sjc_MOD 在 i.MX53 引脚分配表中有列出，但并没有解释其含义。通过搜索相关产品，我们在
    i.MX6 计算机模块的数据表中找到了一个解释（搜索“IMX6DQ6SDLHDG.pdf”；原 NXP 网站需要登录，但该 PDF 在其他地方有镜像）。该数据表解释了
    *low* 将所有系统测试访问端口（TAP）加入链中，而 *high* 使其符合 IEEE1149.1 标准（仅对边界扫描有用，边界扫描的使用将在第 106
    页的“使用 JTAG 边界扫描进行映射”一节中讨论）。查看 Mk I JTAG 页面底部的原理图，建议通过下拉电阻将其接地；这样可以将其 *low* 拉低，以启用系统
    TAPs。正如你所看到的，有时综合不同的信息来源可以补全全貌。'
- en: Power Supply and Voltage
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 电源和电压
- en: For the power supply wires and voltage on the PCB, we go to the datasheet we
    sourced previously. Search for “power,” “Vcc,” “Vdd,” “Vcore,” “Vfuse,” and “ground/Vss.”
    You’ll discover that a modern SoC includes many repeated instances of those terms,
    each one representing a pin. Various subsystems on the power planes have multiple
    input voltages, which is one reason for this abundance of pins. For example, the
    flash memory may have a higher voltage than the core voltage. You may also find
    multiple I/O voltages that support a variety of standards.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 PCB 上的电源线和电压，我们可以查阅之前获取的数据表。搜索“power”、“Vcc”、“Vdd”、“Vcore”、“Vfuse” 和“ground/Vss”。你会发现现代
    SoC 包括多个重复的这些术语实例，每个都代表一个针脚。电源层的各种子系统具有多个输入电压，这也是为什么有如此众多的针脚的原因之一。例如，闪存存储器可能具有比核心电压更高的电压。你还可能会发现支持多种标准的多个
    I/O 电压。
- en: A second reason for the many pins is that they are often duplicated, sometimes
    several times over. This helps keep power and ground pins physically close to
    each other, reducing inductance to help deliver fast power transients to the chip.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个针脚数量众多的原因是它们经常会重复，有时甚至会多次重复。这有助于将电源和地针物理上靠近彼此，减少电感，帮助快速传递电源瞬变给芯片。
- en: The datasheet certainly includes many power pins, which in this chip are denoted
    as VCC (peripheral core voltage) and VDDGP (ARM core voltage), among other designations.
    We look for power pins to find ways to inject faults and do power analysis, which
    are techniques you’ll learn about in the next few chapters. For instance, if you
    want to listen in on crypto on the ARM core, you’d try to probe VDDGP. If you
    want to glitch L1 cache (VDDAL1), JTAG access control (NVCC_JTAG), or fuse writes
    (NVCC_FUSE), you’d try to control those.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 数据表中当然包含许多电源针脚，在此芯片中标记为 VCC（外围核心电压）和 VDDGP（ARM 核心电压），以及其他设计ations。我们寻找电源针脚以找到注入故障和进行电力分析的方法，这些技术将在接下来的几章中学习。例如，如果你想监听
    ARM 核心上的加密内容，你可以尝试探测 VDDGP。如果你想干扰 L1 缓存（VDDAL1）、JTAG 访问控制（NVCC_JTAG）或熔断写入（NVCC_FUSE），你可以尝试控制这些针脚。
- en: A schematic is really helpful to learn how these power pins are connected on
    the circuit board. We found one in the GitHub hardware repository as *armory.pdf*
    ([https://raw.githubusercontent.com/inversepath/usbarmory/b42036e7c3460b6eb515b608b3e8338f408bcb22/hardware/mark-one/armory.pdf](https://raw.githubusercontent.com/inversepath/usbarmory/b42036e7c3460b6eb515b608b3e8338f408bcb22/hardware/mark-one/armory.pdf)).
    Page 3 of this PDF lists the power connections to the SoC. If you follow the PCB
    traces from these power connections, you’ll see a bunch of decoupling capacitors
    (marked C48, C49, and so on), which are used for de-noising the power supply.
    You’ll also notice that the connection names end in labels like PMIC_SW1_VDDGP
    and PMIC_SW2_VCC. *PMIC* stands for power management IC—a chip dedicated to supplying
    the right voltages. Page 2 of the PDF shows how the main power source (USB_VBUS)
    feeds into the main power plane (5V_MAIN) and into the PMIC, which in turn feeds
    the variety of regulated voltages to the SoC.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的原理图对于学习这些电源针脚如何在电路板上连接非常有帮助。我们在 GitHub 硬件库中找到了一份名为 *armory.pdf* 的原理图（[https://raw.githubusercontent.com/inversepath/usbarmory/b42036e7c3460b6eb515b608b3e8338f408bcb22/hardware/mark-one/armory.pdf](https://raw.githubusercontent.com/inversepath/usbarmory/b42036e7c3460b6eb515b608b3e8338f408bcb22/hardware/mark-one/armory.pdf)）。PDF
    的第三页列出了与 SoC 的电源连接。如果你跟随这些电源连接的 PCB 追踪线路，你会看到一堆去噪电容器（标记为 C48、C49 等），这些电容器用于去除电源噪声。你还会注意到连接名称以
    PMIC_SW1_VDDGP 和 PMIC_SW2_VCC 等标签结尾。*PMIC* 意为电源管理 IC，专用于提供正确的电压。PDF 的第二页显示了主要电源（USB_VBUS）如何进入主要电源层（5V_MAIN），然后进入
    PMIC，进而向 SoC 提供各种稳定电压。
- en: This tells us logically how everything is connected, but it doesn’t yet tell
    us where these wires are on the PCB. For that, we need to open the PCB’s layout
    files, found in the KiCAD design files.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们逻辑上一切是如何连接的，但还没有告诉我们这些线路在 PCB 上的具体位置。为此，我们需要打开 KiCAD 设计文件中的 PCB 布局文件。
- en: KiCAD is open source software for designing PCBs. We’re only using one percent
    of its functionality here to check out the PCB layout. We opened the *armory.kicad_pcb*
    design file with KiCAD’s `pcbnew` command. A PCB might include several layers
    of conductive tracks/traces, where each of those layers is shown on the right
    side of the program window, with checkboxes to enable and disable them. Disable
    them all first to see only the pads on the PCB. You’ll see the “U2” (main SoC’s
    ball grid) in the center, the “U1”/PMIC to the left, and the “U4”/DRAM chip to
    the right.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: KiCAD 是用于设计 PCB 的开源软件。在这里，我们只使用它的百分之一功能来检查 PCB 布局。我们通过 KiCAD 的 `pcbnew` 命令打开了
    *armory.kicad_pcb* 设计文件。一个 PCB 可能包括多层导电轨迹/走线，这些层会显示在程序窗口的右侧，并带有复选框用于启用和禁用它们。首先禁用所有层，只显示
    PCB 上的焊盘。你会看到“U2”（主 SoC 的球阵列）位于中间，“U1”/PMIC 在左侧，“U4”/DRAM 芯片在右侧。
- en: KiCAD has a nice tool to highlight a net, appropriately called *highlight net*,
    that allows you to click anywhere and follow the connection. Say we want to play
    around with the power to JTAG. Zoom in to the SoC until you see the ball names
    and find the NVCC_JTAG ball, which according to the datasheet is G9\. You’ll see
    what is shown in [Figure 3-7](#figure3-7).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: KiCAD 有一个很好的工具叫做 *highlight net*，可以让你点击任意位置并跟踪连接。假设我们想玩弄 JTAG 电源。缩放到 SoC，直到看到球名称，并找到
    NVCC_JTAG 球，根据数据表它位于 G9\。你会看到如 [图 3-7](#figure3-7) 所示的内容。
- en: 'Remember the JTAG pads? It seems that NVCC_JTAG is connected to the 2v8 pad
    used for JTAG power. However, near the PMIC, you’ll also see some wires highlighted.
    They are part of the same net; we just can’t see that part because we’ve switched
    off all the layers. Clicking all layers on and off, we find one layer that connects
    them: GND_POWER_1(see [Figure 3-8](#figure3-8)).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 记得 JTAG 焊盘吗？看起来 NVCC_JTAG 连接到了用于 JTAG 电源的 2v8 焊盘。不过，在 PMIC 附近，你还会看到一些高亮显示的线。这些线属于同一网络，只是我们看不见这一部分，因为我们已关闭了所有层。通过逐个启用和禁用各层，我们发现有一层连接了它们：GND_POWER_1（见
    [图 3-8](#figure3-8)）。
- en: The white dots are *vias*, which are small plated holes connecting a trace on
    one layer to a trace on another layer. One via is on the left connection to the
    PMIC, and then a power plane connects to the via on the right, which connects
    to the wire that goes to NVCC_JTAG. If we wanted to control the power on *NVCC_JTAG*
    for fault injection or power analysis, we could physically cut the trace to the
    PMIC and provide our own 2.8 V by soldering a wire to the 2v8 pad.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 白色圆点是 *vias*，即连接一层走线与另一层走线的小镀孔。一个 via 位于与 PMIC 连接的左侧，另一侧通过电源平面连接到右侧的 via，然后连接到通往
    NVCC_JTAG 的线。如果我们想控制 *NVCC_JTAG* 的电源进行故障注入或电源分析，我们可以物理切断与 PMIC 的走线，并通过焊接一根线到 2v8
    焊盘来提供自己的 2.8 V 电压。
- en: '![f03007](image_fi/278748c03/f03007.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![f03007](image_fi/278748c03/f03007.png)'
- en: 'Figure 3-7: Using KiCAD to highlight an interconnection network'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-7：使用 KiCAD 高亮显示一个互连网络
- en: '![f03008](image_fi/278748c03/f03008.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![f03008](image_fi/278748c03/f03008.png)'
- en: 'Figure 3-8: Highlighting the GND_POWER_1 layer'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-8：高亮显示 GND_POWER_1 层
- en: Clock Crystal and Frequency
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 时钟晶体与频率
- en: 'To identify the external clock crystal wires and the frequency clocks, we again
    refer to the datasheet we sourced a previously. Search for “clock/CLK/XTAL,” and
    you’ll discover four interesting external oscillator pins: XTAL and CKIL (and
    their complementary inputs EXTAL and ECKIL), and two general-purpose inputs, CKIH1
    and CKIH2\. Searching for those inputs, we find the “i.MX53 System Development
    User’s Guide” as *MX53UG.pdf*. The section on these inputs, in turn, refers to
    the “i.MX53 Reference Manual,” which we find as *iMX53RM.pdf*. According to the
    reference manual, you program the latter inputs to supply a clock to various peripherals,
    such as the CAN network and SPDIF port. Looking at the board schematics, we find
    that (E)XTAL is connected to a 24 MHz oscillator, (E)CKIL is connected to a 32,768
    Hz oscillator, and CKIH1 and CKIH2 are pulled to ground. The USB armory schematics
    show that those pins are connected to two sets of pads, which correspond to two
    oscillators. Those oscillators are the rather huge components in [Figure 3-9](#figure3-9).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别外部时钟晶体线和频率时钟，我们再次参考之前获取的数据手册。搜索“clock/CLK/XTAL”，你将发现四个有趣的外部振荡器引脚：XTAL 和 CKIL（及其互补输入
    EXTAL 和 ECKIL），以及两个通用输入 CKIH1 和 CKIH2。通过搜索这些输入，我们找到了“i.MX53 系统开发用户指南”，文件名为 *MX53UG.pdf*。该部分内容提到的输入，再次引用了“i.MX53
    参考手册”，我们找到的文件是 *iMX53RM.pdf*。根据参考手册，你可以编程这些输入，为各种外设提供时钟，如 CAN 网络和 SPDIF 端口。查看板子原理图，我们发现（E）XTAL
    连接到一个 24 MHz 的振荡器，（E）CKIL 连接到一个 32,768 Hz 的振荡器，而 CKIH1 和 CKIH2 被拉到地面。USB armory
    原理图显示这些引脚连接到两组焊盘，对应两个振荡器。这些振荡器就是[图 3-9](#figure3-9)中非常大的组件。
- en: '![f03009](image_fi/278748c03/f03009.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![f03009](image_fi/278748c03/f03009.png)'
- en: 'Figure 3-9: Oscillators have a white silkscreen box around them.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-9：振荡器周围有白色丝印框。
- en: 'Clock control is significant for two main purposes: synchronizing side-channel
    measurements to the device clock and facilitating clock fault-injection experiments.
    In this case, the EXTAL input goes through a frequency multiplier, which then
    clocks the ARM core. Here, the PLLs (phase-locked loops) that turn the external
    frequency into an internal clock may eat up any weirdness in your clock, so clock
    fault injection may be a no-go, but we can still insert our own clock into these
    pins to provide more precise clock synchronization to count clock cycles. If you
    are going for clock synchronization, you don’t even need to remove the crystal
    on the board. You can feed in a clock to the crystal circuit, and it will force
    the crystal oscillator circuit to run on the clock pulses that you will inject.
    (See Chapter 4 for more on clock fault injection.)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟控制对两个主要目的至关重要：同步设备时钟的侧信道测量，以及促进时钟故障注入实验。在这种情况下，EXTAL 输入通过一个频率倍增器，然后为 ARM 核提供时钟。这里的
    PLL（锁相环）将外部频率转换为内部时钟，可能会消除时钟中的任何异常，因此时钟故障注入可能无法进行，但我们仍然可以将自己的时钟注入到这些引脚中，以提供更精确的时钟同步来计数时钟周期。如果你要进行时钟同步，甚至不需要移除板上的晶体。你可以将时钟信号输入到晶体电路中，它将迫使晶体振荡器电路按照你注入的时钟脉冲运行。（更多关于时钟故障注入的内容，请参见第
    4 章。）
- en: The I2C Interface
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: I2C 接口
- en: We need to determine where the I2C interface from the main SoC connects to another
    integrated circuit (IC) and what the protocol on that interface is. The USB armory
    schematics show that pins 30 and 31 are I2C, and the i.MX53 datasheet shows three
    I2C controllers. We can trace the layout to find a connection to V3, which is
    named EIM_D21 and is one of the GPIOs. EIM_D21 is either SPI or I2C-1\. This is
    an example of a multiplexed pin; the SoC itself can be configured to talk various
    low-level protocols on the pin.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确定主 SoC 的 I2C 接口连接到另一个集成电路（IC）的位置，并且确定该接口上的协议是什么。USB armory 原理图显示第 30 和
    31 引脚是 I2C，i.MX53 数据手册显示有三个 I2C 控制器。我们可以追踪布局，找到连接到 V3 的线，该接口名为 EIM_D21，是 GPIO
    之一。EIM_D21 要么是 SPI，要么是 I2C-1。这是一个多路复用引脚的例子；SoC 本身可以配置为在该引脚上执行各种低级协议。
- en: As for the high-level protocol, we have to dig a little deeper—specifically,
    into the PMIC datasheet. The PMIC is identified as an LTC3589 in the PCB schematic,
    and the datasheet is called *3589fh.pdf*. In the “I2C Operation” section, the
    datasheet precisely defines the protocol.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 至于高级协议，我们需要深入挖掘——具体来说，是查看 PMIC 数据手册。PMIC 在 PCB 原理图中标识为 LTC3589，数据手册名为 *3589fh.pdf*。在
    “I2C 操作”部分，数据手册详细定义了该协议。
- en: The Boot Configuration Pins
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启动配置引脚
- en: Knowing where the boot configuration pins are, where they are connected on the
    PCB, and what boot mode and configurations the pins select is really helpful.
    For now, we’re providing an example of how to find data; don’t worry about understanding
    the technicalities.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 了解引导配置引脚的位置、它们在PCB上的连接方式，以及这些引脚选择的引导模式和配置是非常有帮助的。目前，我们提供了一个如何查找数据的示例；无需担心理解技术细节。
- en: The i.MX53 datasheet (*IMX53IEC.pdf*) mentions various BOOT_MODE and BOOT_CFG
    pins, but it does not define what they do. In the schematics for the Mk I, we
    find that BOOT_MODE pins (C18 and B20) are not connected to power or ground on
    the PCB.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: i.MX53的数据手册（*IMX53IEC.pdf*）提到各种BOOT_MODE和BOOT_CFG引脚，但没有定义它们的功能。在Mk I的原理图中，我们发现BOOT_MODE引脚（C18和B20）没有连接到电源或地线。
- en: Let’s first find out what it means that BOOT_MODE is not connected. The i.MX53
    datasheet has a table that claims for BOOT_MODE0 and BOOT_MODE1, the “config.
    value” is 100 kΩ PD. PD stands for *pulldown*, so if the pin is not connected,
    it is internally pulled down to ground. This means that the BOOT_MODE0 and BOOT_MODE1
    pins are at logical 0 when not connected. The datasheet mentions nothing more,
    but the i.MX53 reference manual (*iMX53RM.pdf*, which is 5,100 pages of goodness)
    gives the high-level boot sequence and shows that BOOT_MODE[1:0]=0b00 means *internal
    boot*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先弄清楚BOOT_MODE未连接意味着什么。i.MX53的数据手册中有一张表格，声明对于BOOT_MODE0和BOOT_MODE1，"配置值"为100
    kΩ下拉电阻。PD代表*下拉*，因此如果引脚未连接，它会被内部下拉到地。这意味着当引脚未连接时，BOOT_MODE0和BOOT_MODE1引脚的逻辑值为0。数据手册没有提及更多信息，但i.MX53参考手册（*iMX53RM.pdf*，这是一本5100页的好资料）提供了高级引导序列，显示BOOT_MODE[1:0]=0b00表示*内部引导*。
- en: Now, for BOOT_CFG, the i.MX53 datasheet shows that all of these BOOT_CFG pins
    are connected to pins starting with EIM_, such as EIM_A21\. Keep in mind this
    is a pin name, not a coordinate. If you keep searching the datasheet, you’ll see
    that EIM_A21 is a name of the pin at location AA4 (this AA4 is a location on the
    chip, a BGA ball). With that information, we can look at the Mk I schematic to
    see how these pins are connected.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于BOOT_CFG，i.MX53的数据手册显示，所有这些BOOT_CFG引脚都连接到以EIM_开头的引脚，例如EIM_A21\。请记住，这只是引脚的名称，而不是坐标。如果继续查找数据手册，你会发现EIM_A21是位于AA4位置的引脚名称（这个AA4是芯片上的位置，指的是BGA焊球）。有了这些信息，我们可以查看Mk
    I原理图，看看这些引脚是如何连接的。
- en: It turns out that all BOOT_CFG pins are grounded, with the exception of BOOT_CFG2[5]/EIM_DA0/Y8
    and BOOT_CFG1[6]/EIM_A21/AA4, which are pulled up to 3.3 V through a resistor.
    These bits are set to 1, whereas all other BOOT_CFG bits are set to 0\. Searching
    for BOOT_CFG in the reference manual, we find Table 7-8, “Boot Device Selection,”
    which has a line specifying that BOOT_CFG1[7:4] set to 0100 or 0101 means to boot
    from the SD card (written in the table as 010X). The effect of setting BOOT_CFG2[5]
    seems to depend on the boot mode selected. Since we just found out it’s booting
    from the SD card, Table 7-15, “ESDHC Boot eFUSE Descriptions,” is relevant. It
    indicates that BOOT_CFG2[5]=1 means we are using a 4-bit bus width on the SD card.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示，除了BOOT_CFG2[5]/EIM_DA0/Y8和BOOT_CFG1[6]/EIM_A21/AA4这两个引脚外，所有BOOT_CFG引脚都接地。BOOT_CFG2[5]和BOOT_CFG1[6]通过一个电阻上拉到3.3V。这些位被设置为1，而所有其他BOOT_CFG位被设置为0。在参考手册中查找BOOT_CFG，我们找到了第7-8表，“引导设备选择”，其中有一行指定BOOT_CFG1[7:4]设置为0100或0101表示从SD卡引导（在表中写为010X）。设置BOOT_CFG2[5]的效果似乎取决于所选择的引导模式。既然我们刚刚发现是从SD卡引导，那么第7-15表，“ESDHC引导eFUSE描述”，是相关的。它指出BOOT_CFG2[5]=1表示我们使用的是SD卡的4位总线宽度。
- en: And remember that MOD pin for which we couldn’t find proper information? That
    reference manual has everything you want to know about it and more, under the
    sjc_mod pin, which also confirms the information we found before. Don’t despair
    if you can’t find what you need at first.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得那个我们找不到相关信息的MOD引脚吗？参考手册中有你想知道的所有信息，甚至更多，关于sjc_mod引脚的描述也确认了我们之前找到的信息。如果你一开始找不到需要的信息，别灰心。
- en: Those are just a few examples of the kinds of questions you can answer from
    various sources of documentation. Datasheets are usually easy to find; schematics
    and PCB layouts and/or reference designs are rare. However, you can reverse engineer
    information as well, as you’ll see in the next section, “Opening the Case.”
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是你可以从不同文档来源回答的一些问题的例子。数据手册通常很容易找到；而原理图、PCB布局和/或参考设计比较少见。不过，你也可以通过逆向工程来获取信息，正如你将在下一节“打开外壳”中看到的那样。
- en: Opening the Case
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开外壳
- en: As with any reverse engineering task, your objective is to get into the system
    designer’s head. Through research, clues, and a little guesswork, the idea is
    to understand just enough to complete your task. We are not reverse engineering
    for the purpose of cloning or fully extracting schematics; we just want to know
    how to modify and/or attach to a PCB in order to reach our goal. If you are lucky,
    someone has looked at this device (or a similar device) before, and as mentioned
    earlier, you can try to find teardowns of the products already posted.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 和任何逆向工程任务一样，你的目标是进入系统设计者的思维。通过研究、线索和一点猜测，目的是理解足够的信息以完成任务。我们进行逆向工程的目的不是为了克隆或完整提取电路图，而是希望知道如何修改和/或连接到PCB，从而实现我们的目标。如果幸运的话，可能有人已经研究过这个设备（或类似设备），如前所述，你可以尝试查找已有的拆解报告。
- en: What starts out as a collection of IC serial numbers, a handful of external
    ports, and a seemingly infinite number of resistors and capacitors will turn into
    an understanding of the system. And with a bit of luck, you can find a test point
    or debug port that will provide even more access.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 起初可能只有一堆集成电路的序列号、少量外部端口，以及看似无穷无尽的电阻和电容，但随着时间的推移，你将逐渐理解系统的工作原理。如果运气好，你还可以找到一个测试点或调试端口，进一步获得更多的访问权限。
- en: Identifying ICs on the Board
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别电路板上的集成电路
- en: We don’t use one specific device to demonstrate the technique for identifying
    ICs, so if you want to follow along, find a cheap IoT (internet of things) or
    similar device that you won’t mind ripping open.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并没有使用特定的设备来演示识别IC的技巧，因此，如果你想跟着做，可以找一款便宜的物联网（IoT）设备或类似设备，确保你不介意将其拆开。
- en: Most PCBs you’ll encounter in modern electronics are mounted on the PCB’s surface,
    in contrast with the through-hole mounting of times past. This is called *surface-mount
    technology (SMT)*, and any device on it is called a *surface-mount device (SMD)*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你在现代电子设备中遇到的大多数印刷电路板（PCB）都是表面贴装的，与过去的通孔插装方式不同。这种技术叫做*表面贴装技术（SMT）*，其上任何元件都叫做*表面贴装元件（SMD）*。
- en: Once you’ve opened a device, you’ll usually see a single PCB with a bunch of
    components (check the front and back of the PCB), the largest of which will likely
    be the main SoC, DRAM, and external flash storage, as shown in [Figure 3-10](#figure3-10).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你打开设备，通常会看到一块单独的PCB，上面有许多组件（检查PCB的正反面），其中最大的组件可能是主SoC、DRAM和外部闪存存储，如[图 3-10](#figure3-10)所示。
- en: In the top center of [Figure 3-10](#figure3-10) is a DSPGroup DVF97187AA2ANC
    main SoC 1. To the left of that is an EtronTech EM63A165TS-6G SDRAM in a TSSOP
    package 2, and above the SDRAM is Winbond 25Q128JVSQ flash memory in an SOIC-8
    package 3. In addition, there is a Realtek RTL8304MB Ethernet controller 4. This
    particular device is a very low-cost IP phone, which might explain why the SoC
    and SDRAM are brands you’ve likely not heard of before.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 3-10](#figure3-10)的顶部中央位置，是一款DSPGroup DVF97187AA2ANC主SoC 1。其左侧是EtronTech
    EM63A165TS-6G SDRAM，采用TSSOP封装 2，SDRAM上方是Winbond 25Q128JVSQ闪存，采用SOIC-8封装 3。除此之外，还有一款Realtek
    RTL8304MB以太网控制器 4。这款设备是一个非常低成本的IP电话，这或许能解释为何其SoC和SDRAM是你可能从未听说过的品牌。
- en: The first step is to read the die markings on the chips. You can usually get
    pretty far with a phone camera. [Figure 3-11](#figure3-11) shows photos of another
    device, an HDMI RCA audio splitter, taken with a regular phone camera and microscope
    app.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是读取芯片上的标记。你通常可以通过手机摄像头得到相当清晰的图像。[图 3-11](#figure3-11)展示了另一款设备——HDMI RCA 音频分配器的照片，这些照片是用普通手机摄像头和显微镜应用程序拍摄的。
- en: '![f03010](image_fi/278748c03/f03010.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![f03010](image_fi/278748c03/f03010.png)'
- en: 'Figure 3-10: Identifying ICs on the board'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-10：识别电路板上的集成电路（IC）
- en: '![f03011](image_fi/278748c03/f03011.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![f03011](image_fi/278748c03/f03011.png)'
- en: 'Figure 3-11: Die markings: on the left, with flash and a good angle; in the
    middle, with flash and bad angle; on the right, with natural light'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-11：芯片标记：左侧为闪光灯和良好角度；中间为闪光灯和不良角度；右侧为自然光
- en: As you can see, playing with different angles and with the flashlight on or
    off, you should be able to take a suitable photo for reading die markings. Alternatively,
    cheap USB microscope cameras will do the job; see Appendix A for hardware information.
    The photos in [Figure 3-12](#figure3-12) were taken with such a camera.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通过改变拍摄角度并开关手电筒，你应该能拍出适合读取芯片标记的照片。另一种选择是使用便宜的USB显微镜摄像头；有关硬件信息，请参见附录A。[图
    3-12](#figure3-12)中的照片就是用这种相机拍摄的。
- en: '![f03012](image_fi/278748c03/f03012.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![f03012](image_fi/278748c03/f03012.png)'
- en: 'Figure 3-12: Photos taken with a USB microscope camera'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-12：使用USB显微镜摄像头拍摄的照片
- en: Once you have the die markings, employ your reconnaissance skills to dig up
    information on the part. Especially if you’re doing this for the first time, try
    to identify all of the ICs and their datasheets. Even though most of the smaller
    components may be insignificant from a security point of view, you’ll learn a
    bit about all that’s needed to make a device tick. We’ve learned much about voltage
    regulators and other funny little ICs this way.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: For some chips, it’s a little trickier to get to the main IC because of a heatsink
    or protective potting. You can remove heatsinks relatively easily, either by unscrewing
    them or gently pulling them off the IC. If the heatsink is stuck on (typical with
    small devices), a twisting motion will help remove it instead of trying to pry
    or pull it up directly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: You’ll encounter protective potting in higher-security systems where the manufacturer
    wants to avoid access to the IC. Simply chipping away at it may be unsuccessful,
    but you’ll likely find heating it up with a heat gun nicely softens the epoxy,
    and you can then remove it with a tool such as a dental pick. If you want to remove
    the epoxy completely, try a chemical such as Xylene or paint removers (available
    in hardware stores).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Small Leaded Packages: SOIC, SOP, and QFP'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In your quest for IC identification, you’ll encounter various types of beasts.
    Identifying the packages is useful for several reasons for the hardware hacker.
    First, you can find this information useful when searching for datasheets. Second,
    the type of package can actually affect what attacks you can perform. Some of
    the very tiny packages provide almost chip-level access, and probes we’ll discuss
    in later chapters are easier to use on these tiny packages. [Figure 3-13](#figure3-13)
    shows some of the main small leaded packages you’ll find.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![f03013](image_fi/278748c03/f03013.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-13: Small leaded packages: SOIC, TSSOP, and TQFP styles'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: All of the packages in [Figure 3-13](#figure3-13) have leads on them; the difference
    is the relative size between leads (pitch) and the leads’ locations. Many variants
    exist within these families that we also won’t go into here, because for our purposes,
    they are equivalent. For example, you might see references to both *thin quad
    flat pack (TQFP)* and *plastic quad flat pack (PQFP**)*, which look almost identical
    and have similar pin pitch, counts, and package sizes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The largest is the *small outline integrated circuit (SOIC)*, which has pins
    on two sides of the package and typically has a pin-to-pin spacing of 1.27 mm.
    This package is nice because you can fit grabber clips on it. Often SPI flash
    memory chips are in 8- or 16-pin wide SOIC packages.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: A smaller version of the SOIC is the *small outline package (SOP**)*, often
    in the thin SOP (TSOP) or thin-shrink SOP (TSSOP) variant. All of these also have
    pins only on two edges, but with pin pitches typically in the 0.4 mm to 0.8 mm
    range. Wide TSOP packages with 48 pins, as shown in [Figure 3-14](#figure3-14),
    are almost certain to be parallel flash memory chips.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: SOIC的一个更小版本是*小外形封装（SOP）*，通常为薄型SOP（TSOP）或薄缩型SOP（TSSOP）。这些封装也仅在两个边缘有引脚，且引脚间距通常在0.4
    mm到0.8 mm之间。宽型TSOP封装（如[图 3-14](#figure3-14)所示的48引脚封装）几乎肯定是并行闪存芯片。
- en: '![f03014](image_fi/278748c03/f03014.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![f03014](image_fi/278748c03/f03014.png)'
- en: 'Figure 3-14: A 48-pin TSOP package'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-14：48引脚TSOP封装
- en: Finally, the *quad flat pack (QFP)* package has legs on all four edges and is
    often seen in the *thin QFP (TQFP)* or *plastic QFP (PQFP)* package. These have
    small changes in material or thickness, but the general form factor is the same.
    Pin pitch typically varies within the 0.4 mm to 0.8 mm range.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*四方扁平封装（QFP）*的封装在四个边缘都有引脚，通常见于*薄型QFP（TQFP）*或*塑料QFP（PQFP）*封装。这些封装在材料或厚度上有小的变化，但整体外形保持不变。引脚间距通常在0.4
    mm到0.8 mm之间。
- en: The TQFP’s internal construction basically has a small central IC die, which
    is connected to a *leadframe*. If you sand off sections of the IC, you can see
    the relative sizes, as shown in [Figure 3-15](#figure3-15) for a TQFP-64 package.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: TQFP的内部结构基本上包含一个小的中央IC芯片，它通过*引线框*与引脚连接。如果你打磨掉IC的一部分，你可以看到它的相对大小，如[图 3-15](#figure3-15)所示，这是一个TQFP-64封装。
- en: If you want to keep things more intact, you can also use acid decapsulation,
    but sandpaper is something almost everyone can safely use.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想保持物品更完好无损，你也可以使用酸性脱封装方法，但砂纸是几乎每个人都能安全使用的工具。
- en: '[Figure 3-16](#figure3-16) is a simple diagram of the SOIC/SOP/TQFP’s internal
    construction and shows the bonding wires connecting the chip to the leads. What
    was clearly removed in [Figure 3-15](#figure3-15) was any hint of bonding wires
    when the chip was sanded from the top down.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-16](#figure3-16)是SOIC/SOP/TQFP内部结构的简易示意图，展示了连接芯片和引脚的键合线。在[图 3-15](#figure3-15)中，显然移除了芯片从顶部往下打磨时所有的键合线痕迹。'
- en: '![f03015](image_fi/278748c03/f03015.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![f03015](image_fi/278748c03/f03015.png)'
- en: 'Figure 3-15: QFP package; from left to right: top sanded off, cross-section,
    and unharmed'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-15：QFP封装；从左到右：顶部打磨掉、截面图和完好无损
- en: '![f03016](image_fi/278748c03/f03016.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![f03016](image_fi/278748c03/f03016.png)'
- en: 'Figure 3-16: Internal construction of an SOIC/SOP/TQFP package'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-16：SOIC/SOP/TQFP封装的内部结构
- en: 'No-Lead Packages: SO and QFN'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无引脚封装：SO和QFN
- en: No-lead packages are similar to the previous SOIC/QFP packages, but instead
    of leads, a pad underneath the chip is soldered onto the PCB. This pad often (but
    not always) extends just to the edge of the device, so you’ll normally see a small
    protruding solder joint on the edge of the chip with those packages. [Figure 3-17](#figure3-17)
    is a simple diagram of these no-lead devices.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 无引脚封装与之前的SOIC/QFP封装类似，但不使用引脚，而是将芯片下方的焊盘焊接到PCB上。这个焊盘通常（但并不总是）延伸到设备的边缘，所以你通常会看到芯片边缘有一个小的凸起焊点。
    [图 3-17](#figure3-17)是这些无引脚设备的简易示意图。
- en: '![f03017](image_fi/278748c03/f03017.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![f03017](image_fi/278748c03/f03017.png)'
- en: 'Figure 3-17: No-lead package'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-17：无引脚封装
- en: The *small outline no-lead (SON)* package has connections on only two edges.
    These devices have typical pitches in the 0.4 mm to 0.8 mm range. As in other
    packages, many variants exist, such as *thin SON (TSON)*. You may also see various
    custom pin layouts where pads are missing. The SON package almost always has a
    central thermal pad underneath it that is also soldered to the PCB, meaning you
    will likely need hot air to solder or remove this package. Because you can’t reach
    the large hidden central pad with a soldering iron, you need some method of heating
    it indirectly, through either the device package or the PCB.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*小外形无引脚（SON）*封装仅在两个边缘有连接。此类设备的典型引脚间距在0.4 mm到0.8 mm之间。和其他封装一样，也有许多变体，例如*薄型SON（TSON）*。你也可能会看到各种定制的引脚布局，其中一些焊盘可能缺失。SON封装几乎总是有一个中央热焊盘，焊盘下方通常会焊接到PCB上，这意味着你很可能需要使用热风来焊接或拆卸这个封装。由于你无法用焊接铁触及到隐藏的中央焊盘，你需要通过某种方法间接加热它，可以通过设备封装或PCB进行加热。'
- en: Also, pay attention to the WSON package type, which officially seems to be called
    both *very-very thin SON* and *wide SON*. This package is much wider than normal
    and often has a 1.27 mm pitch. It’s frequently used for SPI flash memory chips.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，注意WSON封装类型，官方似乎同时称其为*超薄SON*和*宽型SON*。该封装比普通的SON封装宽，通常具有1.27 mm的引脚间距，常用于SPI闪存芯片。
- en: The *quad flat no-lead (QFN)* package has connections on four edges. These devices
    have typical pitches in the 0.4 mm to 0.8 mm range. Again, you will almost always
    see a thermal pad in the center of these devices. They are widely used and can
    be anything from the main microcontroller to a power-switching regulator.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Ball Grid Array
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Ball grid array (BGA)* packages have balls on the bottom of the chip, as shown
    in [Figure 3-18](#figure3-18), and you won’t be able to see them from the top.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![f03018](image_fi/278748c03/f03018.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-18: BGA package'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: You can see the edge balls if you can get the angle right, as shown in [Figure
    3-19](#figure3-19), where you can also see that there is actually a smaller *carrier
    PCB*. The BGA chip itself is composed of a smaller PCB with the chip mounted onto
    it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![f03019](image_fi/278748c03/f03019.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-19: View of edge balls'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: BGA parts are frequently used for the main processor or SoC. Some eMMC and flash
    devices will also use a BGA package, and smaller BGAs hanging off the side of
    the main processor are often DRAM chips in more complex systems.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: There are actually several variants of BGA devices, which can be important for
    power analysis and fault injection, so we’ll detail that construction difference
    here. Vendors use slightly different names, but we keep with the Fujitsu naming
    process here (*a810000114e-en.pdf*), which typically maps to names other vendors
    use.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Plastic BGA and Fine Pitch BGA
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Plastic BGA (PBGA)* devices typically have a 0.8 mm to 1.0 mm pitch (see [Figure
    3-20](#figure3-20)). The chip is internally bonded to a carrier board that has
    the solder balls on it.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![f03020](image_fi/278748c03/f03020.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-20: Plastic BGA'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '*Fine pitch BGAs (FPBGAs)* are similar to PBGAs, but with a finer grid (typically
    0.4 mm to 0.8 mm). Again, the device is mounted on a carrier PCB.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Thermally Enhanced Ball Grid Array
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *thermally enhanced ball grid array (TEBGA)* shown in [Figure 3-21](#figure3-21)
    has a noticeable metal area on the BGA itself.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![f03021](image_fi/278748c03/f03021.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-21: Thermally enhanced ball grid array'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: This metal area is part of an integrated heat spreader, which helps provide
    a better thermal connection to both the bottom solder balls and a heatsink mounted
    on top of the package.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Flip-Chip Ball Grid Array
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Flip-chip BGAs (FC-BGAs)*, as shown in [Figure 3-22](#figure3-22), do away
    with the internal bond wires. Instead, the chip itself is effectively a much smaller
    BGA (which would be difficult to work with) that is soldered on to the carrier
    PCB. The difference here is that the internal “LSI chip” is *upside down* compared
    to the previous BGA devices.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![f03022](image_fi/278748c03/f03022.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-22: Flip-chip ball grid array'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: On other packages, such as PBGA/FBGA/TEBGA, internal bond-wires touch the “top
    metal” layer of the internal LSI chip. On the FC-BGAs, that top metal layer is
    on the bottom, with very small solder balls mounted on it. This type of package
    also may have small integrated passives, such as decoupling capacitors. With FC-BGAs,
    it may be possible to remove the heat spreader or “lid” to get closer to the actual
    chip for fault injection or side-channel analysis.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他封装中，如PBGA/FBGA/TEBGA，内部的引线会接触到内部LSI芯片的“顶部金属”层。在FC-BGA中，该金属层位于底部，上面装有非常小的焊球。这种封装类型还可能包含小型的集成无源元件，例如去耦电容。对于FC-BGA封装，可能可以去除散热器或“盖子”，以更接近实际芯片进行故障注入或侧信道分析。
- en: Chip Scale Packaging
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 芯片级封装
- en: '*Chip scale packaging (CSP)* is effectively where you are given a piece of
    the sawed-off chip wafer. In the internal structure shown in [Figure 3-23](#figure3-23),
    there is no encapsulant on the top side.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*芯片级封装 (CSP)* 本质上是将切割下来的芯片晶圆的一部分提供给你。在[图3-23](#figure3-23)所示的内部结构中，顶部没有封装材料。'
- en: '![f03023](image_fi/278748c03/f03023.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![f03023](image_fi/278748c03/f03023.png)'
- en: 'Figure 3-23: CSP internal structure'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-23：CSP内部结构
- en: The provided device is almost no bigger than it physically needs to be, and
    typically some very fine-pitch balls on the bottom of the CSP provide the connection
    to the PCB. The name CSP may have modifiers, such as the *wafer-level CSP (WLCSP)*.
    Think of CSPs as the LSI chip part of the flip-chip BGA. They have a very small
    pitch (0.4 mm or finer typically). You can often easily spot these devices, as
    the surface will look noticeably different from a regular BGA.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的设备几乎只有它物理上所需要的大小，通常CSP底部会有一些非常细小的球状连接焊点，用于连接到PCB。CSP这个名称可能有一些修饰词，如 *晶圆级CSP
    (WLCSP)*。可以将CSP视为翻转芯片BGA的LSI芯片部分。它们的引脚间距非常小（通常为0.4毫米或更细）。你通常可以很容易地识别这些设备，因为其表面与常规BGA有明显的不同。
- en: DIP, Through-Hole, and Others
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DIP、穿孔封装及其他
- en: The oldestpackages are through-hole, and you aren’t too likely to run into them
    on real products, especially for ICs. You *will* encounter the DIP package in
    hobby or kit products (such as an Arduino).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最早的封装是穿孔封装，尤其是IC封装中，现实产品中不太可能遇到它们。你*会*在爱好或套件产品（例如Arduino）中遇到DIP封装。
- en: Another relatively outdated technology is *plastic leaded chip carrier (PLCC)*,
    which can be either soldered directly to a PCB or placed in a socket. These devices
    were often used for microcontrollers, and if you are looking at an old product
    using an 8051 microcontroller, you may well run into one.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种相对过时的技术是 *塑料引脚芯片载体 (PLCC)*，它可以直接焊接到PCB上，或者插入插座中。这些设备常用于微控制器，如果你在查看一款使用8051微控制器的老旧产品，可能会遇到这种封装。
- en: Sample IC Packages on PCBs
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PCB上的示例IC封装
- en: Rather than provide a bunch of photos of parts by themselves, we thought it
    would be more useful to show what they look like in-circuit. Let’s look at four
    sample boards pulled from real products. [Figure 3-24](#figure3-24) shows a communications
    daughterboard from a smart lock.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并没有单独提供大量零件的照片，而是认为展示它们在电路板中的实际样子更为有用。让我们来看一下从实际产品中取出的四块样本板。[图3-24](#figure3-24)展示了一块来自智能锁的通信子板。
- en: '![f03024](image_fi/278748c03/f03024.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![f03024](image_fi/278748c03/f03024.png)'
- en: 'Figure 3-24: Example IC packages from a smart lock'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-24：智能锁的示例IC封装
- en: 'The three packages marked in [Figure 3-24](#figure3-24) are as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-24](#figure3-24) 中标出的三个封装类型如下：'
- en: '**QFN package**: The main microcontroller on this device (EM3587).'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**QFN封装**：该设备的主要微控制器（EM3587）。'
- en: '**WSON package**: SPI flash chip (this package size is frequently used for
    SPI flash).'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**WSON封装**：SPI闪存芯片（这种封装尺寸常用于SPI闪存）。'
- en: '**BGA package**: We can’t see any edge connections, so it’s likely a small
    BGA.'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**BGA封装**：我们无法看到任何边缘连接，因此很可能是一个小型BGA。'
- en: Let’s take a different smart lock device and see what we can find (see [Figure
    3-25](#figure3-25)).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们换一个不同的智能锁设备，看看能发现什么（见 [图3-25](#figure3-25)）。
- en: '![f03025](image_fi/278748c03/f03025.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![f03025](image_fi/278748c03/f03025.png)'
- en: 'Figure 3-25: IC package examples from another smart lock'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-25：另一款智能锁的IC封装示例
- en: '[Figure 3-25](#figure3-25) shows the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-25](#figure3-25) 显示了以下内容：'
- en: '**Eight-pin SOIC**: This might be SPI flash based on an eight-pin SOIC (the
    part number confirms it’s SPI flash).'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**八引脚SOIC**：这可能是基于八引脚SOIC的SPI闪存（零件编号确认它是SPI闪存）。'
- en: '**TQFP package**: The main microcontroller for this device.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**TQFP封装**：该设备的主要微控制器。'
- en: '**QFN package**: The co-processor chip (in this case, for audio).'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**QFN封装**：协处理器芯片（在这种情况下用于音频）。'
- en: '**Eight-pin wide SOIC package**: This is certainly SPI flash due to the wide
    package.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**TSOP/TSSOP package**: Unknown IC.'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**TSON package**: Unknown IC.'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continuing with our consumer electronics examples, next let’s look at a board
    from a smart doorbell (see [Figure 3-26](#figure3-26)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![f03026](image_fi/278748c03/f03026.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-26: IC package examples from a smart doorbell'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-26](#figure3-26) shows the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '**A very small BGA**: Unknown IC.'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**TSON-style very small device (pins on two sides only)**: Unknown IC.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**QFN-style very small device (pins on all four sides)**: Unknown IC.'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**CSP package with an almost mirror-like finish**: The main microcontroller,
    BCM4354KKUBG. Underneath this device are 395 balls with 0.2 mm spacing (we told
    you CSP is small).'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a final example, [Figure 3-27](#figure3-27) shows a board from an automotive
    electronic control unit (ECU).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![f03027](image_fi/278748c03/f03027.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-27: IC packages from an automotive ECU'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-27](#figure3-27) shows the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '**BGA package**: The main processor for this device.'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**TSSOP package**: Digital flip-flop.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**QFP package (only the edge is visible here)**: Unknown IC.'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SOIC package**: Digital logic gate.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**TSSOP package**: Two unknown ICs.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identifying Other Components on the Board
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve looked at the main ICs, let’s explore some other components.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Ports
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ports are a good starting point for making connections to a device and understanding
    the function of the various components they interconnect. The ports for digital
    I/O are the most interesting, as they may be used for normal device communication
    or provide debugging interfaces.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Once you identify the port type based on its appearance, you typically find
    the type of protocol used on the port. (See Chapter 2 for a refresher on various
    port protocols.) If you can’t identify the port based on appearance alone, hook
    up an oscilloscope to measure voltages and recognize data patterns. Note the high
    and low voltages, as well as the duration of the shortest pulse you see. The shortest
    pulse will give you the *bitrate*, such as an 8.68 microsecond pulse, which translates
    into an 115,200 bitrate on a UART. The bitrate is typically the rate of toggling
    of a single bit; the shortest pulse normally indicates a 0 or 1\. We get the rate
    by taking the inverse. In this case, 1 / 0.00000868 = 115,207, and we round it
    to a standard baud rate of 115,200.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, trace the PCB lines from the port to an IC and then use information
    from the IC’s pinout to identify the port type.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Headers
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Headers* are basically internal ports and therefore are interesting to look
    at because they may expose some functionality that’s not intended for normal users
    but instead is included in the design for debugging, manufacturing, or repair.
    You may find, among others, JTAG, UART, and SPI/I2C ports internally. Sometimes
    headers are not actually installed on the PCB, but their solder pads are still
    there, so some easy soldering can provide access. [Figure 3-28](#figure3-28) shows
    an example of several surface-mount headers.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![f03028](image_fi/278748c03/f03028.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-28: PCB headers'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The middle header is marked JTAG. This header wasn’t mounted, but we soldered
    it onto the pads, which provided JTAG access to the main IC, as the IC did not
    have any memory read-out protection enabled. This particular header was an Ember
    Packet Trace Port Connector. See Appendix B for several handy header pinouts.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Through-hole headers are easier to probe, but small devices probably need a
    surface-mount header. [Figure 3-29](#figure3-29) shows a classic UART header inside
    a device.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![f03029](image_fi/278748c03/f03029.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-29: A UART header in a device'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The header is the four pins in a row marked with “J404” on the board (note that
    J404 is upside down in the figure). There is no “standard” pinout for this header.
    You’ll need to perform some reverse engineering of it. The pin on the left can
    be visually seen to connect to the larger “ground plane,” and you could confirm
    this with a multimeter. We’ll cover this later in the section “Mapping the PCB”
    on page 102.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Analog Electronics
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most of the small components you find are analog electronics (resistors and
    capacitors), although you can also find inductors, oscillators, transistors, and
    diodes as SMDs. Capacitors and resistors have specific characteristics pertinent
    to this book. The PCB shown in [Figure 3-30](#figure3-30) has many of them.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Capacitors (like C31 in [Figure 3-30](#figure3-30)) can store and release little
    bits of charge, and they’re often used to filter a signal. Capacitors are like
    very fast and small rechargeable batteries. They can charge and discharge millions
    of times per second, which means any fast voltage swings are counteracted either
    by charging or discharging the capacitor. The effect is that of a “low-pass filter.”
    This is one of the reasons you’ll see a lot of capacitors around ICs, connected
    between the power supply and ground. In this function, they are called *decoupling
    capacitors*, and their role is to provide a localized source of power for the
    IC, which prevents electrical noise from being injected into the power line. They
    also help keep noise from other areas from reaching the IC. We discuss *voltage
    fault injection (VFI)* more in Chapter 5, but imagine that if VFI relies on fast
    changes in supply voltage, decoupling capacitors undo the effects of VFI. Therefore,
    we first remove as many decoupling capacitors as we can without letting the system
    become unstable.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![f03030](image_fi/278748c03/f03030.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-30: Surface-mount resistors and capacitors'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Resistors (like R26 in [Figure 3-30](#figure3-30)), as the name implies, resist
    the flow of current, and for our purposes, the most interesting functions are
    that of a shunt resistor, a pullup/pulldown resistor (explained in Chapter 2),
    and a zero-ohm resistor. Shunt resistors measure the current through an IC when
    doing side-channel analysis (see Chapter 8 for more details). Surface-mount resistors
    typically have a number printed on them that indicates the resistance value; for
    example, abc refers to ab × 10^c ohm resistance.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, zero-ohm resistors (like R29 in [Figure 3-30](#figure3-30)) may seem
    a bit mysterious because they offer no resistance; they are basically wires. Their
    raison d’être is allowing configuration of a board at manufacturing time: zero-ohm
    resistors can be installed using the same manufacturing techniques as other resistors.
    By placing them, or not placing them, an electrical circuit can be open or closed,
    which can be used, for instance, as a configuration input to ICs. (As an example,
    recall the section “The Boot Configuration Pins,” on page 85, regarding the BOOT_MODE
    of the NXP i.MX53.) A manufacturer can choose to have the same PCB design for
    debug and production boards but then use a zero-ohm resistor on the relevant pins
    to select between the boot modes of those boards. That’s why zero-ohm resistors
    are interesting to look for; they can change security-sensitive configurations
    because they are easily removed or created. A solder blob across nearby pads is
    sufficient to simulate a zero-ohm resistor.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: You also may encounter package size markings, such as *0603*. This refers to
    the rough physical size of the resistor or capacitor; for instance, 0603 is about
    0.6 × 0.3 mm. SMT components may go down to 0201, although that continues to be
    pushed smaller as technology improves and consumer devices get smaller.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: PCB Features
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Other interesting features we see on top of PCBs include jumpers and test points.
    *Jumpers*(sometimes called *straps*) are used for configuring a PCB by opening
    or closing them as a particular circuit is open or closed. They perform exactly
    the same function as zero-ohm resistors, except they’re easily inserted or disconnected.
    They typically look like headers with two or three pins that have a small removable
    connector on them, which is used, for example, as an input to configure particular
    ICs (see BOOT_MODE described earlier for the NXP i.MX53). Jumpers are particularly
    interesting, as they may provide access to security-sensitive configurations.
    [Figure 3-31](#figure3-31) shows the pads where a jumper header labeled JP1 could
    be installed.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![f03031](image_fi/278748c03/f03031.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-31: Jumper header pads'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '*Test points* are used during manufacturing, repair, or debugging to provide
    access to particular PCB traces. Test points can be as minimal as a pad on the
    PCB, which can be connected to using a pogo pin, full-blown header, or connector.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-32](#figure3-32) shows the exposed traces that can be used for probing.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the photo, test points can also be small, exposed metal components
    that an oscilloscope probe can touch.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![f03032](image_fi/278748c03/f03032.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-32: Test points'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Mapping the PCB
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s look at the PCB itself. The process of sleuthing the circuit design
    from the PCB is known as *reverse engineering*. In the section “Datasheets and
    Schematics” on page 77, we introduced schematics and layouts and how to read them.
    The board layout (encoded in a Gerber file) is sent to manufacturing facilities
    for production. It’s rare we’d have access to this (we cheated in the earlier
    example by using an open source product). We’re actually interested in the reverse
    process: from a physical product, we want to get back to (the security sensitive
    part of) the schematic.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: This exercise is useful, as we often know there are certain signals on an IC
    we want to access, such as some of those boot mode pins we identified before.
    Or, we often know there is a debug or serial header on the IC, and we want to
    figure out the pinout of the header on the PCB.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: For the topics of fault injection and power analysis, we often need to target
    a certain power supply net. In this case, we might have one IC that is the power
    management IC, and we want to see which other ICs it is powering. For this purpose,
    we need to follow the power supply traces from one IC to another.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: The PCB exists to transport power and signals between its components (such as
    our IC and header that we just mentioned). It’s basically a sandwich of conductive
    material, isolating material, and components. The PCB consists of a couple to
    dozens of layers, each electrically isolated from each other. The *traces* look
    like lines on the PCB, and the *vias*look like holes in the PCB at the end of
    a trace (see [Figure 3-33](#figure3-33)). The vias connect to further traces on
    other layers inside or on the PCB. Typically, components are located on the front
    and back of the PCB.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![f03033](image_fi/278748c03/f03033.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-33: Traces and vias; vias may be covered (*tented*), as in this photo,
    or exposed (*untented*)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: A PCB’s outer sides have printed markings that identify components as well as
    company logos, PCB part numbers, and other artwork. These markings are called
    the *silkscreen*, which can be helpful when relating a PCB schematic to an actual
    PCB. Also, it can be hours of fun trying to find resistor R33 in the sea of other
    labeled components. All the text and lines on the PCB shown in [Figure 3-30](#figure3-30)
    are part of the silkscreen.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: When you’re mapping IC pinouts to a board, it’s good to know that pin 1 of a
    chip is usually identified on the silkscreen (and on the IC package itself) as
    a dot.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'The following reference designators are helpful to memorize, although you also
    may find other designators for these components:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: C = capacitor
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: R = resistor
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JP = jumper
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TP = test point
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: U = IC
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VR = voltage regulator
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XTAL or Y = oscillator (crystal)
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can try to follow PCB traces visually, but doing so quickly becomes tricky,
    so the most common way is to grab your favorite multimeter and set it to measure
    resistance (remember, it’s nice to have a multimeter that beeps, so you don’t
    need to watch it the entire time). Before you start measuring, it’s important
    to know that all traces are covered in a *solder mask*, which is the layer that
    makes the PCB green, red, black, or other color. The solder mask prevents corrosion
    and accidental solder bridges during manufacturing. A solder mask is nonconducting,
    so you can’t use your multimeter to get to the trace. However, you can scrape
    off the solder mask pretty easily, even with the tip of your multimeter probe,
    to expose the copper of the trace.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The multimeter measures resistance by applying a small current across the probes
    and measuring the voltage across the probes for the given test current. This is
    simply solving Ohm’s law (*V* = *I* × *R*) for resistance. Because of this, you
    can only use the multimeter on unpowered circuits. Any voltage present in the
    circuit will at best confuse and at worst damage the multimeter.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: The traces carry I/O signals, like JTAG, I2C, or DRAM bus signals, and they
    can also form power and ground planes. Signals usually go between two ICs, or
    between an IC and a port or header. If you’re using a multimeter as we suggest,
    be aware that certain types of parts can still confuse the multimeter. Large capacitors
    will often look like shorts, as the small test current is very slowly charging
    the capacitor, which gives a reading similar to a low resistance. Semiconductor
    components may also read as a low resistance one way, so if you are seeing a signal
    that appears to be connected to nonsensical areas, be suspicious about your measurement.
    Normally, a direct short (0 Ω, where your meter and probe resistance could measure
    in the 0 to 10 Ω range) is a “real” connection; any higher resistance values may
    be artifacts of the circuit elements.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: From the IC pins, it’s common to see pullup or pulldown resistors connected
    to the IC pins. These are normally not the “final destination” of the net, so
    you will want to probe further in most cases. If you see a lot of connections,
    it may be the ground net; a single ground plane usually goes everywhere on the
    PCB. Each IC has at least one ground pin. Metal casings of ports are typically
    ground, and any connector is certain to have ground connected to at least one
    of its pins. Bigger ICs can have dozens of ground pins in order to divide the
    current load over multiple pins. ICs may also have separate analog and digital
    ground pins. The large voltage differentials caused by digital switching on digital
    lines causes a lot of noise on ground traces, so they can be isolated from analog
    circuitry by having a separate ground. At some point, the PCB connects these digital
    and analog grounds together. You can usually find ground at metal cases on ports
    or marked by the text *GND* on the silkscreen.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the metal cases on ports (normally called the shield) don’t connect
    directly to the digital ground, so always do a quick sanity check between some
    potential ground points before you dive too far in.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The PCB can have one or many power planes, each typically providing different
    voltages to components, particularly to the larger ICs. Common voltages that may
    be identified by text on the silkscreen are 5 V, 3.3 V, 1.8 V, and 1.2 V.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The various voltages are generated by *voltage regulators* or *power management
    ICs (PMICs)*. Voltage regulators are dumb components that convert the basic raw
    voltage connected to the PCB into a wide range of stable voltages. For instance,
    the LD1117 takes in a raw voltage of anything between 4 V and 15 V and converts
    it to 3.3 V. PMICs are found in more complex devices like mobile phones. They
    provide the various voltages, but they can be externally instructed to switch
    various voltages on or off. They may communicate with the SoC that they are powering
    via a protocol such as I2C so that if the OS in the SoC needs to run faster, it
    can instruct the PMIC to increase the supply voltage. Voltage drops may occur
    along traces when conducting high currents, so feedback circuitry to the PMICs
    can verify the voltage arriving at the components, allowing the PMIC to adjust
    the voltage where necessary.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you want to bypass the PMIC and provide your own power source (for
    instance, for fault injection). At first, it may seem tricky, as the PMIC may
    go through complex voltage sequencing during boot and operation, but in practice
    we’ve rarely seen an issue with just supplying a constant voltage. Our guess is
    that this sequencing is all to save battery power, and the IC’s operation doesn’t
    seem to suffer if you don’t do this. Further, when providing your own power, you
    want to keep the feedback loop intact. So, substitute your own independent power
    supply only to the IC you are investigating. You want the PMIC to stay happy,
    because it may be holding the main IC in reset until it sees a stable output voltage.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'With these basics, you can start determining the answers to the following questions:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: At what voltage level is the IC or I/O channel running? Power on the device
    and measure the steady voltage between ground and the relevant IC pin or on the
    PCB trace nearby.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the ground plane connected to? The metal casing of any port is going
    to be ground. You can use that as a reference, and after removing power from the
    device, identify all other ground points, on IC pins and connectors, by performing
    the beep test described earlier.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is power distributed on the PCB? You can either measure voltages on all
    pins, as before, or use the beep test to identify all points connected to the
    same power plane.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the JTAG pins connected to? Let’s say you’ve identified the JTAG pins
    of the IC, but you want to know to which header or test point they are connected.
    Use the beep test between a JTAG IC pin and all “suspect” points on the board.
    If you really want to go pro, take a wire and fray one of the ends into a “fan,”
    as shown in [Figure 3-34](#figure3-34). Connect one of your probe pins to the
    wire and “sweep” the board, which is much more efficient than having to touch
    every point manually. If you want to get fancy, you can also buy small metal brushes
    to accomplish the same goal.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![f03034](image_fi/278748c03/f03034.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-34: Continuity sweeper'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on reverse engineering a PCB, take a look at Joe Grand’s
    “Printed Circuit Board Deconstruction Techniques” USENIX paper. If you’d like
    to dig deeper on the design side, the book *Printed Circuit Board Designer’s Reference:
    Basics* (Prentice Hall, 2003), by Christopher T. Robertson, explains how PCBs
    are physically made. For more reverse engineering techniques, see Ng Keng Tiong’s
    *PCB-RE: Tools & Techniques* (CreateSpace Independent Publishing, 2017).'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Using the JTAG Boundary Scan for Mapping
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we’ve mostly discussed passive methods of reverse engineering the connections
    on a PCB. In the previous chapter, we mentioned the existence of the JTAG boundary
    scan mode. With boundary scan, we can use a chip to drive a signal on the board
    and use measurement equipment to find out where that signal is routed. Boundary
    scan can also be used to sense signals on a chip’s pin, which means we can drive
    a signal on the board and figure out to which pin it is routed.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Boundary scan requires us to power up the board as part of the reverse engineering.
    It also requires a little bit of information first. We need a JTAG header to run
    this! Typically, using JTAG boundary scan will be a step after we’ve done some
    basic reverse engineering. It also requires us to have a JTAG Boundary Scan Description
    Language (BSDL) file for the device in question, and the device itself to have
    JTAG boundary scan enabled (not everything will).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take an example of an automotive ECU. The E82 ECU uses an NXP MPC5676R
    device. We can find a BSDL file for the MPC5676R chip with a simple online search,
    which means it’s worth trying to get a JTAG interface connected to it. Inspecting
    the board shows an unmounted 14-pin header that’s suspiciously like the 14-pin
    JTAG commonly used by these devices. We mount a header to this and connect a JTAG
    adapter (see [Figure 3-35](#figure3-35)).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![f03035](image_fi/278748c03/f03035.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-35: JTAG header and adapter connected to E82 ECU; a 1 kΩ resistor
    is used to drive a 1 Hz square wave into test points'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use TopJTAG software to load the BSDL file and put the chip in *EXTEST*
    mode. In this mode, we have complete control of the chip I/O pins. Some risk is
    involved because you may cause havoc by just flipping random pins (for instance,
    accidentally signaling a power supply to turn on or off). There is also *SAMPLE*
    mode, which means the chip is still running; it may be driving outputs high or
    low, preventing effective mapping. We’ll stick to *EXTEST*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: TopJTAG shows JTAG boundary scan connectivity; that’s good news for our ease
    of reverse engineering. We end up with a screen in the software like [Figure 3-36](#figure3-36).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '![f03036](image_fi/278748c03/f03036.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-36: The TopJTAG software uses a BSDL file to show a graphical view
    of the pin state.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 3-36](#figure3-36), you can see the state of each pin on the device.
    This is a “live” view, so if the external voltage on the pin changes, we can see
    the color change in this picture or the I/O value change in the table.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: To map a test point to a pin, we can drive a square wave on the test point using
    a signal generator. You can see this in [Figure 3-35](#figure3-35), where a 1
    kΩ resistor is used to drive a low-current square wave onto the board. We should
    see the associated pin toggling on the TopJTAG screen. If you don’t have a signal
    generator, you can also connect one end of a 1 kΩ resistor to a VCC point on the
    board and tap the other end on the test point.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the software, you could also do the opposite: by toggling a signal from
    a particular pin, you can measure in various places on the board to find out where
    that pin is connected. Unfortunately, there is no feature in the software to generate
    a waveform, but with the CTRL-T hotkey, you can do this manually (or find some
    keypress-injection software). We’ll discuss the tools you require to perform this
    type of work in Appendix A. Joe Grand’s JTAGulator can be used to automatically
    map test points to boundary scan bits, for example.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Information Extraction from the Firmware
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firmware images contain most of the code running on a device, so taking a peek
    at them is usually very interesting in order to find a point of attack. So far,
    we’ve mostly been discussing information we can see with our eyes or simple electrical
    tests. We’re now going to take a quantum leap in complexity and detail how you
    can actually work with firmware. At first glance, this looks like a major departure
    from the nitty-gritty details of the PCB, but if you think back to our overall
    goal of information gathering, analyzing the firmware is a critical step (and
    in many cases, the most important step). In the rest of the book, we discuss many
    operations that depend on firmware. Understanding how to find cryptographic signatures,
    for example, is an important part of knowing where you can apply fault injection;
    seeing code that could be referencing a signature is a good sign that you can
    find the location of the signature check routine.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the Firmware Image
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the device physically in front of you, and fresh off a discussion of JTAG,
    you might assume we’re going to extract the firmware image from the device. But
    taking the path of least resistance, we first check whether we can obtain the
    firmware image by downloading it from an update website or, if the device has
    Linux support, checking the */lib/firmware* directory.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: The image may be available as a separate file for download or embedded in an
    installer package. In case of the former, skip to the next section; in case of
    the latter, use your software reverse engineering skills to find the update file
    in the installation directory. One trick is to do a plain string search for a
    known string that the device prints out, although firmware images may often be
    compressed, and you won’t find the plain string. You can use the binwalk tool
    to find LZMA files or deflate (zlib/gzip) compressed images inside files. In fact,
    we’ll use binwalk later to carve up the firmware image itself to analyze further.
    Alternatively, you can perform the update and then sniff the image off the communication
    channel during a firmware update with a tool like Wireshark for Ethernet connections
    or socat for Linux.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Some devices support the USB Direct Firmware Update (DFU) standard, which is
    used for downloading and uploading firmware images to and from a device. If the
    target supports it, it will typically be enabled as an alternative boot mode.
    For instance, a mode could be set through a jumper, or a mode may be automatically
    chosen if the onboard firmware image is corrupted. You may be able to corrupt
    the image-loading process by a fault injection, which could be as simple as shorting
    out a data line, causing corrupted data to be loaded. Once you have DFU mode,
    you may be able to upload (extract) the firmware image. The dfu-util tool can
    perform this if it supports the device and if the device supports uploading.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: The device may also support its own proprietary protocol that is also called
    DFU mode, and it may have more than one recovery mode. For example, iPhones and
    iPads typically have a “recovery mode” that allows you to reflash the device over
    USB and run firmware that Apple can update. In addition, a separate “DFU mode”
    runs immutable ROM code that allows you to reflash the device over USB. The “DFU
    Mode” is a proprietary protocol and does not implement the USB standard DFU mode.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve exhausted the software means of obtaining an image or just are in
    the mood for a hardware attack, you can attempt to extract the firmware from a
    flash chip. This is only *simply* done on an external flash chip. Some SoCs have
    an internal flash, which is accessible only through chip-level reverse engineering
    and microprobing after decapping, and therefore is beyond the scope of this book.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: To get the flash chip off the board, you need to desolder it, which isn’t as
    hard as it sounds, but it does require a hot-air working station. The off-the-shelf
    method for obtaining the image is to purchase a memory reader. If you want minimal
    fuss, something from the FlashcatUSB series is a good bet. Models from this company
    support both SPI and parallel flash chips, and they range from low to medium cost.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see all sorts of other methods of reading SPI flash memory as well. Solutions
    have been made with Arduino Teensy devices and Raspberry Pis. Jeong Wook (Matt)
    Oh’s “Reverse Engineering Flash Memory for Fun and Benefit,” from Black Hat 2014,
    describes a DIY approach to getting the image and is a great way to learn about
    creating hardware to interface with flash chips and flash chip memory encodings.
    It walks through the process of attaching a chip and reading it by bit-banging
    through an FTDI FT2232H.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of reading flash memory onboard, we should also mention how you can
    read eMMC chips. These chips are basically SD cards in chip form, as mentioned
    in Chapter 2. Thanks to some nice backward compatibility, you can run them in
    1-bit mode (meaning you need only GND, CLK, CMD, and D0). [Figure 3-37](#figure3-37)
    shows an example of an SD card interposer connected to read out eMMC memory.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '![f03037](image_fi/278748c03/f03037.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-37: On this board, the eMMC flash connections (on the bottom of the
    board, not visible) were accessible on several pads onto which we could mount
    pin headers.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we’re holding the target processor in reset by grounding the
    nRST pin, so we can then plug the SD card into the USB SD card reader. Holding
    the target processor in reset is needed, as otherwise it would attempt to toggle
    the I/O lines at the same time. We can then mount the filesystem on the SD card
    on our computer. In this example, it was a standard filesystem readable in Linux.
    The talk “Hardware Hacking with a $10 SD Card Reader” by Amir “Zenofex” Etemadieh,
    CJ “cj_000” Heres, and Khoa “maximus64” Hoang, at Black Hat 2017 and the Exploitee.rs
    Wiki, is a valuable resource.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the Firmware Image
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next task is to analyze the firmware image. It will have multiple blocks
    for different functional components—for example, various stages of the bootloader,
    digital signatures, key slots, and a filesystem image. The first step is to dissect
    the image into its components. Each component may be plaintext, compressed, encrypted,
    and/or signed. Binwalk is a useful tool for finding all components in a firmware
    image. It recognizes different sections by matching them against the “magic” bytes
    that encode different file types.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: For encrypted data, you first need to figure out the encryption used and the
    key. Your best bet is to do side-channel analysis (see Chapters 8–12). Common
    options are AES-128 or AES-256 in CTR or CBC mode, although we’ve also seen ECB
    and GCM used. Once you have the key, you can decrypt the image for further analysis.
    For how to deal with digital signatures, see the “Signatures” section on page
    116.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have an image with plaintext or compressed blocks, binwalk can help
    with the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Detecting various files, filesystems, and compression methods within the image,
    using the `--signature` option.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting the different components with the `--carve`, `--extract`, or `--dd`
    option. If you specify `--matryoshka`, this will be done recursively.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting CPU architecture by analyzing opcodes in a file using `--opcode` or
    `--disasm`.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for a fixed string using `--raw`.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing and graphing the Shannon entropy of a file using `--entropy` or the
    zlib compression ratio with the `--fast` option. Use `--save` to save the entropy
    plot to a file.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing a hexdump and diffing binary files with `--hexdump`.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding compressed data with missing headers by brute force, using `--deflate`
    or `--lzma`.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, let’s take a brief look at some device firmware we can easily
    download (in this case, firmware for the TP-Link TD-W8980 router). We’re looking
    at version TD-W8980_V1_150514 (found as *TD-W8980_V1_150514.zip*). Unzip it and
    then run binwalk like so:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output (formatted for readability) reveals some interesting information:
    a u-boot bootloader image 1, firmware for GPHY 2, and a Squashfs filesystem (Linux)
    3. If you run binwalk with `--extract` and `--matryoshka`, you’ll get all these
    blocks as separate files, with compressed and decompressed versions of components,
    and the Squashfs filesystem unpacked.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: We’re focusing on hardware attacks on embedded systems, but one feature of software
    reverse engineering you may need is to identify encrypted blocks and signatures.
    Later chapters assume you have figured that out already, so we’ll walk through
    a sample analysis. Now, what we’ll find if we modify a file on the Squashfs filesystem
    (such as */etc/passwd* or */etc/vsftpd_passwd*) is that the router doesn’t accept
    the new firmware image. This is because an RSA-1024 signature is used to verify
    the image’s authenticity. The signature isn’t indicated in the binwalk output,
    because signatures are often just sequences of random-looking bytes as specific
    offsets. You can find those offsets through entropy analysis.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Entropy Analysis
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Entropy* is used in computer science as a measure of information density.
    For our purposes, we use 8-bit entropy. An entropy of 0 means a block of data
    contains a single byte value, and an entropy of 1 means a block contains equal
    amounts of every byte value from 0 to 255\. Entropy close to 1 is indicative of
    crypto keys, ciphertexts, or compressed data.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'Full of hope and excitement, we run binwalk again with the `--nplot` and `--entropy`
    options:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The binwalk tool calculates the entropy for each block and determines block
    boundaries by looking for large changes in entropy. This usually works by finding
    contiguous blocks of compressed or encrypted data and sometimes even works for
    finding key material. In this case, we’re looking for an RSA-1024 signature (which
    is 128 bytes), and there’s no such block.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: If you run binwalk again, omitting the `--nplot` option, it produces the graph
    shown in [Figure 3-38](#figure3-38).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '![f03038](image_fi/278748c03/f03038.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-38: Entropy output from binwalk using default settings'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: The graph doesn’t show the 1,024-bit/128-byte signature we are looking for either.
    Although this signature may be embedded in one of those blocks, we already shot
    ourselves in the foot. The way we are using binwalk will never show a 128-byte
    peak. Remember how entropy is calculated over a block of data? This means binwalk
    chops the file into blocks of data and calculates the entropy over those blocks.
    By default, the block size appears to be 0x1000, or 4,096 bytes. If our 128 random
    bytes are embedded in a 4,096-byte block, the entropy is only marginally affected.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: This is why binwalk has the `--block` option. It’s tempting to use a block size
    of 128 bytes now, but we’d still not have a nice entropy peak if the signature
    isn’t stored exactly within a single block. So, to be safe, we tend to use a block
    size of 16.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we encounter another issue: execution is very slow. The output shows only
    the following:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That’s not very useful, as no blocks are identified at all. The output graph
    in [Figure 3-39](#figure3-39) also doesn’t show what we want.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '![f03039](image_fi/278748c03/f03039.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-39: Entropy output using 16-byte block size'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: The reason is the calculation of entropy. It’s important to understand that
    for blocks smaller than 256 bytes, by definition, the entropy cannot be 1\. Actually,
    an entropy of 1 is achieved only when each byte value has the same frequency in
    the block. If a block is smaller than 256 bytes, it’s impossible to have a frequency
    of 1 or more for each byte value; therefore, the entropy cannot be 1\. In fact,
    the entropy is maximally 0.5 at a block length of 16.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Since binwalk does edge-detection for entropy, we need to tune the thresholds
    for a rising and falling edge. If the maximum entropy is 0.5, you can set, for
    example, `--high=0.45` and `--low=0.40`. Alternatively, you can find your own
    entropy “peaks” using the `--verbose` option, which just outputs the entropy for
    each block.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the edge detection doesn’t work. We get more than 2,000 edges. The
    reason is the calculation of entropy, again. Can you guess what the entropy is
    of *Glib jocks quiz nymph to vex dwarf*? With 16-byte blocks, the first block
    has an entropy of 0.447\. This is because the smaller the block size, the higher
    the likelihood that a nonrandom sequence of bytes accidentally has only unique
    bytes, and therefore the highest entropy possible (in other words, we get false
    positives).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s apply a bit of common sense. If we were to store a signature in an image,
    where would we do that? Likely it would be just before or just after the block
    we are protecting. Let’s take a look at the first 0x400 bytes:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It seems there are two high-entropy sections: 16 bytes at `0x40` 1 and 128
    bytes at `0xD0` 2. The 128-byte block is clearly visible in the entropy plot in
    [Figure 3-40](#figure3-40).'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'If you employ the skills described earlier in this chapter, you’ll have found
    the [https://github.com/xdarklight/mktplinkfw3/](https://github.com/xdarklight/mktplinkfw3/)project
    page, which documents the header format for this particular firmware image. You
    guessed it: 0xD0 is the RSA signature (and 0x40 is an MD5 sum).'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '![f03040](image_fi/278748c03/f03040.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-40: A more detailed entropy analysis, concentrating on areas of interest'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Signatures
  id: totrans-351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For signed data, you’ll need the signing key or a way to bypass signature verification
    in order to load modified firmware (we discuss ways to bypass signature verification
    in Chapter 6).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our firmware image: to check for data signing, modify a byte in the
    firmware image that wouldn’t cause execution to fail (for example, in a string
    constant such as a debugging or error message). If the device fails to boot with
    this image, it’s likely doing a signature verification or checksum. It’ll take
    some reverse engineering to find out which, although it may not be trivial. The
    code verifying at least the first firmware boot stage will be located in ROM,
    outside your view.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: One thing you can look for is an RSA or elliptic curve cryptography (ECC) signature
    in the image, both of which are sequences of high-entropy bytes. An RSA-2048 signature
    will be 2,048 bits (256 bytes) long, and an ECDSA signature, for example, on the
    curve *prime256v1*, will have 256 × 2 = 512 bits of signature (64 bytes). Entropy
    spikes at the end or start of a block in the firmware may indicate a signature.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, check the difference between two side-channel traces: one where
    you boot with a correct signature and one where you boot with a corrupted signature.
    This test allows you to pinpoint when the execution path diverges during the boot,
    which typically (but not necessarily) happens right after a signature verification.
    This information is also useful when you want to bypass signature verification
    using fault injection.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the image actually may be shipped with the public key used to verify
    its integrity, because space in ROM (or fuses) is limited and public keys (especially
    RSA) are rather large. This means you can search the firmware image for high-entropy
    sections that are a public key. For RSA-2048, the public key is the modulus of
    2,048 bits and the public exponent. Very often, this exponent is 65,537 (or 0x10001).
    Finding 0x10001 next to a high-entropy section indicates an RSA public key. For
    ECC, public keys are points on the curve. There are a few ways to encode this—for
    example, in affine (x,y) coordinates, in which case the curve prime256v1 has 256
    bits for x and y, or a total of 512 bits. A compressed encoding uses the fact
    that elliptic curves have only two possible values for y, given the curve and
    the point’s x coordinate, so a compressed notation for a point on prime256v1 has
    the full x coordinate (256 bits) and 1 bit of y, for a total of 257 bits. The
    “Standards for Efficient Cryptography, SEC 1: Elliptic Curve Cryptography” specifies
    a common encoding: a point is prefixed with 0x04 if it is uncompressed, and if
    it is compressed, it’s prefixed with 0x02 or 0x03, depending on the 1 bit for
    y.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: You may be thinking, how is embedding a verification key with the object to
    verify secure? That could be easily forged! And you’d be right. To save space,
    the public key’s hash is typically stored in fuses. This means during boot, first
    the public key’s hash is verified against the stored hash and only then is it
    used to verify the image. This sequence gives attackers a second point for fault
    injection. They could create an image that embeds their own public key and sign
    the image with that key. Next, fault injection can be used to skip the key verification.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'Less common ways of signing a firmware image are with hash-based message authentication
    code (HMAC) or cipher-based message authentication code (CMAC). These authentication
    codes require distributing a symmetric key, which means either you have a “root
    key” programmed into each device (capable of verifying and signing arbitrary images)
    or you’re diversifying the symmetric keys per device but then need to encrypt
    each firmware image with a device-specific key. The first option is foolish; the
    second option is costly. The first option is also exactly what happened with the
    Philips Hue attack (see “IoT Goes Nuclear: Creating a ZigBee Chain Reaction” by
    Eyal Ronen et al.), so don’t always assume that you can rule something out because
    *surely no serious product would do it that way*.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we explored how to collect useful information for hardware
    hacking attacks, which typically will be all you need. Devices often don’t have
    firmware encryption, for example, and once you have the ability to dump the firmware
    with JTAG, you can learn enough to exploit the device.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: With any luck, we can learn enough to exploit a system directly, and if we are
    forced to use more advanced attacks, we understand how they might apply to our
    system. Since this book is about advanced attacks, we’ll assume they’re needed
    and dive head-first into how they work. We’ll combine the information-discovering
    techniques described here with the interfacing skills outlined in Chapter 2 to
    test a system for fault injection weaknesses in the next chapter.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
