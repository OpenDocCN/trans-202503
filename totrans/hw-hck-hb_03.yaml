- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Casing the Joint: Identifying Components and Gathering Information'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Frank Herbert wrote in *Dune*, “A beginning is a very delicate time.” As you
    likely know, the way you begin a project sets the tone for its success. Operating
    on false assumptions or overlooking a small bit of information can derail a project
    and burn precious time. Thus, with any reverse engineering or research project
    (hardware being no different), gathering and reviewing as much information as
    possible in the early phases of your investigation into a target system is critical.
  prefs: []
  type: TYPE_NORMAL
- en: Most hardware-based projects start with a curiosity and fact-gathering stage,
    and this chapter is meant to assist with that phase. If you’re performing a target
    system review without design files, specifications, or a bill of materials (BOM),
    you naturally start by opening the device and seeing what’s inside. That’s the
    fun part! This chapter outlines techniques for identifying interesting components
    or interfaces and shares ideas for gathering information and specifications for
    a device and its components.
  prefs: []
  type: TYPE_NORMAL
- en: This information-gathering phase isn’t linear. You’ll find a variety of puzzle
    pieces. In this chapter, we show ways to find the pieces, and it’s up to you to
    put them together, in whatever order, to make the picture sufficiently complete.
  prefs: []
  type: TYPE_NORMAL
- en: Information Gathering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Info gathering*, *doxing*, *recon*, *getting developer Joe to spill the beans*—however
    you express it, this is an important time-saving step. Plenty of information is
    available if you know where to look. We begin with the least effort, which is
    at the keyboard, and later we’ll reach for the screwdriver and other tools.'
  prefs: []
  type: TYPE_NORMAL
- en: Before delving into the deeper recesses of the internet, you might consider
    just searching for the given product name along with the keyword *teardown*. It’s
    common to have teardowns of popular products posted in numerous sources; the iFixit
    website([https://www.ifixit.com/](https://www.ifixit.com/)), for example, has
    many popular teardowns, including detailed annotations of the products. For consumer
    goods, watch for multiple generations of the products. The Nest Protect smart
    smoke alarm second-generation device is very different internally from the first-generation
    device, for example. It’s common that companies won’t actually differentiate such
    generations, as they simply stop selling the older generation devices, so you
    may need to figure that out from model numbers or similar.
  prefs: []
  type: TYPE_NORMAL
- en: Federal Communications Commission Filings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Federal Communications Commission (FCC)* is a US government agency responsible
    for everything from imposing fines for exposing specific body parts on TV to ensuring
    that the latest high-speed wireless devices don’t interfere with each other. It
    sets regulations that manufacturers of any digital device sold in the US must
    follow. These regulations are designed to ensure that a given device doesn’t generate
    excessive amounts of interference (for example, your whiz-bang 5000 causing your
    neighbor’s TV reception to drop out) and continues to operate even in the presence
    of some level of electromagnetic (EM) interference.
  prefs: []
  type: TYPE_NORMAL
- en: Other countries have similar agencies and rules. The FCC is interesting because
    the US is such a large market, so most products have been designed and/or tested
    to meet FCC rules, and the FCC makes the database of filed information publicly
    available.
  prefs: []
  type: TYPE_NORMAL
- en: About FCC Filings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Any digital device that emits radio waves, known as an intentional radiator,
    requires testing. The FCC requires manufacturers to test their devices’ emissions
    carefully and provide documentation proving devices meet FCC rules. It’s a very
    expensive process, and the FCC needs to ensure that it is easy for the public
    to check compliance. This is why, for instance, the open source flash-drive-sized
    computer called the *USB armory Mk I* is labeled as a development platform that
    “may cause interference to electrical or electronic devices in close proximity.”
    Proving that this label may be unjustified is expensive.
  prefs: []
  type: TYPE_NORMAL
- en: For compliance checking by the public, an intentional radiator must publish
    something known as its *FCC ID*, which is printed on the device’s label. You can
    search for this ID on the FCC website and confirm that the device did indeed pass
    compliance testing. This also means detecting fake FCC labels is easy because
    anybody can check the status, not just FCC agents.
  prefs: []
  type: TYPE_NORMAL
- en: A device’s FCC label may be inside a battery cover. [Figure 3-1](#figure3-1)
    shows an example of the label on a D-Link router.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03001](image_fi/278748c03/f03001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-1: D-Link FCC label'
  prefs: []
  type: TYPE_NORMAL
- en: If a device isn’t an intentional radiator, it still must have the FCC compliance
    logo, but it won’t have an FCC ID. These unintentional radiators have less strict
    reporting requirements, and the test documentation is often not available.
  prefs: []
  type: TYPE_NORMAL
- en: Finding FCC Filings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As an example, the wireless router’s label in [Figure 3-1](#figure3-1) shows
    that the FCC ID is KA2IR818LA1, which you can find on the FCC ID Search website.
    The search tool separates the ID into two parts: the grantee code and the product
    code. The FCC assigns the grantee code, and it’s always the same for a given company.
    This code was previously only the first three characters of the FCC ID, but as
    of May 1, 2013, it can be either three or five characters. The company assigns
    the product code, which can be anything from 1 to 14 characters.'
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the router, the grantee code is KA2, and the product code is IR818LA1\.
    Entering this information into the search box gives the results shown in . This
    device has three filings, because it has multiple frequency bands in which it
    can operate. The Detail link provides reports and letters, including external
    and internal product photos—normally photos of the board(s) as well as details
    about the integrated circuits.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling up the internal photos based on the FCC ID KA2IR818LA1, you should easily
    be able to identify the main processor as an RTL8881AB. You can also see some
    sort of header, which is most likely serial-based, as it has around four pins
    and a number of test points on the printed circuit board (PCB). You’ve found all
    of this information without even touching a screwdriver.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03002](image_fi/278748c03/f03002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-2: FCC ID search results'
  prefs: []
  type: TYPE_NORMAL
- en: FCC Equivalents
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Nest doorbell in [Figure 3-3](#figure3-3) shows no FCC ID. Why? Colin bought
    this device, and he’s located in Canada, so the device doesn’t require an FCC
    ID. Instead, it’s marked only with the Industry Canada (IC) code, which allows
    you to search the Industry Canada “Radio Equipment List (REL)” database for a
    matching “certification number.”
  prefs: []
  type: TYPE_NORMAL
- en: '![f03003](image_fi/278748c03/f03003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-3: Nest doorbell'
  prefs: []
  type: TYPE_NORMAL
- en: Searching the IC REL database for 9754A-NC51 provides more information, but
    no detailed internal photos are available on the public website. The product code
    part of the reference (NC51) is shared between the FCC ID and the IC designator,
    so a quick way to find more information is to do a partial search at [https://FCCID.io/](https://FCCID.io/)
    for NC51\. We found that the FCC ID is ZQANC51, which allowed us to find the internal
    photos.
  prefs: []
  type: TYPE_NORMAL
- en: Patents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Patents are effectively licenses given to product developers to sue companies
    who sell a product that copies the well-defined operation of the original product,
    in a specific geographic area, for a limited period of time. Patents, in theory,
    are issued only if that well-defined operation is something novel. The goal is
    to protect inventions, and since this chapter is about information gathering and
    not politics, we’ll leave it at that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most companies like patents since they can use them to stop a competitor from
    releasing a product using some new technology or design. But there is a catch:
    patents must explain how that new technology works. The idea is that in exchange
    for giving away precious details about the new technology, the legal system can
    stop anyone else from using those details to compete with the inventor for that
    limited period of time.'
  prefs: []
  type: TYPE_NORMAL
- en: Finding Patents
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When researching a device, you might find that patents provide useful information
    about how security or other aspects of the design were handled. For example, in
    researching a password-protected hard drive, we found a patent that describes
    a method of securing hard drives by scrambling the partition table.
  prefs: []
  type: TYPE_NORMAL
- en: Products or manuals might be stamped with some sort of statement like “Protected
    by US Patent 7,324,123.” You can easily look up this patent number on the United
    States Patent and Trademark Office (USPTO) website or on a third-party website,
    such as Google Patents. We recommend Google Patents, as it searches multiple databases
    and also contains an easily navigated search tool for general-purpose use.
  prefs: []
  type: TYPE_NORMAL
- en: Often products are labeled “Patent Pending,” or you may find only references
    to patents in the product literature. This normally means the company has simply
    applied for a patent; it might not even be publicly viewable yet. In that case,
    the only reasonable method of searching for those patents is by company name.
    Determine to whom the patent is likely assigned; for example, a patent might be
    owned by the manufacturer of a chip inside the device and not the manufacturer
    of the device itself. Often you can find related patents issued to the company
    and then search by the company’s law firm or even patents by other related inventors.
  prefs: []
  type: TYPE_NORMAL
- en: If you find a patent (or patent application), the actual published application
    isn’t all the information you can use. A system called the USPTO Public PAIR allows
    you to review almost all correspondence between the USPTO and patent applicant.
    Those documents are not indexed by search engines, so you won’t find them without
    using the USPTO Public PAIR system. You can see, for example, if the USPTO has
    been fighting against an application in cases where patents are pending, or you
    can find supporting documentation that applicants may have uploaded. Sometimes
    you can find earlier versions of a patent or an applicant’s arguments, including
    additional information you won’t find on Google Patents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of interesting uses of patents for reverse engineering include
    the Thangrycat attack by Red Balloon Security, detailed in a DEF CON presentation
    titled “100 Seconds of Solitude: Defeating Cisco Trust Anchor with FPGA Bitstream
    Shenanigans.” In this attack, Red Balloon Security defeated the Cisco root of
    trust, which used an electronic component called a *field-programmable gate array
    (FPGA)*. Details of the architecture were helpfully explained in US Patent 9,830,456,
    which provided insights that otherwise would have required considerable effort
    to reverse engineer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example where patents were useful for hardware hackers is a presentation
    at Black Hat USA titled “GOD MODE UNLOCKED: Hardware Backdoors in x86 CPUs,” by
    Christopher Domas. Here, US Patent 8,296,528 explained how a separate processor
    could be connected to the main x86 core and hinted at details that resulted in
    a complete compromise of the core’s security mechanism.'
  prefs: []
  type: TYPE_NORMAL
- en: Patents may even list details about secure devices. For example, a Square credit
    card reader contains an anti-tamper “mesh” integrated into a plastic cover for
    the secure section of the microcontroller. [Figure 3-4](#figure3-4) shows the
    four large square pads (we’ll talk more about PCB features later in this chapter)
    with oval sections that will connect to the tamper mesh cover.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-5](#figure3-5) shows the underside of the tamper mesh cover that
    mates to the PCB shown in [Figure 3-4](#figure3-4).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f03004](image_fi/278748c03/f03004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-4: The Square credit card reader internals with four tamper shield
    connectors near each corner'
  prefs: []
  type: TYPE_NORMAL
- en: '![f03005](image_fi/278748c03/f03005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-5: The Square reader’s tamper shield; the exposed connections will
    mate with the PCB shown in [Figure 3-4](#figure3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: When you remove the mesh, the device will stop working, so reverse engineering
    the device quickly becomes expensive. If you search Google Patents for US10251260B1,
    however, you’ll find details about how the mesh works. Try that now and see if
    you can match the photos from Figures 3-4 and 3-5 to patent figures. If you haven’t
    worked with PCBs before, come back to these figures again after you finish this
    chapter, as we’ll explain some of the PCB features you can see here.
  prefs: []
  type: TYPE_NORMAL
- en: Datasheets and Schematics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Manufacturers publish datasheets (either publicly or under NDA) so designers
    can learn how to use their components, but they usually don’t publish complete
    schematics. Instead, you usually can find publicly shared *logical* designs that
    show how components are interconnected. For instance, a PCB layout shows the physical
    design—that is, where all components are placed and how the wires are routed,
    but it’s usually not publicly available.
  prefs: []
  type: TYPE_NORMAL
- en: Try finding a datasheet online for your favorite device or development board,
    such as for a Raspberry Pi computer module or an Intel 8086 processor, or a random
    datasheet for flash or DRAM memory. Or, if you want to go analog, find a level-shifter
    datasheet. Usually, you just need to do a simple internet search for product IDs
    or other identifiers, as mentioned earlier. Websites like findchips ([https://www.findchips.com/](https://www.findchips.com/))
    also are helpful for locating current products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Datasheets for a specific part may be a bit harder to find. For components,
    first determine the part number (see the “Identifying ICs on the Board” section
    on page 86). The part number often appears to be a random-looking collection of
    letters and numbers, but they encode the available various configurations of a
    part. For instance, the datasheet for the MT29F4G08AAAWP breaks the part number
    down as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: MT stands for Micron Technology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 29F is the product family of NAND flash memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4G indicates a 4GB storage capacity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 08 indicates an 8-bit device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First “A” means one die, one command pin, and one device status pin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second “A” indicates an operating voltage of 3.3 V.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third “A” is a listed feature set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WP indicates that the component is a 48-pin thin small outline package (TSOP).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When searching, simply type in any part number you find on the die. If you can’t
    find the exact number, trim off some of the last characters and search again or
    allow your search engine to suggest some nearly matching names.
  prefs: []
  type: TYPE_NORMAL
- en: Oftentimes you’ll have too many matches, because on very small parts, a full
    part number isn’t printed, but only a shorter *marking code*. Unfortunately, searching
    the marking code will return hundreds of unrelated matches. For example, a particular
    part on a board may simply be labeled *UP9*, which is almost unsearchable. If
    you search the marking code along with the package type, you will often get more
    useful hits. In this example, we had identified the package as being an SOT-353
    package type (we discuss package types later in this chapter). For marking codes
    specifically, you can find SMD (surface-mount device) marking code databases,
    such as [https://smd.yooneed.one/](https://smd.yooneed.one/) and [http://www.s-manuals.com/smd/](http://www.s-manuals.com/smd/),
    which, combined with your knowledge of the package, can lead you to the device
    (in this case, a Diodes, Inc., 74LVC1G14SE).
  prefs: []
  type: TYPE_NORMAL
- en: 'After looking at a few datasheets, you’ll find they have something in common.
    They seldom contain interesting information from a security viewpoint. We’re mainly
    concerned with interacting with a device, which means discovering how it works
    and how to connect to it. The introductory blurb will contain the functionality:
    it’s a CPU, a flash device, or whatever. To connect to it, we look for the pinout
    and any parameters describing the pins, such as functionality, protocol, or voltage
    levels. You’ll almost certainly find some of the interfaces discussed in Chapter
    2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Information Search Example: The USB Armory Device'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look for information on the USB armory Mk I device from Inverse Path
    (acquired by F-Secure) as an example. It’s an open source piece of hardware, so
    we’ll be able to access plenty of detail. Before reading all the spoilers here,
    try researching it yourself. Go find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The manufacturer and part number of the main System-on-Chip (SoC), as well as
    the datasheet for it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GPIO and UART on the PCB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any JTAG ports exposed on the board.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The power supply wires and voltage on the PCB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The external clock crystal wires and frequency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where the I2C interface from the main SoC connects to another IC, and what the
    protocol is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The boot configuration pins on the SoC, where they are connected on the PCB,
    and what boot mode and configurations this selects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manufacturer, Part Number, and Datasheet
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'From the USB armory GitHub pages and wiki ([https://inversepath.com/usbarmory_mark-one.html](https://inversepath.com/usbarmory_mark-one.html)),
    we can see that the USB armory is based on an NXP i.MX53 ARM Cortex-A8\. The datasheet
    is called *IMX53IEC.pdf* and is available in several places. When searching for
    “imx53 vulnerability,” we found a known X.509 vulnerability on the Quarkslab blog.
    If you dig further, you may be able to find an advisory titled “Security Advisory:
    High Assurance Boot (HABv4) Bypass,” which notes these vulnerabilities are not
    present in the Mk II.'
  prefs: []
  type: TYPE_NORMAL
- en: The GPIO and UART on the PCB
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Searching for “USB armory GPIO,” we arrive at its GitHub wiki ([https://github.com/f-secure-foundry/usbarmory/wiki/GPIOs/](https://github.com/f-secure-foundry/usbarmory/wiki/GPIOs/)),
    which provides the GPIO detail. In the datasheet sourced in the previous section,
    we can find all of the i.MX53’s GPIO, UART, I2C, and SPI pins. Any of those communications
    ports would be interesting to monitor; they will surely transport console or debug
    output.
  prefs: []
  type: TYPE_NORMAL
- en: JTAG Ports
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: JTAG, if not locked down, should provide low-level access to the chip via ARM’s
    debugging facilities, so we want information about any JTAG ports exposed on the
    board. Exploring the GitHub pages a bit more yields the JTAG page specific for
    the Mk I ([https://github.com/f-secure-foundry/usbarmory/wiki/JTAG-(Mk-I)/](https://github.com/f-secure-foundry/usbarmory/wiki/JTAG-(Mk-I)/)),
    which includes a PCB photo (see [Figure 3-6](#figure3-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03006](image_fi/278748c03/f03006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-6: USB armory JTAG connector pins'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-6](#figure3-6) shows the standard TCK, TMS, TDI, TDO, nTRST, and
    GND (ground) JTAG connections. The 2v8 pad provides a 2.8 V supply, but what about
    the MOD pad? The datasheet is not very clear about that. The JTAG_MOD/sjc_MOD
    is in the i.MX53 pinout list, but there’s no explanation of its meaning. A bit
    of searching for related products yields an explanation on the i.MX6 computer
    module datasheet (search for “IMX6DQ6SDLHDG.pdf”; the original NXP site requires
    a sign-in, but the PDF is mirrored in other places). This datasheet explains that
    *low* adds all system test access ports (TAPs) to the chain, whereas *high* makes
    it IEEE1149.1- compliant (only useful for boundary scan, which we’ll discuss in
    the section “Using the JTAG Boundary Scan for Mapping” on page 106). Reading the
    schematic at the bottom of the Mk I JTAG page, you’re advised to tie it to ground
    via a pulldown resistor; this pulls it *low* to enable system TAPs. As you can
    see, sometimes synthesizing different information sources completes the picture.'
  prefs: []
  type: TYPE_NORMAL
- en: Power Supply and Voltage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the power supply wires and voltage on the PCB, we go to the datasheet we
    sourced previously. Search for “power,” “Vcc,” “Vdd,” “Vcore,” “Vfuse,” and “ground/Vss.”
    You’ll discover that a modern SoC includes many repeated instances of those terms,
    each one representing a pin. Various subsystems on the power planes have multiple
    input voltages, which is one reason for this abundance of pins. For example, the
    flash memory may have a higher voltage than the core voltage. You may also find
    multiple I/O voltages that support a variety of standards.
  prefs: []
  type: TYPE_NORMAL
- en: A second reason for the many pins is that they are often duplicated, sometimes
    several times over. This helps keep power and ground pins physically close to
    each other, reducing inductance to help deliver fast power transients to the chip.
  prefs: []
  type: TYPE_NORMAL
- en: The datasheet certainly includes many power pins, which in this chip are denoted
    as VCC (peripheral core voltage) and VDDGP (ARM core voltage), among other designations.
    We look for power pins to find ways to inject faults and do power analysis, which
    are techniques you’ll learn about in the next few chapters. For instance, if you
    want to listen in on crypto on the ARM core, you’d try to probe VDDGP. If you
    want to glitch L1 cache (VDDAL1), JTAG access control (NVCC_JTAG), or fuse writes
    (NVCC_FUSE), you’d try to control those.
  prefs: []
  type: TYPE_NORMAL
- en: A schematic is really helpful to learn how these power pins are connected on
    the circuit board. We found one in the GitHub hardware repository as *armory.pdf*
    ([https://raw.githubusercontent.com/inversepath/usbarmory/b42036e7c3460b6eb515b608b3e8338f408bcb22/hardware/mark-one/armory.pdf](https://raw.githubusercontent.com/inversepath/usbarmory/b42036e7c3460b6eb515b608b3e8338f408bcb22/hardware/mark-one/armory.pdf)).
    Page 3 of this PDF lists the power connections to the SoC. If you follow the PCB
    traces from these power connections, you’ll see a bunch of decoupling capacitors
    (marked C48, C49, and so on), which are used for de-noising the power supply.
    You’ll also notice that the connection names end in labels like PMIC_SW1_VDDGP
    and PMIC_SW2_VCC. *PMIC* stands for power management IC—a chip dedicated to supplying
    the right voltages. Page 2 of the PDF shows how the main power source (USB_VBUS)
    feeds into the main power plane (5V_MAIN) and into the PMIC, which in turn feeds
    the variety of regulated voltages to the SoC.
  prefs: []
  type: TYPE_NORMAL
- en: This tells us logically how everything is connected, but it doesn’t yet tell
    us where these wires are on the PCB. For that, we need to open the PCB’s layout
    files, found in the KiCAD design files.
  prefs: []
  type: TYPE_NORMAL
- en: KiCAD is open source software for designing PCBs. We’re only using one percent
    of its functionality here to check out the PCB layout. We opened the *armory.kicad_pcb*
    design file with KiCAD’s `pcbnew` command. A PCB might include several layers
    of conductive tracks/traces, where each of those layers is shown on the right
    side of the program window, with checkboxes to enable and disable them. Disable
    them all first to see only the pads on the PCB. You’ll see the “U2” (main SoC’s
    ball grid) in the center, the “U1”/PMIC to the left, and the “U4”/DRAM chip to
    the right.
  prefs: []
  type: TYPE_NORMAL
- en: KiCAD has a nice tool to highlight a net, appropriately called *highlight net*,
    that allows you to click anywhere and follow the connection. Say we want to play
    around with the power to JTAG. Zoom in to the SoC until you see the ball names
    and find the NVCC_JTAG ball, which according to the datasheet is G9\. You’ll see
    what is shown in [Figure 3-7](#figure3-7).
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember the JTAG pads? It seems that NVCC_JTAG is connected to the 2v8 pad
    used for JTAG power. However, near the PMIC, you’ll also see some wires highlighted.
    They are part of the same net; we just can’t see that part because we’ve switched
    off all the layers. Clicking all layers on and off, we find one layer that connects
    them: GND_POWER_1(see [Figure 3-8](#figure3-8)).'
  prefs: []
  type: TYPE_NORMAL
- en: The white dots are *vias*, which are small plated holes connecting a trace on
    one layer to a trace on another layer. One via is on the left connection to the
    PMIC, and then a power plane connects to the via on the right, which connects
    to the wire that goes to NVCC_JTAG. If we wanted to control the power on *NVCC_JTAG*
    for fault injection or power analysis, we could physically cut the trace to the
    PMIC and provide our own 2.8 V by soldering a wire to the 2v8 pad.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03007](image_fi/278748c03/f03007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-7: Using KiCAD to highlight an interconnection network'
  prefs: []
  type: TYPE_NORMAL
- en: '![f03008](image_fi/278748c03/f03008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-8: Highlighting the GND_POWER_1 layer'
  prefs: []
  type: TYPE_NORMAL
- en: Clock Crystal and Frequency
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To identify the external clock crystal wires and the frequency clocks, we again
    refer to the datasheet we sourced a previously. Search for “clock/CLK/XTAL,” and
    you’ll discover four interesting external oscillator pins: XTAL and CKIL (and
    their complementary inputs EXTAL and ECKIL), and two general-purpose inputs, CKIH1
    and CKIH2\. Searching for those inputs, we find the “i.MX53 System Development
    User’s Guide” as *MX53UG.pdf*. The section on these inputs, in turn, refers to
    the “i.MX53 Reference Manual,” which we find as *iMX53RM.pdf*. According to the
    reference manual, you program the latter inputs to supply a clock to various peripherals,
    such as the CAN network and SPDIF port. Looking at the board schematics, we find
    that (E)XTAL is connected to a 24 MHz oscillator, (E)CKIL is connected to a 32,768
    Hz oscillator, and CKIH1 and CKIH2 are pulled to ground. The USB armory schematics
    show that those pins are connected to two sets of pads, which correspond to two
    oscillators. Those oscillators are the rather huge components in [Figure 3-9](#figure3-9).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f03009](image_fi/278748c03/f03009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-9: Oscillators have a white silkscreen box around them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clock control is significant for two main purposes: synchronizing side-channel
    measurements to the device clock and facilitating clock fault-injection experiments.
    In this case, the EXTAL input goes through a frequency multiplier, which then
    clocks the ARM core. Here, the PLLs (phase-locked loops) that turn the external
    frequency into an internal clock may eat up any weirdness in your clock, so clock
    fault injection may be a no-go, but we can still insert our own clock into these
    pins to provide more precise clock synchronization to count clock cycles. If you
    are going for clock synchronization, you don’t even need to remove the crystal
    on the board. You can feed in a clock to the crystal circuit, and it will force
    the crystal oscillator circuit to run on the clock pulses that you will inject.
    (See Chapter 4 for more on clock fault injection.)'
  prefs: []
  type: TYPE_NORMAL
- en: The I2C Interface
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We need to determine where the I2C interface from the main SoC connects to another
    integrated circuit (IC) and what the protocol on that interface is. The USB armory
    schematics show that pins 30 and 31 are I2C, and the i.MX53 datasheet shows three
    I2C controllers. We can trace the layout to find a connection to V3, which is
    named EIM_D21 and is one of the GPIOs. EIM_D21 is either SPI or I2C-1\. This is
    an example of a multiplexed pin; the SoC itself can be configured to talk various
    low-level protocols on the pin.
  prefs: []
  type: TYPE_NORMAL
- en: As for the high-level protocol, we have to dig a little deeper—specifically,
    into the PMIC datasheet. The PMIC is identified as an LTC3589 in the PCB schematic,
    and the datasheet is called *3589fh.pdf*. In the “I2C Operation” section, the
    datasheet precisely defines the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The Boot Configuration Pins
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Knowing where the boot configuration pins are, where they are connected on the
    PCB, and what boot mode and configurations the pins select is really helpful.
    For now, we’re providing an example of how to find data; don’t worry about understanding
    the technicalities.
  prefs: []
  type: TYPE_NORMAL
- en: The i.MX53 datasheet (*IMX53IEC.pdf*) mentions various BOOT_MODE and BOOT_CFG
    pins, but it does not define what they do. In the schematics for the Mk I, we
    find that BOOT_MODE pins (C18 and B20) are not connected to power or ground on
    the PCB.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first find out what it means that BOOT_MODE is not connected. The i.MX53
    datasheet has a table that claims for BOOT_MODE0 and BOOT_MODE1, the “config.
    value” is 100 kΩ PD. PD stands for *pulldown*, so if the pin is not connected,
    it is internally pulled down to ground. This means that the BOOT_MODE0 and BOOT_MODE1
    pins are at logical 0 when not connected. The datasheet mentions nothing more,
    but the i.MX53 reference manual (*iMX53RM.pdf*, which is 5,100 pages of goodness)
    gives the high-level boot sequence and shows that BOOT_MODE[1:0]=0b00 means *internal
    boot*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, for BOOT_CFG, the i.MX53 datasheet shows that all of these BOOT_CFG pins
    are connected to pins starting with EIM_, such as EIM_A21\. Keep in mind this
    is a pin name, not a coordinate. If you keep searching the datasheet, you’ll see
    that EIM_A21 is a name of the pin at location AA4 (this AA4 is a location on the
    chip, a BGA ball). With that information, we can look at the Mk I schematic to
    see how these pins are connected.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that all BOOT_CFG pins are grounded, with the exception of BOOT_CFG2[5]/EIM_DA0/Y8
    and BOOT_CFG1[6]/EIM_A21/AA4, which are pulled up to 3.3 V through a resistor.
    These bits are set to 1, whereas all other BOOT_CFG bits are set to 0\. Searching
    for BOOT_CFG in the reference manual, we find Table 7-8, “Boot Device Selection,”
    which has a line specifying that BOOT_CFG1[7:4] set to 0100 or 0101 means to boot
    from the SD card (written in the table as 010X). The effect of setting BOOT_CFG2[5]
    seems to depend on the boot mode selected. Since we just found out it’s booting
    from the SD card, Table 7-15, “ESDHC Boot eFUSE Descriptions,” is relevant. It
    indicates that BOOT_CFG2[5]=1 means we are using a 4-bit bus width on the SD card.
  prefs: []
  type: TYPE_NORMAL
- en: And remember that MOD pin for which we couldn’t find proper information? That
    reference manual has everything you want to know about it and more, under the
    sjc_mod pin, which also confirms the information we found before. Don’t despair
    if you can’t find what you need at first.
  prefs: []
  type: TYPE_NORMAL
- en: Those are just a few examples of the kinds of questions you can answer from
    various sources of documentation. Datasheets are usually easy to find; schematics
    and PCB layouts and/or reference designs are rare. However, you can reverse engineer
    information as well, as you’ll see in the next section, “Opening the Case.”
  prefs: []
  type: TYPE_NORMAL
- en: Opening the Case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with any reverse engineering task, your objective is to get into the system
    designer’s head. Through research, clues, and a little guesswork, the idea is
    to understand just enough to complete your task. We are not reverse engineering
    for the purpose of cloning or fully extracting schematics; we just want to know
    how to modify and/or attach to a PCB in order to reach our goal. If you are lucky,
    someone has looked at this device (or a similar device) before, and as mentioned
    earlier, you can try to find teardowns of the products already posted.
  prefs: []
  type: TYPE_NORMAL
- en: What starts out as a collection of IC serial numbers, a handful of external
    ports, and a seemingly infinite number of resistors and capacitors will turn into
    an understanding of the system. And with a bit of luck, you can find a test point
    or debug port that will provide even more access.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying ICs on the Board
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We don’t use one specific device to demonstrate the technique for identifying
    ICs, so if you want to follow along, find a cheap IoT (internet of things) or
    similar device that you won’t mind ripping open.
  prefs: []
  type: TYPE_NORMAL
- en: Most PCBs you’ll encounter in modern electronics are mounted on the PCB’s surface,
    in contrast with the through-hole mounting of times past. This is called *surface-mount
    technology (SMT)*, and any device on it is called a *surface-mount device (SMD)*.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve opened a device, you’ll usually see a single PCB with a bunch of
    components (check the front and back of the PCB), the largest of which will likely
    be the main SoC, DRAM, and external flash storage, as shown in [Figure 3-10](#figure3-10).
  prefs: []
  type: TYPE_NORMAL
- en: In the top center of [Figure 3-10](#figure3-10) is a DSPGroup DVF97187AA2ANC
    main SoC 1. To the left of that is an EtronTech EM63A165TS-6G SDRAM in a TSSOP
    package 2, and above the SDRAM is Winbond 25Q128JVSQ flash memory in an SOIC-8
    package 3. In addition, there is a Realtek RTL8304MB Ethernet controller 4. This
    particular device is a very low-cost IP phone, which might explain why the SoC
    and SDRAM are brands you’ve likely not heard of before.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to read the die markings on the chips. You can usually get
    pretty far with a phone camera. [Figure 3-11](#figure3-11) shows photos of another
    device, an HDMI RCA audio splitter, taken with a regular phone camera and microscope
    app.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03010](image_fi/278748c03/f03010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-10: Identifying ICs on the board'
  prefs: []
  type: TYPE_NORMAL
- en: '![f03011](image_fi/278748c03/f03011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-11: Die markings: on the left, with flash and a good angle; in the
    middle, with flash and bad angle; on the right, with natural light'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, playing with different angles and with the flashlight on or
    off, you should be able to take a suitable photo for reading die markings. Alternatively,
    cheap USB microscope cameras will do the job; see Appendix A for hardware information.
    The photos in [Figure 3-12](#figure3-12) were taken with such a camera.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03012](image_fi/278748c03/f03012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-12: Photos taken with a USB microscope camera'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the die markings, employ your reconnaissance skills to dig up
    information on the part. Especially if you’re doing this for the first time, try
    to identify all of the ICs and their datasheets. Even though most of the smaller
    components may be insignificant from a security point of view, you’ll learn a
    bit about all that’s needed to make a device tick. We’ve learned much about voltage
    regulators and other funny little ICs this way.
  prefs: []
  type: TYPE_NORMAL
- en: For some chips, it’s a little trickier to get to the main IC because of a heatsink
    or protective potting. You can remove heatsinks relatively easily, either by unscrewing
    them or gently pulling them off the IC. If the heatsink is stuck on (typical with
    small devices), a twisting motion will help remove it instead of trying to pry
    or pull it up directly.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll encounter protective potting in higher-security systems where the manufacturer
    wants to avoid access to the IC. Simply chipping away at it may be unsuccessful,
    but you’ll likely find heating it up with a heat gun nicely softens the epoxy,
    and you can then remove it with a tool such as a dental pick. If you want to remove
    the epoxy completely, try a chemical such as Xylene or paint removers (available
    in hardware stores).
  prefs: []
  type: TYPE_NORMAL
- en: 'Small Leaded Packages: SOIC, SOP, and QFP'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In your quest for IC identification, you’ll encounter various types of beasts.
    Identifying the packages is useful for several reasons for the hardware hacker.
    First, you can find this information useful when searching for datasheets. Second,
    the type of package can actually affect what attacks you can perform. Some of
    the very tiny packages provide almost chip-level access, and probes we’ll discuss
    in later chapters are easier to use on these tiny packages. [Figure 3-13](#figure3-13)
    shows some of the main small leaded packages you’ll find.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03013](image_fi/278748c03/f03013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-13: Small leaded packages: SOIC, TSSOP, and TQFP styles'
  prefs: []
  type: TYPE_NORMAL
- en: All of the packages in [Figure 3-13](#figure3-13) have leads on them; the difference
    is the relative size between leads (pitch) and the leads’ locations. Many variants
    exist within these families that we also won’t go into here, because for our purposes,
    they are equivalent. For example, you might see references to both *thin quad
    flat pack (TQFP)* and *plastic quad flat pack (PQFP**)*, which look almost identical
    and have similar pin pitch, counts, and package sizes.
  prefs: []
  type: TYPE_NORMAL
- en: The largest is the *small outline integrated circuit (SOIC)*, which has pins
    on two sides of the package and typically has a pin-to-pin spacing of 1.27 mm.
    This package is nice because you can fit grabber clips on it. Often SPI flash
    memory chips are in 8- or 16-pin wide SOIC packages.
  prefs: []
  type: TYPE_NORMAL
- en: A smaller version of the SOIC is the *small outline package (SOP**)*, often
    in the thin SOP (TSOP) or thin-shrink SOP (TSSOP) variant. All of these also have
    pins only on two edges, but with pin pitches typically in the 0.4 mm to 0.8 mm
    range. Wide TSOP packages with 48 pins, as shown in [Figure 3-14](#figure3-14),
    are almost certain to be parallel flash memory chips.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03014](image_fi/278748c03/f03014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-14: A 48-pin TSOP package'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the *quad flat pack (QFP)* package has legs on all four edges and is
    often seen in the *thin QFP (TQFP)* or *plastic QFP (PQFP)* package. These have
    small changes in material or thickness, but the general form factor is the same.
    Pin pitch typically varies within the 0.4 mm to 0.8 mm range.
  prefs: []
  type: TYPE_NORMAL
- en: The TQFP’s internal construction basically has a small central IC die, which
    is connected to a *leadframe*. If you sand off sections of the IC, you can see
    the relative sizes, as shown in [Figure 3-15](#figure3-15) for a TQFP-64 package.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to keep things more intact, you can also use acid decapsulation,
    but sandpaper is something almost everyone can safely use.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-16](#figure3-16) is a simple diagram of the SOIC/SOP/TQFP’s internal
    construction and shows the bonding wires connecting the chip to the leads. What
    was clearly removed in [Figure 3-15](#figure3-15) was any hint of bonding wires
    when the chip was sanded from the top down.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f03015](image_fi/278748c03/f03015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-15: QFP package; from left to right: top sanded off, cross-section,
    and unharmed'
  prefs: []
  type: TYPE_NORMAL
- en: '![f03016](image_fi/278748c03/f03016.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-16: Internal construction of an SOIC/SOP/TQFP package'
  prefs: []
  type: TYPE_NORMAL
- en: 'No-Lead Packages: SO and QFN'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No-lead packages are similar to the previous SOIC/QFP packages, but instead
    of leads, a pad underneath the chip is soldered onto the PCB. This pad often (but
    not always) extends just to the edge of the device, so you’ll normally see a small
    protruding solder joint on the edge of the chip with those packages. [Figure 3-17](#figure3-17)
    is a simple diagram of these no-lead devices.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03017](image_fi/278748c03/f03017.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-17: No-lead package'
  prefs: []
  type: TYPE_NORMAL
- en: The *small outline no-lead (SON)* package has connections on only two edges.
    These devices have typical pitches in the 0.4 mm to 0.8 mm range. As in other
    packages, many variants exist, such as *thin SON (TSON)*. You may also see various
    custom pin layouts where pads are missing. The SON package almost always has a
    central thermal pad underneath it that is also soldered to the PCB, meaning you
    will likely need hot air to solder or remove this package. Because you can’t reach
    the large hidden central pad with a soldering iron, you need some method of heating
    it indirectly, through either the device package or the PCB.
  prefs: []
  type: TYPE_NORMAL
- en: Also, pay attention to the WSON package type, which officially seems to be called
    both *very-very thin SON* and *wide SON*. This package is much wider than normal
    and often has a 1.27 mm pitch. It’s frequently used for SPI flash memory chips.
  prefs: []
  type: TYPE_NORMAL
- en: The *quad flat no-lead (QFN)* package has connections on four edges. These devices
    have typical pitches in the 0.4 mm to 0.8 mm range. Again, you will almost always
    see a thermal pad in the center of these devices. They are widely used and can
    be anything from the main microcontroller to a power-switching regulator.
  prefs: []
  type: TYPE_NORMAL
- en: Ball Grid Array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Ball grid array (BGA)* packages have balls on the bottom of the chip, as shown
    in [Figure 3-18](#figure3-18), and you won’t be able to see them from the top.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f03018](image_fi/278748c03/f03018.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-18: BGA package'
  prefs: []
  type: TYPE_NORMAL
- en: You can see the edge balls if you can get the angle right, as shown in [Figure
    3-19](#figure3-19), where you can also see that there is actually a smaller *carrier
    PCB*. The BGA chip itself is composed of a smaller PCB with the chip mounted onto
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03019](image_fi/278748c03/f03019.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-19: View of edge balls'
  prefs: []
  type: TYPE_NORMAL
- en: BGA parts are frequently used for the main processor or SoC. Some eMMC and flash
    devices will also use a BGA package, and smaller BGAs hanging off the side of
    the main processor are often DRAM chips in more complex systems.
  prefs: []
  type: TYPE_NORMAL
- en: There are actually several variants of BGA devices, which can be important for
    power analysis and fault injection, so we’ll detail that construction difference
    here. Vendors use slightly different names, but we keep with the Fujitsu naming
    process here (*a810000114e-en.pdf*), which typically maps to names other vendors
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Plastic BGA and Fine Pitch BGA
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Plastic BGA (PBGA)* devices typically have a 0.8 mm to 1.0 mm pitch (see [Figure
    3-20](#figure3-20)). The chip is internally bonded to a carrier board that has
    the solder balls on it.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f03020](image_fi/278748c03/f03020.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-20: Plastic BGA'
  prefs: []
  type: TYPE_NORMAL
- en: '*Fine pitch BGAs (FPBGAs)* are similar to PBGAs, but with a finer grid (typically
    0.4 mm to 0.8 mm). Again, the device is mounted on a carrier PCB.'
  prefs: []
  type: TYPE_NORMAL
- en: Thermally Enhanced Ball Grid Array
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *thermally enhanced ball grid array (TEBGA)* shown in [Figure 3-21](#figure3-21)
    has a noticeable metal area on the BGA itself.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03021](image_fi/278748c03/f03021.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-21: Thermally enhanced ball grid array'
  prefs: []
  type: TYPE_NORMAL
- en: This metal area is part of an integrated heat spreader, which helps provide
    a better thermal connection to both the bottom solder balls and a heatsink mounted
    on top of the package.
  prefs: []
  type: TYPE_NORMAL
- en: Flip-Chip Ball Grid Array
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Flip-chip BGAs (FC-BGAs)*, as shown in [Figure 3-22](#figure3-22), do away
    with the internal bond wires. Instead, the chip itself is effectively a much smaller
    BGA (which would be difficult to work with) that is soldered on to the carrier
    PCB. The difference here is that the internal “LSI chip” is *upside down* compared
    to the previous BGA devices.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f03022](image_fi/278748c03/f03022.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-22: Flip-chip ball grid array'
  prefs: []
  type: TYPE_NORMAL
- en: On other packages, such as PBGA/FBGA/TEBGA, internal bond-wires touch the “top
    metal” layer of the internal LSI chip. On the FC-BGAs, that top metal layer is
    on the bottom, with very small solder balls mounted on it. This type of package
    also may have small integrated passives, such as decoupling capacitors. With FC-BGAs,
    it may be possible to remove the heat spreader or “lid” to get closer to the actual
    chip for fault injection or side-channel analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Chip Scale Packaging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Chip scale packaging (CSP)* is effectively where you are given a piece of
    the sawed-off chip wafer. In the internal structure shown in [Figure 3-23](#figure3-23),
    there is no encapsulant on the top side.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f03023](image_fi/278748c03/f03023.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-23: CSP internal structure'
  prefs: []
  type: TYPE_NORMAL
- en: The provided device is almost no bigger than it physically needs to be, and
    typically some very fine-pitch balls on the bottom of the CSP provide the connection
    to the PCB. The name CSP may have modifiers, such as the *wafer-level CSP (WLCSP)*.
    Think of CSPs as the LSI chip part of the flip-chip BGA. They have a very small
    pitch (0.4 mm or finer typically). You can often easily spot these devices, as
    the surface will look noticeably different from a regular BGA.
  prefs: []
  type: TYPE_NORMAL
- en: DIP, Through-Hole, and Others
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The oldestpackages are through-hole, and you aren’t too likely to run into them
    on real products, especially for ICs. You *will* encounter the DIP package in
    hobby or kit products (such as an Arduino).
  prefs: []
  type: TYPE_NORMAL
- en: Another relatively outdated technology is *plastic leaded chip carrier (PLCC)*,
    which can be either soldered directly to a PCB or placed in a socket. These devices
    were often used for microcontrollers, and if you are looking at an old product
    using an 8051 microcontroller, you may well run into one.
  prefs: []
  type: TYPE_NORMAL
- en: Sample IC Packages on PCBs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rather than provide a bunch of photos of parts by themselves, we thought it
    would be more useful to show what they look like in-circuit. Let’s look at four
    sample boards pulled from real products. [Figure 3-24](#figure3-24) shows a communications
    daughterboard from a smart lock.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03024](image_fi/278748c03/f03024.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-24: Example IC packages from a smart lock'
  prefs: []
  type: TYPE_NORMAL
- en: 'The three packages marked in [Figure 3-24](#figure3-24) are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**QFN package**: The main microcontroller on this device (EM3587).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**WSON package**: SPI flash chip (this package size is frequently used for
    SPI flash).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**BGA package**: We can’t see any edge connections, so it’s likely a small
    BGA.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s take a different smart lock device and see what we can find (see [Figure
    3-25](#figure3-25)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03025](image_fi/278748c03/f03025.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-25: IC package examples from another smart lock'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-25](#figure3-25) shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eight-pin SOIC**: This might be SPI flash based on an eight-pin SOIC (the
    part number confirms it’s SPI flash).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**TQFP package**: The main microcontroller for this device.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**QFN package**: The co-processor chip (in this case, for audio).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Eight-pin wide SOIC package**: This is certainly SPI flash due to the wide
    package.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**TSOP/TSSOP package**: Unknown IC.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**TSON package**: Unknown IC.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continuing with our consumer electronics examples, next let’s look at a board
    from a smart doorbell (see [Figure 3-26](#figure3-26)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03026](image_fi/278748c03/f03026.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-26: IC package examples from a smart doorbell'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-26](#figure3-26) shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A very small BGA**: Unknown IC.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**TSON-style very small device (pins on two sides only)**: Unknown IC.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**QFN-style very small device (pins on all four sides)**: Unknown IC.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**CSP package with an almost mirror-like finish**: The main microcontroller,
    BCM4354KKUBG. Underneath this device are 395 balls with 0.2 mm spacing (we told
    you CSP is small).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a final example, [Figure 3-27](#figure3-27) shows a board from an automotive
    electronic control unit (ECU).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03027](image_fi/278748c03/f03027.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-27: IC packages from an automotive ECU'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-27](#figure3-27) shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**BGA package**: The main processor for this device.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**TSSOP package**: Digital flip-flop.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**QFP package (only the edge is visible here)**: Unknown IC.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SOIC package**: Digital logic gate.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**TSSOP package**: Two unknown ICs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identifying Other Components on the Board
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve looked at the main ICs, let’s explore some other components.
  prefs: []
  type: TYPE_NORMAL
- en: Ports
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ports are a good starting point for making connections to a device and understanding
    the function of the various components they interconnect. The ports for digital
    I/O are the most interesting, as they may be used for normal device communication
    or provide debugging interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Once you identify the port type based on its appearance, you typically find
    the type of protocol used on the port. (See Chapter 2 for a refresher on various
    port protocols.) If you can’t identify the port based on appearance alone, hook
    up an oscilloscope to measure voltages and recognize data patterns. Note the high
    and low voltages, as well as the duration of the shortest pulse you see. The shortest
    pulse will give you the *bitrate*, such as an 8.68 microsecond pulse, which translates
    into an 115,200 bitrate on a UART. The bitrate is typically the rate of toggling
    of a single bit; the shortest pulse normally indicates a 0 or 1\. We get the rate
    by taking the inverse. In this case, 1 / 0.00000868 = 115,207, and we round it
    to a standard baud rate of 115,200.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, trace the PCB lines from the port to an IC and then use information
    from the IC’s pinout to identify the port type.
  prefs: []
  type: TYPE_NORMAL
- en: Headers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Headers* are basically internal ports and therefore are interesting to look
    at because they may expose some functionality that’s not intended for normal users
    but instead is included in the design for debugging, manufacturing, or repair.
    You may find, among others, JTAG, UART, and SPI/I2C ports internally. Sometimes
    headers are not actually installed on the PCB, but their solder pads are still
    there, so some easy soldering can provide access. [Figure 3-28](#figure3-28) shows
    an example of several surface-mount headers.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f03028](image_fi/278748c03/f03028.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-28: PCB headers'
  prefs: []
  type: TYPE_NORMAL
- en: The middle header is marked JTAG. This header wasn’t mounted, but we soldered
    it onto the pads, which provided JTAG access to the main IC, as the IC did not
    have any memory read-out protection enabled. This particular header was an Ember
    Packet Trace Port Connector. See Appendix B for several handy header pinouts.
  prefs: []
  type: TYPE_NORMAL
- en: Through-hole headers are easier to probe, but small devices probably need a
    surface-mount header. [Figure 3-29](#figure3-29) shows a classic UART header inside
    a device.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03029](image_fi/278748c03/f03029.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-29: A UART header in a device'
  prefs: []
  type: TYPE_NORMAL
- en: The header is the four pins in a row marked with “J404” on the board (note that
    J404 is upside down in the figure). There is no “standard” pinout for this header.
    You’ll need to perform some reverse engineering of it. The pin on the left can
    be visually seen to connect to the larger “ground plane,” and you could confirm
    this with a multimeter. We’ll cover this later in the section “Mapping the PCB”
    on page 102.
  prefs: []
  type: TYPE_NORMAL
- en: Analog Electronics
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most of the small components you find are analog electronics (resistors and
    capacitors), although you can also find inductors, oscillators, transistors, and
    diodes as SMDs. Capacitors and resistors have specific characteristics pertinent
    to this book. The PCB shown in [Figure 3-30](#figure3-30) has many of them.
  prefs: []
  type: TYPE_NORMAL
- en: Capacitors (like C31 in [Figure 3-30](#figure3-30)) can store and release little
    bits of charge, and they’re often used to filter a signal. Capacitors are like
    very fast and small rechargeable batteries. They can charge and discharge millions
    of times per second, which means any fast voltage swings are counteracted either
    by charging or discharging the capacitor. The effect is that of a “low-pass filter.”
    This is one of the reasons you’ll see a lot of capacitors around ICs, connected
    between the power supply and ground. In this function, they are called *decoupling
    capacitors*, and their role is to provide a localized source of power for the
    IC, which prevents electrical noise from being injected into the power line. They
    also help keep noise from other areas from reaching the IC. We discuss *voltage
    fault injection (VFI)* more in Chapter 5, but imagine that if VFI relies on fast
    changes in supply voltage, decoupling capacitors undo the effects of VFI. Therefore,
    we first remove as many decoupling capacitors as we can without letting the system
    become unstable.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03030](image_fi/278748c03/f03030.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-30: Surface-mount resistors and capacitors'
  prefs: []
  type: TYPE_NORMAL
- en: Resistors (like R26 in [Figure 3-30](#figure3-30)), as the name implies, resist
    the flow of current, and for our purposes, the most interesting functions are
    that of a shunt resistor, a pullup/pulldown resistor (explained in Chapter 2),
    and a zero-ohm resistor. Shunt resistors measure the current through an IC when
    doing side-channel analysis (see Chapter 8 for more details). Surface-mount resistors
    typically have a number printed on them that indicates the resistance value; for
    example, abc refers to ab × 10^c ohm resistance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, zero-ohm resistors (like R29 in [Figure 3-30](#figure3-30)) may seem
    a bit mysterious because they offer no resistance; they are basically wires. Their
    raison d’être is allowing configuration of a board at manufacturing time: zero-ohm
    resistors can be installed using the same manufacturing techniques as other resistors.
    By placing them, or not placing them, an electrical circuit can be open or closed,
    which can be used, for instance, as a configuration input to ICs. (As an example,
    recall the section “The Boot Configuration Pins,” on page 85, regarding the BOOT_MODE
    of the NXP i.MX53.) A manufacturer can choose to have the same PCB design for
    debug and production boards but then use a zero-ohm resistor on the relevant pins
    to select between the boot modes of those boards. That’s why zero-ohm resistors
    are interesting to look for; they can change security-sensitive configurations
    because they are easily removed or created. A solder blob across nearby pads is
    sufficient to simulate a zero-ohm resistor.'
  prefs: []
  type: TYPE_NORMAL
- en: You also may encounter package size markings, such as *0603*. This refers to
    the rough physical size of the resistor or capacitor; for instance, 0603 is about
    0.6 × 0.3 mm. SMT components may go down to 0201, although that continues to be
    pushed smaller as technology improves and consumer devices get smaller.
  prefs: []
  type: TYPE_NORMAL
- en: PCB Features
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Other interesting features we see on top of PCBs include jumpers and test points.
    *Jumpers*(sometimes called *straps*) are used for configuring a PCB by opening
    or closing them as a particular circuit is open or closed. They perform exactly
    the same function as zero-ohm resistors, except they’re easily inserted or disconnected.
    They typically look like headers with two or three pins that have a small removable
    connector on them, which is used, for example, as an input to configure particular
    ICs (see BOOT_MODE described earlier for the NXP i.MX53). Jumpers are particularly
    interesting, as they may provide access to security-sensitive configurations.
    [Figure 3-31](#figure3-31) shows the pads where a jumper header labeled JP1 could
    be installed.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03031](image_fi/278748c03/f03031.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-31: Jumper header pads'
  prefs: []
  type: TYPE_NORMAL
- en: '*Test points* are used during manufacturing, repair, or debugging to provide
    access to particular PCB traces. Test points can be as minimal as a pad on the
    PCB, which can be connected to using a pogo pin, full-blown header, or connector.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-32](#figure3-32) shows the exposed traces that can be used for probing.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the photo, test points can also be small, exposed metal components
    that an oscilloscope probe can touch.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03032](image_fi/278748c03/f03032.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-32: Test points'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping the PCB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s look at the PCB itself. The process of sleuthing the circuit design
    from the PCB is known as *reverse engineering*. In the section “Datasheets and
    Schematics” on page 77, we introduced schematics and layouts and how to read them.
    The board layout (encoded in a Gerber file) is sent to manufacturing facilities
    for production. It’s rare we’d have access to this (we cheated in the earlier
    example by using an open source product). We’re actually interested in the reverse
    process: from a physical product, we want to get back to (the security sensitive
    part of) the schematic.'
  prefs: []
  type: TYPE_NORMAL
- en: This exercise is useful, as we often know there are certain signals on an IC
    we want to access, such as some of those boot mode pins we identified before.
    Or, we often know there is a debug or serial header on the IC, and we want to
    figure out the pinout of the header on the PCB.
  prefs: []
  type: TYPE_NORMAL
- en: For the topics of fault injection and power analysis, we often need to target
    a certain power supply net. In this case, we might have one IC that is the power
    management IC, and we want to see which other ICs it is powering. For this purpose,
    we need to follow the power supply traces from one IC to another.
  prefs: []
  type: TYPE_NORMAL
- en: The PCB exists to transport power and signals between its components (such as
    our IC and header that we just mentioned). It’s basically a sandwich of conductive
    material, isolating material, and components. The PCB consists of a couple to
    dozens of layers, each electrically isolated from each other. The *traces* look
    like lines on the PCB, and the *vias*look like holes in the PCB at the end of
    a trace (see [Figure 3-33](#figure3-33)). The vias connect to further traces on
    other layers inside or on the PCB. Typically, components are located on the front
    and back of the PCB.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03033](image_fi/278748c03/f03033.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-33: Traces and vias; vias may be covered (*tented*), as in this photo,
    or exposed (*untented*)'
  prefs: []
  type: TYPE_NORMAL
- en: A PCB’s outer sides have printed markings that identify components as well as
    company logos, PCB part numbers, and other artwork. These markings are called
    the *silkscreen*, which can be helpful when relating a PCB schematic to an actual
    PCB. Also, it can be hours of fun trying to find resistor R33 in the sea of other
    labeled components. All the text and lines on the PCB shown in [Figure 3-30](#figure3-30)
    are part of the silkscreen.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re mapping IC pinouts to a board, it’s good to know that pin 1 of a
    chip is usually identified on the silkscreen (and on the IC package itself) as
    a dot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following reference designators are helpful to memorize, although you also
    may find other designators for these components:'
  prefs: []
  type: TYPE_NORMAL
- en: C = capacitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: R = resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JP = jumper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TP = test point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: U = IC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VR = voltage regulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XTAL or Y = oscillator (crystal)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can try to follow PCB traces visually, but doing so quickly becomes tricky,
    so the most common way is to grab your favorite multimeter and set it to measure
    resistance (remember, it’s nice to have a multimeter that beeps, so you don’t
    need to watch it the entire time). Before you start measuring, it’s important
    to know that all traces are covered in a *solder mask*, which is the layer that
    makes the PCB green, red, black, or other color. The solder mask prevents corrosion
    and accidental solder bridges during manufacturing. A solder mask is nonconducting,
    so you can’t use your multimeter to get to the trace. However, you can scrape
    off the solder mask pretty easily, even with the tip of your multimeter probe,
    to expose the copper of the trace.
  prefs: []
  type: TYPE_NORMAL
- en: The multimeter measures resistance by applying a small current across the probes
    and measuring the voltage across the probes for the given test current. This is
    simply solving Ohm’s law (*V* = *I* × *R*) for resistance. Because of this, you
    can only use the multimeter on unpowered circuits. Any voltage present in the
    circuit will at best confuse and at worst damage the multimeter.
  prefs: []
  type: TYPE_NORMAL
- en: The traces carry I/O signals, like JTAG, I2C, or DRAM bus signals, and they
    can also form power and ground planes. Signals usually go between two ICs, or
    between an IC and a port or header. If you’re using a multimeter as we suggest,
    be aware that certain types of parts can still confuse the multimeter. Large capacitors
    will often look like shorts, as the small test current is very slowly charging
    the capacitor, which gives a reading similar to a low resistance. Semiconductor
    components may also read as a low resistance one way, so if you are seeing a signal
    that appears to be connected to nonsensical areas, be suspicious about your measurement.
    Normally, a direct short (0 Ω, where your meter and probe resistance could measure
    in the 0 to 10 Ω range) is a “real” connection; any higher resistance values may
    be artifacts of the circuit elements.
  prefs: []
  type: TYPE_NORMAL
- en: From the IC pins, it’s common to see pullup or pulldown resistors connected
    to the IC pins. These are normally not the “final destination” of the net, so
    you will want to probe further in most cases. If you see a lot of connections,
    it may be the ground net; a single ground plane usually goes everywhere on the
    PCB. Each IC has at least one ground pin. Metal casings of ports are typically
    ground, and any connector is certain to have ground connected to at least one
    of its pins. Bigger ICs can have dozens of ground pins in order to divide the
    current load over multiple pins. ICs may also have separate analog and digital
    ground pins. The large voltage differentials caused by digital switching on digital
    lines causes a lot of noise on ground traces, so they can be isolated from analog
    circuitry by having a separate ground. At some point, the PCB connects these digital
    and analog grounds together. You can usually find ground at metal cases on ports
    or marked by the text *GND* on the silkscreen.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the metal cases on ports (normally called the shield) don’t connect
    directly to the digital ground, so always do a quick sanity check between some
    potential ground points before you dive too far in.
  prefs: []
  type: TYPE_NORMAL
- en: The PCB can have one or many power planes, each typically providing different
    voltages to components, particularly to the larger ICs. Common voltages that may
    be identified by text on the silkscreen are 5 V, 3.3 V, 1.8 V, and 1.2 V.
  prefs: []
  type: TYPE_NORMAL
- en: The various voltages are generated by *voltage regulators* or *power management
    ICs (PMICs)*. Voltage regulators are dumb components that convert the basic raw
    voltage connected to the PCB into a wide range of stable voltages. For instance,
    the LD1117 takes in a raw voltage of anything between 4 V and 15 V and converts
    it to 3.3 V. PMICs are found in more complex devices like mobile phones. They
    provide the various voltages, but they can be externally instructed to switch
    various voltages on or off. They may communicate with the SoC that they are powering
    via a protocol such as I2C so that if the OS in the SoC needs to run faster, it
    can instruct the PMIC to increase the supply voltage. Voltage drops may occur
    along traces when conducting high currents, so feedback circuitry to the PMICs
    can verify the voltage arriving at the components, allowing the PMIC to adjust
    the voltage where necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you want to bypass the PMIC and provide your own power source (for
    instance, for fault injection). At first, it may seem tricky, as the PMIC may
    go through complex voltage sequencing during boot and operation, but in practice
    we’ve rarely seen an issue with just supplying a constant voltage. Our guess is
    that this sequencing is all to save battery power, and the IC’s operation doesn’t
    seem to suffer if you don’t do this. Further, when providing your own power, you
    want to keep the feedback loop intact. So, substitute your own independent power
    supply only to the IC you are investigating. You want the PMIC to stay happy,
    because it may be holding the main IC in reset until it sees a stable output voltage.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these basics, you can start determining the answers to the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: At what voltage level is the IC or I/O channel running? Power on the device
    and measure the steady voltage between ground and the relevant IC pin or on the
    PCB trace nearby.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the ground plane connected to? The metal casing of any port is going
    to be ground. You can use that as a reference, and after removing power from the
    device, identify all other ground points, on IC pins and connectors, by performing
    the beep test described earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is power distributed on the PCB? You can either measure voltages on all
    pins, as before, or use the beep test to identify all points connected to the
    same power plane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the JTAG pins connected to? Let’s say you’ve identified the JTAG pins
    of the IC, but you want to know to which header or test point they are connected.
    Use the beep test between a JTAG IC pin and all “suspect” points on the board.
    If you really want to go pro, take a wire and fray one of the ends into a “fan,”
    as shown in [Figure 3-34](#figure3-34). Connect one of your probe pins to the
    wire and “sweep” the board, which is much more efficient than having to touch
    every point manually. If you want to get fancy, you can also buy small metal brushes
    to accomplish the same goal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![f03034](image_fi/278748c03/f03034.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-34: Continuity sweeper'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on reverse engineering a PCB, take a look at Joe Grand’s
    “Printed Circuit Board Deconstruction Techniques” USENIX paper. If you’d like
    to dig deeper on the design side, the book *Printed Circuit Board Designer’s Reference:
    Basics* (Prentice Hall, 2003), by Christopher T. Robertson, explains how PCBs
    are physically made. For more reverse engineering techniques, see Ng Keng Tiong’s
    *PCB-RE: Tools & Techniques* (CreateSpace Independent Publishing, 2017).'
  prefs: []
  type: TYPE_NORMAL
- en: Using the JTAG Boundary Scan for Mapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we’ve mostly discussed passive methods of reverse engineering the connections
    on a PCB. In the previous chapter, we mentioned the existence of the JTAG boundary
    scan mode. With boundary scan, we can use a chip to drive a signal on the board
    and use measurement equipment to find out where that signal is routed. Boundary
    scan can also be used to sense signals on a chip’s pin, which means we can drive
    a signal on the board and figure out to which pin it is routed.
  prefs: []
  type: TYPE_NORMAL
- en: Boundary scan requires us to power up the board as part of the reverse engineering.
    It also requires a little bit of information first. We need a JTAG header to run
    this! Typically, using JTAG boundary scan will be a step after we’ve done some
    basic reverse engineering. It also requires us to have a JTAG Boundary Scan Description
    Language (BSDL) file for the device in question, and the device itself to have
    JTAG boundary scan enabled (not everything will).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take an example of an automotive ECU. The E82 ECU uses an NXP MPC5676R
    device. We can find a BSDL file for the MPC5676R chip with a simple online search,
    which means it’s worth trying to get a JTAG interface connected to it. Inspecting
    the board shows an unmounted 14-pin header that’s suspiciously like the 14-pin
    JTAG commonly used by these devices. We mount a header to this and connect a JTAG
    adapter (see [Figure 3-35](#figure3-35)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03035](image_fi/278748c03/f03035.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-35: JTAG header and adapter connected to E82 ECU; a 1 kΩ resistor
    is used to drive a 1 Hz square wave into test points'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use TopJTAG software to load the BSDL file and put the chip in *EXTEST*
    mode. In this mode, we have complete control of the chip I/O pins. Some risk is
    involved because you may cause havoc by just flipping random pins (for instance,
    accidentally signaling a power supply to turn on or off). There is also *SAMPLE*
    mode, which means the chip is still running; it may be driving outputs high or
    low, preventing effective mapping. We’ll stick to *EXTEST*.
  prefs: []
  type: TYPE_NORMAL
- en: TopJTAG shows JTAG boundary scan connectivity; that’s good news for our ease
    of reverse engineering. We end up with a screen in the software like [Figure 3-36](#figure3-36).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03036](image_fi/278748c03/f03036.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-36: The TopJTAG software uses a BSDL file to show a graphical view
    of the pin state.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 3-36](#figure3-36), you can see the state of each pin on the device.
    This is a “live” view, so if the external voltage on the pin changes, we can see
    the color change in this picture or the I/O value change in the table.
  prefs: []
  type: TYPE_NORMAL
- en: To map a test point to a pin, we can drive a square wave on the test point using
    a signal generator. You can see this in [Figure 3-35](#figure3-35), where a 1
    kΩ resistor is used to drive a low-current square wave onto the board. We should
    see the associated pin toggling on the TopJTAG screen. If you don’t have a signal
    generator, you can also connect one end of a 1 kΩ resistor to a VCC point on the
    board and tap the other end on the test point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the software, you could also do the opposite: by toggling a signal from
    a particular pin, you can measure in various places on the board to find out where
    that pin is connected. Unfortunately, there is no feature in the software to generate
    a waveform, but with the CTRL-T hotkey, you can do this manually (or find some
    keypress-injection software). We’ll discuss the tools you require to perform this
    type of work in Appendix A. Joe Grand’s JTAGulator can be used to automatically
    map test points to boundary scan bits, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: Information Extraction from the Firmware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firmware images contain most of the code running on a device, so taking a peek
    at them is usually very interesting in order to find a point of attack. So far,
    we’ve mostly been discussing information we can see with our eyes or simple electrical
    tests. We’re now going to take a quantum leap in complexity and detail how you
    can actually work with firmware. At first glance, this looks like a major departure
    from the nitty-gritty details of the PCB, but if you think back to our overall
    goal of information gathering, analyzing the firmware is a critical step (and
    in many cases, the most important step). In the rest of the book, we discuss many
    operations that depend on firmware. Understanding how to find cryptographic signatures,
    for example, is an important part of knowing where you can apply fault injection;
    seeing code that could be referencing a signature is a good sign that you can
    find the location of the signature check routine.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the Firmware Image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the device physically in front of you, and fresh off a discussion of JTAG,
    you might assume we’re going to extract the firmware image from the device. But
    taking the path of least resistance, we first check whether we can obtain the
    firmware image by downloading it from an update website or, if the device has
    Linux support, checking the */lib/firmware* directory.
  prefs: []
  type: TYPE_NORMAL
- en: The image may be available as a separate file for download or embedded in an
    installer package. In case of the former, skip to the next section; in case of
    the latter, use your software reverse engineering skills to find the update file
    in the installation directory. One trick is to do a plain string search for a
    known string that the device prints out, although firmware images may often be
    compressed, and you won’t find the plain string. You can use the binwalk tool
    to find LZMA files or deflate (zlib/gzip) compressed images inside files. In fact,
    we’ll use binwalk later to carve up the firmware image itself to analyze further.
    Alternatively, you can perform the update and then sniff the image off the communication
    channel during a firmware update with a tool like Wireshark for Ethernet connections
    or socat for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Some devices support the USB Direct Firmware Update (DFU) standard, which is
    used for downloading and uploading firmware images to and from a device. If the
    target supports it, it will typically be enabled as an alternative boot mode.
    For instance, a mode could be set through a jumper, or a mode may be automatically
    chosen if the onboard firmware image is corrupted. You may be able to corrupt
    the image-loading process by a fault injection, which could be as simple as shorting
    out a data line, causing corrupted data to be loaded. Once you have DFU mode,
    you may be able to upload (extract) the firmware image. The dfu-util tool can
    perform this if it supports the device and if the device supports uploading.
  prefs: []
  type: TYPE_NORMAL
- en: The device may also support its own proprietary protocol that is also called
    DFU mode, and it may have more than one recovery mode. For example, iPhones and
    iPads typically have a “recovery mode” that allows you to reflash the device over
    USB and run firmware that Apple can update. In addition, a separate “DFU mode”
    runs immutable ROM code that allows you to reflash the device over USB. The “DFU
    Mode” is a proprietary protocol and does not implement the USB standard DFU mode.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve exhausted the software means of obtaining an image or just are in
    the mood for a hardware attack, you can attempt to extract the firmware from a
    flash chip. This is only *simply* done on an external flash chip. Some SoCs have
    an internal flash, which is accessible only through chip-level reverse engineering
    and microprobing after decapping, and therefore is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: To get the flash chip off the board, you need to desolder it, which isn’t as
    hard as it sounds, but it does require a hot-air working station. The off-the-shelf
    method for obtaining the image is to purchase a memory reader. If you want minimal
    fuss, something from the FlashcatUSB series is a good bet. Models from this company
    support both SPI and parallel flash chips, and they range from low to medium cost.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see all sorts of other methods of reading SPI flash memory as well. Solutions
    have been made with Arduino Teensy devices and Raspberry Pis. Jeong Wook (Matt)
    Oh’s “Reverse Engineering Flash Memory for Fun and Benefit,” from Black Hat 2014,
    describes a DIY approach to getting the image and is a great way to learn about
    creating hardware to interface with flash chips and flash chip memory encodings.
    It walks through the process of attaching a chip and reading it by bit-banging
    through an FTDI FT2232H.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of reading flash memory onboard, we should also mention how you can
    read eMMC chips. These chips are basically SD cards in chip form, as mentioned
    in Chapter 2. Thanks to some nice backward compatibility, you can run them in
    1-bit mode (meaning you need only GND, CLK, CMD, and D0). [Figure 3-37](#figure3-37)
    shows an example of an SD card interposer connected to read out eMMC memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03037](image_fi/278748c03/f03037.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-37: On this board, the eMMC flash connections (on the bottom of the
    board, not visible) were accessible on several pads onto which we could mount
    pin headers.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we’re holding the target processor in reset by grounding the
    nRST pin, so we can then plug the SD card into the USB SD card reader. Holding
    the target processor in reset is needed, as otherwise it would attempt to toggle
    the I/O lines at the same time. We can then mount the filesystem on the SD card
    on our computer. In this example, it was a standard filesystem readable in Linux.
    The talk “Hardware Hacking with a $10 SD Card Reader” by Amir “Zenofex” Etemadieh,
    CJ “cj_000” Heres, and Khoa “maximus64” Hoang, at Black Hat 2017 and the Exploitee.rs
    Wiki, is a valuable resource.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the Firmware Image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next task is to analyze the firmware image. It will have multiple blocks
    for different functional components—for example, various stages of the bootloader,
    digital signatures, key slots, and a filesystem image. The first step is to dissect
    the image into its components. Each component may be plaintext, compressed, encrypted,
    and/or signed. Binwalk is a useful tool for finding all components in a firmware
    image. It recognizes different sections by matching them against the “magic” bytes
    that encode different file types.
  prefs: []
  type: TYPE_NORMAL
- en: For encrypted data, you first need to figure out the encryption used and the
    key. Your best bet is to do side-channel analysis (see Chapters 8–12). Common
    options are AES-128 or AES-256 in CTR or CBC mode, although we’ve also seen ECB
    and GCM used. Once you have the key, you can decrypt the image for further analysis.
    For how to deal with digital signatures, see the “Signatures” section on page
    116.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have an image with plaintext or compressed blocks, binwalk can help
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting various files, filesystems, and compression methods within the image,
    using the `--signature` option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting the different components with the `--carve`, `--extract`, or `--dd`
    option. If you specify `--matryoshka`, this will be done recursively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting CPU architecture by analyzing opcodes in a file using `--opcode` or
    `--disasm`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for a fixed string using `--raw`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing and graphing the Shannon entropy of a file using `--entropy` or the
    zlib compression ratio with the `--fast` option. Use `--save` to save the entropy
    plot to a file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing a hexdump and diffing binary files with `--hexdump`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding compressed data with missing headers by brute force, using `--deflate`
    or `--lzma`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, let’s take a brief look at some device firmware we can easily
    download (in this case, firmware for the TP-Link TD-W8980 router). We’re looking
    at version TD-W8980_V1_150514 (found as *TD-W8980_V1_150514.zip*). Unzip it and
    then run binwalk like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output (formatted for readability) reveals some interesting information:
    a u-boot bootloader image 1, firmware for GPHY 2, and a Squashfs filesystem (Linux)
    3. If you run binwalk with `--extract` and `--matryoshka`, you’ll get all these
    blocks as separate files, with compressed and decompressed versions of components,
    and the Squashfs filesystem unpacked.'
  prefs: []
  type: TYPE_NORMAL
- en: We’re focusing on hardware attacks on embedded systems, but one feature of software
    reverse engineering you may need is to identify encrypted blocks and signatures.
    Later chapters assume you have figured that out already, so we’ll walk through
    a sample analysis. Now, what we’ll find if we modify a file on the Squashfs filesystem
    (such as */etc/passwd* or */etc/vsftpd_passwd*) is that the router doesn’t accept
    the new firmware image. This is because an RSA-1024 signature is used to verify
    the image’s authenticity. The signature isn’t indicated in the binwalk output,
    because signatures are often just sequences of random-looking bytes as specific
    offsets. You can find those offsets through entropy analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Entropy Analysis
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Entropy* is used in computer science as a measure of information density.
    For our purposes, we use 8-bit entropy. An entropy of 0 means a block of data
    contains a single byte value, and an entropy of 1 means a block contains equal
    amounts of every byte value from 0 to 255\. Entropy close to 1 is indicative of
    crypto keys, ciphertexts, or compressed data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Full of hope and excitement, we run binwalk again with the `--nplot` and `--entropy`
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The binwalk tool calculates the entropy for each block and determines block
    boundaries by looking for large changes in entropy. This usually works by finding
    contiguous blocks of compressed or encrypted data and sometimes even works for
    finding key material. In this case, we’re looking for an RSA-1024 signature (which
    is 128 bytes), and there’s no such block.
  prefs: []
  type: TYPE_NORMAL
- en: If you run binwalk again, omitting the `--nplot` option, it produces the graph
    shown in [Figure 3-38](#figure3-38).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03038](image_fi/278748c03/f03038.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-38: Entropy output from binwalk using default settings'
  prefs: []
  type: TYPE_NORMAL
- en: The graph doesn’t show the 1,024-bit/128-byte signature we are looking for either.
    Although this signature may be embedded in one of those blocks, we already shot
    ourselves in the foot. The way we are using binwalk will never show a 128-byte
    peak. Remember how entropy is calculated over a block of data? This means binwalk
    chops the file into blocks of data and calculates the entropy over those blocks.
    By default, the block size appears to be 0x1000, or 4,096 bytes. If our 128 random
    bytes are embedded in a 4,096-byte block, the entropy is only marginally affected.
  prefs: []
  type: TYPE_NORMAL
- en: This is why binwalk has the `--block` option. It’s tempting to use a block size
    of 128 bytes now, but we’d still not have a nice entropy peak if the signature
    isn’t stored exactly within a single block. So, to be safe, we tend to use a block
    size of 16.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we encounter another issue: execution is very slow. The output shows only
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That’s not very useful, as no blocks are identified at all. The output graph
    in [Figure 3-39](#figure3-39) also doesn’t show what we want.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03039](image_fi/278748c03/f03039.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-39: Entropy output using 16-byte block size'
  prefs: []
  type: TYPE_NORMAL
- en: The reason is the calculation of entropy. It’s important to understand that
    for blocks smaller than 256 bytes, by definition, the entropy cannot be 1\. Actually,
    an entropy of 1 is achieved only when each byte value has the same frequency in
    the block. If a block is smaller than 256 bytes, it’s impossible to have a frequency
    of 1 or more for each byte value; therefore, the entropy cannot be 1\. In fact,
    the entropy is maximally 0.5 at a block length of 16.
  prefs: []
  type: TYPE_NORMAL
- en: Since binwalk does edge-detection for entropy, we need to tune the thresholds
    for a rising and falling edge. If the maximum entropy is 0.5, you can set, for
    example, `--high=0.45` and `--low=0.40`. Alternatively, you can find your own
    entropy “peaks” using the `--verbose` option, which just outputs the entropy for
    each block.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the edge detection doesn’t work. We get more than 2,000 edges. The
    reason is the calculation of entropy, again. Can you guess what the entropy is
    of *Glib jocks quiz nymph to vex dwarf*? With 16-byte blocks, the first block
    has an entropy of 0.447\. This is because the smaller the block size, the higher
    the likelihood that a nonrandom sequence of bytes accidentally has only unique
    bytes, and therefore the highest entropy possible (in other words, we get false
    positives).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s apply a bit of common sense. If we were to store a signature in an image,
    where would we do that? Likely it would be just before or just after the block
    we are protecting. Let’s take a look at the first 0x400 bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems there are two high-entropy sections: 16 bytes at `0x40` 1 and 128
    bytes at `0xD0` 2. The 128-byte block is clearly visible in the entropy plot in
    [Figure 3-40](#figure3-40).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you employ the skills described earlier in this chapter, you’ll have found
    the [https://github.com/xdarklight/mktplinkfw3/](https://github.com/xdarklight/mktplinkfw3/)project
    page, which documents the header format for this particular firmware image. You
    guessed it: 0xD0 is the RSA signature (and 0x40 is an MD5 sum).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f03040](image_fi/278748c03/f03040.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-40: A more detailed entropy analysis, concentrating on areas of interest'
  prefs: []
  type: TYPE_NORMAL
- en: Signatures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For signed data, you’ll need the signing key or a way to bypass signature verification
    in order to load modified firmware (we discuss ways to bypass signature verification
    in Chapter 6).
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our firmware image: to check for data signing, modify a byte in the
    firmware image that wouldn’t cause execution to fail (for example, in a string
    constant such as a debugging or error message). If the device fails to boot with
    this image, it’s likely doing a signature verification or checksum. It’ll take
    some reverse engineering to find out which, although it may not be trivial. The
    code verifying at least the first firmware boot stage will be located in ROM,
    outside your view.'
  prefs: []
  type: TYPE_NORMAL
- en: One thing you can look for is an RSA or elliptic curve cryptography (ECC) signature
    in the image, both of which are sequences of high-entropy bytes. An RSA-2048 signature
    will be 2,048 bits (256 bytes) long, and an ECDSA signature, for example, on the
    curve *prime256v1*, will have 256 × 2 = 512 bits of signature (64 bytes). Entropy
    spikes at the end or start of a block in the firmware may indicate a signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, check the difference between two side-channel traces: one where
    you boot with a correct signature and one where you boot with a corrupted signature.
    This test allows you to pinpoint when the execution path diverges during the boot,
    which typically (but not necessarily) happens right after a signature verification.
    This information is also useful when you want to bypass signature verification
    using fault injection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the image actually may be shipped with the public key used to verify
    its integrity, because space in ROM (or fuses) is limited and public keys (especially
    RSA) are rather large. This means you can search the firmware image for high-entropy
    sections that are a public key. For RSA-2048, the public key is the modulus of
    2,048 bits and the public exponent. Very often, this exponent is 65,537 (or 0x10001).
    Finding 0x10001 next to a high-entropy section indicates an RSA public key. For
    ECC, public keys are points on the curve. There are a few ways to encode this—for
    example, in affine (x,y) coordinates, in which case the curve prime256v1 has 256
    bits for x and y, or a total of 512 bits. A compressed encoding uses the fact
    that elliptic curves have only two possible values for y, given the curve and
    the point’s x coordinate, so a compressed notation for a point on prime256v1 has
    the full x coordinate (256 bits) and 1 bit of y, for a total of 257 bits. The
    “Standards for Efficient Cryptography, SEC 1: Elliptic Curve Cryptography” specifies
    a common encoding: a point is prefixed with 0x04 if it is uncompressed, and if
    it is compressed, it’s prefixed with 0x02 or 0x03, depending on the 1 bit for
    y.'
  prefs: []
  type: TYPE_NORMAL
- en: You may be thinking, how is embedding a verification key with the object to
    verify secure? That could be easily forged! And you’d be right. To save space,
    the public key’s hash is typically stored in fuses. This means during boot, first
    the public key’s hash is verified against the stored hash and only then is it
    used to verify the image. This sequence gives attackers a second point for fault
    injection. They could create an image that embeds their own public key and sign
    the image with that key. Next, fault injection can be used to skip the key verification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Less common ways of signing a firmware image are with hash-based message authentication
    code (HMAC) or cipher-based message authentication code (CMAC). These authentication
    codes require distributing a symmetric key, which means either you have a “root
    key” programmed into each device (capable of verifying and signing arbitrary images)
    or you’re diversifying the symmetric keys per device but then need to encrypt
    each firmware image with a device-specific key. The first option is foolish; the
    second option is costly. The first option is also exactly what happened with the
    Philips Hue attack (see “IoT Goes Nuclear: Creating a ZigBee Chain Reaction” by
    Eyal Ronen et al.), so don’t always assume that you can rule something out because
    *surely no serious product would do it that way*.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we explored how to collect useful information for hardware
    hacking attacks, which typically will be all you need. Devices often don’t have
    firmware encryption, for example, and once you have the ability to dump the firmware
    with JTAG, you can learn enough to exploit the device.
  prefs: []
  type: TYPE_NORMAL
- en: With any luck, we can learn enough to exploit a system directly, and if we are
    forced to use more advanced attacks, we understand how they might apply to our
    system. Since this book is about advanced attacks, we’ll assume they’re needed
    and dive head-first into how they work. We’ll combine the information-discovering
    techniques described here with the interfacing skills outlined in Chapter 2 to
    test a system for fault injection weaknesses in the next chapter.
  prefs: []
  type: TYPE_NORMAL
