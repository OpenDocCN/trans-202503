- en: '**4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: START ME UP! THE BOOT PROCESS**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While FreeBSD boots easily and automatically when you turn on the power, understanding
    exactly what happens at each stage will make you a better system administrator.
    Intervention during the boot process is rarely necessary, but one day you’ll be
    glad you know how to do it. And once you’re comfortable with adjusting the boot
    process, you’ll find you can solve problems you’ve previously accepted and endured.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by discussing how the system loader starts and gathering information
    from the loader. You can use the loader to change the early boot process, including
    booting alternate kernels and starting in single-user mode. We’ll cover serial
    consoles, a standard system management tool. The FreeBSD multiuser startup process
    is responsible for starting all the various services that make your computer useful,
    and we’ll give attention to that as well. In addition, we’ll cover the information
    FreeBSD records about the boot process and how FreeBSD turns itself off without
    corrupting data.
  prefs: []
  type: TYPE_NORMAL
- en: '**RECURSION WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the topics in this chapter reference material found in later chapters.
    Those later chapters, in turn, require that you understand this chapter first.
    There’s no good place to begin learning. If you don’t quite understand a part
    of this chapter, just skim over it and continue reading; it really will coalesce
    in your mind as you proceed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The boot process itself can be divided into three main parts: the loader, single-user
    startup, and multiuser startup.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Power-On**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A computer needs enough brains to find and load its operating system. For many
    years, this facility came from the basic input/output system (BIOS). Newer systems
    use the Unified Extensible Firmware Interface (UEFI) instead of the BIOS. New
    installs should use UEFI. Other hardware platforms have console firmware or bootroms
    that perform the same function, but we’re focused on commodity hardware, so we’ll
    cover UEFI and BIOS.
  prefs: []
  type: TYPE_NORMAL
- en: '***Unified Extensible Firmware Interface***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: UEFI is a replacement for the three-decades-old BIOS. Any new system will come
    with UEFI enabled and will expect to use it.
  prefs: []
  type: TYPE_NORMAL
- en: UEFI searches the boot drive for a partition marked as a UEFI boot partition.
    Despite what the special mark might imply, that partition contains only a FAT
    filesystem with a specific directory and file layout. UEFI executes the file */EFI/BOOT/BOOTX64.EFI*.
    That file might be a fancy multi-OS boot loader, or it might dump you straight
    into an operating system. In FreeBSD, the UEFI boot fires up the boot loader,
    */boot/loader.efi*.
  prefs: []
  type: TYPE_NORMAL
- en: UEFI is comparatively new. If your new system has trouble booting FreeBSD, you
    might try enabling a BIOS or “legacy” mode. If the system boots FreeBSD in BIOS
    mode but not with UEFI, please file a bug, as discussed in [Chapter 24](ch24.xhtml#ch24).^([1](footnote.xhtml#ch04fn1))
  prefs: []
  type: TYPE_NORMAL
- en: '***Basic Input/Output System***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The primordial Intel PC used a basic input/output system (BIOS) with just enough
    brains to look for an operating system somewhere on a disk. A BIOS searches for
    a disk partition marked active and then executes the first section of that partition.
    For FreeBSD, that chunk of data is called the *loader*. Every FreeBSD system has
    a reference copy of the loader as */boot/loader*.
  prefs: []
  type: TYPE_NORMAL
- en: A BIOS has all sorts of limitations. The boot loader must reside in a very specific
    section of the disk. BIOS can’t boot from disks larger than 2.2TB. The target
    boot loader must be smaller than 512KB—huge by 1980 standards, yes, but paltry
    today. The installed loader is a binary, not a filesystem, so even minor changes
    require recompiling. UEFI has none of these limitations and offers modern features,
    like mouse support.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, though, a BIOS and UEFI both have the goal of getting your system
    to the FreeBSD loader.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Loader**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *loader*, or *boot blocks*, loads the FreeBSD kernel and presents you with
    a menu before starting that kernel. The loader(8) program offers a menu of seven
    options on the left. A new FreeBSD system presents these options:'
  prefs: []
  type: TYPE_NORMAL
- en: Boot Multi User [Enter]
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Boot Single User
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Escape to loader prompt
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reboot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Kernel: default/kernel (1 of 2)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure Boot Options…
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Boot Environment…
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each option highlights certain words or characters, such as *S* in “Boot Single
    User” and ESC in “Escape to loader prompt.” Select an option by pressing the highlighted
    character or the number.
  prefs: []
  type: TYPE_NORMAL
- en: The options at the top of the menu control how FreeBSD boots. We’ll look at
    each option in turn. If you wait 10 seconds, the loader automatically boots FreeBSD
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: The options at the bottom half let you fine-tune the boot process. You can tweak
    how you want the system to boot, as we’ll discuss later, and then choose one of
    the preceding booting options.
  prefs: []
  type: TYPE_NORMAL
- en: '***Boot Multi User [Enter]***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is a normal boot. Hit ENTER to boot immediately, skipping the 10-second
    delay.
  prefs: []
  type: TYPE_NORMAL
- en: '***Boot FreeBSD in Single-User Mode***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Single-user mode* is a minimal startup mode that’s very useful on damaged
    systems, especially when the damage was self-inflicted. It’s the earliest point
    where FreeBSD can provide a command prompt, and it’s important enough to have
    its own section later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Escape to Loader Prompt***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The loader includes a command line interpreter, where you can issue commands
    to tweak your system to boot exactly the way you need. We’ll cover this in detail
    in “[The Loader Prompt](ch04.xhtml#lev106)” on [page 55](ch04.xhtml#page_55).
  prefs: []
  type: TYPE_NORMAL
- en: '***Reboot***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once more, this time with feeling!
  prefs: []
  type: TYPE_NORMAL
- en: Of these options, the most important are single-user mode and the loader prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '**Single-User Mode**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: FreeBSD can perform a minimal boot, called *single-user mode*, that loads the
    kernel and finds devices but doesn’t automatically set up your filesystems, start
    the network, enable security, or run any standard Unix services. Single-user mode
    is the earliest the system can possibly give you a command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Why use single-user mode? If a badly configured daemon hangs the boot, you can
    enter single-user mode to prevent it from starting. If you’ve lost your root password,
    you can boot into single-user mode to change it. If you need to shuffle critical
    filesystems around, again, single-user mode is the place to do it.
  prefs: []
  type: TYPE_NORMAL
- en: When you choose a single-user mode boot, you’ll see the regular system startup
    messages flow past. Before any programs start, however, the kernel offers you
    a chance to choose a shell. You can enter any shell on the root partition; I usually
    just take the default */bin/sh*, but use */bin/tcsh* if you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: '***Disks in Single-User Mode***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In single-user mode, the root partition is mounted read-only and no other disks
    are mounted. (We’ll discuss mounting filesystems in [Chapter 10](ch10.xhtml#ch10),
    but for now just follow along.) Many of the programs that you’ll want to use are
    on partitions other than the root, so you’ll want them all mounted read-write
    and available. The way to do this varies depending on whether you’re using UFS
    or ZFS.
  prefs: []
  type: TYPE_NORMAL
- en: '**UFS in Single-User Mode**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To make all the filesystems listed in the filesystem table */etc/fstab* usable,
    run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The fsck(8) program “cleans” the filesystems and confirms that they’re internally
    consistent and that all the files that a disk thinks it has are actually present
    and accounted for.
  prefs: []
  type: TYPE_NORMAL
- en: The root filesystem is mounted read-only. Whatever drove us to single-user mode
    probably requires changing the root filesystem. Remount the root filesystem read-write.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `-a` flag to mount(8) activates every filesystem listed in */etc/fstab*
    (see [Chapter 10](ch10.xhtml#ch10)). If one of these filesystems is causing you
    problems, you can mount the desired filesystems individually by specifying them
    on the command line (for example, `mount /usr`). If you’re an advanced user with
    NFS filesystems configured (see [Chapter 13](ch13.xhtml#ch13)), you’ll see error
    messages for those filesystems at this point because the network isn’t up yet.
    If the host has network filesystems in */etc/fstab*, mount only the UFS filesystems
    as shown next.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have trouble mounting partitions by name, try using the device name
    instead. The device name for the root partition is probably */dev/ad0s1a*. You’ll
    also need to specify a mount point for this partition. For example, to mount your
    first IDE disk partition as root, enter the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have network filesystems on your server but your network isn’t up yet,
    you can mount all your local partitions by specifying the filesystem type. Here,
    we mount all of the local filesystems of type UFS, which is FreeBSD’s default
    filesystem type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can now access your UFS filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: '**ZFS in Single-User Mode**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To make all of your ZFS datasets available, use `zfs mount`. You can either
    mount individual datasets by name or mount everything that’s marked as mountable
    with `-a`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: ZFS will perform its usual integrity checks before mounting the datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the datasets will be exactly as accessible as in multiuser mode, but
    the dataset mounted as root will still be read-only. Turn that off. Here, I’m
    setting the root dataset to read-write on a default FreeBSD install.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can now change the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '***Programs Available in Single-User Mode***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The commands available for your use depend on which partitions are mounted.
    Some basic commands are available on the root partition in */bin* and */sbin*,
    and they’re available even if root is mounted read-only. Others live in */usr*
    and are inaccessible until you mount that partition. (Take a look at */bin* and
    */sbin* on your system to get an idea of what you’ll have to work with when things
    go bad.)
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve scrambled your shared library system (see [Chapter 17](ch17.xhtml#ch17)),
    none of these programs will work. If you’re that unlucky, FreeBSD provides statically
    linked versions of many core utilities in the */rescue* directory.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Network in Single-User Mode***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you want to have network connectivity in single-user mode, use the shell
    script */etc/netstart*. This script calls the appropriate scripts to start the
    network, gives IP addresses to interfaces, and enables packet filtering and routing.
    If you want some, but not all, of these services, you’ll need to read that shell
    script and execute the appropriate commands manually.
  prefs: []
  type: TYPE_NORMAL
- en: '***Uses for Single-User Mode***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In single-user mode, your access to the system is limited only by your knowledge
    of FreeBSD and Unix.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you’ve forgotten your root password, you can reset it from
    single-user mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You’ll notice that you weren’t asked for the old root password. In single-user
    mode, you’re automatically root, and passwd(8) doesn’t ask root for any password.*'
  prefs: []
  type: TYPE_NORMAL
- en: Or, if you find that there’s a typo in */etc/fstab* that confuses the system
    and makes it unbootable, you can mount the root partition with the device name
    and then edit */etc/fstab* to resolve the issue.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a program that panics the system on boot and you need to stop that
    program from starting again, you can either edit */etc/rc.conf* to disable the
    program or set the permissions on the startup script so that it can’t execute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We’ll discuss third-party programs (ports and packages) in [Chapter 15](ch15.xhtml#ch15).
  prefs: []
  type: TYPE_NORMAL
- en: You need to understand single-user mode to be a successful sysadmin, and we’ll
    refer to it throughout this book. For now, though, let’s look at the loader prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '**SYSTEM FAILURES VERSUS HUMAN FAILINGS**'
  prefs: []
  type: TYPE_NORMAL
- en: There’s a reason all of these examples involve recovering from human errors.
    Hardware failures aren’t common, and FreeBSD failures, even less so. If it weren’t
    for human error, our computers would almost never let us down. As you learn more
    about FreeBSD, you’ll be more and more capable in single-user mode.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Loader Prompt**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The loader prompt allows you to make basic changes to your computer’s boot
    environment and the variables that must be configured early in the boot process.
    It’s not a Unix-like environment; it’s cramped and supports only a minimal feature
    set. When you escape to a loader prompt (the third option in the boot menu), you’ll
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is the loader prompt. While the word *OK* might be friendly and reassuring,
    it’s one of the few friendly things about the loader environment. This isn’t a
    full-featured operating system; it’s a tool for configuring a system boot that’s
    not intended for the ignorant nor the faint of heart. Any changes you make at
    the loader prompt affect only the current boot. To undo changes, reboot again.
    (We’ll see how to make loader changes permanent in the next section.)
  prefs: []
  type: TYPE_NORMAL
- en: To see all available commands, enter a question mark.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Many loader commands aren’t useful to anyone except a developer, so we’ll focus
    on the commands useful to a system administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '***Viewing Disks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To view the disks that the loader knows about, use `lsdev`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The loader checks for CD drives ➊ and doesn’t find any. (The loader finds CD
    drives only if you boot from a CD, so don’t be alarmed by this.) It finds a hard
    drive, known to the BIOS as drive C ➋. It then describes the partitions on that
    hard drive. As we’ll see in [Chapter 10](ch10.xhtml#ch10), GPT partitions identify
    partitions with the letter *p* and a number. The partition disk0p1 ➌ is a FreeBSD
    boot partition used to bootstrap FreeBSD from the BIOS. You might find this knowledge
    useful on an unfamiliar system that’s having trouble booting. The loader can also
    identify the ZFS pools ➍ on the host.
  prefs: []
  type: TYPE_NORMAL
- en: '***Loader Variables***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The loader has variables set within the kernel and by a configuration file.
    View these variables and their settings with the `show` command, and use the spacebar
    to advance to the next page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These values include low-level kernel tunables and information gleaned from
    the hardware BIOS or UEFI. We’ll see a partial list of loader variables in “[Loader
    Configuration](ch04.xhtml#lev111)” on [page 57](ch04.xhtml#page_57), and additional
    values will be brought up throughout the book in the appropriate sections.
  prefs: []
  type: TYPE_NORMAL
- en: You can show specific variables by name. Sadly, you can’t show all of a keyword’s
    sub-variables. A command like `show acpi.oem` works, but `show acpi` or `show
    acpi.*` doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change a value for a single boot with the `set` command. For example, to change
    the `console` setting to `comconsole`, you’d enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The loader lets you change variables that really shouldn’t change. Setting acpi.revision
    to 4 won’t suddenly upgrade your system to ACPI version 4, and you can’t change
    hard drives with a software setting.
  prefs: []
  type: TYPE_NORMAL
- en: '***Reboot***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You didn’t mean to get into the loader? Start over.
  prefs: []
  type: TYPE_NORMAL
- en: '***Booting from the Loader***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you’ve twiddled your system’s low-level settings, you probably want
    to boot the system. Use the boot(8) command. You can adjust the boot further using
    the boot flags discussed in the man page.
  prefs: []
  type: TYPE_NORMAL
- en: Once your system boots just the way you need it to, you’ll probably want to
    make those settings permanent. FreeBSD lets you do this through the loader configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Loader Configuration**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make loader setting changes permanent with the configuration file */boot/loader.conf*.
    Settings in this file are fed directly into the boot loader at system startup.
    Of course, if you enjoy being at your console every time the system boots, then
    don’t bother with this!
  prefs: []
  type: TYPE_NORMAL
- en: The loader has a default configuration file, */boot/defaults/loader.conf*. We
    override many of the values here.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the default loader configuration, you’ll see many options that
    resemble variables listed in the loader. For example, here we can set the name
    of the console device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Throughout the FreeBSD documentation, you’ll see references to *boot-time tunables*
    and *loader settings*. All of these are set in *loader.conf*, which includes many
    sysctl values that are read-only once the system is up and kicking. (For more
    on tunables and sysctls, see [Chapter 6](ch06.xhtml#ch06).) Here, we force the
    kernel variable `kern.maxusers` to `32`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Some of these variables don’t have a specific value set in *loader.conf*; instead,
    they appear as empty quotes. This means that the loader normally lets the kernel
    set this value, but if you want to override the kernel’s setting, you can.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The kernel has an idea of what the value of `kern.nbuf` should be, but you can
    have the loader dictate a different value if you must.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss system tuning via the boot loader in the appropriate section—for
    example, kernel values will be discussed in [Chapter 6](ch06.xhtml#ch06), where
    they’ll make something resembling sense—but here are some commonly used loader
    values that affect the appearance and operation of the loader itself and basic
    boot functionality. As FreeBSD matures, the developers introduce new loader values
    and alter the functionality of old ones, so be sure to check */boot/defaults/loader.conf*
    on your installation for the current list.
  prefs: []
  type: TYPE_NORMAL
- en: boot_verbose="NO"
  prefs: []
  type: TYPE_NORMAL
- en: This value toggles the verbose boot mode that you can reach through the boot
    menu. In a standard boot, the kernel prints out a few basic notes about each device
    as it identifies system hardware. When you boot in verbose mode, the kernel tells
    each device driver to print out any and all information it can about each device
    as well as display assorted kernel-related setup details. Verbose mode is useful
    for debugging and development, but not generally for day-to-day use.
  prefs: []
  type: TYPE_NORMAL
- en: autoboot_delay="10"
  prefs: []
  type: TYPE_NORMAL
- en: This value indicates the number of seconds between the display of the boot menu
    and the automatic boot. I frequently turn this down to 2 or 3 seconds, as I want
    my machines to come up as quickly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: beastie_disable="NO"
  prefs: []
  type: TYPE_NORMAL
- en: This value controls the appearance of the boot menu (originally, an ASCII art
    image of the BSD “Beastie” mascot decorated the boot menu). If set to `YES`, the
    boot menu will not appear.
  prefs: []
  type: TYPE_NORMAL
- en: loader_logo="fbsdbw"
  prefs: []
  type: TYPE_NORMAL
- en: This value allows you to choose which logo appears to the right of the boot
    menu. The `fbsdbw` option gives you the default FreeBSD logo in ASCII art. Other
    options include `beastiebw` (the original logo), `beastie` (the logo in color),
    and `none` (no logo).
  prefs: []
  type: TYPE_NORMAL
- en: '**Boot Options**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The boot menu also presents three options: choosing a kernel, setting boot
    options, and selecting a boot environment. We’ll discuss each of these in an appropriate
    section, but here’s a bit to orient you.'
  prefs: []
  type: TYPE_NORMAL
- en: A host can have multiple kernels in its */boot* directory. Hitting the *Kernel*
    option tells the loader to cycle between the available options. To have a kernel
    appear as an option, list it in *loader.conf* in the kernels variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The menu recognizes kernels only in directories beginning with */boot/kernel*.
    If you have a kernel in */boot/gerbil*, you’ll have to load it from the loader
    prompt.
  prefs: []
  type: TYPE_NORMAL
- en: FreeBSD supports a number of boot options. Selecting the *Configure Boot Options*
    item brings up the most popular.
  prefs: []
  type: TYPE_NORMAL
- en: '**Load System Defaults**'
  prefs: []
  type: TYPE_NORMAL
- en: You mucked with your settings and want to undo all that? Choose this. You can
    at least boot the system to single-user mode and fix your *loader.conf*.
  prefs: []
  type: TYPE_NORMAL
- en: '**ACPI Support**'
  prefs: []
  type: TYPE_NORMAL
- en: ACPI is the Advanced Configuration and Power Interface, an Intel/Toshiba/Microsoft
    standard for hardware configuration. It replaces and subsumes a whole bunch of
    obscure standards. ACPI has been a standard for many years now, but if a particular
    piece of hardware has trouble running FreeBSD, you can turn it off and see what
    happens. If you even think of trying this option, also read [Chapter 24](ch24.xhtml#ch24)
    and file a bug report.
  prefs: []
  type: TYPE_NORMAL
- en: '**Safe Mode**'
  prefs: []
  type: TYPE_NORMAL
- en: FreeBSD’s *safe mode* turns on just about every conservative option in the operating
    system. It turns off DMA and write caching on hard disks, limiting their speed
    but increasing their reliability. It turns off ACPI. 32-bit systems disable SMP.
    USB keyboards no longer work in safe mode. This option is useful for debugging
    older hardware.
  prefs: []
  type: TYPE_NORMAL
- en: '**Verbose**'
  prefs: []
  type: TYPE_NORMAL
- en: The FreeBSD kernel probes every piece of hardware as it boots. Most of the information
    discovered is irrelevant to day-to-day use, so the boot loader doesn’t display
    it. When you boot in verbose mode, FreeBSD prints all the details it can about
    every system setting and attached device. The information will be available later
    in */var/run/dmesg.boot*, as discussed in the next section. I encourage you to
    try verbose mode on new machines, just to glimpse the system’s complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the *Select Boot Environment* option lets you choose between ZFS boot
    environments, as discussed in [Chapter 12](ch12.xhtml#ch12).
  prefs: []
  type: TYPE_NORMAL
- en: '**Startup Messages**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A booting FreeBSD system displays messages indicating the hardware attached
    to the system, the operating system version, and the status of various programs
    and services as they start. These messages are important when you first install
    your system and when you do troubleshooting. The boot messages always start off
    the same way, with a statement listing the copyrights for the FreeBSD Project
    and the Regents of the University of California:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In addition, you get a notice of the version of FreeBSD that’s booting, along
    with the date and time it was compiled and the compiler used. You can also see
    who compiled this kernel, what machine it was built on, and even where in the
    filesystem this kernel was built. If you build a lot of kernels, this information
    can be invaluable when trying to identify exactly what system features are available.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The kernel will print out diagnostic messages throughout the boot process. The
    preceding message means that I have debugging and fault-identifying code enabled
    in this particular kernel, and my performance will suffer as a result. In this
    case, I don’t care about the performance impact, for reasons which will become
    clear momentarily.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This message identifies a particular piece of hardware. The *timecounter*,
    or *hardware clock*, is a special piece of hardware, and while your computer needs
    one, it’s such a low-level device that the end user really can’t do much with
    it directly. Now and then, you’ll see messages like this for hardware that isn’t
    directly visible to the user but is vital to the system. The boot messages dance
    between showing too much detail and obscuring details that might be critical.
    For example, it’ll also show all the information it can about the CPU in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You probably didn’t know that a simple CPU could have so many details and features,
    did you? But when you file a trouble report that advanced features don’t work,
    a developer might respond by asking whether your CPU has a particular feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s why I’m not worried about the performance hit caused by the `WITNESS`
    option shown earlier: this box is pretty darn fast ➊ and supports a whole bunch
    of features important to modern CPUs ➋. While I certainly want all the performance
    I paid for, I also want to catch any problems when they happen. I want to be able
    to file good bug reports on those problems, so the developers will listen to my
    problem report. That’s *why* I’m running a development version of FreeBSD that
    ships with WITNESS enabled, after all!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, the kernel announces that it’s found all eight CPU cores and is ready
    to manage them. I have CPU power to spare and a fair amount of memory as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The *real* memory ➊ is the amount of RAM physically installed in the computer,
    while the *avail* memory ➋ is the amount of memory left over after the kernel
    is loaded. I have 31,669MB of RAM ➌ available for real work, which more than suffices
    for the load on this system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here’s a fairly typical device entry. This device is known as ioapic, and the
    kernel has found that this hardware is version 2.0 and has extra information associated
    with it ➋. What’s more, we’ve found two devices of that type, numbered 0 ➊ and
    1 ➌. (All devices are numbered starting with zero.) You can find out more about
    the device by reading the man page for the device driver. Almost all—but not all—device
    drivers have man pages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Not all device drivers print all their information on a single line. Here, we
    have a single device, usbus, that takes up three lines with just a single instance
    of the device. The only way to know that this is a single USB bus rather than
    three separate ones is to check the number of the device. All of these are for
    device number zero, so it’s a single device.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: One interesting thing about the boot messages is that they display how your
    computer’s components are attached to one another. Here, we have pci0 ➊, a PCI
    interface directly on the mainboard. Then, there’s pcib8 ➋, PCI bridge number
    eight attached to pci0 ➌. We also find PCI bus pci8 ➍ attached to that PCI bridge
    ➎. As you read on, you’ll find individual devices attached to that bus. You might
    not be equipped to do much with this information now, but you’ll find that having
    it available will be valuable when you have to troubleshoot a problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This entry shows em0, a network card of type em(4) ➊, and indicates that the
    card speaks gigabit Ethernet ➋. We also see all sorts of information about its
    memory address, IRQ, and PCI bus attachment.
  prefs: []
  type: TYPE_NORMAL
- en: Every device on your computer has one or more entries like these. Taken as a
    whole, they describe your computer’s hardware in reasonable detail. If you boot
    in verbose mode, you’ll see even more detail—probably far more than you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BOOT MESSAGES FILE**'
  prefs: []
  type: TYPE_NORMAL
- en: While the boot information is handy, chances are it’ll disappear from the screen
    by the time you need it. For future reference, FreeBSD stores boot messages in
    the file */var/run/dmesg.boot*. This means that you can inspect your kernel’s
    hardware messages even after your system has been up and running for months.
  prefs: []
  type: TYPE_NORMAL
- en: One key thing that the kernel displays in the boot messages is the device name
    for each piece of hardware. This is critical information for managing your system.
    Every piece of hardware has a device node name, and to configure it, you’ll need
    to know that name. For example, earlier we saw an entry for an Ethernet card called
    em0\. The card uses the em(4) driver, and the first device controlled by this
    driver has number zero. Your second device of this type would be em1, then em2,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Most devices that can be configured or managed have a device node entry somewhere
    under */dev*. For example, the first optical drive is represented by the file
    */dev/cd0*. These files are called *device nodes*, and they’re a convenient way
    to address a particular piece of hardware. Most device nodes can’t be directly
    accessed as a regular file; you can’t cat(1) a device node or copy another file
    to it. However, device nodes are used as arguments to specialized programs. For
    example, the hard drive that showed up at boot as ada4 is the same as the device
    node */dev/ada4*. When you want to mount that hard drive, you can use the device
    node name and be sure you’re getting that exact piece of hardware.
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiuser Startup**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Beyond single-user mode, you’ll find multiuser mode. This is the standard operating
    mode for a Unix-like OS. If you’re doing real work, your system is in multiuser
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: When FreeBSD finishes inspecting the hardware and attaching all the device drivers
    appropriately, it runs the shell script */etc/rc*. This script mounts all filesystems,
    brings up the network interfaces, configures device nodes, identifies available
    shared libraries, and does all the other work necessary to make a system ready
    for normal work. Most systems have different startup requirements; while almost
    every server needs to mount a hard drive, a web server’s operating requirements
    are very different from those of a database server, even if it’s running on absolutely
    identical hardware. This means that */etc/rc* must be extremely flexible. It achieves
    flexibility by delegating everything to other shell scripts responsible for specific
    aspects of the system.
  prefs: []
  type: TYPE_NORMAL
- en: The */etc/rc* script is controlled by the files */etc/defaults/rc.conf* and
    */etc/rc.conf*.
  prefs: []
  type: TYPE_NORMAL
- en: '***/etc/rc.conf, /etc/rc.conf.d, and /etc/defaults/rc.conf***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Much like the loader configuration file, the configuration of */etc/rc* is
    split between two files: the default settings file, */etc/defaults/rc.conf*, and
    the local settings file, */etc/rc.conf*. Settings in */etc/rc.conf* override any
    values given in */etc/defaults/rc.conf*, exactly as with the loader.'
  prefs: []
  type: TYPE_NORMAL
- en: The */etc/defaults/rc.conf* file is huge and contains quite a few variables,
    frequently called *knobs*, or *tunables*. We aren’t going to discuss all of them,
    not only because knobs are added continually and such a list would be immediately
    obsolete but also because quite a few knobs aren’t commonly used on servers. Almost
    everything in a standard FreeBSD system has one or more *rc.conf* knobs, from
    your keyboard map to TCP/IP behavior. For a complete, up-to-date list, read rc.conf(5).
    To change *rc.conf* settings, you can either use a text editor or sysrc(8).
  prefs: []
  type: TYPE_NORMAL
- en: '**sysrc(8)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: While editing *rc.conf* by hand works just fine, in this age of cloud computing,
    it’s not sustainable across large numbers of machines. If you must change dozens
    of servers, you need a reliable way to alter the system without either manually
    editing each server’s config or resorting to sed/awk hackery.^([2](footnote.xhtml#ch04fn2))
  prefs: []
  type: TYPE_NORMAL
- en: FreeBSD includes sysrc(8), a command line program to consistently and safely
    alter */etc/rc.conf* and friends from the command line. Additionally, sysrc(8)
    can display information about your system’s non-default settings.
  prefs: []
  type: TYPE_NORMAL
- en: Start by using `-a` to ask sysrc(8) what it knows about your host.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You’ll get a list of all non-default */etc/rc.conf* settings.
  prefs: []
  type: TYPE_NORMAL
- en: To have sysrc(8) enable a service, give it the variable name, an equals sign,
    and the new value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The variable `rc_startmsgs` is now set to `no`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that sysrc(8) is a tool for changing *rc.conf*, not for configuring
    FreeBSD. It does no validity checking. One of my very junior sysadmins really
    doesn’t want Bert logging in, and he took some bad advice on how to prevent that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: While this code sets `bert="no"` in */etc/rc.conf*, this variable doesn’t do
    anything. Remove it with the `-x` flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Many FreeBSD configuration files closely resemble *rc.conf*. You can use sysrc(8)
    to manage them by adding the `-f` flag and the file name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Should you edit *rc.conf* or use sysrc(8)? If you’re making manual changes,
    then use whichever you prefer. Automation should err on the side of sysrc(8).
    This book mixes examples of both.
  prefs: []
  type: TYPE_NORMAL
- en: '**/etc/rc.conf.d/**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you use a server configuration system such as Puppet or Ansible, you might
    trust copying entire files more than editing them. Use */etc/rc.conf.d/* files
    to enable services through such tools.
  prefs: []
  type: TYPE_NORMAL
- en: To manage a service in */etc/rc.conf.d/*, create a file named after the service.
    That is, to manage bsnmpd(8) you’d create */etc/rc.conf.d/bsnmpd*. Enable or disable
    that service in this file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: I normally use Ansible’s service enabling features that directly alter */etc/rc.conf*
    rather than */etc/rc.conf.d*, but use whatever you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: The next few sections illustrate the types of things you can enable and disable
    in */etc/rc.conf*. Each appears in */etc/defaults/rc.conf* and can be overridden
    by an */etc/rc.conf* entry. Each variable appears with its default setting.
  prefs: []
  type: TYPE_NORMAL
- en: '**Startup Options**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The following *rc.conf* options control how FreeBSD configures itself and starts
    other programs. These far-reaching settings affect how all other system programs
    and services run.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re having a problem with the startup scripts themselves, you might enable
    debugging on */etc/rc* and its subordinate scripts. This can provide additional
    information about why a script is or isn’t starting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t need the full debugging output but would like some additional
    information about the */etc/rc process*, enable informational messages with `rc_info`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When the boot process hits multiuser startup, it prints out a message for each
    daemon it starts. Remove those messages with the `rc_startmsgs` option.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '**Filesystem Options**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: FreeBSD can use memory as a filesystem, as we’ll discuss in [Chapter 13](ch13.xhtml#ch13).
    One common use for this feature is to make */tmp* really fast by using memory
    rather than a hard drive as its backend. Once you’ve read [Chapter 13](ch13.xhtml#ch13),
    you might consider implementing this. Variables in *rc.conf* let you enable a
    memory-backed */tmp* and set its size transparently and painlessly. You can also
    choose the options FreeBSD will use to complete the filesystem. (The impatient
    among you are probably wondering what the `-S` flag means. It means *disable soft
    updates*. If you have no idea what this means, either, wait for [Chapter 11](ch11.xhtml#ch11).)
    If you want to use a memory filesystem */tmp*, set `tmpmfs` to `YES` and set `tmpsize`
    to the desired size of your */tmp*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Another popular FreeBSD filesystem feature is its integrated encrypted partitions.
    FreeBSD supports two different filesystem encryption systems out of the box: GBDE
    and GELI. *GEOM-Based Disk Encryption (GBDE)* was FreeBSD’s first encrypted filesystem
    designed for military-grade use. GELI is a little more friendly and complies with
    different standards than GBDE. (You definitely want to read [Chapter 23](ch23.xhtml#ch23)
    before enabling either of these!)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: By default, FreeBSD mounts the root partition read-write upon achieving multiuser
    mode. If you want to run in read-only mode instead, you can set the following
    variable to `NO`. Many people consider this more secure, but a read-only root
    can interfere with operation of certain software, and it’ll certainly prevent
    you from editing any files on the root partition!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When a booting FreeBSD attempts to mount its filesystems, it checks them for
    internal consistency. If the kernel finds major filesystem problems, it can try
    to fix them automatically with `fsck -y`. While this is necessary in certain situations,
    it’s not entirely safe. (Be sure to read [Chapter 11](ch11.xhtml#ch11) very carefully
    before enabling this!)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The kernel might also find minor filesystem problems, which it resolves on the
    fly using a *background fsck* while the system is running in multiuser mode, as
    discussed in [Chapter 11](ch11.xhtml#ch11). There are legitimate concerns about
    the safety of using this feature in certain circumstances. You can control the
    use of background fsck and set how long the system will wait before beginning
    the background fsck.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '**Miscellaneous Network Daemons**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: FreeBSD includes many smaller programs, or daemons, that run in the background
    to provide specific services. We’ll cover quite a few of these integrated services
    throughout the book, but here are a few specific ones that’ll be of interest to
    experienced system administrators. One popular daemon is syslogd(8). Logs are
    a Good Thing. Logs are so very, *very* good that large parts of [Chapter 21](ch21.xhtml#ch21)
    are devoted to the topic of logging with, for, by, and on FreeBSD.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve decided to run the logging daemon, you can choose exactly how it’ll
    run by setting command line flags for it. FreeBSD will use these flags when starting
    the daemon. For all the programs included in *rc.conf* that can take command line
    flags, the flags are given in this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Another popular daemon is inetd(8), the server for small network services. (We
    cover inetd in [Chapter 20](ch20.xhtml#ch20).)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Most systems use the Secure Shell (SSH) daemon for remote logins. If you want
    to connect to your system remotely over the network, you’ll almost certainly need
    SSH services.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: While the SSH daemon can be configured via the command line, you’re generally
    better off using the configuration files in */etc/ssh/*. See [Chapter 20](ch20.xhtml#ch20)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: FreeBSD also incorporates extensive time-keeping software that functions to
    ensure the system clock remains synchronized with the rest of the world. You’ll
    need to configure this for it to be useful; we’ll cover that in [Chapter 20](ch20.xhtml#ch20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In addition, FreeBSD includes a small SNMP daemon for use in facilities with
    SNMP-based management tools. We’ll cover configuring SNMP in [Chapter 21](ch21.xhtml#ch21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '**Network Options**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: These knobs control how FreeBSD configures its network facilities during boot.
    We’ll discuss networking in [Chapter 7](ch07.xhtml#ch07).
  prefs: []
  type: TYPE_NORMAL
- en: Every machine on the internet needs a hostname. The hostname is the fully qualified
    domain name of the system, such as *www.absolutefreebsd.org*. Many programs won’t
    run properly without this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: FreeBSD includes a few different integrated firewall packages. We’re going to
    briefly cover the packet filter (PF) in [Chapter 19](ch19.xhtml#ch19). Enable
    and disable PF in *rc.conf*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You might be interested in failed attempts to connect to your system over the
    network. This will help detect port scans and network intrusion attempts, but
    it’ll also collect a lot of garbage. It’s interesting to set this for a short
    period of time just to see what really happens on your network. (Then again, knowing
    what’s *really* going on tends to cause heartburn.) Set this to `1` to log failed
    connection attempts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Routers use ICMP redirects to inform client machines of the proper network gateways
    for particular routes. While this is completely legitimate, on some networks intruders
    can use this to capture data. If you don’t need ICMP redirects on your network,
    you can set this option for an extremely tiny measure of added security. If you’re
    not sure whether you’re using them, ask your network administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If you *are* the network administrator and you’re not sure whether your network
    uses ICMP redirects, there’s an easy way to find out—just log all redirects received
    by your system to */var/log/messages*.^([3](footnote.xhtml#ch04fn3)) Note that
    if your server is under attack, this can fill your hard drive with redirect logs
    fairly quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To get on the network, you’ll need to assign each interface an IP address.
    We’ll discuss this in some detail in [Chapter 8](ch08.xhtml#ch08). You can get
    a list of your network interfaces with the ifconfig(8) command. List each network
    interface on its own line, with its network configuration information in quotes.
    For example, to give your em0 network card an IP address of 172.18.11.3 and a
    netmask of 255.255.254.0, you would use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If your network uses DHCP, use the value `dhcp` as an IP address.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can assign aliases to a network card. An alias is not the card’s
    actual IP address, but the card answers for that IP address, as discussed in [Chapter
    8](ch08.xhtml#ch08). FreeBSD supports hundreds of aliases on a single card, with
    *rc.conf* entries in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The alias numbers must be continuous, starting with 0\. If there’s a break
    in numbering, aliases above the break won’t be installed at boot time. (This is
    a common problem, and when you see it, check your list of aliases.) For example,
    an alias of 192.168.3.4 would be listed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '**Network Routing Options**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: FreeBSD’s network stack includes many features for routing internet traffic.
    These start with the very basic, such as configuring an IP for your default gateway.
    While assigning a valid IP address to a network interface gets you on the local
    network, a default router will give you access to everything beyond your LAN.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Network control devices, such as firewalls, must pass traffic between different
    interfaces. While FreeBSD won’t do this by default, it’s simple to enable. Just
    tell the system that it’s a gateway and it’ll connect multiple networks for you.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '**Console Options**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The console options control how the monitor and keyboard behave. You can change
    the language of your keyboard, the monitor’s font size, or just about anything
    else you like. For example, the keyboard map defaults to the standard US keyboard,
    frequently called *QWERTY*. You’ll find all sorts of keymaps in the directory
    */usr/share/syscons/keymaps*. I prefer the Dvorak keyboard layout, which has an
    entry there as *us.dvorak*. By changing the `keymap` knob to *us.dvorak*, my system
    will use a Dvorak keyboard once it boots to multiuser mode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: FreeBSD turns the monitor dark when the keyboard has been idle for a time specified
    in the `blanktime` knob. If you set this to `NO`, FreeBSD won’t dim the screen.
    Mind you, new hardware will dim the monitor after some time as well, to conserve
    power. If your screen goes blank even if you’ve set the `blanktime` knob to `NO`,
    check your BIOS and your monitor manual.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: FreeBSD can also use a variety of fonts on the console. While the default font
    is fine for servers, you might want a different font on your desktop or laptop.
    My laptop has one of those 17-inch screens proportioned for watching movies, and
    the default fonts look kind of silly at that size. You can choose a new font from
    the directory */usr/share/syscons/fonts*. Try a few to see how they look on your
    systems. The font’s name includes the size, so you can set the appropriate variable.
    For example, the font *swiss-8x8.fnt* is the Swiss font, 8 pixels by 8 pixels.
    To use it, you would set the `font8x8` knob.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: You can use a mouse on the console, even without a GUI. By default, FreeBSD
    will try to autodetect your mouse type. If you have a PS/2 or USB mouse, chances
    are that it’ll just work when you enable the mouse daemon, without any special
    configuration. Some older and more unusual types of mice require manual configuration,
    as documented in moused(8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: You can also change the display on your monitor to fit your needs. If you have
    an odd-sized monitor, you can change the number of lines of text and their length
    to fit, change text colors, change your cursor and cursor behavior, and do all
    sorts of other little tweaks. You can get a full list of different options in
    man vidcontrol(1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you can adjust your keyboard behavior almost arbitrarily. Everything
    from key repeat speed to the effect of function keys can be configured, as documented
    in kbdcontrol(1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '**Other Options**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This final potpourri of knobs might or might not be useful in any given environment,
    but they’re needed frequently enough to deserve mention. For example, not all
    systems have access to a printer, but those that do will want to run the printing
    daemon lpd(8). We brush up against printer configuration in [Chapter 20](ch20.xhtml#ch20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The sendmail(8) daemon manages transmission and receipt of email between systems.
    While almost all systems need to transmit email, most FreeBSD machines don’t need
    to receive email. The `sendmail_enable` knob specifically handles incoming mail,
    while `sendmail_outbound_enable` allows the machine to transmit mail. See [Chapter
    20](ch20.xhtml#ch20) for more details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: One of FreeBSD’s more interesting features is its ability to run software built
    for Linux. We discuss this feature in [Chapter 17](ch17.xhtml#ch17). Running Linux
    software isn’t quite as easy as throwing this toggle, so don’t enable Linux compatibility
    modes without reading that chapter first!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: A vital part of any Unix-like operating system is shared libraries. You can
    control where FreeBSD looks for shared libraries. Although the default setting
    is usually adequate, if you find yourself regularly setting the `LD_LIBRARY_PATH`
    environment variable for your users, you should consider adjusting the library
    path instead. See [Chapter 17](ch17.xhtml#ch17) for more advice on the library
    path.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: FreeBSD has a security profile system that allows the administrator to control
    basic system features. You can globally disallow mounting hard disks, accessing
    particular TCP/IP ports, and even changing files. See [Chapter 9](ch09.xhtml#ch09)
    for details on how to use these.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know a smattering of the configuration knobs FreeBSD supports out
    of the box, let’s see how they’re used.
  prefs: []
  type: TYPE_NORMAL
- en: '**The rc.d Startup System**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: FreeBSD bridges the gap between single-user mode and multiuser mode via the
    shell script */etc/rc*. This script reads in the configuration files */etc/defaults/rc.conf*
    and */etc/rc.conf*, and runs a collection of other scripts based on what it finds
    there. For example, if you’ve enabled the network time daemon, */etc/rc* runs
    a script written specifically for starting that daemon. FreeBSD includes scripts
    for starting services, mounting disks, configuring the network, and setting security
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: These scripts live in */etc/rc.d* and */usr/local/etc/rc.d*. I’d recommend reading
    a few of them if only to see how the *rc.d* system works.
  prefs: []
  type: TYPE_NORMAL
- en: Control these scripts with service(8).
  prefs: []
  type: TYPE_NORMAL
- en: '***The service(8) Command***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All of the *rc.d* scripts are readable, and the way they fit together is pretty
    straightforward. When you have a problem, you can read the scripts to see how
    they work and what they do. But that’s a lot like work, and most sysadmins have
    more interesting work to do. The service(8) command provides a friendly frontend
    to the *rc.d* scripts. You can use service(8) to see which scripts run automatically;
    to stop, start, and restart services; to check the status of a service; and more.
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing and Identifying Enabled Services**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use the `-e` flag to service(8) to see the full path of all scripts that’ll
    be run at system boot, in the order they’ll be run.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This tiny host runs 23 scripts at boot.
  prefs: []
  type: TYPE_NORMAL
- en: One important detail here is the script name. You’ll use the script name in
    other commands, like starting, stopping, and restarting services.
  prefs: []
  type: TYPE_NORMAL
- en: '**Managing Services**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: While it’s entirely possible to restart, say, sshd(8) at the command line, a
    production host needs everything to run consistently. Best practice calls for
    using service(8) to manage processes. You’ll need the script name as shown earlier,
    but without the directory path.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: For example, suppose I want to restart the sshd(8) service. According to the
    `service -e` output shown earlier, there’s a script */etc/rc.d/sshd*. I strongly
    suspect this script manages sshd(8), but I want to be certain I don’t accidentally
    restart the Stupidly Similarly named Harassment Daemon. This is where the `describe`
    command comes in. Let’s ask service(8) to describe the *sshd* script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: It’s the right daemon. Let’s restart it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Restarting a service is a combination of “stop the service” and “start the service.”
    This particular service does more than that, though. It starts by verifying the
    configuration file ➊ and then stopping the daemon ➋. It then reverifies the configuration
    ➌ and starts the daemon ➍. Why?
  prefs: []
  type: TYPE_NORMAL
- en: SSH handles remote access to this host. If the SSH service breaks, nobody can
    log into the host to fix the SSH service. Yes, you could use a remote KVM or IPMI
    or drive to the colocation facility, but any of these prolongs the outage. It’s
    much better to verify that sshd(8) can *be* restarted before shutting it down.
    Many service scripts include this kind of safety check. If a service complains
    that it can’t stop, read the output carefully to find out why.
  prefs: []
  type: TYPE_NORMAL
- en: The commands each service supports vary. The easiest way to get the full list
    of commands a particular service supports is to give the service a bogus argument.
    Something like “bert” is pretty bogus.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: You get a full list of commands this service supports, in two groups.
  prefs: []
  type: TYPE_NORMAL
- en: The first group, in square brackets, contains options for the commands. Here
    are the standard options. Use them as prefixes for the commands in the second
    group.
  prefs: []
  type: TYPE_NORMAL
- en: fast Do no checking (used during startup).
  prefs: []
  type: TYPE_NORMAL
- en: force Try harder.
  prefs: []
  type: TYPE_NORMAL
- en: one Start this service despite not being enabled in *rc.conf*.
  prefs: []
  type: TYPE_NORMAL
- en: quiet Only print service name (used during startup).
  prefs: []
  type: TYPE_NORMAL
- en: 'The second group, in parentheses, contains the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: start Start the service.
  prefs: []
  type: TYPE_NORMAL
- en: stop Stop the service.
  prefs: []
  type: TYPE_NORMAL
- en: restart Stop and restart the service.
  prefs: []
  type: TYPE_NORMAL
- en: rcvar Print the *rc.conf* variables for this service.
  prefs: []
  type: TYPE_NORMAL
- en: enabled Return true in shell if enabled (for script use).
  prefs: []
  type: TYPE_NORMAL
- en: describe Print service description.
  prefs: []
  type: TYPE_NORMAL
- en: extracommands Show service-specific commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `extracommands` command is very specific to the service and lists only
    the additional commands this service accepts. By default, the extra commands appear
    after the default commands. Here are some common extra commands:'
  prefs: []
  type: TYPE_NORMAL
- en: configtest Parse the service’s configuration file and stop if there’s an error.
  prefs: []
  type: TYPE_NORMAL
- en: reload Perform a soft reload (usually via SIGHUP) rather than a restart.
  prefs: []
  type: TYPE_NORMAL
- en: status Determine whether service is running.
  prefs: []
  type: TYPE_NORMAL
- en: To determine exactly what a service’s extra commands do, you need to read the
    service script.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at *rc.d* in more detail in [Chapter 17](ch17.xhtml#ch17), when we
    discuss customizing and writing your own *rc.d* scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '***System Shutdown***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: FreeBSD makes the *rc.d* startup system do double duty; not only must it handle
    system startup, it must also shut all those programs down when it’s time to power
    down. Something has to unmount all those hard drives, shut down the daemons, and
    clean up after doing all the work. Some programs don’t care whether they’re unceremoniously
    killed when the system closes up for the night—after all, after the system goes
    down, any clients connected over SSH will be knocked off and any half-delivered
    web pages remain incomplete. Database software, however, cares very much about
    how it’s turned off, and unceremoniously killing the process will damage your
    data. Many other programs that manage actual data are just as particular, and
    if you don’t let them clean up after themselves, you’ll regret it.
  prefs: []
  type: TYPE_NORMAL
- en: When you shut down FreeBSD with the shutdown(8), halt(8), or reboot(8) commands,
    the system calls the shell script */etc/rc.shutdown*. This script calls each *rc.d*
    script in turn with the `stop` option, reversing the order they were called during
    startup, thereby allowing server programs to terminate gracefully and disks to
    tidy themselves up before the power dies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Serial Consoles**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All this console stuff is nice, but when your FreeBSD system is in a colocation
    facility on the other side of the country or on another continent, you can’t just
    walk up to the keyboard and start typing. Many data centers won’t have room for
    a keyboard or monitor. And how do you reset the machine remotely when it won’t
    respond to the network? Using a serial console to redirect the computer’s keyboard
    and video to the serial port instead of the keyboard and monitor helps with all
    of these problems.
  prefs: []
  type: TYPE_NORMAL
- en: Serial consoles can be physical, such as a serial port on the back of a computer.
    By hooking up a standard null modem cable to the serial port and attaching the
    other end to another computer’s serial port, you can access the first system’s
    boot messages from the second computer.
  prefs: []
  type: TYPE_NORMAL
- en: They might also be virtual, as provided by IPMI’s *Serial-over-LAN (SOL)* protocol.
    Rather than a null modem cable, you’ll need to set up the IPMI interface and use
    special software to configure and access the virtual serial port.
  prefs: []
  type: TYPE_NORMAL
- en: Before we set up a port, though, let’s talk about serial port protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '***Serial Protocol***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some of the first computer consoles were serial ports connected to teletypes.
    Serial has been around a long time and has evolved over the decades. Unlike modern
    protocols, serial lines do not autonegotiate. You must configure both sides of
    a serial link to the exact same settings. A configuration mismatch will cause
    either a blank screen or gibberish.
  prefs: []
  type: TYPE_NORMAL
- en: Original serial lines worked at low speeds. Many of the serial cables remain
    basically the same, but we’ve developed better software and hardware to stick
    at each end that allows us to transmit data much faster. Where old serial connections
    ran at 300 bits per second (baud), a whole bunch of modern hardware can run at
    115,200 baud. Across hardware platforms, though, the common standard is 9600 baud,
    which is FreeBSD’s default console speed. A baud rate of 9600 is enough to carry
    whole screens of text at a comfortable speed.
  prefs: []
  type: TYPE_NORMAL
- en: Stick with 9600 baud for physical connections, unless you can’t. Some modern
    hardware doesn’t support 9600 baud. Some claim to support 9600 baud, but don’t.
    I’ve worked with devices hardcoded to 115,200 baud. Anything that fails or flat-out
    refuses to do 9600 baud is busted by design, but we often don’t control the choice
    of hardware. Changing the serial console speed for reasons other than hardware
    limitations makes your connection more fragile, and if you’re using the console,
    you’re in no mood for fragility. When I mention changing the port speed, that’s
    for use only when you have to.
  prefs: []
  type: TYPE_NORMAL
- en: SOL connections aren’t physical wires, so you don’t have to worry about line
    noise. You can safely run them at higher speeds.
  prefs: []
  type: TYPE_NORMAL
- en: Serial protocols also include a whole bunch of settings beyond their speed.
    It’s possible to muck with them, but the standard settings of 8 data bits, no
    parity, and 1 stop bit are the most widely used. You can’t change these in FreeBSD
    without recompiling the kernel, so don’t muck with them.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let’s set up a console.
  prefs: []
  type: TYPE_NORMAL
- en: '***Physical Serial Console Setup***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: No matter what sort of serial console you have, you’ll need to plug into it
    correctly to make it work. You’ll need a null modem cable, available at any computer
    store or from online vendors. While the gold-plated serial cables are not worth
    the money, don’t buy the cheapest cable you can find either; if you have an emergency
    and need the serial console, you’re probably not in the mood to endure line noise!^([4](footnote.xhtml#ch04fn4))
  prefs: []
  type: TYPE_NORMAL
- en: Plug one end of the null modem cable into the serial console port on your FreeBSD
    server—by default the first serial port (COM1 or uart0, depending on what operating
    system you’re used to). You can change this with a server.
  prefs: []
  type: TYPE_NORMAL
- en: Plug the other end of your null modem cable into an open serial port on another
    system. I recommend either another FreeBSD (or other Unix) system or a terminal
    server, but you can use a Windows box if that’s all you have.
  prefs: []
  type: TYPE_NORMAL
- en: If you have two FreeBSD machines at a remote location, make sure that they each
    have two serial ports. Get two null modem cables and plug the first serial port
    on each box into the second serial port of the other machine. That way, you can
    use each machine as the console client for the other. If you have three machines,
    daisy-chain them into a loop. By combining twos and threes, you can get serial
    consoles on any number of systems. I’ve worked data centers with 30 or 40 FreeBSD
    machines, where installing monitors was simply not practical, and we used serial
    consoles to great effect. Once you have a rack or two of servers, however, investing
    in a terminal server is a really good idea. You can find them cheaply on eBay.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to use two DB9-to-RJ45 converters, one standard and one crossover.
    These allow you to run your console connections over a standard CAT5 cable. If
    you have a lights-out data center where human beings are not allowed, you can
    have your serial consoles come out near your desk, in your warm room, or anywhere
    else your standard Ethernet-style patch panels reach. Most modern data facilities
    are better equipped to handle Ethernet than serial cables.
  prefs: []
  type: TYPE_NORMAL
- en: '***IPMI Serial Console Setup***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *Intelligent Platform Management Interface (IPMI)* is a standard for managing
    computer systems at a hardware level. IPMI runs separately from the operating
    system, using a small device called a *baseboard management controller (BMC)*.
    Essentially, the BMC acts as your remote hands and eyes to control the server.
    To use an IPMI console, you’ll need to configure both the BMC and the host’s BIOS
    or UEFI.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll try to orient you here, but the best resource for configuring BMC or UEFI
    is your hardware manual.^([5](footnote.xhtml#ch04fn5))
  prefs: []
  type: TYPE_NORMAL
- en: '**BMC Setup**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A server’s BMC has its own IP address and normally gets a dedicated Ethernet
    port on the mainboard. Each vendor gets to design its own BMC in a way that conforms
    to its own biases. This means that configuring the BMC is way, way beyond the
    scope of this book, but here are a few hints.
  prefs: []
  type: TYPE_NORMAL
- en: You configure most BMCs through a web interface. Before you can access the web
    interface, though, the BMC needs an IP address. Set most BMC IP information in
    the BIOS or UEFI firmware’s setup menu. Once you get in the management interface,
    configure a username and password. Remember them.
  prefs: []
  type: TYPE_NORMAL
- en: A usual BMC also includes functions such as power cycling the main system, remote
    console access via some sort of downloaded application (often Java), virtual media,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: Never forget that the BMC is a small embedded computer running a web server
    and that it was written by some overworked corporate employee charged with building
    the minimum viable product. The BMC wasn’t tested for how it performed after several
    months of uptime. If it gives you even a sneeze of trouble, reboot it. No, you
    don’t have to power cycle the whole computer; there’s usually a “BMC Reset” or
    “Unit Reboot” menu option somewhere in the web interface.
  prefs: []
  type: TYPE_NORMAL
- en: If the BMC supports an applet-based console, why use a serial console? Because
    the BMC console is applet-based and BMC firmwares are rarely updated. I have quite
    a few BMC consoles that work only with obsolete, insecure^([6](footnote.xhtml#ch04fn6))
    versions of Java. Using them requires overriding security warnings and repeatedly
    clicking the “Yes, I know I’m an idiot, do it anyway” box. I have to keep a virtual
    machine with this insecure Java version specifically to access those consoles.
    The applet-based console doesn’t support copy and paste, and is often very laggy.
  prefs: []
  type: TYPE_NORMAL
- en: IPMI works better than the Java console applet over slower connections. I can
    copy and paste. Also, I can use the IPMI console from the command line, from any
    modern operating system.
  prefs: []
  type: TYPE_NORMAL
- en: While you’re in the BMC setup, locate the option to launch SOL. That brings
    up an applet to connect to the host’s SOL interface, which will help you test
    your serial console configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '**UEFI/BIOS Serial Console Configuration**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once your BMC is ready, you must configure the server hardware to direct a serial
    port to the BMC. Go to the hardware’s Setup menu, where you configure your UEFI
    or BIOS. Somewhere in that maze of twisty little options, you’ll find something
    like “Serial Port Console Redirection.”
  prefs: []
  type: TYPE_NORMAL
- en: A vital question here is, how many serial ports does your host have? Maybe it
    has none. Maybe it has several. You can choose to redirect one of those ports
    or add an additional, virtual port. I encourage you to leave your existing serial
    ports alone and add a virtual port dedicated to SOL. It’s probably called something
    like “SOL Console Redirection.” Enable it, and go into the settings for that port.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some settings I find helpful for FreeBSD and SOL:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Terminal type** vt100'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data bits** 8'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parity** none'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stop bits** 1'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flow control** none'
  prefs: []
  type: TYPE_NORMAL
- en: The tricky part is the baud, speed, or bits-per-second setting. Stick with the
    default speed, but make a note of it. You’ll need the speed to connect.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a serial console, set up FreeBSD.
  prefs: []
  type: TYPE_NORMAL
- en: '***Configuring FreeBSD’s Serial Console***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As FreeBSD boots, the loader decides where to print console messages and where
    to accept input from. While this defaults to the monitor and keyboard, with a
    few tweaks, you can redirect the console to a serial port. The serial console
    won’t grant BIOS access, but you can tweak the FreeBSD boot itself in almost any
    way. You can configure a serial console in either the first- or second-stage boot
    loader.
  prefs: []
  type: TYPE_NORMAL
- en: A first-stage boot loader gets you console access at the earliest possible moment
    but requires you use the first serial port as a console. Changing the port requires
    recompiling the kernel. The first-stage boot loader allows you to perform tasks
    like choose which disk you’re going to load the second-stage loader from—essentially,
    to boot from a disk other than the disk the BIOS or UEFI selected. This is undeniably
    useful, but very few users need this.
  prefs: []
  type: TYPE_NORMAL
- en: The second-stage boot loader can use any serial port as a console, but the first
    bit of output you’ll get is the boot menu discussed in “[The Loader Prompt](ch04.xhtml#lev106)”
    on [page 55](ch04.xhtml#page_55). For most of us, that’s perfectly acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Console Options**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: FreeBSD’s default configuration uses the monitor and keyboard as the console.
    You can choose to switch to only the serial console or to use a dual console.
    Choose which with the */boot/loader.conf* option `console`.
  prefs: []
  type: TYPE_NORMAL
- en: A serial-only console prevents some random colocation employee from power cycling
    your box, plugging in a monitor, and dinking with the menu. Yes, they could still
    work mayhem from the first-stage loader or boot off of USB, but that requires
    greater skill. Set the *console* variable to `comconsole` to use only the serial
    port as a console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: For most deployments, I recommend a dual console. Dual consoles show console
    activity on both the serial port and the monitor. You can use either the standard
    or the serial console as needed. Specify a dual-console configuration by listing
    both `comconsole` and `vidconsole`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: If you’re in a server-room situation, you might want to switch back and forth
    between a standard console and a serial console. I generally manage large arrays
    of FreeBSD systems via the serial console but leave the video console in place
    in case of trouble.
  prefs: []
  type: TYPE_NORMAL
- en: The console won’t be effective until after a reboot. You can see whether FreeBSD
    put its console on a serial port by checking the boot messages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The second line shows that the serial port uart0 is configured as a console,
    using the default settings. We’ll look at those settings in “[Using Serial Consoles](ch04.xhtml#lev139)”
    on [page 79](ch04.xhtml#page_79).
  prefs: []
  type: TYPE_NORMAL
- en: '**Advanced Console Options**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In addition to enabling the console, you can adjust the console’s port and the
    speed.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe I need to use the second serial port for the console. Perhaps the first
    serial port has something plugged into it, or maybe the second port is the virtual
    SOL port. Serial ports use the uart(4) device driver. Remember that FreeBSD devices
    start numbering at zero, while COM ports start numbering at 1\. COM1 is uart0,
    COM2 is uart1, and so on. You’ll need the port’s base I/O port, which you can
    get from the system bootup messages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The first number after the word port is the base I/O port ➊. The base address
    of COM2, or uart1, is 0x2f8\. Set `comconsole_port` to this value ➋.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Your console is now on serial port COM2.
  prefs: []
  type: TYPE_NORMAL
- en: If my serial connection won’t do 9600 baud, I can change the port speed with
    the `comconsole_speed` option.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: On a physical port, don’t increase the port speed just because you can.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Serial Consoles***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that you have both physical and software set up, configure your client
    to access the serial console. The key to using a serial console is to remember
    the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: Speed (9600 baud, or whatever your hardware is set to)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8 bits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No parity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 stop bit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The way you access a serial line depends on whether it’s a physical line or
    an IPMI SOL connection.
  prefs: []
  type: TYPE_NORMAL
- en: '**Physical Serial Lines**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Connect your client to the other end of the serial line. You can find terminal
    emulators for Microsoft platforms (PuTTY being the most famous), macOS, and almost
    any other operating system. Once upon a time, I used a Palm handheld with a serial
    cable to access serial consoles. Enter the correct value settings into the terminal
    emulator, and the serial console will “just work.”
  prefs: []
  type: TYPE_NORMAL
- en: 'FreeBSD accesses serial lines with tip(1), a program that allows you to connect
    to remote systems in a manner similar to telnet. To run tip, do this as root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'A port name is shorthand for specifying the serial port number and speed to
    be used on a serial port. The file */etc/remote* contains a list of port names.
    Most of the entries in this file are relics of the eon when UUCP was the major
    data transfer protocol and serial lines were the norm instead of the exception.^([7](footnote.xhtml#ch04fn7))
    At the end of this file, you’ll see a few entries like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The `uart` entries are the standard Unix-type device names, while the `com`
    names were added for the convenience of people who grew up on x86 hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that you have two FreeBSD boxes wired back-to-back, with each one’s
    serial port 1 null-modemed into serial port 2\. Both machines are configured to
    use a serial console. You’ll want to connect to your local serial port 2 to talk
    to the other system’s serial console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: You’re in!
  prefs: []
  type: TYPE_NORMAL
- en: To disconnect the serial console, press ENTER and then type the disconnect sequence
    “tilde-dot” at any time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: You’ll be gracefully disconnected. (This also works in the OpenSSH client.)
  prefs: []
  type: TYPE_NORMAL
- en: The tip(1) program uses the tilde (`~`) as a control character. Read the man
    page for a full list of things you can do with it.
  prefs: []
  type: TYPE_NORMAL
- en: '**IPMI SOL Connections**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You’ll need a SOL client to connect to your IPMI serial port. The quickest way
    to test your configuration is probably with the SOL client applet included in
    your BMC. While that client has most of the disadvantages of the console applet,
    it’s a good place to test. If the BMC SOL client doesn’t work, check your SOL
    settings and FreeBSD configuration. Verify that the SOL client is set to use the
    same speed you set in the hardware and in FreeBSD. If it doesn’t work but all
    your settings appear to match, reboot the BMC. Once it works, you can use SOL
    from another host.
  prefs: []
  type: TYPE_NORMAL
- en: The standard IPMI SOL client is IPMItool (*[https://sourceforge.net/projects/ipmitool/](https://sourceforge.net/projects/ipmitool/)*),
    available as the ipmitool package. ([Chapter 15](ch15.xhtml#ch15) discusses packages.)
    IPMItool can interact with your BMC over the network, granting you all of the
    BMC functions without logging into a clunky web interface. You can reboot the
    host, check hardware alarms and sensors, and more, all from the command line.
    But for the moment, we’ll stick with the SOL console. Use the BMC’s hostname or
    IP, the username, and the password to log into SOL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Here, I log into my web server’s BMC, with the hostname www-bmc, using the username
    “bert.”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Enter the password at the prompt, and the SOL will acknowledge your login.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: We have a console. Probably. Let’s do the final test.
  prefs: []
  type: TYPE_NORMAL
- en: '***Working at the Console***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The real test of a serial console is whether or not you can get data across
    it. Once you have your console connected, hit ENTER.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: FreeBSD permits logins on serial consoles by default. Log in to the host and
    reboot it, and you’ll get the usual console messages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: There will be a long pause while the system runs its BIOS routines and hands
    control over to the serial console. Just about the time you decide that the machine
    is never coming back up, you’ll get the loader menu. Congratulations! You’re using
    a serial console. Press the spacebar to interrupt the boot just as if you were
    at the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t matter how far away the system is; you can change your booting kernel,
    get a verbose boot, bring it up in single-user mode, or manually fsck the hard
    drive—whatever. A software serial console might not show you the BIOS, but chances
    are that’s set up correctly already. Once you’ve used a serial console for a while,
    it won’t matter whether the machine is on the other side of the world or the other
    side of the room; getting out of your chair merely to access the console will
    feel like too much work.
  prefs: []
  type: TYPE_NORMAL
- en: If a system in a remote location entirely locks up, you can connect to your
    serial console and have the “remote hands” at the colocation facility power-cycle
    the system. It might not be good for your computer, but it’s also not good for
    it to be locked up. With the serial console, you can boot into single-user mode
    and fix the problem by digging through the logs and whatever other troubleshooting
    you feel capable of. We’ll discuss troubleshooting this sort of problem in [Chapter
    24](ch24.xhtml#ch24).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how FreeBSD starts up and shuts down, let’s look at
    some basic tools you can use to ensure that your system will continue to run even
    after you’ve been experimenting with it.
  prefs: []
  type: TYPE_NORMAL
