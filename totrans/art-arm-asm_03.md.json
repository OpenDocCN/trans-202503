["```\n// Listing2-1.S\n//\n// Displays some numeric values on the console\n#include \"aoaa.inc\"\n\n            .data\n// Program title, required by C++ code:\n\ntitleStr:   .asciz      \"Listing 2-1\"\n\n// Format strings for three calls to printf():\n\nfmtStrI:    .asciz      \"i=%d, converted to hex=%x\\n\"\nfmtStrJ:    .asciz      \"j=%d, converted to hex=%x\\n\"\nfmtStrK:    .asciz      \"k=%d, converted to hex=%x\\n\"\n\n// Some values to print in decimal and hexadecimal form:\n\n            .align      2  // Be nice and word-align.\ni:          .dword      1\nj:          .dword      123\nk:          .dword      456789\nsaveLR:     .dword      0\n\n            .text\n            .align      2      // Code must be word-aligned.\n            .extern     printf // printf is outside this code.\n\n// Return program title to C++ program:\n\ngetTitle:\n\n// Load address of \"titleStr\" into the X0 register (X0 holds\n// the function return result) and return back to the caller:\n\n            lea x0, titleStr\n            ret\n\n// Here is the asmMain function:\n\n            .global     asmMain\nasmMain:\n            sub         sp, sp, #64 // Magic instruction\n\n// Save LR so we can return to C++ program:\n\n            lea         x0, saveLR\n            str         lr, [x0]\n\n// Call printf three times to print the three values\n// i, j, and k:\n//\n// printf(\"i=%d, converted to hex=%x\\n\", i, i);\n\n          ❶ lea         x0, fmtStrI\n            vparm2      i           // Get parameter 2\n            vparm3      i           // Get parameter 3\n            bl          printf\n\n// printf(\"j=%d, converted to hex=%x\\n\", j, j);\n\n          ❷ lea         x0, fmtStrJ\n            vparm2      j\n            vparm3      j\n            bl          printf\n\n// printf(\"k=%d, converted to hex=%x\\n\", k, k);\n\n          ❸ lea         x0, fmtStrK\n            vparm2      k\n            vparm3      k\n            bl          printf\n\n// Restore LR so we can return to C++ program:\n\n            lea         x0, saveLR\n            ldr         lr, [x0]\n\n            add         sp, sp, #64  // Magic instruction\n            ret                      // Returns to caller\n```", "```\nprintf(\"i=%d, converted to hex=%x\\n\", i, i);\n```", "```\n$ ./build Listing2-1\n$ ./Listing2-1\nCalling Listing2-1:\ni=1, converted to hex=1\nj=123, converted to hex=7b\nk=456789, converted to hex=6f855\nListing2-1 terminated\n```", "```\n0000\n0001\n0010\n0011\n0100\n0101\n0110\n0111\n1000\n1001\n1010\n1011\n1100\n1101\n1110\n1111\n```", "```\n .data\nbyteVar:  .byte   0\n```", "```\n .data\nhw:      .hword  0\n```", "```\n .data\nw:    .word   0\n```", "```\n .data\ndw:   .dword 0\nqw:   .qword 0\n```", "```\n0 and 0 = 0\n0 and 1 = 0\n1 and 0 = 0\n1 and 1 = 1\n```", "```\n0 or 0 = 0\n0 or 1 = 1\n1 or 0 = 1\n1 or 1 = 1\n```", "```\n0 xor 0 = 0\n0 xor 1 = 1\n1 xor 0 = 1\n1 xor 1 = 0\n```", "```\nnot 0 = 1\nnot 1 = 0\n```", "```\n0b1011_0101\n0b1110_1110\n-----------\n0b1010_0100\n```", "```\nand   `dest`, `source`left, `source`right\nands  `dest`, `source`left, `source`right  // Affects the flags\norr   `dest`, `source`left, `source`right\neor   `dest`, `source`left, `source`right  // XOR operation\n```", "```\n`dest` = `source`left `operator` `source`right\n```", "```\nmvn  `dest`, `source`\n```", "```\n`dest` = not(`source`)\n```", "```\n// Listing2-2.S\n//\n// Demonstrate AND, OR, XOR, and NOT operations.\n\n#include \"aoaa.inc\"\n\n             .data\nleftOp:      .dword     0xf0f0f0f\nrightOp1:    .dword     0xf0f0f0f0\nrightOp2:    .dword     0x12345678\nresult:      .dword     0\nsaveLR:      .dword     0\n\ntitleStr:    .asciz   \"Listing 2-2\"\n\nfmtStr1:     .asciz   \"%lx AND %lx = %lx\\n\"\nfmtStr2:     .asciz   \"%lx OR  %lx = %lx\\n\"\nfmtStr3:     .asciz   \"%lx XOR %lx = %lx\\n\"\nfmtStr4:     .asciz   \"NOT %lx = %lx\\n\"\n\n             .text\n             .align     2   // Make code word-aligned.\n\n             .extern    printf\n\n// Return program title to C++ program:\n\n .global     getTitle\ngetTitle:\n\n// Load address of \"titleStr\" into the X0 register (X0 holds the\n// function return result) and return back to the caller:\n\n            lea     x0, titleStr\n            ret\n\n// Here is the \"asmMain\" function.\n\n            .global asmMain\nasmMain:\n\n// \"Magic\" instruction offered without explanation at this point:\n\n            sub     sp, sp, 64\n\n// Save LR so we can return to C++ code:\n\n            lea     x0, saveLR\n            str     lr, [x0]\n\n// Demonstrate the AND operation:\n\n          ❶ lea     x0, leftOp\n            ldr     x1, [x0]\n            lea     x0, rightOp1\n            ldr     x2, [x0]\n            and     x3, x1, x2  // Compute left AND right.\n            lea     x0, result\n            str     x3, [x0]\n\n            lea     x0, fmtStr1 // Print result.\n            vparm2  leftOp\n            vparm3  rightOp1\n            vparm4  result\n            bl      printf\n\n// Demonstrate the OR operation:\n\n          ❷ lea     x0, leftOp\n            ldr     x1, [x0]\n            lea     x0, rightOp1\n            ldr     x2, [x0]\n            orr     x3, x1, x2  // Compute left OR right.\n            lea     x0, result\n            str     x3, [x0]\n\n            lea     x0, fmtStr2 // Print result.\n            vparm2  leftOp\n            vparm3  rightOp1\n            vparm4  result\n            bl      printf\n\n// Demonstrate the XOR operation:\n\n          ❸ lea     x0, leftOp\n            ldr     x1, [x0]\n            lea     x0, rightOp1\n            ldr     x2, [x0]\n            eor     x3, x1, x2  // Compute left XOR right.\n            lea     x0, result\n            str     x3, [x0]\n\n            lea     x0, fmtStr3 // Print result.\n            vparm2  leftOp\n            vparm3  rightOp1\n            vparm4  result\n            bl      printf\n\n// Demonstrate the NOT instruction:\n\n          ❹ lea     x0, leftOp\n            ldr     x1, [x0]\n            mvn     w1, w1      // W1 = not W1 (32 bits)\n            lea     x0, result\n            str     x1, [x0]\n\n            lea     x0, fmtStr4 // Print result.\n            vparm2  leftOp\n            vparm3  result\n            bl      printf\n\n          ❺ lea     x0, rightOp1\n            ldr     x1, [x0]\n            mvn     w1, w1      // W1 = not W1 (32 bits)\n            lea     x0, result\n            str     x1, [x0]\n\n            lea     x0, fmtStr4 // Print result.\n            vparm2  rightOp1\n            vparm3  result\n            bl      printf\n\n          ❻ lea     x0, rightOp2\n            ldr     x1, [x0]\n            mvn     w1, w1      // W1 = not W1\n            lea     x0, result\n            str     x1, [x0]\n\n            lea     x0, fmtStr4 // Print result.\n            vparm2  rightOp2\n            vparm3  result\n            bl      printf\n\n// Another \"magic\" instruction that undoes the effect of\n// the previous one before this procedure returns to its\n// caller:\n\n add     sp, sp, #64\n\n// Restore LR so we can return to C++ code:\n\n            lea     x0, saveLR\n            ldr     lr, [x0]\n            ret     // Returns to caller\n```", "```\n$ ./build Listing2-2\n$ ./Listing2-2\nCalling Listing2-2:\nf0f0f0f AND f0f0f0f0 = 0\nf0f0f0f OR  f0f0f0f0 = ffffffff\nf0f0f0f XOR f0f0f0f0 = ffffffff\nNOT f0f0f0f = f0f0f0f0\nNOT f0f0f0f0 = f0f0f0f\nNOT 12345678 = edcba987\nListing2-2 terminated\n```", "```\n 0b1111_1011     Take the two's complement for -5.\n   + 0b0000_0101     Invert all the bits and add 1.\n     -----------\n(1)  0b0000_0000     Sum is zero, if you ignore carry.\n```", "```\n0x7FFF: 0b0111_1111_1111_1111   +32,767\n        0b1000_0000_0000_0000   Invert all the bits (8000h).\n        0b1000_0000_0000_0001   Add 1 (8001h or -32,767).\nx04000: 0b0100_0000_0000_0000   16,384\n        0b1011_1111_1111_1111   Invert all the bits (0BFFFh).\n        0b1100_0000_0000_0000   Add 1 (0C000h or -16,384).\n0x8000: 0b1000_0000_0000_0000   -32,768\n        0b0111_1111_1111_1111   Invert all the bits (7FFFh).\n        0b1000_0000_0000_0000   Add 1 (8000h or -32,768).\n```", "```\nneg  `dest`, `source`\nnegs `dest`, `source`  // Sets condition code flags\n```", "```\n// Listing2-3.S\n//\n// Demonstrates two's complement operation and input of\n// numeric values\n\n#include \"aoaa.inc\"\n\n            .equ        maxLen, 256\n\n            .data\ntitleStr:   .asciz      \"Listing 2-3\"\n\nprompt1:    .asciz      \"Enter an integer between 0 and 127:\"\nfmtStr1:    .asciz      \"Value in hexadecimal: %x\\n\"\nfmtStr2:    .asciz      \"Invert all the bits (hexadecimal): %x\\n\"\nfmtStr3:    .asciz      \"Add 1 (hexadecimal): %x\\n\"\nfmtStr4:    .asciz      \"Output as signed integer: %d\\n\"\nfmtStr5:    .ascii      \"Negate again and output as signed integer:\"\n            .asciz      \" %d\\n\"\n\nfmtStr6:    .asciz      \"Using neg instruction: %d\\n\"\n\nintValue:   .dword      0\nsaveLR:     .dword      0\n\n// The following reserves 256 bytes of storage to hold a string\n// read from the user.\n\n❶ input:      .space      maxLen, 0\n\n            .text\n            .align      2\n            .extern     printf\n            .extern     atoi\n          ❷ .extern     readLine\n\n// Return program title to C++ program:\n\n            .global     getTitle\ngetTitle:\n            lea         x0, titleStr\n            ret\n\n// Here is the asmMain function:\n\n            .global     asmMain\nasmMain:\n\n// \"Magic\" instruction offered without explanation at this point:\n\n            sub     sp, sp, #128\n\n// Save LR so we can return to C++ program:\n\n            lea     x0, saveLR\n            str     lr, [x0]\n\n// Read an unsigned integer from the user: this code will blindly\n// assume that the user's input was correct. The atoi function\n// returns zero if there was some sort of error on the user\n// input. Later chapters in AoAA will describe how to check for\n// errors from the user.\n\n            lea     x0, prompt1\n            bl      printf\n\n            lea     x0, input\n            mov     x1, #maxLen\n            bl      readLine\n\n// Call C stdlib strtol function:\n//\n// i = strtol(str, NULL, 10)\n\n ❸ lea     x0, input\n            mov     x1, xzr\n            mov     x2, #10\n            bl      strtol\n            lea     x1, intValue\n            str     x0, [x1]\n\n// Print the input value (in decimal) as a hexadecimal number:\n\n            lea     x0, fmtStr1\n            vparm2  intValue\n            bl      printf\n\n// Perform the two's complement operation on the input number.\n// Begin by inverting all the bits:\n\n            lea     x1, intValue\n            ldr     x0, [x1]\n            mvn     x0, x0      // Not X0\n            str     x0, [x1]    // Store back into intValue.\n            lea     x0, fmtStr2\n            vparm2  intValue\n            bl      printf\n\n// Invert all the bits and add 1 (inverted value is in intValue):\n\n            lea     x0, intValue\n            ldr     x1, [x0]\n            add     x1, x1, #1\n            str     x1, [x0]    // Store back into intValue.\n            lea     x0, fmtStr3\n            vparm2  intValue\n            bl      printf\n\n            lea     x0, fmtStr4 // Output as integer rather\n            vparm2  intValue    // than hexadecimal.\n            bl      printf\n\n// Negate the value and print as a signed integer. Note that\n// intValue already contains the negated value, so this code\n// will print the original value:\n\n            lea     x0, intValue\n            ldr     x1, [x0]\n            mvn     x1, x1\n            add     x1, x1, #1\n            str     x1, [x0]\n            lea     x0, fmtStr5\n            vparm2  intValue\n            bl      printf\n\n// Negate the value using the neg instruction:\n\n            lea     x0, intValue\n            ldr     x1, [x0]\n neg     x1, x1\n            str     x1, [x0]\n            lea     x0, fmtStr6\n            vparm2  intValue\n            bl      printf\n\n// Another \"magic\" instruction that undoes the effect of the\n// previous one before this procedure returns to its caller:\n\n            lea     x0, saveLR\n            ldr     lr, [x0]\n            add     sp, sp, #128\n            ret     // Returns to caller\n```", "```\n$ ./build Listing2-3\n$ ./Listing2-3\nCalling Listing2-3:\nEnter an integer between 0 and 127:123\nValue in hexadecimal: 7b\nInvert all the bits (hexadecimal): ffffff84\nAdd 1 (hexadecimal): ffffff85\nOutput as signed integer: -123\nNegate again and output as signed integer: 123\nUsing neg instruction: -123\nListing2-3 terminated\n```", "```\nldr    `reg`, `mem`\nldrb   `reg`32, `mem`\nldrsb  `reg`, `mem`\nldrh   `reg`32, `mem`\nldrsh  `reg`, `mem`\nldrsw  `reg`64, `mem`\n```", "```\nsxtb `reg`dest, `reg`src  // Sign-extends LO byte of `reg`src\nsxth `reg`dest, `reg`src  // Sign-extends LO half word of `reg`src\nsxtw `reg`dest, `reg`src  // Sign-extends LO word of `reg`src\n```", "```\nmov  w`n`, w`m`  // Zero-extends 32-bit W`m` into X`n`\n```", "```\nand  w`n`, w`m`, #0xFFFF  // Zero-extends 16 bits to 64\n```", "```\nand  w`n`, w`m`, #0xFF  // Zero-extends 8 bits to 64\n```", "```\nstrb `reg`32, `mem`\nstrh `reg`32, `mem`\n```", "```\nb `statementLabel`\n```", "```\nstmtLbl: mov x0, #55\n```", "```\nanotherLabel:\n   mov x0, #55\n```", "```\n`instr`   `operands`\n`instrs`  `operands`  // Only adds, subs, ands, and negs\n```", "```\n lea  x0, int32Var\n    ldr  w0, [x0]\n    lea  x1, anotherVar\n    ldr  w1, [x1]\n    adds w0, w0, w1\n    bcs  overflowOccured\n\n// Continue down here if the addition did not\n// produce an overflow.\n\n    .\n    .\n    .\n\noverflowOccured:\n\n// Execute this code if the sum of int32Var and anotherVar\n// does not fit into 32 bits.\n```", "```\ncmp `left`, `right`\n```", "```\n cmp x0, x1\n    // Branch to geLbl if X0 is not less than X1.\n\n    // Fall through to this code if X0 < X1.\n     .\n     .\n     .\n// Branch here if NOT(X0 < X1) (that is, X0 >= X1).\ngeLbl:\n```", "```\n cmp x0, x1\n    bge geLbl\n\n    // Fall through to this code if X0 < X1.\n     .\n     .\n     .\n// Branch here if NOT(X0 < X1) (that is, X0 >= X1).\ngeLbl:\n```", "```\nlsl  `dest`, `source`, `count` // Does not affect any flags\n```", "```\n1234 shl 1 = 12340\n// (shl 1 means shift one digit position to the left.)\n```", "```\nlsr  `dest`, `source`, `count` // Does not affect any flags\n```", "```\nasr  `dest`, `source`, `count` // Does not affect any flags\n```", "```\nror  `dest`, `source`, `count` // Does not affect any flags\n```", "```\n0100      00010   0000001  = 0100_0001_0000_0001b or 0x4101\n4         2       01\n```", "```\n// Listing2-4.S\n//\n// Demonstrate packed data types.\n\n#include \"aoaa.inc\"\n\n             .equ    NULL, 0         // Error code\n             .equ    maxLen, 256     // Max input line size\n\n .data\n\nsaveLRMain:  .dword  0\nsaveLRRN:    .dword  0\n\nttlStr:      .asciz  \"Listing 2-4\"\nmoPrompt:    .asciz  \"Enter current month: \"\ndayPrompt:   .asciz  \"Enter current day: \"\n\nyearPrompt:  .ascii  \"Enter current year \"\n             .asciz  \"(last 2 digits only): \"\n\npacked:      .ascii  \"Packed date is %04x = \"\n             .asciz  \"%02d/%02d/%02d\\n\"\n\ntheDate:     .asciz  \"The date is %02d/%02d/%02d\\n\"\n\nbadDayStr:   .ascii  \"Bad day value was entered \"\n             .asciz  \"(expected 1-31)\\n\"\n\nbadMonthStr: .ascii \"Bad month value was entered \"\n             .asciz \"(expected 1-12)\\n\"\n\nbadYearStr:  .ascii \"Bad year value was entered \"\n             .asciz \"(expected 00-99)\\n\"\n\n// These need extra padding so they can be printed\n// as integers. They're really byte (and word) values.\n\nmonth:      .dword  0\nday:        .dword  0\nyear:       .dword  0\ndate:       .dword  0\n\nm:          .dword  0\nd:          .dword  0\ny:          .dword  0\n\ninput:      .fill    maxLen, 0\n\n            .text\n            .align  2       // Word-align code\n            .extern printf\n            .extern readLine\n            .extern strtol\n\n// Return program title to C++ program:\n\n            .global getTitle\ngetTitle:\n            lea     x0, ttlStr\n            ret\n\n// Here's a user-written function that reads a numeric value from\n// the user:\n//\n// int readNum(char *prompt);\n//\n// A pointer to a string containing a prompt message is passed in\n// the X0 register.\n//\n// This procedure prints the prompt, reads an input string from\n// the user, then converts the input string to an integer and\n// returns the integer value in X0.\n\nreadNum:\n            lea     x1, saveLRRN\n            str     lr, [x1]        // Save return address.\n\n// Must set up stack properly (using this \"magic\" instruction)\n// before you can call any C/C++ functions:\n\n            sub     sp, sp, #64\n\n// Print the prompt message. Note that the prompt message was\n// passed to this procedure in X0; we're just passing it on to\n// printf:\n\n            bl      printf\n\n// Set up arguments for readLine and read a line of text from\n// the user. Note that readLine returns NULL (0) in RAX if there\n// was an error.\n\n            lea     x0, input\n            mov     x1, #maxLen\n            bl      readLine\n\n// Test for a bad input string:\n\n            cmp     x0, #NULL\n            beq     badInput\n\n// Okay, good input at this point. Try converting the string\n// to an integer by calling strtol. The strtol function returns\n// 0 if there was an error, but this is a perfectly fine\n// return result, so we ignore errors.\n\n            lea     x0, input       // Ptr to string\n            mov     x1, #NULL       // No end string pointer\n            mov     x2, #10         // Decimal conversion\n            bl      strtol          // Convert to integer.\n\nbadInput:\n            add     sp, sp, #64     // Undo stack setup.\n            lea     x1, saveLRRN    // Restore return address.\n            ldr     lr, [x1]\n            ret\n\n// Here is the \"asmMain\" function:\n            .global asmMain\nasmMain:\n            sub     sp, sp, #64     // Magic instruction\n            lea     x0, saveLRMain\n            str     lr, [x0]\n\n// Read the date from the user. Begin by reading the month:\n\n            lea     x0, moPrompt\n            bl      readNum\n\n// Verify the month is in the range 1..12:\n\n            cmp     x0, #1\n            blo     badMonth\n            cmp     x0, #12\n            bhi     badMonth\n\n// Good month, save it for now:\n\n            lea     x1, month\n            strb    w0, [x1]    // 1..12 fits in a byte.\n\n// Read the day:\n\n            lea     x0, dayPrompt\n            bl      readNum\n\n// We'll be lazy here and verify only that the day is in\n// the range 1..31.\n\n            cmp     x0, #1\n            blo     badDay\n            cmp     x0, #31\n            bhi     badDay\n\n// Good day, save it for now:\n\n            lea     x1, day\n            strb    w0, [x1]    // 1..31 fits in a byte.\n\n// Read the year:\n\n            lea     x0, yearPrompt\n            bl      readNum\n\n// Verify that the year is in the range 0..99:\n\n            cmp     x0, #0\n            blo     badYear\n cmp     x0, #99\n            bhi     badYear\n\n// Good year, save it for now:\n\n            lea     x1, year\n            strb    w0, [x1] // 0..99 fits in a byte.\n\n// Pack the data into the following bits:\n//\n//  15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0\n//   m  m  m  m  d  d  d  d  d  y  y  y  y  y  y  y\n\n            lea     x0, month\n            ldrb    w1, [x0]\n            lsl     w1, w1, #5\n\n            lea     x0, day\n            ldrb    w2, [x0]\n            orr     w1, w1, w2\n            lsl     w1, w1, #7\n\n            lea     x0, year\n            ldrb    w2, [x0]\n            orr     w1, w1, w2\n\n            lea     x0, date\n            strh    w1, [x0]\n\n// Print the packed date:\n\n            lea     x0, packed\n            vparm2  date\n            vparm3  month\n            vparm4  day\n            vparm5  year\n            bl      printf\n\n// Unpack the date and print it:\n\n            lea     x0, date\n            ldrh    w1, [x0]\n\n            // Extract month:\n\n            lsr     w2, w1, #12\n            lea     x0, m\n            strb    w2, [x0]\n\n            // Extract day:\n\n            lsr     w3, w1, #7\n            and     w3, w3, #0x1f\n            lea     x0, d\n            strb    w3, [x0]\n\n // Extract year:\n\n            and     w1, w1, #0x7f\n            lea     x0, y\n            strb    w1, [x0]\n\n            lea     x0, theDate\n            vparm2  m\n            vparm3  d\n            vparm4  y\n            bl      printf\n\n            b.al    allDone\n\n// Come down here if a bad day was entered:\n\nbadDay:\n            lea     x0, badDayStr\n            bl      printf\n            b.al    allDone\n\n// Come down here if a bad month was entered:\n\nbadMonth:\n            lea     x0, badMonthStr\n            bl      printf\n            b.al    allDone\n\n// Come here if a bad year was entered:\n\nbadYear:\n            lea     x0, badYearStr\n            bl      printf\n\nallDone:\n            add     sp, sp, #64\n            lea     x0, saveLRMain\n            ldr     lr, [x0]\n            ret     // Returns to caller\n```", "```\n$ ./build Listing2-4\n$ ./Listing2-4\nCalling Listing2-4:\nEnter current month: 2\nEnter current day: 4\nEnter current year (last 2 digits only): 56\nPacked date is 2238 = 02/04/56\nThe date is 02/04/56\nListing2-4 terminated\n```", "```\n lea x0, Date1  // Assume Date1 and Date2 are words.\n     ldr x1, [x0]   // Using the long packed-date format\n     lea x0, Date2\n     ldr x2, [x0]\n     cmp x1, x2\n     ble d1LEd2\n\n       // Do something if Date1 > Date2.\n\nd1LEd2:\n```", "```\nmsr  `systemReg`, `reg`\nmrs  `reg`, `systemReg`\n```", "```\nmrs  x0, nzcv\n```", "```\nmsr  nzcv, x0\n```", "```\nmrs  x0, nzcv\norr  x0, x0, #0x20000000  // Carry is in bit 29; set it.\nmsr  nzcv, x0\n```", "```\n1.`mmmmmmm mmmmmmmm`\n```", "```\n1.234  3.75e2  -1.0  1.1e-1  1.e+4  0.1  -123.456e+300  +25.0e0\n```", "```\n .data\nfltVar1:  .single  0.0\nfltVar1a: .single  2.7\npi:       .single  3.14159\nDblVar:   .double  0.0\nDblVar2:  .double  1.23456789e+10\nDPVar:    .double  -1.0e-104\nIntAsFP:  .double  -123\n```", "```\n'A'\n```", "```\n'\\''\n```", "```\n .data\nUserInput: .byte  0\n```", "```\n .data\nTheCharA:     .byte 'A'\nExtendedChar: .byte 128  // Character code greater than 0x7F\n```", "```\nadds x0, x1, x2\n```", "```\nadd  x0, x1, x2  // Computes X0 = X1 + X2\n```", "```\nand     x0, x0, #0b1\nand     x0, x0, #0b11\nand     x0, x0, #0b111\nand     x0, x0, #0b1110\nand     x0, x0, #0b11100\n```", "```\nand     x0, x0, #0b101\nand     x0, x0, #0b10101\nand     x0, x0, #0b1110111\nand     x0, x0, #0b101100\n```", "```\n// This AND instruction contains 4 copies of the sequence\n// 0b11110000:\n\n        and     w0, w0, #0b11110000111100001111000011110000\n\n// This sequence is legal because it contains 16 copies of\n// the 2-bit sequence 0b10:\n\n        and     w0, w0, #0b01010101010101010101010101010101\n\n// This sequence is legal because it contains 2 copies of\n// the 32-bit sequence 0b11111111111111110000000000000000:\n\n        and     x0, x0, #0xFFFF0000FFFF0000\n```", "```\nand     w0, w0, #0b1111000011110000\n```", "```\nadd w0, w1, w2, lsl #4  // W0 = W1 + (W2 << 4)\nsub x0, x1, x2, lsr #1  // X0 = X1 - (X2 >> 1)\nadd x0, x1, x2, asr #1  // X0 = X1 + (X2 asr 1)\nand x0, x1, x2, ror #2  // X0 = X1 & (X2 ror 2)\n```", "```\ninstr  `reg`dest`, reg`src1`, reg`src2`, extendop #optional_imm`\n```", "```\nadd x1, x1, #40000\n```", "```\nmov x0, #40000  // Works, because mov allows 16-bit consts\nadd x1, x1, x0  // Add 40000 to X1.\n```", "```\nldr `reg`, =`largeConstant`\n```", "```\nmovz `reg`dest, #`imm`1\nmovz `reg`dest, #`imm`1, lsl #`imm`2\n```", "```\nmov  x0, #122\nmovz x0, #122\nmovz x0, #122, lsl #0\n```", "```\nmovk `reg`dest, #`imm`1 // Default is \"lsl #0\"\nmovk `reg`dest, #`imm`1, lsl #`imm`2\n```", "```\nmov  w0, #LO_16_bits\nmovk w0, #HO_16_bits, lsl #16\n```", "```\nmov  x0, #LO_16_bits\nmovk x0, #Bits_16_to_31, lsl #16\nmovk x0, #Bits_32_to_47, lsl #32\nmovk x0, #HO_16_bits, lsl #48\n```", "```\nmovn `reg`dest, #`imm`1    // Default shift is lsl #0.\nmovn `reg`dest, #`imm`1, lsl #`imm`2\n```", "```\nmovn x1, #0xff, lsl 16\n```"]