["```\n#include <sys/resource.h>\n\nint `getrusage`(int *who*, struct rusage **res_usage*);\n```", "```\nstruct rusage {\n    struct timeval ru_utime;      /* User CPU time used */\n    struct timeval ru_stime;      /* System CPU time used */\n    long           ru_maxrss;     /* Maximum size of resident set (kilobytes)\n                                     [used since Linux 2.6.32] */\n    long           ru_ixrss;      /* Integral (shared) text memory size\n                                     (kilobyte-seconds) [unused] */\n    long           ru_idrss;      /* Integral (unshared) data memory used\n                                     (kilobyte-seconds) [unused] */\n    long           ru_isrss;      /* Integral (unshared) stack memory used\n                                     (kilobyte-seconds) [unused] */\n    long           ru_minflt;     /* Soft page faults (I/O not required) */\n    long           ru_majflt;     /* Hard page faults (I/O required) */\n    long           ru_nswap;      /* Swaps out of physical memory [unused] */\n    long           ru_inblock;    /* Block input operations via file\n                                     system [used since Linux 2.6.22] */\n    long           ru_oublock;    /* Block output operations via file\n                                     system [used since Linux 2.6.22] */\n    long           ru_msgsnd;     /* IPC messages sent [unused] */\n    long           ru_msgrcv;     /* IPC messages received [unused] */\n    long           ru_nsignals;   /* Signals received [unused] */\n    long           ru_nvcsw;      /* Voluntary context switches (process\n                                     relinquished CPU before its time slice\n                                     expired) [used since Linux 2.6] */\n    long          ru_nivcsw;      /* Involuntary context switches (higher\n                                     priority process became runnable or time\n                                     slice ran out) [used since Linux 2.6] */\n};\n```", "```\n#include <sys/resource.h>\n\nint `getrlimit`(int *resource*, struct rlimit **rlim*);\nint `setrlimit`(int *resource*, const struct rlimit **rlim*);\n```", "```\nstruct rlimit {\n    rlim_t rlim_cur;        /* Soft limit (actual process limit) */\n    rlim_t rlim_max;        /* Hard limit (ceiling for rlim_cur) */\n};\n```", "```\n$ `./rlimit_nproc 30 100`\nInitial maximum process limits:  soft=1024; hard=1024\nNew maximum process limits:      soft=30; hard=100\nChild 1 (PID=15674) started\nChild 2 (PID=15675) started\nChild 3 (PID=15676) started\nChild 4 (PID=15677) started\nERROR [EAGAIN Resource temporarily unavailable] fork\n```", "```\n`procres/print_rlimit.c`\n#include <sys/resource.h>\n#include \"print_rlimit.h\"           /* Declares function defined here */\n#include \"tlpi_hdr.h\"\n\nint                     /* Print 'msg' followed by limits for 'resource' */\nprintRlimit(const char *msg, int resource)\n{\n    struct rlimit rlim;\n\n    if (getrlimit(resource, &rlim) == -1)\n        return -1;\n\n    printf(\"%s soft=\", msg);\n    if (rlim.rlim_cur == RLIM_INFINITY)\n        printf(\"infinite\");\n#ifdef RLIM_SAVED_CUR               /* Not defined on some implementations */\n    else if (rlim.rlim_cur == RLIM_SAVED_CUR)\n        printf(\"unrepresentable\");\n#endif\n    else\n        printf(\"%lld\", (long long) rlim.rlim_cur);\n\n    printf(\"; hard=\");\n    if (rlim.rlim_max == RLIM_INFINITY)\n        printf(\"infinite\\n\");\n#ifdef RLIM_SAVED_MAX               /* Not defined on some implementations */\n    else if (rlim.rlim_max == RLIM_SAVED_MAX)\n        printf(\"unrepresentable\");\n#endif\n    else\n        printf(\"%lld\\n\", (long long) rlim.rlim_max);\n\n    return 0;\n}\n     `procres/print_rlimit.c`\n```", "```\n`procres/rlimit_nproc.c`\n#include <sys/resource.h>\n#include \"print_rlimit.h\"               /* Declaration of printRlimit() */\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    struct rlimit rl;\n    int j;\n    pid_t childPid;\n\n    if (argc < 2 || argc > 3 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s soft-limit [hard-limit]\\n\", argv[0]);\n\n    printRlimit(\"Initial maximum process limits: \", RLIMIT_NPROC);\n\n    /* Set new process limits (hard == soft if not specified) */\n\n    rl.rlim_cur = (argv[1][0] == 'i') ? RLIM_INFINITY :\n                                getInt(argv[1], 0, \"soft-limit\");\n    rl.rlim_max = (argc == 2) ? rl.rlim_cur :\n                (argv[2][0] == 'i') ? RLIM_INFINITY :\n                                getInt(argv[2], 0, \"hard-limit\");\n    if (setrlimit(RLIMIT_NPROC, &rl) == -1)\n        errExit(\"setrlimit\");\n\n    printRlimit(\"New maximum process limits:     \", RLIMIT_NPROC);\n\n    /* Create as many children as possible */\n\n    for (j = 1; ; j++) {\n        switch (childPid = fork()) {\n        case -1: errExit(\"fork\");\n\n        case 0: _exit(EXIT_SUCCESS);            /* Child */\n\n        default:        /* Parent: display message about each new child\n                           and let the resulting zombies accumulate */\n            printf(\"Child %d (PID=%ld) started\\n\", j, (long) childPid);\n            break;\n        }\n    }\n}\n     `procres/rlimit_nproc.c`\n```", "```\nbytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +\n        attr.mq_maxmsg * attr.mq_msgsize;\n```", "```\n    $ `./rusage` ``*`command arg...`*``\n    ```"]