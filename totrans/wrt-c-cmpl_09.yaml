- en: '![](../images/pg142.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-16.xhtml)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">LOOPS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll add all things loop-related. That includes <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp>
    loops, plus <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements to skip over
    parts of a loop. These are the last statements you’ll implement in this book.
    Once you finish this chapter, if you’ve implemented all the extra credit features,
    your compiler will be able to handle *every* kind of C statement.
  prefs: []
  type: TYPE_NORMAL
- en: But you have work to do first! You’ll update the lexer and parser to support
    all five new statements. Then, you’ll add a new semantic analysis pass, which
    we’ll call *loop labeling*. This new pass, which is bolded in the diagram at the
    start of the chapter, will annotate the AST to associate every <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement with
    the loop that contains it. Finally, you’ll translate every new statement into
    a sequence of TACKY instructions. You can implement all the new statements using
    the TACKY instructions you’ve already defined, so you won’t change any stages
    after TACKY generation.
  prefs: []
  type: TYPE_NORMAL
- en: The new statements in this chapter introduce a few edge cases and errors we’ll
    need to handle. We’ll briefly discuss each of these statements before we start
    on the lexer.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Loops and How to Escape Them</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s first look at the three kinds of loop statements, then consider the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statements. [Listing 8-1](chapter8.xhtml#list8-1) shows an example of a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-1: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">while</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, we evaluate the statement’s *controlling expression* ❶. If it’s 0 (that
    is, false), the loop ends and we move on to the next statement. If it’s nonzero,
    we execute the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop
    body, then go back to the controlling expression, rinse, and repeat.
  prefs: []
  type: TYPE_NORMAL
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp> loop, like the one
    in [Listing 8-2](chapter8.xhtml#list8-2), is almost exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-2: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">do</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The only difference is that we execute the loop body first, *then* check the
    controlling expression. That means the loop body will be executed at least once.
    Like an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement body,
    a loop body is a single statement, which can be a compound statement that contains
    declarations. Any variables you declare in the loop body will not be in scope
    in the controlling expression. For example, [Listing 8-3](chapter8.xhtml#list8-3)
    is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-3: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">do</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop
    where the controlling expression uses an out-of-scope variable</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Things start to get more complicated with <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops. These come in two different flavors. In the first, shown in [Listing 8-4](chapter8.xhtml#list8-4),
    the loop header consists of three expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-4: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop
    where the initial clause is an expression</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial expression ❶ is evaluated once before the first loop iteration.
    Then, on each iteration, we:'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate the controlling expression ❷. If it’s false, the loop terminates. Otherwise,
    we …
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the statement body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Evaluate the final expression ❸.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can omit any or all of the expressions in the loop header. If you omit the
    initial expression or the final expression, nothing happens when that clause would
    normally be evaluated. If you omit the controlling expression, the loop behaves
    as though its controlling expression is always true (that is, nonzero). That means
    it will never terminate, unless it contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement that transfers control out of the loop body.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-5](chapter8.xhtml#list8-5) shows the second kind of <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, in which the initial clause is a declaration rather than an expression.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-5: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop
    with a declaration in the initial clause</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop header introduces
    a new scope, so you can write code like [Listing 8-6](chapter8.xhtml#list8-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-6: Declaring two
    variables with the same name before a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop and in the loop header</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    declared in the header hides the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    declared on the previous line. And since a compound statement always introduces
    a new scope, including when it appears as a loop body, [Listing 8-7](chapter8.xhtml#list8-7)
    is also valid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-7: Declaring three
    variables with the same name before a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop, in the loop header, and
    in the loop body</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Listing 8-7](chapter8.xhtml#list8-7), there are three distinct variables
    named <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>: one declared before
    the start of the loop ❶, one declared in the loop header ❷, and one declared in
    the loop body ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: Although the expressions in a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop header are optional, the loop body is required. (It’s required for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">do</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loops too.) A loop body can, however, be a null statement, like in [Listing 8-8](chapter8.xhtml#list8-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-8: Using a null statement
    as a loop body</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The lone <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> here is a null
    statement. Even though this statement doesn’t do anything, we need to include
    it so the parser can figure out where the loop ends. As we saw when we implemented
    them in [Chapter 5](chapter5.xhtml), null statements aren’t a loop-specific construct;
    you can use them anywhere you can use any other kind of statement. In practice,
    though, they mostly appear in loop bodies because they’re rarely useful anywhere
    else.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s talk about <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements.
    Both can appear only inside loops. (Actually, that’s not entirely true; a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement can also appear
    inside a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement,
    which you can implement as an extra credit feature in this chapter.) A <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement, like the one in [Listing 8-9](chapter8.xhtml#list8-9), jumps to the
    point just after the end of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-9: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we hit this <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement, we’ll jump to the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement after the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement terminates
    only the innermost loop. For example, consider the code snippet in [Listing 8-10](chapter8.xhtml#list8-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-10: Using a</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    to break out of the inner of two nested loops</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement in this listing, we’ll break out of the inner loop, but not the outer
    loop, so we’ll jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b
    * a;</samp>. Throughout this chapter, I’ll call the innermost loop that contains
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement its *enclosing loop*. (Calling this the “smallest enclosing loop” would
    be more in line with the terminology in the C standard, but that’s a bit of a
    mouthful.)
  prefs: []
  type: TYPE_NORMAL
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement jumps
    to the point just after the last statement in the body of the enclosing loop.
    Consider the example in [Listing 8-11](chapter8.xhtml#list8-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-11: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement, we skip over all the statements that follow it and jump to the end
    of the loop body ❶. From there, the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop executes as usual, which means it jumps back to the controlling expression.
    A <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement in a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, like the one in
    [Listing 8-12](chapter8.xhtml#list8-12), works the same way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-12: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    inside a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, we still jump from the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement to the end of the loop body ❷. Then, we jump to the final expression
    ❶, as usual.
  prefs: []
  type: TYPE_NORMAL
- en: If a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement appears outside of a loop, like in [Listing 8-13](chapter8.xhtml#list8-13),
    compilation should fail.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-13: An invalid</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: It’s perfectly fine, however, for one of these statements to appear nested deep
    inside a loop, like the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement in [Listing 8-14](chapter8.xhtml#list8-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-14: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    appearing a few layers deep inside a loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement jumps
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">return 1;</samp> because that’s
    the point right after the end of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: It’s legal to have multiple <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements in
    one loop, like in [Listing 8-15](chapter8.xhtml#list8-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-15: Multiple</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements
    inside a loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered the key things you need to know about the statements
    we’ll add in this chapter, we can get started on implementing them. The first
    step, as usual, is updating the lexer.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll add five keywords in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">do</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">while</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">for</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">break</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">continue</samp>
  prefs: []
  type: TYPE_NORMAL
- en: You won’t need any other new tokens.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll update the AST. We’ll add five new statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statements are as simple as it gets. The <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp> statements are also
    relatively simple; both have a body and a controlling expression. The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    statement is the most complex: it includes an initial clause, an optional controlling
    expression, an optional final expression, and a body. The initial clause can be
    a declaration, an expression, or nothing, so we need a new AST node to describe
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Putting it all together gives us the latest AST definition, shown in [Listing
    8-16](chapter8.xhtml#list8-16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-16: The abstract
    syntax tree with loops and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating the AST in this chapter involves one complication. The loop labeling
    pass will annotate every <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>, and loop statement
    in the program with a label (we’ll use these labels to associate each <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement with
    its enclosing loop). That means you’ll need some way to attach these labels to
    the new statements in the AST. There are a few different options. One is to include
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp> argument for each
    new constructor, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you go with this option, you may need to use dummy labels during parsing,
    then replace them with real labels in the loop labeling pass. Another option is
    to define two AST data structures: one without annotations to use before loop
    labeling and one with annotations to use afterward. The right approach depends
    on what language you’re writing your compiler in (and on your personal taste).'
  prefs: []
  type: TYPE_NORMAL
- en: After updating the AST, we’ll make the corresponding changes to the grammar,
    as shown in [Listing 8-17](chapter8.xhtml#list8-17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-17: The grammar with
    loops and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: I recommend writing a helper function to parse optional expressions. You can
    use this helper function to parse the two optional expressions in a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop header, plus expression statements and null statements. The helper function
    should let you specify which token marks the end of the optional expression; most
    of the optional expressions in the grammar are followed by a semicolon, but the
    third clause in a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    header is followed by a closing parenthesis.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Semantic Analysis</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The semantic analysis stage of your compiler currently performs one task: it
    resolves variable names. In this chapter, it will take on a completely new task:
    loop labeling. The loop labeling pass associates each <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement with
    its enclosing loop. More concretely, this pass assigns every loop statement a
    unique ID and annotates each <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement with
    the ID of its enclosing loop. If it finds a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement outside
    of a loop, it will throw an error. During TACKY generation, we’ll use these annotations
    to convert each <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement into a
    jump to the correct spot relative to its enclosing loop.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll resolve variable names and label loops in two separate passes, traversing
    the whole program each time. Let’s start by extending the variable resolution
    pass to handle this chapter’s new statements; then we’ll implement the loop labeling
    pass.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extending Variable
    Resolution</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ll need to extend <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_statement</samp>
    to traverse the five new statements you added in this chapter. You’ll treat <samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp>
    loops just like <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements,
    processing every substatement and subexpression recursively. Resolving <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements is
    even simpler; since they don’t have any substatements or subexpressions, you don’t
    have to do anything.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is
    a tiny bit more complicated because the loop header introduces a new variable
    scope. [Listing 8-18](chapter8.xhtml#list8-18) demonstrates how to handle <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops in <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_statement</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-18: Resolving a</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We start by making a new copy of the variable map, just like we do at the beginning
    of a compound statement. Copying the map ensures that a variable declared in the
    loop header won’t be visible outside of the loop and that it won’t trigger a compiler
    error if it hides a variable from the outer scope.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we process the initial clause with <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_for_init</samp>,
    which we’ll look at in a moment. We then traverse the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop’s controlling expression, final expression, and body, all using the new variable
    map. I won’t provide pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_optional_exp</samp>,
    which handles the optional controlling expression and final expression; it just
    calls <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp> if the
    expression is present and does nothing if it’s absent.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-19](chapter8.xhtml#list8-19) shows the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_for_init</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-19: Resolving the
    initial clause of a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We resolve an expression or declaration in the initial clause exactly the same
    way we would resolve it if it appeared elsewhere in the program. If the clause
    is a declaration, calling <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_declaration</samp>
    will add the newly declared variable to the variable map so it’s visible throughout
    the rest of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Loop Labeling</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After resolving variables, we’ll traverse the program again, labeling each loop,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement with an ID. Whenever we encounter a loop statement, we’ll generate a
    unique ID for it. Then, when we traverse the loop body, we’ll attach that same
    ID to any <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements we encounter.
    Let’s look at a few examples. In the next three listings, the markers ❶ and ❷
    represent IDs attached to the AST. Although the loop labeling pass annotates the
    AST rather than source files, these listings are presented as source code for
    the sake of readability.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-20](chapter8.xhtml#list8-20) illustrates how we’ll annotate a code
    fragment that contains two loops in succession.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-20: Annotating</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements
    and their enclosing loops</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Each of the two loops in this listing gets its own ID. We annotate the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop with ID ❶ and the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop with ID ❷. Each <samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement is annotated with the ID of its enclosing loop, so we annotate the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement with ID ❶ and the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement with ID
    ❷.
  prefs: []
  type: TYPE_NORMAL
- en: If several <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements are in the
    same enclosing loop, they’re all annotated with the same ID, as [Listing 8-21](chapter8.xhtml#list8-21)
    demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-21: Annotating multiple</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements
    in the same loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop labeled
    ❶ is the enclosing loop of the two <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statements and the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement, we annotate all three of those statements with ID ❶.
  prefs: []
  type: TYPE_NORMAL
- en: If a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement appears inside nested loops, we annotate it with the ID of its enclosing
    loop, which is the innermost loop. [Listing 8-22](chapter8.xhtml#list8-22) illustrates
    how to annotate nested loops.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-22: Annotating nested
    loops</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The outer <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop and
    inner <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop are labeled
    ❶ and ❷, respectively. Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement appears in the inner loop, we annotate it with ID ❷. The <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement is in the outer loop, so we annotate it with ID ❶.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing Loop
    Labeling</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To implement this compiler pass, we pass the current loop ID along as an argument
    when we traverse the AST, much like we pass the variable map as an argument to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_statement</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>, and so on during the
    variable resolution pass. When we’re outside of a loop, the current ID is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>,
    or whatever your implementation language uses to indicate an absent value. When
    we hit a loop statement, we generate a new ID and annotate the statement with
    it. We then pass it along as the current ID when we traverse the loop body. When
    we hit a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement, we annotate it with the ID that was passed to us. The pseudocode in
    [Listing 8-23](chapter8.xhtml#list8-23) illustrates how to annotate statements
    with loop IDs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-23: The loop annotation
    algorithm</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">make_label</samp> helper function
    ❸ generates unique loop IDs; you can use the same helper function here that you
    use to generate unique labels in TACKY. The <samp class="SANS_TheSansMonoCd_W5Regular_11">annotate</samp>
    helper function takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>
    AST node and a label and returns a copy of that AST node annotated with that label.
    Here, we use it to annotate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Break</samp>
    ❶, <samp class="SANS_TheSansMonoCd_W5Regular_11">Continue</samp> ❷, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">While</samp> ❹ statements. I haven’t provided
    the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">annotate</samp>
    because it will depend on how exactly you represent loop annotations in your AST.
    I’ve also omitted the pseudocode to handle <samp class="SANS_TheSansMonoCd_W5Regular_11">DoWhile</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">For</samp>, and all the statements
    we added in earlier chapters. You can process <samp class="SANS_TheSansMonoCd_W5Regular_11">DoWhile</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">For</samp> essentially the same
    way as <samp class="SANS_TheSansMonoCd_W5Regular_11">While</samp>. To process
    any other kind of statement, call <samp class="SANS_TheSansMonoCd_W5Regular_11">label_statement</samp>
    recursively for every substatement, passing along the same value of <samp class="SANS_TheSansMonoCd_W5Regular_11">current_label</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve updated the loop labeling pass, you’re ready to test out the whole
    semantic analysis stage.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we’ll convert each new statement to TACKY. We won’t change the TACKY IR
    in this chapter, because we can implement these statements with our existing TACKY
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">break and continue
    Statements</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement unconditionally
    jumps to some other point in the program, so we implement it with a single <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> instruction. The same is true
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements.
    The only question is where to jump to. The loop annotations we added in the last
    section help us answer that question.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we convert a loop statement to TACKY, we’ll emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    right after the instructions for the loop body. Any <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement in that loop can be implemented as a jump to that label, which I’ll
    call the *continue label*. We’ll emit another <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    as the final instruction for the whole loop; I’ll call this the *break label*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll derive these labels from the IDs we added during the loop annotation
    pass. For example, if a loop is labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">loop0</samp>,
    its break and continue labels might be <samp class="SANS_TheSansMonoCd_W5Regular_11">break_loop0</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue_loop0</samp>. Using
    this example naming scheme, we’d convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">Break</samp>
    AST node annotated with ID <samp class="SANS_TheSansMonoCd_W5Regular_11">loop0</samp>
    to the following TACKY instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We’d convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">Continue</samp>
    node with the same annotation to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You don’t need to use this particular naming scheme (although your naming scheme
    must guarantee that these labels won’t conflict with any other labels in the TACKY
    program). The important point is that you can derive the same label when you convert
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement to TACKY as when you convert its enclosing loop to TACKY, because that
    statement and its enclosing loop are annotated with the same ID.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">do Loops</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can execute the statement <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><body></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">while
    (</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">);</samp> in three steps. First, we execute
    the loop body. Then, we evaluate the condition and compare the result to zero.
    Finally, if the result was not zero, we jump back to the beginning of the loop.
    [Listing 8-24](chapter8.xhtml#list8-24) demonstrates how to implement these steps
    in TACKY.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-24: The TACKY instructions
    for a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">do</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We also need break and continue labels. The continue label goes between the
    body and the condition, and the break label goes at the very end, after <samp
    class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>. Adding both of these
    labels gives us the complete TACKY for a <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp>
    loop, as shown in [Listing 8-25](chapter8.xhtml#list8-25).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-25: The TACKY instructions
    for a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">do</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop,
    with break and continue labels</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now any <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements
    in the loop body will jump to the continue label, and any <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statements will jump to the break label. These labels are necessary only if a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement shows up somewhere in the loop body—otherwise, they won’t be used—but
    to keep things simple, we’ll always emit them. That way, we don’t need to figure
    out whether a loop contains <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">while Loops</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll handle <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loops
    similarly to <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp> loops, but
    in this case we’ll execute the condition before the loop body, then use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> to exit the loop if
    the condition is false. We can convert the statement <samp class="SANS_TheSansMonoCd_W5Regular_11">while
    (</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><body></samp>
    to the TACKY in [Listing 8-26](chapter8.xhtml#list8-26).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-26: The TACKY instructions
    for a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">while</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s figure out where to put the break and continue labels. This time,
    we don’t need extra <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    instructions; we can reuse the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    instructions that are already present in [Listing 8-26](chapter8.xhtml#list8-26).
    We’ll put the break label in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    instruction at the end of this listing. It will be the target for both the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> instruction and any
    <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statements in the loop
    body.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, we’ll put the continue label in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    instruction at the start of this listing. This has the same effect as putting
    the continue label just after the end of the loop body ❶, because the instruction
    after the loop body is an unconditional jump that immediately takes us back to
    the start of the loop. Having <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statements jump directly to the start of the loop lets them bypass that <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> instruction, which makes them
    a little bit more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-27](chapter8.xhtml#list8-27) shows where to use the break and continue
    labels when we convert <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loops to TACKY.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-27: The TACKY instructions
    for a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">while</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">loop, with break and continue labels</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This TACKY is identical to [Listing 8-26](chapter8.xhtml#list8-26), except that
    it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">continue_</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">break_label</samp> instead of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">for Loops</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our final task is to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops to TACKY. We’ll convert the statement <samp class="SANS_TheSansMonoCd_W5Regular_11">for
    (</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><init></samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><post></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><body></samp>
    into the TACKY in [Listing 8-28](chapter8.xhtml#list8-28), which includes the
    break and continue labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-28: The TACKY instructions
    for a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, we execute <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><init></samp>.
    Then, we execute the controlling expression, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>,
    and check whether the result is zero. If it is, we jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">Label(break
    _label)</samp> at the very end, without executing the loop body or the final expression.
    Otherwise, we execute the loop body followed by the final expression, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><post></samp>,
    then jump back to <samp class="SANS_TheSansMonoCd_W5Regular_11">Label(start)</samp>
    and start another loop iteration. We won’t execute <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><init></samp>
    again, since <samp class="SANS_TheSansMonoCd_W5Regular_11">Label(start)</samp>
    comes after <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><init></samp>.
    Note that the continue label appears at the end of the loop body, just before
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><post></samp>, and the
    break label appears at the very end of the loop, where it does double duty as
    the target of the <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>
    instruction and any <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s break down how to handle each of the three clauses in the loop header.
    The first clause can be an expression, a declaration, or nothing. If it’s a declaration
    or expression, we’ll handle it the same way as a declaration or expression outside
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop. If it’s absent,
    we won’t emit any instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second clause is the controlling expression. If this expression is present,
    we’ll convert it to TACKY exactly like the controlling expressions in <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp> loops. If it’s absent,
    the C standard says that this expression is “replaced by a nonzero constant” (section
    6.8.5.3, paragraph 2). We could just use a nonzero constant in the conditional
    jump:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: But this instruction doesn’t do anything; <samp class="SANS_TheSansMonoCd_W5Regular_11">Const(1)</samp>
    will never equal zero, so we’ll never jump. Instead, we’ll leave out the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> instruction entirely,
    since that’s a more efficient way to produce the same behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to handle the third clause, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><post></samp>.
    If it’s present, we’ll convert it to TACKY; if it’s absent, we won’t emit any
    instructions.  ### <samp class="SANS_Futura_Std_Bold_B_11">Extra Credit: switch
    Statements</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You have the option of implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    statements in this chapter. To support these statements, you’ll need to make significant
    changes to the semantic analysis stage. First, you’ll need to change the loop
    annotation pass, because <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statements can break out of <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statements as well as loops. You can’t, however, use a <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement inside a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statement, so this pass will need to treat <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statements differently from <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need additional analysis, probably in a separate compiler pass, to collect
    the cases that appear inside each <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statement. To generate the TACKY for a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statement, you’ll need a list of all the cases in that statement. However, that
    information isn’t immediately available in the AST. The cases in a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statement may be nested several layers deep, or the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statement body may not include any cases at all. You’ll need to attach that information
    to the AST in a more usable form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--switch</samp> flag
    to enable the tests for <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Or enable every extra credit test with the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp>
    flag, as usual.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you implemented your last set of control-flow statements. You
    added support for three different loop statements, plus <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements.
    You implemented a new semantic analysis pass to associate <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements with
    their enclosing loops, and you saw how to convert each of these complex structures
    into a list of TACKY instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we’re done with control-flow *statements*, you’ll add support for
    one more control-flow *expression* in the next chapter: function calls. You’ll
    learn about the calling conventions that dictate how function calls work in assembly
    and write a simple type checker. Best of all, you’ll end the chapter by compiling
    “Hello, World!”'
  prefs: []
  type: TYPE_NORMAL
