<html><head></head><body>
<h2 class="h2" id="ch01"><span epub:type="pagebreak" id="page_1"/><strong><span class="big">1</span><br/>BUG BOUNTY BASICS</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/common.jpg"/></div>&#13;
<p class="noindent">If you’re new to hacking, it will help to have a basic understanding of how the internet works and what happens under the hood when you enter a URL into a browser’s address bar. Although navigating to a website might seem simple, it involves many hidden processes, such as preparing an HTTP request, identifying the domain to send the request to, translating the domain to an IP address, sending the request, rendering a response, and so on.</p>&#13;
<p class="indent">In this chapter, you’ll learn basic concepts and terminology, such as vulnerabilities, bug bounties, clients, servers, IP addresses, and HTTP. You’ll get a general understanding of how performing unintended actions and providing unexpected input or access to private information can result in vulnerabilities. Then, we’ll see what happens when you enter a URL in <span epub:type="pagebreak" id="page_2"/>your browser’s address bar, including what HTTP requests and responses look like and the various HTTP action verbs. We’ll end the chapter with an understanding of what it means to say HTTP is stateless.</p>&#13;
<h3 class="h3" id="ch01lev1sec1"><strong>Vulnerabilities and Bug Bounties</strong></h3>&#13;
<p class="noindent">A <em>vulnerability</em> is a weakness in an application that allows a malicious person to perform some unpermitted action or gain access to information they shouldn’t otherwise be allowed to access.</p>&#13;
<p class="indent">As you learn and test applications, keep in mind that vulnerabilities can result from attackers performing intended and unintended actions. For example, changing the ID of a record identifier to access information you shouldn’t have access to is an example of an unintended action.</p>&#13;
<p class="indent">Suppose a website allowed you to create a profile with your name, email, birthday, and address. It would keep your information private and share it only with your friends. But if the website allowed anyone to add you as a friend without your permission, this would be a vulnerability. Even though the site kept your information private from non-friends, by allowing anyone to add you as a friend, anyone could access your information. As you test a site, always consider how someone could abuse existing functionality.</p>&#13;
<p class="indent">A <em>bug bounty</em> is a reward a website or company gives to anyone who ethically discovers a vulnerability and reports it to that website or company. Rewards are often monetary and range from tens of dollars to tens of thousands of dollars. Other examples of bounties include cryptocurrencies, air miles, reward points, service credits, and so on.</p>&#13;
<p class="indent">When a company offers bug bounties, it creates a <em>program</em>, a term that we’ll use in this book to denote the rules and framework established by companies for people who want to test the company for vulnerabilities. Note that this is different from companies that operate a <em>vulnerability disclosure program (VDP)</em>. Bug bounties offer some monetary reward, whereas a VDP does not offer payment (though a company may award swag). A VDP is just a way for ethical hackers to report vulnerabilities to a company for that company to fix. Although not all reports included in this book were rewarded, they’re all examples from hackers participating in bug bounty programs.</p>&#13;
<h3 class="h3" id="ch01lev1sec2"><strong>Client and Server</strong></h3>&#13;
<p class="noindent">Your browser relies on the internet, which is a network of computers that send messages to each other. We call these messages <em>packets</em>. Packets include the data you’re sending and information about where that data is coming from and where it’s going. Every computer on the internet has an address for sending packets to it. But some computers only accept certain types of packets, and others only allow packets from a restricted list of other computers. It’s then up to the receiving computer to determine what to do with the packets and how to respond. For the purposes of this book, we’ll focus only on the data included in the packets (the HTTP messages), not the packets themselves.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_3"/>I’ll refer to these computers as either clients or servers. The computer initiating requests is typically referred to as the <em>client</em> regardless of whether the request is initiated by a browser, command line, or so on. <em>Servers</em> refer to the websites and web applications receiving the requests. If the concept is applicable to either clients or servers, I refer to computers in general.</p>&#13;
<p class="indent">Because the internet can include any number of computers talking to each other, we need guidelines for how computers should communicate over the internet. This takes the form of <em>Request for Comment (RFC)</em> documents, which define standards for how computers should behave. For example, the <em>Hypertext Transfer Protocol (HTTP)</em> defines how your internet browser communicates with a remote server using <em>Internet Protocol (IP)</em>. In this scenario, both the client and server must agree to implement the same standards so they can understand the packets each is sending and receiving.</p>&#13;
<h3 class="h3" id="ch01lev1sec3"><strong>What Happens When You Visit a Website</strong></h3>&#13;
<p class="noindent">Because we’ll focus on HTTP messages in this book, this section provides you with a high-level overview of the process that occurs when you enter a URL in your browser’s address bar.</p>&#13;
<h4 class="h4" id="ch01lev2sec1"><strong><em>Step 1: Extracting the Domain Name</em></strong></h4>&#13;
<p class="noindent">Once you enter <em><a href="http://www.google.com/">http://www.google.com/</a></em>, your browser determines the domain name from the URL. A <em>domain name</em> identifies which website you’re trying to visit and must adhere to specific rules as defined by RFCs. For example, a domain name can only contain alphanumeric characters and underscores. An exception is internationalized domain names, which are beyond the scope of this book. To learn more, refer to RFC 3490, which defines their usage. In this case, the domain is <em><a href="http://www.google.com">www.google.com</a></em>. The domain serves as one way to find the server’s address.</p>&#13;
<h4 class="h4" id="ch01lev2sec2"><strong><em>Step 2: Resolving an IP Address</em></strong></h4>&#13;
<p class="noindent">After determining the domain name, your browser uses IP to look up the <em>IP address</em> associated with the domain. This process is referred to as resolving the IP address, and every domain on the internet must resolve to an IP address to work.</p>&#13;
<p class="indent">Two types of IP addresses exist: Internet Protocol version 4 (IPv4) and Internet Protocol version 6 (IPv6). IPv4 addresses are structured as four numbers connected by periods, and each number falls in a range from 0 to 255. IPv6 is the newest version of the Internet Protocol. It was designed to address the problem of available IPv4 addresses running out. IPv6 addresses are made up of eight groups of four hexadecimal digits separated by colons, but methods exist to shorten IPv6 addresses. For example, 8.8.8.8 is an IPv4 address, and 2001:4860:4860::8888 is a shortened IPv6 address.</p>&#13;
<p class="indent">To look up an IP address using just the domain name, your computer sends a request to <em>Domain Name System (DNS)</em> servers, which consist of <span epub:type="pagebreak" id="page_4"/>specialized servers on the internet that have a registry of all domains and their matching IP addresses. The preceding IPv4 and IPv6 addresses are Google DNS servers.</p>&#13;
<p class="indent">In this example, the DNS server you connect to would match <em><a href="http://www.google.com">www.google.com</a></em> to the IPv4 address 216.58.201.228 and send that back to your computer. To learn more about a site’s IP address, you can use the command <code>dig A</code> <span class="codeitalic">site.com</span> from your terminal and replace <span class="codeitalic">site.com</span> with the site you’re looking up.</p>&#13;
<h4 class="h4" id="ch01lev2sec3"><strong><em>Step 3: Establishing a TCP Connection</em></strong></h4>&#13;
<p class="noindent">Next, the computer attempts to establish a <em>Transmission Control Protocol (TCP)</em> connection with the IP address on port 80 because you visited a site using <em>http://</em>. The details of TCP aren’t important other than to note that it’s another protocol that defines how computers communicate with each other. TCP provides two-way communication so that message recipients can verify the information they receive and nothing is lost in transmission.</p>&#13;
<p class="indent">The server you’re sending a request to might be running multiple services (think of a service as a computer program), so it uses <em>ports</em> to identify specific processes to receive requests. You can think of ports as a server’s doors to the internet. Without ports, services would have to compete for the information being sent to the same place. This means that we need another standard to define how services cooperate with each other and ensure that the data for one service isn’t stolen by another. For example, port 80 is the standard port for sending and receiving unencrypted HTTP requests. Another common port is 443, which is used for encrypted HTTPS requests. Although port 80 is standard for HTTP and 443 is standard for HTTPS, TCP communication can happen on any port, depending on how an administrator configures an application.</p>&#13;
<p class="indent">You can establish your own TCP connection to a website on port 80 by opening your terminal and running <code>nc</code> <span class="codeitalic">&lt;IP ADDRESS&gt;</span> <code>80</code>. This line uses the Netcat utility <code>nc</code> command to create a network connection for reading and writing messages.</p>&#13;
<h4 class="h4" id="ch01lev2sec4"><strong><em>Step 4: Sending an HTTP Request</em></strong></h4>&#13;
<p class="noindent">Continuing with <em><a href="http://www.google.com/">http://www.google.com/</a></em> as an example, if the connection in step 3 is successful, your browser should prepare and send an HTTP request, as shown in <a href="ch01.xhtml#ch01ex01">Listing 1-1</a>:</p>&#13;
<pre><span class="ent">➊</span> GET / HTTP/1.1<br/>&#13;
<span class="ent">➋</span> Host: www.google.com<br/>&#13;
<span class="ent">➌</span> Connection: keep-alive<br/>&#13;
<span class="ent">➍</span> Accept: application/html, */*<br/>&#13;
<span class="ent">➎</span> User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36<br/>&#13;
   (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36</pre>&#13;
<p class="listing"><a id="ch01ex01"/><em>Listing 1-1: Sending an HTTP request</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_5"/>The browser makes a <code>GET</code> request to the <code>/</code> path <span class="ent">➊</span>, which is the website’s root. A website’s content is organized into paths, just like the folders and files on your computer. As you get deeper into each folder, the path you take is denoted by recording each folder’s name followed by a <code>/</code>. When you visit the first page of a website, you access the root path, which is just a <code>/</code>. The browser also indicates it’s using the HTTP version 1.1 protocol. A <code>GET</code> request just retrieves information. We’ll learn more about it later.</p>&#13;
<p class="indent">The <em>host header</em> <span class="ent">➋</span> holds an additional piece of information that is sent as part of the request. HTTP 1.1 needs it to identify where a server at the given IP address should send the request because IP addresses can host multiple domains. A <em>connection header</em> <span class="ent">➌</span> indicates the request to keep the connection with the server open to avoid the overhead of constantly opening and closing connections.</p>&#13;
<p class="indent">You can see the expected response format at <span class="ent">➍</span>. In this case, we’re expecting <code>application/html</code> but will accept any format, as indicated by the wildcard (<code>*/*</code>). There are hundreds of possible content types, but for our purposes, you’ll see <code>application/html</code>, <code>application/json</code>, <code>application/octet-stream</code>, and <code>text/plain</code> most often. Finally, the User-Agent <span class="ent">➎</span> denotes the software responsible for sending the request.</p>&#13;
<h4 class="h4" id="ch01lev2sec5"><strong><em>Step 5: Server Response</em></strong></h4>&#13;
<p class="noindent">In response to our request, the server should respond with something that looks like <a href="ch01.xhtml#ch01ex02">Listing 1-2</a>:</p>&#13;
<pre><span class="ent">➊</span> HTTP/1.1 200 OK<br/>&#13;
<span class="ent">➋</span> Content-Type: text/html<br/>&#13;
   &lt;html&gt;<br/>&#13;
     &lt;head&gt;<br/>&#13;
       &lt;title&gt;Google.com&lt;/title&gt;<br/>&#13;
     &lt;/head&gt;<br/>&#13;
     &lt;body&gt;<br/>&#13;
    <span class="ent">➌</span> --<span class="codeitalic1">snip</span>--<br/>&#13;
     &lt;/body&gt;<br/>&#13;
   &lt;/html&gt;</pre>&#13;
<p class="listing"><a id="ch01ex02"/><em>Listing 1-2: Server response</em></p>&#13;
<p class="indent">Here, we’ve received an HTTP response with the status code 200 <span class="ent">➊</span> adhering to HTTP/1.1. The status code is important because it indicates how the server is responding. Also defined by RFC, these codes typically have three-digit numbers that begin with 2, 3, 4, or 5. Although there is no strict requirement for servers to use specific codes, 2<em>xx</em> codes typically indicate a request was successful.</p>&#13;
<p class="indent">Because there is no strict enforcement of how a server implements its use of HTTP codes, you might see some applications respond with a 200 even though the HTTP message body explains there was an application error. An <em>HTTP message body</em> is the text associated with a request or response <span class="ent">➌</span>. In this case, we’ve removed the content and replaced it with <span class="codeitalic">--snip--</span> because of how <span epub:type="pagebreak" id="page_6"/>big the response body from Google is. This text in a response is usually the HTML for a web page but could be JSON for an application programming interface, file contents for a file download, and so on.</p>&#13;
<p class="indent">The Content-Type header <span class="ent">➋</span> informs the browsers of the body’s media type. The media type determines how a browser will render body contents. But browsers don’t always use the value returned from an application; instead, browsers perform <em>MIME sniffing</em>, reading the first bit of the body contents to determine the media type for themselves. Applications can disable this browser behavior by including the header <em>X-Content-Type-Options: nosniff</em>, which is not included in the preceding example.</p>&#13;
<p class="indent">Other response codes starting with 3 indicate a redirection, which instructs your browser to make an additional request. For example, if Google theoretically needed to permanently redirect you from one URL to another, it could use a 301 response. In contrast, a 302 is a temporary redirect.</p>&#13;
<p class="indent">When a 3<em>xx</em> response is received, your browser should make a new HTTP request to the URL defined in a <code>Location</code> header, as follows:</p>&#13;
<pre>HTTP/1.1 301 Found<br/>&#13;
Location: https://www.google.com/</pre>&#13;
<p class="indent">Responses starting with a 4 typically indicate a user error, such as response 403 when a request doesn’t include proper identification to authorize access to content despite providing a valid HTTP request. Responses starting with a 5 identify some type of server error, such as 503, which indicates a server is unavailable to handle the sent request.</p>&#13;
<h4 class="h4" id="ch01lev2sec6"><strong><em>Step 6: Rendering the Response</em></strong></h4>&#13;
<p class="noindent">Because the server sent a 200 response with the content type text/html, our browser will begin rendering the contents it received. The response’s body tells the browser what should be presented to the user.</p>&#13;
<p class="indent">For our example, this would include HTML for the page structure; Cascading Style Sheets (CSS) for the styles and layout; and JavaScript to add additional dynamic functionality and media, such as images or videos. It’s possible for the server to return other content, such as XML, but we’ll stick to the basics for this example. <a href="ch11.xhtml#ch11">Chapter 11</a> discusses XML in more detail.</p>&#13;
<p class="indent">Because it’s possible for web pages to reference external files such as CSS, JavaScript, and media, the browser might make additional HTTP requests for all a web page’s required files. While the browser is requesting those additional files, it continues parsing the response and presenting the body to you as a web page. In this case, it will render Google’s home page, <em><a href="http://www.google.com">www.google.com</a></em>.</p>&#13;
<p class="indent">Note that JavaScript is a scripting language supported by every major browser. JavaScript allows web pages to have dynamic functionality, including the ability to update content on a web page without reloading the page, check whether your password is strong enough (on some websites), and so on. Like other programming languages, JavaScript has built-in functions and can store values in variables and run code in response to events on a web <span epub:type="pagebreak" id="page_7"/>page. It also has access to various browser application programming interfaces (APIs). These APIs enable JavaScript to interact with other systems, the most important of which may be the document object model (DOM).</p>&#13;
<p class="indent">The DOM allows JavaScript to access and manipulate a web page’s HTML and CSS. This is significant because if an attacker can execute their own JavaScript on a site, they’ll have access to the DOM and can perform actions on the site on behalf of the targeted user. <a href="ch07.xhtml#ch07">Chapter 7</a> explores this concept further.</p>&#13;
<h3 class="h3" id="ch01lev1sec4"><strong>HTTP Requests</strong></h3>&#13;
<p class="noindent">The agreement between client and server on how to handle HTTP messages includes defining request methods. A <em>request method</em> indicates the purpose of the client’s request and what the client expects as a successful result. For example, in <a href="ch01.xhtml#ch01ex01">Listing 1-1</a>, we sent a <code>GET</code> request to <em><a href="http://www.google.com/">http://www.google.com/</a></em> implying we expect only the contents of <em><a href="http://www.google.com/">http://www.google.com/</a></em> to be returned and no other actions to be performed. Because the internet is designed as an interface between remote computers, request methods were developed and implemented to distinguish between the actions being invoked.</p>&#13;
<p class="indent">The HTTP standard defines the following request methods: <code>GET</code>, <code>HEAD</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code>, <code>CONNECT</code>, and <code>OPTIONS</code> (<code>PATCH</code> was also proposed but not commonly implemented in the HTTP RFC). At the time of this writing, browsers will only send <code>GET</code> and <code>POST</code> requests using HTML. Any <code>PUT</code>, <code>PATCH</code>, or <code>DELETE</code> request is the result of JavaScript’s invoking the HTTP request. This will have implications later in the book when we consider vulnerability examples in applications expecting these method types.</p>&#13;
<p class="indent">The next section provides a brief overview of request methods you’ll find in this book.</p>&#13;
<h4 class="h4" id="ch01lev2sec7"><strong><em>Request Methods</em></strong></h4>&#13;
<p class="noindent">The <code>GET</code> method retrieves whatever information is identified by the request <em>Uniform Resource Identifier (URI)</em>. The term URI is commonly used synonymously with Uniform Resource Locator (URL). Technically, a <em>URL</em> is a type of URI that defines a resource and includes a way to locate that resource by way of its network location. For example, <em>http://www.google.com/&lt;example&gt;/file.txt</em> and <em>/&lt;example&gt;/file.txt</em> are valid URIs. But only <em>http://www.google.com/&lt;example&gt;/file.txt</em> is a valid URL because it identifies how to locate the resource via the domain <em><a href="http://www.google.com">http://www.google.com</a></em>. Despite the nuance, we’ll use <em>URL</em> throughout the book when referencing any resource identifiers.</p>&#13;
<p class="indent">While there is no way to enforce this requirement, <code>GET</code> requests shouldn’t alter data; they should just retrieve data from a server and return it in the HTTP message body. For example, on a social media site, a <code>GET</code> request should return your profile name but not update your profile. This behavior is critical for the cross-site request forgery (CSRF) vulnerabilities discussed in <a href="ch04.xhtml#ch04">Chapter 4</a>. Visiting any URL or website link (unless invoked by JavaScript) causes your browser to send a <code>GET</code> request to the intended server. This behavior is crucial to the open redirect vulnerabilities discussed in <a href="ch02.xhtml#ch02">Chapter 2</a>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_8"/>The <code>HEAD</code> method is identical to the <code>GET</code> method except the server must not return a message body in the response.</p>&#13;
<p class="indent">The <code>POST</code> method invokes some function on the receiving server, as determined by the server. In other words, typically there will be some type of backend action performed, such as creating a comment, registering a user, deleting an account, and so on. The action performed by the server in response to a <code>POST</code> can vary. Sometimes, the server may take no action at all. For example, a <code>POST</code> request could cause an error to occur while a request is being processed, and a record wouldn’t be saved on the server.</p>&#13;
<p class="indent">The <code>PUT</code> method invokes some function that refers to an already existing record on the remote website or application. For example, it might be used when updating an account, a blog post, or so on that already exists. Again, the action performed can vary and might result in the server taking no action at all.</p>&#13;
<p class="indent">The <code>DELETE</code> method requests that the remote server delete a remote resource identified with a URI.</p>&#13;
<p class="indent">The <code>TRACE</code> method is another uncommon method; it is used to reflect the request message back to the requester. It allows the requester to see what is being received by the server and to use that information for testing and collecting diagnostic information.</p>&#13;
<p class="indent">The <code>CONNECT</code> method is reserved for use with a <em>proxy</em>, a server that forwards requests to other servers. This method starts two-way communications with a requested resource. For example, the <code>CONNECT</code> method can access websites that use HTTPS via a proxy.</p>&#13;
<p class="indent">The <code>OPTIONS</code> method requests information from a server about the communication options available. For example, by calling for <code>OPTIONS</code>, you can find out whether the server accepts <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and <code>OPTIONS</code> calls. This method won’t indicate whether a server accepts <code>HEAD</code> or <code>TRACE</code> calls. Browsers automatically send this type of request for specific content types, such as <code>application/json</code>. This method, referred to as a <em>preflight</em> <span class="codeitalic">OPTIONS</span> <em>call</em>, is discussed more in depth in <a href="ch04.xhtml#ch04">Chapter 4</a> because it serves as a CSRF vulnerability protection.</p>&#13;
<h4 class="h4" id="ch01lev2sec8"><strong><em>HTTP Is Stateless</em></strong></h4>&#13;
<p class="noindent">HTTP requests are <em>stateless</em>, which means that every request sent to a server is treated as a brand-new request. The server knows nothing about its previous communication with your browser when receiving a request. This is problematic for most sites because the sites want to remember who you are. Otherwise, you’d have to reenter your username and password for every HTTP request sent. This also means that all the data required to process an HTTP request must be reloaded with every request a client sends to a server.</p>&#13;
<p class="indent">To clarify this confusing concept, consider this example: if you and I had a stateless conversation, before every sentence spoken, I’d have to start with “I’m Peter Yaworski; we were just discussing hacking.” You’d then have <span epub:type="pagebreak" id="page_9"/>to <em>reload</em> all the information about what we were discussing about hacking. Think of what Adam Sandler does for Drew Barrymore every morning in <em>50 First Dates</em> (if you haven’t seen the movie, you should).</p>&#13;
<p class="indent">To avoid having to resend your username and password for every HTTP request, websites use cookies or basic authentication, which we’ll discuss in detail in <a href="ch04.xhtml#ch04">Chapter 4</a>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The specifics of how content is encoded using base64 are beyond the scope of this book, but you’ll likely encounter base64-encoded content while you’re hacking. If so, you should always decode that content. A Google search for “base64 decode” should provide plenty of tools and methods for doing this.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch01lev1sec5"><strong>Summary</strong></h3>&#13;
<p class="noindent">You should now have a basic understanding of how the internet works. Specifically, you learned what happens when you enter a website into your browser’s address bar: how the browser translates that to a domain, how the domain is mapped to an IP address, and how an HTTP request is sent to a server.</p>&#13;
<p class="indent">You also learned how your browser structures requests and renders responses and how HTTP request methods allow clients to communicate with servers. Additionally, you learned that vulnerabilities result from someone performing an unintended action or gaining access to information otherwise not available and that bug bounties are rewards for ethically discovering and reporting vulnerabilities to the owners of websites.<span epub:type="pagebreak" id="page_10"/></p>&#13;
</body></html>