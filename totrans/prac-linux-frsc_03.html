<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_31"/><strong><span class="big">3</span><br/>EVIDENCE FROM STORAGE DEVICES AND FILESYSTEMS</strong></h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="190" height="189"/></div>&#13;
<p class="noindent">This chapter focuses on the forensic analysis of Linux storage, including partition tables, volume management and RAID, filesystems, swap partitions and hibernation, and drive encryption. Each of these areas have Linux-specific artifacts that we can analyze. You may be able to use commercial forensic tools to perform most of the activities shown here, but for illustrative purposes, the examples in this chapter use Linux tools.</p>&#13;
<p class="indent">When performing a forensic analysis of a computer system’s storage, the first step is to identify precisely what is on the drive. We must understand the layout, formats, versions, and configuration. After we have a high-level understanding of the drive contents, we can begin looking for other interesting forensic artifacts and data to examine or extract.</p>&#13;
<p class="indent">The filesystem forensic analysis shown in this chapter is described at a relatively high level compared to academic research papers and other literature in digital forensics. Here, I’ll describe file and filesystem metadata and information that could be useful for a forensic investigation. I’ll show how to list and extract files, and explore the likelihood of recovering deleted files <span epub:type="pagebreak" id="page_32"/>and slack. It is expected that the filesystems under analysis are in a (relatively) consistent state and that tools can parse the filesystem data structures. Corrupt, severely damaged, or partially wiped and overwritten filesystems require a different approach to analysis, which involves manually reassembling sectors or blocks into files for recovery and other low-level analysis techniques. That level of investigation is beyond the intended depth of this book. For an excellent resource on deeper filesystem analysis, I recommend Brian Carrier’s <em>File System Forensic Analysis</em>.</p>&#13;
<p class="indent">The “Filesystem Forensic Analysis" section in this chapter begins with a description of the structures common to all Unix-like filesystems, and it’s followed by a closer look at the most common filesystems used in Linux: ext4, xfs, and btrfs. These three filesystem sections have the following format:</p>&#13;
<ul>&#13;
<li class="noindent">History, overview, and features</li>&#13;
<li class="noindent">How to find and identify the filesystem</li>&#13;
<li class="noindent">Forensic artifacts in filesystem metadata (superblock)</li>&#13;
<li class="noindent">Forensic artifacts in the file metadata (inodes)</li>&#13;
<li class="noindent">Listing and extracting files</li>&#13;
<li class="noindent">Other unique features</li>&#13;
</ul>&#13;
<p class="indent">The analysis examples are shown using The Sleuth Kit (TSK), debugging and troubleshooting tools provided by the respective project teams, and various free and open source community projects. I use patched versions of TSK with btrfs and xfs support for some analysis examples.</p>&#13;
<p class="indent">The examples in this chapter use the naming convention <em>image.raw</em> for full drive images and <em>partimage.raw</em> for images of partitions (containing filesystems). Examples using partition images may work on full drive images if you specify the partition offset. Some tools work only with devices, not forensic image files. In those cases, a loopback device associated with the image file is created.</p>&#13;
<p class="indent">We are coming to the end of a “golden age” in filesystem forensics. On magnetic spinning disks, when deleted files are unlinked and blocks are unallocated, the data remains on the physical disk sectors. Forensic tools can “magically” recover these deleted files and fragments of partially overwritten files. However, today SSDs are accepting TRIM and DISCARD commands from the operating system that instruct the SSD firmware to erase unused blocks (for performance and efficiency reasons). Also, the flash translation layer (FTL) maps defective memory blocks to over-provisioned areas of storage that are not accessible through the standard hardware interfaces (SATA, SAS, or NVMe). Because of this, some traditional forensic techniques are becoming less effective at recovering data. Recovery techniques such as <em>chip-off</em>, where memory chips are de-soldered, require special equipment and training to perform. This chapter covers recovery of deleted files where it is still possible using software tools.</p>&#13;
<h3 class="h3" id="ch00lev1_9"><span epub:type="pagebreak" id="page_33"/><strong>Analysis of Storage Layout and Volume Management</strong></h3>&#13;
<p class="noindent">This section describes how to identify Linux partitions and volumes on storage media. I’ll show how to reconstruct or reassemble volumes that may contain filesystems and highlight traces of information interesting for an investigation.</p>&#13;
<h4 class="h4" id="ch00lev2_28"><strong><em>Analysis of Partition Tables</em></strong></h4>&#13;
<p class="noindent">Typical storage media are organized using a defined partition scheme. Common partition schemes include:</p>&#13;
<ul>&#13;
<li class="noindent">DOS/MBR (original PC partition scheme)</li>&#13;
<li class="noindent">GPT</li>&#13;
<li class="noindent">BSD</li>&#13;
<li class="noindent">Sun (vtoc)</li>&#13;
<li class="noindent">APM (Apple Partition Map)</li>&#13;
<li class="noindent">None (the absence of a partition scheme where filesystems start at sector zero)</li>&#13;
</ul>&#13;
<p class="noindent">DOS was the most popular partition scheme for many years, but GPT is becoming more common.</p>&#13;
<p class="indent">Partitions are defined with a partition table,<sup><a id="ch03foot01" href="footnotes.xhtml#ch03foot_01">1</a></sup> which provides information like the partition type, size, offset, and so on. Linux systems are often divided into partitions to create separate filesystems. Common partitions may contain the following:</p>&#13;
<div class="bqparan">&#13;
<table>&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:80%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong>/</strong></td>&#13;
<td style="vertical-align: top">Operating system installation and root mount</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong>ESP</strong></td>&#13;
<td style="vertical-align: top">The EFI system partition (FAT) used for UEFI booting</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong>swap</strong></td>&#13;
<td style="vertical-align: top">Used for paging, swapping, and hibernation</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong><em>/boot/</em></strong></td>&#13;
<td style="vertical-align: top">Bootloader information, kernels, and initial ram disks</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong><em>/usr/</em></strong></td>&#13;
<td style="vertical-align: top">Sometimes used for read-only filesystem of system files</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong><em>/var/</em></strong></td>&#13;
<td style="vertical-align: top">Sometimes used for variable or changing system data</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong><em>/home/</em></strong></td>&#13;
<td style="vertical-align: top">User home directories</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
<p class="noindent">The default partition and filesystem layout differs for each Linux distro, and the user is given the chance to customize it during installation.</p>&#13;
<p class="indent">From a digital forensics perspective, we want to identify the partition scheme, analyze the partition tables, and look for possible inter-partition gaps. The analysis of DOS and GPT<sup><a id="ch03foot02" href="footnotes.xhtml#ch03foot_02">2</a></sup> partition tables is independent of the installed operating system. All commercial forensic tools can analyze Linux <span epub:type="pagebreak" id="page_34"/>system partition tables. We will focus here on the artifacts that are specific to Linux.</p>&#13;
<p class="indent">A DOS partition table entry allocates one byte for the partition type. No authoritative standards body defines DOS partition types; however, a community effort to maintain a list of known partition types is located at <em><a href="https://www.win.tue.nl/~aeb/partitions/partition_types-1.html">https://www.win.tue.nl/~aeb/partitions/partition_types-1.html</a></em> (the UEFI specification even links to this site). Some common Linux partition types you might find are:</p>&#13;
<div class="bqpara">&#13;
<table>&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:80%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong>0x83</strong></td>&#13;
<td style="vertical-align: top">Linux</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong>0x85</strong></td>&#13;
<td style="vertical-align: top">Linux extended</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong>0x82</strong></td>&#13;
<td style="vertical-align: top">Linux swap</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong>0x8E</strong></td>&#13;
<td style="vertical-align: top">Linux LV</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong>0xE8</strong></td>&#13;
<td style="vertical-align: top">LUKS (Linux Unified Key Setup)</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong>0xFD</strong></td>&#13;
<td style="vertical-align: top">Linux RAID auto</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
<p class="noindent">The 0x prefix denotes that the partition types are in hexadecimal format. Linux installations typically have one or more <em>primary</em> partitions, which are traditional partition table entries. A single <em>extended</em> partition (type 0x05 or 0x85) may also exist and contain additional <em>logical</em> partitions.<sup><a id="ch03foot03" href="footnotes.xhtml#ch03foot_03">3</a></sup></p>&#13;
<p class="indent">A GPT partition table entry allocates 16 bytes for the partition GUID. The UEFI specification states: “OS vendors need to generate their own Partition Type GUIDs to identify their partition types.” The Linux Discoverable Partitions Specification (<em><a href="https://systemd.io/DISCOVERABLE_PARTITIONS/">https://systemd.io/DISCOVERABLE_PARTITIONS/</a></em>) defines several Linux GUID partition types, but it is not complete. See the systemd-id128(1) man page about listing known GUIDs with the <span class="literal">systemd-id128</span> <span class="literal">show</span> command. Some Linux GPT partition types you might find for a GPT partition scheme include:</p>&#13;
<div class="bqpara">&#13;
<table>&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:80%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong>Linux swap</strong></td>&#13;
<td style="vertical-align: top">0657FD6D-A4AB-43C4-84E5-0933C84B4F4F</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong>Linux filesystem</strong></td>&#13;
<td style="vertical-align: top">0FC63DAF-8483-4772-8E79-3D69D8477DE4</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong>Linux root (x86-64)</strong></td>&#13;
<td style="vertical-align: top">4F68BCE3-E8CD-4DB1-96E7-FBCAF984B709</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong>Linux RAID</strong></td>&#13;
<td style="vertical-align: top">A19D880F-05FC-4D3B-A006-743F0F84911E</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong>Linux LVM</strong></td>&#13;
<td style="vertical-align: top">E6D6D379-F507-44C2-A23C-238F2A3DF928</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong>Linux LUKS</strong></td>&#13;
<td style="vertical-align: top">CA7D7CCB-63ED-4C53-861C-1742536059CC</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
<p class="noindent">Don’t confuse the standard defined GUID of the partition type with the randomly generated GUID that is unique to a particular partition or filesystem.</p>&#13;
<p class="indent">During a forensic examination, DOS or GPT partition types may indicate the contents. But beware, users can define any partition type they want and then create a completely different filesystem. The partition type is used as an indicator for various tools, but there is no guarantee that it will be correct. If a partition type is incorrect and misleading, it could be an attempt to <span epub:type="pagebreak" id="page_35"/>hide or obfuscate information (similar to trying to hide a file type by changing the file extension).</p>&#13;
<p class="indent">On a Linux system, detected partitions appear in the <em>/dev/</em> directory. This is a mounted pseudo-directory on a running system. In a postmortem forensic examination, this directory will be empty, but the device names may still be found in logs, referenced in configuration files, or found elsewhere in files on the filesystem. A brief review of storage devices (including partitions) is provided here.</p>&#13;
<p class="indent">The most common storage drives used with Linux are SATA, SAS, NVMe, and SD cards. These block devices are represented in the <em>/dev/</em> directory of a running system as follows:</p>&#13;
<ul>&#13;
<li class="noindent"><em>/dev/sda</em>, <em>/dev/sdb</em>, <em>/dev/sdc</em>, . . .</li>&#13;
<li class="noindent"><em>/dev/nvme0n1</em>, <em>/dev/nvme1n1</em>, . . .</li>&#13;
<li class="noindent"><em>/dev/mmcblk0</em>, <em>mmcblk1</em>, . . .</li>&#13;
</ul>&#13;
<p class="indent">There is one device file per drive. SATA and SAS drives are represented alphabetically (sda, sdb, sdc, . . .). NVMe drives are represented numerically; the first number is the drive, and the second <em>n</em> number is the namespace.<sup><a id="ch03foot04" href="footnotes.xhtml#ch03foot_04">4</a></sup> SD cards are also represented numerically (mmcblk0, mmcblk1, . . .).</p>&#13;
<p class="indent">If a Linux system detects partitions on a particular drive, additional device files are created to represent those partitions. The naming convention usually adds an additional number to the drive or the letter <em>p</em> with a number; for example:</p>&#13;
<ul>&#13;
<li class="noindent"><em>/dev/sda1</em>, <em>/dev/sda2</em>, <em>/dev/sda3</em>, . . .</li>&#13;
<li class="noindent"><em>/dev/nvme0n1p1</em>, <em>/dev/nvme0n1p2</em>, . . .</li>&#13;
<li class="noindent"><em>/dev/mmcblk0p1</em>, <em>/dev/mmcblk0p2</em>, . . .</li>&#13;
</ul>&#13;
<p class="indent">If commercial tools are unable to properly analyze Linux partition tables or if you want additional analysis results, several Linux tools are available, including <span class="literal">mmls</span> (from TSK) and <span class="literal">disktype</span>.</p>&#13;
<p class="indent">Here is an example of TSK’s <span class="literal">mmls</span> command output of a Manjaro Linux partition table:</p>&#13;
<pre>$ <span class="codestrong1">mmls image.raw</span>&#13;
DOS Partition Table&#13;
Offset Sector: 0&#13;
Units are in 512-byte sectors&#13;
&#13;
       Slot   Start       End         Length      Description&#13;
000:   Meta   0000000000  0000000000  0000000001  Primary Table (#0)&#13;
001: -------  0000000000  0000002047  0000002048  Unallocated&#13;
002: 000:000  0000002048  0024188109  0024186062  Linux (0x83)&#13;
003: 000:001  0024188110  0041929649  0017741540  Linux Swap / Solaris x86 (0x82)&#13;
004: -------  0041929650  0041943039  0000013390  Unallocated</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_36"/>The <span class="literal">mmls</span> tool lists different “slots,” which can be partition metadata, unallocated areas (including inter-partition gaps), and the actual partitions. The start, end, and length of the partitions is shown in 512-byte sectors. This example presents a traditional DOS partition scheme, a Linux partition (0x83) at sector 2048, and a swap partition immediately following. The last 13390 sectors are not allocated to any partition.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Be careful with your units. Some tools use sectors; others use bytes.</em></p>&#13;
</div>&#13;
<p class="indent">Next, let’s consider an example of the <span class="literal">disktype</span> output of a Linux Mint partition table:</p>&#13;
<pre>   # <span class="codestrong1">disktype /dev/sda</span>&#13;
&#13;
   --- /dev/sda&#13;
   Block device, size 111.8 GiB (120034123776 bytes)&#13;
   DOS/MBR partition map&#13;
<span class="ent">➊</span> Partition 1: 111.8 GiB (120034123264 bytes, 234441647 sectors from 1)&#13;
     Type 0xEE (EFI GPT protective)&#13;
   GPT partition map, 128 entries&#13;
     Disk size 111.8 GiB (120034123776 bytes, 234441648 sectors)&#13;
     Disk GUID 11549728-F37C-C943-9EA7-A3F9F9A8D071&#13;
   Partition 1: 512 MiB (536870912 bytes, 1048576 sectors from 2048)&#13;
  <span class="ent">➋</span> Type EFI System (FAT) (GUID 28732AC1-1FF8-D211-BA4B-00A0C93EC93B)&#13;
     Partition Name "EFI System Partition"&#13;
     Partition GUID EB66AA4C-4840-1E44-A777-78B47EC4936A&#13;
     FAT32 file system (hints score 5 of 5)&#13;
       Volume size 511.0 MiB (535805952 bytes, 130812 clusters of 4 KiB)&#13;
   Partition 2: 111.3 GiB (119495720960 bytes, 233390080 sectors from 1050624)&#13;
     Type Unknown (GUID AF3DC60F-8384-7247-8E79-3D69D8477DE4)&#13;
  <span class="ent">➌</span> Partition Name ""&#13;
     Partition GUID A6EC4415-231A-114F-9AAD-623C90548A03&#13;
     Ext4 file system&#13;
       UUID 9997B65C-FF58-4FDF-82A3-F057B6C17BB6 (DCE, v4)&#13;
       Last mounted at "/"&#13;
       Volume size 111.3 GiB (119495720960 bytes, 29173760 blocks of 4 KiB)&#13;
   Partition 3: unused</pre>&#13;
<p class="noindent">In this output, the GPT partition is shown <span class="ent">➊</span> with a protective MBR (<span class="literal">Type</span> <span class="literal">0xEE</span>). Partition 1 is the EFI FAT partition <span class="ent">➋</span>, and the UUID (<span class="literal">GUID</span>) is recognized. The UUID of Partition 2 <span class="ent">➌</span> is not recognized by <span class="literal">disktype</span>, but it detects the filesystem and shows some information about it.</p>&#13;
<p class="indent">The format of GPT UUIDs presented by tools may vary and appear different from the format stored on disk. For example, here is the Linux GPT partition type <span class="literal">0FC63DAF-8483-4772-8E79-3D69D8477DE4</span> displayed by several different tools:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><span class="codestrong">fdisk/gdisk</span> <span class="literal">0FC63DAF-8483-4772-8E79-3D69D8477DE4</span></p>&#13;
<p class="noindentin"><span class="codestrong">disktype</span> <span class="literal">AF3DC60F-8384-7247-8E79-3D69D8477DE4</span></p>&#13;
<p class="noindentin"><span epub:type="pagebreak" id="page_37"/><span class="codestrong">hexedit</span> <span class="literal">AF 3D C6 0F 83 84 72 47 8E 79 3D 69 D8 47 7D E4</span></p>&#13;
<p class="noindentin"><span class="codestrong">xxd</span> <span class="literal">af3d c60f 8384 7247 8e79 3d69 d847 7de4</span></p>&#13;
</div>&#13;
<p class="indent">The GPT UUID has a defined structure, and parts of it are stored on disk in little-endian form. The UEFI specification (<a href="app01.xhtml">Appendix A</a>) describes the EFI GUID format in detail (<em><a href="https://uefi.org/sites/default/files/resources/UEFI_Spec_2_8_final.pdf">https://uefi.org/sites/default/files/resources/UEFI_Spec_2_8_final.pdf</a></em>). Some tools (<span class="literal">disktype</span> or hex dump tools, for example) may display the raw bytes written to disk rather than interpreting the bytes as a GPT UUID.</p>&#13;
<h4 class="h4" id="ch00lev2_29"><strong><em>Logical Volume Manager</em></strong></h4>&#13;
<p class="noindent">Modern operating systems provide volume management for organizing and managing groups of physical drives, allowing the flexibility to create logical (virtual) drives that contain partitions and filesystems. Volume management can be a separate subsystem like <em>Logical Volume Manager (LVM)</em> or it can be built directly into the filesystem as in btrfs or zfs.</p>&#13;
<p class="indent">The examples in this section cover a simplified LVM setup with a single physical storage device. This will be enough to analyze many distros that install LVM by default on one hard drive. More complex scenarios involving multiple drives will require forensic tools that support LVM volumes or a Linux forensic analysis machine able to access and assemble LVM volumes. You can still use forensic tools without LVM support if the filesystem is written as a linear sequence of sectors on a single disk and the starting offset of the filesystem is known.</p>&#13;
<p class="indent">The most common volume manager in Linux environments is LVM. <a href="ch03.xhtml#ch03fig01">Figure 3-1</a> shows the high-level architecture.</p>&#13;
<div class="image"><img id="ch03fig01" src="Images/ch03fig01.jpg" alt="Image" width="695" height="265"/></div>&#13;
<p class="figcap"><em>Figure 3-1: Logical Volume Manager</em></p>&#13;
<p class="indent">LVM systems have several key concepts:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong>Physical volume (PV)</strong> Physical storage device (SATA, SAS, and NVMe drives)</p>&#13;
<p class="noindentin"><strong>Volume group (VG)</strong> Created from a group of PVs</p>&#13;
<p class="noindentin"><strong>Logical volume (LV)</strong> Virtual storage device within a VG</p>&#13;
<p class="noindentin"><span epub:type="pagebreak" id="page_38"/><strong>Physical extents (PEs)</strong> Sequence of consecutive sectors in a PV</p>&#13;
<p class="noindentin"><strong>Logical extents (LEs)</strong> Sequence of consecutive sectors in an LV</p>&#13;
</div>&#13;
<p class="indent">In the context of LVM, extents are similar to traditional filesystem blocks, and they have a fixed size defined at creation. A typical default LVM extent size is 8192 sectors (4MB) and is used for both PEs and LEs. LVM is also able to provide redundancy and stripping for logical volumes.</p>&#13;
<p class="indent">The use of partition tables is not required for LVM, and PVs can be created directly on the raw disk without a partition. When partitions are used, LVM has a partition entry type indicating that the physical drive is a PV. For a DOS partition scheme, the LVM partition code is <span class="literal">0x8E</span>. For GPT, the UUID of an LVM partition is <span class="literal">E6D6D379-F507-44C2-A23C-238F2A3DF928</span> (some tools may display the bytes in the order they are stored on disk: <span class="literal">D3 79 E6 D6 F5 07 44 C2</span> <span class="literal">3C A2 8F 23 3D 2A 28 F9</span>). Here’s an example partition table:</p>&#13;
<pre>$ <span class="codestrong1">sudo mmls /dev/sdc</span>&#13;
DOS Partition Table&#13;
Offset Sector: 0&#13;
Units are in 512-byte sectors&#13;
&#13;
     Slot     Start       End         Length      Description&#13;
000: Meta     0000000000  0000000000  0000000001  Primary Table (#0)&#13;
001: -------  0000000000  0000002047  0000002048  Unallocated&#13;
002: 000:000  0000002048  0002099199  0002097152  Linux (0x83)&#13;
003: 000:001  0002099200  0117231407  0115132208  Linux Logical Volume Manager (0x8e)</pre>&#13;
<p class="noindent">In this example, <span class="literal">mmls</span> displays a DOS partition table, and an LVM partition is detected at sector 2099200, taking up much of the drive.</p>&#13;
<p class="indent">Information about the PV is written to a 32-byte label header in the second sector of the LVM partition (sector 1). This label contains:</p>&#13;
<ul>&#13;
<li class="noindent">LVM ID with the string <span class="literal">LABELONE</span> (8 bytes)</li>&#13;
<li class="noindent">Sector in the partition where this label resides (8 bytes)</li>&#13;
<li class="noindent">CRC checksum of the rest of this sector (4 bytes)</li>&#13;
<li class="noindent">Byte offset of the start of content (4 bytes)</li>&#13;
<li class="noindent">LVM type with the string <span class="literal">LVM2 001</span> (8 bytes)</li>&#13;
<li class="noindent">PV UUID (16 bytes)</li>&#13;
</ul>&#13;
<p class="noindent">Here is an example hexdump of the LVM label at the start (second sector) of the LVM partition:</p>&#13;
<pre>40100200  4C 41 42 45 4C 4F 4E 45 01 00 00 00 00 00 00 00 LABELONE........&#13;
40100210  53 BF 78 2F 20 00 00 00 4C 56 4D 32 20 30 30 31 S.x/ ...LVM2 001&#13;
40100220  55 77 37 73 73 53 4A 61 50 36 67 43 44 42 4D 61 Uw7ssSJaP6gCDBMa&#13;
40100230  51 32 4A 57 39 32 71 6F 66 71 59 47 56 57 6F 68 Q2JW92qofqYGVWoh&#13;
...</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_39"/>You need the lvm2 software package to manage LVM volumes. It has a number of tools that can assist in performing forensic analysis of attached LVM drives, including the lvm(8) man page that describes the LVM system in more detail.</p>&#13;
<p class="indent">The LVM tools operate on devices, not plain files. To examine an LVM setup on a Linux forensic analysis workstation, the suspect drive must be attached with a write blocker or as a read-only acquired image file associated with a loop device (see the “Devices” subsection in <a href="ch02.xhtml">Chapter 2</a>). In these examples, the suspect LVM drive is the <em>/dev/sdc</em> device on the forensic analysis machine.</p>&#13;
<p class="indent">The <span class="literal">pvdisplay</span> tool provides information about the PVs. The <span class="literal">--foreign</span> flag includes volumes that would normally be skipped and <span class="literal">--readonly</span> reads data directly from the disk (ignoring the kernel device mapper driver):</p>&#13;
<pre>$ <span class="codestrong1">sudo pvdisplay --maps --foreign --readonly</span>&#13;
  --- Physical volume ---&#13;
  PV Name               /dev/sdc2&#13;
  VG Name               mydisks&#13;
  PV Size               &lt;54.90 GiB / not usable &lt;4.90 MiB&#13;
  Allocatable           yes&#13;
  PE Size               4.00 MiB&#13;
  Total PE              14053&#13;
  Free PE               1&#13;
  Allocated PE          14052&#13;
  PV UUID               Uw7ssS-JaP6-gCDB-MaQ2-JW92-qofq-YGVWoh&#13;
&#13;
  --- Physical Segments ---&#13;
...&#13;
  Physical extent 1024 to 14051:&#13;
    Logical volume     /dev/mydisks/root&#13;
    Logical extents    0 to 13027&#13;
...</pre>&#13;
<p class="noindent">This output shows information about a single physical volume (<span class="literal">sdc2</span>), including the PE size, the number of PEs in the volume, and information about the extents. The LVM UUIDs are not in a standard hexadecimal format; rather, they are a randomly generated string with 0–9, a–z, and A–Z characters.</p>&#13;
<p class="indent">You can use the <span class="literal">lvdisplay</span> tool to query for information about logical volumes. The <span class="literal">--maps</span> flag provides additional details about the segments and extents:</p>&#13;
<pre>$ <span class="codestrong1">sudo lvdisplay --maps --foreign --readonly</span>&#13;
...&#13;
   --- Logical volume ---&#13;
   LV Path                /dev/mydisks/root&#13;
   LV Name                root&#13;
   VG Name                mydisks&#13;
   LV UUID                uecfOf-3E0x-ohgP-IHyh-QPac-IaKl-HU1FMn&#13;
   <span epub:type="pagebreak" id="page_40"/>LV Write Access        read/write&#13;
<span class="ent">➊</span> LV Creation host, time pc1, 2020-12-02 20:45:45 +0100&#13;
   LV Size                50.89 GiB&#13;
   Current LE             13028&#13;
   Segments               1&#13;
   Allocation             inherit&#13;
   Read ahead sectors     auto&#13;
&#13;
   --- Segments ---&#13;
   Logical extents 0 to 13027:&#13;
  <span class="ent">➋</span> Type                linear&#13;
     Physical volume     /dev/sdc2&#13;
     Physical extents    1024 to 14051</pre>&#13;
<p class="noindent">The <span class="literal">Type linear</span> line <span class="ent">➋</span> indicates that the volume resides on the disk as a consecutive sequence of sectors (like an LBA). In a linear single disk configuration, we only need to find the offset of the start of the filesystem, and then we can operate on it using forensic tools that don’t support LVM. Also interesting from a forensics perspective is the hostname where the logical volume was created and the creation timestamp of the volume <span class="ent">➊</span> .</p>&#13;
<p class="indent">Information about extents helps us find (calculate) the first sector of the filesystem. The partition table above (<span class="literal">mmls</span> output) shows that the LVM partition starts at sector 2099200. The first PE is 2048 sectors from the start of the LVM partition.<sup><a id="ch03foot05" href="footnotes.xhtml#ch03foot_05">5</a></sup> The <span class="literal">pvdisplay</span> output shows that the LVM extent size is 8192 sectors (<span class="literal">PE Size 4.00 MiB</span>), and the <span class="literal">lvdisplay</span> output shows that the root volume starts at extent 1024. From all of this, we can determine the filesystem sector offset from the beginning of the drive:</p>&#13;
<p class="indenttt">2099200 + 2048 + (8192 * 1024) = 10489856</p>&#13;
<p class="indent">For a linear single disk LVM system in which the filesystem is stored as a continuous sequence of sectors, we can use standard forensic tools by using this sector offset from the beginning of the physical drive. Here is an example with TSK:</p>&#13;
<pre>$ <span class="codestrong1">sudo fsstat -o 10489856 /dev/sdc</span>&#13;
FILE SYSTEM INFORMATION&#13;
--------------------------------------------&#13;
File System Type: Ext4&#13;
Volume Name:&#13;
Volume ID: 6d0edeac50c97b979148918692af1e0b&#13;
...</pre>&#13;
<p class="noindent">The TSK command <span class="literal">fsstat</span> provides information about filesystems. In this example, an ext4 filesystem was found at the offset calculated within the <span epub:type="pagebreak" id="page_41"/>LVM partition. An alternative to calculating the start of the filesystem is to search for the start of the filesystem exhaustively (using tools like <span class="literal">gpart</span>, for example). You can use the <span class="literal">vgdisplay</span> and <span class="literal">pvs</span> commands with one or more <span class="literal">-v</span> flags for additional verbose information about volume groups and physical volumes.</p>&#13;
<p class="indent">LVM also has the ability to perform <em>copy-on-write (CoW)</em> snapshots. These can be interesting from a forensics perspective, as snapshots of volumes may exist from a previous point in time. On running systems, the volumes can be “frozen” in a snapshot for analysis or even acquisition.</p>&#13;
<h4 class="h4" id="ch00lev2_30"><strong><em>Linux Software RAID</em></strong></h4>&#13;
<p class="noindent">In the early days of enterprise computing, it was discovered that groups of hard disks could be configured to work in parallel for improved reliability and performance. This concept became known as a <em>redundant array of independent disks</em>, or <em>RAID</em>.<sup><a id="ch03foot06" href="footnotes.xhtml#ch03foot_06">6</a></sup> Several terms are used to describe RAID configurations. <em>Mirror</em> refers to two disks that are mirror images of each other. <em>Striped</em> refers to stripes of data spread across multiple disks for performance (multiple disks can be read from and written to simultaneously). <em>Parity</em> is a computer science term for an extra bit of data used for error detection and/or correction.</p>&#13;
<p class="indent">A RAID has different levels that describe how a group of disks work together:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong>RAID</strong> Striped for performance, no redundancy</p>&#13;
<p class="noindentin"><strong>RAID1</strong> Mirrored disks for redundancy, half the capacity but up to half of the disks can fail</p>&#13;
<p class="noindentin"><strong>RAID2,3,4,5</strong> Variations of parity allowing a single disk to fail</p>&#13;
<p class="noindentin"><strong>RAID6</strong> Double parity allowing up to two disks to fail</p>&#13;
<p class="noindentin"><strong>RAID10</strong> Mirrored and striped (“1 + 0”) for maximum redundancy and performance</p>&#13;
<p class="noindentin"><strong>JBOD</strong> “Just a Bunch Of Disks” concatenated, no redundancy or performance, maximum capacity</p>&#13;
</div>&#13;
<p class="noindent">Organizations choose a RAID level based on a balance of cost, performance, and reliability.</p>&#13;
<p class="indent">Some commercial forensic tools may support the reassembly and analysis of Linux RAID systems. If not, the forensic images can be transferred to a Linux machine for analysis. My previous book, <em>Practical Forensic Imaging</em> (No Starch Press, 2016), explains how to create a forensic image of various RAID systems, including Linux. In this section, we’ll assume that the individual drives were forensically acquired and available as read-only image files or directly attached to an analysis system with write blockers. It is important to ensure that the disks or images are read-only, or the analysis system may auto-detect <span epub:type="pagebreak" id="page_42"/>the RAID partitions and attempt to reassemble, resync, or rebuild the RAID.</p>&#13;
<p class="indent">RAID capability in Linux can be provided by <span class="literal">md</span> (multiple device driver, or Linux Software RAID), the LVM, or built in to the filesystem (btrfs and zfs have integrated RAID capability, for example).</p>&#13;
<p class="indent">The most commonly used method of RAID (and the focus of this chapter) is the Linux software RAID or <span class="literal">md</span>. This kernel module produces a meta device from a configured array of disks. You can use the <span class="literal">mdadm</span> userspace tool to configure and manage the RAID. The rest of this section describes forensic artifacts found in a typical <span class="literal">md</span> RAID system. See the md(4) man page for more information about <span class="literal">md</span> devices.</p>&#13;
<p class="indent">A disk used in a RAID may have a partition table with standard Linux RAID partition types. For GPT partition tables, the GUID for Linux RAID is <span class="literal">A19D880F-05FC-4D3B-A006-743F0F84911E</span> (or <span class="literal">0F889DA1-FC05-3B4D-A006-743F0F84911E</span> as bytes written on disk).</p>&#13;
<p class="indent">For DOS/MBR partition tables, the partition type for Linux RAID is 0xFD. A forensic tool will find these partitions on each disk that is part of a RAID system.</p>&#13;
<p class="indent">Each device from a Linux RAID system has a <em>superblock</em> (not to be confused with filesystem superblocks, which are different) that contains information about the device and the array. The default location of the <span class="literal">md</span> superblock on a modern Linux RAID device is eight sectors from the start of the partition. We can identify it by the magic string 0xA92B4EFC. You can examine this superblock information with a hex editor or the <span class="literal">mdadm</span> command, as follows:</p>&#13;
<pre>   # <span class="codestrong1">mdadm --examine /dev/sda1</span>&#13;
   /dev/sda1:&#13;
             Magic : a92b4efc&#13;
           Version : 1.2&#13;
       Feature Map : 0x0&#13;
<span class="ent">➊</span> Array UUID : 1412eafa:0d1524a6:dc378ce0:8361e245&#13;
           <span class="ent">➋</span> Name : My Big Storage&#13;
  <span class="ent">➌</span> Creation Time : Sun Nov 22 13:48:35 2020&#13;
        Raid Level : raid5&#13;
      Raid Devices : 3&#13;
&#13;
    Avail Dev Size : 30270751 (14.43 GiB 15.50 GB)&#13;
        Array Size : 30270464 (28.87 GiB 31.00 GB)&#13;
     Used Dev Size : 30270464 (14.43 GiB 15.50 GB)&#13;
       Data Offset : 18432 sectors&#13;
      Super Offset : 8 sectors&#13;
      Unused Space : before=18280 sectors, after=287 sectors&#13;
             State : clean&#13;
    <span class="ent">➍</span> Device UUID : 79fde003:dbf203d5:521a3be5:6072caa6&#13;
&#13;
    <span class="ent">➎</span> Update Time : Sun Nov 22 14:02:44 2020&#13;
     Bad Block Log : 512 entries available at offset 136 sectors&#13;
          <span epub:type="pagebreak" id="page_43"/>Checksum : 8f6317ee - correct&#13;
            Events : 4&#13;
&#13;
            Layout : left-symmetric&#13;
        Chunk Size : 512K&#13;
&#13;
       Device Role : Active device 0&#13;
       Array State : AAA ('A' == active, '.' == missing, 'R' == replacing)</pre>&#13;
<p class="noindent">This output contains several artifacts that may be of interest in a forensic examination. <span class="literal">Array UUID</span> <span class="ent">➊</span> will identify the overall RAID system, and each disk belonging to this RAID (including previously replaced disks) will have this same UUID string in its superblock. <span class="literal">Name</span> (<span class="literal">My Big Storage</span>) <span class="ent">➋</span> can be specified by the administrator or auto-generated. <span class="literal">Device UUID</span> <span class="ent">➍</span> uniquely identifies the individual disks. The creation timestamp <span class="ent">➌</span> refers to the creation date of the array (a newly replaced disk will inherit the original array’s creation date). <span class="literal">Update Time</span> <span class="ent">➎</span> refers to the last time the superblock was updated due to some filesystem event.</p>&#13;
<p class="indent">The disks in an array might not all be identical sizes. For a forensic examination, this can be important. In this example, three devices are each using 15.5GB to produce a 31GB RAID5 array. However, the device shown here (sdc) is 123.6GB in size:</p>&#13;
<pre># <span class="codestrong1">mdadm --examine /dev/sdc1</span>&#13;
/dev/sdc1:&#13;
...&#13;
 Avail Dev Size : 241434463 (115.12 GiB 123.61 GB)&#13;
     Array Size : 30270464 (28.87 GiB 31.00 GB)&#13;
 Used Dev Size : 30270464 (14.43 GiB 15.50 GB)&#13;
   Data Offset : 18432 sectors&#13;
...</pre>&#13;
<p class="noindent">The device in this example is significantly larger than the size of the other members of the array, which indicates that more than 100GB of untouched data is on this drive. This area can be forensically examined for previously stored data.</p>&#13;
<p class="indent">The array device is typically in the form <span class="literal">/dev/md#</span>, <span class="literal">/dev/md/#</span>, or <span class="literal">/dev/md/</span><em>NAME</em>, where the system administrator can specify <span class="literal">#</span> or <em>NAME</em> at creation. These Linux kernel devices will exist only on a running system, but in a postmortem forensic examination, they may be found in the logs; for example:</p>&#13;
<pre>Nov 22 11:48:08 pc1 kernel: md/raid:md0: Disk failure on sdc1, disabling device.&#13;
                            md/raid:md0: Operation continuing on 2 devices.&#13;
...&#13;
Nov 22 12:00:54 pc1 kernel: md: recovery of RAID array md0</pre>&#13;
<p class="noindent">Here, one disk in a RAID5 system has failed, and the kernel produced a message that was subsequently saved in the journal. After the failed disk was replaced, a kernel message about the recovery was generated.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_44"/>The kernel should automatically scan and recognize Linux RAID devices on boot. However, they can also be defined in separate configuration files. During an examination involving RAID systems, check for uncommented <span class="literal">DEVICE</span> or <span class="literal">ARRAY</span> lines in the <em>/etc/mdadm.conf</em> file (or files in <em>/etc/ mdadm.conf.d/</em>). See the mdadm.conf(5) man page for more information.</p>&#13;
<p class="indent">If previously failed disks can be physically located, they may still be readable. Failed or replaced disks contain a snapshot of data at a certain point in time and may be relevant to a forensic investigation.</p>&#13;
<p class="indent">The future of traditional RAID in enterprise IT environments is being influenced by multiple factors. Large commodity disks (18TB disks are available as of this writing) need more time to resync and rebuild. In some cases, this could take days to complete depending on the size and speed of the disks. There is a shift toward clusters of inexpensive PCs (like a RAID of PCs) that use data replication for performance and redundancy. The use of SSDs instead of spinning magnetic disks also reduces the risk of failure (no moving mechanical parts).</p>&#13;
<h3 class="h3" id="ch00lev1_10"><strong>Filesystem Forensic Analysis</strong></h3>&#13;
<p class="noindent">This section provides an introduction to filesystem concepts common to all Unix-like filesystems. The analysis examples use TSK for illustration, but all of the techniques should be possible with popular commercial digital forensic tools. Linux supports dozens of filesystems, and the analysis approach shown here can be applied to most of them.</p>&#13;
<h4 class="h4" id="ch00lev2_31"><strong><em>Linux Filesystem Concepts</em></strong></h4>&#13;
<p class="noindent">The concept of filesystems is central and fundamental in Unix and Linux. When Ken Thompson began creating the first version of Unix, he made the filesystem first and developed the concept of “everything is a file.” This idea allows everything to be accessible through files in a filesystem tree, including hardware devices, processes, kernel data structures, networking, interprocess communication, and, of course, regular files and directories.</p>&#13;
<p class="indent">The fundamental file types described by POSIX are discussed in the next chapter and include regular files, directories, symbolic links, named pipes, devices, and sockets. When I refer to file types in this chapter, I am referring to Unix filesystem and POSIX file types rather than application file types like images, videos, or office documents.</p>&#13;
<p class="indent">Hard disk drives and SSDs have integrated electronics that create an abstraction of a contiguous sequence of sectors (logical block access, or LBA). Partitions on a drive may contain filesystems, which are located at a known offset from sector zero. A filesystem uses a contiguous group of sectors to form a block (typically 4KB in size). A collection of one or more blocks (not necessarily contiguous) forms the data contents of files.</p>&#13;
<p class="indent">Each file is assigned a number (unique within a filesystem) called an <em>inode</em>. The blocks allocated to each file and other metadata (permissions, timestamps, and so on) are stored in an <em>inode table</em>. The names of files are <span epub:type="pagebreak" id="page_45"/>not defined in the inode, but are rather listed as entries in a <em>directory file</em>. These directory entries link a filename to an inode and create the illusion of a filesystem tree structure. The familiar full file “path” with directories (<em>/some/path/file.txt</em>) is not stored anywhere, but is calculated by traversing the linked directory filenames between the file and the root (/) directory.</p>&#13;
<p class="indent">The allocation state of blocks and inodes is stored in bitmaps and updated when files are created or deleted. <a href="ch03.xhtml#ch03fig02">Figure 3-2</a> illustrates these layers of abstraction.</p>&#13;
<div class="image"><img id="ch03fig02" src="Images/ch03fig02.jpg" alt="Image" width="692" height="876"/></div>&#13;
<p class="figcap"><em>Figure 3-2: Filesystem abstractions. (This is a simplified view and doesn’t include block groups, redundancy, scalability, and other special features.)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_46"/>Traditional filesystems were designed in the days of rotating magnetic platters with read/write heads attached to mechanical arms. Performance optimization and fault tolerance was necessary, and was achieved by grouping blocks and inodes across a disk.</p>&#13;
<p class="indent">Some of the original filesystem design decisions (for example, performance optimization related to mechanical spinning platters and seeking drive heads) are unnecessary with SSDs, but they continue to exist today. Modern filesystems have additional features, such as journaling, to ensure data consistency in the event of a crash, or they use <em>extents</em> (ranges of contiguous blocks) instead of a list of individual allocated blocks for a file. In addition, each filesystem may have its own unique features and attributes that can be interesting in a digital forensic context (for example, ext4 has a last mounted timestamp and path).</p>&#13;
<p class="indent">Network filesystems (NFS, CIFS/Samba, and so on), FUSE, and pseudo-filesystems (<em>/proc/</em>, <em>/sys/</em>, and so on) have a similar tree/file representation to other filesystems. However, these are outside the scope of this book as they cannot be analyzed postmortem like physical storage.</p>&#13;
<p class="indent">Most filesystems in the Unix and Linux world follow the same general design concepts, which makes it easier to apply the same digital forensic analysis methods to multiple filesystems.</p>&#13;
<h4 class="h4" id="ch00lev2_32"><strong><em>Forensic Artifacts in Linux Filesystems</em></strong></h4>&#13;
<p class="noindent">The first step in filesystem analysis is identifying what filesystem is being examined. As explained earlier, the partition tables can provide some hints, but having correct partition types is not a requirement; thus, a more reliable method is needed.</p>&#13;
<p class="indent">Most filesystems can be identified by a few bytes at the beginning of the filesystem called a <em>magic string</em> or <em>signature</em>. If your forensic tools can’t automatically determine a filesystem, you can search for this signature manually (using TSK’s <span class="literal">sigfind</span> command, for example). The filesystem’s specification defines this magic number. You can also use other tools such as <span class="literal">disktype</span> or TSK’s <span class="literal">fsstat</span> to identify a filesystem. If a known magic string is located at an expected offset in a partition, it is a good indicator of the existence of that filesystem.</p>&#13;
<p class="indent">The <em>superblock</em> is the filesystem metadata that describes the overall filesystem. Depending on the filesystem, this may contain items of forensic interest, including:</p>&#13;
<ul>&#13;
<li class="noindent">Label or volume name specified by the system owner</li>&#13;
<li class="noindent">Unique identifier (UUID/GUID)</li>&#13;
<li class="noindent">Timestamps (filesystem creation, last mount, last write, and last checked)</li>&#13;
<li class="noindent">Size and number of blocks (good to identify volume slack)</li>&#13;
<li class="noindent">Number of mounts and last mount point</li>&#13;
<li class="noindent">Other filesystem features and configuration</li>&#13;
</ul>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_47"/>Most forensic tools, including <span class="literal">fsstat</span>, will show this information. Filesystems typically come with debugging and troubleshooting tools that might show even more technical information.</p>&#13;
<p class="indent">The inode structure also depends on the filesystem and defines the metadata that’s available for each file. This may contain items of forensic interest, including:</p>&#13;
<ul>&#13;
<li class="noindent">POSIX file type</li>&#13;
<li class="noindent">Permissions and ownership</li>&#13;
<li class="noindent">Multiple timestamps (the well-known MACB, maybe others)</li>&#13;
<li class="noindent">Sizes and blocks (indicates possibility of file slack)</li>&#13;
<li class="noindent">Other flags and attributes</li>&#13;
</ul>&#13;
<p class="noindent">The most authoritative place to find information about a filesystem’s inode structure is the project’s own developer documentation or the source code to the implementation.</p>&#13;
<p class="indent">Other forensic artifacts have to do with storage content. Understanding the areas of the drive that have content helps examiners with recovery and extraction. Some definitions and areas of forensic interest on a drive include:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong>Sector</strong> Smallest accessible unit on a drive</p>&#13;
<p class="noindentin"><strong>Block</strong> Group of consecutive sectors and the smallest accessible unit on a filesystem</p>&#13;
<p class="noindentin"><strong>Extent</strong> A group of consecutive filesystem blocks (variable size)</p>&#13;
<p class="noindentin"><strong>Allocated blocks</strong> Filesystem blocks that are allocated to files</p>&#13;
<p class="noindentin"><strong>Unallocated blocks</strong> Filesystem blocks that are not allocated to files (possibly containing data from deleted files)</p>&#13;
</div>&#13;
<p class="indent">When a file is deleted, it is unlinked and the inode and associated data blocks are flagged as unallocated and free to use. On magnetic disk drives, the deleted file’s data continues to reside on the platters until the blocks are overwritten, meaning data can be recovered by forensic tools. On SSDs, the operating system may send a command (TRIM or DISCARD) to the drive firmware, instructing it to erase the data in preparation for the next write.<sup><a id="ch03foot07" href="footnotes.xhtml#ch03foot_07">7</a></sup> This reduces the chance of deleted data recovery from unallocated areas of SSDs.</p>&#13;
<p class="indent">The term <em>slack</em> or <em>slackspace</em> is used in forensics to describe additional unused areas of a drive where data could (theoretically) exist:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong>Volume slack</strong> Area between end of filesystem and end of partition</p>&#13;
<p class="noindentin"><strong>File slack</strong> Area between end of file and end of block</p>&#13;
<p class="noindentin"><strong>RAM or memory slack</strong> Area between end of file and end of sector</p>&#13;
<p class="noindentin"><span epub:type="pagebreak" id="page_48"/><strong>Interpartition gaps</strong> A region of the drive not belonging to any defined partition (possibly deleted partitions)</p>&#13;
</div>&#13;
<p class="indent">Today, operating systems are more careful about handling discarded data. TRIM and DISCARD commands are used to wipe SSD memory cells, and 4KB native sectors (the smallest addressable unit) are the same size as filesystem blocks. These factors are resulting in slackspace becoming less useful as an evidence source.</p>&#13;
<h4 class="h4" id="ch00lev2_33"><strong><em>List and Extract Data</em></strong></h4>&#13;
<p class="noindent">Part of filesystem forensic analysis is the ability to recover files (including deleted files) and recover file fragments (slack or unallocated areas). This is a normal feature of every computer forensic toolkit. Let’s look at a small cookbook of examples using TSK.</p>&#13;
<p class="indent">First, let’s examine the relationships between sectors, blocks, inodes, and filenames. These examples use basic math or TSK tools to answer the following questions:</p>&#13;
<ul>&#13;
<li class="noindent">I know the drive sector. What is the filesystem block? <span class="literal">(sector - partitionoffset) * sectorsize / blocksize</span></li>&#13;
<li class="noindent">I know the filesystem block. At what sector is it located? <span class="literal">(block * blocksize / sectorsize) + partitionoffset</span></li>&#13;
<li class="noindent">Is this filesystem block (123) allocated? <span class="literal">blkstat partimage.raw 123</span></li>&#13;
<li class="noindent">I know an allocated block (456). What is the inode? <span class="literal">ifind -d 456 partimage.raw</span></li>&#13;
<li class="noindent">I know a file’s inode. Show the file’s metadata (and blocks used): <span class="literal">istat partimage.raw 789</span></li>&#13;
<li class="noindent">I know a file’s inode. What is the filename? <span class="literal">ffind partimage.raw 789</span></li>&#13;
<li class="noindent">I know the filename. What is the inode? <span class="literal">ifind -n "hello.txt" partimage.raw</span></li>&#13;
</ul>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Make sure you are using the correct units! Depending on the tool, the units could be bytes, sectors, or blocks.</em></p>&#13;
</div>&#13;
<p class="indent">TSK has tools for analyzing drive images and filesystems. When using a tool for filesystem analysis, the location of the filesystem is needed. Filesystem forensic tools can read data from a partition device file (<em>/dev/sda1</em>) or an extracted partition image (<em>partimage.raw</em>), or by specifying a sector offset (typically by using the <span class="literal">-o</span> flag) for an attached drive or drive image file.</p>&#13;
<p class="indent">We can use TSK’s <span class="literal">fls</span> tool to list all known files (including deleted files) on a filesystem. In the following example, the <span class="literal">-r</span> flag lists files from all directories recursively, and <span class="literal">-p</span> displays a full path (the <span class="literal">-l</span> flag would include timestamps, size, and ownership).</p>&#13;
<pre><span epub:type="pagebreak" id="page_49"/>$ <span class="codestrong1">fls -r -p partimage.raw</span>&#13;
...&#13;
r/r 262172:   etc/hosts&#13;
d/d 131074:   var/cache&#13;
...&#13;
r/r 1050321:  usr/share/zoneinfo/Europe/Vaduz&#13;
r/r 1050321:  usr/share/zoneinfo/Europe/Zurich&#13;
...&#13;
r/r * 136931(realloc): var/cache/ldconfig/aux-cache~&#13;
r/r 136931:   var/cache/ldconfig/aux-cache&#13;
...&#13;
V/V 1179649:  $OrphanFiles&#13;
-/r * 655694: $OrphanFiles/OrphanFile-655694&#13;
...</pre>&#13;
<p class="indent">This command found more than 45,000 files on my test system, and I’ve picked a few examples to explain the output. For more information, see the TSK wiki (<em><a href="https://github.com/sleuthkit/sleuthkit/wiki/fls/">https://github.com/sleuthkit/sleuthkit/wiki/fls/</a></em>). The first column (<span class="literal">r/r</span>, <span class="literal">d/d</span>, and so on) represents the file type identified from the directory entry and the inode. For example, <em>/etc/hosts</em> is a regular file (<span class="literal">r</span>) and the output shows <span class="literal">r/r</span>. The first <span class="literal">r</span> is determined from the <em>/etc/</em> directory entry, and the second <span class="literal">r</span> is determined from the <em>/etc/hosts</em> metadata (the inode). The Linux-relevant<sup><a id="ch03foot08" href="footnotes.xhtml#ch03foot_08">8</a></sup> file types are documented on the TSK wiki and shown here:</p>&#13;
<div class="bqparan">&#13;
<table>&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:80%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top"><span class="codestrong">r/r</span></td>&#13;
<td style="vertical-align: top">Regular file</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><span class="codestrong">d/d</span></td>&#13;
<td style="vertical-align: top">Directory</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><span class="codestrong">c/c</span></td>&#13;
<td style="vertical-align: top">Character device</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><span class="codestrong">b/b</span></td>&#13;
<td style="vertical-align: top">Block device</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><span class="codestrong">l/l</span></td>&#13;
<td style="vertical-align: top">Symbolic link</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><span class="codestrong">p/p</span></td>&#13;
<td style="vertical-align: top">Named FIFO</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><span class="codestrong">h/h</span></td>&#13;
<td style="vertical-align: top">Socket</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
<p class="indent">A dash (<span class="literal">-/-</span>) on either side of the slash indicates an unknown file type (that is, it couldn’t be found in either the directory entry or the inode). The number following the file type represents the inode. Note how two files can share the same inode (<em>Vaduz</em> and <em>Zurich</em>). These are hard-linked files. An asterisk (<span class="literal">*</span>) indicates a deleted file. If a file was deleted and the inode number was reused (reallocated) for a new file, <span class="literal">(realloc)</span> will be shown (this can also happen when files are renamed). If a file was deleted and no filename information exists (only the inode data), it will be listed in a TSK <em>$OrphanFiles</em> virtual directory. TSK may display additional information with a file or directory type of <span class="literal">v/v</span> or <span class="literal">V/V</span>, but those names are virtual and don’t exist in the filesystem under analysis. The inode number used for the <em>$OrphanFiles</em> virtual directory is derived from the maximum number of inodes plus one.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_50"/>We can also use TSK commands to extract content from the filesystem. Here are a few examples:</p>&#13;
<ul>&#13;
<li class="noindent">Extract a file based on inode number (use <span class="literal">-s</span> to include slack): <span class="literal">icat partimage.raw 1234</span></li>&#13;
<li class="noindent">Extract a file based on filename (use <span class="literal">-s</span> to include slack): <span class="literal">fcat hello.txt /dev/sda1</span></li>&#13;
<li class="noindent">Extract filesystem blocks (with offset and number of blocks): <span class="literal">blkcat partimage.raw 56789 1</span></li>&#13;
<li class="noindent">Extract all unallocated filesystem blocks: <span class="literal">blkls partimage.raw</span></li>&#13;
<li class="noindent">Extract all file slackspace (from allocated blocks): <span class="literal">blkls -s partimage.raw</span></li>&#13;
<li class="noindent">Extract one drive sector with <span class="literal">dd</span> (increment <span class="literal">count</span> for more sectors): <span class="literal">dd if=image.raw skip=12345 count=1</span></li>&#13;
</ul>&#13;
<p class="indent">Always pipe or redirect extracted output to a program or file (with <span class="literal">|</span> or <span class="literal">&gt;</span>) or you will mess up your shell/terminal or risk executing unwanted commands.</p>&#13;
<p class="indent">For easier reference, I’ve grouped all the TSK commands by analysis or extraction function here:</p>&#13;
<ul>&#13;
<li class="noindent">Forensic images: <span class="literal">img_cat</span>, <span class="literal">img_stat</span></li>&#13;
<li class="noindent">Partitions: <span class="literal">mmcat</span>, <span class="literal">mmls</span>, <span class="literal">mmstat</span></li>&#13;
<li class="noindent">Filesystem information: <span class="literal">fsstat</span>, <span class="literal">pstat</span></li>&#13;
<li class="noindent">Filesystem blocks: <span class="literal">blkcalc</span>, <span class="literal">blkcat</span>, <span class="literal">blkls</span>, <span class="literal">blkstat</span></li>&#13;
<li class="noindent">Filenames: <span class="literal">fcat</span>, <span class="literal">ffind</span>, <span class="literal">fls</span>, <span class="literal">fiwalk</span></li>&#13;
<li class="noindent">Inodes: <span class="literal">icat</span>, <span class="literal">ifind</span>, <span class="literal">ils</span>, <span class="literal">istat</span></li>&#13;
<li class="noindent">Timelines: <span class="literal">mactime</span>, <span class="literal">tsk_gettimes</span></li>&#13;
<li class="noindent">Search and sort: <span class="literal">sigfind</span>, <span class="literal">sorter</span>, <span class="literal">srch_strings</span>, <span class="literal">tsk_comparedir</span>, <span class="literal">tsk_loaddb</span>, <span class="literal">tsk_recover</span>, <span class="literal">hfind</span></li>&#13;
<li class="noindent">Filesystem journal: <span class="literal">jcat</span>, <span class="literal">jls</span>, <span class="literal">usnjls</span></li>&#13;
</ul>&#13;
<p class="indent">You can find more information in the man pages. (The Debian project has some additional man pages not included in the TSK software package.)</p>&#13;
<p class="indent">Most commercial forensic tools will perform these tasks. As mentioned previously, an alternative for unsupported filesystems is the debugging and troubleshooting tools that are typically provided by the filesystem’s developers. Those will be used in the following sections on ext4, btrfs, and xfs.</p>&#13;
<h3 class="h3" id="ch00lev1_11"><strong>An Analysis of ext4</strong></h3>&#13;
<p class="noindent">One of the oldest and most popular of the Linux filesystems is the <em>extended filesystem</em>, or <em>ext</em>. Every modern Linux distribution supports ext4, and many of them specify it as the default filesystem during installation. Because of <span epub:type="pagebreak" id="page_51"/>the popularity of ext (2, 3, and 4), many commercial forensic tools support ext4. TSK (and Autopsy) support it, and many other ext4 troubleshooting, debugging, and data recovery tools are available.</p>&#13;
<p class="indent">Ext4 is a scalable filesystem, supports journaling, is extent-based, and supports directory-level encryption. See the ext4(5) man page for more information.</p>&#13;
<p class="indent">Compared to other popular Linux filesystems, ext4 contains more forensic artifacts in the superblock that could be useful in an investigation. However, it also eliminates more traces of information during the deletion process, making recovery of deleted files more difficult.</p>&#13;
<h4 class="h4" id="ch00lev2_34"><strong><em>Filesystem Metadata: Superblock</em></strong></h4>&#13;
<p class="noindent">The superblock starts at byte offset 1024 (0x400) from the start of the filesystem. The magic string for ext2, ext3, and ext4 is 0xEF53 (the same for all three versions). The location of the magic string is at byte offset 56 (0x38) in the superblock and, therefore, byte offset 1080 (0x438) from the beginning of the filesystem. It is written on disk in little-endian order:</p>&#13;
<pre>00000438: 53ef S.</pre>&#13;
<p class="indent">The ext4 superblock has timestamps, unique identifiers, features, and descriptive information that can be interesting in a forensic examination. For example:</p>&#13;
<ul>&#13;
<li class="noindent">Filesystem creation timestamp</li>&#13;
<li class="noindent">Filesystem last-mounted timestamp</li>&#13;
<li class="noindent">Filesystem last-checked (<span class="literal">fsck</span>) timestamp</li>&#13;
<li class="noindent">Superblock last-written timestamp</li>&#13;
<li class="noindent">User-specified volume name or label (maximum 16 characters)</li>&#13;
<li class="noindent">Unique volume UUID</li>&#13;
<li class="noindent">Creator OS: If this is not Linux, it could indicate another OS was involved (0 = Linux, 3 = FreeBSD)</li>&#13;
<li class="noindent">Directory where last mounted: If this is not a standard location, the user may have manually created the mount point on a system</li>&#13;
<li class="noindent">Number of times mounted since last <span class="literal">fsck</span>: For external drives, this could be an indicator of how often the filesystem was used</li>&#13;
<li class="noindent">Number KiB written over the lifetime of the filesystem: This provides an idea about how “busy” the filesystem was in the past</li>&#13;
</ul>&#13;
<p class="indent">The number of KiB written over the lifetime of the filesystem can be interesting in some cases (data theft, for example) where large amounts of files are copied to external media. If the total number of bytes ever written is the same as the total size of all the files, it indicates the filesystem was not used for anything else. If a drive has SMART capabilities, the <em>Total LBAs Written</em> attribute can be used to compare the amount of data on the drive to data <span epub:type="pagebreak" id="page_52"/>written over the lifetime of the drive itself (similar analysis may be done with the <em>Total LBAs Read</em> attribute).</p>&#13;
<p class="indent">Commercial forensic tools should support the analysis of the ext4 superblock; otherwise <span class="literal">fsstat</span> can be used. The <span class="literal">dumpe2fs</span> tool (part of the <span class="literal">e2fsprogs</span> software package) also shows detailed information about the superblock. In this example, a forensic image of a partition (<em>partimage.raw</em>) is used, and the <span class="literal">-h</span> flag specifies that superblock’s header information:</p>&#13;
<pre>$ <span class="codestrong1">dumpe2fs -h partimage.raw</span>&#13;
dumpe2fs 1.46.2 (28-Feb-2021)&#13;
Filesystem volume name:  TooManySecrets&#13;
Last mounted on:         /run/media/sam/TooManySecrets&#13;
Filesystem UUID:         7de10bcf-a377-4800-b6ad-2938bf0c08a7&#13;
Filesystem magic number: 0xEF53&#13;
...&#13;
Filesystem OS type:      Linux&#13;
Inode count:             483328&#13;
Block count:             1933312&#13;
...&#13;
Filesystem created:      Sat Mar 13 07:42:13 2021&#13;
Last mount time:         Sat Mar 13 08:33:42 2021&#13;
Last write time:         Sat Mar 13 08:33:42 2021&#13;
Mount count:             16&#13;
Maximum mount count:     -1&#13;
Last checked:            Sat Mar 13 07:42:13 2021&#13;
...</pre>&#13;
<p class="indent">Some records have been removed from this output to highlight artifacts that could be useful in a forensic investigation. If the volume name (<span class="literal">TooManySecrets</span>) is specified by the user, it may provide a description of the contents (from the user’s perspective). The <span class="literal">Last mounted on:</span> record indicates the directory where the filesystem was last mounted. In a forensic investigation, this is especially interesting for external drives because it can associate the drive with a mount point or user on a particular Linux system. The mount point can be manually created by the user or temporarily created by a disk manager. In the preceding example, the filesystem was last mounted on <em>/run/media/sam/TooManySecrets</em>, indicating that user Sam possibly mounted it on their desktop system with a disk manager.<sup><a id="ch03foot09" href="footnotes.xhtml#ch03foot_09">9</a></sup> See <em><a href="https://www.kernel.org/doc/html/latest/filesystems/ext4/globals.html">https://www.kernel.org/doc/html/latest/filesystems/ext4/globals.html</a></em> for authoritative documentation on the superblock structure.</p>&#13;
<p class="indent">TSK’s <span class="literal">fsstat</span> tool can display the superblock information, as well, but in less detail than <span class="literal">dumpe2fs</span>; for example:</p>&#13;
<pre>$ <span class="codestrong1">fsstat partimage.raw</span>&#13;
FILE SYSTEM INFORMATION&#13;
--------------------------------------------&#13;
<span epub:type="pagebreak" id="page_53"/>File System Type: Ext4&#13;
Volume Name: TooManySecrets&#13;
Volume ID: a7080cbf3829adb64877a3cf0be17d&#13;
&#13;
Last Written at: 2021-03-13 08:33:42 (CET)&#13;
Last Checked at: 2021-03-13 07:42:13 (CET)&#13;
&#13;
Last Mounted at: 2021-03-13 08:33:42 (CET)&#13;
Unmounted properly&#13;
Last mounted on: /run/media/sam/TooManySecrets&#13;
&#13;
Source OS: Linux&#13;
...</pre>&#13;
<p class="noindent">The full output will describe the block groups and allocation information. In many forensic examinations, the block allocation information is not needed for drawing investigative conclusions (but could still be provided in the appendix of a forensic report).</p>&#13;
<p class="indent">Notice how <span class="literal">dumpe2fs</span>’s <span class="literal">Filesystem UUID</span> and <span class="literal">fsstat</span>’s <span class="literal">Volume ID</span> are different representations of the same hexadecimal string.</p>&#13;
<h4 class="h4" id="ch00lev2_35"><strong><em>File Metadata: Inodes</em></strong></h4>&#13;
<p class="noindent">The inode structure in ext4 is well documented and has many fields that are interesting from a digital forensics perspective.</p>&#13;
<p class="indent">The file size and block count are specified. These are usually not exactly the same unless the file size is a multiple of the block size. Any data residing beyond the end of the file in the last block is the file slack.</p>&#13;
<p class="indent">Additional flags are specified in the inode. For example, a flag of 0x80 states that the file access time should not be updated. A flag of 0x800 states that the inode blocks are encrypted.<sup><a id="ch03foot010" href="footnotes.xhtml#ch03foot_010">10</a></sup></p>&#13;
<p class="indent">The file mode defines the permissions (read, write, execute for owner, group, and other), and special bits (SetUID, SetGID, and the sticky bit). The mode also specifies the file type (regular, directory, symbolic link, FIFO, socket, and character and block devices).</p>&#13;
<p class="indent">Extended attributes (ACLs, for example) are not stored in the inode, but in a separate data block. The inode has a pointer to this data block.</p>&#13;
<p class="indent">File ownership is defined by the owner (UID) and group (GID). Originally this was 16 bits, allowing for a maximum of 65,535 users and groups. Two additional bytes each were later assigned (but stored in separate places in the inode), making the UID and GID 32 bits wide.</p>&#13;
<p class="indent">Five timestamps (M, A, C, B, and D) are stored in the ext4 inode:</p>&#13;
<ul>&#13;
<li class="noindent">Last data modification time (<span class="literal">mtime</span>)</li>&#13;
<li class="noindent">Last access time (<span class="literal">atime</span>)</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_54"/>Last inode change time (<span class="literal">ctime</span>)</li>&#13;
<li class="noindent">Creation time (<span class="literal">crtime</span>, sometimes called the “birth” timestamp)</li>&#13;
<li class="noindent">Deletion time</li>&#13;
</ul>&#13;
<p class="noindent">The deletion timestamp is set only when the inode is changed from allocated to unallocated.</p>&#13;
<p class="indent">Historically, timestamps have been 32 bits long, containing the seconds between January 1, 1970 and January 19, 2038. Modern systems need greater resolution (nanoseconds) and need to go beyond 2038. To solve this, ext4 adds an additional four bytes for each timestamp. These additional 32 bits are split, with 2 bits providing time after 2038, and 30 bits providing higher resolution (more time accuracy).</p>&#13;
<p class="indent">You can view the ext4 inode information with TSK’s <span class="literal">istat</span> tool:</p>&#13;
<pre>$ <span class="codestrong1">istat partimage.raw 262172</span>&#13;
inode: 262172&#13;
Allocated&#13;
Group: 32&#13;
Generation Id: 3186738182&#13;
uid / gid: 0 / 0&#13;
mode: rrw-r--r--&#13;
Flags: Extents,&#13;
size: 139&#13;
num of links: 1&#13;
&#13;
Inode Times:&#13;
Accessed:       2020-03-11 11:12:37.626666598 (CET)&#13;
File Modified:  2020-03-11 11:12:34.483333261 (CET)&#13;
Inode Modified: 2020-03-11 11:12:34.483333261 (CET)&#13;
File Created:   2020-03-11 11:03:19.903333268 (CET)&#13;
&#13;
Direct Blocks:&#13;
1081899</pre>&#13;
<p class="noindent">This output shows the state of the inode (<span class="literal">Allocated</span>), ownership and permissions, four timestamps, and which blocks are used.</p>&#13;
<p class="indent">Alternatively, we can use <span class="literal">debugfs</span> (part of <span class="literal">e2fsprogs</span>) for more information. The following is an example using a deleted file. The <span class="literal">-R</span> flag refers to <em>request</em>, not <em>read-only</em> (it’s read-only by default), the <span class="literal">"stat &lt;136939&gt;"</span> parameter requests stat information for inode 136939, and the command operates on the forensic image file <em>partimage.raw</em>:</p>&#13;
<pre>$ <span class="codestrong1">debugfs -R "stat &lt;136939&gt;" partimage.raw</span>&#13;
debugfs 1.45.6 (20-Mar-2020)&#13;
Inode: 136939  Type: regular  Mode: 0000  Flags: 0x80000&#13;
Generation: 166965863  Version: 0x00000000:00000001&#13;
User:     0  Group:    0   Project:     0   Size: 0&#13;
File ACL: 0&#13;
<span epub:type="pagebreak" id="page_55"/>Links: 0  Blockcount: 0&#13;
Fragment: Address: 0  Number: 0  Size: 0&#13;
 ctime: 0x5e68c4bb:04c4b400 -- Wed Mar 11 12:00:11 2020&#13;
 atime: 0x5e68c4ba:9a2d66ac -- Wed Mar 11 12:00:10 2020&#13;
 mtime: 0x5e68c4ba:9a2d66ac -- Wed Mar 11 12:00:10 2020&#13;
crtime: 0x5e68c4ba:9a2d66ac -- Wed Mar 11 12:00:10 2020&#13;
 dtime: 0x5e68c4bb:(04c4b400) -- Wed Mar 11 12:00:11 2020&#13;
Size of extra inode fields: 32&#13;
Inode checksum: 0x95521a7d&#13;
EXTENTS:</pre>&#13;
<p class="indent">This is a deleted file’s inode and contains five timestamps, including the time of deletion. Notice the lack of block information after the <span class="literal">EXTENTS:</span> line. When a file is deleted on ext4, the blocks previously used are removed from the unused inode. This means that file recovery using some traditional forensic techniques may not be possible.</p>&#13;
<h4 class="h4" id="ch00lev2_36"><strong><em>List and Extract Files</em></strong></h4>&#13;
<p class="noindent">The file listing and extraction examples used TSK on ext4 in the previous section, so I’ll provide an alternative method here. The <span class="literal">debugfs</span> tool can do most of the things TSK can do; for example:</p>&#13;
<ul>&#13;
<li class="noindent">List directory contents, including deleted files (not recursive): <span class="literal">debugfs -R "ls -drl" partimage.raw</span></li>&#13;
<li class="noindent">Extract contents of a file by specifying the inode (similar to <span class="literal">icat</span>): <span class="literal">debugfs -R "cat &lt;14&gt;" partimage.raw</span></li>&#13;
<li class="noindent">Extract the inode metadata (similar to <span class="literal">istat</span>): <span class="literal">debugfs -R "stat &lt;14&gt;" partimage.raw</span></li>&#13;
<li class="noindent">Extract the inode metadata as a hex dump (similar to <span class="literal">istat</span> but raw): <span class="literal">debugfs -R "inode_dump &lt;14&gt;" partimage.raw</span></li>&#13;
</ul>&#13;
<p class="noindent">The <span class="literal">&lt;14&gt;</span> notation represents an inode (14 in this example). A file path can also be specified:</p>&#13;
<pre>$ <span class="codestrong1">debugfs -R "ls -drl /Documents" partimage.raw</span>&#13;
debugfs 1.45.6 (20-Mar-2020)&#13;
     12   40750 (2)      0   0  4096 30-Nov-2020 22:35 .&#13;
      2   40755 (2)      0   0  4096 30-Nov-2020 22:39 ..&#13;
     13  100640 (1)      0   0    91 30-Nov-2020 22:35 evilplan.txt</pre>&#13;
<p class="noindent">The output shows the file list with inodes, sizes, timestamps, and filenames.</p>&#13;
<p class="indent">The <span class="literal">debugfs</span> output can be displayed in the terminal or redirected into a file on the forensic analysis machine. Here the file from the preceding example (<span class="literal">evilplan.txt</span>) is being displayed with <span class="literal">debugfs</span>:</p>&#13;
<pre>$ <span class="codestrong1">debugfs -R "cat &lt;13&gt;" partimage.raw</span>&#13;
debugfs 1.45.6 (20-Mar-2020)&#13;
&#13;
<span epub:type="pagebreak" id="page_56"/>this is the master plan to destroy all copies of powerpoint.exe across the&#13;
entire company.</pre>&#13;
<p class="noindent">The content of the file is sent to the terminal (<span class="literal">stdout</span>) and can be redirected into a file or piped into a program. The <span class="literal">debugfs</span> version string is seen on the terminal but not added to files or sent to programs (this is <span class="literal">stderr</span> output).</p>&#13;
<p class="indent">Another feature of ext4 that is interesting for forensic examiners is encrypted subdirectories. We’ll look at identification and decryption of ext4 subdirectories at the end of this chapter.</p>&#13;
<p class="indent">The ext4 specification is published on the kernel documentation site at <em><a href="https://www.kernel.org/doc/html/latest/filesystems/ext4/index.html">https://www.kernel.org/doc/html/latest/filesystems/ext4/index.html</a></em>.</p>&#13;
<p class="indent">For more information specific to digital forensics, several research papers on ext4 forensics have also been written:</p>&#13;
<ul>&#13;
<li class="noindent">Kevin D. Fairbanks, “An Analysis of Ext4 for Digital Forensics,” <em><a href="https://www.sciencedirect.com/science/article/pii/S1742287612000357/">https://www.sciencedirect.com/science/article/pii/S1742287612000357/</a></em>.</li>&#13;
<li class="noindent">Thomas Göbel and Harald Baier, “Anti-Forensics in Ext4: On Secrecy and Usability of Timestamp-Based Data Hiding,” <em><a href="https://www.sciencedirect.com/science/article/pii/S174228761830046X/">https://www.sciencedirect.com/science/article/pii/S174228761830046X/</a></em>.</li>&#13;
<li class="noindent">Andreas Dewald and Sabine Seufert, “AFEIC: Advanced Forensic Ext4 Inode Carving,” <em><a href="https://dfrws.org/presentation/afeic-advanced-forensic-ext4-inode-carving/">https://dfrws.org/presentation/afeic-advanced-forensic-ext4-inode-carving/</a></em>.</li>&#13;
</ul>&#13;
<h3 class="h3" id="ch00lev1_12"><strong>An Analysis of btrfs</strong></h3>&#13;
<p class="noindent">Chris Mason originally developed btrfs while working at Oracle, and it was announced on the Linux Kernel Mailing List (LKML) in 2007. The Linux community was in need of something more than the aging ext3, and for various reasons, ReiserFS and zfs weren’t viable options at that time. Since then, btrfs has become part of the mainline Linux kernel and has grown in popularity. Today, SUSE and Fedora use btrfs as their default filesystem, Facebook uses it internally, and storage companies like Synology depend on it.</p>&#13;
<p class="indent">Among the many modern features in btrfs are multiple device management, subvolumes, and CoW snapshots. Because of these features, btrfs doesn’t need a separate volume management layer like LVM. Today, btrfs is actively developed, and newly implemented features are listed on the btrfs homepage at <em><a href="https://btrfs.wiki.kernel.org/index.php/Main_Page">https://btrfs.wiki.kernel.org/index.php/Main_Page</a></em>.</p>&#13;
<p class="indent">As of this writing, btrfs support among digital forensic tools is poor. Most of the major forensic analysis suites don’t support it, and even TSK has no support for btrfs at the moment. Several experimental and research implementations for TSK btrfs support are available on GitHub, including an older pull request for TSK to add support (<em><a href="https://github.com/basicmaster/sleuthkit/">https://github.com/basicmaster/sleuthkit/</a></em>) and a stand-alone tool that uses TSK libraries and mimics TSK commands (<em><a href="https://github.com/shujianyang/btrForensics/">https://github.com/shujianyang/btrForensics/</a></em>). These tools may or may not work for your btrfs filesystem, so use them at your own risk.</p>&#13;
<p class="indent">In this section, we’ll use a combination of tools from the btrfs project team (the <span class="literal">btrfs-progs</span> software package), and research from Fraunhofer <span epub:type="pagebreak" id="page_57"/>FKIE presented at DFRWS USA in 2018 (<em><a href="https://www.sciencedirect.com/science/article/pii/S1742287618301993/">https://www.sciencedirect.com/science/article/pii/S1742287618301993/</a></em>). You can download a forked version of TSK with patches for btrfs support from <em><a href="https://github.com/fkie-cad/sleuthkit/">https://github.com/fkie-cad/sleuthkit/</a></em>.</p>&#13;
<p class="indent">The examples shown in this section use a variety of tools and techniques. Each tool may require a different form of access to a btrfs filesystem. To help avoid confusion, these are the device, file, and directory names used in the examples below:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong><em>image.raw</em></strong> A forensically acquired raw image file (using sector offsets for the filesystem)</p>&#13;
<p class="noindentin"><strong><em>partimage(X).raw</em></strong> Separately extracted partition image file(s) containing only the filesystem</p>&#13;
<p class="noindentin"><strong><em>/dev/loopX</em></strong> A block device (in <em>/dev/</em>) physically attached or using a loopback (<span class="literal">losetup</span>)</p>&#13;
<p class="noindentin"><strong><em>/evidence/</em></strong> A path to a mounted btrfs filesystem</p>&#13;
<p class="noindentin"><strong><em>pool/</em> or <em>poolm/</em></strong> A pool directory containing one or more btrfs partition image files</p>&#13;
</div>&#13;
<p class="noindent">Paths to files and directories are considered to be relative to the current working directory.</p>&#13;
<h4 class="h4" id="ch00lev2_37"><strong><em>Filesystem Metadata: Superblock</em></strong></h4>&#13;
<p class="noindent">A btrfs filesystem can be identified from the magic string in the superblock. The primary btrfs superblock is at byte offset 65536 (0x10000) from the start of the filesystem. On a drive with 512 byte sectors, this would be sector 128 from the start of the partition. The eight-byte magic string that identifies a btrfs filesystem is <span class="literal">_BHRfS_M</span>, and is shown here together with the hexadecimal representation:</p>&#13;
<pre>5F 42 48 52 66 53 5F 4D _BHRfS_M</pre>&#13;
<p class="indent">This magic string is at byte offset 64 (0x40) in the superblock, which is byte offset 65600 (0x10040) from the start of the partition containing the filesystem. A search for this magic string across all sectors of the drive may reveal mirror copies of the superblock or other btrfs filesystems for analysis.</p>&#13;
<p class="indent">The Fraunhofer FKIE TSK fork added several new flags to the filesystem commands. Forensic images of btrfs partitions are expected to be found in a pool directory (called <span class="literal">pool/</span> in the following examples) and specified with the <span class="literal">-P</span> flag. In this example, <span class="literal">fsstat</span> is used to output the superblock, which contains several items of forensic interest:</p>&#13;
<pre>   $ <span class="codestrong1">fsstat -P pool/</span>&#13;
<span class="ent">➊</span> Label:                   My Stuff&#13;
<span class="ent">➋</span> File system UUID:        EA920473-EC49-4F1A-A037-90258D453DB6&#13;
   Root tree root address:  5406720&#13;
   Chunk tree root address: 1048576&#13;
   <span epub:type="pagebreak" id="page_58"/>Log tree root address:   0&#13;
<span class="ent">➌</span> Generation:              20&#13;
   Chunk root generation:   11&#13;
   Total bytes:             4293898240&#13;
   Number of devices:       1&#13;
&#13;
<span class="ent">➍</span> Device UUID:             22D40FDB-C768-4623-BCBB-338AC0744EC7&#13;
   Device ID:               1&#13;
<span class="ent">➎</span> Device total bytes:      4293898240&#13;
<span class="ent">➏</span> Device total bytes used: 457179136&#13;
&#13;
   Total size: 3GB&#13;
   Used size: 38MB&#13;
&#13;
<span class="ent">➐</span> The following subvolumes or snapshots are found:&#13;
   256       Documents&#13;
   257       Videos&#13;
   259       .snapshot&#13;
   260       Confidential</pre>&#13;
<p class="indent">The user can choose a label <span class="ent">➊</span> (maximum 256 characters), which may be a helpful artifact in an investigation. The first UUID <span class="ent">➋</span> is the unique identifier for the btrfs filesystem, and the second UUID <span class="ent">➍</span> is the unique identifier for the btrfs drive device. The drive’s total capacity <span class="ent">➎</span> is shown together with the used capacity <span class="ent">➏</span>. These byte totals should correlate with other capacity artifacts collected during the examination (like the partition table, for example). The <span class="literal">Generation</span> <span class="ent">➌</span> is updated with new changes, so the filesystem knows which copy (out of all the redundant copies) of the superblock is the newest. Lastly, a list of subvolumes and snapshots <span class="ent">➐</span> are shown (these are described in a separate section below).</p>&#13;
<p class="indent">The btrfs command <span class="literal">btrfs inspect-internal dump-super partimage.raw</span> provides the same information plus some additional statistics and flags (which are less useful for most forensic investigations). The <span class="literal">btrfs inspect-internal</span> command can analyze a variety of low-level technical artifacts about the filesystem and how structures are stored on a drive. See the btrfs-inspect-internal(8) man page for more information. The btrfs superblock does not contain any timestamps like ext4.</p>&#13;
<h4 class="h4" id="ch00lev2_38"><strong><em>File Metadata: Inodes</em></strong></h4>&#13;
<p class="noindent">The btrfs inode structure is documented on the <a href="http://kernel.org">kernel.org</a> website (<em><a href="https://btrfs.wiki.kernel.org/index.php/Data_Structures#btrfs_inode_ref">https://btrfs.wiki.kernel.org/index.php/Data_Structures#btrfs_inode_ref</a></em>). Unlike ext4 and xfs, a btrfs inode contains minimal information and pushes some information about files into various separate tree structures. The contents of a btrfs inode include the following information:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><span class="codestrong">generation</span>    Incrementing counter on changes</p>&#13;
<p class="noindentin"><span class="codestrong">transid</span>    Transaction ID</p>&#13;
<p class="noindentin"><span epub:type="pagebreak" id="page_59"/><span class="codestrong">size</span>    Size of the file in bytes</p>&#13;
<p class="noindentin"><span class="codestrong">nbytes</span>    Size of the allocated blocks in bytes (directories are 0)</p>&#13;
<p class="noindentin"><span class="codestrong">nlink</span>    Number of links</p>&#13;
<p class="noindentin"><span class="codestrong">uid</span>    File owner</p>&#13;
<p class="noindentin"><span class="codestrong">gid</span>    File group</p>&#13;
<p class="noindentin"><span class="codestrong">mode</span>    Permissions</p>&#13;
<p class="noindentin"><span class="codestrong">rdev</span>    If inode is a device, the major/minor numbers</p>&#13;
<p class="noindentin"><span class="codestrong">flags</span>    Inode flags (listed in the next paragraph)</p>&#13;
<p class="noindentin"><span class="codestrong">sequence</span>    For NFS compatibility (initialized to 0 and incremented each time the <span class="literal">mtime</span> value is changed)</p>&#13;
<p class="noindentin"><span class="codestrong">atime</span>    Last access timestamp</p>&#13;
<p class="noindentin"><span class="codestrong">ctime</span>    Last inode change timestamp</p>&#13;
<p class="noindentin"><span class="codestrong">mtime</span>    Last file content change timestamp</p>&#13;
<p class="noindentin"><span class="codestrong">otime</span>    Inode creation timestamp (file birth)</p>&#13;
</div>&#13;
<p class="indent">Most of these items are familiar and can be found in other filesystems. The NFS compatibility sequence numbers are incremented each time the content changes (<span class="literal">mtime</span>). In an investigation, knowing how many (or how few) times a file was modified could be interesting. It could also indicate how “busy” changes were to a file or directory in the past or compared to other files.</p>&#13;
<p class="indent">The inode flags<sup><a id="ch03foot011" href="footnotes.xhtml#ch03foot_011">11</a></sup> provide additional attributes imposed on a file. The btrfs documentation defines the following flags in the inode structure:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><span class="codestrong">NODATASUM</span>    Do not perform checksum operations on this inode</p>&#13;
<p class="noindentin"><span class="codestrong">NODATACOW</span>    Do not perform CoW for data extents on this inode when the reference count is 1</p>&#13;
<p class="noindentin"><span class="codestrong">READONLY</span>    Inode is read-only regardless of Unix permissions or ownership (superseded by <span class="literal">IMMUTABLE</span>)</p>&#13;
<p class="noindentin"><span class="codestrong">NOCOMPRESS</span>    Do not compress this inode</p>&#13;
<p class="noindentin"><span class="codestrong">PREALLOC</span>    Inode contains preallocated extents</p>&#13;
<p class="noindentin"><span class="codestrong">SYNC</span>    Operations on this inode will be performed synchronously</p>&#13;
<p class="noindentin"><span class="codestrong">IMMUTABLE</span>    Inode is read-only regardless of Unix permissions or ownership</p>&#13;
<p class="noindentin"><span class="codestrong">APPEND</span>    Inode is append-only</p>&#13;
<p class="noindentin"><span class="codestrong">NODUMP</span>    Inode is not a candidate for dumping using the <span class="literal">dump(8)</span> program</p>&#13;
<p class="noindentin"><span epub:type="pagebreak" id="page_60"/><span class="codestrong">NOATIME</span>    Do not update <span class="literal">atime</span> (last accessed timestamp)</p>&#13;
<p class="noindentin"><span class="codestrong">DIRSYNC</span>    Directory operations will be performed synchronously</p>&#13;
<p class="noindentin"><span class="codestrong">COMPRESS</span>    Compression is enabled on this inode</p>&#13;
</div>&#13;
<p class="noindent">The <span class="literal">NOATIME</span> attribute can affect forensic analysis, as the last accessed timestamp is no longer set by the kernel.</p>&#13;
<p class="indent">Dumping the full inode information for a file on btrfs depends on the support provided by the forensics tool. For example, the Fraunhofer FKIE <span class="literal">istat</span> tool shows minimal information (the <span class="literal">-P</span> flag is explained in the next section):</p>&#13;
<pre>$ <span class="codestrong1">istat -P pool/ 257</span>&#13;
Inode number: 257&#13;
Size: 29&#13;
Name: secret.txt&#13;
&#13;
Directory Entry Times(local);&#13;
Created time:  Sun Nov 29 16:55:34 2020&#13;
Access time:   Sun Nov 29 16:56:41 2020&#13;
Modified time: Sun Nov 29 16:55:25 2020</pre>&#13;
<p class="indent">This level of detail may be enough for some investigations. For more detail, the btrfs <span class="literal">inspect-internal</span> command provides much more information:</p>&#13;
<pre>$ <span class="codestrong1">btrfs inspect-internal dump-tree pool/partimage.raw</span>&#13;
...&#13;
   item 8 key (257 INODE_ITEM 0) itemoff 15721 itemsize 160&#13;
           generation 10 transid 12 size 29 nbytes 29&#13;
           block group 0 mode 100640 links 1 uid 1000 gid 1000 rdev 0&#13;
           sequence 15 flags 0x0(none)&#13;
           atime 1606665401.870699900 (2020-11-29 16:56:41)&#13;
           ctime 1606665334.900190664 (2020-11-29 16:55:34)&#13;
           mtime 1606665325.786787936 (2020-11-29 16:55:25)&#13;
           otime 1606665325.786787936 (2020-11-29 16:55:25)&#13;
   item 9 key (257 INODE_REF 256) itemoff 15701 itemsize 20&#13;
           index 4 namelen 10 name: secret.txt&#13;
...</pre>&#13;
<p class="noindent">This command dumps metadata for the entire filesystem. If the inode number is known, the command output can be searched for the inode item. Here inode 257 has been found and the full inode structure is shown.</p>&#13;
<p class="indent">Depending on the file and number of objects, dumping the entire metadata with the btrfs <span class="literal">inspect-internal</span> command may produce a large amount of output. If multiple searches or more complex analysis are expected, it may be easier saving the output to a separate file.</p>&#13;
<h4 class="h4" id="ch00lev2_39"><span epub:type="pagebreak" id="page_61"/><strong><em>Multiple Devices and Subvolumes</em></strong></h4>&#13;
<p class="noindent">UUIDs are used extensively in btrfs for different objects that make up the filesystem. GPT also uses UUIDs for various storage components. Some of these unique UUIDs are listed here to help explain the differences and provide clarity when interpreting what is being identified:</p>&#13;
<ul>&#13;
<li class="noindent">UUID for each GPT device (a drive with a GPT partition)</li>&#13;
<li class="noindent">UUID for each GPT partition (PARTUUID)</li>&#13;
<li class="noindent">UUID for each btrfs filesystem</li>&#13;
<li class="noindent">UUID for each btrfs device (a drive that is part of a btrfs filesystem, UUID_SUB)</li>&#13;
<li class="noindent">UUID for each btrfs subvolume or snapshot</li>&#13;
</ul>&#13;
<p class="noindent">These unique UUIDs can be used as identifiers when writing forensic reports or when correlating with other evidence sources. Understanding the UUIDs is important when analyzing btrfs systems with multiple devices.</p>&#13;
<p class="indent">One of the design goals built into btrfs is volume management, and a single btrfs filesystem can be created across multiple physical devices. A “profile” defines how data and metadata are replicated across the devices (RAID levels and so on). See the mkfs.btrfs(8) man page for more information about creating btrfs filesystems.</p>&#13;
<p class="indent">The developers of zfs use the term <em>pool</em> when describing multiple devices. The Fraunhofer btrfs patches for TSK use the same terminology and provide the <span class="literal">pls</span> command to list pool information for a collection of images saved to a pool directory. Other TSK commands include flags to specify a pool directory (<span class="literal">-P</span>), transaction/generation number (<span class="literal">-T</span>), and which subvolume to work with (<span class="literal">-S</span>). In this example, the <em>poolm/</em> directory on our forensic analysis machine contains multiple partition image files that were forensically acquired from three drives:</p>&#13;
<pre>   $ <span class="codestrong1">ls poolm/</span>&#13;
   partimage1.raw partimage2.raw partimage3.raw&#13;
   $ <span class="codestrong1">pls poolm/</span>&#13;
<span class="ent">➊</span> FSID:              CB9EC8A5-8A79-40E8-9DDB-2A54D9CB67A9&#13;
<span class="ent">➋</span> System chunks:     RAID1 (1/1)&#13;
   Metadata chunks:   RAID1 (1/1)&#13;
   Data chunks:       Single (1/1)&#13;
<span class="ent">➌</span> Number of devices: 3 (3 detected)&#13;
   -------------------------------------------------&#13;
<span class="ent">➍</span> ID:                  1&#13;
   GUID:               2179D1FD-F94B-4CB7-873D-26CE05B41662&#13;
&#13;
   ID:                  2&#13;
   GUID:               0F784A29-B752-46C4-8DBC-C8E2455C7A13&#13;
&#13;
   <span epub:type="pagebreak" id="page_62"/>ID:                  3&#13;
   GUID:               31C19872-9707-490D-9267-07B499C5BD06&#13;
   ...</pre>&#13;
<p class="noindent">This output reveals a filesystem UUID <span class="ent">➊</span>, the number of devices that are part of the filesystem <span class="ent">➌</span>, the profiles used (like <span class="literal">RAID1</span>) <span class="ent">➋</span>, and the UUIDs (or GUIDs) of each btrfs device <span class="ent">➍</span>. The device UUIDs shown here are part of the btrfs filesystem and are not the same as the UUIDs in the GPT partition table.</p>&#13;
<p class="indent">Subvolumes are a btrfs feature that divides the filesystem into separate logical parts that can have their own characteristics. Subvolumes are not segregated at the block/extent layer, and data blocks/extents may be shared between subvolumes. This is how snapshot functionality is implemented. The previous section showed a <span class="literal">fsstat</span> example that described the superblock. Also listed were the subvolumes found on the filesystem:</p>&#13;
<pre>$ <span class="codestrong1">fsstat -P pool/</span>&#13;
...&#13;
The following subvolumes or snapshots are found:&#13;
256       Documents&#13;
257       Videos&#13;
259       .snapshot&#13;
260       Confidential</pre>&#13;
<p class="indent">Subvolumes have an ID number and their own UUIDs. At the file and directory level, subvolumes can be analyzed as if they were separate filesystems (files even have unique inodes across subvolumes). But at lower layers, files in different subvolumes may share blocks/extents.</p>&#13;
<p class="indent">In some cases, you may want to mount the btrfs filesystem on the examination machine. Reasons for this may include browsing with file management tools, using applications (viewers and office programs), or running additional btrfs analysis commands that operate only on mounted directories. To illustrate, we’ll mount a single partition image (<span class="literal">pool/partimage.raw</span>) to an evidence directory (<span class="literal">/evidence/</span>) in a two-step process:</p>&#13;
<pre>$ <span class="codestrong1">sudo losetup -f --show -r pool/partimage.raw</span>&#13;
/dev/loop0&#13;
$ <span class="codestrong1">sudo mount -o ro,subvol=/ /dev/loop0 /evidence/</span></pre>&#13;
<p class="noindent">The first command creates a read-only <span class="literal">loop0</span> device associated with the partition image file. The second command mounts the <span class="literal">loop0</span> device, read-only, on the <em>/evidence/</em> directory. We explicitly specify the btrfs root subvolume so that no other default subvolumes are used. Now we are able to safely use the mounted <em>/evidence/</em> directory for further content analysis.</p>&#13;
<p class="indent">The btrfs <span class="literal">subvolume</span> command can also list the subvolumes and snapshots found on a filesystem. This command uses a mounted filesystem:</p>&#13;
<pre>$ <span class="codestrong1">sudo btrfs subvolume list /evidence/</span>&#13;
ID 256 gen 19 top level 5 path Documents&#13;
<span epub:type="pagebreak" id="page_63"/>ID 257 gen 12 top level 5 path Videos&#13;
ID 259 gen 13 top level 5 path .snapshot&#13;
ID 260 gen 19 top level 256 path Documents/Confidential</pre>&#13;
<p class="noindent">Every subvolume is given an ID (it also appears as the inode number with <span class="literal">stat</span> or <span class="literal">ls -i</span>). The incrementing generation number is shown. The string <span class="literal">top level</span> refers to the parent subvolume’s ID, and the path here is relative to the root of the mounted filesystem (<em>/evidence/</em> in this case).</p>&#13;
<p class="indent">The btrfs <span class="literal">subvolume</span> command can display more information for a particular subvolume. This example shows metadata for the <span class="literal">Documents</span> subvolume:</p>&#13;
<pre>$ <span class="codestrong1">sudo btrfs subvolume show /evidence/Documents/</span>&#13;
Documents&#13;
        Name:               Documents&#13;
        UUID:               77e546f8-9864-c844-9edb-733da662cb6c&#13;
        Parent UUID:        -&#13;
        Received UUID:      -&#13;
        Creation time:      2020-11-29 16:53:56 +0100&#13;
        Subvolume ID:       256&#13;
        Generation:         19&#13;
        Gen at creation:    7&#13;
        Parent ID:          5&#13;
        Top level ID:       5&#13;
        Flags:              -&#13;
        Snapshot(s):</pre>&#13;
<p class="noindent">Here, the subvolume’s UUID is shown together with its creation timestamp and other flags. If a subvolume has any snapshots, they are also listed.</p>&#13;
<p class="indent">Snapshots are one of the highlights of btrfs. They utilize CoW functionality to create a snapshot of a subvolume at a particular point in time. The original subvolume remains and continues to be available for use, and a new subvolume containing the snapshot is created. Snapshots can be made read-only and are typically used for performing backups or restoring a system to a previous point in time. They can also be used to freeze a filesystem for certain types of live forensic analysis (with btrfs this is at the file level and not the block/sector level). Snapshots are interesting forensically as they may contain previous versions of files. Analyzing files in a snapshot works the same way as in any other subvolume. For example, you can find the snapshot creation timestamp by using the btrfs <span class="literal">subvolume</span> command, as shown previously:</p>&#13;
<pre>$ <span class="codestrong1">sudo btrfs subvolume show /evidence/.snapshot/</span>&#13;
.snapshot&#13;
        Name:              .snapshot&#13;
        UUID:              57912eb8-30f9-1948-b68e-742f15d9408a&#13;
...&#13;
        Creation time:     2020-11-29 16:58:28 +0100&#13;
...</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_64"/>Files in a snapshot that are unchanged share the same underlying blocks as the original subvolume from where the snapshot was taken.</p>&#13;
<h4 class="h4" id="ch00lev2_40"><strong><em>List and Extract Files</em></strong></h4>&#13;
<p class="noindent">A forensic tool with full btrfs support should be able to browse, examine, and extract files in the usual way. A major difference from other filesystems is the subvolumes. Each subvolume must be treated like a separate filesystem when examining individual files and directories (while respecting that the underlying blocks may be shared).</p>&#13;
<p class="indent">As of this writing, support for btrfs in TSK is still missing; however, the Fraunhofer FKIE filesystem tools have basic (experimental) support. Here are a few examples:</p>&#13;
<pre>$ <span class="codestrong1">fls -P pool/</span>&#13;
r/r 257:   secret.txt&#13;
$ <span class="codestrong1">fls -P pool/ -S .snapshot</span>&#13;
r/r 257:   secret.txt&#13;
$ <span class="codestrong1">fls -P pool/ -S Documents</span>&#13;
r/r 257:   report.pdf&#13;
$ <span class="codestrong1">fls -P pool/ -S Videos</span>&#13;
r/r 257:   phiberoptik.mkv</pre>&#13;
<p class="noindent">The <span class="literal">fls</span> command is used with the <span class="literal">-P</span> flag to list files from images that are in the btrfs <em>pool/</em> directory. The <span class="literal">-S</span> flag is used to specify the subvolume, including snapshots. By coincidence, the inode numbers in this example are the same in the different subvolumes. This is possible because each subvolume maintains its own inode table.</p>&#13;
<p class="indent">Files can be extracted with <span class="literal">icat</span> using the same <span class="literal">-P</span> and <span class="literal">-S</span> flags and specifying the inode number:</p>&#13;
<pre>$ <span class="codestrong1">icat -P pool/ 257</span>&#13;
The new password is "canada101"&#13;
$ <span class="codestrong1">icat -P pool/ -S .snapshot 257</span>&#13;
The password is "canada99"&#13;
$ <span class="codestrong1">icat -P pool/ -S Documents 257 &gt; report.pdf</span>&#13;
$ <span class="codestrong1">icat -P pool/ -S Videos 257 &gt; phiberoptik.mkv</span></pre>&#13;
<p class="noindent">The extracted file from <span class="literal">icat</span> is either output to the screen or redirected into a file. The file contents can then be examined on the local forensic analysis machine.</p>&#13;
<p class="indent">The <span class="literal">undelete-btrfs</span> tool (<em><a href="https://github.com/danthem/undelete-btrfs/">https://github.com/danthem/undelete-btrfs/</a></em>) attempts recovery of deleted files on a btrfs filesystem. This tool is a shell script that uses the <span class="literal">btrfs restore</span> and <span class="literal">btrfs-find-root</span> commands to search for and extract deleted files. Use these at your own risk.</p>&#13;
<p class="indent">In theory, forensic analysis of btrfs filesystems could have an increased likelihood of recovering deleted or previously written data. The CoW philosophy avoids overwriting old data, preferring to create new blocks/extents <span epub:type="pagebreak" id="page_65"/>and update the references to those disk areas, instead. Explicitly created snapshots produce a historic view of files and directories with previous contents and metadata. Forensic tools to perform such analysis will eventually arrive on the market and in the free and open source community. Until this time, more academic research on btrfs forensic analysis may be needed.</p>&#13;
<h3 class="h3" id="ch00lev1_13"><strong>An Analysis of xfs</strong></h3>&#13;
<p class="noindent">Silicon Graphics (SGI) originally developed the xfs filesystem in the early 1990s for SGI IRIX UNIX. In 2000, SGI released xfs under the Gnu General Public License (GPL), and it was subsequently ported to Linux. Later, xfs was officially merged into the mainline kernel, and today it’s supported by every major Linux distribution. It is even the default filesystem on Red Hat Enterprise Linux. The xfs wiki is the most authoritative source of information about xfs (<em><a href="https://xfs.wiki.kernel.org/">https://xfs.wiki.kernel.org/</a></em>).</p>&#13;
<p class="indent">Forensic tool support for xfs is weak compared to ext4. AccessData Imager mentions support in the 4.3 release notes, and as of this writing, only X-Ways Forensics appears to have full support. Even TSK doesn’t support it (as of this writing), although several pull requests exist on GitHub for community-contributed xfs support. Some of the examples in this section use Andrey Labunets’s xfs TSK patches (see <em><a href="https://github.com/isciurus/sleuthkit.git/">https://github.com/isciurus/sleuthkit.git/</a></em>).</p>&#13;
<p class="indent">The xfs developers include tools such as <span class="literal">xfs_db</span> and <span class="literal">xfs_info</span> for debugging and troubleshooting an xfs filesystem, which provide much of the functionality needed to forensically examine an xfs filesystem. See the xfs_info(8) and xfs_db(8) man pages for more information.</p>&#13;
<h4 class="h4" id="ch00lev2_41"><strong><em>Filesystem Metadata: Superblock</em></strong></h4>&#13;
<p class="noindent">Xfs is well documented and the filesystem data structures can be analyzed for artifacts that could be interesting for a forensic investigation. The xfs(5) man page provides a good introduction to xfs mount options, layout, and various attributes. The data structures of xfs are defined in detail in the <em>XFS Algorithms &amp; Data Structures</em> document (<em><a href="https://mirrors.edge.kernel.org/pub/linux/utils/fs/xfs/docs/xfs_filesystem_structure.pdf">https://mirrors.edge.kernel.org/pub/linux/utils/fs/xfs/docs/xfs_filesystem_structure.pdf</a></em>).</p>&#13;
<p class="indent">You can identify xfs filesystems by the magic string in the superblock:</p>&#13;
<pre>0x58465342      XFSB</pre>&#13;
<p class="noindent">This superblock magic string is found at the start of the first sector of the filesystem. There are more than 50 magic strings (or magic numbers) defined for different areas of the xfs filesystem (see <a href="ch07.xhtml">Chapter 7</a> of <em>XFS Algorithms &amp; Data Structures</em>).</p>&#13;
<p class="indent">You can use the <span class="literal">xfs_db</span> tool to print the superblock meta information. In this next example, the <span class="literal">-r</span> flag ensures the operation is read-only, the two <span epub:type="pagebreak" id="page_66"/><span class="literal">-c</span> flags are the commands needed to print the superblock, and <em>partimage.raw</em> is the forensic image file:</p>&#13;
<pre>$ <span class="codestrong1">xfs_db -r -c sb -c print partimage.raw</span>&#13;
magicnum = 0x58465342&#13;
blocksize = 4096&#13;
dblocks = 524288&#13;
...&#13;
uuid = 75493c5d-3ceb-441b-bdee-205e5548c8c3&#13;
logstart = 262150&#13;
...&#13;
fname = "Super Secret"&#13;
...</pre>&#13;
<p class="indent">Most of the xfs superblock consists of flags, statistics, block counts, and so on; however, some artifacts are interesting from a forensics perspective. The block size and total blocks (<span class="literal">dblocks</span>) are interesting to compare with the size of the partition where the filesystem resides. <span class="literal">UUID</span> is a unique identifying string. The 12-character label or filesystem name (<span class="literal">fname</span>), if defined, is specified by the owner of the system and may be interesting in an investigation. For more information about various settings during the creation of xfs filesystems, see the mkfs.xfs(8) man page.</p>&#13;
<p class="indent">TSK’s <span class="literal">fsstat</span> command with xfs patches also provides a summary of the filesystem information in the superblock:</p>&#13;
<pre>$ <span class="codestrong1">fsstat partimage.raw</span>&#13;
FILE SYSTEM INFORMATION&#13;
--------------------------------------------&#13;
File System Type: XFS&#13;
Volume Name: Super Secret&#13;
&#13;
Volume ID: 75493c5d-3ceb-441b-bdee-205e5548c8c3&#13;
Version: V5,NLINK,ALIGN,DIRV2,LOGV2,EXTFLG,MOREBITS,ATTR2,LAZYSBCOUNT,&#13;
PROJID32BIT,CRC,FTYPE&#13;
Features Compat: 0&#13;
Features Read-Only Compat: 5&#13;
Read Only Compat Features: Free inode B+tree, Reference count B+tree,&#13;
Features Incompat: 3&#13;
InCompat Features: Directory file type, Sparse inodes,&#13;
CRC: 3543349244&#13;
...</pre>&#13;
<p class="noindent">The <span class="literal">fsstat</span> output is more descriptive than the <span class="literal">xfs_db</span> output, but it provides the same information.</p>&#13;
<p class="indent">The xfs superblock is compact (one sector) and doesn’t have enriched information such as timestamps, last mount point, and so on that other filesystems may store.</p>&#13;
<h4 class="h4" id="ch00lev2_42"><span epub:type="pagebreak" id="page_67"/><strong><em>File Metadata: Inodes</em></strong></h4>&#13;
<p class="noindent">The xfs filesystem has the same concept of inodes as other Unix-styled filesystems. The inode contains the metadata and knows the blocks (or extents) associated with a file on the drive. (The inode structure is defined in <a href="ch07.xhtml">Chapter 7</a> of <em>XFS Algorithms &amp; Data Structures.</em>)</p>&#13;
<p class="indent">The <span class="literal">xfs_db</span> command can list the metadata given the file’s inode number. The parameter <span class="literal">"inode 133"</span> is in quotes in this next example because of the space separating the command and the inode number. The print parameter and partition image file is the same as the previous example:</p>&#13;
<pre>   $ <span class="codestrong1">xfs_db -r -c "inode 133" -c print partimage.raw</span>&#13;
   core.magic = 0x494e&#13;
<span class="ent">➊</span> core.mode = 0100640&#13;
   core.version = 3&#13;
   core.format = 2 (extents)&#13;
   core.nlinkv2 = 1&#13;
   core.onlink = 0&#13;
   core.projid_lo = 0&#13;
   core.projid_hi = 0&#13;
<span class="ent">➋</span> core.uid = 0&#13;
   core.gid = 0&#13;
   core.flushiter = 0&#13;
<span class="ent">➌</span> core.atime.sec = Mon Nov 30 19:57:54 2020&#13;
   core.atime.nsec = 894778100&#13;
<span class="ent">➍</span> core.mtime.sec = Mon Nov 30 19:57:54 2020&#13;
   core.mtime.nsec = 898113100&#13;
<span class="ent">➎</span> core.ctime.sec = Mon Nov 30 19:57:54 2020&#13;
   core.ctime.nsec = 898113100&#13;
   core.size = 1363426&#13;
   core.nblocks = 333&#13;
   ...&#13;
   core.immutable = 0&#13;
   core.append = 0&#13;
   core.sync = 0&#13;
   core.noatime = 0&#13;
   core.nodump = 0&#13;
   ...&#13;
   core.gen = 1845361178&#13;
   ...&#13;
<span class="ent">➏</span> v3.crtime.sec = Mon Nov 30 19:57:54 2020&#13;
   v3.crtime.nsec = 894778100&#13;
   v3.inumber = 133&#13;
<span class="ent">➐</span> v3.uuid = 75493c5d-3ceb-441b-bdee-205e5548c8c3&#13;
   ...</pre>&#13;
<p class="noindent">This example output lists the metadata of a file with inode 133. Four timestamps are found: last accessed <span class="ent">➌</span> (<span class="literal">atime</span>), last content modified <span class="ent">➍</span> (<span class="literal">mtime</span>), <span epub:type="pagebreak" id="page_68"/>last metadata change <span class="ent">➎</span> (<span class="literal">ctime</span>), and the birth/creation timestamp <span class="ent">➏</span> (<span class="literal">crtime</span>, which was added in version 3 of xfs). File ownership <span class="ent">➋</span> (<span class="literal">uid</span>/<span class="literal">gid</span>), permissions <span class="ent">➊</span> (<span class="literal">mode</span>), and other attributes are also shown. The UUID <span class="ent">➐</span> is a reference to the superblock and is not unique to the file or inode.</p>&#13;
<p class="indent">The xfs-patched TSK’s <span class="literal">istat</span> command shows similar information in a different format:</p>&#13;
<pre>$ istat partimage.raw 133&#13;
Inode: 133&#13;
Allocated&#13;
uid / gid: 0 / 0&#13;
mode: rrw-r-----&#13;
Flags:&#13;
size: 1363426&#13;
num of links: 1&#13;
&#13;
Inode Times:&#13;
Accessed:       2020-11-30 19:57:54.894778100 (CET)&#13;
File Modified:  2020-11-30 19:57:54.898113100 (CET)&#13;
Inode Modified: 2020-11-30 19:57:54.898113100 (CET)&#13;
File Created:   2020-11-30 19:57:54.894778100 (CET)&#13;
&#13;
Direct Blocks:&#13;
24 25 26 27 28 29 30 31&#13;
32 33 34 35 36 37 38 39&#13;
...</pre>&#13;
<p class="indent">Included in this formatted output is a list of allocated blocks used by the file.</p>&#13;
<h4 class="h4" id="ch00lev2_43"><strong><em>List and Extract Files</em></strong></h4>&#13;
<p class="noindent">The examples here are identical to previous TSK examples and are included for completeness. The xfs-patched TSK’s <span class="literal">fls</span> command provides file listings of an xfs filesystem in the usual <span class="literal">fls</span> way:</p>&#13;
<pre>$ <span class="codestrong1">fls -pr partimage.raw</span>&#13;
d/d 131:      Documents&#13;
r/r 132:      Documents/passwords.txt&#13;
r/r 133:      report.pdf&#13;
d/d 1048704:  Other Stuff</pre>&#13;
<p class="noindent">The <span class="literal">-l</span> flag can also be used to list file size, ownership, and timestamps. The inode numbers for each file and directory are also listed.</p>&#13;
<p class="indent">The inode numbers can be used to extract files from a forensic image as follows:</p>&#13;
<pre>$ <span class="codestrong1">icat partimage.raw 132</span>&#13;
The new password is "Supercalifragilisticexpialidocious"&#13;
$ <span class="codestrong1">icat partimage.raw 133 &gt; report.pdf</span></pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_69"/>In the first example, the output is displayed in the terminal. The second example shows extract data being redirected to a file on the forensic analysis machine.</p>&#13;
<p class="indent">Xfs also has a logging (journal) system. Analysis of the journal and other low-level analysis are beyond the scope of this book. For an additional overview on performing xfs forensics, see this five-part series of blog posts by Hal Pomeranz: <em><a href="https://righteousit.wordpress.com/2018/05/21/xfs-part-1-superblock/">https://righteousit.wordpress.com/2018/05/21/xfs-part-1-superblock/</a></em>.</p>&#13;
<p class="indent">Other projects related to xfs forensics are available on GitHub such as <em><a href="https://github.com/ianka/xfs_undelete/">https://github.com/ianka/xfs_undelete/</a></em> and <em><a href="https://github.com/aivanoffff/xfs_untruncate/">https://github.com/aivanoffff/xfs_untruncate/</a></em>. These may or may not work with your forensic image; use at your own risk.</p>&#13;
<h3 class="h3" id="ch00lev1_14"><strong>Linux Swap Analysis</strong></h3>&#13;
<p class="noindent">The forensic analysis of swap and hibernation falls under the domain of memory forensics. These topics are included here because they involve memory data that have been written to persistent storage and are accessible for a postmortem forensic examination. In this section, you’ll learn how swap areas are used, identify their location on the hard drive, and understand the potential forensic artifacts they contain.</p>&#13;
<h4 class="h4" id="ch00lev2_44"><strong><em>Identifying and Analyzing Swap</em></strong></h4>&#13;
<p class="noindent">Since the early days of computing, memory management has always been a challenge. Computers have a limited amount of high-speed volatile storage (RAM), and when that is full, the system either crashes or employs techniques to clear memory. One of those techniques is to save sections of memory to disk (which is much larger) temporarily and read it back from disk when needed. This action is managed by the kernel and is known as <em>swapping</em>. When memory is full, individual memory pages of a running system are written to special areas of disk and can be retrieved later. If both memory and swap are full, an out-of-memory (OOM) killer is employed to clear memory by selecting processes to kill based on a scoring heuristic. Unless the kernel is configured to dump core for each killed process (<span class="literal">sysctl vm.oom</span> <span class="literal">_dump_tasks</span>), nothing is saved to disk that can be forensically analyzed.</p>&#13;
<p class="indent">Swap area under Linux can be in the form of a dedicated partition on a disk, or a file on a filesystem. Most Linux distros use a separate dedicated swap partition. The DOS/MBR partition type for Linux swap is 0x82. On GPT systems, the GUID for a Linux swap partition is 0657FD6D-A4AB-43C4-84E5-0933C84B4F4F. These partitions are typically greater than or equal to the amount of memory on a system.</p>&#13;
<p class="indent">The kernel must be told what swap areas to use, which is typically done at boot time either by reading <em>/etc/fstab</em> or through a systemd swap unit file. The <em>fstab</em> file will contain a single line for each swap partition used (normally there’s only one, but there can be more). The next three examples from <em>fstab</em> are used to configure swap.</p>&#13;
<pre><span epub:type="pagebreak" id="page_70"/>UUID=3f054075-6bd4-41c2-a03d-adc75dfcd26d none swap defaults 0 0&#13;
/dev/nvme0n1p3 none swap defaults 0 0&#13;
/swapfile none swap sw 0 0</pre>&#13;
<p class="noindent">The first two lines show swap partitions identified by UUID and device file. The third example shows the use of a regular file for swap. The partitions can be extracted for examination or analyzed in place using a sector offset determined from the partition table. When a file is used for swap, that file can be copied or extracted from the image and analyzed.</p>&#13;
<p class="indent">Swap partitions can also be configured using systemd. A systemd unit file ending in <em>*.swap</em> contains information needed to set up a swap device or file, for example:</p>&#13;
<pre># <span class="codestrong1">cat /etc/systemd/system/swapfile.swap</span>&#13;
[Swap]&#13;
What=/swapfile&#13;
# <span class="codestrong1">ls -lh /swapfile</span>&#13;
-rw------- 1 root root 1.0G 23. Nov 06:24 /swapfile</pre>&#13;
<p class="noindent">This simple two-line swap unit file points to a 1GB swap file in the root directory called <em>swapfile</em>. This will add the file as swap when the system starts. See the systemd.swap(5) man page for more details.</p>&#13;
<p class="indent">If additional swap space is needed or if a file is preferred over a partition, a system administrator can create a file with the desired size and designate it as swap. There’s no standard naming conventions for swap files, although some distros and many tutorials use <em>swapfile</em> as the name. There is also no standard location for swap files, but the root (/) directory is typical.</p>&#13;
<p class="indent">You can identify a swap partition (or file) by a 10-character signature string located at byte offset 4086 (0xFF6):</p>&#13;
<pre>00000ff6: 5357 4150 5350 4143 4532 SWAPSPACE2</pre>&#13;
<p class="noindent">This signature string is either <span class="literal">SWAPSPACE2</span> or <span class="literal">SWAP-SPACE</span>. It indicates that the partition or file has been set up for use as swap (using the <span class="literal">mkswap</span> command).</p>&#13;
<p class="indent">The Linux <span class="literal">file</span> command can also be used to identify swap files and provide basic information:<sup><a id="ch03foot012" href="footnotes.xhtml#ch03foot_012">12</a></sup></p>&#13;
<pre># <span class="codestrong1">file swapfile</span>&#13;
swapfile: Linux swap file, 4k page size, little endian, version 1, size 359674&#13;
pages, 0 bad pages, no label, UUID=7ed18640-0569-43af-998b-aabf4446d71d</pre>&#13;
<p class="noindent">The system administrator can generate a 16-character label. The UUID is randomly generated and should be unique.</p>&#13;
<p class="indent">To analyze the swap on a separate analysis machine, a swap partition can be acquired from the drive (with <span class="literal">dd</span> or an equivalent command) into a forensic image file and a swap file can be simply copied. The swap partition or <span epub:type="pagebreak" id="page_71"/>file may contain fragments of memory from processes that were temporarily swapped to disk.</p>&#13;
<p class="indent">The scope of memory analysis in this book is limited to identification, searching, and carving, which can reveal many interesting artifacts. For example, carving for strings using <span class="literal">bulk_extractor</span> (<em><a href="https://forensicswiki.xyz/wiki/index.php?title=Bulk_extractor">https://forensicswiki.xyz/wiki/index.php?title=Bulk_extractor</a></em>) will extract the following:</p>&#13;
<ul>&#13;
<li class="noindent">Credit card numbers and track 2 information</li>&#13;
<li class="noindent">Domain names</li>&#13;
<li class="noindent">Email addresses</li>&#13;
<li class="noindent">IP addresses</li>&#13;
<li class="noindent">Ethernet MAC addresses</li>&#13;
<li class="noindent">URLs</li>&#13;
<li class="noindent">Telephone numbers</li>&#13;
<li class="noindent">EXIF data from media files (photos and videos)</li>&#13;
<li class="noindent">Custom-specified regex strings</li>&#13;
</ul>&#13;
<p class="indent">In addition to carving for strings, we can also carve for files. Standard carving tools (like <span class="literal">foremost</span>, for example) can be used to attempt extraction of files or file fragments from swap.</p>&#13;
<h4 class="h4" id="ch00lev2_45"><strong><em>Hibernation</em></strong></h4>&#13;
<p class="noindent">Most PCs today have the ability to suspend various hardware components or the entire system into power-saving modes. This is typically done using the ACPI interface and is controlled by various userspace tools.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_72"/>If a swap partition or file is greater than or equal to the size of the system’s physical memory, the physical memory can be suspended to disk for hibernation. With the entire contents of memory saved to disk (in the swap partition), the OS can be halted and the machine powered off. When the machine powers back on, the bootloader is run and the kernel is started. If the kernel finds a suspended (hibernated) state, it will start the resume process to bring back the system’s last running state. There are other power-saving modes, but this one is particularly interesting from a forensics perspective because the entire contents of memory are saved to disk and can be analyzed.</p>&#13;
<p class="indent">The bootloader can pass the <span class="literal">resume=</span> parameter to the kernel with a partition device like <em>/dev/sdaX</em> or a UUID. The parameter tells the kernel where to look for a possible hibernated image. For example:</p>&#13;
<pre>resume=UUID=327edf54-00e6-46fb-b08d-00250972d02a</pre>&#13;
<p class="indent">The <span class="literal">resume=</span> parameter instructs the kernel to search for a block device with the UUID of <span class="literal">327edf54-00e6-46fb-b08d-00250972d02a</span> and checks whether it should resume from hibernation.</p>&#13;
<p class="indent">A swap partition (or file) contains a hibernation memory image if the string <span class="literal">S1SUSPEND</span> is found at byte offset 4086 (0xFF6):</p>&#13;
<pre>00000ff6: 5331 5355 5350 454e 4400 S1SUSPEND.</pre>&#13;
<p class="noindent">This offset is the same as the one mentioned in the previous section about regular swap partitions. When the system goes into hibernation, the string <span class="literal">SWAPSPACE2</span> (or <span class="literal">SWAP-SPACE</span>) is overwritten with <span class="literal">S1SUSPEND</span> and changed back when the system boots and resumes from hibernation. Basic forensic tools or a hex editor can be used to check for the existence of this string on an acquired image.</p>&#13;
<p class="indent">The <span class="literal">file</span> command can also be used to check the swap file or forensic image of the swap partition to see whether the system is in a hibernated state:</p>&#13;
<pre>$ <span class="codestrong1">file swapfile</span>&#13;
swapfile: Linux swap file, 4k page size, little endian, version 1, size 359674 pages,&#13;
0 bad pages, no label, UUID=7ed18640-0569-43af-998b-aabf4446d71d, with SWSUSP1 image</pre>&#13;
<p class="noindent">The <span class="literal">with SWSUSP1 image</span> string at the end of the file output indicates that the file contains a hibernation image.</p>&#13;
<p class="indent">A hibernation swap partition with a full memory dump contains a wealth of information, some of it sensitive (passwords, keys, and so on). In 2005, a kernel patch was proposed to implement encrypted hibernation (it included the compilation flag <span class="literal">SWSUSP_ENCRYPT</span>). The patch was removed a short time later because the decryption key was stored unencrypted on the disk and several kernel developers were against it.<sup><a id="ch03foot013" href="footnotes.xhtml#ch03foot_013">13</a></sup> The community recommended that <span class="literal">dm-crypt</span>-based encryption like the Linux Unified Key Setup (LUKS) be used, instead. Some installations may use LUKS to encrypt swap, and those must be decrypted before analyzing. In the case of LUKS, the partition is encrypted at the block layer, and decrypting (assuming the key is available) with <span class="literal">cryptsetup</span> on an analysis machine will reveal the hibernation contents. (Decrypting LUKS is described in the next section.)</p>&#13;
<p class="indent">The same carving techniques described in the previous section can be used on the hibernation image, as well. A search for cryptographic keys may also yield interesting results.</p>&#13;
<p class="indent">Research has been done on the use of compression in swap and hibernation images, which may limit what can be easily carved from the file or partition. See <em><a href="https://www.cs.uno.edu/~golden/Papers/DFRWS2014-1.pdf">https://www.cs.uno.edu/~golden/Papers/DFRWS2014-1.pdf</a></em> for more information.</p>&#13;
<h3 class="h3" id="ch00lev1_15"><strong>Analyzing Filesystem Encryption</strong></h3>&#13;
<p class="noindent">Encryption has traditionally been the greatest challenge for the digital forensics community. The focus of encryption is restricting access to data, whereas <span epub:type="pagebreak" id="page_73"/>the focus of forensics is gaining access to data. This fundamental conflict remains unresolved and continues to be discussed.</p>&#13;
<p class="indent">It has become common practice to encrypt stored information. This encryption can take place at multiple layers:</p>&#13;
<ul>&#13;
<li class="noindent">Application file encryption: protected PDF, office documents, and so on</li>&#13;
<li class="noindent">Individual file containers: GPG, encrypted zip</li>&#13;
<li class="noindent">Directories: eCryptfs, fscrypt</li>&#13;
<li class="noindent">Volumes: TrueCrypt/Veracrypt</li>&#13;
<li class="noindent">Block devices: Linux LUKS, Microsoft Bitlocker, Apple FileVault</li>&#13;
<li class="noindent">Drive hardware: OPAL/SED (self-encrypting drive)</li>&#13;
</ul>&#13;
<p class="indent">This section focuses on three Linux encryption technologies: LUKS, eCryptfs, and fscrypt (formerly ext4 directory encryption). Other file and filesystem encryption systems for Linux are available but aren’t covered here because they either aren’t specific to Linux or are too obscure and rarely used.</p>&#13;
<p class="indent">Decrypting protected data requires a password/passphrase or a copy of the cryptographic key (a string or key file). The forensic challenge is to find the decryption key. Some methods known to be used (some are obviously not used by the forensics community) for password/key recovery include:</p>&#13;
<ul>&#13;
<li class="noindent">Brute-force with dictionary-based attacks to find simple passwords</li>&#13;
<li class="noindent">Brute-force with GPU clusters for fast exhaustive password search</li>&#13;
<li class="noindent">Cryptanalysis (mathematical weakness, reduce keyspace)</li>&#13;
<li class="noindent">Finding passwords saved, written, or transferred previously</li>&#13;
<li class="noindent">Password reuse across multiple accounts or devices</li>&#13;
<li class="noindent">Legal requirement to produce passwords in court</li>&#13;
<li class="noindent">Cooperative system owner or accomplice with the password</li>&#13;
<li class="noindent">Key backup/escrow in enterprise environments</li>&#13;
<li class="noindent">Device exploit, vulnerability, or backdoor</li>&#13;
<li class="noindent">Keyloggers or keyboard visibility (HD video cameras or telescope)</li>&#13;
<li class="noindent">Rainbow tables: Precomputed table of cryptographic hashes</li>&#13;
<li class="noindent">Extract keys from memory: PCI-bus DMA attacks, hibernation</li>&#13;
<li class="noindent">Man-in-the-middle attacks on network traffic</li>&#13;
<li class="noindent">Social engineering</li>&#13;
<li class="noindent">Forced or unwitting biometric identity theft</li>&#13;
<li class="noindent">Torture, blackmail, coercion, or other malicious means (see <a href="ch03.xhtml#ch03fig03">Figure 3-3</a>)</li>&#13;
</ul>&#13;
<p class="noindent">Linux tools that attempt technical password/key recovery include John the Ripper, Hashcat, and Bulk_Extractor.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_74"/><img id="ch03fig03" src="Images/ch03fig03.jpg" alt="Image" width="556" height="340"/></div>&#13;
<p class="figcap"><em>Figure 3-3: XKCD on ISO 8601 (</em> <span class="normal"><a href="https://xkcd.com/538/">https://xkcd.com/538/</a></span><em>)</em></p>&#13;
<p class="indent">This section explains how the encryption works, how to identify the use of encryption, and how to extract metadata of the encrypted volume or directory. Decryption is also explained, with the assumption that the key is already known.</p>&#13;
<h4 class="h4" id="ch00lev2_46"><strong><em>LUKS Full-Disk Encryption</em></strong></h4>&#13;
<p class="noindent">LUKS<sup><a id="ch03foot014" href="footnotes.xhtml#ch03foot_014">14</a></sup> is a standard format for encrypted storage. The specification is at <em><a href="https://gitlab.com/cryptsetup/cryptsetup/">https://gitlab.com/cryptsetup/cryptsetup/</a></em> and the reference implementation is the <span class="literal">cryptsetup</span> software package. See the cryptsetup(8) man page for more information. If your commercial forensic software doesn’t support the analysis and decryption of LUKS volumes, you can examine a forensic image on a Linux analysis machine.</p>&#13;
<p class="indent">LUKS volumes may be created with or without a partition table on a drive. The DOS partition type<sup><a id="ch03foot015" href="footnotes.xhtml#ch03foot_015">15</a></sup> of 0xE8 and the GPT GUID partition type<sup><a id="ch03foot016" href="footnotes.xhtml#ch03foot_016">16</a></sup> of CA7D7CCB-63ED-4C53-861C-1742536059CC are designated for LUKS volumes. If used, these partition types may indicate the existence of a LUKS volume. However, be aware that not all tools recognize those partition types (<span class="literal">unknown</span> in <span class="literal">fdisk</span>, for example), and LUKS partitions are sometimes created using the standard (generic) Linux partition types.</p>&#13;
<p class="indent">On boot, Linux systems will read the <em>/etc/crypttab</em> file to set up encrypted filesystems. This file is useful to analyze because it shows what is encrypted, where the password comes from, and other options. The <em>crypttab</em> file has four fields:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><span class="codestrong">name</span>    The name of the block device to appear in <em>/dev/mapper/</em></p>&#13;
<p class="noindentin"><span epub:type="pagebreak" id="page_75"/><span class="codestrong">device</span>    A UUID or device of an encrypted volume</p>&#13;
<p class="noindentin"><span class="codestrong">password</span>    The password source, either a key file or manual entry (“<span class="literal">none</span>” or “<span class="literal">-</span>” indicate manual entry)</p>&#13;
<p class="noindentin"><span class="codestrong">options</span>    Information about the crypto algorithms, configuration, and other behavior</p>&#13;
</div>&#13;
<p class="indent">The following are some example lines from <em>/etc/crypttab</em> that encrypt the root directory and swap partition:</p>&#13;
<pre>#  &lt;name&gt;  &lt;device&gt;  &lt;password&gt;  &lt;options&gt;&#13;
root-crypt UUID=2505567a-9e27-4efe-a4d5-15ad146c258b none luks,discard&#13;
swap-crypt /dev/sda7 /dev/urandom swap</pre>&#13;
<p class="noindent">Here, <span class="literal">swap-crypt</span> and <span class="literal">root-crypt</span> will be the decrypted devices in <em>/dev/mapper/</em>. A password is requested for root (<span class="literal">none</span>) and swap is randomly generated. The <em>crypttab</em> file may also exist in the initramfs. Some administrators want to reboot servers without entering a password, so they may hide the key file somewhere. This file may also exist in a backup.</p>&#13;
<p class="indent">A LUKS volume can be identified by an initial six-byte magic string and a two-byte version string (version 1 or 2), as follows:</p>&#13;
<pre>4C55 4B53 BABE 0001 LUKS....&#13;
4C55 4B53 BABE 0002 LUKS....</pre>&#13;
<p class="noindent">If a LUKS partition is suspected but not found in the normal partition table, this (magic) hex string can be used as a search pattern. A valid search hit should also start at the beginning of a drive sector.</p>&#13;
<p class="indent">The LUKS kernel module encrypts data at the block layer, below the filesystem. An encrypted LUKS partition has a header describing the algorithms used, keyslots, a unique identifier (UUID), a user-specified label, and other information. You can extract the header of a LUKS volume by using the <span class="literal">cryptsetup luksDump</span> command, either with an attached device (using a write blocker) or a raw forensic image file; for example:</p>&#13;
<pre># <span class="codestrong1">cryptsetup luksDump /dev/sdb1</span>&#13;
LUKS header information&#13;
Version:        2&#13;
Epoch:          5&#13;
Metadata area:  16384 [bytes]&#13;
Keyslots area:  16744448 [bytes]&#13;
UUID:           246143fb-a3ec-4f2e-b865-c3a3affab880&#13;
Label:          My secret docs&#13;
Subsystem:      (no subsystem)&#13;
Flags:          (no flags)&#13;
&#13;
Data segments:&#13;
  0: crypt&#13;
        offset: 16777216 [bytes]&#13;
    &#13;
        <span epub:type="pagebreak" id="page_76"/>length: (whole device)&#13;
        cipher: aes-xts-plain64&#13;
        sector: 512 [bytes]&#13;
&#13;
Keyslots:&#13;
 1: luks2&#13;
       Key:        512 bits&#13;
       Priority:   normal&#13;
       Cipher:     aes-xts-plain64&#13;
       Cipher key: 512 bits&#13;
       PBKDF:      argon2i&#13;
       Time cost:  4&#13;
       Memory:     964454&#13;
       Threads:    4&#13;
       Salt:       8a 96 06 13 38 5b 61 80 c3 59 75 87 f7 31 43 87&#13;
                  54 dd 32 8c ea c0 b2 8b e5 bc 77 23 11 fb e9 34&#13;
       AF stripes: 4000&#13;
       AF hash:    sha256&#13;
       Area offset:290816 [bytes]&#13;
       Area length:258048 [bytes]&#13;
       Digest ID:  0&#13;
Tokens:&#13;
Digests:&#13;
  0: pbkdf2&#13;
        Hash:       sha256&#13;
        Iterations: 110890&#13;
        Salt:       74 a3 81 df d7 f0 f5 0d d9 c6 3d d8 98 5a 16 11&#13;
                   7c c2 ea cb 06 7f e9 b1 37 0b 66 24 3c 69 e1 ce&#13;
        Digest:    17 ad cb 13 16 f2 cd e5 d8 ea 49 d7 a4 89 bc e0&#13;
                  00 a0 60 e8 95 6b e1 e2 19 4b e7 07 24 f4 73 cb</pre>&#13;
<p class="noindent">The LUKS header doesn’t contain any timestamps indicating creation or last used dates. If the label is specified, it can be interesting in an investigation. The label is a text field defined by the user and may contain a description of the encrypted contents. The key slots can also be of interest from a forensics perspective. A LUKS volume can have up to eight keys, which is potentially eight different passwords where recovery can be attempted.</p>&#13;
<p class="indent">Creating backup copies of the LUKS header is a recommended practice, and copies may exist. If different (possibly known) passwords were used at the time of the backup, they could provide access to encrypted LUKS data. The <span class="literal">cryptsetup</span> tool provides <span class="literal">luksHeaderBackup</span> and <span class="literal">luksHeaderRestore</span> subcommands that create and restore LUKS header backups. This backup could also be made by using <span class="literal">dd</span> because it simply contains a copy of the raw bytes up to the data segment offset (16,777,216 bytes, or 32,768 sectors in this example).</p>&#13;
<p class="indent">To decrypt a LUKS volume on a Linux analysis machine, the forensic image must be accessible as a block device (<span class="literal">cryptsetup</span> can’t unlock regular <span epub:type="pagebreak" id="page_77"/>files). The <span class="literal">luksOpen</span> subcommand creates a new device with access to the decrypted volume:</p>&#13;
<pre># <span class="codestrong1">cryptsetup luksOpen --readonly /dev/sdb1 evidence</span>&#13;
Enter passphrase for /dev/sdb1:&#13;
# <span class="codestrong1">fsstat /dev/mapper/evidence</span>&#13;
FILE SYSTEM INFORMATION&#13;
--------------------------------------------&#13;
File System Type: Ext4&#13;
Volume Name:&#13;
Volume ID: 6c7ed3581ee94d952d4d120dd29718d2&#13;
&#13;
Last Written at: 2020-11-20 07:14:14 (CET)&#13;
Last Checked at: 2020-11-20 07:13:52 (CET)&#13;
...</pre>&#13;
<p class="noindent">A new block device <em>/dev/mapper/evidence</em> is created with the decrypted LUKS volume contents. In this example, an ext4 filesystem is revealed. Even though the device should be protected with a write blocker, the <span class="literal">--readonly</span> can be included as a matter of diligence. The device can be removed with the <span class="literal">luksClose</span> subcommand (<span class="literal">cryptsetup luksClose evidence</span>).</p>&#13;
<p class="indent">The password cracker John the Ripper currently supports attempting to recover LUKS version 1 passwords (check the latest source code at <em><a href="https://github.com/openwall/john/">https://github.com/openwall/john/</a></em> to see if version 2 support has been added). Some installations may still use LUKS version 1.</p>&#13;
<p class="indent">The new <span class="literal">systemd-homed</span> uses LUKS by default to encrypt home directories. As of this writing, <span class="literal">systemd-homed</span> is newly proposed and not widely used. The analysis techniques shown in this section should work on any LUKS-encrypted volume.</p>&#13;
<h4 class="h4" id="ch00lev2_47"><strong><em>eCryptfs Encrypted Directories</em></strong></h4>&#13;
<p class="noindent">During installation, some Linux distros offer the possibility to encrypt the user’s home directory or a subdirectory (instead of full-disk encryption like LUKS).</p>&#13;
<p class="indent">Until recently, eCryptfs was the most common directory-based encryption system, using a stacked filesystem implementation. Other directory-based systems include EncFS and cryptfs (which is based on ext4’s built-in directory encryption). This section covers eCryptfs. The future of eCryptfs is not clear. Some distros have deprecated eCryptfs, and Debian has removed it due to incompatibilities with systemd.</p>&#13;
<p class="indent">An eCryptfs system has three main directory components: the encrypted directory tree (often a hidden directory named <em>.Private/</em>), the mount point for the decrypted directory tree, and a hidden directory for the passphrase and various state files (often named <em>.ecryptfs/</em> and in the same directory as <em>.Private/</em>).</p>&#13;
<p class="indent">When used to encrypt entire home directories, some distros place each user’s <em>.Private/</em> and <em>.ecryptfs/</em> in a separate <em>/home/.ecryptfs/</em> directory. The <span epub:type="pagebreak" id="page_78"/>normal user home locations are then used as mount points for the decrypted directories. In this example from Linux Mint, these three directories belong to the user Sam:</p>&#13;
<pre>/home/.ecryptfs/sam/.ecryptfs/&#13;
/home/.ecryptfs/sam/.Private/&#13;
/home/sam/</pre>&#13;
<p class="noindent">The first directory contains user Sam’s passphrase file and other information. The second directory contains the encrypted files and directories of the user Sam. The last directory is the mount point used by the eCryptfs system, providing decrypted access to the user’s home directory.</p>&#13;
<p class="indent">In some cases, a user may wish to encrypt only a subdirectory of their home directory instead of encrypting everything. The following eCryptfs directory structure is a typical configuration:</p>&#13;
<pre>/home/sam/.ecryptfs/&#13;
/home/sam/.Private/&#13;
/home/sam/Private/</pre>&#13;
<p class="noindent">Here again, the <em>.ecryptfs/</em> hidden directory contains the passphrase and supporting files, <em>.Private/</em> is a hidden directory containing the encrypted files, and <em>Private/</em> is the mount point where the decrypted files are found. When performing a forensic examination, a search for any directory called <em>.ecryptfs</em> is an indicator that eCryptfs was used. The <em>Private.mnt</em> file indicates the location of the decrypted mount point.</p>&#13;
<p class="indent">File and directory names are also encrypted to hide information about the file type or contents. The following is an example of an encrypted filename (<em>secrets.txt</em>):</p>&#13;
<pre>ECRYPTFS_FNEK_ENCRYPTED.FWb.MkIpyP2LoUSd698zVj.LP4tIzB6lyLWDy1vKIhPz8WBMAYFCpelfHU--</pre>&#13;
<p class="noindent">When performing a forensic examination, a search for files prefixed with <span class="literal">ECRYPTFS_FNEK_ENCRYPTED.*</span> reveals that eCryptfs was used.</p>&#13;
<p class="indent">The contents and filenames are encrypted, but there is some metadata that could be useful for an investigation. Here we compare the stat output (information from the inode) for both an encrypted and decrypted file:</p>&#13;
<pre>   $ <span class="codestrong1">stat Private/secrets.txt</span>&#13;
     File: Private/secrets.txt&#13;
  <span class="ent">➊</span> Size: 18     Blocks: 24     IO Block: 4096  regular file&#13;
   Device: 47h/71d Inode: 33866440  Links: 1&#13;
   Access: (0640/-rw-r-----) Uid: ( 1000/   sam)  Gid: ( 1000/   <span class="ent">➋</span> sam)&#13;
<span class="ent">➌</span> Access: 2020-11-21 10:14:56.092400513 +0100&#13;
   Modify: 2020-11-21 09:14:45.430398866 +0100&#13;
   Change: 2020-11-21 14:27:43.233570339 +0100&#13;
    Birth: -&#13;
   ...&#13;
   $ <span class="codestrong1">stat .Private/ECRYPTFS_FNEK_ENCRYPTED.FWb.MkIpyP2LoUSd698zVj.</span>&#13;
   <span class="codestrong1">LP4tIzB6lyLWDy1vKIhPz8WBMAYFCpelfHU--</span>&#13;
   <span epub:type="pagebreak" id="page_79"/>File: .Private/ECRYPTFS_FNEK_ENCRYPTED.FWb.MkIpyP2LoUSd698zVj.&#13;
   LP4tIzB6lyLWDy1vKIhPz8WBMAYFCpelfHU--&#13;
 <span class="ent">➊</span> Size: 12288     Blocks: 24     IO Block: 4096  regular file&#13;
  Device: 1bh/27d Inode: 33866440  Links: 1&#13;
  Access: (0640/-rw-r-----) Uid: ( 1000/   sam)  Gid: ( 1000/   <span class="ent">➋</span> sam)&#13;
<span class="ent">➌</span> Access: 2020-11-21 10:14:56.092400513 +0100&#13;
   Modify: 2020-11-21 09:14:45.430398866 +0100&#13;
   Change: 2020-11-21 14:27:43.233570339 +0100&#13;
    Birth: 2020-11-21 09:14:45.430398866 +0100</pre>&#13;
<p class="noindent">The encrypted files have the same timestamps <span class="ent">➌</span>, permissions, and ownership <span class="ent">➋</span> as their decrypted counterparts. The file sizes <span class="ent">➊</span> are different, and encrypted files will be at least 12,288 bytes in size. When mounted, the encrypted and decrypted files show the same inode number (even though they are on different mounted filesystems).</p>&#13;
<p class="indent">The decrypted files are available only when mounted on a running system. To access the decrypted content (assuming that the passphrase is known), the encrypted directory can be copied to an analysis system and decrypted. To do this, install the <span class="literal">ecryptfs-utils</span> software package, copy the three directories (<em>.ecryptfs/</em>, <em>.Private/</em>, and <em>Private/</em>), and run <span class="codestrong">ecryptfs-mount-private</span>. The passphrase should be requested, and the decryption directory (<em>Private/</em>) will be mounted. The inode number can be used to match corresponding encrypted and decrypted files (the <span class="literal">ecryptfs-find</span> tool can also do this).</p>&#13;
<p class="indent">To unmount (make encrypted files unavailable), run the <span class="literal">ecryptfs-umount</span> <span class="literal">-private</span> command. See the mount.ecryptfs_private(1) man page for alternative locations and ways of decrypting.</p>&#13;
<p class="indent">Two passwords are associated with an eCryptfs directory: a <em>mount passphrase</em> and a <em>wrapping passphrase</em>. By default, the mount passphrase is a randomly generated 32-character hexadecimal string, which the user may be asked to save in case of emergency (if they forgot their wrapping passphrase). This mount passphrase is provided to the kernel to mount and decrypt the files. The wrapping passphrase protects the mount passphrase and is chosen by the user, who can change it without affecting the encrypted files. The wrapping passphrase is often the same as the user’s login password.</p>&#13;
<p class="indent">In a forensic examination, a successful search for this backup passphrase may allow access to the encrypted files. If the mount passphrase is discovered, a new wrapping passphrase can be set using the <span class="literal">ecryptfs-wrap-passphrase</span> command. This newly set passphrase can then be used to mount the eCryptfs directory.</p>&#13;
<p class="indent">As a last resort, the password cracker John the Ripper supports attempting to recover eCryptfs passwords. In the following example, we first extract information from the eCryptfs wrapped-passphrase file and save it in a format that John the Ripper can understand. We then run <span class="codestrong">john</span> to crack it:</p>&#13;
<pre>$ <span class="codestrong1">ecryptfs2john.py .ecryptfs/wrapped-passphrase &gt; ecryptfs.john</span>&#13;
$ <span class="codestrong1">john ecryptfs.john</span>&#13;
Using default input encoding: UTF-8&#13;
Loaded 1 password hash (eCryptfs [SHA512 128/128 AVX 2x])&#13;
<span epub:type="pagebreak" id="page_80"/>Will run 4 OpenMP threads&#13;
Proceeding with single, rules:Single&#13;
Press 'q' or Ctrl-C to abort, almost any other key for status&#13;
Almost done: Processing the remaining buffered candidate passwords, if any.&#13;
Proceeding with wordlist:/usr/share/john/password.lst&#13;
canada           (wrapped-passphrase)&#13;
1g 0:00:01:35 DONE 2/3 (2020-11-20 15:57) 0.01049g/s 128.9p/s 128.9c/s&#13;
128.9C/s 123456..maggie&#13;
Use the "--show" option to display all of the cracked passwords reliably&#13;
Session completed.</pre>&#13;
<p class="noindent">After some number-crunching and wordlist brute-forcing, John the Ripper discovers the ecryptfs password is <span class="literal">canada</span>.</p>&#13;
<h4 class="h4" id="ch00lev2_48"><strong><em>Fscrypt and Ext4 Directory Encryption</em></strong></h4>&#13;
<p class="noindent">The Linux kernel provides the ability to encrypt files and directories at the filesystem level (in contrast to the block level of LUKS) using fscrypt. Originally, this was part of ext4, but it’s been abstracted to support other filesystems (like F2FS, for example). This kernel API is described here: <em><a href="https://www.kernel.org/doc/html/latest/filesystems/fscrypt.html">https://www.kernel.org/doc/html/latest/filesystems/fscrypt.html</a></em>. You can use userspace tools like <span class="literal">fscrypt</span> or <span class="literal">fscryptctl</span> to set up the kernel and lock and unlock encryption for specified directories.</p>&#13;
<p class="indent">Evidence of the use of fscrypt can be found in several places. The ext4 filesystem will show artifacts indicating that fscrypt capability is available:</p>&#13;
<pre>$ <span class="codestrong1">dumpe2fs -h partimage.raw</span>&#13;
...&#13;
Filesystem features:      has_journal ext_attr resize_inode dir_index filetype&#13;
needs_recovery extent 64bit flex_bg encrypt sparse_super large_file huge_file&#13;
dir_nlink extra_isize metadata_csum&#13;
...</pre>&#13;
<p class="noindent">Note the <span class="literal">encrypt</span> feature in the superblock output. Support for fscrypt is typically not enabled by default (mainly for backward compatibility). If this is enabled, it does not imply that fscrypt encryption is being used; however, it indicates that it was explicitly enabled, meaning that further examination should be done.</p>&#13;
<p class="indent">Some fscrypt userspace tools may create traces on the system. For example, fscrypt from Google (<em><a href="https://github.com/google/fscrypt/">https://github.com/google/fscrypt/</a></em>) creates a configuration file <em>/etc/fscrypt.conf</em> and a hidden directory <em>/.fscrypt/</em> in the root of the filesystem. Searching for those files indicates use of fscrypt functionality. Another (possible) indicator is the existence of long, cryptic filenames that can’t be copied. The following output is from an fscrypt directory in locked and unlocked states, respectively:</p>&#13;
<pre>$ <span class="codestrong1">ls KEEPOUT/</span>&#13;
GpJCNtGVcwD7bkNVer7dWV8aTlb8gt2PP3,pG23vDQtRTldW1zpS7D&#13;
OWmj3cUXuNmIMZN6VP+qiE8DgR0ZZAXwVynF5ftvSaBBmayI9dq3HA&#13;
<span epub:type="pagebreak" id="page_81"/>...&#13;
$ <span class="codestrong1">ls KEEPOUT/</span>&#13;
report.doc video.mpeg</pre>&#13;
<p class="indent">Unlike eCryptfs, the encrypted files can’t be copied to the analysis machine. The filesystem can’t access the files without the key:</p>&#13;
<pre>$ <span class="codestrong1">cp KEEPOUT/* /evidence/</span>&#13;
cp: cannot open 'KEEPOUT/GpJCNtGVcwD7bkNVer7dWV8aTlb8gt2PP3,pG23vDQtRTldW1zpS7D'&#13;
for reading: Required key not available&#13;
cp: cannot open 'KEEPOUT/OWmj3cUXuNmIMZN6VP+qiE8DgR0ZZAXwVynF5ftvSaBBmayI9dq3HA'&#13;
for reading: Required key not available</pre>&#13;
<p class="indent">Decrypted access to the directory is possible only if the entire filesystem is accessible on the forensic analysis machine and encryption is configured in the kernel. The userspace tool used to encrypt the directory must also be installed on the analysis machine. If the passphrase is known, the encrypted directory can be accessed. The file <em>/etc/fscrypt.conf</em> on the forensic analysis machine and the suspect drive should be compared, and this file may need to be copied (it contains configuration data).</p>&#13;
<p class="indent">The following example shows the <span class="literal">fscrypt</span> tool used to access evidence on an encrypted directory of an ext4 filesystem:</p>&#13;
<pre># <span class="codestrong1">mount /dev/sdb /evidence/</span>&#13;
# <span class="codestrong1">fscrypt unlock /evidence/KEEPOUT/</span>&#13;
Enter custom passphrase for protector "sam":&#13;
"/evidence/KEEPOUT/" is now unlocked and ready for use.</pre>&#13;
<p class="noindent">In the first line, the ext4 partition is mounted on <em>/evidence/</em> (it’s still a normal filesystem; nothing unusual here). In the second line, the <span class="literal">fscrypt unlock</span> command specifies the encrypted directory and a passphrase is requested. The required key information is stored in the <em>.fscrypt/</em> directory in the root of the drive, but the passphrase is needed to decrypt it.</p>&#13;
<p class="indent">The metadata is not encrypted under fscrypt. The inode information (using <span class="literal">stat</span> or <span class="literal">istat</span>) will be the same whether the directory is locked or unlocked. Timestamps, ownership, permissions, and so on are all visible even if the directory is encrypted (locked).</p>&#13;
<h3 class="h3" id="ch00lev1_16"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, I have explained the forensic analysis of storage. You have learned to examine the drive layout and partition tables, RAID, and LVM. The three most popular Linux filesystems have been explained, with a focus on analysis and recovering interesting forensic artifacts. Clearly the community’s forensic tool development is lacking in some areas, but this is an evolving area of research that will mature over time.<span epub:type="pagebreak" id="page_82"/></p>&#13;
</div></body></html>