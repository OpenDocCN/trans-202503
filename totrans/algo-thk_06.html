<html><head></head><body>
<h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_197"/><span class="big">6</span><br/>SHORTEST PATHS IN WEIGHTED GRAPHS</h2>
<div class="image1"><img alt="Image" src="../images/common1.jpg"/></div>
<p class="noindenta">This chapter generalizes what we learned in <a href="ch05.xhtml">Chapter 5</a> about finding shortest paths. In <a href="ch05.xhtml">Chapter 5</a>, our focus was on finding the minimum number of moves needed to solve a problem. Now, what if we care not about the minimum number of moves but about the minimum amount of time or distance? Think about using a GPS app to get home. Maybe there’s a route to get home using only one street that takes 10 minutes. Maybe there’s another way that involves using three streets that takes only eight minutes in total. We might prefer using the three streets, since they save us time.</p>
<p class="indent">In this chapter, we’ll learn <em>Dijkstra’s algorithm</em> for finding shortest paths in weighted graphs. We’ll use it to determine the number of mice that can escape a maze within a time limit and the number of shortest paths between someone’s home and their grandma’s house. I chose that grandma example in particular to reprise a discovery we made in <a href="ch05.xhtml">Chapter 5</a>: that, suitably modified, algorithms such as BFS and Dijkstra’s can do much more than “find <span epub:type="pagebreak" id="page_198"/>the shortest path.” We’re learning algorithms—deservedly famous ones—but also stocking up on flexible problem-solving tools. Let’s go!</p>
<h3 class="h3" id="lev38">Problem 1: Mice Maze</h3>
<p class="noindent">This is UVa problem <code>1112</code>.</p>
<h4 class="h4" id="sec82"><em>The Problem</em></h4>
<p class="noindent">A maze consists of cells and passages. Each passage leads from some cell <em>a</em> to some other cell <em>b</em>, and it takes <em>t</em> time units to walk the passage. For example, it may take 5 time units to walk from Cell 2 to Cell 4. Now for the passage going the other way: it may take 70 time units to walk from Cell 4 to Cell 2, or there may be no passage at all from Cell 4 to Cell 2—the <em>a</em> <em>→</em> <em>b</em> and <em>b</em> <em>→</em> <em>a</em> passages are independent. One of the cells of the maze is designated as the exit cell.</p>
<p class="indent">There’s a lab mouse in each cell, including the exit cell. The mice have been trained to walk to the exit cell in as little time as possible. Our task is to determine the number of mice that can reach the exit cell within a specified time limit.</p>
<h5 class="h5">Input</h5>
<p class="noindent">The first line of input gives the number of test cases and is followed by a blank line. There’s also a blank line between each pair of test cases. Each test case consists of the following lines:</p>
<ul>
<li class="noindent">A line containing <em>n</em>, the number of cells in the maze. Cells are numbered 1 to <em>n</em>; <em>n</em> is at most 100.</li>
<li class="noindent">A line containing <em>e</em>, the exit cell. <em>e</em> is between 1 and <em>n</em>.</li>
<li class="noindent">A line containing <em>t</em>, the integer time limit for the mice to get to the exit cell. <em>t</em> is at least zero.</li>
<li class="noindent">A line containing <em>m</em>, the number of passages in the maze.</li>
<li class="noindent"><em>m</em> lines, each describing a passage in the maze. Each such line contains three integers: the first cell <em>a</em> (between 1 and <em>n</em>), the second cell <em>b</em> (between 1 and <em>n</em>), and the time (at least zero) it takes to walk from <em>a</em> to <em>b</em>.</li>
</ul>
<h5 class="h5">Output</h5>
<p class="noindent">For each test case, output the number of mice that reach the exit cell <em>e</em> within the time limit <em>t</em>. The output for each test case is separated from the next by a blank line.</p>
<p class="indent">The time limit for solving the test cases—for our code, not the mice—is three seconds.</p>
<h4 class="h4" id="sec83"><span epub:type="pagebreak" id="page_199"/><em>Moving On from BFS</em></h4>
<p class="noindent">There are key similarities between the Mice Maze problem and the three problems in <a href="ch05.xhtml">Chapter 5</a>. We can model the Mice Maze as a graph, where the nodes are the maze cells and the edges are the passages. The graph is directed (as in the Rope Climb problem), because a passage from Cell <em>a</em> to Cell <em>b</em> tells us nothing about the possible passage from <em>b</em> to <em>a</em>.</p>
<p class="indent">The workhorse for the three problems in <a href="ch05.xhtml">Chapter 5</a> was breadth-first search. The killer feature of BFS is that it finds shortest paths. Not coincidentally, we want shortest paths for our Mice Maze, too. They’ll let us determine how long it takes each mouse to reach the exit cell.</p>
<p class="indent">However, all this talk of similarities is obscuring a crucial difference: the Mice Maze graph is <em>weighted</em>: on each edge, we have an arbitrary integer giving the time required to traverse that edge. See <a href="ch06.xhtml#ch06fig01">Figure 6-1</a> for an example.</p>
<div class="image"><img alt="Image" id="ch06fig01" src="../images/ch06fig01.jpg"/></div>
<p class="figcap"><em>Figure 6-1: The Mice Maze graph</em></p>
<p class="indent">Let’s say that the exit cell is Cell 4. What’s the minimum amount of time taken by the mouse in Cell 1 to get to Cell 4? There’s an edge directly from Cell 1 to Cell 4, so if we were counting edges (as in BFS), then the answer would be <code>1</code>. However, we are not interested in the number of edges here: instead, we want the shortest path in terms of the sum of its edge weights. The weight of the 1 <em>→</em> 4 edge is 45. That is not the shortest path. The shortest path from Cell 1 to Cell 4 is the three-edge path that goes from Cell 1 to Cell 3 (six units of time), then from Cell 3 to Cell 2 (two units of time), and finally from Cell 2 to Cell 4 (nine units of time). That’s 6 + 2 + 9 = 17 in all. It is because of this focus on edge weights, not edge counts, that BFS is out of its element here and we’ll need a different algorithm.</p>
<p class="indent">Hold on, though: there were some weighted graphs in <a href="ch05.xhtml">Chapter 5</a>, and we used BFS on those. What gives? Look back at <a href="ch05.xhtml#ch05fig06">Figure 5-6</a>, a Rope Climb graph where some of the edges had weight 1 and others had weight 0. We managed to use a variant of BFS there, but only because the edge weights were so constrained. Now look back at <a href="ch05.xhtml#ch05fig07">Figure 5-7</a>, a Book Translation graph. That’s a full-blown weighted graph with arbitrary edge weights. We managed <span epub:type="pagebreak" id="page_200"/>to use BFS there, too, but that’s because the primary distance measure was the number of edges. Once a node’s edge distance was determined by BFS, only then did the edge weights come into play, helping us add the node as cheaply as possible.</p>
<p class="indent">However, in no way does the Mice Maze have anything to do with the number of edges. A path from <em>a</em> to <em>b</em> might have 100 edges and a total time of 5 units. A different path from <em>a</em> to <em>b</em> might have only 1 edge with a time of 80 units. BFS would discover that second path, when what we want is the first.</p>
<h4 class="h4" id="sec84"><em>Finding Shortest Paths in Weighted Graphs</em></h4>
<p class="noindent">BFS operates by progressively identifying nodes that are further and further away, in terms of edge count, from the starting node. The algorithm that I’ll present in this section operates similarly: it identifies the shortest path for nodes further and further away, in terms of total edge weight, from the starting node.</p>
<p class="indent">BFS organizes its work in rounds, where the nodes discovered in the next round are one edge more distant than the nodes in the current round. We aren’t going to be able to use that rounds idea to find shortest paths in weighted graphs, because the shortest paths that we discover most recently are not necessarily those that will help us find the shortest path for a new node. We’ll have to work a little harder to find the next shortest path.</p>
<p class="indent">To demonstrate, let’s find the shortest paths from Node 1 to each node in the graph using <a href="ch06.xhtml#ch06fig01">Figure 6-1</a>. That will tell us how long it takes the mouse in cell 1 to get to the exit cell.</p>
<p class="indent">For each node, we’ll maintain two pieces of information:</p>
<p class="block"><em><strong>done</strong></em>   This is a true/false variable. If it’s false, it means that we haven’t found the shortest path for this node yet; if it’s true, then we have. Once a node’s <em>done</em> value is true, we’re done with it: its shortest path will never change again.</p>
<p class="block"><em><strong>min_time</strong></em>   This is the shortest path distance from the starting node to this node, in terms of total time, using a path whose other nodes are all done. As more and more nodes become done, <em>min_time</em> can decrease, because we have more options for paths to this node.</p>
<p class="indent">The shortest path from Node 1 to Node 1 is 0: there’s nowhere to go and no edge to take. Let’s start there, with a <em>min_time</em> for Node 1 of 0 and no <em>min_time</em> information for the other nodes:</p>
<div class="bqparanc">
<table class="allc">
<colgroup>
<col style="width:30%"/>
<col style="width:35%"/>
<col style="width:35%"/>
</colgroup>
<thead>
<tr>
<th class="borderb" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>done</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>min_time</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="gray" style="vertical-align: top">1</td>
<td class="gray" style="vertical-align: top">false</td>
<td class="gray" style="vertical-align: top">0</td>
</tr>
<tr>
<td style="vertical-align: top">2</td>
<td style="vertical-align: top">false</td>
<td/>
</tr>
<tr>
<td class="gray" style="vertical-align: top">3</td>
<td class="gray" style="vertical-align: top">false</td>
<td class="gray"/>
</tr>
<tr>
<td style="vertical-align: top">4</td>
<td style="vertical-align: top">false</td>
<td/>
</tr>
<tr>
<td class="gray" style="vertical-align: top">5</td>
<td class="gray" style="vertical-align: top">false</td>
<td class="gray"/>
</tr>
</tbody>
</table>
</div>
<p class="indent"><span epub:type="pagebreak" id="page_201"/>We next set Node 1 to done, and then we set the <em>min_time</em> for each other node based on the edge weights from Node 1. Here’s our next snapshot:</p>
<div class="bqparanc">
<table class="allc">
<colgroup>
<col style="width:30%"/>
<col style="width:35%"/>
<col style="width:35%"/>
</colgroup>
<thead>
<tr>
<th class="borderb" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>done</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>min_time</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="gray" style="vertical-align: top">1</td>
<td class="gray" style="vertical-align: top">true</td>
<td class="gray" style="vertical-align: top">0</td>
</tr>
<tr>
<td style="vertical-align: top">2</td>
<td style="vertical-align: top">false</td>
<td style="vertical-align: top">12</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">3</td>
<td class="gray" style="vertical-align: top">false</td>
<td class="gray" style="vertical-align: top">6</td>
</tr>
<tr>
<td style="vertical-align: top">4</td>
<td style="vertical-align: top">false</td>
<td style="vertical-align: top">45</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">5</td>
<td class="gray" style="vertical-align: top">false</td>
<td class="gray" style="vertical-align: top">7</td>
</tr>
</tbody>
</table>
</div>
<p class="indent">Now, here’s a claim that’s at the heart of what we’re doing here: the shortest path from Node 1 to Node 3 is 6, and there’s no way we can ever do better than 6. I chose Node 3 in my claim because it has the smallest <em>min_time</em> value of any node that is not done.</p>
<p class="indent">Claiming that the answer is 6 right now might seem brazen. What if there were some other path to Node 3 that was shorter, maybe another path that goes through some other nodes before eventually making its way to Node 3?</p>
<p class="indent">Here’s why that can’t happen, and why our claim of 6 is safe. Imagine that there were some shorter path <em>p</em> from Node 1 to Node 3. That path must start at Node 1 and leave Node 1 on some edge <em>e</em>. Then it must take zero or more other edges and arrive at Node 3. Check it out: <em>e</em> already takes at least 6 time units, because 6 is the minimum time it takes to go from Node 1 to some other node. Any other edges that are on <em>p</em> only add to this, so there’s no way that <em>p</em> could have a total time of less than 6 units!</p>
<p class="indent">So, Node 3 is done: we know its shortest path. Now we will have to use Node 3 to check whether we can improve any of the shortest paths for nodes that are not yet done. Remember that the <em>min_time</em> values give the shortest path using done nodes. It takes 6 time units to get to Node 3, and there’s an edge from Node 3 to Node 2 that takes 2 time units, so we now have a way to get from Node 1 to Node 2 in only 8 time units. We therefore update the <em>min_time</em> value for Node 2 from 12 to 8. Here’s where that leaves us:</p>
<div class="bqparanc">
<table class="allc">
<colgroup>
<col style="width:30%"/>
<col style="width:35%"/>
<col style="width:35%"/>
</colgroup>
<thead>
<tr>
<th class="borderb" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>done</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>min_time</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="gray" style="vertical-align: top">1</td>
<td class="gray" style="vertical-align: top">true</td>
<td class="gray" style="vertical-align: top">0</td>
</tr>
<tr>
<td style="vertical-align: top">2</td>
<td style="vertical-align: top">false</td>
<td style="vertical-align: top">8</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">3</td>
<td class="gray" style="vertical-align: top">true</td>
<td class="gray" style="vertical-align: top">6</td>
</tr>
<tr>
<td style="vertical-align: top">4</td>
<td style="vertical-align: top">false</td>
<td style="vertical-align: top">45</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">5</td>
<td class="gray" style="vertical-align: top">false</td>
<td class="gray" style="vertical-align: top">7</td>
</tr>
</tbody>
</table>
</div>
<p class="indent">Nodes 2, 4, and 5 are not yet done. Which one can we doneify now? The answer is Node 5: it’s got the minimum <em>min_time</em>. Can we use Node 5 to update any of our other shortest paths? Node 5 does have an outgoing edge to Node 2, but getting from Node 1 to Node 5 (7 time units) and then taking the edge from Node 5 to Node 2 (21 time units) takes more time (7 + 21 = 28) than our old path from Node 1 to Node 2 (8 time units). So we leave Node 2’s <em>min_time</em> alone. The only change in the next snapshot, then, is to set Node 5 to done.</p>
<div class="bqparanc"><span epub:type="pagebreak" id="page_202"/>
<table class="allc">
<colgroup>
<col style="width:30%"/>
<col style="width:35%"/>
<col style="width:35%"/>
</colgroup>
<thead>
<tr>
<th class="borderb" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>done</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>min_time</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="gray" style="vertical-align: top">1</td>
<td class="gray" style="vertical-align: top">true</td>
<td class="gray" style="vertical-align: top">0</td>
</tr>
<tr>
<td style="vertical-align: top">2</td>
<td style="vertical-align: top">false</td>
<td style="vertical-align: top">8</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">3</td>
<td class="gray" style="vertical-align: top">true</td>
<td class="gray" style="vertical-align: top">6</td>
</tr>
<tr>
<td style="vertical-align: top">4</td>
<td style="vertical-align: top">false</td>
<td style="vertical-align: top">45</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">5</td>
<td class="gray" style="vertical-align: top">true</td>
<td class="gray" style="vertical-align: top">7</td>
</tr>
</tbody>
</table>
</div>
<p class="indent">There are two nodes to go. Node 2 has a <em>min_time</em> of 8, and Node 4 has a <em>min_time</em> of 45. As always, we choose the smaller, finalizing the shortest path distance from Node 1 to Node 2 as 8. Again, there can be no shorter path to Node 2 than 8. Any shorter path <em>p</em> from Node 1 to Node 2 must begin with some done nodes and will at some point cross for the first time on an edge from a done node to one that is not done. Call that edge <em>x</em> <em>→</em> <em>y</em>, where <em>x</em> is done and <em>y</em> is not. So that’s how <em>p</em> gets from Node 1 to Node <em>y</em>. It can then do whatever it wants to get from Node <em>y</em> to Node 2 . . . but it’s all frivolous. Getting from Node 1 to Node <em>y</em> already takes at least 8 time units: if it were less, then <em>y</em>’s <em>min_time</em> value would be less than 8 and we’d have chosen to set <em>y</em> to done rather than Node 2. Whatever <em>p</em> does to get from Node <em>y</em> to Node 2 can only add even more time. So <em>p</em> can’t be shorter than 8.</p>
<p class="indent">Adding Node 2 gives us two edges to check for shorter paths. There’s an edge from Node 2 to Node 1, but that won’t help us because Node 1 is already done. There’s an edge of 9 time units from Node 2 to Node 4. That one does help us! Getting from Node 1 to Node 2 takes 8 time units, and then the 2 <em>→</em> 4 edge takes 9 time units, for a total of 17 time units. That’s better than our old path from Node 1 to Node 4 that took 45 time units. Here’s the next snapshot:</p>
<div class="bqparanc">
<table class="allc">
<colgroup>
<col style="width:30%"/>
<col style="width:35%"/>
<col style="width:35%"/>
</colgroup>
<thead>
<tr>
<th class="borderb" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>done</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>min_time</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="gray" style="vertical-align: top">1</td>
<td class="gray" style="vertical-align: top">true</td>
<td class="gray" style="vertical-align: top">0</td>
</tr>
<tr>
<td style="vertical-align: top">2</td>
<td style="vertical-align: top">true</td>
<td style="vertical-align: top">8</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">3</td>
<td class="gray" style="vertical-align: top">true</td>
<td class="gray" style="vertical-align: top">6</td>
</tr>
<tr>
<td style="vertical-align: top">4</td>
<td style="vertical-align: top">false</td>
<td style="vertical-align: top">17</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">5</td>
<td class="gray" style="vertical-align: top">true</td>
<td class="gray" style="vertical-align: top">7</td>
</tr>
</tbody>
</table>
</div>
<p class="indent">There’s only one node, Node 4, that’s not done. As all other nodes are done, we’ve found all of their shortest paths. Node 4, therefore, can’t help us find any new, shorter paths. We can set Node 4 to done and conclude:</p>
<div class="bqparanc">
<table class="allc">
<colgroup>
<col style="width:30%"/>
<col style="width:35%"/>
<col style="width:35%"/>
</colgroup>
<thead>
<tr>
<th class="borderb" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>done</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>min_time</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="gray" style="vertical-align: top">1</td>
<td class="gray" style="vertical-align: top">true</td>
<td class="gray" style="vertical-align: top">0</td>
</tr>
<tr>
<td style="vertical-align: top">2</td>
<td style="vertical-align: top">true</td>
<td style="vertical-align: top">8</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">3</td>
<td class="gray" style="vertical-align: top">true</td>
<td class="gray" style="vertical-align: top">6</td>
</tr>
<tr>
<td style="vertical-align: top">4</td>
<td style="vertical-align: top">true</td>
<td style="vertical-align: top">17</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">5</td>
<td class="gray" style="vertical-align: top">true</td>
<td class="gray" style="vertical-align: top">7</td>
</tr>
</tbody>
</table>
</div>
<p class="indent">It takes 17 time units for the mouse in Cell 1 to get to the exit cell 4. We could repeat the process for each other node to find out how long each <span epub:type="pagebreak" id="page_203"/>other mouse takes to get to the exit cell, then count the mice that get there in time.</p>
<p class="indent">This algorithm is known as Dijkstra’s algorithm, after Edsger W. Dijkstra, a pioneering and influential computer scientist. Given a starting node <em>s</em> and a weighted graph, it calculates the shortest path from <em>s</em> to each node in the graph. It’s exactly what we need to solve the Mice Maze problem. Let’s read the input to build the graph and then see how Dijkstra’s algorithm can be implemented.</p>
<h4 class="h4" id="sec85"><em>Building the Graph</em></h4>
<p class="noindent">With all of your experience building trees and graphs to this point, there won’t be many surprises here. We’ll build the graph like we built it for the Book Translation problem in the previous chapter (see “Building the Graph” on <a href="ch05.xhtml#sec79">page 189</a>). The only difference is that the graphs there were undirected and our graphs here are directed. In more good news, we’re given the node numbers directly and don’t have to map between language names and integers.</p>
<p class="indent">Just so we have something on which to test, here’s an input corresponding to <a href="ch06.xhtml#ch06fig01">Figure 6-1</a>:</p>
<pre>   1
 
   5
   4
<span class="ent">➊</span> 12
   9
   1 2 12
   1 3 6
   2 1 26
   1 4 45
   1 5 7
   3 2 2
   2 4 9
   4 3 8
   5 2 21</pre>
<p class="indent">That <code>12</code> <span class="ent">➊</span>  gives the time limit for the mice to get to the exit. (You can verify that three mice can get to the exit within this time limit; those mice are the ones in Cells 2, 3, and 4.)</p>
<p class="indent">As in Book Translation, we’ll use an adjacency list representation of the graph. Each edge maintains the cell to which it points, the length of time required to walk the edge, and a next pointer.</p>
<p class="indent">Here’s the needed constant and <code>typedef</code>:</p>
<pre>#define MAX_CELLS 100
 
typedef struct edge {
<span epub:type="pagebreak" id="page_204"/>  int to_cell, length;
  struct edge *next;
} edge;</pre>
<p class="indent">The graphs are read by the <code>main</code> function in <a href="ch06.xhtml#ch06ex01">Listing 6-1</a>.</p>
<pre>int main(void) {
  static edge *adj_list[MAX_CELLS + 1];
  int num_cases, case_num, i;
  int num_cells, exit_cell, time_limit, num_edges;
  int from_cell, to_cell, length;
  int total, min_time;
  edge *e;
  
  scanf("%d", &amp;num_cases);
  for (case_num = 1; case_num &lt;= num_cases; case_num++) {
    scanf("%d%d%d", &amp;num_cells, &amp;exit_cell, &amp;time_limit);
    scanf("%d", &amp;num_edges);
<span class="ent">➊</span> for (i = 1; i &lt;= num_cells; i++)
    adj_list[i] = NULL;
  for (i = 0; i &lt; num_edges; i++) {
    scanf("%d%d%d", &amp;from_cell, &amp;to_cell, &amp;length);
    e = malloc(sizeof(edge));
    if (e == NULL) {
      fprintf(stderr, "malloc error\n");
      exit(1);
    }
    e-&gt;to_cell = to_cell;
    e-&gt;length = length;
    e-&gt;next = adj_list[from_cell];
  <span class="ent">➋</span> adj_list[from_cell] = e;
  }

  total = 0;
  for (i = 1; i &lt;= num_cells; i++) {
  <span class="ent">➌</span> min_time = find_time(adj_list, num_cells, i, exit_cell);
  <span class="ent">➍</span> if (min_time &gt;= 0 &amp;&amp; min_time &lt;= time_limit)
       total++;
  }
  printf("%d\n", total);
  if (case_num &lt; num_cases)
    printf("\n");
 }
 return 0;
}</pre>
<p class="excap" id="ch06ex01"><em>Listing 6-1: The</em> <span class="codeitalic1">main</span> <em>function for building the graph</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_205"/>The input specification says that a blank line follows the number of test cases and that a blank line sits between each pair of test cases. However, using <code>scanf</code>, we don’t have to worry about that: when reading a number, <code>scanf</code> skips leading whitespace (including newlines) that it encounters.</p>
<p class="indent">The first thing we do for each test case is to clear the adjacency list by setting each cell’s edge list to <code>NULL</code> <span class="ent">➊</span>. Not doing that results in a horrible bug where each test case includes edges from prior test cases. (I would know: I made that mistake, and three hours later it was three hours later.) It’s our responsibility to clear things for each test case!</p>
<p class="indent">Upon initializing each edge, we add it to the linked list for <code>from_cell</code> <span class="ent">➋</span>. We don’t add anything to the linked list for <code>to_cell</code>, because the graph is directed (not undirected).</p>
<p class="indent">The problem requires that we find the shortest path from each cell to the exit cell. For each cell, then, we call <code>find_time</code> <span class="ent">➌</span>, a helper function that implements Dijkstra’s algorithm. We’ll write that function next. Given a starting cell <code>i</code> and target cell <code>exit_cell</code>, it returns <code>-1</code> if there’s no path at all or else returns the shortest path time. Each cell that takes <code>time_limit</code> units of time or less to get to the exit cell results in <code>total</code> being incremented by one <span class="ent">➍</span>. Once each cell’s shortest path has been considered, <code>total</code> is output.</p>
<h4 class="h4" id="sec86"><em>Implementing Dijkstra’s Algorithm</em></h4>
<p class="noindent">Now it’s time to implement Dijkstra’s algorithm, following the outline provided in “Finding Shortest Paths in Weighted Graphs” on <a href="ch06.xhtml#sec84">page 200</a>. Here’s the signature for the function that we’ll implement:</p>
<pre>int find_time(edge *adj_list[], int num_cells,
              int from_cell, int exit_cell)</pre>
<p class="noindent">The four parameters correspond to the adjacency list, number of cells, starting cell, and exit cell, respectively. Dijkstra’s algorithm will calculate the shortest path time from the starting cell to all other cells, including the exit cell. Once we’re done, we can return the shortest path time to the exit cell. That may seem extravagant, calculating the shortest path to all cells only to throw everything away except the shortest path to the exit cell. There are various optimizations that we can perform, and we’ll turn to those in the next subsection. For now, let’s settle in with a working, unadorned implementation.</p>
<p class="indent">The body of Dijkstra’s algorithm is implemented by two nested <code>for</code> loops. The outer <code>for</code> loop runs once per cell; each iteration sets one cell to done and updates shortest paths using that new cell. The inner <code>for</code> loop is a minimum computation: it finds the cell whose <code>min_time</code> value, among all cells that are not done, is minimum. See <a href="ch06.xhtml#ch06ex02">Listing 6-2</a> for the code.</p>
<pre>int find_time(edge *adj_list[], int num_cells,
              int from_cell, int exit_cell) {
  static int done[MAX_CELLS + 1];
  static int min_times[MAX_CELLS + 1];
<span epub:type="pagebreak" id="page_206"/>   int i, j, found;
   int min_time, min_time_index, old_time;
   edge *e;
<span class="ent">➊</span> for (i = 1; i &lt;= num_cells; i++) {
     done[i] = 0;
     min_times[i] = -1;
   }
<span class="ent">➋</span> min_times[from_cell] = 0;
  
   for (i = 0; i &lt; num_cells; i++) {
     min_time = -1;
   <span class="ent">➌</span> found = 0;
   <span class="ent">➍</span> for (j = 1; j &lt;= num_cells; j++) {
     <span class="ent">➎</span> if (!done[j] &amp;&amp; min_times[j] &gt;= 0) {
       <span class="ent">➏</span> if (min_time == -1 || min_times[j] &lt; min_time) {
            min_time = min_times[j];
            min_time_index = j;
            found = 1;
          }
        }
      }
   <span class="ent">❼</span> if (!found)
        break;
      done[min_time_index] = 1;
    
      e = adj_list[min_time_index];
      while (e) {
        old_time = min_times[e-&gt;to_cell];
     <span class="ent">➑</span> if (old_time == -1 || old_time &gt; min_time + e-&gt;length)
          min_times[e-&gt;to_cell] = min_time + e-&gt;length;
        e = e-&gt;next;
     }
   }
<span class="ent">➒</span> return min_times[exit_cell];
}</pre>
<p class="excap" id="ch06ex02"><em>Listing 6-2: The shortest path to the exit cell using Dijkstra’s algorithm</em></p>
<p class="indent">The purpose of the <code>done</code> array is to indicate whether each cell is done: a <code>0</code> means “not done” and a <code>1</code> means “done.” The purpose of the <code>min_times</code> array is to store the shortest path distance from the starting cell to each cell.</p>
<p class="indent">We use a <code>for</code> loop <span class="ent">➊</span> to initialize these two arrays: it sets all <code>done</code> values to <code>0</code> (false) and <code>min_times</code> values to <code>-1</code> (not found). We then set <code>min_times</code> for <code>from_cell</code> to <code>0</code> <span class="ent">➋</span> to indicate that the shortest path distance from the starting cell to itself is zero.</p>
<p class="indent">The <code>found</code> variable tracks whether a new cell can be discovered by Dijkstra’s algorithm. On each iteration of the outer <code>for</code> loop, it starts off as <code>0</code> (false) <span class="ent">➌</span> and gets set to <code>1</code> (true) if a cell can be found—but how could a cell <span epub:type="pagebreak" id="page_207"/>not be found? For example, earlier in this chapter, we found all of the cells. However, there may be graphs where there is <em>no</em> path between a starting cell and some other cell. On those graphs, there will be cells that Dijkstra’s algorithm does not find; when no new cell can be found, it’s time to stop.</p>
<p class="indent">Now we arrive at the inner <code>for</code> loop <span class="ent">➍</span>, whose task is to identify the cell whose shortest path will be found next. This loop will leave <code>min_time_index</code> with the index of the cell whose shortest path has been found and <code>min_time</code> with the shortest path time itself. The eligible cells are those that are both not done and have a <code>min_times</code> value that’s at least <code>0</code> (that is, not <code>-1</code>) <span class="ent">➎</span>. We need the cell to be not done, because done cells already have their shortest paths finalized. We also need the <code>min_times</code> value to be at least <code>0</code>: if it’s <code>-1</code>, then the cell hasn’t been found yet, so we have no idea what its shortest path is. If we had no eligible cell yet or the current cell has a shorter path than our shortest thus far <span class="ent">➏</span>, we update <code>min_time</code> and <code>min_time_index</code> and set <code>found</code> to <code>1</code> to flag that we successfully found a cell.</p>
<p class="indent">If no cell was found, then we stop <span class="ent">➐</span>. Otherwise, we set the identified cell to done and loop through its outgoing edges to find shorter paths. For each edge <code>e</code>, we check whether the cell provides a shorter path to <code>e-&gt;to_cell</code> <span class="ent">➑</span>. That possible shorter path is <code>min_time</code> (the time taken to get from <code>from_cell</code> to <code>min_time_index</code>) plus the time taken to walk edge <code>e</code> (from <code>min_time_index</code> to <code>e-&gt;to_cell</code>).</p>
<p class="indent">When looking at edge <code>e</code>, shouldn’t we first be verifying that <code>e-&gt;to_cell</code> is not done before checking whether we’ve found a shorter path <span class="ent">➑</span>? Although we could add that check, it would have no effect. Done cells already have their finalized shortest paths; there’s no way that some shorter path can be found.</p>
<p class="indent">Having computed shortest paths to all cells, we’ve certainly computed the shortest path to the exit cell. The final thing to do is return that time <span class="ent">➒</span>.</p>
<p class="indent">That’s a wrap! Go ahead and submit to the judge. The code should pass all of the test cases.</p>
<h4 class="h4" id="sec87"><em>Two Optimizations</em></h4>
<p class="noindent">There are a few things that can be done to speed up Dijkstra’s algorithm. The most widely applicable and dramatic speedup is wrought by a data structure called a <em>heap</em>. In our current implementation, it’s very expensive to find the next node to set to done, as we need to scan through all nodes that are not done to find the one with the shortest path. A heap uses a tree to convert this slow, linear search into a fast search. As heaps are useful in many contexts beyond Dijkstra’s algorithm, I’ll discuss them later, in <a href="ch08.xhtml">Chapter 8</a>. Here, I’ll offer a couple of optimizations more specific to the Mice Maze problem.</p>
<p class="indent">Recall that as soon as a cell is done, we never change its shortest path again. As such, once we set the exit cell to done, we have its shortest path. After that, there’s no reason to find shortest paths for other cells. We may as well terminate Dijkstra’s algorithm early.</p>
<p class="indent">We can still do better, though. For a maze of <em>n</em> cells, we invoke Dijkstra’s algorithm <em>n</em> times, once for each cell. For Cell 1, we compute all shortest <span epub:type="pagebreak" id="page_208"/>paths—and then keep only the shortest path to the exit cell. We do the same for Cell 2, Cell 3, and so on, throwing out all of the shortest paths we found except for those that involve the exit cell.</p>
<p class="indent">Instead, consider running Dijkstra’s algorithm just once, with the exit cell as the starting cell. Dijkstra’s algorithm would then find the shortest path from the exit cell to Cell 1, the exit cell to Cell 2, and so on. However, that’s not quite what we want, because the graph is directed: the shortest path from the exit cell to Cell 1 is <em>not</em> necessarily the shortest path from Cell 1 to the exit cell.</p>
<p class="indent">Here again is <a href="ch06.xhtml#ch06fig01">Figure 6-1</a>:</p>
<div class="image1"><img alt="Image" src="../images/unch06fig01.jpg"/></div>
<p class="indent">As we discovered earlier, the shortest path from Cell 1 to Cell 4 is 17, but the shortest path from Cell 4 to Cell 1 is 36.</p>
<p class="indent">The shortest path from Cell 1 to Cell 4 uses the edges 1 <em>→</em> 3, 3 <em>→</em> 2, and 2 <em>→</em> 4. If we intend on starting Dijkstra’s algorithm from Cell 4, then we need it to find edges 4 <em>→</em> 2, 2 <em>→</em> 3, and 3 <em>→</em> 1. Each of these edges is the <em>reverse</em> of an edge in the original graph. <a href="ch06.xhtml#ch06fig02">Figure 6-2</a> shows the <em>reversed graph</em>.</p>
<div class="image"><span epub:type="pagebreak" id="page_209"/><img alt="Image" id="ch06fig02" src="../images/ch06fig02.jpg"/></div>
<p class="figcap"><em>Figure 6-2: A reversed version of the graph in <a href="ch06.xhtml#ch06fig01">Figure 6-1</a></em></p>
<p class="indent">Now we can run Dijkstra’s algorithm—just one invocation of it!—from Cell 4 to recover shortest paths to all nodes.</p>
<p class="indent">In terms of implementation, we would need to produce the reversed graph instead of the original graph. This can be done in the <code>main</code> function (<a href="ch06.xhtml#ch06ex01">Listing 6-1</a>), when reading the graph. Instead of:</p>
<pre>      e-&gt;to_cell = to_cell;
      e-&gt;length = length;
      e-&gt;next = adj_list[from_cell];
      adj_list[from_cell] = e;</pre>
<p class="noindent">we want this:</p>
<pre>      e-&gt;to_cell = from_cell;
      e-&gt;length = length;
      e-&gt;next = adj_list[to_cell];
      adj_list[to_cell] = e;</pre>
<p class="indent">That is, the edge now points to <code>from_cell</code>, and it gets added to the linked list for <code>to_cell</code>. If you make this change and adapt the code so that it invokes Dijkstra’s algorithm just once (from the exit cell), you’ll end up with a much faster program. Give it a try!</p>
<h3 class="h3" id="lev39"><span epub:type="pagebreak" id="page_210"/>Dijkstra’s Algorithm</h3>
<p class="noindent">Dijkstra’s algorithm takes over where BFS leaves off. BFS finds shortest paths in terms of numbers of edges in an unweighted graph; Dijkstra’s algorithm finds shortest paths in terms of edge weights in a weighted graph.</p>
<p class="indent">Like BFS, Dijkstra’s algorithm takes a starting node, and it finds shortest paths from there to each node in the graph. Like BFS, it then solves the <em>single-source shortest-paths</em> problem, except on weighted graphs rather than unweighted graphs.</p>
<p class="indent">To be fair, Dijkstra’s algorithm <em>can</em> find shortest paths in unweighted graphs, too. Just take the unweighted graph and give each edge a weight of one. Now, when Dijkstra’s algorithm finds the shortest paths, it will have minimized the number of edges in the path, precisely what BFS does.</p>
<p class="indent">Why not hammer every shortest-path problem, unweighted or weighted, with Dijkstra’s algorithm, then? Indeed, there are problems where it’s difficult to decide between BFS and Dijkstra’s algorithm. For example, I suspect that many people would have chosen Dijkstra’s algorithm over (modified) BFS to solve the Rope Climb problem in <a href="ch05.xhtml">Chapter 5</a>. When the task is clearly to minimize the number of moves, BFS should still get the call: it’s generally easier to implement than Dijkstra’s algorithm and runs a little faster, too. By no means, however, is Dijkstra’s algorithm slow.</p>
<h4 class="h4" id="sec88"><em>Runtime of Dijkstra’s Algorithm</em></h4>
<p class="noindent">Let’s characterize the runtime of Dijkstra’s algorithm as seen in <a href="ch06.xhtml#ch06ex02">Listing 6-2</a>. We’ll use <em>n</em> to refer to the number of nodes in the graph.</p>
<p class="indent">The initialization loop <span class="ent">➊</span> iterates <em>n</em> times, doing a constant number of steps per iteration, so it does total work proportional to <em>n</em>. The next bit of initialization <span class="ent">➋</span> is a single step. Whether we say that the initialization takes <em>n</em> steps or <em>n</em> + 1 steps changes nothing, so we’ll ignore this 1 and say that it takes <em>n</em> steps.</p>
<p class="indent">The real work done by Dijkstra’s algorithm starts now. Its outer <code>for</code> loop iterates up to <em>n</em> times. For each such iteration, the inner <code>for</code> loop does <em>n</em> iterations to find the next node. The inner <code>for</code> loop, then, iterates a total of <em>n</em><sup>2</sup> times. Each such iteration does a constant amount of work, so the inner <code>for</code> loop does total work proportional to <em>n</em><sup>2</sup>.</p>
<p class="indent">The other work that Dijkstra’s algorithm does is to iterate through the edges of each node. There are a total of <em>n</em> nodes, so certainly each node has no more than <em>n</em> edges leaving it. We therefore take <em>n</em> steps to iterate through the edges of one node, and we have to do this for each of the <em>n</em> nodes. That’s another <em>n</em><sup>2</sup> steps.</p>
<p class="indent">Summarizing, we’ve got <em>n</em> work in the initialization, <em>n</em><sup>2</sup> work in the inner <code>for</code> loop, and <em>n</em><sup>2</sup> work checking the edges. The biggest exponent there is 2, so this is an <em>O</em>(<em>n</em><sup>2</sup>), or quadratic, algorithm.</p>
<p class="indent">In <a href="ch01.xhtml">Chapter 1</a>, we sneezed at a quadratic-time algorithm for Unique Snow-flakes, tossing it away in favor of a linear-time algorithm. In that sense, the implementation of Dijkstra’s algorithm that we have developed is not too <span epub:type="pagebreak" id="page_211"/>impressive. In another sense, though, it is, because in <em>n</em><sup>2</sup> time it’s solving not one but <em>n</em> problems, one for each shortest path from the starting node.</p>
<p class="indent">I’ve chosen to present Dijkstra’s algorithm in this book, but there are many other shortest-paths algorithms. Some find the shortest path between all pairs of nodes in the graph in one fell swoop. Doing so solves the <em>all-pairs shortest-paths</em> problem. One such algorithm is called the <em>Floyd–Warshall algorithm</em>, and it runs in <em>O</em>(<em>n</em><sup>3</sup>) time. Interestingly, we can find all-pairs shortest paths with Dijkstra’s algorithm, too, and just as quickly. We can run Dijkstra’s algorithm <em>n</em> times, once from each starting node. That’s <em>n</em> invocations of an <em>n</em><sup>2</sup> algorithm, for a total of <em>O</em>(<em>n</em><sup>3</sup>) work.</p>
<p class="indent">Weighted or unweighted, single-source or all-pairs, Dijkstra’s algorithm can do it. Is it simply unstoppable? Negative!</p>
<h4 class="h4" id="sec89"><em>Negative-Weight Edges</em></h4>
<p class="noindent">We’ve made an implicit assumption to this point in the chapter: edge weights are nonnegative. In the Mice Maze, for example, edge weights represent times to walk edges; walking an edge surely can’t cause time to go backward, so no edge weight was negative. Similarly, in many other graphs, edges with negative weights don’t arise simply because they don’t make sense. For example, consider a graph where the nodes are cities and edges are flight costs between cities. No airline is going to pay us for taking their flights, so each edge will be a nonnegative dollar cost.</p>
<p class="indent">Now consider a game in which some moves give us points, and other moves take points away. Those latter moves correspond to <em>negative-weight edges</em>. Thus negative-weight edges do appear from time to time. How does Dijkstra’s algorithm respond? Let’s find out using the sample graph in <a href="ch06.xhtml#ch06fig03">Figure 6-3</a>.</p>
<div class="image"><img alt="Image" id="ch06fig03" src="../images/ch06fig03.jpg"/></div>
<p class="figcap"><em>Figure 6-3: A graph with a negative-weight edge</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_212"/>Let’s try to find shortest paths from Node A. As always, Dijkstra’s algorithm begins by assigning a shortest path of 0 to Node A and setting Node A to done. The distance to B from A is 3, the distance to C from A is 5, but the distance to D from A is not defined (and has been left blank):</p>
<div class="bqparanc">
<table class="allc">
<colgroup>
<col style="width:30%"/>
<col style="width:35%"/>
<col style="width:35%"/>
</colgroup>
<thead>
<tr>
<th class="borderb" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>done</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>min_distance</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="gray" style="vertical-align: top">A</td>
<td class="gray" style="vertical-align: top">true</td>
<td class="gray" style="vertical-align: top">0</td>
</tr>
<tr>
<td style="vertical-align: top">B</td>
<td style="vertical-align: top">false</td>
<td style="vertical-align: top">3</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">C</td>
<td class="gray" style="vertical-align: top">false</td>
<td class="gray" style="vertical-align: top">5</td>
</tr>
<tr>
<td style="vertical-align: top">D</td>
<td style="vertical-align: top">false</td>
<td style="vertical-align: top"/>
</tr>
</tbody>
</table>
</div>
<p class="indent">Dijkstra’s algorithm then decides to finalize the shortest path to Node B at 3, and it sets B to done. It also updates the shortest path to D:</p>
<div class="bqparanc">
<table class="allc">
<colgroup>
<col style="width:30%"/>
<col style="width:35%"/>
<col style="width:35%"/>
</colgroup>
<thead>
<tr>
<th class="borderb" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>done</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>min_distance</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="gray" style="vertical-align: top">A</td>
<td class="gray" style="vertical-align: top">true</td>
<td class="gray" style="vertical-align: top">0</td>
</tr>
<tr>
<td style="vertical-align: top">B</td>
<td style="vertical-align: top">true</td>
<td style="vertical-align: top">3</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">C</td>
<td class="gray" style="vertical-align: top">false</td>
<td class="gray" style="vertical-align: top">5</td>
</tr>
<tr>
<td style="vertical-align: top">D</td>
<td style="vertical-align: top">false</td>
<td style="vertical-align: top">4</td>
</tr>
</tbody>
</table>
</div>
<p class="indent">By virtue of B being done, we’re claiming that 3 is the shortest path from A to B, but that spells trouble, because 3 is <em>not</em> the shortest path that we can find from A to B. The shortest path is <em>A</em> <em>→</em> <em>C</em> <em>→</em> <em>B</em>, with a total weight of –495. For kicks, let’s continue under these fishy circumstances and see what Dijkstra’s algorithm would do anyway. The next node that’s done is D:</p>
<div class="bqparanc">
<table class="allc">
<colgroup>
<col style="width:30%"/>
<col style="width:35%"/>
<col style="width:35%"/>
</colgroup>
<thead>
<tr>
<th class="borderb" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>done</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>min_distance</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="gray" style="vertical-align: top">A</td>
<td class="gray" style="vertical-align: top">true</td>
<td class="gray" style="vertical-align: top">0</td>
</tr>
<tr>
<td style="vertical-align: top">B</td>
<td style="vertical-align: top">true</td>
<td style="vertical-align: top">3</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">C</td>
<td class="gray" style="vertical-align: top">false</td>
<td class="gray" style="vertical-align: top">5</td>
</tr>
<tr>
<td style="vertical-align: top">D</td>
<td style="vertical-align: top">true</td>
<td style="vertical-align: top">4</td>
</tr>
</tbody>
</table>
</div>
<p class="indent">That shortest path to D is wrong, too! It should be –494. As all nodes are done except for C, there’s nothing that C can do:</p>
<div class="bqparanc">
<table class="allc">
<colgroup>
<col style="width:30%"/>
<col style="width:35%"/>
<col style="width:35%"/>
</colgroup>
<thead>
<tr>
<th class="borderb" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>done</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>min_distance</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="gray" style="vertical-align: top">A</td>
<td class="gray" style="vertical-align: top">true</td>
<td class="gray" style="vertical-align: top">0</td>
</tr>
<tr>
<td style="vertical-align: top">B</td>
<td style="vertical-align: top">true</td>
<td style="vertical-align: top">3</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">C</td>
<td class="gray" style="vertical-align: top">true</td>
<td class="gray" style="vertical-align: top">5</td>
</tr>
<tr>
<td style="vertical-align: top">D</td>
<td style="vertical-align: top">true</td>
<td style="vertical-align: top">4</td>
</tr>
</tbody>
</table>
</div>
<p class="indent">Even if we let Dijkstra’s algorithm change the shortest path to B here, from 3 to –495, then the shortest path to D will still be wrong. We’d have to somehow process B again, even though B is done. We’d need some way of saying, “Hey, I know that I said B was done, but I’m changing my mind.” In any event, the classical Dijkstra’s algorithm as I’ve presented it gets this example wrong.</p>
<p class="indent"><span epub:type="pagebreak" id="page_213"/>In general, Dijkstra’s algorithm does not work when graph edges can be negative. For that, you may wish to explore the <em>Bellman–Ford algorithm</em> or the aforementioned Floyd–Warshall algorithm.</p>
<p class="indent">Let’s proceed here with another problem where we don’t have to worry about negative-weight edges. We’ll use Dijkstra’s algorithm again, or, rather, we’ll adapt Dijkstra’s algorithm to solve a new kind of problem about shortest paths.</p>
<h3 class="h3" id="lev40">Problem 2: Grandma Planner</h3>
<p class="noindent">Sometimes, we’ll be asked for not only the shortest path distance but also further information about the shortest paths. This problem is just such an example.</p>
<p class="indent">This is DMOJ problem <code>saco08p3</code>.</p>
<h4 class="h4" id="sec90"><em>The Problem</em></h4>
<p class="noindent">Bruce is planning a trip to his grandma’s house. There are <em>n</em> towns, numbered 1 to <em>n</em>. Bruce starts in Town 1, and his grandma lives in Town <em>n</em>. Between each pair of towns is a road, and we’re given the length (distance) of each road.</p>
<p class="indent">Bruce wishes to arrive at his grandma’s with a box of cookies, so he must buy it along the way. Some of the towns have cookie stores; Bruce is required to hit at least one of these cookie towns on his way to his grandma’s.</p>
<p class="indent">Our task is twofold. First, we must determine the minimum distance needed for Bruce to get from his starting point to his grandma’s house, picking up a box of cookies along the way. That minimum distance does not tell us how many options Bruce has for getting to his grandma’s. Maybe there’s only one way that he can do it, with all other routes requiring greater distance, or maybe there are several routes all with the same minimum distance. So, second, we’re asked to determine the number of these minimum-distance routes.</p>
<h5 class="h5">Input</h5>
<p class="noindent">The input contains one test case, consisting of the following lines:</p>
<ul>
<li class="noindent">A line containing <em>n</em>, the number of towns. Towns are numbered 1 to <em>n</em>. There are between 2 and 700 towns.</li>
<li class="noindent"><em>n</em> lines, each containing <em>n</em> integers. The first of these lines gives the road distance from Town 1 to each town (Town 1, then Town 2, and so on); the second of these lines gives the road distance from Town 2 to each town; and so on. The distance from a town to itself is zero; each other distance is at least one. The distance from Town <em>a</em> to Town <em>b</em> is the same as the distance from Town <em>b</em> to Town <em>a</em>.</li>
<li class="noindent">A line containing <em>m</em>, the number of towns that have a cookie store. <em>m</em> is at least one.</li>
<li class="noindent"><span epub:type="pagebreak" id="page_214"/>A line containing <em>m</em> integers, each giving the number of a town with a cookie store.</li>
</ul>
<h5 class="h5">Output</h5>
<p class="noindent">Output the following on a single line:</p>
<ul>
<li class="noindent">The minimum distance to get from Town 1 to Town <em>n</em> (picking up a box of cookies along the way)</li>
<li class="noindent">A space</li>
<li class="noindent">The number of minimum-distance routes, mod 1,000,000</li>
</ul>
<p class="indent">The time limit for solving the test case is one second.</p>
<h4 class="h4" id="sec91"><em>Adjacency Matrix</em></h4>
<p class="noindent">The way that the graph is represented here differs from that of the Mice Maze and that of the Book Translation problem in <a href="ch05.xhtml">Chapter 5</a>. In those two problems, each edge was supplied as one node, the other node, and the edge weight. For example, consider the following:</p>
<pre>1 2 12</pre>
<p class="noindent">This means that there’s an edge from Node 1 to Node 2 with weight 12.</p>
<p class="indent">In the Grandma Planner problem, the graph is presented as an <em>adjacency matrix</em>, which is a two-dimensional array of numbers where a given row, column coordinate gives us the weight of the edge at that row and column.</p>
<p class="indent">Here’s a sample test case:</p>
<pre>4
0 3 8 2
3 0 2 1
8 2 0 5
2 1 5 0
1
2</pre>
<p class="indent">The <code>4</code> at the top tells us that there are four towns. The next four lines are the adjacency matrix. Let’s focus on the first of those lines:</p>
<pre>0 3 8 2</pre>
<p class="indent">This single line gives all of the edges leaving Town 1. There’s an edge from Town 1 to Town 1 of weight <code>0</code>, from Town 1 to Town 2 of weight <code>3</code>, from Town 1 to Town 3 of weight <code>8</code>, and from Town 1 to Town 4 of weight <code>2</code>.</p>
<p class="indent">The next line,</p>
<pre>3 0 2 1</pre>
<p class="noindent">does similarly for Town 2, and so on.</p>
<p class="indent"><span epub:type="pagebreak" id="page_215"/>Notice that there’s an edge between any pair of towns; that is, there are no missing edges. Such a graph is called a <em>complete graph</em>.</p>
<p class="indent">This adjacency matrix has some redundancy. For example, it says in row 1, column 3 that there’s an edge from Town 1 to Town 3 of weight <code>8</code>. However, since the problem specifies that the road from Town <em>a</em> to Town <em>b</em> is the same distance as that of the road from Town <em>b</em> to Town <em>a</em>, we see this <code>8</code> again in row 3, column 1. (We’re therefore dealing with undirected graphs.) We also have <code>0</code>’s along the diagonal, which explicitly state that the distance from some town to itself is zero. We’ll just ignore those.</p>
<h4 class="h4" id="sec92"><em>Building the Graph</em></h4>
<p class="noindent">This problem is ultimately going to demand our creativity not once, but twice. First, we’ll need to force our paths through a town with a cookie store. Among those paths, we want the shortest one. Second, we’ll need to keep track not only of the shortest path but also of the number of ways we can realize that shortest path. Double the fun, I say!</p>
<p class="indent">Let’s begin by reading the test case from the input and building the graph. We’re well positioned to do that at this point. With our graph in hand, we’ll then be ready for what lies ahead.</p>
<p class="indent">The plan is to read the adjacency matrix, building our adjacency lists as we go. We’ll have to keep track of the town indices ourselves, since the adjacency matrix doesn’t explicitly provide them.</p>
<p class="indent">It’s possible to read in and use the adjacency matrix directly, avoiding the adjacency list representation altogether. Each row <em>i</em> gives the distance to each town, so we could just loop through row <em>i</em> in Dijkstra’s algorithm instead of looping through <em>i</em>’s adjacency list. Since the graph is complete, we wouldn’t even have to waste time skipping over edges that don’t exist. We’ll use adjacency lists here, however, for continuity with what we’ve already done.</p>
<p class="indent">Here’s a constant and <code>edge</code> struct that we’ll use:</p>
<pre>#define MAX_TOWNS 700
 
typedef struct edge {
  int to_town, length;
  struct edge *next;
} edge;</pre>
<p class="indent">The code for reading the graph is given in <a href="ch06.xhtml#ch06ex03">Listing 6-3</a>.</p>
<pre>int main(void) {
  static edge *adj_list[MAX_TOWNS + 1] = {NULL};
  int i, num_towns, from_town, to_town, length;
  int num_stores, store_num;
  static int store[MAX_TOWNS + 1] = {0};
  edge *e;
<span epub:type="pagebreak" id="page_216"/>  scanf("%d", &amp;num_towns);
<span class="ent">➊</span> for (from_town = 1; from_town &lt;= num_towns; from_town++)
     for (to_town = 1; to_town &lt;= num_towns; to_town++) {
       scanf("%d", &amp;length);
    <span class="ent">➋</span> if (from_town != to_town) {
         e = malloc(sizeof(edge));
         if (e == NULL) {
           fprintf(stderr, "malloc error\n");
           exit(1);
         }
         e-&gt;to_town = to_town;
         e-&gt;length = length;
         e-&gt;next = adj_list[from_town];
         adj_list[from_town] = e;
       }
     }

<span class="ent">➌</span> scanf("%d", &amp;num_stores);
   for (i = 1; i &lt;= num_stores; i++) {
     scanf("%d", &amp;store_num);
     store[store_num] = 1;
   }
   solve(adj_list, num_towns, store);
   return 0;
}</pre>
<p class="excap" id="ch06ex03"><em>Listing 6-3: The</em> <span class="codeitalic1">main</span> <em>function for building the graph</em></p>
<p class="indent">After reading the number of towns, we use a double <code>for</code> loop to read the adjacency matrix. Each iteration of the outer <code>for</code> loop <span class="ent">➊</span> is responsible for reading one row, specifically, the row for <code>from_town</code>. To read that row, we have an inner <code>for</code> loop, which reads one <code>length</code> value for each <code>to_town</code>. So now we know where the edge starts, where the edge ends, and the length of the edge. We then want to add the edge, but only if it’s not one of those 0-weight edges that go from a town back to itself. If the edge is between distinct towns <span class="ent">➋</span>, then we add it to the adjacency list for <code>from_town</code>. Because the graph is undirected, we must also ensure that eventually this edge is added to the adjacency list for <code>to_town</code>. We had to do that explicitly in <a href="ch05.xhtml#ch05ex016">Listing 5-16</a> when solving the Book Translation problem. We don’t have to do that here, though, because it’ll get added later without us doing anything special when we process the row for <code>to_town</code>. For example, if <code>from_town</code> is <code>1</code> and <code>to_town</code> is <code>2</code>, then the 1 <em>→</em> 2 edge will be added now. Later, when <code>from_town</code> is <code>2</code> and <code>to_town</code> is <code>1</code>, then the 2 <em>→</em> 1 edge will be added.</p>
<p class="indent">All that’s left is to read the information about which towns have cookie stores, starting with the number of such towns <span class="ent">➌</span>. To keep track of these towns, we use array <code>store</code>, where <code>store[i]</code> is <code>1</code> (true) if Town <code>i</code> has a cookie store and <code>0</code> (false) if it does not.</p>
<h4 class="h4" id="sec93"><span epub:type="pagebreak" id="page_217"/><em>Working Through a Weird Test Case</em></h4>
<p class="noindent">Let’s get a feel for the problem by working through the test case from “Adjacency Matrix” on <a href="ch06.xhtml#sec91">page 214</a>. The corresponding graph is provided in <a href="ch06.xhtml#ch06fig04">Figure 6-4</a>, where<strong> c</strong> represents a cookie town.</p>
<div class="image"><img alt="Image" id="ch06fig04" src="../images/ch06fig04.jpg"/></div>
<p class="figcap"><em>Figure 6-4: The grandma graph</em></p>
<p class="indent">Bruce starts in Town 1 and has to get to Town 4. Town 2 is the only town with a cookie store. What’s the shortest-distance path? While it’s true that Bruce can zip from Town 1 directly to Town 4 along the edge of distance 2, that isn’t a feasible solution to the problem. Remember that we need to ensure that a town with a cookie store is included in any proposed shortest path. For this particular graph, this means that we must include Town 2. (In other test cases, there could be multiple towns that have cookie stores; what we’d need to do is include one or more of them.)</p>
<p class="indent">Here’s a path from Town 1 to Town 4 that <em>is</em> feasible: 1 <em>→</em> 2 (distance 3) <em>→</em> 4 (distance 1). That’s a total distance of 4, and it is indeed a shortest path from Town 1 to Town 4 that passes through Town 2.</p>
<p class="indent">That’s not the only optimal path, though. There’s one more, and here it is: 1 <em>→</em> 4 (distance 2) <em>→</em> 2 (distance 1) <em>→</em> 4 (distance 1). What’s a little weird about this path is that we visit Town 4, grandma’s house, <em>twice</em>. We start by going from Town 1 to Town 4, but we cannot end the path there because we don’t have the box of cookies yet. Then we go from Town 4 to Town 2, where we pick up the box of cookies. Finally, we go from Town 2 to Town 4, which is our second visit to Town 4, but this time we arrive with the box of cookies, and so we have a feasible path.</p>
<p class="indent">It does seem that this path is cyclic, since we get to Town 4 once and then get to Town 4 again. Viewed in a different light, however, there is no cycle at all. When we visited Town 4 the first time, we had no box of cookies; when we visited Town 4 again, we had a box of cookies. These two visits are therefore not repeats: it’s true that Town 4 was visited twice, but it is also true that the state (not carrying a box of cookies versus carrying a box of cookies) differs each time.</p>
<p class="indent"><span epub:type="pagebreak" id="page_218"/>Now we see that the same town can’t possibly be visited more than twice. If a town is visited three times, for example, then two of those visits must be in the same state. Perhaps Visit 1 and Visit 2 were both in the “not carrying a box of cookies” state. Then that really is a cycle, and it costs us some distance to traverse the cycle, so removing it gives a shorter path.</p>
<p class="indent">It’s not sufficient, then, to know which town we’re in. We also need to know whether or not a box of cookies has been picked up.</p>
<p class="indent">We’ve wrestled with this kind of problem once before, when solving Rope Climb in <a href="ch05.xhtml">Chapter 5</a>. There, we discussed adding a second rope to produce a more suitable model of the problem. We’re going to reprise that idea here, by adding a state that tells us whether or not a box of cookies is being carried. In State 0, no box of cookies is being carried; in State 1, a box of cookies is being carried. A feasible path, then, is any path that arrives at grandma’s house in State 1. Arriving at grandma’s house in State 0 cannot be the end of a feasible path.</p>
<p class="indent">Take a look at <a href="ch06.xhtml#ch06fig05">Figure 6-5</a>, which introduces a cookie state to <a href="ch06.xhtml#ch06fig04">Figure 6-4</a>. Again,<strong> c</strong> represents a cookie town. The edges with no arrows are undirected, but now we have some directed edges, too.</p>
<div class="image"><img alt="Image" id="ch06fig05" src="../images/ch06fig05.jpg"/></div>
<p class="figcap"><em>Figure 6-5: A grandma graph with a cookie state</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_219"/>Here’s what we do to create this graph:</p>
<ul>
<li class="noindent">Add four new town nodes, one for each original town in the graph. The original nodes are in State 0; the new nodes are in Sate 1.</li>
<li class="noindent">Keep all of the original edges, except for those leaving Town 2 (the town with the cookie store). If we reach Town 2 in State 0, then we’ve transitioned to State 1, so the only edge leaving (2,0) is the directed edge to (2,1). It’s a 0-weight edge, because changing state takes no time. While Dijkstra’s algorithm can’t be trusted on graphs with negative-weight edges (see “Negative-Weight Edges” on <a href="ch06.xhtml#sec89">page 211</a>), 0-weight edges are okay.</li>
<li class="noindent">Connect nodes in State 1 using exactly the same edges that originally connected nodes in State 0.</li>
</ul>
<p class="indent">When we’re in State 0 and reach a town with a cookie store, we buy a box of cookies and end up in State 1. Once we’re in State 1, the graph gives us no way to return to State 0, because there’s no way to lose the box of cookies.</p>
<p class="indent">We start in Town 1, State 0. We must arrive in Town 4, State 1. This requires that we eventually move from State 0 to State 1 and then go to Town 4 using the State-1 edges. When there are multiple towns with cookie stores, the problem becomes increasingly tricky, because then we have to choose exactly which cookie town takes us from State 0 to State 1. Well, it might be tricky for us, but not for Dijkstra’s algorithm, because we’re just asking for a shortest path in a graph.</p>
<h4 class="h4" id="sec94"><em>Task 1: Shortest Paths</em></h4>
<p class="noindent">So far, we’ve talked about how to model the problem as a graph and find the shortest path distance, but not how to find the <em>number</em> of shortest paths. I’ll take these two subtasks in turn. At the end of this subsection, we’ll have solved half of the problem, correctly printing the shortest path distance. We won’t be printing anything for the number of paths, though, so we’ll still fail all of the test cases. Don’t worry: in the next subsection, we’ll work out how to coax the number of paths out of our code, too. It’s Dijkstra time!</p>
<p class="indent">With our new model (using the States 0 and 1), the graph that we read from the input no longer corresponds to the graph that we’ll explore with Dijkstra’s algorithm. One idea is to produce the adjacency list representation of the new graph from the adjacency list for the original graph. That is, start with an empty graph that has twice the number of nodes and add all of the required edges. That can be done, but I think it’s easier to leave the graph alone, logically adding the state to the code for Dijkstra’s algorithm. (When solving the Rope Climb problem in <a href="ch05.xhtml">Chapter 5</a>, we didn’t have much of a choice of what to do, because the input did not contain a graph.)</p>
<p class="indent">We’ll write the function with the following signature:</p>
<pre>void solve(edge *adj_list[], int num_towns, int store[])</pre>
<p class="indent"><span epub:type="pagebreak" id="page_220"/>Here, <code>adj_list</code> is the adjacency list, <code>num_towns</code> is the number of towns (and the number of grandma’s town), and <code>store</code> tells us for any given <code>i</code> whether town <code>i</code> has a cookie store.</p>
<p class="indent">Now we’ll proceed just as we did with the Mice Maze (<a href="ch06.xhtml#ch06ex02">Listing 6-2</a>). At each step, however, we ask what effect the state has on our code and we make appropriate modifications. Let’s walk through the code, which is given in <a href="ch06.xhtml#ch06ex04">Listing 6-4</a>. Compare this code to <a href="ch06.xhtml#ch06ex02">Listing 6-2</a> to highlight the similarities.</p>
<pre>void solve(edge *adj_list[], int num_towns, int store[]) {
  static int done[MAX_TOWNS + 1][2];
  static int min_distances[MAX_TOWNS + 1][2];
  int i, j, state, found;
  int min_distance, min_town_index, min_state_index, old_distance;
  edge *e;
    
<span class="ent">➊</span> for (state = 0; state &lt;= 1; state++)
    for (i = 1; i &lt;= num_towns; i++) {
      done[i][state] = 0;
      min_distances[i][state] = -1;
    }
<span class="ent">➋</span> min_distances[1][0] = 0;
 
<span class="ent">➌</span> for (i = 0; i &lt; num_towns * 2; i++) {
    min_distance = -1;
    found = 0;
    for (state = 0; state &lt;= 1; state++)
      for (j = 1; j &lt;= num_towns; j++) {
        if (!done[j][state] &amp;&amp; min_distances[j][state] &gt;= 0) {
          if (min_distance == -1 || min_distances[j][state] &lt; min_distance) {
            min_distance = min_distances[j][state];
            min_town_index = j;
            min_state_index = state;
            found = 1;
          }
        }
      }
    if (!found)
      break;
 <span class="ent">➍</span> done[min_town_index][min_state_index] = 1;
 
 <span class="ent">➎</span> if (min_state_index == 0 &amp;&amp; store[min_town_index]) {
      old_distance = min_distances[min_town_index][1];
      if (old_distance == -1 || old_distance &gt; min_distance)
        min_distances[min_town_index][1] = min_distance;
    } else {
   <span class="ent">➏</span> e = adj_list[min_town_index];
      while (e) {
        old_distance = min_distances[e-&gt;to_town][min_state_index];
<span epub:type="pagebreak" id="page_221"/>        if (old_distance == -1 || old_distance &gt; min_distance + e-&gt;length)
          min_distances[e-&gt;to_town][min_state_index] = min_distance +
                                                       e-&gt;length;
        e = e-&gt;next;
      }
    }
  }
<span class="ent">❼</span> printf("%d\n", min_distances[num_towns][1]);
}</pre>
<p class="excap" id="ch06ex04"><em>Listing 6-4: The shortest path to grandma’s using Dijkstra’s algorithm</em></p>
<p class="indent">Right from the start, we see the influence of the state on our arrays, as <code>done</code> and <code>min_distances</code> are now two-dimensional arrays. The first dimension is indexed by the town number, and the second is indexed by the state. In our initialization <span class="ent">➊</span>, we’re careful to initialize the elements of both states.</p>
<p class="indent">Our starting point is Town 1, State 0, so that’s the distance that we initialize to <code>0</code> <span class="ent">➋</span>.</p>
<p class="indent">As always, we want to continue running Dijkstra’s algorithm until no new nodes can be found. We have <code>num_towns</code> towns, but each one exists in both State 0 and State 1, so we have a maximum of <code>num_towns * 2</code> nodes to find <span class="ent">➌</span>.</p>
<p class="indent">The nested <code>state</code> and <code>j</code> loops together find the next node. When these loops are done <span class="ent">➍</span>, two important variables will be set: <code>min_town_index</code> gives the index of the town, and <code>min_state_index</code> gives the index of the state.</p>
<p class="indent">Our next step depends on which state we’re in and whether the town has a cookie store. If we’re in State 0 and at a town with a cookie store <span class="ent">➎</span>, then we ignore <code>adj_list</code> and consider only the transition to State 1. Remember that the transition from <code>[min_town_index][0]</code> to <code>[min_town_index][1]</code> has distance <code>0</code>, so our new path to <code>[min_town_index][1]</code> has the same distance as the shortest path to <code>[min_town_index][0]</code>. In typical Dijkstra fashion, we update the shortest path if our new path is shorter.</p>
<p class="indent">Otherwise, we’re in State 0 but not at a town with a cookie store, or we’re in State 1. The available edges here are exactly those in the input graph from the current town, so we examine all edges from <code>min_town_index</code> <span class="ent">➏</span>. Now we’re in Mice Maze territory, looking for new shorter paths using edge <code>e</code>. Just be careful to use <code>min_state_index</code> everywhere, since none of these edges changes the state.</p>
<p class="indent">The final thing to do is print the shortest path distance <span class="ent">➐</span>. We use <code>num_towns</code> as the first index (that’s grandma’s town) and <code>1</code> as the second index (so that a box of cookies is being carried).</p>
<p class="indent">If you run our program on the test case from “Adjacency Matrix” on <a href="ch06.xhtml#sec91">page 214</a>, you should get the correct output of <code>4</code>. Indeed, for any test case, we’ll output the shortest path. Now, let’s move on to the number of shortest paths.</p>
<h4 class="h4" id="sec95"><span epub:type="pagebreak" id="page_222"/><em>Task 2: Number of Shortest Paths</em></h4>
<p class="noindent">It takes just a few changes to beef up Dijkstra’s algorithm so that it finds not only the shortest path distance, but also the number of shortest paths. Those changes are subtle, so I’ll begin by working a few steps of an example to give you some intuition about why what we’re doing makes sense. I’ll then show the new code before giving a more detailed correctness argument.</p>
<h5 class="h5">Working Through an Example</h5>
<p class="noindent">Let’s trace Dijkstra’s algorithm on <a href="ch06.xhtml#ch06fig05">Figure 6-5</a> from node (1,0). In addition to tracking whether each node is done and the minimum distance to each node, we’ll also keep <em>num_paths</em>, giving the number of shortest paths of minimum distance to the node. We’ll see that those paths counted by <em>num_paths</em> get thrown away whenever a shorter path is found.</p>
<p class="indent">To begin, we initialize the state for the starting node (1, 0). We set its minimum distance to 0 and set it to be done. As there’s exactly one path of distance 0 from the starting node to itself (the path of no edges), we set its number of paths to 1. We use the edges from the starting node to initialize the other nodes, and we set each of them to have one path (the path from the starting node). This gives us our first snapshot:</p>
<div class="bqparanc">
<table class="allc">
<colgroup>
<col style="width:25%"/>
<col style="width:25%"/>
<col style="width:25%"/>
<col style="width:25%"/>
</colgroup>
<thead>
<tr>
<th class="borderb" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>done</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>min_distance</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>num_paths</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="gray" style="vertical-align: top">(1,0)</td>
<td class="gray" style="vertical-align: top">true</td>
<td class="gray" style="vertical-align: top">0</td>
<td class="gray" style="vertical-align: top">1</td>
</tr>
<tr>
<td style="vertical-align: top">(2,0)</td>
<td style="vertical-align: top">false</td>
<td style="vertical-align: top">3</td>
<td style="vertical-align: top">1</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">(3,0)</td>
<td class="gray" style="vertical-align: top">false</td>
<td class="gray" style="vertical-align: top">8</td>
<td class="gray" style="vertical-align: top">1</td>
</tr>
<tr>
<td style="vertical-align: top">(4,0)</td>
<td style="vertical-align: top">false</td>
<td style="vertical-align: top">2</td>
<td style="vertical-align: top">1</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">(1,1)</td>
<td class="gray" style="vertical-align: top">false</td>
<td class="gray" style="vertical-align: top"/>
<td class="gray" style="vertical-align: top"/>
</tr>
<tr>
<td style="vertical-align: top">(2,1)</td>
<td style="vertical-align: top">false</td>
<td style="vertical-align: top"/>
<td style="vertical-align: top"/>
</tr>
<tr>
<td class="gray" style="vertical-align: top">(3,1)</td>
<td class="gray" style="vertical-align: top">false</td>
<td class="gray" style="vertical-align: top"/>
<td class="gray" style="vertical-align: top"/>
</tr>
<tr>
<td style="vertical-align: top">(4,1)</td>
<td style="vertical-align: top">false</td>
<td style="vertical-align: top"/>
<td style="vertical-align: top"/>
</tr>
</tbody>
</table>
</div>
<p class="indent">Now what? Well, as always with Dijkstra’s algorithm, we scan through the nodes that are not done and choose one with minimum <em>min_distance</em> value. We therefore choose node (4,0). Dijkstra’s algorithm guarantees that this node has its shortest path set, so we can set it to done. Then, we must check the edges leaving (4,0) to see whether we can find shorter paths to other nodes. We can indeed find a shorter path to (3,0): before it was 8, but now it’s 7, because we can get to (4,0) with distance 2, and then from (4,0) to (3,0) with distance 5. What do we put for the number of shortest paths to (3,0)? Well, it used to be 1, so it’s tempting to make it 2. However, 2 is wrong, because that would count the path of distance 8, and that’s no longer a shortest path. The answer is 1, because there’s only one path of distance 7.</p>
<p class="indent">There’s an edge from (4,0) to (2,0) that we shouldn’t dismiss too quickly. The old shortest path to (2,0) was 3. What does the edge from (4,0) to (2,0) do for us? Does it give us a shorter path? Well, the distance to (4,0) is 2, and the edge from (4,0) to (2,0) has distance 1, so we have a new way to get to (2,0) with distance 3. That’s not a shorter path, but it is <em>another</em> shortest path! That is, getting to (4,0) and then using the edge to (2,0) gives us <span epub:type="pagebreak" id="page_223"/>new ways to get to (2,0). The number of new ways is the number of shortest paths to (4,0), which is just one. That gives us 1 + 1 = 2 shortest paths to get to (2,0).</p>
<p class="indent">This is all summarized in the next snapshot:</p>
<div class="bqparanc">
<table class="allc">
<colgroup>
<col style="width:25%"/>
<col style="width:25%"/>
<col style="width:25%"/>
<col style="width:25%"/>
</colgroup>
<thead>
<tr>
<th class="borderb" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>done</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>min_distance</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>num_paths</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="gray" style="vertical-align: top">(1,0)</td>
<td class="gray" style="vertical-align: top">true</td>
<td class="gray" style="vertical-align: top">0</td>
<td class="gray" style="vertical-align: top">1</td>
</tr>
<tr>
<td style="vertical-align: top">(2,0)</td>
<td style="vertical-align: top">false</td>
<td style="vertical-align: top">3</td>
<td style="vertical-align: top">2</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">(3,0)</td>
<td class="gray" style="vertical-align: top">false</td>
<td class="gray" style="vertical-align: top">7</td>
<td class="gray" style="vertical-align: top">1</td>
</tr>
<tr>
<td style="vertical-align: top">(4,0)</td>
<td style="vertical-align: top">true</td>
<td style="vertical-align: top">2</td>
<td style="vertical-align: top">1</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">(1,1)</td>
<td class="gray" style="vertical-align: top">false</td>
<td class="gray" style="vertical-align: top"/>
<td class="gray" style="vertical-align: top"/>
</tr>
<tr>
<td style="vertical-align: top">(2,1)</td>
<td style="vertical-align: top">false</td>
<td style="vertical-align: top"/>
<td style="vertical-align: top"/>
</tr>
<tr>
<td class="gray" style="vertical-align: top">(3,1)</td>
<td class="gray" style="vertical-align: top">false</td>
<td class="gray" style="vertical-align: top"/>
<td class="gray" style="vertical-align: top"/>
</tr>
<tr>
<td style="vertical-align: top">(4,1)</td>
<td style="vertical-align: top">false</td>
<td style="vertical-align: top"/>
<td style="vertical-align: top"/>
</tr>
</tbody>
</table>
</div>
<p class="indent">The next node that’s done is (2,0). There’s an edge of weight 0 from (2,0) to (2,1), and it takes distance 3 to get to (2,0), so we have a shortest path of distance 3 to (2,1) as well. There are two ways to get to (2,0) with that minimum distance, so there are two ways to get to (2,1) as well. Here’s what we’ve got now:</p>
<div class="bqparanc">
<table class="allc">
<colgroup>
<col style="width:25%"/>
<col style="width:25%"/>
<col style="width:25%"/>
<col style="width:25%"/>
</colgroup>
<thead>
<tr>
<th class="borderb" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>done</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>min_distance</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>num_paths</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="gray" style="vertical-align: top">(1,0)</td>
<td class="gray" style="vertical-align: top">true</td>
<td class="gray" style="vertical-align: top">0</td>
<td class="gray" style="vertical-align: top">1</td>
</tr>
<tr>
<td style="vertical-align: top">(2,0)</td>
<td style="vertical-align: top">true</td>
<td style="vertical-align: top">3</td>
<td style="vertical-align: top">2</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">(3,0)</td>
<td class="gray" style="vertical-align: top">false</td>
<td class="gray" style="vertical-align: top">7</td>
<td class="gray" style="vertical-align: top">1</td>
</tr>
<tr>
<td style="vertical-align: top">(4,0)</td>
<td style="vertical-align: top">true</td>
<td style="vertical-align: top">2</td>
<td style="vertical-align: top">1</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">(1,1)</td>
<td class="gray" style="vertical-align: top">false</td>
<td class="gray" style="vertical-align: top"/>
<td class="gray" style="vertical-align: top"/>
</tr>
<tr>
<td style="vertical-align: top">(2,1)</td>
<td style="vertical-align: top">false</td>
<td style="vertical-align: top">3</td>
<td style="vertical-align: top">2</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">(3,1)</td>
<td class="gray" style="vertical-align: top">false</td>
<td class="gray" style="vertical-align: top"/>
<td class="gray" style="vertical-align: top"/>
</tr>
<tr>
<td style="vertical-align: top">(4,1)</td>
<td style="vertical-align: top">false</td>
<td style="vertical-align: top"/>
<td style="vertical-align: top"/>
</tr>
</tbody>
</table>
</div>
<p class="indent">The next node that’s done is (2,1), and it is this node that finds the shortest path distance to our destination (4,1). There are two shortest paths to (2,1), so there are two shortest paths to (4,1) as well. Node (2,1) also finds new shortest paths to (1,1) and (3,1). Here’s what we’ve got now:</p>
<div class="bqparanc">
<table class="allc">
<colgroup>
<col style="width:25%"/>
<col style="width:25%"/>
<col style="width:25%"/>
<col style="width:25%"/>
</colgroup>
<thead>
<tr>
<th class="borderb" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>done</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>min_distance</em></strong></th>
<th class="borderb" style="vertical-align: top"><strong><em>num_paths</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="gray" style="vertical-align: top">(1,0)</td>
<td class="gray" style="vertical-align: top">true</td>
<td class="gray" style="vertical-align: top">0</td>
<td class="gray" style="vertical-align: top">1</td>
</tr>
<tr>
<td style="vertical-align: top">(2,0)</td>
<td style="vertical-align: top">true</td>
<td style="vertical-align: top">3</td>
<td style="vertical-align: top">2</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">(3,0)</td>
<td class="gray" style="vertical-align: top">false</td>
<td class="gray" style="vertical-align: top">7</td>
<td class="gray" style="vertical-align: top">1</td>
</tr>
<tr>
<td style="vertical-align: top">(4,0)</td>
<td style="vertical-align: top">true</td>
<td style="vertical-align: top">2</td>
<td style="vertical-align: top">1</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">(1,1)</td>
<td class="gray" style="vertical-align: top">false</td>
<td class="gray" style="vertical-align: top">6</td>
<td class="gray" style="vertical-align: top">2</td>
</tr>
<tr>
<td style="vertical-align: top">(2,1)</td>
<td style="vertical-align: top">true</td>
<td style="vertical-align: top">3</td>
<td style="vertical-align: top">2</td>
</tr>
<tr>
<td class="gray" style="vertical-align: top">(3,1)</td>
<td class="gray" style="vertical-align: top">false</td>
<td class="gray" style="vertical-align: top">5</td>
<td class="gray" style="vertical-align: top">2</td>
</tr>
<tr>
<td style="vertical-align: top">(4,1)</td>
<td style="vertical-align: top">false</td>
<td style="vertical-align: top">4</td>
<td style="vertical-align: top">2</td>
</tr>
</tbody>
</table>
</div>
<p class="indent"><span epub:type="pagebreak" id="page_224"/>Node (4,1) is the next one out, so we have our answer: the shortest path is 4 and the number of shortest paths is 2. (In our code we won’t have a stopping criterion here at the destination, so Dijkstra’s algorithm would keep going, finding shortest paths and number of shortest paths for other nodes. I encourage you to persevere with this example until the end.)</p>
<p class="indent">That’s how the algorithm works. It can be summarized by two rules:</p>
<p class="block"><strong>Rule 1</strong>   Suppose that we use Node <em>u</em> to find a shorter path to Node <em>v</em>. Then the number of shortest paths to <em>v</em> is the number of shortest paths to <em>u</em>. (All of the old paths to <em>v</em> are invalidated and no longer count, because we now know that they are not shortest paths.)</p>
<p class="block"><strong>Rule 2</strong>   Suppose that we use Node <em>u</em> to find a path to Node <em>v</em> that’s the same distance as the current shortest path to <em>v</em>. Then the number of paths to <em>v</em> is the number of shortest paths that we already had for <em>v</em>, plus the number of shortest paths to <em>u</em>. (All of the old paths to <em>v</em> still count.)</p>
<p class="indent">Suppose that we focus on some node <em>n</em> and watch what happens to its minimum distance and number of shortest paths as it runs. We don’t know what the shortest path to <em>n</em> will be: we might have its shortest path now, or Dijkstra’s algorithm might find a shorter one later. If we have its shortest path now, then we had better accumulate the number of shortest paths to <em>n</em>, since we may ultimately need that value to compute the number of shortest paths for other nodes. If we don’t have its shortest path now, then in retrospect we’ll have pointlessly accumulated its number of shortest paths. That’s okay, though, because we’ll just reset the number of shortest paths anyway when we find a shorter path.</p>
<h5 class="h5">The Code</h5>
<p class="noindent">To solve this task, we can start with <a href="ch06.xhtml#ch06ex04">Listing 6-4</a> and make the changes necessary to find the number of shortest paths. The updated code is given in <a href="ch06.xhtml#ch06ex05">Listing 6-5</a>.</p>
<pre>#define MOD 1000000
 
void solve(edge *adj_list[], int num_towns, int store[]) {
  static int done[MAX_TOWNS + 1][2];
  static int min_distances[MAX_TOWNS + 1][2];
<span class="ent">➊</span> static int num_paths[MAX_TOWNS + 1][2];
  int i, j, state, found;
  int min_distance, min_town_index, min_state_index, old_distance;
  edge *e;
   
  for (state = 0; state &lt;= 1; state++)
    for (i = 1; i &lt;= num_towns; i++) {
      done[i][state] = 0;
      min_distances[i][state] = -1;
    <span class="ent">➋</span> num_paths[i][state] = 0;
  }
  <span epub:type="pagebreak" id="page_225"/>min_distances[1][0] = 0;
<span class="ent">➌</span> num_paths[1][0] = 1;
 
  for (i = 0; i &lt; num_towns * 2; i++) {
    min_distance = -1;
    found = 0;
    for (state = 0; state &lt;= 1; state++)
      for (j = 1; j &lt;= num_towns; j++) {
        if (!done[j][state] &amp;&amp; min_distances[j][state] &gt;= 0) {
          if (min_distance == -1 || min_distances[j][state] &lt; min_distance) {
            min_distance = min_distances[j][state];
            min_town_index = j;
            min_state_index = state;
            found = 1;
          }
        }
      }
    if (!found)
      break;
    done[min_town_index][min_state_index] = 1;
   
    if (min_state_index == 0 &amp;&amp; store[min_town_index]) {
      old_distance = min_distances[min_town_index][1];
   <span class="ent">➍</span> if (old_distance == -1 || old_distance &gt;= min_distance) {
        min_distances[min_town_index][1] = min_distance;
      <span class="ent">➎</span> if (old_distance == min_distance)
          num_paths[min_town_index][1] += num_paths[min_town_index][0];
        else
          num_paths[min_town_index][1] = num_paths[min_town_index][0];
      <span class="ent">➏</span> num_paths[min_town_index][1] %= MOD;
       }
     } else {
       e = adj_list[min_town_index];
       while (e) {
         old_distance = min_distances[e-&gt;to_town][min_state_index];
         if (old_distance == -1 ||
             old_distance &gt;= min_distance + e-&gt;length) {
           min_distances[e-&gt;to_town][min_state_index] = min_distance +
                                                        e-&gt;length;
        <span class="ent">❼</span> if (old_distance == min_distance + e-&gt;length)
             num_paths[e-&gt;to_town][min_state_index] +=
                 num_paths[min_town_index][min_state_index];
           else
             num_paths[e-&gt;to_town][min_state_index] =
                 num_paths[min_town_index][min_state_index];
        <span class="ent">➑</span> num_paths[e-&gt;to_town][min_state_index] %= MOD;
        }
<span epub:type="pagebreak" id="page_226"/>        e = e-&gt;next;
      }
    }
  }
<span class="ent">➒</span> printf("%d %d\n", min_distances[num_towns][1], num_paths[num_towns][1]);
}</pre>
<p class="excap" id="ch06ex05"><em>Listing 6-5: The shortest path and number of shortest paths to grandma’s</em></p>
<p class="indent">I added a <code>num_paths</code> array that tracks the number of paths that we’ve found for each node <span class="ent">➊</span> and set all of its elements to <code>0</code> <span class="ent">➋</span>. The only nonzero element in <code>num_paths</code> is for our starting node (1,0), which has one path of distance 0 (the path that begins at the starting node and follows no edges) <span class="ent">➌</span>.</p>
<p class="indent">The remaining new work is to update <code>num_paths</code>. As we’ve discussed, there are two cases. If we find a shorter path, then the old number of paths no longer counts. If we find another way to reach a node using its current path distance, then we add to the old number of paths. It’s that second case that can trip us up if we’re not careful, because we need to include an equality check in addition to a greater-than check <span class="ent">➍</span>. If we used exactly the code that we’ve used throughout the chapter,</p>
<pre>if (old_distance == -1 || old_distance &gt; min_distance) {</pre>
<p class="noindent">then the number of paths to a node would only be updated when a shorter path was found; there would be no way to accumulate shortest paths from multiple sources. Instead, we use <code>&gt;=</code> rather than <code>&gt;</code></p>
<pre>if (old_distance == -1 || old_distance &gt;= min_distance) {</pre>
<p class="noindent">so that we can find more shortest paths, even if the shortest path itself does not change.</p>
<p class="indent">Now we can implement exactly the two cases that we’ve discussed for updating the number of paths. We have to do these cases twice, because there are two places in the code where Dijkstra’s algorithm can find shortest paths. The first addition <span class="ent">➎</span> is to the code that follows a 0-weight edge from State 0. If the shortest path is the same as before, we add; if there’s now a new shorter path, we reset. The second addition of essentially the same code <span class="ent">➐</span> is added to the code for looping through the edges leaving the current node. In both cases, we use the mod operator <span class="ent">➏ ➑</span> to keep us under 1,000,000 shortest paths.</p>
<p class="indent">The final required change is to update the <code>printf</code> call at the end <span class="ent">➒</span>, now also printing the number of shortest paths to grandma’s.</p>
<p class="indent">You’re ready to submit to the judge. Let’s discuss a little bit about correctness before we wrap up for good.</p>
<h5 class="h5">Algorithm Correctness</h5>
<p class="noindent">There are no negative-weight edges in our Grandma Planner graphs, so we know that Dijkstra’s algorithm will correctly find all shortest path distances. There are some 0-weight edges—one from each cookie town in State 0 to the <span epub:type="pagebreak" id="page_227"/>corresponding town in State 1—but Dijkstra’s algorithm copes just fine with those when finding shortest paths.</p>
<p class="indent">However, we must carefully think through the implications of 0-weight edges on finding the <em>number</em> of shortest paths. If we allow arbitrary 0-weight edges, then there may be an <em>infinite</em> number of shortest paths. Take a look at <a href="ch06.xhtml#ch06fig06">Figure 6-6</a>, where we have 0-weight edges from A to B, B to C, and C to A. The shortest path from A to C, for example, is 0, and we have an infinite number of such paths: A <em>→</em> B <em>→</em> C, A <em>→</em> B <em>→</em> C <em>→</em> A <em>→</em> B <em>→</em> C, and so on.</p>
<div class="image"><img alt="Image" id="ch06fig06" src="../images/ch06fig06.jpg"/></div>
<p class="figcap"><em>Figure 6-6: A graph with an infinite number of shortest paths</em></p>
<p class="indent">Luckily, cycles of 0-weight edges cannot actually present themselves in Grandma Planner graphs. Remember that all road distances are at least one. Suppose that there were a 0-weight edge from Node <em>u</em> to Node <em>v</em>. This means that <em>u</em> is in State 0 and <em>v</em> is in State 1. We can never get from <em>v</em> back to <em>u</em>, because our graphs provide no way to move from State 1 back to State 0.</p>
<p class="indent">I’ll end by arguing the following: once a node is set to done, we have found its total number of shortest paths. Consider a run of our algorithm where it gives the wrong number of shortest paths. Our algorithm hums along, finding shortest paths and the number of shortest paths . . . and then, boom, it makes a mistake for the first time. It sets some node <em>n</em> to done, but it’s missed finding some of its shortest paths. We need to argue that this mistake cannot arise.</p>
<p class="indent">Suppose that some shortest paths to <em>n</em> end with some edge <em>m</em> <em>→</em> <em>n</em>. If <em>m</em> <em>→</em> <em>n</em> has a weight greater than 0, then the shortest path to <em>m</em> is shorter than the shortest path to <em>n</em>. (It’s the shortest path to <em>n</em> minus the weight of <em>m</em> <em>→</em> <em>n</em>.) Dijkstra’s algorithm works by finding nodes that are further and further from the starting node, so Node <em>m</em> must be done by this point. When Dijkstra’s algorithm set <em>m</em> to done, it would have gone through all edges from <em>m</em>, including <em>m</em> <em>→</em> <em>n</em>. Since <em>m</em>’s number of paths was set correctly (<em>m</em> is done, and Dijkstra’s algorithm hadn’t made its mistake yet), Dijkstra’s algorithm includes all of those paths in <em>n</em>’s path count.</p>
<p class="indent">Now, what if <em>m</em> <em>→</em> <em>n</em> is a 0-weight edge? We need <em>m</em> to be done before <em>n</em>; otherwise, <em>m</em>’s number of paths cannot be trusted when exploring the edges that leave <em>m</em>. We know that 0-weight edges go from a node in State 0 to a node in State 1, so <em>m</em> must be in State 0 and <em>n</em> must be in State 1. The shortest path to <em>m</em> must be the same as the shortest path to <em>n</em>, since the 0-weight <span epub:type="pagebreak" id="page_228"/>edge adds nothing to <em>m</em>’s shortest path. At some point, then, at the time when <em>m</em> and <em>n</em> are not done, Dijkstra’s algorithm will have to choose which of the two to next set to done. It had better choose <em>m</em>; and it will, because, as I’ve written the code, when there is a tie it chooses a node from State 0 rather than State 1.</p>
<p class="indent">We need to tread lightly: we’re really getting away with something here. Here’s a test case that exemplifies why we have to process State-0 nodes before State-1 nodes:</p>
<pre>4
0 3 1 2
3 0 2 1
1 2 0 5
2 1 5 0
2
2 3</pre>
<p class="indent">Trace our modified Dijkstra’s algorithm on this example. If you have a choice of which node to next set to done, choose one from State 0. If you do that, you’ll get the correct answer: a shortest path distance of four and four shortest paths. Then, trace the algorithm again, only this time break ties by choosing a node from State 1. You’ll still get the correct shortest path distance of four, because Dijkstra’s algorithm is not sensitive to how ties are broken. But our modified Dijkstra’s algorithm is, witnessed by the fact that you should get two shortest paths rather than four.</p>
<h3 class="h3" id="lev41">Summary</h3>
<p class="noindent">Dijkstra’s algorithm is designed to find shortest paths in graphs. We’ve seen in this chapter how to model a problem instance as a suitable weighted graph and then use Dijkstra’s algorithm. Moreover, Dijkstra’s algorithm, like BFS in <a href="ch05.xhtml">Chapter 5</a>, can serve as a guide for solving related but distinct problems. In the Grandma Planner problem, we found the number of shortest paths by a suitable modification to Dijkstra’s algorithm. We didn’t have to start from scratch. We’re not always literally going to be asked for the shortest path. If Dijkstra’s algorithm were resolute, finding shortest paths and nothing else, then it would offer no help when contexts shift. Indeed, we’d have learned a powerful algorithm, but one of an all-or-nothing flavor. Fortunately, Dijkstra’s algorithm applies more broadly. If you continue with graph algorithms beyond what I’ve included in this book, you’ll likely see ideas from Dijkstra’s algorithm appear again. While there may be millions of problems out there, there are far fewer algorithms. The best algorithms are often the ones that rest on ideas so flexible that they can ooze beyond their intended purpose.</p>
<h3 class="h3" id="lev42"><span epub:type="pagebreak" id="page_229"/>Notes</h3>
<p class="noindent">Mice Maze is originally from the 2001 Southwestern Europe Regional Contest. Grandma Planner is originally from the 2008 South African Programming Olympiad, Final Round.</p>
<p class="indent">For more about graph search and its many applications to competitive programming problems, I recommend <em>Competitive Programming 4</em> by Steven Halim and Felix Halim (2020).<span epub:type="pagebreak" id="page_230"/></p>
</body></html>