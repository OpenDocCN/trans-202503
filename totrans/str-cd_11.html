<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_217"/><span class="big">8</span><br/>FRACTRAN</h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">John Conway (1937–2020) was a British mathematician, most famous to the general public for his Game of Life (see <em><a href="https://playgameoflife.com/">https://playgameoflife.com/</a></em>), but equally famous to his fellow mathematicians for his many contributions to a wide variety of mathematical disciplines. In this chapter, we’ll examine another of Conway’s contributions, one that isn’t as well known as his Game of Life, but is perfect for our purposes: FRACTRAN. We’ll start with the specification of FRACTRAN, build it, and, lastly, use it to implement basic programs for addition, subtraction, and multiplication, among other tasks. After that, we’ll end with a discussion, like always.</p>&#13;
<p class="indent">Be warned that there’s math ahead, at the level of fractions, prime numbers, and big integers. FRACTRAN is the most mathematical esolang we’ll encounter. If you wish, skip this chapter and move on to the remaining esolangs. However, if you do, please don’t forget to come back. FRACTRAN is worth the struggle.</p>&#13;
<h3 class="h3" id="lev1sec58"><span epub:type="pagebreak" id="page_218"/><strong>The FRACTRAN Specification</strong></h3>&#13;
<p class="noindent">FRACTRAN’s specification is straightforward. In fact, it’s almost as straightforward as ABC’s. Here’s the full specification for FRACTRAN:</p>&#13;
<pre>FRACTRAN&#13;
&#13;
Input:&#13;
    A sequence of fractions&#13;
    An integer&#13;
&#13;
Operation:&#13;
    1. Multiply the integer by the fractions in turn:&#13;
    2.   If the product is an integer, use that as the new integer &#13;
         and repeat from Step 1.&#13;
    3.   If the product is not an integer, move to the following fraction.&#13;
    4. If all fractions are exhausted, stop.&#13;
&#13;
Output:&#13;
    The final integer&#13;
    Optionally: all intermediate integers, if desired&#13;
&#13;
Assumption:&#13;
    The implementation must use arbitrary precision fractions.</pre>&#13;
<p class="indent">FRACTRAN programs are a sequence of integers and nothing more. An initial integer is tested against each fraction in the program, in order. If the product of the integer and the fraction is itself an integer, that product becomes the new integer and the program loops from the beginning. If the program ever reaches the state where no product results in a new integer, the program ends. That’s it.</p>&#13;
<p class="indent">As the specification is simple, so are the implementations. Let’s write two FRACTRAN interpreters because it’s fun and it will expose us to another programming language, one that is well suited to this particular task.</p>&#13;
<h3 class="h3" id="lev1sec59"><strong>A Tale of Two Implementations</strong></h3>&#13;
<p class="noindent">The specification above includes the phrase <em>arbitrary precision</em>. A FRACTRAN implementation must use fractions where the numerator and denominator are integers of any size, even if that size has thousands of digits.</p>&#13;
<p class="indent">Most programming languages don’t natively support arbitrary-precision integers, let alone fractions (rationals). However, Scheme does. Scheme is a dialect of Lisp, which we first mentioned in <a href="ch01.xhtml#ch01">Chapter 1</a>. Not only does Scheme support arbitrary-precision integers, it also natively supports rationals. Therefore, Scheme is ideally suited to implementing FRACTRAN.</p>&#13;
<p class="indent">We’ve used Python fairly often throughout the book. Python also supports arbitrary-precision integers natively and has a rational arithmetic library module. So we’ll implement FRACTRAN in Python as well. The <span epub:type="pagebreak" id="page_219"/>juxtaposition between the two implementations will be illustrative, and allow us to test each against the other to ensure our implementations are correct.</p>&#13;
<h4 class="h4" id="lev2sec62"><strong><em>A Scheme Implementation</em></strong></h4>&#13;
<p class="noindent">The version of Scheme we’ll use is called Racket (<em><a href="https://racket-lang.org/">https://racket-lang.org/</a></em>). It’s easy to install on Linux:</p>&#13;
<pre>&gt; <span class="codestrong1">sudo apt-get install racket</span></pre>&#13;
<p class="noindent">See the Racket website to install macOS and Windows versions. Once installed, run Racket by entering <span class="codestrong">racket</span> at the command line:</p>&#13;
<pre>Welcome to Racket v6.11.&#13;
&gt;</pre>&#13;
<p class="noindent">Your version should be at least 6.11 or greater. Like Python and Forth, Racket enters an interactive mode if no file is given to it. For now, just quit by entering <span class="codestrong">(exit)</span>; note that the parentheses are required.</p>&#13;
<p class="indent">We certainly don’t have the space here to give even a short tutorial on Scheme (Racket). The genuinely motivated will find all they need on the Racket website. Instead, we’ll walk through our implementation. <a href="ch08.xhtml#ch08list1">Listing 8-1</a> shows the code.</p>&#13;
<pre>(define argv (current-command-line-arguments))&#13;
(define prog (file-&gt;list (vector-ref argv 0)))&#13;
(define num (string-&gt;number (vector-ref argv 1)))&#13;
(define trace (string-&gt;number (vector-ref argv 2)))&#13;
&#13;
<span class="ent">➊</span> (define (FRACTRAN)&#13;
    <span class="ent">➋</span> (do ((i 0 (+ i 1))) (#f)&#13;
        <span class="ent">➌</span> (when (= i (length prog)) &#13;
               (when (= trace 0) (display num)(newline))&#13;
               (exit))&#13;
        <span class="ent">➍</span> (let ((n (* num (list-ref prog i))))&#13;
            <span class="ent">➎</span> (when (exact-integer? n) &#13;
                   (set! num n)&#13;
                   (set! i -1)&#13;
                   (when (= trace 1) (display num)(newline))) ) ))&#13;
<span class="ent">➏</span> (FRACTRAN)</pre>&#13;
<p class="caption" id="ch08list1"><em>Listing 8-1: FRACTRAN in Racket</em></p>&#13;
<p class="indent">The Racket implementation of FRACTRAN is compact. The first four lines do nothing more than parse the command line. In Racket, <span class="literal">define</span> assigns a value. We use <span class="literal">argv</span> to avoid duplicating the call to <span class="literal">current-command-line</span> <span class="literal">-arguments</span>. Racket returns the command line arguments as a vector, so <span class="literal">(vector</span> <span class="literal">-ref argv 0)</span> is equivalent to <span class="literal">argv[0]</span> in other languages. Racket is a prefix language, meaning that function names come first, followed by the arguments with parentheses around everything. We’ll see below how FRACTRAN code <span epub:type="pagebreak" id="page_220"/>is stored. We chose a format friendly to Racket so we can add comments easily. The <span class="literal">file-&gt;list</span> function reads the code and returns a list of the fractions. The next argument is the starting integer, which Racket puts in <span class="literal">num</span>. The last argument, <span class="literal">trace</span>, is a 0 or 1 flag indicating whether to output only the final integer or all intermediate integers. We’ll learn what that means in a bit.</p>&#13;
<p class="indent">All of FRACTRAN is a single function that takes no arguments <span class="ent">➊</span>. It consists of a <span class="literal">do</span> loop, which is similar to a <span class="literal">for</span> loop in other languages, but is configured to run forever <span class="ent">➋</span>. The loop counter is <span class="literal">i</span>, which we use to get the <span class="literal">i</span>th fraction from <span class="literal">prog</span>.</p>&#13;
<p class="indent">The body of the <span class="literal">do</span> loop has two main parts: a <span class="literal">when</span> function <span class="ent">➌</span> and a <span class="literal">let</span> function <span class="ent">➍</span>. A <span class="literal">when</span> function checks whether a given condition is true, and if so, executes all the code in the body. This <span class="literal">when</span> checks to see if the loop counter matches the length of the program, that is, the number of fractions. If so, the program ends, outputting the final value of <span class="literal">num</span> if <span class="literal">trace</span> is 0.</p>&#13;
<p class="indent">The <span class="literal">let</span> function creates a local environment assigning <span class="literal">(* num (list-ref</span> <span class="literal">prog i))</span> to <span class="literal">n</span>. What is <span class="literal">(* num (list-ref prog i))</span>? It’s the current integer times the current fraction: <span class="literal">num*prog[i]</span>. The body of <span class="literal">let</span> is a single <span class="literal">when</span> <span class="ent">➎</span> function. The function <span class="literal">exact-integer?</span> is true when its argument, <span class="literal">n</span>, is an integer rather than a rational or a float. Recall that the fractions in <span class="literal">prog</span> are native Racket rational numbers. This is the condition we need to check. If true, we have a new integer, so the body of the <span class="literal">when</span> destructively sets <span class="literal">num</span> to the new value in <span class="literal">n</span> and modifies the loop counter by setting it to <em>–</em>1 so that the next iteration of the <span class="literal">do</span> begins again with 0. Additionally, if <span class="literal">trace</span> is 1, the new integer is output. The program starts by calling <span class="literal">FRACTRAN</span> <span class="ent">➏</span>.</p>&#13;
<p class="indent">Now, let’s implement FRACTRAN in Python.</p>&#13;
<h4 class="h4" id="lev2sec63"><strong><em>A Python Implementation</em></strong></h4>&#13;
<p class="noindent">The Racket version of FRACTRAN was straightforward, at least after learning to interpret Racket’s prefix approach to everything. Our Python implementation is longer, but it’s likely more familiar. Racket gave us arbitrary-precision integers, and Python gives us those, too. Racket also gave us rational arithmetic, which is something Python does not have out of the box, but does support via the <span class="literal">fractions</span> library module.</p>&#13;
<p class="indent">Our Python implementation mimics the Racket code in <a href="ch08.xhtml#ch08list1">Listing 8-1</a>. The code we’ll use is shown in <a href="ch08.xhtml#ch08list2">Listing 8-2</a>.</p>&#13;
<pre><span class="ent">➊</span> n = Fraction(int(sys.argv[2]))&#13;
<span class="ent">➋</span> p = LoadProgram(sys.argv[1])&#13;
   m = int(sys.argv[3]) if (len(sys.argv) &gt;= 4) else 0&#13;
   k = 0&#13;
<span class="ent">➌</span> while (k &lt; len(p)):&#13;
    <span class="ent">➍</span> v = n * p[k]&#13;
       if (v.denominator == 1):&#13;
           if (m):&#13;
               print(v)&#13;
           n = Fraction(v)&#13;
           k = -1<span epub:type="pagebreak" id="page_221"/>&#13;
       k += 1&#13;
   if (not m):&#13;
       print(n)</pre>&#13;
<p class="caption" id="ch08list2"><em>Listing 8-2: FRACTRAN in Python</em></p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08list2">Listing 8-2</a> shows the body of <span class="literal">main</span>. <em>FRACTRAN.py</em> uses the expected Python convention of running from <span class="literal">main</span> if not imported.</p>&#13;
<p class="indent">FRACTRAN in Python expects the same arguments as the Racket version: the name of the FRACTRAN program, the initial integer value, and whether to output every integer change. Unlike the Racket version, the final argument is optional and defaults to 0 if not present.</p>&#13;
<p class="indent">The code operates like the Racket version. The command line is parsed to set the initial integer as a rational <span class="ent">➊</span>, followed by loading the FRACTRAN code via <span class="literal">LoadProgram</span> <span class="ent">➋</span>. We won’t show <span class="literal">LoadProgram</span> here, but it loads the file and returns the fractions as a list of <span class="literal">Fraction</span> objects. Do read through it.</p>&#13;
<p class="indent">The <span class="literal">while</span> loop runs until all fractions in <span class="literal">p</span> are exhausted <span class="ent">➌</span>. The current integer (<span class="literal">n</span>) is multiplied by the current fraction (<span class="literal">p[k]</span>) <span class="ent">➍</span>. If the result is an integer, meaning the denominator is 1, we have a new <span class="literal">n</span>. Thus, <span class="literal">n</span> is updated and printed if <span class="literal">m = 1</span>. Lastly, as in the Racket version, the loop counter is reset so the fractions are scanned from the beginning again (<span class="literal">k = -1</span>). When the loop ends, the final value of <span class="literal">n</span> is printed if it has not already been printed above.</p>&#13;
<p class="indent">We now have two implementations of FRACTRAN ready to go. Why two? To illustrate that different programming languages require different thought processes to arrive at the same endpoint. This is a book on programming languages, after all. Now, lets put them through their paces.</p>&#13;
<h3 class="h3" id="lev1sec60"><strong>Using FRACTRAN</strong></h3>&#13;
<p class="noindent">The simplest FRACTRAN program is the single fraction, 3/2. It’s in the file <em>add.frac</em>. Let’s run it. We won’t understand the output just yet, but it will make sense eventually. Try the following:</p>&#13;
<pre>&gt; <span class="codestrong1">python3 FRACTRAN.py add.frac 72</span>&#13;
243&#13;
&gt; <span class="codestrong1">python3 FRACTRAN.py add.frac 3888</span>&#13;
19683&#13;
&gt; <span class="codestrong1">python3 FRACTRAN.py add.frac 2519424</span>&#13;
43046721&#13;
&gt; <span class="codestrong1">python3 FRACTRAN.py add.frac 4760622968832</span>&#13;
617673396283947</pre>&#13;
<p class="noindent">To test the Racket version, create a shell script named <em>FRACTRAN</em> with the following line, which wraps the command line Racket expects:</p>&#13;
<pre>racket -f FRACTRAN.scm $1 $2 $3</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_222"/>Lastly, make <em>FRACTRAN</em> executable by typing <span class="codestrong">chmod a+x FRACTRAN</span>. Let’s test the Racket version using <em>add.frac</em>. The output should match the Python version just shown.</p>&#13;
<pre>&gt; <span class="codestrong1">./FRACTRAN add.frac 72 0</span>&#13;
243&#13;
&gt; <span class="codestrong1">./FRACTRAN add.frac 3888 0</span>&#13;
19683&#13;
&gt; <span class="codestrong1">./FRACTRAN add.frac 2519424 0</span>&#13;
43046721&#13;
&gt; <span class="codestrong1">./FRACTRAN add.frac 4760622968832 0</span>&#13;
617673396283947</pre>&#13;
<p class="noindent">The output matches the Python version, so our FRACTRAN implementations are working; however, we don’t yet understand what the output means. Let’s remedy that situation.</p>&#13;
<h3 class="h3" id="lev1sec61"><strong>Understanding FRACTRAN</strong></h3>&#13;
<p class="noindent">FRACTRAN is perhaps the most elegant of all esolangs. It’s subtle, brilliant, strangely beautiful, and difficult. In this section, we’ll finally dive into the operation of FRACTRAN. We’ll start with <em>add.frac</em>, the version included with the book’s code. That version contains the following:</p>&#13;
<pre>;  Add two integers&#13;
;&#13;
;  Input:  (2**a)(3**b)&#13;
;  Output: 3**(a+b)&#13;
;&#13;
3/2</pre>&#13;
<p class="indent">It appears that <em>add.frac</em> adds two integers. Before learning how, we must make sense of the input and output comments. To do that, we must understand how FRACTRAN represents state.</p>&#13;
<p class="indent">FRACTRAN is a <em>register machine</em>, which is a hypothetical machine that manipulates an infinite set of registers. FRACTRAN uses Gödel numbering to represent its state, the value of the registers. So to understand FRACTRAN, we first must understand Gödel numbering.</p>&#13;
<p class="indent">Kurt Gödel was a German-Austrian-American mathematician most famous for his <em>incompleteness theorem</em>, by which he proved that in any system of axioms capable of describing mathematics with natural numbers, there are true statements that cannot be proved from the axioms. The incompleteness theorem sounded the death knell of early 20th-century attempts to put all of mathematics on rigorous footing.</p>&#13;
<p class="indent">As part of his incompleteness theorem, Gödel made use of <em>Gödel numbering</em>, which itself makes use of the fact that all integers can be expressed as the product of a unique set of prime numbers: <em>prime factorization</em>. For example, the prime factorization of 88 is 2<sup>3</sup>11<sup>1</sup>, whereas the prime factorization of 68,600 is 2<sup>3</sup>5<sup>2</sup>7<sup>3</sup>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_223"/>Gödel used his numbering scheme to represent the expressions and theorems of mathematics. FRACTRAN uses Gödel numbering to represent its state—the value of all registers—which must be positive or 0. For example, if the state is 88 = 2<sup>3</sup>11<sup>1</sup>, the v2 register is 3, the v11 register is 1, and all other registers are 0. It’s customary to refer to the registers by their associated primes. Similarly, the state 68,600 = 2<sup>3</sup>5<sup>2</sup>7<sup>3</sup> means v2 = 3, v5 = 2, and v7 = 3. As there are an infinite number of primes, there are an infinite number of FRACTRAN registers with all possible states representable by a single integer. This single integer is the integer multiplied by each fraction.</p>&#13;
<p class="indent">Let’s review a bit before proceeding. We must follow the link between the integer FRACTRAN manipulates, prime factorization of a number, and state represented by registers holding specific values.</p>&#13;
<p class="indent">Let’s start with registers holding values. At some point in a program, we may want register v17 to hold the value 12, that is, v17 = 12. Again, registers are identified by their prime, and 17 is a prime. In FRACTRAN, setting v17 to 12 means raising 17 to the 12th power: 17<sup>1</sup>2. Likewise, if we want v3 = 7, we use 3<sup>7</sup>. So to set a FRACTRAN register to a value, we raise the corresponding prime to that power.</p>&#13;
<p class="indent">The state of a FRACTRAN program is the current value of all of its registers. This is because FRACTRAN can manipulate only register values. To continue the example above, if v3 and v17 are the only nonzero registers, then the entire state of the FRACTRAN program is the product of 3<sup>7</sup> and 17<sup>1</sup>2, which is 3<sup>7</sup>17<sup>1</sup>2 = 1,274,194,832,821,487,307. This number is the integer FRACTRAN implementations use to represent the state.</p>&#13;
<p class="indent">Conway’s insight was that all positive integers can be written as the product of a series of primes in only one way, that is, prime factorization. Therefore, the large integer in the previous paragraph represents the state where v3 = 7 and v17 = 12 and all other registers are 0, and that is the <em>only</em> integer representing that state.</p>&#13;
<p class="indent">The fractions of a FRACTRAN program attempt to alter the state in two ways: by decrementing register values via canceling with the denominator and by incrementing register values via multiplying by the numerator. Only fractions where the denominator cancels completely “fire” are allowed to alter the program state.</p>&#13;
<p class="indent">We’re now able to understand the input and output comments from <em>add.frac</em>. The expected input sets register v2 = <em>a</em> and v3 = <em>b</em>. When the program ends, register v3 = <em>a</em> + <em>b</em>. Therefore, if we want to add <em>a</em> + <em>b</em> = 3 + 2, the input given to FRACTRAN is</p>&#13;
<p class="equationc">2<em><sup>a</sup></em>3<em><sup>b</sup></em> = 2<sup>3</sup>3<sup>2</sup> = 8(9) = 72</p>&#13;
<p class="noindent">which is the first test input above. If the input is 2<sup>3</sup>3<sup>2</sup>, then the output is, according to the comments in <em>add.frac</em>, 3<sup><em>a</em>+<em>b</em></sup> = 3<sup>3+2</sup> = 3<sup>5</sup> = 243, which is the first test output.</p>&#13;
<p class="indent">Let’s work through <em>add.frac</em> for the input 2<sup>3</sup>3<sup>2</sup> = 72 to see each step leading to the output. First, let’s run the code with trace on.</p>&#13;
<pre><span epub:type="pagebreak" id="page_224"/>&gt; <span class="codestrong1">./FRACTRAN add.frac 72 1</span>&#13;
108&#13;
162&#13;
243</pre>&#13;
<p class="indent">Trace tells us the program looped three times, changing the state from 72 → 108 → 162 → 243. Stepping through by hand gives</p>&#13;
<div class="imagec"><img src="Images/f0224-01.jpg" alt="Image" width="557" height="224"/></div>&#13;
<p class="noindent">Or, tracking the state: 2<sup>3</sup>3<sup>2</sup> → 2<sup>2</sup>3<sup>3</sup> → 2<sup>1</sup>3<sup>4</sup> → 2<sup>0</sup>3<sup>5</sup> = 3<sup>5</sup>.</p>&#13;
<p class="indent">Following how the state changes, especially when writing the prime factorization of the state, shows us what FRACTRAN is doing. The add program is a single instruction: 3/2. Every time the state is multiplied by 3/2, the 2 in the denominator decrements v2, and the 3 in the numerator increments v3. This is a general rule: the denominators are gatekeepers, so they decide whether the fraction “fires” or not. If the current integer contains factors of each prime factor of the denominator, to at least the power specified by the factor, then the denominator will be completely canceled and a new integer will be the result. This is what is meant by a fraction “firing.” When a fraction fires, it also decrements register values. Numerators, on the other hand, increment register values because they multiply the state integer. A FRACTRAN program is a sequence of operations applied to the state of the register machine.</p>&#13;
<p class="indent">For addition, every multiplication of the state by 3/2 increments v3 and decrements v2 until v2 = 0, making the state no longer evenly divisible by 2. According to the processing rule, the state should be multiplied by the next fraction in the list; however, there is no next fraction, so the program halts and outputs its state.</p>&#13;
<p class="indent">It’s clever enough to realize that repeated multiplications by 3/2 when an integer has the form 2<sup><em>a</em></sup>3<sup><em>b</em></sup> will result in 3<sup><em>a</em>+<em>b</em></sup>, thereby adding <em>a</em> and <em>b</em>, but realizing that this is a general form of computation is brilliant. We’ll explore other FRACTRAN programs, but before we do, notice that 3/2 isn’t the only add program in FRACTRAN—2/3 works as well. Instead of decrementing v2 and incrementing v3, 2/3 decrements v3 and increments v2, leaving the sum in v2. Let’s see that this is so.</p>&#13;
<pre>&gt; <span class="codestrong1">python3 FRACTRAN.py add2.frac 72 1</span>&#13;
48&#13;
32</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_225"/>The file <em>add2.frac</em> contains <span class="literal">2/3</span>. The input is 2<sup>3</sup>3<sup>2</sup> = 72 as before. The state transitions are</p>&#13;
<p class="equationc">2<sup>3</sup>3<sup>2</sup> = 72 → 2<sup>4</sup>3<sup>1</sup> = 48 → 2<sup>5</sup>3<sup>0</sup> = 32 → end → 2<sup>5</sup> = 32</p>&#13;
<p class="noindent">proving that the sum is in v2.</p>&#13;
<p class="noindent">Let’s make sure we follow how FRACTRAN manipulates state. These examples are not full programs, but they show the way fractions operate on the state. For example, see Equations 8.1 through 8.5.</p>&#13;
<div class="imagec"><img src="Images/08eqa01.jpg" alt="Image" width="603" height="62"/></div>&#13;
<div class="imagec"><img src="Images/08eqa02.jpg" alt="Image" width="582" height="63"/></div>&#13;
<div class="imagec"><img src="Images/08eqa03.jpg" alt="Image" width="568" height="50"/></div>&#13;
<div class="imagec"><img src="Images/08eqa04.jpg" alt="Image" width="569" height="50"/></div>&#13;
<div class="imagec"><img src="Images/08eqa05.jpg" alt="Image" width="571" height="63"/></div>&#13;
<p class="indent">Equation 8.1 fires because the denominator contains v5 and v17, which are also present in the state. Notice that several things happen when the fraction fires: v5 goes down by 4, v17 goes down by o1ne, v7 goes up by 2 (from 0), and v11 goes up by 1. Thus, the new state is v2 = 3, v5 = 3, v7 = 2, v11 = 1, and v17 = 1.</p>&#13;
<p class="indent">For Equation 8.2, there is no factor of 13 in the state (v13 = 0), so the result of multiplying the state by the fraction is not an integer. Therefore, the fraction does not fire, and FRACTRAN proceeds to the next fraction in the list.</p>&#13;
<p class="indent">Equation 8.3 fires and sets v2 = 0 without changing v5 or v17.</p>&#13;
<p class="indent">Equation 8.4 does not fire, because even though v2 = 3, attempting to subtract five from its state would make v2 negative, which is not allowed. The rules of FRACTRAN account for this by requiring the product of the state and a fraction to be an integer. The denominator of the fraction must be canceled completely by the prime factors of the state.</p>&#13;
<p class="indent">The addition example manipulated v2 and v3. These are often used because they are the smallest primes, but there is no reason they must be used. Any two primes will work. For example, 8,675,309 and 8,675,311 are both prime. To show they work just as well, create <em>add3.frac</em>, containing</p>&#13;
<pre>8675311/8675309</pre>&#13;
<p class="indent">Then add 3 and 2 as before using v8675309 and v8675311 to set the initial state:</p>&#13;
<p class="equationc">8675309<sup>3</sup>8675311<sup>2</sup> = 49138847138949979077348022181175509</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_226"/>Run it to get</p>&#13;
<pre>&gt; <span class="codestrong1">./FRACTRAN add3.frac 49138847138949979077348022181175509 0</span>&#13;
49138881124269787781458189243397551</pre>&#13;
<p class="noindent">which is 8675311<sup>5</sup>.</p>&#13;
<pre>&gt; <span class="codestrong1">python3</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">8675311**5</span>&#13;
49138881124269787781458189243397551</pre>&#13;
<p class="noindent">This proves once again that 3 + 2 = 5 and that any pair of FRACTRAN registers work.</p>&#13;
<h3 class="h3" id="lev1sec62"><strong>More FRACTRAN Examples</strong></h3>&#13;
<p class="noindent">Let’s examine more FRACTRAN examples. Specifically, let’s work through subtraction, the maximum of two values, duplicating registers, and multiplication. We’ll conclude by exploring Conway’s prime number example, PRIMEGAME, and the Collatz conjecture.</p>&#13;
<h4 class="h4" id="lev2sec64"><strong><em>Subtraction</em></strong></h4>&#13;
<p class="noindent">Addition in FRACTRAN is a single fraction, and it turns out that subtraction is as well (see <em>sub.frac</em>).</p>&#13;
<pre>;  Input:  (2**a)(3**b)&#13;
;  Output: 2**(a-b)&#13;
;&#13;
1/6</pre>&#13;
<p class="indent">Let’s run a test to work out 17 <em>–</em> 4 = 13. The input is 2<sup>17</sup>3<sup>4</sup> = 10,616,832, with intermediate values corresponding to states:</p>&#13;
<p class="equationc">2<sup>16</sup>3<sup>3</sup> → 2<sup>15</sup>3<sup>2</sup> → 2<sup>14</sup>3<sup>1</sup> → 2<sup>13</sup></p>&#13;
<pre>&gt; <span class="codestrong1">python3 FRACTRAN.py sub.frac 10616832 1</span>&#13;
1769472&#13;
294912&#13;
49152&#13;
8192</pre>&#13;
<p class="indent">The fraction 1/6 = 1/(2<sup>1</sup>3<sup>1</sup>), so every multiplication decrements both v2 and v3 by 1.</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_227"/><img src="Images/f0227-01.jpg" alt="Image" width="203" height="224"/></div>&#13;
<p class="noindent">It decrements both v2 and v3 by 1 until v3 = 0 and multiplication by 1/6 no longer produces an integer, causing the program to stop. By assumption, the input is of the form 2<em><sup>a</sup></em>3<em><sup>b</sup></em>, <em>a</em> &gt; <em>b</em>, so continually decrementing v2 and v3 together until v3 is 0 will necessarily leave the difference in v2. If <em>b</em> &gt; <em>a</em>, <em>sub.frac</em> still works, but the difference is in v3, not v2.</p>&#13;
<h4 class="h4" id="lev2sec65"><strong><em>Maximum of Two Integers</em></strong></h4>&#13;
<p class="noindent">FRACTRAN adds and subtracts using single fractions, but to do anything more requires additional fractions. The file <em>max.frac</em> contains</p>&#13;
<pre>;  Input:  (2**a)(3**b)&#13;
;  Output: 5**max(a b)&#13;
;&#13;
5/6 5/2 5/3</pre>&#13;
<p class="noindent">This is our first FRACTRAN program to use more than one fraction. The claim is that <em>max.frac</em> finds the largest of two integers, <em>a</em> and <em>b</em>. The input state looks familiar: register v2 = <em>a</em> and v3 = <em>b</em> with v5 holding the larger of the two when the program ends. Let’s try it and see.</p>&#13;
<pre>&gt; <span class="codestrong1">./FRACTRAN max.frac 3359232 1</span>&#13;
2799360&#13;
2332800&#13;
1944000&#13;
1620000&#13;
1350000&#13;
1125000&#13;
937500&#13;
781250&#13;
1953125</pre>&#13;
<p class="caption" id="ch08list3"><em>Listing 8-3: Finding the maximum of two integers</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_228"/>The input state is 2<sup>9</sup>3<sup>8</sup> = 3,359,232 and the output state is 5<sup>9</sup> = 1,953,125, which is correct, as 9 &gt; 8. Let’s follow the state step by step.</p>&#13;
<p class="equationc">2<sup>9</sup>3<sup>8</sup> → 2<sup>8</sup>3<sup>7</sup>5<sup>1</sup> → 2<sup>7</sup>3<sup>6</sup>5<sup>2</sup> → 2<sup>6</sup>3<sup>5</sup>5<sup>3</sup> → 2<sup>5</sup>3<sup>4</sup>5<sup>4</sup> →</p>&#13;
<p class="equationc">→ 2<sup>4</sup>3<sup>3</sup>5<sup>5</sup> → 2<sup>3</sup>3<sup>2</sup>5<sup>6</sup> → 2<sup>2</sup>3<sup>1</sup>5<sup>7</sup> → 2<sup>1</sup>3<sup>0</sup>5<sup>8</sup> → 5<sup>9</sup></p>&#13;
<p class="noindent">Each state is the prime factorization of the sequence of integers shown in <a href="ch08.xhtml#ch08list3">Listing 8-3</a>.</p>&#13;
<p class="indent">The state sequence shows us how the program progresses, but as we have multiple fractions, it doesn’t show us exactly what is happening. Therefore, let’s trace the program’s actual execution.</p>&#13;
<div class="imagec"><img src="Images/f0228-01.jpg" alt="Image" width="369" height="778"/></div>&#13;
<p class="noindent">Note that 5/6 is written as 5/(2<sup>1</sup>3<sup>1</sup>) to make it clear that 5/6 decrements v2 and v3 when both are greater than 0, and 0 exponents are used to emphasize that a particular register has 0 value.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_229"/>From the sequence of steps, we see that 5/6 starts a loop, decrementing v2 and v3 for as long as both of them are greater than 0. At the same time, the loop increments v5. Once v2 or v3 are 0, 5/6 does not fire, so the next fraction, 5/2, is tested. In this case, v3 = 0 and v2 &gt; 0, so 5/2 fires, incrementing v5 and decrementing v2. Then, and this is important, as there is a new state, the program loops <em>from the beginning</em> so both 5/6 and 5/2 are tested again. As v3 is 0, 5/6 doesn’t fire. Additionally, v2 is now 0, so 5/2 doesn’t fire, either. That leaves 5/3, but v3 is 0 already, so 5/3 does not fire. There are no more fractions, so the program ends with v2 = 0, v3 = 0, and v5 = 9, as it should in this case. If the program were run with v2=8 and v3 = 9, then after 5/6 stops firing, 5/2 would not fire, but 5/3 would count v3 to 0 while still incrementing v5.</p>&#13;
<p class="indent">Let’s write <em>max.frac</em> in a more familiar way. <a href="ch08.xhtml#ch08list4">Listing 8-4</a> presents a Python implementation of the algorithm implied by <em>max.frac</em> using register names (see <em>max.py</em>).</p>&#13;
<pre>while not ((v2 == 0) and (v3 == 0)):&#13;
    if (v2&gt;0) and (v3&gt;0):&#13;
        v2 = v2 - 1 &#13;
        v3 = v3 - 1 &#13;
        v5 = v5 + 1 &#13;
        continue&#13;
    if (v2&gt;0) and (v3==0):&#13;
        v2 = v2 - 1 &#13;
        v5 = v5 + 1 &#13;
        continue&#13;
    if (v2==0) and (v3&gt;0):&#13;
        v3 = v3 - 1 &#13;
        v5 = v5 + 1 &#13;
        continue</pre>&#13;
<p class="caption" id="ch08list4"><em>Listing 8-4: The FRACTRAN max program in Python</em></p>&#13;
<p class="indent">The outer <span class="literal">while</span> loop runs until both v2 and v3 are 0. This is equivalent to restarting the scan of fractions from the beginning every time the state changes. The first <span class="literal">if</span> acts like 5/6, looping for as long as both v2 and v3 are greater than 0. Notice that because of the <span class="literal">continue</span>, the following <span class="literal">if</span> statements are not even considered until at least one of v2 or v3 are 0.</p>&#13;
<p class="indent">The second <span class="literal">if</span> acts like 5/2. It loops if v3 is 0 but v2 is not. The <span class="literal">continue</span> here starts the outer <span class="literal">while</span> loop again, meaning the first <span class="literal">if</span> is evaluated yet again; however, as v3 must be 0 for the second <span class="literal">if</span> to fire, the first <span class="literal">if</span> does not execute.</p>&#13;
<p class="indent">Lastly, if v2 is decremented to 0 first by the first <span class="literal">if</span>, then the last <span class="literal">if</span> fires to decrement v3 until 0. Notice that each <span class="literal">if</span> statement increments v5 every time it fires.</p>&#13;
<p class="indent">The first <span class="literal">if</span> decrements both v2 and v3 while incrementing v5. This removes the value in common between v2 and v3. The following two <span class="literal">if</span> statements provide clean up. One or the other will fire until whichever register <span epub:type="pagebreak" id="page_230"/>that isn’t yet 0, either v2 or v3, becomes 0. As v5 is always incremented regardless of which <span class="literal">if</span> fires, v5 will ultimately contain v2 or v3, whichever is larger. Note also that this program is destructive; both v2 and v3 will be lost.</p>&#13;
<h4 class="h4" id="lev2sec66"><strong><em>Copying a Register</em></strong></h4>&#13;
<p class="noindent">FRACTRAN fractions fire when all of the prime factors of the denominator, to at least the power present in the denominator, are likewise present in the current state. In other words, the registers corresponding to the prime factors of the fraction’s denominator must have a value at least as large as the exponent of the denominator’s prime factors. Additionally, the act of firing necessarily decrements a register’s value. This is exactly how 3/2 operates in <em>add.frac</em>.</p>&#13;
<p class="indent">Therefore, to move the value of register v2 to, say, v7, we need a single fraction, 7/2. This is because every time it fires, v2 is decremented and v7 is incremented until v2 is 0. The value of v2 is now in v7 and is no longer in v2. What if instead we want to copy the value in v2 to v7 while leaving it in v2? Learning how to do this in FRACTRAN will teach us what we need to know to understand our next example, multiplication.</p>&#13;
<p class="indent">Our copying-a-register code is based on an example found on Chris Lomont’s blog (see <em><a href="http://lomont.org/posts/2017/fractran/">http://lomont.org/posts/2017/fractran/</a></em>). In this example, he not only gives detailed descriptions of various FRACTRAN programs, but presents a FRACTRAN interpreter written in FRACTRAN. Do take a look.</p>&#13;
<p class="indent">There is no getting around decrementing our source register, as that’s the only way we’ll get the fraction to fire. The trick, according to Chris, is to move the register’s value to <em>two</em> other registers: the desired target register and an auxiliary register. Then, when the move is complete, copy the auxiliary register back to the source.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08list5">Listing 8-5</a> shows <em>copy.frac</em>, which copies the contents of v2 to v3.</p>&#13;
<pre>;  Input: 2^a 7&#13;
;  Output: 2^a 3^a&#13;
;&#13;
165/14 7/11 13/7 34/65 13/17 1/13</pre>&#13;
<p class="caption" id="ch08list5"><em>Listing 8-5: Copying v2 to v3</em></p>&#13;
<p class="indent">Our plan of attack is to define what each register will do, show the code again using prime factors, and, lastly, walk through the steps to copy v2 = 3 to v3.</p>&#13;
<p class="indent">To copy v2 to v3, we clearly need at least those two registers. The source is v2 and the target is v3. We’ll use v5 as the second copy of v2. The copy algorithm is as follows:</p>&#13;
<ol>&#13;
<li class="noindent">Decrement v2; increment v3 and v5.</li>&#13;
<li class="noindent">Repeat Step 1 until v2 is 0.</li>&#13;
<li class="noindent">Decrement v5; increment v2.</li>&#13;
<li class="noindent">Repeat Step 3 until v5 is 0.</li>&#13;
</ol>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_231"/>We need two loops, one to increment v3 and v5 running v2 times and another incrementing v2 running v5 times. FRACTRAN always scans fractions from the first onward, so loops are implemented by flags triggering the next scan of the code. Two loops imply that we need two additional registers to act as flags. However, to fire a fraction, we must always decrement at least one register, so using a single register to cause a loop destroys the flag value. Two registers are needed—one to trigger the loop and another to restore the flag after it was decremented. We’ll use v7 and v11 as flags for the first loop. Registers v13 and v17 will handle the second loop.</p>&#13;
<p class="indent">We now have our registers. Let’s review the code again, but this time using prime factors with labels and comments.</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:10%"/>&#13;
<col style="width:45%"/>&#13;
<col style="width:45%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Label</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="tabac"><strong>Fraction</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Comment</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">A</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="tabac"><img src="Images/f0231-03.jpg" alt="Image" width="72" height="48"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Inc v3,v5; Dec v2,v7</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">B</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="tabac"><img src="Images/f0231-04.jpg" alt="Image" width="22" height="41"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Reset v7</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">C</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="tabac"><img src="Images/f0231-05.jpg" alt="Image" width="38" height="51"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Clear v7; Set v13</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">D</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="tabac"><img src="Images/f0231-06.jpg" alt="Image" width="52" height="49"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Inc v2; Dec v5</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">E</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="tabac"><img src="Images/f0231-07.jpg" alt="Image" width="44" height="51"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Reset v13</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">F</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="tabac"><img src="Images/f0231-08.jpg" alt="Image" width="22" height="40"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Clear v13</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Let’s take a walk through the code. We set the initial state to 2<sup>3</sup>7 = 56 to set v2 = 3 and v7, the flag for the first loop. The program then runs like so:</p>&#13;
<div class="imagec"><img src="Images/f0231-02.jpg" alt="Image" width="692" height="126"/></div>&#13;
<p class="noindent">The numbers represent the state after each fraction fires. The label above the arrow shows which fraction fired. The loops are evident: fractions A and B repeat three times. This decrements v2 and increments v3 and v5. Then fraction C fires to clear v7 and set v13. Doing this initiates the second loop. The second loop runs three times, with fractions D and E firing to decrement v5 and increment v2, thereby restoring its initial value. The very last fraction, F, then fires to clear v13. After this, no other fractions fire, so the program ends with v2 = v3 = 3, as intended.</p>&#13;
<p class="indent">Let’s look a bit more closely at the paired flags. The program begins with v7 set. Fraction A fires because both v2 and v7 are greater than 0. Register v2 is decremented along with v7. The numerator of fraction A increments v3 and v5 and sets v11. To continue the loop, we must set v7 again. <span epub:type="pagebreak" id="page_232"/>That’s what fraction B does: it fires when v11 is set (&gt;0) and resets v7. The loop then continues firing fraction A again because v2 and v7 are both greater than 0, that is, the state contains factors of 2 and 7. When v2 is drained, v3 and v5 are both set to what v2 was initially. Fraction C then fires to clear v7 and set v13 to begin the second loop to move v5 back to v2 using fractions D and E. To end the program with no flags set, fraction F clears v13.</p>&#13;
<p class="indent">Now, let’s see how this double-move loop structure can be used to implement multiplication.</p>&#13;
<h4 class="h4" id="lev2sec67"><strong><em>Multiplication</em></strong></h4>&#13;
<p class="noindent">Multiplication of two integers is repeated addition. To find the product of <em>a</em> × <em>b</em>, we either add <em>a</em> to itself <em>b</em> times or add <em>b</em> to itself <em>a</em> times. This is likely the origin of using the word <em>times</em> for multiplication. The copy example given earlier showed us how to use flags to set up independent loops and how to increment a register a set number of times while preserving the source register’s value. Let’s use repeated addition along with copying to implement multiplication.</p>&#13;
<p class="indent">Specifically, we want a FRACTRAN program that takes an input state of 2<sup><em>a</em></sup>3<sup><em>b</em></sup> and generates a final state of 5<sup><em>ab</em></sup> by adding v2 to v5 v3 times. We’ll implement the following algorithm:</p>&#13;
<ol>&#13;
<li class="noindent">While v2 &gt; 0, increment v5 and v7.</li>&#13;
<li class="noindent">While v7 &gt; 0, increment v2.</li>&#13;
<li class="noindent">While v3 &gt; 0, repeat from Step 1.</li>&#13;
</ol>&#13;
<p class="indent">The first loop is Step 1, which decrements v2 while incrementing v5 and v7. Register v5 holds the product, so we’ll only increment it. Register v7 is used to hold v2 as v2 is drained while adding it to v5. Step 2 restores v2 by moving v7 back to v2 just as we did in <em>copy.frac</em>. Steps 1 and 2 repeat until v3 is 0, thereby adding v2 to v5 v3 times.</p>&#13;
<p class="indent">There are three loops, but we can combine Steps 2 and 3 into a single loop. For Step 1, we need a pair of registers for the flag; we’ll use v11 and v13. The initial version of this program added v17 for the other loop, but that would only be necessary if there were code after the multiplication.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08list6">Listing 8-6</a> shows the end result (see <em>mult.frac</em>).</p>&#13;
<pre>;  Input:  2^a 3^b&#13;
;  Output: 5^{ab}&#13;
;&#13;
&#13;
455/22 11/13 1/11 2/7 11/3 1/2</pre>&#13;
<p class="caption" id="ch08list6"><em>Listing 8-6: Multiplication by repeated addition</em></p>&#13;
<p class="indent">Let’s label the fractions A through F as we did earlier. Doing this gives us:</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:10%"/>&#13;
<col style="width:45%"/>&#13;
<col style="width:45%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><span epub:type="pagebreak" id="page_233"/><strong>Label</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="tabac"><strong>Fraction</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Comment</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">A</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="tabac"><img src="Images/f0233-03.jpg" alt="Image" width="94" height="55"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Inc v5, v7; Set v13; Dec v2; Clear v11</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">B</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="tabac"><img src="Images/f0233-04.jpg" alt="Image" width="22" height="40"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Reset v11</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">C</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="tabac"><img src="Images/f0233-05.jpg" alt="Image" width="44" height="48"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Clear v11</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">D</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="tabac"><img src="Images/f0233-06.jpg" alt="Image" width="12" height="40"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Inc v2; Dec v7</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">E</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="tabac"><img src="Images/f0233-07.jpg" alt="Image" width="22" height="39"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Dec v3; Set v11</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">F</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="tabac"><img src="Images/f0233-08.jpg" alt="Image" width="12" height="41"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Dec v2</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">With this table, we can walk through a trace of 3 × 2 = 6. The input state is 2<sup>3</sup>3<sup>2</sup> = 72 and the expected output state is 5<sup>6</sup> = 15625. First, let’s see that <em>mult.frac</em> actually works:</p>&#13;
<pre>&gt; <span class="codestrong1">./FRACTRAN mult.frac 72 0</span>&#13;
15625</pre>&#13;
<p class="noindent">The output is as expected. Now, let’s trace the evolution of the state:</p>&#13;
<div class="imagec"><img src="Images/f0233-09.jpg" alt="Image" width="659" height="225"/></div>&#13;
<p class="noindent">The first fraction to fire is E, which decrements v3 and sets v11 to cause the add-v2-to-v5 loop to execute. The add loop, fractions A and B, repeats three times to increment v5 and v7. After the third iteration, there is no longer a factor of 2 in the state (v2 = 0), so fraction C fires next to clear v11 and begin the outer loop.</p>&#13;
<p class="indent">The first part of the outer loop uses D to decrement v7 and increment v2, thereby restoring v2 to its original value. After the third time through that loop, v7 is 0 and 7 is no longer a factor of the state, so fraction E fires to decrement v3 and set v11 to add v2 to v5 again.</p>&#13;
<p class="indent">The add loop of fractions A and B runs another three times. At this point, we have our answer in v5, and v2 and v3 are both 0, but fraction C fires again because v7 is not 0. Fraction C fires three times to make v7 0 and <span epub:type="pagebreak" id="page_234"/>v2 = 3. However, v3 is now 0, so v11 is never set. Register v7 is now also 0 and the state is only v2 = 3 and v5 = 6. Therefore, no fraction fires until F, which fires three times to decrement v2 to 0. Lastly, the state is only v5 = 6, and no fraction has a factor of 5 in its denominator, so no fractions fire and the program ends. <a href="ch08.xhtml#ch08list6">Listing 8-6</a> multiplies, but cleaning up after calculating the answer requires many additional operations.</p>&#13;
<p class="indent">Let’s change gears now and explore the first FRACTRAN program Conway presented: PRIMEGAME.</p>&#13;
<h4 class="h4" id="lev2sec68"><strong><em>Conway’s PRIMEGAME</em></strong></h4>&#13;
<p class="noindent">When Conway first presented PRIMEGAME, he did so by writing the fractions in <a href="ch08.xhtml#ch08list7">Listing 8-7</a> and claiming that not only does every power of two generated by the program have a prime exponent, the primes are in order. Let’s explore in this section what he meant.</p>&#13;
<pre>;  Input:  2&#13;
;&#13;
&#13;
17/91 78/85 19/51 23/38 29/33 77/29 95/23 77/19 1/17 &#13;
11/13 13/11 15/14 15/2 55/1</pre>&#13;
<p class="caption" id="ch08list7"><em>Listing 8-7: Conway’s PRIMEGAME</em></p>&#13;
<p class="indent">Unlike the copy and multiply examples above, we won’t step through <a href="ch08.xhtml#ch08list7">Listing 8-7</a>. Conway does so in lectures available on the internet (for example, see <em><a href="https://www.youtube.com/watch?v=548BH-YFT1E/">https://www.youtube.com/watch?v=548BH-YFT1E/</a></em>). Instead, we’ll capture the output of <a href="ch08.xhtml#ch08list7">Listing 8-7</a> to see, empirically, that Conway’s claim is true. I leave it as an exercise for the motivated reader to work through the operation of <a href="ch08.xhtml#ch08list7">Listing 8-7</a>.</p>&#13;
<p class="indent">The primes program never halts, so we need to tell the interpreter to display every new state. If you run <em>primes.frac</em> with an initial state of 2</p>&#13;
<pre>&gt; <span class="codestrong1">python3 FRACTRAN.py primes.frac 2 1</span></pre>&#13;
<p class="noindent">your screen would immediately fill with large numbers. Some of these numbers are powers of two. Those are the numbers we want to display. We could modify <em>FRACTRAN.py</em> to display only the powers of two, but why alter the code for the interpreter when we can instead feed the output of <em>primes.frac</em> to the input of a second program that takes the output and, if it is a power of two, displays it?</p>&#13;
<p class="indent">The script <em>power_of_two.py</em> does what we want. It uses <span class="literal">input</span> to read the number FRACTRAN displays and checks whether it is a power of two. <a href="ch08.xhtml#ch08list8">Listing 8-8</a> contains the code.</p>&#13;
<pre><span class="ent">➊</span> def isPowerOfTwo(d):&#13;
       s = "{0:b}".format(d)&#13;
       n = s.count("1")&#13;
       p = len(s)-1&#13;
       return (n == 1), p<span epub:type="pagebreak" id="page_235"/>&#13;
&#13;
<span class="ent">➋</span> while (True):&#13;
       try:&#13;
        <span class="ent">➌</span> d = int(input())&#13;
       except:&#13;
           exit(0)&#13;
       ok, p = isPowerOfTwo(d)&#13;
       if (ok):&#13;
           print("2**%d = %d" % (p, 2**p))</pre>&#13;
<p class="caption" id="ch08list8"><em>Listing 8-8: A Python script to check for powers of two</em></p>&#13;
<p class="indent">The script accepts the input from FRACTRAN as an integer <span class="ent">➌</span>, passes it to <span class="literal">isPowerOfTwo</span>, which returns <span class="literal">True</span> if the input (<span class="literal">d</span>) is a power of two and then prints it along with the exponent (<span class="literal">p</span>). This process repeats forever because of the <span class="literal">while</span> loop <span class="ent">➋</span>.</p>&#13;
<p class="indent">The function <span class="literal">isPowerOfTwo</span> <span class="ent">➊</span> must check whether its argument is a power of two. We could call a log base-2 function here, but we’ll quickly encounter integers too large for any function expecting a floating-point argument. If an integer is a power of two, that means there is only one digit in its binary representation that is a 1. So <span class="literal">d</span> is converted to binary and stored as a string in <span class="literal">s</span>. Then we set <span class="literal">n</span> to the number of 1s by using <span class="literal">count</span>. If <span class="literal">d</span> is a power of two, the exponent is the number of digits in <span class="literal">d</span> minus one (<span class="literal">p</span>). Lastly, any power of two is displayed along with its exponent.</p>&#13;
<p class="indent">To link the output of FRACTRAN to the input expected by <a href="ch08.xhtml#ch08list8">Listing 8-8</a>, we use a Unix pipe character, <span class="literal">|</span>:</p>&#13;
<pre>&gt; <span class="codestrong1">python3 FRACTRAN.py primes.frac 2 1 | python3 power_of_two.py</span></pre>&#13;
<p class="noindent">which feeds the output of FRACTRAN to the input of <em>power_of_two.py</em> to display powers of two. For example, the output begins as follows:</p>&#13;
<pre>2**2 = 4&#13;
2**3 = 8&#13;
2**5 = 32&#13;
2**7 = 128&#13;
2**11 = 2048&#13;
2**13 = 8192&#13;
2**17 = 131072&#13;
2**19 = 524288&#13;
2**23 = 8388608&#13;
2**29 = 536870912&#13;
2**31 = 2147483648&#13;
2**37 = 137438953472&#13;
2**41 = 2199023255552&#13;
2**43 = 8796093022208&#13;
2**47 = 140737488355328&#13;
2**53 = 9007199254740992</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_236"/>Here the exponents are all primes and, more than that, primes in the correct order with no gaps, just like Conway promised. The rate at which new primes are generated slows as the primes get larger. For example, the file <em>powers_of_two.txt</em> contains the output generated by letting the code run over-night. The largest prime found was 953.</p>&#13;
<p class="indent">Devin Kilminster made a nine fraction version of PRIMEGAME that outputs the primes as powers of 10 instead of two. See <a href="ch08.xhtml#ch08list9">Listing 8-9</a> (<em>prime10.frac</em>).</p>&#13;
<pre>;  Input:  10&#13;
;&#13;
3/11 847/45 143/6 7/3 10/91 3/7 36/325 1/2 36/5</pre>&#13;
<p class="caption" id="ch08list9"><em>Listing 8-9: Kilminster’s primes</em></p>&#13;
<p class="indent">Run <em>prime10.frac</em> with <em>power_of_ten.py</em> as we did for Conway’s game above.</p>&#13;
<pre>&gt; <span class="codestrong1">./FRACTRAN prime10.frac 10 1 | python3 power_of_ten.py</span></pre>&#13;
<p class="noindent">The output sequence using powers of 10 generates the primes, in order.</p>&#13;
<p class="indent">We might wonder which prime generator is faster. I modified <em>power_of</em> <em>_two.py</em> and <em>power_of_ten.py</em> to stop after the 100th prime, 541, and timed how long each program took using the Racket version of the FRACTRAN interpreter.</p>&#13;
<table class="all5">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba">Program</p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba">Runtime(s)</p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Conway</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">3317</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Kilminster</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">783</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">Not only is Kilminster’s program shorter than Conway’s original PRIMEGAME, it’s also significantly faster.</p>&#13;
<p class="indent">Our next example generates the Collatz sequence for an integer. Don’t worry, I’ll explain what that means.</p>&#13;
<h4 class="h4" id="lev2sec69"><strong><em>The Collatz Conjecture</em></strong></h4>&#13;
<p class="noindent">Lothar Collatz was a German mathematician. In 1937, he speculated that the following sequence, for any initial integer, <em>x</em><sub>0</sub> = <em>n</em>, will always end with 1 (see Equation 8.6):</p>&#13;
<div class="imagec"><img src="Images/08eqa06.jpg" alt="Image" width="455" height="76"/></div>&#13;
<p class="noindent">For example, the sequence for <em>n</em> = 10 is</p>&#13;
<p class="equationc">10 → 5 → 16 → 8 → 4 → 2 → 1</p>&#13;
<p class="indent">Once the output is 4, the sequence 4 → 2 → 1 will repeat forever because 3(1) + 1 = 4.</p>&#13;
<p class="indent">To date, no one has succeeded in proving the Collatz conjecture, and all empirical tests have always ended in 1. There is a deep connection between <span epub:type="pagebreak" id="page_237"/>FRACTRAN and the Collatz conjecture that we’ll get to in the discussion below. For now, let’s run Conway’s FRACTRAN program to generate the Collatz sequence for any integer, <em>n</em>. (It’s highly likely Conway wrote this code, but solid proof has not been forthcoming.) The code is in <em>collatz.frac</em> and <a href="ch08.xhtml#ch08list10">Listing 8-10</a>.</p>&#13;
<pre>165/14 11/63 38/21 13/7 34/325 1/13 184/95 1/19 &#13;
7/11 13/17 19/23 1575/4</pre>&#13;
<p class="caption" id="ch08list10"><em>Listing 8-10: FRACTRAN code to generate the Collatz sequence</em></p>&#13;
<p class="noindent">The input is 2<sup><em>n</em></sup> and the final output is 2<sup>1</sup>. All states that are powers of two represent a number in the Collatz sequence. So we must filter the output using <em>power_of_two.py</em> as we did for PRIMEGAME above. Let’s try a few runs beginning with <em>n</em> = 128.</p>&#13;
<pre>&gt; <span class="codestrong1">./FRACTRAN collatz.frac 340282366920938463463374607431768211456 1 &#13;
   | python3 power_of_two.py</span>&#13;
2**64 = 18446744073709551616&#13;
2**32 = 4294967296&#13;
2**16 = 65536&#13;
2**8 = 256&#13;
2**4 = 16&#13;
2**2 = 4&#13;
2**1 = 2</pre>&#13;
<p class="noindent">The large starting state is 2<sup>128</sup>. The Collatz sequence ends after seven steps. Not all sequences are so short. For example, changing from <em>n</em> = 128 to <em>n</em> = 129 generates</p>&#13;
<pre> 388,  194,   97,  292,  146,   73,  220,  110,   55,  166,&#13;
  83,  250,  125,  376,  188,   94,   47,  142,   71,  214, &#13;
 107,  322,  161,  484,  242,  121,  364,  182,   91,  274, &#13;
 137,  412,  206,  103,  310,  155,  466,  233,  700,  350, &#13;
 175,  526,  263,  790,  395, 1186,  593, 1780,  890,  445, &#13;
1336,  668,  334,  167,  502,  251,  754,  377, 1132,  566, &#13;
 283,  850,  425, 1276,  638,  319,  958,  479, 1438,  719, &#13;
2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822,  911, &#13;
2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, &#13;
 577, 1732,  866,  433, 1300,  650,  325,  976,  488,  244, &#13;
 122,   61,  184,   92,   46,   23,   70,   35,  106,   53, &#13;
 160,   80,   40,   20,   10,    5,   16,    8,    4,    2,   1</pre>&#13;
<p class="noindent">for a total of 121 steps. As with PRIMEGAME, parsing the algorithm in <em>collatz.frac</em> is left as an exercise for the ambitious reader.</p>&#13;
<p class="indent">Note that the sequence for 129 included values as large as 9,232. This means the state contained a factor of 2<sup>9232</sup>, a number with 2,780 digits. Although <em>collatz.frac</em> will work for any integer, the intermediate values become quite large. Play around with <em>collatz.frac</em> or, if you are impatient, the much <span epub:type="pagebreak" id="page_238"/>faster Python version, <em>collatz.py</em>. Do you notice anything interesting about the largest value in each sequence for <em>n</em> from 5 to 200?</p>&#13;
<h4 class="h4" id="lev2sec70"><strong><em>A FRACTRAN Greeting</em></strong></h4>&#13;
<p class="noindent">We’ll end with an example more cute than it is useful. However, it does one interesting thing: the program’s goal is not a specific set of register values, per se, but the decimal value of the single integer representing the final state. The code is in <em>hello.frac</em> and <a href="ch08.xhtml#ch08list11">Listing 8-11</a>.</p>&#13;
<pre>;  Input:  2^3 5^1 7^1 11^1 == 3080&#13;
;  Output: 72697676794432877982766833&#13;
&#13;
3/2 41/5 6701021/7 9800132160937639/11</pre>&#13;
<p class="caption" id="ch08list11"><em>Listing 8-11: A FRACTRAN greeting</em></p>&#13;
<p class="indent">First, run the program to verify that it produces the claimed output.</p>&#13;
<pre>&gt; <span class="codestrong1">./FRACTRAN hello.frac 3080 0</span>&#13;
72697676794432877982766833</pre>&#13;
<p class="noindent">Next, pipe the output to <em>hello.py</em>.</p>&#13;
<pre>&gt; <span class="codestrong1">./FRACTRAN hello.frac 3080 0 | python3 hello.py</span>&#13;
HELLO, WORLD!</pre>&#13;
<p class="noindent">The <em>hello.py</em> script is</p>&#13;
<pre>d = input()&#13;
while (d != ""):&#13;
    print(chr(int(d[:2])), end="")&#13;
    d = d[2:]&#13;
print()</pre>&#13;
<p class="noindent">This reads the FRACTRAN output as a string, breaking it up into pairs of digits and outputting the ASCII character corresponding to that pair of digits.</p>&#13;
<p class="indent">Let’s walk through <em>hello.frac</em>. The starting state is 2<sup>3</sup>5<sup>1</sup>7<sup>1</sup>11<sup>1</sup>. The denominators of the fractions are also 2, 5, 7, and 11. Therefore, the initial state will match each fraction, but the fractions’ order means it matches 3/2 first. The product of the state and 3/2 decrements v2 and increments v3, then starts again from the beginning, matching 3/2 a second time. Now v2 = 1 and v3 = 2. Looping again sets v2 to 0 and v3 to 3. Now the state has no factor of 2, so 3/2 does not fire, and FRACTRAN moves to 41/5. The state is 3<sup>3</sup>5<sup>1</sup>7<sup>1</sup>11<sup>1</sup>, which does have a factor of 5, so v5 is decremented, v41 is incremented, and the program loops. There are only factors of 7 and 11 left to match fractions. First, the fraction with a denominator of 7 matches and fires followed by the fraction with a denominator of 11.</p>&#13;
<p class="indent">The final state of the system is</p>&#13;
<p class="equationc">3<sup>3</sup>41<sup>1</sup>6701021<sup>1</sup>9800132160937639<sup>1</sup> = 72697676794432877982766833</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_239"/>which is precisely what we want it to be: a string of ASCII character codes.</p>&#13;
<p class="indent">We wanted <em>hello.frac</em> to produce the integer corresponding to the sentence <span class="literal">HELLO, WORLD!</span>. That determined the printed output. The prime factorization of that output determined the final registers and their values. The included <em>primeFactors.py</em> searches for prime factors, but it is too slow to factor a large integer like the output of <em>hello.frac</em>. For that, I used WolframAlpha (see <em><a href="https://www.wolframalpha.com/">https://www.wolframalpha.com/</a></em>). Prime factors in hand, the program itself was straightforward: set the initial state to v2 = 3, v5 = 1, v7 = 1, and v11 = 1. Then, use the prime factors as the numerators to increment v3, v41, and so on for the necessary number of times: 3, 1, 1, and 1.</p>&#13;
<p class="indent">Of course, we could initialize the program with the desired output state and, using a fraction with no factor in the denominator matching the state, produce the desired output immediately, but that would be boring.</p>&#13;
<h3 class="h3" id="lev1sec63"><strong>Discussion</strong></h3>&#13;
<p class="noindent">Let’s discuss two aspects of FRACTRAN: Turing completeness and its relation to the Collatz conjecture. After that, we’ll conclude with some final thoughts.</p>&#13;
<h4 class="h4" id="lev2sec71"><strong><em>Is FRACTRAN Turing Complete?</em></strong></h4>&#13;
<p class="noindent">Is FRACTRAN Turing complete? Yes, it is. FRACTRAN has looping and an infinite number of registers as there are an infinite number of primes. Additionally, FRACTRAN can implement FRACTRAN, as Chris Lomont’s blog post mentioned previously demonstrates. Also, FRACTRAN is a Minsky-style register machine, a machine that has been proven to be Turing complete, so FRACTRAN is also Turing complete.</p>&#13;
<p class="indent">Conway himself included a universal FRACTRAN program in his description of FRACTRAN: POLYGAME. See “FRACTRAN: A Simple Universal Programming Language for Arithmetic” in <em>Open Problems in Communication and Computation</em> (Springer, 1987).</p>&#13;
<p class="indent">POLYGAME is a FRACTRAN program capable of computing any function when given the proper “catalogue number” as Conway called it. We’ll use the British spelling henceforth. Here is POLYGAME:</p>&#13;
<div class="imagec"><img src="Images/f0239-01.jpg" alt="Image" width="565" height="108"/></div>&#13;
<p class="indent">The input is <em>c</em>2<sup>2<sup><em>n</em></sup></sup>, with <em>n</em> the argument and <em>c</em> the catalogue number. The output is 2<sup>2<sup>m</sup></sup> to implement <em>f</em><sub><em>c</em></sub>(<em>n</em>) = <em>m</em>. For example, the increment function <em>n</em> →<em>n</em> + 1 has catalogue number 2,268,945. Therefore, to increment 4, the input to FRACTRAN is</p>&#13;
<p class="equationc">(2,268,945)2<sup>2<sup>4</sup></sup> = 148,697,579,520</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_240"/>to produce the output</p>&#13;
<p class="equationc">2<sup>2<sup>5</sup></sup> = 4,294,967,296</p>&#13;
<p class="noindent">which is exactly what we get if we run POLYGAME.</p>&#13;
<pre>&gt; <span class="codestrong1">./FRACTRAN polygame.frac 148697579520 0</span>&#13;
4294967296</pre>&#13;
<p class="indent">POLYGAME can implement <em>all</em> functions given the proper <em>c</em>. Another example is <em>c</em> = 255, the identity function: <em>n</em> → <em>n</em>. The most interesting example Conway gives is <em>c</em><sub><em>π</em></sub>. It’s an integer, but good luck calculating</p>&#13;
<div class="image"><img src="Images/f0270-1.jpg" alt="Image" width="700" height="500"/></div>&#13;
<p class="noindent">Yes, that is a 5 raised to the power of two raised to the factorial of 101. Given the insane size of <em>c</em><sub><em>π</em></sub>, we’ll take Conway’s word for it that <em>c</em><sub><em>π</em></sub> is the catalogue number for a function, <em>π</em>(<em>n</em>), returning the <em>n</em>th digit of <em>π</em>.</p>&#13;
<h4 class="h4" id="lev2sec72"><strong><em>FRACTRAN and the Collatz Conjecture</em></strong></h4>&#13;
<p class="noindent">Equation 8.6 defined the Collatz sequence for an integer, <em>n</em>. The equation describes how to generate the next number in the sequence based on whether the current number is even or odd. Another way to formulate Equation 8.6 is shown in Equation 8.7.</p>&#13;
<div class="imagec"><img src="Images/08eqa07.jpg" alt="Image" width="491" height="75"/></div>&#13;
<p class="noindent">meaning <em>x</em><sub><em>i</em>+1</sub> = <em>x</em><sub><em>i</em></sub>/2 if <em>x</em><sub><em>i</em></sub>/2 is an integer; otherwise, <em>x</em><sub><em>i</em>+1</sub> = 3<em>x</em><sub><em>i</em></sub> + 1, which is always an integer.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_241"/>The Collatz sequence is what Conway terms a <em>bipartite linear function</em>, meaning a function that can be written as</p>&#13;
<p class="equationc"><em>g</em>(<em>n</em>) = <em>g</em><sub>1</sub>(<em>n</em>) <em>|</em> <em>g</em><sub>2</sub>(<em>n</em>)</p>&#13;
<p class="noindent">with <em>g</em>(<em>n</em>) returning whichever of <em>g</em><sub>1</sub>(<em>n</em>) or <em>g</em><sub>2</sub>(<em>n</em>) returns an integer first when evaluating left to right. Each <em>g</em><sub><em>i</em></sub>(<em>n</em>) is of the form</p>&#13;
<p class="equationc"><em>g</em><em><sub>i</sub></em>(<em>n</em>) = <em>a</em><em><sub>i</sub></em><em>n</em> + <em>b</em><em><sub>i</sub></em></p>&#13;
<p class="noindent">which is a linear function (a line). For the Collatz sequence, <em>a</em><sub>1</sub> = 1/2 and <em>b</em><sub>1</sub> = 0. Similarly, <em>a</em><sub>2</sub> = 3 and <em>b</em><sub>2</sub> = 1.</p>&#13;
<p class="indent">There is no reason why <em>g</em>(<em>n</em>) should be limited to only two parts. A <em>k</em>-partite linear function is</p>&#13;
<p class="equationc"><em>g</em>(<em>n</em>) = <em>g</em><sub>1</sub>(<em>n</em>) <em>|</em> <em>g</em><sub>2</sub>(<em>n</em>) <em>|</em> <em>g</em><sub>3</sub>(<em>n</em>) <em>|</em> … <em>|</em> <em>g</em><em><sub>k</sub></em>(<em>n</em>)</p>&#13;
<p class="indent">Conway calls <em>k</em>-partite functions with <em>g</em><sub><em>i</em></sub>(<em>n</em>) = <em>a</em><sub><em>i</em></sub><em>n</em> + <em>b</em><sub><em>i</em></sub> <em>Collatzian games</em>. The rule for evaluating <em>g</em>(<em>n</em>) is to calculate <em>g</em><sub>1</sub>(<em>n</em>) followed by <em>g</em><sub>2</sub>(<em>n</em>) and so on until one of them returns an integer. If none of them return an integer, or if the integer returned is some specified value, like 1, stop.</p>&#13;
<p class="indent">This rule sounds familiar. If we set all the <em>b</em><sub><em>i</em></sub>s to 0 and all the <em>a</em><sub><em>i</em></sub>s to rationals, then <em>g</em>(<em>n</em>) is a FRACTRAN program. Therefore, FRACTRAN programs are Collatzian games. However, note that the Collatz conjecture is not a FRACTRAN program, as <em>b</em><sub>2</sub> = 1.</p>&#13;
<p class="indent">Gödel’s incompleteness theorem states that arithmetic contains true statements it cannot prove using the axioms of arithmetic. Alan Turing translated this concept into the <em>halting problem</em>, which states that it is impossible to find an algorithm that will correctly decide in all cases whether a program (a Turing machine) with a finite input will eventually stop or run forever. The term to describe these cases is <em>undecidable</em>. An undecidable problem has been <em>proven</em> to be so; there is no algorithm that will correctly decide in all cases.</p>&#13;
<p class="indent">FRACTRAN programs are undecidable, and FRACTRAN programs are a type of Collatzian game. Therefore, there are Collatzian games that are undecidable, games for which it is impossible to prove that the game ends as desired for all inputs, <em>n</em>. This fact does not solve the question of the Collatz conjecture, as the conjecture applies to a Collatzian game that is not a FRACTRAN program. However, showing there are undecidable Collatzian games is an important result all the same. It may be that the Collatz conjecture is undecidable, too.</p>&#13;
<h4 class="h4" id="lev2sec73"><strong><em>Final Thoughts on FRACTRAN</em></strong></h4>&#13;
<p class="noindent">When first encountered, FRACTRAN might appear to be a cute but useless esolang, much like the original form of ABC from <a href="ch07.xhtml#ch07">Chapter 7</a>. The trick of using Gödel numbering to hold the state of the program makes FRACTRAN more interesting, but still, it’s just another esolang, though now a clever one.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_242"/>The universality of FRACTRAN adds to its intellectual attractiveness. However, the fact that FRACTRAN links Gödel’s incompleteness theorem with Turing’s halting problem and Conway’s Collatzian games is brilliant. FRACTRAN is set apart from the other languages we’ll explore. I hope it causes you to ponder deeper issues related to programming, computation, what can and cannot be known, and what it even means to know that you cannot know.</p>&#13;
<h3 class="h3" id="lev1sec64"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, we explored FRACTRAN, an esolang that at first glance seems like nothing more than a clever game. After implementing the language in both Racket and Python, we tested it and struggled to understand how it worked. Next, we explored multiple examples of FRACTRAN programs to help build our intuition about what coding in FRACTRAN entails. Along the way, we learned about the Collatz conjecture, itself an interesting intellectual exercise.</p>&#13;
<p class="indent">We closed the chapter by discussing the connections between FRACTRAN, Gödel’s incompleteness theorem, Turing’s halting problem, and Collatzian games, all of which provide much food for thought.</p>&#13;
<p class="indent">FRACTRAN forced us to think mathematically. Now, let’s mix things up with Piet, a language that forces us to think visually.</p>&#13;
</div></body></html>