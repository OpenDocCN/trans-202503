- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CRYPTOCURRENCY
    CRYPTOGRAPHY</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">加密货币加密学</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: This chapter wasn’t in the initial edition of this book when it came out in
    fall 2017, a period when cryptocurrency and blockchain were at peak hype. While
    blockchain hasn’t quite lived up to its promises of disrupting several industries,
    it has profoundly influenced cryptographic research and engineering. Blockchain
    applications have brought new exciting problems, attracted fresh talent, and offered
    a novel way to bridge theory and practice.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章并未包含在2017年秋季初版的书中，那时加密货币和区块链正处于 hype 的巅峰期。虽然区块链并未完全实现其颠覆多个行业的承诺，但它已深刻影响了加密学研究和工程领域。区块链应用带来了新的激动人心的挑战，吸引了新的人才，并提供了一种新的方式来弥合理论与实践之间的差距。
- en: Before “crypto” became synonymous with cryptocurrency, cryptographic algorithms
    and protocols largely pertained to standard functionalities such as encryption
    and secure channels. The more arcane protocols were restricted to niche research
    areas and technical articles, typically catering to researchers’ interests and
    presented only in academic conferences. New algorithms were predominantly crafted
    by academic researchers and would see real-world deployment, if ever, after at
    least five years of peer review and analysis and after numerous research papers
    detailing unsuccessful cryptanalysis attempts.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在“加密”成为加密货币的代名词之前，加密算法和协议主要涉及标准功能，如加密和安全通道。那些较为深奥的协议通常局限于小众研究领域和技术文章，通常服务于研究人员的兴趣，并仅在学术会议上呈现。新的算法主要由学术研究人员设计，并且至少在经过五年的同行评审和分析，以及众多未成功破解的加密分析文章之后，才会在现实世界中部署（如果有的话）。
- en: Blockchain turned that process upside down. Much like how the cryptographic
    protocols of Signal and Tor sidestepped the conventional academic route, blockchain
    enthusiasts were less bound by tradition. Groundbreaking protocols often debuted
    in blog posts or informal white papers, with implementation following shortly
    after. Occasionally, they’d forgo written specifications altogether, letting the
    code speak for itself. Only after widespread adoption would academia take notice.
    The most notable case is the Bitcoin protocol, which didn’t undergo formal peer
    review before being deployed.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链颠覆了这一过程。就像Signal和Tor的加密协议避开了传统的学术途径一样，区块链爱好者在某种程度上也不受传统束缚。突破性的协议通常会在博客文章或非正式的白皮书中首次亮相，随后很快进行实现。有时，他们会完全放弃书面规范，让代码本身发声。只有在广泛采用后，学术界才会注意到它们。最著名的案例是比特币协议，在部署之前并没有经过正式的同行评审。
- en: Many seasoned researchers identified novel challenges within the blockchain
    domain, often collaborating directly with blockchain entities. They developed
    complex protocols that not only pushed boundaries and garnered peer recognition
    but also saw rapid real-world implementation, impacting thousands, if not millions,
    of systems. Prime instances include efficient ECDSA threshold signature schemes
    and zero-knowledge proof systems. In some scenarios, existing protocols with little
    practical use found impactful use cases, such as Boneh–Lynn–Shacham (BLS) signatures.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 许多资深研究人员在区块链领域识别出了新颖的挑战，通常与区块链实体直接合作。他们开发了复杂的协议，这些协议不仅突破了边界并获得同行认可，而且在现实世界中得到了迅速实施，影响了成千上万，甚至百万个系统。重要的例子包括高效的ECDSA门限签名方案和零知识证明系统。在某些情况下，现有的几乎没有实际应用的协议找到了具有重大影响的应用场景，例如Boneh–Lynn–Shacham（BLS）签名。
- en: This chapter provides an overview of these cryptographic algorithms and protocols—those
    tailored for blockchain and those that thrived due to it. I won’t delve into defining
    blockchain or its workings, as there are myriad online resources. Instead, I emphasize
    the cryptographic schemes underpinning blockchains, which hold significance irrespective
    of the blockchain use cases. Even if you remain skeptical of the blockchain phenomenon,
    I trust you’ll find this chapter enlightening.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了这些加密算法和协议的概述——那些专为区块链量身定制的协议以及由于区块链而蓬勃发展的协议。我不会深入定义区块链或其工作原理，因为网络上有大量资源可以参考。相反，我强调的是支撑区块链的加密方案，这些方案在任何区块链应用场景中都有重要意义。即使你对区块链现象仍持怀疑态度，我相信你会发现本章内容具有启发性。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Hashing Applications</samp>
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">哈希应用</samp>
- en: 'Hash functions, the Swiss Army knives of cryptography, serve numerous applications
    in blockchain systems, including:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数，密码学的瑞士军刀，在区块链系统中担任着多种应用，包括：
- en: '**Hashing a transaction’s data**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希交易的数据**'
- en: Hash functions can produce a digest signed by the transaction’s issuer, typically
    with ECDSA-secp256k1 or Ed25519\. Verifying the signature ensures that the owner
    of a given address approved of the information hashed, leading to including the
    transaction in the chain’s ledger.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数可以生成由交易发行者签名的摘要，通常使用ECDSA-secp256k1或Ed25519。验证签名确保给定地址的所有者批准了被哈希的信息，从而将交易包含在链的分类帐中。
- en: In the blockchain Ethereum, a transaction’s hash serves as its unique identifier;
    for example, you can enter a hash in the search field of *[https://<wbr>etherscan<wbr>.io](https://etherscan.io)*
    to retrieve the associated transaction. Ethereum transaction hashes use Keccak-256—which
    is similar but not identical to SHA3-256—and process-encoded data. This data includes
    the recipient’s address, the amount of ether (ticker ETH) sent, any smart contract
    input, the gas price and limit, a nonce (increasing for each new transaction),
    and a signature of the transaction.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊区块链中，交易的哈希作为其唯一标识符；例如，您可以在*[https://<wbr>etherscan<wbr>.io](https://etherscan.io)*的搜索字段中输入哈希来检索相关交易。以太坊交易哈希使用Keccak-256——这与SHA3-256类似但不完全相同——并处理编码数据。该数据包括收款人地址、发送的以太（代号ETH）数量、任何智能合约输入、燃气价格和限制、一个随机数（每个新交易递增）以及交易的签名。
- en: '**Hashing the content of a block**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希块的内容**'
- en: Hash functions can include the digest in the subsequent block to “chain” the
    blocks. For example, each Bitcoin block has a *block header* that includes the
    previous block’s hash, a tree hash of the recorded transactions, and some metadata
    (version, timestamp, nonce, and so on). Bitcoin computes the previous block’s
    hash by hashing the header of the previous block using double SHA-256, or **SHA-256**(**SHA-256**(block
    header)). This unorthodox construction eliminates the risk of length extension
    attacks and adds a safety net in case SHA-256 was found to be insecure—which is
    unlikely.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数可以在后续块中包含摘要以“链接”这些块。例如，每个比特币块都有一个*块头*，其中包括上一个块的哈希，记录的交易的树哈希，以及一些元数据（版本、时间戳、随机数等）。比特币通过对上一个块的头部进行双SHA-256哈希或**SHA-256**（**SHA-256**（块头））来计算上一个块的哈希。这种非正统的构建消除了长度扩展攻击的风险，并在SHA-256被发现不安全时提供了安全保障——尽管这种情况不太可能发生。
- en: Aside from these basic use cases, hash functions are the main building block
    in key components of blockchain systems.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些基本用例外，哈希函数是区块链系统关键组件中的主要构建块。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Merkle Trees</samp>
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Merkle树</samp>
- en: '*Merkle trees* are a type of hash tree, which is a data structure computing
    a root value from leaf values according to a tree pattern. In hash trees, the
    parent node is computed by hashing the child nodes. Merkle trees are, for example,
    used to create a Bitcoin block’s header. They’re named after computer scientist
    Ralph Merkle, whose 1979 cryptographic scheme construction used binary hash trees.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*Merkle树*是一种哈希树，它是一种根据树模式从叶子值计算根值的数据结构。在哈希树中，父节点通过对子节点进行哈希计算而生成。例如，Merkle树用于创建比特币块的头部。它们以计算机科学家拉尔夫·默克尔命名，其1979年的加密方案构建使用了二进制哈希树。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Tree Hashing Computation</samp>
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">树哈希计算</samp>
- en: A Merkle tree takes as input values that constitute its *leaves*—that is, the
    values from which the *root* (the output) is computed. You generally represent
    data structure trees with their root at the top and leaves at the bottom.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Merkle树将构成其*叶子*的值作为输入，即计算其*根*（输出）的值。通常，您将数据结构树的根表示为顶部，叶子表示为底部。
- en: For example, [Figure 15-1](chapter15.xhtml#fig15-1) shows a Merkle tree hashing
    four values (*A*, *B*, *C*, *D*).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[图15-1](chapter15.xhtml#fig15-1)展示了一个Merkle树对四个值（*A*、*B*、*C*、*D*）进行哈希。
- en: '![](../images/fig15-1.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig15-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-1: A hash tree, where
    the leaves are the input and the root is the output</samp>'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图15-1：一个哈希树，其中叶子是输入，根是输出</samp>
- en: 'The tree hashing then works as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，树哈希工作如下：
- en: Hashing each of the four values to obtain the four hashes **H**(*A*), **H**(*B*),
    **H**(*C*), and **H**(*D*).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对四个值中的每一个进行哈希以获得四个哈希**H**（*A*）、**H**（*B*）、**H**（*C*）和**H**（*D*）。
- en: Hashing together each consecutive pair of hashes to obtain **H**(**H**(*A*)
    || **H**(*B*)) and **H**(**H**(*C*) || **H**(*D*)). Here you concatenate the hash
    values (as the || symbol denotes).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每一对连续的哈希值组合起来得到**H**(**H**(*A*) || **H**(*B*))和**H**(**H**(*C*) || **H**(*D*)）。这里你将哈希值进行连接（如符号||所示）。
- en: 'Hashing the two hashes together to obtain the root of the tree, which is the
    final output of the tree hashing: **H**(**H**(**H**(*A*) || **H**(*B*)) || **H**(**H**(*C*)
    || **H**(*D*))).'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将两个哈希值组合在一起，得到树的根节点，这是树哈希的最终输出：**H**(**H**(**H**(*A*) || **H**(*B*)) || **H**(**H**(*C*)
    || **H**(*D*))).
- en: If you omit the initial hashing of the input values—which is necessary only
    if the values aren’t already the size of the hash—you go from four values to one
    with a tree of two layers, or of *height* two. Note that while the input data
    may be a different size, all hash values are the same size. Generally, a tree
    of *n* layers has 2*^n* leaves, allowing you to process up to 2*^n* values by
    computing 2*^n* – 1 hashes from the (hashed) leaves.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略了输入值的初始哈希——仅在输入值不是哈希大小时才需要——你将从四个值开始，最终得到一个具有两层树结构的单一值，或者说*高度*为二。注意，虽然输入数据可能具有不同的大小，但所有哈希值的大小都是相同的。通常，一个*高度*为*n*的树具有2*^n*个叶子，允许你通过计算2*^n*
    - 1个哈希值（从哈希后的叶子开始）来处理最多2*^n*个值。
- en: If the number of input values isn’t exactly 2*^n* for some integer *n*, a common
    technique is to add dummy values (for example, set to zero or to the last value
    in the list); the padding rule should, however, be carefully chosen to avoid trivial
    collisions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入值的数量不是2*^n*（对于某个整数*n*），一种常见的技术是添加虚拟值（例如，将其设为零或列表中的最后一个值）；但是，填充规则应该仔细选择，以避免出现简单的冲突。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Merkle Proofs</samp>
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Merkle证明</samp>
- en: A Merkle tree’s structure can be leveraged to prove that a given value belongs
    to the list of 2*^n* values hashed without recomputing the whole tree (which takes
    on the order of 2*^n* operations) but only in time proportional to the *height*
    of the tree—that is, its number of layers *n*. Depending on the context, such
    proofs are called a *membership path*, an *inclusion proof*, or a *Merkle proof*.
    This is a Merkle tree’s killer feature, which general-purpose hash functions don’t
    offer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Merkle树的结构可以用来证明某个给定的值属于被哈希的2*^n*个值的列表，而无需重新计算整个树（这将涉及2*^n*次操作），而只需要与树的*高度*（即其层数*n*）成比例的时间。根据具体情况，这种证明被称为*成员路径*、*包含证明*或*Merkle证明*。这是Merkle树的一个杀手级特性，而通用哈希函数则不提供这一功能。
- en: '[Figure 15-2](chapter15.xhtml#fig15-2) shows how this works. The shaded cells
    are the values sufficient to prove that *V*[1] is one of the values hashed to
    obtain the root.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[图15-2](chapter15.xhtml#fig15-2)展示了这一过程的工作原理。阴影单元格是足够证明*V*[1]是被哈希得到根节点的值之一。'
- en: '![](../images/fig15-2.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig15-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-2: A Merkle tree,
    wherein the shaded cells constitute the membership path of</samp> <samp class="SANS_Futura_Std_Book_11">A</samp>'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图15-2：一个Merkle树，其中阴影单元格构成了</samp>
    <samp class="SANS_Futura_Std_Book_11">A</samp>的成员路径
- en: 'Say you want to prove that *A* was one of the values hashed, without revealing
    *B*, *C*, or *D*. First, hash *A* to obtain the actual leaf of the hash tree.
    Then, assume that you’ve received *A*’s membership path, which consists of the
    other shaded values, **H**(*B*) and **H**(**H**(*C*) || **H**(*D*)). To verify
    that *A* belongs to the tree, compute the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想证明*A*是被哈希的值之一，而不暴露*B*、*C*或*D*。首先，对*A*进行哈希处理，得到哈希树的实际叶子节点。然后，假设你已经收到了*A*的成员路径，该路径包含其他阴影值，**H**(*B*)和**H**(**H**(*C*)
    || **H**(*D*)）。为了验证*A*是否属于这棵树，计算以下内容：
- en: '*X* = **H**(**H**(*A*) || **H**(*B*)), since you know *A* and **H**(*B*)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*X* = **H**(**H**(*A*) || **H**(*B*))，因为你知道*A*和**H**(*B*)'
- en: '**H(H**(*X*) || **H**(**H**(*C*) || **H**(*D*))), since you know **H**(**H**(*C*)
    || **H**(*D*))'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**H(H**(*X*) || **H**(**H**(*C*) || **H**(*D*)))，因为你知道**H**(**H**(*C*) || **H**(*D*))'
- en: It took only two hashes of sibling values to prove *A*’s inclusion, or as many
    hashes as the height of the tree. A tree with eight leaves has a height of three;
    thus, a membership path verification needs three sibling hashes. With 16 leaves,
    you need four sibling hashes, and so on, with *n* sibling hashes for a tree with
    2*^n* leaves.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过两次哈希操作就能证明*A*的包含性，或者根据树的高度，进行的哈希操作次数即为树的高度。具有八个叶子的树的高度为三；因此，验证成员路径需要三个兄弟哈希。对于16个叶子，您需要四个兄弟哈希，以此类推，对于具有2*^n*个叶子的树，需要*n*个兄弟哈希。
- en: Blockchain applications often use Merkle trees to hash transactions into a single
    *Merkle root*, such as that included in a Bitcoin block header. A typical Bitcoin
    block registers about 2,000 transactions, which requires a tree of height 11 (2^(11)
    = 2,048). In this case, it takes 2,048 – 1 = 2,047 sibling hashes to compute the
    root from the leaves, where each leaf is the hash of a transaction’s data. Each
    hash computes a double SHA-256, so in the case of 2,048 transactions, it takes
    2,047 + 2,048 = 4,095 double SHA-256s, or 8,190 calls to SHA-256.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链应用通常使用梅克尔树将交易哈希成一个单一的*梅克尔根*，例如比特币区块头中包含的那个。一个典型的比特币区块注册大约2,000个交易，这需要一个高度为11的树（2^(11)
    = 2,048）。在这种情况下，从叶子节点计算根节点需要2,048 - 1 = 2,047个兄弟哈希，每个叶子节点是交易数据的哈希。每个哈希计算一次双重SHA-256，因此，在2,048个交易的情况下，需要2,047
    + 2,048 = 4,095次双重SHA-256计算，或者8,190次SHA-256调用。
- en: 'Ethereum uses a slightly more complex tree-based data structure, combining
    Merkle trees with *Patricia tries* (this is not a typo; “trie” comes from “retrieval”),
    a tree-like structure that stores key-value pairs. This structure serves Ethereum’s
    state-based model, which significantly differs from Bitcoin’s UTXO (unspent transaction
    output) model, for which simpler Merkle trees are sufficient.  #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Proof
    of Work</samp>'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '以太坊使用一种稍微复杂的基于树的数据结构，将梅克尔树与*帕特里夏树*（这不是打字错误；“trie”来自“检索”）结合起来，帕特里夏树是一种存储键值对的树状结构。该结构服务于以太坊的状态模型，这与比特币的UTXO（未花费交易输出）模型有显著不同，后者对于简单的梅克尔树就足够了。
    #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">工作量证明</samp>'
- en: Proof of work (PoW) is arguably the most critical component of a blockchain’s
    consensus protocol—for those based on PoW rather than proof of stake (PoS) or
    other protocols.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 工作量证明（PoW）可以说是区块链共识协议中最关键的组成部分——对于那些基于PoW而非权益证明（PoS）或其他协议的区块链。
- en: A *PoW* is essentially a hash function that takes some fixed inputs and variable
    inputs and whose result must match a certain pattern to be valid. Parties that
    aim to *solve* a PoW repeatedly compute the hash with different values of the
    variable inputs until the result satisfies some constraint.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*PoW*本质上是一个哈希函数，它接受一些固定输入和可变输入，并且其结果必须匹配某种模式才能有效。旨在*解决* PoW的各方会重复计算哈希，使用不同的可变输入值，直到结果满足某种约束条件。'
- en: For example, in Bitcoin and some other PoW-based blockchains, the constraint
    is that the hash value when seen as a 256-bit number must be less than a given
    number. This can also be seen as the hash value having a given number of leading
    zeros, when seeing the hash as the big-endian encoding of a 256-bit number.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在比特币和一些其他基于PoW的区块链中，约束条件是将哈希值视为一个256位数字时，该值必须小于给定的数字。也可以将其视为哈希值具有一定数量的前导零，前提是将哈希值视为一个256位数字的大端编码。
- en: For example, in 2022 the highest Bitcoin difficulty value (as reported on *[https://<wbr>btc<wbr>.com<wbr>/stats<wbr>/diff](https://btc.com/stats/diff)*)
    was 34,244,331,613,176, or approximately 2^(45). You multiply this by 2^(32) to
    find the actual value that the hash must be less than, 2^(77). For each block,
    all the network participants (*miners*) jointly compute in the order of 2^(77)
    double SHA-256 computations to find a solution to the PoW. Such a solution consists
    of a nonce (the variable part of the PoW hash’s input) that yields a hash value
    less than 2^(77). The fixed part of the PoW hash’s input consists of the block
    header values (version, previous block hash, Merkle tree root, timestamp, and
    difficulty target value).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在2022年，比特币的最高难度值（如* [https://<wbr>btc<wbr>.com<wbr>/stats<wbr>/diff](https://btc.com/stats/diff)
    *上报道）是34,244,331,613,176，约为2^(45)。你将其乘以2^(32)，得到哈希值必须小于的实际值，即2^(77)。对于每个区块，所有网络参与者（*矿工*）共同计算大约2^(77)次双重SHA-256计算，以找到PoW的解决方案。这样的解决方案包括一个nonce（PoW哈希输入的可变部分），该nonce使哈希值小于2^(77)。PoW哈希输入的固定部分包括区块头的值（版本、前一个区块哈希、梅克尔树根、时间戳和难度目标值）。
- en: Without a PoW “slowing down” the production of blocks in a blockchain, new valid
    blocks could be produced instantaneously, meaning that histories of transactions
    could be produced and re-created at will. It would be impossible to achieve *finality*
    (that is, the assurance that a block, and thus a set of transactions, cannot be
    reverted or changed once accepted by the network). In particular, it would be
    impossible to protect the network against *double spending*, or spending the same
    coins in two distinct transactions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有PoW“减缓”区块链中区块生产的速度，新有效区块可能会瞬间生成，这意味着交易历史可以随意创建和重建。这样就不可能实现*最终性*（即，一旦区块被网络接受，不能被撤回或更改，交易也无法被修改）。特别是，无法保护网络免受*双重支付*攻击，即在两笔不同交易中花费相同的币。
- en: 'Not all PoW schemes are as simple as Bitcoin’s, which uses a general-purpose
    hash function (SHA-256). Several PoWs attempted to make its computation on dedicated
    hardware less efficient compared to general-purpose CPUs to discourage the centralization
    of mining by organizations investing in the development of optimized hardware
    miner technology—as opposed to off-the-shelf servers and computers that anyone
    can use. Implemented tricks include the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有PoW方案都像比特币那样简单，它使用了一种通用哈希函数（SHA-256）。一些PoW尝试使其在专用硬件上的计算效率低于通用CPU，从而阻止由投资于优化硬件矿机技术的组织垄断挖矿——与任何人都能使用的现成服务器和计算机不同。实施的技巧包括以下几种：
- en: '**Memory hardness **You can force the PoW to use a large amount of memory,
    typically by generating a huge table and accessing at unpredictable addresses.
    For example, Ethereum’s PoW used the Ethash algorithm, which required approximately
    4GB of memory. (In September 2022, Ethereum abandoned Ethash and switched from
    a PoW to a proof-of-stake mechanism.)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存难度** 你可以强迫工作量证明（PoW）使用大量内存，通常通过生成一个巨大的表格并访问不可预测的地址。例如，以太坊的PoW使用了Ethash算法，需要大约4GB的内存。（在2022年9月，以太坊放弃了Ethash，并从PoW机制切换为权益证明机制。）'
- en: '**Virtual machines **As some malware do, you can create a custom set of computer
    instructions that would be translated to standard instructions by a virtual machine
    application, while also potentially using a large amount of memory to compute
    a PoW’s solution. This is the approach of RandomX, a PoW algorithm adopted by
    the Monero blockchain.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟机** 就像一些恶意软件那样，你可以创建一组自定义的计算机指令，这些指令将由虚拟机应用程序转换为标准指令，同时还可能使用大量内存来计算PoW的解决方案。这是Monero区块链采用的PoW算法——RandomX的做法。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Hierarchical Key
    Derivation</samp>
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">分层密钥派生</samp>
- en: 'Blockchain users generally want to manage multiple accounts, such that each
    account consists of a key pair where:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链用户通常希望管理多个账户，每个账户由一对密钥组成，其中：
- en: The *private key* must be secret, as it’s the signing key required to sign transactions
    and transfer funds from the account.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*私钥*必须保密，因为它是签名密钥，用于签署交易并从账户中转移资金。'
- en: The *public key* must be public, as it’s used to verify signatures of transactions.
    It’s also the value from which the account’s address is derived. For example,
    Bitcoin derives addresses from a public key using a combination of SHA-256 and
    RIPEMD-160 hashing. Note that in some blockchains, such as Bitcoin, the public
    key is not public until the account issues a transaction.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*公钥*必须公开，因为它用于验证交易的签名。它也是从中衍生出账户地址的值。例如，比特币通过SHA-256和RIPEMD-160哈希的组合从公钥衍生出地址。需要注意的是，在一些区块链中，如比特币，公钥在账户发起交易之前并不公开。'
- en: To reliably manage all these keys, blockchain developers defined *hierarchical
    deterministic wallets (HD wallets)*, which make key management less cumbersome
    and risky than having to generate and back up a fresh random key for each new
    account.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可靠地管理所有这些密钥，区块链开发人员定义了*分层确定性钱包（HD钱包）*，这种方式比为每个新账户生成并备份一个随机密钥更加简便且减少风险。
- en: With HD wallets, you generate and store one secret, the *seed* (also called
    the *master key* or *entropy*). This seed is the only randomly generated value
    and the only one providing entropy, or uncertainty, and therefore secrecy to the
    private signing keys derived from it. Wallet software applications often encode
    the seed as a *seed phrase*, or *mnemonic*, a sequence of 12 to 24 words that
    makes it easier to save and memorize.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HD 钱包时，你生成并存储一个秘密，即*种子*（也称为*主密钥*或*熵*）。该种子是唯一随机生成的值，是唯一提供熵或不确定性，从而保证通过它推导出来的私有签名密钥的保密性。因此，钱包软件应用通常将种子编码为*种子短语*或*助记符*，这是一组由
    12 到 24 个单词组成的序列，便于保存和记忆。
- en: 'Let’s review how this key derivation works using the HMAC-SHA-512 pseudorandom
    function (the HMAC construction instantiated with SHA-512): from a seed *S* of
    128 or 256 bits, compute HMAC-SHA-512 with the seed as a key input, and as a message
    input an identifier of the underlying elliptic curve (a string that can be “Bitcoin
    seed,” “Nist256p1 seed,” or “ed25519 seed”). The first 256 bits of the result
    are the master key, *k*, and the last 256 bits are the master chain code, *c*,
    a value used to derive more keys.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下如何使用 HMAC-SHA-512 伪随机函数（通过 SHA-512 实现的 HMAC 构造）来执行此密钥推导：从一个 128 或 256
    位的种子 *S* 开始，使用该种子作为密钥输入计算 HMAC-SHA-512，将底层椭圆曲线的标识符作为消息输入（该字符串可以是“比特币种子”，“Nist256p1
    种子”或“ed25519 种子”）。结果的前 256 位是主密钥 *k*，后 256 位是主链码 *c*，该值用于推导更多的密钥。
- en: 'You can derive a *child private key* from *k* and *c* as follows, given an
    identifier *i* (a number at most 2^(31)): compute HMAC-SHA-512 with the chain
    code *c* as a key, and a message including *k* and *i*. The 512-bit result is
    parsed as a 256-bit value *L* followed by a 256-bit chain code *R*. In simplified
    notation, *L* || *R* = HMAC-SHA-512(*c*, *k* || *i*). You then set the child private
    key to *k* + *L*, and its chain code is *R*.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 *k* 和 *c* 推导一个*子私钥*，方法如下：给定一个标识符 *i*（最大为 2^(31) 的数字），使用链码 *c* 作为密钥计算 HMAC-SHA-512，并将
    *k* 和 *i* 作为消息输入。512 位的结果被解析为 256 位的值 *L*，后跟 256 位的链码 *R*。简化表示为 *L* || *R* = HMAC-SHA-512(*c*,
    *k* || *i*)。然后将子私钥设置为 *k* + *L*，其链码为 *R*。
- en: 'You can in turn derive keys from the obtained key and chain code to establish
    a key *hierarchy*. For example, from the key with index 0, you derive all your
    keys for Bitcoin, and from the key with index 60, you derive all your keys for
    Ethereum. Conventions associating a number to each blockchain network are standardized
    as part of the document “SLIP-0044: Registered Coin Types for BIP-0044.”'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以依此推导密钥，并通过获得的密钥和链码建立密钥的*层次结构*。例如，从标识符为 0 的密钥推导出所有比特币的密钥，从标识符为 60 的密钥推导出所有以太坊的密钥。将一个数字与每个区块链网络关联的约定已在文档“SLIP-0044:
    BIP-0044 注册硬币类型”中标准化。'
- en: If you first derive a child key with identifier 0 and next derive a key with
    identifier (say) 29 from this key and its chain code, then the key’s *derivation
    path* is 0/29\. You’ll have done two calls of HMAC-SHA-512, yielding, respectively,
    *L*[1] and *L*[2] as their first 256 bits, and the final private key is *k* +
    *L*[1] + *L*[2]. Therefore, you can see all keys derived from a given master key
    *k* as *k* plus the sum of values HMAC-SHA-512 returns. This derivation is called
    *hardened* because you need both the private key *k* and the chain code *c* of
    the parent key.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你首先通过标识符 0 推导一个子密钥，然后再通过该密钥及其链码推导一个标识符为（假设）29的密钥，那么该密钥的*推导路径*为 0/29。你将执行两次
    HMAC-SHA-512 调用，分别生成*L*[1]和*L*[2]作为它们的前 256 位，最终的私钥为 *k* + *L*[1] + *L*[2]。因此，你可以将所有由给定主密钥
    *k* 推导的密钥视为 *k* 加上 HMAC-SHA-512 返回的值的总和。此推导称为*硬化*，因为你需要父密钥的私钥 *k* 和链码 *c*。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*For the* nonhardened *version, use the public key instead of the private key,
    which allows you to determine the public key of a child key from its parent public
    key. For more details, see the initial Bitcoin standard document “BIP32: Hierarchical
    Deterministic Wallets” and its generalized standard document “SLIP-0010: Universal
    Private Key Derivation from Master Private Key.”*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于* 非硬化 *版本，请使用公钥而不是私钥，这样可以从父公钥确定子公钥。详细信息，请参阅初始比特币标准文档“BIP32: 分层确定性钱包”和其通用标准文档“SLIP-0010:
    从主私钥推导通用私钥”。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Algebraic Hash Functions</samp>
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代数哈希函数</samp>
- en: Hash functions like SHA-3 and BLAKE3 operate on *bytes*, or on *words* of 4
    or 8 bytes, where a byte is a chunk of 8 bits. The input data is a sequence of
    bytes, where each byte can take any of the 256 possible values from 0x00 to 0xff
    (255), and likewise the output data is a sequence of arbitrary bytes. This works
    well when using data efficiently converted into a sequence of bytes and when operations
    on bytes or words are efficient (such as XOR, word bit shift, and integer addition).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数如 SHA-3 和 BLAKE3 作用于*字节*，或者 4 字节或 8 字节的*字*，其中一个字节是 8 位的一个数据单元。输入数据是一系列字节，每个字节可以取从
    0x00 到 0xff（255）之间的 256 个可能值，输出数据同样是任意字节的序列。当数据有效地转化为字节序列时，并且字节或字的操作（如 XOR、字移位和整数加法）高效时，这种方式效果很好。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Mathematical Computer</samp>
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">数学计算机</samp>
- en: Say you have a computer that works with numbers only in a given range, such
    as numbers modulo 13\. The XOR operation won’t do well with such numbers, because
    not all 4-bit numbers are less than 13; for example, a XOR between 10 and 4 will
    give you 14, which is out of range. You might reduce it modulo 13 to obtain 1,
    but then 10 XOR 4 yields the same result as 10 XOR 11, a problem you don’t have
    when working with bytes. This tends to significantly reduce the security of the
    hash function—through collisions, for example.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一台计算机，它只能处理特定范围内的数字，比如模 13 的数字。XOR 操作对这些数字的效果不好，因为并非所有 4 位数字都小于 13；例如，10
    和 4 的 XOR 运算结果是 14，这超出了范围。你可能会将结果按模 13 进行缩减，得到 1，但这样一来，10 XOR 4 和 10 XOR 11 会产生相同的结果，而在处理字节时不会出现这种问题。这通常会显著降低哈希函数的安全性——例如，通过碰撞。
- en: 'Even worse, your computer knows only operations modulo 13: addition, subtraction,
    multiplication, and division. It doesn’t have a built-in bitwise XOR instruction,
    so it simulates it with its modulo 13 arithmetic instructions, which isn’t straightforward
    or computationally efficient. I’ll leave the details of this simulation as an
    exercise.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟的是，你的计算机只能进行模 13 的运算：加法、减法、乘法和除法。它没有内建的按位 XOR 指令，所以只能用模 13 的算术运算来模拟，这既不直接也不高效。我将把这个模拟过程的细节留给你作为练习。
- en: Your task is to create a hash function that works only (or mostly) with arithmetic
    operations for the given range of numbers and doesn’t use bitwise operations including
    XOR, OR, AND, or bit shifts.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是创建一个只使用（或主要使用）算术运算的哈希函数，适用于给定数字范围，并且不使用按位操作，包括 XOR、OR、AND 或位移运算。
- en: You need this kind of function to efficiently run certain advanced cryptographic
    protocols—namely, multiparty computation (MPC) and zero-knowledge proofs, which
    you’ll see later in this chapter. Such protocols often operate in the realm of
    mathematical structures such as finite fields (for example, sets of integers modulo
    a prime number) and sometimes have to “convert” a program into mathematical equations.
    In principle, you can convert any program into equations. But when the program
    isn’t optimized for the underlying math structure, the equations get very large
    and slow to compute. *Algebraic hash functions* aim to address this issue by designing
    hash functions that are both secure and easy to implement with only arithmetic
    operations in a finite field.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要这种类型的函数来高效地运行某些高级加密协议——即多方计算（MPC）和零知识证明，后面你将看到这一章的内容。此类协议通常在数学结构的范围内操作，比如有限域（例如，模素数的整数集合），有时还需要将程序“转化”为数学方程。从原则上讲，任何程序都可以转化为方程。但当程序没有针对底层数学结构进行优化时，方程会变得非常庞大且计算缓慢。*代数哈希函数*旨在通过设计既安全又易于仅使用有限域中的算术运算实现的哈希函数来解决这个问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Design Principles</samp>
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">设计原则</samp>
- en: Let’s consider the design principles of *Poseidon*, a hash function designed
    in 2019 for zero-knowledge proof systems and rapidly adopted by many blockchain
    systems. Such proofs sometimes have to express a hash function as a circuit of
    arithmetic operations over a large finite field, such as those of integers modulo
    a 255-bit prime number. In that case, Poseidon proved orders of magnitude more
    efficient than general-purpose hash functions like SHA-256.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来考虑 *Poseidon* 的设计原则，这是一个在 2019 年为零知识证明系统设计的哈希函数，并迅速被许多区块链系统采纳。这类证明有时需要将哈希函数表示为一个关于大有限域的算术运算电路，比如模
    255 位素数的整数集合。在这种情况下，Poseidon 比像 SHA-256 这样的通用哈希函数高效几个数量级。
- en: Poseidon uses the sponge hash function construction (see [Chapter 7](chapter7.xhtml)),
    so it needs to construct a *permutation*, an invertible transformation with input
    and output of the same size. It applies this permutation to a state that is a
    vector of finite field elements. In the relevant applications, such a finite field
    usually consists of numbers modulo a prime, which may be as small as 31 bits and
    as large as 381 bits, depending on the application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Poseidon 使用海绵哈希函数构造（参见 [第 7 章](chapter7.xhtml)），因此需要构建一个 *置换*，这是一种输入输出大小相同的可逆变换。它将这个置换应用于一个有限域元素的向量状态。在相关应用中，这样的有限域通常由模素数的数字组成，大小可能从
    31 位小到 381 位不等，具体取决于应用。
- en: Then, like most hash functions, the permutation iterates a series of rounds,
    so it needs to design a *round function*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，像大多数哈希函数一样，置换会迭代一系列轮次，因此需要设计一个 *轮次函数*。
- en: 'Finally, Poseidon breaks down its permutation into three layers, with three
    different purposes, reminiscent of AES’s rounds:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Poseidon 将其置换分解为三个层，具有三个不同的目的，类似于 AES 的轮次：
- en: A *unicity* layer, *AddRoundConstants*, which Poseidon notes as *ARC*() in the
    documentation. This adds constant values to the state’s elements, such that the
    constants are different for each round. Making each round unique prevents attacks
    including the slide attack. To avoid defining and storing many constants, Poseidon
    generates constants from a deterministic random bit generator initialized with
    an encoding of the Poseidon instance characteristics (number of rounds, finite
    field, S-box type, and so on).
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *唯一性* 层，*AddRoundConstants*，在 Poseidon 文档中标记为 *ARC*()。这个层向状态的元素添加常数值，使得每一轮的常数都不同。使每一轮具有唯一性可以防止包括滑动攻击在内的攻击。为了避免定义和存储许多常数，Poseidon
    使用一个确定性随机位生成器来生成常数，该生成器初始化时使用 Poseidon 实例特征（如轮次数量、有限域、S-box 类型等）的编码。
- en: A *nonlinear* layer or *S-box layer*, *SubWords*, which Poseidon’s documentation
    notes as *S*. This layer adds *confusion*, the property that the input and output
    values of the function are related by high-degree algebraic equations—and thus
    are as far as possible from linear and low-degree equations, which differential
    cryptanalysis can exploit. S-box transforms each element of its state independently
    of the others, typically mapping a field element *x* to *x*³ or *x*⁵. The exponent
    is kept relatively low to be efficiently computed.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *非线性* 层或 *S-box 层*，*SubWords*，在 Poseidon 文档中标记为 *S*。这个层引入了 *混淆*，即输入和输出值之间通过高阶代数方程关联的特性——因此它们尽可能远离线性和低阶方程，后者是差分密码分析可以利用的。S-box
    会独立地转换其状态的每个元素，通常将域元素 *x* 映射到 *x*³ 或 *x*⁵。指数保持相对较低，以便高效计算。
- en: A *linear* layer, *MixLayer*, which Poseidon notes as *M*() in the documentation.
    MixLayer brings *diffusion*, or the propagation of differences in the initial
    state across all elements. For example, if the state consists of the four-element
    vector (*x*[1], *x*[2], *x*[3], *x*[4]), then *M*() replaces each element with
    a linear combination of all elements. It might replace *x*[1] with the result
    of 2*x*[1] + 10*x*[2] + *x*[3] + 3*x*[4]. Such a transformation corresponds to
    a multiplication of a vector by a matrix. Poseidon’s matrices must satisfy certain
    security properties and should be designed for efficient implementation.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *线性* 层，*MixLayer*，在 Poseidon 文档中标记为 *M*()。MixLayer 引入了 *扩散*，即初始状态中各元素之间差异的传播。例如，如果状态由四元素向量（*x*[1],
    *x*[2], *x*[3], *x*[4]）组成，则 *M*() 会将每个元素替换为所有元素的线性组合。它可能会用 2*x*[1] + 10*x*[2]
    + *x*[3] + 3*x*[4] 的结果替换 *x*[1]。这样的变换对应于将一个向量乘以一个矩阵。Poseidon 的矩阵必须满足某些安全性要求，并应为高效实现而设计。
- en: 'A *full round* of Poseidon applies the three layers in this order: *ARC*(),
    *S* to each element, and *M*(). A *partial round* applies *S* to only one element
    and may use a different matrix in *M*(). A Poseidon *instance* then iterates full
    rounds, partial rounds, and full rounds—the number of which depends on the instance,
    number of elements, finite field, and target security level.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *完整轮次* 的 Poseidon 按以下顺序应用三个层：*ARC*()，*S* 到每个元素，再应用 *M*()。一个 *部分轮次* 只对一个元素应用
    *S*，并且可能在 *M*() 中使用不同的矩阵。一个 Poseidon *实例* 会反复执行完整轮次、部分轮次和完整轮次——这些轮次的数量取决于实例、元素数量、有限域和目标安全等级。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*For more details on Poseidon, see* [https://<wbr>www<wbr>.poseidon<wbr>-hash<wbr>.info](https://www.poseidon-hash.info)
    *as well as the initial Poseidon paper (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2019<wbr>/458<wbr>.pdf](https://eprint.iacr.org/2019/458.pdf)*)
    and the improved design Poseidon2 paper (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2023<wbr>/323<wbr>.pdf](https://eprint.iacr.org/2023/323.pdf)*).*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*欲了解更多关于Poseidon的详细信息，请参见* [https://<wbr>www<wbr>.poseidon<wbr>-hash<wbr>.info](https://www.poseidon-hash.info)
    *以及初始的Poseidon论文(*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2019<wbr>/458<wbr>.pdf](https://eprint.iacr.org/2019/458.pdf)*)和改进版Poseidon2论文(*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2023<wbr>/323<wbr>.pdf](https://eprint.iacr.org/2023/323.pdf)*)。*'
- en: Poseidon is one of many algebraic hash functions created to address practical
    use cases. Other designs include MiMC, Monolith, Rescue-Prime, and Tip5.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Poseidon是为了解决实际应用问题而创建的众多代数哈希函数之一。其他设计包括MiMC、Monolith、Rescue-Prime和Tip5。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Things Can Go
    Wrong</samp>
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">事情是如何出错的</samp>
- en: Let’s look at some security failures that involve hash functions and their applications
    in the blockchain world.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下在区块链世界中涉及哈希函数及其应用的一些安全失败案例。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Broken Custom Hash</samp>
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">破损的自定义哈希</samp>
- en: The 2017 blockchain project Iota was quite weird. It claimed to use an architecture
    different from the sequential chain of blocks of most blockchains, closer to direct
    acyclic graph (DAG), which was much less secure. It also encoded data not in bits
    but in *trits*, units taking three values instead of two, supposedly to make computations
    more efficient on processors that don’t exist.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年的区块链项目Iota相当奇怪。它声称采用不同于大多数区块链顺序区块链结构的架构，更接近直接无环图（DAG），这使得它的安全性大大降低。它还不是用位来编码数据，而是用*三值*（trit），这种单位有三种值而不是两种，目的是让计算在不存在的处理器上更高效。
- en: Iota didn’t use an elliptic curve-based signature scheme like ECDSA or Ed25519
    but rather a hash-based signature scheme based on the established Winternitz construction,
    thus offering post-quantum security—except Iota also designed its own custom hash
    function, Curl.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Iota并没有使用像ECDSA或Ed25519那样基于椭圆曲线的签名方案，而是使用了一种基于已建立的Winternitz结构的基于哈希的签名方案，从而提供了后量子安全性——然而Iota也设计了自己的自定义哈希函数Curl。
- en: Iota became one of the top 10 most popular cryptocurrencies and made grandiose
    claims about its potential usefulness and its security. But its custom hash function,
    which it claimed to develop with the aid of artificial intelligence, turned out
    to be very weak against collision attacks. Using off-the-shelf hardware, researchers
    found collisions within minutes, which could be exploited only in contrived attack
    scenarios. Iota quickly patched its hash function.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Iota 成为了十大最流行的加密货币之一，并对其潜在的有用性和安全性做出了宏大的声明。但它声称通过人工智能的帮助开发的自定义哈希函数，在碰撞攻击面前却非常脆弱。研究人员使用市售硬件，在几分钟内就发现了碰撞，这些碰撞仅在设计好的攻击场景中才能被利用。Iota
    很快修补了其哈希函数。
- en: After this fiasco, renowned cryptography and security expert Bruce Schneier
    commented, “In 2017, leaving your crypto algorithm vulnerable to differential
    cryptanalysis is a rookie mistake. It says that no one of any caliber analyzed
    their system, and that the odds that their fix makes the system secure is low.”
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次失败之后，著名的密码学和安全专家布鲁斯·施奈尔评论道：“在2017年，让你的加密算法容易受到差分密码分析攻击是一个新手错误。这表明没有任何有能力的人分析他们的系统，而他们的修复措施让系统变得安全的可能性很低。”
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Wallet with Low Entropy</samp>'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">低熵钱包</samp>'
- en: The hierarchical key derivation model from earlier in this section is secure
    on paper but in practice only if it’s implemented correctly. You can usually verify
    this using test vectors within the BIP32 and SLIP-0010 standard documents. If
    you obtain the same input/output values as those documented, your implementation
    is likely correct, though not necessarily secure.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本节早些时候提到的分层密钥派生模型在理论上是安全的，但在实践中只有在正确实现时才是安全的。通常可以通过使用BIP32和SLIP-0010标准文档中的测试向量来验证这一点。如果你得到的输入/输出值与文档中记录的相同，那么你的实现很可能是正确的，尽管不一定是安全的。
- en: In 2022, the popular cryptocurrency mobile wallet application Trust Wallet announced
    the release of a browser extension version that used WebAssembly (Wasm) technology
    to run efficiently on different browsers. However, Wasm couldn’t use the same
    PRNG as the mobile versions; it had to define a different one.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 2022 年，流行的加密货币移动钱包应用 Trust Wallet 宣布发布了一款浏览器扩展版本，采用 WebAssembly（Wasm）技术，能够在不同的浏览器中高效运行。然而，Wasm
    无法使用与移动版本相同的 PRNG，它必须定义一个不同的 PRNG。
- en: A poor PRNG can be cryptography’s Achilles’ heel (see [Chapter 2](chapter2.xhtml)).
    In Trust Wallet, the developers used the Mersenne Twister PRNG (mt19937), which
    is not a cryptographic PRNG. Its entropy is at most 32 bits, and it produces its
    output bits using simple linear combinations of the internal state values.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个糟糕的 PRNG 可能是加密学的致命弱点（参见 [第二章](chapter2.xhtml)）。在 Trust Wallet 中，开发者使用了 Mersenne
    Twister PRNG（mt19937），它并不是一个加密学 PRNG。它的熵最多为 32 位，且通过对内部状态值的简单线性组合来生成输出比特。
- en: As Trust Wallet’s PRNG had 32 bits of entropy, it could generate only 2^(32)
    different seeds for users’ wallets. An attacker could then compute all the 2^(32)
    possible seeds and, for each seed, compute the private keys and addresses derived
    using hierarchical key derivation. They could then scan blockchains to find addresses
    generated by Trust Wallet and steal their tokens. The Ledger company researchers
    who found the flaw commented, “Running such an attack takes much more than a couple
    of hours, but is doable with a few GPUs in less than a day.”
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Trust Wallet 的 PRNG 具有 32 位的熵，它只能为用户的钱包生成 2^(32) 个不同的种子。攻击者可以计算出所有 2^(32)
    个可能的种子，并针对每个种子，计算出通过层级密钥派生法得到的私钥和地址。然后，他们可以扫描区块链，找到由 Trust Wallet 生成的地址并窃取其代币。发现该漏洞的
    Ledger 公司研究人员评论道：“执行这样的攻击需要的时间远不止几个小时，但只需几张 GPU，便可在一天之内完成。”
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Collisions from Domain Separation
    Failures</samp>
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">来自域分离失败的碰撞</samp>
- en: Let’s discuss how to find collisions for a hash function that is collision resistant.
    As cryptographer Moti Yung said, “If it sounds impossible, then it’s cryptographically
    interesting.”
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论如何找到一个抗碰撞的哈希函数的碰撞。正如加密学家 Moti Yung 所说：“如果这听起来不可能，那就从加密学的角度来看非常有趣。”
- en: 'Imagine the following simple case: an application receives messages *A* and
    *B* from two parties, Alice and Bob, and then hashes these two messages together
    to create a hash value unique for these messages. It could then compute **H**(*A*
    || *B*) by hashing the string consisting of *A* followed by *B*. Even if your
    hash function is collision resistant, you’ll get the same hash value for *A* =
    COL and *B* = LISION as for *A* = CO and *B* = LLISION. You end up with a hash
    collision with respect to the application’s input values, although it’s not a
    collision for the hash function because the hash function **H** processes the
    same string in the two cases, COLLISION.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 假设以下简单情况：一个应用从两方，Alice 和 Bob，接收消息 *A* 和 *B*，然后将这两条消息一起哈希，生成一个唯一的哈希值。它接着可以通过对字符串
    *A* 后跟 *B* 进行哈希来计算 **H**(*A* || *B*)。即使你的哈希函数是抗碰撞的，当 *A* = COL 且 *B* = LISION
    时，得到的哈希值与 *A* = CO 且 *B* = LLISION 时的哈希值相同。你会遇到针对应用输入值的哈希碰撞，尽管对哈希函数而言并不算碰撞，因为哈希函数
    **H** 在这两种情况下处理的是相同的字符串，即 COLLISION。
- en: 'To avoid the problem, encode the application’s input values into a string that’s
    unique per input, with no ambiguous encoding: for each string, you should be able
    to uniquely identify the original set of input values. In our example, adding
    a dollar sign ($) character as a separator between the two inputs seems to avoid
    the collision between COL || LISION and CO || LLISION: you would get the strings
    COL$LISION and CO$LLISION, leading to different hash values.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，将应用的输入值编码为唯一的字符串，并且不采用模糊的编码方式：对于每个字符串，你应该能够唯一识别原始的输入值集合。在我们的例子中，在两个输入之间添加美元符号（$）作为分隔符似乎可以避免
    COL || LISION 和 CO || LLISION 之间的碰撞：你将得到字符串 COL$LISION 和 CO$LLISION，从而生成不同的哈希值。
- en: 'But a separator symbol isn’t enough to eliminate ambiguities when the character
    is authorized in the application’s input values. For example, take the string
    COL$$LISION as the concatenation of two input strings separated with $. You could
    have obtained that string from two pairs of inputs: COL and $LISION, COL$ and
    LISION. Note that the problem doesn’t occur when the input values are a fixed,
    constant size—for example, a first string of two characters and a second of three
    characters. Even in that case, it’s still safer to use some separator or encoding
    that prevents collisions, as a future patch may introduce variable-length input.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，仅仅使用分隔符符号不足以消除当字符在应用程序的输入值中被授权时产生的歧义。例如，考虑字符串COL$$LISION，它是两个输入字符串通过$符号连接起来的结果。你可以从两个输入对中得到该字符串：COL和$LISION，或者COL$和LISION。注意，当输入值的大小固定且常量时，问题不会出现——例如，第一个字符串由两个字符组成，第二个字符串由三个字符组成。即便如此，仍然更安全使用某些分隔符或编码来防止冲突，因为未来的补丁可能会引入可变长度的输入。
- en: Researchers have found bugs of this type in threshold signing protocols, which
    you’ll see later in this chapter, as well as in e-voting protocols, where the
    resulting hash collisions could be exploited to violate the security properties
    of these protocols.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员发现了在门限签名协议中存在这种类型的漏洞，稍后你将在本章中看到，此外在电子投票协议中也有类似问题，其中生成的哈希冲突可能被利用来破坏这些协议的安全属性。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Multisignature Protocols</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">多重签名协议</samp>
- en: In a cryptographic *multisignature protocol*, participants jointly produce a
    signature of a message that’s functionally equivalent to having all parties separately
    sign the message; an obtained signature means all parties agreed to sign the message.
    The advantage is that instead of having as many signatures as signers, there’s
    only one. Anyone who has the public keys of all the signers can then verify the
    signature.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密的*多重签名协议*中，参与者共同生成一条消息的签名，功能上相当于所有方分别签署消息；获得的签名意味着所有参与者同意签署该消息。其优点是，签名的数量不再与签署者的数量相等，而只有一个。任何拥有所有签署者公钥的人都可以验证该签名。
- en: Blockchain platforms employ multisignatures when multiple parties manage an
    account to ensure that all parties endorse issued transactions. A single party
    can also use them if they have multiple keys on multiple devices to prevent a
    single compromised key from allowing the attack to issue transactions. Such multisignature
    protocols are one of the many types of *collective signature* protocols, where
    parties run a protocol to produce a signature.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链平台在多个参与方共同管理账户时使用多重签名，以确保所有参与方都支持已发起的交易。如果单个方在多个设备上有多个密钥，他们也可以使用多重签名，以防止单个被泄露的密钥允许攻击者发起交易。此类多重签名协议是*集体签名*协议的众多类型之一，在这些协议中，参与方运行一个协议以生成签名。
- en: Before diving into the technical details, let’s clarify how these multisignatures
    differ from related protocols.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入技术细节之前，让我们先澄清这些多重签名与相关协议的不同之处。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiple Multiparty
    Signatures</samp>
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">多方多重签名</samp>
- en: Despite their similar name, the multisignature protocols we’ll discuss are different
    from on-chain multisignature scripts or multisignature smart contracts, as used
    in Bitcoin and Ethereum, respectively. The latter aren’t cryptographic protocols
    because participants independently submit their individual signature to the blockchain
    network. The network in turn verifies a rule such as “if a transaction has signatures
    from *pub*[1] and *pub*[2], then accept it” or “if a transaction is signed by
    any two parties among *pub*[1], *pub*[2], and *pub*[3], then accept it”—rejecting
    the transaction otherwise. Here we implicitly view public keys *pub* as the identifiers
    of the parties, as is common in blockchain protocols.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名称相似，我们将要讨论的多重签名协议与比特币和以太坊中使用的链上多重签名脚本或多重签名智能合约不同。后者并不是加密协议，因为参与者独立提交各自的签名到区块链网络，网络则验证如“如果交易拥有来自*pub*[1]和*pub*[2]的签名，则接受它”或“如果交易由*pub*[1]、*pub*[2]和*pub*[3]中的任意两方签署，则接受它”这样的规则——否则拒绝该交易。在这里，我们隐含地将公钥*pub*视为参与方的标识符，这在区块链协议中是常见的做法。
- en: Compared to on-chain multisigs, multisignature protocols produce a single signature;
    there’s then only one signature to verify rather than multiple ones. The multisignature
    scripts and smart contracts instead process several signatures and consist of
    a verification rule rather than a protocol on the signers’ end. In both cases,
    verification requires the public keys of all signers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与链上多签不同，多签名协议生成单一签名；然后只需要验证一个签名，而不是多个签名。多签名脚本和智能合约代替处理几个签名并包含验证规则，而不是签署者端的协议。在两种情况下，验证都需要所有签署者的公钥。
- en: 'Multisignature protocols also differ from two types of other collective signature
    protocols, which you’ll see in the following sections. In both protocols, the
    outcome is a single signature, but the difference is how and from what it’s created:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 多签名协议也不同于其他两种集体签名协议类型，你将在以下部分看到。在这两种协议中，结果是一个单一的签名，但不同之处在于如何以及从何创建：
- en: '**Aggregate signature protocols**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**聚合签名协议**'
- en: Like in multisignatures, each participant has their own key pair (public and
    private keys).
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像在多签名中一样，每个参与者都有自己的密钥对（公钥和私钥）。
- en: Unlike in multisignatures, participants may sign different messages, rather
    than the same one. A participant can also sign multiple messages.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不像在多签名中一样，参与者可以签署不同的消息，而不是相同的消息。一个参与者还可以签署多个消息。
- en: Like in multisignatures, the verification of a signature requires multiple public
    keys (or a single aggregate version thereof, for supporting protocols).
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像在多签名中一样，验证签名需要多个公钥（或其单个聚合版本，用于支持协议）。
- en: '**Threshold signature protocols**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**门限签名协议**'
- en: Unlike in multisignatures, participants don’t use their own keys. Instead, they
    have shares (also called *shards*) of a single private key, such that no single
    participant ever knows the full key, even during the protocol’s execution.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与多签名不同，参与者不使用自己的密钥。相反，他们有一个单一私钥的份额（也称为*碎片*），以便在协议执行期间没有单个参与者知道完整的密钥。
- en: Like in multisignatures, participants sign a single message.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像在多签名中一样，参与者签署单个消息。
- en: Unlike in multisignatures, verification requires a single public key.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与多签名不同，验证只需要单个公钥。
- en: 'Now that we’ve defined what multisignatures are, let’s see how they work in
    their most illustrious use case: Schnorr signatures.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了多签名，让我们看看它们在它们最显著的用例中是如何工作的：Schnorr 签名。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Schnorr Signature
    Protocols</samp>
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">施诺尔签名协议</samp>
- en: Mathematician Claus-Peter Schnorr created the eponymous signature scheme in
    1989 and filed a patent for it, which prevented its wide adoption until 2008,
    when the EdDSA scheme (see [Chapter 12](chapter12.xhtml)) optimized it to work
    with modern elliptic curves. Schnorr’s scheme is simpler than the ECDSA standard,
    making it easier to turn into a multisignature scheme. Bitcoin supports Schnorr
    signatures, which were introduced in 2022 as better support for multisignature
    protocols.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 数学家克劳斯-彼得·施诺尔于1989年创建了同名签名方案，并对其进行了专利申请，这阻碍了其广泛采用，直到2008年EdDSA方案（参见[第12章](chapter12.xhtml)）优化了它以适应现代椭圆曲线。施诺尔的方案比ECDSA标准更简单，更容易转换为多签名方案。比特币支持施诺尔签名，这些签名在2022年作为更好的多签名协议支持引入。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*We’ll use additive notation (as with EdDSA and when working with elliptic
    curve), rather than the original multiplicative notation (as used when working
    with integers in a multiplicative group). Therefore, the public key* A *associated
    with a private key* a *is the elliptic curve point* A *=* aG*, where* G *is a
    predefined base point, and group elements are points combined by addition. This
    is opposed to the multiplicative notation where we’d have* A *=* g^a *for some
    group generator* g*, where group elements are numbers multiplied together.*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将使用加法表示法（与EdDSA以及处理椭圆曲线时一样），而不是原始的乘法表示法（用于整数的乘法群中使用）。因此，与私钥* a *相关联的公钥*
    A *是椭圆曲线点* A *=* aG*，其中* G *是预定义的基点，而组元素是通过加法组合的点。这与在乘法表示法中的情况相反，那里我们会有* A *=*
    g^a *，其中组元素是相乘在一起的数字。*'
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Single-Signer Schnorr
    Signatures</samp>'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">单签名 Schnorr 签名</samp>'
- en: Before seeing how multiparty signing works, let’s see how single-party Schnorr
    signing works. Suppose Alice has a private key *a*, with associated public key
    *A* = *aG*. Here *a* is a number, or scalar, in a given range of numbers (specifically,
    the finite field over which the elliptic curve is defined, typically positive
    integers modulo some large prime numbers, of at least approximately 256 bits),
    and *G* is a fixed base point of the curve.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解如何进行多方签名之前，我们先看看单方Schnorr签名是如何工作的。假设Alice有一个私钥 *a*，对应的公钥是 *A* = *aG*。这里的
    *a* 是一个数字，或者说是一个标量，在给定的数字范围内（具体来说，是椭圆曲线定义的有限域，通常是模某些大质数的正整数，至少大约为256位），而 *G* 是曲线的固定基点。
- en: 'To sign a message *M*, Alice proceeds as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了签署一条消息 *M*，Alice按以下步骤进行：
- en: 1.  Pick a secret random number, *r*, and compute the point *R* = *rG*. The
    value *r* is a *nonce*, a one-time private key with *R* its public key.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  选择一个秘密随机数 *r*，并计算点 *R* = *rG*。值 *r* 是一个 *nonce*，即一次性的私钥，*R* 是其公钥。
- en: 2.  Compute *h* = **H**(*R* || *A* || *M*), the value that you’ll “connect”
    to the private key *a* and the one-time private key *r* to sign *M*. We not only
    hash the message but also bind *h* to the signer and the nonce, respectively,
    via the nonsecret values *A* and *R*. Without these, different attacks would be
    possible.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  计算 *h* = **H**(*R* || *A* || *M*)，这是你将“连接”到私钥 *a* 和一次性私钥 *r* 以签署 *M* 的值。我们不仅对消息进行哈希处理，而且通过非秘密值
    *A* 和 *R* 分别将 *h* 绑定到签名者和nonce上。如果没有这些，不同的攻击将成为可能。
- en: 3.  Compute *s* = *r* + *ha* and return the pair (*R*, *s*) as a signature.
    You can see *s* as the multiplication between the secret key and the data to sign,
    where the secret *r* masks the result; without this, it’s trivial to recover the
    private key from a signature.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  计算 *s* = *r* + *ha*，并返回一对 (*R*, *s*) 作为签名。你可以把 *s* 看作是私钥和数据进行签名时的乘积，其中秘密
    *r* 对结果进行掩码；如果没有这个，恢复私钥从签名中将变得很容易。
- en: Verify a signature by checking that *sG* equals *R* + **H**(*R* || *A* || *M*)*A*.
    This works because from *s* = *r* + *ha*, substituting *r* + *ha* for *s* in *sG*,
    you obtain
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 验证签名时，检查 *sG* 是否等于 *R* + **H**(*R* || *A* || *M*)*A*。这是因为从 *s* = *r* + *ha*，将
    *r* + *ha* 代入 *sG*，你会得到：
- en: '![](../images/pg308-1.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg308-1.jpg)'
- en: with *h* = **H**(*R* || *A* || *M*), which the verifier must compute from the
    message *M*, the public key *A*, and the *R* part of the signature.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *h* = **H**(*R* || *A* || *M*)，验证者必须根据消息*M*、公钥*A*和签名的*R*部分来计算该值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Schnorr Multisignatures</samp>
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Schnorr多重签名</samp>
- en: 'In multisignatures we don’t have one signer but multiple ones. For the sake
    of simplicity, we’ll describe the case of two cosigners: meet Bob, who’ll sign
    messages jointly with Alice. Bob’s private key is *b* and his public key is *B*
    = *bG*. To jointly create a multisignature, Alice and Bob could proceed as follows
    to sign a message *M*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在多重签名中，我们不仅仅有一个签名者，而是多个签名者。为了简化，我们描述两位共同签名者的情况：见Bob，他将与Alice共同签署消息。Bob的私钥是*b*，他的公钥是*B*
    = *bG*。为了共同创建一个多重签名，Alice和Bob可以按照以下步骤来签署消息*M*：
- en: 1.  Alice picks a nonce *r*[A], computes *R*[A] = *r*[A]*G*, and sends *R*[A]
    to Bob.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  Alice选择一个nonce *r*[A]，计算 *R*[A] = *r*[A]*G*，并将 *R*[A]发送给Bob。
- en: 2.  Bob picks a nonce *r*[B], computes *R*[B] = *r*[B]*G*, and sends *R*[B]
    to Alice.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  Bob选择一个nonce *r*[B]，计算 *R*[B] = *r*[B]*G*，并将 *R*[B]发送给Alice。
- en: 3.  They compute *R* = *R*[A] + *R*[B] and set *h* = **H**(*R* || *A* || *B*
    || *M*), the value that Alice and Bob will use to generate their part of the signature.
    A specific value of *h* is bound to the parties via their public keys (*A* and
    *B*) and bound to the current signing session via the nonce *R* only for the specific
    signature execution as defined by the nonce *R*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  他们计算 *R* = *R*[A] + *R*[B]，并设置 *h* = **H**(*R* || *A* || *B* || *M*)，这是Alice和Bob将用来生成其签名部分的值。*h*的特定值通过他们的公钥(*A*和*B*)与签名者绑定，并且仅通过nonce
    *R*与当前的签名会话绑定，这个绑定只适用于由nonce *R*定义的特定签名执行。
- en: 4.  Alice computes *s*[A] = *r*[A] + *ha* and sends it to Bob.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  Alice计算 *s*[A] = *r*[A] + *ha*，并将其发送给Bob。
- en: 5.  Bob computes *s*[B] = *r*[B] + *hb* and sends it to Alice.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  Bob计算 *s*[B] = *r*[B] + *hb*，并将其发送给Alice。
- en: 6.  They both compute *R* = *R*[A] + *R*[B] and *s* = *s*[A] + *s*[B] and return
    (*R*, *s*) as the signature.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  他们一起计算 *R* = *R*[A] + *R*[B] 和 *s* = *s*[A] + *s*[B]，并返回 (*R*, *s*) 作为签名。
- en: 'To verify a signature, check that *sG* equals *R* + *h*(*A + B*). Substituting
    *s* in *sG* by the previously computed value results in the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 验证签名时，检查 *sG* 是否等于 *R* + *h*(*A + B*)。将 *s* 代入 *sG* 后，结果如下：
- en: '![](../images/pg309-1.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg309-1.jpg)'
- en: Note that the verifier needs to know both *A* and *B*, and not only their sum
    *A* + *B*, because they need both values to compute **H**(*R* || *A* || *B* ||
    *M*). However, if *h* is instead defined as **H**(*R* || *A* + *B* || *M*), a
    verifier can use a single public key *A* + *B* without knowing that the signature
    is issued by two parties. We call the “merging” of multiple public keys into one
    *key aggregation*. This is particularly useful to reduce the size of the data
    to hash when there are many signers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，验证者需要知道 *A* 和 *B*，而不仅仅是它们的和 *A* + *B*，因为他们需要这两个值来计算 **H**(*R* || *A* ||
    *B* || *M*)。然而，如果 *h* 被定义为 **H**(*R* || *A* + *B* || *M*), 那么验证者就可以使用一个公钥 *A*
    + *B*，而无需知道签名是由两方发布的。我们称将多个公钥合并为一个的方式为 *密钥聚合*。这在有多个签名者的情况下尤其有用，可以减少哈希时数据的大小。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*I’ve described basic Schnorr multisignatures in the case of two parties, but
    the protocol scales to an arbitrary number of parties with public keys* P1*,*
    P2 *, . . . ,* P[n]*. In the definition, replace* A *+* B *with* P1 *+* P2 *+
    . . . +* P[n]*, replace* A *||* B *with* P1 *||* P2 *|| . . . ||* P[n]*, and replace
    “sends it to Bob/Alice” with “sends it to everyone.” You can apply a similar protocol
    to EdDSA and Ed25519, variants of Schnorr’s scheme.*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*我描述了基本的 Schnorr 多重签名方案，适用于两方的情况，但该协议可以扩展到任意数量的公钥 *P1*, *P2*, …, *P[n]* 的情况。在定义中，替换
    *A* + *B* 为 *P1* + *P2* + … + *P[n]*，将 *A* || *B* 替换为 *P1* || *P2* || … || *P[n]*，并将“发送给
    Bob/Alice”替换为“发送给所有人”。你可以将类似的协议应用到 EdDSA 和 Ed25519，这些是 Schnorr 方案的变种。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Things Can Go
    Wrong</samp>
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">事情可能出错的方式</samp>
- en: The Schnorr multisignature protocol is relatively simple but may fail in the
    following attack scenarios.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Schnorr 多重签名协议相对简单，但在以下攻击场景中可能会失败。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Key Cancellation Attack</samp>
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">密钥取消攻击</samp>
- en: In this attack, Bob convinces signature verifiers that he jointly signed a message
    with Alice, whereas Alice hasn’t seen the message and didn’t interact with Bob.
    An attacker could exploit this in a scenario where you expect Alice and Bob to
    jointly sign messages—for example, in transactions that require both parties’
    approval. In the normal case, the verifiers would know Alice’s public key *A*
    and Bob’s public key *B*, and Bob and Alice would know each other’s keys.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在此攻击中，Bob 让签名验证者相信他与 Alice 一起签署了消息，而实际上 Alice 没有看到这条消息，也没有与 Bob 互动。攻击者可以在你期望
    Alice 和 Bob 一起签署消息的场景中利用这一点——例如，在需要双方批准的交易中。在正常情况下，验证者会知道 Alice 的公钥 *A* 和 Bob
    的公钥 *B*，并且 Bob 和 Alice 会知道彼此的公钥。
- en: 'Now suppose the following happens: Alice sends her public key *A* to everyone
    including Bob, but instead of sharing his public key *B*, Bob shares *C* = *B*
    – *A* = (*b* – *a*)*G* with the verifiers, and *B* with Alice. That Bob doesn’t
    know the private key corresponding to *C* won’t matter for the attack.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设发生以下情况：Alice 将她的公钥 *A* 发送给所有人，包括 Bob，但 Bob 并没有分享他的公钥 *B*，而是将 *C* = *B* – *A*
    = (*b* – *a*)*G* 分享给验证者，并将 *B* 分享给 Alice。Bob 不知道与 *C* 对应的私钥，对于攻击来说并不重要。
- en: Bob has to sign a message using his private key *b*, as in the single-signer
    case, but with *h* = **H**(*R* || *A* || *C* || *M*), as if he were signing with
    Alice. He returns (*R*, *s*) as a signature, with *R* = *rG* for an *r* of his
    choice and *s* = *r* + *hb.*
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Bob 必须使用他的私钥 *b* 来签署消息，就像单签名者的情况一样，但此时 *h* = **H**(*R* || *A* || *C* || *M*),
    就像他在与 Alice 一起签名一样。他返回 (*R*, *s*) 作为签名，其中 *R* = *rG*（*r* 为他选择的值），*s* = *r* + *hb*。
- en: Expecting signatures from Alice and Bob, verifiers check that *sG* equals *R*
    + *h*(*A + C*), which is correct because *A* + *C* = *A* + (*B* – *A*) = *B*.
    Bob can therefore forge multisignature without even interacting with Alice and
    without knowing her private key.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在期望 Alice 和 Bob 签名的情况下，验证者检查 *sG* 是否等于 *R* + *h*(*A + C*), 这是正确的，因为 *A* + *C*
    = *A* + (*B* – *A*) = *B*。因此，Bob 可以伪造多重签名，而无需与 Alice 交互，也无需知道她的私钥。
- en: In practice, you can avoid this attack by requesting signers to prove the knowledge
    of the private key—for example, by signing a message. Since Bob doesn’t know the
    private key corresponding to *C*, he can’t provide such evidence. As you’ll see
    with the MuSig protocol, you can also avoid the attack at the protocol level.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以通过要求签名者证明他们知道私钥（例如，通过签署一条消息）来避免这种攻击。由于 Bob 不知道与 *C* 对应的私钥，他无法提供这种证明。如你在
    MuSig 协议中看到的，你也可以在协议层面避免这种攻击。
- en: The attack scales to an arbitrary number of parties, a context that’s often
    called a *rogue key attack*. Having received the public keys of all other parties,
    an attacker Bob would just define his public key as *B* – *X*, with *X* the sum
    of all other parties’ public keys.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Repeated Nonces</samp>
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Like in ECDSA, repeated nonces are lethal to the Schnorr multisignature protocol.
    Imagine that Alice’s pseudorandom generator fails and she generates the same secret
    nonce *r*[A] twice in two runs of the protocol: she sends an initial *s*[A] =
    *r*[A] + *ha* to Bob, and a second *s*[A]*''* = *r*[A] + *h''a* where the first
    *h* and the second *h''* also depend on Bob’s randomness. You thus have *r*[A]
    = *ha – s*[A] and *r*[A] = *h''a – s*[A]*''*, which implies *ha – s*[A] = *h''a
    – s*[A]*''* or, equivalently,'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg310-1.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: from which you can compute Alice’s private key *a* = (*s*[A] – *s*[A]*'*) /
    (*h – h'*).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach to eliminate security risks caused by a randomness failure is
    to get rid of randomness. For example, computing the nonce by hashing the message
    and the private key as in Ed25519 works when there’s a single signer. However,
    setting *r* to **H**(*a* || *M*) won’t work in the case of multisignatures: if
    Alice and Bob sign the same message twice, then Alice computes a first *s*[A]
    = *r*[A] + *ha* and a second *s*[A]*''* = *r*[A] + *h''a*, where in both cases
    *r*[A] *=* **H**(*a* **||** *M*), where *h''* will be distinct from *h* if a malicious
    Bob sends a different value than **H**(*b* **||** *M*). In this case, Bob—and
    any eavesdropper of the communications—can again compute *a* as (*s*[A] – *s*[A]*''*)
    / (*h – h''*).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Parallel Execution Insecurity</samp>
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Schnorr multisignature protocol is insecure when the attacker can initiate
    multiple simultaneous signature protocols. The attack is too complicated to describe
    here but is documented in the research articles available at *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2018<wbr>/417](https://eprint.iacr.org/2018/417)*
    and *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2020<wbr>/945](https://eprint.iacr.org/2020/945)*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Safer Schnorr Multisignatures</samp>
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To avoid the key cancellation attack and repeated nonce issues, researchers
    developed more advanced multisignature protocols and in particular the MuSig protocols:
    MuSig, MuSig2, and MuSig-DN, where *MuSig* stands for *multisignature* and *DN*
    for *deterministic nonce*. MuSig protocols also support key aggregation to allow
    a verifier to check a signature using only one public key that’s derived from
    the signers’ keys, such that the aggregated key doesn’t reveal the number of signers
    or their public keys.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see MuSig’s main trick in action. If we’re in the simplest case of two
    signers, Alice and Bob, using the same notations as in the previous sections,
    instead of computing *s*[A] = *r*[A] + *ha* as her share of the signature, Alice
    computes *s*[A] = *r*[A] + *μ*[A]*ha*, thus multiplying the *ha* part with the
    *μ*[A] value. She computes *μ*[A] (where *μ* is the Greek letter mu) by hashing
    the list of participants’ public keys followed by Alice’s key, **H**(*A* || *B*
    || *A*). Likewise, Bob computes *s*[B] = *r*[B] + *μ*[B]*hb* with *μ*[B] = **H**(*A*
    || *B* || *B*), hashing the list of public keys followed by his key.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看MuSig的主要技巧如何运作。如果我们处于最简单的情况，只有两个签名者，Alice和Bob，并且使用与前面章节相同的符号，那么Alice不再计算*s*[A]
    = *r*[A] + *ha*作为她的签名部分，而是计算*s*[A] = *r*[A] + *μ*[A]*ha*，从而将* ha*部分与* μ*[A]值相乘。她通过哈希参与者的公钥列表，再加上Alice的密钥，**H**(*A*
    || *B* || *A*)，来计算* μ*[A]（其中* μ*是希腊字母mu）。同样，Bob通过哈希公钥列表，再加上他的密钥，**H**(*A* || *B*
    || *B*)来计算* μ*[B]，从而计算*s*[B] = *r*[B] + *μ*[B]*hb*。
- en: Alice then computes the *aggregate public key* as *X* = *μ*[A]*A* + *μ*[B]*B*,
    the sum of the public keys multiplied by their respective *μ* values. The hash
    of the message is then *h* = **H**(*R* || *X* || *M*) instead of **H**(*R* ||
    (*A* + *B*) || *M*) in the vulnerable version multisignature scheme supporting
    key aggregation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Alice计算*聚合公钥*为*X* = *μ*[A]*A* + *μ*[B]*B*，即公钥与各自* μ*值的乘积之和。消息的哈希值为*h* = **H**(*R*
    || *X* || *M*)，而不是脆弱版本的多重签名方案中支持密钥聚合的**H**(*R* || (*A* + *B*) || *M*)。
- en: This trick works because a malicious Bob can no longer forge another public
    key that would “cancel” Alice’s *A*, as he could by setting *C* = *B* – *A* in
    the key cancellation attack. In the equation *X* = *μ*[A]*A* + *μ*[B]*B*, Bob
    has to find a new value of *B* that yields the “right” *μ* coefficients to remove
    *A* from the equation. But that’s now impossible because the equation is nonlinear
    with respect to *A* and *B* (linearity is often synonymous with insecurity—see
    [Chapter 2](chapter2.xhtml)).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧之所以有效，是因为恶意的Bob不再能够伪造另一个“取消”Alice的公钥* A*，就像他可以通过设置*C* = *B* – *A* 在密钥取消攻击中做到的那样。在方程式*
    X* = *μ*[A]*A* + *μ*[B]*B*中，Bob必须找到一个新的* B*值，得出“正确”的* μ*系数，以从方程中移除* A*。但这现在是不可能的，因为该方程式对*
    A*和* B*是非线性的（线性通常意味着不安全——参见[第二章](chapter2.xhtml)）。
- en: When there are more than two signers, you apply the trick in a similar way,
    computing the *μ* coefficients by hashing the list of keys followed by the signer’s
    key and then aggregating the public keys into a single *X* by computing the sum
    of the public keys multiplied by their respective *μ*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当签名者超过两个时，可以以类似的方式应用这个技巧，通过哈希公钥列表和签名者的密钥来计算* μ*系数，然后通过计算公钥乘以各自的* μ*值，将公钥聚合为一个单一的*
    X*。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*For more details on the MuSig protocols and how the MuSig-DN version securely
    derives nonces from the message, see* [https://<wbr>bitcoinops<wbr>.org<wbr>/en<wbr>/topics<wbr>/musig<wbr>/](https://bitcoinops.org/en/topics/musig/).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关MuSig协议的更多详情，以及MuSig-DN版本如何从消息中安全地推导出随机数，请参见* [https://<wbr>bitcoinops<wbr>.org<wbr>/en<wbr>/topics<wbr>/musig<wbr>/](https://bitcoinops.org/en/topics/musig/)。'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Aggregate Signature Protocols</samp>
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">聚合签名协议</samp>
- en: '*Aggregate signatures* have multiple signers, and each signer signs a message
    (which can be distinct for all signers); then these signatures are merged into
    a single signature. From only this signature and from the signers’ public keys
    and the messages they signed, verification checks that all signers signed their
    respective messages. Because a single signature must be stored, instead of as
    many signatures as signers, verification time is proportional to the number of
    messages. When all signers sign the same message, verification can be as fast
    as the verification of a single signer’s signature, regardless of the number of
    signers.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*聚合签名*有多个签名者，每个签名者签署一条消息（每个签名者的消息可以不同）；然后将这些签名合并为一个单一的签名。通过这个签名、签名者的公钥和他们签署的消息，验证过程检查所有签名者是否都签署了各自的消息。由于只需要存储一个签名，而不是与签名者数量相等的签名，因此验证时间与消息的数量成正比。当所有签名者签署相同的消息时，验证速度可以和单一签名者的签名验证一样快，无论签名者有多少个。'
- en: 'Aggregate signatures are notably used in Ethereum, specifically in its consensus
    layer. In this use case, validator nodes endorse proposals to change the state
    of the system (as blocks) and leverage aggregate signatures to minimize the signature
    storage space and verification time. They use the Boneh–Lynn–Shacham (BLS) signature
    scheme, which you’ll learn about in this section, starting with the magic behind
    BLS signatures: cryptographic pairings.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合签名在以太坊中特别用于其共识层。在这种用例中，验证节点支持提议以改变系统状态（作为区块），并利用聚合签名来最小化签名存储空间和验证时间。它们使用Boneh-Lynn-Shacham（BLS）签名方案，你将在本节中了解到，从BLS签名的魔力开始：密码学配对。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pairings</samp>'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">配对</samp>'
- en: 'In elliptic curve cryptography, a *pairing* is an operation that transforms
    two points from two elliptic curve groups (not necessarily the same) into a finite
    field element. The standard notation for a pairing between two elliptic curve
    points *P* and *Q* is *e*(*P*, *Q*). Pairings used in cryptography have the property
    called *bilinearity* and are thus called *bilinear pairings*, which means they
    satisfy the following for any points *P*, *Q*, and *R*:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在椭圆曲线密码学中，*配对*是一种操作，它将两个来自两个椭圆曲线群（不一定相同）的点转换为有限域元素。两个椭圆曲线点*P*和*Q*之间的配对的标准表示法是*e*(*P*,
    *Q*)。在密码学中使用的配对具有称为*双线性*的属性，因此称为*双线性配对*，这意味着对于任何点*P*、*Q*和*R*，它们满足以下条件：
- en: '![](../images/pg312-1.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg312-1.jpg)'
- en: Here, adding a point *R* to an operand is equivalent to multiplying the result
    by the pairing between *R* and the other operand. Consequently, if you add a point
    to itself *n* times—that is, if you multiply it by a number *n*—then you have
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，将点*R*添加到操作数相当于将结果乘以*R*与另一个操作数之间的配对。因此，如果你将一个点加上它自身*n*次，也就是说，将其乘以一个数字*n*，那么你得到的是
- en: '![](../images/pg312-2.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg312-2.jpg)'
- en: or *e*(*P*, *Q*) multiplied by itself *n* times, which is also equal to *e*(*P*,
    *nQ*).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 或者是*e*(*P*, *Q*)乘以它自身*n*次，这也等同于*e*(*P*, *nQ*)。
- en: 'If you have different points *P*[1], *P*[2], . . . , *P*n, you can turn addition
    of the input values into multiplication of the output values:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有不同的点*P*[1]、*P*[2]、...、*P*[n]，你可以将输入值的加法转换为输出值的乘法：
- en: '![](../images/pg312-3.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg312-3.jpg)'
- en: The internals of how pairings work is beyond this book’s scope. For more details,
    see the article “Cryptographic Pairings” by Kristin Lauter and Michael Naehrig
    (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2017<wbr>/1108](https://eprint.iacr.org/2017/1108)*)
    and the book *Guide to Pairing-Based Cryptography* by Nadia El Mrabet and Marc
    Joye (Chapman and Hall/CRC, 2016).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 配对的内部工作原理超出了本书的范围。更多详情请参阅Kristin Lauter和Michael Naehrig的文章“密码学配对”（*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2017<wbr>/1108](https://eprint.iacr.org/2017/1108)*）以及Nadia
    El Mrabet和Marc Joye的书籍《基于配对的密码学指南》（Chapman and Hall/CRC, 2016）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">BLS Signatures</samp>
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">BLS签名</samp>
- en: 'BLS signatures were presented in 2006 in the article “Short Signatures from
    the Weil Pairing” by Dan Boneh, Ben Lynn, and Hovav Shacham. It stated that the
    scheme was designed “for systems where signatures are typed in by a human or signatures
    are sent over a low-bandwidth channel.” BLS signatures turned out to be used in
    highly automated systems over high-bandwidth channels, which benefited from a
    property described in a subsequent paper: aggregation of signatures and of public
    keys.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 2006年，Dan Boneh，Ben Lynn和Hovav Shacham在文章“从Weil配对获得的短签名”中提出了BLS签名。文章指出，该方案设计用于“由人类输入签名或通过低带宽信道发送签名的系统”。BLS签名后来被用于高度自动化的系统，这些系统通过后续论文描述的一种特性受益匪浅：签名和公钥的聚合。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Don’t confuse BLS signatures with BLS (Barreto–Lynn–Scott) curves, which have
    an author (Lynn) in common. BLS curves are elliptic curves designed to be pairing
    friendly, allowing secure and efficient pairing operations. In fact, BLS signatures
    often work with points over a BLS curve. For example, the Ethereum BLS signature
    relies on the curve BLS12-381.*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要将BLS签名与BLS（Barreto-Lynn-Scott）曲线混淆，这两者共同的作者是（Lynn）。BLS曲线是设计成配对友好的椭圆曲线，允许安全高效的配对操作。事实上，BLS签名通常使用BLS曲线上的点。例如，以太坊的BLS签名依赖于曲线BLS12-381。*'
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Single-Signer Signature
    and Verification</samp>'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">单签名签名与验证</samp>'
- en: 'In BLS signatures, Alice’s private key is a scalar number *a*, and her public
    key is *A* = *aG*, for a predefined base point *G*. To sign a message *M*, she
    first computes *H* = **H**(*M*), where the hash function returns a curve point
    rather than a bit string or a scalar—the *H* notation follows the general convention
    that you denote points as capital letters. The signature is then *S* = *aH*. This
    looks much simpler than a Schnorr’s or an ECDSA signature: just hash the message
    and multiply the result with the private key.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify a BLS signature, compute two pairing operations:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '*e*(*A*, *H*) between the public key and the hashed message (note that *A*
    = *aG*)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*e*(*G*, *S*) between the base point and the signature (note that *S* = *aH*)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These values should be equal because of the pairing’s bilinearity property:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg313-1.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: If the equality holds, the signature is accepted; otherwise, it’s rejected.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring the complexity of the pairing operation, such pairing-based signatures
    are the simplest signature scheme.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Aggregate Signatures from
    Multiple Signers</samp>
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s further exploit the magic of BLS signatures and bilinear pairings, considering
    a scenario wherein *n* signers with private keys *k*[1], *k*[2], . . . , *k*n
    and public keys *P*[1], *P*[2], . . . , *P*n sign *n* messages *M*[1], *M*[2],
    . . . , *M*n and produce the signatures *S*[1], *S*[2], . . . , *S*n. Note that
    *H*i = **H**(*M*i) is the hash of the *i*th message.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'You can aggregate signatures *S*i = *k*i*H*i into one by adding them to obtain
    *S* = *S*[1] + *S*[2] + . . . + *S*n. Observe that computing *e*(*G*, *S*), as
    in the verification of a single signature, results in the following, owing to
    the bilinearity property:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg313-2.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: 'Remember that pairings satisfy *e*(*nP*, *Q*) = *e*(*P*, *nQ*). You can thus
    replace each *e*(*G*, *S*i) term with *e*(*P*i, *H*i) by “moving” the multiplicative
    factor *k*i to the left operand of the pairing: the first operand will thus be
    *k*i*G* = *P*i instead of *G*, and the second will be *H*i instead of *S*i = *k*i*H*i.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: After aggregating multiple signatures of multiple signers over multiple messages
    into a single signature, you can verify the aggregate signature from the signers’
    public keys and messages signed. Verification just checks the equality between
    *e*(*G*, *S*) and the product of all pairings *e*(*P*i, *H*i). There are 1 + *n*
    pairings to compute, rather than the 2*n* pairings if you hadn’t aggregated the
    signatures—in this case, the signatures occupy *n* times as much memory as the
    aggregated one.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider a scenario where you’ll aggregate both signatures and public
    keys.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Aggregate Public Keys</samp>'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that all signers sign the same message *M* and that you aggregate all
    public keys into a single one: *P* = *P*[1] + *P*[2] + . . . + *P*n. Note that
    *k*[1], *k*[2], . . . , *k*n still represents their respective private keys and
    *H* = **H**(*M*) the hash of the message. Given valid signatures *S*i, you obtain
    the following equality:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg314-1.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: You therefore verify the signatures of *n* parties over the same message using
    only two pairing operations, *e*(*P*, *H*) and *e*(*G*, *S*). This is extremely
    efficient, as it makes signature verification essentially independent of the number
    of parties, as you can add points efficiently, whereas pairings are costly to
    compute. In addition to the computing efficiency, aggregating keys and signatures
    also saves memory.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Things Can Go
    Wrong</samp>
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like many elliptic curve cryptography schemes, BLS signatures should avoid invalid
    keys and weak parameters to be secure. And like the previous protocols, BLS signatures
    could be vulnerable to key cancellation attack. Let’s explore the details.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Invalid Keys</samp>
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: BLS signatures are specified in an Internet-Draft, a working document of the
    IETF available at *[https://<wbr>github<wbr>.com<wbr>/cfrg<wbr>/draft<wbr>-irtf<wbr>-cfrg<wbr>-bls<wbr>-signature](https://github.com/cfrg/draft-irtf-cfrg-bls-signature)*.
    This specifies core operations including key generation (the algorithm <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyGen</samp>),
    signature (<samp class="SANS_TheSansMonoCd_W5Regular_11">CoreSign</samp>), verification
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">CoreVerify</samp>), and key validation
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">KeyValidate</samp>). Given a public
    key, the latter ensures the validity of a public key in that it “represents a
    valid, non-identity point that is in the correct subgroup.”
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Key validation prevents the use of weak private/public keys pairs, for which
    signatures are easier to forge. For example, take the trivial case of a zero secret
    key *a* = 0\. It follows that the signature of any message *M* is 0 × **H**(*M*)
    = 0\. It’s therefore trivial to forge a signature for any message. In that case,
    the public key is then 0 × *G* = *O*, which is the point at infinity. If key validation
    rejects public keys equal to *O*, it ensures that the secret key is not zero.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: A less trivial case is when the public key, as an elliptic curve point, has
    a value that makes it easier to forge signatures—that is, to create a valid signature
    without knowing the private key. Not all points on a given elliptic curve are
    equally secure—in particular, points that belong to a small subgroup rather than
    to the main subgroup of points. If a public key point belongs to one such small
    subgroup, there will be way fewer possible valid signatures, making it easier
    to forge a signature. Likewise, if the public key offered to the verification
    function doesn’t belong to the elliptic curve, then valid signatures are easy
    to forge.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不那么简单的情况是，当公钥作为椭圆曲线点时，其值使得伪造签名更容易——也就是说，可以在不知道私钥的情况下创建有效的签名。并非所有的椭圆曲线上的点都同样安全——特别是属于小子群而非主子群的点。如果公钥点属于这样的小子群，那么可能的有效签名会少得多，从而使伪造签名变得更加容易。同样，如果提供给验证函数的公钥不属于椭圆曲线，那么有效签名也容易被伪造。
- en: It’s therefore crucial to check that public keys are valid using the <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyValidate</samp>
    algorithm from the aforementioned specification, as copied in [Listing 15-1](chapter15.xhtml#Lis15-1).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用上述规范中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyValidate</samp>
    算法检查公钥是否有效是至关重要的，正如 [清单 15-1](chapter15.xhtml#Lis15-1) 中所复制的那样。
- en: '[PRE0]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-1: The</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">KeyValidate</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">algorithm
    ensures that a BLS public key is valid.</samp>'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-1：该</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">KeyValidate</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">算法确保BLS公钥是有效的。</samp>
- en: If you implement BLS signatures, make sure your code does all the checks described
    in the BLS specification when validating public keys and signatures.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你实现BLS签名，确保你的代码在验证公钥和签名时执行BLS规范中描述的所有检查。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Key Cancellation Attack</samp>
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">密钥取消攻击</samp>
- en: 'In their basic form, BLS aggregate signatures with aggregate public keys are
    subject to the same type of key cancellation attack as Schnorr signatures: if
    an attacker knows the public keys *P*[1], *P*[2], . . . , *P*n – [1] of the first
    *n* – 1 signers, they can claim that their public key is'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在其基本形式中，带有聚合公钥的BLS聚合签名会受到与Schnorr签名相同类型的密钥取消攻击：如果攻击者知道前 *n* - 1 个签名者的公钥 *P*[1],
    *P*[2], . . . , *P*n – [1]，他们可以声称自己的公钥是
- en: '![](../images/pg315-1.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg315-1.jpg)'
- en: where *X* is the public key for which they know the private key *x*, such that
    *X* = *xG*. When the attacker presents a signature created from *x*, unsuspecting
    users verify a message’s signature using the public key *P*[1] + *P*[2] + . .
    . + *P*n, which is equal to *X*. The attacker can single-handedly sign a message
    on behalf of the set of supposed signers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *X* 是他们知道私钥 *x* 的公钥，满足 *X* = *xG*。当攻击者提供一个由 *x* 创建的签名时，毫不怀疑的用户使用公钥 *P*[1]
    + *P*[2] + . . . + *P*n 验证消息签名，这等于 *X*。攻击者可以单方面代表假定的签名者集合签署一条消息。
- en: To prevent this attack, users may prove the knowledge of their public key’s
    private key by signing a message. As the attacker doesn’t know the private key
    of *P*n, they would fail this test.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种攻击，用户可以通过签名消息来证明他们知道其公钥的私钥。由于攻击者不知道 *P*n 的私钥，他们会未能通过此测试。
- en: Another mitigation is to modify the aggregate signature scheme so that the returned
    signature isn’t just the sum of signature *S* = *S*[1] + *S*[2] + . . . + *S*n
    but instead the sum with coefficients derived from public keys, as in
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种缓解方法是修改聚合签名方案，使返回的签名不仅仅是签名的和 *S* = *S*[1] + *S*[2] + . . . + *S*n，而是通过从公钥派生的系数和，如下所示
- en: '![](../images/pg315-2.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg315-2.jpg)'
- en: where *t*i = **H**(*P*i || *P*[1] || *P*[2] || . . . || *P*n) for *i* = 1, 2,
    . . . , *n*. The aggregate public key used to verify a signature is then *P* =
    *t*[1]*P*[1] + *t*[2]*P*[2] + . . . + *t*n*P*n. You can see that this trick works
    by checking that *e*(*P*, **H**(*M*)) still equals *e*(*G*, *S*).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *t*i = **H**(*P*i || *P*[1] || *P*[2] || . . . || *P*n)，对于 *i* = 1, 2, .
    . . , *n*。然后用于验证签名的聚合公钥是 *P* = *t*[1]*P*[1] + *t*[2]*P*[2] + . . . + *t*n*P*n。你可以通过检查
    *e*(*P*, **H**(*M*)) 是否仍然等于 *e*(*G*, *S*) 来验证这个技巧。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Threshold Signature Protocols</samp>
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">门限签名协议</samp>
- en: '*Threshold signatures* differ from multisignatures and aggregate signatures—which
    require all participants in the signing protocol to have their own public and
    private key—in that there’s a single private key *k* and a single public key *P*,
    and there are *n* participants that each has a distinct *share* of the key *k*i
    where a parameter *t* (the *threshold*) is defined such that *t* < *n* and:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '*t* + 1 signers can jointly issue a valid signature of some message that is
    verified using the public key *P*, in such a way that no signer learns the private
    key *k*. This is done by running a protocol that uses the shares *k*i of each
    signer and the message to be signed, without ever exposing the private key to
    any party.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of *t* signers or fewer can’t create a signature and therefore can’t determine
    the private key *k* either.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The issued signature looks like a normal, single-signer signature and verifies
    as such.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Threshold signatures are a specific type of *multiparty computation (MPC)*,
    a class of protocols wherein *n* participants compute the output of some function
    *f*(*x*[1], *x*[2], . . . , *x*n) such that each participant knows their respective
    input *x*i and learns the output of the function but doesn’t learn the other participants’
    *x*i inputs. In the case of threshold signatures, the *x*is are shares of the
    private key, and the output is a signature. I’ll elaborate on what a share is
    in the “Secret-Sharing Techniques” section on [page 319](#sec38).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Threshold signatures have the benefit of “hiding” the number of co-signers and
    their identities, as verifiers see only a signature from a single private key.
    While some multisignature and aggregate signature schemes share this property,
    threshold signatures better suit the use case of crypto asset custody because
    there’s only one private key and one public key; you can directly apply threshold
    signatures to distribute control of any address.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Use Cases</samp>
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Threshold signatures are used in cryptocurrency and digital asset management
    to distribute control of an address across multiple systems or parties. They can
    serve to share control of an account between a service provider and a user’s device:
    each party has one share of the key and must run a protocol together to sign a
    transaction, thus spending funds. This setup ensures that an attacker can’t autonomously
    authorize transactions, even if they breach the user’s device and obtain the key
    shares. Similarly, the provider can’t initiate transactions without the user’s
    consent. However, implementing this model reliably poses challenges, particularly
    key management aspects (key generation, key rotation, backups, and so on).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: An organization can also use threshold signatures to distribute custody of funds
    across multiple systems, such as different device types, data centers, operating
    systems, and software components. This approach is particularly suitable for cold
    wallets and accounts containing significant assets. Relying solely on threshold
    signatures is insufficient, as comprehensive security measures and controls are
    crucial. For example, one must properly separate accesses to IT components to
    ensure that distinct individuals or IT service providers have access to different
    systems (thus different shares). Moreover, the initiation and approval of transactions
    must be subject to strict controls and an audit trail.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Model</samp>
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As with all cryptographic protocols, we need to define what it means for a threshold
    signing scheme to be secure. Such a security model includes the security goal
    (what should be hard for an attacker to do) and the attacker model (the assumptions
    about the attacker’s capabilities). Let’s delve into these two characteristics.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security Goals</samp>
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The main security goal of threshold signature is the same as that of single-party
    signatures: an attacker must not be able to forge valid signatures, which implies
    they must not be able to determine the private key. This also implies that the
    protocol ensures *input privacy*: the key shares held by the parties shouldn’t
    leak to any other party. Finally, the protocol must ensure *correctness*: the
    signature the protocol computes must be valid and accessible to all participants
    in the protocol execution.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Attacker Models</samp>
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There isn’t one security model for threshold signatures; instead, an attacker
    is characterized according to several dimensions. The common threat in all attack
    scenarios is the assumption that an attacker can actively attack network communications—capturing,
    modifying, and injecting messages. Using a secure channel to establish authenticated
    and encrypted communications between the parties thwarts such attacks. Protocol
    designers also assume reliable communications in that all transmitted messages
    should be received in the same order they were sent.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The attacker model of threshold signatures considers the *corruption* of participants—namely,
    that an attacker compromises their system, learns their secrets, and essentially
    gets them to do what they want. The model assumes that an attacker can’t corrupt
    more than *t* parties; otherwise, they’d be able to forge signatures, by definition
    of the threshold signing functionality.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine the parameters to consider when an attacker can corrupt participants.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we characterize an attacker by the *number of parties* they could corrupt.
    Two categories of threshold signatures exist, each defined by the maximum number
    of malicious participants that can be compromised without compromising the security
    of the protocol:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '**Honest majority **Here, the attacker is limited to corrupting less than half
    of the key-sharing parties. Therefore, the threshold *t* must satisfy *t* < *n*/2\.
    By definition, a threshold signing protocol with parameters (*t*, *n*) must be
    safe even with compromised *t* participants. Protocols designed under the honest
    majority assumption are typically more efficient, but they can’t accommodate arbitrary
    values of *t*. For instance, a protocol with parameters (4, 5) is infeasible in
    this model, as it requires tolerating up to four corrupted parties.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '**Dishonest majority **This model allows the protocol to support any value
    of *t* from 1 to *n* – 1\. It enables the creation of protocols where all but
    one of the *n* parties could be corrupted, yet the malicious parties would still
    be incapable of forging signatures or recovering the private key. This model offers
    more flexibility in terms of the threshold value but often requires more complex
    and robust security mechanisms.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'We also characterize an attacker by what they can do once they corrupt a party
    and learn their secret values (including the key share). There are two attacker
    models defining this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '**Passive, or honest-but-curious **They learn information from corrupted parties
    but can’t force them to deviate from the protocol. This models “read-only” compromises,
    where an attacker gets a snapshot of a system’s memory, both storage and volatile
    memory (RAM, processor registers).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '**Active, or malicious **Parties may arbitrarily deviate from the prescribed
    protocol. This models systems fully compromised by an attacker or controlled by
    a malicious insider (such as an operator, administrator, or cloud provider).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: A protocol secure against active attackers is therefore always secure against
    passive attackers, but not the other way around.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways for an attacker to choose which parties to corrupt, which
    are defined by the following models of corruption type:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '**Static corruption **The attacker must choose which participants to corrupt
    before starting the protocol.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '**Adaptive corruption **The attacker may wait until after the protocol begins
    to choose which participants to corrupt—and then learn the history of their operations
    throughout the protocol.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: A protocol secure against static corruption is always secure against adaptive
    corruption, but not the other way around. However, there are techniques to convert
    a protocol from secure against static corruption to secure against adaptive corruption.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Secret-Sharing
    Techniques</samp>'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: A key ingredient of threshold signatures is *secret-sharing* protocols, or techniques
    that split a secret into multiple pieces (*shares*) distributed to different parties
    in a way that the parties can then jointly recompute the initial secret. Secret-sharing
    protocols can notably be used when creating backups of private keys such that
    different parties store different shares in different locations.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Additive Sharing</samp>
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The simplest way to share a secret that you see as a number is through *additive
    sharing*: given a number *s*, you share it as *n* values *s*[1], *s*[2], . . .
    , *s*n such that *s*[1] + *s*[2] + . . . + *s*n = *s.* For example, if you work
    with numbers modulo 100, you could create a random additive sharing of the number
    *s* = 47 into four shares as follows: pick three random numbers between 0 and
    99, say *s*[1] = 12, *s*[2] = 94, and *s*[3] = 80, and set *s*[4] = *s* – *s*[1]
    – *s*[2] – *s*[3] = 61\. (Note that subtraction is computed modulo 100, such that
    –1 = 99, –2 = 98, and so on.)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: This approach is very simple but requires using all the shares to recover the
    original secret.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Threshold Sharing</samp>
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Threshold sharing is closer to what threshold signatures do: given parameters
    *n* and *t* < *n* and the secret *s*, it creates shares such that you can recover
    the secret using any set of *t* shares out of the *n* created.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'The best-known threshold sharing method is *Shamir’s secret sharing*, which
    leverages the following property of polynomials: given a polynomial of degree
    *t* of the form'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg319-1.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: you need the result of only *t* + 1 evaluations of *f*(*x*) on *t* + 1 distinct
    values of *x* to determine all *a*i coefficients, which are fixed values.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: To create a threshold secret sharing from this property, set *a*[0] = *s*, the
    secret. Then pick random values of *a*[1] to *a*t and compute *f*(*x*) for *n*
    distinct values of *x*, which will be the *n* shares of the secret.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Recomputing the coefficients from the *f*(*x*) values is a technique called
    *Lagrange interpolation*, from the 18th-century Italian mathematician who developed
    a general method to determine the equation of a curve given a list of points on
    that curve. Indeed, you can view the problem geometrically. If the equation has
    degree 1 (and is of the form *a*[0] + *a*[1]*x*), then it’s the equation of a
    line, and knowing two points on a line is sufficient to uniquely identify the
    line. Likewise, if the equation has degree 2 (of the form *a*[0] + *a*[1]*x* +
    *a*[2]*x*²), then the curve is a parabola, whose equation can be determined with
    three points.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: We sometimes find implementations of Shamir’s secret sharing defining a function
    **Lagrange**() that computes the interpolation and returns the *a*[0] coefficient,
    which is the shared secret. If you have values of *f*(*x*) to combine to recover
    the secret, you can define the operation **Lagrange**(*s*[1], *s*[2], . . . ,
    *s*t) returning the shared secret *s*. This works for any combination of *t* distinct
    shares, not necessarily the first *t* ones. The details of the **Lagrange**()
    operation are a bit too technical for this book, but you can implement it as a
    series of basic additions, multiplications, and inverses.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Trivial Case</samp>
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One of the simplest types of threshold signature uses the BLS signature, as
    viewed earlier in the context of aggregate signatures. Recall that given a private
    key *k*, BLS signatures compute a signature by multiplying *k* with the curve
    point *H* = **H**(*M*). You can use additive sharing to create a threshold scheme
    with parameters (*n* – 1, *n*). For example, if *n* = 3, split the key into three
    shares such that *k*[1] + *k*[2] + *k*[3] = *k*. Each party then computes their
    share of the signature by multiplying their share *k*i with *H*. Adding the three
    shares then yields the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg320-1.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: Combining the three shares via addition gives a valid signature with *k*, even
    if none of the parties knows *k*. The parties could also recover *k* if they add
    their respective shares, but adding the shares of two parties reveals no information
    on *k* if the shares were randomly generated.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a threshold signature scheme with arbitrary *t* and *n*, use the
    Shamir secret-sharing technique and leverage the linearity of the **Lagrange**()
    operation: you generate the key shares *k*i as described in the “Threshold Sharing”
    section and compute the signature like so:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg320-2.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: Again, you obtain a valid signature with the key *k*.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Simple Case</samp>
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll now compute Schnorr signatures in the threshold setting, which is a
    bit more technical than with BLS signatures. Recall the Schnorr scheme computes
    a signature as *s* = *r* + *ha*, where *h* = **H**(*R* || *A* || *M*), *r* is
    the per-signature random nonce, and *a* is the signer’s private key. The signature
    also includes *R* = *rG*, the public nonce value. This is relatively easy to turn
    into a threshold signature scheme, owing to its linearity with respect to secret
    values: observe that the secret *r* is added to the secret *a* multiplied by the
    hash *h*, which is not secret.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine the simplest case of two signers, with an additive sharing of the private
    signing key *k* = *a* + *b*, with *a* and *b* the respective key shares of the
    two signers. To sign, the two parties could generate secret nonces *r*[A] and
    *r*[B], with respective public values *R*[A] = *r*[A]*G* and *R*[B] = *r*[B]*G*.
    The parties can then exchange these values and compute the public nonce *R* =
    *R*[A] + *R*[B], which will be part of the signature. *R* is then the public value
    you derive from the private value *r* = *r*[A] + *r*[B], since you have:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg320-3.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: 'Next, the parties compute their shares of the signature: *s*[A] = *r*[A] +
    *ha* and *s*[B] = *r*[B] + *hb*, which are added together to yield:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg321-1.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: You thus obtain *r* + *hk*, a signature from the key *k*, even though participants
    used only the additive shares *a* and *b* in their computations. To obtain a threshold
    construction for arbitrary parameters *t* and *n*, Shamir’s secret sharing can
    be used instead of additive sharing.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The previous construction isn’t secure enough to satisfy all the security requirements
    of a threshold signing scheme. It’s notably vulnerable to key cancellation attacks
    unless participants *commit* to their nonces in a preliminary phase of the protocol—for
    example, by sending the hash of their nonce. It also has a number of subtle vulnerabilities
    addressed by the protocol Flexible Round-Optimized Schnorr Threshold (FROST) signatures,
    designed by cryptographers Chelsea Komlo and Ian Goldberg in 2020 and documented
    at *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2020<wbr>/852](https://eprint.iacr.org/2020/852)*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The EdDSA signature protocol from [Chapter 12](chapter12.xhtml) is similar
    to Schnorr’s signatures but computes the nonce as a hash from the message, rather
    than as a random, arbitrary value. This complicates the creation of threshold
    signature protocols compliant with the original EdDSA specification.*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Hard Case</samp>
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The hardest signature scheme to run in a threshold setting is also the most
    common. The ECDSA signature algorithm (see [Chapter 12](chapter12.xhtml)) is more
    complex than Schnorr signatures and EdDSA because it involves a division. Given
    a message hash *h* = **H**(*M*), the signer picks a random number *k*, computes
    the number *r* from the point *kG*’s coordinates, and computes the signature as
    *s* = (*h* + *ra*) / *k*, where *a* is the private key of the signer.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Efficient and secure ECDSA threshold signatures remain a challenging research
    problem among cryptographers. The first practical protocols appeared in the late
    2010s, motivated by the use case of cryptocurrency—most of the leading cryptocurrencies,
    including Bitcoin and Ethereum, then supported only ECDSA as a transaction signing
    scheme.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographers devised several approaches to build ECDSA threshold signing protocols.
    For example, Yehuda Lindell’s 2017 “Fast Secure Two-Party ECDSA Signing” (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2017<wbr>/552](https://eprint.iacr.org/2017/552)*)
    required a commitment scheme, homomorphic encryption scheme, and zero-knowledge
    proof system. The complexity of such protocols complicated their understanding,
    implementation, and security analysis, leading to a number of security flaws in
    deployed systems.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Things Can Go
    Wrong</samp>
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Specific security issues in threshold signature protocols are often complex
    and involve details of cryptographic constructions that I haven’t covered in this
    book. Therefore, instead of specific problems, I’ll discuss categories of problems
    that impacted real deployments of threshold signatures, from widely used open
    source software to commercial solutions.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Papers vs. Code</samp>
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When engineers need to implement a threshold signature protocol from their
    research papers, they encounter challenges. These papers, primarily aimed at cryptography
    researchers, often vary in editorial quality and are complicated, heavy in mathematics,
    and quite new. This recency can mean that an experimental protocol might not be
    as secure as intended. These factors contribute to a range of real-world security
    issues, which can be categorized into four main areas:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '**Insecure protocol **If the protocol isn’t secure on paper, it won’t be more
    secure in implementation. Common issues include overlooked edge cases or inadequate
    validation when receiving inputs from other parties. For example, some protocols
    failed to verify if an encrypted number falls within the expected range, leading
    to practical attacks.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '**Incomplete description **Research papers aren’t technical specifications
    but are written for academic audiences, so they often lack practical implementation
    details like networking and encoding. A notable example is the TSSHOCK attack
    on threshold signatures, which exploited ambiguous encoding in a hash function’s
    input elements, as described in “Collisions from Domain Separation Failures” on
    [page 305](#sec13).'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '**Incomplete implementation **The complexity of threshold signing protocols,
    with their numerous subcomponents and detailed requirements, can lead to overlooked
    security validations, particularly if these are mentioned only in appendixes.
    An instance of this was when a protocol required a number *N* = *pq* (for Paillier
    encryption) to be verified as the product of two large enough primes via a zero-knowledge
    proof, but this verification was omitted in the implementation, allowing insecure
    *N* values.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '**Insecure component choice **Descriptions of protocols usually don’t say “use
    the hash function BLAKE3” or “use the 256-bit elliptic curve nistp256”; instead,
    they say “use a hash function and an elliptic curve that offer the security level
    you need.” It’s thus up to the implementers to pick suitable primitives and use
    their programming interfaces securely. For example, using an RSA modulus of 1,024
    bits isn’t enough to ensure 128-bit security.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, risks arise when implementers intentionally modify a protocol,
    perhaps to enhance efficiency or fit a specific use case. This usually doesn’t
    end well. For examples of attacks on threshold signatures, see the papers “Alpha-Rays:
    Key Extraction Attacks on Threshold ECDSA Implementations” by Dmytro Tymokhanov
    and Omer Shlomovits (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2021<wbr>/1621](https://eprint.iacr.org/2021/1621)*)
    and “Practical Key-Extraction Attacks in Leading MPC Wallets” by Nikolaos Makriyannis,
    Oren Yomtov, and Arik Galansky (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2023<wbr>/1234](https://eprint.iacr.org/2023/1234)*).'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Key Management Aspects</samp>
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A friend once remarked, “For every 10 lines of encryption code, there are 1,500
    lines of key management,” which emphasizes the criticality and intricacy of key
    management processes, including key creation, storage, backup, and recovery. While
    these facets may be overlooked in academic papers focusing on theoretical aspects,
    they’re vital in practical applications. Engineers and security professionals
    implementing threshold signing in a production environment must prioritize these
    key management issues—even the most robust threshold signature protocols are no
    substitute for comprehensive key management practices.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review the main key management considerations for an organization employing
    threshold signatures to safeguard substantial cryptocurrency holdings:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '**Key generation **Whether you’re using distributed key generation or centralized
    generation, you must ensure that the secret values aren’t exposed to unauthorized
    systems or parties during or after the key generation. This assurance is generally
    provided through rigorous processes such as key ceremonies, ensuring supply-chain
    integrity and audit trail, to demonstrate that keys have been generated properly.
    Don’t allow another party (such as a cloud provider) to generate keys on your
    behalf or to have the capability to read them at any time.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '**Key storage **Storing a key as multiple shares instead of a single value
    doesn’t diminish the necessity for secure storage. Safeguarding numerous secrets
    across diverse platforms can present more of a challenge than protecting a single
    secret on a unified platform. Key shares must be stored in some type of secure
    memory, protected against unauthorized access, tampering, and physical attacks.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '**Key backup and recovery **Implementing a threshold scheme where, for instance,
    you require three out of six shares to sign a transaction, protects against the
    loss of key shares or system outages. Nevertheless, this doesn’t negate the necessity
    for key backups, which you should also maintain as threshold shares. It’s imperative
    to distribute access to these backup shares among distinct parties. Additionally,
    validate the reliability of backups periodically to ensure they haven’t been compromised
    and can be effectively utilized to reconstruct the key when necessary, such as
    during disaster recovery drills.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Zero-Knowledge Proofs</samp>
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Zero-knowledge proofs (ZKPs)* are one of cryptographers’ most powerful tools.
    These are protocols between two parties, a *prover* and a *verifier*, where the
    prover convinces the verifier that something is true without revealing anything
    about why. For example, the prover could prove that they know a solution to some
    hard computational problem without revealing the solution. You might create a
    ZKP for any **NP**-complete problems to prove you know a solution without revealing
    it.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: More generally, ZKPs are used to prove a statement, such as “the number encrypted
    in this ciphertext is between 100 and 200” or “for a given plaintext *P* and ciphertext
    *C*, I know a secret key *K* for which *C* = **AES**(*K*, *P*).”
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: For a non-technical introduction to zero-knowledge proofs, I recommend cryptographer
    Amit Sahai’s video “Computer Scientist Explains One Concept in 5 Levels of Difficulty”
    (*[https://<wbr>youtu<wbr>.be<wbr>/fOGdb1CTu5c](https://youtu.be/fOGdb1CTu5c)*).
    For mathematical details, see the links on *[https://<wbr>github<wbr>.com<wbr>/matter<wbr>-labs<wbr>/awesome<wbr>-zero<wbr>-knowledge<wbr>-proofs](https://github.com/matter-labs/awesome-zero-knowledge-proofs)*.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The term* zero-knowledge proof *is a simplification of more accurate terms
    from the research literature. For example, many “zero-knowledge proof” protocols
    are in fact* zero-knowledge arguments of knowledge*. Researchers reserve the term*
    proof *for unconditional security and use* argument *for computational security.
    Furthermore, the term* witness *refers to the secret allowing the prover to prove
    its statement, as a generalization of* secret *or* secret key*, due to its broader
    scope.*'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Model</samp>
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What does it mean for a ZKP protocol to be secure? Is the attacker the prover
    or the verifier? How can they attack the protocol? Let’s answer these questions
    by examining security goals and attacker models.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security Goals</samp>
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A secure ZKP must satisfy the following notions:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '**Completeness **If the prover follows the protocol using the correct secret,
    an honest verifier is convinced of the truth of the statement. In other words,
    the protocol always works.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '**Soundness **If the prover doesn’t know the secret, they can’t convince the
    honest verifier of a false statement (except with negligible probability). In
    other words, provers can’t cheat.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '**Zero-knowledge **A verifier learns nothing beyond the fact that the statement
    is true. Specifically, they can’t learn anything about the prover’s secret.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: The notion that a verifier “will be convinced of the truth of the statement”
    is guaranteed by the mutual agreement that the protocol satisfies these three
    properties—namely, that a prover could not complete the protocol if the statement
    was false (for example, if they didn’t know the solution they claim to).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Attacker Models</samp>'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'Both parties can potentially be attackers attempting to compromise soundness
    and zero-knowledge, respectively:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '**Malicious provers **Want to prove a false statement—for example, to wrongly
    convince the verifier that they know a solution to some hard problem. Such an
    attacker can deviate from the protocol to try to fool the verifier. In practice,
    this is the greatest threat to ZKPs in applications like confidential program
    execution.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '**Malicious verifiers **Want to extract information about the secret (the *witness*),
    thereby breaking the zero-knowledge property. Attacker models distinguish *passive*
    verifier attackers (honest-but-curious) and *active* verifier attackers (who can
    arbitrarily deviate from the protocol).'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Note that malicious verifiers can challenge completeness by claiming they aren’t
    convinced by the truth of a statement. In practice, this isn’t an issue, as the
    prover can repeat the proof protocol for other (honest) verifiers who would expose
    the lying verifier.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Schnorr’s Protocol</samp>
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Claus-Peter Schnorr, who created the eponymous signature scheme, also described
    a similar construction that is a zero-knowledge *proof of knowledge of a discrete
    logarithm*. It’s the basis for Schnorr’s and EdDSA signatures, as well as for
    many more complex ZKPs.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Schnorr’s protocol works in three steps to prove the knowledge of *a* such
    that *aG* = *A*—that is, the discrete logarithm of *A* with respect to the generator
    *G*:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '1.  *Commitment*: The prover picks a random number *r* and sends *R* = *rG*.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '2.  *Challenge*: The verifier sends a random number *c*.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '3.  *Response*: The prover sends *s* = *r* + *ca*, and the verifier accepts
    if and only if *sG* = *R + cA*.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This kind of three-step protocol, with a commitment, a challenge, and a response,
    is called a* sigma protocol*, after the shape of the uppercase Greek letter sigma
    (Σ).*'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'The *completeness* of Schnorr’s protocol is the easiest to verify: if *a* satisfies
    *aG* = *A*, you’ll have'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg325-1.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
- en: which is the prover’s validation condition.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: To see that the protocol ensures *soundness*—that the prover must know *a*—imagine
    that the prover uses the same *r* twice in two runs of the protocol. The verifier
    thus gets two responses, *s*[1] = *r* + *c*[1]*a* and *s*[2] = *r* + *c*[2]*a*,
    for the two distinct challengers *c*[1] and *c*[2]. Now they can compute
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg326-1.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
- en: and divide the result by (*c*[1] – *c*[2]) to obtain *a*. Since the check that
    *sG* equals *R* + *cA* ensures that you had *s* = *r* + *ca*, it follows that
    the prover must know *a* when executing this protocol correctly. This kind of
    logical reasoning is called a *knowledge extractor*, and it’s the main technique
    to show that a ZKP is sound.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: The protocol can also be proved to be zero-knowledge, using a technique called
    a *simulator*, an algorithm that creates messages (or a *transcript of communication*)
    that are indistinguishable from those in a real execution of a zero-knowledge
    proof. However, unlike a real prover, the simulator doesn’t necessarily know the
    secret (or witness) being proven. Despite this, the messages it generates still
    appear valid and convincing to the verifier in the context of the proof system.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: In Schnorr’s protocol, the simulator works backward and first chooses a random
    response, *s*, to show that a real *s* will be “as random” as a purely random
    one. Then it picks a random challenge *c* and computes the original commitment
    as *R* = *sG* – *cA*. The proof that the protocol is zero-knowledge then demonstrates
    that these three values are indistinguishable from those of a real execution of
    a protocol yet don’t require the knowledge of the secret *a*. (Note that in Schnorr’s
    case, you must assume that the verifier follows the protocol and picks a random
    *c*.)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Noninteractive Proofs</samp>
  id: totrans-332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Schnorr’s protocol is *interactive*: the prover sends a first message, the
    verifier responds with a challenge, and the prover sends them a response—the parties
    interact over three rounds of messages. But what if the verifier can’t send messages
    and just wants to receive a single message that convinces them? How can one create
    such *noninteractive* proofs from an interactive protocol?'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take another look at the Schnorr protocol, wherein the verifier sends
    a random challenge *c*, a value that must be unpredictable to the prover. If the
    prover knows *c* before sending *R*, they can cheat, as follows: given *c*, choose
    some arbitrary value for *s*, and compute *R* = *sG* – *cA*; then send this *R*
    to the verifier, and send *s* as a response to *c*. Verification succeeds, yet
    the prover didn’t need to use the secret value *a*.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: How do you make *c* unpredictable to the prover without interacting with a verifier?
    The trick is to derive *c* from *R* using a hash function, which prevents the
    prover from finding a pair (*R*, *c*) that satisfies *sG* = *R* + *cA* due to
    the pseudorandom behavior of hash functions.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a *noninteractive zero-knowledge (NIZK)* proof of knowledge of
    the secret *a* using Schnorr’s protocol, a prover proceeds as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '1.  *Commitment*: The prover picks a random number *r* and computes *R* = *rG*.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '2.  *Challenge*: The prover computes *c* = **H**(*G* || *R* || *A*); you must
    include the values *G* and *A* to bind the *c* generation to the generator parameter
    *G* and to the public key *A* of the prover.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '3.  *Response*: The prover computes *s* = *r* + *ca* and generates the proof
    as an encoding of *R* and *s*.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: To verify a proof (*R*, *s*) received from the prover with public key *A*, a
    verifier recomputes the challenge *c* = **H**(*G* || *R* || *A*) and checks the
    equality if *sG* = *R* + *cA*.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: The trick in hash function protocol data to replace verifier-generated challenges
    was formalized by the *Fiat–Shamir transform*, a general technique to turn an
    interactive protocol into a noninteractive one. For this transform to be applicable,
    a verifier’s random challenges must be independent of the prover’s message and
    be public (nonsecret) values.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">zkSNARKs</samp>
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s talk about the kind of zero-knowledge proof that’s seen wide adoption
    in blockchain applications due to its power and efficiency. For example, zkSNARKs
    are the cornerstone of the Zcash confidential transaction platform: in Zcash,
    zkSNARKs prove that a certain amount has been deducted from an account and credited
    to another account, without revealing the amount of the accounts and without leading
    to a prohibitively large amount of computation or storage.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'A *zkSNARK* is a type of noninteractive proof of knowledge that offers the
    zero-knowledge (*zk*) property, where *SNARK* stands for the following:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '**Succinct **The proof is very small compared to the size of the statement
    and the secret. It may be similar in size to the statement size’s logarithm, or
    even of *constant size*—always of the same size regardless of the statement’s
    size.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '**Noninteractive **A SNARK is a noninteractive argument of knowledge, typically
    using the Fiat–Shamir transform to turn an interactive protocol into a noninteractive
    one. It doesn’t need the verifier to send messages to the prover.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '**Argument **The *argument* of knowledge is a computationally secure proof
    that is conditionally secure. In other words, it wouldn’t be secure against an
    attacker with infinite computing power, which is generally a tolerable limitation.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '**Of knowledge **A SNARK offers completeness and soundness, as an argument
    of knowledge.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: In addition, proving and verifying a zkSNARK must be computationally efficient.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Generating such a succinct proof when you want to prove the knowledge of a solution
    to a problem whose description doesn’t even fit in the proof size sounds counterintuitive.
    For example, what about statements like “I know a solution to the equation *f*(*x*)
    = 0,” when the equation *f*(*x*) can be of arbitrary size? From a theoretical
    perspective, short proofs make sense because the only information a proof must
    convey is the *knowledge* of some solution and generally the *correctness* of
    some statement, as opposed to the actual solution and secrets; the proof must
    be zero-knowledge and reveal only that information to the verifier.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: In 2016, cryptographer Jens Groth published the article “On the Size of Pairing-Based
    Non-interactive Arguments” (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2016<wbr>/260](https://eprint.iacr.org/2016/260)*),
    which describes an exceptionally efficient zkSNARK. The proof consisted of only
    three group elements and could be verified by computing three pairing operations
    (the same type of pairing as with BLS signatures). The Zcash protocol adopted
    this breakthrough result, which laid the foundation for several other zkSNARKs.
    Groth’s zkSNARK is usually just called *Groth16*.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">From Statements to
    Proofs</samp>
  id: totrans-352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: zkSNARKs are some of the most complex cryptographic constructions, with one
    of their most complex and costly steps being *arithmetization*, an operation that
    converts the statement to prove into a fixed number of polynomial equations, which
    are generally of the form
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg328-1.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
- en: for a polynomial of degree *n*, where the coefficients *a*i are elements of
    some finite ring or finite field structure. The proving algorithm then processes
    the polynomials to create the zkSNARK proof.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Arithmetization follows a general workflow:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Describe the statement to prove using formal notations, such as a computer
    program, equations, or logical formulas.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Transform the formal expression from step 1 into a *circuit*, which defines
    an output from input values by applying a sequence of *gates* to the input, similar
    to logical gates in a Boolean or electronic circuit, except that the gates may
    be algebraic operations such as addition and multiplication.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Turn the circuit into a structured list of *constraints*, according to the
    zkSNARK proof system’s constraint system. Such constraints are lists of conditions
    that the input must fulfill to satisfy the statement to prove.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'The statement to prove may be as trivial as “I know integer *x* and *y* satisfying
    the equation *x*³ + *y*² + *xy* + 55 = 0 mod 57.” This completes step 1 by having
    a formal equation expressing the problem. To complete step 2, you may break down
    the equation as a sequence of simple operations involving two operands (Groth16
    requires this). This works as follows, where you write the intermediate values
    *v*[0], *v*[1], . . . , *v*[6]:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Set *v*[0] = *x* × *x*.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Set *v*[1] = *x* × *v*[0]; thus *v*[1] = *x*³.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Set *v*[2] = *y* × *y*.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Set *v*[3] = *x* × *y*.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Set *v*[4] = *v*[1] *+ v*[2].
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Set *v*[5] = *v*[4] *+ v*[3].
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Set *v*[6] = *v*[5] + 55; thus *v*[6] = *x*³ + *y*² + *xy* + 55.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Such a translation of a long equation into a series of small ones is called
    *flattening*.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: The prover then converts these operations—the circuit—into a set of mathematical
    structures that serve to construct the polynomials processed by the prover. The
    long polynomials are finally “compressed” into a proof using randomness, specifically
    the concept of *probabilistically checkable proof (PCP)*, which is a major discovery
    from the field of complexity theory. This convinces a verifier that many constraints
    are satisfied with only a few actual constraint checks, while preserving the zero-knowledge
    property.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about the intricacies of arithmetization, research the two main
    approaches used by zkSNARKs: rank-1 constraint systems (R1CS) and algebraic intermediate
    representations (AIR).'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, note that we distinguish *nonuniversal* and *universal* zkSNARK proof
    systems: in the former, the prover works for a specific, predefined statement.
    In particular, the setup phase of the proof system creates parameters suitable
    only to a given statement. However, universal proof systems such as Marlin and
    Plonk take as input a statement and create a proof for it. They’re more flexible
    but also more complex to construct and have higher computation overhead.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Things Can Go
    Wrong</samp>
  id: totrans-372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: zkSNARKs can suffer from the same classes of problems as in the context of threshold
    signatures, from an insecure protocol to implementation flaws. Security issues
    can arise at different stages of the workflow, from the statement definition to
    the arithmetization step and the proof computation. The security notion impacted
    may be completeness, soundness, or zero-knowledge. But most of the time, the greatest
    risk concerns soundness, or the possibility of an attacker to cheat and fool a
    verifier—both because of the potential impact on the application and the subtlety
    of soundness bugs, whereas a leak of “knowledge” is less likely, especially if
    the proof must remain a valid one accepted by a verifier.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: In the forthcoming examples, we’ll focus on Schnorr’s protocol. The problems
    are relatively simple, but more complex proof systems can have much subtler issues.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Recall that Schnorr’s noninteractive protocol proves the knowledge of *a* to
    a verifier that knows *A* = *aG* by sending a verifier *s* = *r* + *ca* and *R*
    = *rG* for a random *r* and *c* = **H**(*G* || *R* || *A*). The verifier then
    checks the equality *sG* = *R* + *cA* after recomputing *c*. In the interactive
    version, the verifier chooses *c* randomly.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Insufficient Fiat–Shamir
    Hashing</samp>'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that instead of *c* = **H**(*G* || *R* || *A*), a noninteractive Schnorr
    proof did *c* = **H**(*G* || *A*), making the challenge *c* independent of the
    nonce *R*. The attacker then picks an arbitrary value for *s* and computes *R*
    = *sG* – *cA*. The resulting proof consisting of *s* and *R* is valid, yet the
    attacker didn’t need to know *a*, thereby breaking the protocol’s soundness.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, if *c* = **H**(*G* || *R*), omitting the public key *A* from the
    data hashed to define the challenge *c*, an attack is possible: the attacker can
    now choose arbitrary *R* and *s* values and compute the point *B* = (1/*c*) ×
    (*sG* – *R*), which satisfies *sG* = *R* + *cB*. This gives the attacker a proof
    of knowledge of the discrete logarithm of *B*—namely, *b* such that *B* = *bG*—whereas
    they don’t know it.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: These attacks illustrate the importance of including all necessary values in
    the hash function input when using the Fiat–Shamir transform to make a protocol
    noninteractive.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Replay Attacks</samp>
  id: totrans-380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A replay is a trivial but potentially devastating attack. If an attacker learns
    the value of some noninteractive proof of knowledge, they can send it to another
    party and say they created it, claiming the credit for the knowledge proven.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: You may avoid this by binding the proof to the identity of the prover, including
    their public key in the data hashed. To prevent replay by the same party over
    time, you may bind the proof to a session identifier or timestamp by including
    such values in the data processed by the Fiat–Shamir hashes.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Randomness Reuse</samp>
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consider the interactive Schnorr protocol, where the verifier picks a random
    *c*. If the prover has a flawed pseudorandom generator and reuses the same challenge
    *r* twice, then an attacker observing the exchanged values can recover the secret
    *a* by using the two proofs *s*[1] = *r* + *c*[1]*a* and *s*[2] = *r* + *c*[2]*a*
    for two distinct challengers, *c*[1] and *c*[2], and computing *a* = (*s*[1] –
    *s*[2]) / (*c*[1] – *c*[2]).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Really Serious Crypto</samp>
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With this final chapter, we’ve reviewed some of the most captivating topics
    in cryptography at the time of writing, from both theoretical and practical viewpoints.
    We’ve touched only the surface, though, particularly in the realm of zero-knowledge
    proof systems, an active research and engineering space with extensive applications
    beyond blockchain technology. But cool cryptography isn’t the panacea of blockchains.
    From multiparty computation protocols such as private set intersection (PSI) to
    homomorphic encryption used for private evaluation of AI models, new applications
    and use cases call for better, faster cryptographic functionalities.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: We’re witnessing a golden age in cryptography, with an unprecedented convergence
    of theoretical principles and practical applications. This synergy is providing
    almost magical solutions to some of the most daunting security and privacy problems.
    Nonetheless, significant challenges need to be addressed, particularly in the
    legal and regulatory spheres. It’s imperative that technologists and policymakers
    collaborate closely to navigate these challenges and that both attempt to understand
    each other’s perspectives. It is my hope that this book, and particularly this
    last chapter, contributes to demystifying cryptography and making it more accessible
    and less enigmatic for all its readers.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
