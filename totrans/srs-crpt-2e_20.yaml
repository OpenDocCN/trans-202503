- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CRYPTOCURRENCY
    CRYPTOGRAPHY</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter wasn’t in the initial edition of this book when it came out in
    fall 2017, a period when cryptocurrency and blockchain were at peak hype. While
    blockchain hasn’t quite lived up to its promises of disrupting several industries,
    it has profoundly influenced cryptographic research and engineering. Blockchain
    applications have brought new exciting problems, attracted fresh talent, and offered
    a novel way to bridge theory and practice.
  prefs: []
  type: TYPE_NORMAL
- en: Before “crypto” became synonymous with cryptocurrency, cryptographic algorithms
    and protocols largely pertained to standard functionalities such as encryption
    and secure channels. The more arcane protocols were restricted to niche research
    areas and technical articles, typically catering to researchers’ interests and
    presented only in academic conferences. New algorithms were predominantly crafted
    by academic researchers and would see real-world deployment, if ever, after at
    least five years of peer review and analysis and after numerous research papers
    detailing unsuccessful cryptanalysis attempts.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain turned that process upside down. Much like how the cryptographic
    protocols of Signal and Tor sidestepped the conventional academic route, blockchain
    enthusiasts were less bound by tradition. Groundbreaking protocols often debuted
    in blog posts or informal white papers, with implementation following shortly
    after. Occasionally, they’d forgo written specifications altogether, letting the
    code speak for itself. Only after widespread adoption would academia take notice.
    The most notable case is the Bitcoin protocol, which didn’t undergo formal peer
    review before being deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Many seasoned researchers identified novel challenges within the blockchain
    domain, often collaborating directly with blockchain entities. They developed
    complex protocols that not only pushed boundaries and garnered peer recognition
    but also saw rapid real-world implementation, impacting thousands, if not millions,
    of systems. Prime instances include efficient ECDSA threshold signature schemes
    and zero-knowledge proof systems. In some scenarios, existing protocols with little
    practical use found impactful use cases, such as Boneh–Lynn–Shacham (BLS) signatures.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides an overview of these cryptographic algorithms and protocols—those
    tailored for blockchain and those that thrived due to it. I won’t delve into defining
    blockchain or its workings, as there are myriad online resources. Instead, I emphasize
    the cryptographic schemes underpinning blockchains, which hold significance irrespective
    of the blockchain use cases. Even if you remain skeptical of the blockchain phenomenon,
    I trust you’ll find this chapter enlightening.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Hashing Applications</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Hash functions, the Swiss Army knives of cryptography, serve numerous applications
    in blockchain systems, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hashing a transaction’s data**'
  prefs: []
  type: TYPE_NORMAL
- en: Hash functions can produce a digest signed by the transaction’s issuer, typically
    with ECDSA-secp256k1 or Ed25519\. Verifying the signature ensures that the owner
    of a given address approved of the information hashed, leading to including the
    transaction in the chain’s ledger.
  prefs: []
  type: TYPE_NORMAL
- en: In the blockchain Ethereum, a transaction’s hash serves as its unique identifier;
    for example, you can enter a hash in the search field of *[https://<wbr>etherscan<wbr>.io](https://etherscan.io)*
    to retrieve the associated transaction. Ethereum transaction hashes use Keccak-256—which
    is similar but not identical to SHA3-256—and process-encoded data. This data includes
    the recipient’s address, the amount of ether (ticker ETH) sent, any smart contract
    input, the gas price and limit, a nonce (increasing for each new transaction),
    and a signature of the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hashing the content of a block**'
  prefs: []
  type: TYPE_NORMAL
- en: Hash functions can include the digest in the subsequent block to “chain” the
    blocks. For example, each Bitcoin block has a *block header* that includes the
    previous block’s hash, a tree hash of the recorded transactions, and some metadata
    (version, timestamp, nonce, and so on). Bitcoin computes the previous block’s
    hash by hashing the header of the previous block using double SHA-256, or **SHA-256**(**SHA-256**(block
    header)). This unorthodox construction eliminates the risk of length extension
    attacks and adds a safety net in case SHA-256 was found to be insecure—which is
    unlikely.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from these basic use cases, hash functions are the main building block
    in key components of blockchain systems.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Merkle Trees</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Merkle trees* are a type of hash tree, which is a data structure computing
    a root value from leaf values according to a tree pattern. In hash trees, the
    parent node is computed by hashing the child nodes. Merkle trees are, for example,
    used to create a Bitcoin block’s header. They’re named after computer scientist
    Ralph Merkle, whose 1979 cryptographic scheme construction used binary hash trees.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Tree Hashing Computation</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A Merkle tree takes as input values that constitute its *leaves*—that is, the
    values from which the *root* (the output) is computed. You generally represent
    data structure trees with their root at the top and leaves at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: For example, [Figure 15-1](chapter15.xhtml#fig15-1) shows a Merkle tree hashing
    four values (*A*, *B*, *C*, *D*).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig15-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-1: A hash tree, where
    the leaves are the input and the root is the output</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The tree hashing then works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Hashing each of the four values to obtain the four hashes **H**(*A*), **H**(*B*),
    **H**(*C*), and **H**(*D*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashing together each consecutive pair of hashes to obtain **H**(**H**(*A*)
    || **H**(*B*)) and **H**(**H**(*C*) || **H**(*D*)). Here you concatenate the hash
    values (as the || symbol denotes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hashing the two hashes together to obtain the root of the tree, which is the
    final output of the tree hashing: **H**(**H**(**H**(*A*) || **H**(*B*)) || **H**(**H**(*C*)
    || **H**(*D*))).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you omit the initial hashing of the input values—which is necessary only
    if the values aren’t already the size of the hash—you go from four values to one
    with a tree of two layers, or of *height* two. Note that while the input data
    may be a different size, all hash values are the same size. Generally, a tree
    of *n* layers has 2*^n* leaves, allowing you to process up to 2*^n* values by
    computing 2*^n* – 1 hashes from the (hashed) leaves.
  prefs: []
  type: TYPE_NORMAL
- en: If the number of input values isn’t exactly 2*^n* for some integer *n*, a common
    technique is to add dummy values (for example, set to zero or to the last value
    in the list); the padding rule should, however, be carefully chosen to avoid trivial
    collisions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Merkle Proofs</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A Merkle tree’s structure can be leveraged to prove that a given value belongs
    to the list of 2*^n* values hashed without recomputing the whole tree (which takes
    on the order of 2*^n* operations) but only in time proportional to the *height*
    of the tree—that is, its number of layers *n*. Depending on the context, such
    proofs are called a *membership path*, an *inclusion proof*, or a *Merkle proof*.
    This is a Merkle tree’s killer feature, which general-purpose hash functions don’t
    offer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-2](chapter15.xhtml#fig15-2) shows how this works. The shaded cells
    are the values sufficient to prove that *V*[1] is one of the values hashed to
    obtain the root.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig15-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-2: A Merkle tree,
    wherein the shaded cells constitute the membership path of</samp> <samp class="SANS_Futura_Std_Book_11">A</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you want to prove that *A* was one of the values hashed, without revealing
    *B*, *C*, or *D*. First, hash *A* to obtain the actual leaf of the hash tree.
    Then, assume that you’ve received *A*’s membership path, which consists of the
    other shaded values, **H**(*B*) and **H**(**H**(*C*) || **H**(*D*)). To verify
    that *A* belongs to the tree, compute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*X* = **H**(**H**(*A*) || **H**(*B*)), since you know *A* and **H**(*B*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**H(H**(*X*) || **H**(**H**(*C*) || **H**(*D*))), since you know **H**(**H**(*C*)
    || **H**(*D*))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It took only two hashes of sibling values to prove *A*’s inclusion, or as many
    hashes as the height of the tree. A tree with eight leaves has a height of three;
    thus, a membership path verification needs three sibling hashes. With 16 leaves,
    you need four sibling hashes, and so on, with *n* sibling hashes for a tree with
    2*^n* leaves.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain applications often use Merkle trees to hash transactions into a single
    *Merkle root*, such as that included in a Bitcoin block header. A typical Bitcoin
    block registers about 2,000 transactions, which requires a tree of height 11 (2^(11)
    = 2,048). In this case, it takes 2,048 – 1 = 2,047 sibling hashes to compute the
    root from the leaves, where each leaf is the hash of a transaction’s data. Each
    hash computes a double SHA-256, so in the case of 2,048 transactions, it takes
    2,047 + 2,048 = 4,095 double SHA-256s, or 8,190 calls to SHA-256.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ethereum uses a slightly more complex tree-based data structure, combining
    Merkle trees with *Patricia tries* (this is not a typo; “trie” comes from “retrieval”),
    a tree-like structure that stores key-value pairs. This structure serves Ethereum’s
    state-based model, which significantly differs from Bitcoin’s UTXO (unspent transaction
    output) model, for which simpler Merkle trees are sufficient.  #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Proof
    of Work</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Proof of work (PoW) is arguably the most critical component of a blockchain’s
    consensus protocol—for those based on PoW rather than proof of stake (PoS) or
    other protocols.
  prefs: []
  type: TYPE_NORMAL
- en: A *PoW* is essentially a hash function that takes some fixed inputs and variable
    inputs and whose result must match a certain pattern to be valid. Parties that
    aim to *solve* a PoW repeatedly compute the hash with different values of the
    variable inputs until the result satisfies some constraint.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in Bitcoin and some other PoW-based blockchains, the constraint
    is that the hash value when seen as a 256-bit number must be less than a given
    number. This can also be seen as the hash value having a given number of leading
    zeros, when seeing the hash as the big-endian encoding of a 256-bit number.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in 2022 the highest Bitcoin difficulty value (as reported on *[https://<wbr>btc<wbr>.com<wbr>/stats<wbr>/diff](https://btc.com/stats/diff)*)
    was 34,244,331,613,176, or approximately 2^(45). You multiply this by 2^(32) to
    find the actual value that the hash must be less than, 2^(77). For each block,
    all the network participants (*miners*) jointly compute in the order of 2^(77)
    double SHA-256 computations to find a solution to the PoW. Such a solution consists
    of a nonce (the variable part of the PoW hash’s input) that yields a hash value
    less than 2^(77). The fixed part of the PoW hash’s input consists of the block
    header values (version, previous block hash, Merkle tree root, timestamp, and
    difficulty target value).
  prefs: []
  type: TYPE_NORMAL
- en: Without a PoW “slowing down” the production of blocks in a blockchain, new valid
    blocks could be produced instantaneously, meaning that histories of transactions
    could be produced and re-created at will. It would be impossible to achieve *finality*
    (that is, the assurance that a block, and thus a set of transactions, cannot be
    reverted or changed once accepted by the network). In particular, it would be
    impossible to protect the network against *double spending*, or spending the same
    coins in two distinct transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all PoW schemes are as simple as Bitcoin’s, which uses a general-purpose
    hash function (SHA-256). Several PoWs attempted to make its computation on dedicated
    hardware less efficient compared to general-purpose CPUs to discourage the centralization
    of mining by organizations investing in the development of optimized hardware
    miner technology—as opposed to off-the-shelf servers and computers that anyone
    can use. Implemented tricks include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory hardness **You can force the PoW to use a large amount of memory,
    typically by generating a huge table and accessing at unpredictable addresses.
    For example, Ethereum’s PoW used the Ethash algorithm, which required approximately
    4GB of memory. (In September 2022, Ethereum abandoned Ethash and switched from
    a PoW to a proof-of-stake mechanism.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtual machines **As some malware do, you can create a custom set of computer
    instructions that would be translated to standard instructions by a virtual machine
    application, while also potentially using a large amount of memory to compute
    a PoW’s solution. This is the approach of RandomX, a PoW algorithm adopted by
    the Monero blockchain.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Hierarchical Key
    Derivation</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Blockchain users generally want to manage multiple accounts, such that each
    account consists of a key pair where:'
  prefs: []
  type: TYPE_NORMAL
- en: The *private key* must be secret, as it’s the signing key required to sign transactions
    and transfer funds from the account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *public key* must be public, as it’s used to verify signatures of transactions.
    It’s also the value from which the account’s address is derived. For example,
    Bitcoin derives addresses from a public key using a combination of SHA-256 and
    RIPEMD-160 hashing. Note that in some blockchains, such as Bitcoin, the public
    key is not public until the account issues a transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To reliably manage all these keys, blockchain developers defined *hierarchical
    deterministic wallets (HD wallets)*, which make key management less cumbersome
    and risky than having to generate and back up a fresh random key for each new
    account.
  prefs: []
  type: TYPE_NORMAL
- en: With HD wallets, you generate and store one secret, the *seed* (also called
    the *master key* or *entropy*). This seed is the only randomly generated value
    and the only one providing entropy, or uncertainty, and therefore secrecy to the
    private signing keys derived from it. Wallet software applications often encode
    the seed as a *seed phrase*, or *mnemonic*, a sequence of 12 to 24 words that
    makes it easier to save and memorize.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review how this key derivation works using the HMAC-SHA-512 pseudorandom
    function (the HMAC construction instantiated with SHA-512): from a seed *S* of
    128 or 256 bits, compute HMAC-SHA-512 with the seed as a key input, and as a message
    input an identifier of the underlying elliptic curve (a string that can be “Bitcoin
    seed,” “Nist256p1 seed,” or “ed25519 seed”). The first 256 bits of the result
    are the master key, *k*, and the last 256 bits are the master chain code, *c*,
    a value used to derive more keys.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can derive a *child private key* from *k* and *c* as follows, given an
    identifier *i* (a number at most 2^(31)): compute HMAC-SHA-512 with the chain
    code *c* as a key, and a message including *k* and *i*. The 512-bit result is
    parsed as a 256-bit value *L* followed by a 256-bit chain code *R*. In simplified
    notation, *L* || *R* = HMAC-SHA-512(*c*, *k* || *i*). You then set the child private
    key to *k* + *L*, and its chain code is *R*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can in turn derive keys from the obtained key and chain code to establish
    a key *hierarchy*. For example, from the key with index 0, you derive all your
    keys for Bitcoin, and from the key with index 60, you derive all your keys for
    Ethereum. Conventions associating a number to each blockchain network are standardized
    as part of the document “SLIP-0044: Registered Coin Types for BIP-0044.”'
  prefs: []
  type: TYPE_NORMAL
- en: If you first derive a child key with identifier 0 and next derive a key with
    identifier (say) 29 from this key and its chain code, then the key’s *derivation
    path* is 0/29\. You’ll have done two calls of HMAC-SHA-512, yielding, respectively,
    *L*[1] and *L*[2] as their first 256 bits, and the final private key is *k* +
    *L*[1] + *L*[2]. Therefore, you can see all keys derived from a given master key
    *k* as *k* plus the sum of values HMAC-SHA-512 returns. This derivation is called
    *hardened* because you need both the private key *k* and the chain code *c* of
    the parent key.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For the* nonhardened *version, use the public key instead of the private key,
    which allows you to determine the public key of a child key from its parent public
    key. For more details, see the initial Bitcoin standard document “BIP32: Hierarchical
    Deterministic Wallets” and its generalized standard document “SLIP-0010: Universal
    Private Key Derivation from Master Private Key.”*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Algebraic Hash Functions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Hash functions like SHA-3 and BLAKE3 operate on *bytes*, or on *words* of 4
    or 8 bytes, where a byte is a chunk of 8 bits. The input data is a sequence of
    bytes, where each byte can take any of the 256 possible values from 0x00 to 0xff
    (255), and likewise the output data is a sequence of arbitrary bytes. This works
    well when using data efficiently converted into a sequence of bytes and when operations
    on bytes or words are efficient (such as XOR, word bit shift, and integer addition).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Mathematical Computer</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Say you have a computer that works with numbers only in a given range, such
    as numbers modulo 13\. The XOR operation won’t do well with such numbers, because
    not all 4-bit numbers are less than 13; for example, a XOR between 10 and 4 will
    give you 14, which is out of range. You might reduce it modulo 13 to obtain 1,
    but then 10 XOR 4 yields the same result as 10 XOR 11, a problem you don’t have
    when working with bytes. This tends to significantly reduce the security of the
    hash function—through collisions, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even worse, your computer knows only operations modulo 13: addition, subtraction,
    multiplication, and division. It doesn’t have a built-in bitwise XOR instruction,
    so it simulates it with its modulo 13 arithmetic instructions, which isn’t straightforward
    or computationally efficient. I’ll leave the details of this simulation as an
    exercise.'
  prefs: []
  type: TYPE_NORMAL
- en: Your task is to create a hash function that works only (or mostly) with arithmetic
    operations for the given range of numbers and doesn’t use bitwise operations including
    XOR, OR, AND, or bit shifts.
  prefs: []
  type: TYPE_NORMAL
- en: You need this kind of function to efficiently run certain advanced cryptographic
    protocols—namely, multiparty computation (MPC) and zero-knowledge proofs, which
    you’ll see later in this chapter. Such protocols often operate in the realm of
    mathematical structures such as finite fields (for example, sets of integers modulo
    a prime number) and sometimes have to “convert” a program into mathematical equations.
    In principle, you can convert any program into equations. But when the program
    isn’t optimized for the underlying math structure, the equations get very large
    and slow to compute. *Algebraic hash functions* aim to address this issue by designing
    hash functions that are both secure and easy to implement with only arithmetic
    operations in a finite field.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Design Principles</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s consider the design principles of *Poseidon*, a hash function designed
    in 2019 for zero-knowledge proof systems and rapidly adopted by many blockchain
    systems. Such proofs sometimes have to express a hash function as a circuit of
    arithmetic operations over a large finite field, such as those of integers modulo
    a 255-bit prime number. In that case, Poseidon proved orders of magnitude more
    efficient than general-purpose hash functions like SHA-256.
  prefs: []
  type: TYPE_NORMAL
- en: Poseidon uses the sponge hash function construction (see [Chapter 7](chapter7.xhtml)),
    so it needs to construct a *permutation*, an invertible transformation with input
    and output of the same size. It applies this permutation to a state that is a
    vector of finite field elements. In the relevant applications, such a finite field
    usually consists of numbers modulo a prime, which may be as small as 31 bits and
    as large as 381 bits, depending on the application.
  prefs: []
  type: TYPE_NORMAL
- en: Then, like most hash functions, the permutation iterates a series of rounds,
    so it needs to design a *round function*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, Poseidon breaks down its permutation into three layers, with three
    different purposes, reminiscent of AES’s rounds:'
  prefs: []
  type: TYPE_NORMAL
- en: A *unicity* layer, *AddRoundConstants*, which Poseidon notes as *ARC*() in the
    documentation. This adds constant values to the state’s elements, such that the
    constants are different for each round. Making each round unique prevents attacks
    including the slide attack. To avoid defining and storing many constants, Poseidon
    generates constants from a deterministic random bit generator initialized with
    an encoding of the Poseidon instance characteristics (number of rounds, finite
    field, S-box type, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *nonlinear* layer or *S-box layer*, *SubWords*, which Poseidon’s documentation
    notes as *S*. This layer adds *confusion*, the property that the input and output
    values of the function are related by high-degree algebraic equations—and thus
    are as far as possible from linear and low-degree equations, which differential
    cryptanalysis can exploit. S-box transforms each element of its state independently
    of the others, typically mapping a field element *x* to *x*³ or *x*⁵. The exponent
    is kept relatively low to be efficiently computed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *linear* layer, *MixLayer*, which Poseidon notes as *M*() in the documentation.
    MixLayer brings *diffusion*, or the propagation of differences in the initial
    state across all elements. For example, if the state consists of the four-element
    vector (*x*[1], *x*[2], *x*[3], *x*[4]), then *M*() replaces each element with
    a linear combination of all elements. It might replace *x*[1] with the result
    of 2*x*[1] + 10*x*[2] + *x*[3] + 3*x*[4]. Such a transformation corresponds to
    a multiplication of a vector by a matrix. Poseidon’s matrices must satisfy certain
    security properties and should be designed for efficient implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A *full round* of Poseidon applies the three layers in this order: *ARC*(),
    *S* to each element, and *M*(). A *partial round* applies *S* to only one element
    and may use a different matrix in *M*(). A Poseidon *instance* then iterates full
    rounds, partial rounds, and full rounds—the number of which depends on the instance,
    number of elements, finite field, and target security level.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For more details on Poseidon, see* [https://<wbr>www<wbr>.poseidon<wbr>-hash<wbr>.info](https://www.poseidon-hash.info)
    *as well as the initial Poseidon paper (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2019<wbr>/458<wbr>.pdf](https://eprint.iacr.org/2019/458.pdf)*)
    and the improved design Poseidon2 paper (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2023<wbr>/323<wbr>.pdf](https://eprint.iacr.org/2023/323.pdf)*).*'
  prefs: []
  type: TYPE_NORMAL
- en: Poseidon is one of many algebraic hash functions created to address practical
    use cases. Other designs include MiMC, Monolith, Rescue-Prime, and Tip5.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Things Can Go
    Wrong</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s look at some security failures that involve hash functions and their applications
    in the blockchain world.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Broken Custom Hash</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The 2017 blockchain project Iota was quite weird. It claimed to use an architecture
    different from the sequential chain of blocks of most blockchains, closer to direct
    acyclic graph (DAG), which was much less secure. It also encoded data not in bits
    but in *trits*, units taking three values instead of two, supposedly to make computations
    more efficient on processors that don’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: Iota didn’t use an elliptic curve-based signature scheme like ECDSA or Ed25519
    but rather a hash-based signature scheme based on the established Winternitz construction,
    thus offering post-quantum security—except Iota also designed its own custom hash
    function, Curl.
  prefs: []
  type: TYPE_NORMAL
- en: Iota became one of the top 10 most popular cryptocurrencies and made grandiose
    claims about its potential usefulness and its security. But its custom hash function,
    which it claimed to develop with the aid of artificial intelligence, turned out
    to be very weak against collision attacks. Using off-the-shelf hardware, researchers
    found collisions within minutes, which could be exploited only in contrived attack
    scenarios. Iota quickly patched its hash function.
  prefs: []
  type: TYPE_NORMAL
- en: After this fiasco, renowned cryptography and security expert Bruce Schneier
    commented, “In 2017, leaving your crypto algorithm vulnerable to differential
    cryptanalysis is a rookie mistake. It says that no one of any caliber analyzed
    their system, and that the odds that their fix makes the system secure is low.”
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Wallet with Low Entropy</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The hierarchical key derivation model from earlier in this section is secure
    on paper but in practice only if it’s implemented correctly. You can usually verify
    this using test vectors within the BIP32 and SLIP-0010 standard documents. If
    you obtain the same input/output values as those documented, your implementation
    is likely correct, though not necessarily secure.
  prefs: []
  type: TYPE_NORMAL
- en: In 2022, the popular cryptocurrency mobile wallet application Trust Wallet announced
    the release of a browser extension version that used WebAssembly (Wasm) technology
    to run efficiently on different browsers. However, Wasm couldn’t use the same
    PRNG as the mobile versions; it had to define a different one.
  prefs: []
  type: TYPE_NORMAL
- en: A poor PRNG can be cryptography’s Achilles’ heel (see [Chapter 2](chapter2.xhtml)).
    In Trust Wallet, the developers used the Mersenne Twister PRNG (mt19937), which
    is not a cryptographic PRNG. Its entropy is at most 32 bits, and it produces its
    output bits using simple linear combinations of the internal state values.
  prefs: []
  type: TYPE_NORMAL
- en: As Trust Wallet’s PRNG had 32 bits of entropy, it could generate only 2^(32)
    different seeds for users’ wallets. An attacker could then compute all the 2^(32)
    possible seeds and, for each seed, compute the private keys and addresses derived
    using hierarchical key derivation. They could then scan blockchains to find addresses
    generated by Trust Wallet and steal their tokens. The Ledger company researchers
    who found the flaw commented, “Running such an attack takes much more than a couple
    of hours, but is doable with a few GPUs in less than a day.”
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Collisions from Domain Separation
    Failures</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s discuss how to find collisions for a hash function that is collision resistant.
    As cryptographer Moti Yung said, “If it sounds impossible, then it’s cryptographically
    interesting.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine the following simple case: an application receives messages *A* and
    *B* from two parties, Alice and Bob, and then hashes these two messages together
    to create a hash value unique for these messages. It could then compute **H**(*A*
    || *B*) by hashing the string consisting of *A* followed by *B*. Even if your
    hash function is collision resistant, you’ll get the same hash value for *A* =
    COL and *B* = LISION as for *A* = CO and *B* = LLISION. You end up with a hash
    collision with respect to the application’s input values, although it’s not a
    collision for the hash function because the hash function **H** processes the
    same string in the two cases, COLLISION.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid the problem, encode the application’s input values into a string that’s
    unique per input, with no ambiguous encoding: for each string, you should be able
    to uniquely identify the original set of input values. In our example, adding
    a dollar sign ($) character as a separator between the two inputs seems to avoid
    the collision between COL || LISION and CO || LLISION: you would get the strings
    COL$LISION and CO$LLISION, leading to different hash values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But a separator symbol isn’t enough to eliminate ambiguities when the character
    is authorized in the application’s input values. For example, take the string
    COL$$LISION as the concatenation of two input strings separated with $. You could
    have obtained that string from two pairs of inputs: COL and $LISION, COL$ and
    LISION. Note that the problem doesn’t occur when the input values are a fixed,
    constant size—for example, a first string of two characters and a second of three
    characters. Even in that case, it’s still safer to use some separator or encoding
    that prevents collisions, as a future patch may introduce variable-length input.'
  prefs: []
  type: TYPE_NORMAL
- en: Researchers have found bugs of this type in threshold signing protocols, which
    you’ll see later in this chapter, as well as in e-voting protocols, where the
    resulting hash collisions could be exploited to violate the security properties
    of these protocols.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Multisignature Protocols</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a cryptographic *multisignature protocol*, participants jointly produce a
    signature of a message that’s functionally equivalent to having all parties separately
    sign the message; an obtained signature means all parties agreed to sign the message.
    The advantage is that instead of having as many signatures as signers, there’s
    only one. Anyone who has the public keys of all the signers can then verify the
    signature.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain platforms employ multisignatures when multiple parties manage an
    account to ensure that all parties endorse issued transactions. A single party
    can also use them if they have multiple keys on multiple devices to prevent a
    single compromised key from allowing the attack to issue transactions. Such multisignature
    protocols are one of the many types of *collective signature* protocols, where
    parties run a protocol to produce a signature.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into the technical details, let’s clarify how these multisignatures
    differ from related protocols.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiple Multiparty
    Signatures</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Despite their similar name, the multisignature protocols we’ll discuss are different
    from on-chain multisignature scripts or multisignature smart contracts, as used
    in Bitcoin and Ethereum, respectively. The latter aren’t cryptographic protocols
    because participants independently submit their individual signature to the blockchain
    network. The network in turn verifies a rule such as “if a transaction has signatures
    from *pub*[1] and *pub*[2], then accept it” or “if a transaction is signed by
    any two parties among *pub*[1], *pub*[2], and *pub*[3], then accept it”—rejecting
    the transaction otherwise. Here we implicitly view public keys *pub* as the identifiers
    of the parties, as is common in blockchain protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to on-chain multisigs, multisignature protocols produce a single signature;
    there’s then only one signature to verify rather than multiple ones. The multisignature
    scripts and smart contracts instead process several signatures and consist of
    a verification rule rather than a protocol on the signers’ end. In both cases,
    verification requires the public keys of all signers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multisignature protocols also differ from two types of other collective signature
    protocols, which you’ll see in the following sections. In both protocols, the
    outcome is a single signature, but the difference is how and from what it’s created:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Aggregate signature protocols**'
  prefs: []
  type: TYPE_NORMAL
- en: Like in multisignatures, each participant has their own key pair (public and
    private keys).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike in multisignatures, participants may sign different messages, rather
    than the same one. A participant can also sign multiple messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like in multisignatures, the verification of a signature requires multiple public
    keys (or a single aggregate version thereof, for supporting protocols).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Threshold signature protocols**'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike in multisignatures, participants don’t use their own keys. Instead, they
    have shares (also called *shards*) of a single private key, such that no single
    participant ever knows the full key, even during the protocol’s execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like in multisignatures, participants sign a single message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike in multisignatures, verification requires a single public key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we’ve defined what multisignatures are, let’s see how they work in
    their most illustrious use case: Schnorr signatures.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Schnorr Signature
    Protocols</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Mathematician Claus-Peter Schnorr created the eponymous signature scheme in
    1989 and filed a patent for it, which prevented its wide adoption until 2008,
    when the EdDSA scheme (see [Chapter 12](chapter12.xhtml)) optimized it to work
    with modern elliptic curves. Schnorr’s scheme is simpler than the ECDSA standard,
    making it easier to turn into a multisignature scheme. Bitcoin supports Schnorr
    signatures, which were introduced in 2022 as better support for multisignature
    protocols.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*We’ll use additive notation (as with EdDSA and when working with elliptic
    curve), rather than the original multiplicative notation (as used when working
    with integers in a multiplicative group). Therefore, the public key* A *associated
    with a private key* a *is the elliptic curve point* A *=* aG*, where* G *is a
    predefined base point, and group elements are points combined by addition. This
    is opposed to the multiplicative notation where we’d have* A *=* g^a *for some
    group generator* g*, where group elements are numbers multiplied together.*'
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Single-Signer Schnorr
    Signatures</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Before seeing how multiparty signing works, let’s see how single-party Schnorr
    signing works. Suppose Alice has a private key *a*, with associated public key
    *A* = *aG*. Here *a* is a number, or scalar, in a given range of numbers (specifically,
    the finite field over which the elliptic curve is defined, typically positive
    integers modulo some large prime numbers, of at least approximately 256 bits),
    and *G* is a fixed base point of the curve.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sign a message *M*, Alice proceeds as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Pick a secret random number, *r*, and compute the point *R* = *rG*. The
    value *r* is a *nonce*, a one-time private key with *R* its public key.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Compute *h* = **H**(*R* || *A* || *M*), the value that you’ll “connect”
    to the private key *a* and the one-time private key *r* to sign *M*. We not only
    hash the message but also bind *h* to the signer and the nonce, respectively,
    via the nonsecret values *A* and *R*. Without these, different attacks would be
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Compute *s* = *r* + *ha* and return the pair (*R*, *s*) as a signature.
    You can see *s* as the multiplication between the secret key and the data to sign,
    where the secret *r* masks the result; without this, it’s trivial to recover the
    private key from a signature.
  prefs: []
  type: TYPE_NORMAL
- en: Verify a signature by checking that *sG* equals *R* + **H**(*R* || *A* || *M*)*A*.
    This works because from *s* = *r* + *ha*, substituting *r* + *ha* for *s* in *sG*,
    you obtain
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg308-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: with *h* = **H**(*R* || *A* || *M*), which the verifier must compute from the
    message *M*, the public key *A*, and the *R* part of the signature.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Schnorr Multisignatures</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In multisignatures we don’t have one signer but multiple ones. For the sake
    of simplicity, we’ll describe the case of two cosigners: meet Bob, who’ll sign
    messages jointly with Alice. Bob’s private key is *b* and his public key is *B*
    = *bG*. To jointly create a multisignature, Alice and Bob could proceed as follows
    to sign a message *M*:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Alice picks a nonce *r*[A], computes *R*[A] = *r*[A]*G*, and sends *R*[A]
    to Bob.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Bob picks a nonce *r*[B], computes *R*[B] = *r*[B]*G*, and sends *R*[B]
    to Alice.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  They compute *R* = *R*[A] + *R*[B] and set *h* = **H**(*R* || *A* || *B*
    || *M*), the value that Alice and Bob will use to generate their part of the signature.
    A specific value of *h* is bound to the parties via their public keys (*A* and
    *B*) and bound to the current signing session via the nonce *R* only for the specific
    signature execution as defined by the nonce *R*.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Alice computes *s*[A] = *r*[A] + *ha* and sends it to Bob.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Bob computes *s*[B] = *r*[B] + *hb* and sends it to Alice.
  prefs: []
  type: TYPE_NORMAL
- en: 6.  They both compute *R* = *R*[A] + *R*[B] and *s* = *s*[A] + *s*[B] and return
    (*R*, *s*) as the signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify a signature, check that *sG* equals *R* + *h*(*A + B*). Substituting
    *s* in *sG* by the previously computed value results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg309-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the verifier needs to know both *A* and *B*, and not only their sum
    *A* + *B*, because they need both values to compute **H**(*R* || *A* || *B* ||
    *M*). However, if *h* is instead defined as **H**(*R* || *A* + *B* || *M*), a
    verifier can use a single public key *A* + *B* without knowing that the signature
    is issued by two parties. We call the “merging” of multiple public keys into one
    *key aggregation*. This is particularly useful to reduce the size of the data
    to hash when there are many signers.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*I’ve described basic Schnorr multisignatures in the case of two parties, but
    the protocol scales to an arbitrary number of parties with public keys* P1*,*
    P2 *, . . . ,* P[n]*. In the definition, replace* A *+* B *with* P1 *+* P2 *+
    . . . +* P[n]*, replace* A *||* B *with* P1 *||* P2 *|| . . . ||* P[n]*, and replace
    “sends it to Bob/Alice” with “sends it to everyone.” You can apply a similar protocol
    to EdDSA and Ed25519, variants of Schnorr’s scheme.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Things Can Go
    Wrong</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Schnorr multisignature protocol is relatively simple but may fail in the
    following attack scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Key Cancellation Attack</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In this attack, Bob convinces signature verifiers that he jointly signed a message
    with Alice, whereas Alice hasn’t seen the message and didn’t interact with Bob.
    An attacker could exploit this in a scenario where you expect Alice and Bob to
    jointly sign messages—for example, in transactions that require both parties’
    approval. In the normal case, the verifiers would know Alice’s public key *A*
    and Bob’s public key *B*, and Bob and Alice would know each other’s keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now suppose the following happens: Alice sends her public key *A* to everyone
    including Bob, but instead of sharing his public key *B*, Bob shares *C* = *B*
    – *A* = (*b* – *a*)*G* with the verifiers, and *B* with Alice. That Bob doesn’t
    know the private key corresponding to *C* won’t matter for the attack.'
  prefs: []
  type: TYPE_NORMAL
- en: Bob has to sign a message using his private key *b*, as in the single-signer
    case, but with *h* = **H**(*R* || *A* || *C* || *M*), as if he were signing with
    Alice. He returns (*R*, *s*) as a signature, with *R* = *rG* for an *r* of his
    choice and *s* = *r* + *hb.*
  prefs: []
  type: TYPE_NORMAL
- en: Expecting signatures from Alice and Bob, verifiers check that *sG* equals *R*
    + *h*(*A + C*), which is correct because *A* + *C* = *A* + (*B* – *A*) = *B*.
    Bob can therefore forge multisignature without even interacting with Alice and
    without knowing her private key.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, you can avoid this attack by requesting signers to prove the knowledge
    of the private key—for example, by signing a message. Since Bob doesn’t know the
    private key corresponding to *C*, he can’t provide such evidence. As you’ll see
    with the MuSig protocol, you can also avoid the attack at the protocol level.
  prefs: []
  type: TYPE_NORMAL
- en: The attack scales to an arbitrary number of parties, a context that’s often
    called a *rogue key attack*. Having received the public keys of all other parties,
    an attacker Bob would just define his public key as *B* – *X*, with *X* the sum
    of all other parties’ public keys.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Repeated Nonces</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Like in ECDSA, repeated nonces are lethal to the Schnorr multisignature protocol.
    Imagine that Alice’s pseudorandom generator fails and she generates the same secret
    nonce *r*[A] twice in two runs of the protocol: she sends an initial *s*[A] =
    *r*[A] + *ha* to Bob, and a second *s*[A]*''* = *r*[A] + *h''a* where the first
    *h* and the second *h''* also depend on Bob’s randomness. You thus have *r*[A]
    = *ha – s*[A] and *r*[A] = *h''a – s*[A]*''*, which implies *ha – s*[A] = *h''a
    – s*[A]*''* or, equivalently,'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg310-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: from which you can compute Alice’s private key *a* = (*s*[A] – *s*[A]*'*) /
    (*h – h'*).
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach to eliminate security risks caused by a randomness failure is
    to get rid of randomness. For example, computing the nonce by hashing the message
    and the private key as in Ed25519 works when there’s a single signer. However,
    setting *r* to **H**(*a* || *M*) won’t work in the case of multisignatures: if
    Alice and Bob sign the same message twice, then Alice computes a first *s*[A]
    = *r*[A] + *ha* and a second *s*[A]*''* = *r*[A] + *h''a*, where in both cases
    *r*[A] *=* **H**(*a* **||** *M*), where *h''* will be distinct from *h* if a malicious
    Bob sends a different value than **H**(*b* **||** *M*). In this case, Bob—and
    any eavesdropper of the communications—can again compute *a* as (*s*[A] – *s*[A]*''*)
    / (*h – h''*).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Parallel Execution Insecurity</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Schnorr multisignature protocol is insecure when the attacker can initiate
    multiple simultaneous signature protocols. The attack is too complicated to describe
    here but is documented in the research articles available at *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2018<wbr>/417](https://eprint.iacr.org/2018/417)*
    and *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2020<wbr>/945](https://eprint.iacr.org/2020/945)*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Safer Schnorr Multisignatures</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To avoid the key cancellation attack and repeated nonce issues, researchers
    developed more advanced multisignature protocols and in particular the MuSig protocols:
    MuSig, MuSig2, and MuSig-DN, where *MuSig* stands for *multisignature* and *DN*
    for *deterministic nonce*. MuSig protocols also support key aggregation to allow
    a verifier to check a signature using only one public key that’s derived from
    the signers’ keys, such that the aggregated key doesn’t reveal the number of signers
    or their public keys.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see MuSig’s main trick in action. If we’re in the simplest case of two
    signers, Alice and Bob, using the same notations as in the previous sections,
    instead of computing *s*[A] = *r*[A] + *ha* as her share of the signature, Alice
    computes *s*[A] = *r*[A] + *μ*[A]*ha*, thus multiplying the *ha* part with the
    *μ*[A] value. She computes *μ*[A] (where *μ* is the Greek letter mu) by hashing
    the list of participants’ public keys followed by Alice’s key, **H**(*A* || *B*
    || *A*). Likewise, Bob computes *s*[B] = *r*[B] + *μ*[B]*hb* with *μ*[B] = **H**(*A*
    || *B* || *B*), hashing the list of public keys followed by his key.
  prefs: []
  type: TYPE_NORMAL
- en: Alice then computes the *aggregate public key* as *X* = *μ*[A]*A* + *μ*[B]*B*,
    the sum of the public keys multiplied by their respective *μ* values. The hash
    of the message is then *h* = **H**(*R* || *X* || *M*) instead of **H**(*R* ||
    (*A* + *B*) || *M*) in the vulnerable version multisignature scheme supporting
    key aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: This trick works because a malicious Bob can no longer forge another public
    key that would “cancel” Alice’s *A*, as he could by setting *C* = *B* – *A* in
    the key cancellation attack. In the equation *X* = *μ*[A]*A* + *μ*[B]*B*, Bob
    has to find a new value of *B* that yields the “right” *μ* coefficients to remove
    *A* from the equation. But that’s now impossible because the equation is nonlinear
    with respect to *A* and *B* (linearity is often synonymous with insecurity—see
    [Chapter 2](chapter2.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: When there are more than two signers, you apply the trick in a similar way,
    computing the *μ* coefficients by hashing the list of keys followed by the signer’s
    key and then aggregating the public keys into a single *X* by computing the sum
    of the public keys multiplied by their respective *μ*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For more details on the MuSig protocols and how the MuSig-DN version securely
    derives nonces from the message, see* [https://<wbr>bitcoinops<wbr>.org<wbr>/en<wbr>/topics<wbr>/musig<wbr>/](https://bitcoinops.org/en/topics/musig/).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Aggregate Signature Protocols</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Aggregate signatures* have multiple signers, and each signer signs a message
    (which can be distinct for all signers); then these signatures are merged into
    a single signature. From only this signature and from the signers’ public keys
    and the messages they signed, verification checks that all signers signed their
    respective messages. Because a single signature must be stored, instead of as
    many signatures as signers, verification time is proportional to the number of
    messages. When all signers sign the same message, verification can be as fast
    as the verification of a single signer’s signature, regardless of the number of
    signers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aggregate signatures are notably used in Ethereum, specifically in its consensus
    layer. In this use case, validator nodes endorse proposals to change the state
    of the system (as blocks) and leverage aggregate signatures to minimize the signature
    storage space and verification time. They use the Boneh–Lynn–Shacham (BLS) signature
    scheme, which you’ll learn about in this section, starting with the magic behind
    BLS signatures: cryptographic pairings.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pairings</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'In elliptic curve cryptography, a *pairing* is an operation that transforms
    two points from two elliptic curve groups (not necessarily the same) into a finite
    field element. The standard notation for a pairing between two elliptic curve
    points *P* and *Q* is *e*(*P*, *Q*). Pairings used in cryptography have the property
    called *bilinearity* and are thus called *bilinear pairings*, which means they
    satisfy the following for any points *P*, *Q*, and *R*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg312-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, adding a point *R* to an operand is equivalent to multiplying the result
    by the pairing between *R* and the other operand. Consequently, if you add a point
    to itself *n* times—that is, if you multiply it by a number *n*—then you have
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg312-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: or *e*(*P*, *Q*) multiplied by itself *n* times, which is also equal to *e*(*P*,
    *nQ*).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have different points *P*[1], *P*[2], . . . , *P*n, you can turn addition
    of the input values into multiplication of the output values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg312-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The internals of how pairings work is beyond this book’s scope. For more details,
    see the article “Cryptographic Pairings” by Kristin Lauter and Michael Naehrig
    (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2017<wbr>/1108](https://eprint.iacr.org/2017/1108)*)
    and the book *Guide to Pairing-Based Cryptography* by Nadia El Mrabet and Marc
    Joye (Chapman and Hall/CRC, 2016).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">BLS Signatures</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'BLS signatures were presented in 2006 in the article “Short Signatures from
    the Weil Pairing” by Dan Boneh, Ben Lynn, and Hovav Shacham. It stated that the
    scheme was designed “for systems where signatures are typed in by a human or signatures
    are sent over a low-bandwidth channel.” BLS signatures turned out to be used in
    highly automated systems over high-bandwidth channels, which benefited from a
    property described in a subsequent paper: aggregation of signatures and of public
    keys.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Don’t confuse BLS signatures with BLS (Barreto–Lynn–Scott) curves, which have
    an author (Lynn) in common. BLS curves are elliptic curves designed to be pairing
    friendly, allowing secure and efficient pairing operations. In fact, BLS signatures
    often work with points over a BLS curve. For example, the Ethereum BLS signature
    relies on the curve BLS12-381.*'
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Single-Signer Signature
    and Verification</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'In BLS signatures, Alice’s private key is a scalar number *a*, and her public
    key is *A* = *aG*, for a predefined base point *G*. To sign a message *M*, she
    first computes *H* = **H**(*M*), where the hash function returns a curve point
    rather than a bit string or a scalar—the *H* notation follows the general convention
    that you denote points as capital letters. The signature is then *S* = *aH*. This
    looks much simpler than a Schnorr’s or an ECDSA signature: just hash the message
    and multiply the result with the private key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify a BLS signature, compute two pairing operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '*e*(*A*, *H*) between the public key and the hashed message (note that *A*
    = *aG*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*e*(*G*, *S*) between the base point and the signature (note that *S* = *aH*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These values should be equal because of the pairing’s bilinearity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg313-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the equality holds, the signature is accepted; otherwise, it’s rejected.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring the complexity of the pairing operation, such pairing-based signatures
    are the simplest signature scheme.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Aggregate Signatures from
    Multiple Signers</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s further exploit the magic of BLS signatures and bilinear pairings, considering
    a scenario wherein *n* signers with private keys *k*[1], *k*[2], . . . , *k*n
    and public keys *P*[1], *P*[2], . . . , *P*n sign *n* messages *M*[1], *M*[2],
    . . . , *M*n and produce the signatures *S*[1], *S*[2], . . . , *S*n. Note that
    *H*i = **H**(*M*i) is the hash of the *i*th message.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can aggregate signatures *S*i = *k*i*H*i into one by adding them to obtain
    *S* = *S*[1] + *S*[2] + . . . + *S*n. Observe that computing *e*(*G*, *S*), as
    in the verification of a single signature, results in the following, owing to
    the bilinearity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg313-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Remember that pairings satisfy *e*(*nP*, *Q*) = *e*(*P*, *nQ*). You can thus
    replace each *e*(*G*, *S*i) term with *e*(*P*i, *H*i) by “moving” the multiplicative
    factor *k*i to the left operand of the pairing: the first operand will thus be
    *k*i*G* = *P*i instead of *G*, and the second will be *H*i instead of *S*i = *k*i*H*i.'
  prefs: []
  type: TYPE_NORMAL
- en: After aggregating multiple signatures of multiple signers over multiple messages
    into a single signature, you can verify the aggregate signature from the signers’
    public keys and messages signed. Verification just checks the equality between
    *e*(*G*, *S*) and the product of all pairings *e*(*P*i, *H*i). There are 1 + *n*
    pairings to compute, rather than the 2*n* pairings if you hadn’t aggregated the
    signatures—in this case, the signatures occupy *n* times as much memory as the
    aggregated one.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider a scenario where you’ll aggregate both signatures and public
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Aggregate Public Keys</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that all signers sign the same message *M* and that you aggregate all
    public keys into a single one: *P* = *P*[1] + *P*[2] + . . . + *P*n. Note that
    *k*[1], *k*[2], . . . , *k*n still represents their respective private keys and
    *H* = **H**(*M*) the hash of the message. Given valid signatures *S*i, you obtain
    the following equality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg314-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You therefore verify the signatures of *n* parties over the same message using
    only two pairing operations, *e*(*P*, *H*) and *e*(*G*, *S*). This is extremely
    efficient, as it makes signature verification essentially independent of the number
    of parties, as you can add points efficiently, whereas pairings are costly to
    compute. In addition to the computing efficiency, aggregating keys and signatures
    also saves memory.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Things Can Go
    Wrong</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like many elliptic curve cryptography schemes, BLS signatures should avoid invalid
    keys and weak parameters to be secure. And like the previous protocols, BLS signatures
    could be vulnerable to key cancellation attack. Let’s explore the details.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Invalid Keys</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: BLS signatures are specified in an Internet-Draft, a working document of the
    IETF available at *[https://<wbr>github<wbr>.com<wbr>/cfrg<wbr>/draft<wbr>-irtf<wbr>-cfrg<wbr>-bls<wbr>-signature](https://github.com/cfrg/draft-irtf-cfrg-bls-signature)*.
    This specifies core operations including key generation (the algorithm <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyGen</samp>),
    signature (<samp class="SANS_TheSansMonoCd_W5Regular_11">CoreSign</samp>), verification
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">CoreVerify</samp>), and key validation
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">KeyValidate</samp>). Given a public
    key, the latter ensures the validity of a public key in that it “represents a
    valid, non-identity point that is in the correct subgroup.”
  prefs: []
  type: TYPE_NORMAL
- en: Key validation prevents the use of weak private/public keys pairs, for which
    signatures are easier to forge. For example, take the trivial case of a zero secret
    key *a* = 0\. It follows that the signature of any message *M* is 0 × **H**(*M*)
    = 0\. It’s therefore trivial to forge a signature for any message. In that case,
    the public key is then 0 × *G* = *O*, which is the point at infinity. If key validation
    rejects public keys equal to *O*, it ensures that the secret key is not zero.
  prefs: []
  type: TYPE_NORMAL
- en: A less trivial case is when the public key, as an elliptic curve point, has
    a value that makes it easier to forge signatures—that is, to create a valid signature
    without knowing the private key. Not all points on a given elliptic curve are
    equally secure—in particular, points that belong to a small subgroup rather than
    to the main subgroup of points. If a public key point belongs to one such small
    subgroup, there will be way fewer possible valid signatures, making it easier
    to forge a signature. Likewise, if the public key offered to the verification
    function doesn’t belong to the elliptic curve, then valid signatures are easy
    to forge.
  prefs: []
  type: TYPE_NORMAL
- en: It’s therefore crucial to check that public keys are valid using the <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyValidate</samp>
    algorithm from the aforementioned specification, as copied in [Listing 15-1](chapter15.xhtml#Lis15-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-1: The</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">KeyValidate</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">algorithm
    ensures that a BLS public key is valid.</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If you implement BLS signatures, make sure your code does all the checks described
    in the BLS specification when validating public keys and signatures.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Key Cancellation Attack</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In their basic form, BLS aggregate signatures with aggregate public keys are
    subject to the same type of key cancellation attack as Schnorr signatures: if
    an attacker knows the public keys *P*[1], *P*[2], . . . , *P*n – [1] of the first
    *n* – 1 signers, they can claim that their public key is'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg315-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *X* is the public key for which they know the private key *x*, such that
    *X* = *xG*. When the attacker presents a signature created from *x*, unsuspecting
    users verify a message’s signature using the public key *P*[1] + *P*[2] + . .
    . + *P*n, which is equal to *X*. The attacker can single-handedly sign a message
    on behalf of the set of supposed signers.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this attack, users may prove the knowledge of their public key’s
    private key by signing a message. As the attacker doesn’t know the private key
    of *P*n, they would fail this test.
  prefs: []
  type: TYPE_NORMAL
- en: Another mitigation is to modify the aggregate signature scheme so that the returned
    signature isn’t just the sum of signature *S* = *S*[1] + *S*[2] + . . . + *S*n
    but instead the sum with coefficients derived from public keys, as in
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg315-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *t*i = **H**(*P*i || *P*[1] || *P*[2] || . . . || *P*n) for *i* = 1, 2,
    . . . , *n*. The aggregate public key used to verify a signature is then *P* =
    *t*[1]*P*[1] + *t*[2]*P*[2] + . . . + *t*n*P*n. You can see that this trick works
    by checking that *e*(*P*, **H**(*M*)) still equals *e*(*G*, *S*).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Threshold Signature Protocols</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Threshold signatures* differ from multisignatures and aggregate signatures—which
    require all participants in the signing protocol to have their own public and
    private key—in that there’s a single private key *k* and a single public key *P*,
    and there are *n* participants that each has a distinct *share* of the key *k*i
    where a parameter *t* (the *threshold*) is defined such that *t* < *n* and:'
  prefs: []
  type: TYPE_NORMAL
- en: '*t* + 1 signers can jointly issue a valid signature of some message that is
    verified using the public key *P*, in such a way that no signer learns the private
    key *k*. This is done by running a protocol that uses the shares *k*i of each
    signer and the message to be signed, without ever exposing the private key to
    any party.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of *t* signers or fewer can’t create a signature and therefore can’t determine
    the private key *k* either.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The issued signature looks like a normal, single-signer signature and verifies
    as such.
  prefs: []
  type: TYPE_NORMAL
- en: Threshold signatures are a specific type of *multiparty computation (MPC)*,
    a class of protocols wherein *n* participants compute the output of some function
    *f*(*x*[1], *x*[2], . . . , *x*n) such that each participant knows their respective
    input *x*i and learns the output of the function but doesn’t learn the other participants’
    *x*i inputs. In the case of threshold signatures, the *x*is are shares of the
    private key, and the output is a signature. I’ll elaborate on what a share is
    in the “Secret-Sharing Techniques” section on [page 319](#sec38).
  prefs: []
  type: TYPE_NORMAL
- en: Threshold signatures have the benefit of “hiding” the number of co-signers and
    their identities, as verifiers see only a signature from a single private key.
    While some multisignature and aggregate signature schemes share this property,
    threshold signatures better suit the use case of crypto asset custody because
    there’s only one private key and one public key; you can directly apply threshold
    signatures to distribute control of any address.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Use Cases</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Threshold signatures are used in cryptocurrency and digital asset management
    to distribute control of an address across multiple systems or parties. They can
    serve to share control of an account between a service provider and a user’s device:
    each party has one share of the key and must run a protocol together to sign a
    transaction, thus spending funds. This setup ensures that an attacker can’t autonomously
    authorize transactions, even if they breach the user’s device and obtain the key
    shares. Similarly, the provider can’t initiate transactions without the user’s
    consent. However, implementing this model reliably poses challenges, particularly
    key management aspects (key generation, key rotation, backups, and so on).'
  prefs: []
  type: TYPE_NORMAL
- en: An organization can also use threshold signatures to distribute custody of funds
    across multiple systems, such as different device types, data centers, operating
    systems, and software components. This approach is particularly suitable for cold
    wallets and accounts containing significant assets. Relying solely on threshold
    signatures is insufficient, as comprehensive security measures and controls are
    crucial. For example, one must properly separate accesses to IT components to
    ensure that distinct individuals or IT service providers have access to different
    systems (thus different shares). Moreover, the initiation and approval of transactions
    must be subject to strict controls and an audit trail.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Model</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As with all cryptographic protocols, we need to define what it means for a threshold
    signing scheme to be secure. Such a security model includes the security goal
    (what should be hard for an attacker to do) and the attacker model (the assumptions
    about the attacker’s capabilities). Let’s delve into these two characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security Goals</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The main security goal of threshold signature is the same as that of single-party
    signatures: an attacker must not be able to forge valid signatures, which implies
    they must not be able to determine the private key. This also implies that the
    protocol ensures *input privacy*: the key shares held by the parties shouldn’t
    leak to any other party. Finally, the protocol must ensure *correctness*: the
    signature the protocol computes must be valid and accessible to all participants
    in the protocol execution.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Attacker Models</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There isn’t one security model for threshold signatures; instead, an attacker
    is characterized according to several dimensions. The common threat in all attack
    scenarios is the assumption that an attacker can actively attack network communications—capturing,
    modifying, and injecting messages. Using a secure channel to establish authenticated
    and encrypted communications between the parties thwarts such attacks. Protocol
    designers also assume reliable communications in that all transmitted messages
    should be received in the same order they were sent.
  prefs: []
  type: TYPE_NORMAL
- en: The attacker model of threshold signatures considers the *corruption* of participants—namely,
    that an attacker compromises their system, learns their secrets, and essentially
    gets them to do what they want. The model assumes that an attacker can’t corrupt
    more than *t* parties; otherwise, they’d be able to forge signatures, by definition
    of the threshold signing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine the parameters to consider when an attacker can corrupt participants.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we characterize an attacker by the *number of parties* they could corrupt.
    Two categories of threshold signatures exist, each defined by the maximum number
    of malicious participants that can be compromised without compromising the security
    of the protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Honest majority **Here, the attacker is limited to corrupting less than half
    of the key-sharing parties. Therefore, the threshold *t* must satisfy *t* < *n*/2\.
    By definition, a threshold signing protocol with parameters (*t*, *n*) must be
    safe even with compromised *t* participants. Protocols designed under the honest
    majority assumption are typically more efficient, but they can’t accommodate arbitrary
    values of *t*. For instance, a protocol with parameters (4, 5) is infeasible in
    this model, as it requires tolerating up to four corrupted parties.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dishonest majority **This model allows the protocol to support any value
    of *t* from 1 to *n* – 1\. It enables the creation of protocols where all but
    one of the *n* parties could be corrupted, yet the malicious parties would still
    be incapable of forging signatures or recovering the private key. This model offers
    more flexibility in terms of the threshold value but often requires more complex
    and robust security mechanisms.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also characterize an attacker by what they can do once they corrupt a party
    and learn their secret values (including the key share). There are two attacker
    models defining this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Passive, or honest-but-curious **They learn information from corrupted parties
    but can’t force them to deviate from the protocol. This models “read-only” compromises,
    where an attacker gets a snapshot of a system’s memory, both storage and volatile
    memory (RAM, processor registers).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Active, or malicious **Parties may arbitrarily deviate from the prescribed
    protocol. This models systems fully compromised by an attacker or controlled by
    a malicious insider (such as an operator, administrator, or cloud provider).'
  prefs: []
  type: TYPE_NORMAL
- en: A protocol secure against active attackers is therefore always secure against
    passive attackers, but not the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways for an attacker to choose which parties to corrupt, which
    are defined by the following models of corruption type:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static corruption **The attacker must choose which participants to corrupt
    before starting the protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adaptive corruption **The attacker may wait until after the protocol begins
    to choose which participants to corrupt—and then learn the history of their operations
    throughout the protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: A protocol secure against static corruption is always secure against adaptive
    corruption, but not the other way around. However, there are techniques to convert
    a protocol from secure against static corruption to secure against adaptive corruption.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Secret-Sharing
    Techniques</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: A key ingredient of threshold signatures is *secret-sharing* protocols, or techniques
    that split a secret into multiple pieces (*shares*) distributed to different parties
    in a way that the parties can then jointly recompute the initial secret. Secret-sharing
    protocols can notably be used when creating backups of private keys such that
    different parties store different shares in different locations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Additive Sharing</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The simplest way to share a secret that you see as a number is through *additive
    sharing*: given a number *s*, you share it as *n* values *s*[1], *s*[2], . . .
    , *s*n such that *s*[1] + *s*[2] + . . . + *s*n = *s.* For example, if you work
    with numbers modulo 100, you could create a random additive sharing of the number
    *s* = 47 into four shares as follows: pick three random numbers between 0 and
    99, say *s*[1] = 12, *s*[2] = 94, and *s*[3] = 80, and set *s*[4] = *s* – *s*[1]
    – *s*[2] – *s*[3] = 61\. (Note that subtraction is computed modulo 100, such that
    –1 = 99, –2 = 98, and so on.)'
  prefs: []
  type: TYPE_NORMAL
- en: This approach is very simple but requires using all the shares to recover the
    original secret.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Threshold Sharing</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Threshold sharing is closer to what threshold signatures do: given parameters
    *n* and *t* < *n* and the secret *s*, it creates shares such that you can recover
    the secret using any set of *t* shares out of the *n* created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The best-known threshold sharing method is *Shamir’s secret sharing*, which
    leverages the following property of polynomials: given a polynomial of degree
    *t* of the form'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg319-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: you need the result of only *t* + 1 evaluations of *f*(*x*) on *t* + 1 distinct
    values of *x* to determine all *a*i coefficients, which are fixed values.
  prefs: []
  type: TYPE_NORMAL
- en: To create a threshold secret sharing from this property, set *a*[0] = *s*, the
    secret. Then pick random values of *a*[1] to *a*t and compute *f*(*x*) for *n*
    distinct values of *x*, which will be the *n* shares of the secret.
  prefs: []
  type: TYPE_NORMAL
- en: Recomputing the coefficients from the *f*(*x*) values is a technique called
    *Lagrange interpolation*, from the 18th-century Italian mathematician who developed
    a general method to determine the equation of a curve given a list of points on
    that curve. Indeed, you can view the problem geometrically. If the equation has
    degree 1 (and is of the form *a*[0] + *a*[1]*x*), then it’s the equation of a
    line, and knowing two points on a line is sufficient to uniquely identify the
    line. Likewise, if the equation has degree 2 (of the form *a*[0] + *a*[1]*x* +
    *a*[2]*x*²), then the curve is a parabola, whose equation can be determined with
    three points.
  prefs: []
  type: TYPE_NORMAL
- en: We sometimes find implementations of Shamir’s secret sharing defining a function
    **Lagrange**() that computes the interpolation and returns the *a*[0] coefficient,
    which is the shared secret. If you have values of *f*(*x*) to combine to recover
    the secret, you can define the operation **Lagrange**(*s*[1], *s*[2], . . . ,
    *s*t) returning the shared secret *s*. This works for any combination of *t* distinct
    shares, not necessarily the first *t* ones. The details of the **Lagrange**()
    operation are a bit too technical for this book, but you can implement it as a
    series of basic additions, multiplications, and inverses.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Trivial Case</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One of the simplest types of threshold signature uses the BLS signature, as
    viewed earlier in the context of aggregate signatures. Recall that given a private
    key *k*, BLS signatures compute a signature by multiplying *k* with the curve
    point *H* = **H**(*M*). You can use additive sharing to create a threshold scheme
    with parameters (*n* – 1, *n*). For example, if *n* = 3, split the key into three
    shares such that *k*[1] + *k*[2] + *k*[3] = *k*. Each party then computes their
    share of the signature by multiplying their share *k*i with *H*. Adding the three
    shares then yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg320-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Combining the three shares via addition gives a valid signature with *k*, even
    if none of the parties knows *k*. The parties could also recover *k* if they add
    their respective shares, but adding the shares of two parties reveals no information
    on *k* if the shares were randomly generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a threshold signature scheme with arbitrary *t* and *n*, use the
    Shamir secret-sharing technique and leverage the linearity of the **Lagrange**()
    operation: you generate the key shares *k*i as described in the “Threshold Sharing”
    section and compute the signature like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg320-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Again, you obtain a valid signature with the key *k*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Simple Case</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll now compute Schnorr signatures in the threshold setting, which is a
    bit more technical than with BLS signatures. Recall the Schnorr scheme computes
    a signature as *s* = *r* + *ha*, where *h* = **H**(*R* || *A* || *M*), *r* is
    the per-signature random nonce, and *a* is the signer’s private key. The signature
    also includes *R* = *rG*, the public nonce value. This is relatively easy to turn
    into a threshold signature scheme, owing to its linearity with respect to secret
    values: observe that the secret *r* is added to the secret *a* multiplied by the
    hash *h*, which is not secret.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine the simplest case of two signers, with an additive sharing of the private
    signing key *k* = *a* + *b*, with *a* and *b* the respective key shares of the
    two signers. To sign, the two parties could generate secret nonces *r*[A] and
    *r*[B], with respective public values *R*[A] = *r*[A]*G* and *R*[B] = *r*[B]*G*.
    The parties can then exchange these values and compute the public nonce *R* =
    *R*[A] + *R*[B], which will be part of the signature. *R* is then the public value
    you derive from the private value *r* = *r*[A] + *r*[B], since you have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg320-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, the parties compute their shares of the signature: *s*[A] = *r*[A] +
    *ha* and *s*[B] = *r*[B] + *hb*, which are added together to yield:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg321-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You thus obtain *r* + *hk*, a signature from the key *k*, even though participants
    used only the additive shares *a* and *b* in their computations. To obtain a threshold
    construction for arbitrary parameters *t* and *n*, Shamir’s secret sharing can
    be used instead of additive sharing.
  prefs: []
  type: TYPE_NORMAL
- en: The previous construction isn’t secure enough to satisfy all the security requirements
    of a threshold signing scheme. It’s notably vulnerable to key cancellation attacks
    unless participants *commit* to their nonces in a preliminary phase of the protocol—for
    example, by sending the hash of their nonce. It also has a number of subtle vulnerabilities
    addressed by the protocol Flexible Round-Optimized Schnorr Threshold (FROST) signatures,
    designed by cryptographers Chelsea Komlo and Ian Goldberg in 2020 and documented
    at *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2020<wbr>/852](https://eprint.iacr.org/2020/852)*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The EdDSA signature protocol from [Chapter 12](chapter12.xhtml) is similar
    to Schnorr’s signatures but computes the nonce as a hash from the message, rather
    than as a random, arbitrary value. This complicates the creation of threshold
    signature protocols compliant with the original EdDSA specification.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Hard Case</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The hardest signature scheme to run in a threshold setting is also the most
    common. The ECDSA signature algorithm (see [Chapter 12](chapter12.xhtml)) is more
    complex than Schnorr signatures and EdDSA because it involves a division. Given
    a message hash *h* = **H**(*M*), the signer picks a random number *k*, computes
    the number *r* from the point *kG*’s coordinates, and computes the signature as
    *s* = (*h* + *ra*) / *k*, where *a* is the private key of the signer.
  prefs: []
  type: TYPE_NORMAL
- en: Efficient and secure ECDSA threshold signatures remain a challenging research
    problem among cryptographers. The first practical protocols appeared in the late
    2010s, motivated by the use case of cryptocurrency—most of the leading cryptocurrencies,
    including Bitcoin and Ethereum, then supported only ECDSA as a transaction signing
    scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographers devised several approaches to build ECDSA threshold signing protocols.
    For example, Yehuda Lindell’s 2017 “Fast Secure Two-Party ECDSA Signing” (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2017<wbr>/552](https://eprint.iacr.org/2017/552)*)
    required a commitment scheme, homomorphic encryption scheme, and zero-knowledge
    proof system. The complexity of such protocols complicated their understanding,
    implementation, and security analysis, leading to a number of security flaws in
    deployed systems.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Things Can Go
    Wrong</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Specific security issues in threshold signature protocols are often complex
    and involve details of cryptographic constructions that I haven’t covered in this
    book. Therefore, instead of specific problems, I’ll discuss categories of problems
    that impacted real deployments of threshold signatures, from widely used open
    source software to commercial solutions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Papers vs. Code</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When engineers need to implement a threshold signature protocol from their
    research papers, they encounter challenges. These papers, primarily aimed at cryptography
    researchers, often vary in editorial quality and are complicated, heavy in mathematics,
    and quite new. This recency can mean that an experimental protocol might not be
    as secure as intended. These factors contribute to a range of real-world security
    issues, which can be categorized into four main areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insecure protocol **If the protocol isn’t secure on paper, it won’t be more
    secure in implementation. Common issues include overlooked edge cases or inadequate
    validation when receiving inputs from other parties. For example, some protocols
    failed to verify if an encrypted number falls within the expected range, leading
    to practical attacks.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Incomplete description **Research papers aren’t technical specifications
    but are written for academic audiences, so they often lack practical implementation
    details like networking and encoding. A notable example is the TSSHOCK attack
    on threshold signatures, which exploited ambiguous encoding in a hash function’s
    input elements, as described in “Collisions from Domain Separation Failures” on
    [page 305](#sec13).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Incomplete implementation **The complexity of threshold signing protocols,
    with their numerous subcomponents and detailed requirements, can lead to overlooked
    security validations, particularly if these are mentioned only in appendixes.
    An instance of this was when a protocol required a number *N* = *pq* (for Paillier
    encryption) to be verified as the product of two large enough primes via a zero-knowledge
    proof, but this verification was omitted in the implementation, allowing insecure
    *N* values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insecure component choice **Descriptions of protocols usually don’t say “use
    the hash function BLAKE3” or “use the 256-bit elliptic curve nistp256”; instead,
    they say “use a hash function and an elliptic curve that offer the security level
    you need.” It’s thus up to the implementers to pick suitable primitives and use
    their programming interfaces securely. For example, using an RSA modulus of 1,024
    bits isn’t enough to ensure 128-bit security.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, risks arise when implementers intentionally modify a protocol,
    perhaps to enhance efficiency or fit a specific use case. This usually doesn’t
    end well. For examples of attacks on threshold signatures, see the papers “Alpha-Rays:
    Key Extraction Attacks on Threshold ECDSA Implementations” by Dmytro Tymokhanov
    and Omer Shlomovits (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2021<wbr>/1621](https://eprint.iacr.org/2021/1621)*)
    and “Practical Key-Extraction Attacks in Leading MPC Wallets” by Nikolaos Makriyannis,
    Oren Yomtov, and Arik Galansky (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2023<wbr>/1234](https://eprint.iacr.org/2023/1234)*).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Key Management Aspects</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A friend once remarked, “For every 10 lines of encryption code, there are 1,500
    lines of key management,” which emphasizes the criticality and intricacy of key
    management processes, including key creation, storage, backup, and recovery. While
    these facets may be overlooked in academic papers focusing on theoretical aspects,
    they’re vital in practical applications. Engineers and security professionals
    implementing threshold signing in a production environment must prioritize these
    key management issues—even the most robust threshold signature protocols are no
    substitute for comprehensive key management practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review the main key management considerations for an organization employing
    threshold signatures to safeguard substantial cryptocurrency holdings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Key generation **Whether you’re using distributed key generation or centralized
    generation, you must ensure that the secret values aren’t exposed to unauthorized
    systems or parties during or after the key generation. This assurance is generally
    provided through rigorous processes such as key ceremonies, ensuring supply-chain
    integrity and audit trail, to demonstrate that keys have been generated properly.
    Don’t allow another party (such as a cloud provider) to generate keys on your
    behalf or to have the capability to read them at any time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Key storage **Storing a key as multiple shares instead of a single value
    doesn’t diminish the necessity for secure storage. Safeguarding numerous secrets
    across diverse platforms can present more of a challenge than protecting a single
    secret on a unified platform. Key shares must be stored in some type of secure
    memory, protected against unauthorized access, tampering, and physical attacks.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Key backup and recovery **Implementing a threshold scheme where, for instance,
    you require three out of six shares to sign a transaction, protects against the
    loss of key shares or system outages. Nevertheless, this doesn’t negate the necessity
    for key backups, which you should also maintain as threshold shares. It’s imperative
    to distribute access to these backup shares among distinct parties. Additionally,
    validate the reliability of backups periodically to ensure they haven’t been compromised
    and can be effectively utilized to reconstruct the key when necessary, such as
    during disaster recovery drills.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Zero-Knowledge Proofs</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Zero-knowledge proofs (ZKPs)* are one of cryptographers’ most powerful tools.
    These are protocols between two parties, a *prover* and a *verifier*, where the
    prover convinces the verifier that something is true without revealing anything
    about why. For example, the prover could prove that they know a solution to some
    hard computational problem without revealing the solution. You might create a
    ZKP for any **NP**-complete problems to prove you know a solution without revealing
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: More generally, ZKPs are used to prove a statement, such as “the number encrypted
    in this ciphertext is between 100 and 200” or “for a given plaintext *P* and ciphertext
    *C*, I know a secret key *K* for which *C* = **AES**(*K*, *P*).”
  prefs: []
  type: TYPE_NORMAL
- en: For a non-technical introduction to zero-knowledge proofs, I recommend cryptographer
    Amit Sahai’s video “Computer Scientist Explains One Concept in 5 Levels of Difficulty”
    (*[https://<wbr>youtu<wbr>.be<wbr>/fOGdb1CTu5c](https://youtu.be/fOGdb1CTu5c)*).
    For mathematical details, see the links on *[https://<wbr>github<wbr>.com<wbr>/matter<wbr>-labs<wbr>/awesome<wbr>-zero<wbr>-knowledge<wbr>-proofs](https://github.com/matter-labs/awesome-zero-knowledge-proofs)*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The term* zero-knowledge proof *is a simplification of more accurate terms
    from the research literature. For example, many “zero-knowledge proof” protocols
    are in fact* zero-knowledge arguments of knowledge*. Researchers reserve the term*
    proof *for unconditional security and use* argument *for computational security.
    Furthermore, the term* witness *refers to the secret allowing the prover to prove
    its statement, as a generalization of* secret *or* secret key*, due to its broader
    scope.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Model</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What does it mean for a ZKP protocol to be secure? Is the attacker the prover
    or the verifier? How can they attack the protocol? Let’s answer these questions
    by examining security goals and attacker models.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security Goals</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A secure ZKP must satisfy the following notions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Completeness **If the prover follows the protocol using the correct secret,
    an honest verifier is convinced of the truth of the statement. In other words,
    the protocol always works.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Soundness **If the prover doesn’t know the secret, they can’t convince the
    honest verifier of a false statement (except with negligible probability). In
    other words, provers can’t cheat.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zero-knowledge **A verifier learns nothing beyond the fact that the statement
    is true. Specifically, they can’t learn anything about the prover’s secret.'
  prefs: []
  type: TYPE_NORMAL
- en: The notion that a verifier “will be convinced of the truth of the statement”
    is guaranteed by the mutual agreement that the protocol satisfies these three
    properties—namely, that a prover could not complete the protocol if the statement
    was false (for example, if they didn’t know the solution they claim to).
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Attacker Models</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both parties can potentially be attackers attempting to compromise soundness
    and zero-knowledge, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Malicious provers **Want to prove a false statement—for example, to wrongly
    convince the verifier that they know a solution to some hard problem. Such an
    attacker can deviate from the protocol to try to fool the verifier. In practice,
    this is the greatest threat to ZKPs in applications like confidential program
    execution.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Malicious verifiers **Want to extract information about the secret (the *witness*),
    thereby breaking the zero-knowledge property. Attacker models distinguish *passive*
    verifier attackers (honest-but-curious) and *active* verifier attackers (who can
    arbitrarily deviate from the protocol).'
  prefs: []
  type: TYPE_NORMAL
- en: Note that malicious verifiers can challenge completeness by claiming they aren’t
    convinced by the truth of a statement. In practice, this isn’t an issue, as the
    prover can repeat the proof protocol for other (honest) verifiers who would expose
    the lying verifier.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Schnorr’s Protocol</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Claus-Peter Schnorr, who created the eponymous signature scheme, also described
    a similar construction that is a zero-knowledge *proof of knowledge of a discrete
    logarithm*. It’s the basis for Schnorr’s and EdDSA signatures, as well as for
    many more complex ZKPs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Schnorr’s protocol works in three steps to prove the knowledge of *a* such
    that *aG* = *A*—that is, the discrete logarithm of *A* with respect to the generator
    *G*:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.  *Commitment*: The prover picks a random number *r* and sends *R* = *rG*.'
  prefs: []
  type: TYPE_NORMAL
- en: '2.  *Challenge*: The verifier sends a random number *c*.'
  prefs: []
  type: TYPE_NORMAL
- en: '3.  *Response*: The prover sends *s* = *r* + *ca*, and the verifier accepts
    if and only if *sG* = *R + cA*.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This kind of three-step protocol, with a commitment, a challenge, and a response,
    is called a* sigma protocol*, after the shape of the uppercase Greek letter sigma
    (Σ).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *completeness* of Schnorr’s protocol is the easiest to verify: if *a* satisfies
    *aG* = *A*, you’ll have'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg325-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: which is the prover’s validation condition.
  prefs: []
  type: TYPE_NORMAL
- en: To see that the protocol ensures *soundness*—that the prover must know *a*—imagine
    that the prover uses the same *r* twice in two runs of the protocol. The verifier
    thus gets two responses, *s*[1] = *r* + *c*[1]*a* and *s*[2] = *r* + *c*[2]*a*,
    for the two distinct challengers *c*[1] and *c*[2]. Now they can compute
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg326-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and divide the result by (*c*[1] – *c*[2]) to obtain *a*. Since the check that
    *sG* equals *R* + *cA* ensures that you had *s* = *r* + *ca*, it follows that
    the prover must know *a* when executing this protocol correctly. This kind of
    logical reasoning is called a *knowledge extractor*, and it’s the main technique
    to show that a ZKP is sound.
  prefs: []
  type: TYPE_NORMAL
- en: The protocol can also be proved to be zero-knowledge, using a technique called
    a *simulator*, an algorithm that creates messages (or a *transcript of communication*)
    that are indistinguishable from those in a real execution of a zero-knowledge
    proof. However, unlike a real prover, the simulator doesn’t necessarily know the
    secret (or witness) being proven. Despite this, the messages it generates still
    appear valid and convincing to the verifier in the context of the proof system.
  prefs: []
  type: TYPE_NORMAL
- en: In Schnorr’s protocol, the simulator works backward and first chooses a random
    response, *s*, to show that a real *s* will be “as random” as a purely random
    one. Then it picks a random challenge *c* and computes the original commitment
    as *R* = *sG* – *cA*. The proof that the protocol is zero-knowledge then demonstrates
    that these three values are indistinguishable from those of a real execution of
    a protocol yet don’t require the knowledge of the secret *a*. (Note that in Schnorr’s
    case, you must assume that the verifier follows the protocol and picks a random
    *c*.)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Noninteractive Proofs</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Schnorr’s protocol is *interactive*: the prover sends a first message, the
    verifier responds with a challenge, and the prover sends them a response—the parties
    interact over three rounds of messages. But what if the verifier can’t send messages
    and just wants to receive a single message that convinces them? How can one create
    such *noninteractive* proofs from an interactive protocol?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take another look at the Schnorr protocol, wherein the verifier sends
    a random challenge *c*, a value that must be unpredictable to the prover. If the
    prover knows *c* before sending *R*, they can cheat, as follows: given *c*, choose
    some arbitrary value for *s*, and compute *R* = *sG* – *cA*; then send this *R*
    to the verifier, and send *s* as a response to *c*. Verification succeeds, yet
    the prover didn’t need to use the secret value *a*.'
  prefs: []
  type: TYPE_NORMAL
- en: How do you make *c* unpredictable to the prover without interacting with a verifier?
    The trick is to derive *c* from *R* using a hash function, which prevents the
    prover from finding a pair (*R*, *c*) that satisfies *sG* = *R* + *cA* due to
    the pseudorandom behavior of hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a *noninteractive zero-knowledge (NIZK)* proof of knowledge of
    the secret *a* using Schnorr’s protocol, a prover proceeds as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.  *Commitment*: The prover picks a random number *r* and computes *R* = *rG*.'
  prefs: []
  type: TYPE_NORMAL
- en: '2.  *Challenge*: The prover computes *c* = **H**(*G* || *R* || *A*); you must
    include the values *G* and *A* to bind the *c* generation to the generator parameter
    *G* and to the public key *A* of the prover.'
  prefs: []
  type: TYPE_NORMAL
- en: '3.  *Response*: The prover computes *s* = *r* + *ca* and generates the proof
    as an encoding of *R* and *s*.'
  prefs: []
  type: TYPE_NORMAL
- en: To verify a proof (*R*, *s*) received from the prover with public key *A*, a
    verifier recomputes the challenge *c* = **H**(*G* || *R* || *A*) and checks the
    equality if *sG* = *R* + *cA*.
  prefs: []
  type: TYPE_NORMAL
- en: The trick in hash function protocol data to replace verifier-generated challenges
    was formalized by the *Fiat–Shamir transform*, a general technique to turn an
    interactive protocol into a noninteractive one. For this transform to be applicable,
    a verifier’s random challenges must be independent of the prover’s message and
    be public (nonsecret) values.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">zkSNARKs</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s talk about the kind of zero-knowledge proof that’s seen wide adoption
    in blockchain applications due to its power and efficiency. For example, zkSNARKs
    are the cornerstone of the Zcash confidential transaction platform: in Zcash,
    zkSNARKs prove that a certain amount has been deducted from an account and credited
    to another account, without revealing the amount of the accounts and without leading
    to a prohibitively large amount of computation or storage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *zkSNARK* is a type of noninteractive proof of knowledge that offers the
    zero-knowledge (*zk*) property, where *SNARK* stands for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Succinct **The proof is very small compared to the size of the statement
    and the secret. It may be similar in size to the statement size’s logarithm, or
    even of *constant size*—always of the same size regardless of the statement’s
    size.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Noninteractive **A SNARK is a noninteractive argument of knowledge, typically
    using the Fiat–Shamir transform to turn an interactive protocol into a noninteractive
    one. It doesn’t need the verifier to send messages to the prover.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Argument **The *argument* of knowledge is a computationally secure proof
    that is conditionally secure. In other words, it wouldn’t be secure against an
    attacker with infinite computing power, which is generally a tolerable limitation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Of knowledge **A SNARK offers completeness and soundness, as an argument
    of knowledge.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, proving and verifying a zkSNARK must be computationally efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Generating such a succinct proof when you want to prove the knowledge of a solution
    to a problem whose description doesn’t even fit in the proof size sounds counterintuitive.
    For example, what about statements like “I know a solution to the equation *f*(*x*)
    = 0,” when the equation *f*(*x*) can be of arbitrary size? From a theoretical
    perspective, short proofs make sense because the only information a proof must
    convey is the *knowledge* of some solution and generally the *correctness* of
    some statement, as opposed to the actual solution and secrets; the proof must
    be zero-knowledge and reveal only that information to the verifier.
  prefs: []
  type: TYPE_NORMAL
- en: In 2016, cryptographer Jens Groth published the article “On the Size of Pairing-Based
    Non-interactive Arguments” (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2016<wbr>/260](https://eprint.iacr.org/2016/260)*),
    which describes an exceptionally efficient zkSNARK. The proof consisted of only
    three group elements and could be verified by computing three pairing operations
    (the same type of pairing as with BLS signatures). The Zcash protocol adopted
    this breakthrough result, which laid the foundation for several other zkSNARKs.
    Groth’s zkSNARK is usually just called *Groth16*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">From Statements to
    Proofs</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: zkSNARKs are some of the most complex cryptographic constructions, with one
    of their most complex and costly steps being *arithmetization*, an operation that
    converts the statement to prove into a fixed number of polynomial equations, which
    are generally of the form
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg328-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: for a polynomial of degree *n*, where the coefficients *a*i are elements of
    some finite ring or finite field structure. The proving algorithm then processes
    the polynomials to create the zkSNARK proof.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arithmetization follows a general workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Describe the statement to prove using formal notations, such as a computer
    program, equations, or logical formulas.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Transform the formal expression from step 1 into a *circuit*, which defines
    an output from input values by applying a sequence of *gates* to the input, similar
    to logical gates in a Boolean or electronic circuit, except that the gates may
    be algebraic operations such as addition and multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Turn the circuit into a structured list of *constraints*, according to the
    zkSNARK proof system’s constraint system. Such constraints are lists of conditions
    that the input must fulfill to satisfy the statement to prove.
  prefs: []
  type: TYPE_NORMAL
- en: 'The statement to prove may be as trivial as “I know integer *x* and *y* satisfying
    the equation *x*³ + *y*² + *xy* + 55 = 0 mod 57.” This completes step 1 by having
    a formal equation expressing the problem. To complete step 2, you may break down
    the equation as a sequence of simple operations involving two operands (Groth16
    requires this). This works as follows, where you write the intermediate values
    *v*[0], *v*[1], . . . , *v*[6]:'
  prefs: []
  type: TYPE_NORMAL
- en: Set *v*[0] = *x* × *x*.
  prefs: []
  type: TYPE_NORMAL
- en: Set *v*[1] = *x* × *v*[0]; thus *v*[1] = *x*³.
  prefs: []
  type: TYPE_NORMAL
- en: Set *v*[2] = *y* × *y*.
  prefs: []
  type: TYPE_NORMAL
- en: Set *v*[3] = *x* × *y*.
  prefs: []
  type: TYPE_NORMAL
- en: Set *v*[4] = *v*[1] *+ v*[2].
  prefs: []
  type: TYPE_NORMAL
- en: Set *v*[5] = *v*[4] *+ v*[3].
  prefs: []
  type: TYPE_NORMAL
- en: Set *v*[6] = *v*[5] + 55; thus *v*[6] = *x*³ + *y*² + *xy* + 55.
  prefs: []
  type: TYPE_NORMAL
- en: Such a translation of a long equation into a series of small ones is called
    *flattening*.
  prefs: []
  type: TYPE_NORMAL
- en: The prover then converts these operations—the circuit—into a set of mathematical
    structures that serve to construct the polynomials processed by the prover. The
    long polynomials are finally “compressed” into a proof using randomness, specifically
    the concept of *probabilistically checkable proof (PCP)*, which is a major discovery
    from the field of complexity theory. This convinces a verifier that many constraints
    are satisfied with only a few actual constraint checks, while preserving the zero-knowledge
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about the intricacies of arithmetization, research the two main
    approaches used by zkSNARKs: rank-1 constraint systems (R1CS) and algebraic intermediate
    representations (AIR).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, note that we distinguish *nonuniversal* and *universal* zkSNARK proof
    systems: in the former, the prover works for a specific, predefined statement.
    In particular, the setup phase of the proof system creates parameters suitable
    only to a given statement. However, universal proof systems such as Marlin and
    Plonk take as input a statement and create a proof for it. They’re more flexible
    but also more complex to construct and have higher computation overhead.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Things Can Go
    Wrong</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: zkSNARKs can suffer from the same classes of problems as in the context of threshold
    signatures, from an insecure protocol to implementation flaws. Security issues
    can arise at different stages of the workflow, from the statement definition to
    the arithmetization step and the proof computation. The security notion impacted
    may be completeness, soundness, or zero-knowledge. But most of the time, the greatest
    risk concerns soundness, or the possibility of an attacker to cheat and fool a
    verifier—both because of the potential impact on the application and the subtlety
    of soundness bugs, whereas a leak of “knowledge” is less likely, especially if
    the proof must remain a valid one accepted by a verifier.
  prefs: []
  type: TYPE_NORMAL
- en: In the forthcoming examples, we’ll focus on Schnorr’s protocol. The problems
    are relatively simple, but more complex proof systems can have much subtler issues.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that Schnorr’s noninteractive protocol proves the knowledge of *a* to
    a verifier that knows *A* = *aG* by sending a verifier *s* = *r* + *ca* and *R*
    = *rG* for a random *r* and *c* = **H**(*G* || *R* || *A*). The verifier then
    checks the equality *sG* = *R* + *cA* after recomputing *c*. In the interactive
    version, the verifier chooses *c* randomly.
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Insufficient Fiat–Shamir
    Hashing</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that instead of *c* = **H**(*G* || *R* || *A*), a noninteractive Schnorr
    proof did *c* = **H**(*G* || *A*), making the challenge *c* independent of the
    nonce *R*. The attacker then picks an arbitrary value for *s* and computes *R*
    = *sG* – *cA*. The resulting proof consisting of *s* and *R* is valid, yet the
    attacker didn’t need to know *a*, thereby breaking the protocol’s soundness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, if *c* = **H**(*G* || *R*), omitting the public key *A* from the
    data hashed to define the challenge *c*, an attack is possible: the attacker can
    now choose arbitrary *R* and *s* values and compute the point *B* = (1/*c*) ×
    (*sG* – *R*), which satisfies *sG* = *R* + *cB*. This gives the attacker a proof
    of knowledge of the discrete logarithm of *B*—namely, *b* such that *B* = *bG*—whereas
    they don’t know it.'
  prefs: []
  type: TYPE_NORMAL
- en: These attacks illustrate the importance of including all necessary values in
    the hash function input when using the Fiat–Shamir transform to make a protocol
    noninteractive.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Replay Attacks</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A replay is a trivial but potentially devastating attack. If an attacker learns
    the value of some noninteractive proof of knowledge, they can send it to another
    party and say they created it, claiming the credit for the knowledge proven.
  prefs: []
  type: TYPE_NORMAL
- en: You may avoid this by binding the proof to the identity of the prover, including
    their public key in the data hashed. To prevent replay by the same party over
    time, you may bind the proof to a session identifier or timestamp by including
    such values in the data processed by the Fiat–Shamir hashes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Randomness Reuse</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consider the interactive Schnorr protocol, where the verifier picks a random
    *c*. If the prover has a flawed pseudorandom generator and reuses the same challenge
    *r* twice, then an attacker observing the exchanged values can recover the secret
    *a* by using the two proofs *s*[1] = *r* + *c*[1]*a* and *s*[2] = *r* + *c*[2]*a*
    for two distinct challengers, *c*[1] and *c*[2], and computing *a* = (*s*[1] –
    *s*[2]) / (*c*[1] – *c*[2]).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Really Serious Crypto</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With this final chapter, we’ve reviewed some of the most captivating topics
    in cryptography at the time of writing, from both theoretical and practical viewpoints.
    We’ve touched only the surface, though, particularly in the realm of zero-knowledge
    proof systems, an active research and engineering space with extensive applications
    beyond blockchain technology. But cool cryptography isn’t the panacea of blockchains.
    From multiparty computation protocols such as private set intersection (PSI) to
    homomorphic encryption used for private evaluation of AI models, new applications
    and use cases call for better, faster cryptographic functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: We’re witnessing a golden age in cryptography, with an unprecedented convergence
    of theoretical principles and practical applications. This synergy is providing
    almost magical solutions to some of the most daunting security and privacy problems.
    Nonetheless, significant challenges need to be addressed, particularly in the
    legal and regulatory spheres. It’s imperative that technologists and policymakers
    collaborate closely to navigate these challenges and that both attempt to understand
    each other’s perspectives. It is my hope that this book, and particularly this
    last chapter, contributes to demystifying cryptography and making it more accessible
    and less enigmatic for all its readers.
  prefs: []
  type: TYPE_NORMAL
