- en: Chapter 16. Extended Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter describes extended attributes (EAs), which allow arbitrary metadata,
    in the form of name-value pairs, to be associated with file i-nodes. EAs were
    added to Linux in version 2.6.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: EAs are used to implement access control lists ([Chapter 17](ch17.html "Chapter 17. Access
    Control Lists")) and file capabilities ([Chapter 39](ch39.html "Chapter 39. Capabilities")).
    However, the design of EAs is general enough to allow them to be used for other
    purposes as well. For example, EAs could be used to record a file version number,
    information about the MIME type or character set for the file, or (a pointer to)
    a graphical icon.
  prefs: []
  type: TYPE_NORMAL
- en: EAs are not specified in SUSv3\. However, a similar feature is provided on a
    few other UNIX implementations, notably the modern BSDs (see *extattr(2)*) and
    Solaris 9 and later (see *fsattr(5)*).
  prefs: []
  type: TYPE_NORMAL
- en: EAs require support from the underlying file system. This support is provided
    in *Btrfs*, *ext2*, *ext3*, *ext4*, *JFS*, *Reiserfs*, and *XFS*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support for EAs is optional for each file system, and is controlled by kernel
    configuration options under the *File systems* menu. EAs are supported on *Reiserfs*
    since Linux 2.6.7.
  prefs: []
  type: TYPE_NORMAL
- en: EA namespaces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: EAs have names of the form *namespace.name*. The *namespace* component serves
    to separate EAs into functionally distinct classes. The *name* component uniquely
    identifies an EA within the given *namespace*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Four values are supported for *namespace*: *user*, *trusted*, *system*, and
    *security*. These four types of EAs are used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*User* EAs may be manipulated by unprivileged processes, subject to file permission
    checks: to retrieve the value of a *user* EA requires read permission on the file;
    to change the value of a *user* EA requires write permission. (Lack of the required
    permission results in an `EACCES` error.) In order to associate *user* EAs with
    a file on *ext2*, *ext3*, *ext4*, or *Reiserfs* file systems, the underlying file
    system must be mounted with the *user_xattr* option:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Trusted* EAs are like *user* EAs in that they can be manipulated by user processes.
    The difference is that a process must be privileged (`CAP_SYS_ADMIN`) in order
    to manipulate *trusted* EAs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*System* EAs are used by the kernel to associate system objects with a file.
    Currently, the only supported object type is an access control list ([Chapter 17](ch17.html
    "Chapter 17. Access Control Lists")).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Security* EAs are used to store file security labels for operating system
    security modules, and to associate capabilities with executable files ([File Capabilities](ch39.html#file_capabilities
    "File Capabilities")). *Security* EAs were initially devised to support Security-Enhanced
    Linux (SELinux, [http://www.nsa.gov/research/selinux/](http://www.nsa.gov/research/selinux/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An i-node may have multiple associated EAs, in the same namespace or in different
    namespaces. The EA names within each namespace are distinct sets. In the *user*
    and *trusted* namespaces, EA names can be arbitrary strings. In the *system* namespace,
    only names explicitly permitted by the kernel (e.g., those used for access control
    lists) are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*JFS* supports another namespace, *os2*, that is not implemented in other file
    systems. The *os2* namespace is provided to support legacy OS/2 file-system EAs.
    A process doesn’t need to be privileged in order to create *os2* EAs.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and viewing EAs from the shell
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'From the shell, we can use the *setfattr(1)* and *getfattr(1)* commands to
    set and view the EAs on a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: One of the points that the preceding shell session demonstrates is that the
    value of an EA may be an empty string, which is not the same as an EA that is
    undefined. (At the end of the shell session, the value of *user.x* is an empty
    string and *user.y* is undefined.)
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, *getfattr* lists only the values of *user* EAs. The *-m* option
    can be used to specify a regular expression pattern that selects the EA names
    that are to be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]*`pattern`*[PRE3]'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value for *pattern* is `^user\.`. We can list all EAs on a file
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Extended Attribute Implementation Details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we extend the overview of the preceding section to fill in
    a few details of the implementation of EAs.
  prefs: []
  type: TYPE_NORMAL
- en: Restrictions on *user* extended attributes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It is only possible to place *user* EAs on files and directories. Other file
    types are excluded for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: For a symbolic link, all permissions are enabled for all users, and these permissions
    can’t be changed. (Symbolic link permissions have no meaning on Linux, as detailed
    in Section 18.2.) This means that permissions can’t be used to prevent arbitrary
    users from placing *user* EAs on a symbolic link. The resolution of this problem
    is to prevent all users from creating *user* EAs on the symbolic link.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For device files, sockets, and FIFOs, the permissions control the access that
    users are granted for the purpose of performing I/O on the underlying object.
    Manipulating these permissions to control the creation of *user* EAs would conflict
    with this purpose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, it is not possible for an unprivileged process to place a *user*
    EA on a directory owned by another user if the sticky bit ([Set-User-ID, Set-Group-ID,
    and Sticky Bits](ch15.html#set-user-id_comma_set-group-id_comma_and "Set-User-ID,
    Set-Group-ID, and Sticky Bits")) is set on the directory. This prevents arbitrary
    users from attaching EAs to directories such as `/tmp`, which are publicly writable
    (and so would allow arbitrary users to manipulate EAs on the directory), but which
    have the sticky bit set to prevent users from deleting files owned by other users
    in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation limits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Linux VFS imposes the following limits on EAs on all file systems:'
  prefs: []
  type: TYPE_NORMAL
- en: The length of an EA name is limited to 255 characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An EA value is limited to 64 kB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, some file systems impose more restrictive limits on the size and
    number of EAs that can be associated with a file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On *ext2, ext3*, and *ext4*, the total bytes used by the names and values of
    all EAs on a file is limited to the size of a single logical disk block ([File
    Systems](ch14.html#file_systems-id1 "File Systems")): 1024, 2048, or 4096 bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On *JFS*, there is an upper limit of 128 kB on the total bytes used by the names
    and values of all EAs on a file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System Calls for Manipulating Extended Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we look at the system calls used to update, retrieve, and remove
    EAs.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and modifying EAs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *setxattr(), lsetxattr()*, and *fsetxattr()* system calls set the value
    of one of a file’s EAs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All return 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: 'The differences between these three calls are analogous to those between *stat()*,
    *lstat()*, and *fstat()* ([Retrieving File Information: *stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "Retrieving File Information: stat()")):'
  prefs: []
  type: TYPE_NORMAL
- en: '*setxattr()* identifies a file by *pathname*, and dereferences the filename
    if it is a symbolic link;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*lsetxattr()* identifies a file by *pathname*, but doesn’t dereference symbolic
    links; and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*fsetxattr()* identifies a file by the open file descriptor *fd*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same distinction applies to the other groups of system calls described in
    the remainder of this section.
  prefs: []
  type: TYPE_NORMAL
- en: The *name* argument is a null-terminated string that defines the name of the
    EA. The *value* argument is a pointer to a buffer that defines the new value for
    the EA. The *size* argument specifies the length of this buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, these system calls create a new EA if one with the given *name*
    doesn’t already exist, or replace the value of an EA if it does already exist.
    The *flags* argument provides finer control over this behavior. It may be specified
    as 0 to obtain the default behavior, or as one of the following constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`XATTR_CREATE`'
  prefs: []
  type: TYPE_NORMAL
- en: Fail (`EEXIST`) if an EA with the given *name* already exists.
  prefs: []
  type: TYPE_NORMAL
- en: '`XATTR_REPLACE`'
  prefs: []
  type: TYPE_NORMAL
- en: Fail (`ENODATA`) if an EA with the given *name* doesn’t already exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the use of *setxattr()* to create a *user* EA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving the value of an EA
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *getxattr()*, *lgetxattr()*, and *fgetxattr()* system calls retrieve the
    value of an EA.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All return (nonnegative) size of EA value on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *name* argument is a null-terminated string that identifies the EA whose
    value we want to retrieve. The EA value is returned in the buffer pointed to by
    *value*. This buffer must be allocated by the caller, and its length must be specified
    in *size*. On success, these system calls return the number of bytes copied into
    *value*.
  prefs: []
  type: TYPE_NORMAL
- en: If the file doesn’t have an attribute with the given *name*, these system calls
    fail with the error `ENODATA`. If *size* is too small, these system calls fail
    with the error `ERANGE`.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to specify *size* as 0, in which case *value* is ignored but
    the system call still returns the size of the EA value. This provides a mechanism
    to determine the size of the *value* buffer required for a subsequent call to
    actually retrieve the EA value. Note, however, that we still have no guarantee
    that the returned size will be big enough when subsequently trying to retrieve
    the value. Another process may have assigned a bigger value to the attribute in
    the meantime, or removed the attribute altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Removing an EA
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *removexattr()*, *lremovexattr()*, and *fremovexattr()* system calls remove
    an EA from a file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All return 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The null-terminated string given in *name* identifies the EA that is to be removed.
    An attempt to remove an EA that doesn’t exist fails with the error `ENODATA`.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the names of all EAs associated with a file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *listxattr()*, *llistxattr()*, and *flistxattr()* system calls return a
    list containing the names of all of the EAs associated with a file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All return number of bytes copied into list on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The list of EA names is returned as a series of null-terminated strings in the
    buffer pointed to by *list*. The size of this buffer must be specified in *size*.
    On success, these system calls return the number of bytes copied into *list*.
  prefs: []
  type: TYPE_NORMAL
- en: As with *getxattr()*, it is possible to specify *size* as 0, in which case *list*
    is ignored, but the system call returns the size of the buffer that would be required
    for a subsequent call to actually retrieve the EA name list (assuming it remains
    unchanged).
  prefs: []
  type: TYPE_NORMAL
- en: To retrieve a list of the EA names associated with a file requires only that
    the file be accessible (i.e., that we have execute access to all of the directories
    included in *pathname*). No permissions are required on the file itself.
  prefs: []
  type: TYPE_NORMAL
- en: For security reasons, the EA names returned in *list* may exclude attributes
    to which the calling process doesn’t have access. For example, most file systems
    omit *trusted* attributes from the list returned by a call to *listxattr()* in
    an unprivileged process. But note the “may” in the earlier sentence, indicating
    that a file-system implementation is not obliged to do this. Therefore, we need
    to allow for the possibility that a subsequent call to *getxattr()* using an EA
    name returned in *list* may fail because the process doesn’t have the privilege
    required to obtain the value of that EA. (A similar failure could also happen
    if another process deleted an attribute between the calls to *listxattr()* and
    *getxattr()*.)
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The program in [Example 16-1](ch16.html#display_file_extended_attributes "Example 16-1. Display
    file extended attributes") retrieves and displays the names and values of all
    EAs of the files listed on its command line. For each file, the program uses *listxattr()*
    to retrieve the names of all EAs associated with the file, and then executes a
    loop calling *getxattr()* once for each name, to retrieve the corresponding value.
    By default, attribute values are displayed as plain text. If the *-x* option is
    supplied, then the attribute values are displayed as hexadecimal strings. The
    following shell session log demonstrates the use of this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Example 16-1. Display file extended attributes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From version 2.6 onward, Linux supports extended attributes, which allow arbitrary
    metadata to be associated with a file, in the form of name-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a program that can be used to create or modify a *user* EA for a file
    (i.e., a simple version of *setfattr(1)*). The filename and the EA name and value
    should be supplied as command-line arguments to the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
