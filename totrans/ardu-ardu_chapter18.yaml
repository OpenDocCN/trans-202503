- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">18</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ARDUINO-TO-RS485
    COMMUNICATION</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: In the previous chapter, you used the RS232 bus to create long, reliable wired
    data connections between Arduino microcontrollers and other devices. This chapter
    introduces the RS485 bus, which you can use for even longer wired connections.
  prefs: []
  type: TYPE_NORMAL
- en: The RS485 data bus is used for a wide range of devices, from device controllers
    for heating, ventilation, and air conditioning (HVAC) systems to remote-sensor
    communications and security system networks. It requires a twin-core shielded
    wire. Depending on the data speed, your cable length can extend more than 800
    meters, and you can connect up to 256 devices on a single bus. This secure, interference-free
    communication between devices isn’t possible with wireless data modules. RS485
    modules are quite inexpensive, allowing you to easily use them in your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I’ll explain how to connect RS485 interface modules with Arduino.
    You’ll learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: Send data from a remote Arduino to your PC via a circuit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a remote thermometer with LCD readout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build remote-controlled Arduino projects with one primary controller and two
    or more secondary remote-controlled Arduinos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use these projects as a framework for your future Arduino-to-RS485 communication
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The RS485 Bus</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The RS485 data bus was designed to connect two or more data terminal equipment
    devices directly without needing modems over a longer distance than is possible
    with other data buses like the RS232\. It’s ideal for connecting two microcontroller-based
    devices that need to communicate with each other, as it’s more reliable than wireless
    data links and works over a much greater distance between units.
  prefs: []
  type: TYPE_NORMAL
- en: Like RS232, RS485 is a serial data bus that operates in a similar manner to
    the Arduino’s serial port (usually found on pins D0 and D1). However, data doesn’t
    simply pass from the Arduino through an RS485 interface to the RS485-based device
    at the other end. The Arduino must tell the RS485 device whether it’s transmitting
    or receiving data before the data can move along the bus as required. The data
    then travels along the RS485 bus as required to another RS485 device, then to
    the attached Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: Although the RS485 bus sends sequential bits of data representing ones and zeros,
    the signal type differs from the TTL serial you’re used to with Arduino. For comparison,
    the image in [Figure 18-1](chapter18.xhtml#fig18-1) shows some data being sent
    from an Arduino’s serial port, as captured on an oscilloscope. As you can see,
    the ones are at 5 V and the zeros are at 0 V.
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF TTL LOGIC DATA CAPTURED FROM AN OSCILLOSCOPE](../images/fig18-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-1: Data being sent
    from an Arduino serial port</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now consider the same piece of data being sent along RS485, as shown in [Figure
    18-2](chapter18.xhtml#fig18-2). RS485 uses two wires, A and B. When a 1 is sent,
    the A line has a voltage higher than the B line, and when a 0 is sent, the A line
    has a voltage lower than the B line. The voltages used can vary between −7 V and
    12 V DC or more, depending on the RS485 interface hardware used.
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF RS485 LOGIC DATA CAPTURED FROM AN OSCILLOSCOPE](../images/fig18-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-2: Data being sent
    from an RS485 interface</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Using different voltages for ones and zeros over two wires enables clear definition
    of the two bits, removing chance of confusion and thus increasing data accuracy.
    Thanks to the wide voltage range, the length of the RS485 cable has less effect
    on the signal integrity, as there’s more scope for a change in signal voltage
    due to cable length (the longer the cable, the larger the voltage drop over the
    cable due to the resistance of wire). Combined with the use of shielded cable,
    this voltage range means you can use RS485 over much longer distances than other
    data buses, such as RS232.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Connecting to RS485</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic RS485 interface board or module has a transmit terminal (called RO)
    and receive terminal (called DI) used for communication between the Arduino, along
    with power (usually 5V) and GND. An additional signal from the microcontroller
    to the RS485 interface, usually labeled DE/RE, indicates whether data will be
    received or transmitted. On some modules, DE and RE are separate pins which you
    must connect with one other. Finally, as described in the previous section, connection
    between the RS485 interfaces uses two wires, A and B. This allows for *half-duplex
    communication*, in which data travels in one direction at a time.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The RS485 bus also supports full-duplex communication over four wires, but
    describing this in detail is outside the scope of this book.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see all the pins clearly labeled on an inexpensive RS485 module, such
    as PMD Way part number 600197, shown in [Figure 18-3](chapter18.xhtml#fig18-3).
    These modules can be placed conveniently in solderless breadboards for experimenting
    or rapid prototyping. You’ll use them in projects throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE RS485 INTERFACE MODULE](../images/fig18-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-3: An inexpensive
    RS485 interface module</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-4](chapter18.xhtml#fig18-4) shows the schematic symbol used for
    these modules.'
  prefs: []
  type: TYPE_NORMAL
- en: The 5V and GND pins in the schematic connect to a power source. The A and B
    pins of the interface modules connect to other interface modules; A pins are connected
    to A pins, and B pins to B pins. The DI (data in) pin receives data from the Arduino
    and sends it out along RS485\. The R0 pin sends data received over RS485 to the
    Arduino. Finally, use the DE and RE pins in your circuits to set the interface
    module to transmit or receive data, setting them HIGH to transmit and LOW to receive
    data, as you’ll do in the following project.
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE RS485 INTERFACE MODULE SCHEMATIC SYMBOL](../images/fig18-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-4: The RS485 interface
    module schematic symbol</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #51: Creating an Arduino-to-PC
    Data Link</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This project demonstrates how easy it is to send data from one Arduino, to another
    Arduino, to a PC with the RS485 bus. You can also use it to capture data to a
    PC from a remote Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Two Arduino Uno or compatible boards and one USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two RS485 interface modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two solderless breadboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assorted jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A suitable power supply for an Arduino Uno or compatible board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A twin-core wire for a long-distance communication (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As with all the projects in this chapter, you’ll create two Arduino-to- RS485
    circuits: a receiver circuit and a transmitter circuit. The transmitter’s Arduino
    will send data to the receiver’s Arduino via RS485, and that data will then travel
    to the PC via the usual USB connection. You may find it easier to upload the receiver
    and transmitter sketches for this project to their respective Arduinos before
    constructing the circuits, as it is then easier to build out the circuits, especially
    over a distance.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to run a long RS485 cable, use shielded twin-core cable and use
    the cable shield to connect the GND of the transmitter and receiver. However,
    you can also test this project with short hook-up wire.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-5](chapter18.xhtml#fig18-5) shows the schematic diagram for the
    receiver circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE PROJECT #51 RECEIVER CIRCUIT SCHEMATIC](../images/fig18-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-5: The Project #51
    receiver circuit schematic</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-6](chapter18.xhtml#fig18-6) shows the schematic diagram for the
    transmitter circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE PROJECT #51 TRANSMITTER CIRCUIT SCHEMATIC](../images/fig18-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-6: The Project #51
    transmitter circuit schematic</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve built the circuits and uploaded the sketches, connect the receiver
    unit to the PC via USB and open the Arduino’s Serial Monitor or terminal software
    such as CoolTerm (as first explained in [Chapter 14](chapter14.xhtml)). The terminal
    should display values for analog pin 0 on the transmitter circuit’s Arduino, as
    shown in [Figure 18-7](chapter18.xhtml#fig18-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF THE RESULTS OF PROJECT #51 IN THE COOLTERM WINDOW](../images/fig18-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-7: Example output
    from Project #51</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works, first taking a closer look at the sketch for the
    transmitter circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The sketch configures software serial to communicate with the RS485 interface
    modules using digital pins D4 and D3 ❶. It uses Arduino digital pin D2 to control
    the DE/RE pins that determine the data direction on the RS485 bus ❷. In <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the sketch starts
    the software serial that will communicate with the RS485 module, then sets pin
    D2 to output to control the data direction on the RS485 module. It then sets the
    direction to transmit. Finally, in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp>, the sketch continuously sends the example data in the form of the
    value for analog input 0 along the RS485 bus via software serial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider the receiver circuit sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Configuration for the receiver sketch is identical to the transmitter sketch,
    except that the program sets the RS485 module to receive mode by setting digital
    pin D2 to LOW ❶. The Arduino then waits for a character of text to come from the
    RS485 bus via software serial. When a character arrives, the Arduino sends it
    to the attached computer via hardware serial and USB ❷. You can use this project
    to send any type of data generated by devices connected to an Arduino over an
    RS485 data link and back to a PC for recording.
  prefs: []
  type: TYPE_NORMAL
- en: The next project demonstrates a way of viewing data received over an RS485 data
    link that is independent of using a computer for operation.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #52: Creating an Arduino-to-Arduino
    Data Link</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll build an RS485 data link that sends temperature data
    from a BMP180 sensor over the bus, to be displayed using an I²C PCF8574 LCD module.
    Apart from being another good demonstration of using the RS485 data bus, this
    project serves as a framework for building remote real-time monitoring systems
    that don’t require a host computer at the receiving end, such as operating temperature,
    machine speed, or other sensor data.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you’re not familiar with I**²**C PCF8574 module LCDs, review their use
    as described in [Chapter 13](chapter13.xhtml). I also cover the BMP180 sensor
    in [Chapter 10](chapter10.xhtml).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following parts for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Two Arduino Uno or compatible boards and one USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two RS485 interface modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two solderless breadboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assorted jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two suitable power supplies for an Arduino Uno or compatible board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PCF8574 LCD module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A BMP180 temperature and air pressure sensor board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A twin-core wire for a longer distance communication (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll again build two Arduino-to-RS485 circuits, a receiver and a transmitter.
    In this project, the transmitter’s Arduino will send temperature data to the receiver’s
    Arduino via RS485 to be displayed on the LCD. Again, you may find it easier to
    upload the two sketches for this project to their respective Arduinos before constructing
    the circuits.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-8](chapter18.xhtml#fig18-8) shows the schematic diagram for the
    receiver circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE PROJECT #52 RECEIVER CIRCUIT SCHEMATIC](../images/fig18-8.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-8: The Project #52
    receiver circuit schematic</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-9](chapter18.xhtml#fig18-9) shows the schematic for the transmitter
    circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE PROJECT #52 TRANSMITTER CIRCUIT SCHEMATIC](../images/fig18-9.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-9: The Project #52
    transmitter circuit schematic</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have uploaded the sketches to their respective Arduino boards and the
    circuits are complete, power both circuits up. The current ambient temperature
    should appear on the LCD, as shown in [Figure 18-10](chapter18.xhtml#fig18-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE PROJECT #52 LCD DISPLAYING: “TEMPERATURE: 28.10 CELSIUS](../images/fig18-10.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-10: Example output
    from Project #52</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works, first taking a closer look at the transmitter sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The sketch first includes the library required to use the BMP180 temperature
    sensor and creates the instance ❶. Again, the sketch configures software serial
    to communicate with the RS485 interface modules using digital pins D4 and D3 ❷.
    The sketch uses Arduino digital pin D2 to control the DE/RE pins that determine
    the data direction on the RS485 bus ❸.
  prefs: []
  type: TYPE_NORMAL
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the sketch
    starts the software serial that will communicate with the RS485 module, then sets
    pin D2 to output to control the data direction on the RS485 module. It then sets
    the direction to transmit and starts the BMP180 sensor. Finally, in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp>, it sends temperature data from the BMP180 sensor every half a second
    along the RS485 bus via software serial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider the receiver circuit sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since the receiver uses the PCF8574 I²C LCD, the required library for the I²C
    bus, the sketch includes the LCD display and instance ❶. In <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp>, it starts the I²C bus and begins communication to the LCD in order
    to configure the LCD display size ❷, turn on the backlight ❸, and clear the display
    ❹. The sketch then includes the RS485 configuration for the receiver sketch. This
    is identical to that of the transmitter sketch, except that the sketch sets the
    RS485 module to receive mode by setting digital pin D2 to LOW.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino waits for text to come from the RS485 bus via software serial ❺.
    Once the text arrives, the sketch converts it into a floating-point number using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">.parsefloat()</samp> function
    from the serial library. The temperature information is then displayed on the
    LCD ❻. The process repeats when more temperature data arrives from the transmitter
    circuit.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #53: Remote Control Operation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Since it supports longer cable runs, the RS485 bus also lends itself well to
    remote-control applications. This project demonstrates remote-control operation
    over RS485, in which one Arduino circuit (the primary) sends signals to another
    Arduino (the secondary) over RS485 to take various actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following parts for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Two Arduino Uno or compatible boards and one USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two RS485 interface modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two solderless breadboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assorted jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two suitable power supplies for an Arduino Uno or compatible board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A twin-core wire for a longer distance communication (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this project, the primary Arduino sends single characters to the secondary
    Arduino via RS485\. You’ll program the secondary Arduino to take various actions
    depending on the character received; if an unknown command is received, a default
    action will occur. Again, you may find it easier to upload the sketches to each
    Arduino before constructing the circuits.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-11](chapter18.xhtml#fig18-11) shows the schematic diagram for the
    primary circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE PROJECT #53 PRIMARY CIRCUIT SCHEMATIC](../images/fig18-11.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-11: The Project #53
    primary circuit schematic</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-12](chapter18.xhtml#fig18-12) shows the schematic diagram for the
    secondary circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE PROJECT #53 SECONDARY CIRCUIT SCHEMATIC](../images/fig18-12.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-12: The Project #53
    secondary circuit schematic</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have uploaded the project sketches to their respective Arduino boards
    and built the circuits, power them both up. The primary Arduino should start sending
    commands to the secondary, which will act on those commands by blinking the Arduino’s
    onboard LED in various sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works, first examining the sketch for the primary circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This sketch configures the primary circuit to transmit over RS485, as did previous
    projects. The point of difference is the example commands sent in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp>. The secondary Arduino is configured to act upon the commands 0,
    1, 2, and 3, so the primary sketch sends those commands as a demonstration. It
    also sends the number 8 to demonstrate the function on the receiver which deals
    with unknown commands. Each command is sent in turn with a delay between each.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the sketch for the secondary circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The secondary circuit is configured to receive commands over RS485 then act
    based on those commands. To demonstrate this, the sketch uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">blinkLED()</samp>
    function, which accepts an integer and blinks the onboard LED that number of times.
    The secondary circuit awaits a character of text (the command) from the RS485
    bus via the software serial port ❶. The secondary unit uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp>
    function ❷ to determine which function to call, depending on the command received
    from the primary unit. If it receives a command that isn’t covered in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp> function, it blinks
    the LED twice ❸.
  prefs: []
  type: TYPE_NORMAL
- en: You can modify this project for your own remote-control needs by replacing the
    calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">blinkLED()</samp> function
    with your own actionable requirements.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Controlling Two or More Secondary RS485
    Devices</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you’ve learned how to communicate between two RS485-connected Arduino
    boards. As mentioned earlier, however, you can control more than one secondary
    device with the RS485 bus, up to 256 devices in total. In this section and the
    following project, I’ll show you how to do so.
  prefs: []
  type: TYPE_NORMAL
- en: The wiring of the RS485 bus is slightly different when using three or more devices.
    The transceiver IC found on the modules you’ve been using also requires a 120
    Ω terminating resistor across the A and B wires at each end of the RS485 bus.
    This resistor is fitted with the required terminating resistor, so if you’re just
    using the two modules, you don’t need to change anything. If you’re using three
    or more of the RS485 modules covered in this chapter, though, you’ll need to desolder
    the terminating resistor labeled R7 on the PCB (with the value 121 on the resistor,
    which is interpreted as 12 Ω, with a 0 added on the end for 120 Ω) from the module.
    This resistor is circled in [Figure 18-13](chapter18.xhtml#fig18-13).
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE TERMINATING RESISTOR ON THE RS485 MODULE](../images/fig18-13.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-13: An RS485 terminating
    resistor</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When wiring your devices over distances longer than that used for demonstration
    on your workbench, ensure the A/B pair of wires travel from device to device in
    a “daisy-chain” configuration, as shown in [Figure 18-14](chapter18.xhtml#fig18-14).
    Don’t create a separate run from each device back to a main A/B pair.
  prefs: []
  type: TYPE_NORMAL
- en: '![AN EXAMPLE OF THE RS485 WIRING CONFIGURATION FOR THREE DEVICES](../images/fig18-14.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-14: Example RS485
    wiring configuration for three devices</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll put this technique to work in the next project.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #54: Controlling Two or More
    Secondary Arduino Boards</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This project demonstrates controlling two or more secondary Arduino boards over
    RS485 from one primary board. One Arduino circuit (the primary) will send commands
    to other Arduinos (the secondary devices) over RS485, telling them to take various
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hardware for this project is the same as that used in Project #53, except
    that you’ll use two or more secondary devices. Start by building one primary device
    and two secondary devices, connecting them via the RS485 bus as shown in [Figure
    18-14](chapter18.xhtml#fig18-14) in the previous section. Again, it’s a good idea
    to upload the sketches to each Arduino before building the circuits. You can add
    more secondary devices to the project later, if you like, once you’ve got your
    three-device setup working.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re just testing this project on your workbench, the distance of the RS485
    bus will be short enough that you may not need to remove the terminating resistors
    from the RS485 modules, so test the code before making any changes to your hardware.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, the primary board sends a three-digit number across the RS485
    bus, which is received by all the secondary boards. The first digit of the command
    represents the number of the secondary unit to control (units 1 through 9), and
    the final 2 digits represent the command being sent to the specific secondary
    unit. For example, to send command 12 to secondary unit 2, the primary would send
    212 across the RS485 bus, since the sketch loaded onto the second secondary unit
    is programmed to act based on receiving 12\. If you add 10 or more secondary units,
    you can change the commands in the sketch so they send four-digit numbers, or
    modify the command coding method for your own needs.
  prefs: []
  type: TYPE_NORMAL
- en: This project is just a demonstration of multiple-secondary-device control over
    RS485\. In its current form, each command sent from the primary will trigger the
    matching secondary device to blink its onboard LED a certain number of times.
    However, in your own future projects, you can replace the simple example actions
    in the secondary units with your own requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works in the sketches, starting with the primary device
    sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In a sequence that should be familiar to you by now, the sketch first configures
    the primary unit to send data to the RS485 bus. In <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp>, it sends two new example commands: 105 ❶, which is command 5 for
    the secondary unit 1, and 205 ❷, which is command 5 for secondary unit 2\. Remember
    that the commands are three digits, with the first being the secondary unit to
    address, and the following two digits (00 to 99) being the actual command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the sketch for secondary device 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This sketch is configured so that commands received from the primary unit call
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">blinkLED()</samp> function with
    a varying parameter to blink the LED a different number of times. In <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp>, the secondary awaits an incoming integer from the RS485 bus ❶.
    It then checks whether the received integer falls between 100 and 199 inclusive
    ❷. If so, meaning the command is intended for this unit, the sketch compares the
    integer against the preset commands using the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp>
    function. For example, if the command 105 is received, the <samp class="SANS_TheSansMonoCd_W5Regular_11">blinkLED()</samp>
    function is called to blink the onboard LED five times ❸. If a command is received
    but not recognized ❹, the LED blinks twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the sketch for secondary device 2 is the same as for secondary
    device 1\. Only the <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>
    section of the sketch differs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The sketch tests the received command to see whether it falls between 200 and
    299 inclusive ❶, as the first digit of the command (2) notes the command is for
    this secondary unit. If the command is for this unit, the sketch compares it against
    the preset commands using the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp>
    function. For example, if the device receives the command 205, the sketch calls
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">blinkLED()</samp> function to
    blink the onboard LED five times ❷. If a command is received but not recognized
    ❸, the LED blinks twice.
  prefs: []
  type: TYPE_NORMAL
- en: To add additional secondary units, you’d simply change the test line ❶ so the
    new unit can check whether a command from the primary device falls within its
    required numeric range. You’d also need to add the appropriate commands and required
    actions in the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp>
    function.
  prefs: []
  type: TYPE_NORMAL
- en: For a challenge, you might try creating a system that returns data from the
    secondary devices back to the primary device.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter has given you the basic building blocks for implementing the RS485
    data bus with Arduino. You can use this knowledge to make your own data transfer
    and control applications over longer distances, such as monitoring sensors or
    controlling devices in other rooms in an office or factory.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll get started with popular Wi-Fi-capable Arduino-compatible
    boards to make remote-control devices that can be controlled from a cell phone
    or any web-enabled device.
  prefs: []
  type: TYPE_NORMAL
