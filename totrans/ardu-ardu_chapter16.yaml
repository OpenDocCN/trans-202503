- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">16</samp> <samp class="SANS_Dogma_OT_Bold_B_11">MONITORING
    AUTOMOTIVE ELECTRONICS WITH THE CAN BUS</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: Cars use a complex network of electronics to monitor operations and control
    various functions, including engine management, temperature measurement, and window
    and lock controls. These electronics and devices communicate with each other over
    the *controller area network data bus (CAN bus)*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn to interface your Arduino with the CAN bus to
    monitor data from certain automotive electronics. You’ll set up and test an Arduino-to-CAN-bus
    data connection and then monitor and record real-time engine statistics for later
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The CAN Bus</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may be familiar with the SPI and I²C data buses. The CAN bus is a data bus
    that is used to connect the engine management computer with other devices in a
    contemporary automobile. This reduces physical wiring between devices and allows
    you to connect an external device, such as a computer, a scanning tool, or your
    Arduino, to the automobile for monitoring operations.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a car’s engine management computer reads sensors in the engine
    and braking system. Using the CAN bus, it then broadcasts the speed, engine RPM,
    temperature, and other data to the computer system that controls the dashboard
    display. When you press the button on a remote control to lock your car doors,
    the radio data transceiver receives the signal from the remote control and then
    likewise instructs the central locking controller unit via the CAN bus to lock
    all the doors.
  prefs: []
  type: TYPE_NORMAL
- en: The protocol used for communication over the CAN bus is called *On-Board Diagnostic
    II (OBDII)*, the second generation of the OBD protocol. You can use an Arduino
    and matching CAN bus shield to communicate with the bus to review car statistics.
  prefs: []
  type: TYPE_NORMAL
- en: Before progressing further, if you plan to build the projects for this chapter,
    check whether your car has a CAN bus and an OBDII connector, as some older cars
    will not. To do this, look around under the dashboard of your car. The connector
    will be in an out-of-the-way position; for example, it appears above the pedals
    in my Mitsubishi Outlander Sport/ASX, as shown in [Figure 16-1](chapter16.xhtml#fig16-1).
    If you can’t initially find your OBDII connector, you may have to refer to the
    manual provided by the manufacturer or the service manual.
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF AN OBDII CONNECTOR UNDER A CAR DASHBOARD](../images/fig16-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-1: An OBDII connector
    socket</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes time to connect a cable to the OBDII connector, hold the socket
    firmly with one hand as you insert the plug with your other hand. The socket is
    usually not mounted with much support, and if you’re not careful, you’ll risk
    breaking the support bracket.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Required CAN Bus Hardware</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the projects in this chapter, you’ll need an Arduino shield such as PMD
    Way part 13479987, shown in [Figure 16-2](chapter16.xhtml#fig16-2). Whichever
    shield you choose, it must use the Microchip MCP2515 CAN controller and MCP2551
    CAN transceiver ICs.
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF THE CAN BUS SHIELD FOR ARDUINO](../images/fig16-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-2: A CAN bus shield
    for Arduino</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll need a matching cable that runs from the vehicle’s OBDII port to
    the nine-pin plug on the shield, such as PMD Way part 717211, shown in [Figure
    16-3](chapter16.xhtml#fig16-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF AN OBDII-TO-DB9 FEMALE CABLE](../images/fig16-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-3: An OBDII-to-shield
    cable</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you’ll need a way to power your Arduino. If you don’t have a laptop
    computer with enough battery life to last an hour or so, consider getting a USB
    power bank, as shown in [Figure 16-4](chapter16.xhtml#fig16-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF A USB POWER BANK](../images/fig16-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-4: A USB power bank</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you could power your project using a USB cable and a car USB
    adapter, as shown in [Figure 16-5](chapter16.xhtml#fig16-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF A CIGAR LIGHTER USB POWER ADAPTER](../images/fig16-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-5: A car USB power
    adapter</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The OBDII connection may differ for each brand and model of car, so it’s a good
    idea to check with enthusiast forums for more information about your car before
    purchasing the hardware required for this chapter. For example, Mitsubishi owners
    could consult the forum at [*https://<wbr>www<wbr>.mitsubishi<wbr>-forums<wbr>.com*](https://www.mitsubishi-forums.com)
    and search for OBDII posts.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the required hardware, download the CAN bus library ZIP file from
    [*https://<wbr>github<wbr>.com<wbr>/sparkfun<wbr>/SparkFun<wbr>_CAN<wbr>-Bus<wbr>_Arduino<wbr>_Library<wbr>/archive<wbr>/master<wbr>.zip*](https://github.com/sparkfun/SparkFun_CAN-Bus_Arduino_Library/archive/master.zip).
    Open the Arduino IDE and select **Sketch** ![](../images/arr.png) **Include Library**
    ![](../images/arr.png) **Add ZIP Library** to install the library.
  prefs: []
  type: TYPE_NORMAL
- en: You’re now ready to test your hardware with a simple CAN bus data retrieval
    sketch.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #47: Monitoring Engine Data</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll use the CAN bus shield to receive basic engine data
    and speed from the car’s engine control unit (ECU) and display this in the Arduino
    IDE’s Serial Monitor. This is a good way to check that the hardware is operating
    and increase familiarity with your car’s operating statistics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your project will monitor the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Car speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engine RPM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throttle position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Percentage of throttle application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engine coolant temperature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oxygen sensor voltage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mass air flow (MAF) sensor values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ECU uses the oxygen sensor voltage to determine the amount of oxygen present
    in the engine exhaust gases, which indicates how fuel efficiently the engine is
    operating. Once your car’s MAF sensor measures the amount of air entering the
    engine, the ECU uses this value to determine the correct amount of fuel needed
    for optimal engine operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following parts for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A CAN bus shield for Arduino
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An OBDII-to-shield cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A laptop computer (preferable but not required)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have a laptop computer running the Arduino IDE, you can use that to monitor
    the project’s output. Otherwise, you could set up a desktop computer in your garage.
    If neither of these is possible, skip to the next project.
  prefs: []
  type: TYPE_NORMAL
- en: To assemble the project, connect the CAN bus shield to the Arduino, the Arduino
    to the computer, and the CAN bus shield to the OBDII connector in the car. If
    your Arduino board has a full-sized USB socket, such as that shown in [Figure
    16-6](chapter16.xhtml#fig16-6), it can rest against the solder joints of the CAN
    bus shield. If this is the case, place some paper between the two to insulate
    the Arduino from the shield.
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF A CAN BUS SHIELD CONNECTED TO AN ARDUINO WITH A USB SOCKET BRUSHING
    SHIELD](../images/fig16-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-6: An Arduino USB
    port contacting the CAN bus shield</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Enter and upload the sketch, and then make sure the car won’t move if you start
    the engine. Start the engine, open the Serial Monitor in the Arduino IDE, and
    set the data rate to 115,200 baud. After a few moments, the engine data should
    be displayed, as shown in [Figure 16-7](chapter16.xhtml#fig16-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF EXAMPLE ECU DATA CAPTURED WITH PROJECT #47](../images/fig16-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-7: Example output
    from Project #47</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the figure, the speed is greater than 0 km/h. That’s because I took the
    car for a drive with a passenger, who took the screenshot using a laptop. This
    test also demonstrates the potential differences in OBDII data between different
    cars: in the results shown in [Figure 16-7](chapter16.xhtml#fig16-7), you can
    see that I didn’t get any readings for the oxygen sensor voltage from the ECU.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The sketch first includes the CAN bus library ❶ and then creates two variables.
    The first is <samp class="SANS_TheSansMonoCd_W5Regular_11">requestDelay</samp>,
    which is used to create a delay after reading data from the CAN bus. You may need
    to alter this variable’s value depending on the car you’re using, but try 100
    first. If the data returned doesn’t match the type or you’re not seeing any data
    at all, you will need to experiment with values that are higher or lower. The
    second variable is the large character array <samp class="SANS_TheSansMonoCd_W5Regular_11">buffer</samp>,
    used to store data received over the CAN bus and then displayed in the Serial
    Monitor.
  prefs: []
  type: TYPE_NORMAL
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the sketch
    initializes the serial output ❷. It then starts CAN bus communication ❸, also
    checking whether it’s possible to communicate between the Arduino and the CAN
    bus using the <samp class="SANS_TheSansMonoCd_W5Regular_11">if (Canbus.init (CANSPEED_500))</samp>
    function. The parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">CANSPEED_500</samp>
    sets the CAN bus shield-to-data rate. The required speed varies depending on the
    car; the appropriate speed for my vehicle was 500 kbps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sketch retrieves data using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Canbus.ecu_req()</samp>
    functions in <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>.
    These functions have two parameters: the data type and the variable in which to
    store the data. For example, the sketch retrieves and places the first piece of
    data, speed, into the <samp class="SANS_TheSansMonoCd_W5Regular_11">buffer</samp>
    variable and then displays that data on the Serial Monitor ❹. A short delay follows,
    after which the next parameters are retrieved and displayed and the process repeats.'
  prefs: []
  type: TYPE_NORMAL
- en: If the project doesn’t work, you may need to change the data rate. You can change
    the parameter to <samp class="SANS_TheSansMonoCd_W5Regular_11">CANSPEED_125</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">CANSPEED_250</samp> for 125 kbps
    or 250 kpbs, respectively, trying different speeds to see what works.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn a lot about your car using this sketch. For example, I found that
    the ECU in my Mitsubishi limited the throttle to 18 percent when the transmission
    was in park or neutral, preventing drivers from unnecessarily over-revving the
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a basic framework to retrieve OBDII data, you’re ready to
    learn to save this data to a microSD card for later review. Keep the hardware
    for this project together, as you’ll also use it in the next project.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #48: Logging OBDII Car Data</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll log the data retrieved from the CAN bus to a microSD
    card, which allows you to analyze the data over time, whether the car is stationary
    or being driven. The required hardware and assembly are the same as the previous
    project, except that you’ll also need a microSD card—the type used in [Chapter
    9](chapter9.xhtml) will be fine—and a power supply for your Arduino, as described
    at the start of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Enter and upload the sketch, insert the microSD card into the CAN bus shield,
    and then confirm the car won’t move if you start the engine. Connect the Arduino
    to the power supply and start the engine. The sketch should retrieve and log the
    data to a text file called *CANBUS.TXT* on the microSD card, with a new entry
    around every second.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re able, take your car for a drive. After you’ve finished, remove the
    power from the Arduino, insert the microSD card into your PC, and open it for
    viewing. It should include the *CANBUS.TXT* file containing all your logged data,
    as shown in [Figure 16-8](chapter16.xhtml#fig16-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF EXAMPLE ECU DATA CAPTURED BY PROJECT #48](../images/fig16-8.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-8: Example data file
    contents from a microSD card</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Open *CANBUS.TXT* in a spreadsheet, and during the opening process, delimit
    with a comma and a space. For example, if you’re using Microsoft Excel, you can
    do this using the Text Import Wizard that appears when you open a text file, as
    shown in [Figure 16-9](chapter16.xhtml#fig16-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![OPENING THE CANBUS.TXT FILE IN EXCEL](../images/fig16-9.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-9: Opening the</samp>
    <samp class="SANS_Futura_Std_Book_11">CANBUS.TXT</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    in Excel</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data is in normal spreadsheet file format, you can now open it
    in spreadsheet software for further analysis, such as to find relationships between
    speed and RPM or RPM and throttle position, as shown in [Figure 16-10](chapter16.xhtml#fig16-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF THE ECU DATA DISPLAYED IN A SPREADSHEET](../images/fig16-10.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-10: Working with
    example data in the spreadsheet</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how the sketch works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The sketch includes the requisite CAN bus library and variables ❶, followed
    by the library to use the microSD card reader and the <samp class="SANS_TheSansMonoCd_W5Regular_11">chipselect</samp>
    variable. This variable indicates which CS pin the microSD card socket uses, in
    this case using a value of 9 for Arduino digital pin 9\. In <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp>, the sketch checks that the microSD card subsection is working
    ❷ and then initializes the CAN bus interface with the required bus speed ❸. As
    in the previous project, if the sketch doesn’t log any data, try changing the
    value for <samp class="SANS_TheSansMonoCd_W5Regular_11">requestDelay</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: If the microSD card and the CAN bus initialize successfully, the sketch moves
    on to the main loop and opens the file on the microSD card for writing ❹. If a
    file to be written to exists ❺, the sketch moves on to retrieve the first piece
    of data from the ECU ❻; then, instead of sending the data to the Serial Monitor,
    the sketch writes it to the microSD card ❼. The process then repeats for the other
    five pieces of data from the ECU. Once finished, the sketch closes the file for
    writing ❽. You can change the period between logging data using <samp class="SANS_TheSansMonoCd_W5Regular_11">delay()</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: For a challenge, you could add a real-time clock IC such as the popular DS3231
    series to log time and date information along with the engine parameters. You
    could also add a GPS module to log speed from both the ECU and the GPS, allowing
    you to compare the inaccuracy of your car’s speedometer.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter gave you the tools to monitor and record various parameters of
    information made available by your vehicle’s systems such as speed, engine RPM,
    throttle position, coolant temperatures, and so on that give greater insight into
    the operation of the engine and its sensors. Each type of vehicle is different,
    so by using the projects you built in this chapter, you can find data specific
    to your own ride.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn how to make an Arduino communicate with other
    devices using the RS232 data bus.
  prefs: []
  type: TYPE_NORMAL
