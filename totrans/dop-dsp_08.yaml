- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Containerizing an Application with Docker
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker容器化应用程序
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: A *container* is the running instance of an application based off a container
    image. Using containers provides you with a predictable and isolated way to create
    and run code. It allows you to package an application and its dependencies into
    a portable artifact you can easily distribute and run. Microservice architectures
    and continuous integration/continuous development pipelines heavily use containers,
    and if you’re a software or DevOps engineer, using containers has most likely
    changed the way you deliver and write software.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*容器*是基于容器镜像的运行实例。使用容器为您提供了一种可预测且隔离的方式来创建和运行代码。它允许您将应用程序及其依赖项打包成一个便于分发和运行的可移植工件。微服务架构和持续集成/持续开发流水线广泛使用容器，如果您是软件工程师或DevOps工程师，使用容器很可能已经改变了您交付和编写软件的方式。'
- en: In this chapter, you’ll learn how to install the Docker engine and the `docker`
    client command line tool. You’ll also get a crash course in Dockerfiles, container
    images, and containers. You’ll combine this knowledge, along with some basic Docker
    commands, to containerize a sample application called *telnet-server* that I’ve
    provided in the repository for this book ([https://github.com/bradleyd/devops_for_the_desperate/](https://github.com/bradleyd/devops_for_the_desperate/)).
    By the end of this chapter, you’ll have a solid understanding of how to use Docker
    to containerize any application, as well as the benefits of doing so.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何安装Docker引擎和`docker`客户端命令行工具。您还将快速了解Dockerfile、容器镜像和容器的基础知识。您将结合这些知识以及一些基本的Docker命令，将我在本书存储库中提供的样例应用程序*telnet-server*容器化（[https://github.com/bradleyd/devops_for_the_desperate/](https://github.com/bradleyd/devops_for_the_desperate/)）。通过本章的学习，您将对如何使用Docker将任何应用程序容器化以及这样做的好处有深入的理解。
- en: Docker from 30,000 Feet
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker的高层视角
- en: The word *Docker* has become synonymous with the container movement. This is
    due to Docker’s ease of use, the rise of microservice architectures, and the need
    to solve the “works on my machine” paradox. The idea of containers has been around
    for quite some time, however, and numerous container frameworks exist. But since
    Docker released its first open-source version in March 2013, the industry has
    adopted the Docker framework as the de facto standard. The first stable version
    of Docker (1.0) was released in 2014, and since then, new versions have included
    many improvements.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 单词*Docker*已经成为容器运动的代名词。这是因为Docker的易用性，微服务架构的兴起，以及解决“在我的机器上可运行”的悖论的需要。容器的概念已经存在了相当长的时间，然而，存在许多容器框架。但自从Docker在2013年3月发布了第一个开源版本以来，该行业已经采纳了Docker框架作为事实上的标准。Docker的第一个稳定版本（1.0）发布于2014年，自那时以来，新版本已包含了许多改进。
- en: 'The Docker framework consists of a Docker daemon (server), a `docker` command
    line client, and other tools that are beyond the scope of this book. Docker uses
    Linux kernel features to build and run containers. These pieces fit together to
    allow Docker to do its magic: *OS-level virtualization*, which partitions the
    operating system into what looks like separate isolated servers, as shown in [Figure
    6-1](#figure6-1). Because of this, containers are effective when you need to run
    a lot of applications on limited hardware.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Docker框架由一个Docker守护程序（服务器）、一个`docker`命令行客户端以及本书范围之外的其他工具组成。Docker利用Linux内核特性来构建和运行容器。这些组件结合在一起使得Docker能够发挥其魔力：*操作系统级虚拟化*，将操作系统分割成看起来像是独立隔离的服务器，如[图
    6-1](#figure6-1)所示。因此，当您需要在有限的硬件上运行大量应用程序时，容器非常有效。
- en: '![Diagram showing these layers from top to bottom: Containerized applications,
    docker framework, host os, infrastructure](image_fi/502482c06/f06001.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![这些层次的图示从上到下依次是：容器化应用程序、Docker框架、主机操作系统、基础设施](image_fi/502482c06/f06001.png)'
- en: 'Figure 6-1: OS-level virtualization'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-1：操作系统级虚拟化
- en: Getting Started with Docker
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Docker入门
- en: First, you’ll create a *Dockerfile* that describes how to build the *container
    image* from your application. A container image is made of different layers that
    house your application, dependencies, and anything else the application needs
    so it can run. Container images can be distributed and served from a service called
    a *registry*. Docker hosts the most popular registry at [https://hub.docker.com/](https://hub.docker.com/).
    There, you’ll find just about any image you might need, such as Ubuntu or the
    PostgreSQL database. With a simple `docker pull` `<image-name>` command, you can
    download and use an image in a matter of seconds. A container is the running instance
    of an application based off the container image. [Figure 6-2](#figure6-2) shows
    how all of Docker’s pieces fit together. In this chapter, you’ll mostly be working
    with the `docker` client.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要创建一个 *Dockerfile*，描述如何从应用程序构建 *容器镜像*。容器镜像由不同的层组成，这些层包含了你的应用程序、依赖关系以及应用程序运行所需的其他内容。容器镜像可以通过一个叫做
    *镜像库* 的服务进行分发和提供。Docker 提供了最受欢迎的镜像库：[https://hub.docker.com/](https://hub.docker.com/)。在这里，你几乎可以找到任何你需要的镜像，例如
    Ubuntu 或 PostgreSQL 数据库。使用简单的 `docker pull` `<image-name>` 命令，你可以在几秒钟内下载并使用一个镜像。容器是基于容器镜像运行的应用实例。[图
    6-2](#figure6-2) 显示了 Docker 各个部分是如何协同工作的。在本章中，你将主要使用 `docker` 客户端。
- en: '![Diagram showing the client (which contains the docker commands), connected
    to the docker host (which contains the docker daemon, containers, and images),
    connected to the registry (which is where the images come from)](image_fi/502482c06/f06002.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![显示客户端（包含 Docker 命令）、连接到 Docker 主机（包含 Docker 守护进程、容器和镜像），再连接到镜像库（镜像的来源）](image_fi/502482c06/f06002.png)'
- en: 'Figure 6-2: Docker framework'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-2：Docker 框架
- en: Dockerfile Instructions
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dockerfile 指令
- en: 'The Dockerfile contains the instructions that teach the Docker server how to
    turn an application into a container image. Each instruction represents a specific
    job and creates a new layer inside the container image. The following list includes
    the most common instructions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 包含了指导 Docker 服务器如何将应用程序转化为容器镜像的指令。每条指令代表一个特定的任务，并在容器镜像内创建一个新的层。以下列表包含了最常见的指令：
- en: '`FROM` Specifies the parent or base image from which to build the new image
    (must be the first command in the file)'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FROM` 指定从哪个父镜像或基础镜像构建新的镜像（必须是文件中的第一个命令）'
- en: '`COPY` Adds files from your current directory (where the Dockerfile resides)
    to a destination in the image filesystem'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`COPY` 将当前目录（Dockerfile 所在的目录）中的文件添加到镜像文件系统中的目标位置'
- en: '`RUN` Executes a command inside the image'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RUN` 在镜像内执行命令'
- en: '`ADD` Copies new files or directories from either a source or a URL to a destination
    in the image filesystem'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ADD` 将新的文件或目录从源位置或 URL 复制到镜像文件系统中的目标位置'
- en: '`ENTRYPOINT` Makes your container run like an executable (which you can think
    of as any Linux command line application that takes arguments on your host)'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT` 使容器像可执行文件一样运行（你可以把它当作任何在主机上接受参数的 Linux 命令行应用程序）'
- en: '`CMD` Provides a default command or default parameters for the container (can
    be used in conjunction with `ENTRYPOINT`)'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CMD` 提供容器的默认命令或默认参数（可以与 `ENTRYPOINT` 配合使用）'
- en: See the Dockerfile reference at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
    for instructions and configuration details.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考 Dockerfile 文档：[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
    以获取指令和配置详情。
- en: Container Images and Layers
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器镜像和层
- en: The Dockerfile you build creates a container image. This image is made of different
    layers that house your application, dependencies, and anything else the application
    needs so it can run. These layers are like snapshots in time of your application’s
    state, so keeping your Dockerfiles in version control along with your source code
    makes it easier to build new container images every time your application code
    changes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建的 Dockerfile 会创建一个容器镜像。这个镜像由不同的层组成，这些层包含了你的应用程序、依赖关系以及应用程序运行所需的其他内容。这些层就像是应用程序状态的时间快照，因此将
    Dockerfile 与源代码一起保存在版本控制中，可以让你在每次应用程序代码更改时更容易构建新的容器镜像。
- en: The layers fit together like LEGO bricks. Each layer, or intermediate image,
    is created each time an instruction in the Dockerfile is executed. For example,
    every time you use the `RUN` instruction, a new intermediate layer is created
    with the results of that instruction. Each layer (image) is assigned a unique
    hash, and all layers are cached by default. This means you can share layers with
    other images, so if a given layer hasn’t changed, you don’t need to build it again
    from scratch. Also, caching is your best friend, as it cuts down the time and
    space needed to build images.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 各个层就像乐高积木一样紧密结合。每一层，或称为中间镜像，都是在执行 Dockerfile 中的每一条指令时创建的。例如，每次使用 `RUN` 指令时，都会根据该指令的结果创建一个新的中间层。每个层（镜像）都会分配一个唯一的哈希值，并且所有层默认都会被缓存。这意味着你可以与其他镜像共享层，因此如果某个层没有发生变化，你就无需重新从头构建它。此外，缓存是你的好朋友，因为它可以减少构建镜像所需的时间和空间。
- en: 'Docker can stack these layers on top of each other because it uses the *union
    filesystem (UFS**)*, which allows multiple filesystems to come together and create
    what looks like a single filesystem. The topmost layer is the *container layer*,
    which is added when you run the container image. It’s the only layer that can
    be written to. All the subsequent layers are read only, by design. If you make
    any file or system changes to the container layer and then remove the running
    container, those changes will be gone. The underlying read-only images are kept
    intact. This is why containers are so popular with software engineers: the image
    is an immutable artifact that can be run on any Docker host and behave in the
    same way.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 可以将这些层叠加在一起，因为它使用了*联合文件系统（UFS）*，允许多个文件系统结合起来，创建出看似单一的文件系统。最上面的层是*容器层*，在你运行容器镜像时会添加这个层。它是唯一一个可以被写入的层。所有后续的层都是只读的，这是有意为之的。如果你在容器层做了任何文件或系统更改，然后删除运行中的容器，这些更改将会消失。底层的只读镜像会保持不变。这就是为什么容器在软件工程师中如此受欢迎：镜像是不可变的工件，可以在任何
    Docker 主机上运行，并表现出相同的行为。
- en: Containers
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器
- en: The Docker container is a running instance of a container image. In computer
    programming terms, you can think of the container image as a *class* and the container
    as an *instance* of that class. When the container starts, the container layer
    is created. This writeable layer is where all the changes (like writing, deleting,
    and modifying existing files) will take place.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器是容器镜像的一个运行实例。在计算机编程术语中，可以将容器镜像视为一个*类*，而容器则是该类的*实例*。当容器启动时，容器层会被创建。这个可写层是所有更改（例如写入、删除和修改现有文件）发生的地方。
- en: Namespaces and Cgroups
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间和控制组
- en: The container is also roped off from the rest of the Linux host by some boundaries
    and limited views called *namespaces* and *cgroups*. These are kernel features
    that limit what a container can see and use on a host. They also make OS-level
    virtualization a reality. Namespaces restrict global system resources for a container.
    Without namespaces, a container could have free run of the system. Imagine if
    a container could see a process in another container. That mischievous container
    could kill a process, delete a user, or unmount a directory in another container.
    Try tracking that down when you’re on call at 2 am!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 容器还通过一些边界和有限视图将自己与 Linux 主机的其他部分隔离开来，这些被称为*命名空间*和*控制组*。它们是内核特性，限制了容器在主机上可以看到和使用的内容。它们还使操作系统级虚拟化成为现实。命名空间限制了容器的全局系统资源。如果没有命名空间，容器可能会自由地访问整个系统。想象一下，如果一个容器能够看到另一个容器中的进程。那个调皮的容器可能会杀死进程、删除用户，或卸载另一个容器中的目录。当你凌晨2点接到故障电话时，试着追踪这个问题！
- en: 'Common kernel namespaces include the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的内核命名空间包括以下内容：
- en: Process ID (`PID`) Isolates the process IDs
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程 ID（`PID`）隔离进程 ID
- en: Network (`net`) Isolates the network interface stack
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络（`net`）隔离网络接口栈
- en: UTS Isolates the hostname and domain name
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UTS 隔离主机名和域名
- en: Mount (`mnt`) Isolates the mount points
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挂载（`mnt`）隔离挂载点
- en: IPC Isolates the SysV-style interprocess communication
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IPC 隔离 SysV 样式的进程间通信
- en: User Isolates the user and group IDs
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户隔离用户和组 ID
- en: Using these namespaces is not enough, however. You also need to control how
    much memory, CPU, and other physical resources a container uses. That’s where
    cgroups come in. Cgroups manage and measure the resources a container can use.
    They allow you to set resource limitations and prioritization for processes. The
    most common resources Docker sets with cgroups are memory, CPU, disk I/O, and
    network. Cgroups make it possible to stop a container from using up all the resources
    on a host.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，单独使用这些命名空间是不够的。你还需要控制容器使用的内存、CPU和其他物理资源。这里就需要使用cgroups。Cgroups管理并衡量容器可以使用的资源。它们允许你为进程设置资源限制和优先级。Docker通过cgroups设置的最常见资源是内存、CPU、磁盘I/O和网络。Cgroups使得你可以防止容器占用主机的所有资源。
- en: The main point to remember is that namespaces limit what you can see, while
    cgroups limit what you can use. Without these features, containers would not be
    secure or useful.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的主要要点是，命名空间限制了你可以看到的内容，而cgroups限制了你可以使用的内容。如果没有这些功能，容器将既不安全也不实用。
- en: Installing and Testing Docker
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和测试Docker
- en: To containerize a sample application, you’ll start by installing Docker with
    the aid of *minikube*, an app that contains the Docker engine and also provides
    a Kubernetes cluster (which you’ll use in the next chapter). Next, you’ll install
    the `docker` client so that you’ll be able to communicate with the Docker server.
    Then, you’ll configure your environment so that it can find the new Docker server.
    Finally, you’ll test client connectivity.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将一个示例应用程序容器化，你将首先借助*minikube*安装Docker，它是一个包含Docker引擎并提供Kubernetes集群的应用（你将在下一章中使用该集群）。接下来，你将安装`docker`客户端，以便能够与Docker服务器进行通信。然后，你将配置环境，以便能够找到新的Docker服务器。最后，你将测试客户端连接性。
- en: Installing the Docker Engine with Minikube
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Minikube安装Docker引擎
- en: To install minikube, follow the instructions for your operating system at [https://minikube.sigs.k8s.io/](https://minikube.sigs.k8s.io/).
    If you’re not on a Linux host, minikube requires a virtual machine manager to
    install Docker. Use VirtualBox for that.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装minikube，请根据你的操作系统参考[https://minikube.sigs.k8s.io/](https://minikube.sigs.k8s.io/)上的说明。如果你不是在Linux主机上，minikube需要虚拟机管理器来安装Docker。使用VirtualBox即可。
- en: By default, minikube makes a best guess about memory allocation for the VM it
    will create. It also sets the number of CPUs to two and the disk space to 20GB.
    For the purposes of this book, the defaults should be fine.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，minikube会根据它将要创建的虚拟机进行内存分配的最佳猜测。它还将CPU数量设置为2个，磁盘空间设置为20GB。对于本书的目的，这些默认设置应该是合适的。
- en: 'To start minikube using the resource defaults and VirtualBox as the VM manager,
    enter the following in a terminal:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用资源默认值和VirtualBox作为虚拟机管理器启动minikube，请在终端中输入以下命令：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Done!` message shows that minikube started successfully. If minikube fails
    to start, you should investigate any error messages listed in the output.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Done!`消息表示minikube启动成功。如果minikube启动失败，你应该检查输出中的错误信息。'
- en: Installing the Docker Client and Setting Up Docker Environment Variables
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Docker客户端并设置Docker环境变量
- en: To install the `docker` client, follow the instructions at [https://docs.docker.com/engine/install/binaries/](https://docs.docker.com/engine/install/binaries/)
    for your operating system. Make sure you only download and install the client
    binary. You’ll use minikube to set some local environment variables in your shell,
    including the Docker host IP and the path to the Docker host TLS certificates,
    which are needed to connect. The Bash `eval` command will source the environment
    variables in your shell.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`docker`客户端，请根据你的操作系统参考[https://docs.docker.com/engine/install/binaries/](https://docs.docker.com/engine/install/binaries/)上的说明。确保只下载并安装客户端二进制文件。你将使用minikube设置一些本地环境变量，包括Docker主机的IP地址和Docker主机TLS证书的路径，这些都是连接所需的。Bash的`eval`命令会在你的终端中加载这些环境变量。
- en: 'In a terminal, enter the following to set your Docker environment variables:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，输入以下命令来设置你的Docker环境变量：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command should return zero output if it’s successful. The Docker host environment
    variables should be exported in your current terminal session.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令成功执行，它应该没有任何输出。Docker主机的环境变量应该已经在当前终端会话中导出。
- en: When you close this terminal window, the environment variables will be lost,
    and you’ll need to run the command each time you want to interact with the Docker
    server. To avoid this inconvenience, add the command to the bottom of your shell
    configuration file such as *~/.bashrc* or *~/.zshrc* so it’s executed each time
    you open a terminal window or tab. Then you won’t see the `Is the docker daemon
    running?` error.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你关闭这个终端窗口时，环境变量将会丢失，每次想要与Docker服务器交互时，你都需要重新运行这个命令。为了避免这个不便，可以将该命令添加到你的Shell配置文件底部，比如*~/.bashrc*或*~/.zshrc*，这样每次打开终端窗口或标签页时，都会执行该命令。这样，你就不会看到`Is
    the docker daemon running?`的错误。
- en: Testing the Docker Client Connectivity
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试Docker客户端连接性
- en: 'You should test whether the `docker` client can talk to the Docker server running
    inside the minikube VM. In the same terminal where you set the environment variables,
    enter the following to check the Docker version:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该测试`docker`客户端是否能与运行在minikube虚拟机中的Docker服务器通信。在你设置了环境变量的同一个终端中，输入以下命令来检查Docker版本：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output should show your client and server versions if the connection is
    successful.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接成功，输出应该显示你的客户端和服务器版本。
- en: Containerizing a Sample Application
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器化示例应用程序
- en: I created a sample application named *telnet-server* that you can use to build
    a container with Docker. It’s a simple telnet server that mimics the bulletin
    board systems (BBSs) people used in the 1980s. The app is written in the Go programming
    language for OS portability and a small footprint. You’ll use an Alpine Linux
    container image that contains Go and all the needed dependencies.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个名为*telnet-server*的示例应用程序，你可以用它来构建一个Docker容器。它是一个简单的telnet服务器，模仿了1980年代人们使用的公告板系统（BBS）。该应用程序使用Go编程语言编写，具有操作系统的可移植性和小巧的占用空间。你将使用一个包含Go及所有必要依赖项的Alpine
    Linux容器镜像。
- en: To containerize an application, you’ll need the source code or binary you want
    to run in the container plus the Dockerfile to build the container image. The
    sample application source code and Dockerfile are in the companion repository
    for this book at [https://github.com/bradleyd/devops_for_the_desperate/](https://github.com/bradleyd/devops_for_the_desperate/
    ) in the *telnet-server/* folder.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要容器化一个应用程序，你需要源代码或二进制文件来运行容器内的程序，以及一个Dockerfile来构建容器镜像。示例应用程序的源代码和Dockerfile可以在本书的伴随仓库中找到，地址是[https://github.com/bradleyd/devops_for_the_desperate/](https://github.com/bradleyd/devops_for_the_desperate/
    )，位于*telnet-server/*文件夹下。
- en: Dissecting the Example telnet-server Dockerfile
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析示例的telnet-server Dockerfile
- en: 'The example Dockerfile is a *multistage* *build* with two separate stages:
    *build* and *final*. Multistage builds allow you to manage complex builds in one
    Dockerfile, and they provide a good pattern for keeping container images small
    and secure. In the build stage, the Dockerfile instruction compiles the sample
    application with all its dependencies. In the final stage, the Dockerfile instruction
    copies the build artifact (in this case, the compiled sample application) from
    the build stage. The final container image is much smaller because it doesn’t
    contain all the dependencies or source code for the sample application from the
    build stage. Visit [https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/)for
    more information on multistage builds.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例Dockerfile是一个*多阶段* *构建*，包括两个独立的阶段：*build*和*final*。多阶段构建让你能够在一个Dockerfile中管理复杂的构建过程，同时提供了一种保持容器镜像小巧且安全的良好模式。在构建阶段，Dockerfile指令会编译包含所有依赖的示例应用程序。在最终阶段，Dockerfile指令会将构建产物（在这个例子中是编译后的示例应用程序）从构建阶段复制过来。最终的容器镜像会更小，因为它不包含构建阶段中的所有依赖或源代码。欲了解更多关于多阶段构建的信息，请访问[https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/)。
- en: 'Navigate to the *telnet-server/* directory and open the Dockerfile, which should
    look like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到*telnet-server/*目录并打开Dockerfile，文件内容应如下所示：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The file starts the build stage with a `FROM` instruction to pull in the `golang:alpine`
    parent image. This is an Alpine Linux image from the Docker Hub registry that’s
    prebuilt for developing in the Go programming language. This image stage is named
    `build-env`, using the `AS` keyword. This name reference is used again later,
    in the final stage.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 文件通过`FROM`指令开始构建阶段，拉取`golang:alpine`父镜像。这个镜像来自Docker Hub，它是一个预先构建的Alpine Linux镜像，专门用于Go语言的开发。该镜像阶段命名为`build-env`，使用`AS`关键字。这个名称引用稍后将在最终阶段再次使用。
- en: The `ADD` instruction copies all the Go source code in the current local *telnet-server/*
    directory to the image’s filesystem at the root (`/`) destination.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD`指令将当前本地*telnet-server/*目录中的所有 Go 源代码复制到镜像文件系统中的根目录（`/`）位置。'
- en: The next `RUN` instruction executes the shell command that navigates to the
    root directory in the image filesystem, and it uses the `go build` command to
    build the Go binary named telnet-server.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个`RUN`指令执行 shell 命令，导航到镜像文件系统中的根目录，并使用`go build`命令构建名为 telnet-server 的 Go
    二进制文件。
- en: The final stage begins with a `FROM` instruction that again pulls in an Alpine
    Linux image (`alpine:latest`) for the final stage’s parent image. This time, though,
    the Alpine Linux image is the minimal image in which the application will run.
    It doesn’t contain any dependencies.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最终阶段以`FROM`指令开始，重新拉取一个 Alpine Linux 镜像（`alpine:latest`）作为最终阶段的父镜像。不过，这次 Alpine
    Linux 镜像是应用程序运行的最小镜像，不包含任何依赖项。
- en: The `WORKDIR` instruction sets the working directory for the application, which
    is */app* in this example. Any `CMD`, `RUN`, `COPY`, or `ENTRYPOINT` instruction
    after that declaration will be executed in the context of that working directory.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`WORKDIR`指令设置应用程序的工作目录，在此示例中为*/app*。之后的任何`CMD`、`RUN`、`COPY`或`ENTRYPOINT`指令都将在该工作目录的上下文中执行。'
- en: 'The two `ENV` instructions set environment variables in the container image
    that the application can use: they set the telnet server to port `2323` and the
    metric server port to `9000`. (More on those ports later.)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`ENV`指令在容器镜像中设置环境变量，供应用程序使用：它们将 telnet 服务器设置为端口 `2323`，并将度量服务器端口设置为 `9000`。（稍后将详细讨论这些端口。）
- en: The `COPY` instruction copies the telnet-server Golang binary from the `build-env`
    stage and places it in the working *app/* directory in the final-stage Alpine
    image.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY`指令将 telnet-server 的 Golang 二进制文件从 `build-env` 阶段复制，并将其放置在最终阶段 Alpine
    镜像中的工作*app/*目录中。'
- en: The final `ENTRYPOINT` instruction invokes the telnet-server binary when the
    container starts to execute the sample application. You’ll use `ENTRYPOINT` instead
    of `CMD` because the application will require additional flags passed to it during
    a container test in a later chapter. If you need to override the default command
    in your container, swap `ENTRYPOINT` with the `CMD` instruction instead. See the
    Dockerfile reference at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
    to learn more about `CMD` versus `ENTRYPOINT`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`ENTRYPOINT`指令在容器启动时调用 telnet-server 二进制文件来执行示例应用程序。你将使用`ENTRYPOINT`而不是`CMD`，因为该应用程序在后续章节的容器测试中需要传递额外的标志。如果你需要覆盖容器中的默认命令，可以将`ENTRYPOINT`与`CMD`指令互换。有关`CMD`与`ENTRYPOINT`的更多信息，请参见
    Dockerfile 参考文档：[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)。
- en: Building the Container Image
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: 'Next, you’ll build the container image for the sample telnet-server application,
    using the Dockerfile you just reviewed. Navigate to the *telnet-server/* directory
    and enter the following to pass Docker the image name and Dockerfile location:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使用刚才审阅的 Dockerfile 构建示例 telnet-server 应用程序的容器镜像。导航到*telnet-server/*目录并输入以下内容，将镜像名称和
    Dockerfile 位置传递给 Docker：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `-t` flag sets the name and (optionally) a tag for the image, and the dot
    (`.`) argument sets the Dockerfile’s current location. The *dftd/telnet-server:v1*
    URI has three parts: the registry hostname (*dftd*), the image name, and the tag.
    The registry is local to minikube rather than online, so you can use anything
    for the base. (If it were a remote registry, you’d use something like *registry.example.com*.)
    The image name sandwiched between the forward slash (`/`) and the colon (`:`)
    is set to the name of the example application, *telnet-server*. The *v1* image
    tag comes after the colon.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t`标志设置镜像的名称和（可选）标签，点（`.`）参数设置 Dockerfile 的当前位置。*dftd/telnet-server:v1* URI
    由三部分组成：注册表主机名（*dftd*）、镜像名称和标签。注册表是本地的 minikube，而不是在线的，因此你可以随意设置基本名称。（如果是远程注册表，你会使用类似
    *registry.example.com* 的名称。）镜像名称位于正斜杠（`/`）和冒号（`:`）之间，设置为示例应用程序的名称，*telnet-server*。*v1*
    镜像标签紧随冒号之后。'
- en: Tags allow you to identify each build of an image and indicate what changes
    are inside. Using Git commit hashes as tags is a common practice, as each hash
    is unique and can mark the image’s source code version. If you omit the tag, Docker
    uses the latest word as the default tag.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 标签允许你识别每个镜像构建，并指示其中的变化。使用 Git 提交哈希作为标签是一种常见做法，因为每个哈希都是唯一的，可以标记镜像的源代码版本。如果你省略标签，Docker
    会使用最新的词作为默认标签。
- en: 'After running the command, you should see output like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，你应该看到类似这样的输出：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Each instruction is logged, allowing you to follow along with the build process
    in a linear fashion. At the end of the build, the image ID (`f796da88ab94`) should
    be listed, followed by a note that the image is tagged successfully as *dftf/telnet-server:v1*.
    The image ID you see will be different.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个指令都会被记录，允许你按顺序跟踪构建过程。在构建结束时，应该列出镜像 ID（`f796da88ab94`），随后会有一条说明，表示镜像成功标记为 *dftf/telnet-server:v1*。你看到的镜像
    ID 会不同。
- en: If your `docker build` wasn’t successful, you’ll want to resolve any errors
    in the output because you’ll build upon this image going forward. Common errors
    are typos in the `RUN` execution and missing files when using the `COPY` instruction.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 `docker build` 没有成功，你需要解决输出中的任何错误，因为接下来你将基于这个镜像进行构建。常见错误包括 `RUN` 执行中的拼写错误和使用
    `COPY` 指令时缺少文件。
- en: Verifying the Docker Image
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证 Docker 镜像
- en: Next, verify that the Docker registry inside minikube is storing the telnet-server
    image. (As mentioned previously, a registry is a server that stores and serves
    container images.)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，验证 minikube 内的 Docker 仓库是否存储了 telnet-server 镜像。（如前所述，仓库是存储并提供容器镜像的服务器。）
- en: 'In a terminal, enter the following to list the Docker telnet-server image:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中输入以下命令来列出 Docker 的 telnet-server 镜像：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that the final image for the telnet-server is only 16.8MB. The Alpine
    Linux base image in the final stage was roughly 5MB before adding the telnet-server
    application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最终的 telnet-server 镜像只有 16.8MB。最终阶段的 Alpine Linux 基础镜像在添加 telnet-server 应用之前大约为
    5MB。
- en: Running the Container
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行容器
- en: 'The next step is to create and run the telnet-server container from the image
    you just built. Do this by entering the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从你刚刚构建的镜像创建并运行 `telnet-server` 容器。通过输入以下命令来完成：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `-p` (port) flag exposes port `2323` outside the container. (The telnet-server
    application needs to have port `2323` open.) The left side of the colon (`:`)
    is the host port, and the right side is the container port. This is useful if
    you have another application listening on the same port and need to change it
    for the host while keeping the container port the same. The `-d` (detach) flag
    launches the container in the background. If you don’t supply the `-d` flag, the
    container will run in the foreground of the terminal from which it launched. The
    `--name` flag sets the container name to `telnet-server`. Docker, by default,
    assigns randomly generated names for containers if you don’t set them. The last
    argument is the image name, complete with path and tag, from the build step.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p`（端口）标志暴露了容器外部的端口 `2323`。（telnet-server 应用需要开放端口 `2323`。）冒号（`:`）左侧是主机端口，右侧是容器端口。如果你有另一个应用程序正在监听相同端口，并且需要为主机更改端口，同时保持容器端口不变，这很有用。`-d`（分离）标志将在后台启动容器。如果你没有提供
    `-d` 标志，容器将在启动它的终端前台运行。`--name` 标志将容器名称设置为 `telnet-server`。默认情况下，如果你没有设置，Docker
    会为容器随机分配名称。最后一个参数是构建步骤中的镜像名称，包含路径和标签。'
- en: The container is now running in the background and ready to accept traffic.
    This `docker run` command was successful because it returned the *container ID*
    (the long string of numbers and letters, which will be different for you) and
    no errors.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 容器现在在后台运行并准备接受流量。这个 `docker run` 命令成功执行，因为它返回了*容器 ID*（一长串数字和字母，对于你来说会不同），且没有出现错误。
- en: 'Enter the following to verify that the container is actually running:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令验证容器是否实际正在运行：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The optional filter flag (`-f`) narrows the output to the containers you specify.
    If you omit the filter flag, running the command should list every container running
    on the host.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的筛选标志（`-f`）将输出限制为你指定的容器。如果省略筛选标志，运行该命令将列出主机上所有正在运行的容器。
- en: 'If the container is running, the output should look like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器正在运行，输出应该如下所示：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `CONTAINER ID` column matches the first 12 digits of the ID received from
    the `docker run` command issued previously. The `IMAGE` column contains the image
    ID given when you built the container image. The `PORTS` column shows that port
    `2323` is exposed on every interface (0.0.0.0) and is mapping that traffic to
    port `2323` inside the container. The directional arrow (`->`) denotes the traffic
    flow direction. Finally, the `NAMES` column shows the telnet-server name set earlier
    from the `run` command.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`CONTAINER ID`列匹配先前`docker run`命令接收到的ID的前12位数字。`IMAGE`列包含构建容器镜像时给定的镜像ID。`PORTS`列显示端口`2323`在每个接口（0.0.0.0）上公开，并将流量映射到容器内部的端口`2323`。方向箭头(`->`)表示流量流向。最后，`NAMES`列显示之前从`run`命令设置的telnet-server名称。'
- en: 'Now, enter the following in your terminal to stop the container:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在终端中输入以下内容停止容器：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The container name should be returned, letting you know the Docker daemon thinks
    the container is stopped. To start the container again, swap the word `stop` with
    `start`, and you should see the container name returned again.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 容器名称应该被返回，让您知道 Docker 守护程序认为容器已停止。要重新启动容器，将 `stop` 与 `start` 交换，并且您应该再次看到容器名称返回。
- en: Docker won’t check to see whether your application stays running after you start
    it. As long as the container can start and not error out immediately, entering
    `docker start` or `docker run` will return the container name as if nothing were
    wrong. This can be misleading. You’ll want to perform health checks and monitor
    the application to verify that it’s actually running. (We’ll explore those topics
    in future chapters.)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 不会检查应用程序在启动后是否保持运行状态。只要容器能够启动并且不会立即出错，输入 `docker start` 或 `docker run`
    将返回容器名称，就像一切正常一样。这可能会产生误导。您应该执行健康检查并监视应用程序，以验证其实际运行情况（我们将在未来的章节中探讨这些主题）。
- en: Other Docker Client Commands
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他 Docker 客户端命令
- en: Let’s look at a few more common Docker commands you’ll need to use when working
    with containers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在处理容器时需要使用的几个常见 Docker 命令。
- en: exec
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: exec
- en: 'The `exec` command allows you to run a command inside a container or interact
    with a container, as if you were logged in to a terminal session. For example,
    if you are troubleshooting an application in a container and want to verify that
    the correct environment variables are being set, you could run the following command
    in a terminal to output all the environment variables:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec`命令允许您在容器内部运行命令或与容器交互，就像您登录到终端会话中一样。例如，如果您正在容器中调试应用程序并希望验证是否正确设置了环境变量，您可以在终端中运行以下命令输出所有环境变量：'
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `env` command executes inside the container, using the OS’s default shell.
    When it finishes, the output is sent back to the terminal.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`env`命令在容器内部使用操作系统的默认 shell 执行。执行完毕后，输出将发送回终端。'
- en: 'The `exec` command also allows you to access a running container to troubleshoot
    it or run a command. You’ll need to pass the interactive flag (`-i`) and the pseudo-TTY
    flag (`-t`), along with the shell command (`/bin/sh`), to do this. The interactive
    flag keeps STDIN open so you can type commands inside the container layer. The
    pseudo-TTY flag simulates a terminal, and when combined with the interactive flag,
    it mimics being in a live terminal session inside the container. Operating systems
    other than Linux will use different shells: most commonly, */bin/sh* and */bin/bash*.
    Alpine Linux uses the */bin/sh* shell as its default.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec`命令还允许您访问正在运行的容器以进行故障排除或运行命令。您需要传递交互标志(`-i`)和伪TTY标志(`-t`)，以及 shell 命令(`/bin/sh`)来执行此操作。交互标志保持
    STDIN 打开，因此您可以在容器层内输入命令。伪TTY标志模拟终端，与交互标志结合使用时，模拟在容器内部进行实时终端会话。除了 Linux 外，其他操作系统将使用不同的
    shell，最常见的是 */bin/sh* 和 */bin/bash*。Alpine Linux 默认使用 */bin/sh* 作为其默认 shell。'
- en: 'Enter the following in a terminal to get a shell inside the container:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中输入以下内容以获取容器内部的 shell：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `ls` command is issued to show you’re inside the container you built. (You
    earlier set the working directory to *app/* and put the telnet-server binary in
    there.) Input the `exit` command and press enter to leave the container and return
    to the local terminal.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 发出 `ls` 命令以显示您已构建的容器内部。 （您先前将工作目录设置为 *app/* 并将 telnet-server 二进制文件放在其中。）输入 `exit`
    命令并按 Enter 键以离开容器并返回本地终端。
- en: rm
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: rm
- en: 'The `rm` command removes a stopped container. For example, to remove the telnet-server
    container once it is stopped, enter the following in a terminal:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`rm`命令删除已停止的容器。例如，一旦telnet-server容器停止，输入以下内容在终端中删除它：'
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The removed container’s name should be returned. You can use the `-f` (force)
    flag to remove a running container, but it’s best to stop it first.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 删除的容器名称应该被返回。您可以使用`-f`（强制）标志来删除正在运行的容器，但最好先停止它。
- en: inspect
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: inspect
- en: The `inspect` `docker` command returns low-level information about some Docker
    objects. The output is in JSON format by default. Depending on the Docker object,
    the results can be verbose.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`inspect` `docker`命令返回有关某些Docker对象的低级信息。默认情况下，输出是JSON格式的。根据Docker对象的不同，结果可能很冗长。'
- en: 'To inspect the telnet-server container, enter the following in a terminal:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查telnet-server容器，请在终端中输入以下内容：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `State` section 1 contains data about the running container, like `Status`
    and `StartedAt` date. The `NetworkSettings` section 2 provides information like
    `Ports` and `IPAddress`, which are helpful when troubleshooting problematic containers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`State`部分1包含有关运行中的容器的数据，如`Status`和`StartedAt`日期。`NetworkSettings`部分2提供像`Ports`和`IPAddress`这样的信息，这些在排除容器问题时非常有用。'
- en: history
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: history
- en: The `history` command displays a container image’s history, which is useful
    for viewing the number and sizes of an image’s layers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`history`命令显示容器镜像的历史，对于查看镜像层的数量和大小很有用。'
- en: 'To see the telnet-server image’s layers, enter the following in a terminal:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看telnet-server镜像的层，请在终端中输入以下内容：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The output (edited) shows the instructions that start each layer, like `COPY`
    and `ADD`. It also shows the layers’ ages and sizes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 输出（已编辑）显示了启动每个层的指令，如`COPY`和`ADD`。它还显示了各层的年龄和大小。
- en: stats
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: stats
- en: The `stats` command displays a real-time update on the resources a container
    is using. It gathers this information from the cgroups and behaves similarly to
    the Linux `top` command. If you have a host that manages multiple containers and
    want to see which one is the resource hog, use the `stats` command. Once you run
    the `stats` command, it drops you into a page that updates every few seconds.
    As that’s impossible to show in a book, we’ll pass the `--no-stream` flag to take
    a snapshot of the resources and exit immediately.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`stats`命令显示容器正在使用的资源的实时更新。它从cgroups收集这些信息，行为类似于Linux的`top`命令。如果您有一个管理多个容器的主机，并希望查看哪个容器占用资源，使用`stats`命令。一旦运行`stats`命令，它会将您带入一个每隔几秒更新一次的页面。由于这在书中无法展示，我们将传递`--no-stream`标志以拍摄资源快照并立即退出。'
- en: 'Enter the following to show the telnet-server container’s resource usage:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令以显示telnet-server容器的资源使用情况：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This telnet-server container is using virtually no CPU, no disk or network I/O,
    and only 2MiB of memory. You could easily run hundreds of these in a cloud environment
    on a single server.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个telnet-server容器几乎没有使用CPU、磁盘或网络I/O，只有2MiB的内存。您可以轻松地在单个服务器的云环境中运行数百个这样的容器。
- en: Visit [https://docs.docker.com/engine/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/)to
    explore all of the `docker` command line client’s commands and flags.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://docs.docker.com/engine/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/)以探索所有`docker`命令行客户端的命令和标志。
- en: Testing the Container
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试容器
- en: To find out whether the sample application you’ve containerized actually works,
    you’ll connect to the telnet-server on port `2323` and run some basic commands.
    Then you’ll view the container logs to verify that the application is working
    correctly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定您容器化的示例应用程序是否实际运行，您将连接到端口`2323`上的telnet-server并运行一些基本命令。然后，您将查看容器日志，以验证应用程序是否正常工作。
- en: Before performing either of these steps, however, you’ll need to install a `telnet`
    client for your OS to communicate with the telnet-server. If you’re using macOS,
    simply enter `brew install telnet` in your terminal. If you’re using Ubuntu, enter
    `apt` `install telnet` in a terminal as a privileged user.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在执行这些步骤之前，您需要为您的操作系统安装一个`telnet`客户端，以便与telnet-server通信。如果您使用的是macOS，只需在终端中输入`brew
    install telnet`。如果您使用的是Ubuntu，请以特权用户身份在终端中输入`apt install telnet`。
- en: Connecting to the Telnet-Server
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到Telnet-Server
- en: To connect to the server, pass telnet the hostname or IP address of the server
    plus the port to which you want to connect. Since the Docker server is running
    inside a VM (minikube), you’ll need the IP address minikube exposes to your local
    host.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到服务器，向telnet传递服务器的主机名或IP地址以及要连接的端口。由于Docker服务器运行在虚拟机（minikube）内部，因此您需要使用minikube暴露给本地主机的IP地址。
- en: 'Enter the following in a terminal to get the IP address:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中输入以下内容以获取IP地址：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: My minikube IP address is 192.168.99.103; yours may be different.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我的minikube IP地址是192.168.99.103；您的可能不同。
- en: 'To connect to the telnet-server running inside the container, pass the IP address
    (192.168.99.103) and port (`2323`) to the `telnet` command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到容器内运行的telnet-server，使用IP地址（192.168.99.103）和端口（`2323`）传递给`telnet`命令：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Success! The ASCII text banner of DFTD should greet you in all its glory. You’re
    now connected to the telnet-server application. The prompt (`>`) is where you
    can enter commands. To start, you can enter only the `date`, `help`, `yell`, and
    `quit` commands. You can use the first character of any of those commands as a
    shortcut, and any commands you enter will be logged.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！DFTD的ASCII文本横幅应该会以它的全貌欢迎你。你现在已经连接到了telnet-server应用程序。提示符（`>`）是你可以输入命令的地方。首先，你只能输入`date`、`help`、`yell`和`quit`命令。你可以使用这些命令的首字母作为快捷方式，且你输入的任何命令都会被记录。
- en: 'While still connected to the telnet-server, enter the following to print the
    current date and time:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在仍然连接到telnet-server的情况下，输入以下命令以打印当前的日期和时间：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Great! The current date and time should be displayed. Depending on your age,
    this could bring back memories of baud rates and high-pitched squeals.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！当前的日期和时间应该会显示出来。根据你的年龄，这可能会唤起你对波特率和高频尖叫声的回忆。
- en: 'Enter the following to quit the telnet-server session:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令退出telnet-server会话：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You should see that the telnet-server session is nice enough to say goodbye.
    Take that, modern-day internet!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到telnet-server会话会很友好地向你告别。现代互联网，我看你能做什么！
- en: You can add new commands to the server or change the responses in the *telnet-server/telnet/server.go*
    file. If you do, don’t forget to build, stop, and replace the image and container
    using the commands you learned earlier in this chapter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*telnet-server/telnet/server.go*文件中添加新命令或更改响应。如果这样做，别忘了使用你在本章之前学到的命令来构建、停止并替换镜像和容器。
- en: Getting Logs from the Container
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从容器获取日志
- en: Docker provides a simple way to retrieve logs from a running container. This
    is important for troubleshooting and forensics purposes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Docker提供了一种简单的方法来获取正在运行的容器的日志。这对于故障排除和取证非常重要。
- en: 'To see all the logs for the telnet-server, which is logging to STDOUT, enter
    the following in your terminal:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看telnet-server的所有日志（日志输出到STDOUT），在终端中输入以下命令：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first two lines of output are startup messages showing that the server is
    running and listening on specific ports. (We’ll explore the metrics server when
    we look at monitoring applications in Chapter 9.) The fourth log line is from
    when you entered the `d` command into the telnet session to print the current
    date and time. The fifth log line shows when you entered `q` to exit the test
    telnet session.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的前两行是启动消息，显示服务器正在运行并监听特定的端口。（我们将在第9章讨论监控应用时探讨度量服务器。）第四行日志来自你在telnet会话中输入`d`命令来打印当前日期和时间。第五行日志显示你输入`q`命令退出测试telnet会话的时刻。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: If you’re a software or DevOps engineer, you need a solid understanding of containers
    in today’s infrastructure. In this chapter, you explored how Docker makes containers
    possible with OS-level virtualization. You examined how a Dockerfile works to
    create the layers of a container image, and you applied that knowledge to build
    a sample container image using a multistage build. Finally, you started a container
    from the provided telnet-server image, tested that it was working correctly, and
    checked its logs. In the next chapter, you’ll take the telnet-server image you
    built here and run it inside a Kubernetes cluster.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是软件工程师或DevOps工程师，你需要对当今基础设施中的容器有深入的理解。在本章中，你探索了Docker如何通过操作系统级别的虚拟化使容器成为可能。你研究了Dockerfile如何工作以创建容器镜像的层，并将这一知识应用于使用多阶段构建构建一个示例容器镜像。最后，你启动了一个由提供的telnet-server镜像创建的容器，测试它是否正常工作，并检查了其日志。在下一章中，你将把你在这里构建的telnet-server镜像运行在Kubernetes集群中。
