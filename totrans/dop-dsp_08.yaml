- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containerizing an Application with Docker
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: A *container* is the running instance of an application based off a container
    image. Using containers provides you with a predictable and isolated way to create
    and run code. It allows you to package an application and its dependencies into
    a portable artifact you can easily distribute and run. Microservice architectures
    and continuous integration/continuous development pipelines heavily use containers,
    and if you’re a software or DevOps engineer, using containers has most likely
    changed the way you deliver and write software.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to install the Docker engine and the `docker`
    client command line tool. You’ll also get a crash course in Dockerfiles, container
    images, and containers. You’ll combine this knowledge, along with some basic Docker
    commands, to containerize a sample application called *telnet-server* that I’ve
    provided in the repository for this book ([https://github.com/bradleyd/devops_for_the_desperate/](https://github.com/bradleyd/devops_for_the_desperate/)).
    By the end of this chapter, you’ll have a solid understanding of how to use Docker
    to containerize any application, as well as the benefits of doing so.
  prefs: []
  type: TYPE_NORMAL
- en: Docker from 30,000 Feet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The word *Docker* has become synonymous with the container movement. This is
    due to Docker’s ease of use, the rise of microservice architectures, and the need
    to solve the “works on my machine” paradox. The idea of containers has been around
    for quite some time, however, and numerous container frameworks exist. But since
    Docker released its first open-source version in March 2013, the industry has
    adopted the Docker framework as the de facto standard. The first stable version
    of Docker (1.0) was released in 2014, and since then, new versions have included
    many improvements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker framework consists of a Docker daemon (server), a `docker` command
    line client, and other tools that are beyond the scope of this book. Docker uses
    Linux kernel features to build and run containers. These pieces fit together to
    allow Docker to do its magic: *OS-level virtualization*, which partitions the
    operating system into what looks like separate isolated servers, as shown in [Figure
    6-1](#figure6-1). Because of this, containers are effective when you need to run
    a lot of applications on limited hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram showing these layers from top to bottom: Containerized applications,
    docker framework, host os, infrastructure](image_fi/502482c06/f06001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-1: OS-level virtualization'
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started with Docker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll create a *Dockerfile* that describes how to build the *container
    image* from your application. A container image is made of different layers that
    house your application, dependencies, and anything else the application needs
    so it can run. Container images can be distributed and served from a service called
    a *registry*. Docker hosts the most popular registry at [https://hub.docker.com/](https://hub.docker.com/).
    There, you’ll find just about any image you might need, such as Ubuntu or the
    PostgreSQL database. With a simple `docker pull` `<image-name>` command, you can
    download and use an image in a matter of seconds. A container is the running instance
    of an application based off the container image. [Figure 6-2](#figure6-2) shows
    how all of Docker’s pieces fit together. In this chapter, you’ll mostly be working
    with the `docker` client.
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram showing the client (which contains the docker commands), connected
    to the docker host (which contains the docker daemon, containers, and images),
    connected to the registry (which is where the images come from)](image_fi/502482c06/f06002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-2: Docker framework'
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Dockerfile contains the instructions that teach the Docker server how to
    turn an application into a container image. Each instruction represents a specific
    job and creates a new layer inside the container image. The following list includes
    the most common instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM` Specifies the parent or base image from which to build the new image
    (must be the first command in the file)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`COPY` Adds files from your current directory (where the Dockerfile resides)
    to a destination in the image filesystem'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RUN` Executes a command inside the image'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ADD` Copies new files or directories from either a source or a URL to a destination
    in the image filesystem'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ENTRYPOINT` Makes your container run like an executable (which you can think
    of as any Linux command line application that takes arguments on your host)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CMD` Provides a default command or default parameters for the container (can
    be used in conjunction with `ENTRYPOINT`)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See the Dockerfile reference at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
    for instructions and configuration details.
  prefs: []
  type: TYPE_NORMAL
- en: Container Images and Layers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Dockerfile you build creates a container image. This image is made of different
    layers that house your application, dependencies, and anything else the application
    needs so it can run. These layers are like snapshots in time of your application’s
    state, so keeping your Dockerfiles in version control along with your source code
    makes it easier to build new container images every time your application code
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: The layers fit together like LEGO bricks. Each layer, or intermediate image,
    is created each time an instruction in the Dockerfile is executed. For example,
    every time you use the `RUN` instruction, a new intermediate layer is created
    with the results of that instruction. Each layer (image) is assigned a unique
    hash, and all layers are cached by default. This means you can share layers with
    other images, so if a given layer hasn’t changed, you don’t need to build it again
    from scratch. Also, caching is your best friend, as it cuts down the time and
    space needed to build images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker can stack these layers on top of each other because it uses the *union
    filesystem (UFS**)*, which allows multiple filesystems to come together and create
    what looks like a single filesystem. The topmost layer is the *container layer*,
    which is added when you run the container image. It’s the only layer that can
    be written to. All the subsequent layers are read only, by design. If you make
    any file or system changes to the container layer and then remove the running
    container, those changes will be gone. The underlying read-only images are kept
    intact. This is why containers are so popular with software engineers: the image
    is an immutable artifact that can be run on any Docker host and behave in the
    same way.'
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Docker container is a running instance of a container image. In computer
    programming terms, you can think of the container image as a *class* and the container
    as an *instance* of that class. When the container starts, the container layer
    is created. This writeable layer is where all the changes (like writing, deleting,
    and modifying existing files) will take place.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces and Cgroups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The container is also roped off from the rest of the Linux host by some boundaries
    and limited views called *namespaces* and *cgroups*. These are kernel features
    that limit what a container can see and use on a host. They also make OS-level
    virtualization a reality. Namespaces restrict global system resources for a container.
    Without namespaces, a container could have free run of the system. Imagine if
    a container could see a process in another container. That mischievous container
    could kill a process, delete a user, or unmount a directory in another container.
    Try tracking that down when you’re on call at 2 am!
  prefs: []
  type: TYPE_NORMAL
- en: 'Common kernel namespaces include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Process ID (`PID`) Isolates the process IDs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Network (`net`) Isolates the network interface stack
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: UTS Isolates the hostname and domain name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mount (`mnt`) Isolates the mount points
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IPC Isolates the SysV-style interprocess communication
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: User Isolates the user and group IDs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using these namespaces is not enough, however. You also need to control how
    much memory, CPU, and other physical resources a container uses. That’s where
    cgroups come in. Cgroups manage and measure the resources a container can use.
    They allow you to set resource limitations and prioritization for processes. The
    most common resources Docker sets with cgroups are memory, CPU, disk I/O, and
    network. Cgroups make it possible to stop a container from using up all the resources
    on a host.
  prefs: []
  type: TYPE_NORMAL
- en: The main point to remember is that namespaces limit what you can see, while
    cgroups limit what you can use. Without these features, containers would not be
    secure or useful.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and Testing Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To containerize a sample application, you’ll start by installing Docker with
    the aid of *minikube*, an app that contains the Docker engine and also provides
    a Kubernetes cluster (which you’ll use in the next chapter). Next, you’ll install
    the `docker` client so that you’ll be able to communicate with the Docker server.
    Then, you’ll configure your environment so that it can find the new Docker server.
    Finally, you’ll test client connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Docker Engine with Minikube
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To install minikube, follow the instructions for your operating system at [https://minikube.sigs.k8s.io/](https://minikube.sigs.k8s.io/).
    If you’re not on a Linux host, minikube requires a virtual machine manager to
    install Docker. Use VirtualBox for that.
  prefs: []
  type: TYPE_NORMAL
- en: By default, minikube makes a best guess about memory allocation for the VM it
    will create. It also sets the number of CPUs to two and the disk space to 20GB.
    For the purposes of this book, the defaults should be fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start minikube using the resource defaults and VirtualBox as the VM manager,
    enter the following in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `Done!` message shows that minikube started successfully. If minikube fails
    to start, you should investigate any error messages listed in the output.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Docker Client and Setting Up Docker Environment Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To install the `docker` client, follow the instructions at [https://docs.docker.com/engine/install/binaries/](https://docs.docker.com/engine/install/binaries/)
    for your operating system. Make sure you only download and install the client
    binary. You’ll use minikube to set some local environment variables in your shell,
    including the Docker host IP and the path to the Docker host TLS certificates,
    which are needed to connect. The Bash `eval` command will source the environment
    variables in your shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal, enter the following to set your Docker environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This command should return zero output if it’s successful. The Docker host environment
    variables should be exported in your current terminal session.
  prefs: []
  type: TYPE_NORMAL
- en: When you close this terminal window, the environment variables will be lost,
    and you’ll need to run the command each time you want to interact with the Docker
    server. To avoid this inconvenience, add the command to the bottom of your shell
    configuration file such as *~/.bashrc* or *~/.zshrc* so it’s executed each time
    you open a terminal window or tab. Then you won’t see the `Is the docker daemon
    running?` error.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Docker Client Connectivity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should test whether the `docker` client can talk to the Docker server running
    inside the minikube VM. In the same terminal where you set the environment variables,
    enter the following to check the Docker version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The output should show your client and server versions if the connection is
    successful.
  prefs: []
  type: TYPE_NORMAL
- en: Containerizing a Sample Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I created a sample application named *telnet-server* that you can use to build
    a container with Docker. It’s a simple telnet server that mimics the bulletin
    board systems (BBSs) people used in the 1980s. The app is written in the Go programming
    language for OS portability and a small footprint. You’ll use an Alpine Linux
    container image that contains Go and all the needed dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: To containerize an application, you’ll need the source code or binary you want
    to run in the container plus the Dockerfile to build the container image. The
    sample application source code and Dockerfile are in the companion repository
    for this book at [https://github.com/bradleyd/devops_for_the_desperate/](https://github.com/bradleyd/devops_for_the_desperate/
    ) in the *telnet-server/* folder.
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting the Example telnet-server Dockerfile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The example Dockerfile is a *multistage* *build* with two separate stages:
    *build* and *final*. Multistage builds allow you to manage complex builds in one
    Dockerfile, and they provide a good pattern for keeping container images small
    and secure. In the build stage, the Dockerfile instruction compiles the sample
    application with all its dependencies. In the final stage, the Dockerfile instruction
    copies the build artifact (in this case, the compiled sample application) from
    the build stage. The final container image is much smaller because it doesn’t
    contain all the dependencies or source code for the sample application from the
    build stage. Visit [https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/)for
    more information on multistage builds.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the *telnet-server/* directory and open the Dockerfile, which should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The file starts the build stage with a `FROM` instruction to pull in the `golang:alpine`
    parent image. This is an Alpine Linux image from the Docker Hub registry that’s
    prebuilt for developing in the Go programming language. This image stage is named
    `build-env`, using the `AS` keyword. This name reference is used again later,
    in the final stage.
  prefs: []
  type: TYPE_NORMAL
- en: The `ADD` instruction copies all the Go source code in the current local *telnet-server/*
    directory to the image’s filesystem at the root (`/`) destination.
  prefs: []
  type: TYPE_NORMAL
- en: The next `RUN` instruction executes the shell command that navigates to the
    root directory in the image filesystem, and it uses the `go build` command to
    build the Go binary named telnet-server.
  prefs: []
  type: TYPE_NORMAL
- en: The final stage begins with a `FROM` instruction that again pulls in an Alpine
    Linux image (`alpine:latest`) for the final stage’s parent image. This time, though,
    the Alpine Linux image is the minimal image in which the application will run.
    It doesn’t contain any dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The `WORKDIR` instruction sets the working directory for the application, which
    is */app* in this example. Any `CMD`, `RUN`, `COPY`, or `ENTRYPOINT` instruction
    after that declaration will be executed in the context of that working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two `ENV` instructions set environment variables in the container image
    that the application can use: they set the telnet server to port `2323` and the
    metric server port to `9000`. (More on those ports later.)'
  prefs: []
  type: TYPE_NORMAL
- en: The `COPY` instruction copies the telnet-server Golang binary from the `build-env`
    stage and places it in the working *app/* directory in the final-stage Alpine
    image.
  prefs: []
  type: TYPE_NORMAL
- en: The final `ENTRYPOINT` instruction invokes the telnet-server binary when the
    container starts to execute the sample application. You’ll use `ENTRYPOINT` instead
    of `CMD` because the application will require additional flags passed to it during
    a container test in a later chapter. If you need to override the default command
    in your container, swap `ENTRYPOINT` with the `CMD` instruction instead. See the
    Dockerfile reference at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
    to learn more about `CMD` versus `ENTRYPOINT`.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Container Image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, you’ll build the container image for the sample telnet-server application,
    using the Dockerfile you just reviewed. Navigate to the *telnet-server/* directory
    and enter the following to pass Docker the image name and Dockerfile location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-t` flag sets the name and (optionally) a tag for the image, and the dot
    (`.`) argument sets the Dockerfile’s current location. The *dftd/telnet-server:v1*
    URI has three parts: the registry hostname (*dftd*), the image name, and the tag.
    The registry is local to minikube rather than online, so you can use anything
    for the base. (If it were a remote registry, you’d use something like *registry.example.com*.)
    The image name sandwiched between the forward slash (`/`) and the colon (`:`)
    is set to the name of the example application, *telnet-server*. The *v1* image
    tag comes after the colon.'
  prefs: []
  type: TYPE_NORMAL
- en: Tags allow you to identify each build of an image and indicate what changes
    are inside. Using Git commit hashes as tags is a common practice, as each hash
    is unique and can mark the image’s source code version. If you omit the tag, Docker
    uses the latest word as the default tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the command, you should see output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Each instruction is logged, allowing you to follow along with the build process
    in a linear fashion. At the end of the build, the image ID (`f796da88ab94`) should
    be listed, followed by a note that the image is tagged successfully as *dftf/telnet-server:v1*.
    The image ID you see will be different.
  prefs: []
  type: TYPE_NORMAL
- en: If your `docker build` wasn’t successful, you’ll want to resolve any errors
    in the output because you’ll build upon this image going forward. Common errors
    are typos in the `RUN` execution and missing files when using the `COPY` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the Docker Image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, verify that the Docker registry inside minikube is storing the telnet-server
    image. (As mentioned previously, a registry is a server that stores and serves
    container images.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal, enter the following to list the Docker telnet-server image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the final image for the telnet-server is only 16.8MB. The Alpine
    Linux base image in the final stage was roughly 5MB before adding the telnet-server
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next step is to create and run the telnet-server container from the image
    you just built. Do this by entering the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `-p` (port) flag exposes port `2323` outside the container. (The telnet-server
    application needs to have port `2323` open.) The left side of the colon (`:`)
    is the host port, and the right side is the container port. This is useful if
    you have another application listening on the same port and need to change it
    for the host while keeping the container port the same. The `-d` (detach) flag
    launches the container in the background. If you don’t supply the `-d` flag, the
    container will run in the foreground of the terminal from which it launched. The
    `--name` flag sets the container name to `telnet-server`. Docker, by default,
    assigns randomly generated names for containers if you don’t set them. The last
    argument is the image name, complete with path and tag, from the build step.
  prefs: []
  type: TYPE_NORMAL
- en: The container is now running in the background and ready to accept traffic.
    This `docker run` command was successful because it returned the *container ID*
    (the long string of numbers and letters, which will be different for you) and
    no errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following to verify that the container is actually running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The optional filter flag (`-f`) narrows the output to the containers you specify.
    If you omit the filter flag, running the command should list every container running
    on the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the container is running, the output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `CONTAINER ID` column matches the first 12 digits of the ID received from
    the `docker run` command issued previously. The `IMAGE` column contains the image
    ID given when you built the container image. The `PORTS` column shows that port
    `2323` is exposed on every interface (0.0.0.0) and is mapping that traffic to
    port `2323` inside the container. The directional arrow (`->`) denotes the traffic
    flow direction. Finally, the `NAMES` column shows the telnet-server name set earlier
    from the `run` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, enter the following in your terminal to stop the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The container name should be returned, letting you know the Docker daemon thinks
    the container is stopped. To start the container again, swap the word `stop` with
    `start`, and you should see the container name returned again.
  prefs: []
  type: TYPE_NORMAL
- en: Docker won’t check to see whether your application stays running after you start
    it. As long as the container can start and not error out immediately, entering
    `docker start` or `docker run` will return the container name as if nothing were
    wrong. This can be misleading. You’ll want to perform health checks and monitor
    the application to verify that it’s actually running. (We’ll explore those topics
    in future chapters.)
  prefs: []
  type: TYPE_NORMAL
- en: Other Docker Client Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at a few more common Docker commands you’ll need to use when working
    with containers.
  prefs: []
  type: TYPE_NORMAL
- en: exec
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `exec` command allows you to run a command inside a container or interact
    with a container, as if you were logged in to a terminal session. For example,
    if you are troubleshooting an application in a container and want to verify that
    the correct environment variables are being set, you could run the following command
    in a terminal to output all the environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `env` command executes inside the container, using the OS’s default shell.
    When it finishes, the output is sent back to the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `exec` command also allows you to access a running container to troubleshoot
    it or run a command. You’ll need to pass the interactive flag (`-i`) and the pseudo-TTY
    flag (`-t`), along with the shell command (`/bin/sh`), to do this. The interactive
    flag keeps STDIN open so you can type commands inside the container layer. The
    pseudo-TTY flag simulates a terminal, and when combined with the interactive flag,
    it mimics being in a live terminal session inside the container. Operating systems
    other than Linux will use different shells: most commonly, */bin/sh* and */bin/bash*.
    Alpine Linux uses the */bin/sh* shell as its default.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following in a terminal to get a shell inside the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `ls` command is issued to show you’re inside the container you built. (You
    earlier set the working directory to *app/* and put the telnet-server binary in
    there.) Input the `exit` command and press enter to leave the container and return
    to the local terminal.
  prefs: []
  type: TYPE_NORMAL
- en: rm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `rm` command removes a stopped container. For example, to remove the telnet-server
    container once it is stopped, enter the following in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The removed container’s name should be returned. You can use the `-f` (force)
    flag to remove a running container, but it’s best to stop it first.
  prefs: []
  type: TYPE_NORMAL
- en: inspect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `inspect` `docker` command returns low-level information about some Docker
    objects. The output is in JSON format by default. Depending on the Docker object,
    the results can be verbose.
  prefs: []
  type: TYPE_NORMAL
- en: 'To inspect the telnet-server container, enter the following in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `State` section 1 contains data about the running container, like `Status`
    and `StartedAt` date. The `NetworkSettings` section 2 provides information like
    `Ports` and `IPAddress`, which are helpful when troubleshooting problematic containers.
  prefs: []
  type: TYPE_NORMAL
- en: history
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `history` command displays a container image’s history, which is useful
    for viewing the number and sizes of an image’s layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the telnet-server image’s layers, enter the following in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The output (edited) shows the instructions that start each layer, like `COPY`
    and `ADD`. It also shows the layers’ ages and sizes.
  prefs: []
  type: TYPE_NORMAL
- en: stats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `stats` command displays a real-time update on the resources a container
    is using. It gathers this information from the cgroups and behaves similarly to
    the Linux `top` command. If you have a host that manages multiple containers and
    want to see which one is the resource hog, use the `stats` command. Once you run
    the `stats` command, it drops you into a page that updates every few seconds.
    As that’s impossible to show in a book, we’ll pass the `--no-stream` flag to take
    a snapshot of the resources and exit immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following to show the telnet-server container’s resource usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This telnet-server container is using virtually no CPU, no disk or network I/O,
    and only 2MiB of memory. You could easily run hundreds of these in a cloud environment
    on a single server.
  prefs: []
  type: TYPE_NORMAL
- en: Visit [https://docs.docker.com/engine/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/)to
    explore all of the `docker` command line client’s commands and flags.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To find out whether the sample application you’ve containerized actually works,
    you’ll connect to the telnet-server on port `2323` and run some basic commands.
    Then you’ll view the container logs to verify that the application is working
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Before performing either of these steps, however, you’ll need to install a `telnet`
    client for your OS to communicate with the telnet-server. If you’re using macOS,
    simply enter `brew install telnet` in your terminal. If you’re using Ubuntu, enter
    `apt` `install telnet` in a terminal as a privileged user.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the Telnet-Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To connect to the server, pass telnet the hostname or IP address of the server
    plus the port to which you want to connect. Since the Docker server is running
    inside a VM (minikube), you’ll need the IP address minikube exposes to your local
    host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following in a terminal to get the IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: My minikube IP address is 192.168.99.103; yours may be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect to the telnet-server running inside the container, pass the IP address
    (192.168.99.103) and port (`2323`) to the `telnet` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Success! The ASCII text banner of DFTD should greet you in all its glory. You’re
    now connected to the telnet-server application. The prompt (`>`) is where you
    can enter commands. To start, you can enter only the `date`, `help`, `yell`, and
    `quit` commands. You can use the first character of any of those commands as a
    shortcut, and any commands you enter will be logged.
  prefs: []
  type: TYPE_NORMAL
- en: 'While still connected to the telnet-server, enter the following to print the
    current date and time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Great! The current date and time should be displayed. Depending on your age,
    this could bring back memories of baud rates and high-pitched squeals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following to quit the telnet-server session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You should see that the telnet-server session is nice enough to say goodbye.
    Take that, modern-day internet!
  prefs: []
  type: TYPE_NORMAL
- en: You can add new commands to the server or change the responses in the *telnet-server/telnet/server.go*
    file. If you do, don’t forget to build, stop, and replace the image and container
    using the commands you learned earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Logs from the Container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker provides a simple way to retrieve logs from a running container. This
    is important for troubleshooting and forensics purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see all the logs for the telnet-server, which is logging to STDOUT, enter
    the following in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines of output are startup messages showing that the server is
    running and listening on specific ports. (We’ll explore the metrics server when
    we look at monitoring applications in Chapter 9.) The fourth log line is from
    when you entered the `d` command into the telnet session to print the current
    date and time. The fifth log line shows when you entered `q` to exit the test
    telnet session.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re a software or DevOps engineer, you need a solid understanding of containers
    in today’s infrastructure. In this chapter, you explored how Docker makes containers
    possible with OS-level virtualization. You examined how a Dockerfile works to
    create the layers of a container image, and you applied that knowledge to build
    a sample container image using a multistage build. Finally, you started a container
    from the provided telnet-server image, tested that it was working correctly, and
    checked its logs. In the next chapter, you’ll take the telnet-server image you
    built here and run it inside a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
