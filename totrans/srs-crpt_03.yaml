- en: '2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '2'
- en: RANDOMNESS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随机性
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: 'Randomness is found everywhere in cryptography: in the generation of secret
    keys, in encryption schemes, and even in the attacks on cryptosystems. Without
    randomness, cryptography would be impossible because all operations would become
    predictable, and therefore insecure.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随机性在密码学中无处不在：在生成秘密密钥、加密方案，甚至在密码系统的攻击中。没有随机性，密码学将无法进行，因为所有操作都将变得可预测，因此不安全。
- en: This chapter introduces you to the concept of randomness in the context of cryptography
    and its applications. We discuss pseudorandom number generators and how operating
    systems can produce reliable randomness, and we conclude with real examples showing
    how flawed randomness can impact security.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍密码学中随机性的概念及其应用。我们讨论伪随机数生成器以及操作系统如何产生可靠的随机性，并通过实际例子展示有缺陷的随机性如何影响安全性。
- en: Random or Non-Random?
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机还是非随机？
- en: You’ve probably already heard the phrase “random bits,” but strictly speaking
    there is no such thing as a series of random bits. What is random is actually
    the algorithm or process that produces a series of random bits; therefore, when
    we say “random bits,” we actually mean randomly generated bits.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经听过“随机位”这个词，但严格来说，并没有所谓的“随机位”序列。真正随机的是产生随机位序列的算法或过程；因此，当我们说“随机位”时，实际上指的是随机生成的位。
- en: What do random bits look like? For example, to most people, the 8-bit string
    11010110 is more random than 00000000, although both have the same chance of being
    generated (namely, 1/256). The value 11010110 looks more random than 00000000
    because it has the signs typical of a randomly generated value. That is, 11010110
    has no obvious pattern.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 随机位是什么样子的？例如，对于大多数人来说，8位字符串11010110比00000000更具随机性，尽管它们生成的机会是相同的（即1/256）。11010110看起来更随机，是因为它具有典型的随机生成值的特征。也就是说，11010110没有明显的模式。
- en: When we see the string 11010110, our brain registers that it has about as many
    zeros (three) as it does ones (five), just like 55 other 8-bit strings (11111000,
    11110100, 11110010, and so on), but only one 8-bit string has eight zeros. Because
    the pattern three-zeros-and-five-ones is more likely to occur than the pattern
    eight-zeros, we identify 11010110 as random and 00000000 as non-random, and if
    a program produces the bits 11010110, you may think that it’s random, even if
    it’s not. Conversely, if a randomized program produces 00000000, you’ll probably
    doubt that it’s random.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到字符串11010110时，大脑会注册到它的零（3个）和一（5个）的数量大致相同，就像其他55个8位字符串（11111000、11110100、11110010等），但只有一个8位字符串是全零的。因为模式“三个零和五个一”比“八个零”的模式更可能出现，我们将11010110识别为随机，而将00000000识别为非随机。如果一个程序生成了11010110，你可能认为它是随机的，即使它并不随机。相反，如果一个随机程序生成了00000000，你可能会怀疑它是不是随机的。
- en: 'This example illustrates two types of errors people often make when identifying
    randomness:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了人们在识别随机性时常犯的两种错误：
- en: '**Mistaking non-randomness for randomness** Thinking that an object was randomly
    generated simply because it *looks* random.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**把非随机性误认为是随机性** 认为某个对象是随机生成的，仅仅因为它*看起来*是随机的。'
- en: '**Mistaking randomness for non-randomness** Thinking that patterns appearing
    by chance are there for a reason other than chance.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**把随机性误认为是非随机性** 认为偶然出现的模式是出于其他原因，而非偶然。'
- en: The distinction between random-looking and actually random is crucial. Indeed,
    in crypto, non-randomness is often synonymous with insecurity.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随机看起来与真正随机之间的区别至关重要。事实上，在密码学中，非随机性通常意味着不安全。
- en: Randomness as a Probability Distribution
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机性作为概率分布
- en: Any randomized process is characterized by a *probability distribution*, which
    gives all there is to know about the randomness of the process. A probability
    distribution, or simply distribution, lists the outcomes of a randomized process
    where each outcome is assigned a *probability*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 任何随机化过程都由*概率分布*来表征，概率分布提供了关于该过程随机性的所有信息。概率分布，或者简而言之分布，列出了随机化过程的结果，其中每个结果都被分配一个*概率*。
- en: A probability measures the likelihood of an event occurring. It’s expressed
    as a real number between 0 and 1 where a probability 0 means impossible and a
    probability of 1 means certain. For example, when tossing a two-sided coin, each
    side has a probability of landing face up of 1/2, and we usually assume that landing
    on the edge of the coin has probability zero.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 概率衡量一个事件发生的可能性。它表示为介于 0 和 1 之间的实数，其中概率为 0 表示不可能，概率为 1 表示确定。例如，当抛一枚双面硬币时，每一面朝上的概率为
    1/2，我们通常假设硬币落在边缘的概率为零。
- en: A probability distribution must include all possible outcomes, such that the
    sum of all probabilities is 1\. Specifically, if there are *N* possible events,
    there are *N* probabilities *p*[1], *p*[2], … , *p*[*N*] with *p*[1] + *p*[2]
    + … + *p*[*N*] = 1\. In the case of the coin toss, the distribution is 1/2 for
    heads and 1/2 for tails. The sum of both probabilities is equal to 1/2 + 1/2 =
    1, because the coin will fall on one of its two faces.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 概率分布必须包括所有可能的结果，以使所有概率的总和为 1。具体来说，如果有 *N* 个可能的事件，那么有 *N* 个概率 *p*[1]，*p*[2]，…，*p*[*N*]，并且
    *p*[1] + *p*[2] + … + *p*[*N*] = 1。例如，在抛硬币的情况下，正面和反面的分布分别是 1/2 和 1/2。两个概率的总和为
    1/2 + 1/2 = 1，因为硬币会落在两个面之一。
- en: A *uniform distribution* occurs when all probabilities in the distribution are
    equal, meaning that all outcomes are equally likely to occur. If there are *N*
    events, then each event has probability 1/*N*. For example, if a 128-bit key is
    picked uniformly at random—that is, according to a uniform distribution—then each
    of the 2^(128) possible keys should have a probability of 1/2^(128).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*均匀分布*发生在分布中的所有概率相等时，这意味着所有结果发生的可能性相等。如果有 *N* 个事件，那么每个事件的概率为 1/*N*。例如，如果一个
    128 位的密钥是均匀随机选择的——即根据均匀分布——那么所有 2^(128) 个可能的密钥的概率应该是 1/2^(128)。'
- en: In contrast, when a distribution is *non-uniform*, probabilities aren’t all
    equal. A coin toss with a non-uniform distribution is said to be biased, and may
    yield heads with probability 1/4 and tails with probability 3/4, for example.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当分布是 *非均匀* 时，概率并不相等。例如，一次具有非均匀分布的硬币抛掷可能会以 1/4 的概率出现正面，3/4 的概率出现反面。
- en: 'Entropy: A Measure of Uncertainty'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 熵：不确定性的度量
- en: '*Entropy* is the measure of uncertainty, or disorder in a system. You might
    think of entropy as the amount of surprise found in the result of a randomized
    process: the higher the entropy, the less the certainty found in the result.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*熵*是衡量系统中不确定性或无序度的指标。你可以将熵看作是随机过程结果中的惊讶程度：熵越高，结果的不确定性越大。'
- en: 'We can compute the entropy of a probability distribution. If your distribution
    consists of probabilities *p*[1], *p*[2], … , *p*[*N*], then its entropy is the
    negative sum of all probabilities multiplied by their logarithm, as shown in this
    expression:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以计算概率分布的熵。如果你的分布包含概率 *p*[1]，*p*[2]，…，*p*[*N*]，那么它的熵是所有概率与它们的对数相乘的负和，如下所示：
- en: −*p*[1] × log(*p*[1]) − *p*[2] × log(*p*[2]) − … − *p[N]* × log(*p[N]*)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: −*p*[1] × log(*p*[1]) − *p*[2] × log(*p*[2]) − … − *p[N]* × log(*p[N]*)
- en: 'Here the function *log* is the *binary logarithm*, or logarithm in base two.
    Unlike the natural logarithm, the binary logarithm expresses the information in
    bits and yields integer values when probabilities are powers of two. For example,
    log(1/2) = –1, log(1/4) = –2, and more generally log(1/2^(*n*)) = –*n*. (That’s
    why we actually take the *negative sum*, in order to end up with a positive number.)
    Random 128-bit keys produced using a uniform distribution therefore have the following
    entropy:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的函数 *log* 是 *二进制对数*，即以二为底的对数。与自然对数不同，二进制对数以位为单位表示信息，并且当概率是二的幂时，它会返回整数值。例如，log(1/2)
    = -1，log(1/4) = -2，更一般地，log(1/2^(*n*)) = - *n*。（这就是为什么我们实际取 *负和*，以得到一个正数。）因此，使用均匀分布生成的随机
    128 位密钥的熵为：
- en: 2^(128) × (−2^(−128) × log(2^(−128))) = −log(2^(−128)) = 128 bits
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 2^(128) × (−2^(−128) × log(2^(−128))) = −log(2^(−128)) = 128 位
- en: If you replace 128 by any integer *n* you will find that the entropy of a uniformly
    distributed *n*-bit string will be *n* bits.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 128 替换为任意整数 *n*，你会发现均匀分布的 *n* 位字符串的熵为 *n* 位。
- en: 'Entropy is maximized when the distribution is uniform because a uniform distribution
    maximizes uncertainty: no outcome is more likely than the others. Therefore, *n*-bit
    values can’t have more than *n* bits of entropy.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当分布是均匀时，熵最大，因为均匀分布最大化了不确定性：没有结果比其他结果更有可能发生。因此，*n* 位值的熵不能超过 *n* 位。
- en: 'By the same token, when the distribution is not uniform, entropy is lower.
    Consider the coin toss example. The entropy of a fair toss is the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，当分布不均匀时，熵就较低。考虑硬币抛掷的例子。公平抛掷的熵是如下：
- en: −(1/2) × log (1/2) − (1/2) × log (1/2) = 1/2 + 1/2 = 1 bit
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: −(1/2) × log (1/2) − (1/2) × log (1/2) = 1/2 + 1/2 = 1 bit
- en: What if one side of the coin has a higher probability of landing face up than
    the other? Say heads has a probability of 1/4 and tails 3/4 (remember that the
    sum of all probabilities should be 1).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果硬币的一面比另一面更可能朝上怎么办？比如正面朝上的概率是1/4，反面朝上的概率是3/4（记住所有概率的总和应该为1）。
- en: 'The entropy of such a biased toss is this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种偏向的抛掷的熵为：
- en: −(3/4) × log(3/4) − (1/4) × log(1/4) ≈ −(3/4) × (−0.415) − (1/4) × (−2) ≈ 0.81
    bit
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: −(3/4) × log(3/4) − (1/4) × log(1/4) ≈ −(3/4) × (−0.415) − (1/4) × (−2) ≈ 0.81
    bit
- en: The fact that 0.81 is less than the 1-bit entropy of a fair toss tells us that
    the more biased the coin, the less uniform the distribution and the lower the
    entropy. Taking this example further, if heads has a probability of 1/10, the
    entropy is 0.469; if the probability drops to 1/100, the entropy drops to 0.081.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 0.81比公平抛掷的1位熵要少，这告诉我们硬币越偏，分布越不均匀，熵越低。进一步说，如果正面的概率是1/10，那么熵为0.469；如果概率降至1/100，熵降至0.081。
- en: '**NOTE**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Entropy can also be viewed as a measure of information. For example, the result
    of a fair coin toss gives you exactly one bit of information—heads or tails—and
    you’re unable to predict the result of the toss in advance. In the case of the
    unfair coin toss, you know in advance that tails is more probable, so you can
    usually predict the outcome of the toss. The result of the coin toss gives you
    the information needed to predict the result with certainty.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*熵也可以视为信息的度量。例如，公平抛硬币的结果给你正好一位信息——正面或反面——你无法预先预测抛掷结果。在不公平的硬币抛掷中，你提前知道反面更可能出现，因此你通常可以预测抛掷的结果。硬币抛掷的结果提供了预测结果所需的信息，且可以确定预测。*'
- en: Random Number Generators (RNGs) and Pseudorandom Number Generators (PRNGs)
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机数生成器（RNGs）和伪随机数生成器（PRNGs）
- en: 'Cryptosystems need randomness to be secure and therefore need a component from
    which to get their randomness. The job of this component is to return random bits
    when requested to do so. How is this randomness generation done? You’ll need two
    things:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 加密系统需要随机性来保持安全性，因此需要一个组件来获取随机性。这个组件的任务是，在被请求时返回随机位。那么，如何生成这种随机性呢？你需要两个东西：
- en: A source of uncertainty, or *source of entropy*, provided by random number generators
    (RNGs).
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不确定性的来源，或称*熵的来源*，由随机数生成器（RNGs）提供。
- en: A cryptographic algorithm to produce high-quality random bits from the source
    of entropy. This is found in pseudorandom number generators (PRNGs).
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个加密算法，用于从熵的来源产生高质量的随机位。这在伪随机数生成器（PRNGs）中有所体现。
- en: Using RNGs and PRNGs is the key to making cryptography practical and secure.
    Let’s briefly look at how RNGs work before exploring PRNGs in depth.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RNGs和PRNGs是使加密技术实用且安全的关键。在深入研究PRNGs之前，我们先简要了解RNGs的工作原理。
- en: Randomness comes from the environment, which is analog, chaotic, uncertain,
    and hence unpredictable. Randomness can’t be generated by computer-based algorithms
    alone. In cryptography, randomness usually comes from *random number generators
    (RNGs)*, which are software or hardware components that leverage entropy in the
    analog world to produce unpredictable bits in a digital system. For example, an
    RNG might directly sample bits from measurements of temperature, acoustic noise,
    air turbulence, or electrical static. Unfortunately, such analog entropy sources
    aren’t always available, and their entropy is often difficult to estimate.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 随机性来自环境，它是模拟的、混乱的、不确定的，因此是不可预测的。仅靠计算机算法无法生成随机性。在加密学中，随机性通常来自*随机数生成器（RNGs）*，这些是利用模拟世界中的熵生成数字系统中不可预测位的软件或硬件组件。例如，一个RNG可能直接从温度、声噪、空气湍流或电气静电的测量中采样位。不幸的是，这些模拟熵源并不总是可用，而且它们的熵通常难以估计。
- en: RNGs can also harvest the entropy in a running operating system by drawing from
    attached sensors, I/O devices, network or disk activity, system logs, running
    processes, and user activities such as key presses and mouse movement. Such system-
    and human-generated activities can be a good source of entropy, but they can be
    fragile and manipulated by an attacker. Also, they’re slow to yield random bits.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: RNG 还可以通过从附加的传感器、I/O 设备、网络或磁盘活动、系统日志、运行中的进程和用户活动（如按键和鼠标移动）中获取熵来收集一个正在运行的操作系统中的熵。此类系统和人为生成的活动可以是一个很好的熵源，但它们可能很脆弱，且容易受到攻击者的操控。此外，它们生成随机位的速度较慢。
- en: '*Quantum random number generators (QRNGs)* are a type of RNG that relies on
    the randomness arising from quantum mechanical phenomena such as radioactive decay,
    vacuum fluctuations, and observing photons’ polarization. These can provide *real*
    randomness, rather than just apparent randomness. However, in practice, QRNGs
    may be biased and don’t produce bits quickly; like the previously cited entropy
    sources, they need an additional component to produce reliably at high speed.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*量子随机数生成器（QRNGs）* 是一种依赖于量子力学现象（如放射性衰变、真空波动和观察光子偏振）产生随机性的 RNG。它们可以提供*真正的*随机性，而不仅仅是表面上的随机性。然而，实际上，QRNG
    可能存在偏差，并且不能快速生成位；像前面提到的熵源一样，它们需要额外的组件才能在高速下稳定生成。'
- en: '*Pseudorandom number generators (PRNGs)* address the challenge we face in generating
    randomness by reliably producing many artificial random bits from a few true random
    bits. For example, an RNG that translates mouse movements to random bits would
    stop working if you stop moving the mouse, whereas a PRNG always returns pseudorandom
    bits when requested to do so.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*伪随机数生成器（PRNGs）* 解决了我们在生成随机性方面的挑战，通过可靠地从少量真正的随机位中生成许多人工随机位。例如，一个将鼠标移动转换为随机位的
    RNG 如果停止移动鼠标就会停止工作，而 PRNG 每次请求时都会返回伪随机位。'
- en: 'PRNGs rely on RNGs but behave differently: RNGs produce true random bits relatively
    slowly from analog sources, in a nondeterministic way, and with no guarantee of
    high entropy. In contrast, PRNGs produce random-looking bits quickly from digital
    sources, in a deterministic way, and with maximum entropy. Essentially, PRNGs
    transform a few unreliable random bits into a long stream of reliable pseudorandom
    bits suitable for crypto applications, as shown in [Figure 2-1](ch02.xhtml#ch2fig1).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: PRNG 依赖于 RNG，但其行为有所不同：RNG 从模拟源中以非确定性的方式相对缓慢地产生真正的随机位，并且没有高熵的保证。相比之下，PRNG 从数字源中以确定性的方式快速生成看似随机的位，并且具有最大熵。本质上，PRNG
    将少量不可靠的随机位转换为适用于加密应用的大量可靠伪随机位，如[图 2-1](ch02.xhtml#ch2fig1)所示。
- en: '![image](../images/f02-01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f02-01.jpg)'
- en: '*Figure 2-1: RNGs produce few unreliable bits from analog sources, whereas
    PRNGs expand those bits to a long stream of reliable bits.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：RNG 从模拟源中生成少量不可靠的位，而 PRNG 将这些位扩展为可靠的长位流。*'
- en: '*How PRNGs Work*'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*PRNG 工作原理*'
- en: A PRNG receives random bits from an RNG at regular intervals and uses them to
    update the contents of a large memory buffer, called the *entropy pool*. The entropy
    pool is the PRNG’s source of entropy, just like the physical environment is to
    an RNG. When the PRNG updates the entropy pool, it mixes the pool’s bits together
    to help remove any statistical bias.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: PRNG 定期从 RNG 获取随机位，并使用它们更新一个大型内存缓冲区，称为 *熵池*。熵池是 PRNG 的熵源，就像物理环境对于 RNG 一样。当 PRNG
    更新熵池时，它将熵池中的位混合在一起，以帮助消除任何统计偏差。
- en: 'In order to generate pseudorandom bits, the PRNG runs a deterministic random
    bit generator (DRBG) algorithm that expands some bits from the entropy pool into
    a much longer sequence. As its name suggests, a DRBG is deterministic, not randomized:
    given one input you will always get the same output. The PRNG ensures that its
    DRBG never receives the same input twice, in order to generate unique pseudorandom
    sequences.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成伪随机位，PRNG 运行一个确定性随机位生成器（DRBG）算法，将熵池中的一些位扩展成更长的序列。顾名思义，DRBG 是确定性的，而不是随机的：给定一个输入，你总是会得到相同的输出。PRNG
    确保其 DRBG 永远不会接收到相同的输入两次，从而生成唯一的伪随机序列。
- en: 'In the course of its work, the PRNG performs three operations, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在其工作过程中，PRNG 执行三个操作，如下所示：
- en: '***init()*** Initializes the entropy pool and the internal state of the PRNG'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '***init()*** 初始化熵池和 PRNG 的内部状态'
- en: '***refresh(R)*** Updates the entropy pool using some data, *R*, usually sourced
    from an RNG'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '***refresh(R)*** 使用一些数据 *R* 更新熵池，数据通常来源于 RNG'
- en: '***next(N)*** Returns *N* pseudorandom bits and updates the entropy pool'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '***next(N)*** 返回 *N* 个伪随机比特并更新熵池'
- en: The *init* operation resets the PRNG to a fresh state, reinitializes the entropy
    pool to some default value, and initializes any variables or memory buffers used
    by the PRNG to carry out the *refresh* and *next* operations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*init* 操作将 PRNG 重置为一个全新的状态，重新初始化熵池为默认值，并初始化 PRNG 用于执行 *refresh* 和 *next* 操作的任何变量或内存缓冲区。'
- en: The *refresh* operation is often called *reseeding*, and its argument *R* is
    called a *seed*. When no RNG is available, seeds may be unique values hardcoded
    in a system. The *refresh* operation is typically called by the operating system,
    whereas *next* is typically called or requested by applications. The *next* operation
    runs the DRBG and modifies the entropy pool to ensure that the next call will
    yield different pseudorandom bits.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*refresh* 操作通常称为 *重新播种*，其参数 *R* 被称为 *种子*。当没有 RNG 可用时，种子可能是系统中硬编码的唯一值。*refresh*
    操作通常由操作系统调用，而 *next* 则通常由应用程序调用或请求。*next* 操作运行 DRBG 并修改熵池，确保下一次调用将生成不同的伪随机比特。'
- en: '*Security Concerns*'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*安全问题*'
- en: Let’s talk briefly about the way that PRNGs address some high-level security
    concerns. Specifically, PRNGs should guarantee *backtracking resistance* and *prediction
    resistance*. Backtracking resistance (also called *forward secrecy*) means that
    previously generated bits are impossible to recover, whereas prediction resistance
    (*backward secrecy*) means that future bits should be impossible to predict.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要讨论一下 PRNG 如何解决一些高级安全问题。具体来说，PRNG 应该保证 *回溯抵抗* 和 *预测抵抗*。回溯抵抗（也称为 *前向保密性*）意味着无法恢复先前生成的比特，而预测抵抗（*后向保密性*）意味着未来的比特无法预测。
- en: In order to achieve backtracking resistance, the PRNG should ensure that the
    transformations performed when updating the state through the *refresh* and *next*
    operations are irreversible so that if an attacker compromises the system and
    obtains the entropy pool’s value, they can’t determine the previous values of
    the pool or the previously generated bits. To achieve prediction resistance, the
    PRNG should call *refresh* regularly with *R* values that are unknown to an attacker
    and that are difficult to guess, thus preventing an attacker from determining
    future values of the entropy pool, even if the whole pool is compromised. (Even
    if the list of *R* values used were known, you’d need to know the order in which
    *refresh* and *next* calls were made in order to reconstruct the pool.)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现回溯抵抗，PRNG 应确保在通过 *refresh* 和 *next* 操作更新状态时所执行的转换是不可逆的，这样即使攻击者攻破系统并获得熵池的值，也无法确定熵池之前的值或先前生成的比特。为了实现预测抵抗，PRNG
    应定期调用 *refresh*，使用攻击者无法知道且难以猜测的 *R* 值，从而防止攻击者在熵池被完全攻破的情况下预测未来的熵池值。（即使知道了使用的 *R*
    值列表，你仍然需要知道 *refresh* 和 *next* 调用的顺序，才能重建熵池。）
- en: '*The PRNG Fortuna*'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*PRNG Fortuna*'
- en: '*Fortuna* is a PRNG construction used in Windows originally designed in 2003
    by Niels Ferguson and Bruce Schneier. Fortuna superseded *Yarrow*, a 1998 design
    by Kelsey and Schneier now used in the macOS and iOS operating systems. I won’t
    provide the Fortuna specification here or show you how to implement it, but I
    will try to explain how it works. You’ll find a complete description of Fortuna
    in [Chapter 9](ch09.xhtml#ch9) of *Cryptography Engineering* by Ferguson, Schneier,
    and Kohno (Wiley, 2010).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*Fortuna* 是一种 PRNG 构造，最初由 Niels Ferguson 和 Bruce Schneier 于 2003 年设计，用于 Windows。Fortuna
    替代了 *Yarrow*，后者是 Kelsey 和 Schneier 于 1998 年设计的，现在用于 macOS 和 iOS 操作系统。我不会在这里提供
    Fortuna 的规格说明或实施方法，但我会尝试解释其工作原理。你可以在 Ferguson、Schneier 和 Kohno 的《Cryptography
    Engineering》一书的 [第 9 章](ch09.xhtml#ch9) 中找到 Fortuna 的完整描述（Wiley，2010）。'
- en: 'Fortuna’s internal memory includes the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Fortuna 的内部内存包括以下内容：
- en: Thirty-two entropy pools, *P*[1], *P*[2], … , *P*[32], such that *P*[*i*] is
    used every 2^(*i*) reseeds.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三十二个熵池，*P*[1]，*P*[2]，…，*P*[32]，其中 *P*[*i*] 每 2^(*i*) 次重新播种时使用一次。
- en: A key, *K*, and a counter, *C* (both 16 bytes). These form the internal state
    of Fortuna’s DRBG.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个密钥 *K* 和一个计数器 *C*（均为 16 字节）。这两者组成了 Fortuna DRBG 的内部状态。
- en: 'In simplest terms, Fortuna works like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，Fortuna 的工作方式如下：
- en: '*init*() sets *K* and *C* to zero and empties the 32 entropy pools *P*[*i*],
    where *i* = 1 … 32.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*init*() 将 *K* 和 *C* 设置为零，并清空 32 个熵池 *P*[*i*]，其中 *i* = 1 … 32。'
- en: '*refresh*(*R*) appends the data, *R*, to one of the entropy pools. The system
    chooses the RNGs used to produce *R* values, and it should call *refresh* regularly.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*刷新*(*R*)将数据*R*附加到一个熵池中。系统选择用于生成*R*值的RNG，并且应该定期调用*刷新*。'
- en: '*next*(*N*) updates *K* using data from one or more entropy pools, where the
    choice of the entropy pools depends mainly on how many updates of *K* have already
    been done. The *N* bits requested are then produced by encrypting *C* using *K*
    as a key. If encrypting *C* is not enough, Fortuna encrypts *C* + 1, then *C*
    + 2, and so on, to get enough bits.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*下一步*(*N*)使用来自一个或多个熵池的数据更新*K*，熵池的选择主要取决于*K*已经更新的次数。然后，通过使用*K*作为密钥加密*C*来生成请求的*N*比特。如果加密*C*不足够，Fortuna将依次加密*C*
    + 1，*C* + 2，依此类推，直到获得足够的比特。'
- en: Although Fortuna’s operations look fairly simple, implementing them correctly
    is hard. For one thing, you need to get all the details of the algorithm right—namely,
    how entropy pools are chosen, the type of cipher to be used in *next*, how to
    behave when no entropy is received, and so on. Although the specs define most
    of the details, they don’t include a comprehensive test suite to check that an
    implementation is correct, which makes it difficult to ensure that your implementation
    of Fortuna will behave as expected.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Fortuna的操作看起来相当简单，但正确实现它们却很难。首先，你需要把算法的所有细节弄对——即如何选择熵池、*下一步*使用什么类型的加密算法、在没有熵的情况下如何处理等等。虽然规范定义了大部分细节，但它们没有包含全面的测试套件来检查实现是否正确，这使得确保你对Fortuna的实现按预期工作变得困难。
- en: Even if Fortuna is correctly implemented, security failures may occur for reasons
    other than the use of an incorrect algorithm. For example, Fortuna might not notice
    if the RNGs fail to produce enough random bits, and as a result Fortuna will produce
    lower-quality pseudorandom bits, or it may stop delivering pseudorandom bits altogether.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 即使Fortuna正确实现，也可能由于其他原因发生安全失败，而非仅仅是使用了不正确的算法。例如，如果RNG未能生成足够的随机比特，Fortuna可能不会察觉，结果Fortuna会生成质量较低的伪随机比特，或者可能完全停止生成伪随机比特。
- en: Another risk inherent in Fortuna implementations lies in the possibility of
    exposing associated *seed files* to attackers. The data in Fortuna seed files
    is used to feed entropy to Fortuna through *refresh* calls when an RNG is not
    immediately available, such as immediately after a system reboot and before the
    system’s RNGs have recorded any unpredictable events. However, if an identical
    seed file is used twice, then Fortuna will produce the same bit sequence twice.
    Seed files should therefore be erased after being used to ensure that they aren’t
    reused.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Fortuna实现中另一个固有的风险是可能会暴露关联的*种子文件*给攻击者。Fortuna种子文件中的数据用于在RNG不可用时通过*刷新*调用为Fortuna提供熵，例如系统重启后，系统的RNG尚未记录任何不可预测事件时。然而，如果相同的种子文件被使用了两次，那么Fortuna将生成相同的比特序列。因此，种子文件在使用后应被擦除，以确保不被重复使用。
- en: Finally, if two Fortuna instances are in the same state because they are sharing
    a seed file (meaning they are sharing the same data in the entropy pools, including
    the same *C* and *K*), then the *next* operation will return the same bits in
    both instances.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果两个Fortuna实例处于相同的状态，因为它们共享一个种子文件（意味着它们共享相同的数据在熵池中，包括相同的*C*和*K*），那么*下一步*操作将在两个实例中返回相同的比特。
- en: '*Cryptographic vs. Non-Cryptographic PRNGs*'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*加密与非加密PRNGs*'
- en: There are both cryptographic and non-cryptographic PRNGs. Non-crypto PRNGs are
    designed to produce uniform distributions for applications such as scientific
    simulations or video games. However, you should never use non-crypto PRNGs in
    crypto applications, because they’re insecure—they’re only concerned with the
    quality of the bits’ probability distribution and not with their predictability.
    Crypto PRNGs, on the other hand, are unpredictable, because they’re also concerned
    with the strength of the underlying *operations* used to deliver well-distributed
    bits.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 存在加密和非加密的伪随机数生成器（PRNG）。非加密PRNG被设计用来生成均匀分布，适用于科学模拟或视频游戏等应用。然而，绝对不要在加密应用中使用非加密PRNG，因为它们不安全——它们只关注比特的概率分布质量，而不关心其可预测性。另一方面，加密PRNG是不可预测的，因为它们还关注用于生成均匀分布比特的底层*操作*的强度。
- en: Unfortunately, most PRNGs exposed by programming languages, such as libc’s `rand`
    and `drand48`, PHP’s `rand` and `mt_rand`, Python’s `random` module, Ruby’s `Random`
    class, and so on, are non-cryptographic. Defaulting to a non-crypto PRNG is a
    recipe for disaster because it often ends up being used in crypto applications,
    so be sure to use only crypto PRNGs in crypto applications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，大多数编程语言暴露的伪随机数生成器（PRNGs），例如libc的`rand`和`drand48`，PHP的`rand`和`mt_rand`，Python的`random`模块，Ruby的`Random`类等，都是非加密的。默认使用非加密PRNG是一个灾难的开端，因为它通常最终会在加密应用中被使用，所以一定要在加密应用中只使用加密PRNG。
- en: 'A Popular Non-Crypto PRNG: Mersenne Twister'
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一种流行的非加密PRNG：梅森旋转算法
- en: 'The *Mersenne Twister* (MT) algorithm is a non-cryptographic PRNG used (at
    the time of this writing) in PHP, Python, R, Ruby, and many other systems. MT
    will generate uniformly distributed random bits without statistical bias, but
    it’s predictable: given a few bits produced by MT, it’s easy enough to tell which
    bits will follow.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*梅森旋转算法*（MT）是一种非加密的伪随机数生成器（PRNG），目前（撰写本文时）在PHP、Python、R、Ruby和许多其他系统中使用。MT将生成均匀分布的随机位，没有统计偏差，但它是可预测的：给定由MT生成的几个位，足够容易地判断出接下来会产生哪些位。'
- en: 'Let’s look under the hood to see what makes the Mersenne Twister insecure.
    The MT algorithm is much simpler than that of crypto PRNGs: its internal state
    is an array, *S*, consisting of 624 32-bit words. This array is initially set
    to *S*[1], *S*[2], … , *S*[624] and evolves to *S*[2], … , *S*[625], then *S*[3],
    … , *S*[626], and so on, according to this equation:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入看看，是什么使得梅森旋转算法不安全。MT算法比加密伪随机数生成器（crypto PRNGs）的算法要简单得多：其内部状态是一个由624个32位字组成的数组，*S*。这个数组最初设置为
    *S*[1]、*S*[2]、…、*S*[624]，然后根据这个公式演变为 *S*[2]、…、*S*[625]，接着是 *S*[3]、…、*S*[626]，以此类推：
- en: '*S*[*k* + 624] = *S*[*k* + 397] ⊕ **A**((*S[k]* ∧ 0x80000000) ∨ (*S*[*k* +
    1] ∧ 0x7fffffff))'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*S*[*k* + 624] = *S*[*k* + 397] ⊕ **A**((*S[k]* ∧ 0x80000000) ∨ (*S*[*k* +
    1] ∧ 0x7fffffff))'
- en: Here, ⊕ denotes the bitwise XOR (`^` in the C programming language), ∧ denotes
    the bitwise AND (& in C), ∨ denotes the bitwise OR (`|` in C), and **A** is a
    function that transforms some 32-bit word, *x*, to (*x* >> 1), if *x*’s most significant
    bit is 0, or to (*x* >> 1) ⊕ 0x9908b0df otherwise.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，⊕表示按位异或（在C语言中为`^`），∧表示按位与（在C语言中为`&`），∨表示按位或（在C语言中为`|`），**A**是一个函数，将某个32位字
    *x* 转换为 (*x* >> 1)，如果 *x* 的最高有效位为0，或者转换为 (*x* >> 1) ⊕ 0x9908b0df，否则。
- en: Notice in this equation that bits of *S* interact with each other only through
    XORs. The operators ∧ and ∨ never combine two bits of *S* together, but just bits
    of *S* with bits from the constants 0x80000000 and 0x7fffffff. This way, any bit
    from *S*[625] can be expressed as an XOR of bits from *S*[398], *S*[1], and *S*[2],
    and any bit from any future state can be expressed as an XOR combination of bits
    from the initial state *S*[1], … , *S*[624]. (When you express, say, *S*[228 +
    624] = *S*[852] as a function of *S*[625], *S*[228], and *S*[229], you can in
    turn replace *S*[625] by its expression in terms of *S*[398], *S*[1], and *S*[2].)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个公式中，*S*的位仅通过异或运算相互作用。操作符∧和∨从未将*S*的两个位结合在一起，而只是将*S*的位与常量0x80000000和0x7fffffff的位结合在一起。这样，*S*[625]中的任何位都可以表示为*S*[398]、*S*[1]和*S*[2]的位的异或，而任何未来状态中的位都可以表示为初始状态*S*[1]、…、*S*[624]中位的异或组合。（例如，当你将
    *S*[228 + 624] = *S*[852] 表示为 *S*[625]、*S*[228] 和 *S*[229] 的函数时，你可以进一步将 *S*[625]
    替换为它在 *S*[398]、*S*[1] 和 *S*[2] 的表示形式。）
- en: 'Because there are exactly 624 × 32 = 19,968 bits in the initial state (or 624
    32-bit words), any output bit can be expressed as an equation with at most 19,969
    terms (19,968 bits plus one constant bit). That’s just about 2.5 kilobytes of
    data. The converse is also true: bits from the initial state can be expressed
    as an XOR of output bits.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因为初始状态中恰好有624 × 32 = 19,968位（或者624个32位字），任何输出位都可以表示为最多包含19,969项（19,968位加一个常量位）的方程。这大约是2.5千字节的数据。反过来说，初始状态中的位也可以表示为输出位的异或。
- en: Linearity Insecurity
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 线性不安全性
- en: We call an XOR combination of bits a *linear combination*. For example, if *X*,
    *Y*, and *Z* are bits, then the expression *X* ⊕ *Y* ⊕ *Z* is a linear combination,
    whereas (*X* ∧ *Y*) ⊕ *Z* is not because there’s an AND (∧). If you flip a bit
    of *X* in *X* ⊕ *Y* ⊕ *Z*, then the result changes as well, regardless of the
    value of the *Y* and *Z*. In contrast, if you flip a bit of *X* in (*X* ∧ *Y*)
    ⊕ *Z*, the result changes only if *Y*’s bit at the same position is 1\. The upshot
    is that linear combinations are predictable, because you don’t need to know the
    value of the bits in order to predict how a change in their value will affect
    the result.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将位的异或（XOR）组合称为*线性组合*。例如，如果*X*、*Y*和*Z*是位，那么表达式 *X* ⊕ *Y* ⊕ *Z* 就是一个线性组合，而 (*X*
    ∧ *Y*) ⊕ *Z* 不是，因为有一个与运算（∧）。如果你翻转 *X* 中的一个位，在 *X* ⊕ *Y* ⊕ *Z* 中，结果也会改变，无论 *Y*
    和 *Z* 的值如何。相比之下，如果你翻转 (*X* ∧ *Y*) ⊕ *Z* 中 *X* 的一个位，只有当 *Y* 在同一位置的位为1时，结果才会发生变化。关键是，线性组合是可预测的，因为你不需要知道位的值，就能预测它们值的变化如何影响结果。
- en: For comparison, if the MT algorithm were cryptographically strong, its equations
    would be *nonlinear* and would involve not only single bits but also AND-combinations
    (*products*) of bits, such as *S*[1]*S*[15]*S*[182] or *S*[17]*S*[256]*S*[257]*S*[354]*S*[498]*S*[601].
    Although linear combinations of those bits include at most 624 variables, nonlinear
    combinations allow for up to 2^(624) variables. It would be impossible to solve,
    let alone write down the whole of these equations. (Note that 2^(305), a much
    smaller number, is the estimated information capacity of the observable universe.)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 做个对比，如果MT算法是密码学上强的，它的方程将是*非线性的*，不仅涉及单个位，还会涉及位的与运算（*乘积*），例如 *S*[1]*S*[15]*S*[182]
    或 *S*[17]*S*[256]*S*[257]*S*[354]*S*[498]*S*[601]。虽然这些位的线性组合最多包含624个变量，但非线性组合可以允许多达2^(624)个变量。解决这些方程几乎是不可能的，更不用说写出这些方程了。（请注意，2^(305)，这个更小的数字，是可观察宇宙的估计信息容量。）
- en: The key here is that linear transformations lead to short equations (comparable
    in size to the number of variables), which are easy to solve, whereas nonlinear
    transformations give rise to equations of exponential size, which are practically
    unsolvable. The game of cryptographers is thus to design PRNG algorithms that
    emulate such complex nonlinear transformations using only a small number of simple
    operations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是，线性变换会导致短小的方程（其大小与变量的数量相当），这些方程容易求解，而非线性变换则会产生指数大小的方程，几乎无法解决。因此，密码学家的任务是设计出仅使用少量简单操作的PRNG算法，模拟这种复杂的非线性变换。
- en: '**NOTE**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Linearity is just one of many security criteria. Although necessary, nonlinearity
    alone does not make a PRNG cryptographically secure.*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*线性性*只是众多安全标准中的一个。虽然它是必要的，但仅有非线性并不足以使一个伪随机数生成器（PRNG）在密码学上是安全的。'
- en: '*The Uselessness of Statistical Tests*'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*统计测试的无用性*'
- en: Statistical test suites like TestU01, Diehard, or the National Institute of
    Standards and Technology (NIST) test suite are one way to test the quality of
    pseudorandom bits. These tests take a sample of pseudorandom bits produced by
    a PRNG (say, one megabyte worth), compute some statistics on the distribution
    of certain patterns in the bits, and compare the results with the typical results
    obtained for a perfect, uniform distribution. For example, some tests count the
    number of 1 bits versus the number of 0 bits, or the distribution of 8-bit patterns.
    But statistical tests are largely irrelevant to cryptographic security, and it’s
    possible to design a cryptographically weak PRNG that will fool any statistical
    test.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 像TestU01、Diehard或美国国家标准与技术研究院（NIST）测试套件这样的统计测试套件是测试伪随机位质量的一种方式。这些测试会取样由PRNG生成的伪随机位（比如，取一兆字节的数据），计算这些位中某些模式的分布的统计量，并将结果与完美、均匀分布的典型结果进行比较。例如，一些测试会计算1位与0位的数量，或者8位模式的分布。但统计测试在密码学安全性方面基本上是无关的，完全可以设计出一个密码学上弱的PRNG，它能骗过任何统计测试。
- en: 'When you run statistical tests on randomly generated data, you will usually
    see a bunch of statistical indicators as a result. These are typically *p*-values,
    a common statistical indicator. These results aren’t always easy to interpret,
    because they’re rarely as simple as passed or failed. If your first results seem
    abnormal, don’t worry: they may be the result of some accidental deviation, or
    you may be testing too few samples. To ensure that the results you see are normal,
    compare them with those obtained for some reliable sample of identical size; for
    example, one generated with the OpenSSL toolkit using the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Real-World PRNGs
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s turn our attention to how to implement PRNGs in the real world. You’ll
    find crypto PRNGs in the operating systems (OSs) of most platforms, from desktops
    and laptops to embedded systems such as routers and set-top boxes, as well as
    virtual machines, mobile phones, and so on. Most of these PRNGs are software based,
    but some are pure hardware. Those PRNGs are used by applications running on the
    OS, and sometimes other PRNGs running on top of cryptographic libraries or applications.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we’ll look at the most widely deployed PRNGs: the one for Linux, Android,
    and many other Unix-based systems; the one in Windows; and the one in recent Intel
    microprocessors, which is hardware based.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '*Generating Random Bits in Unix-Based Systems*'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The device file */dev/urandom* is the userland interface to the crypto PRNG
    of common *nix systems, and it’s what you will typically use to generate reliable
    random bits. Because it’s a device file, requesting random bits from */dev/urandom*
    is done by reading it as a file. For example, the following command uses */dev/urandom*
    to write 10MB of random bits to a file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Wrong Way to Use /dev/urandom
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You could write a naive and insecure C program like the one shown in [Listing
    2-1](ch02.xhtml#ch2list1) to read random bits, and hope for the best, but that
    would be a bad idea.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 2-1: Insecure use of /dev/urandom*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: This code is insecure; it doesn’t even check the return values of `open()` and
    `read()`, which means your expected random buffer could end up filled with zeroes,
    or left unchanged.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: A Safer Way to Use /dev/urandom
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 2-2](ch02.xhtml#ch2list2), copied from LibreSSL, shows a safer way
    to use */dev/urandom*.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 2-2: Safe use of /dev/urandom*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike [Listing 2-1](ch02.xhtml#ch2list1), [Listing 2-2](ch02.xhtml#ch2list2)
    makes several sanity checks. Compare, for example, the call to `open()` at ❶ and
    the call to `read()` at ❷ with those in [Listing 2-1](ch02.xhtml#ch2list1): you’ll
    notice that the safer code checks the return values of those functions, and upon
    failure closes the file descriptor and returns –1.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Differences Between /dev/urandom and /dev/random on Linux
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Different Unix versions use different PRNGs. The Linux PRNG, defined in *drivers/char/random.c*
    in the Linux kernel, mainly uses the hash function SHA-1 to turn raw entropy bits
    into reliable pseudorandom bits. The PRNG harvests entropy from various sources
    (including the keyboard, mouse, disk, and interrupt timings) and has a primary
    entropy pool of 512 bytes, as well as a non-blocking pool for */dev/urandom* and
    a blocking pool for */dev/random*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: What’s the difference between */dev/urandom* and */dev/random*? The short story
    is that */dev/random* attempts to estimate the amount of entropy and refuses to
    return bits if the level of entropy is too low. Although this may sound like a
    good idea, it’s not. For one thing, entropy estimators are notoriously unreliable
    and can be fooled by attackers (which is one reason why Fortuna ditched Yarrow’s
    entropy estimation). Furthermore, */dev/random* runs out of estimated entropy
    pretty quickly, which can produce a denial-of-service condition, slowing applications
    that are forced to wait for more entropy. The upshot is that in practice, */dev/random*
    is no better than */dev/urandom* and creates more problems than it solves.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Estimating the Entropy of /dev/random
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can observe how */dev/random*’s entropy estimate evolves by reading its
    current value in bits in */proc/sys/kernel/random/entropy_avail* on Linux. For
    example, the shell script shown in [Listing 2-3](ch02.xhtml#ch2list3) first minimizes
    the entropy estimate by reading 4KB from */dev/random*, waits until it reaches
    an estimate of 128 bits, reads 64 bits from */dev/random*, and then shows the
    new estimate. When running the script, notice how user activity accelerates entropy
    recovery (bytes read are printed to stdout encoded in base64).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 2-3: A script showing the evolution of* /dev/urandom’s entropy estimate'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: A sample run of [Listing 2-3](ch02.xhtml#ch2list3) gave the output shown in
    [Listing 2-4](ch02.xhtml#ch2list4). (Guess when I started randomly moving the
    mouse and hitting the keyboard to gather entropy.)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 2-4: A sample execution of the entropy estimate evolution script in
    [Listing 2-3](ch02.xhtml#ch2list3)*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in [Listing 2-4](ch02.xhtml#ch2list4), we have 193 − 64 = 129
    bits of entropy left in the pool, as per */dev/random*’s estimator. Does it make
    sense to consider a PRNG as having *N* less entropy bits just because *N* bits
    were just read from the PRNG? (Spoiler: it does not.)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '*Like* /dev/random, *Linux’s getrandom() system call blocks if it hasn’t gathered
    enough initial entropy. However, unlike* /dev/random, *it won’t attempt to estimate
    the entropy in the system and will never block after its initialization stage.
    And that’s fine. (You can force getrandom() to use* /dev/random *and to block
    by tweaking its flags, but I don’t see why you’d want to do that.)*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '*The CryptGenRandom() Function in Windows*'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In Windows, the legacy userland interface to the system’s PRNG is the `CryptGenRandom()`
    function from the Cryptography application programming interface (API). The `CryptGenRandom()`
    function has been replaced in recent Windows versions with the `BcryptGenRandom()`
    function in the Cryptography API: Next Generation (CNG) API. The Windows PRNG
    takes entropy from the kernel mode driver *cng.sys* (formerly *ksecdd.sys*), whose
    entropy collector is loosely based on Fortuna. As is usually the case in Windows,
    the process is complicated.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-5](ch02.xhtml#ch2list5) shows a typical C++ invocation of `CryptGenRandom()`
    with the required checks.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 2-5: Using the Windows CryptGenRandom() PRNG interface*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Notice in [Listing 2-5](ch02.xhtml#ch2list5) that prior to calling the actual
    PRNG, you need to declare a *cryptographic service provider* (`HCRYPTPROV`) and
    then acquire a *cryptographic context* with `CryptAcquireContext()`, which increases
    the chances of things going wrong. For instance, the final version of the TrueCrypt
    encryption software was found to call `CryptAcquireContext()` in a way that could
    silently fail, leading to suboptimal randomness without notifying the user. Fortunately,
    the newer `BCryptGenRandom()` interface for Windows is much simpler and doesn’t
    require the code to explicitly open a handle (or at least makes it much easier
    to use without a handle).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '*A Hardware-Based PRNG: RDRAND in Intel Microprocessors*'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve discussed only software PRNGs so far, so let’s have a look at a hardware
    one. The *Intel Digital Random Number Generator* is a hardware PRNG introduced
    in 2012 in Intel’s Ivy Bridge microarchitecture, and it’s based on NIST’s SP 800-90
    guidelines with the Advanced Encryption Standard (AES) in CTR_DRBG mode. Intel’s
    PRNG is accessed through the `RDRAND` assembly instruction, which offers an interface
    independent of the operating system and is in principle faster than software PRNGs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Whereas software PRNGs try to collect entropy from unpredictable sources, `RDRAND`
    has a single entropy source that provides a serial stream of entropy data as zeroes
    and ones. In hardware engineering terms, this entropy source is a dual differential
    jamb latch with feedback; essentially, a small hardware circuit that jumps between
    two states (0 or 1) depending on thermal noise fluctuations, at a frequency of
    800 MHz. This kind of thing is usually pretty reliable.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The `RDRAND` assembly instruction takes as an argument a register of 16, 32,
    or 64 bits and then writes a random value. When invoked, `RDRAND` sets the carry
    flag to 1 if the data set in the destination register is a valid random value,
    and to 0 otherwise, which means you should be sure to check the `CF` flag if you
    write assembly code directly. Note that the C intrinsics available in common compilers
    don’t check the `CF` flag but do return its value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '*Intel’s PRNG framework provides an assembly instruction other than* RDRAND*:
    the* RDSEED *assembly instruction returns random bits directly from the entropy
    source, after some conditioning or cryptographic processing. It’s intended to
    be able to seed other PRNGs.*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Intel’s PRNG is only partially documented, but it’s built on known standards,
    and has been audited by the well-regarded company Cryptography Research (see their
    report titled “Analysis of Intel’s Ivy Bridge Digital Random Number Generator”).
    Nonetheless, there have been some concerns about its security, especially following
    Snowden’s revelations about cryptographic backdoors, and PRNGs are indeed the
    perfect target for sabotage. If you’re concerned but still wish to use `RDRAND`
    or `RDSEED`, just mix them with other entropy sources. Doing so will prevent effective
    exploitation of a hypothetical backdoor in Intel’s hardware or in the associated
    microcode in all but the most far-fetched scenarios.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: How Things Can Go Wrong
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To conclude, I’ll present a few examples of randomness failures. There are countless
    examples to choose from, but I’ve chosen four that are simple enough to understand
    and illustrate different problems.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '*Poor Entropy Sources*'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In 1996, the SSL implementation of the Netscape browser was computing 128-bit
    PRNG seeds according to the pseudocode shown in [Listing 2-6](ch02.xhtml#ch2list6),
    copied from Goldberg and Wagner’s page at *[http://www.cs.berkeley.edu/~daw/papers/ddj-netscape.html](http://www.cs.berkeley.edu/~daw/papers/ddj-netscape.html)*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 2-6: Pseudocode of the Netscape browser’s generation of 128-bit PRNG
    seeds*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The problem here is that the PIDs and microseconds are guessable values. Assuming
    that you can guess the value of `seconds`, `microseconds` has only 10⁶ possible
    values and thus an entropy of log(10⁶), or about 20 bits. The process ID (PID)
    and parent process ID (PPID) are 15-bit values, so you’d expect 15 + 15 = 30 additional
    entropy bits. But if you look at how `b` is computed at ❶, you’ll see that the
    overlap of three bits yields an entropy of only about 15 + 12 = 27 bits, for a
    total entropy of only 47 bits, whereas a 128-bit seed should have 128 bits of
    entropy.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '*Insufficient Entropy at Boot Time*'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In 2012, researchers scanned the whole internet and harvested public keys from
    TLS certificates and SSH hosts. They found that a handful of systems had identical
    public keys, and in some cases very similar keys (namely, RSA keys with shared
    prime factors): in short, two numbers, *n* = *pq* and *n′* = *p′q′*, with *p*
    = *p′*, whereas normally all *p*s and *q*s should be different in distinct modulus
    values.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: After further investigation, it turned out that many devices generated their
    public key early, at first boot, before having collected enough entropy, despite
    using an otherwise decent PRNG (typically */dev/urandom*). PRNGs in different
    systems ended up producing identical random bits due to a same base entropy source
    (for example, a hardcoded seed).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, the presence of identical keys is due to key-generation schemes
    like the following, in pseudocode:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If two systems run this code given an identical seed, they’ll produce the same
    *p*, the same *q*, and therefore the same *n*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'The presence of shared primes in different keys is due to key-generation schemes
    where additional entropy is injected during the process, as shown here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If two systems run this code with the same seed, they’ll produce the same *p*,
    but the injection of entropy through `prng.add_entropy()` will ensure distinct
    *q*s.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The problem with shared prime factors is that given *n* = *pq* and *n′* = *pq′*,
    it’s trivial to recover the shared *p* by computing the *greatest common divisor*
    (GCD) of *n* and *n′*. For the details, see the paper “Mining Your Ps and Qs”
    by Heninger, Durumeric, Wustrow, and Halderman, available at *[https://factorable.net/](https://factorable.net/)*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '*Non-cryptographic PRNG*'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Earlier we discussed the difference between crypto and non-crypto PRNGs and
    why the latter should never be used for crypto applications. Alas, many systems
    overlook that detail, so I thought I should give you at least one such example.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The popular MediaWiki application runs on Wikipedia and many other wikis. It
    uses randomness to generate things like security tokens and temporary passwords,
    which of course should be unpredictable. Unfortunately, a now obsolete version
    of MediaWiki used a non-crypto PRNG, the Mersenne Twister, to generate these tokens
    and passwords. Here’s a snippet from the vulnerable MediaWiki source code. Look
    for the function called to get a random bit, and be sure to read the comments.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Did you notice `mt_rand()` in the preceding code? Here, `mt` stands for Mersenne
    Twister, the non-crypto PRNG discussed earlier. In 2012, researchers showed how
    to exploit the predictability of Mersenne Twister to predict future tokens and
    temporary passwords, given a couple of security tokens. MediaWiki was patched
    in order to use a crypto PRNG.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '*Sampling Bug with Strong Randomness*'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next bug shows how even a strong crypto PRNG with sufficient entropy can
    produce a biased distribution. The chat program Cryptocat was designed to offer
    secure communication. It used a function that attempted to create a uniformly
    distributed string of decimal digits—namely, numbers in the range 0 through 9\.
    However, just taking random bytes modulo 10 doesn’t yield a uniform distribution,
    because when taking all numbers between 0 and 255 and reducing them modulo 10,
    you don’t get an equal number of values in 0 to 9.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Cryptocat did the following to address that problem and obtain a uniform distribution:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And that was almost perfect. By taking only the numbers up to a multiple of
    10 and discarding others, you’d expect a uniform distribution of the digits 0
    through 9\. Unfortunately, there was an off-by-one error in the `if` condition.
    I’ll leave the details to you as an exercise. You should find that the values
    generated had an entropy of 45 instead of approximately 53 bits (hint: `<=` should
    have been `<` instead).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ve just scratched the surface of randomness in cryptography in this chapter.
    There is much more to learn about the theory of randomness, including topics such
    as different entropy notions, randomness extractors, and even the power of randomization
    and derandomization in complexity theory. To learn more about PRNGs and their
    security, read the classic 1998 paper “Cryptanalytic Attacks on Pseudorandom Number
    Generators” by Kelsey, Schneier, Wagner, and Hall. Then look at the implementation
    of PRNGs in your favorite applications and try to find their weaknesses. (Search
    online for “random generator bug” to find plenty of examples.)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: We’re not done with randomness, though. We’ll encounter it again and again throughout
    this book, and you’ll discover the many ways it helps to construct secure systems.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
