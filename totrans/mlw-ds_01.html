<html><head></head><body>
<h2 class="h2" id="ch01"><span epub:type="pagebreak" id="page_1"/><strong><span class="big">1</span></strong><br/><strong>BASIC STATIC MALWARE ANALYSIS</strong></h2>
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>
<p class="noindent">In this chapter we look at the basics of static malware analysis. Static analysis is performed by analyzing a program file’s disassembled code, graphical images, printable strings, and other on-disk resources. It refers to reverse engineering without actually running the program. Although static analysis techniques have their shortcomings, they can help us understand a wide variety of malware. Through careful reverse engineering, you’ll be able to better understand the benefits that malware binaries provide attackers after they’ve taken possession of a target, as well as the ways attackers can hide and continue their attacks on an infected machine. As you’ll see, this chapter combines descriptions and examples. Each section introduces a static analysis technique and then illustrates its application in real-world analysis.</p>
<p class="indent"><span epub:type="pagebreak" id="page_2"/>I begin this chapter by describing the Portable Executable (PE) file format used by most Windows programs, and then examine how to use the popular Python library <span class="literal">pefile</span> to dissect a real-world malware binary. I then describe techniques such as imports analysis, graphical image analysis, and strings analysis. In all cases, I show you how to use open source tools to apply the analysis technique to real-world malware. Finally, at the end of the chapter, I introduce ways malware can make life difficult for malware analysts and discuss some ways to mitigate these issues.</p>
<p class="indent">You’ll find the malware sample used in the examples in this chapter in this book’s data under the directory <em>/ch1</em>. To demonstrate the techniques discussed in this chapter, we use <em>ircbot.exe</em>, an Internet Relay Chat (IRC) bot created for experimental use, as an example of the kinds of malware commonly observed in the wild. As such, the program is designed to stay resident on a target computer while connected to an IRC server. After <em>ircbot.exe</em> gets hold of a target, attackers can control the target computer via IRC, allowing them to take actions such as turning on a webcam to capture and surreptitiously extract video feeds of the target’s physical location, taking screenshots of the desktop, extracting files from the target machine, and so on. Throughout this chapter, I demonstrate how static analysis techniques can reveal the capabilities of this malware.</p>
<h3 class="h3" id="lev7"><strong>The Microsoft Windows Portable Executable Format</strong></h3>
<p class="noindent">To perform static malware analysis, you need to understand the Windows PE format, which describes the structure of modern Windows program files such as <em>.exe</em>, <em>.dll</em>, and <em>.sys</em> files and defines the way they store data. PE files contain x86 instructions, data such as images and text, and metadata that a program needs in order to run.</p>
<p class="indent">The PE format was originally designed to do the following:</p>
<p class="hang"><strong>Tell Windows how to load a program into memory</strong> The PE format describes which chunks of a file should be loaded into memory, and where. It also tells you where in the program code Windows should start a program’s execution and which dynamically linked code libraries should be loaded into memory.</p>
<p class="hang"><strong>Supply media (or resources) a running program may use in the course of its execution</strong> These resources can include strings of characters like the ones in GUI dialogs or console output, as well as images or videos.</p>
<p class="hang"><strong>Supply security data such as digital code signatures</strong> Windows uses such security data to ensure that code comes from a trusted source.</p>
<p class="indent">The PE format accomplishes all of this by leveraging the series of constructs shown in <a href="ch01.xhtml#ch01fig1">Figure 1-1</a>.</p>
<div class="image"><span epub:type="pagebreak" id="page_3"/><a id="ch01fig1"/><img alt="image" src="../images/f0003-01.jpg"/></div>
<p class="figcap"><em>Figure 1-1: The PE file format</em></p>
<p class="indent">As the figure shows, the PE format includes a series of headers telling the operating system how to load the program into memory. It also includes a series of sections that contain the actual program data. Windows loads the sections into memory such that their memory offsets correspond to where they appear on disk. Let’s explore this file structure in more detail, starting with the PE header. We’ll skip over a discussion of the DOS header, which is a relic of the 1980s-era Microsoft DOS operating system and only present for compatibility reasons.</p>
<h4 class="h4" id="lev8"><strong><em>The PE Header</em></strong></h4>
<p class="noindent">Shown at the bottom of <a href="ch01.xhtml#ch01fig1">Figure 1-1</a>, above the DOS header <span class="ent">➊</span>, is the PE header <span class="ent">➋</span>, which defines a program’s general attributes such as binary code, images, compressed data, and other program attributes. It also tells us whether a program is designed for 32- or 64-bit systems. The PE header provides basic but useful contextual information to the malware analyst. For example, the header includes a timestamp field that can give away the time at which the malware author compiled the file. This happens when malware authors forget to replace this field with a bogus value, which they often do.</p>
<h4 class="h4" id="lev9"><strong><em>The Optional Header</em></strong></h4>
<p class="noindent">The optional header <span class="ent">➌</span> is actually ubiquitous in today’s PE executable programs, contrary to what its name suggests. It defines the location of the program’s <em>entry point</em> in the PE file, which refers to the first instruction the program runs once loaded. It also defines the size of the data that Windows loads into memory as it loads the PE file, the Windows subsystem, the program targets (such as the Windows GUI or the Windows <span epub:type="pagebreak" id="page_4"/>command line), and other high-level details about the program. The information in this header can prove invaluable to reverse engineers, because a program’s entry point tells them where to begin reverse engineering.</p>
<h4 class="h4" id="lev10"><strong><em>Section Headers</em></strong></h4>
<p class="noindent">Section headers <span class="ent">➍</span> describe the data sections contained within a PE file. A <em>section</em> in a PE file is a chunk of data that either will be mapped into memory when the operating system loads a program or will contain instructions about how the program should be loaded into memory. In other words, a section is a sequence of bytes on disk that will either become a contiguous string of bytes in memory or inform the operating system about some aspect of the loading process.</p>
<p class="indent">Section headers also tell Windows what permissions it should grant to sections, such as whether they should be readable, writable, or executable by the program when it’s executing. For example, the <span class="literal">.text</span> section containing x86 code will typically be marked readable and executable but not writable to prevent program code from accidentally modifying itself in the course of execution.</p>
<p class="indent">A number of sections, such as <span class="literal">.text</span> and <span class="literal">.rsrc</span>, are depicted in <a href="ch01.xhtml#ch01fig1">Figure 1-1</a>. These get mapped into memory when the PE file is executed. Other special sections, such as the <span class="literal">.reloc</span> section, aren’t mapped into memory. We’ll discuss these sections as well. Let’s go over the sections shown in <a href="ch01.xhtml#ch01fig1">Figure 1-1</a>.</p>
<h5 class="h5" id="lev11"><strong>The .text Section</strong></h5>
<p class="noindent">Each PE program contains at least one section of x86 code marked executable in its section header; these sections are almost always named <span class="literal">.text</span> <span class="ent">➎</span>. We’ll disassemble the data in the <span class="literal">.text</span> section when performing program disassembly and reverse engineering in <a href="ch02.xhtml#ch02">Chapter 2</a>.</p>
<h5 class="h5" id="lev12"><strong>The .idata Section</strong></h5>
<p class="noindent">The <span class="literal">.idata</span> section <span class="ent">➏</span>, also called <em>imports</em>, contains the <em>Import Address Table (IAT)</em>, which lists dynamically linked libraries and their functions. The IAT is among the most important PE structures to inspect when initially approaching a PE binary for analysis because it reveals the library calls a program makes, which in turn can betray the malware’s high-level functionality.</p>
<h5 class="h5" id="lev13"><strong>The Data Sections</strong></h5>
<p class="noindent">The data sections in a PE file can include sections like <span class="literal">.rsrc</span>, <span class="literal">.data</span>, and <span class="literal">.rdata</span>, which store items such as mouse cursor images, button skins, audio, and other media used by a program. For example, the <span class="literal">.rsrc</span> section <span class="ent">➐</span> in <a href="ch01.xhtml#ch01fig1">Figure 1-1</a> contains printable character strings that a program uses to render text as strings.</p>
<p class="indent"><span epub:type="pagebreak" id="page_5"/>The information in the <span class="literal">.rsrc</span> (resources) section can be vital to malware analysts because by examining the printable character strings, graphical images, and other assets in a PE file, they can gain vital clues about the file’s functionality. In “<a href="ch01.xhtml#lev16">Examining Malware Images</a>” on <a href="ch01.xhtml#page_7">page 7</a>, you’ll learn how to use the <span class="literal">icoutils</span> toolkit (including <span class="literal">icotool</span> and <span class="literal">wrestool</span>) to extract graphical images from malware binaries’ resources sections. Then, in “<a href="ch01.xhtml#lev17">Examining Malware Strings</a>” on <a href="ch01.xhtml#page_8">page 8</a>, you’ll learn how to extract printable strings from malware resources sections.</p>
<h5 class="h5" id="lev14"><strong>The .reloc Section</strong></h5>
<p class="noindent">A PE binary’s code is not <em>position independent</em>, which means it will not execute correctly if it’s moved from its intended memory location to a new memory location. The <span class="literal">.reloc</span> section <span class="ent">➑</span> gets around this by allowing code to be moved without breaking. It tells the Windows operating system to translate memory addresses in a PE file’s code if the code has been moved so that the code still runs correctly. These translations usually involve adding or subtracting an offset from a memory address.</p>
<p class="indent">Although a PE file’s <span class="literal">.reloc</span> section may well contain information you’ll want to use in your malware analysis, we won’t discuss it further in this book because our focus is on applying machine learning and data analysis to malware, not doing the kind of hardcore reverse engineering that involves looking at relocations.</p>
<h3 class="h3" id="lev15"><strong>Dissecting the PE Format Using pefile</strong></h3>
<p class="noindent">The <span class="literal">pefile</span> Python module, written and maintained by Ero Carerra, has become an industry-standard malware analysis library for dissecting PE files. In this section, I show you how to use <span class="literal">pefile</span> to dissect <em>ircbot.exe</em>. The <em>ircbot.exe</em> file can be found on the virtual machine accompanying this book in the directory <em>~/malware_data_science/ch1/data</em>. <a href="ch01.xhtml#ch01list1">Listing 1-1</a> assumes that <em>ircbot.exe</em> is in your current working directory.</p>
<p class="indent">Enter the following to install the <span class="literal">pefile</span> library so that we can import it within Python:</p>
<p class="programs">$ <span class="codestrong1">pip install pefile</span></p>
<p class="indent">Now, use the commands in <a href="ch01.xhtml#ch01list1">Listing 1-1</a> to start Python, import the <span class="literal">pefile</span> module, and open and parse the PE file <em>ircbot.exe</em> using <span class="literal">pefile</span>.</p>
<p class="programs">$ <span class="codestrong1">python</span><br/>&gt;&gt;&gt; <span class="codestrong1">import pefile</span><br/>&gt;&gt;&gt; <span class="codestrong1">pe = pefile.PE("ircbot.exe")</span></p>
<p class="listing" id="ch01list1"><em>Listing 1-1: Loading the</em> <span class="codeitalic">pefile</span> <em>module and parsing a PE file</em> (ircbot.exe)</p>
<p class="indent"><span epub:type="pagebreak" id="page_6"/>We instantiate <span class="literal">pefile.PE</span>, which is the core class implemented by the PE module. It parses PE files so that we can examine their attributes. By calling the PE constructor, we load and parse the specified PE file, which is <em>ircbot.exe</em> in this example. Now that we’ve loaded and parsed our file, run the code in <a href="ch01.xhtml#ch01list2">Listing 1-2</a> to pull information from <em>ircbot.exe</em>’s PE fields.</p>
<p class="programs"># based on Ero Carrera's example code (pefile library author)<br/>for section in pe.sections:<br/>  print (section.Name, hex(section.VirtualAddress),<br/>    hex(section.Misc_VirtualSize), section.SizeOfRawData )</p>
<p class="listing" id="ch01list2"><em>Listing 1-2: Iterating through the PE file’s sections and printing information about them</em></p>
<p class="indent"><a href="ch01.xhtml#ch01list3">Listing 1-3</a> shows the output.</p>
<p class="programs">('.text\x00\x00\x00', <span class="ent">➊</span>'0x1000', <span class="ent">➋</span>'0x32830', <span class="ent">➌</span>207360)<br/>('.rdata\x00\x00', '0x34000', '0x427a', 17408)<br/>('.data\x00\x00\x00', '0x39000', '0x5cff8', 10752)<br/>('.idata\x00\x00', '0x96000', '0xbb0', 3072)<br/>('.reloc\x00\x00', '0x97000', '0x211d', 8704)</p>
<p class="listing" id="ch01list3"><em>Listing 1-3: Pulling section data from</em> ircbot.exe <em>using Python’s</em> <span class="codeitalic">pefile</span> <em>module</em></p>
<p class="indent">As you can see in <a href="ch01.xhtml#ch01list3">Listing 1-3</a>, we’ve pulled data from five different sections of the PE file: <span class="literal">.text</span>, <span class="literal">.rdata</span>, <span class="literal">.data</span>, <span class="literal">.idata</span>, and <span class="literal">.reloc</span>. The output is given as five tuples, one for each PE section pulled. The first entry on each line identifies the PE section. (You can ignore the series of <span class="literal">\x00</span> null bytes, which are simply C-style null string terminators.) The remaining fields tell us what each section’s memory utilization will be once it’s loaded into memory and where in memory it will be found once loaded.</p>
<p class="indent">For example, <span class="literal">0x1000</span> <span class="ent">➊</span> is the <em>base virtual memory address</em> where these sections will be loaded. Think of this as the section’s base memory address. The <span class="literal">0x32830</span> <span class="ent">➋</span> in the <em>virtual size</em> field specifies the amount of memory required by the section once loaded. The <span class="literal">207360</span> <span class="ent">➌</span> in the third field represents the amount of data the section will take up within that chunk of memory.</p>
<p class="indent">In addition to using <span class="literal">pefile</span> to parse a program’s sections, we can also use it to list the DLLs a binary will load, as well as the function calls it will request within those DLLs. We can do this by dumping a PE file’s IAT. <a href="ch01.xhtml#ch01list4">Listing 1-4</a> shows how to use <span class="literal">pefile</span> to dump the IAT for <em>ircbot.exe</em>.</p>
<p class="programs">$ <span class="codestrong1">python</span><br/>pe = pefile.PE("ircbot.exe")<br/>for entry in pe.DIRECTORY_ENTRY_IMPORT:<br/>    print entry.dll<br/>    for function in entry.imports:<br/>        print '\t',function.name</p>
<p class="listing" id="ch01list4"><em>Listing 1-4: Extracting imports from</em> ircbot.exe</p>
<p class="indent"><a href="ch01.xhtml#ch01list4">Listing 1-4</a> should produce the output shown in <a href="ch01.xhtml#ch01list5">Listing 1-5</a> (truncated for brevity).</p>
<p class="programs"><span epub:type="pagebreak" id="page_7"/>KERNEL32.DLL<br/>      GetLocalTime<br/>      ExitThread<br/>      CloseHandle<br/>    <span class="ent">➊</span> WriteFile<br/>    <span class="ent">➋</span> CreateFileA<br/>      ExitProcess<br/>    <span class="ent">➌</span> CreateProcessA<br/>      GetTickCount<br/>      GetModuleFileNameA<br/><span class="codeitalic1">--snip--</span></p>
<p class="listing" id="ch01list5"><em>Listing 1-5: Contents of the IAT of</em> ircbot.exe<em>, showing library functions used by this malware</em></p>
<p class="indent">As you can see in <a href="ch01.xhtml#ch01list5">Listing 1-5</a>, this output is valuable for malware analysis because it lists a rich array of functions that the malware declares and will reference. For example, the first few lines of the output tell us that the malware will write to files using <span class="literal">WriteFile</span> <span class="ent">➊</span>, open files using the <span class="literal">CreateFileA</span> call <span class="ent">➋</span>, and create new processes using <span class="literal">CreateProcessA</span> <span class="ent">➌</span>. Although this is fairly basic information about the malware, it’s a start in understanding the malware’s behavior in more detail.</p>
<h3 class="h3" id="lev16"><strong>Examining Malware Images</strong></h3>
<p class="noindent">To understand how malware may be designed to game a target, let’s look at the icons contained in its <span class="literal">.rsrc</span> section. For example, malware binaries are often designed to trick users into clicking them by masquerading as Word documents, game installers, PDF files, and so on. You also find images in the malware suggesting programs of interest to the attackers themselves, such as network attack tools and programs run by attackers for the remote control of compromised machines. I have even seen binaries containing desktop icons of jihadists, images of evil-looking cyberpunk cartoon characters, and images of Kalashnikov rifles. For our sample image analysis, let’s consider a malware sample the security company Mandiant identified as having been crafted by a Chinese state-sponsored hacking group. You can find this sample malware in this chapter’s data directory under the name <em>fakepdfmalware.exe</em>. This sample uses an Adobe Acrobat icon to trick users into thinking it is an Adobe Acrobat document, when in fact it’s a malicious PE executable.</p>
<p class="indent">Before we can extract the images from the <em>fakepdfmalware.exe</em> binary using the Linux command line tool <span class="literal">wrestool</span>, we first need to create a directory to hold the images we’ll extract. <a href="ch01.xhtml#ch01list6">Listing 1-6</a> shows how to do all this.</p>
<p class="programs">$ <span class="codestrong1">mkdir images</span><br/>$ <span class="codestrong1">wrestool –x fakepdfmalware.exe –output=images</span><br/>$ <span class="codestrong1">icotool –x –o images images/*.ico</span></p>
<p class="listing" id="ch01list6"><em>Listing 1-6: Shell commands that extract images from a malware sample</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_8"/>We first use <span class="literal">mkdir images</span> to create a directory to hold the extracted images. Next, we use <span class="literal">wrestool</span> to extract image resources (<span class="literal">-x</span>) from <em>fakepdfmalware.exe</em> to <em>/images</em> and then use <span class="literal">icotool</span> to extract (<span class="literal">-x</span>) and convert (<span class="literal">-o</span>) any resources in the Adobe <em>.ico</em> icon format into <em>.png</em> graphics so that we can view them using standard image viewer tools. If you don’t have <span class="literal">wrestool</span> installed on your system, you can download it at <em><a href="http://www.nongnu.org/icoutils/">http://www.nongnu.org/icoutils/</a></em>.</p>
<p class="indent">Once you’ve used <span class="literal">wrestool</span> to convert the images in the target executable to the PNG format, you should be able open them in your favorite image viewer and see the Adobe Acrobat icon at various resolutions. As my example here demonstrates, extracting images and icons from PE files is relatively straightforward and can quickly reveal interesting and useful information about malware binaries. Similarly, we can easily extract printable strings from malware for more information, which we’ll do next.</p>
<h3 class="h3" id="lev17"><strong>Examining Malware Strings</strong></h3>
<p class="noindent"><em>Strings</em> are sequences of printable characters within a program binary. Malware analysts often rely on strings in a malicious sample to get a quick sense of what may be going on inside it. These strings often contain things like HTTP and FTP commands that download web pages and files, IP addresses and hostnames that tell you what addresses the malware connects to, and the like. Sometimes even the language used to write the strings can hint at a malware binary’s country of origin, though this can be faked. You may even find text in a string that explains in leetspeak the purpose of a malicious binary.</p>
<p class="indent">Strings can also reveal more technical information about a binary. For example, you may find information about the compiler used to create it, the programming language the binary was written in, embedded scripts or HTML, and so on. Although malware authors can obfuscate, encrypt, and compress all of these traces, even advanced malware authors often leave at least some traces exposed, making it particularly important to examine <span class="literal">strings</span> dumps when analyzing malware.</p>
<h4 class="h4" id="lev18"><strong><em>Using the strings Program</em></strong></h4>
<p class="noindent">The standard way to view all strings in a file is to use the command line tool <span class="literal">strings</span>, which uses the following syntax:</p>
<p class="programs">$ <span class="codestrong1">strings</span> <span class="codestrongitalic1">filepath</span> <span class="codestrong1">| less</span></p>
<p class="indent">This command prints all strings in a file to the terminal, line by line. Adding <span class="literal">| less</span> at the end prevents the strings from just scrolling across the terminal. By default, the <span class="literal">strings</span> command finds all printable strings with a minimum length of 4 bytes, but you can set a different minimum length and change various other parameters, as listed in the commands manual page. I recommend simply using the default minimum string length of 4, <span epub:type="pagebreak" id="page_9"/>but you can change the minimum string length using the <span class="literal">–n</span> option. For example, <span class="literal">strings –n 10</span> <span class="codeitalic">filepath</span> would extract only strings with a minimum length of 10 bytes.</p>
<h4 class="h4" id="lev19"><strong><em>Analyzing Your strings Dump</em></strong></h4>
<p class="noindent">Now that we dumped a malware program’s printable strings, the challenge is to understand what the strings mean. For example, let’s say we dump the strings to the <em>ircbotstring.txt</em> file for <em>ircbot.exe</em>, which we explored earlier in this chapter using the <span class="literal">pefile</span> library, like this:</p>
<p class="programs">$ <span class="codestrong1">strings ircbot.exe &gt; ircbotstring.txt</span></p>
<p class="indent">The contents of <em>ircbotstring.txt</em> contain thousands of lines of text, but some of these lines should stick out. For example, <a href="ch01.xhtml#ch01list7">Listing 1-7</a> shows a bunch of lines extracted from the string dump that begin with the word <span class="literal">DOWNLOAD</span>.</p>
<p class="programs">[DOWNLOAD]: Bad URL, or DNS Error: %s.<br/>[DOWNLOAD]: Update failed: Error executing file: %s.<br/>[DOWNLOAD]: Downloaded %.1fKB to %s @ %.1fKB/sec. Updating.<br/>[DOWNLOAD]: Opened: %s.<br/><span class="codeitalic1">--snip--</span><br/>[DOWNLOAD]: Downloaded %.1f KB to %s @ %.1f KB/sec.<br/>[DOWNLOAD]: CRC Failed (%d != %d).<br/>[DOWNLOAD]: Filesize is incorrect: (%d != %d).<br/>[DOWNLOAD]: Update: %s (%dKB transferred).<br/>[DOWNLOAD]: File download: %s (%dKB transferred).<br/>[DOWNLOAD]: Couldn't open file: %s.</p>
<p class="listing" id="ch01list7"><em>Listing 1-7: The</em> <span class="codeitalic">strings</span> <em>output showing evidence that the malware can download files specified by the attacker onto a target machine</em></p>
<p class="indent">These lines indicate that <em>ircbot.exe</em> will attempt to download files specified by an attacker onto the target machine.</p>
<p class="indent">Let’s try analyzing another one. The string dump shown in <a href="ch01.xhtml#ch01list8">Listing 1-8</a> indicates that <em>ircbot.exe</em> can act as a web server that listens on the target machine for connections from the attacker.</p>
<p class="programs"><span class="ent">➊</span> GET<br/><span class="ent">➋</span> HTTP/1.0 200 OK<br/>   Server: myBot<br/>   Cache-Control: no-cache,no-store,max-age=0<br/>   pragma: no-cache<br/>   Content-Type: %s<br/>   Content-Length: %i<br/>   Accept-Ranges: bytes<br/>   Date: %s %s GMT<br/>   Last-Modified: %s %s GMT<br/>   Expires: %s %s GMT<br/>   Connection: close<br/>   HTTP/1.0 200 OK<br/><span class="ent">➌</span> Server: myBot<br/>   <span epub:type="pagebreak" id="page_10"/>Cache-Control: no-cache,no-store,max-age=0<br/>   pragma: no-cache<br/>   Content-Type: %s<br/>   Accept-Ranges: bytes<br/>   Date: %s %s GMT<br/>   Last-Modified: %s %s GMT<br/>   Expires: %s %s GMT<br/>   Connection: close<br/>   HH:mm:ss<br/>   ddd, dd MMM yyyy<br/>   application/octet-stream<br/>   text/html</p>
<p class="listing" id="ch01list8"><em>Listing 1-8: The</em> <span class="codeitalic">strings</span> <em>output showing that the malware has an HTTP server to which the attacker can connect</em></p>
<p class="indent"><a href="ch01.xhtml#ch01list8">Listing 1-8</a> shows a wide variety of HTTP boilerplates used by <em>ircbot.exe</em> to implement an HTTP server. It’s likely that this HTTP server allows the attacker to connect to a target machine via HTTP to issue commands, such as the command to take a screenshot of the victim’s desktop and send it back to the attacker. We see evidence of HTTP functionality throughout the listing. For example, the <span class="literal">GET</span> method <span class="ent">➊</span> requests data from an internet resource. The line <span class="literal">HTTP/1.0 200 OK</span> <span class="ent">➋</span> is an HTTP string that returns the status code <span class="literal">200</span>, indicating that all went well with an HTTP network transaction, and <span class="literal">Server: myBot</span> <span class="ent">➌</span> indicates that the name of the HTTP server is <em>myBot</em>, a giveaway that <em>ircbot.exe</em> has a built-in HTTP server.</p>
<p class="indent">All of this information is useful in understanding and stopping a particular malware sample or malicious campaign. For example, knowing that a malware sample has an HTTP server that outputs certain strings when you connect to it allows you to scan your network to identify infected hosts.</p>
<h3 class="h3" id="lev20"><strong>Summary</strong></h3>
<p class="noindent">In this chapter, you got a high-level overview of static malware analysis, which involves inspecting a malware program without actually running it. You learned about the PE file format that defines Windows <em>.exe</em> and <em>.dll</em> files, and you learned how to use the Python library <span class="literal">pefile</span> to dissect a real-world malware <em>ircbot.exe</em> binary. You also used static analysis techniques such as image analysis and strings analysis to extract more information from malware samples. <a href="ch02.xhtml#ch02">Chapter 2</a> continues our discussion of static malware analysis with a focus on analyzing the assembly code that can be recovered from malware.</p>
</body></html>