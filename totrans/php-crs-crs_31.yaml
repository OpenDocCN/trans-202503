- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 26 ABSTRACT METHODS, INTERFACES, AND TRAITS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll move beyond the standard mechanism of inheritance from
    a superclass to a subclass and explore other strategies for sharing methods among
    classes. You’ll be introduced to abstract methods, interfaces, and traits.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you’ll see, abstract methods and interfaces allow you to share just the
    signatures of methods across multiple classes, without specifying the details
    of how the methods should be implemented. In effect, these mechanisms act as *contracts*:
    to use abstract methods or interfaces, a class must agree to provide suitable
    implementations of those methods. Meanwhile, traits are a way to bypass inheritance
    and share fully implemented methods among classes in separate hierarchies. Interfaces,
    too, transcend class hierarchies, while abstract methods are still passed along
    between superclasses and subclasses through inheritance.'
  prefs: []
  type: TYPE_NORMAL
- en: Together, abstract methods, interfaces, and traits can facilitate updating an
    application without breaking any code, since they provide assurances that certain
    methods will be present on a class for use by other parts of the application.
    Abstract methods and interfaces, in particular, promote class interchangeability.
    By enforcing method signatures while remaining agnostic about the implementations,
    they make it easy to substitute in classes that realize those methods differently
    as new project requirements arise (for example, having new types of files to write
    to, new database management systems to communicate with, or new destinations for
    logging events and exceptions). Traits, on the other hand, are helpful for avoiding
    redundancy and promoting code reusability, since they save you from having to
    declare the same method on several unrelated classes. In this sense, they’re somewhat
    similar to utility classes that are designed to make certain common operations
    available to all the classes in an application.
  prefs: []
  type: TYPE_NORMAL
- en: Of the topics covered in this chapter, interfaces especially are quite common
    in medium-to-large PHP projects. Even if you don’t write many interfaces yourself,
    you’ll probably use them, since they’re a feature of many third-party libraries
    for core web application components, including database communication and working
    with HTTP requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: From Inheritance to Interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll progressively develop a sample network of classes to
    illustrate the features and merits of abstract methods and interfaces. We’ll start
    by reviewing the conventional process of a subclass inheriting methods from a
    superclass, then transition to using abstract methods and finally interfaces to
    standardize the features of unrelated classes. For simplicity, this will be a
    toy example. Once we’ve established the basics, however, we’ll turn to a more
    realistic and practical application for interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting a Fully Implemented Method from a Superclass
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we discussed in [Chapter 19](chapter19.xhtml), inheritance makes it possible
    to pass down the definition of a superclass method to a related group of subclasses.
    If some of the subclasses need to implement the method differently, they can always
    override it with their own implementation, while other subclasses will simply
    inherit the default implementation from the superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the superclass may be abstract, meaning it will never be instantiated.
    In this case, one or more non-abstract subclasses must extend the abstract superclass
    in order for objects to be created and the superclass’s methods to be executed.
    As an example, [Figure 26-1](#fig26-1) shows a simple class hierarchy of various
    animals, all of which will be able to return a string describing the type of sound
    they make.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure26-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 26-1: A class hierarchy with an abstract superclass passing down a getSound()
    method'
  prefs: []
  type: TYPE_NORMAL
- en: At the top of this class hierarchy is the abstract Animal superclass. Its sound
    property is declared with a default value of 'meow' and protected (#) visibility,
    meaning the property’s value can be accessed (and overridden) by a subclass if
    required. Its numLegs property is public (+) and has a default value of 4. In
    addition, a getSound() method returns the string stored in sound.
  prefs: []
  type: TYPE_NORMAL
- en: At the next layer of the hierarchy, the Cat subclass extends Animal and so inherits
    the sound and numLegs properties and the getSound() method. This means Cat objects
    will produce a 'meow' sound. The Dog subclass also extends Animal but declares
    its own sound property of 'bark', overriding the value inherited from the superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s imagine that opinions vary about the sound a bird makes; sometimes
    'tweet tweet' is more popular, and sometimes 'chirp chirp'. To account for this,
    the Bird subclass declares a custom implementation of getSound(), overriding the
    inherited method from the superclass. At runtime, each Bird object’s getSound()
    method will access a (fictional) API at *[www.mostPopularBirdSound.com](http://www.mostPopularBirdSound.com)*
    to determine the most popular bird sound string, ignoring the value of its inherited
    sound property. In addition, since birds have only two legs, the Bird class overrides
    the inherited number of legs.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 26-1 shows the code for the Animal class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-1: The Animal class'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the Animal class to be abstract so that it can never be instantiated
    and assign it sound and numLegs properties. We also provide an implementation
    of the getSound() method ❶, which returns the value of the sound property. For
    any instance of a subclass inheriting this method, the value of the object’s sound
    property will be determined at runtime when the getSound() method is invoked.
    For example, a Cat object will return 'meow', a Dog object will return 'bark',
    and a Bird object will override this method and instead return whatever string
    is retrieved from the *[www.mostPopularBirdSound.com](http://www.mostPopularBirdSound.com)*
    API.
  prefs: []
  type: TYPE_NORMAL
- en: The takeaway from this example is that a superclass (whether abstract or not)
    provides a way to offer a default method implementation that gets inherited by
    the subclasses in its class hierarchy. When required, however, this implementation
    can be overridden by individual subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting an Abstract Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An *abstract method* is a method on a superclass that doesn’t have an implementation.
    Instead, all that’s declared is the method’s signature: its name, its parameters,
    and its return type. Any subclasses that inherit from the superclass must provide
    their own implementation of the abstract method. The exact details of how the
    method is implemented are left up to each subclass, as long as the implementation
    matches the method signature specified on the superclass.'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract methods can come into play when very different classes should exhibit
    the same behavior. For example, cars, like animals, make sound, and they should
    likely have a getSound() method that returns a string, just like our Animal class
    does. However, cars are otherwise very different from animals, and even the way
    they make sounds is pretty different; cars might output a sound such as 'putt-putt-putt',
    'purr', or 'vroom-vroom', depending on their engine size, fuel type, and so on.
    As such, the getSound() method for cars will be different from that for animals,
    and yet they’ll still have the same signature, since in both cases the method
    is ultimately returning a string.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s address this scenario by introducing a new abstract SoundMaker superclass
    that declares an abstract getSound() method. Any subclasses inheriting from SoundMaker,
    such as Animal and Car, will have to provide an appropriate getSound() implementation.
    [Figure 26-2](#fig26-2) shows the new, modified class hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure26-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 26-2: Sharing an abstract getSound() method through the SoundMaker superclass'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 26-2 shows the declaration of the new SoundMaker class. Notice that
    the class provides no implementation for the getSound() method, just its signature.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-2: The SoundMaker class with an abstract method'
  prefs: []
  type: TYPE_NORMAL
- en: We designate the getSound() method abstract and declare just its signature.
    The method declaration is considered a statement, since no implementation is provided,
    and so it must end with a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: 'The non-abstract Car subclass must now provide an implementation for the getSound()
    method in order to successfully inherit from SoundMaker. If it didn’t, we’d get
    a fatal error like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We’ve already provided a getSound() implementation on the Animal class, so it
    can successfully inherit from SoundMaker. The Cat and Dog subclasses inherit the
    method implementation from Animal, so they also meet the requirements of the SoundMaker
    class. The Bird class can still override the getSound() implementation inherited
    from Animal with its own implementation.
  prefs: []
  type: TYPE_NORMAL
- en: To see the benefit of making getSound() an abstract method, say our application
    has a function that needs to know the sound an object makes. That function can
    require a SoundMaker object (or one of its subclasses) as an argument, and know
    that whatever subclass of SoundMaker is received will have a getSound() method
    that can be invoked to return a string. It doesn’t matter whether it’s an Animal
    object or a Car object; the method is guaranteed to be there. In this way, abstract
    methods maximize class interchangeability while still allowing for different classes
    to have quite distinct implementations of a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a class declares one or more abstract methods, the class itself must also
    be abstract. This is because you can’t instantiate a class with an abstract method,
    since no implementation of the method is provided. The opposite isn’t necessarily
    true, however: a class may be declared abstract but not contain any abstract methods.
    For example, you might have an abstract class consisting of fully implemented,
    static members.'
  prefs: []
  type: TYPE_NORMAL
- en: Requiring Method Implementations with Interfaces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An *interface* is a way to declare the signatures of one or more methods that
    a class should have. Classes then *implement* the interface by declaring methods
    with those specified signatures. Interfaces are similar to abstract methods in
    that both are ways of ensuring that one or more classes should have certain methods,
    without specifying exactly how those methods should be implemented. Both promote
    class interchangeability by guaranteeing the consistency of those methods’ signatures.
    The difference is that interfaces *aren’t* classes, and therefore are independent
    of any class hierarchy scheme, whereas abstract methods are declared as part of
    a class. As such, any classes that implement the abstract methods must fall within
    the hierarchy of the class that declares them.
  prefs: []
  type: TYPE_NORMAL
- en: Being independent of class hierarchies, interfaces are useful when you want
    to share a behavior among very different classes that wouldn’t belong in the same
    class hierarchy, or when you want to share multiple behaviors, in various combinations,
    among several very different classes.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with the example from the previous sections, pipe organs also make
    sounds, like cars and animals. Both pipe organs and cars require regular maintenance
    as well, whereas animals don’t. Let’s consider that subclasses of a Maintainable
    class must implement a nextService() method that returns some kind of Date object.
    The way a service date is calculated will be implemented differently for Car objects
    and PipeOrgan objects. Car service dates may be based on the type of engine and
    number of miles driven, while PipeOrgan objects may have service dates calculated
    based on, say, the length and material of the pipes.
  prefs: []
  type: TYPE_NORMAL
- en: We might be tempted to create a new abstract Maintainable class that declares
    an abstract nextService() method. The Car and PipeOrgan classes would inherit
    from Maintainable and provide their own nextService() implementations, while also
    inheriting from the SoundMaker class, along with Animal. This would be an example
    of *multiple inheritance*, the capability of a class to inherit from two or more
    superclasses at the same time. The class diagram in [Figure 26-3](#fig26-3) illustrates
    this scheme.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure26-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 26-3: A class hierarchy with multiple inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: 'This arrangement may seem appealing: the Car and PipeOrgan classes inherit
    from two superclasses, thereby receiving the requirement for the getSound() method
    from the abstract SoundMaker class as before while also receiving the requirement
    for the nextService() method from the abstract Maintainable class. However, although
    some computer languages allow multiple inheritance, PHP does not, to avoid problems
    of ambiguity. If a class inherits from more than one superclass, and two or more
    of those superclasses declare a constant or method of the same name, how does
    the inheriting class know which to use?'
  prefs: []
  type: TYPE_NORMAL
- en: We could try to get around the prohibition against multiple inheritance by placing
    the SoundMaker and Maintainable superclasses at different levels of the same class
    hierarchy. That is, we could make Maintainable a subclass of SoundMaker, and Car
    and PipeOrgan subclasses of Maintainable, as in [Figure 26-4](#fig26-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure26-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 26-4: A class hierarchy where Maintainable is a subclass of SoundMaker'
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, this seems to work. Objects of any class in the hierarchy must
    have a getSound() method, and Car and PipeOrgan each must implement a nextService()
    method as well. However, what if we identify further behaviors that some of these
    classes should have but not others? Those behaviors may not make sense anywhere
    in the proposed hierarchy. Also, what if we want to add a Maintainable subclass
    that doesn’t make sound? Chimneys, for example, require regular maintenance but
    are silent.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, we’ve created a fragile and artificial class hierarchy. Completely
    unrelated classes such as birds, cars, and chimneys may be forced into being subclasses
    of classes they have nothing to do with, all to enforce the inheritance of the
    getSound() and nextService() method signatures. The solution is to use an interface
    to define a set of required method signatures that can be implemented by classes
    that aren’t all in the same hierarchy. This dodges the illegal solution of multiple
    inheritance while also skirting the requirement for a single class hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate, let’s first define SoundMaker as an interface rather than a
    class. Then we can stipulate that the classes in our example should all implement
    the SoundMaker interface. This is illustrated in [Figure 26-5](#fig26-5).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the lower left of the diagram, the SoundMaker interface declares the signature
    of the getSound() method. With SoundMaker reframed as an interface rather than
    a class, we’re free to break our classes into separate, more meaningful, and robust
    hierarchies: we have the abstract Animal class and its subclasses, and the abstract
    Vehicle class with subclasses Car and Helicopter. The PipeOrgan class, which has
    little to do with animals or vehicles, is off by itself. The classes that implement
    the SoundMaker interface are annotated with the interface name and *lollipop notation*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure26-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 26-5: The SoundMaker interface, implemented by multiple classes'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when an abstract class such as Animal or Vehicle implements an interface,
    it doesn’t have to provide full implementations of all (or any) of the methods
    declared on the interface. The implementation can be left to the non-abstract
    subclasses instead. Here Animal provides a getSound() implementation (although
    it’s overridden by the Bird subclass), while Vehicle doesn’t. In the latter case,
    the Car and Helicopter subclasses must each provide their own custom getSound()
    implementation in order to fulfill the promise the Vehicle class is making by
    declaring that it will implement the SoundMaker interface.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring an Interface
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The code declaring an interface goes in its own.*php* file with the same name
    as the interface, much like a class declaration. For example, the SoundMaker interface
    should be declared in a *SoundMaker.php* file. [Listing 26-3](#lis26-3) shows
    its code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-3: The SoundMaker interface'
  prefs: []
  type: TYPE_NORMAL
- en: We declare SoundMaker by using the interface keyword. Its body contains just
    the signature for the getSound() method, without an actual implementation. Just
    as when declaring an abstract method, the getSound() signature must end with a
    semicolon to indicate the end of the statement. Notice that we give getSound()
    public visibility. Including the public modifier explicitly is considered best
    practice, though it isn’t strictly necessary since all methods declared on an
    interface are automatically considered public so that other parts of the system
    can harness the behaviors of any interface-implementing classes.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In addition to declaring method signatures, interfaces can also declare constants.
    A class that implements the interface will inherit the interface constant, although
    as of PHP 8.1, the class can override the interface constant if needed.*'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an Interface
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now let’s look at how a class can implement an interface. As an example, [Listing
    26-4](#lis26-4) shows the code for the PipeOrgan class, which implements the SoundMaker
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-4: Implementing the SoundMaker interface with the PipeOrgan class'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare that this class implements the SoundMaker interface by using the
    implements keyword. Because the PipeOrgan class implements SoundMaker, the class
    is obligated to provide an implementation for the getSound() method: in this case,
    it returns the string ''dum, dum, dum-dum''. The method matches the signature
    declared by the SoundMaker interface. We would similarly declare getSound() methods
    on the Animal and Vehicle classes. The details of each implementation don’t matter,
    as long as the method is called getSound() and it returns a string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a (non-abstract) class doesn’t include a definition for a method required
    by an interface it’s implementing, you’d get a fatal error. For example, if the
    code for the PipeOrgan class didn’t declare a getSound() method, you’d see the
    following when trying to create an object of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this is exactly the same fatal error as when a subclass fails to
    implement an abstract method declared in its superclass. The PHP engine processes
    the method signatures of an interface as if they were abstract methods; they must
    be realized in the class hierarchy implementing the interface before any object
    can be created.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Multiple Interfaces with One Class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A powerful feature of interfaces is that a single class may implement more than
    one of them. When a class implements an interface, it’s promising to provide a
    set of public methods with the signatures declared in that interface, and there’s
    no reason a class can’t do this for multiple interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our example, the PipeOrgan class can implement a Maintainable interface,
    promising to declare an implementation of nextService(), in addition to implementing
    the SoundMaker interface by declaring a getSound() method. Likewise, if all vehicles
    require maintenance and make sounds, the Vehicle class can implement both the
    Maintainable and SoundMaker interfaces too. [Figure 26-6](#fig26-6) shows how
    these classes can implement multiple interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure26-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 26-6: Classes implementing multiple interfaces'
  prefs: []
  type: TYPE_NORMAL
- en: The figure shows the Maintainable interface alongside SoundMaker, and the PipeOrgan
    and Vehicle classes now have two “lollipops,” indicating that they implement both
    interfaces. This arrangement of classes and interfaces is much neater conceptually
    than the artificial class hierarchy shown in [Figure 26-4](#fig26-4) or the multiple
    inheritance scheme shown in [Figure 26-3](#fig26-3).
  prefs: []
  type: TYPE_NORMAL
- en: To see how to declare that a class implements multiple interfaces, refer to
    [Listing 26-5](#lis26-5), which shows the updated code for the PipeOrgan class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-5: Implementing multiple interfaces with the PipeOrgan class'
  prefs: []
  type: TYPE_NORMAL
- en: When a class implements multiple interfaces, you need to use the implements
    keyword only once, followed by the interface names, separated by commas, as in
    implements SoundMaker, Maintainable here. Beyond this, implementing multiple interfaces
    is as simple as providing definitions for all requisite methods. In this case,
    we’ve added the nextService() method, which returns a DateTime object as the Maintainable
    interface requires (we’ll discuss handling dates in [Chapter 31](chapter31.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: I mentioned earlier that an argument against multiple inheritance is the ambiguity
    of a class attempting to inherit the same member from multiple superclasses. This
    isn’t a problem for a class implementing multiple interfaces. Whether one, two,
    or any number of interfaces declare identical method signatures, all those interface
    contracts can be met by a single method of that signature implemented in a class.
    For example, if for some reason the Maintainable interface declared both a nextService()
    and a getSound() method, the code would still work fine provided the PipeOrgan
    class declares implementations for both methods. As long as all methods coming
    from interfaces are defined in the classes that implement them, no ambiguity exists
    and the PHP engine will work consistently, correctly, and error-free.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Interfaces and Abstract Classes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At first glance, it may seem that interfaces are the same as abstract classes,
    as neither can be used to instantiate objects. However, while the concepts are
    related, key differences exist, and each is appropriate for different situations.
    Above all, an abstract class is a class, while an interface is not; it’s a promise,
    or contract, of method signatures that a class must implement. Another key difference
    is that a class can inherit from only one abstract class, whereas a class can
    implement multiple interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces can’t declare or work with instance-level members, so interfaces
    can’t have instance properties or implement methods that work with instance members.
    Indeed, interfaces can’t implement methods at all; they only specify requirements
    for instance methods. An abstract class, meanwhile, can be a fully implemented
    class, or it can be a partially completed class including instance variables,
    a constructor, and a combination of implemented instance methods and unimplemented
    abstract methods. In the latter case, a class extending an abstract class has
    to complete the implementation only by fleshing out the inherited abstract methods.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces and abstract classes also differ in terms of method visibility. Methods
    declared on interfaces must be public, whereas abstract classes have the option
    to declare protected methods that are available only for internal use by objects
    within the class hierarchy. Also, while declaring the signature of a constructor
    method on an interface is technically possible, it’s highly discouraged; but it’s
    perfectly fine for an abstract class to have a constructor. Finally, it should
    be noted that an interface can extend another interface, much like a subclass
    extending a superclass. Unlike with class inheritance, however, an interface can
    extend multiple interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Real-World Applications of Interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our SoundMaker and Maintainable scenario may have been a trivial example, but
    interfaces have significant real-world applications as well. They’re particularly
    useful for standardizing the method signatures of classes whose behavior may change
    as a web application evolves. Declaring the method signatures as an interface
    ensures that the application will still work; even if the details of the method
    implementations change, the way to call the methods won’t, so the rest of the
    application code will be unaffected.
  prefs: []
  type: TYPE_NORMAL
- en: We already used a practical, real-world interface in [Chapter 24](chapter24.xhtml)
    when we discussed logging. The PSR-3 standard specifies a Logger interface, outlining
    several methods that any classes implementing the interface must provide, such
    as log(), error(), and so on. You can work with any class that implements this
    interface and feel confident that these methods will be present. In [Chapter 24](chapter24.xhtml),
    for example, we used the Monolog library’s Logger class, which implements the
    Logger interface, but classes from other third-party libraries implement it too.
    Any of these classes would work, and you could even switch between Logger implementations
    without having to change the code that uses the logging object provided.
  prefs: []
  type: TYPE_NORMAL
- en: Another functionality that interfaces can help with is the ability to temporarily
    cache (store) data, such as when processing form submissions or HTTP requests
    in a web application. Caching the data helps avoid having to pass lots of arguments
    between controller objects and methods; you can simply store the data to the cache
    in one part of the code and then retrieve it from the cache in another part.
  prefs: []
  type: TYPE_NORMAL
- en: Caching has many approaches, such as using browser sessions, a database, JSON
    or XML files, the PHP Extension Community Library (PECL) language extension, or
    perhaps an API to connect to another service. If you declare an interface for
    common caching operations, you can write code that will be compatible with any
    interface-compliant caching system. Then you can easily switch caching systems
    as the project requirements change. For example, you might use one caching system
    when developing a project and a different caching system for the live production
    website.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore the approaches to caching in this section and illustrate how to
    standardize them through a caching interface. We’ll test everything through a
    web application designed to cache the ID of any incoming HTTP requests and display
    that ID on an About page.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*PHP already has the PSR-6 and PSR-16 standards recommendations for caching
    interfaces, but they’re too involved for our purposes. We’ll create our own simpler
    approach to caching to explore the benefits of interfaces through a more straightforward
    example.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Caching Approach 1: Using an Array'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, let’s implement a cache as a class called CacheStatic that uses a static
    (class-level) array for storing and retrieving values under string keys. We might
    use this simple approach to get the cache working quickly during the early stages
    of development. Besides getting and setting values, we’ll want the class to provide
    a has() method that returns a Boolean indicating whether a value is currently
    stored for a given key.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project and give it the usual *composer.json* file declaring *src*
    as the location for classes in the Mattsmithdev namespace. Generate an autoloader
    with Composer, and create the usual *public/index.php* script that reads in and
    executes the autoloader, creates an Application object, and invokes its run()
    method. Once that’s written, you’re ready to declare the CacheStatic class in
    *src/CacheStatic.php*, as shown in [Listing 26-6](#lis26-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-6: The CacheStatic class'
  prefs: []
  type: TYPE_NORMAL
- en: We initialize the private static dataItems property as an empty array ❶. This
    will be our cache. Then we declare the set() static method, which takes in two
    string arguments, a key and a value, for storage in the cache ❷. We next declare
    the get() static method, which takes in a string key and returns the value in
    the cache array stored for that key ❸. The method includes a test that returns
    NULL if no value exists for the given key. Finally, we declare the static has()
    method ❹, which returns true or false to indicate whether a value is cached for
    the given key.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll declare the Application class. Its run() method will cache the ID
    from the HTTP request, then instantiate a MainController object (we’ll declare
    this class shortly) to respond to the request. Create the file *src/Application.php*
    with the code in [Listing 26-7](#lis26-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-7: The Application class'
  prefs: []
  type: TYPE_NORMAL
- en: After retrieving the URL-encoded action variable as usual, we attempt to retrieve
    another URL-encoded variable called id and store its value in the $id variable
    ❶. If this query-string variable turns out to be empty, we set $id to '(no id
    provided)' instead. Then we use the CacheStatic class’s set() static method to
    store the string in the $id variable in the cache with a key of 'id' ❷. We can
    now retrieve the stored string with the CacheStatic public static method get('id')
    if needed. The run() method concludes with a typical switch statement that invokes
    either the homepage() or aboutUs() method of the MainController object, depending
    on the value of the action variable ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll declare the MainController class. Create *src/MainController.php*
    as shown in [Listing 26-8](#lis26-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-8: The MainController class'
  prefs: []
  type: TYPE_NORMAL
- en: The homepage() method simply outputs the Home page template. In the aboutUs()
    method, we use the CacheStatic class’s get() method to retrieve the ID from the
    cache array, storing the result in the $id variable ❶. Then we read in and execute
    the About page template, which will have access to $id.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 26-9 shows the content of the Home page template. Enter this code into
    *templates/homepage.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-9: The homepage.php template'
  prefs: []
  type: TYPE_NORMAL
- en: This basic HTML Home page template reuses some code by outputting the navigation
    bar from the partial template file *templates/_nav.php* ❶. [Listing 26-10](#lis26-10)
    shows the content of that partial template.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-10: The _nav.php partial template'
  prefs: []
  type: TYPE_NORMAL
- en: The navigation bar starts with two simple links, with the */* URL for the home
    page and */?action=about* for the About page. We also provide an extra, more complex
    link to the About page ❶, using PHP’s rand() function to pick an integer from
    1 to 99 and pass it as the value of the id query-string variable. This value will
    be cached and then displayed in the content of the About page to confirm that
    the cache is working.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 26-11 shows the About page template in *templates/aboutUs.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-11: The aboutUs.php template'
  prefs: []
  type: TYPE_NORMAL
- en: As for the home page, we draw on the partial *_nav.php* template to simplify
    the file at hand. Then we incorporate the value of the $id variable into the body
    of the page ❶. [Figure 26-7](#fig26-7) shows the resulting web page.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure26-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 26-7: The About page, including the cached ID value'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the value of the URL-encoded id variable has been printed to the
    page. This indicates that the ID was successfully cached by the run() method in
    the Application class, then retrieved by the aboutUs() method of the MainController
    class, and finally printed by the *aboutUs.php* template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Caching Approach 2: Using a JSON File'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose we later decide to add a second caching approach that caches data in
    a JSON file. This JSON approach would, for example, make it much easier to log
    different states of the cache at different times to a logging API that accepts
    JSON data. Let’s declare a new caching class named CacheJson to implement this
    other approach. Create *src/CacheJson.php* containing the code in [Listing 26-12](#lis26-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-12: The CacheJson class'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within CacheJson, we declare public set() ❶, get() ❷, and has() ❸ methods.
    Outwardly, they’re similar to those in our CacheStatic class, except they’re instance
    methods, belonging to each object of the class, rather than static methods belonging
    to the class as a whole. Internally, however, the method definitions are different
    from those of CacheStatic: they read and write information to a JSON file by using
    the private readJson() and writeJson() methods, which in turn use the built-in
    file_get_contents() and file_put_contents() functions introduced in [Chapter 9](chapter9.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: These details are hidden from the rest of the application, though, so the impact
    of these changes on our code is minimal. For example, [Listing 26-13](#lis26-13)
    shows the only changes we need to make to the Application class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-13: Updating the Application class to use a CacheJson object'
  prefs: []
  type: TYPE_NORMAL
- en: We replace CacheStatic::set('id', $id) with two statements that create a CacheJson
    object and invoke its set() method. The MainController class requires a similar
    small tweak, shown in [Listing 26-14](#lis26-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-14: Updating the MainController class to use a CacheJson object'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the $id = CacheStatic::get('id') statement, we create a CacheJson
    object and invoke its get() method to retrieve the value cached under the 'id'
    key ❶. If you now test the application again, it should work just as it did before.
    The only difference is that the ID is being cached to a JSON file instead of an
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Caching Approach 3: Creating a Cacheable Interface'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve already used two methods of caching for our application, and in the future
    we might want to use still others. This situation lends itself to abstracting
    the caching classes’ common operations as an interface, then writing classes that
    implement the interface. This way, as long as our code can create an object of
    any class that implements the interface, we know we’ll be able to use that class’s
    get(), set(), and has() methods without having to worry about which class the
    caching object is an instance of or how the class is doing the work.
  prefs: []
  type: TYPE_NORMAL
- en: To make this change, we’ll first declare a generic Cacheable interface. In addition
    to the get(), set(), and has() methods, we’ll also stipulate a fourth method,
    reset(), that completely empties the cache of any stored values. Create *src/Cacheable.php*
    and enter the contents of [Listing 26-15](#lis26-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-15: The Cacheable interface'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the Cacheable interface with the signatures for the four methods
    that any class implementing the interface must have. These methods are all public
    instance methods, with appropriate typed arguments and return types. For example,
    set() takes in strings for the desired key and value being cached and returns
    void, while get() takes in a string key and returns a string or NULL.
  prefs: []
  type: TYPE_NORMAL
- en: When we switched from using CacheStatic to CacheJson, we had to make some updates
    to the Application and MainController classes. We’ll now refactor those classes
    so that we can switch implementations of the Cacheable interface without having
    to change anything. We’ll start with the Application class. [Listing 26-16](#lis26-16)
    shows the updates to *src/Application.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-16: Refactoring the Application class to use the Cacheable interface'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first add a private cache property to the class, whose value is a reference
    to a Cacheable object ❶. This is a powerful feature of interfaces: we can provide
    an interface name as a data type for a variable, method parameter, or method return
    value, and any object from any class that implements the interface will work fine.'
  prefs: []
  type: TYPE_NORMAL
- en: We next obtain a Cacheable object reference for this property as an argument
    passed to the constructor method ❷. Whatever object is passed as an argument when
    an Application object is created must therefore be of a class that implements
    the Cacheable interface. The constructor invokes the reset() method of the provided
    Cacheable object, so we know we’ll have an empty cache when we start processing
    the current HTTP request. Because the cache property is private, we declare a
    public getter method so that it can be accessed outside the Application class
    ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that all these new statements so far have been written in such a way
    that the Application class doesn’t need to know which implementation of the Cacheable
    interface is referenced by the argument provided to the class’s constructor. You’ll
    see later how the Cacheable object is created in the index script, so this is
    the only place where the code needs to change if we choose to use a different
    Cacheable implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Inside run(), we use the Cacheable object’s expected set() method to store the
    value of the $id variable in the cache ❹. Then, when we create a MainController
    object, we provide $this as an argument ❺, meaning that the MainController object
    will have a reference back to this Application object. By extension, the MainController
    object will also have access to the Cacheable object through the Application object’s
    cache property.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s update the MainController class. [Listing 26-17](#lis26-17) shows
    the revised *src/MainController.php* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-17: Refactoring the MainController class to use the Cacheable interface'
  prefs: []
  type: TYPE_NORMAL
- en: We declare a private application property ❶ whose value is the reference to
    the Application object passed as an argument to the constructor method ❷. Then,
    in the aboutUs() method, we use the public getCache() method of the application
    object to obtain a reference to the Cacheable object ❸. This way, we can call
    the get() method as before to retrieve the stored ID from the cache for use within
    the page template.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to update the *public/index.php* script to create a caching object
    and pass it to the Application object when the latter is created. As mentioned
    earlier, this is the only part of the code that needs to know which implementation
    of the Cacheable interface we want to use. Update the index script as shown in
    [Listing 26-18](#lis26-18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-18: Choosing a Cacheable implementation in index.php'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create two objects: $cache1 is a CacheJson object, and $cache2 is a CacheStatic
    object. Then we pass one of these variables when we construct the Application
    object. Try the code with both variables, and it should work the same way each
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: The final step is to revise our cache classes to implement the Cacheable interface.
    [Listing 26-19](#lis26-19) shows the updated CacheStatic class. To meet the contractual
    obligations of the Cacheable interface, we need to make set(), get(), and has()
    instance (rather than static) methods, and we also must add a public reset() instance
    method. Update *src/CacheStatic.php* as shown in the listing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-19: Revising CacheStatic to implement the Cacheable interface'
  prefs: []
  type: TYPE_NORMAL
- en: We declare that the class implements the Cacheable interface, then provide an
    implementation for the requisite reset() method that sets $dataItems to an empty
    array ❶. The set(), get(), and has() implementations are the same as before, except
    we’ve changed them all from static to instance methods. The $dataItems array itself
    remains a static member.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 26-20 shows the modified CacheJson class in *src/CacheJson.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-20: Our refactored CacheJson class, implementing the Cacheable interface'
  prefs: []
  type: TYPE_NORMAL
- en: Again, we have to provide an implementation for the reset() method ❶. It uses
    the private makeDirIfNotExists() and makeEmptyFile() methods (declared next in
    the listing) to ensure that an empty file and directory exist after reset() is
    invoked. The remainder of the code, including the set(), get(), and has() methods,
    is the same as it was in [Listing 26-12](#lis26-12).
  prefs: []
  type: TYPE_NORMAL
- en: As this example has illustrated, declaring a useful feature like caching as
    an interface means you can create different implementations of that feature while
    writing most of your code (in this case, the Application and MainController classes)
    in a general way. This enables you to switch implementations of the interface,
    or create new ones later, without having to update all your code because of hardcoded
    references to the old way of doing things. All that has to change is the code
    that actually instantiates the class implementing the interface. We’ve conveniently
    located that code in the index script, where it can easily be updated without
    breaking the application.
  prefs: []
  type: TYPE_NORMAL
- en: Traits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *trait* is a way to provide default versions of methods that are shared among
    multiple, unrelated classes. This feature offers not just the method signatures,
    as with an interface or abstract method, but actual method implementations. When
    a class uses a trait, it’s called *insertion*, since the trait is essentially
    inserting a method into the class without the class having to define the method
    itself. That said, a trait can be inserted onto a class and then be overridden
    by the class’s own method implementations if necessary. This is useful when most,
    but not all, classes inserting a trait can use the same method implementation.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In some other programming languages, traits are known as* mixins*, after the
    extra ingredients such as nuts or candy that can be mixed into ice cream.*'
  prefs: []
  type: TYPE_NORMAL
- en: Traits are a way of permitting code reuse across class hierarchies without resorting
    to multiple inheritance, a sort of copy-and-paste feature for methods that allows
    the methods to still be overridden if needed. This is helpful, for example, if
    you have several classes implementing the same interface, all with identical versions
    of some of the methods the interface calls for. In this case, a lot of code would
    be duplicated across the classes, a violation of the DRY principle. Declaring
    those methods as a trait would allow you to write the code once and then add it
    to all the relevant classes by telling them to use the trait.
  prefs: []
  type: TYPE_NORMAL
- en: More broadly, traits may come into play when classes in multiple class hierarchies
    need to perform common actions. For example, several classes may need the behaviors
    of makeDirIfNotExists() and makeEmptyFile(), methods we declared earlier as part
    of the CacheJson class. One solution could be to make these methods public members
    of some kind of utility class (say, FileUtilities), so each class needing that
    functionality could create a FileUtilities object and invoke the methods; or we
    could declare the methods as public static members of the utility class to avoid
    having to create an object at all.
  prefs: []
  type: TYPE_NORMAL
- en: However, the application might change over time, and some of the classes may
    need specialized variations of the main method implementations. As such, instead
    of relegating the methods to a utility class, we can declare them as a trait.
    The methods will then be available for any class to use, but each class can replace
    them with custom implementations if required, without affecting any other part
    of the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, traits and utility classes are similar concepts, in that both can
    provide the same fully implemented methods to classes from different class hierarchies.
    Traits are a little more sophisticated and flexible than utility classes, however,
    since they can be overridden if needed. A class’s reliance on a trait may be more
    obvious than its reliance on a utility class, since the trait must be referenced
    with a use statement, whereas utility class method calls might be hidden within
    the implementation of a method; in this way, traits make code dependencies more
    transparent. On the other hand, traits can be harder to test directly since their
    methods are often private or protected, whereas utility class methods are typically
    public.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Traits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You declare a trait much like a class, but with the trait rather than the class
    keyword. To see how it works, let’s move the declarations of the makeDirIfNotExists()
    and makeEmptyFiles() methods from the class to a FileSystemTrait trait. Continuing
    the project from the previous section, create a new *src/FileSystemTrait.php*
    file and copy over the two method definitions, as shown in [Listing 26-21](#lis26-21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-21: The FileSystemTrait trait'
  prefs: []
  type: TYPE_NORMAL
- en: We use the trait keyword to declare FileSystemTrait as a trait. It contains
    method declarations for makeDirIfNotExists() and makeEmptyFile(). The implementation
    of these two methods is exactly as it was when they were in the CacheJson class.
  prefs: []
  type: TYPE_NORMAL
- en: While we’re at it, let’s extract the two JSON file methods from the CacheJson
    class, readJson() and writeJson(), and declare them as a second trait, JsonFileTrait,
    since these methods also define functionality that several classes might need.
    Copy the method definitions into a new *src/JsonFileTrait.php* file and update
    them as shown in [Listing 26-22](#lis26-22).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-22: The JsonFileTrait trait'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the JsonFileTrait trait with two methods, readJson() and writeJson().
    Once again the method implementations are virtually identical to the original
    methods on the CacheJson class, but this time we use a string $path parameter
    to indicate the JSON file that needs to be read or written to instead of a hardcoded
    class constant. This makes the methods more generally applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting Traits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s look at how to insert traits onto a class by refactoring CacheJson
    to use our two traits. [Listing 26-23](#lis26-23) shows the modified *src/CacheJson.php*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 26-23: Updating the CacheJson class to use traits'
  prefs: []
  type: TYPE_NORMAL
- en: We start with a use statement containing a comma-separated list of the traits
    to insert onto the class ❶. In the reset() method ❷, notice how we invoke the
    makeDirIfNotExists() and makeEmptyFile() methods, which now come from the trait,
    just as we did before. We don’t need to mention the trait when using these methods;
    we simply call the methods by name, as usual. Similarly, we’re able to use the
    readJson() and writeJson() methods as before, but now we pass the CACHE_PATH constant
    as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a much simpler CacheJson class. The commonly used methods for filesystem
    and JSON file operations have been refactored as traits, which keeps CacheJson
    itself focused on tasks related to caching. Meanwhile, the methods on the traits
    are also available for any other class to use.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving Trait Conflicts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If a class uses two or more traits, the same member could be declared in multiple
    traits. This potential problem is similar to issues that occur in languages that
    allow multiple inheritance. In such cases, you’ll get a fatal error if you try
    to call that method, since the PHP engine won’t know which implementation to invoke.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve the ambiguity and avoid the error, use the insteadof keyword to
    specify which version of the method you want to use. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet specifies that if printHello() is declared in both TraitA
    and TraitB, it’s the TraitA implementation that should be inserted into the class.
  prefs: []
  type: TYPE_NORMAL
- en: What to Use When?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The various strategies we’ve discussed in this chapter have considerable overlap.
    Deciding which to use in a given situation may be a matter of personal preference
    or the preference of a larger team. That said, [Figure 26-8](#fig26-8) offers
    some guidance by summarizing the similarities and differences between the approaches
    we’ve discussed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure26-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 26-8: Comparing strategies for code reuse and class interchangeability'
  prefs: []
  type: TYPE_NORMAL
- en: For basic class hierarchies, much can be achieved with simple inheritance, allowing
    subclasses to inherit fully implemented methods from concrete ❸ or abstract ❹
    superclasses. If many subclasses will require custom implementations of the inherited
    methods, you might declare them on the superclass as abstract methods instead
    ❺. This way, only the methods’ signatures will be specified, with the implementation
    details left up to the subclasses. Interfaces are another way to declare just
    the signatures of methods, but in this case the methods can be shared across class
    hierarchies ❻.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taken together, inheritance, abstract methods, and interfaces promote class
    interchangeability while also loosening the dependencies among the components
    in a software system. This greatly facilitates cooperative software development.
    By standardizing method signatures while allowing for flexibility in method implementation,
    interfaces in particular can be a contract between software components as well
    as a contract between cooperating developers, each with responsibilities for coding
    different parts of the system. The whole team can be confident that the system
    will behave as expected as long as the interface requirements are adhered to.
    This approach to software design is sometimes referred to as *loose coupling*:
    the number and form of breakable dependencies among software components are reduced,
    so changes in any one component are much less likely to affect performance or
    require refactoring of other components.'
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, if your goal is to reduce code duplication, you can use traits to
    offer sets of default method implementations that can be explicitly inserted into
    classes from different hierarchies ❷. For small systems, utility classes, perhaps
    with public static methods, can be another way to offer the same functionality
    to different parts of the system ❶. Traits provide more flexibility (for example,
    a class that inserts a trait may still override a method from that trait with
    its own custom implementation), but the public methods on utility classes are
    more readily exposed for thorough testing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we looked at several strategies for sharing methods among classes,
    both within and outside the confines of class hierarchies. You saw how abstract
    methods and interfaces enforce method signatures without providing implementations.
    The rest of the application can safely call the relevant methods, regardless of
    the implementation, since the signatures are guaranteed to always be the same.
    You saw this at work when we created a Cacheable interface that allowed us to
    switch approaches to caching (using a static array versus an external JSON file)
    with virtually no impact on the rest of the application code.
  prefs: []
  type: TYPE_NORMAL
- en: You also saw how to use traits to insert fully implemented methods onto unrelated
    classes, while still having the flexibility to override those methods if necessary.
    We harnessed traits to make general-purpose filesystem and JSON-handling methods
    available for any class in our caching project to use. This promoted code reusability
    and allowed us to declare simpler, more narrowly focused classes.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Declare a Book class that has the following members:'
  prefs: []
  type: TYPE_NORMAL
- en: A private string title property with get and set methods
  prefs: []
  type: TYPE_NORMAL
- en: A private float price property with get and set methods
  prefs: []
  type: TYPE_NORMAL
- en: A public getPriceIncludingSalesTax() method that returns a float, calculated
    as price plus 5 percent sales tax
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a main script that creates a Book object and prints its price with and
    without sales tax, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 2.   Refactor your project for Exercise 1 to declare an interface named SalesTaxable
    requiring classes to implement a getPriceIncludingSalesTax() method that returns
    a float. The Book class should implement the SalesTaxable interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, declare a Donut class that also implements the SalesTaxable interface
    and has these members:'
  prefs: []
  type: TYPE_NORMAL
- en: A private string topping property with get and set methods
  prefs: []
  type: TYPE_NORMAL
- en: A private float price property with get and set methods
  prefs: []
  type: TYPE_NORMAL
- en: A public getPriceIncludingSalesTax() method implementing the SalesTaxable interface
    and returning price plus 7 percent sales tax
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, write a main script that creates the following two objects and prints
    their price with and without sales tax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 3.   Write a TaxFunctions utility class that declares a public static addTaxToPrice()
    method that takes in a float price and float tax rate and returns the value of
    the price with the tax added. Refactor the implementations of the getPriceIncludingSalesTax()
    methods in the Book and Donut classes to use this utility class method, to avoid
    code duplication.
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Change your TaxFunctions utility class to a trait, declaring a (nonstatic)
    addTaxToPrice() method. Refactor the Book and Donut classes to insert the trait
    and use its addTaxToPrice() method in their implementations of getPriceIncludingSalesTax().
  prefs: []
  type: TYPE_NORMAL
- en: 5.   Refactor your project as a class hierarchy, with an abstract SellableItem
    superclass that declares a fully implemented getPriceIncludingSalesTax() method
    with protected visibility. Make Book and Donut subclasses of SellableItem, and
    delete the interface and trait files; they aren’t needed in this design. Sometimes,
    for a simple situation, the simplest solution is the most appropriate.
  prefs: []
  type: TYPE_NORMAL
