- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 26 ABSTRACT METHODS, INTERFACES, AND TRAITS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 26 抽象方法、接口和 traits
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In this chapter, we’ll move beyond the standard mechanism of inheritance from
    a superclass to a subclass and explore other strategies for sharing methods among
    classes. You’ll be introduced to abstract methods, interfaces, and traits.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将超越从超类到子类的标准继承机制，探索在类之间共享方法的其他策略。你将会接触到抽象方法、接口和 traits。
- en: 'As you’ll see, abstract methods and interfaces allow you to share just the
    signatures of methods across multiple classes, without specifying the details
    of how the methods should be implemented. In effect, these mechanisms act as *contracts*:
    to use abstract methods or interfaces, a class must agree to provide suitable
    implementations of those methods. Meanwhile, traits are a way to bypass inheritance
    and share fully implemented methods among classes in separate hierarchies. Interfaces,
    too, transcend class hierarchies, while abstract methods are still passed along
    between superclasses and subclasses through inheritance.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将看到的，抽象方法和接口允许你跨多个类共享方法的签名，而无需指定方法的实现细节。实际上，这些机制充当了*契约*：为了使用抽象方法或接口，一个类必须同意提供这些方法的合适实现。同时，traits
    是一种绕过继承的方式，可以在不同层次结构的类之间共享完全实现的方法。接口也超越了类层次结构，而抽象方法仍然通过继承在超类和子类之间传递。
- en: Together, abstract methods, interfaces, and traits can facilitate updating an
    application without breaking any code, since they provide assurances that certain
    methods will be present on a class for use by other parts of the application.
    Abstract methods and interfaces, in particular, promote class interchangeability.
    By enforcing method signatures while remaining agnostic about the implementations,
    they make it easy to substitute in classes that realize those methods differently
    as new project requirements arise (for example, having new types of files to write
    to, new database management systems to communicate with, or new destinations for
    logging events and exceptions). Traits, on the other hand, are helpful for avoiding
    redundancy and promoting code reusability, since they save you from having to
    declare the same method on several unrelated classes. In this sense, they’re somewhat
    similar to utility classes that are designed to make certain common operations
    available to all the classes in an application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法、接口和 traits 一起可以促进应用程序的更新，而不会破坏任何代码，因为它们确保了某些方法将会在类中存在，以供应用程序的其他部分使用。特别是抽象方法和接口促进了类的可互换性。通过强制方法签名，同时对实现保持中立，它们使得在项目需求变化时（例如需要写入新的文件类型、与新的数据库管理系统通信，或是为日志记录和异常处理指定新的目标）可以轻松替换那些以不同方式实现方法的类。另一方面，traits
    有助于避免冗余并促进代码的重用，因为它们避免了你必须在多个不相关的类中声明相同的方法。从这个意义上说，它们有点像工具类，旨在使应用程序中的所有类都能使用某些常见的操作。
- en: Of the topics covered in this chapter, interfaces especially are quite common
    in medium-to-large PHP projects. Even if you don’t write many interfaces yourself,
    you’ll probably use them, since they’re a feature of many third-party libraries
    for core web application components, including database communication and working
    with HTTP requests and responses.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章涉及的主题中，接口特别是在中型到大型的 PHP 项目中非常常见。即使你自己并不编写许多接口，你可能会使用它们，因为它们是许多第三方库的一个特性，这些库用于核心
    Web 应用程序组件，包括数据库通信以及处理 HTTP 请求和响应。
- en: From Inheritance to Interfaces
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从继承到接口
- en: In this section, we’ll progressively develop a sample network of classes to
    illustrate the features and merits of abstract methods and interfaces. We’ll start
    by reviewing the conventional process of a subclass inheriting methods from a
    superclass, then transition to using abstract methods and finally interfaces to
    standardize the features of unrelated classes. For simplicity, this will be a
    toy example. Once we’ve established the basics, however, we’ll turn to a more
    realistic and practical application for interfaces.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将逐步构建一个示例类网络，以说明抽象方法和接口的特点与优点。我们将首先回顾子类从超类继承方法的传统过程，然后过渡到使用抽象方法，最后使用接口来标准化不相关类的特性。为了简单起见，这将是一个玩具示例。然而，一旦我们建立了基础，我们将转向接口的更实际和更具实际应用性的场景。
- en: Inheriting a Fully Implemented Method from a Superclass
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从超类继承完全实现的方法
- en: As we discussed in [Chapter 19](chapter19.xhtml), inheritance makes it possible
    to pass down the definition of a superclass method to a related group of subclasses.
    If some of the subclasses need to implement the method differently, they can always
    override it with their own implementation, while other subclasses will simply
    inherit the default implementation from the superclass.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第19章](chapter19.xhtml)中讨论的，继承使得可以将超类方法的定义传递给一组相关的子类。如果某些子类需要以不同方式实现该方法，它们可以始终用自己的实现来覆盖它，而其他子类则会简单地继承超类的默认实现。
- en: Sometimes the superclass may be abstract, meaning it will never be instantiated.
    In this case, one or more non-abstract subclasses must extend the abstract superclass
    in order for objects to be created and the superclass’s methods to be executed.
    As an example, [Figure 26-1](#fig26-1) shows a simple class hierarchy of various
    animals, all of which will be able to return a string describing the type of sound
    they make.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，超类可能是抽象的，这意味着它永远不会被实例化。在这种情况下，一个或多个非抽象的子类必须扩展抽象超类，以便创建对象并执行超类的方法。举个例子，[图26-1](#fig26-1)展示了一个简单的动物类层次结构，所有这些动物类都能够返回描述它们发出声音的字符串。
- en: '![](../images/figure26-1.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure26-1.jpg)'
- en: 'Figure 26-1: A class hierarchy with an abstract superclass passing down a getSound()
    method'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图26-1：一个类层次结构，抽象超类传递一个getSound()方法
- en: At the top of this class hierarchy is the abstract Animal superclass. Its sound
    property is declared with a default value of 'meow' and protected (#) visibility,
    meaning the property’s value can be accessed (and overridden) by a subclass if
    required. Its numLegs property is public (+) and has a default value of 4. In
    addition, a getSound() method returns the string stored in sound.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类层次结构的顶部是抽象的Animal超类。它的sound属性默认值为“喵”，并具有保护（#）可见性，这意味着如果需要，子类可以访问（并覆盖）该属性的值。它的numLegs属性是公共的（+），默认值为4。此外，getSound()方法返回存储在sound中的字符串。
- en: At the next layer of the hierarchy, the Cat subclass extends Animal and so inherits
    the sound and numLegs properties and the getSound() method. This means Cat objects
    will produce a 'meow' sound. The Dog subclass also extends Animal but declares
    its own sound property of 'bark', overriding the value inherited from the superclass.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在该层次结构的下一层，Cat子类扩展了Animal类，因此继承了sound和numLegs属性以及getSound()方法。这意味着Cat对象将发出“喵”声。Dog子类也扩展了Animal类，但声明了自己的sound属性值为“汪”，覆盖了从超类继承的值。
- en: Finally, let’s imagine that opinions vary about the sound a bird makes; sometimes
    'tweet tweet' is more popular, and sometimes 'chirp chirp'. To account for this,
    the Bird subclass declares a custom implementation of getSound(), overriding the
    inherited method from the superclass. At runtime, each Bird object’s getSound()
    method will access a (fictional) API at *[www.mostPopularBirdSound.com](http://www.mostPopularBirdSound.com)*
    to determine the most popular bird sound string, ignoring the value of its inherited
    sound property. In addition, since birds have only two legs, the Bird class overrides
    the inherited number of legs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们假设关于鸟类发出的声音存在不同的看法；有时“叽叽喳喳”更受欢迎，有时“啾啾”更常见。为了解决这个问题，Bird子类声明了getSound()的自定义实现，覆盖了从超类继承的方法。在运行时，每个Bird对象的getSound()方法将访问一个（虚构的）API
    *[www.mostPopularBirdSound.com](http://www.mostPopularBirdSound.com)* 来确定最流行的鸟类声音字符串，而忽略其继承的sound属性的值。此外，由于鸟类只有两条腿，Bird类还覆盖了继承的腿数属性。
- en: Listing 26-1 shows the code for the Animal class.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 清单26-1显示了Animal类的代码。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 26-1: The Animal class'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 清单26-1：Animal类
- en: We declare the Animal class to be abstract so that it can never be instantiated
    and assign it sound and numLegs properties. We also provide an implementation
    of the getSound() method ❶, which returns the value of the sound property. For
    any instance of a subclass inheriting this method, the value of the object’s sound
    property will be determined at runtime when the getSound() method is invoked.
    For example, a Cat object will return 'meow', a Dog object will return 'bark',
    and a Bird object will override this method and instead return whatever string
    is retrieved from the *[www.mostPopularBirdSound.com](http://www.mostPopularBirdSound.com)*
    API.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明Animal类为抽象类，这样它就无法被实例化，并为其分配了sound和numLegs属性。我们还提供了getSound()方法的实现❶，该方法返回sound属性的值。对于任何继承该方法的子类实例，调用getSound()方法时，对象的sound属性值将在运行时确定。例如，Cat对象将返回'meow'，Dog对象将返回'bark'，而Bird对象将覆盖该方法，并返回从*[www.mostPopularBirdSound.com](http://www.mostPopularBirdSound.com)*
    API获取的任何字符串。
- en: The takeaway from this example is that a superclass (whether abstract or not)
    provides a way to offer a default method implementation that gets inherited by
    the subclasses in its class hierarchy. When required, however, this implementation
    can be overridden by individual subclasses.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子告诉我们，一个超类（无论是否抽象）提供了一种默认方法实现的方式，子类可以继承这个实现。需要时，这个实现可以被单独的子类覆盖。
- en: Inheriting an Abstract Method
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 继承抽象方法
- en: 'An *abstract method* is a method on a superclass that doesn’t have an implementation.
    Instead, all that’s declared is the method’s signature: its name, its parameters,
    and its return type. Any subclasses that inherit from the superclass must provide
    their own implementation of the abstract method. The exact details of how the
    method is implemented are left up to each subclass, as long as the implementation
    matches the method signature specified on the superclass.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*抽象方法*是超类中的一个没有实现的方法。它声明的只是方法的签名：方法的名称、参数和返回类型。任何继承该超类的子类必须提供自己对该抽象方法的实现。实现的具体细节由每个子类自行决定，只要实现符合超类中指定的方法签名。'
- en: Abstract methods can come into play when very different classes should exhibit
    the same behavior. For example, cars, like animals, make sound, and they should
    likely have a getSound() method that returns a string, just like our Animal class
    does. However, cars are otherwise very different from animals, and even the way
    they make sounds is pretty different; cars might output a sound such as 'putt-putt-putt',
    'purr', or 'vroom-vroom', depending on their engine size, fuel type, and so on.
    As such, the getSound() method for cars will be different from that for animals,
    and yet they’ll still have the same signature, since in both cases the method
    is ultimately returning a string.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法适用于需要展示相同行为但非常不同的类。例如，像动物一样，汽车也会发出声音，它们可能也需要一个返回字符串的getSound()方法，就像我们的Animal类一样。然而，汽车与动物有很大的不同，甚至它们发出声音的方式也大不相同；汽车可能会发出如'putt-putt-putt'、'purr'或'vroom-vroom'等声音，这取决于它们的发动机大小、燃料类型等。因此，汽车的getSound()方法将与动物的不同，但它们仍然会有相同的签名，因为在这两种情况下，方法最终都返回一个字符串。
- en: Let’s address this scenario by introducing a new abstract SoundMaker superclass
    that declares an abstract getSound() method. Any subclasses inheriting from SoundMaker,
    such as Animal and Car, will have to provide an appropriate getSound() implementation.
    [Figure 26-2](#fig26-2) shows the new, modified class hierarchy.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过引入一个新的抽象SoundMaker超类来解决这个问题，该超类声明了一个抽象的getSound()方法。任何从SoundMaker继承的子类，如Animal和Car，必须提供适当的getSound()实现。[图26-2](#fig26-2)显示了新的修改后的类层次结构。
- en: '![](../images/figure26-2.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure26-2.jpg)'
- en: 'Figure 26-2: Sharing an abstract getSound() method through the SoundMaker superclass'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图26-2：通过SoundMaker超类共享抽象getSound()方法
- en: Listing 26-2 shows the declaration of the new SoundMaker class. Notice that
    the class provides no implementation for the getSound() method, just its signature.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 清单26-2展示了新的SoundMaker类的声明。注意，类没有为getSound()方法提供实现，只声明了它的签名。
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 26-2: The SoundMaker class with an abstract method'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 清单26-2：带有抽象方法的SoundMaker类
- en: We designate the getSound() method abstract and declare just its signature.
    The method declaration is considered a statement, since no implementation is provided,
    and so it must end with a semicolon.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将getSound()方法指定为抽象方法，并仅声明它的签名。由于没有提供实现，方法声明被视为语句，因此必须以分号结束。
- en: 'The non-abstract Car subclass must now provide an implementation for the getSound()
    method in order to successfully inherit from SoundMaker. If it didn’t, we’d get
    a fatal error like the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 非抽象的 Car 子类现在必须为 getSound() 方法提供实现，才能成功地继承自 SoundMaker。如果没有实现，我们将得到一个类似下面的致命错误：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We’ve already provided a getSound() implementation on the Animal class, so it
    can successfully inherit from SoundMaker. The Cat and Dog subclasses inherit the
    method implementation from Animal, so they also meet the requirements of the SoundMaker
    class. The Bird class can still override the getSound() implementation inherited
    from Animal with its own implementation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 Animal 类上提供了 getSound() 的实现，因此它可以成功继承自 SoundMaker。Cat 和 Dog 子类继承了 Animal
    的方法实现，因此它们也满足了 SoundMaker 类的要求。Bird 类仍然可以用自己的实现覆盖从 Animal 继承来的 getSound() 实现。
- en: To see the benefit of making getSound() an abstract method, say our application
    has a function that needs to know the sound an object makes. That function can
    require a SoundMaker object (or one of its subclasses) as an argument, and know
    that whatever subclass of SoundMaker is received will have a getSound() method
    that can be invoked to return a string. It doesn’t matter whether it’s an Animal
    object or a Car object; the method is guaranteed to be there. In this way, abstract
    methods maximize class interchangeability while still allowing for different classes
    to have quite distinct implementations of a method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到将 getSound() 作为抽象方法的好处，假设我们的应用程序有一个需要知道对象发出声音的功能。该功能可以要求一个 SoundMaker 对象（或它的子类）作为参数，并且知道无论接收到哪个
    SoundMaker 的子类，都将有一个可以调用的 getSound() 方法来返回一个字符串。无论是 Animal 对象还是 Car 对象都没有关系；该方法肯定会存在。通过这种方式，抽象方法最大化了类的可互换性，同时仍然允许不同的类拥有非常不同的实现方式。
- en: 'If a class declares one or more abstract methods, the class itself must also
    be abstract. This is because you can’t instantiate a class with an abstract method,
    since no implementation of the method is provided. The opposite isn’t necessarily
    true, however: a class may be declared abstract but not contain any abstract methods.
    For example, you might have an abstract class consisting of fully implemented,
    static members.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类声明了一个或多个抽象方法，那么该类本身也必须是抽象的。这是因为你不能实例化一个包含抽象方法的类，因为该方法没有提供实现。然而，反过来并不一定成立：一个类可以声明为抽象类，但不包含任何抽象方法。例如，你可能有一个由完全实现的静态成员组成的抽象类。
- en: Requiring Method Implementations with Interfaces
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用接口要求方法实现
- en: An *interface* is a way to declare the signatures of one or more methods that
    a class should have. Classes then *implement* the interface by declaring methods
    with those specified signatures. Interfaces are similar to abstract methods in
    that both are ways of ensuring that one or more classes should have certain methods,
    without specifying exactly how those methods should be implemented. Both promote
    class interchangeability by guaranteeing the consistency of those methods’ signatures.
    The difference is that interfaces *aren’t* classes, and therefore are independent
    of any class hierarchy scheme, whereas abstract methods are declared as part of
    a class. As such, any classes that implement the abstract methods must fall within
    the hierarchy of the class that declares them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*接口* 是一种声明一个或多个方法签名的方式，类应该实现这些方法。然后，类通过声明具有这些指定签名的方法来*实现*接口。接口类似于抽象方法，因为它们都确保一个或多个类应该拥有某些方法，但不指定这些方法应该如何实现。它们都通过保证这些方法签名的一致性来促进类的可互换性。不同之处在于，接口*不是*类，因此独立于任何类层次结构，而抽象方法是作为类的一部分声明的。因此，任何实现抽象方法的类必须属于声明这些方法的类的层次结构。'
- en: Being independent of class hierarchies, interfaces are useful when you want
    to share a behavior among very different classes that wouldn’t belong in the same
    class hierarchy, or when you want to share multiple behaviors, in various combinations,
    among several very different classes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接口独立于类层次结构，因此当你希望在非常不同的类之间共享某种行为，这些类不属于同一个类层次结构时，或者你希望在多个非常不同的类之间共享多种行为时，接口就非常有用。
- en: Continuing with the example from the previous sections, pipe organs also make
    sounds, like cars and animals. Both pipe organs and cars require regular maintenance
    as well, whereas animals don’t. Let’s consider that subclasses of a Maintainable
    class must implement a nextService() method that returns some kind of Date object.
    The way a service date is calculated will be implemented differently for Car objects
    and PipeOrgan objects. Car service dates may be based on the type of engine and
    number of miles driven, while PipeOrgan objects may have service dates calculated
    based on, say, the length and material of the pipes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前面章节中的示例，管风琴也能发出声音，像汽车和动物一样。管风琴和汽车也需要定期维护，而动物则不需要。假设Maintainable类的子类必须实现一个返回某种Date对象的nextService()方法。服务日期的计算方法在Car对象和PipeOrgan对象中会有所不同。汽车的服务日期可能基于发动机类型和行驶的里程，而管风琴对象的服务日期可能根据管道的长度和材质来计算。
- en: We might be tempted to create a new abstract Maintainable class that declares
    an abstract nextService() method. The Car and PipeOrgan classes would inherit
    from Maintainable and provide their own nextService() implementations, while also
    inheriting from the SoundMaker class, along with Animal. This would be an example
    of *multiple inheritance*, the capability of a class to inherit from two or more
    superclasses at the same time. The class diagram in [Figure 26-3](#fig26-3) illustrates
    this scheme.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会倾向于创建一个新的抽象Maintainable类，声明一个抽象的nextService()方法。Car和PipeOrgan类将从Maintainable继承，并提供各自的nextService()实现，同时也继承自SoundMaker类，以及Animal类。这将是一个*多重继承*的例子，即一个类能够同时从两个或多个超类继承。图26-3中的类图展示了这一方案。
- en: '![](../images/figure26-3.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure26-3.jpg)'
- en: 'Figure 26-3: A class hierarchy with multiple inheritance'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图26-3：具有多重继承的类层次结构
- en: 'This arrangement may seem appealing: the Car and PipeOrgan classes inherit
    from two superclasses, thereby receiving the requirement for the getSound() method
    from the abstract SoundMaker class as before while also receiving the requirement
    for the nextService() method from the abstract Maintainable class. However, although
    some computer languages allow multiple inheritance, PHP does not, to avoid problems
    of ambiguity. If a class inherits from more than one superclass, and two or more
    of those superclasses declare a constant or method of the same name, how does
    the inheriting class know which to use?'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种安排可能看起来很吸引人：Car和PipeOrgan类都从两个超类继承，因此像之前一样，它们都可以继承来自抽象SoundMaker类的getSound()方法要求，同时也能继承来自抽象Maintainable类的nextService()方法要求。然而，尽管一些编程语言允许多重继承，PHP并不允许多重继承，以避免歧义问题。如果一个类从多个超类继承，并且这些超类中有两个或更多声明了相同名称的常量或方法，那么继承类该如何知道使用哪个呢？
- en: We could try to get around the prohibition against multiple inheritance by placing
    the SoundMaker and Maintainable superclasses at different levels of the same class
    hierarchy. That is, we could make Maintainable a subclass of SoundMaker, and Car
    and PipeOrgan subclasses of Maintainable, as in [Figure 26-4](#fig26-4).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试通过将SoundMaker和Maintainable超类放在同一类层次结构的不同层级来绕过对多重继承的禁止。也就是说，我们可以让Maintainable成为SoundMaker的子类，而Car和PipeOrgan成为Maintainable的子类，就像在[图26-4](#fig26-4)中那样。
- en: '![](../images/figure26-4.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure26-4.jpg)'
- en: 'Figure 26-4: A class hierarchy where Maintainable is a subclass of SoundMaker'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图26-4：一个类层次结构，其中Maintainable是SoundMaker的子类
- en: At first glance, this seems to work. Objects of any class in the hierarchy must
    have a getSound() method, and Car and PipeOrgan each must implement a nextService()
    method as well. However, what if we identify further behaviors that some of these
    classes should have but not others? Those behaviors may not make sense anywhere
    in the proposed hierarchy. Also, what if we want to add a Maintainable subclass
    that doesn’t make sound? Chimneys, for example, require regular maintenance but
    are silent.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，这似乎是可行的。层次结构中的任何类的对象都必须有一个getSound()方法，Car和PipeOrgan各自也必须实现一个nextService()方法。然而，如果我们识别出一些应该有但其他类没有的行为呢？这些行为在提议的层次结构中可能没有意义。另外，如果我们想添加一个不发声的Maintainable子类怎么办？例如，烟囱需要定期维护，但它是静音的。
- en: Clearly, we’ve created a fragile and artificial class hierarchy. Completely
    unrelated classes such as birds, cars, and chimneys may be forced into being subclasses
    of classes they have nothing to do with, all to enforce the inheritance of the
    getSound() and nextService() method signatures. The solution is to use an interface
    to define a set of required method signatures that can be implemented by classes
    that aren’t all in the same hierarchy. This dodges the illegal solution of multiple
    inheritance while also skirting the requirement for a single class hierarchy.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们创建了一个脆弱且人为的类层次结构。 完全不相关的类，如鸟类、汽车和烟囱，可能被迫成为它们与之无关的类的子类，所有这些都是为了强制继承 getSound()
    和 nextService() 方法签名。 解决方案是使用接口来定义一组必需的方法签名，这些方法可以由不在同一层次结构中的类来实现。 这样既避免了多重继承的非法解决方案，又规避了单一类层次结构的要求。
- en: To demonstrate, let’s first define SoundMaker as an interface rather than a
    class. Then we can stipulate that the classes in our example should all implement
    the SoundMaker interface. This is illustrated in [Figure 26-5](#fig26-5).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们首先将 SoundMaker 定义为一个接口而不是一个类。 然后我们可以规定我们示例中的类都应该实现 SoundMaker 接口。 这在
    [图 26-5](#fig26-5) 中有所说明。
- en: 'At the lower left of the diagram, the SoundMaker interface declares the signature
    of the getSound() method. With SoundMaker reframed as an interface rather than
    a class, we’re free to break our classes into separate, more meaningful, and robust
    hierarchies: we have the abstract Animal class and its subclasses, and the abstract
    Vehicle class with subclasses Car and Helicopter. The PipeOrgan class, which has
    little to do with animals or vehicles, is off by itself. The classes that implement
    the SoundMaker interface are annotated with the interface name and *lollipop notation*.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表的左下角，SoundMaker 接口声明了 getSound() 方法的签名。 将 SoundMaker 重新定义为接口而不是类之后，我们可以将我们的类分解为单独、更有意义和更健壮的层次结构：我们有抽象的
    Animal 类及其子类，以及抽象的 Vehicle 类和其子类 Car 和 Helicopter。 与动物或车辆无关的 PipeOrgan 类单独存在。
    实现 SoundMaker 接口的类用接口名称和 *棒棒糖符号* 进行注释。
- en: '![](../images/figure26-5.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure26-5.jpg)'
- en: 'Figure 26-5: The SoundMaker interface, implemented by multiple classes'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 26-5：实现了多个类的 SoundMaker 接口
- en: Notice that when an abstract class such as Animal or Vehicle implements an interface,
    it doesn’t have to provide full implementations of all (or any) of the methods
    declared on the interface. The implementation can be left to the non-abstract
    subclasses instead. Here Animal provides a getSound() implementation (although
    it’s overridden by the Bird subclass), while Vehicle doesn’t. In the latter case,
    the Car and Helicopter subclasses must each provide their own custom getSound()
    implementation in order to fulfill the promise the Vehicle class is making by
    declaring that it will implement the SoundMaker interface.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当抽象类（如 Animal 或 Vehicle）实现一个接口时，并不需要提供所有（或任何）在接口中声明的方法的完整实现。 具体的实现可以留给非抽象的子类来完成。
    在这里，Animal 提供了一个 getSound() 的实现（尽管被 Bird 子类覆盖），而 Vehicle 没有。 在后一种情况下，Car 和 Helicopter
    子类必须分别提供自己定制的 getSound() 实现，以实现 Vehicle 类通过声明其将实现 SoundMaker 接口而做出的承诺。
- en: Declaring an Interface
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 声明一个接口
- en: The code declaring an interface goes in its own.*php* file with the same name
    as the interface, much like a class declaration. For example, the SoundMaker interface
    should be declared in a *SoundMaker.php* file. [Listing 26-3](#lis26-3) shows
    its code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 声明接口的代码应该放在与接口同名的 *.php* 文件中，就像类声明一样。 例如，SoundMaker 接口应该在 *SoundMaker.php* 文件中声明。
    [清单 26-3](#lis26-3) 展示了其代码。
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 26-3: The SoundMaker interface'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 26-3：SoundMaker 接口
- en: We declare SoundMaker by using the interface keyword. Its body contains just
    the signature for the getSound() method, without an actual implementation. Just
    as when declaring an abstract method, the getSound() signature must end with a
    semicolon to indicate the end of the statement. Notice that we give getSound()
    public visibility. Including the public modifier explicitly is considered best
    practice, though it isn’t strictly necessary since all methods declared on an
    interface are automatically considered public so that other parts of the system
    can harness the behaviors of any interface-implementing classes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 interface 关键字声明 SoundMaker。它的主体仅包含 getSound() 方法的签名，没有实际的实现。就像声明一个抽象方法一样，getSound()
    的签名必须以分号结尾，以表示语句的结束。请注意，我们为 getSound() 提供了公共可见性。虽然显式包括 public 修饰符并非严格必要（因为在接口中声明的所有方法都会自动被视为公共方法），但最佳实践是显式声明，因为其他系统部分可以利用任何实现接口的类的行为。
- en: NOTE
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*In addition to declaring method signatures, interfaces can also declare constants.
    A class that implements the interface will inherit the interface constant, although
    as of PHP 8.1, the class can override the interface constant if needed.*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*除了声明方法签名外，接口还可以声明常量。实现该接口的类将继承接口常量，尽管从 PHP 8.1 开始，类可以根据需要覆盖接口常量。*'
- en: Implementing an Interface
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现接口
- en: Now let’s look at how a class can implement an interface. As an example, [Listing
    26-4](#lis26-4) shows the code for the PipeOrgan class, which implements the SoundMaker
    interface.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一个类如何实现一个接口。作为示例，[列表 26-4](#lis26-4) 展示了实现 SoundMaker 接口的 PipeOrgan 类的代码。
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 26-4: Implementing the SoundMaker interface with the PipeOrgan class'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 26-4：使用 PipeOrgan 类实现 SoundMaker 接口
- en: 'We declare that this class implements the SoundMaker interface by using the
    implements keyword. Because the PipeOrgan class implements SoundMaker, the class
    is obligated to provide an implementation for the getSound() method: in this case,
    it returns the string ''dum, dum, dum-dum''. The method matches the signature
    declared by the SoundMaker interface. We would similarly declare getSound() methods
    on the Animal and Vehicle classes. The details of each implementation don’t matter,
    as long as the method is called getSound() and it returns a string.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 implements 关键字声明该类实现了 SoundMaker 接口。由于 PipeOrgan 类实现了 SoundMaker，类有义务提供
    getSound() 方法的实现：在这种情况下，它返回字符串 'dum, dum, dum-dum'。该方法与 SoundMaker 接口声明的签名匹配。我们也会在
    Animal 和 Vehicle 类中声明 getSound() 方法。每个实现的细节并不重要，只要该方法被命名为 getSound() 且返回一个字符串。
- en: 'If a (non-abstract) class doesn’t include a definition for a method required
    by an interface it’s implementing, you’d get a fatal error. For example, if the
    code for the PipeOrgan class didn’t declare a getSound() method, you’d see the
    following when trying to create an object of this class:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个（非抽象）类没有包含实现接口所需的某个方法定义，那么会发生致命错误。例如，如果 PipeOrgan 类的代码没有声明 getSound() 方法，那么在尝试创建该类的对象时，你会看到如下错误：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that this is exactly the same fatal error as when a subclass fails to
    implement an abstract method declared in its superclass. The PHP engine processes
    the method signatures of an interface as if they were abstract methods; they must
    be realized in the class hierarchy implementing the interface before any object
    can be created.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这与子类未能实现其超类声明的抽象方法时的致命错误完全相同。PHP 引擎处理接口方法签名时，就像它们是抽象方法一样；在创建任何对象之前，必须在实现接口的类层次结构中实现这些方法。
- en: Implementing Multiple Interfaces with One Class
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用一个类实现多个接口
- en: A powerful feature of interfaces is that a single class may implement more than
    one of them. When a class implements an interface, it’s promising to provide a
    set of public methods with the signatures declared in that interface, and there’s
    no reason a class can’t do this for multiple interfaces.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的一个强大特性是，一个类可以实现多个接口。当一个类实现一个接口时，它承诺提供一组公共方法，这些方法的签名在该接口中声明，且没有理由一个类不能为多个接口提供这些方法。
- en: Returning to our example, the PipeOrgan class can implement a Maintainable interface,
    promising to declare an implementation of nextService(), in addition to implementing
    the SoundMaker interface by declaring a getSound() method. Likewise, if all vehicles
    require maintenance and make sounds, the Vehicle class can implement both the
    Maintainable and SoundMaker interfaces too. [Figure 26-6](#fig26-6) shows how
    these classes can implement multiple interfaces.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的示例，PipeOrgan 类可以实现 Maintainable 接口，承诺声明 `nextService()` 方法的实现，并通过声明 `getSound()`
    方法实现 SoundMaker 接口。同样，如果所有车辆都需要维护并发出声音，Vehicle 类也可以实现 Maintainable 和 SoundMaker
    两个接口。[图 26-6](#fig26-6) 展示了这些类如何实现多个接口。
- en: '![](../images/figure26-6.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure26-6.jpg)'
- en: 'Figure 26-6: Classes implementing multiple interfaces'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 26-6：实现多个接口的类
- en: The figure shows the Maintainable interface alongside SoundMaker, and the PipeOrgan
    and Vehicle classes now have two “lollipops,” indicating that they implement both
    interfaces. This arrangement of classes and interfaces is much neater conceptually
    than the artificial class hierarchy shown in [Figure 26-4](#fig26-4) or the multiple
    inheritance scheme shown in [Figure 26-3](#fig26-3).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图中展示了 Maintainable 接口与 SoundMaker 接口，PipeOrgan 和 Vehicle 类现在有两个“棒棒糖”，表示它们实现了这两个接口。与[图
    26-4](#fig26-4)中展示的人工类层次结构或[图 26-3](#fig26-3)中的多重继承方案相比，这种类和接口的安排在概念上更加简洁。
- en: To see how to declare that a class implements multiple interfaces, refer to
    [Listing 26-5](#lis26-5), which shows the updated code for the PipeOrgan class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看如何声明一个类实现多个接口，请参考[清单 26-5](#lis26-5)，其中展示了更新后的 PipeOrgan 类代码。
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 26-5: Implementing multiple interfaces with the PipeOrgan class'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 26-5：使用 PipeOrgan 类实现多个接口
- en: When a class implements multiple interfaces, you need to use the implements
    keyword only once, followed by the interface names, separated by commas, as in
    implements SoundMaker, Maintainable here. Beyond this, implementing multiple interfaces
    is as simple as providing definitions for all requisite methods. In this case,
    we’ve added the nextService() method, which returns a DateTime object as the Maintainable
    interface requires (we’ll discuss handling dates in [Chapter 31](chapter31.xhtml)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类实现多个接口时，只需要使用一次 `implements` 关键字，后跟接口名称，并用逗号分隔，如 `implements SoundMaker,
    Maintainable`。除此之外，实现多个接口只需为所有必需的方法提供定义。在这种情况下，我们添加了 `nextService()` 方法，该方法返回一个
    `DateTime` 对象，符合 Maintainable 接口的要求（我们将在[第 31 章](chapter31.xhtml)中讨论如何处理日期）。
- en: I mentioned earlier that an argument against multiple inheritance is the ambiguity
    of a class attempting to inherit the same member from multiple superclasses. This
    isn’t a problem for a class implementing multiple interfaces. Whether one, two,
    or any number of interfaces declare identical method signatures, all those interface
    contracts can be met by a single method of that signature implemented in a class.
    For example, if for some reason the Maintainable interface declared both a nextService()
    and a getSound() method, the code would still work fine provided the PipeOrgan
    class declares implementations for both methods. As long as all methods coming
    from interfaces are defined in the classes that implement them, no ambiguity exists
    and the PHP engine will work consistently, correctly, and error-free.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，反对多重继承的一个论点是，如果一个类试图从多个父类继承相同的成员，会造成歧义。但对于一个实现多个接口的类来说，这不是问题。无论一个、两个，还是任意数量的接口声明了相同的方法签名，所有这些接口的契约都可以通过类中实现的单个方法来满足。例如，如果因为某些原因
    Maintainable 接口声明了 `nextService()` 和 `getSound()` 两个方法，只要 PipeOrgan 类声明了这两个方法的实现，代码仍然能正常工作。只要来自接口的所有方法都在实现这些接口的类中定义，就不会有歧义，PHP
    引擎将始终一致、正确、无错误地运行。
- en: Comparing Interfaces and Abstract Classes
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 比较接口与抽象类
- en: At first glance, it may seem that interfaces are the same as abstract classes,
    as neither can be used to instantiate objects. However, while the concepts are
    related, key differences exist, and each is appropriate for different situations.
    Above all, an abstract class is a class, while an interface is not; it’s a promise,
    or contract, of method signatures that a class must implement. Another key difference
    is that a class can inherit from only one abstract class, whereas a class can
    implement multiple interfaces.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，可能会觉得接口与抽象类是一样的，因为它们都不能用于实例化对象。然而，尽管这两个概念相关，但它们之间存在关键差异，每个概念适用于不同的情况。最重要的一点是，抽象类是一个类，而接口不是；它是一个类必须实现的方法签名的承诺或契约。另一个关键区别是，类只能继承一个抽象类，而可以实现多个接口。
- en: Interfaces can’t declare or work with instance-level members, so interfaces
    can’t have instance properties or implement methods that work with instance members.
    Indeed, interfaces can’t implement methods at all; they only specify requirements
    for instance methods. An abstract class, meanwhile, can be a fully implemented
    class, or it can be a partially completed class including instance variables,
    a constructor, and a combination of implemented instance methods and unimplemented
    abstract methods. In the latter case, a class extending an abstract class has
    to complete the implementation only by fleshing out the inherited abstract methods.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接口不能声明或处理实例级别的成员，因此接口不能拥有实例属性或实现与实例成员交互的方法。事实上，接口根本不能实现方法；它们只指定实例方法的要求。与此不同，抽象类可以是一个完全实现的类，或者是一个部分实现的类，包括实例变量、构造函数以及实现的实例方法和未实现的抽象方法。在后一种情况下，扩展抽象类的类只需要通过完善继承的抽象方法来完成实现。
- en: Interfaces and abstract classes also differ in terms of method visibility. Methods
    declared on interfaces must be public, whereas abstract classes have the option
    to declare protected methods that are available only for internal use by objects
    within the class hierarchy. Also, while declaring the signature of a constructor
    method on an interface is technically possible, it’s highly discouraged; but it’s
    perfectly fine for an abstract class to have a constructor. Finally, it should
    be noted that an interface can extend another interface, much like a subclass
    extending a superclass. Unlike with class inheritance, however, an interface can
    extend multiple interfaces.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接口和抽象类在方法可见性方面也有所不同。接口上声明的方法必须是公共的，而抽象类可以声明受保护的方法，这些方法仅供类层次结构内的对象内部使用。此外，虽然在接口上声明构造方法的签名在技术上是可能的，但强烈不推荐这样做；而抽象类可以拥有构造函数。最后需要注意的是，接口可以扩展另一个接口，就像子类扩展父类一样。然而，与类继承不同，接口可以扩展多个接口。
- en: Real-World Applications of Interfaces
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口的现实世界应用
- en: Our SoundMaker and Maintainable scenario may have been a trivial example, but
    interfaces have significant real-world applications as well. They’re particularly
    useful for standardizing the method signatures of classes whose behavior may change
    as a web application evolves. Declaring the method signatures as an interface
    ensures that the application will still work; even if the details of the method
    implementations change, the way to call the methods won’t, so the rest of the
    application code will be unaffected.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的SoundMaker和Maintainable场景可能是一个简单的例子，但接口在现实世界中也有重要的应用。它们对于标准化类的方法签名特别有用，尤其是那些随着Web应用演变其行为可能发生变化的类。将方法签名声明为接口可以确保应用程序仍然有效；即使方法实现的细节发生变化，调用方法的方式也不会改变，因此应用程序的其他代码不会受到影响。
- en: We already used a practical, real-world interface in [Chapter 24](chapter24.xhtml)
    when we discussed logging. The PSR-3 standard specifies a Logger interface, outlining
    several methods that any classes implementing the interface must provide, such
    as log(), error(), and so on. You can work with any class that implements this
    interface and feel confident that these methods will be present. In [Chapter 24](chapter24.xhtml),
    for example, we used the Monolog library’s Logger class, which implements the
    Logger interface, but classes from other third-party libraries implement it too.
    Any of these classes would work, and you could even switch between Logger implementations
    without having to change the code that uses the logging object provided.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 24 章](chapter24.xhtml)中，我们已经使用了一个实际的、真实世界的接口来讨论日志记录。PSR-3 标准定义了一个 Logger
    接口，列出了任何实现该接口的类必须提供的多个方法，如 log()、error() 等。你可以与任何实现了这个接口的类一起工作，并且可以放心地知道这些方法会存在。例如，在[第
    24 章](chapter24.xhtml)中，我们使用了 Monolog 库的 Logger 类，该类实现了 Logger 接口，但其他第三方库的类也实现了这个接口。这些类中的任何一个都可以使用，而且你甚至可以在不同的
    Logger 实现之间切换，而无需更改使用提供的日志对象的代码。
- en: Another functionality that interfaces can help with is the ability to temporarily
    cache (store) data, such as when processing form submissions or HTTP requests
    in a web application. Caching the data helps avoid having to pass lots of arguments
    between controller objects and methods; you can simply store the data to the cache
    in one part of the code and then retrieve it from the cache in another part.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以帮助的另一个功能是暂时缓存（存储）数据，比如在处理表单提交或 HTTP 请求时缓存数据。在 Web 应用程序中缓存数据有助于避免在控制器对象和方法之间传递大量参数；你只需要在代码的一部分将数据存储到缓存中，然后在另一部分从缓存中检索数据。
- en: Caching has many approaches, such as using browser sessions, a database, JSON
    or XML files, the PHP Extension Community Library (PECL) language extension, or
    perhaps an API to connect to another service. If you declare an interface for
    common caching operations, you can write code that will be compatible with any
    interface-compliant caching system. Then you can easily switch caching systems
    as the project requirements change. For example, you might use one caching system
    when developing a project and a different caching system for the live production
    website.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存有许多方法，比如使用浏览器会话、数据库、JSON 或 XML 文件、PHP 扩展社区库（PECL）语言扩展，或者可能通过 API 连接到其他服务。如果你声明一个通用缓存操作的接口，你可以编写与任何符合接口的缓存系统兼容的代码。这样，你就可以根据项目需求的变化轻松切换缓存系统。例如，在开发一个项目时，你可能使用一种缓存系统，而在实际生产网站上则使用另一种缓存系统。
- en: We’ll explore the approaches to caching in this section and illustrate how to
    standardize them through a caching interface. We’ll test everything through a
    web application designed to cache the ID of any incoming HTTP requests and display
    that ID on an About page.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨缓存的不同方法，并演示如何通过缓存接口对它们进行标准化。我们将通过一个网页应用程序进行测试，该应用程序设计用于缓存任何传入 HTTP
    请求的 ID，并在 About 页面上显示该 ID。
- en: NOTE
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*PHP already has the PSR-6 and PSR-16 standards recommendations for caching
    interfaces, but they’re too involved for our purposes. We’ll create our own simpler
    approach to caching to explore the benefits of interfaces through a more straightforward
    example.*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*PHP 已经有 PSR-6 和 PSR-16 标准推荐用于缓存接口，但它们对于我们的目的来说过于复杂。我们将创建一个更简单的缓存方法，通过一个更直接的例子来探索接口的好处。*'
- en: 'Caching Approach 1: Using an Array'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓存方法 1：使用数组
- en: First, let’s implement a cache as a class called CacheStatic that uses a static
    (class-level) array for storing and retrieving values under string keys. We might
    use this simple approach to get the cache working quickly during the early stages
    of development. Besides getting and setting values, we’ll want the class to provide
    a has() method that returns a Boolean indicating whether a value is currently
    stored for a given key.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们实现一个名为 CacheStatic 的缓存类，该类使用静态（类级别）数组来存储和检索以字符串键为索引的值。我们可能会在开发的早期阶段使用这种简单的方法来快速使缓存工作。除了获取和设置值之外，我们还希望该类提供一个
    has() 方法，用于返回一个布尔值，指示是否已为给定键存储了某个值。
- en: Start a new project and give it the usual *composer.json* file declaring *src*
    as the location for classes in the Mattsmithdev namespace. Generate an autoloader
    with Composer, and create the usual *public/index.php* script that reads in and
    executes the autoloader, creates an Application object, and invokes its run()
    method. Once that’s written, you’re ready to declare the CacheStatic class in
    *src/CacheStatic.php*, as shown in [Listing 26-6](#lis26-6).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 26-6: The CacheStatic class'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: We initialize the private static dataItems property as an empty array ❶. This
    will be our cache. Then we declare the set() static method, which takes in two
    string arguments, a key and a value, for storage in the cache ❷. We next declare
    the get() static method, which takes in a string key and returns the value in
    the cache array stored for that key ❸. The method includes a test that returns
    NULL if no value exists for the given key. Finally, we declare the static has()
    method ❹, which returns true or false to indicate whether a value is cached for
    the given key.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll declare the Application class. Its run() method will cache the ID
    from the HTTP request, then instantiate a MainController object (we’ll declare
    this class shortly) to respond to the request. Create the file *src/Application.php*
    with the code in [Listing 26-7](#lis26-7).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 26-7: The Application class'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: After retrieving the URL-encoded action variable as usual, we attempt to retrieve
    another URL-encoded variable called id and store its value in the $id variable
    ❶. If this query-string variable turns out to be empty, we set $id to '(no id
    provided)' instead. Then we use the CacheStatic class’s set() static method to
    store the string in the $id variable in the cache with a key of 'id' ❷. We can
    now retrieve the stored string with the CacheStatic public static method get('id')
    if needed. The run() method concludes with a typical switch statement that invokes
    either the homepage() or aboutUs() method of the MainController object, depending
    on the value of the action variable ❸.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll declare the MainController class. Create *src/MainController.php*
    as shown in [Listing 26-8](#lis26-8).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 26-8: The MainController class'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The homepage() method simply outputs the Home page template. In the aboutUs()
    method, we use the CacheStatic class’s get() method to retrieve the ID from the
    cache array, storing the result in the $id variable ❶. Then we read in and execute
    the About page template, which will have access to $id.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Listing 26-9 shows the content of the Home page template. Enter this code into
    *templates/homepage.php*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 26-9: The homepage.php template'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: This basic HTML Home page template reuses some code by outputting the navigation
    bar from the partial template file *templates/_nav.php* ❶. [Listing 26-10](#lis26-10)
    shows the content of that partial template.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 26-10: The _nav.php partial template'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The navigation bar starts with two simple links, with the */* URL for the home
    page and */?action=about* for the About page. We also provide an extra, more complex
    link to the About page ❶, using PHP’s rand() function to pick an integer from
    1 to 99 and pass it as the value of the id query-string variable. This value will
    be cached and then displayed in the content of the About page to confirm that
    the cache is working.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 导航栏以两个简单的链接开始，其中*/\* 是主页的 URL，*/?action=about* 是关于页面的 URL。我们还提供了一个额外的、更复杂的链接到关于页面
    ❶，使用 PHP 的 rand() 函数从 1 到 99 中随机选择一个整数，并将其作为 id 查询字符串变量的值传递。这个值将被缓存，然后显示在关于页面的内容中，以确认缓存是否有效。
- en: Listing 26-11 shows the About page template in *templates/aboutUs.php*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 26-11 显示了 *templates/aboutUs.php* 中的关于页面模板。
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 26-11: The aboutUs.php template'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 26-11：aboutUs.php 模板
- en: As for the home page, we draw on the partial *_nav.php* template to simplify
    the file at hand. Then we incorporate the value of the $id variable into the body
    of the page ❶. [Figure 26-7](#fig26-7) shows the resulting web page.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 至于主页，我们借用了部分的 *_nav.php* 模板，以简化手头的文件。然后，我们将 $id 变量的值嵌入到页面正文中 ❶。[图 26-7](#fig26-7)
    显示了生成的网页。
- en: '![](../images/figure26-7.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure26-7.jpg)'
- en: 'Figure 26-7: The About page, including the cached ID value'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 26-7：关于页面，包括缓存的 ID 值
- en: Notice that the value of the URL-encoded id variable has been printed to the
    page. This indicates that the ID was successfully cached by the run() method in
    the Application class, then retrieved by the aboutUs() method of the MainController
    class, and finally printed by the *aboutUs.php* template.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 URL 编码的 id 变量的值已被打印到页面。这表明 ID 已成功通过 Application 类中的 run() 方法被缓存，然后通过 MainController
    类的 aboutUs() 方法检索，最终由 *aboutUs.php* 模板打印。
- en: 'Caching Approach 2: Using a JSON File'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓存方法 2：使用 JSON 文件
- en: Suppose we later decide to add a second caching approach that caches data in
    a JSON file. This JSON approach would, for example, make it much easier to log
    different states of the cache at different times to a logging API that accepts
    JSON data. Let’s declare a new caching class named CacheJson to implement this
    other approach. Create *src/CacheJson.php* containing the code in [Listing 26-12](#lis26-12).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们后来决定添加第二种缓存方法，将数据缓存到 JSON 文件中。这个 JSON 方法，例如，会让我们更容易在不同时间将缓存的不同状态记录到一个接受
    JSON 数据的日志 API 中。我们来声明一个名为 CacheJson 的新缓存类来实现这种方法。创建 *src/CacheJson.php* 文件，包含
    [清单 26-12](#lis26-12) 中的代码。
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 26-12: The CacheJson class'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 26-12：CacheJson 类
- en: 'Within CacheJson, we declare public set() ❶, get() ❷, and has() ❸ methods.
    Outwardly, they’re similar to those in our CacheStatic class, except they’re instance
    methods, belonging to each object of the class, rather than static methods belonging
    to the class as a whole. Internally, however, the method definitions are different
    from those of CacheStatic: they read and write information to a JSON file by using
    the private readJson() and writeJson() methods, which in turn use the built-in
    file_get_contents() and file_put_contents() functions introduced in [Chapter 9](chapter9.xhtml).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CacheJson 中，我们声明了 public set() ❶、get() ❷ 和 has() ❸ 方法。从外部来看，它们类似于我们 CacheStatic
    类中的方法，只不过它们是实例方法，属于类的每个对象，而不是属于整个类的静态方法。内部实现上，这些方法的定义与 CacheStatic 中的不同：它们通过使用私有的
    readJson() 和 writeJson() 方法来读取和写入 JSON 文件，而这些方法又使用 [第 9 章](chapter9.xhtml) 中介绍的内建函数
    file_get_contents() 和 file_put_contents()。
- en: These details are hidden from the rest of the application, though, so the impact
    of these changes on our code is minimal. For example, [Listing 26-13](#lis26-13)
    shows the only changes we need to make to the Application class.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些细节对应用程序的其余部分是隐藏的，因此这些更改对我们的代码的影响是最小的。例如，[清单 26-13](#lis26-13) 显示了我们只需要对
    Application 类做出的唯一更改。
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 26-13: Updating the Application class to use a CacheJson object'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 26-13：更新 Application 类以使用 CacheJson 对象
- en: We replace CacheStatic::set('id', $id) with two statements that create a CacheJson
    object and invoke its set() method. The MainController class requires a similar
    small tweak, shown in [Listing 26-14](#lis26-14).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 CacheStatic::set('id', $id) 替换为两条语句，创建一个 CacheJson 对象并调用其 set() 方法。MainController
    类需要做类似的小调整，如 [清单 26-14](#lis26-14) 所示。
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 26-14: Updating the MainController class to use a CacheJson object'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 26-14：更新 MainController 类以使用 CacheJson 对象
- en: Instead of the $id = CacheStatic::get('id') statement, we create a CacheJson
    object and invoke its get() method to retrieve the value cached under the 'id'
    key ❶. If you now test the application again, it should work just as it did before.
    The only difference is that the ID is being cached to a JSON file instead of an
    array.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 代替 `$id = CacheStatic::get('id')` 语句，我们创建一个 CacheJson 对象并调用其 get() 方法来检索缓存中
    'id' 键下的值 ❶。如果你现在重新测试应用程序，它应该和之前一样工作。唯一的区别是，ID 被缓存到 JSON 文件中，而不是数组中。
- en: 'Caching Approach 3: Creating a Cacheable Interface'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓存方法 3：创建一个 Cacheable 接口
- en: We’ve already used two methods of caching for our application, and in the future
    we might want to use still others. This situation lends itself to abstracting
    the caching classes’ common operations as an interface, then writing classes that
    implement the interface. This way, as long as our code can create an object of
    any class that implements the interface, we know we’ll be able to use that class’s
    get(), set(), and has() methods without having to worry about which class the
    caching object is an instance of or how the class is doing the work.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为应用程序使用了两种缓存方法，未来我们可能还需要使用其他方法。这种情况适合将缓存类的公共操作抽象为一个接口，然后编写实现该接口的类。这样，只要我们的代码能够创建任何实现了该接口的类的对象，我们就可以使用该类的
    get()、set() 和 has() 方法，而无需担心缓存对象是哪个类的实例，或者该类是如何执行工作的。
- en: To make this change, we’ll first declare a generic Cacheable interface. In addition
    to the get(), set(), and has() methods, we’ll also stipulate a fourth method,
    reset(), that completely empties the cache of any stored values. Create *src/Cacheable.php*
    and enter the contents of [Listing 26-15](#lis26-15).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行此更改，我们首先声明一个通用的 Cacheable 接口。除了 get()、set() 和 has() 方法外，我们还规定了一个第四个方法，reset()，该方法完全清空缓存中的所有存储值。创建
    *src/Cacheable.php* 并输入 [列表 26-15](#lis26-15) 的内容。
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 26-15: The Cacheable interface'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 26-15：Cacheable 接口
- en: We declare the Cacheable interface with the signatures for the four methods
    that any class implementing the interface must have. These methods are all public
    instance methods, with appropriate typed arguments and return types. For example,
    set() takes in strings for the desired key and value being cached and returns
    void, while get() takes in a string key and returns a string or NULL.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了 Cacheable 接口，并为任何实现该接口的类必须具有的四个方法定义了签名。这些方法都是公共实例方法，具有适当的类型化参数和返回类型。例如，set()
    接收字符串类型的键和值作为缓存内容，并返回 void，而 get() 接收一个字符串类型的键并返回一个字符串或 NULL。
- en: When we switched from using CacheStatic to CacheJson, we had to make some updates
    to the Application and MainController classes. We’ll now refactor those classes
    so that we can switch implementations of the Cacheable interface without having
    to change anything. We’ll start with the Application class. [Listing 26-16](#lis26-16)
    shows the updates to *src/Application.php*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从使用 CacheStatic 切换到 CacheJson 时，我们需要对 Application 和 MainController 类做一些更新。接下来，我们将重构这些类，以便可以在不更改任何内容的情况下切换
    Cacheable 接口的实现。我们从 Application 类开始。[列表 26-16](#lis26-16) 展示了对 *src/Application.php*
    的更新。
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 26-16: Refactoring the Application class to use the Cacheable interface'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 26-16：重构 Application 类以使用 Cacheable 接口
- en: 'We first add a private cache property to the class, whose value is a reference
    to a Cacheable object ❶. This is a powerful feature of interfaces: we can provide
    an interface name as a data type for a variable, method parameter, or method return
    value, and any object from any class that implements the interface will work fine.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为类添加一个私有缓存属性，该属性的值是指向一个可缓存对象（Cacheable） ❶ 的引用。这是接口的一个强大特性：我们可以将接口名作为变量、方法参数或方法返回值的数据类型，任何实现该接口的类中的对象都可以正常工作。
- en: We next obtain a Cacheable object reference for this property as an argument
    passed to the constructor method ❷. Whatever object is passed as an argument when
    an Application object is created must therefore be of a class that implements
    the Cacheable interface. The constructor invokes the reset() method of the provided
    Cacheable object, so we know we’ll have an empty cache when we start processing
    the current HTTP request. Because the cache property is private, we declare a
    public getter method so that it can be accessed outside the Application class
    ❸.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们获取该属性的Cacheable对象引用，作为构造方法传递的参数❷。当创建Application对象时传递的任何对象，必须是实现了Cacheable接口的类。因此，构造函数调用提供的Cacheable对象的reset()方法，因此我们知道在开始处理当前HTTP请求时，缓存将是空的。由于缓存属性是私有的，我们声明了一个公共的getter方法，以便它可以在Application类外部访问❸。
- en: Notice that all these new statements so far have been written in such a way
    that the Application class doesn’t need to know which implementation of the Cacheable
    interface is referenced by the argument provided to the class’s constructor. You’ll
    see later how the Cacheable object is created in the index script, so this is
    the only place where the code needs to change if we choose to use a different
    Cacheable implementation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，到目前为止，所有这些新语句都已经写得如此方式，以至于Application类不需要知道构造函数提供的参数引用的是哪个Cacheable接口的实现。稍后你将看到在index脚本中如何创建Cacheable对象，因此如果我们选择使用不同的Cacheable实现，这里是唯一需要修改的地方。
- en: Inside run(), we use the Cacheable object’s expected set() method to store the
    value of the $id variable in the cache ❹. Then, when we create a MainController
    object, we provide $this as an argument ❺, meaning that the MainController object
    will have a reference back to this Application object. By extension, the MainController
    object will also have access to the Cacheable object through the Application object’s
    cache property.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在run()方法内部，我们使用Cacheable对象预期的set()方法将$id变量的值存储到缓存中❹。然后，当我们创建一个MainController对象时，我们将$this作为参数传递❺，这意味着MainController对象将有一个指向Application对象的引用。通过这种方式，MainController对象也可以通过Application对象的缓存属性访问Cacheable对象。
- en: Now let’s update the MainController class. [Listing 26-17](#lis26-17) shows
    the revised *src/MainController.php* file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新MainController类。[清单26-17](#lis26-17)展示了更新后的*src/MainController.php*文件。
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 26-17: Refactoring the MainController class to use the Cacheable interface'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 清单26-17：重构MainController类以使用Cacheable接口
- en: We declare a private application property ❶ whose value is the reference to
    the Application object passed as an argument to the constructor method ❷. Then,
    in the aboutUs() method, we use the public getCache() method of the application
    object to obtain a reference to the Cacheable object ❸. This way, we can call
    the get() method as before to retrieve the stored ID from the cache for use within
    the page template.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个私有的应用程序属性❶，其值是作为参数传递给构造方法的Application对象的引用❷。然后，在aboutUs()方法中，我们使用应用程序对象的公共getCache()方法来获取Cacheable对象的引用❸。这样，我们就可以像以前一样调用get()方法，从缓存中检索存储的ID，并在页面模板中使用它。
- en: Next, we need to update the *public/index.php* script to create a caching object
    and pass it to the Application object when the latter is created. As mentioned
    earlier, this is the only part of the code that needs to know which implementation
    of the Cacheable interface we want to use. Update the index script as shown in
    [Listing 26-18](#lis26-18).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新*public/index.php*脚本，以便创建一个缓存对象并在创建Application对象时将其传递给它。如前所述，这部分代码是唯一需要知道我们想要使用哪种Cacheable接口实现的地方。按[清单26-18](#lis26-18)所示更新index脚本。
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 26-18: Choosing a Cacheable implementation in index.php'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 清单26-18：在index.php中选择Cacheable实现
- en: 'We create two objects: $cache1 is a CacheJson object, and $cache2 is a CacheStatic
    object. Then we pass one of these variables when we construct the Application
    object. Try the code with both variables, and it should work the same way each
    time.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个对象：$cache1是一个CacheJson对象，$cache2是一个CacheStatic对象。然后，我们在构造Application对象时传递这两个变量之一。尝试使用这两个变量的代码，每次应该都能正常工作。
- en: The final step is to revise our cache classes to implement the Cacheable interface.
    [Listing 26-19](#lis26-19) shows the updated CacheStatic class. To meet the contractual
    obligations of the Cacheable interface, we need to make set(), get(), and has()
    instance (rather than static) methods, and we also must add a public reset() instance
    method. Update *src/CacheStatic.php* as shown in the listing.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的步骤是修改我们的缓存类以实现 Cacheable 接口。[清单 26-19](#lis26-19) 显示了更新后的 CacheStatic 类。为了满足
    Cacheable 接口的契约要求，我们需要将 set()、get() 和 has() 方法改为实例方法（而不是静态方法），同时必须添加一个公共的 reset()
    实例方法。按照清单中的内容更新 *src/CacheStatic.php*。
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 26-19: Revising CacheStatic to implement the Cacheable interface'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 26-19：修改 CacheStatic 以实现 Cacheable 接口
- en: We declare that the class implements the Cacheable interface, then provide an
    implementation for the requisite reset() method that sets $dataItems to an empty
    array ❶. The set(), get(), and has() implementations are the same as before, except
    we’ve changed them all from static to instance methods. The $dataItems array itself
    remains a static member.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明该类实现了 Cacheable 接口，然后为必需的 reset() 方法提供实现，将 $dataItems 设置为空数组❶。set()、get()
    和 has() 方法的实现与之前相同，唯一的区别是我们将它们从静态方法改为了实例方法。$dataItems 数组本身仍然是静态成员。
- en: Listing 26-20 shows the modified CacheJson class in *src/CacheJson.php*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 26-20 显示了修改后的 CacheJson 类，位于 *src/CacheJson.php*。
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 26-20: Our refactored CacheJson class, implementing the Cacheable interface'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 26-20：我们重构后的 CacheJson 类，实现了 Cacheable 接口
- en: Again, we have to provide an implementation for the reset() method ❶. It uses
    the private makeDirIfNotExists() and makeEmptyFile() methods (declared next in
    the listing) to ensure that an empty file and directory exist after reset() is
    invoked. The remainder of the code, including the set(), get(), and has() methods,
    is the same as it was in [Listing 26-12](#lis26-12).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，我们必须为 reset() 方法提供实现❶。它使用私有的 makeDirIfNotExists() 和 makeEmptyFile() 方法（在清单中接下来声明）来确保在调用
    reset() 后，空文件和目录存在。其余代码，包括 set()、get() 和 has() 方法，和 [清单 26-12](#lis26-12) 中的一样。
- en: As this example has illustrated, declaring a useful feature like caching as
    an interface means you can create different implementations of that feature while
    writing most of your code (in this case, the Application and MainController classes)
    in a general way. This enables you to switch implementations of the interface,
    or create new ones later, without having to update all your code because of hardcoded
    references to the old way of doing things. All that has to change is the code
    that actually instantiates the class implementing the interface. We’ve conveniently
    located that code in the index script, where it can easily be updated without
    breaking the application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个例子所示，将像缓存这样的有用特性声明为接口意味着你可以创建该特性的不同实现，同时在编写大部分代码（例如 Application 和 MainController
    类）时采用通用方式。这使得你可以在不必更新所有代码的情况下切换接口的实现，或者稍后创建新的实现，而不需要因为硬编码引用旧方式而导致应用程序出错。唯一需要改变的代码是实际实例化实现接口的类的代码。我们已经将这段代码方便地放在了索引脚本中，在那里可以轻松更新而不会破坏应用程序。
- en: Traits
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特性
- en: A *trait* is a way to provide default versions of methods that are shared among
    multiple, unrelated classes. This feature offers not just the method signatures,
    as with an interface or abstract method, but actual method implementations. When
    a class uses a trait, it’s called *insertion*, since the trait is essentially
    inserting a method into the class without the class having to define the method
    itself. That said, a trait can be inserted onto a class and then be overridden
    by the class’s own method implementations if necessary. This is useful when most,
    but not all, classes inserting a trait can use the same method implementation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*特性* 是一种提供多个不相关类共享的默认方法实现的方式。此特性不仅提供方法签名（如接口或抽象方法），还提供实际的方法实现。当一个类使用特性时，称为*插入*，因为特性本质上是在类中插入方法，而不需要类自己定义该方法。也就是说，特性可以插入到类中，并且如果需要，类可以通过自己的方法实现覆盖特性中的方法。这在大多数类（但不是所有类）插入特性时，能够使用相同的方法实现时特别有用。'
- en: NOTE
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*In some other programming languages, traits are known as* mixins*, after the
    extra ingredients such as nuts or candy that can be mixed into ice cream.*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*在其他一些编程语言中，特性被称为* mixins*，就像冰淇淋中可以混合的坚果或糖果等额外成分一样。*'
- en: Traits are a way of permitting code reuse across class hierarchies without resorting
    to multiple inheritance, a sort of copy-and-paste feature for methods that allows
    the methods to still be overridden if needed. This is helpful, for example, if
    you have several classes implementing the same interface, all with identical versions
    of some of the methods the interface calls for. In this case, a lot of code would
    be duplicated across the classes, a violation of the DRY principle. Declaring
    those methods as a trait would allow you to write the code once and then add it
    to all the relevant classes by telling them to use the trait.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 特性是一种允许跨类层次复用代码的方式，而不需要使用多重继承，它是一种类似于方法的复制粘贴功能，可以在需要时覆盖这些方法。例如，如果你有多个类实现相同的接口，而这些类中的某些方法版本完全相同，使用特性可以避免代码在类中重复，从而遵循了DRY（不要重复自己）原则。在这种情况下，你可以将这些方法声明为特性，只需要编写一次代码，然后通过告诉相关类使用该特性，将其添加到所有相关类中。
- en: More broadly, traits may come into play when classes in multiple class hierarchies
    need to perform common actions. For example, several classes may need the behaviors
    of makeDirIfNotExists() and makeEmptyFile(), methods we declared earlier as part
    of the CacheJson class. One solution could be to make these methods public members
    of some kind of utility class (say, FileUtilities), so each class needing that
    functionality could create a FileUtilities object and invoke the methods; or we
    could declare the methods as public static members of the utility class to avoid
    having to create an object at all.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 更广泛地说，当多个类层次中的类需要执行公共操作时，特性可能会派上用场。例如，几个类可能需要`makeDirIfNotExists()`和`makeEmptyFile()`这两个方法的行为，而这两个方法我们之前在`CacheJson`类中声明过。一个解决方案是将这些方法作为某个工具类（例如，`FileUtilities`）的公共成员，这样每个需要该功能的类都可以创建一个`FileUtilities`对象并调用这些方法；或者，我们可以将这些方法声明为工具类的公共静态成员，以避免创建对象。
- en: However, the application might change over time, and some of the classes may
    need specialized variations of the main method implementations. As such, instead
    of relegating the methods to a utility class, we can declare them as a trait.
    The methods will then be available for any class to use, but each class can replace
    them with custom implementations if required, without affecting any other part
    of the codebase.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，应用程序可能会随着时间的推移而变化，一些类可能需要主方法实现的特定变体。因此，与其将方法放入工具类中，我们可以将它们声明为特性。这样，这些方法将可供任何类使用，但每个类都可以在需要时用自定义实现替换这些方法，而不会影响代码库的其他部分。
- en: Ultimately, traits and utility classes are similar concepts, in that both can
    provide the same fully implemented methods to classes from different class hierarchies.
    Traits are a little more sophisticated and flexible than utility classes, however,
    since they can be overridden if needed. A class’s reliance on a trait may be more
    obvious than its reliance on a utility class, since the trait must be referenced
    with a use statement, whereas utility class method calls might be hidden within
    the implementation of a method; in this way, traits make code dependencies more
    transparent. On the other hand, traits can be harder to test directly since their
    methods are often private or protected, whereas utility class methods are typically
    public.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，特性（traits）和工具类（utility classes）是相似的概念，因为它们都能为来自不同类层次的类提供相同的完全实现的方法。然而，特性比工具类更为复杂和灵活，因为它们可以根据需要被重写。一个类对特性的依赖可能比对工具类的依赖更加明显，因为特性必须通过`use`语句进行引用，而工具类的方法调用可能隐藏在方法的实现中；从这个角度看，特性使得代码依赖关系更加透明。另一方面，特性可能更难直接测试，因为它们的方法通常是私有的或受保护的，而工具类的方法通常是公共的。
- en: Declaring Traits
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 声明特性
- en: You declare a trait much like a class, but with the trait rather than the class
    keyword. To see how it works, let’s move the declarations of the makeDirIfNotExists()
    and makeEmptyFiles() methods from the class to a FileSystemTrait trait. Continuing
    the project from the previous section, create a new *src/FileSystemTrait.php*
    file and copy over the two method definitions, as shown in [Listing 26-21](#lis26-21).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 声明特性的方法类似于声明类，只不过是使用`trait`关键字而不是`class`关键字。为了演示如何使用特性，接下来我们将`makeDirIfNotExists()`和`makeEmptyFiles()`方法的声明从类中移到`FileSystemTrait`特性中。在前一节的基础上，创建一个新的*src/FileSystemTrait.php*文件，并按[Listing
    26-21](#lis26-21)所示复制这两个方法的定义。
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 26-21: The FileSystemTrait trait'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 26-21：FileSystemTrait 特性
- en: We use the trait keyword to declare FileSystemTrait as a trait. It contains
    method declarations for makeDirIfNotExists() and makeEmptyFile(). The implementation
    of these two methods is exactly as it was when they were in the CacheJson class.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`trait`关键字声明FileSystemTrait为一个trait。它包含了`makeDirIfNotExists()`和`makeEmptyFile()`的声明。这两个方法的实现与它们在CacheJson类中的实现完全相同。
- en: While we’re at it, let’s extract the two JSON file methods from the CacheJson
    class, readJson() and writeJson(), and declare them as a second trait, JsonFileTrait,
    since these methods also define functionality that several classes might need.
    Copy the method definitions into a new *src/JsonFileTrait.php* file and update
    them as shown in [Listing 26-22](#lis26-22).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们处理这些问题时，接下来让我们从CacheJson类中提取两个JSON文件方法，`readJson()`和`writeJson()`，并将它们声明为第二个trait，JsonFileTrait，因为这些方法也定义了多个类可能需要的功能。将方法定义复制到新的*src/JsonFileTrait.php*文件中，并按照[Listing
    26-22](#lis26-22)中的示例进行更新。
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 26-22: The JsonFileTrait trait'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 26-22：JsonFileTrait trait
- en: We declare the JsonFileTrait trait with two methods, readJson() and writeJson().
    Once again the method implementations are virtually identical to the original
    methods on the CacheJson class, but this time we use a string $path parameter
    to indicate the JSON file that needs to be read or written to instead of a hardcoded
    class constant. This makes the methods more generally applicable.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了JsonFileTrait trait，包含两个方法，`readJson()`和`writeJson()`。再次说明，这些方法的实现几乎与原来CacheJson类中的方法相同，但这次我们使用了一个字符串类型的`$path`参数来表示需要读取或写入的JSON文件，而不是硬编码的类常量。这使得这些方法更加通用。
- en: Inserting Traits
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 插入Traits
- en: Now let’s look at how to insert traits onto a class by refactoring CacheJson
    to use our two traits. [Listing 26-23](#lis26-23) shows the modified *src/CacheJson.php*
    file.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何通过重构CacheJson类来使用这两个traits。在[Listing 26-23](#lis26-23)中，展示了修改后的*src/CacheJson.php*文件。
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 26-23: Updating the CacheJson class to use traits'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 26-23：更新CacheJson类以使用traits
- en: We start with a use statement containing a comma-separated list of the traits
    to insert onto the class ❶. In the reset() method ❷, notice how we invoke the
    makeDirIfNotExists() and makeEmptyFile() methods, which now come from the trait,
    just as we did before. We don’t need to mention the trait when using these methods;
    we simply call the methods by name, as usual. Similarly, we’re able to use the
    readJson() and writeJson() methods as before, but now we pass the CACHE_PATH constant
    as an argument.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个`use`语句开始，语句中包含了一个用逗号分隔的trait列表 ❶。在`reset()`方法 ❷中，注意我们如何调用`makeDirIfNotExists()`和`makeEmptyFile()`方法，这些方法现在来自trait，就像我们之前做的那样。使用这些方法时，我们不需要提及trait；我们像平常一样直接按名称调用方法。同样，我们也能像之前一样使用`readJson()`和`writeJson()`方法，但现在我们传递了`CACHE_PATH`常量作为参数。
- en: We now have a much simpler CacheJson class. The commonly used methods for filesystem
    and JSON file operations have been refactored as traits, which keeps CacheJson
    itself focused on tasks related to caching. Meanwhile, the methods on the traits
    are also available for any other class to use.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有一个更简单的CacheJson类。常用的文件系统和JSON文件操作方法已被重构为traits，这使得CacheJson本身更加专注于与缓存相关的任务。同时，traits上的方法也可以被其他任何类使用。
- en: Resolving Trait Conflicts
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决Trait冲突
- en: If a class uses two or more traits, the same member could be declared in multiple
    traits. This potential problem is similar to issues that occur in languages that
    allow multiple inheritance. In such cases, you’ll get a fatal error if you try
    to call that method, since the PHP engine won’t know which implementation to invoke.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类使用了两个或多个traits，可能会在多个traits中声明相同的成员。这个潜在问题类似于允许多重继承的语言中会发生的冲突。在这种情况下，如果你尝试调用该方法，将会遇到致命错误，因为PHP引擎无法确定应该调用哪个实现。
- en: 'To resolve the ambiguity and avoid the error, use the insteadof keyword to
    specify which version of the method you want to use. Here’s an example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决歧义并避免错误，使用`insteadof`关键字来指定要使用的方法版本。以下是一个示例：
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code snippet specifies that if printHello() is declared in both TraitA
    and TraitB, it’s the TraitA implementation that should be inserted into the class.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码指定，如果`printHello()`在TraitA和TraitB中都被声明，那么应该插入TraitA中的实现。
- en: What to Use When?
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时使用什么？
- en: The various strategies we’ve discussed in this chapter have considerable overlap.
    Deciding which to use in a given situation may be a matter of personal preference
    or the preference of a larger team. That said, [Figure 26-8](#fig26-8) offers
    some guidance by summarizing the similarities and differences between the approaches
    we’ve discussed.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中讨论的各种策略有相当大的重叠。在给定情况下决定使用哪种方法，可能是个人偏好或更大团队的偏好。话虽如此，[图 26-8](#fig26-8)通过总结我们讨论的各种方法的相似性和差异，提供了一些指导。
- en: '![](../images/figure26-8.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure26-8.jpg)'
- en: 'Figure 26-8: Comparing strategies for code reuse and class interchangeability'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 26-8：比较代码重用和类可互换性的策略
- en: For basic class hierarchies, much can be achieved with simple inheritance, allowing
    subclasses to inherit fully implemented methods from concrete ❸ or abstract ❹
    superclasses. If many subclasses will require custom implementations of the inherited
    methods, you might declare them on the superclass as abstract methods instead
    ❺. This way, only the methods’ signatures will be specified, with the implementation
    details left up to the subclasses. Interfaces are another way to declare just
    the signatures of methods, but in this case the methods can be shared across class
    hierarchies ❻.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本的类层次结构，简单的继承可以实现很多功能，允许子类从具体❸或抽象❹超类继承完全实现的方法。如果许多子类需要对继承的方法进行自定义实现，您可能会将它们声明为超类的抽象方法❺。这样，只有方法的签名会被指定，具体实现则由子类决定。接口是另一种声明方法签名的方式，但在这种情况下，方法可以在类层次结构❻之间共享。
- en: 'Taken together, inheritance, abstract methods, and interfaces promote class
    interchangeability while also loosening the dependencies among the components
    in a software system. This greatly facilitates cooperative software development.
    By standardizing method signatures while allowing for flexibility in method implementation,
    interfaces in particular can be a contract between software components as well
    as a contract between cooperating developers, each with responsibilities for coding
    different parts of the system. The whole team can be confident that the system
    will behave as expected as long as the interface requirements are adhered to.
    This approach to software design is sometimes referred to as *loose coupling*:
    the number and form of breakable dependencies among software components are reduced,
    so changes in any one component are much less likely to affect performance or
    require refactoring of other components.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，继承、抽象方法和接口促进了类的可互换性，同时也减轻了软件系统中组件之间的依赖关系。这大大促进了协作软件开发。通过标准化方法签名，同时允许方法实现的灵活性，接口尤其可以成为软件组件之间以及协作开发者之间的合同，每个开发者负责编码系统的不同部分。只要遵循接口要求，整个团队可以确信系统将按预期运行。这种软件设计方法有时被称为*松耦合*：软件组件之间可破坏依赖关系的数量和形式减少，因此任何一个组件的变化不太可能影响性能或需要重构其他组件。
- en: Meanwhile, if your goal is to reduce code duplication, you can use traits to
    offer sets of default method implementations that can be explicitly inserted into
    classes from different hierarchies ❷. For small systems, utility classes, perhaps
    with public static methods, can be another way to offer the same functionality
    to different parts of the system ❶. Traits provide more flexibility (for example,
    a class that inserts a trait may still override a method from that trait with
    its own custom implementation), but the public methods on utility classes are
    more readily exposed for thorough testing.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，如果你的目标是减少代码重复，可以使用特征（traits）提供默认方法实现的集合，这些方法实现可以明确地插入到来自不同层次结构的类中❷。对于小型系统，可能带有公共静态方法的工具类可以是提供相同功能给系统不同部分的另一种方式❶。特征提供了更多的灵活性（例如，插入特征的类仍然可以用自己的自定义实现重写该特征中的方法），但工具类中的公共方法更容易暴露，便于彻底测试。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at several strategies for sharing methods among classes,
    both within and outside the confines of class hierarchies. You saw how abstract
    methods and interfaces enforce method signatures without providing implementations.
    The rest of the application can safely call the relevant methods, regardless of
    the implementation, since the signatures are guaranteed to always be the same.
    You saw this at work when we created a Cacheable interface that allowed us to
    switch approaches to caching (using a static array versus an external JSON file)
    with virtually no impact on the rest of the application code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: You also saw how to use traits to insert fully implemented methods onto unrelated
    classes, while still having the flexibility to override those methods if necessary.
    We harnessed traits to make general-purpose filesystem and JSON-handling methods
    available for any class in our caching project to use. This promoted code reusability
    and allowed us to declare simpler, more narrowly focused classes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Declare a Book class that has the following members:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: A private string title property with get and set methods
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: A private float price property with get and set methods
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: A public getPriceIncludingSalesTax() method that returns a float, calculated
    as price plus 5 percent sales tax
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a main script that creates a Book object and prints its price with and
    without sales tax, like so:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 2.   Refactor your project for Exercise 1 to declare an interface named SalesTaxable
    requiring classes to implement a getPriceIncludingSalesTax() method that returns
    a float. The Book class should implement the SalesTaxable interface.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, declare a Donut class that also implements the SalesTaxable interface
    and has these members:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: A private string topping property with get and set methods
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: A private float price property with get and set methods
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: A public getPriceIncludingSalesTax() method implementing the SalesTaxable interface
    and returning price plus 7 percent sales tax
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, write a main script that creates the following two objects and prints
    their price with and without sales tax:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 3.   Write a TaxFunctions utility class that declares a public static addTaxToPrice()
    method that takes in a float price and float tax rate and returns the value of
    the price with the tax added. Refactor the implementations of the getPriceIncludingSalesTax()
    methods in the Book and Donut classes to use this utility class method, to avoid
    code duplication.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Change your TaxFunctions utility class to a trait, declaring a (nonstatic)
    addTaxToPrice() method. Refactor the Book and Donut classes to insert the trait
    and use its addTaxToPrice() method in their implementations of getPriceIncludingSalesTax().
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 5.   Refactor your project as a class hierarchy, with an abstract SellableItem
    superclass that declares a fully implemented getPriceIncludingSalesTax() method
    with protected visibility. Make Book and Donut subclasses of SellableItem, and
    delete the interface and trait files; they aren’t needed in this design. Sometimes,
    for a simple situation, the simplest solution is the most appropriate.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   将你的项目重构为一个类层次结构，创建一个抽象的SellableItem超类，该类声明一个完全实现的`getPriceIncludingSalesTax()`方法，并设置为受保护可见性。将Book和Donut作为SellableItem的子类，并删除接口和特征文件；在这种设计中它们并不需要。有时，对于简单的情况，最简单的解决方案是最合适的。
