<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 3: Common API Vulnerabilities</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4817cf93-40a6-403c-8355-e951c69da606" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_53" title="53"/>3</span><br/>
<span class="ChapterTitle">Common API Vulnerabilities</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">Understanding common vulnerabilities will help you identify weaknesses when you’re testing APIs. In this chapter, I cover most of the vulnerabilities included in the Open Web Application Security Project (OWASP) API Security Top 10 list, plus two other useful weaknesses: information disclosure and business logic flaws. I’ll describe each vulnerability, its significance, and the techniques used to exploit it. In later chapters, you’ll gain hands-on experience finding and exploiting many of these vulnerabilities.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span epub:type="pagebreak" id="Page_54" title="54"/>OWASP API Security Top 10</h2>
<p class="BoxBodyFirst">OWASP is a nonprofit foundation that creates free content and tools aimed at securing web applications. Due to the increasing prevalence of API vulnerabilities, OWASP released the OWASP API Security Top 10, a list of the 10 most common API vulnerabilities, at the end of 2019. Check out the project, which was led by API security experts Inon Shkedy and Erez Yalon, at <a class="LinkURL" href="https://owasp.org/www-project-api-security">https://owasp.org/www-project-api-security</a>. In <span class="xref" itemid="xref_target_Chapter 15">Chapter 15</span>, I will demonstrate how the vulnerabilities described in the OWASP API Security Top 10 have been exploited in major breaches and bug bounty findings. We’ll also use several OWASP tools to attack APIs in Parts II and III of the book.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-502444c03-0001">Information Disclosure</h2>
<p class="BodyFirst">When an API and its supporting software share sensitive information with unprivileged users, the API has an <em>information disclosure</em> vulnerability. Information may be disclosed in API responses or public sources such as code repositories, search results, news, social media, the target’s website, and public API directories.</p>
<p>Sensitive data can include any information that attackers can leverage to their advantage. For example, a site that is using the WordPress API may unknowingly be sharing user information with anyone who navigates to the API path <em>/wp-json/wp/v2/users</em>, which returns all the WordPress usernames, or “slugs.” For instance, take a look at the following request:</p>
<pre><code>GET https://www.sitename.org/wp-json/wp/v2/users</code></pre>
<p class="BodyContinued">It might return this data:</p>
<pre><code>[{"id":1,"name":"Administrator", "slug":"admin"}],
{"id":2,"name":"Vincent Valentine", "slug":"Vincent"}]</code></pre>
<p>These slugs can then be used in an attempt to log in as the disclosed users with a brute-force, credential-stuffing, or password-spraying attack. (<span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span> describes these attacks in detail.)</p>
<p>Another common information disclosure issue involves verbose messaging. Error messaging helps API consumers troubleshoot their interactions with an API and allows API providers to understand issues with their application. However, it can also reveal sensitive information about resources, users, and the API’s underlying architecture (such as the version of the web server or database). For example, say you attempt to authenticate to an API and receive an error message such as “the provided user ID does not exist.” Next, say you use another email and the error message changes to “incorrect password.” This lets you know that you’ve provided a legitimate user ID for the API.</p>
<p><span epub:type="pagebreak" id="Page_55" title="55"/>Finding user information is a great way to start gaining access to an API. The following information can also be leveraged in an attack: software packages, operating system information, system logs, and software bugs. Generally, any information that can help us find more severe vulnerabilities or assist in exploitation can be considered an information disclosure vulnerability.</p>
<p>Often, you can gather the most information by interacting with an API endpoint and analyzing the response. API responses can reveal information within headers, parameters, and verbose errors. Other good sources of information are API documentation and resources gathered during reconnaissance. <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span> covers many of the tools and techniques used for discovering API information disclosures.</p>
<h2 id="h1-502444c03-0002">Broken Object Level Authorization</h2>
<p class="BodyFirst">One of the most prevalent vulnerabilities in APIs is <em>broken object level authorization (BOLA)</em>. BOLA vulnerabilities occur when an API provider allows an API consumer access to resources they are not authorized to access. If an API endpoint does not have object-level access controls, it won’t perform checks to make sure users can only access their own resources. When these controls are missing, User A will be able to successfully request User B’s resources.</p>
<p>APIs use some sort of value, such as names or numbers, to identify various objects. When we discover these object IDs, we should test to see if we can interact with the resources of other users when unauthenticated or authenticated as a different user. For instance, imagine that we are authorized to access only the user Cloud Strife. We would send an initial GET request to <em>https://bestgame.com/api/v3/users?id=5501</em> and receive the following response:</p>
<pre><code>{
  "id": "5501",
  "first_name": "Cloud",
  "last_name": "Strife",
  "link": "https://www.bestgame.com/user/strife.buster.97",
  "name": "Cloud Strife",
  "dob": "1997-01-31",
  "username": "strife.buster.97"
}</code></pre>
<p>This poses no problem since we are authorized to access Cloud’s information. However, if we are able to access another user’s information, there is a major authorization issue.</p>
<p>In this situation, we might check for these problems by using another identification number that is close to Cloud’s ID of 5501. Say we are able to obtain information about another user by sending a request for <em>https://bestgame.com/api/v3/users?id=5502</em> and receiving the following response:</p>
<pre><code>{
  "id": "5502",
  "first_name": "Zack",
<span epub:type="pagebreak" id="Page_56" title="56"/>  "last_name": "Fair",
  "link": " https://www.bestgame.com/user/shinra-number-1",
  "name": "Zack Fair",
  "dob": "2007-09-13",
  "username": "shinra-number-1"
}</code></pre>
<p>In this case, Cloud has discovered a BOLA. Note that predictable object IDs don’t necessarily indicate that you’ve found a BOLA. For the application to be vulnerable, it must fail to verify that a given user is only able to access their own resources.</p>
<p>In general, you can test for BOLAs by understanding how an API’s resources are structured and attempting to access resources you shouldn’t be able to access. By detecting patterns within API paths and parameters, you should be able to predict other potential resources. The bolded elements in the following API requests should catch your attention:</p>
<pre><code>GET /api/resource/<b>1</b>
GET /user/account/find?user_id=<b>15</b>
POST /company/account/<b>Apple</b>/balance
POST /admin/pwreset/account/<b>90</b></code></pre>
<p>In these instances, you can probably guess other potential resources, like the following, by altering the bolded values:</p>
<pre><code>GET /api/resource/<b>3</b>
GET /user/account/find?user_id=<b>23</b>
POST /company/account/<b>Google</b>/balance
POST /admin/pwreset/account/<b>111</b></code></pre>
<p>In these simple examples, you’ve performed an attack by merely replacing the bolded items with other numbers or words. If you can successfully access information you shouldn’t be authorized to access, you have discovered a BOLA vulnerability.</p>
<p>In <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>, I will demonstrate how you can easily fuzz parameters like <em>user_id=</em> in the URL path and sort through the results to determine if a BOLA vulnerability exists. In <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>, we will focus on attacking authorization vulnerabilities like BOLA and BFLA (broken function level authorization, discussed later in this chapter). BOLA can be a low-hanging API vulnerability that you can easily discover using pattern recognition and then prodding it with a few requests. Other times, it can be quite complicated to discover due to the complexities of object IDs and the requests used to obtain another user’s resources.</p>
<h2 id="h1-502444c03-0003">Broken User Authentication</h2>
<p class="BodyFirst"><em>Broken user authentication</em> refers to <em>any</em> weakness within the API authentication process. These vulnerabilities typically occur when an API provider either doesn’t implement an authentication protection mechanism or implements a mechanism incorrectly.</p>
<p><span epub:type="pagebreak" id="Page_57" title="57"/>API authentication can be a complex system that includes several processes with a lot of room for failure. A couple decades ago, security expert Bruce Schneier said, “The future of digital systems is complexity, and complexity is the worst enemy of security.” As we know from the six constraints of REST APIs discussed in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>, RESTful APIs are supposed to be stateless. In order to be stateless, the provider shouldn’t need to remember the consumer from one request to another. For this constraint to work, APIs often require users to undergo a registration process in order to obtain a unique token. Users can then include the token within requests to demonstrate that they’re authorized to make such requests.</p>
<p>As a consequence, the registration process used to obtain an API token, the token handling, and the system that generates the token could all have their own sets of weaknesses. To determine if the <em>token generation process</em> is weak, for example, we could collect a sampling of tokens and analyze them for similarities. If the token generation process doesn’t rely on a high level of randomness, or entropy, there is a chance we’ll be able to create our own token or hijack someone else’s.</p>
<p><em>Token handling</em> could be the storage of tokens, the method of transmitting tokens across a network, the presence of hardcoded tokens, and so on. We might be able to detect hardcoded tokens in JavaScript source files or capture them as we analyze a web application. Once we’ve captured a token, we can use it to gain access to previously hidden endpoints or to bypass detection. If an API provider attributes an identity to a token, we would then take on the identity by hijacking the stolen token.</p>
<p>The other authentication processes that could have their own set of vulnerabilities include aspects of the <em>registration system</em>, such as the password reset and multifactor authentication features. For example, imagine a password reset feature requires you to provide an email address and a six-digit code to reset your password. Well, if the API allowed you to make as many requests as you wanted, you’d only have to make one million requests in order to guess the code and reset any user’s password. A four-digit code would require only 10,000 requests.</p>
<p>Also watch for the ability to access sensitive resources without being authenticated; API keys, tokens, and credentials used in URLs; a lack of rate-limit restrictions when authenticating; and verbose error messaging. For example, code committed to a GitHub repository could reveal a hardcoded admin API key:</p>
<pre><code>"oauth_client":
[{"client_id": "12345-abcd",
"client_type": "admin",
"api_key": "AIzaSyDrbTFCeb5k0yPSfL2heqdF-N19XoLxdw"}]</code></pre>
<p>Due to the stateless nature of REST APIs, a publicly exposed API key is the equivalent of discovering a username and password. By using an exposed API key, you’ll assume the role associated with that key. In <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>, we will use our reconnaissance skills to find exposed keys across the internet.</p>
<p><span epub:type="pagebreak" id="Page_58" title="58"/>In <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>, we will perform numerous attacks against API authentication, such as authentication bypass, brute-force attacks, credential stuffing, and a variety of attacks against tokens.</p>
<h2 id="h1-502444c03-0004">Excessive Data Exposure</h2>
<p class="BodyFirst"><em>Excessive data exposure</em> is when an API endpoint responds with more information than is needed to fulfill a request. This often occurs when the provider expects the API consumer to filter results; in other words, when a consumer requests specific information, the provider might respond with all sorts of information, assuming the consumer will then remove any data they don’t need from the response. When this vulnerability is present, it can be the equivalent of asking someone for their name and having them respond with their name, date of birth, email address, phone number, and the identification of every other person they know.</p>
<p>For example, if an API consumer requests information for their user account and receives information about other user accounts as well, the API is exposing excessive data. Suppose I requested my own account information with the following request:</p>
<pre><code>GET /api/v3/account?name=Cloud+Strife</code></pre>
<p class="BodyContinued">Now say I got the following JSON in the response:</p>
<pre><code>{
  "id": "5501",
  "first_name": "Cloud",
  "last_name": "Strife",
  "privilege": "user",
       "representative": [

        "name": "Don Corneo",
        "id": "2203"
        "email": "dcorn@gmail.com",
        "privilege": "super-admin"
        "admin": true
        "two_factor_auth": false,
        }</code></pre>
<p>I requested a single user’s account information, and the provider responded with information about the person who created my account, including the administrator’s full name, the admin’s ID number, and whether the admin had two-factor authentication enabled.</p>
<p>Excessive data exposure is one of those awesome API vulnerabilities that bypasses every security control in place to protect sensitive information and hands it all to an attacker on a silver platter simply because they used the API. All you need to do to detect excessive data exposure is test your target API endpoints and review the information sent in response.</p>
<h2 id="h1-502444c03-0005"><span epub:type="pagebreak" id="Page_59" title="59"/>Lack of Resources and Rate Limiting</h2>
<p class="BodyFirst">One of the more important vulnerabilities to test for is <em>lack of resources and rate limiting</em>. Rate limiting plays an important role in the monetization and availability of APIs. Without limiting the number of requests consumers can make, an API provider’s infrastructure could be overwhelmed by the requests. Too many requests without enough resources will lead to the provider’s systems crashing and becoming unavailable—a <em>denial of service (DoS)</em> state.</p>
<p>Besides potentially DoS-ing an API, an attacker who bypasses rate limits can cause additional costs for the API provider. Many API providers monetize their APIs by limiting requests and allowing paid customers to request more information. RapidAPI, for example, allows for 500 requests per month for free but 1,000 requests per month for paying customers. Some API providers also have infrastructure that automatically scales with the quantity of requests. In these cases, an unlimited number of requests would lead to a significant and easily preventable increase in infrastructure costs.</p>
<p>When testing an API that is supposed to have rate limiting, the first thing you should check is that rate limiting works, and you can do so by sending a barrage of requests to the API. If rate limiting is functioning, you should receive some sort of response informing you that you’re no longer able to make additional requests, usually in the form of an HTTP 429 status code.</p>
<p>Once you are restricted from making additional requests, it’s time to attempt to see how rate limiting is enforced. Can you bypass it by adding or removing a parameter, using a different client, or altering your IP address? <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span> includes various measures for attempting to bypass rate limiting.</p>
<h2 id="h1-502444c03-0006">Broken Function Level Authorization</h2>
<p class="BodyFirst"><em>Broken function level authorization (BFLA)</em> is a vulnerability where a user of one role or group is able to access the API functionality of another role or group. API providers will often have different roles for different types of accounts, such as public users, merchants, partners, administrators, and so on. A BFLA is present if you are able to use the functionality of another privilege level or group. In other words, BFLA can be a lateral move, where you use the functions of a similarly privileged group, or it could be a privilege escalation, where you are able to use the functions of a more privileged group. Particularly interesting API functions to access include those that deal with sensitive information, resources that belong to another group, and administrative functionality such as user account management.</p>
<p>BFLA is similar to BOLA, except instead of an authorization problem involving accessing resources, it is an authorization problem for performing actions. For example, consider a vulnerable banking API. When a BOLA vulnerability is present in the API, you might be able to access the information of other accounts, such as payment histories, usernames, email addresses, and account numbers. If a BFLA vulnerability is present, you might be able to transfer money and actually update the account information. BOLA is about unauthorized access, whereas BFLA is about unauthorized actions.</p>
<p><span epub:type="pagebreak" id="Page_60" title="60"/>If an API has different privilege levels or roles, it may use different endpoints to perform privileged actions. For example, a bank may use the <em>/{user}/account/balance</em> endpoint for a user wishing to access their account information and the <em>/admin/account/{user}</em> endpoint for an administrator wishing to access user account information. If the application does not have access controls implemented correctly, we’ll be able to perform administrative actions, such as seeing a user’s full account details, by simply making administrative requests.</p>
<p>An API won’t always use administrative endpoints for administrative functionality. Instead, the functionality could be based on HTTP request methods such as GET, POST, PUT, and DELETE. If a provider doesn’t restrict the HTTP methods a consumer can use, simply making an unauthorized request with a different method could indicate a BFLA vulnerability.</p>
<p>When hunting for BFLA, look for any functionality you could use to your advantage, including altering user accounts, accessing user resources, and gaining access to restricted endpoints. For example, if an API gives partners the ability to add new users to the partner group but does not restrict this functionality to the specific group, any user could add themselves to any group. Moreover, if we’re able to add ourselves to a group, there is a good chance we’ll be able to access that group’s resources.</p>
<p>The easiest way to discover BFLA is to find administrative API documentation and send requests as an unprivileged user that test admin functions and capabilities. <a href="#figure3-1" id="figureanchor3-1">Figure 3-1</a> shows the public Cisco Webex Admin API documentation, which provides a handy list of actions to attempt if you were testing Cisco Webex.</p>
<figure>
<img alt="Screenshot of a Cisco Webex documentation page titled “Admin API.” Includes links to a list of APIs for various actions, including “Create a user,” “Update a user,” “View license usage of an organization,” “View available roles of an organization,” “Manage Hybrid Services licenses and users,” and “View information about Hybrid Clusters or Hybrid Connectors.”" class="keyline" src="image_fi/502444c03/F03001.png"/>
<figcaption><p><a id="figure3-1">Figure 3-1</a>: The Cisco Webex Admin API documentation</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_61" title="61"/>As an unprivileged user, make requests included in the admin section, such as attempting to create users, update user accounts, and so on. If access controls are in place, you’ll likely receive an HTTP 401 Unauthorized or 403 Forbidden response. However, if you’re able to make successful requests, you have discovered a BFLA vulnerability.</p>
<p>If API documentation for privileged actions is not available, you will need to discover or reverse engineer the endpoints used to perform privileged actions before testing them; more on this in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>. Once you’ve found administrative endpoints, you can begin making requests.</p>
<h2 id="h1-502444c03-0007">Mass Assignment</h2>
<p class="BodyFirst"><em>Mass assignment</em> occurs when an API consumer includes more parameters in their requests than the application intended and the application adds these parameters to code variables or internal objects. In this situation, a consumer may be able to edit object properties or escalate privileges.</p>
<p>For example, an application might have account update functionality that the user should use only to update their username, password, and address. If the consumer can include other parameters in a request related to their account, such as the account privilege level or sensitive information like account balances, and the application accepts those parameters without checking them against a whitelist of permitted actions, the consumer could take advantage of this weakness to change these values.</p>
<p>Imagine an API is called to create an account with parameters for <code>"User"</code> and <code>"Password"</code>:</p>
<pre><code>{
"User": "scuttleph1sh",
"Password": "GreatPassword123"
}</code></pre>
<p>While reading the API documentation regarding the account creation process, suppose you discover that there is an additional key, <code>"isAdmin"</code>, that consumers can use to become administrators. You could use a tool like Postman or Burp Suite to add the attribute to a request and set the value to <code>true</code>:</p>
<pre><code>{
"User": "scuttleph1sh",
"Password": "GreatPassword123",
"isAdmin": true
}</code></pre>
<p>If the API does not sanitize the request input, it is vulnerable to mass assignment, and you could use the updated request to create an admin account. On the backend, the vulnerable web app will add the key/value attribute, <code>{"isAdmin":"true"}</code>, to the user object and make the user the equivalent of an administrator.</p>
<p><span epub:type="pagebreak" id="Page_62" title="62"/>You can discover mass assignment vulnerabilities by finding interesting parameters in API documentation and then adding those parameters to a request. Look for parameters involved in user account properties, critical functions, and administrative actions. Intercepting API requests and responses could also reveal parameters worthy of testing. Additionally, you can guess parameters or fuzz them in API requests. (<span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span> describes the art of fuzzing.)</p>
<h2 id="h1-502444c03-0008">Security Misconfigurations</h2>
<p class="BodyFirst"><em>Security misconfigurations</em> include all the mistakes developers could make within the supporting security configurations of an API. If a security misconfiguration is severe enough, it can lead to sensitive information exposure or a complete system takeover. For example, if the API’s supporting security configuration reveals an unpatched vulnerability, there is a chance that an attacker could leverage a published exploit to easily “pwn” the API and its system.</p>
<p>Security misconfigurations are really a set of weaknesses that includes misconfigured headers, misconfigured transit encryption, the use of default accounts, the acceptance of unnecessary HTTP methods, a lack of input sanitization, and verbose error messaging.</p>
<p>A <em>lack of input sanitization</em> can allow attackers to upload malicious payloads to the server. APIs often play a key role in automating processes, so imagine being able to upload payloads that the server automatically processes into a format that could be remotely executed or executed by an unsuspecting end user. For example, if an upload endpoint was used to pass uploaded files to a web directory, it could allow the upload of a script. Navigating to the URL where the file is located could launch the script, resulting in direct shell access to the web server. Additionally, lack of input sanitization can lead to unexpected behavior on the part of the application. In <span class="xref" itemid="xref_target_Part III">Part III</span>, we will fuzz API inputs in attempts to discover vulnerabilities such as security misconfigurations, improper assets management, and injection weaknesses.</p>
<p>API providers use <em>headers</em> to provide the consumer with instructions for handling the response and security requirements. Misconfigured headers can result in sensitive information disclosure, downgrade attacks, and cross-site scripting attacks. Many API providers will use additional services alongside their API to enhance API-related metrics or to improve security. It is fairly common for those additional services to add headers to requests for metrics and perhaps serve as some level of assurance to the consumer. For example, take the following response:</p>
<pre><code>HTTP/ 200 OK
<var>--snip--</var>
<b>X-Powered-By: VulnService 1.11</b>
<b>X-XSS-Protection: 0</b>
<b>X-Response-Time: 566.43</b></code></pre>
<p><span epub:type="pagebreak" id="Page_63" title="63"/>The <code>X-Powered-By</code> header reveals backend technology. Headers like this one will often advertise the exact supporting service and its version. You could use information like this to search for exploits published for that version of software.</p>
<p><code>X-XSS-Protection</code> is exactly what it looks like: a header meant to prevent cross-site scripting (XSS) attacks. XSS is a common type of injection vulnerability where an attacker can insert scripts into a web page and trick end users into clicking malicious links. We will cover XSS and cross-API scripting (XAS) in <span class="xref" itemid="xref_target_Chapter 12">Chapter 12</span>. An <code>X-XSS-Protection</code> value of <code>0</code> indicates no protections are in place, and a value of <code>1</code> indicates that protection is turned on. This header, and others like it, clearly reveals whether a security control is in place.</p>
<p>The <code>X-Response-Time</code> header is middleware that provides usage metrics. In the previous example, its value represents 566.43 milliseconds. However, if the API isn’t configured properly, this header can function as a side channel used to reveal existing resources. If the <code>X-Response-Time</code> header has a consistent response time for nonexistent records, for example, but increases its response time for certain other records, this could be an indication that those records exist. Here’s an example:</p>
<pre><code>HTTP/<b>UserA</b> 404 Not Found
<var>--snip--</var>
<b>X-Response-Time: 25.5</b>

HTTP/<b>UserB</b> 404 Not Found
<var>--snip--</var>
<b>X-Response-Time: 25.5</b>

HTTP/<b>UserC </b>404 Not Found
<var>--snip--</var>
<b>X-Response-Time: 510.00</b></code></pre>
<p>In this case, UserC has a response time value that is 20 times the response time of the other resources. With this small sample size, it is hard to definitively conclude that UserC exists. However, imagine you have a sample of hundreds or thousands of requests and know the average <code>X-Response-Time</code> values for certain existing and nonexistent resources. Say, for instance, you know that a bogus account like <em>/user/account/thisdefinitelydoesnotexist876</em> has an average <code>X-Response-Time</code> of 25.5 ms. You also know that your existing account <em>/user/account/1021</em> receives an <code>X-Response-Time</code> of 510.00. If you then sent requests brute-forcing all account numbers from 1000 to 2000, you could review the results and see which account numbers resulted in drastically increased response times.</p>
<p>Any API providing sensitive information to consumers should use Transport Layer Security (TLS) to encrypt the data. Even if the API is only provided internally, privately, or at a partner level, using TLS, the protocol that encrypts HTTPS traffic, is one of the most basic ways to ensure that API requests and responses are protected when being passed across a network. Misconfigured or missing transit encryption can cause API users to pass sensitive API information in cleartext across networks, in which case <span epub:type="pagebreak" id="Page_64" title="64"/>an attacker could capture the responses and requests with a man-in-the-middle (MITM) attack and read them plainly. The attacker would need to have access to the same network as the person they were attacking and then intercept the network traffic with a network protocol analyzer such as Wireshark to see the information being communicated between the consumer and the provider.</p>
<p>When a service uses a <em>default account and credentials</em> and the defaults are known, an attacker can use those credentials to assume the role of that account. This could allow them to gain access to sensitive information or administrative functionality, potentially leading to a compromise of the supporting systems.</p>
<p>Lastly, if an API provider allows <em>unnecessary HTTP methods</em>, there is an increased risk that the application won’t handle these methods properly or will result in sensitive information disclosure.</p>
<p>You can detect several of these security misconfigurations with web application vulnerability scanners such as Nessus, Qualys, OWASP ZAP, and Nikto. These scanners will automatically check the web server version information, headers, cookies, transit encryption configuration, and parameters to see if expected security measures are missing. You can also check for these security misconfigurations manually, if you know what you are looking for, by inspecting the headers, SSL certificate, cookies, and parameters.</p>
<h2 id="h1-502444c03-0009">Injections</h2>
<p class="BodyFirst"><em>Injection flaws</em> exist when a request is passed to the API’s supporting infrastructure and the API provider doesn’t filter the input to remove unwanted characters (a process known as <em>input sanitization</em>). As a result, the infrastructure might treat data from the request as code and run it. When this sort of flaw is present, you’ll be able to conduct injection attacks such as SQL injection, NoSQL injection, and system command injection.</p>
<p>In each of these injection attacks, the API delivers your unsanitized payload directly to the operating system running the application or its database. As a result, if you send a payload containing SQL commands to a vulnerable API that uses a SQL database, the API will pass the commands to the database, which will process and perform the commands. The same will happen with vulnerable NoSQL databases and affected systems.</p>
<p>Verbose error messaging, HTTP response codes, and unexpected API behavior can all be clues that you may have discovered an injection flaw. Say, for example, you were to send <code>OR 1=0--</code> as an address in an account registration process. The API may pass that payload directly to the backend SQL database, where the <code>OR 1=0</code> statement would fail (because 1 does not equal 0), causing some SQL error:</p>
<pre><code>POST /api/v1/register HTTP 1.1
Host: example.com
<var>--snip--</var>
{
"Fname": "hAPI",
<span epub:type="pagebreak" id="Page_65" title="65"/>"Lname": "Hacker",
"Address": <b>"' OR 1=0--"</b>,
}</code></pre>
<p>An error in the backend database could show up as a response to the consumer. In this case, you might receive a response like “Error: You have an error in your SQL syntax. . . .” Any response directly from a database or the supporting system is a clear indicator that there is an injection vulnerability.</p>
<p>Injection vulnerabilities are often complemented by other vulnerabilities such as poor input sanitization. In the following example, you can see a code injection attack that uses an API GET request to take advantage of a weak query parameter. In this case, the weak query parameter passes any data in the query portion of the request directly to the underlying system, without sanitizing it first:</p>
<pre><code>GET http://10.10.78.181:5000/api/v1/resources/books?show=/etc/passwd</code></pre>
<p>The following response body shows that the API endpoint has been manipulated into displaying the host’s <em>/etc/passwd</em> file, revealing users on the system:</p>
<pre><code>root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin</code></pre>
<p>Finding injection flaws requires diligently testing API endpoints, paying attention to how the API responds, and then crafting requests that attempt to manipulate the backend systems. Like directory traversal attacks, injection attacks have been around for decades, so there are many standard security controls to protect API providers from them. I will demonstrate various methods for performing injection attacks, encoding traffic, and bypassing standard controls in <span class="xref" itemid="xref_target_Chapters 12">Chapters 12</span> and <span class="xref" itemid="xref_target_13">13</span>.</p>
<h2 id="h1-502444c03-0010">Improper Assets Management</h2>
<p class="BodyFirst"><em>Improper assets management</em> takes place when an organization exposes APIs that are either retired or still in development. As with any software, old API versions are more likely to contain vulnerabilities because they are no longer being patched and upgraded. Likewise, APIs that are still being developed are typically not as secure as their production API counterparts.</p>
<p>Improper assets management can lead to other vulnerabilities, such as excessive data exposure, information disclosure, mass assignment, improper rate limiting, and API injection. For attackers, this means that <span epub:type="pagebreak" id="Page_66" title="66"/>discovering an improper assets management vulnerability is only the first step toward further exploitation of an API.</p>
<p>You can discover improper assets management by paying close attention to outdated API documentation, changelogs, and version history on repositories. For example, if an organization’s API documentation has not been updated along with the API’s endpoints, it could contain references to portions of the API that are no longer supported. Organizations often include versioning information in their endpoint names to distinguish between older and newer versions, such as <em>/v1/</em>, <em>/v2/</em>, <em>/v3/</em>, and so on. APIs still in development often use paths such as <em>/alpha/</em>, <em>/beta/</em>, <em>/test/</em>, <em>/uat/</em>, and <em>/demo/</em>. If you know that an API is now using <em>apiv3.org/admin</em> but part of the API documentation refers to <em>apiv1.org/admin</em>, you could try testing different endpoints to see if <em>apiv1 </em>or <em>apiv2</em> is still active. Additionally, the organization’s changelog may disclose the reasons why <em>v1</em> was updated or retired. If you have access to <em>v1</em>, you can test for those weaknesses.</p>
<p>Outside of using documentation, you can discover improper assets management vulnerabilities through the use of guessing, fuzzing, or brute-force requests. Watch for patterns in the API documentation or path-naming scheme, and then make requests based on your assumptions.</p>
<h2 id="h1-502444c03-0011">Business Logic Vulnerabilities</h2>
<p class="BodyFirst"><em>Business logic vulnerabilities </em>(also known as <em>business logic flaws</em>, or<em> BLFs</em>) are intended features of an application that attackers can use maliciously. For example, if an API has an upload feature that doesn’t validate encoded payloads, a user could upload any file as long as it was encoded. This would allow end users to upload and execute arbitrary code, including malicious payloads.</p>
<p>Vulnerabilities of this sort normally come about from an assumption that API consumers will follow directions, be trustworthy, or only use the API in a certain way. In those cases, the organization essentially depends on trust as a security control by expecting the consumer to act benevolently. Unfortunately, even good-natured API consumers make mistakes that could lead to a compromise of the application.</p>
<p>The Experian partner API leak, in early 2021, was a great example of an API trust failure. A certain Experian partner was authorized to use Experian’s API to perform credit checks, but the partner added the API’s credit check functionality to their web application and inadvertently exposed all partner-level requests to users. A request could be intercepted when using the partner’s web application, and if it included a name and address, the Experian API would respond with the individual’s credit score and credit risk factors. One of the leading causes of this business logic vulnerability was that Experian trusted the partner not to expose the API.</p>
<p>Another problem with trust is that credentials, such as API keys, tokens, and passwords, are constantly being stolen and leaked. When a trusted consumer’s credentials are stolen, the consumer can become a wolf in sheep’s <span epub:type="pagebreak" id="Page_67" title="67"/>clothing and wreak havoc. Without strong technical controls in place, business logic vulnerabilities can often have the most significant impact, leading to exploitation and compromise.</p>
<p>You can search API documentation for telltale signs of business logic vulnerabilities. Statements like the following should illuminate the lightbulb above your head:</p>
<ol class="none">
<li>“Only use feature X to perform function Y.”</li>
<li>“Do not do X with endpoint Y.”</li>
<li>“Only admins should perform request X.”</li>
</ol>
<p>These statements may indicate that the API provider is trusting that you won’t do any of the discouraged actions, as instructed. When you attack their API, make sure to disobey such requests to test for the presence of security controls.</p>
<p>Another business logic vulnerability comes about when developers assume that consumers will exclusively use a browser to interact with the web application and won’t capture API requests that take place behind the scenes. All it takes to exploit this sort of weakness is to intercept requests with a tool like Burp Suite Proxy or Postman and then alter the API request before it is sent to the provider. This could allow you to capture shared API keys or use parameters that could negatively impact the security of the application.</p>
<p>As an example, consider a web application authentication portal that a user would normally employ to authenticate to their account. Say the web application issued the following API request:</p>
<pre><code>POST /api/v1/login HTTP 1.1
Host: example.com
<var>--snip--</var>
UserId=hapihacker&amp;password=arealpassword!&amp;<b>MFA=true</b></code></pre>
<p>There is a chance that we could bypass multifactor authentication by simply altering the parameter <code>MFA</code> to <code>false</code>.</p>
<p>Testing for business logic flaws can be challenging because each business is unique. Automated scanners will have a difficult time detecting these issues, as the flaws are part of the API’s intended use. You must understand how the business and API operate and then consider how you could use these features to your advantage. Study the application’s business logic with an adversarial mindset, and try breaking any assumptions that have been made.</p>
<h2 id="h1-502444c03-0012">Summary</h2>
<p class="BodyFirst">In this chapter, I covered common API vulnerabilities. It is important to become familiar with these vulnerabilities so that you can easily recognize them, take advantage of them during an engagement, and report them <span epub:type="pagebreak" id="Page_68" title="68"/>back to the organization to prevent the criminals from dragging your client into the headlines.</p>
<p>Now that you are familiar with web applications, APIs, and their weaknesses, it is time to prepare your hacking machine and get your hands busy on the keyboard.</p>
</section>
</body>
</html>