- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">TLS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: The *Transport Layer Security (TLS) protocol* is the workhorse of internet security.
    TLS protects connections between servers and clients, whether between a website
    and its visitors, email servers, a mobile application and its servers, or video
    game servers and players. Without TLS, the internet wouldn’t be very secure.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: TLS is application agnostic, meaning you can use it for web-based applications
    that rely on the HTTP protocol, as well as for any system where a client computer
    or device needs to initiate a connection with a remote server. For example, TLS
    is widely used for machine-to-machine communications in internet of things (IoT)
    applications, such as smart refrigerators that communicate with remote servers.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides an abbreviated view of TLS, which has become increasingly
    complex over the years. Unfortunately, complexity and bloat brought multiple vulnerabilities,
    and bugs found in its cluttered implementations have made headlines—Heartbleed,
    BEAST, CRIME, and POODLE are all vulnerabilities that impacted millions of web
    servers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You may see folks refer to TLS as* Secure Sockets Layer (SSL)*, which is the
    name of its predecessor.*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: In 2013, engineers started working on TLS 1.3\. As you’ll learn in this chapter,
    TLS 1.3 ditched unnecessary and insecure features and replaced old algorithms
    with then state-of-the-art ones. The result is a simpler, faster, and more secure
    protocol.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Before we explore how TLS 1.3 works, let’s review the problem that TLS aims
    to solve and the reason for its existence.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Target Applications and Requirements</samp>
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TLS is the *S* in HTTPS websites, and the padlock that appears in a browser’s
    address bar indicates that a page is secure. The primary driver for creating TLS
    was to enable secure browsing in applications such as e-commerce or e-banking,
    by authenticating the site and encrypting traffic to protect sensitive information
    such as personal data, credit card numbers, and user credentials.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: TLS also helps protect general internet-based communication by establishing
    a *secure channel* between a client and a server that ensures the data transferred
    is confidential, authenticated, and unmodified.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: One of TLS’s security goals is to prevent man-in-the-middle attacks, wherein
    an attacker intercepts encrypted traffic from the transmitting party, decrypts
    the traffic to capture the clear content, and reencrypts it to send to the receiving
    party. TLS defeats these attacks by authenticating servers (and optionally clients)
    using certificates and trusted certificate authorities, as we’ll discuss in “Certificates
    and Certificate Authorities” on [page 258](#sec5).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure wide adoption, TLS needed to satisfy four more requirements: efficiency,
    interoperability, extensibility, and versatility. For TLS, efficiency means minimizing
    the performance penalty compared with unencrypted connections. This is good for
    both the server (to reduce the cost of hardware for the service providers) and
    the clients (to avoid perceptible delays or the reduction of the battery life
    of mobile devices). The protocol needed to be interoperable so that it would work
    on any hardware and any operating system. It was to be extensible so that it could
    support additional features or algorithms. And it had to be versatile—that is,
    not bound to a specific application. This parallels the Transport Control Protocol
    (TCP), which doesn’t care about the application protocol used on top of it.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保广泛采用，TLS 需要满足四个额外的要求：效率、互操作性、可扩展性和多功能性。对于 TLS，效率意味着尽量减少与未加密连接相比的性能损失。这对服务器（减少服务提供商硬件成本）和客户端（避免明显的延迟或减少移动设备的电池寿命）都有好处。该协议需要具备互操作性，以便能够在任何硬件和任何操作系统上工作。它还必须具备可扩展性，以便支持额外的功能或算法。最后，它必须是多功能的——也就是说，不局限于某个特定的应用程序。这与传输控制协议（TCP）相似，TCP
    不关心其上层应用协议是什么。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The TLS Protocol Suite</samp>
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">TLS 协议套件</samp>
- en: To protect client-server communications, TLS consists of multiple versions of
    several protocols that form the TLS protocol *suite*. TLS is not a transport protocol
    and usually sits between the transport protocol (TCP) and an application layer
    protocol such as HTTP or SMTP, to secure data transmitted over a TCP connection.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护客户端和服务器之间的通信，TLS 由多个版本的几个协议组成，形成了 TLS 协议的 *套件*。TLS 不是一个传输协议，通常位于传输协议（TCP）和应用层协议（如
    HTTP 或 SMTP）之间，以加密通过 TCP 连接传输的数据。
- en: TLS also works over the *User Datagram Protocol (UDP)* transport protocol, which
    is used for “connectionless” transmissions when latency must be minimal, such
    as audio or video streaming and online gaming. However, unlike TCP, UDP doesn’t
    guarantee delivery or correct packet ordering. The UDP version of TLS, *Datagram
    Transport Layer Security (DTLS)*, is therefore slightly different. For more on
    TCP and UDP, see Charles Kozierok’s *The TCP/IP Guide* (No Starch Press, 2005).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 也可以在 *用户数据报协议 (UDP)* 传输协议上工作，这通常用于“无连接”传输，尤其是在延迟必须最小化的场景中，如音频或视频流媒体以及在线游戏。然而，与
    TCP 不同，UDP 不保证数据的传输或正确的包排序。因此，TLS 的 UDP 版本——*数据报传输层安全协议 (DTLS)*——有所不同。关于 TCP 和
    UDP 的更多信息，请参见 Charles Kozierok 的 *《TCP/IP指南》*（No Starch Press，2005年）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The TLS and SSL Families
    of Protocols</samp>
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">TLS 和 SSL 协议家族</samp>
- en: TLS began in 1995 when Netscape developed TLS’s ancestor, the SSL protocol.
    SSL was far from perfect, and both SSL 2.0 and SSL 3.0 had security flaws. You
    should never use SSL, and you should always use TLS—what adds to the confusion
    is that people often refer to TLS as SSL, including security experts.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 始于1995年，当时 Netscape 开发了 TLS 的前身——SSL 协议。SSL 远非完美，SSL 2.0 和 SSL 3.0 都存在安全漏洞。你永远不应该使用
    SSL，而应该始终使用 TLS——令人困惑的是，人们常常将 TLS 称为 SSL，包括安全专家。
- en: Not all versions of TLS are secure. TLS 1.0 (1999) is the least secure version,
    though it’s still more secure than SSL 3.0\. TLS 1.1 (2006) is better but includes
    a number of weak algorithms. TLS 1.2 (2008) is better yet, but it’s complex and
    provides high security only if configured correctly. Also, its complexity increases
    the risk of bugs in implementations and the risk of incorrect configurations.
    For example, TLS 1.2 supports AES in CBC mode, which is often vulnerable to padding
    oracle attacks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有版本的 TLS 都是安全的。TLS 1.0（1999年）是最不安全的版本，尽管它比 SSL 3.0 更安全。TLS 1.1（2006年）更好，但包含了一些弱算法。TLS
    1.2（2008年）更好，但它复杂，只有在正确配置的情况下才能提供高安全性。此外，它的复杂性增加了实现中的错误风险和配置错误的风险。例如，TLS 1.2 支持
    AES 在 CBC 模式下，这常常容易受到填充 oracle 攻击。
- en: TLS 1.2 inherited dozens of features and design choices from earlier versions
    of TLS that make it suboptimal in terms of security and performance. To clean
    up this mess, cryptography engineers reinvented TLS—keeping only the good parts
    and adding security features. The result is TLS 1.3, an overhaul that’s simplified
    a bloated design and made it more secure, more efficient, and simpler. Essentially,
    TLS 1.3 is mature TLS.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.2 继承了 TLS 较早版本的数十个特性和设计选择，这使得其在安全性和性能方面并不理想。为了整顿这一混乱局面，密码学工程师重新设计了 TLS——只保留了优秀的部分并添加了安全功能。结果是
    TLS 1.3，这是一次全面革新，简化了臃肿的设计并提升了安全性和效率。本质上，TLS 1.3 是成熟的 TLS。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">TLS in a Nutshell</samp>
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">TLS 简介</samp>
- en: 'TLS has two main protocols: the *handshake protocol* (or just *handshake*)
    determines the secret keys shared between the two parties; the *record protocol*
    describes how to use these keys to protect data. The data packets TLS processes
    are called *records*. TLS defines a packet format for encapsulating data from
    higher-layer protocols for transmission to another party.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 有两个主要协议：*握手协议*（或简称*握手*）确定了双方共享的密钥；*记录协议*描述了如何使用这些密钥来保护数据。TLS 处理的数据包称为*记录*。TLS
    定义了一种封装来自更高层协议数据的数据包格式，以便传输到另一方。
- en: The handshake starts with a client that initiates a secure connection with a
    server. The client sends an initial message called ClientHello with parameters
    that include the cipher it wants to use. The server checks this message and its
    parameters and then responds with a ServerHello message. Once the client and the
    server process each other’s messages, they’re ready to exchange encrypted data
    using session keys established through the handshake protocol, as you’ll see in
    “The TLS Handshake Protocol” on [page 263](#sec10).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 握手由启动安全连接的客户端开始。客户端发送一个称为 ClientHello 的初始消息，其中包含它希望使用的密码。服务器检查此消息及其参数，然后响应一个
    ServerHello 消息。一旦客户端和服务器处理彼此的消息，它们就可以使用通过握手协议建立的会话密钥交换加密数据，详见“TLS 握手协议”第[263页](#sec10)。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Certificates
    and Certificate Authorities</samp>'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">证书和证书颁发机构</samp>'
- en: The most critical step in the TLS handshake, and the crux of TLS’s security,
    is the *certificate validation step*, wherein a server uses a certificate to authenticate
    itself to a client.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 握手中最关键的步骤，也是 TLS 安全性的核心，是*证书验证步骤*，在此步骤中，服务器使用证书向客户端进行身份验证。
- en: A *certificate* is essentially a public key accompanied by a signature of that
    key and associated information (including the domain name). For example, when
    connecting to *[https://<wbr>www<wbr>.google<wbr>.com](https://www.google.com)*,
    your browser receives a certificate from some network host and then verifies the
    certificate’s signature, which reads something like “I am *google.com*, and my
    public key is [*key*].” If the signature is verified, the certificate and its
    public key are *trusted*, and the browser proceeds with establishing the connection.
    (See [Chapters 10](chapter10.xhtml) and [12](chapter12.xhtml) for details regarding
    signatures.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*证书*本质上是一对公钥及其签名以及相关信息（包括域名）。例如，当连接到*[https://<wbr>www<wbr>.google<wbr>.com](https://www.google.com)*时，您的浏览器从某个网络主机接收证书，然后验证证书的签名，其内容类似于“我是*google.com*，我的公钥是[*key*]”。如果签名验证成功，证书及其公钥就是*受信任的*，浏览器会继续建立连接。（有关签名的详细信息，请参阅[第10章](chapter10.xhtml)和[第12章](chapter12.xhtml)。）'
- en: The browser knows the public key needed to verify the signature through a *certificate
    authority (CA)*, which is essentially a public key hardcoded in your browser or
    operating system. The public key’s private key (that is, its signing capability)
    belongs to a trusted organization that ensures the public keys in certificates
    it issues belong to the website or entity that claims them. That is, a CA acts
    as a *trusted third party*. Without CAs, there’s no way to verify that the public
    key served by *google.com* belongs to Google and not to an eavesdropper performing
    a man-in-the-middle attack.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器通过*证书颁发机构（CA）*知道用于验证签名的公钥，这本质上是在浏览器或操作系统中硬编码的公钥。公钥的私钥（即其签名能力）属于一个受信任的组织，该组织确保其签发的证书中的公钥属于声称拥有它们的网站或实体。换句话说，CA
    充当*受信任的第三方*。如果没有 CA，就无法验证由*google.com*提供的公钥是否属于 Google 而不是中间人进行的中间人攻击。
- en: For example, [Listing 13-1](chapter13.xhtml#Lis13-1) shows what happens when
    you use the OpenSSL command line tool to initiate a TLS connection to *www.google.com*
    on port 443, the network port used for TLS-based HTTP connections (HTTPS).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-1: Establishing
    a TLS connection with</samp> <samp class="SANS_Futura_Std_Book_11">[www<wbr>.google<wbr>.com](http://www.google.com)</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and receiving certificates to
    authenticate the connection</samp>'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The certificate data is between the <samp class="SANS_TheSansMonoCd_W5Regular_11">BEGIN
    CERTIFICATE</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">END CERTIFICATE</samp>
    markers. Before this, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Certificate
    chain</samp> contains a description of the certificate chain, wherein the lines
    beginning with <samp class="SANS_TheSansMonoCd_W5Regular_11">s:</samp> describe
    the *subject* of the certified entity, and the lines beginning with <samp class="SANS_TheSansMonoCd_W5Regular_11">i:</samp>
    describe the *issuer* of the signature. Certificate number 0 is received by *[www<wbr>.google<wbr>.com](http://www.google.com)*,
    certificate 1 belongs to the entity that signed certificate 0, and certificate
    2 belongs to the entity that signed certificate 1.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The organization that issued certificate 0 is Google (via the Google Trust Services
    entity, GTS), which authorized the issuance of certificate 0 for the domain name
    *[www<wbr>.google<wbr>.com](http://www.google.com)* by signing the certificate
    with the private key GTS CA 1C3\. The certificate attesting that this key belongs
    to the Google key hierarchy is certificate 1, which is signed by the GTS key Root
    R1, a root certificate within Google. Certificate 2, issued by GlobalSign (a recognized
    certification authority), attests that the GTS Root R1 key belongs to the Google
    organization.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, your operating system usually already has certificates 1 and
    2, which it considers trusted certificates. In such a case, you just need to check
    two signatures: Google’s GTS CA 1C3 entity in certificate 0 and Google’s GTS Root
    R1 entity in certificate 1\. If your system doesn’t already include certificate
    2 as a trusted certificate but has GlobalSign’s root certificate (GlobalSign Root
    CA), then you’ll also need to check GlobalSign’s signature in certificate 2.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Certificate authority organizations such as Google and GlobalSign must be trustworthy
    and issue certificates only to trustworthy entities, and they must protect their
    private keys in order to prevent an attacker from issuing certificates on their
    behalf (for example, to impersonate a legitimate *[www<wbr>.google<wbr>.com](http://www.google.com)*
    server).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: To see what’s in a certificate, enter the command <samp class="SANS_TheSansMonoCd_W7Bold_B_11">openssl
    x509 -text -noout</samp> in a Unix terminal and then paste the certificate in
    [Listing 13-1](chapter13.xhtml#Lis13-1). The output appears in [Listing 13-2](chapter13.xhtml#Lis13-2).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-2: Decoding a certificate
    received from</samp> <samp class="SANS_Futura_Std_Book_11">[www<wbr>.google<wbr>.com](http://www.google.com)</samp>'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: This listing shows the command <samp class="SANS_TheSansMonoCd_W5Regular_11">openssl
    x509</samp> decoding a certificate, originally provided as a block of base64-encoded
    data. Because OpenSSL knows the structure of this data, it can tell you what’s
    inside the certificate, including a serial number and version information, identifying
    information, validity dates (the <samp class="SANS_TheSansMonoCd_W5Regular_11">Not
    Before</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Not After</samp>
    lines), a public key (here as an RSA modulus and its public exponent), and a signature
    of the preceding information.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Although security experts and cryptographers often claim the whole certificate
    system is inherently broken, it’s one of the best solutions we have, along with
    the trust-on-first-use (TOFU) policy adopted by SSH, for example.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Record Protocol</samp>
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All data exchanged through TLS 1.3 communications is transmitted as sequences
    of TLS records, the data packets used by TLS. The TLS record protocol (the *record
    layer*) is essentially a transport protocol, agnostic of the transported data’s
    meaning; this makes TLS suitable for any application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The TLS record protocol first carries the data exchanged during the handshake.
    Once the handshake is complete and both parties share a secret key, application
    data is fragmented into chunks that transmit as part of the TLS records.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Structure of a TLS Record</samp>
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A TLS record is a chunk of data of at most 16KB with the following structure:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The first byte represents the type of data transmitted and is set to the value
    <samp class="SANS_TheSansMonoCd_W5Regular_11">22</samp> for handshake data, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">23</samp> for encrypted data, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">21</samp> for alerts. The TLS 1.3 specifications
    call this value ContentType.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second and third bytes are set to <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>, respectively. These
    bytes are fixed for historical reasons and aren’t unique to TLS version 1.3\.
    The specifications call this 2-byte value ProtocolVersion.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth and fifth bytes encode the length of the data to transmit as a 16-bit
    integer, which can be no larger than 2^(14) bytes (16KB).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the bytes are the data to transmit (or the *payload*), of a length
    equal to the value encoded by the record’s fourth and fifth bytes.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*A TLS record has a relatively simple structure. As you’ve seen, a TLS record’s
    header includes only three fields. For comparison, an IPv4 packet includes 14
    fields before its payload, and a TCP segment includes 13 fields.*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'When the first byte of a TLS 1.3 record (ContentType) is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">23</samp>,
    an authenticated cipher encrypts and authenticates its payload. The payload consists
    of a ciphertext followed by an authentication tag, which the receiving end, respectively,
    decrypts and verifies. The recipient knows which cipher and key to decrypt with,
    thanks to the magic of TLS: if you receive an encrypted TLS record, you already
    know the cipher and key because executing the handshake protocol establishes them.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Nonces</samp>
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unlike many other protocols, such as IPsec’s Encapsulating Security Payload
    (ESP), TLS records don’t specify the nonce the authenticated cipher will use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The nonces that encrypt and decrypt TLS records are derived from 64-bit sequence
    numbers, maintained locally by each party and incremented for each new record.
    When the client encrypts data, it derives a nonce by XORing the sequence number
    with a <samp class="SANS_TheSansMonoCd_W5Regular_11">client_write_iv</samp> value,
    itself derived from the shared secret. The server uses a similar method to choose
    nonces when transmitting data, but with a <samp class="SANS_TheSansMonoCd_W5Regular_11">server_write_iv</samp>
    value.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you transmit three TLS records, you’ll derive a nonce from 0
    for the first record, from 1 for the second, and from 2 for the third; if you
    then receive three records, you’ll also use nonces 0, 1, and 2, in this order.
    Reusing the same sequence numbers values for encrypting transmitted data and decrypting
    receiving data isn’t a weakness because they’re XORed with different constants
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">client_write_iv</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">server_write_iv</samp>) and because you
    use different secret keys for each direction.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Zero Padding Feature</samp>
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: TLS 1.3 records support *zero padding*, which mitigates traffic analysis attacks.
    Attackers use *traffic analysis* to extract information from traffic patterns
    using timing, volume of data transferred, and so on. For example, because ciphertexts
    are approximately the same size as plaintexts, even when using strong encryption,
    attackers can determine the approximate size of messages by simply looking at
    the length of their ciphertext.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Zero padding adds zeros to the plaintext to inflate the ciphertext’s size, fooling
    observers into thinking that an encrypted message is longer than it really is.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The TLS Handshake
    Protocol</samp>
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The handshake is the crux of the TLS agreement protocol—the process by which
    a client and a server establish shared secret keys to initiate secure communications.
    During a TLS handshake, the client and the server play different roles. The client
    proposes some configurations (the TLS version and a suite of ciphers, in order
    of preference), and the server chooses the configuration it will use. The server
    should follow the client’s preferences. To ensure interoperability between implementations
    and that any server implementing TLS 1.3 will be able to read TLS 1.3 data sent
    by any client implementing TLS 1.3 (even if it’s using a different library or
    programming language), the TLS 1.3 specifications also describe the format data
    should be sent in.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-1](chapter13.xhtml#fig13-1) shows how the handshake process exchanges
    data, as the TLS 1.3 specifications describe.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-1.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: The TLS 1.3 handshake
    process</samp>'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: In the TLS 1.3 handshake, the client sends a message to the server saying, “I
    want to establish a TLS connection with you. Here are the ciphers that I support
    to encrypt TLS records, and here is a Diffie–Hellman public key.” The public key
    must be generated specifically for this TLS session, and the client keeps the
    associated private key. The message sent by the client also includes a 32-byte
    random value and optional information (such as additional parameters). This first
    message, *ClientHello*, must follow a specific format when transmitted as a series
    of bytes, as the TLS 1.3 specification defines.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The server receives the ClientHello message, verifies that it’s correctly formatted,
    and responds with a ServerHello message, which is loaded with information. Typically,
    when connecting to an HTTPS website, it contains the cipher that will encrypt
    TLS records, a Diffie–Hellman public key, a 32-byte random value (discussed in
    “Downgrade Protection” on [page 266](#sec13)), a certificate, a signature of all
    the previous information in ClientHello and ServerHello messages (computed using
    the private key associated with the certificate’s public key), and a MAC of that
    same information, plus the signature. The MAC is computed using a symmetric key
    derived from the Diffie–Hellman shared secret, which the server computes from
    its Diffie–Hellman private key and the client’s public key.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: When the client receives the ServerHello message, it verifies the certificate’s
    validity, verifies the signature, computes the shared Diffie–Hellman secret and
    derives symmetric keys from it, and verifies the MAC sent by the server. Once
    everything is verified, the client is ready to send encrypted messages to the
    server.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*TLS 1.3 supports many options and extensions, so it may behave differently.
    You can, for example, configure the TLS 1.3 handshake to require a client certificate
    so that the server verifies the identity of the client. TLS 1.3 also supports
    a handshake with preshared keys.*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at this in practice. Say you’ve deployed TLS 1.3 to provide secure
    access to the website *[https://<wbr>www<wbr>.nostarch<wbr>.com](https://www.nostarch.com)*.
    When you point your browser (the client) to this site, your browser sends a ClientHello
    message to the site’s server that includes the ciphers that it supports. The website
    responds with a ServerHello message and a certificate that includes a public key
    associated with the domain *[www<wbr>.nostarch<wbr>.com](http://www.nostarch.com)*.
    The client verifies the certificate’s validity using one of the certificate authorities
    embedded in the browser (a trusted certificate authority, whose certificate should
    be included in the browser’s or the operating system’s certificate store to be
    validated, should sign the received certificate). Once all checks pass, the browser
    requests the site’s initial page from the *[www<wbr>.nostarch<wbr>.com](http://www.nostarch.com)*
    server.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Upon a successful TLS 1.3 handshake, all communications between the client and
    the server are encrypted and authenticated. An eavesdropper can learn that a client
    at a given IP address is talking to a server at another given IP address and can
    observe the encrypted content exchanged but can’t learn the underlying plaintext
    or modify the encrypted messages (if they do, the receiving party will notice
    that the communication has been tampered with, because messages are authenticated).
    That’s enough security for many applications.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">TLS 1.3 Cryptographic
    Algorithms</samp>
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TLS 1.3 uses authenticated encryption algorithms, a key derivation function
    (a hash function that derives secret keys from a shared secret), as well as a
    Diffie–Hellman operation—but how exactly do these work, what algorithms are used,
    and how secure are they?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'With regard to the choice of authenticated ciphers, TLS 1.3 supports only three
    algorithms: AES-GCM, AES-CCM (a slightly less efficient mode than GCM), and the
    ChaCha20 stream cipher combined with the Poly1305 MAC (as defined in RFC 7539).
    Because TLS 1.3 prevents using an unsafe key length such as 64 or 80 bits, the
    secret key can be either 128 bits (AES-GCM or AES-CCM) or 256 bits (AES-GCM or
    ChaCha20-Poly1305).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The key derivation operation (KDF) in [Figure 13-1](chapter13.xhtml#fig13-1)
    is based on HKDF, a construction based on HMAC (see [Chapter 7](chapter7.xhtml))
    and defined in RFC 5869 that uses either the SHA-256 or the SHA-384 hash function.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Your options for performing the Diffie–Hellman operation (the core of the TLS
    1.3 handshake) are limited to elliptic curve cryptography and a multiplicative
    group of integers modulo a prime number (as in traditional Diffie–Hellman). But
    you can’t use just any elliptic curve or group: the supported curves include three
    NIST curves as well as Curve25519 (see [Chapter 12](chapter12.xhtml)) and Curve448,
    both defined in RFC 7748\. TLS 1.3 also supports DH over groups of integers, as
    opposed to elliptic curves. The groups supported are the five groups defined in
    RFC 7919: groups of 2,048, 3,072, 4,096, 6,144, and 8,192 bits.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The 2,048-bit group may in theory be TLS 1.3’s weakest link. Whereas the other
    options provide at least 128-bit security, 2,048-bit Diffie–Hellman is believed
    to provide less than 100-bit security. Supporting a 2,048-bit group can therefore
    be seen as inconsistent with other TLS 1.3 design choices. In practice, 100-bit
    security is about as hard to crack as 128-bit—that is, practically impossible.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">TLS 1.3 Improvements over TLS 1.2</samp>
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TLS 1.3 is very different from its predecessor. For one, it gets rid of weak
    algorithms like MD5, SHA-1, RC4, and AES in CBC mode. Also, whereas TLS 1.2 often
    protected records using a combination of a cipher and a MAC (such as HMAC-SHA-1)
    within a MAC-then-encrypt construction, TLS 1.3 supports only the more efficient
    and secure authenticated ciphers. TLS 1.3 also ditches elliptic curve point encoding
    negotiation and defines a single point format for each curve.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: TLS 1.3 removed features in 1.2 that weakened the protocol, and it reduced the
    protocol’s overall complexity and thereby its attack surface. For example, TLS
    1.3 ditches optional data compression, a feature that enabled the CRIME attack
    on TLS 1.2\. This attack exploited the fact that the length of the compressed
    version of a message leaks information on the content of the message.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'But TLS 1.3 also brings new features that make connections either more secure
    or more efficient. I’ll discuss three of these features: downgrade protection,
    the single round-trip handshake, and session resumption.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Downgrade Protection</samp>
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TLS 1.3’s *downgrade protection* feature is a defense against *downgrade attacks*,
    wherein an attacker forces the client and the server to use a weaker version of
    TLS than 1.3\. To carry out a downgrade attack, an attacker forces the server
    to use a weaker version of TLS by intercepting and modifying the ClientHello message
    to tell the server that the client doesn’t support TLS 1.3\. Now the attacker
    can exploit vulnerabilities in earlier versions of TLS.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: In an effort to defeat downgrade attacks, the TLS 1.3 server uses three types
    of patterns in the 32-byte random value sent within the ServerHello message to
    identify the type of connection requested. The pattern should match the client’s
    request for a specific type of TLS connection. If the client receives the wrong
    pattern, it knows something is up.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, if the client asks for a TLS 1.2 connection, the first 8 of the
    32 bytes are set to <samp class="SANS_TheSansMonoCd_W5Regular_11">44 4F 57 4E
    47 52 44 01</samp>, and if it asks for a TLS 1.1 connection, they’re set to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">44 4F 57 4E 47 52 44 00</samp>. However,
    if the client requests a TLS 1.3 connection, these first 8 bits should be random.
    For example, if a client sends a ClientHello asking for a TLS 1.3 connection,
    but an attacker on the network modifies it to ask for a TLS 1.1 connection, when
    the client receives the ServerHello with the wrong pattern, it knows that its
    ClientHello message was modified. (The attacker can’t arbitrarily modify the server’s
    32-byte random value because this value is cryptographically signed.)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Single Round-Trip
    Handshake</samp>
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a typical TLS 1.2 handshake, the client sends some data to the server, waits
    for a response, and then sends more data and waits for the server’s response before
    sending encrypted messages. The delay is that of two round-trip times (RTT). In
    contrast, TLS 1.3’s handshake takes a single round-trip time (see [Figure 13-1](chapter13.xhtml#fig13-1)).
    The time saved can be in the hundreds of milliseconds. This is significant when
    you consider that servers of popular services handle thousands of connections
    per second.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Session Resumption</samp>
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'TLS 1.3 is faster than TLS 1.2, but it can be made even faster (on the order
    of hundreds of milliseconds) by completely eliminating the round trips that precede
    an encrypted session. The trick is to use *session resumption*, which leverages
    the preshared key exchanged between the client and the server in a previous session
    to bootstrap a new session. Session resumption brings two major benefits: the
    client can start encrypting immediately, and there’s no need to use certificates
    in subsequent sessions.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-2](chapter13.xhtml#fig13-2) shows how session resumption works.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-2.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-2: The TLS 1.3 session
    resumption handshake, wherein the 0-RTT data is the session resumption data sent
    along with the ClientHello</samp>'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: First, the client sends a ClientHello message that includes the identifier of
    the key already shared (called *PSK* for *preshared key*) with the server, along
    with a fresh DH public key. The client can also include encrypted data in this
    first message (called *0-RTT data*). When the server responds to a ClientHello
    message, it provides a MAC over the data exchange. The client verifies the MAC
    and knows that it’s talking to the same server as it did previously, thus rendering
    certificate validation somewhat superfluous. The client and the server perform
    a Diffie–Hellman key agreement as in the normal handshake, and subsequent messages
    are encrypted using keys that depend on both the PSK and the newly computed Diffie–Hellman
    shared secret.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Strengths of TLS Security</samp>
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll evaluate the strengths of TLS 1.3 with respect to two main security notions
    from [Chapter 11](chapter11.xhtml): authentication and forward secrecy.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authentication</samp>
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: During the TLS 1.3 handshake, the server authenticates to the client using the
    certificate mechanism. However, the client isn’t authenticated, and clients may
    authenticate with a server-based application (such as Gmail) by providing a username
    and password in a TLS record after performing the handshake. If the client’s already
    established a session with the remote service, it may authenticate by sending
    a *secure cookie*, which can be sent only through a TLS connection.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'In certain cases, clients can authenticate to a server using a certificate-based
    mechanism similar to what the server uses to authenticate to the client: the client
    sends a *client certificate* to the server, which verifies this certificate before
    authorizing the client. However, you will rarely use client certificates because
    they complicate things for both clients and the server (that is, the certificate
    issuer): clients need to perform complex operations to integrate the certificate
    into their system and to protect its private key, while the issuer needs to make
    sure that only authorized clients received a certificate, among other requirements.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Forward Secrecy</samp>
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recall from “Key Agreement Protocols” in [Chapter 11](chapter11.xhtml) that
    a key agreement provides forward secrecy if previous sessions aren’t compromised
    when the present session is compromised. In the data leak model, only temporary
    secrets are compromised, whereas in the breach model, long-term secrets are exposed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, TLS 1.3 forward secrecy holds up in the face of both a data leak
    and a breach. In the data leak model, the attacker recovers temporary secrets
    such as the session keys or Diffie–Hellman private keys of a specific session
    (the values *c*, *s*, *secret*, and *keys* in [Figure 13-1](chapter13.xhtml#fig13-1)).
    However, they can use these values to decrypt communications from only the present
    session, not previous sessions, because different values of *c* and *s* were used
    (thus yielding different keys).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: In the breach model, the attacker also recovers long-term secrets (namely, the
    private key that corresponds to the public key in the certificate). However, this
    is no more useful when decrypting previous sessions than temporary secrets, because
    this private key serves to authenticate only the server, and forward secrecy holds
    up again.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: In practice, if an attacker compromises a client’s machine and gains access
    to all of its memory, they may recover the client’s TLS session keys and secrets
    for the current session from memory. But more importantly, if previous keys are
    still in memory, the attacker may be able to find them and decrypt previous sessions,
    thereby bypassing the theoretical forward secrecy. Therefore, for a TLS implementation
    to ensure forward secrecy, it must properly erase keys from memory once they’re
    no longer used, typically by zeroing out the memory.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TLS 1.3 fits the bill as a general-purpose secure communications protocol, but
    it’s not bulletproof. Like any security system, it can fail under certain circumstances
    (for example, when the assumptions made by its designers about real attacks are
    wrong). Unfortunately, even the latest version of TLS 1.3, configured with the
    most secure ciphers, can be compromised. For example, TLS 1.3 security relies
    on the assumption that all three parties (the client, the server, and the certificate
    authority) will behave honestly, but what if one party is compromised or the TLS
    implementation itself is poorly implemented?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Compromised Certificate
    Authority</samp>
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Root certificate authorities (root CAs) are organizations that browsers trust
    to validate certificates served by remote hosts. For example, if your browser
    accepts the certificate provided by *[www<wbr>.google<wbr>.com](http://www.google.com)*,
    the assumption is that a trusted CA has verified the legitimacy of the certificate
    owner. The browser verifies the certificate by checking its CA-issued signature.
    Since only the CA knows the private key required to create this signature, we
    assume others can’t create valid certificates on behalf of the CA. Very often
    a website’s certificate won’t be signed by a root CA but by an intermediate CA,
    which is connected to the root CA through a certificate chain.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: If a CA’s private key is compromised, the attacker is able to use the CA’s private
    key to create a certificate for any URLs in, say, the *google.com* domain without
    Google’s approval. The attacker can then use those certificates to pretend to
    host a legitimate server or subdomain like *mail.google.com* and intercept a user’s
    credentials and communications. That’s exactly what happened in 2011 when an attacker
    hacked into the network of the Dutch certificate authority DigiNotar and created
    seemingly legitimate certificates. The attacker used these fake certificates for
    several Google services.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Compromised Server</samp>
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a server is compromised and fully controlled by an attacker, all is lost:
    the server holds the session keys, being the termination point of the TLS connection.
    The attacker can see all transmitted data before it’s encrypted and all received
    data once it’s decrypted. They’ll also likely get their hands on the server’s
    private key, which could allow them to impersonate the legitimate server using
    their own malicious server. TLS won’t save you in this case.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, such security disasters are rarely seen in high-profile applications
    such as Gmail and iCloud, which are well protected and sometimes have their private
    keys stored in a separate security module, such as a hardware security module
    (HSM), directly or via a key management system (KMS) application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Attacks on web applications via vulnerabilities such as database query injections
    and cross-site scripting are more common because they’re mostly independent of
    TLS’s security and are carried out by attackers over a legitimate TLS connection.
    Such attacks may compromise usernames, passwords, and so on.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Compromised Client</samp>
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TLS security is also jeopardized when a client, such as a browser, is compromised
    by a remote attacker. Having compromised the client, the attacker is able to capture
    session keys, read any decrypted data, and so on. They could even install a rogue
    CA certificate in the client’s system to have it silently accept otherwise-invalid
    certificates, thereby letting attackers intercept TLS connections.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the compromised CA or server scenarios and the compromised
    client scenario is that in the case of the compromised client, only the targeted
    client is affected, instead of potentially *all* clients.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bugs in Implementations</samp>
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As with any cryptographic component, TLS can fail when there are bugs in its
    implementation. The poster child for TLS bugs is Heartbleed (see [Figure 13-3](chapter13.xhtml#fig13-3)),
    a buffer overflow in the OpenSSL implementation of a minor TLS feature called
    *heartbeat*. Heartbleed was discovered in 2014, independently by a Google researcher
    and by the Codenomicon company, and affected millions of TLS servers and clients.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-3.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-3: The Heartbleed
    bug in OpenSSL implementations of TLS</samp>'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: A client first sends a buffer along with a buffer length to the server to check
    whether the server is online. In this example, the buffer is the string *BANANAS*,
    and the client explicitly says that this word is seven letters long. The server
    reads the seven-letter word and returns it to the client.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that the server doesn’t confirm that the length is correct and
    attempts to read as many characters as the client tells it to. Consequently, if
    the client provides a length that is longer than the string’s actual length, the
    server reads too much data from memory and returns it to the client, together
    with any extra data that may contain sensitive information, such as private keys
    or session cookies.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The Heartbleed bug came as a shock. To avoid similar future bugs, OpenSSL and
    other major TLS implementations now perform rigorous code reviews and use automated
    tools such as fuzzers to identify potential issues.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter isn’t a comprehensive guide to TLS, and you may want to dig deeper
    into the history of TLS, its previous vulnerabilities, and its latest version.
    The complete TLS 1.3 specifications, found on the home page of the TLS Working
    Group (TLSWG) at *[https://<wbr>tlswg<wbr>.org](https://tlswg.org)*, include everything
    about the protocol (though not necessarily its underlying rationale).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: I also suggest you learn about major protocols that use TLS, such as QUIC (used
    in connections between Chrome and Google servers) and SRTP (used for videoconferencing
    and streaming traffic).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, here are two important initiatives related to TLS deployment:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: SSL Labs TLS test (*[https://<wbr>www<wbr>.ssllabs<wbr>.com<wbr>/ssltest](https://www.ssllabs.com/ssltest)*)
    is a free service by Qualys that lets you test a browser’s or a server’s TLS configuration,
    providing a security rating as well as improvement suggestions. If you set up
    your own TLS server, use this test to make sure everything is safe.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s Encrypt (*[https://<wbr>letsencrypt<wbr>.org](https://letsencrypt.org)*)
    is a nonprofit that offers a service to “automagically” deploy TLS on your HTTP
    servers. It includes features to automatically generate a certificate and configure
    the TLS server, and it supports all the common web servers and operating systems.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
