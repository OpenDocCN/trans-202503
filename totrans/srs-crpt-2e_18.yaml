- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">TLS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The *Transport Layer Security (TLS) protocol* is the workhorse of internet security.
    TLS protects connections between servers and clients, whether between a website
    and its visitors, email servers, a mobile application and its servers, or video
    game servers and players. Without TLS, the internet wouldn’t be very secure.
  prefs: []
  type: TYPE_NORMAL
- en: TLS is application agnostic, meaning you can use it for web-based applications
    that rely on the HTTP protocol, as well as for any system where a client computer
    or device needs to initiate a connection with a remote server. For example, TLS
    is widely used for machine-to-machine communications in internet of things (IoT)
    applications, such as smart refrigerators that communicate with remote servers.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides an abbreviated view of TLS, which has become increasingly
    complex over the years. Unfortunately, complexity and bloat brought multiple vulnerabilities,
    and bugs found in its cluttered implementations have made headlines—Heartbleed,
    BEAST, CRIME, and POODLE are all vulnerabilities that impacted millions of web
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You may see folks refer to TLS as* Secure Sockets Layer (SSL)*, which is the
    name of its predecessor.*'
  prefs: []
  type: TYPE_NORMAL
- en: In 2013, engineers started working on TLS 1.3\. As you’ll learn in this chapter,
    TLS 1.3 ditched unnecessary and insecure features and replaced old algorithms
    with then state-of-the-art ones. The result is a simpler, faster, and more secure
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Before we explore how TLS 1.3 works, let’s review the problem that TLS aims
    to solve and the reason for its existence.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Target Applications and Requirements</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TLS is the *S* in HTTPS websites, and the padlock that appears in a browser’s
    address bar indicates that a page is secure. The primary driver for creating TLS
    was to enable secure browsing in applications such as e-commerce or e-banking,
    by authenticating the site and encrypting traffic to protect sensitive information
    such as personal data, credit card numbers, and user credentials.
  prefs: []
  type: TYPE_NORMAL
- en: TLS also helps protect general internet-based communication by establishing
    a *secure channel* between a client and a server that ensures the data transferred
    is confidential, authenticated, and unmodified.
  prefs: []
  type: TYPE_NORMAL
- en: One of TLS’s security goals is to prevent man-in-the-middle attacks, wherein
    an attacker intercepts encrypted traffic from the transmitting party, decrypts
    the traffic to capture the clear content, and reencrypts it to send to the receiving
    party. TLS defeats these attacks by authenticating servers (and optionally clients)
    using certificates and trusted certificate authorities, as we’ll discuss in “Certificates
    and Certificate Authorities” on [page 258](#sec5).
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure wide adoption, TLS needed to satisfy four more requirements: efficiency,
    interoperability, extensibility, and versatility. For TLS, efficiency means minimizing
    the performance penalty compared with unencrypted connections. This is good for
    both the server (to reduce the cost of hardware for the service providers) and
    the clients (to avoid perceptible delays or the reduction of the battery life
    of mobile devices). The protocol needed to be interoperable so that it would work
    on any hardware and any operating system. It was to be extensible so that it could
    support additional features or algorithms. And it had to be versatile—that is,
    not bound to a specific application. This parallels the Transport Control Protocol
    (TCP), which doesn’t care about the application protocol used on top of it.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The TLS Protocol Suite</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To protect client-server communications, TLS consists of multiple versions of
    several protocols that form the TLS protocol *suite*. TLS is not a transport protocol
    and usually sits between the transport protocol (TCP) and an application layer
    protocol such as HTTP or SMTP, to secure data transmitted over a TCP connection.
  prefs: []
  type: TYPE_NORMAL
- en: TLS also works over the *User Datagram Protocol (UDP)* transport protocol, which
    is used for “connectionless” transmissions when latency must be minimal, such
    as audio or video streaming and online gaming. However, unlike TCP, UDP doesn’t
    guarantee delivery or correct packet ordering. The UDP version of TLS, *Datagram
    Transport Layer Security (DTLS)*, is therefore slightly different. For more on
    TCP and UDP, see Charles Kozierok’s *The TCP/IP Guide* (No Starch Press, 2005).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The TLS and SSL Families
    of Protocols</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TLS began in 1995 when Netscape developed TLS’s ancestor, the SSL protocol.
    SSL was far from perfect, and both SSL 2.0 and SSL 3.0 had security flaws. You
    should never use SSL, and you should always use TLS—what adds to the confusion
    is that people often refer to TLS as SSL, including security experts.
  prefs: []
  type: TYPE_NORMAL
- en: Not all versions of TLS are secure. TLS 1.0 (1999) is the least secure version,
    though it’s still more secure than SSL 3.0\. TLS 1.1 (2006) is better but includes
    a number of weak algorithms. TLS 1.2 (2008) is better yet, but it’s complex and
    provides high security only if configured correctly. Also, its complexity increases
    the risk of bugs in implementations and the risk of incorrect configurations.
    For example, TLS 1.2 supports AES in CBC mode, which is often vulnerable to padding
    oracle attacks.
  prefs: []
  type: TYPE_NORMAL
- en: TLS 1.2 inherited dozens of features and design choices from earlier versions
    of TLS that make it suboptimal in terms of security and performance. To clean
    up this mess, cryptography engineers reinvented TLS—keeping only the good parts
    and adding security features. The result is TLS 1.3, an overhaul that’s simplified
    a bloated design and made it more secure, more efficient, and simpler. Essentially,
    TLS 1.3 is mature TLS.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">TLS in a Nutshell</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'TLS has two main protocols: the *handshake protocol* (or just *handshake*)
    determines the secret keys shared between the two parties; the *record protocol*
    describes how to use these keys to protect data. The data packets TLS processes
    are called *records*. TLS defines a packet format for encapsulating data from
    higher-layer protocols for transmission to another party.'
  prefs: []
  type: TYPE_NORMAL
- en: The handshake starts with a client that initiates a secure connection with a
    server. The client sends an initial message called ClientHello with parameters
    that include the cipher it wants to use. The server checks this message and its
    parameters and then responds with a ServerHello message. Once the client and the
    server process each other’s messages, they’re ready to exchange encrypted data
    using session keys established through the handshake protocol, as you’ll see in
    “The TLS Handshake Protocol” on [page 263](#sec10).
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Certificates
    and Certificate Authorities</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The most critical step in the TLS handshake, and the crux of TLS’s security,
    is the *certificate validation step*, wherein a server uses a certificate to authenticate
    itself to a client.
  prefs: []
  type: TYPE_NORMAL
- en: A *certificate* is essentially a public key accompanied by a signature of that
    key and associated information (including the domain name). For example, when
    connecting to *[https://<wbr>www<wbr>.google<wbr>.com](https://www.google.com)*,
    your browser receives a certificate from some network host and then verifies the
    certificate’s signature, which reads something like “I am *google.com*, and my
    public key is [*key*].” If the signature is verified, the certificate and its
    public key are *trusted*, and the browser proceeds with establishing the connection.
    (See [Chapters 10](chapter10.xhtml) and [12](chapter12.xhtml) for details regarding
    signatures.)
  prefs: []
  type: TYPE_NORMAL
- en: The browser knows the public key needed to verify the signature through a *certificate
    authority (CA)*, which is essentially a public key hardcoded in your browser or
    operating system. The public key’s private key (that is, its signing capability)
    belongs to a trusted organization that ensures the public keys in certificates
    it issues belong to the website or entity that claims them. That is, a CA acts
    as a *trusted third party*. Without CAs, there’s no way to verify that the public
    key served by *google.com* belongs to Google and not to an eavesdropper performing
    a man-in-the-middle attack.
  prefs: []
  type: TYPE_NORMAL
- en: For example, [Listing 13-1](chapter13.xhtml#Lis13-1) shows what happens when
    you use the OpenSSL command line tool to initiate a TLS connection to *www.google.com*
    on port 443, the network port used for TLS-based HTTP connections (HTTPS).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-1: Establishing
    a TLS connection with</samp> <samp class="SANS_Futura_Std_Book_11">[www<wbr>.google<wbr>.com](http://www.google.com)</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and receiving certificates to
    authenticate the connection</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The certificate data is between the <samp class="SANS_TheSansMonoCd_W5Regular_11">BEGIN
    CERTIFICATE</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">END CERTIFICATE</samp>
    markers. Before this, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Certificate
    chain</samp> contains a description of the certificate chain, wherein the lines
    beginning with <samp class="SANS_TheSansMonoCd_W5Regular_11">s:</samp> describe
    the *subject* of the certified entity, and the lines beginning with <samp class="SANS_TheSansMonoCd_W5Regular_11">i:</samp>
    describe the *issuer* of the signature. Certificate number 0 is received by *[www<wbr>.google<wbr>.com](http://www.google.com)*,
    certificate 1 belongs to the entity that signed certificate 0, and certificate
    2 belongs to the entity that signed certificate 1.
  prefs: []
  type: TYPE_NORMAL
- en: The organization that issued certificate 0 is Google (via the Google Trust Services
    entity, GTS), which authorized the issuance of certificate 0 for the domain name
    *[www<wbr>.google<wbr>.com](http://www.google.com)* by signing the certificate
    with the private key GTS CA 1C3\. The certificate attesting that this key belongs
    to the Google key hierarchy is certificate 1, which is signed by the GTS key Root
    R1, a root certificate within Google. Certificate 2, issued by GlobalSign (a recognized
    certification authority), attests that the GTS Root R1 key belongs to the Google
    organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, your operating system usually already has certificates 1 and
    2, which it considers trusted certificates. In such a case, you just need to check
    two signatures: Google’s GTS CA 1C3 entity in certificate 0 and Google’s GTS Root
    R1 entity in certificate 1\. If your system doesn’t already include certificate
    2 as a trusted certificate but has GlobalSign’s root certificate (GlobalSign Root
    CA), then you’ll also need to check GlobalSign’s signature in certificate 2.'
  prefs: []
  type: TYPE_NORMAL
- en: Certificate authority organizations such as Google and GlobalSign must be trustworthy
    and issue certificates only to trustworthy entities, and they must protect their
    private keys in order to prevent an attacker from issuing certificates on their
    behalf (for example, to impersonate a legitimate *[www<wbr>.google<wbr>.com](http://www.google.com)*
    server).
  prefs: []
  type: TYPE_NORMAL
- en: To see what’s in a certificate, enter the command <samp class="SANS_TheSansMonoCd_W7Bold_B_11">openssl
    x509 -text -noout</samp> in a Unix terminal and then paste the certificate in
    [Listing 13-1](chapter13.xhtml#Lis13-1). The output appears in [Listing 13-2](chapter13.xhtml#Lis13-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-2: Decoding a certificate
    received from</samp> <samp class="SANS_Futura_Std_Book_11">[www<wbr>.google<wbr>.com](http://www.google.com)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This listing shows the command <samp class="SANS_TheSansMonoCd_W5Regular_11">openssl
    x509</samp> decoding a certificate, originally provided as a block of base64-encoded
    data. Because OpenSSL knows the structure of this data, it can tell you what’s
    inside the certificate, including a serial number and version information, identifying
    information, validity dates (the <samp class="SANS_TheSansMonoCd_W5Regular_11">Not
    Before</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Not After</samp>
    lines), a public key (here as an RSA modulus and its public exponent), and a signature
    of the preceding information.
  prefs: []
  type: TYPE_NORMAL
- en: Although security experts and cryptographers often claim the whole certificate
    system is inherently broken, it’s one of the best solutions we have, along with
    the trust-on-first-use (TOFU) policy adopted by SSH, for example.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Record Protocol</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All data exchanged through TLS 1.3 communications is transmitted as sequences
    of TLS records, the data packets used by TLS. The TLS record protocol (the *record
    layer*) is essentially a transport protocol, agnostic of the transported data’s
    meaning; this makes TLS suitable for any application.
  prefs: []
  type: TYPE_NORMAL
- en: The TLS record protocol first carries the data exchanged during the handshake.
    Once the handshake is complete and both parties share a secret key, application
    data is fragmented into chunks that transmit as part of the TLS records.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Structure of a TLS Record</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A TLS record is a chunk of data of at most 16KB with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: The first byte represents the type of data transmitted and is set to the value
    <samp class="SANS_TheSansMonoCd_W5Regular_11">22</samp> for handshake data, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">23</samp> for encrypted data, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">21</samp> for alerts. The TLS 1.3 specifications
    call this value ContentType.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second and third bytes are set to <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>, respectively. These
    bytes are fixed for historical reasons and aren’t unique to TLS version 1.3\.
    The specifications call this 2-byte value ProtocolVersion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth and fifth bytes encode the length of the data to transmit as a 16-bit
    integer, which can be no larger than 2^(14) bytes (16KB).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the bytes are the data to transmit (or the *payload*), of a length
    equal to the value encoded by the record’s fourth and fifth bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*A TLS record has a relatively simple structure. As you’ve seen, a TLS record’s
    header includes only three fields. For comparison, an IPv4 packet includes 14
    fields before its payload, and a TCP segment includes 13 fields.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the first byte of a TLS 1.3 record (ContentType) is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">23</samp>,
    an authenticated cipher encrypts and authenticates its payload. The payload consists
    of a ciphertext followed by an authentication tag, which the receiving end, respectively,
    decrypts and verifies. The recipient knows which cipher and key to decrypt with,
    thanks to the magic of TLS: if you receive an encrypted TLS record, you already
    know the cipher and key because executing the handshake protocol establishes them.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Nonces</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unlike many other protocols, such as IPsec’s Encapsulating Security Payload
    (ESP), TLS records don’t specify the nonce the authenticated cipher will use.
  prefs: []
  type: TYPE_NORMAL
- en: The nonces that encrypt and decrypt TLS records are derived from 64-bit sequence
    numbers, maintained locally by each party and incremented for each new record.
    When the client encrypts data, it derives a nonce by XORing the sequence number
    with a <samp class="SANS_TheSansMonoCd_W5Regular_11">client_write_iv</samp> value,
    itself derived from the shared secret. The server uses a similar method to choose
    nonces when transmitting data, but with a <samp class="SANS_TheSansMonoCd_W5Regular_11">server_write_iv</samp>
    value.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you transmit three TLS records, you’ll derive a nonce from 0
    for the first record, from 1 for the second, and from 2 for the third; if you
    then receive three records, you’ll also use nonces 0, 1, and 2, in this order.
    Reusing the same sequence numbers values for encrypting transmitted data and decrypting
    receiving data isn’t a weakness because they’re XORed with different constants
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">client_write_iv</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">server_write_iv</samp>) and because you
    use different secret keys for each direction.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Zero Padding Feature</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: TLS 1.3 records support *zero padding*, which mitigates traffic analysis attacks.
    Attackers use *traffic analysis* to extract information from traffic patterns
    using timing, volume of data transferred, and so on. For example, because ciphertexts
    are approximately the same size as plaintexts, even when using strong encryption,
    attackers can determine the approximate size of messages by simply looking at
    the length of their ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: Zero padding adds zeros to the plaintext to inflate the ciphertext’s size, fooling
    observers into thinking that an encrypted message is longer than it really is.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The TLS Handshake
    Protocol</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The handshake is the crux of the TLS agreement protocol—the process by which
    a client and a server establish shared secret keys to initiate secure communications.
    During a TLS handshake, the client and the server play different roles. The client
    proposes some configurations (the TLS version and a suite of ciphers, in order
    of preference), and the server chooses the configuration it will use. The server
    should follow the client’s preferences. To ensure interoperability between implementations
    and that any server implementing TLS 1.3 will be able to read TLS 1.3 data sent
    by any client implementing TLS 1.3 (even if it’s using a different library or
    programming language), the TLS 1.3 specifications also describe the format data
    should be sent in.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-1](chapter13.xhtml#fig13-1) shows how the handshake process exchanges
    data, as the TLS 1.3 specifications describe.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: The TLS 1.3 handshake
    process</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In the TLS 1.3 handshake, the client sends a message to the server saying, “I
    want to establish a TLS connection with you. Here are the ciphers that I support
    to encrypt TLS records, and here is a Diffie–Hellman public key.” The public key
    must be generated specifically for this TLS session, and the client keeps the
    associated private key. The message sent by the client also includes a 32-byte
    random value and optional information (such as additional parameters). This first
    message, *ClientHello*, must follow a specific format when transmitted as a series
    of bytes, as the TLS 1.3 specification defines.
  prefs: []
  type: TYPE_NORMAL
- en: The server receives the ClientHello message, verifies that it’s correctly formatted,
    and responds with a ServerHello message, which is loaded with information. Typically,
    when connecting to an HTTPS website, it contains the cipher that will encrypt
    TLS records, a Diffie–Hellman public key, a 32-byte random value (discussed in
    “Downgrade Protection” on [page 266](#sec13)), a certificate, a signature of all
    the previous information in ClientHello and ServerHello messages (computed using
    the private key associated with the certificate’s public key), and a MAC of that
    same information, plus the signature. The MAC is computed using a symmetric key
    derived from the Diffie–Hellman shared secret, which the server computes from
    its Diffie–Hellman private key and the client’s public key.
  prefs: []
  type: TYPE_NORMAL
- en: When the client receives the ServerHello message, it verifies the certificate’s
    validity, verifies the signature, computes the shared Diffie–Hellman secret and
    derives symmetric keys from it, and verifies the MAC sent by the server. Once
    everything is verified, the client is ready to send encrypted messages to the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*TLS 1.3 supports many options and extensions, so it may behave differently.
    You can, for example, configure the TLS 1.3 handshake to require a client certificate
    so that the server verifies the identity of the client. TLS 1.3 also supports
    a handshake with preshared keys.*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at this in practice. Say you’ve deployed TLS 1.3 to provide secure
    access to the website *[https://<wbr>www<wbr>.nostarch<wbr>.com](https://www.nostarch.com)*.
    When you point your browser (the client) to this site, your browser sends a ClientHello
    message to the site’s server that includes the ciphers that it supports. The website
    responds with a ServerHello message and a certificate that includes a public key
    associated with the domain *[www<wbr>.nostarch<wbr>.com](http://www.nostarch.com)*.
    The client verifies the certificate’s validity using one of the certificate authorities
    embedded in the browser (a trusted certificate authority, whose certificate should
    be included in the browser’s or the operating system’s certificate store to be
    validated, should sign the received certificate). Once all checks pass, the browser
    requests the site’s initial page from the *[www<wbr>.nostarch<wbr>.com](http://www.nostarch.com)*
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Upon a successful TLS 1.3 handshake, all communications between the client and
    the server are encrypted and authenticated. An eavesdropper can learn that a client
    at a given IP address is talking to a server at another given IP address and can
    observe the encrypted content exchanged but can’t learn the underlying plaintext
    or modify the encrypted messages (if they do, the receiving party will notice
    that the communication has been tampered with, because messages are authenticated).
    That’s enough security for many applications.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">TLS 1.3 Cryptographic
    Algorithms</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TLS 1.3 uses authenticated encryption algorithms, a key derivation function
    (a hash function that derives secret keys from a shared secret), as well as a
    Diffie–Hellman operation—but how exactly do these work, what algorithms are used,
    and how secure are they?
  prefs: []
  type: TYPE_NORMAL
- en: 'With regard to the choice of authenticated ciphers, TLS 1.3 supports only three
    algorithms: AES-GCM, AES-CCM (a slightly less efficient mode than GCM), and the
    ChaCha20 stream cipher combined with the Poly1305 MAC (as defined in RFC 7539).
    Because TLS 1.3 prevents using an unsafe key length such as 64 or 80 bits, the
    secret key can be either 128 bits (AES-GCM or AES-CCM) or 256 bits (AES-GCM or
    ChaCha20-Poly1305).'
  prefs: []
  type: TYPE_NORMAL
- en: The key derivation operation (KDF) in [Figure 13-1](chapter13.xhtml#fig13-1)
    is based on HKDF, a construction based on HMAC (see [Chapter 7](chapter7.xhtml))
    and defined in RFC 5869 that uses either the SHA-256 or the SHA-384 hash function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your options for performing the Diffie–Hellman operation (the core of the TLS
    1.3 handshake) are limited to elliptic curve cryptography and a multiplicative
    group of integers modulo a prime number (as in traditional Diffie–Hellman). But
    you can’t use just any elliptic curve or group: the supported curves include three
    NIST curves as well as Curve25519 (see [Chapter 12](chapter12.xhtml)) and Curve448,
    both defined in RFC 7748\. TLS 1.3 also supports DH over groups of integers, as
    opposed to elliptic curves. The groups supported are the five groups defined in
    RFC 7919: groups of 2,048, 3,072, 4,096, 6,144, and 8,192 bits.'
  prefs: []
  type: TYPE_NORMAL
- en: The 2,048-bit group may in theory be TLS 1.3’s weakest link. Whereas the other
    options provide at least 128-bit security, 2,048-bit Diffie–Hellman is believed
    to provide less than 100-bit security. Supporting a 2,048-bit group can therefore
    be seen as inconsistent with other TLS 1.3 design choices. In practice, 100-bit
    security is about as hard to crack as 128-bit—that is, practically impossible.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">TLS 1.3 Improvements over TLS 1.2</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TLS 1.3 is very different from its predecessor. For one, it gets rid of weak
    algorithms like MD5, SHA-1, RC4, and AES in CBC mode. Also, whereas TLS 1.2 often
    protected records using a combination of a cipher and a MAC (such as HMAC-SHA-1)
    within a MAC-then-encrypt construction, TLS 1.3 supports only the more efficient
    and secure authenticated ciphers. TLS 1.3 also ditches elliptic curve point encoding
    negotiation and defines a single point format for each curve.
  prefs: []
  type: TYPE_NORMAL
- en: TLS 1.3 removed features in 1.2 that weakened the protocol, and it reduced the
    protocol’s overall complexity and thereby its attack surface. For example, TLS
    1.3 ditches optional data compression, a feature that enabled the CRIME attack
    on TLS 1.2\. This attack exploited the fact that the length of the compressed
    version of a message leaks information on the content of the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'But TLS 1.3 also brings new features that make connections either more secure
    or more efficient. I’ll discuss three of these features: downgrade protection,
    the single round-trip handshake, and session resumption.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Downgrade Protection</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TLS 1.3’s *downgrade protection* feature is a defense against *downgrade attacks*,
    wherein an attacker forces the client and the server to use a weaker version of
    TLS than 1.3\. To carry out a downgrade attack, an attacker forces the server
    to use a weaker version of TLS by intercepting and modifying the ClientHello message
    to tell the server that the client doesn’t support TLS 1.3\. Now the attacker
    can exploit vulnerabilities in earlier versions of TLS.
  prefs: []
  type: TYPE_NORMAL
- en: In an effort to defeat downgrade attacks, the TLS 1.3 server uses three types
    of patterns in the 32-byte random value sent within the ServerHello message to
    identify the type of connection requested. The pattern should match the client’s
    request for a specific type of TLS connection. If the client receives the wrong
    pattern, it knows something is up.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, if the client asks for a TLS 1.2 connection, the first 8 of the
    32 bytes are set to <samp class="SANS_TheSansMonoCd_W5Regular_11">44 4F 57 4E
    47 52 44 01</samp>, and if it asks for a TLS 1.1 connection, they’re set to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">44 4F 57 4E 47 52 44 00</samp>. However,
    if the client requests a TLS 1.3 connection, these first 8 bits should be random.
    For example, if a client sends a ClientHello asking for a TLS 1.3 connection,
    but an attacker on the network modifies it to ask for a TLS 1.1 connection, when
    the client receives the ServerHello with the wrong pattern, it knows that its
    ClientHello message was modified. (The attacker can’t arbitrarily modify the server’s
    32-byte random value because this value is cryptographically signed.)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Single Round-Trip
    Handshake</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a typical TLS 1.2 handshake, the client sends some data to the server, waits
    for a response, and then sends more data and waits for the server’s response before
    sending encrypted messages. The delay is that of two round-trip times (RTT). In
    contrast, TLS 1.3’s handshake takes a single round-trip time (see [Figure 13-1](chapter13.xhtml#fig13-1)).
    The time saved can be in the hundreds of milliseconds. This is significant when
    you consider that servers of popular services handle thousands of connections
    per second.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Session Resumption</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'TLS 1.3 is faster than TLS 1.2, but it can be made even faster (on the order
    of hundreds of milliseconds) by completely eliminating the round trips that precede
    an encrypted session. The trick is to use *session resumption*, which leverages
    the preshared key exchanged between the client and the server in a previous session
    to bootstrap a new session. Session resumption brings two major benefits: the
    client can start encrypting immediately, and there’s no need to use certificates
    in subsequent sessions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-2](chapter13.xhtml#fig13-2) shows how session resumption works.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-2: The TLS 1.3 session
    resumption handshake, wherein the 0-RTT data is the session resumption data sent
    along with the ClientHello</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, the client sends a ClientHello message that includes the identifier of
    the key already shared (called *PSK* for *preshared key*) with the server, along
    with a fresh DH public key. The client can also include encrypted data in this
    first message (called *0-RTT data*). When the server responds to a ClientHello
    message, it provides a MAC over the data exchange. The client verifies the MAC
    and knows that it’s talking to the same server as it did previously, thus rendering
    certificate validation somewhat superfluous. The client and the server perform
    a Diffie–Hellman key agreement as in the normal handshake, and subsequent messages
    are encrypted using keys that depend on both the PSK and the newly computed Diffie–Hellman
    shared secret.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Strengths of TLS Security</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll evaluate the strengths of TLS 1.3 with respect to two main security notions
    from [Chapter 11](chapter11.xhtml): authentication and forward secrecy.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authentication</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: During the TLS 1.3 handshake, the server authenticates to the client using the
    certificate mechanism. However, the client isn’t authenticated, and clients may
    authenticate with a server-based application (such as Gmail) by providing a username
    and password in a TLS record after performing the handshake. If the client’s already
    established a session with the remote service, it may authenticate by sending
    a *secure cookie*, which can be sent only through a TLS connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In certain cases, clients can authenticate to a server using a certificate-based
    mechanism similar to what the server uses to authenticate to the client: the client
    sends a *client certificate* to the server, which verifies this certificate before
    authorizing the client. However, you will rarely use client certificates because
    they complicate things for both clients and the server (that is, the certificate
    issuer): clients need to perform complex operations to integrate the certificate
    into their system and to protect its private key, while the issuer needs to make
    sure that only authorized clients received a certificate, among other requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Forward Secrecy</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recall from “Key Agreement Protocols” in [Chapter 11](chapter11.xhtml) that
    a key agreement provides forward secrecy if previous sessions aren’t compromised
    when the present session is compromised. In the data leak model, only temporary
    secrets are compromised, whereas in the breach model, long-term secrets are exposed.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, TLS 1.3 forward secrecy holds up in the face of both a data leak
    and a breach. In the data leak model, the attacker recovers temporary secrets
    such as the session keys or Diffie–Hellman private keys of a specific session
    (the values *c*, *s*, *secret*, and *keys* in [Figure 13-1](chapter13.xhtml#fig13-1)).
    However, they can use these values to decrypt communications from only the present
    session, not previous sessions, because different values of *c* and *s* were used
    (thus yielding different keys).
  prefs: []
  type: TYPE_NORMAL
- en: In the breach model, the attacker also recovers long-term secrets (namely, the
    private key that corresponds to the public key in the certificate). However, this
    is no more useful when decrypting previous sessions than temporary secrets, because
    this private key serves to authenticate only the server, and forward secrecy holds
    up again.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, if an attacker compromises a client’s machine and gains access
    to all of its memory, they may recover the client’s TLS session keys and secrets
    for the current session from memory. But more importantly, if previous keys are
    still in memory, the attacker may be able to find them and decrypt previous sessions,
    thereby bypassing the theoretical forward secrecy. Therefore, for a TLS implementation
    to ensure forward secrecy, it must properly erase keys from memory once they’re
    no longer used, typically by zeroing out the memory.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TLS 1.3 fits the bill as a general-purpose secure communications protocol, but
    it’s not bulletproof. Like any security system, it can fail under certain circumstances
    (for example, when the assumptions made by its designers about real attacks are
    wrong). Unfortunately, even the latest version of TLS 1.3, configured with the
    most secure ciphers, can be compromised. For example, TLS 1.3 security relies
    on the assumption that all three parties (the client, the server, and the certificate
    authority) will behave honestly, but what if one party is compromised or the TLS
    implementation itself is poorly implemented?
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Compromised Certificate
    Authority</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Root certificate authorities (root CAs) are organizations that browsers trust
    to validate certificates served by remote hosts. For example, if your browser
    accepts the certificate provided by *[www<wbr>.google<wbr>.com](http://www.google.com)*,
    the assumption is that a trusted CA has verified the legitimacy of the certificate
    owner. The browser verifies the certificate by checking its CA-issued signature.
    Since only the CA knows the private key required to create this signature, we
    assume others can’t create valid certificates on behalf of the CA. Very often
    a website’s certificate won’t be signed by a root CA but by an intermediate CA,
    which is connected to the root CA through a certificate chain.
  prefs: []
  type: TYPE_NORMAL
- en: If a CA’s private key is compromised, the attacker is able to use the CA’s private
    key to create a certificate for any URLs in, say, the *google.com* domain without
    Google’s approval. The attacker can then use those certificates to pretend to
    host a legitimate server or subdomain like *mail.google.com* and intercept a user’s
    credentials and communications. That’s exactly what happened in 2011 when an attacker
    hacked into the network of the Dutch certificate authority DigiNotar and created
    seemingly legitimate certificates. The attacker used these fake certificates for
    several Google services.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Compromised Server</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a server is compromised and fully controlled by an attacker, all is lost:
    the server holds the session keys, being the termination point of the TLS connection.
    The attacker can see all transmitted data before it’s encrypted and all received
    data once it’s decrypted. They’ll also likely get their hands on the server’s
    private key, which could allow them to impersonate the legitimate server using
    their own malicious server. TLS won’t save you in this case.'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, such security disasters are rarely seen in high-profile applications
    such as Gmail and iCloud, which are well protected and sometimes have their private
    keys stored in a separate security module, such as a hardware security module
    (HSM), directly or via a key management system (KMS) application.
  prefs: []
  type: TYPE_NORMAL
- en: Attacks on web applications via vulnerabilities such as database query injections
    and cross-site scripting are more common because they’re mostly independent of
    TLS’s security and are carried out by attackers over a legitimate TLS connection.
    Such attacks may compromise usernames, passwords, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Compromised Client</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TLS security is also jeopardized when a client, such as a browser, is compromised
    by a remote attacker. Having compromised the client, the attacker is able to capture
    session keys, read any decrypted data, and so on. They could even install a rogue
    CA certificate in the client’s system to have it silently accept otherwise-invalid
    certificates, thereby letting attackers intercept TLS connections.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the compromised CA or server scenarios and the compromised
    client scenario is that in the case of the compromised client, only the targeted
    client is affected, instead of potentially *all* clients.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bugs in Implementations</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As with any cryptographic component, TLS can fail when there are bugs in its
    implementation. The poster child for TLS bugs is Heartbleed (see [Figure 13-3](chapter13.xhtml#fig13-3)),
    a buffer overflow in the OpenSSL implementation of a minor TLS feature called
    *heartbeat*. Heartbleed was discovered in 2014, independently by a Google researcher
    and by the Codenomicon company, and affected millions of TLS servers and clients.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-3: The Heartbleed
    bug in OpenSSL implementations of TLS</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: A client first sends a buffer along with a buffer length to the server to check
    whether the server is online. In this example, the buffer is the string *BANANAS*,
    and the client explicitly says that this word is seven letters long. The server
    reads the seven-letter word and returns it to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that the server doesn’t confirm that the length is correct and
    attempts to read as many characters as the client tells it to. Consequently, if
    the client provides a length that is longer than the string’s actual length, the
    server reads too much data from memory and returns it to the client, together
    with any extra data that may contain sensitive information, such as private keys
    or session cookies.
  prefs: []
  type: TYPE_NORMAL
- en: The Heartbleed bug came as a shock. To avoid similar future bugs, OpenSSL and
    other major TLS implementations now perform rigorous code reviews and use automated
    tools such as fuzzers to identify potential issues.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter isn’t a comprehensive guide to TLS, and you may want to dig deeper
    into the history of TLS, its previous vulnerabilities, and its latest version.
    The complete TLS 1.3 specifications, found on the home page of the TLS Working
    Group (TLSWG) at *[https://<wbr>tlswg<wbr>.org](https://tlswg.org)*, include everything
    about the protocol (though not necessarily its underlying rationale).
  prefs: []
  type: TYPE_NORMAL
- en: I also suggest you learn about major protocols that use TLS, such as QUIC (used
    in connections between Chrome and Google servers) and SRTP (used for videoconferencing
    and streaming traffic).
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, here are two important initiatives related to TLS deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: SSL Labs TLS test (*[https://<wbr>www<wbr>.ssllabs<wbr>.com<wbr>/ssltest](https://www.ssllabs.com/ssltest)*)
    is a free service by Qualys that lets you test a browser’s or a server’s TLS configuration,
    providing a security rating as well as improvement suggestions. If you set up
    your own TLS server, use this test to make sure everything is safe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s Encrypt (*[https://<wbr>letsencrypt<wbr>.org](https://letsencrypt.org)*)
    is a nonprofit that offers a service to “automagically” deploy TLS on your HTTP
    servers. It includes features to automatically generate a certificate and configure
    the TLS server, and it supports all the common web servers and operating systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
