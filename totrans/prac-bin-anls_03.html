<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_31"/><span class="big">2</span><br/>THE ELF FORMAT</h2>&#13;
<p class="startpara">Now that you have a high-level idea of what binaries look like and how they work, you’re ready to dive into a real binary format. In this chapter, you’ll investigate the Executable and Linkable Format (ELF), which is the default binary format on Linux-based systems and the one you’ll be working with in this book.</p>&#13;
<p class="indent">ELF is used for executable files, object files, shared libraries, and core dumps. I’ll focus on ELF executables here, but the same concepts apply to other ELF file types. Because you will deal mostly with 64-bit binaries in this book, I’ll center the discussion around 64-bit ELF files. However, the 32-bit format is similar, differing mainly in the size and order of certain header fields and other data structures. You shouldn’t have any trouble generalizing the concepts discussed here to 32-bit ELF binaries.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch02fig1">Figure 2-1</a> illustrates the format and contents of a typical 64-bit ELF executable. When you first start analyzing ELF binaries in detail, all the intricacies involved may seem overwhelming. But in essence, ELF binaries really consist of only four types of components: an <em>executable header</em>, a series of (optional) <em>program headers</em>, a number of <em>sections</em>, and a series of (optional) <em>section headers</em>, one per section. I’ll discuss each of these components next.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_32"/><a id="ch02fig1"/><img src="Images/f032-01.jpg" alt="image" width="680" height="1135"/></div>&#13;
<p class="fig-caption"><em>Figure 2-1: A 64-bit ELF binary at a glance</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_33"/>As you can see in <a href="ch02.xhtml#ch02fig1">Figure 2-1</a>, the executable header comes first in standard ELF binaries, the program headers come next, and the sections and section headers come last. To make the following discussion easier to follow, I’ll use a slightly different order and discuss sections and section headers before program headers. Let’s start with the executable header.</p>&#13;
<h3 class="h3" id="ch02_1">2.1 The Executable Header</h3>&#13;
<p class="noindent">Every ELF file starts with an <em>executable header</em>, which is just a structured series of bytes telling you that it’s an ELF file, what kind of ELF file it is, and where in the file to find all the other contents. To find out what the format of the executable header is, you can look up its type definition (and the definitions of other ELF-related types and constants) in <em>/usr/include/elf.h</em> or in the ELF specification.<sup><a id="ch02fn_1a" href="footnote.xhtml#ch02fn_1">1</a></sup> <a href="ch02.xhtml#ch02list1">Listing 2-1</a> shows the type definition for the 64-bit ELF executable header.</p>&#13;
<p class="listing1" id="ch02list1"><em>Listing 2-1: Definition of</em> <span class="codeitalic">ELF64_Ehdr</span> <em>in</em> /usr/include/elf.h</p>&#13;
<pre>typedef struct {<br/>  unsigned char e_ident[16];   /* Magic number and other info       */<br/>  uint16_t     e_type;         /* Object file type                  */<br/>  uint16_t     e_machine;      /* Architecture                      */<br/>  uint32_t     e_version;      /* Object file version               */<br/>  uint64_t     e_entry;        /* Entry point virtual address       */<br/>  uint64_t     e_phoff;        /* Program header table file offset  */<br/>  uint64_t     e_shoff;        /* Section header table file offset  */<br/>  uint32_t     e_flags;        /* Processor-specific flags          */<br/>  uint16_t     e_ehsize;       /* ELF header size in bytes          */<br/>  uint16_t     e_phentsize;    /* Program header table entry size   */<br/>  uint16_t     e_phnum;        /* Program header table entry count  */<br/>  uint16_t     e_shentsize;    /* Section header table entry size   */<br/>  uint16_t     e_shnum;        /* Section header table entry count  */<br/>  uint16_t     e_shstrndx;     /* Section header string table index */<br/>} Elf64_Ehdr;</pre>&#13;
<p class="indent">The executable header is represented here as a C <code>struct</code> called <code>Elf64 _Ehdr</code>. If you look it up in <em>/usr/include/elf.h</em>, you may notice that the <code>struct</code> definition given there contains types such as <code>Elf64_Half</code> and <code>Elf64_Word</code>. These are just <code>typedef</code>s for integer types such as <code>uint16_t</code> and <code>uint32_t</code>. For simplicity, I’ve expanded all the <code>typedef</code>s in <a href="ch02.xhtml#ch02fig1">Figure 2-1</a> and <a href="ch02.xhtml#ch02list1">Listing 2-1</a>.</p>&#13;
<h4 class="h4" id="ch02_1_1"><em>2.1.1 <span epub:type="pagebreak" id="page_34"/>The e_ident Array</em></h4>&#13;
<p class="noindent">The executable header (and the ELF file) starts with a 16-byte array called <code>e_ident</code>. The <code>e_ident</code> array always starts with a 4-byte “magic value” identifying the file as an ELF binary. The magic value consists of the hexadecimal number <code>0x7f</code>, followed by the ASCII character codes for the letters <em>E</em>, <em>L</em>, and <em>F</em>. Having these bytes right at the start is convenient because it allows tools such as <code>file</code>, as well as specialized tools such as the binary loader, to quickly discover that they’re dealing with an ELF file.</p>&#13;
<p class="indent">Following the magic value, there are a number of bytes that give more detailed information about the specifics of the type of ELF file. In <em>elf.h</em>, the indexes for these bytes (indexes 4 through 15 in the <code>e_ident</code> array) are symbolically referred to as <code>EI_CLASS</code>, <code>EI_DATA</code>, <code>EI_VERSION</code>, <code>EI_OSABI</code>, <code>EI_ABIVERSION</code>, and <code>EI_PAD</code>, respectively. <a href="ch02.xhtml#ch02fig1">Figure 2-1</a> shows a visual representation of them.</p>&#13;
<p class="indent">The <code>EI_PAD</code> field actually contains multiple bytes, namely, indexes 9 through 15 in <code>e_ident</code>. All of these bytes are currently designated as padding; they are reserved for possible future use but currently set to zero.</p>&#13;
<p class="indent">The <code>EI_CLASS</code> byte denotes what the ELF specification refers to as the binary’s “class.” This is a bit of a misnomer since the word <em>class</em> is so generic, it could mean almost anything. What the byte really denotes is whether the binary is for a 32-bit or 64-bit architecture. In the former case, the <code>EI_CLASS</code> byte is set to the constant <code>ELFCLASS32</code> (which is equal to 1), while in the latter case, it’s set to <code>ELFCLASS64</code> (equal to 2).</p>&#13;
<p class="indent">Related to the architecture’s bit width is the <em>endianness</em> of the architecture. In other words, are multibyte values (such as integers) ordered in memory with the least significant byte first (<em>little-endian</em>) or the most significant byte first (<em>big-endian</em>)? The <code>EI_DATA</code> byte indicates the endianness of the binary. A value of <code>ELFDATA2LSB</code> (equal to 1) indicates little-endian, while <code>ELFDATA2MSB</code> (equal to 2) means big-endian.</p>&#13;
<p class="indent">The next byte, called <code>EI_VERSION</code>, indicates the version of the ELF specification used when creating the binary. Currently, the only valid value is <code>EV_CURRENT</code>, which is defined to be equal to 1.</p>&#13;
<p class="indent">Finally, the <code>EI_OSABI</code> and <code>EI_ABIVERSION</code> bytes denote information regarding the application binary interface (ABI) and operating system (OS) for which the binary was compiled. If the <code>EI_OSABI</code> byte is set to nonzero, it means that some ABI- or OS-specific extensions are used in the ELF file; this can change the meaning of some other fields in the binary or can signal the presence of nonstandard sections. The default value of zero indicates that the binary targets the UNIX System V ABI. The <code>EI_ABIVERSION</code> byte denotes the specific version of the ABI indicated in the <code>EI_OSABI</code> byte that the binary targets. You’ll usually see this set to zero because it’s not necessary to specify any version information when the default <code>EI_OSABI</code> is used.</p>&#13;
<p class="indent">You can inspect the <code>e_ident</code> array of any ELF binary by using <code>readelf</code> to view the binary’s header. For instance, <a href="ch02.xhtml#ch02list2">Listing 2-2</a> shows the output for the <code>compilation_example</code> binary from <a href="ch01.xhtml#ch01">Chapter 1</a> (I’ll also refer to this output when discussing the other fields in the executable header).</p>&#13;
<p class="listing1" id="ch02list2"><span epub:type="pagebreak" id="page_35"/><em>Listing 2-2: Executable header as shown by</em> <span class="codeitalic">readelf</span></p>&#13;
<pre>  $ <span class="codestrong1">readelf -h a.out</span><br/>  ELF Header:<br/><span class="ent">➊</span> Magic:     7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00<br/><span class="ent">➋</span> Class:                               ELF64<br/>   Data:                                2's complement, little endian<br/>   Version:                             1 (current)<br/>   OS/ABI:                              UNIX - System V<br/>   ABI Version:                         0<br/><span class="ent">➌</span> Type:                                EXEC (Executable file)<br/><span class="ent">➍</span> Machine:                             Advanced Micro Devices X86-64<br/><span class="ent">➎</span> Version:                             0x1<br/><span class="ent">➏</span> Entry point address:                 0x400430<br/><span class="ent">➐</span> Start of program headers:            64 (bytes into file)<br/>   Start of section headers:            6632 (bytes into file)<br/>   Flags:                               0x0<br/><span class="ent">➑</span> Size of this header:                 64 (bytes)<br/><span class="ent">➒</span> Size of program headers:             56 (bytes)<br/>   Number of program headers:           9<br/>   Size of section headers:             64 (bytes)<br/>   Number of section headers:           31<br/><span class="ent">➓</span> Section header string table index:   28</pre>&#13;
<p class="indent">In <a href="ch02.xhtml#ch02list2">Listing 2-2</a>, the <code>e_ident</code> array is shown on the line marked <code>Magic</code> <span class="ent">➊</span>. It starts with the familiar four magic bytes, followed by a value of 2 (indicating <code>ELFCLASS64</code>), then a 1 (<code>ELFDATA2LSB</code>), and finally another 1 (<code>EV_CURRENT</code>). The remaining bytes are all zeroed out since the <code>EI_OSABI</code> and <code>EI_ABIVERSION</code> bytes are at their default values; the padding bytes are all set to zero as well. The information contained in some of the bytes is explicitly repeated on dedicated lines, marked <code>Class</code>, <code>Data</code>, <code>Version</code>, <code>OS/ABI</code>, and <code>ABI Version</code>, respectively <span class="ent">➋</span>.</p>&#13;
<h4 class="h4" id="ch02_1_2"><em>2.1.2 The e_type, e_machine, and e_version Fields</em></h4>&#13;
<p class="noindent">After the <code>e_ident</code> array comes a series of multibyte integer fields. The first of these, called <code>e_type</code>, specifies the type of the binary. The most common values you’ll encounter here are <code>ET_REL</code> (indicating a relocatable object file), <code>ET_EXEC</code> (an executable binary), and <code>ET_DYN</code> (a dynamic library, also called a shared object file). In the <code>readelf</code> output for the example binary, you can see you’re dealing with an executable file (<code>Type: EXEC</code> <span class="ent">➌</span> in <a href="ch02.xhtml#ch02list2">Listing 2-2</a>).</p>&#13;
<p class="indent">Next comes the <code>e_machine</code> field, which denotes the architecture that the binary is intended to run on <span class="ent">➍</span>. For this book, this will usually be set to <code>EM_X86_64</code> (as it is in the <code>readelf</code> output) since you will mostly be working on 64-bit x86 binaries. Other values you’re likely to encounter include <code>EM_386</code> (32-bit x86) and <code>EM_ARM</code> (for ARM binaries).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_36"/>The <code>e_version</code> field serves the same role as the <code>EI_VERSION</code> byte in the <code>e_ident</code> array; specifically, it indicates the version of the ELF specification that was used when creating the binary. As this field is 32 bits wide, you might think there are numerous possible values, but in reality, the only possible value is 1 (<code>EV_CURRENT</code>) to indicate version 1 of the specification <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch02_1_3"><em>2.1.3 The e_entry Field</em></h4>&#13;
<p class="noindent">The <code>e_entry</code> field denotes the <em>entry point</em> of the binary; this is the virtual address at which execution should start (see also <a href="ch01.xhtml#ch01_4">Section 1.4</a>). For the example binary, execution starts at address <code>0x400430</code> (marked <span class="ent">➏</span> in the <code>readelf</code> output in <a href="ch02.xhtml#ch02list2">Listing 2-2</a>). This is where the interpreter (typically <em>ld-linux.so</em>) will transfer control after it finishes loading the binary into virtual memory. The entry point is also a useful starting point for recursive disassembly, as I’ll discuss in <a href="ch06.xhtml#ch06">Chapter 6</a>.</p>&#13;
<h4 class="h4" id="ch02_1_4"><em>2.1.4 The e_phoff and e_shoff Fields</em></h4>&#13;
<p class="noindent">As shown in <a href="ch02.xhtml#ch02fig1">Figure 2-1</a>, ELF binaries contain tables of program headers and section headers, among other things. I’ll revisit the meaning of these header types after I finish discussing the executable header, but one thing I can already reveal is that the program header and section header tables need not be located at any particular offset in the binary file. The only data structure that can be assumed to be at a fixed location in an ELF binary is the executable header, which is always at the beginning.</p>&#13;
<p class="indent">How can you know where to find the program headers and section headers? For this, the executable header contains two dedicated fields, called <code>e_phoff</code> and <code>e_shoff</code>, that indicate the file offsets to the beginning of the program header table and the section header table. For the example binary, the offsets are 64 and 6632 bytes, respectively (the two lines at <span class="ent">➐</span> in <a href="ch02.xhtml#ch02list2">Listing 2-2</a>). The offsets can also be set to zero to indicate that the file does not contain a program header or section header table. It’s important to note here that these fields are <em>file offsets</em>, meaning the number of bytes you should read into the file to get to the headers. In other words, in contrast to the <code>e_entry</code> field discussed earlier, <code>e_phoff</code> and <code>e_shoff</code> are <em>not</em> virtual addresses.</p>&#13;
<h4 class="h4" id="ch02_1_5"><em>2.1.5 The e_flags Field</em></h4>&#13;
<p class="noindent">The <code>e_flags</code> field provides room for flags specific to the architecture for which the binary is compiled. For instance, ARM binaries intended to run on embedded platforms can set ARM-specific flags in the <code>e_flags</code> field to indicate additional details about the interface they expect from the embedded operating system (file format conventions, stack organization, and so on). For x86 binaries, <code>e_flags</code> is typically set to zero and thus not of interest.</p>&#13;
<h4 class="h4" id="ch02_1_6"><em>2.1.6 The e_ehsize Field</em></h4>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_37"/>The <code>e_ehsize</code> field specifies the size of the executable header, in bytes. For 64-bit x86 binaries, the executable header size is always 64 bytes, as you can see in the <code>readelf</code> output, while it’s 52 bytes for 32-bit x86 binaries (see <span class="ent">➑</span> in <a href="ch02.xhtml#ch02list2">Listing 2-2</a>).</p>&#13;
<h4 class="h4" id="ch02_1_7"><em>2.1.7 The e_*entsize and e_*num Fields</em></h4>&#13;
<p class="noindent">As you now know, the <code>e_phoff</code> and <code>e_shoff</code> fields point to the file offsets where the program header and section header tables begin. But for the linker or loader (or another program handling an ELF binary) to actually traverse these tables, additional information is needed. Specifically, they need to know the size of the individual program or section headers in the tables, as well as the number of headers in each table. This information is provided by the <code>e_phentsize</code> and <code>e_phnum</code> fields for the program header table and by the <code>e_shentsize</code> and <code>e_shnum</code> fields for the section header table. In the example binary in <a href="ch02.xhtml#ch02list2">Listing 2-2</a>, there are nine program headers of 56 bytes each, and there are 31 section headers of 64 bytes each <span class="ent">➒</span>.</p>&#13;
<h4 class="h4" id="ch02_1_8"><em>2.1.8 The e_shstrndx Field</em></h4>&#13;
<p class="noindent">The <code>e_shstrndx</code> field contains the index (in the section header table) of the header associated with a special <em>string table</em> section, called <code>.shstrtab</code>. This is a dedicated section that contains a table of null-terminated ASCII strings, which store the names of all the sections in the binary. It is used by ELF processing tools such as <code>readelf</code> to correctly show the names of sections. I’ll describe <code>.shstrtab</code> (and other sections) later in this chapter.</p>&#13;
<p class="indent">In the example binary in <a href="ch02.xhtml#ch02list2">Listing 2-2</a>, the section header for <code>.shstrtab</code> has index 28 <span class="ent">➓</span>. You can view the contents of the <code>.shstrtab</code> section (as a hexadecimal dump) using <code>readelf</code>, as shown in <a href="ch02.xhtml#ch02list3">Listing 2-3</a>.</p>&#13;
<p class="listing1" id="ch02list3"><em>Listing 2-3: The</em> <span class="codeitalic">.shstrtab</span> <em>section as shown by</em> <span class="codeitalic">readelf</span></p>&#13;
<pre>$ <span class="codestrong1">readelf -x .shstrtab a.out</span><br/><br/>Hex dump of section '.shstrtab':<br/>  0x00000000 002e7379 6d746162 002e7374 72746162 <span class="ent">➊</span>..symtab..strtab<br/>  0x00000010 002e7368 73747274 6162002e 696e7465 ..shstrtab..inte<br/>  0x00000020 7270002e 6e6f7465 2e414249 2d746167 rp..note.ABI-tag<br/>  0x00000030 002e6e6f 74652e67 6e752e62 75696c64 ..note.gnu.build<br/>  0x00000040 2d696400 2e676e75 2e686173 68002e64 -id..gnu.hash..d<br/>  0x00000050 796e7379 6d002e64 796e7374 72002e67 ynsym..dynstr..g<br/>  0x00000060 6e752e76 65727369 6f6e002e 676e752e nu.version..gnu.<br/>  0x00000070 76657273 696f6e5f 72002e72 656c612e version_r..rela.<br/>  0x00000080 64796e00 2e72656c 612e706c 74002e69 dyn..rela.plt..i<br/>  0x00000090 6e697400 2e706c74 2e676f74 002e7465 nit..plt.got..te<br/>  0x000000a0 7874002e 66696e69 002e726f 64617461 xt..fini..rodata<br/>  0x000000b0 002e6568 5f667261 6d655f68 6472002e ..eh_frame_hdr..<br/>  0x000000c0 65685f66 72616d65 002e696e 69745f61 eh_frame..init_a<br/>  0x000000d0 72726179 002e6669 6e695f61 72726179 rray..fini_array<br/>  0x000000e0 002e6a63 72002e64 796e616d 6963002e ..jcr..dynamic..<br/>  0x000000f0 676f742e 706c7400 2e646174 61002e62 got.plt..data..b<br/>  0x00000100 7373002e 636f6d6d 656e7400          ss..comment.</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_38"/>You can see the section names (such as <code>.symtab</code>, <code>.strtab</code>, and so on) contained in the string table at the right side of <a href="ch02.xhtml#ch02list3">Listing 2-3</a> <span class="ent">➊</span>. Now that you’re familiar with the format and contents of the ELF executable header, let’s move on to the section headers.</p>&#13;
<h3 class="h3" id="ch02_2">2.2 Section Headers</h3>&#13;
<p class="noindent">The code and data in an ELF binary are logically divided into contiguous nonoverlapping chunks called <em>sections</em>. Sections don’t have any predetermined structure; instead, the structure of each section varies depending on the contents. In fact, a section may not even have any particular structure at all; often a section is nothing more than an unstructured blob of code or data. Every section is described by a <em>section header</em>, which denotes the properties of the section and allows you to locate the bytes belonging to the section. The section headers for all sections in the binary are contained in the <em>section header table</em>.</p>&#13;
<p class="indent">Strictly speaking, the division into sections is intended to provide a convenient organization for use by the linker (of course, sections can also be parsed by other tools, such as static binary analysis tools). This means that not every section is actually needed when setting up a process and virtual memory to execute the binary. Some sections contain data that isn’t needed for execution at all, such as symbolic or relocation information.</p>&#13;
<p class="indent">Because sections are intended to provide a view for the linker only, the section header table is an optional part of the ELF format. ELF files that don’t need linking aren’t required to have a section header table. If no section header table is present, the <code>e_shoff</code> field in the executable header is set to zero.</p>&#13;
<p class="indent">To load and execute a binary in a process, you need a different organization of the code and data in the binary. For this reason, ELF executables specify another logical organization, called <em>segments</em>, which are used at execution time (as opposed to sections, which are used at link time). I’ll cover segments later in this chapter when I talk about program headers. For now, let’s focus on sections, but keep in mind that the logical organization I discuss here exists only at link time (or when used by a static analysis tool) and not at runtime.</p>&#13;
<p class="indent">Let’s begin by discussing the format of the section headers. After that, we’ll take a look at the contents of the sections. <a href="ch02.xhtml#ch02list4">Listing 2-4</a> shows the format of an ELF section header as specified in <em>/usr/include/elf.h</em>.</p>&#13;
<p class="listing1" id="ch02list4"><span epub:type="pagebreak" id="page_39"/><em>Listing 2-4: Definition of</em> <span class="codeitalic">Elf64_Shdr</span> <em>in</em> /usr/include/elf.h</p>&#13;
<pre>typedef struct {<br/>  uint32_t  sh_name;       /* Section name (string tbl index)   */<br/>  uint32_t  sh_type;       /* Section type                      */<br/>  uint64_t  sh_flags;      /* Section flags                     */<br/>  uint64_t  sh_addr;       /* Section virtual addr at execution */<br/>  uint64_t  sh_offset;     /* Section file offset               */<br/>  uint64_t  sh_size;       /* Section size in bytes             */<br/>  uint32_t  sh_link;       /* Link to another section           */<br/>  uint32_t  sh_info;       /* Additional section information    */<br/>  uint64_t  sh_addralign;  /* Section alignment                 */<br/>  uint64_t  sh_entsize;    /* Entry size if section holds table */<br/>} Elf64_Shdr;</pre>&#13;
<h4 class="h4" id="ch02_2_1"><em>2.2.1 The sh_name Field</em></h4>&#13;
<p class="noindent">As you can see in <a href="ch02.xhtml#ch02list4">Listing 2-4</a>, the first field in a section header is called <code>sh_name</code>. If set, it contains an index into the <em>string table</em>. If the index is zero, it means the section doesn’t have a name.</p>&#13;
<p class="indent">In <a href="ch02.xhtml#ch02_1">Section 2.1</a>, I discussed a special section called <code>.shstrtab</code>, which contains an array of <code>NULL</code>-terminated strings, one for every section name. The index of the section header describing the string table is given in the <code>e_shstrndx</code> field of the executable header. This allows tools like <code>readelf</code> to easily find the <code>.shstrtab</code> section and then index it with the <code>sh_name</code> field of every section header (including the header of <code>.shstrtab</code>) to find the string describing the name of the section in question. This allows a human analyst to easily identify the purpose of each section.<sup><a id="ch02fn_2a" href="footnote.xhtml#ch02fn_2">2</a></sup></p>&#13;
<h4 class="h4" id="ch02_2_2"><em>2.2.2 The sh_type Field</em></h4>&#13;
<p class="noindent">Every section has a type, indicated by an integer field called <code>sh_type</code>, that tells the linker something about the structure of a section’s contents. <a href="ch02.xhtml#ch02fig1">Figure 2-1</a> shows the most important section types for our purposes. I’ll discuss each of the important section types in turn.</p>&#13;
<p class="indent">Sections with type <code>SHT_PROGBITS</code> contain program data, such as machine instructions or constants. These sections have no particular structure for the linker to parse.</p>&#13;
<p class="indent">There are also special section types for symbol tables (<code>SHT_SYMTAB</code> for static symbol tables and <code>SHT_DYNSYM</code> for symbol tables used by the dynamic linker) and string tables (<code>SHT_STRTAB</code>). Symbol tables contain symbols in a well-defined format (<code>struct Elf64_Sym</code> in <em>elf.h</em> if you’re interested), which describes the symbolic name and type for particular file offsets or addresses,<span epub:type="pagebreak" id="page_40"/>among other things. The static symbol table may not be present if the binary is stripped, for example. String tables, as discussed, simply contain an array of <code>NULL</code>-terminated strings, with the first byte in the string table set to <code>NULL</code> by convention.</p>&#13;
<p class="indent">Sections with type <code>SHT_REL</code> or <code>SHT_RELA</code> are particularly important for the linker because they contain relocation entries in a well-defined format (<code>struct Elf64_Rel</code> and <code>struct Elf64_Rela</code> in <em>elf.h</em>), which the linker can parse to perform the necessary relocations in other sections. Each relocation entry tells the linker about a particular location in the binary where a relocation is needed and which symbol the relocation should be resolved to. The actual relocation process is quite involved, and I won’t go into the details right now. The important takeaway is that the <code>SHT_REL</code> and <code>SHT_RELA</code> sections are used for static linking purposes.</p>&#13;
<p class="indent">Sections of type <code>SHT_DYNAMIC</code> contain information needed for dynamic linking. This information is formatted using <code>struct Elf64_Dyn</code> as specified in <em>elf.h</em>.</p>&#13;
<h4 class="h4" id="ch02_2_3"><em>2.2.3 The sh_flags Field</em></h4>&#13;
<p class="noindent">Section flags (specified in the <code>sh_flags</code> field) describe additional information about a section. The most important flags for the purposes here are <code>SHF_WRITE</code>, <code>SHF_ALLOC</code>, and <code>SHF_EXECINSTR</code>.</p>&#13;
<p class="indent"><code>SHF_WRITE</code> indicates that the section is writable at runtime. This makes it easy to distinguish between sections that contain static data (such as constants) and those that contain variables. The <code>SHF_ALLOC</code> flag indicates that the contents of the section are to be loaded into virtual memory when executing the binary (though the actual loading happens using the segment view of the binary, not the section view). Finally, <code>SHF_EXECINSTR</code> tells you that the section contains executable instructions, which is useful to know when disassembling a binary.</p>&#13;
<h4 class="h4" id="ch02_2_4"><em>2.2.4 The sh_addr, sh_offset, and sh_size Fields</em></h4>&#13;
<p class="noindent">The <code>sh_addr</code>, <code>sh_offset</code>, and <code>sh_size</code> fields describe the virtual address, file offset (in bytes from the start of the file), and size (in bytes) of the section, respectively. At first glance, a field describing the virtual address of a section, like <code>sh_addr</code>, may seem out of place here; after all, I said that sections are used only for linking, not for creating and executing a process. While this is still true, the linker sometimes needs to know at which addresses particular pieces of code and data will end up at runtime to do relocations. The <code>sh_addr</code> field provides this information. Sections that aren’t intended to be loaded into virtual memory when setting up the process have an <code>sh_addr</code> value of zero.</p>&#13;
<h4 class="h4" id="ch02_2_5"><em>2.2.5 The sh_link Field</em></h4>&#13;
<p class="noindent">Sometimes there are relationships between sections that the linker needs to know about. For instance, an <code>SHT_SYMTAB</code>, <code>SHT_DYNSYM</code>, or <code>SHT_DYNAMIC</code> <span epub:type="pagebreak" id="page_41"/>has an associated string table section, which contains the symbolic names for the symbols in question. Similarly, relocation sections (type <code>SHT_REL</code> or <code>SHT_RELA</code>) are associated with a symbol table describing the symbols involved in the relocations. The <code>sh_link</code> field makes these relationships explicit by denoting the index (in the section header table) of the related section.</p>&#13;
<h4 class="h4" id="ch02_2_6"><em>2.2.6 The sh_info Field</em></h4>&#13;
<p class="noindent">The <code>sh_info</code> field contains additional information about the section. The meaning of the additional information varies depending on the section type. For instance, for relocation sections, <code>sh_info</code> denotes the index of the section to which the relocations are to be applied.</p>&#13;
<h4 class="h4" id="ch02_2_7"><em>2.2.7 The sh_addralign Field</em></h4>&#13;
<p class="noindent">Some sections may need to be aligned in memory in a particular way for efficiency of memory accesses. For example, a section may need to be loaded at some address that is a multiple of 8 bytes or 16 bytes. These alignment requirements are specified in the <code>sh_addralign</code> field. For instance, if this field is set to 16, it means the base address of the section (as chosen by the linker) must be some multiple of 16. The values 0 and 1 are reserved to indicate no special alignment needs.</p>&#13;
<h4 class="h4" id="ch02_2_8"><em>2.2.8 The sh_entsize Field</em></h4>&#13;
<p class="noindent">Some sections, such as symbol tables or relocation tables, contain a table of well-defined data structures (such as <code>Elf64_Sym</code> or <code>Elf64_Rela</code>). For such sections, the <code>sh_entsize</code> field indicates the size in bytes of each entry in the table. When the field is unused, it is set to zero.</p>&#13;
<h3 class="h3" id="ch02_3">2.3 Sections</h3>&#13;
<p class="noindent">Now that you are familiar with the structure of a section header, let’s look at some specific sections found in an ELF binary. Typical ELF files that you’ll find on a GNU/Linux system are organized into a series of standard (or de facto standard) sections. <a href="ch02.xhtml#ch02list5">Listing 2-5</a> shows the <code>readelf</code> output with the sections in the example binary.</p>&#13;
<p class="listing1" id="ch02list5"><em>Listing 2-5: A listing of sections in the example binary</em></p>&#13;
<pre>$ <span class="codestrong1">readelf --sections --wide a.out</span><br/>There are 31 section headers, starting at offset 0x19e8:<br/><br/>Section Headers:<br/>  [Nr] Name             Type             Address          Off    Size   ES  Flg Lk Inf Al<br/>  [ 0]                 <span class="ent">➊</span>NULL             0000000000000000 000000 000000 00      0  0  0<br/>  [ 1] .interp          PROGBITS         0000000000400238 000238 00001c 00     A  0  0  1<br/>  [ 2] .note.ABI-tag    NOTE             0000000000400254 000254 000020 00     A  0  0  4<br/><span epub:type="pagebreak" id="page_42"/>&#13;
  [ 3] .note.gnu.build-id NOTE           0000000000400274 000274 000024 00     A  0  0  4<br/>  [ 4] .gnu.hash        GNU_HASH        0000000000400298 000298 00001c 00     A  5  0  8<br/>  [ 5] .dynsym          DYNSYM          00000000004002b8 0002b8 000060 18     A  6  1  8<br/>  [ 6] .dynstr          STRTAB          0000000000400318 000318 00003d 00     A  0  0  1<br/>  [ 7] .gnu.version     VERSYM          0000000000400356 000356 000008 02     A  5  0  2<br/>  [ 8] .gnu.version_r   VERNEED         0000000000400360 000360 000020 00     A  6  1  8<br/>  [ 9] .rela.dyn        RELA            0000000000400380 000380 000018 18     A  5  0  8<br/>  [10] .rela.plt        RELA            0000000000400398 000398 000030 18    AI  5 24  8<br/>  [11] .init            PROGBITS        00000000004003c8 0003c8 00001a 00  <span class="ent">➋</span>AX  0  0  4<br/>  [12] .plt             PROGBITS        00000000004003f0 0003f0 000030 10    AX  0  0 16<br/>  [13] .plt.got         PROGBITS        0000000000400420 000420 000008 00    AX  0  0  8<br/>  [14] .text           <span class="ent">➌</span>PROGBITS        0000000000400430 000430 000192 00  <span class="ent">➍</span>AX  0  0 16<br/>  [15] .fini            PROGBITS        00000000004005c4 0005c4 000009 00    AX  0  0  4<br/>  [16] .rodata          PROGBITS        00000000004005d0 0005d0 000011 00     A  0  0  4<br/>  [17] .eh_frame_hdr    PROGBITS        00000000004005e4 0005e4 000034 00     A  0  0  4<br/>  [18] .eh_frame        PROGBITS        0000000000400618 000618 0000f4 00     A  0  0  8<br/>  [19] .init_array      INIT_ARRAY      0000000000600e10 000e10 000008 00    WA  0  0  8<br/>  [20] .fini_array      FINI_ARRAY      0000000000600e18 000e18 000008 00    WA  0  0  8<br/>  [21] .jcr             PROGBITS        0000000000600e20 000e20 000008 00    WA  0  0  8<br/>  [22] .dynamic         DYNAMIC         0000000000600e28 000e28 0001d0 10    WA  6  0  8<br/>  [23] .got             PROGBITS        0000000000600ff8 000ff8 000008 08    WA  0  0  8<br/>  [24] .got.plt         PROGBITS        0000000000601000 001000 000028 08    WA  0  0  8<br/>  [25] .data            PROGBITS        0000000000601028 001028 000010 00    WA  0  0  8<br/>  [26] .bss             NOBITS          0000000000601038 001038 000008 00    WA  0  0  1<br/>  [27] .comment         PROGBITS        0000000000000000 001038 000034 01    MS  0  0  1<br/>  [28] .shstrtab        STRTAB          0000000000000000 0018da 00010c 00        0  0  1<br/>  [29] .symtab          SYMTAB          0000000000000000 001070 000648 18       30 47  8<br/>  [30] .strtab          STRTAB          0000000000000000 0016b8 000222 00        0  0  1<br/>Key to Flags:<br/>  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)<br/>  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)<br/>  O (extra OS processing required) o (OS specific), p (processor specific)</pre>&#13;
<p class="indent">For each section, <code>readelf</code> shows the relevant basic information, including the index (in the section header table), name, and type of the section. Moreover, you can also see the virtual address, file offset, and size in bytes of the section. For sections containing a table (such as symbol tables and relocation tables), there’s also a column showing the size of each table entry. Finally, <code>readelf</code> also shows the relevant flags for each section, as well as the index of the linked section (if any), additional information (specific to the section type), and alignment requirements.</p>&#13;
<p class="indent">As you can see, the output conforms closely to the structure of a section header. The first entry in the section header table of every ELF file is defined by the ELF standard to be a <code>NULL</code> entry. The type of the entry is <code>SHT_NULL</code> <span class="ent">➊</span>, and all fields in the section header are zeroed out. This means it has no name and no associated bytes (in other words, it is a section header without an actual section). Let’s now delve a bit deeper into the contents <span epub:type="pagebreak" id="page_43"/>and purpose of the most interesting remaining sections that you’re likely to see in your binary analysis endeavors.<sup><a id="ch02fn_3a" href="footnote.xhtml#ch02fn_3">3</a></sup></p>&#13;
<h4 class="h4" id="ch02_3_1"><em>2.3.1 The .init and .fini Sections</em></h4>&#13;
<p class="noindent">The <code>.init</code> section (index 11 in <a href="ch02.xhtml#ch02list5">Listing 2-5</a>) contains executable code that performs initialization tasks and needs to run before any other code in the binary is executed. You can tell that it contains executable code by the <code>SHF_EXECINSTR</code> flag, denoted as an <code>X</code> by <code>readelf</code> (in the <code>Flg</code> column) <span class="ent">➋</span>. The system executes the code in the <code>.init</code> section before transferring control to the main entry point of the binary. Thus, if you’re familiar with object-oriented programming, you can think of this section as a constructor. The <code>.fini</code> section (index 15) is analogous to the <code>.init</code> section, except that it runs after the main program completes, essentially functioning as a kind of destructor.</p>&#13;
<h4 class="h4" id="ch02_3_2"><em>2.3.2 The .text Section</em></h4>&#13;
<p class="noindent">The <code>.text</code> section (index 14) is where the main code of the program resides, so it will frequently be the main focus of your binary analysis or reverse engineering efforts. As you can see in the <code>readelf</code> output in <a href="ch02.xhtml#ch02list5">Listing 2-5</a>, the <code>.text</code> section has type <code>SHT_PROGBITS</code> <span class="ent">➌</span> because it contains user-defined code. Also note the section flags, which indicate that the section is executable but not writable <span class="ent">➍</span>. In general, executable sections should almost never be writable (and vice versa) because that would make it easy for an attacker exploiting a vulnerability to modify the behavior of the program by directly overwriting the code.</p>&#13;
<p class="indent">Besides the application-specific code compiled from the program’s source, the <code>.text</code> section of a typical binary compiled by <code>gcc</code> contains a number of standard functions that perform initialization and finalization tasks, such as <code>_start</code>, <code>register_tm_clones</code>, and <code>frame_dummy</code>. For now, the <code>_start</code> function is the most important of these standard functions for you. <a href="ch02.xhtml#ch02list6">Listing 2-6</a> shows why (don’t worry about understanding all of the assembly code in the listing; I’ll point out the important parts next).</p>&#13;
<p class="listing1" id="ch02list6"><em>Listing 2-6: Disassembly of the standard</em> <span class="codeitalic">_start</span> <em>function</em></p>&#13;
<pre>  $ <span class="codestrong1">objdump -M intel -d a.out</span><br/>  ...<br/><br/>  Disassembly of section .text:<br/><br/><span class="ent">➊</span> 0000000000400430 &lt;_start&gt;:<br/>    400430: 31 ed                   xor    ebp,ebp<br/>    400432: 49 89 d1                mov    r9,rdx<br/>    400435: 5e                      pop    rsi<br/><span epub:type="pagebreak" id="page_44"/>    400436: 48 89 e2                       mov  rdx,rsp<br/>    400439: 48 83 e4 f0                    and  rsp,0xfffffffffffffff0<br/>    40043d: 50                             push rax<br/>    40043e: 54                             push rsp<br/>    40043f: 49 c7 c0 c0 05 40 00    mov    r8,0x4005c0<br/>    400446: 48 c7 c1 50 05 40 00    mov    rcx,0x400550<br/>    40044d: 48 c7 c7 26 05 40 00    mov  <span class="ent">➋</span>rdi,0x400526<br/>    400454: e8 b7 ff ff ff          call   400410 <span class="ent">➌</span>&lt;__libc_start_main@plt&gt;<br/>    400459: f4                      hlt<br/>    40045a: 66 0f 1f 44 00 00       nop    WORD PTR [rax+rax*1+0x0]<br/>  ...<br/><br/><span class="ent">➍</span> 0000000000400526 &lt;main&gt;:<br/>    400526: 55                             push   rbp<br/>    400527: 48 89 e5                       mov    rbp,rsp<br/>    40052a: 48 83 ec 10                    sub    rsp,0x10<br/>    40052e: 89 7d fc                       mov    DWORD PTR [rbp-0x4],edi<br/>    400531: 48 89 75 f0                    mov    QWORD PTR [rbp-0x10],rsi<br/>    400535: bf d4 05 40 00                 mov    edi,0x4005d4<br/>    40053a: e8 c1 fe ff ff                 call   400400 &lt;puts@plt&gt;<br/>    40053f: b8 00 00 00 00                 mov    eax,0x0<br/>    400544: c9                             leave<br/>    400545: c3                             ret<br/>    400546: 66 2e 0f 1f 84 00 00           nop    WORD PTR cs:[rax+rax*1+0x0]<br/>    40054d: 00 00 00<br/>...</pre>&#13;
<p class="indent">When you write a C program, there’s always a <code>main</code> function where your program begins. But if you inspect the entry point of the binary, you’ll find that it <em>doesn’t</em> point to <code>main</code> at address <code>0x400526</code> <span class="ent">➍</span>. Instead, it points to address <code>0x400430</code>, the beginning of <code>_start</code> <span class="ent">➊</span>.</p>&#13;
<p class="indent">So, how does execution eventually reach <code>main</code>? If you look closely, you can see that <code>_start</code> contains an instruction at address <code>0x40044d</code> that moves the address of <code>main</code> into the <code>rdi</code> register <span class="ent">➋</span>, which is one of the registers used to pass parameters for function calls on the x64 platform. Then, <code>_start</code> calls a function called <code>__libc_start_main</code> <span class="ent">➌</span>. It resides in the <code>.plt</code> section, which means the function is part of a shared library (I’ll cover this in more detail in <a href="ch02.xhtml#ch02_3_4">Section 2.3.4</a>).</p>&#13;
<p class="indent">As its name implies, <code>__libc_start_main</code> finally calls to the address of <code>main</code> to begin execution of the user-defined code.</p>&#13;
<h4 class="h4" id="ch02_3_3"><em>2.3.3 The .bss, .data, and .rodata Sections</em></h4>&#13;
<p class="noindent">Because code sections are generally not writable, variables are kept in one or more dedicated sections, which are writable. Constant data is usually also kept in its own section to keep the binary neatly organized, though compilers <em>do</em> sometimes output constant data in code sections. (Modern versions of <code>gcc</code> and <code>clang</code> generally don’t mix code and data, but Visual <span epub:type="pagebreak" id="page_45"/>Studio sometimes does.) As you’ll see in <a href="ch06.xhtml#ch06">Chapter 6</a>, this can make disassembly considerably more difficult because it’s not always clear which bytes represent instructions and which represent data.</p>&#13;
<p class="indent">The <code>.rodata</code> section, which stands for “read-only data,” is dedicated to storing constant values. Because it stores constant values, <code>.rodata</code> is not writable. The default values of initialized variables are stored in the <code>.data</code> section, which <em>is</em> marked as writable since the values of variables may change at runtime. Finally, the <code>.bss</code> section reserves space for uninitialized variables. The name historically stands for “block started by symbol,” referring to the reserving of blocks of memory for (symbolic) variables.</p>&#13;
<p class="indent">Unlike <code>.rodata</code> and <code>.data</code>, which have type <code>SHT_PROGBITS</code>, the <code>.bss</code> section has type <code>SHT_NOBITS</code>. This is because <code>.bss</code> doesn’t occupy any bytes in the binary as it exists on disk—it’s simply a directive to allocate a properly sized block of memory for uninitialized variables when setting up an execution environment for the binary. Typically, variables that live in <code>.bss</code> are zero initialized, and the section is marked as writable.</p>&#13;
<h4 class="h4" id="ch02_3_4"><em>2.3.4 Lazy Binding and the .plt, .got, and .got.plt Sections</em></h4>&#13;
<p class="noindent">In <a href="ch01.xhtml#ch01">Chapter 1</a>, we discussed that when a binary is loaded into a process for execution, the dynamic linker performs last-minute relocations. For instance, it resolves references to functions located in shared libraries, where the load address is not yet known at compile time. I also briefly mentioned that, in reality, many of the relocations are typically not done right away when the binary is loaded but are deferred until the first reference to the unresolved location is actually made. This is known as <em>lazy binding</em>.</p>&#13;
<h5 class="h5"><strong>Lazy Binding and the PLT</strong></h5>&#13;
<p class="noindent">Lazy binding ensures that the dynamic linker never needlessly wastes time on relocations; it only performs those relocations that are truly needed at runtime. On Linux, lazy binding is the default behavior of the dynamic linker. It’s possible to force the linker to perform all relocations right away by exporting an environment variable called <code>LD_BIND_NOW</code>,<sup><a id="ch02fn_4a" href="footnote.xhtml#ch02fn_4">4</a></sup> but this is usually not done unless the application calls for real-time performance guarantees.</p>&#13;
<p class="indent">Lazy binding in Linux ELF binaries is implemented with the help of two special sections, called the <em>Procedure Linkage Table</em> (<code>.plt</code>) and the <em>Global Offset Table</em> (<code>.got</code>). Though the following discussion focuses on lazy binding, the GOT is actually used for more than just that. ELF binaries often contain a separate GOT section called <code>.got.plt</code> for use in conjunction with <code>.plt</code> in the lazy binding process. The <code>.got.plt</code> section is analogous to the regular <code>.got</code>, and for your purposes here, you can consider them to be the same (in fact, historically, they were).<sup><a id="ch02fn_5a" href="footnote.xhtml#ch02fn_5">5</a></sup> <a href="ch02.xhtml#ch02fig2">Figure 2-2</a> illustrates the lazy binding process and the role of the PLT and GOT.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_46"/><a id="ch02fig2"/><img src="Images/f046-01.jpg" alt="image" width="686" height="484"/></div>&#13;
<p class="fig-caption"><em>Figure 2-2: Calling a shared library function via the PLT</em></p>&#13;
<p class="indent">As the figure and the <code>readelf</code> output in <a href="ch02.xhtml#ch02list5">Listing 2-5</a> show, <code>.plt</code> is a code section that contains executable code, just like <code>.text</code>, while <code>.got.plt</code> is a data section.<sup><a id="ch02fn_6a" href="footnote.xhtml#ch02fn_6">6</a></sup> The PLT consists entirely of stubs of a well-defined format, dedicated to directing calls from the <code>.text</code> section to the appropriate library location. To explore the format of the PLT, let’s look at a disassembly of the <code>.plt</code> section from the example binary, as shown in <a href="ch02.xhtml#ch02list7">Listing 2-7</a>. (The instruction opcodes have been omitted for brevity.)</p>&#13;
<p class="listing1" id="ch02list7"><em>Listing 2-7: Disassembly of a</em> <span class="codeitalic">.plt</span> <em>section</em></p>&#13;
<pre>  $ <span class="codestrong1">objdump -M intel --section .plt -d a.out</span><br/><br/>  a.out:        file format elf64-x86-64<br/><br/>  Disassembly of section .plt:<br/><br/><span class="ent">➊</span> 00000000004003f0 &lt;puts@plt-0x10&gt;:<br/>   4003f0: push QWORD PTR [rip+0x200c12] # 601008 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;<br/>   4003f6: jmp  QWORD PTR [rip+0x200c14] # 601010 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;<br/><span epub:type="pagebreak" id="page_47"/>&#13;
   4003fc: nop  DWORD PTR [rax+0x0]<br/><br/><span class="ent">➋</span> 0000000000400400 &lt;puts@plt&gt;:<br/>   400400: jmp  QWORD PTR [rip+0x200c12] # 601018 &lt;_GLOBAL_OFFSET_TABLE_+0x18&gt;<br/>   400406: push <span class="ent">➌</span>0x0<br/>   40040b: jmp  4003f0 &lt;_init+0x28&gt;<br/><br/><span class="ent">➍</span> 0000000000400410 &lt;__libc_start_main@plt&gt;:<br/>   400410: jmp  QWORD PTR [rip+0x200c0a] # 601020 &lt;_GLOBAL_OFFSET_TABLE_+0x20&gt;<br/>   400416: push <span class="ent">➎</span>0x1<br/>   40041b: jmp  4003f0 &lt;_init+0x28&gt;</pre>&#13;
<p class="indent">The format of the PLT is as follows: First, there is a default stub <span class="ent">➊</span>, which I’ll talk about in a second. After that comes a series of function stubs <span class="ent">➋</span><span class="ent">➍</span>, one per library function, all following the same pattern. Also note that for each consecutive function stub, the value pushed onto the stack is incremented <span class="ent">➌</span><span class="ent">➎</span>. This value is an identifier, the use of which I’ll cover shortly. Now let’s explore how PLT stubs like those shown in <a href="ch02.xhtml#ch02list7">Listing 2-7</a> allow you to call a shared library function, as illustrated in <a href="ch02.xhtml#ch02fig2">Figure 2-2</a>, and how this aids the lazy binding process.</p>&#13;
<h3 class="h3">Dynamically Resolving a Library Function Using the PLT</h3>&#13;
<p class="noindent">Let’s say you want to call the <code>puts</code> function, which is part of the well-known <code>libc</code> library. Instead of calling it directly (which isn’t possible for the aforementioned reasons), you can make a call to the corresponding PLT stub, <code>puts@plt</code> (step <span class="ent">➊</span> in <a href="ch02.xhtml#ch02fig2">Figure 2-2</a>).</p>&#13;
<p class="indent">The PLT stub begins with an indirect jump instruction, which jumps to an address stored in the <code>.got.plt</code> section (step <span class="ent">➋</span> in <a href="ch02.xhtml#ch02fig2">Figure 2-2</a>). Initially, before the lazy binding has happened, this address is simply the address of the next instruction in the function stub, which is a <code>push</code> instruction. Thus, the indirect jump simply transfers control to the instruction directly after it (step <span class="ent">➌</span> in <a href="ch02.xhtml#ch02fig2">Figure 2-2</a>)! That’s a rather roundabout way of getting to the next instruction, but there’s a good reason for doing it this way, as you’ll now see.</p>&#13;
<p class="indent">The <code>push</code> instruction pushes an integer (in this case, <code>0x0</code>) onto the stack. As mentioned, this integer serves as an identifier for the PLT stub in question. Subsequently, the next instruction jumps to the common default stub shared among all PLT function stubs (step <span class="ent">➍</span> in <a href="ch02.xhtml#ch02fig2">Figure 2-2</a>). The default stub pushes another identifier (taken from the GOT), identifying the executable itself, and then jumps (indirectly, again through the GOT) to the dynamic linker (step <span class="ent">➎</span> in <a href="ch02.xhtml#ch02fig2">Figure 2-2</a>).</p>&#13;
<p class="indent">Using the identifiers pushed by the PLT stubs, the dynamic linker figures out that it should resolve the address of <code>puts</code> and should do so on behalf of the main executable loaded into the process. This last bit is important because there may be multiple libraries loaded in the same process as well, each with their own PLT and GOT. The dynamic linker then looks up the address at which the <code>puts</code> function is located and plugs the address of that function into the GOT entry associated with <code>puts@plt</code>. Thus, the GOT entry <span epub:type="pagebreak" id="page_48"/>no longer points back into the PLT stub, as it did initially, but now points to the actual address of <code>puts</code>. At this point, the lazy binding process is complete.</p>&#13;
<p class="indent">Finally, the dynamic linker satisfies the original intention of calling <code>puts</code> by transferring control to it. For any subsequent calls to <code>puts@plt</code>, the GOT entry already contains the appropriate (patched) address of <code>puts</code> so that the jump at the start of the PLT stub goes directly to <code>puts</code> without involving the dynamic linker (step <span class="ent">➏</span> in the figure).</p>&#13;
<h3 class="h3">Why Use a GOT?</h3>&#13;
<p class="noindent">At this point, you may wonder why the GOT is needed at all. For example, wouldn’t it be simpler to just patch the resolved library address directly into the code of the PLT stubs? One of the main reasons things don’t work that way essentially boils down to security. If there’s a vulnerability in the binary somewhere (which, for any nontrivial binary, there surely is), it would be all too easy for an attacker to modify the code of the binary if executable sections like <code>.text</code> and <code>.plt</code> were writable. But because the GOT is a data section and it’s okay for it to be writable, it makes sense to have the additional layer of indirection through the GOT. In other words, this extra layer of indirection allows you to avoid creating writable code sections. While an attacker may still succeed in changing the addresses in the GOT, this attack model is a lot less powerful than the ability to inject arbitrary code.</p>&#13;
<p class="indent">The other reason has to do with code shareability in shared libraries. As discussed, modern operating systems save (physical) memory by sharing the code of libraries among all processes using them. That way, instead of having to load a separate copy of every library for each process using it, the operating system has to load only a single copy of each library. However, even though there is only a single <em>physical</em> copy of each library, the same library will likely be mapped to a completely different <em>virtual</em> address for each process. The implication is that you can’t patch addresses resolved on behalf of a library directly into the code because the address would work only in the context of one process and break the others. Patching them into the GOT instead does work because each process has its own private copy of the GOT.</p>&#13;
<p class="indent">As you may have already guessed, references from the code to relocatable data symbols (such as variables and constants exported from shared libraries) also need to be redirected via the GOT to avoid patching data addresses directly into the code. The difference is that data references go directly through the GOT, without the intermediate step of the PLT. This also clarifies the distinction between the <code>.got</code> and <code>.got.plt</code> sections: <code>.got</code> is for references to data items, while <code>.got.plt</code> is dedicated to storing resolved addresses for library functions accessed via the PLT.</p>&#13;
<h4 class="h4" id="ch02_3_5"><em>2.3.5 The .rel.* and .rela.* Sections</em></h4>&#13;
<p class="noindent">As you can see in the <code>readelf</code> dump of the example binary’s section headers, there are several sections with names of the form <code>rela.*</code>. These sections are of type <code>SHT_RELA</code>, meaning that they contain information used by the linker <span epub:type="pagebreak" id="page_49"/>for performing relocations. Essentially, each section of type <code>SHT_RELA</code> is a table of relocation entries, with each entry detailing a particular address where a relocation needs to be applied, as well as instructions on how to resolve the particular value that needs to be plugged in at this address. <a href="ch02.xhtml#ch02list8">Listing 2-8</a> shows the contents of the relocation sections in the example binary. As you’ll see, only the dynamic relocations (to be performed by the dynamic linker) remain, as all the static relocations that existed in the object file have already been resolved during static linking. In any real-world binary (as opposed to this simple example), there would of course be many more dynamic relocations.</p>&#13;
<p class="listing1" id="ch02list8"><em>Listing 2-8: The relocation sections in the example binary</em></p>&#13;
<pre>   $ <span class="codestrong1">readelf --relocs a.out</span><br/><br/>   Relocation section '.rela.dyn' at offset 0x380 contains 1 entries:<br/>    Offset       Info           Type           Sym. Value    Sym. Name + Addend<br/><span class="ent">➊</span> 0000600ff8 000300000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0<br/><br/>   Relocation section '.rela.plt' at offset 0x398 contains 2 entries:<br/>    Offset       Info           Type           Sym. Value    Sym. Name + Addend<br/><span class="ent">➋</span> 0000601018 000100000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0<br/><span class="ent">➌</span> 0000601020 000200000007 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0</pre>&#13;
<p class="indent">There are two types of relocations here, called <code>R_X86_64_GLOB_DAT</code> and <code>R_X86_64_JUMP_SLO</code>. While you may encounter many more types in the wild, these are some of the most common and important ones. What all relocation types have in common is that they specify an offset at which to apply the relocation. The details of how to compute the value to plug in at that offset differ per relocation type and are sometimes rather involved. You can find all these specifics in the ELF specification, though for normal binary analysis tasks you don’t need to know them.</p>&#13;
<p class="indent">The first relocation shown in <a href="ch02.xhtml#ch02list8">Listing 2-8</a>, of type <code>R_X86_64_GLOB_DAT</code>, has its offset in the <code>.got</code> section <span class="ent">➊</span>, as you can tell by comparing the offset to the <code>.got</code> base address shown in the <code>readelf</code> output in <a href="ch02.xhtml#ch02list5">Listing 2-5</a>. Generally, this type of relocation is used to compute the address of a data symbol and plug it into the correct offset in <code>.got</code>.</p>&#13;
<p class="indent">The <code>R_X86_64_JUMP_SLO</code> entries are called <em>jump slots</em><span class="ent">➋</span><span class="ent">➌</span>; they have their offset in the <code>.got.plt</code> section and represent slots where the addresses of library functions can be plugged in. If you look back at the dump of the PLT of the example binary in <a href="ch02.xhtml#ch02list7">Listing 2-7</a>, you can see that each of these slots is used by one of the PLT stubs to retrieve its indirect jump target. The addresses of the jump slots (computed from the relative offset to the <code>rip</code> register) appear on the right side of the output in <a href="ch02.xhtml#ch02list7">Listing 2-7</a>, just after the # symbol.</p>&#13;
<h4 class="h4" id="ch02_3_6"><span epub:type="pagebreak" id="page_50"/><em>2.3.6 The .dynamic Section</em></h4>&#13;
<p class="noindent">The <code>.dynamic</code> section functions as a “road map” for the operating system and dynamic linker when loading and setting up an ELF binary for execution. If you’ve forgotten how the loading process works, you may want to refer to <a href="ch01.xhtml#ch01_4">Section 1.4</a>.</p>&#13;
<p class="indent">The <code>.dynamic</code> section contains a table of <code>Elf64_Dyn</code> structures (as specified in <em>/usr/include/elf.h</em>), also referred to as <em>tags</em>. There are different types of tags, each of which comes with an associated value. As an example, let’s take a look at the contents of <code>.dynamic</code> in the example binary, shown in <a href="ch02.xhtml#ch02list9">Listing 2-9</a>.</p>&#13;
<p class="listing1" id="ch02list9"><em>Listing 2-9: Contents of the</em> <span class="codeitalic">.dynamic</span> <em>section</em></p>&#13;
<pre>   $ <span class="codestrong1">readelf --dynamic a.out</span><br/><br/>   Dynamic section at offset 0xe28 contains 24 entries:<br/>     Tag                Type                 Name/Value<br/><span class="ent">➊</span> 0x0000000000000001  (NEEDED)             Shared library: [libc.so.6]<br/>   0x000000000000000c  (INIT)               0x4003c8<br/>   0x000000000000000d  (FINI)               0x4005c4<br/>   0x0000000000000019  (INIT_ARRAY)         0x600e10<br/>   0x000000000000001b  (INIT_ARRAYSZ)       8 (bytes)<br/>   0x000000000000001a  (FINI_ARRAY)         0x600e18<br/>   0x000000000000001c  (FINI_ARRAYSZ)       8 (bytes)<br/>   0x000000006ffffef5  (GNU_HASH)           0x400298<br/>   0x0000000000000005  (STRTAB)             0x400318<br/>   0x0000000000000006  (SYMTAB)             0x4002b8<br/>   0x000000000000000a  (STRSZ)              61 (bytes)<br/>   0x000000000000000b  (SYMENT)             24 (bytes)<br/>   0x0000000000000015  (DEBUG)              0x0<br/>   0x0000000000000003  (PLTGOT)             0x601000<br/>   0x0000000000000002  (PLTRELSZ)           48 (bytes)<br/>   0x0000000000000014  (PLTREL)             RELA<br/>   0x0000000000000017  (JMPREL)             0x400398<br/>   0x0000000000000007  (RELA)               0x400380<br/>   0x0000000000000008  (RELASZ)             24 (bytes)<br/>   0x0000000000000009  (RELAENT)            24 (bytes)<br/><span class="ent">➋</span> 0x000000006ffffffe  (VERNEED)            0x400360<br/><span class="ent">➌</span> 0x000000006fffffff  (VERNEEDNUM)         1<br/>   0x000000006ffffff0  (VERSYM)             0x400356<br/>   0x0000000000000000  (NULL)               0x0</pre>&#13;
<p class="indent">As you can see, the type of each tag in the <code>.dynamic</code> section is shown in the second output column. Tags of type <code>DT_NEEDED</code> inform the dynamic linker about dependencies of the executable. For instance, the binary uses the <code>puts</code> function from the <em>libc.so.6</em> shared library <span class="ent">➊</span>, so it needs to be loaded when executing the binary. The <code>DT_VERNEED</code> <span class="ent">➋</span> and <code>DT_VERNEEDNUM</code> <span class="ent">➌</span> tags specify <span epub:type="pagebreak" id="page_51"/>the starting address and number of entries of the <em>version dependency table</em>, which indicates the expected version of the various dependencies of the executable.</p>&#13;
<p class="indent">In addition to listing dependencies, the <code>.dynamic</code> section also contains pointers to other important information required by the dynamic linker (for instance, the dynamic string table, dynamic symbol table, <code>.got.plt</code> section, and dynamic relocation section pointed to by tags of type <code>DT_STRTAB</code>, <code>DT_SYMTAB</code>, <code>DT_PLTGOT</code>, and <code>DT_RELA</code>, respectively).</p>&#13;
<h4 class="h4" id="ch02_3_7"><em>2.3.7 The .init_array and .fini_array Sections</em></h4>&#13;
<p class="noindent">The <code>.init_array</code> section contains an array of pointers to functions to use as constructors. Each of these functions is called in turn when the binary is initialized, before <code>main</code> is called. While the aforementioned <code>.init</code> section contains a single startup function that performs some crucial initialization needed to start the executable, <code>.init_array</code> is a data section that can contain as many function pointers as you want, including pointers to your own custom constructors. In <code>gcc</code>, you can mark functions in your C source files as constructors by decorating them with <code>__attribute__((constructor))</code>.</p>&#13;
<p class="indent">In the example binary, <code>.init_array</code> contains only a single entry. It’s a pointer to another default initialization function, called <code>frame_dummy</code>, as you can see in the <code>objdump</code> output shown in <a href="ch02.xhtml#ch02list10">Listing 2-10</a>.</p>&#13;
<p class="listing1" id="ch02list10"><em>Listing 2-10: Contents of the</em> <span class="codeitalic">.init_array</span> <em>section</em></p>&#13;
<pre><span class="ent">➊</span> $ <span class="codestrong1">objdump -d --section .init_array a.out</span><br/><br/>  a.out:      file format elf64-x86-64<br/><br/>  Disassembly of section .init_array:<br/><br/>  0000000000600e10 &lt;__frame_dummy_init_array_entry&gt;:<br/>    600e10:  <span class="ent">➋</span><span class="gray_mark">00 05 40 00 00 00 00 00</span> ..@.....<br/><br/><span class="ent">➌</span> $ <span class="codestrong1">objdump -d a.out | grep '&lt;frame_dummy&gt;'</span><br/>  0000000000400500 &lt;frame_dummy&gt;:</pre>&#13;
<p class="indent">The first <code>objdump</code> invocation shows the contents of <code>.init_array</code> <span class="ent">➊</span>. As you can see, there’s a single function pointer (shaded in the output) that contains the bytes <code>00 05 40 00 00 00 00 00</code> <span class="ent">➋</span>. This is just little-endian-speak for the address <code>0x400500</code> (obtained by reversing the byte order and stripping off the leading zeros). The second call to <code>objdump</code> shows that this is indeed the starting address of the <code>frame_dummy</code> function <span class="ent">➌</span>.</p>&#13;
<p class="indent">As you may have guessed by now, <code>.fini_array</code> is analogous to <code>.init_array</code>, except that <code>.fini_array</code> contains pointers to destructors rather than constructors. The pointers contained in <code>.init_array</code> and <code>.fini_array</code> are easy to change, making them convenient places to insert hooks that add initialization or finalization code to the binary to modify its behavior. Note that <span epub:type="pagebreak" id="page_52"/>binaries produced by older <code>gcc</code> versions may contain sections called <code>.ctors</code> and <code>.dtors</code> instead of <code>.init_array</code> and <code>.fini_array</code>.</p>&#13;
<h4 class="h4" id="ch02_3_8"><em>2.3.8 The .shstrtab, .symtab, .strtab, .dynsym, and .dynstr Sections</em></h4>&#13;
<p class="noindent">As mentioned during the discussion of section headers, the <code>.shstrtab</code> section is simply an array of <code>NULL</code>-terminated strings that contain the names of all the sections in the binary. It’s indexed by the section headers to allow tools like <code>readelf</code> to find out the names of the sections.</p>&#13;
<p class="indent">The <code>.symtab</code> section contains a symbol table, which is a table of <code>Elf64_Sym</code> structures, each of which associates a symbolic name with a piece of code or data elsewhere in the binary, such as a function or variable. The actual strings containing the symbolic names are located in the <code>.strtab</code> section. These strings are pointed to by the <code>Elf64_Sym</code> structures. In practice, the binaries you’ll encounter during binary analysis will often be stripped, which means that the <code>.symtab</code> and <code>.strtab</code> tables are removed.</p>&#13;
<p class="indent">The <code>.dynsym</code> and <code>.dynstr</code> sections are analogous to <code>.symtab</code> and <code>.strtab</code>, except that they contain symbols and strings needed for dynamic linking rather than static linking. Because the information in these sections is needed during dynamic linking, they cannot be stripped.</p>&#13;
<p class="indent">Note that the static symbol table has section type <code>SHT_SYMTAB</code>, while the dynamic symbol table has type <code>SHT_DYNSYM</code>. This makes it easy for tools like <code>strip</code> to recognize which symbol tables can be safely removed when stripping a binary and which cannot.</p>&#13;
<h3 class="h3" id="ch02_4">2.4 Program Headers</h3>&#13;
<p class="noindent">The <em>program header table</em> provides a <em>segment view</em> of the binary, as opposed to the <em>section view</em> provided by the section header table. The section view of an ELF binary, which I discussed earlier, is meant for static linking purposes only. In contrast, the segment view, which I’ll discuss next, is used by the operating system and dynamic linker when loading an ELF into a process for execution to locate the relevant code and data and decide what to load into virtual memory.</p>&#13;
<p class="indent">An ELF segment encompasses zero or more sections, essentially bundling these into a single chunk. Since segments provide an execution view, they are needed only for executable ELF files and not for nonexecutable files such as relocatable objects. The program header table encodes the segment view using program headers of type <code>struct Elf64_Phdr</code>. Each program header contains the fields shown in <a href="ch02.xhtml#ch02list11">Listing 2-11</a>.</p>&#13;
<p class="listing1" id="ch02list11"><em>Listing 2-11: Definition of</em> <span class="codeitalic">Elf64_Phdr</span> <em>in</em> /usr/include/elf.h</p>&#13;
<pre>typedef struct {<br/>  uint32_t  p_type;   /* Segment type             */<br/>  uint32_t  p_flags;  /* Segment flags            */<br/>  uint64_t  p_offset; /* Segment file offset      */<br/>  uint64_t  p_vaddr;  /* Segment virtual address  */<br/>  uint64_t  p_paddr;  /* Segment physical address */<br/>  uint64_t  p_filesz; /* Segment size in file     */<br/>  uint64_t  p_memsz;  /* Segment size in memory   */<br/>  uint64_t  p_align;  /* Segment alignment        */<br/>} Elf64_Phdr;</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_53"/>I’ll describe each of these fields in the next few sections. <a href="ch02.xhtml#ch02list12">Listing 2-12</a> shows the program header table for the example binary, as displayed by <code>readelf</code>.</p>&#13;
<p class="listing1" id="ch02list12"><em>Listing 2-12: A typical program header as shown by</em> <span class="codeitalic">readelf</span></p>&#13;
<pre> $ <span class="codestrong1">readelf --wide --segments a.out</span><br/><br/> Elf file type is EXEC (Executable file)<br/> Entry point 0x400430<br/> There are 9 program headers, starting at offset 64<br/><br/> Program Headers:<br/>   Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align<br/>   PHDR           0x000040 0x0000000000400040 0x0000000000400040 0x0001f8 0x0001f8 R E 0x8<br/>   INTERP         0x000238 0x0000000000400238 0x0000000000400238 0x00001c 0x00001c R   0x1<br/>       [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]          <br/>   LOAD           0x000000 0x0000000000400000 0x0000000000400000 0x00070c 0x00070c R E 0x200000<br/>   LOAD           0x000e10 0x0000000000600e10 0x0000000000600e10 0x000228 0x000230 RW  0x200000<br/>   DYNAMIC        0x000e28 0x0000000000600e28 0x0000000000600e28 0x0001d0 0x0001d0 RW  0x8<br/>   NOTE           0x000254 0x0000000000400254 0x0000000000400254 0x000044 0x000044 R   0x4<br/>   GNU_EH_FRAME   0x0005e4 0x00000000004005e4 0x00000000004005e4 0x000034 0x000034 R   0x4<br/>   GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10<br/>   GNU_RELRO      0x000e10 0x0000000000600e10 0x0000000000600e10 0x0001f0 0x0001f0 R   0x1<br/><br/><span class="ent">➊</span> Section to Segment mapping:<br/>   Segment Sections...<br/>    00<br/>    01     .interp<br/>    02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version<br/>           .gnu.version_r .rela.dyn .rela.plt .init .plt .plt.got .text .fini .rodata<br/>           .eh_frame_hdr .eh_frame<br/>    03     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss<br/>    04     .dynamic<br/>    05     .note.ABI-tag .note.gnu.build-id<br/>    06     .eh_frame_hdr<br/>    07<br/>    08     .init_array .fini_array .jcr .dynamic .got</pre>&#13;
<p class="indent">Note the section-to-segment mapping at the bottom of the <code>readelf</code> output, which clearly illustrates that segments are simply a bunch of sections bundled together <span class="ent">➊</span>. This specific section-to-segment mapping is typical for <span epub:type="pagebreak" id="page_54"/>most ELF binaries you’ll encounter. In the rest of this section, I’ll discuss the program header fields shown in <a href="ch02.xhtml#ch02list11">Listing 2-11</a>.</p>&#13;
<h4 class="h4" id="ch02_4_1"><em>2.4.1 The p_type Field</em></h4>&#13;
<p class="noindent">The <code>p_type</code> field identifies the type of the segment. Important values for this field include <code>PT_LOAD</code>, <code>PT_DYNAMIC</code>, and <code>PT_INTERP</code>.</p>&#13;
<p class="indent">Segments of type <code>PT_LOAD</code>, as the name implies, are intended to be loaded into memory when setting up the process. The size of the loadable chunk and the address to load it at are described in the rest of the program header. As you can see in the <code>readelf</code> output, there are usually at least two <code>PT_LOAD</code> segments—one encompassing the nonwritable sections and one containing the writable data sections.</p>&#13;
<p class="indent">The <code>PT_INTERP</code> segment contains the <code>.interp</code> section, which provides the name of the interpreter that is to be used to load the binary. In turn, the <code>PT_DYNAMIC</code> segment contains the <code>.dynamic</code> section, which tells the interpreter how to parse and prepare the binary for execution. It’s also worth mentioning the <code>PT_PHDR</code> segment, which encompasses the program header table.</p>&#13;
<h4 class="h4" id="ch02_4_2"><em>2.4.2 The p_flags Field</em></h4>&#13;
<p class="noindent">The flags specify the runtime access permissions for the segment. Three important types of flags exist: <code>PF_X</code>, <code>PF_W</code>, and <code>PF_R</code>. The <code>PF_X</code> flag indicates that the segment is executable and is set for code segments (<code>readelf</code> displays it as an <code>E</code> rather than an <code>X</code> in the <code>Flg</code> column in <a href="ch02.xhtml#ch02list12">Listing 2-12</a>). The <code>PF_W</code> flag means that the segment is writable, and it is normally set only for writable data segments, never for code segments. Finally, <code>PF_R</code> means that the segment is readable, as is normally the case for both code and data segments.</p>&#13;
<h4 class="h4" id="ch02_4_3"><em>2.4.3 The p_offset, p_vaddr, p_paddr, p_filesz, and p_memsz Fields</em></h4>&#13;
<p class="noindent">The <code>p_offset</code>, <code>p_vaddr</code>, and <code>p_filesz</code> fields in <a href="ch02.xhtml#ch02list11">Listing 2-11</a> are analogous to the <code>sh_offset</code>, <code>sh_addr</code>, and <code>sh_size</code> fields in a section header. They specify the file offset at which the segment starts, the virtual address at which it is to be loaded, and the file size of the segment, respectively. For loadable segments, <code>p_vaddr</code> must be equal to <code>p_offset</code>, modulo the page size (which is typically 4,096 bytes).</p>&#13;
<p class="indent">On some systems, it’s possible to use the <code>p_paddr</code> field to specify at which address in physical memory to load the segment. On modern operating systems such as Linux, this field is unused and set to zero since they execute all binaries in virtual memory.</p>&#13;
<p class="indent">At first glance, it may not be obvious why there are distinct fields for the file size of the segment (<code>p_filesz</code>) and the size in memory (<code>p_memsz</code>). To understand this, recall that some sections only indicate the need to allocate some bytes in memory but don’t actually occupy these bytes in the binary file. For instance, the <code>.bss</code> section contains zero-initialized data. Since all data in this section is known to be zero anyway, there’s no need to actually include all these zeros in the binary. However, when loading the segment <span epub:type="pagebreak" id="page_55"/>containing <code>.bss</code> into virtual memory, all the bytes in <code>.bss</code> <em>should</em> be allocated. Thus, it’s possible for <code>p_memsz</code> to be larger than <code>p_filesz</code>. When this happens, the loader adds the extra bytes at the end of the segment when loading the binary and initializes them to zero.</p>&#13;
<h4 class="h4" id="ch02_4_4"><em>2.4.4 The p_align Field</em></h4>&#13;
<p class="noindent">The <code>p_align</code> field is analogous to the <code>sh_addralign</code> field in a section header. It indicates the required memory alignment (in bytes) for the segment. Just as with <code>sh_addralign</code>, an alignment value of 0 or 1 indicates that no particular alignment is required. If <code>p_align</code> isn’t set to 0 or 1, then its value must be a power of 2, and <code>p_vaddr</code> must be equal to <code>p_offset</code>, modulo <code>p_align</code>.</p>&#13;
<h3 class="h3" id="ch02_5">2.5 Summary</h3>&#13;
<p class="noindent">In this chapter, you learned all the intricacies of the ELF format. I covered the format of the executable header, the section header and program header tables, and the contents of sections. That was quite an endeavor! It was worth it because now that you’re familiar with the innards of ELF binaries, you have a great foundation for learning more about binary analysis. In the next chapter, you’ll take a detailed look at the PE format, which is a binary format used in Windows-based systems. If you’re interested only in analyzing ELF binaries, you can skip the next chapter and move straight to <a href="ch04.xhtml#ch04">Chapter 4</a>.</p>&#13;
<div class="box">&#13;
<p class="headbox" id="ch02_6">Exercises</p>&#13;
<p class="boxhead1">1. Manual Header Inspection</p>&#13;
<p class="noindent">Use a hex viewer such as <code>xxd</code> to view the bytes in an ELF binary in hexadecimal format. For example, you can use the command <code>xxd /bin/ls | head -n 30</code> to view the first 30 lines of bytes for the <em>/bin/ls</em> program. Can you identify the bytes representing the ELF header? Try to find all of the ELF header fields in the <code>xxd</code> output and see whether the contents of those fields make sense to you.</p>&#13;
<p class="boxhead1">2. Sections and Segments</p>&#13;
<p class="noindent">Use <code>readelf</code> to view the sections and segments in an ELF binary. How are the sections mapped into segments? Make an illustration of the binary’s on-disk representation versus its representation in memory. What are the major differences?</p>&#13;
<p class="boxhead1">3. C and C++ Binaries</p>&#13;
<p class="noindent">Use <code>readelf</code> to disassemble two binaries, namely a binary produced from C source and one produced from C++ source. What differences are there?</p>&#13;
<p class="boxhead1"><span epub:type="pagebreak" id="page_56"/>4. Lazy Binding</p>&#13;
<p class="noindent">Use <code>objdump</code> to disassemble the PLT section of an ELF binary. Which GOT entries do the PLT stubs use? Now view the contents of those GOT entries (again with <code>objdump</code>) and analyze their relationship with the PLT.</p>&#13;
</div>&#13;
</div></body></html>