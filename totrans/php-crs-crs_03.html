<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="ch2" epub:type="chapter" role="doc-chapter">
<span aria-label="27" epub:type="pagebreak" id="pg_27" role="doc-pagebreak"/>
<hgroup>
<h2 class="CHAPTER" id="ch2">
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">2</span></span>
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">DATA TYPES</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="380" src="../images/opener.jpg" width="380"/>
</figure>
<p class="INTRO">In this chapter, we’ll explore the data types available in PHP. We’ll also consider how to force a value into a specified data type (<i>type casting</i>), as well as situations where PHP automatically attempts to convert data types to make the various parts of expressions work together (<i>type juggling</i>).</p>
<p class="TX">A <i>data type</i> is a categorization of a value in a program that specifies how the PHP engine is to interpret that value and therefore which operations can be applied to it. For example, if a value is an integer, the PHP engine knows that operations such as addition and multiplication are permitted and that the outcomes of those operations are themselves integers; meanwhile, the PHP engine knows that the outcome of division on an integer might be another integer or a floating-point (decimal) number.</p>
<p class="TX">Understanding which data types are available—and knowing when and how a value’s data type can change—is essential as you work with inputs, perform calculations, and output data. If you don’t know the type of data you’re manipulating or how that data responds to various operations, you might get unexpected results.</p>
<section aria-labelledby="sec1" epub:type="division">
<span aria-label="28" epub:type="pagebreak" id="pg_28" role="doc-pagebreak"/>
<h3 class="H1" id="sec1"><span id="toc-link_21"/><span class="SANS_Futura_Std_Bold_B_11">PHP Data Types</span></h3>
<p class="TNI1">In <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, we stored the word <span class="SANS_TheSansMonoCd_W5Regular_11">"matt"</span> in a variable and assigned the number <span class="SANS_TheSansMonoCd_W5Regular_11">99</span> to a constant. These values are of different data types: one is a string, and the other an integer. In all, PHP has 10 built-in data types divided into three categories, as shown in <a href="#fig2-1">Figure 2-1</a>.</p>
<figure class="IMG"><a id="fig2-1"/><img alt="" class="img100" height="779" src="../images/figure2-1.jpg" width="1149"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-1: PHP data types</span></p></figcaption>
</figure>
<p class="TX">For now, we’ll mostly focus on the four <i>scalar</i> data types, which can hold only one value at a time. We’ll also pay some attention to the special <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> data type. In later chapters, you’ll learn about two of the <i>compound</i> data types, <span class="SANS_TheSansMonoCd_W5Regular_11">array</span> (in <span class="Xref"><a href="chapter8.xhtml">Chapters 8</a></span> and <span class="Xref"><a href="chapter9.xhtml">9</a></span>) and <span class="SANS_TheSansMonoCd_W5Regular_11">object</span> (in <span class="Xref"><a href="part5.xhtml">Part V</a></span>), which can store and manipulate collections of multiple values. The <span class="SANS_TheSansMonoCd_W5Regular_11">resource</span> special type and the <span class="SANS_TheSansMonoCd_W5Regular_11">callable</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">iterable</span> compound types are used only in complex and special cases and won’t be considered in this book.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="H2" id="sec2"><span id="toc-link_22"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Scalar Data Types</span></h4>
<p class="TNI1">The four scalar (single-value) data types are <span class="SANS_TheSansMonoCd_W5Regular_11">string</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">int</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">float</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">bool</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">string</span> type is for text, the <span class="SANS_TheSansMonoCd_W5Regular_11">int</span> type is for whole numbers (integers), the <span class="SANS_TheSansMonoCd_W5Regular_11">float</span> type is for floating-point (decimal) numbers, and the <span class="SANS_TheSansMonoCd_W5Regular_11">bool</span> type is for Boolean true/false values.</p>
<p class="TX">Let’s use PHP’s <i>interactive mode</i> to explore the scalar data types. This mode allows you to enter individual PHP statements at the command line and immediately see the results. We’ll use interactive mode in the coming chapters to quickly demonstrate basic concepts and get instant feedback, instead of having to write full PHP scripts. Enter <span class="SANS_TheSansMonoCd_W7Bold_11">php -a</span> at the command line to turn on interactive mode and then enter the following:</p>
<pre><code>php &gt; <b>$username = "matt";</b>&#13;
php &gt; <b>print gettype($username);</b>&#13;
string</code></pre>
<p class="TX"><span aria-label="29" epub:type="pagebreak" id="pg_29" role="doc-pagebreak"/>Here we once again assign the value <span class="SANS_TheSansMonoCd_W5Regular_11">"matt"</span> to the <span class="SANS_TheSansMonoCd_W5Regular_11">$username</span> variable. We then use PHP’s built-in <span class="SANS_TheSansMonoCd_W5Regular_11">gettype()</span> function to print out the variable’s type. The output confirms that <span class="SANS_TheSansMonoCd_W5Regular_11">$username</span> contains a string.</p>
<p class="TX">If you’ve previously seen or written code in strongly typed languages like Java or C#, you may have noticed that you don’t have to specify the data type when assigning a value to a variable. PHP is a <i>loosely typed</i> language, meaning that the same variable can store values of different data types at different times and that the PHP engine will automatically infer the data type of an expression.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>We can also explicitly declare data types in PHP, something we’ll do starting in <a href="chapter5.xhtml">Chapter 5</a> when we begin writing functions. For now, though, as we work with simple variables, we’ll let the interpreter infer data types.</i></p>
<p class="TX">In the case of the <span class="SANS_TheSansMonoCd_W5Regular_11">$username</span> variable, the value <span class="SANS_TheSansMonoCd_W5Regular_11">"matt"</span> is inferred to be a string. We can similarly assign variables numeric values with or without decimals, and PHP will interpret them as integers or floats as appropriate:</p>
<pre><code>php &gt; <b>$age = 21;</b>&#13;
php &gt; <b>print gettype($age);</b>&#13;
integer&#13;
php &gt; <b>$price = 9.99;</b>&#13;
php &gt; <b>print gettype($price);</b>&#13;
double</code></pre>
<p class="TX">Here we see that <span class="SANS_TheSansMonoCd_W5Regular_11">$age</span>, with its whole-number value, has been interpreted as an integer, and <span class="SANS_TheSansMonoCd_W5Regular_11">$price</span>, whose value includes a decimal, has been interpreted as ... a <i>double</i>? Although the documentation refers to floating-point values as being of the <span class="SANS_TheSansMonoCd_W5Regular_11">float</span> data type, for historical reasons (PHP is an old language!) the function <span class="SANS_TheSansMonoCd_W5Regular_11">gettype()</span> returns <span class="SANS_TheSansMonoCd_W5Regular_11">double</span> when used on floats—a reference to the double-precision format for storing floating-point values. PHP has only one kind of floating-point data type, however, so while other programming languages may have different precision and memory representations for floats, doubles, reals, and so on, all floating-point values in PHP are of the <span class="SANS_TheSansMonoCd_W5Regular_11">float</span> data type (no matter what the <span class="SANS_TheSansMonoCd_W5Regular_11">gettype()</span> function says).</p>
<p class="TX">Let’s try creating a variable of the <span class="SANS_TheSansMonoCd_W5Regular_11">bool</span> type next. Enter the following:</p>
<pre><code>php &gt; <b>$isDutyFree = true;</b>&#13;
php &gt; <b>print gettype($isDutyFree);</b>&#13;
boolean&#13;
php &gt; <b>print $isDutyFree;</b>&#13;
1</code></pre>
<p class="TX">When we use <span class="SANS_TheSansMonoCd_W5Regular_11">gettype()</span> on the <span class="SANS_TheSansMonoCd_W5Regular_11">$isDutyFree</span> variable, we see <span class="SANS_TheSansMonoCd_W5Regular_11">boolean</span> displayed. This is an alias for <span class="SANS_TheSansMonoCd_W5Regular_11">bool</span> in PHP; the two are mostly interchangeable, but to avoid some cases where aliases don’t work, always write <span class="SANS_TheSansMonoCd_W5Regular_11">bool</span> in your code (and I’ll do so in this book).</p>
<p class="TX">More curiously, notice that when we try to print the value of <span class="SANS_TheSansMonoCd_W5Regular_11">$isDutyFree</span>, we see the number <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> rather than <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> in the output. This isn’t an error. It’s <span aria-label="30" epub:type="pagebreak" id="pg_30" role="doc-pagebreak"/>related to the way <span class="SANS_TheSansMonoCd_W5Regular_11">bool</span> values are converted, or <i>juggled</i>, into strings. The <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> command expects a string, so whatever we provide after the keyword <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> is automatically converted into a string expression by the PHP engine. For the <span class="SANS_TheSansMonoCd_W5Regular_11">bool</span> type, <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> is converted to the string <span class="SANS_TheSansMonoCd_W5Regular_11">"1"</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> is converted to an empty string (that is, a string with no content, denoted by a set of quotation marks with nothing in between: <span class="SANS_TheSansMonoCd_W5Regular_11">""</span>). We’ll discuss conversion to another data type through manual casting and automatic type juggling in more detail later in the chapter.</p>
<p class="TX">To see the actual Boolean value of <span class="SANS_TheSansMonoCd_W5Regular_11">$isDutyFree</span>, use the built-in <span class="SANS_TheSansMonoCd_W5Regular_11">var_dump()</span> function instead of <span class="SANS_TheSansMonoCd_W5Regular_11">print</span>. This useful function outputs information about a variable. It’s helpful when learning PHP and for debugging purposes to know the value of a variable at a certain point in the execution of your code:</p>
<pre><code>php &gt; <b>$isDutyFree = true;</b>&#13;
php &gt; <b>var_dump($isDutyFree);</b>&#13;
bool(true)</code></pre>
<p class="TX">The output from <span class="SANS_TheSansMonoCd_W5Regular_11">var_dump()</span> confirms that the data type of <span class="SANS_TheSansMonoCd_W5Regular_11">$isDutyFree</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">bool</span> and that its value is <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="H2" id="sec3"><span id="toc-link_23"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">The Special NULL Type</span></h4>
<p class="TNI1">PHP has a special data type represented in code by the constant <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">null</span> (it’s case insensitive). A variable is <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> in three situations. In the first, a variable has never been assigned a value, as shown here:</p>
<pre><code>php &gt; <b>var_dump($lastName);</b>&#13;
Warning: Undefined variable $lastName in php shell code on line 1&#13;
NULL</code></pre>
<p class="TX">When we try <span class="SANS_TheSansMonoCd_W5Regular_11">var_dump()</span> on <span class="SANS_TheSansMonoCd_W5Regular_11">$lastName</span> without giving the variable a value, we first get a warning that <span class="SANS_TheSansMonoCd_W5Regular_11">$lastName</span> is undefined. Then we see that the variable, not having been given a value, evaluates to <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>.</p>
<p class="TX">Second, a variable is <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> if it’s been explicitly assigned the constant <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> as its value:</p>
<pre><code>php &gt; <b>$firstName = NULL;</b>&#13;
php &gt; <b>var_dump($firstName);</b>&#13;
NULL</code></pre>
<p class="TX">Here we see an important difference between a variable never having been given a value, as in the previous example, and a variable containing the value <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>. In the first case, <span class="SANS_TheSansMonoCd_W5Regular_11">var_dump()</span> produces a warning, whereas in this case we don’t get a warning; we just see the variable’s value (<span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>) printed out. Assigning a variable the value <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> is fine, just like assigning a variable another value.</p>
<p class="TX"><span aria-label="31" epub:type="pagebreak" id="pg_31" role="doc-pagebreak"/>Finally, a variable will be <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> if it has been <i>unset</i>, or cleared of its value, with the built-in <span class="SANS_TheSansMonoCd_W5Regular_11">unset()</span> function:</p>
<pre><code>php &gt; <b>$lastName = "Smith"</b>&#13;
php &gt; <b>var_dump($lastName);</b>&#13;
string(5) "Smith"&#13;
php &gt; <b>unset($lastName);</b>&#13;
php &gt; <b>var_dump($lastName);</b>&#13;
Warning: Undefined variable $lastName in php shell code on line 1&#13;
NULL</code></pre>
<p class="TX">Here we give <span class="SANS_TheSansMonoCd_W5Regular_11">$lastName</span> a value and then use <span class="SANS_TheSansMonoCd_W5Regular_11">unset()</span> to get rid of that value. When we try to use <span class="SANS_TheSansMonoCd_W5Regular_11">var_dump()</span> on <span class="SANS_TheSansMonoCd_W5Regular_11">$lastName</span> after unsetting it, we get the same warning as before and see that it evaluates to <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>. Unsetting a variable is the same as never having given it a value in the first place.</p>
<p class="TX">When working with variables and data items in more complex programs, you’ll sometimes need to design logic to handle encounters with <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>. For example, if you’re creating a connection to a database but have a problem connecting, the connection variable will be set to <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>. In another example, if you expect to be passed a reference to an object (such as the logged-in user) but no such object exists, then a variable will be <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>. We’ll explore these kinds of situations in <span class="Xref"><a href="part5.xhtml">Parts V</a></span> and <span class="Xref"><a href="part6.xhtml">VI</a></span>, when we discuss object-oriented programming and databases.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="H2" id="sec4"><span id="toc-link_24"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Functions to Test for a Data Type</span></h4>
<p class="TNI1">PHP has many functions that produce <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> based on whether the provided variable or expression is of a certain data type. These include <span class="SANS_TheSansMonoCd_W5Regular_11">is_string()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">is_int()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">is_float()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">is_bool()</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">is_null()</span>. Such functions are useful if you need to confirm that a variable is of a particular type before trying to work with it or, conversely, if you need to check that a variable isn’t <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>. Here are some examples of these functions in action:</p>
<pre><code>php &gt; <b>$gpa = 3.5;</b>&#13;
php &gt; <b>var_dump(is_string($gpa));</b>&#13;
bool(false)&#13;
php &gt; <b>var_dump(is_int($gpa));</b>&#13;
bool(false)&#13;
php &gt; <b>var_dump(is_float($gpa));</b>&#13;
bool(true)&#13;
php &gt; <b>$middleName = NULL;</b>&#13;
php &gt; <b>var_dump(is_bool($middleName));</b>&#13;
bool(false)&#13;
php &gt; <b>var_dump(is_null($middleName));</b>&#13;
bool(true)</code></pre>
<p class="TX">Our variable <span class="SANS_TheSansMonoCd_W5Regular_11">$gpa</span> contains a decimal value, so only <span class="SANS_TheSansMonoCd_W5Regular_11">is_float()</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> for it. Similarly, <span class="SANS_TheSansMonoCd_W5Regular_11">$middleName</span> contains <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>, so passing it to <span class="SANS_TheSansMonoCd_W5Regular_11">is_null()</span> yields <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>.</p>
<p class="TX"><span aria-label="32" epub:type="pagebreak" id="pg_32" role="doc-pagebreak"/>Some of PHP’s type-checking functions are <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> for broader categories of data types. For example, the <span class="SANS_TheSansMonoCd_W5Regular_11">is_numeric()</span> function is <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> for variables of type <span class="SANS_TheSansMonoCd_W5Regular_11">int</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">float</span>:</p>
<pre><code>php &gt; <b>$gpa = 3.5;</b>&#13;
php &gt; <b>$age = 21;</b>&#13;
php &gt; <b>var_dump(is_numeric($gpa));</b>&#13;
bool(true)&#13;
php &gt; <b>var_dump(is_numeric($age))</b>;&#13;
bool(true)</code></pre>
<p class="TX">Here we see both the decimal value <span class="SANS_TheSansMonoCd_W5Regular_11">3.5</span> and the whole-number value <span class="SANS_TheSansMonoCd_W5Regular_11">21</span> pass the <span class="SANS_TheSansMonoCd_W5Regular_11">is_numeric()</span> test. The same function is also <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> for strings that contain only numeric characters, but not if non-numeric characters are mixed in:</p>
<pre><code>php &gt; <b>$price = "9.99";</b>&#13;
php &gt; <b>var_dump(is_numeric($price));</b>&#13;
bool(true)&#13;
php &gt; <b>$price = "9.99 dollars";</b>&#13;
php &gt; <b>var_dump(is_numeric($price));</b>&#13;
bool(false)</code></pre>
<p class="TX">When <span class="SANS_TheSansMonoCd_W5Regular_11">$price</span> contains the string <span class="SANS_TheSansMonoCd_W5Regular_11">"9.99"</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">is_numeric()</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>. When we add the word <i>dollars</i> to the end of the string, however, <span class="SANS_TheSansMonoCd_W5Regular_11">is_numeric()</span> becomes <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>.</p>
</section>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H1" id="sec5"><span id="toc-link_25"/><span class="SANS_Futura_Std_Bold_B_11">Type Juggling</span></h3>
<p class="TNI1">In some situations, the PHP engine automatically converts a value from one data type to another. This is known as <i>type juggling</i>. Consider this example:</p>
<pre><code>php &gt; <b>$answer = "1" + 3;</b>&#13;
php &gt; <b>var_dump($answer);</b>&#13;
int(4)</code></pre>
<p class="TX">Here we try to add the string <span class="SANS_TheSansMonoCd_W5Regular_11">"1"</span> and the integer <span class="SANS_TheSansMonoCd_W5Regular_11">3</span>. When the PHP engine evaluates this expression and stores the result in <span class="SANS_TheSansMonoCd_W5Regular_11">$answer</span>, it will see the plus-sign operator (<span class="SANS_TheSansMonoCd_W5Regular_11">+</span>) and assume that numeric addition is meant to take place. The PHP engine will therefore examine the two operands (the values on either side of the plus sign) and try to interpret them as numbers (floats or integers). The <span class="SANS_TheSansMonoCd_W5Regular_11">3</span> is already an integer, but the string <span class="SANS_TheSansMonoCd_W5Regular_11">"1"</span> will be converted (juggled) into an integer to allow the addition to take place. In the end, we get the integer <span class="SANS_TheSansMonoCd_W5Regular_11">4</span> as an answer.</p>
<p class="TX">In six kinds of situations, PHP automatically juggles expressions into different types: numeric contexts, string contexts, comparative contexts, logic contexts, function contexts, and bitwise (integral and string) contexts. We’ll consider some of these contexts next.</p>
<section aria-labelledby="sec6" epub:type="division">
<span aria-label="33" epub:type="pagebreak" id="pg_33" role="doc-pagebreak"/>
<h4 class="H2" id="sec6"><span id="toc-link_26"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Numeric Contexts</span></h4>
<p class="TNI1">When an expression includes an arithmetic operator, PHP will try to juggle the operands to integers or floats. This often happens when one or more of the operands are strings, as in the <span class="SANS_TheSansMonoCd_W5Regular_11">"1" + 3</span> example we just looked at. We’ll see an example of this in action when function parameters are coerced into integers in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>. Boolean values can also be juggled into integers; <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> becomes the integer <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> becomes the integer <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>.</p>
<p class="TX">Two important questions arise when juggling in numeric contexts: Will the result become an <span class="SANS_TheSansMonoCd_W5Regular_11">int</span> or a <span class="SANS_TheSansMonoCd_W5Regular_11">float</span>, and what happens when a string includes both numeric and non-numeric characters?</p>
<section aria-labelledby="sec7" epub:type="division">
<h5 class="H3" id="sec7"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Integer vs. Float</span></h5>
<p class="TNI1">If either operand in an arithmetic expression is a float (or isn’t interpretable as an integer), both values will be juggled into floats, and a float operation is performed. Otherwise, both values will be juggled into integers, and an integer operation is performed. For example, when both operands are integers, the result is an integer:</p>
<pre><code>php &gt; <b>$answer = (1 + 1);</b>&#13;
php &gt; <b>var_dump($answer);</b>&#13;
int(2)</code></pre>
<p class="TX">When one operand is an integer, and the other is a numeric string that evaluates to an integer, both operators become integers. The result is also an integer:</p>
<pre><code>php &gt; <b>$answer = (1 + "1");</b>&#13;
php &gt; <b>var_dump($answer);</b>&#13;
int(2)</code></pre>
<p class="TX">Leading and trailing whitespace is ignored when strings are juggled into numbers, so we’ll get the same result if we add spaces at either end of the string:</p>
<pre><code>php &gt; <b>$answer = (1 + "  1 ");</b>&#13;
php &gt; <b>var_dump($answer);</b>&#13;
int(2)</code></pre>
<p class="BodyContinued">Notice that the extra spaces in the string before and after the <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> character make no difference. The string is still juggled to the integer <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>.</p>
<p class="TX">When both operands are numbers and one of the operands is a float, both operands become floats. The result is also a float:</p>
<pre><code>php &gt; <b>$answer = (1.5 + 1);</b>&#13;
php &gt; <b>var_dump($answer);</b>&#13;
float(2.5)</code></pre>
<p class="BodyContinued">To arrive at this result of <span class="SANS_TheSansMonoCd_W5Regular_11">2.5</span>, the integer <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> is juggled to a float behind the scenes, before the addition operation is performed. The same process occurs <span aria-label="34" epub:type="pagebreak" id="pg_34" role="doc-pagebreak"/>when one operand is an integer and the other is a numeric string that evaluates to a float. Both operands become floats, and the result is a float:</p>
<pre><code>php &gt; <b>$answer = (1 + "9.9");</b>&#13;
php &gt; <b>var_dump($answer);</b>&#13;
float(10.9)</code></pre>
<p class="TX">In short, if float arithmetic is needed, PHP uses float arithmetic. Otherwise, it uses integer arithmetic.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h5 class="H3" id="sec8"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Numeric, Leading Numeric, and Non-numeric Strings</span></h5>
<p class="TNI1">PHP differentiates between <i>numeric strings</i>, whose entire contents evaluate to an integer or a float, and <i>leading numeric strings</i>, which begin with numeric characters but also include non-numeric characters such as letters or special symbols. When a leading numeric string is juggled to an integer or float, everything from the first non-numeric character on is dropped. If a string <i>starts</i> with a non-numeric character, however, the entire string is considered <i>non-numeric</i>, even if it also contains numbers, and it can’t be juggled to a number.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>The exception to this rule about non-numeric characters at the start of a string is the special case of a string beginning with spaces, followed by numeric characters. Such a string will be treated as a numeric string, since leading (or trailing) spaces are ignored.</i></p>
<p class="TX">Let’s try numeric addition with a leading numeric string that evaluates to an integer:</p>
<pre><code>php &gt; <b>$answer = (1 + "1 dollar");</b>&#13;
Warning:  A non-numeric value encountered in php shell code on line 1&#13;
php &gt; <b>var_dump($answer);</b>&#13;
int(2)</code></pre>
<p class="TX">Here <span class="SANS_TheSansMonoCd_W5Regular_11">"1 dollar"</span> is a leading numeric string. When used in an arithmetic expression, the <span class="SANS_TheSansMonoCd_W5Regular_11">"1"</span> at the beginning is juggled to an integer, while the <span class="SANS_TheSansMonoCd_W5Regular_11">" dollar"</span> at the end is ignored. Notice that PHP raises a warning about this but goes ahead with the type conversion anyway. Since both operands can be juggled into integers, the result is an integer.</p>
<p class="TX">Addition with a leading numeric string that evaluates to a float works the same way:</p>
<pre><code>php &gt; <b>$answer = (1 + "9.99 dollars");</b>&#13;
Warning:  A non-numeric value encountered in php shell code on line 1&#13;
php &gt; <b>var_dump($answer);</b>&#13;
int(10.99)</code></pre>
<p class="TX">In this case, <span class="SANS_TheSansMonoCd_W5Regular_11">"9.99 dollars"</span> is a leading numeric string whose beginning evaluates to the float <span class="SANS_TheSansMonoCd_W5Regular_11">9.99</span>. Since both operands can be juggled into floats, the result is a float. Again, PHP raises a warning because of the leading numeric string.</p>
<p class="TX"><span aria-label="35" epub:type="pagebreak" id="pg_35" role="doc-pagebreak"/>By contrast, if you try to use a non-numeric string in an arithmetic expression, you’ll get a <span class="SANS_TheSansMonoCd_W5Regular_11">TypeError</span>, meaning the operation can’t be performed with the given data types. This halts the execution of the code. Here’s an example:</p>
<pre><code>php &gt; <b>$answer = (1 + "April 1");</b>&#13;
Warning: Uncaught TypeError: Unsupported operand types: int + string in&#13;
php shell code:1&#13;
Stack trace:&#13;
#0 {main}&#13;
  thrown in php shell code on line 1</code></pre>
<p class="TX">Here <span class="SANS_TheSansMonoCd_W5Regular_11">"April 1"</span> is a non-numeric string because it starts with letters, not numbers. The string can’t be evaluated as a number, so it triggers an error. The same error happens if we use an empty string (<span class="SANS_TheSansMonoCd_W5Regular_11">""</span>):</p>
<pre><code>php &gt; <b>$answer = (1 + "");</b>&#13;
Warning: Uncaught TypeError: Unsupported operand types: int + string in&#13;
php shell code:1&#13;
Stack trace:&#13;
#0 {main}&#13;
  thrown in php shell code on line 1</code></pre>
<p class="TX">An empty string does <i>not</i> evaluate to <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> as it does in some other languages. It’s a non-numeric string, so it leads to a <span class="SANS_TheSansMonoCd_W5Regular_11">TypeError</span> in arithmetic expressions.</p>
</section>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="H2" id="sec9"><span id="toc-link_27"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">String Contexts</span></h4>
<p class="TNI1">In a few cases, PHP automatically juggles values into strings. First, expressions involving <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> statements are juggled to strings, since these commands expect anything that follows to be a string. You’ve already seen, for example, that values of type <span class="SANS_TheSansMonoCd_W5Regular_11">bool</span> are juggled to the string <span class="SANS_TheSansMonoCd_W5Regular_11">"1"</span> (for <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>) or <span class="SANS_TheSansMonoCd_W5Regular_11">""</span> (for <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>) when they’re part of a <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> statement. Similarly, numbers are juggled to their string equivalents.</p>
<p class="TX">Second, expressions involving the string concatenation operator (<span class="SANS_TheSansMonoCd_W5Regular_11">.</span>) are also juggled to strings, as are expressions whose values are being parsed inside strings. We’ll discuss these topics in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="H2" id="sec10"><span id="toc-link_28"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Comparative Contexts</span></h4>
<p class="TNI1">Type juggling also occurs when comparing two values of different data types. Comparative expressions evaluate to a Boolean <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>, which you then typically use for decision-making logic (as we’ll discuss in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>). The PHP engine knows an expression is comparative when it sees a <i>comparison operator</i>, such as <span class="SANS_TheSansMonoCd_W5Regular_11">==</span> for <i>equal</i> or <span class="SANS_TheSansMonoCd_W5Regular_11">&gt;</span> for <i>greater than</i>. PHP has rules that determine how these expressions are juggled and evaluated, depending on the data types involved.</p>
<section aria-labelledby="sec11" epub:type="division">
<h5 class="H3" id="sec11"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Identical vs. Equal Values</span></h5>
<p class="TNI1">PHP makes an important distinction between values that are identical and values that are equal. Two expressions are considered <i>identical</i> only if (<i>before</i> <span aria-label="36" epub:type="pagebreak" id="pg_36" role="doc-pagebreak"/>any type juggling) they’re of the same data type and contain the same value. By contrast, two expressions are considered <i>equal</i> if they contain the same value <i>after</i> type juggling.</p>
<p class="TX">We use different operators to test for identity and equality. The triple equal sign (<span class="SANS_TheSansMonoCd_W5Regular_11">===</span>) is the <i>identical operator</i>, while the double equal sign (<span class="SANS_TheSansMonoCd_W5Regular_11">==</span>) is the <i>equal operator</i>. Consider these examples comparing the string <span class="SANS_TheSansMonoCd_W5Regular_11">"1"</span> and the integer <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>:</p>
<pre><code>php &gt; <b>var_dump("1" === 1);</b>&#13;
bool(false)&#13;
php &gt; <b>var_dump("1" == 1);</b>&#13;
bool(true)</code></pre>
<p class="TX">First, we try the comparison with the identical operator. This evaluates to <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>, since the operands are of different data types. Next, we try the comparison with the equal operator. This time it evaluates to <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>, since PHP juggles the string <span class="SANS_TheSansMonoCd_W5Regular_11">"1"</span> into an integer before making the comparison.</p>
<p class="TX">PHP also has operators for not-identical (<span class="SANS_TheSansMonoCd_W5Regular_11">!==</span>) and not-equal (<span class="SANS_TheSansMonoCd_W5Regular_11">!=</span>). Consider these comparisons between an integer and a float:</p>
<pre><code>php &gt; <b>var_dump(1 !== 1.0);</b>&#13;
bool(true)&#13;
php &gt; <b>var_dump(1 != 1.0);</b>&#13;
bool(false)</code></pre>
<p class="TX">Using the not-identical operator, the comparison is <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>, since the values are of different data types. Using the not-equal operator, the numbers are first juggled to the same type. This gives them the same value, so the not-equal comparison is <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>The PHP</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">&lt;&gt;</span> <i>operator is equivalent to the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">!=</span> <i>operator; both mean “not equal.” Personally, I always use the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">!=</span> <i>operator, since an exclamation mark (</i><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">!</span><i>) by itself means “not” in other contexts too.</i></p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h5 class="H3" id="sec12"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Strings vs. Numbers</span></h5>
<p class="TNI1">Since PHP 8.0, when comparing a string with a number, a numeric comparison is made if the string is a numeric string. Otherwise, a string comparison is made. We saw a numeric comparison when we tested the equality of the integer <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> and the numeric string <span class="SANS_TheSansMonoCd_W5Regular_11">"1"</span>. If we try the same comparison with a leading numeric string, the result will be <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>:</p>
<pre><code>php &gt; <b>var_dump(1 == "1 dollar");</b>&#13;
bool(false)</code></pre>
<p class="TX">Though <span class="SANS_TheSansMonoCd_W5Regular_11">"1 dollar"</span> starts with a number, it isn’t a fully numeric string. As such, PHP juggles the integer <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> to the string <span class="SANS_TheSansMonoCd_W5Regular_11">"1"</span> and makes a string comparison. The strings aren’t equal, so we get <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>.</p>
<p class="TX">Two important implications of using only numeric comparisons for fully numeric strings are that any leading or trailing spaces are ignored and <span aria-label="37" epub:type="pagebreak" id="pg_37" role="doc-pagebreak"/>that an empty string is <i>not</i> considered a numeric string and so is not equal to a numeric <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, as shown here:</p>
<pre><code>php &gt; <b>var_dump(0 == "");</b>&#13;
bool(false)</code></pre>
<p class="TX">In this comparison, since the empty string isn’t numeric, the integer <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> is juggled into the string <span class="SANS_TheSansMonoCd_W5Regular_11">"0"</span>. Then strings <span class="SANS_TheSansMonoCd_W5Regular_11">"0"</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">""</span> are compared and found to be not equal.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h5 class="H3" id="sec13"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Less Than and Greater Than</span></h5>
<p class="TNI1">When working with numbers, using the less-than (<span class="SANS_TheSansMonoCd_W5Regular_11">&lt;</span>), greater-than (<span class="SANS_TheSansMonoCd_W5Regular_11">&gt;</span>), less-than-or-equal-to (<span class="SANS_TheSansMonoCd_W5Regular_11">&lt;=</span>), or greater-than-or-equal-to (<span class="SANS_TheSansMonoCd_W5Regular_11">&gt;=</span>) operators is straightforward, since it’s very clear whether one number is less than, equal to, or greater than another. Here are some examples:</p>
<pre><code>php &gt; <b>var_dump(1 &lt; 2);</b>&#13;
bool(true)&#13;
php &gt; <b>var_dump(1 &lt;= 1.01)</b>&#13;
bool(true)&#13;
php &gt; <b>var_dump(2 &gt;= 2);</b>&#13;
bool(true)&#13;
php &gt; <b>var_dump(2 &gt; 2);</b>&#13;
bool(false)</code></pre>
<p class="TX">You can also use these operators with non-numeric data types, in which case PHP has a variety of rules for evaluating the comparisons. For example, the Boolean <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> is considered greater than <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> and also greater than <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>:</p>
<pre><code>php &gt; <b>var_dump(true &gt; false);</b>&#13;
bool(true)&#13;
php &gt; v<b>ar_dump(true &gt; NULL);</b>&#13;
bool(true)</code></pre>
<p class="TX">Strings are compared with each other one character at a time, with later letters in the alphabet considered greater than earlier letters:</p>
<pre><code>php &gt; <b>var_dump("abc" &lt; "acb");</b>&#13;
bool(true)</code></pre>
<p class="TX">Lowercase letters are considered greater than capital letters, however:</p>
<pre><code>php &gt; <b>var_dump("a" &gt; "B");</b>&#13;
bool(true)</code></pre>
<p class="TX">Strings are typically considered greater than any number, as in these cases:</p>
<pre><code>php &gt; <b>var_dump("abc" &gt; 123);</b>&#13;
bool(true)&#13;
<span aria-label="38" epub:type="pagebreak" id="pg_38" role="doc-pagebreak"/>php &gt; <b>var_dump("one" &gt; 1000000);</b>&#13;
bool(true)</code></pre>
<p class="TX">Exceptions to such general rules of thumb exist, however. As we’ve already discussed, when a fully numeric string is compared to a number, the string is first juggled to a number and then a numeric comparison is made. Here, for example, the string <span class="SANS_TheSansMonoCd_W5Regular_11">"15"</span> becomes the integer <span class="SANS_TheSansMonoCd_W5Regular_11">15</span> for the purposes of comparison:</p>
<pre><code>php &gt; <b>var_dump("15" &lt; 19);</b>&#13;
bool(true)</code></pre>
<p class="TX">Another exception is strings beginning with a special character such as these: <span class="SANS_TheSansMonoCd_W5Regular_11">! # $ % &amp; ' () * + , - . /</span>. Such a string is always considered less than a number:</p>
<pre><code>php &gt; <b>var_dump("*77" &lt; 5);</b>&#13;
bool(true)</code></pre>
<p class="TX">If a number is compared with a leading numeric string (one that starts with numbers but contains other characters), the number is juggled to a string, and the strings are compared character by character:</p>
<pre><code>php &gt; <b>var_dump("1a" &gt; 10);</b>&#13;
bool(true)&#13;
php &gt; <b>var_dump("1a" &gt; 20);</b>&#13;
bool(false)</code></pre>
<p class="TX">In the first case, the integer <span class="SANS_TheSansMonoCd_W5Regular_11">10</span> is converted to the string <span class="SANS_TheSansMonoCd_W5Regular_11">"10"</span> before comparison with the string <span class="SANS_TheSansMonoCd_W5Regular_11">"1a"</span>. The first characters are the same, but the character <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> (a letter) is considered greater than the character <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> (a number). In the second case, the <span class="SANS_TheSansMonoCd_W5Regular_11">2</span> in the string <span class="SANS_TheSansMonoCd_W5Regular_11">"20"</span> (after juggling) is considered greater than the <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> in the string <span class="SANS_TheSansMonoCd_W5Regular_11">"1a"</span>, so the expression is <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>.</p>
<p class="TX">Knowing these string-number and Boolean comparison rules is useful, but relying on them can be dangerous. It’s safer to use validation logic to convert strings to numbers first and then make simple numeric comparisons. For example, we’ll test that the price received from a web form is numeric in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h5 class="H3" id="sec14"><span class="SANS_Futura_Std_Bold_Condensed_B_11">The Spaceship Operator</span></h5>
<p class="TNI1">A relatively new addition to the PHP language is the <i>spaceship operator</i> (<span class="SANS_TheSansMonoCd_W5Regular_11">&lt;=&gt;</span>). Instead of <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>, this operator gives an integer value of <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">-1</span> depending on the two expressions being compared. If both expressions are the same (after any type juggling), the operator gives a <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>; if the first expression is greater than the second, it gives a <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>; or if the second expression is greater than the first, it gives a <span class="SANS_TheSansMonoCd_W5Regular_11">-1</span>. For example:</p>
<pre><code>php &gt; <b>var_dump(11 &lt;=&gt; 22);</b>&#13;
int(-1)&#13;
<span aria-label="39" epub:type="pagebreak" id="pg_39" role="doc-pagebreak"/>php &gt; <b>var_dump(55 &lt;=&gt; 22);</b>&#13;
int(1)&#13;
php &gt; <b>var_dump("22" &lt;=&gt; 22);</b>&#13;
int(0)</code></pre>
<p class="TX">In the first case, we see <span class="SANS_TheSansMonoCd_W5Regular_11">-1</span> as the output, since <span class="SANS_TheSansMonoCd_W5Regular_11">11</span> is less than <span class="SANS_TheSansMonoCd_W5Regular_11">22</span>. In the second case, we see <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> as the output, since <span class="SANS_TheSansMonoCd_W5Regular_11">55</span> is greater than <span class="SANS_TheSansMonoCd_W5Regular_11">22</span>. In the last case, we see <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> as the output, since <span class="SANS_TheSansMonoCd_W5Regular_11">"22"</span> is the same as <span class="SANS_TheSansMonoCd_W5Regular_11">22</span> after type juggling.</p>
<p class="TX">The spaceship operator may seem like a strange amalgam of the less-than, greater-than, and equal-to operators. However, it’s particularly useful when sorting collections of data into a desired sequence, since certain sorting functions require exactly this <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">-1</span> encoding scheme.</p>
</section>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h4 class="H2" id="sec15"><span id="toc-link_29"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Logical and Other Contexts</span></h4>
<p class="TNI1">When a logical value of <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> is expected, PHP will juggle values of other types to the <span class="SANS_TheSansMonoCd_W5Regular_11">bool</span> type. The three logical type-juggling contexts are as follows:</p>
<ul class="ul">
<li class="ListBullet">Logical operators, such as AND (<span class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</span>) and OR (<span class="SANS_TheSansMonoCd_W5Regular_11">||</span>)</li>
<li class="ListBullet">The ternary operator (<span class="SANS_TheSansMonoCd_W5Regular_11">?</span>)</li>
<li class="ListBullet">Conditional statements such as <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span></li>
</ul>
<p class="BodyContinued">We’ll cover all of these logic contexts in <span class="bodycontinued_Xref"><a href="chapter4.xhtml">Chapter 4</a></span>.</p>
<p class="TX">Type juggling also may occur in function contexts and bitwise contexts. We’ll explore the function context (when arguments are evaluated against function signatures) in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>. The bitwise context is rarely used in web applications and is beyond the scope of this book.</p>
</section>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h3 class="H1" id="sec16"><span id="toc-link_30"/><span class="SANS_Futura_Std_Bold_B_11">Type Casting</span></h3>
<p class="TNI1"><i>Type casting</i> refers to explicitly converting an expression or variable to a desired data type. Manual type casting stands in contrast to the type juggling performed automatically by the PHP engine. To cast the value of an expression to a particular type, provide the new data type in parentheses before the expression. For instance, <span class="SANS_TheSansMonoCd_W5Regular_11">(float)21</span> ensures that the value <span class="SANS_TheSansMonoCd_W5Regular_11">21</span> will be treated as a float instead of an integer. Here are some examples of casting various scalar data types:</p>
<pre><code>php &gt; <b>$age = (int)20.5;</b>&#13;
php &gt; <b>var_dump($age);</b>&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> int(20)&#13;
php &gt; <b>$price = (string)9.99;</b>&#13;
php &gt; <b>var_dump($price);</b>&#13;
string(4) "9.99";&#13;
php &gt; <b>$inventory = (bool)0;</b>&#13;
php &gt; <b>var_dump($inventory);</b>&#13;
<span aria-label="annotation2" class="codeannotated_CodeAnnotation">❷</span> bool(false)</code></pre>
<p class="TX"><span aria-label="40" epub:type="pagebreak" id="pg_40" role="doc-pagebreak"/>Notice that casting from a float to an integer truncates anything after the decimal point, effectively rounding down to the nearest whole number <span aria-label="annotation1" class="CodeAnnotation">❶</span>. When casting from a number to a Boolean, <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> becomes <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> <span aria-label="annotation2" class="CodeAnnotation">❷</span>, while any other numeric value (including negative numbers!) becomes <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>.</p>
<p class="TX">Type casting is one of the lesser-used features of PHP. One example of its use could be to easily obtain the integer part of a float, such as the whole number of seconds when comparing two timestamps.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h3 class="H1" id="sec17"><span id="toc-link_31"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>
<p class="TNI1">This chapter introduced you to PHP’s four scalar data types, as well as the special <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> type. You saw the difference between variables containing <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> and variables evaluating to <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> by virtue of being undefined or unset, and you practiced testing whether a variable is of a particular type by using functions like <span class="SANS_TheSansMonoCd_W5Regular_11">is_int()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">is_null()</span>. Later, this will help you write code that carefully tests values to manage situations that may occur when receiving input from users or external data sources such as databases.</p>
<p class="TX">This chapter also showed you how an expression’s data type can change, either automatically through juggling or manually through casting. You learned about the contexts where type juggling can occur and rules for evaluating expressions with different data types. Understanding when and how types are juggled will help you avoid unexpected results when working with data of mixed types.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h3 class="H1" id="sec18"><span id="toc-link_32"/><span class="SANS_Futura_Std_Bold_B_11">Exercises</span></h3>
<p class="ListNumber">1.   Write a script to use integer casting to round down a float. Do the following:</p>
<p class="ListLetterSub">a.   Create a <span class="SANS_TheSansMonoCd_W5Regular_11">$scoreFloat</span> variable containing <span class="SANS_TheSansMonoCd_W5Regular_11">55.9</span>.</p>
<p class="ListLetterSub">b.   Create a second variable, <span class="SANS_TheSansMonoCd_W5Regular_11">$scoreInt</span>, containing the value of <span class="SANS_TheSansMonoCd_W5Regular_11">$scoreFloat</span> cast into an integer.</p>
<p class="ListLetterSub">c.   Print out the type of <span class="SANS_TheSansMonoCd_W5Regular_11">$scoreFloat</span>, then its value, then a newline character.</p>
<p class="ListLetterSub">d.   Print out the type of <span class="SANS_TheSansMonoCd_W5Regular_11">$scoreInt</span>, then its value, then a newline character.</p>
<p class="ListContinued">Your program output should look as follows:</p>
<pre><code>double scoreFloat = 55.9&#13;
integer scoreInt = 55</code></pre>
<p class="ListNumber">2.   Assign the <span class="SANS_TheSansMonoCd_W5Regular_11">$age</span> variable the integer <span class="SANS_TheSansMonoCd_W5Regular_11">21</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">var_dump</span> its value. Then assign <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> to this variable, and <span class="SANS_TheSansMonoCd_W5Regular_11">var_dump</span> it again. Finally, unset the variable and <span class="SANS_TheSansMonoCd_W5Regular_11">var_dump</span> it once more. Note that the output differs when the variable is assigned <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> and when it’s unset.</p>
</section>
</section>
</div></body></html>