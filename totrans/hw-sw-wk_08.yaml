- en: '**8**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8**'
- en: '**Concurrency**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发**'
- en: '![image](graphics/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common-01.jpg)'
- en: Usually we can tell when software is doing something interesting, even if we
    don’t know how it’s done. We know that computers make graphics, encrypt our transmissions,
    and stream our videos. What we miss, though, is that these tasks often involve
    multiple programs, multiple processors, or even multiple computers connected via
    a network, accessing the same data at the same time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们能够察觉软件在做一些有趣的事情，即使我们不知道它是怎么做到的。我们知道计算机会生成图形、加密我们的传输并播放视频。但我们忽视的是，这些任务通常涉及多个程序、多个处理器，甚至是多个通过网络连接的计算机，同时访问相同的数据。
- en: This overlapping access of data, known as *concurrency*, is a vital part of
    modern technology. High-performance tasks like graphics and shared resources like
    websites wouldn’t be possible without it. But concurrency causes big problems
    when it’s not carefully managed. In this chapter, we’ll see how results can become
    scrambled when multiple processors access the same data. Then we’ll look at the
    clever software (and hardware) techniques that keep processors from getting in
    each other’s way.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据的重叠访问，被称为*并发*，是现代技术的关键部分。像图形处理和共享资源（如网站）这样的高性能任务，如果没有并发，根本无法实现。但如果并发没有得到妥善管理，就会带来很大的问题。在这一章中，我们将看到当多个处理器访问相同数据时，结果是如何变得混乱的。接着，我们将看看巧妙的软件（和硬件）技术，如何确保处理器不会相互干扰。
- en: '**Why Concurrency Is Needed**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为什么需要并发**'
- en: 'Situations that require concurrency fall into three basic categories: performance,
    multiuser environments, and multitasking.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 需要并发的情况可以分为三类：性能、多用户环境和多任务处理。
- en: '***Performance***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***性能***'
- en: Concurrency is needed when there’s more work to do than a single processor can
    handle. Until recently, the number of instructions a processor could execute in
    a second was steadily increasing, but now the pace of improvement has slowed.
    In order to execute more instructions in the same amount of time, a processor
    has to run faster. The faster it runs, the more power courses through it and the
    hotter it gets, which can eventually damage the components.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当有更多的工作要做，而单个处理器无法处理时，就需要并发。直到最近，处理器每秒可以执行的指令数量还在稳步增加，但现在这种进步的速度已经放缓。为了在相同的时间内执行更多的指令，处理器必须运行得更快。运行速度越快，电力通过处理器的流动就越多，温度也会越高，最终可能会损坏组件。
- en: To mitigate that problem, the size of the components in the processor keeps
    getting smaller so that they draw less current and remain relatively cool. But
    it’s getting difficult to make processor components any smaller, which in turn
    makes it difficult to make them run any faster. When a single processor can’t
    get the job done, the only solution is to use multiple processing cores. We saw
    this with video game graphics in [Chapter 5](ch05.html#ch05), but it’s not just
    high-end game graphics that need multiple processors. Even today’s basic graphics
    tasks may require multiple processor cores.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解这个问题，处理器中的组件尺寸不断减小，以便它们消耗更少的电流并保持相对较低的温度。但是，使处理器组件进一步缩小变得越来越困难，这也使得它们的运行速度难以进一步提升。当单个处理器无法完成任务时，唯一的解决方案是使用多个处理核心。我们在[第五章](ch05.html#ch05)中已经看到过视频游戏图形的情况，但不仅仅是高端游戏图形需要多个处理器，即便是今天的一些基本图形任务也可能需要多个处理器核心。
- en: '***Multiuser Environments***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***多用户环境***'
- en: Concurrency also allows networked computer systems to work together. Suppose
    you are playing an online game such as *World of Warcraft*. The game tracks each
    player’s actions as well as those of the computer-controlled monsters. The game’s
    servers tally every spell and axe swing, and calculate the damage done, the monsters
    slain, and the loot dropped.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 并发还使得网络化计算机系统能够协同工作。假设你正在玩一款在线游戏，例如*魔兽世界*。游戏会跟踪每个玩家的动作以及计算机控制的怪物的动作。游戏的服务器会统计每个法术和斧头挥动的次数，并计算造成的伤害、击败的怪物数量以及掉落的战利品。
- en: Concurrency is required here because the processor in every player’s computer
    must share the data of nearby players and computer-controlled creatures.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要并发，因为每个玩家计算机中的处理器必须共享附近玩家和计算机控制的生物的数据。
- en: '***Multitasking***'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***多任务处理***'
- en: Concurrency can occur even in situations where only one processor is involved.
    Modern computers *multitask*, which means they are constantly switching between
    different programs, even when we think we’re doing only one thing on the computer
    at a time. For example, multitasking is what allows your email client to receive
    a new message while you surf the Web. In these cases, whether or not the computer
    has multiple processor cores, it’s definitely running multiple *processes*—different
    programs with overlapping executions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 即使只有一个处理器，仍然可以发生并发。现代计算机*多任务处理*，这意味着即使我们认为自己一次只在做一件事情，计算机也在不断地在不同程序之间切换。例如，多任务处理使得你的电子邮件客户端能够在你浏览网页时接收新邮件。在这些情况下，无论计算机是否有多个处理器核心，它都肯定在运行多个*进程*——不同程序的执行是重叠的。
- en: Printing is another typical example. When you print a recipe from a website,
    the software that manages the printer, known as the driver, collects the print
    data in an orderly queue and then passes it on to the printer as needed. This
    is called *print spooling*. Without print spooling, the browser could send the
    data only as fast as the printer processed it, which means that you would have
    to wait for the print job to finish before you could do anything else with the
    browser.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 打印是另一个典型的例子。当你从网站打印一个食谱时，管理打印机的软件（称为驱动程序）会按照顺序将打印数据排队，然后按需将其传递给打印机。这就是*打印缓存*。如果没有打印缓存，浏览器只能以打印机处理数据的速度发送数据，这意味着你必须等打印任务完成后，才能继续使用浏览器做其他事情。
- en: Print spooling can’t work without concurrency. You can think of a print spool
    as one of those carousels that sit in the window between the front counter and
    the kitchen in a short-order restaurant, like the one shown in [Figure 8-1](ch08.html#ch8fig1).
    Someone in the front puts new orders on the carousel, and someone in the back
    takes down the orders as they are fulfilled. The shared data storage of the carousel
    allows the order takers and the cooks to work independently.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 打印缓存如果没有并发就无法工作。你可以把打印缓存想象成那种短时餐厅中，位于前台和厨房之间的旋转装置，就像[图 8-1](ch08.html#ch8fig1)所示的那样。前台的人将新订单放到旋转装置上，后台的人根据完成情况拿下订单。旋转装置的共享数据存储使得点单员和厨师能够独立工作。
- en: '![image](graphics/f08-01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-01.jpg)'
- en: '*Figure 8-1: An order-ticket carousel*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-1：订单票旋转装置*'
- en: This arrangement is known as a *shared buffer* and is frequently used behind
    the scenes in software. For example, suppose you are typing an email, but your
    computer momentarily slows down so that nothing you typed appears on screen. Then
    the system catches up, and everything you typed is now in the email. That happens
    because the keyboard doesn’t communicate directly with the email program, but
    uses the operating system as an intermediary. The operating system queues the
    keystrokes in a shared buffer so the email program can access them when ready.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种安排被称为*共享缓冲区*，并且在软件的幕后经常使用。例如，假设你正在输入一封邮件，但你的计算机暂时变慢，屏幕上没有显示你输入的内容。然后，系统赶上来了，所有你输入的内容都出现在邮件中。这是因为键盘并不直接与电子邮件程序通信，而是通过操作系统作为中介。操作系统将按键存储在共享缓冲区中，电子邮件程序可以在准备好时访问这些按键。
- en: Multitasking also allows programs to sit in the background and interrupt you
    when something significant happens. When a new email alert appears in the corner
    of your desktop’s screen while you are working in a word processor, or your phone
    signals a newly received text message while you’re playing a game, that’s multitasking
    at work.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 多任务处理还允许程序在后台运行，并在发生重要事件时打断你。当你在使用文字处理软件时，桌面屏幕角落弹出一封新邮件的提醒，或者你在玩游戏时，手机提醒收到新短信，这就是多任务处理在工作中的体现。
- en: Beyond the performance benefits of multiple processors and distributed processing,
    the importance of multitasking means some form of concurrency is required to provide
    the basic computing functionality we rely on daily.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了多个处理器和分布式处理的性能优势外，多任务处理的重要性意味着必须有某种形式的并发，以提供我们每天依赖的基本计算功能。
- en: '**How Concurrency Can Fail**'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**并发如何失败**'
- en: Although concurrency is a vital part of everyday computing, it creates enormous
    headaches for software and can produce serious problems if proper safeguards aren’t
    in place to prevent them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管并发是日常计算中的重要部分，但它给软件带来了巨大的麻烦，如果没有适当的保障措施来防止问题的发生，可能会导致严重的故障。
- en: The underlying issue is how data is copied when it’s used in calculations. Essentially,
    all a computer processor does is retrieve numbers from storage and either perform
    math with them or compare them. To do these tasks, though, it must copy the numbers
    from wherever they are stored to locations inside the processor. Stored data isn’t
    changed directly. Instead, the computer fetches the value from main memory, or
    a hard drive, or across a network, and delivers it to the innermost part of the
    processor. The processor performs the math on this internal copy, and then sends
    the updated value back to storage to replace the original data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 根本问题在于数据在计算中是如何被复制的。本质上，计算机处理器所做的就是从存储中提取数字，然后用它们进行数学运算或比较。然而，要完成这些任务，处理器必须将数字从存储位置复制到处理器内部的某个位置。存储的数据不会直接被修改。相反，计算机会从主存储器、硬盘或通过网络提取值，并将其传输到处理器的最内层。处理器对这个内部副本进行计算，然后将更新后的值送回存储，以替换原始数据。
- en: Suppose you’re playing a first-person shooter game. You have 300 bullets in
    reserve when you run over an ammo clip, picking up 20 more bullets. [Figure 8-2](ch08.html#ch8fig2)
    shows the steps involved. To update your bullet count, the processor first retrieves
    your current bullet count and the number of bullets in the clip from their places
    in storage, shown in step 1\. These values are fed into the inputs of an “adder”
    circuit in the processor, as shown in step 2, which performs the actual math.
    Then the result is sent back to main memory, replacing the old value in the bullet
    count storage location, as shown in step 3.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在玩一款第一人称射击游戏。当你跑过一个弹药包时，你的备用子弹数量是 300 发，捡起了 20 发子弹。[图 8-2](ch08.html#ch8fig2)
    展示了涉及的步骤。为了更新你的子弹数，处理器首先从存储位置获取当前的子弹数量和弹药包中的子弹数，如步骤 1 所示。这些值被输入到处理器中“加法器”电路的输入端，如步骤
    2 所示，进行实际的数学运算。然后，结果被送回主存储器，替换掉子弹数存储位置中的旧值，如步骤 3 所示。
- en: '![image](graphics/f08-02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-02.jpg)'
- en: '*Figure 8-2: Three steps to update a number from 300 to 320*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：将数字从 300 更新到 320 的三步骤*'
- en: This update sequence causes problems when multiple processes attempt to make
    alterations to the same storage location. Take, for example, a *massively multiplayer
    online game (MMO)*. Trina Orcslayer and Skylar Rockguardian are two players. They
    are both officers of the same “guild,” and this game allows guilds to hold shared
    bank accounts across multiple game servers. On Friday morning, the balance of
    the guild account is exactly 10,000 gold, and Skylar and Trina each have 500 gold
    in their personal accounts. Sometime that day, Skylar withdraws 300 gold from
    the guild account while Trina deposits 200 gold into it. If these are the only
    transactions that happen, the final balance should be 9,900 in the guild account
    (10,000 – 300 + 200), 800 in Skylar’s account (500 + 300), and 300 in Trina’s
    account (500 – 200).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更新顺序会在多个进程尝试对同一存储位置进行修改时引发问题。例如，考虑一个*大型多人在线游戏（MMO）*。Trina Orcslayer 和 Skylar
    Rockguardian 是两名玩家。他们都是同一个“公会”的成员，而这个游戏允许公会在多个游戏服务器之间共享银行账户。周五早上，公会账户的余额正好是 10,000
    金币，Skylar 和 Trina 各自的个人账户中有 500 金币。在当天的某个时刻，Skylar 从公会账户提取了 300 金币，而 Trina 向公会账户存入了
    200 金币。如果只有这两笔交易发生，那么最终的余额应为：公会账户中 9,900 金币（10,000 – 300 + 200），Skylar 账户中 800
    金币（500 + 300），Trina 账户中 300 金币（500 – 200）。
- en: 'And that’s what will happen if the transactions are kept separate. Suppose
    Skylar makes the withdrawal in the morning, and Trina makes her deposit that afternoon.
    We won’t get into programming here, but let’s consider the steps that the game
    software will take to carry out these transactions. Let’s start with Skylar’s
    withdrawal:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些交易被分开处理，那就会发生上述情况。假设 Skylar 在早上进行取款，而 Trina 在下午进行存款。我们不涉及编程部分，但可以考虑游戏软件在执行这些交易时将采取的步骤。让我们从
    Skylar 的取款开始：
- en: 1.   Retrieve the balance of the guild account. Call this **Skylar’s copy**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   获取公会账户的余额，称之为**Skylar 的副本**。
- en: 2.   Subtract 300 gold from **Skylar’s copy**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   从**Skylar 的副本**中减去 300 金币。
- en: 3.   Add 300 gold to Skylar’s personal stash.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   向 Skylar 的个人账户增加 300 金币。
- en: 4.   Update the guild bank balance to **Skylar’s copy**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   更新公会银行余额为**Skylar 的副本**。
- en: 'Now suppose Trina makes the deposit in the afternoon. The steps of her transaction
    are:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 Trina 在下午进行存款。她的交易步骤如下：
- en: 1.   Retrieve the balance of the guild account. Call this **Trina’s copy**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   获取公会账户的余额，称之为**Trina 的副本**。
- en: 2.   Subtract 200 gold from Trina’s personal stash.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   从 Trina 的个人账户中减去 200 金币。
- en: 3.   Add 200 gold to **Trina’s copy**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   向**Trina 的副本**增加 200 金币。
- en: 4.   Update the guild bank balance to **Trina’s copy**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   将公会银行余额更新为**Trina的副本**。
- en: In this example everything works fine. But what happens if Skylar and Trina
    perform their transactions at the same time? In that case, the final balance of
    the guild account could be incorrect. This happens if the original guild balance
    of 10,000 gold is retrieved for calculation by both processes before either of
    them completes the transaction.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一切正常。但是如果Skylar和Trina同时进行交易，会发生什么呢？在这种情况下，公会账户的最终余额可能会不正确。如果在两个进程完成交易之前，两个进程都从银行提取了原始公会余额10,000金币进行计算，就会发生这种情况。
- en: Take a look at the details shown in [Table 8-1](ch08.html#ch8tab1). When Trina
    and Skylar initiate transactions at the same time, the same 10,000 balance is
    retrieved into their separate copies of the balance. Trina’s copy is increased
    to 10,200, while Skylar’s copy is decreased to 9,700\. Then both of the updated
    figures overwrite the guild account balance. In the example shown in the table,
    Skylar’s updated number arrives last, which means 9,700 is the new account balance
    and 200 gold has simply vanished.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[表格 8-1](ch08.html#ch8tab1)中显示的详细信息。当Trina和Skylar同时发起交易时，同样的10,000金币余额会被提取到他们各自的余额副本中。Trina的副本增加到10,200，而Skylar的副本减少到9,700。然后这两个更新的数字会覆盖公会账户余额。在表格中显示的例子中，Skylar的更新数字最后到达，这意味着9,700成为了新的账户余额，而200金币就这样消失了。
- en: It could have worked out the other way—Trina’s copy could have arrived after
    Skylar’s, increasing the guild’s gold balance, but of course neither result is
    correct. The only correct final balance is 9,900 gold, the balance that corresponds
    to the two transactions occurring separately.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 结果本可以不同——Trina的副本本可以在Skylar的副本之后到达，从而增加公会的金币余额，但当然无论哪种结果都不正确。唯一正确的最终余额是9,900金币，这个余额对应的是两个交易分别发生的情况。
- en: Situations similar to this example are possible whenever two or more processes
    use the same data simultaneously. The general term for this situation is a *race
    condition*, since all the processes involved are racing to complete their task
    first. In this case the process that finishes last “wins,” because it determines
    the final value of the data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于这个例子的情况可能发生在两个或更多进程同时使用相同数据时。这种情况的通用术语是*竞态条件*，因为所有涉及的进程都在竞速，争先完成任务。在这种情况下，最后完成的进程“获胜”，因为它决定了数据的最终值。
- en: While this example features two different processors, Trina’s and Skyler’s,
    it’s important to note that race conditions can happen even with a single processor.
    Because multitasking involves switching the processor to a different program many
    times a second, multiple processes operating on the same data could interleave,
    creating a race condition.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子涉及的是两个不同的处理器，Trina的和Skylar的，但需要注意的是，即使只有一个处理器，竞态条件也可能发生。因为多任务处理涉及每秒多次切换处理器到不同的程序，所以多个进程操作相同数据时，可能会交替执行，导致竞态条件。
- en: '**Table 8-1:** The Danger of Overlapping Bank Transactions'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格 8-1：** 重叠银行交易的危险'
- en: '| **Step** | **Description** | **Skylar’s copy** | **Trina’s copy** | **Guild
    balance** |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | **描述** | **Skylar的副本** | **Trina的副本** | **公会余额** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Trina 1 | Retrieve the guild balance from the bank. |  | 10,000 | 10,000
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| Trina 1 | 从银行提取公会余额。 |  | 10,000 | 10,000 |'
- en: '| Skylar 1 | Retrieve the guild balance from the bank. | 10,000 |  | 10,000
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| Skylar 1 | 从银行提取公会余额。 | 10,000 |  | 10,000 |'
- en: '| Trina 2 | Subtract 200 gold from Trina’s stash. |  | 10,000 | 10,000 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| Trina 2 | 从Trina的储备中减去200金币。 |  | 10,000 | 10,000 |'
- en: '| Trina 3 | Add 200 gold to Trina’s copy of the guild balance. |  | 10,200
    | 10,000 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| Trina 3 | 向Trina的公会余额副本中添加200金币。 |  | 10,200 | 10,000 |'
- en: '| Skylar 2 | Subtract 300 gold from Skylar’s copy of the guild balance. | 9,700
    |  | 10,000 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| Skylar 2 | 从Skylar的公会余额副本中减去300金币。 | 9,700 |  | 10,000 |'
- en: '| Skylar 3 | Add 300 gold to Skylar’s stash. | 9,700 |  | 10,000 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| Skylar 3 | 向Skylar的储备中添加300金币。 | 9,700 |  | 10,000 |'
- en: '| Trina 4 | Send Trina’s copy of the guild balance to the bank. |  | 10,200
    | 10,200 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| Trina 4 | 将Trina的公会余额副本发送到银行。 |  | 10,200 | 10,200 |'
- en: '| Skylar 4 | Send Skylar’s copy of the guild balance to the bank. | 9,700 |  |
    9,700 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| Skylar 4 | 将Skylar的公会余额副本发送到银行。 | 9,700 |  | 9,700 |'
- en: '**Making Concurrency Safe**'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**确保并发安全**'
- en: In order to make concurrency useful, then, we need to prevent race conditions.
    This requires enforcing rules on how processes can access data. The tighter the
    restrictions, the easier it is to prevent problems from occurring, but these restrictions
    can have an adverse effect on performance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使并发有意义，我们需要防止竞争条件的发生。这要求对进程如何访问数据进行规则的约束。限制越严格，越容易防止问题发生，但这些限制可能会对性能产生不利影响。
- en: '***Read-Only Data***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***只读数据***'
- en: One possible restriction is to allow processes to retrieve data simultaneously,
    but prohibit them from changing it; this is known as *read-only* data. This eliminates
    the possibility of a race condition but at an enormous cost. Most applications
    that require shared data access simply can’t work without the ability to change
    the data. So this method is rarely considered. However, as we’ll see later, distinguishing
    which processes want to change data from those that merely want to read data can
    improve the performance of concurrency.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的限制是允许进程同时检索数据，但禁止它们修改数据；这被称为*只读*数据。这可以消除竞争条件的可能性，但代价极大。大多数需要共享数据访问的应用程序无法在没有修改数据能力的情况下正常工作。因此，这种方法很少被考虑。然而，正如我们稍后看到的，将想要更改数据的进程与仅仅想读取数据的进程区分开来，可以提高并发性能。
- en: '***Transaction-Based Processing***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基于交易的处理***'
- en: 'Another straightforward, comprehensive solution eliminates simultaneous data
    access entirely. The race condition occurs in the example because Skylar’s and
    Trina’s transactions overlap. What if we prevent overlapping transactions? To
    enforce this rule, once any bank transaction begins, we wait for it to signal
    its completion before any other transaction may start. For example, the steps
    in Skylar’s process now might look like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种直接而全面的解决方案完全消除了同时数据访问的问题。示例中的竞争条件发生是因为Skylar和Trina的交易重叠了。如果我们能防止交易重叠会怎样呢？为了执行这一规则，一旦任何银行交易开始，我们需要等到它发出完成信号之后，才能开始其他交易。例如，Skylar的流程中的步骤现在可能如下所示：
- en: 1.   Signal **Start Transaction** to the bank server.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 向银行服务器发出**开始交易**信号。
- en: 2.   Retrieve the balance of the guild account. Call this **Skylar’s copy**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 检索公会账户余额，将其称为**Skylar的副本**。
- en: 3.   Subtract 300 gold from **Skylar’s copy**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从**Skylar的副本**中扣除300金币。
- en: 4.   Add 300 gold to Skylar’s personal stash.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 向Skylar的个人储备中添加300金币。
- en: 5.   Update the guild bank balance to **Skylar’s copy**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将公会银行余额更新为**Skylar的副本**。
- en: 6.   Signal **End Transaction** to the bank server.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 向银行服务器发出**结束交易**信号。
- en: 'The steps in Trina’s process would be likewise bracketed:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Trina的流程中的步骤也将按类似方式被括起来：
- en: 1.   Signal **Start Transaction** to the bank server.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 向银行服务器发出**开始交易**信号。
- en: 2.   Retrieve the balance of the guild account. Call this **Trina’s copy**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 检索公会账户余额，将其称为**Trina的副本**。
- en: 3.   Subtract 200 gold from Trina’s personal stash.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从Trina的个人储备中扣除200金币。
- en: 4.   Add 200 gold to **Trina’s copy**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 向**Trina的副本**中添加200金币。
- en: 5.   Update the guild bank balance to **Trina’s copy**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将公会银行余额更新为**Trina的副本**。
- en: 6.   Signal **End Transaction** to the bank server.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 向银行服务器发出**结束交易**信号。
- en: The bank server process enforces the transaction rules. When no transaction
    is under way, a signal to start a new transaction is immediately accepted. So
    if Trina’s transaction began during an idle period, it would continue. If, however,
    the *start transaction* signal from Skylar’s process arrived while Trina’s transaction
    was being processed, Skylar’s transaction would have to wait until Trina’s transaction
    finished. And if other transactions arrived during this time, the bank server
    would put them in a queue, to process them in the order in which they arrived.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 银行服务器流程强制执行交易规则。当没有交易进行时，新的交易开始信号会立即被接受。所以，如果Trina的交易在空闲期间开始，它会继续进行。然而，如果Skylar的**开始交易**信号在Trina的交易正在处理时到达，Skylar的交易就必须等到Trina的交易完成。如果在此期间有其他交易到达，银行服务器会将它们排入队列，按到达顺序处理。
- en: This rule transforms the guild bank into the equivalent of a lobby with a single
    teller. If a customer arrives and the teller is available, the customer gets immediate
    service; otherwise, the customer must wait until the teller is free. This prevents
    race conditions but robs the system of the performance benefit of having multiple
    processors. Just as having one teller in a busy bank means a long wait for each
    customer, allowing only one transaction through the bank server at a time means
    a relatively long wait for each transaction.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则将公会银行转变成相当于一个只有一个出纳员的大堂。如果客户到达且出纳员空闲，客户将立即得到服务；否则，客户必须等到出纳员空闲。这可以防止竞争条件，但剥夺了系统通过多个处理器带来的性能优势。就像在一个忙碌的银行只有一个出纳员意味着每个客户都要长时间等待一样，每次只允许一个交易通过银行服务器，也意味着每个交易都要相对等待较长时间。
- en: The rule is much too strict. At any given time, the bank may be handling a large
    number of transactions, and few (if any) of them involve the same accounts. This
    rule prevents race conditions by preventing all overlapping transactions, even
    when the overlap is harmless.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则过于严格。在任何给定时间，银行可能正在处理大量交易，而且其中很少（甚至没有）涉及相同的账户。这个规则通过阻止所有重叠交易来防止竞争条件，即使这些重叠是无害的。
- en: '***Semaphores***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***信号量***'
- en: Another idea takes advantage of the fact that most of the transactions are not
    interacting with the same data. If the transaction rule is like a bank with a
    single teller, a better rule would be like a bank where every account has its
    own personal teller. Two or more customers attempting to access the same account
    at the same time will form a queue, but customers accessing different accounts
    won’t slow each other down at all.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个思路利用了大多数交易并不操作相同数据这一事实。如果交易规则像是一个只有一个出纳员的银行，那么更好的规则应该像是一个每个账户都有自己个人出纳员的银行。两个或更多客户同时尝试访问同一个账户时会排队，但访问不同账户的客户不会互相影响。
- en: The secret ingredient behind this technique is a special type of data called
    a *semaphore*. In nautical language, semaphores are flags that ships hoist to
    signal other ships; in software, semaphores are the numerical equivalent of flags,
    signaling whether or not logically connected data is in use. The simplest type
    of semaphore has just two possible values, 0 or 1, and is called a *binary semaphore*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术背后的秘密成分是称为*信号量*的特殊数据类型。在航海语言中，信号量是船只举起的旗帜，用来向其他船只发信号；在软件中，信号量是旗帜的数字等价物，用于指示是否存在逻辑连接的数据正在使用。最简单类型的信号量只有两个可能的值，0或1，称为*二进制信号量*。
- en: '**How Semaphores Prevent Race Conditions**'
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**信号量如何防止竞争条件**'
- en: Returning to our guild bank account, we can avoid the race condition by creating
    semaphores on the bank server for each of the account balances. Each semaphore
    begins with a value of 1.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到我们的公会银行账户，我们可以通过在银行服务器上为每个账户余额创建信号量来避免竞争条件。每个信号量的初始值为1。
- en: Before requesting an account balance, a process must first *acquire* the semaphore
    associated with that account. This acquire operation will check the value of the
    semaphore. If the semaphore is 1, it means no other process is using the associated
    balance; in this case, the semaphore changes to 0, and the process will be allowed
    to continue.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求账户余额之前，进程必须先*获取*与该账户相关的信号量。此获取操作将检查信号量的值。如果信号量为1，表示没有其他进程正在使用相关余额；此时，信号量将变为0，进程将被允许继续执行。
- en: If the semaphore is already 0, though, it means another process is currently
    accessing the associated balance. In this case, the software will have to wait.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果信号量已经为0，意味着另一个进程正在访问相关的余额。在这种情况下，软件将必须等待。
- en: When a process completes its transaction, it *releases* the semaphore, which
    immediately sets its value back to 1\. This allows one of the processes waiting
    for the semaphore to continue.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程完成交易后，它会*释放*信号量，立即将其值恢复为1。这允许其中一个等待信号量的进程继续执行。
- en: 'Using semaphores, Skylar’s process would look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用信号量时，Skylar的进程将如下所示：
- en: 1.   **Acquire** the semaphore for the guild account.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   **获取**公会账户的信号量。
- en: 2.   Retrieve the balance of the guild account. Call this **Skylar’s copy**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   获取公会账户的余额。称之为**Skylar的副本**。
- en: 3.   Subtract 300 gold from **Skylar’s copy**.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从**Skylar的副本**中减去300金币。
- en: 4.   Add 300 gold to Skylar’s personal stash.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   向Skylar的个人存储添加300金币。
- en: 5.   Update the guild bank balance to **Skylar’s copy**.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   更新公会银行余额为**Skylar的副本**。
- en: 6.   **Release** the semaphore for the guild account.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 6.   **释放**公会账户的信号量。
- en: 'And Trina’s:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以及Trina的：
- en: 1.   **Acquire** the semaphore for the guild account.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   **获取**公会账户的信号量。
- en: 2.   Retrieve the balance of the guild account. Call this **Trina’s copy**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   获取公会账户的余额。将其称为**Trina的副本**。
- en: 3.   Subtract 200 gold from Trina’s personal stash.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从Trina的个人储备中减去200金币。
- en: 4.   Add 200 gold to **Trina’s copy**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   向**Trina的副本**中添加200金币。
- en: 5.   Update the guild bank balance to **Trina’s copy**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   更新公会银行余额为**Trina的副本**。
- en: 6.   **Release** the semaphore for the guild account.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 6.   **释放**公会账户的信号量。
- en: In this way, Skylar and Trina are prevented from accessing the guild balance
    at the same time, preventing the race condition. Additionally, neither transaction
    will affect any other transaction that doesn’t deal with this particular account.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，Skylar和Trina被防止同时访问公会余额，从而避免了竞态条件。此外，任何不涉及该账户的其他事务也不会受到影响。
- en: '**How Semaphores Are Made**'
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**信号量是如何创建的**'
- en: 'Now let’s look at how semaphores are actually made. If semaphores aren’t implemented
    with care, they can produce the very race conditions they are intended to prevent.
    Although the acquire operation is just one step for Skylar’s and Trina’s processes,
    in reality, it takes several steps itself:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看信号量是如何实际创建的。如果信号量实现不小心，它们可能会导致它们本应防止的竞态条件。尽管获取操作对于Skylar和Trina的进程来说只是一步，但实际上，它本身需要多个步骤：
- en: 1.   Retrieve the value of the semaphore.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   获取信号量的值。
- en: 2.   If the value is 0, go back to step 1 and try again.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   如果值是0，返回第1步并重试。
- en: 3.   Set the semaphore to 0.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   将信号量设置为0。
- en: Now consider what happens if both Skylar’s and Trina’s processes attempt to
    acquire the guild account semaphore at the same time. If the semaphore had a value
    of 1, both processes could retrieve this initial value (in step 1) before either
    had a chance to check the value and set it to 0\. In this case, both processes
    would think that they were the only process that had acquired the semaphore, and
    were therefore free to do whatever they wanted with the accompanying bank balance.
    We’re right back where we started.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一下如果Skylar和Trina的进程同时尝试获取公会账户信号量会发生什么。如果信号量的值是1，两者都能在第1步获取到这个初始值，然后才有机会检查这个值并将其设置为0。在这种情况下，两个进程都会认为自己是唯一获取信号量的进程，因此可以随意操作随附的银行余额。我们又回到了最初的状态。
- en: To make a semaphore, then, software needs some help from hardware. The processor
    on the bank server must be able to implement the acquire and release operations
    in such a way that nothing can interrupt them. This is known as making the operations
    *atomic*, which in this sense means indivisible.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建信号量，软件需要硬件的帮助。银行服务器上的处理器必须能够以一种方式实现获取和释放操作，使得没有任何东西能打断它们。这被称为使操作成为*原子操作*，在这个意义上，原子操作指的是不可分割的。
- en: 'Modern processors implement a hardware operation known as *test-andset*. This
    sets a byte in main memory to a particular value, while retrieving the previous
    value for inspection. Test-and-set makes semaphores possible. In the list of semaphore
    steps, the problem is the potential interruption between steps 1 and 3\. If two
    different processes execute the first step before either reaches the third step,
    both will be able to alter the data that the semaphore is supposed to protect.
    Using the atomic test-and-set operation, though, a semaphore acquire operation
    can be implemented like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现代处理器实现了一种硬件操作，称为*测试和设置*。这个操作会将主存中的一个字节设置为特定值，同时检索先前的值进行检查。测试和设置使信号量成为可能。在信号量的步骤列表中，问题出在第1步和第3步之间的潜在中断。如果两个不同的进程在任何一个进程到达第3步之前执行第1步，它们都能修改信号量本应保护的数据。然而，通过使用原子测试和设置操作，信号量获取操作可以这样实现：
- en: 1.   Using test-and-set, set the semaphore to 0 and retrieve the old value.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   使用测试和设置，将信号量设置为0并获取旧值。
- en: 2.   If the old value was 0, go back to step 1 and try again.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   如果旧值为0，返回第1步并重试。
- en: Now the race condition cannot happen. If two processes attempt to acquire the
    same semaphore at the same time, they will each execute the test-and-set in step
    1\. Both operations will set the semaphore value to 0, but only the semaphore
    that tests-and-sets first will retrieve a 1\. The other process will retrieve
    a 0\. One process will immediately continue, while the other will have to wait.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在竞态条件不会发生。如果两个进程同时尝试获取相同的信号量，它们都会执行第1步中的测试和设置操作。两个操作都会将信号量值设置为0，但只有第一个执行测试和设置的进程会获取到1，而另一个进程会获取到0。一个进程会立即继续，另一个进程则必须等待。
- en: '**The Problem of Indefinite Waits**'
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**无限等待的问题**'
- en: A process acquiring a semaphore using this two-step plan—continuously checking
    the semaphore’s value until it changes back to 1—is said to be in a *spin lock*.
    This is the simplest way to wait for a semaphore to become available, but it has
    two major problems. First, it wastes processor time. A process in a spin lock
    is continuously executing code, but the code isn’t doing anything useful. Secondly,
    spin locks can be unfair. In some cases, some processes cannot check the semaphore
    as fast as others. Perhaps the process is executing on a slower processor, or
    perhaps the process is communicating with a server across a slower network. Regardless
    of the reason, if a semaphore’s resource is so popular that multiple processes
    are always waiting, a slower-checking process might never be able to snag the
    semaphore. This is known as *starvation*; picture the least-assertive person at
    a busy restaurant with only one waiter, and you’ll get the idea.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种两步计划获取信号量的进程——不断检查信号量的值，直到它恢复为1——被称为*自旋锁*。这是等待信号量变得可用的最简单方法，但它有两个主要问题。首先，它浪费了处理器时间。处于自旋锁中的进程不断执行代码，但这些代码并没有做任何有用的事情。其次，自旋锁可能是不公平的。在某些情况下，一些进程的信号量检查速度可能比其他进程慢。也许进程运行在较慢的处理器上，或者进程正在通过较慢的网络与服务器通信。无论原因如何，如果一个信号量的资源如此受欢迎，以至于总有多个进程在等待，检查信号量较慢的进程可能永远无法获取到信号量。这就是*饥饿*现象；可以想象在一个繁忙餐厅里，最不积极的人面对唯一的服务员，你就能理解这一点。
- en: '***Orderly Queues***'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***有序队列***'
- en: Avoiding starvation requires a more organized approach to waiting. Banks organize
    the wait in their lobbies with cordons, forming groups of waiting customers into
    orderly queues. Semaphores can be designed to do the same thing. Rather than waste
    time continually checking the value of the semaphore, many acquire operations
    written so that when they do not succeed immediately, they put their process to
    sleep, so to speak. Putting a computer or phone to sleep means suspending all
    running applications in a way that allows the applications to be restored quickly.
    In the same way, if a process cannot immediately acquire a semaphore, it will
    be suspended and flushed out of the processor, but its internal data will remain
    in storage.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 避免饥饿现象需要一种更有组织的等待方式。银行通过隔离带组织大厅里的等待，形成有序的排队。信号量也可以设计成做类似的事情。与其浪费时间不断检查信号量的值，许多获取操作在无法立即成功时，会让进程“休眠”，可以这么说。让计算机或手机“休眠”意味着暂停所有正在运行的应用程序，以便应用程序能够迅速恢复。以同样的方式，如果一个进程无法立即获取信号量，它将被挂起并从处理器中清除，但其内部数据将保存在存储中。
- en: To accomplish this, the computer’s operating system assigns each process a unique
    identification number. When an acquire operation has to wait, the process identifier
    is placed at the end of that semaphore’s wait list. When the process currently
    holding that semaphore releases it, the first process on the list is awakened.
    In this way, processes acquire the semaphore in the same order they request it.
    A process may have to wait to acquire a popular semaphore, but will eventually
    get to the top of the list— it won’t starve.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，计算机的操作系统为每个进程分配一个唯一的标识符。当一个获取操作需要等待时，进程标识符会被放置在该信号量的等待队列末尾。当当前持有该信号量的进程释放它时，队列中的第一个进程会被唤醒。通过这种方式，进程会按照请求信号量的顺序获取它。一个进程可能需要等待获取一个热门信号量，但最终会排到队列的最前面——它不会饿死。
- en: '***Starvation from Circular Waits***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***循环等待导致的饥饿现象***'
- en: Although semaphores prevent race conditions when implemented and used correctly,
    they can cause starvation when processes need to access multiple pieces of data
    that are protected by semaphores.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管信号量在正确实现和使用时可以防止竞态条件，但当进程需要访问由信号量保护的多个数据时，它们可能会导致饥饿现象。
- en: Suppose Skylar and Trina’s guild opens a second account that is accessible to
    lower-ranked guild officers, so now the guild has a main account and a secondary
    account. The banking system has implemented semaphores for each individual account,
    eliminating the chance of a race condition on any guild transactions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设Skylar和Trina的公会开设了一个二级账户，低级别的公会官员也可以访问这个账户，所以现在公会有一个主账户和一个辅助账户。银行系统为每个账户实施了信号量，消除了任何公会交易中的竞态条件。
- en: 'But on a particular day, Skylar and Trina are each transferring 200 gold from
    one account to the other in opposite directions. Both transactions involve debiting
    one account and crediting the other. Skylar’s transaction would have these steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在某一天，Skylar 和 Trina 每个人都在将 200 金币从一个账户转移到另一个账户，方向相反。两个事务都涉及从一个账户借出并存入另一个账户。Skylar
    的事务会有这些步骤：
- en: 1.   **Acquire** the semaphore of the main account balance.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   **获取**主账户余额的信号量。
- en: 2.   Retrieve the balance of the main account.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   获取主账户余额。
- en: 3.   **Acquire** the semaphore of the secondary account balance.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   **获取**次账户余额的信号量。
- en: 4.   Retrieve the balance of the secondary account.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   获取次账户余额。
- en: 5.   Add 200 gold to the secondary account balance.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   向次账户余额添加 200 金币。
- en: 6.   Subtract 200 gold from the main account balance.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 6.   从主账户余额中减去 200 金币。
- en: 7.   Update the secondary account balance.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 7.   更新次账户余额。
- en: 8.   Update the main account balance.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 8.   更新主账户余额。
- en: 9.   **Release** the semaphore of the secondary account.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 9.   **释放**次账户的信号量。
- en: 10\. **Release** the semaphore of the main account.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 10. **释放**主账户的信号量。
- en: 'Trina’s transaction would run like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Trina 的事务会像这样运行：
- en: 1.   **Acquire** the semaphore of the secondary account balance.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   **获取**次账户余额的信号量。
- en: 2.   Retrieve the balance of the secondary account.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   获取次账户余额。
- en: 3.   **Acquire** the semaphore of the main account balance.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   **获取**主账户余额的信号量。
- en: 4.   Retrieve the balance of the main account balance.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   获取主账户余额。
- en: 5.   Add 200 gold to the main account balance.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   向主账户余额添加 200 金币。
- en: 6.   Subtract 200 gold from the secondary account balance.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 6.   从次账户余额中减去 200 金币。
- en: 7.   Update the main account balance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 7.   更新主账户余额。
- en: 8.   Update the secondary account balance.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 8.   更新次账户余额。
- en: 9.   **Release** the semaphore of the main account.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 9.   **释放**主账户的信号量。
- en: 10\. **Release** the semaphore of the secondary account.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 10. **释放**次账户的信号量。
- en: Because all shared value access is properly bracketed by the acquisition and
    release of associated semaphores, no race conditions can occur from the overlapping
    execution of these transactions. However, suppose both transactions begin around
    the same time and the first few steps interleave as shown in [Table 8-2](ch08.html#ch8tab2).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因为所有共享值的访问都通过获取和释放相关的信号量得到了适当的括起来，所以这些事务的重叠执行不会发生竞争条件。然而，假设两个事务几乎同时开始，并且前几个步骤交错执行，如[表
    8-2](ch08.html#ch8tab2)所示。
- en: '**Table 8-2:** Multiple Semaphores Leading to Indefinite Waiting'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-2：** 多个信号量导致的无限等待'
- en: '| **Step** | **Description** | **Main account semaphore** | **Secondary account
    semaphore** |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | **描述** | **主账户信号量** | **次账户信号量** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '|  | Initial state. | 1 | 1 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|  | 初始状态。 | 1 | 1 |'
- en: '| Skylar 1 | Acquire the semaphore of the main account balance. | 0 | 1 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| Skylar 1 | 获取主账户余额的信号量。 | 0 | 1 |'
- en: '| Skylar 2 | Retrieve the balance of the main account. | 0 | 1 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| Skylar 2 | 获取主账户余额。 | 0 | 1 |'
- en: '| Trina 1 | Acquire the semaphore of the secondary account balance. | 0 | 0
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| Trina 1 | 获取次账户余额的信号量。 | 0 | 0 |'
- en: '| Trina 2 | Retrieve the balance of the secondary account. | 0 | 0 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| Trina 2 | 获取次账户余额。 | 0 | 0 |'
- en: '| Skylar 3 | Acquire the semaphore of the secondary account balance. | 0 |
    0 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| Skylar 3 | 获取次账户余额的信号量。 | 0 | 0 |'
- en: '| Trina 3 | Acquire the semaphore of the main account balance. | 0 | 0 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| Trina 3 | 获取主账户余额的信号量。 | 0 | 0 |'
- en: I’ve shown only these steps because these are the only steps that would occur.
    Both Skylar’s and Trina’s processes would halt at step 3, because both are trying
    to acquire semaphores that aren’t available. What’s worse is that they can never
    become available, because each is being held by the other process. This is like
    waiting for traffic to clear so you can turn left on a two-lane road, but someone
    going the other way wants to turn left behind you, as shown in [Figure 8-3](ch08.html#ch8fig3).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我只展示了这些步骤，因为这是唯一会发生的步骤。Skylar 和 Trina 的过程都会在步骤 3 停止，因为两者都在尝试获取不可用的信号量。更糟糕的是，它们永远无法变得可用，因为每个信号量都被另一个进程持有。这就像是在一条双车道的路上等待交通清空，好让你左转，但有人从对面要在你后面左转，如[图
    8-3](ch08.html#ch8fig3)所示。
- en: '![image](graphics/f08-03.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-03.jpg)'
- en: '*Figure 8-3: If both white cars are waiting to turn left, traffic is stopped.*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-3：如果两辆白色汽车都在等待左转，那么交通就会停止。*'
- en: Because neither process in this example can continue until the other process
    completes, this situation is known as a *circular wait*. In this case, the circular
    wait involves only two processes, but circular waits sometimes involve many processes,
    and is therefore difficult to detect or foresee. A circular wait is one form of
    *deadlock*, which describes a situation in which a process cannot be expected
    to continue. Circular waits are one way that concurrency can cause deadlocks,
    and unless precautions are taken, a circular wait can occur whenever processes
    hold multiple semaphores at once. Fortunately, such precautions can be easy to
    implement.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在这个例子中，任何一个进程都无法继续执行，直到另一个进程完成，这种情况被称为*循环等待*。在这种情况下，循环等待只涉及两个进程，但有时循环等待可能涉及多个进程，因此难以检测或预见。循环等待是*死锁*的一种表现，死锁描述的是一种进程无法继续执行的情况。循环等待是并发导致死锁的一种方式，除非采取预防措施，否则当进程同时持有多个信号量时，就有可能发生循环等待。幸运的是，这类预防措施是相对容易实现的。
- en: One solution is a rule by which semaphores must be acquired in some specified
    order. In our example, the game’s bank management system can internally assign
    each account a number, and require processes to acquire account semaphores in
    numerical order. Or, put more broadly, a process can acquire an account’s semaphore
    only when it does not currently hold a semaphore for an account with a higher
    number. This rule prevents the circular wait in the previous example. Let’s suppose
    the main account is 39785 and the secondary account is 87685\. Because the main
    account number is lower, both Skylar’s and Trina’s processes would attempt to
    acquire its semaphore first. If both processes tried at the same time, only one
    process would succeed. That process would then acquire the semaphore for the secondary
    account and complete the transaction, at which point both account semaphores would
    be released, allowing the other process to continue through completion.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是通过规则要求信号量必须按指定的顺序获取。在我们的示例中，游戏的银行管理系统可以为每个账户内部分配一个号码，并要求进程按数字顺序获取账户信号量。或者更广泛地说，进程只能在当前没有持有编号更高账户的信号量时，才可以获取某个账户的信号量。这个规则避免了前面示例中的循环等待。假设主账户是39785，副账户是87685。因为主账户的号码较低，Skylar和Trina的进程都会尝试首先获取主账户的信号量。如果两个进程同时尝试，只有一个进程会成功。成功的进程将获取副账户的信号量并完成交易，此时两个账户的信号量都会被释放，允许另一个进程继续执行直到完成。
- en: '**Performance Issues of Semaphores**'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**信号量的性能问题**'
- en: With the proper rules in place, semaphores enable concurrency without fear of
    race conditions, deadlock, or starvation. However, in situations where we are
    trying to boost performance by having multiple processors work together on the
    same job, enforcing these semaphore rules can limit the performance benefit we
    hoped to create. Instead of lots of processors working together, we are left instead
    with lots of processors waiting in line for an opportunity to work. Concurrent
    software can mitigate these performance issues by creating additional rules.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在适当规则的约束下，信号量能够实现并发，而无需担心竞态条件、死锁或饥饿问题。然而，在我们试图通过让多个处理器共同处理同一任务来提高性能时，强制执行这些信号量规则可能会限制我们希望创造的性能收益。我们没有看到多个处理器一起工作，而是看到大量处理器排队等待工作机会。并发软件可以通过制定额外的规则来缓解这些性能问题。
- en: Sometimes a process needs access to a piece of data but doesn’t need to change
    it. In our running guild bank example, suppose Skylar and Trina are both inspecting
    the main guild account at the same time—that is, neither player is depositing
    or withdrawing, but is merely checking the balance. In this case, no danger arises
    from the simultaneous access of the account. Even though the processes would have
    potentially overlapping retrieval operations, as long as neither one of them updated
    the balance, everything would be fine.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，进程需要访问某一数据项，但不需要更改它。在我们正在运行的公会银行示例中，假设Skylar和Trina同时检查主公会账户——也就是说，两位玩家都没有进行存款或取款，而只是检查余额。在这种情况下，账户的同时访问不会产生危险。尽管进程可能会有重叠的检索操作，只要它们都没有更新余额，一切都不会出问题。
- en: 'Allowing simultaneous access during “read-only” situations greatly improves
    multiprocessor performance, and requires only a modification of the semaphore
    concept. Instead of having one semaphore for each piece of data to be shared,
    we’ll have two: a *read* semaphore and a *write* semaphore, subject to the following
    rules:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在“只读”情况下允许同时访问极大地提高了多处理器的性能，这只需要对信号量概念进行修改。我们将不再为每个要共享的数据项设置一个信号量，而是设置两个：一个*读*信号量和一个*写*信号量，并遵循以下规则：
- en: • Acquiring the associated *write* semaphore allows data to be retrieved or
    updated, just like how the semaphores worked in previous examples.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: • 获取关联的*写*信号量允许数据被检索或更新，就像前面例子中的信号量一样。
- en: • Acquiring the associated *read* semaphore allows data to be retrieved, but
    not updated.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: • 获取关联的*读*信号量可以检索数据，但不能更新数据。
- en: • A *write* semaphore can be acquired only when no process holds a semaphore
    (of either type) for that data.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: • 只有当没有进程持有该数据的信号量（无论是哪种类型）时，才能获取*写*信号量。
- en: • A *read* semaphore can be acquired only when no process holds a *write* semaphore
    for that data.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: • 只有当没有进程持有该数据的*写*信号量时，才能获取*读*信号量。
- en: Following these rules means that at any given time, either one process will
    have acquired the write semaphore for a piece of data or one or more processes
    will have acquired read semaphores for that data. At first, this appears to be
    what we want. So long as processes are merely looking at, but not changing data,
    they can share access. Once a process needs to change the data, all other processes
    are locked out until the updating process completes its work.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些规则意味着在任何给定时刻，要么一个进程已经获取了某个数据项的写信号量，要么一个或多个进程已经获取了该数据的读信号量。乍一看，这似乎是我们想要的。只要进程仅仅是查看数据而不进行修改，它们就可以共享访问。一旦某个进程需要更改数据，所有其他进程都会被锁住，直到更新进程完成工作。
- en: 'Unfortunately, these rules potentially reintroduce the starvation problem.
    As long as read-only processes keep arriving, a process that needs a write semaphore
    might wait indefinitely. To prevent this from happening, we can modify the last
    rule as follows: “a read semaphore can be acquired only when no process is holding
    or waiting for a write semaphore.” In other words, once a process attempts to
    acquire a write semaphore, all processes arriving later must wait behind it.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这些规则可能会重新引入饥饿问题。只要只读进程不断到来，可能需要写信号量的进程可能会一直等待下去。为了防止这种情况发生，我们可以按如下方式修改最后一条规则：“只有在没有进程持有或等待写信号量时，才能获取读信号量。”换句话说，一旦进程尝试获取写信号量，所有之后到达的进程必须排队等待。
- en: Another potential concern for performance is known as *granularity*, which in
    this context refers to whether we lock up individual pieces or collections of
    data. For example, the bank system could use semaphores to protect individual
    data elements, such as the balance of the main guild account, or it could apply
    a single read/write pair for all data related to a particular guild’s finances,
    such as the balances of all guild accounts, the list of guild officers who are
    allowed to access that account, and so on.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能影响性能的问题被称为*粒度*，在这个上下文中，粒度是指我们是锁定单个数据元素还是一组数据。例如，银行系统可以使用信号量来保护单个数据元素，如主公会账户的余额，或者它可以为与特定公会财务相关的所有数据应用一个读/写信号量对，例如所有公会账户的余额、允许访问该账户的公会官员名单等。
- en: Protecting data as a group can cause more waiting, because a process that may
    need only one or two numbers in a data group will have to lock up all the data
    in the group, potentially blocking another process that needs other, nonoverlapping
    data from the group. Very fine granularity can also hinder performance. Acquiring
    and releasing semaphores takes time, and with lots of semaphores, it’s possible
    for processes to spend most of their time dealing with them. Developers must therefore
    carefully determine the best granularity for a particular application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个整体保护数据可能会导致更多的等待，因为一个只需要数据组中一两个数字的进程将不得不锁住整个数据组，这可能会阻塞另一个需要从该组中获取其他不重叠数据的进程。过细的粒度也会影响性能。获取和释放信号量需要时间，并且如果信号量过多，进程可能会花费大部分时间来处理它们。因此，开发人员必须仔细确定特定应用程序的最佳粒度。
- en: '**What’s Next for Concurrency**'
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**并发的未来**'
- en: For several reasons, we can expect concurrency to be an even greater concern
    for the future.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 出于几个原因，我们可以预见并发将在未来成为更为重要的问题。
- en: These days, multiple processing cores can be found even in our simplest computing
    devices. The push for more processing power will continue, and until the arrival
    of a new processing paradigm like quantum computing, more processing power will
    mean more processor cores.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，即使在我们最简单的计算设备中，也可以找到多个处理核心。对更强大处理能力的追求将持续进行，直到量子计算等新的处理范式出现为止，更多的处理能力将意味着更多的处理器核心。
- en: Multitasking is now the norm. We expect our computing devices to run multiple
    applications at the same time, and to interrupt our foreground tasks when something
    interesting happens in the background.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 多任务处理现在已经成为常态。我们期望我们的计算设备能够同时运行多个应用程序，并且在后台发生有趣的事情时打断我们的前台任务。
- en: Data and devices are becoming more connected than ever. Data and processing
    are increasingly being moved from client devices onto servers or clouds of interconnected
    servers. In computer gaming, socialization is the new paradigm, and in some games,
    even single-player game modes require an Internet connection.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 数据和设备之间的连接比以往任何时候都更加紧密。数据和处理正越来越多地从客户端设备转移到服务器或相互连接的服务器云上。在计算机游戏中，社交化已成为新的范式，在某些游戏中，即使是单人游戏模式也需要互联网连接。
- en: In short, properly handling concurrency is becoming essential in everyday computing.
    What looks like a single computer running a single-user application may contain
    a multiprocessor that provides a multitasking environment with shared cloud storage
    for data. The vital power of concurrency is thus often invisible. As the trend
    toward even greater concurrency continues, we may take for granted the way in
    which so many processes work together without running into one another. But future
    improvements in computing depend upon further advancements in concurrency control.
    We don’t know yet whether current methods of preventing deadlock, starvation,
    and race conditions will be sufficient as concurrency increases. If current methods
    are inadequate for solving future challenges, they will become the bottleneck
    until better methods are developed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，正确处理并发性在日常计算中变得至关重要。看似只有一个计算机在运行单用户应用程序，实际上可能包含一个多处理器系统，提供一个多任务环境，并共享云存储来存储数据。因此，并发的强大能力往往是隐形的。随着向更大并发性的趋势不断发展，我们可能会理所当然地认为，许多进程能够在不互相干扰的情况下协同工作。但计算机技术的未来进步将依赖于并发控制的进一步发展。目前，我们还不清楚当前防止死锁、饥饿和竞争条件的方法是否能随着并发性的增加而保持足够有效。如果当前的方法无法解决未来的挑战，它们将成为瓶颈，直到开发出更好的方法。
