<html><head></head><body>
<h2 class="h2" id="ch8"><span epub:type="pagebreak" id="page_91"/><span class="big">8</span><br/>RUNNING SCRIPTS REMOTELY</h2>&#13;
<div class="image1"><img class="inline" src="../images/common.jpg" alt="Images"/></div>&#13;
<p class="noindent"><span class="bign">If you’re the sole IT person in a small organization, chances are you have several servers to manage. If you have a script you need to run, you could log in to each server, open up the PowerShell console, and run your script there. But you can save a lot of time if you run one script that performs a particular task on each server. In this chapter, you’ll learn how to run commands remotely using PowerShell remoting.</span></p>&#13;
<p class="indent"><em>PowerShell remoting</em> is a feature that allows a user to remotely run commands in a session on one or many computers at once. A <em>session</em>, or more specifically, a <span class="literal">PSSession</span>, is a PowerShell remoting term that refers to the environment running PowerShell on a remote computer from which you can execute commands. Though executed differently, the Microsoft Sysinternals tool <span class="literal">psexec</span> is the same concept: you write code that works on your local machine, <span epub:type="pagebreak" id="page_92"/>send that code over to a remote computer, and execute the code as if you were sitting in front of it.</p>&#13;
<p class="indent">We’ll spend most of this chapter looking at sessions—what they are, how to use them, and what to do when you’re done with them—but first, you’ll need to understand a few things about scriptblocks.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Microsoft introduced PowerShell remoting in PowerShell v2, which is built on top of the</em> Windows Remote Management (WinRM) <em>service. For this reason, you may, on occasion, see the term WinRM used to refer to PowerShell remoting.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch8lev1">Working with Scriptblocks</h3>&#13;
<p class="noindent">PowerShell remoting makes extensive use of <em>scriptblocks</em>, which, like functions, are code packaged into a single executable unit. But they’re different from functions in a couple of key ways: they’re anonymous—or unnamed—and they can be assigned to variables.</p>&#13;
<p class="indent">To examine this difference, let’s consider an example. Let’s define a function, called <span class="literal">New-Thing</span>, which calls <span class="literal">Write-Host</span> to display some text in the console (see <a href="ch08.xhtml#ch8list1">Listing 8-1</a>).</p>&#13;
<pre>function New-Thing {&#13;
    param()&#13;
    Write-Host "Hi! I am in New-Thing"&#13;
}&#13;
&#13;
New-Thing</pre>&#13;
<p class="caption" id="ch8list1"><em>Listing 8-1: Defining the <span class="literal">New-Thing</span> function, which displays text in the console window</em></p>&#13;
<p class="indent">If you run this script, you should see that it returns the text <span class="literal">"Hi! I am in New-Thing!"</span> to the console. But notice that for this result, you had to call <span class="literal">New-Thing</span> for the function to run.</p>&#13;
<p class="indent">You can replicate the result of the <span class="literal">New-Thing</span> function call with a scriptblock by first assigning the scriptblock to a variable, as in <a href="ch08.xhtml#ch8list2">Listing 8-2</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$newThing = { Write-Host "Hi! I am in a scriptblock!" }</span></pre>&#13;
<p class="caption" id="ch8list2"><em>Listing 8-2: Creating a scriptblock and assigning it to a variable called <span class="literal">$newThing</span></em></p>&#13;
<p class="indent">To build a scriptblock, place the code you want to execute between curly brackets. You stored our scriptblock in the <span class="literal">$newThing</span> variable, and you might think that to execute that scriptblock, you could simply call the variable, as shown in <a href="ch08.xhtml#ch8list3">Listing 8-3</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$newThing = { Write-Host "Hi! I am in a scriptblock!" }</span>&#13;
PS&gt; <span class="codestrong1">$newThing</span>&#13;
 Write-Host "Hi! I am in a scriptblock!"</pre>&#13;
<p class="caption" id="ch8list3"><em>Listing 8-3: Creating and executing a scriptblock</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_93"/>But as you can see, PowerShell reads the contents of <span class="literal">$newThing</span> literally. It doesn’t realize that <span class="literal">Write-Host</span> is a command it should execute and instead displays the value of the scriptblock.</p>&#13;
<p class="indent">To tell PowerShell to run the code inside, you need to use an ampersand (<span class="literal">&amp;</span>) followed by the variable name. <a href="ch08.xhtml#ch8list4">Listing 8-4</a> shows this syntax.</p>&#13;
<pre>PS&gt; <span class="codestrong1">&amp; $newThing</span>&#13;
Hi! I am in a scriptblock!</pre>&#13;
<p class="caption" id="ch8list4"><em>Listing 8-4: Executing a scriptblock</em></p>&#13;
<p class="indent">The ampersand tells PowerShell that the stuff between the curly brackets is code that it should run. The ampersand is one way to execute a code block; however, it does not allow you the customization a command would, which you’ll need when using PowerShell remoting to work on remote computers. The next section covers another way to execute scriptblocks.</p>&#13;
<h4 class="h4" id="ch8lev1sec1">Using Invoke-Command to Execute Code on Remote Systems</h4>&#13;
<p class="noindent">You’ll use two main commands when working with PowerShell remoting: <span class="literal">Invoke-Command</span> and <span class="literal">New-PSSession</span>. In this section, you’ll learn about <span class="literal">Invoke-Command</span>; the next section covers the <span class="literal">New-PSSession</span> command.</p>&#13;
<p class="indent"><span class="literal">Invoke-Command</span> is probably the command you’ll use the most with PowerShell remoting. There are two main ways to use it. The first is when you run what I call <em>ad hoc commands</em>—small, one-off expressions you want to execute. The second is using interactive sessions. We’ll cover both in this chapter.</p>&#13;
<p class="indent">An example of an ad hoc command is when you run <span class="literal">Start-Service</span> to start a service on a remote computer When you execute an ad hoc command by using <span class="literal">Invoke-Command</span>, PowerShell creates a session behind the scenes, tearing it down as soon as the command has completed. This limits what you can do with just <span class="literal">Invoke-Command</span>, which is why in the next section, you’ll see how to create your own sessions.</p>&#13;
<p class="indent">But for now, let’s see how <span class="literal">Invoke-Command</span> works with an ad hoc command. Open your PowerShell console, type <span class="literal">Invoke-Command</span>, and press <span class="small">ENTER</span>, as in <a href="ch08.xhtml#ch8list5">Listing 8-5</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Invoke-Command</span>&#13;
&#13;
cmdlet Invoke-Command at command pipeline position 1&#13;
Supply values for the following parameters:&#13;
ScriptBlock:</pre>&#13;
<p class="caption" id="ch8list5"><em>Listing 8-5: Running <span class="literal">Invoke-Command</span> with no parameters</em></p>&#13;
<p class="indent">Your console should immediately ask you to provide a scriptblock. You’ll provide the <span class="literal">hostname</span> command, which will return the hostname of the computer the command is run on.</p>&#13;
<p class="indent">To pass a scriptblock with <span class="literal">hostname</span> to <span class="literal">Invoke-Command</span>, you need to use the required parameter, <span class="literal">ComputerName</span>, which tells <span class="literal">Invoke-Command</span> which remote computer to run this command on, as you can see in <a href="ch08.xhtml#ch8list6">Listing 8-6</a>. (Note that <span epub:type="pagebreak" id="page_94"/>for this to work, my machine and the remote computer <span class="literal">WEBSRV1</span> have to be part of the same Active Directory (AD) domain, and my machine needs to have admin rights on <span class="literal">WEBSRV1</span>.)</p>&#13;
<pre>PS&gt; <span class="codestrong1">Invoke-Command -ScriptBlock { hostname } -ComputerName WEBSRV1</span>&#13;
WEBSRV1</pre>&#13;
<p class="caption" id="ch8list6"><em>Listing 8-6: Running a simple <span class="literal">Invoke-Command</span> example</em></p>&#13;
<p class="indent">Notice that the output of <span class="literal">hostname</span> is now the name of the remote computer—in my system, the remote computer is called <span class="literal">WEBSRV1</span>. You’ve now executed your first remote command!</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you try this on a remote machine with an operating system older than Windows Server 2012 R2, it might not work as expected. If this is the case, you’ll first have to enable PowerShell remoting. As of Server 2012 R2, PowerShell remoting is enabled, by default, with the WinRM service running with all the necessary firewall ports open and access rights set up. But if you’re running an earlier version of Windows, this has to be done manually, so run <span class="codeitalicB">Enable-PSRemoting</span> on your remote computer in an elevated console session first before attempting to run <span class="codeitalic">Invoke-Command</span> against an older server. You may also use the <span class="codeitalicB">Test-WSMan</span> command to confirm whether PowerShell remoting is configured and available.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch8lev1sec2">Running Local Scripts on Remote Computers</h4>&#13;
<p class="noindent">In the previous section, you executed scriptblocks on remote computers. You can also use <span class="literal">Invoke-Command</span> to execute entire scripts. Instead of using the <span class="literal">Scriptblock</span> parameter, you can use the <span class="literal">FilePath</span> parameter and a path to a script on your machine. When using the <span class="literal">FilePath</span> parameter, <span class="literal">Invoke-Command</span> will read the contents of the script locally and then execute that code on the remote computer. Contrary to popular belief, the script itself isn’t executed on the remote computer.</p>&#13;
<p class="indent">To demonstrate, let’s say you have a script on your local computer in the root of <em>C:\</em> called <em>GetHostName.ps1</em>. This script has one line in it: <span class="literal">hostname</span>. You’d like to run this script on a remote computer to return the computer’s hostname. Note that while we’re keeping the script extremely simple, <span class="literal">Invoke-Command</span> doesn’t care what’s inside the script. It will happily execute whatever is there.</p>&#13;
<p class="indent">To run the script, you pass the script file to the <span class="literal">FilePath</span> parameter on <span class="literal">Invoke-Command</span>, as shown in <a href="ch08.xhtml#ch8list7">Listing 8-7</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Invoke-Command -ComputerName WEBSRV1 -FilePath C:\GetHostName.ps1</span>&#13;
WEBSRV1</pre>&#13;
<p class="caption" id="ch8list7"><em>Listing 8-7: Running a local script on remote computers</em></p>&#13;
<p class="indent"><span class="literal">Invoke-Command</span> runs the code inside <em>GetHostName.ps1</em> on the <span class="literal">WEBSRV1</span> computer and returns the output back to your local session.</p>&#13;
<h4 class="h4" id="ch8lev1sec3"><span epub:type="pagebreak" id="page_95"/>Using Local Variables Remotely</h4>&#13;
<p class="noindent">Though PowerShell remoting takes care of a lot of things, you have to watch out when using local variables. Let’s say you have a file path on a remote computer that’s <em>C:\File.txt</em>. Because this file path may change at some point, you may decide to assign that path as a variable; for example, <span class="literal">$serverFilePath</span>:</p>&#13;
<pre>PS&gt; <span class="codestrong1">$serverFilePath = 'C:\File.txt'</span></pre>&#13;
<p class="indent">Now, you may need to reference the <em>C:\File.txt</em> path inside a remote scriptblock. In <a href="ch08.xhtml#ch8list8">Listing 8-8</a>, you can see what happens when you attempt to reference the variable directly.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Invoke-Command -ComputerName WEBSRV1 -ScriptBlock { Write-Host "The value&#13;
of foo is $serverFilePath" }</span>&#13;
The value of foo is</pre>&#13;
<p class="caption" id="ch8list8"><em>Listing 8-8: Local variables do not work in remote sessions.</em></p>&#13;
<p class="indent">Notice that the <span class="literal">$serverFilePath</span> variable doesn’t have a value, because while inside the scriptblock being executed on the remote computer, the variable doesn’t exist! When you define a variable in a script or at the console, that variable is stored in a particular <em>runspace</em>, which is a container that PowerShell uses to store the information for the session. You may have run into runspaces if you’ve tried to open two PowerShell consoles at the same time and (failed to) use the variables of one in the other.</p>&#13;
<p class="indent">By default, variables, functions, and other constructs can’t spread over multiple runspaces. However, you can use a couple of methods to use variables, functions, and so forth, in various runspaces. There are two main ways to transfer variables to a remote computer.</p>&#13;
<h5 class="h5">Passing Variables with the ArgumentList Parameter</h5>&#13;
<p class="noindent">To get the value of a variable into a remote scriptblock, you can use the <span class="literal">ArgumentList</span> parameter on <span class="literal">Invoke-Command</span>. This parameter allows you to pass an array of local values to the scriptblock, called <span class="literal">$args</span>, which you can use in your scriptblock’s code. To show how this works, in <a href="ch08.xhtml#ch8list9">Listing 8-9</a>, you’ll pass the <span class="literal">$serverFilePath</span> variable, which contains the file path <em>C:\File.txt</em>, to the remote scriptblock and then reference it through the <span class="literal">$args</span> array.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Invoke-Command -ComputerName WEBSRV1 -ScriptBlock { Write-Host "The value&#13;
of foo is $($args[0])" } -ArgumentList $serverFilePath</span>&#13;
The value of foo is C:\File.txt</pre>&#13;
<p class="caption" id="ch8list9"><em>Listing 8-9: Using the <span class="literal">$args</span> array to pass local variables to a remote session</em></p>&#13;
<p class="indent">As you should see, the variable’s value, <em>C:\File.txt</em>, is now inside the scriptblock. This is because you passed <span class="literal">$serverFilePath</span> into <span class="literal">ArgumentList</span> and replaced the <span class="literal">$serverFilePath</span> reference inside the scriptblock with <span class="literal">$args[0]</span>. If you want to pass more than one variable into the scriptblock, <span epub:type="pagebreak" id="page_96"/>you can add another value to the <span class="literal">ArgumentList</span> parameter value and increment the <span class="literal">$args</span> reference by one where you want to reference the new variable.</p>&#13;
<h5 class="h5">Using the $Using Statement to Pass Variable Values</h5>&#13;
<p class="noindent">Another way to pass the values of local variables to a remote scriptblock is with the <span class="literal">$using</span> statement. You can avoid using the <span class="literal">ArgumentList</span> parameter by prepending <span class="literal">$using</span> to any local variable name. Before PowerShell sends the scriptblock to the remote computer, it will look for the <span class="literal">$using</span> statement and expand all the local variables inside the scriptblock.</p>&#13;
<p class="indent">In <a href="ch08.xhtml#ch8list10">Listing 8-10</a>, you’ll rewrite <a href="ch08.xhtml#ch8list9">Listing 8-9</a> to use <span class="literal">$using:serverFilePath</span> instead of <span class="literal">ArgumentList</span>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Invoke-Command -ComputerName WEBSRV1 -ScriptBlock { Write-Host "The value&#13;
of foo is $using:serverFilePath" }</span>&#13;
The value of foo is C:\File.txt</pre>&#13;
<p class="caption" id="ch8list10"><em>Listing 8-10: Using <span class="literal">$using</span> to reference local variables in a remote session</em></p>&#13;
<p class="indent">As you should see, the results of <a href="ch08.xhtml#ch8list9">Listings 8-9</a> and <a href="ch08.xhtml#ch8list10">8-10</a> are the same.</p>&#13;
<p class="indent">The <span class="literal">$using</span> statement requires less work and is more intuitive, but down the road, when you begin to write Pester to test your scripts, you’ll see that you may have to revert to using the <span class="literal">ArgumentList</span> parameter: when using the <span class="literal">$using</span> option, Pester will have no way to evaluate the value in a <span class="literal">$using</span> variable. When using the <span class="literal">ArgumentList</span> parameter, the variables passed to the remote session are defined locally, which Pester can interpret and understand. If this doesn’t make sense now, it will when you read <a href="ch09.xhtml#ch9">Chapter 9</a>. For now, the <span class="literal">$using</span> statement works excellently!</p>&#13;
<p class="indent">Now that you have a basic understanding of the <span class="literal">Invoke-Command</span> cmdlet, let’s learn a few more sessions.</p>&#13;
<h3 class="h3" id="ch8lev2">Working with Sessions</h3>&#13;
<p class="noindent">As mentioned earlier, PowerShell remoting uses a concept called a <em>session</em>. When you create a session remotely, PowerShell opens a <em>local session</em> on the remote computer, which you can use to execute commands there. You don’t need to know too many of the technical details of a session. What you do need to know is that you can create, connect to, and disconnect from a session, and it will maintain the same state that you left it in. The session won’t end until you remove it.</p>&#13;
<p class="indent">In the previous section, when you ran <span class="literal">Invoke-Command</span>, it brought up a new session, ran the code, and tore it down all in one go. In this section, you’ll see how to create what I call <em>full sessions</em>, sessions that you can enter commands into directly. Using <span class="literal">Invoke-Command</span> to execute one-off ad hoc commands works well, but it’s not too efficient when you need to run a lot of commands that can’t all squeeze into a single scriptblock. For example, if you’re working on a large script that performs work locally, has to grab information from another source, use that information in a remoting session, grab information from a remoting session to be used locally, and then return to the local computer, <span epub:type="pagebreak" id="page_97"/>you will have to create a script that runs <span class="literal">Invoke-Command</span> repeatedly. On top of that, you’ll have more issues if you need to set a variable in the remote session and use it again later. Using <span class="literal">Invoke-Command</span> as you have so far, this wouldn’t work—you’ll need a session that stays there after you leave.</p>&#13;
<h4 class="h4" id="ch8lev2sec4">Creating a New Session</h4>&#13;
<p class="noindent">To create a semipermanent session on a remote computer with PowerShell remoting, you have to explicitly create a full session by using the <span class="literal">New-PSSession</span> command, which will create a session on the remote computer and a reference to that session on your local computer.</p>&#13;
<p class="indent">To create a new <span class="literal">PSSession</span>, use <span class="literal">New-PSSession</span> with the <span class="literal">ComputerName</span> parameter, as in <a href="ch08.xhtml#ch8list11">Listing 8-11</a>. In this example, the computer I’m running this on is in the same Active Directory domain as <span class="literal">WEBSRV1</span>, and I’m logged in as a domain user with admin rights on <span class="literal">WEBSRV1</span>. To connect by using the <span class="literal">ComputerName</span> parameter (as I have in <a href="ch08.xhtml#ch8list11">Listing 8-11</a>), the user must be a local administrator or at least in the Remote Management Users group on the remote computer. If you’re not in an AD domain, you can use the <span class="literal">Credential</span> parameter on <span class="literal">New-PSSession</span> to pass a <span class="literal">PSCredential</span> object containing an alternate credential to authenticate to the remote computer.</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-PSSession -ComputerName WEBSRV1</span>&#13;
&#13;
 Id Name        ComputerName   ComputerType    State    ConfigurationName      Availability&#13;
 -- ----        ------------   ------------    -----    -----------------      ------------&#13;
  3 WinRM3      WEBSRV1        RemoteMachine   Opened   Microsoft.PowerShell   Available</pre>&#13;
<p class="caption" id="ch8list11"><em>Listing 8-11: Creating a new <span class="literal">PSSession</span></em></p>&#13;
<p class="indent">As you can see, <span class="literal">New-PSSession</span> returns a session. Once the session is established, you can jump in and out of the session with <span class="literal">Invoke-Command</span>; instead of using the <span class="literal">ComputerName</span> parameter, as you did with the ad hoc command, you’ll have to use the <span class="literal">Session</span> parameter.</p>&#13;
<p class="indent">You need to provide the <span class="literal">Session</span> parameter with a session object. You can use the <span class="literal">Get-PSSession</span> command to see all your current sessions. In <a href="ch08.xhtml#ch8list12">Listing 8-12</a>, you’ll store the output of <span class="literal">Get-PSSession</span> in a variable.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$session = Get-PSSession</span>&#13;
PS&gt; <span class="codestrong1">$session</span>&#13;
&#13;
 Id    Name     ComputerName   ComputerType    State    ConfigurationName      Availability&#13;
 --    ----     ------------   ------------    -----    -----------------      ------------&#13;
  6    WinRM6   WEBSRV1        RemoteMachine   Opened   Microsoft.PowerShell   Available</pre>&#13;
<p class="caption" id="ch8list12"><em>Listing 8-12: Finding sessions created on the local computer</em></p>&#13;
<p class="indent">Because you ran <span class="literal">New-PSSession</span> only once, you have only one <span class="literal">PSSession</span> created in <a href="ch08.xhtml#ch8list12">Listing 8-12</a>. If you have multiple sessions, you can pick the session you want <span class="literal">Invoke-Command</span> to use by using the <span class="literal">Get-PSSession</span> command’s <span class="literal">Id</span> parameter.</p>&#13;
<h4 class="h4" id="ch8lev2sec5"><span epub:type="pagebreak" id="page_98"/>Invoking Commands in a Session</h4>&#13;
<p class="noindent">Now that you have a session in a variable, you can pass that variable to <span class="literal">Invoke-Command</span> and run some code inside the session, as in <a href="ch08.xhtml#ch8list13">Listing 8-13</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Invoke-Command -Session $session -ScriptBlock { hostname }</span>&#13;
WEBSRV1</pre>&#13;
<p class="caption" id="ch8list13"><em>Listing 8-13: Using an existing session to invoke commands on a remote computer</em></p>&#13;
<p class="indent">You should notice that this command runs much faster than when you passed it a command. This is because <span class="literal">Invoke-Command</span> doesn’t have to create and tear down a new session. When you create a full session, not only is it faster, but you also have access to more functionality. For example, as you can see in <a href="ch08.xhtml#ch8list14">Listing 8-14</a>, you can set variables in the remote session and return to the session without losing those variables.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Invoke-Command -Session $session -ScriptBlock { $foo = 'Please be here next time' }</span>&#13;
PS&gt; <span class="codestrong1">Invoke-Command -Session $session -ScriptBlock { $foo }</span>&#13;
Please be here next time</pre>&#13;
<p class="caption" id="ch8list14"><em>Listing 8-14: Variable values remain over subsequent session connections.</em></p>&#13;
<p class="indent">As long as the session stays open, you can do whatever you need in the remote session, and the state of the session will go unchanged. However, this is valid for only your current local session. If you start another PowerShell process, you can’t just pick up where you left off. The remote session will still be active, but the reference to that remote session on the local computer will be gone. In that case, the <span class="literal">PSSession</span> will go into a disconnected state (which you’ll see in an upcoming section).</p>&#13;
<h4 class="h4" id="ch8lev2sec6">Opening Interactive Sessions</h4>&#13;
<p class="noindent"><a href="ch08.xhtml#ch8list14">Listing 8-14</a> used <span class="literal">Invoke-Command</span> to send commands to a remote computer and receive a response. Running remote commands like this is like running an unmonitored script. It’s not interactive, as when you’re punching keystrokes into a PowerShell console. If you want to open an interactive console for the session running on a remote computer—for some troubleshooting, for example—you can use the <span class="literal">Enter-PSSession</span> command.</p>&#13;
<p class="indent">The <span class="literal">Enter-PSSession</span> command allows the user to work with the session interactively. It can either create its own session or rely on an existing one created with <span class="literal">New-PSSession</span>. If you do not specify a session to enter into, <span class="literal">Enter-PSSession</span> will create a new one and wait for further input, as in <a href="ch08.xhtml#ch8list15">Listing 8-15</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Enter-PSSession -ComputerName WEBSRV1</span>&#13;
[WEBSRV1]: PS C:\Users\Adam\Documents&gt;</pre>&#13;
<p class="caption" id="ch8list15"><em>Listing 8-15: Entering an interactive session</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_99"/>Notice that your PowerShell prompt changes to <span class="literal">[WEBSRV1]: PS</span>. This prompt indicates that you’re no longer running commands locally but in that remote session. At this point, you can run any command you want, as if you’re at the console of the remote computer. Working with sessions interactively like this is a great way to eliminate using the <em>Remote Desktop Protocol</em> (<em>RDP</em>) application to bring up an interactive GUI to perform tasks, like troubleshooting on a remote computer.</p>&#13;
<h4 class="h4" id="ch8lev2sec7">Disconnecting from and Reconnecting to Sessions</h4>&#13;
<p class="noindent">If you close your PowerShell console, open it back up again, and try to use <span class="literal">Invoke-Command</span> in the session you were previously working in, you will receive an error message, as in <a href="ch08.xhtml#ch8list16">Listing 8-16</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$session = Get-PSSession -ComputerName websrv1</span>&#13;
PS&gt; <span class="codestrong1">Invoke-Command -Session $session -ScriptBlock { $foo }</span>&#13;
Invoke-Command : Because the session state for session WinRM6, a617c702-ed92&#13;
-4de6-8800-40bbd4e1b20c, websrv1 is not equal to Open, you cannot run a&#13;
command in the session. The session state is Disconnected.&#13;
At line:1 char:1&#13;
+ Invoke-Command -Session $session -ScriptBlock { $foo }&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch8list16"><em>Listing 8-16: Attempting to run commands in a disconnected session</em></p>&#13;
<p class="indent">PowerShell can find the <span class="literal">PSSession</span> on the remote computer but can’t find the reference on the local machine, which tells you the session is disconnected. This is what happens if you don’t correctly disconnect the local session reference to the remote <span class="literal">PSSession</span>.</p>&#13;
<p class="indent">You can disconnect existing sessions by using the <span class="literal">Disconnect-PSSession</span> command. You can clean up any sessions previously created by retrieving them with <span class="literal">Get-PSSession</span> and then piping those sessions to the <span class="literal">Disconnect-PSSession</span> command (see <a href="ch08.xhtml#ch8list17">Listing 8-17</a>). Or, alternatively, you can use the <span class="literal">Session</span> parameter on <span class="literal">Disconnect-PSSession</span> to disconnect one session at a time.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-PSSession | Disconnect-PSSession</span>&#13;
&#13;
Id Name          ComputerName   ComputerType    State          ConfigurationName    Availability&#13;
-- ----          ------------   ------------    -----          -----------------    ------------&#13;
 4 WinRM4        WEBSRV1        RemoteMachine   Disconnected   Microsoft.PowerShell None</pre>&#13;
<p class="caption" id="ch8list17"><em>Listing 8-17: Disconnecting a <span class="literal">PSSession</span></em></p>&#13;
<p class="indent">To properly disconnect from a session, you pass your remote session name to the <span class="literal">Session</span> parameter by either calling it explicitly via <span class="literal">Disconnect-PSSession -Session</span> <span class="codeitalic">session name</span> or piping an existing session to the command via <span class="literal">Get-PSSession</span> as in <a href="ch08.xhtml#ch8list17">Listing 8-17</a>.</p>&#13;
<p class="indent">If you’d like to connect to your session again later, after you’ve disconnected with <span class="literal">Disconnect-PSSession</span>, close your PowerShell console and then use the <span class="literal">Connect-PSSession</span> command, as in <a href="ch08.xhtml#ch8list18">Listing 8-18</a>. Note that you can see <span epub:type="pagebreak" id="page_100"/>and connect only to disconnected sessions that your account has already created. You will not be able to see sessions other users have created.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Connect-PSSession -ComputerName websrv1</span>&#13;
[WEBSRV1]: PS&gt;</pre>&#13;
<p class="caption" id="ch8list18"><em>Listing 8-18: Reconnecting to a <span class="literal">PSSession</span></em></p>&#13;
<p class="indent">You should now be able to run code on the remote computer as if you never closed your console.</p>&#13;
<p class="indent">If you still receive an error message, you may have mismatched PowerShell versions. Disconnected sessions work only if the local machine and remote server have the same PowerShell version. For example, if you have PowerShell 5.1 on your local computer, but the remote server you’re connecting to is running a version of PowerShell that doesn’t support disconnected sessions (such as PowerShell v2 or older), disconnected sessions won’t work. Always be sure that both the local machine and remote server have the same PowerShell version.</p>&#13;
<p class="indent">To check whether your local computer’s PowerShell version matches the version on your remote computer, check the value of the <span class="literal">$PSVersionTable</span> variable, which contains versioning information (see <a href="ch08.xhtml#ch8list19">Listing 8-19</a>).</p>&#13;
<pre>PS&gt; <span class="codestrong1">$PSVersionTable</span>&#13;
&#13;
Name                           Value&#13;
----                           -----&#13;
PSVersion                      5.1.15063.674&#13;
PSEdition                      Desktop&#13;
PSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}&#13;
BuildVersion                   10.0.15063.674&#13;
CLRVersion                     4.0.30319.42000&#13;
WSManStackVersion              3.0&#13;
PSRemotingProtocolVersion      2.3&#13;
SerializationVersion           1.1.0.1</pre>&#13;
<p class="caption" id="ch8list19"><em>Listing 8-19: Checking the PowerShell version on a local computer</em></p>&#13;
<p class="indent">To check for the version on your remote computer, run <span class="literal">Invoke-Command</span> on that computer, passing it the <span class="literal">$PSVersionTable</span> variable, as in <a href="ch08.xhtml#ch8list20">Listing 8-20</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Invoke-Command -ComputerName WEBSRV1 -ScriptBlock { $PSVersionTable }</span>&#13;
&#13;
Name                           Value&#13;
----                           -----&#13;
PSRemotingProtocolVersion      2.2&#13;
BuildVersion                   6.3.9600.16394&#13;
PSCompatibleVersions           {1.0, 2.0, 3.0, 4.0}&#13;
PSVersion                      4.0&#13;
CLRVersion                     4.0.30319.34014&#13;
WSManStackVersion              3.0&#13;
SerializationVersion           1.1.0.1</pre>&#13;
<p class="caption" id="ch8list20"><em>Listing 8-20: Checking the PowerShell version on a remote computer</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_101"/>I suggest that, before you disconnect from a session, you check that your versions match; that way, you can avoid losing valuable work on a remote system.</p>&#13;
<h4 class="h4" id="ch8lev2sec8">Removing Sessions with Remove-PSSession</h4>&#13;
<p class="noindent">Whenever the <span class="literal">New-PSSession</span> command creates a new session, that session exists both on the remote server and on the local computer. You can open a lot of sessions across many servers at the same time as well, and if some of those sessions are no longer in use, you may eventually need to clean them up. You can do so with the <span class="literal">Remove-PSSession</span> command, which goes out to the remote computer, tears down that session, and if it exists, removes the local <span class="literal">PSSession</span> reference. <a href="ch08.xhtml#ch8list21">Listing 8-21</a> is an example of this:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-PSSession | Remove-PSSession</span>&#13;
PS&gt; <span class="codestrong1">Get-PSSession</span></pre>&#13;
<p class="caption" id="ch8list21"><em>Listing 8-21: Removing a <span class="literal">PSSession</span></em></p>&#13;
<p class="indent">Here, you see that you’re running <span class="literal">Get-PSSession</span> again, and nothing is returned. This means there are no sessions on your local computer.</p>&#13;
<h3 class="h3" id="ch8lev3">Understanding PowerShell Remoting Authentication</h3>&#13;
<p class="noindent">So far, I’ve been ignoring the question of authentication. By default, if your local and remote computers are both in the same domain and both have PowerShell remoting enabled, you don’t need to explicitly authenticate. But if they’re not, you’ll need to authenticate somehow.</p>&#13;
<p class="indent">Two of the most common ways you can authenticate to remote computers with PowerShell remoting are by using Kerberos or CredSSP. If you’re in an Active Directory domain, you’re probably already using a Kerberos ticket system, whether you know it or not. Active Directory and some Linux systems use Kerberos <em>realms</em>, entities that issue tickets to clients. These tickets are then presented to resources and compared (in Active Directory) on domain controllers.</p>&#13;
<p class="indent">CredSSP, on the other hand, doesn’t need Active Directory. CredSSP was introduced way back with Windows Vista and uses a client-side credential service provider (CSP) to enable applications to delegate user credentials to remote computers. CredSSP doesn’t require an outside system, such as a domain controller, in order to authenticate two systems.</p>&#13;
<p class="indent">In an Active Directory environment, PowerShell remoting uses the Kerberos network authentication protocol to make calls out to Active Directory that perform all the authentication under the hood. PowerShell uses the account you’re logged onto locally as the user in order to authenticate to the remote computer—just like many other services. This is the beauty of single sign-on.</p>&#13;
<p class="indent">But sometimes you’re forced to change up that authentication type a bit if you’re not in an Active Directory environment; for example, when <span epub:type="pagebreak" id="page_102"/>you need to connect to remote computers over the internet or on the local network, but via local credentials on the remote computer. PowerShell supports numerous methods for PowerShell remoting authentication, but the most common—other than just using Kerberos—is CredSSP, which allows a local computer to delegate the user’s credentials to the remote computer. This concept is similar to Kerberos, but Active Directory is not needed.</p>&#13;
<p class="indent">You don’t usually need to use a different authentication type when working in an Active Directory environment, but it does come up sometimes, so it’s best you’re prepared. In this section, you’ll learn about a common authentication issue and how to work around it.</p>&#13;
<h4 class="h4" id="ch8lev3sec9">The Double Hop Problem</h4>&#13;
<p class="noindent">The <em>double hop problem</em> has been an issue ever since Microsoft added the PowerShell remoting feature. This problem arises when you’re running code inside a remote session, and then attempt to access remote resources from that remote session. For example, if you have a domain controller called DC on your network and you want to check out the files on the root of <em>C:\</em> by using the <span class="literal">C$</span> administrative share, you can browse the share remotely from your local machine without an issue (see <a href="ch08.xhtml#ch8list22">Listing 8-22</a>).</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-ChildItem -Path '\\dc\c$'</span>&#13;
&#13;
&#13;
    Directory: \\dc\c$&#13;
&#13;
&#13;
Mode                LastWriteTime         Length Name&#13;
----                -------------         ------ ----&#13;
d-----        10/1/2019  12:05 PM                FileShare&#13;
d-----       11/24/2019   2:28 PM                inetpub&#13;
d-----       11/22/2019   6:37 PM                InstallWindowsFeature&#13;
d-----        4/16/2019   1:10 PM                Iperf</pre>&#13;
<p class="caption" id="ch8list22"><em>Listing 8-22: Enumerating files over a UNC share</em></p>&#13;
<p class="indent">The issue arises when you create a <span class="literal">PSSession</span> and attempt to rerun the same command, as in <a href="ch08.xhtml#ch8list23">Listing 8-23</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Enter-PSSession -ComputerName WEBSRV1</span>&#13;
[WEBSRV1]: PS&gt; Get-ChildItem -Path '\\dc\c$'&#13;
ls : Access is denied&#13;
--<span class="codeitalic1">snip</span>--&#13;
[WEBSRV1]: PS&gt;</pre>&#13;
<p class="caption" id="ch8list23"><em>Listing 8-23: Attempting to access network resources in a session</em></p>&#13;
<p class="indent">In this case, PowerShell tells you that access is denied—even when you know your user account has access. This happens because, when you use the default Kerberos authentication, PowerShell remoting doesn’t then pass that credential to the other network resource. In other words, it doesn’t <span epub:type="pagebreak" id="page_103"/>make both hops. For security reasons, PowerShell adheres to Windows restrictions and refuses to delegate those credentials, and as a result, returns an Access Denied message.</p>&#13;
<h4 class="h4" id="ch8lev3sec10">Double Hopping with CredSSP</h4>&#13;
<p class="noindent">In this section, you’ll learn how to work around the double hop problem. I say <em>work around</em> instead of <em>fix</em> for a reason. Microsoft has warned that using CredSSP is a security problem, as the credential passed to the first computer is automatically used for all connections from that computer. This means if the original computer is compromised, that credential can be used from that computer to connect to other computers across the network. Nevertheless, other than using some fancy workarounds, like resource-based Kerberos constrained delegation, many users choose to use the CredSSP approach because it’s easy to use.</p>&#13;
<p class="indent">Before you implement CredSSP, you have to enable it on both the client and the server by using the <span class="literal">Enable-WsManCredSSP</span> command in an elevated PowerShell session. This command has a <span class="literal">Role</span> parameter, which allows you to define whether CredSSP is being enabled on the client or the server side. First, enable CredSSP on the client side, as in <a href="ch08.xhtml#ch8list24">Listing 8-24</a>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>To get CredSSP to work, you may have to relax a local policy. If you receive a permission error when trying to enable CredSSP, be sure you enable the <span class="regular">Allow Delegating Saved Credentials with NTLM-only Server Authentication</span> setting by running gpedit.msc and looking under Computer Configuration <span class="ent">▶</span> Administrative Templates <span class="ent">▶</span> System <span class="ent">▶</span> Credentials Delegation. While in the policy, click on the <strong>Show</strong> button and enter <strong>WSMAN/*</strong> to allow delegation from any endpoint.</em></p>&#13;
</div>&#13;
<pre>PS&gt; <span class="codestrong1">Enable-WSManCredSSP</span> <span class="ent">❶</span><span class="codestrong1">-Role</span> <span class="ent">❷</span><span class="codestrong1">Client</span> <span class="ent">❸</span><span class="codestrong1">-DelegateComputer WEBSRV1 -Force</span>&#13;
&#13;
CredSSP Authentication Configuration for WS-Management&#13;
CredSSP authentication allows the user credentials on this computer to be sent&#13;
to a remote computer. If you use CredSSP authentication for a connection to&#13;
a malicious or compromised computer, that machine will have access to your&#13;
username and password. For more information, see the Enable-WSManCredSSP Help&#13;
topic.&#13;
Do you want to enable CredSSP authentication?&#13;
[Y] Yes  [N] No  [S] Suspend  [?] Help (default is "Y"): <span class="codestrong1">y</span>&#13;
&#13;
&#13;
cfg         : http://schemas.microsoft.com/wbem/wsman/1/config/client/auth&#13;
lang        : en-US&#13;
Basic       : true&#13;
Digest      : true&#13;
Kerberos    : true&#13;
Negotiate   : true&#13;
Certificate : true&#13;
CredSSP     : true</pre>&#13;
<p class="caption" id="ch8list24"><em>Listing 8-24: Enabling CredSSP support on the client computer</em></p>&#13;
<p class="indent">You enable CredSSP on the client by passing the value <span class="literal">Client</span> <span class="ent">❷</span> to the <span class="literal">Role</span> parameter <span class="ent">❶</span>. You also use the required <span class="literal">DelegateComputer</span> parameter <span class="ent">❸</span> here because PowerShell needs to know which computers are allowed to use the credential you’ll be delegating it to. You could pass an asterisk (<span class="literal">*</span>) to <span class="literal">DelegateComputer</span> in order to allow delegation to all computers, but for security purposes, it’s better to just allow the computers you’re working with, in this case, <span class="literal">WEBSRV1</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_104"/>Once CredSSP is enabled on the client, you need to do the same on the server (<a href="ch08.xhtml#ch8list25">Listing 8-25</a>). Luckily, you can just open up a new remote session without using CredSSP, and then enable CredSSP within the session—rather than having to use Microsoft Remote Desktop to access the server or visit it physically.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Invoke-Command -ComputerName WEBSRV1 -ScriptBlock { Enable-WSManCredSSP -Role Server }</span>&#13;
&#13;
CredSSP Authentication Configuration for WS-Management CredSSP authentication allows the server&#13;
to accept user credentials from a remote computer. If you enable CredSSP authentication on the&#13;
server, the server will have access to the username and password of the&#13;
client computer if the client computer sends them. For more information, see the Enable-WSManCredSSP Help topic.&#13;
Do you want to enable CredSSP authentication?&#13;
[Y] Yes  [N] No  [?] Help (default is "Y"): <span class="codestrong1">y</span>&#13;
&#13;
#text&#13;
-----&#13;
False&#13;
True&#13;
True&#13;
False&#13;
True&#13;
Relaxed</pre>&#13;
<p class="caption" id="ch8list25"><em>Listing 8-25: Enabling CredSSP support on the server computer</em></p>&#13;
<p class="indent">With that, you’ve enabled CredSSP on both the client and the server: the client is allowing its user credentials to be delegated to the remote server, and the remote server has CredSSP enabled itself. Now you can try to access remote network resources from that remote session again (see <a href="ch08.xhtml#ch8list26">Listing 8-26</a>). Note that if you ever need to undo enabling CredSSP, the command <span class="literal">Disable-WsmanCredSSP</span> will revert your changes.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Invoke-Command -ComputerName WEBSRV1 -ScriptBlock { Get-ChildItem -Path '\\dc\c$'  }</span> &#13;
<span class="ent">❶</span><span class="codestrong1">-Authentication Credssp</span> <span class="ent">❷</span><span class="codestrong1">-Credential (Get-Credential)</span>&#13;
&#13;
cmdlet Get-Credential at command pipeline position 1&#13;
Supply values for the following parameters:&#13;
Credential&#13;
&#13;
&#13;
    Directory: \\dc\c$&#13;
&#13;
&#13;
Mode                LastWriteTime         Length Name                            PSComputerName&#13;
----                -------------         ------ ----                            --------------&#13;
d-----        10/1/2019  12:05 PM                FileShare                       WEBSRV1&#13;
d-----       11/24/2019   2:28 PM                inetpub                         WEBSRV1&#13;
d-----       11/22/2019   6:37 PM                InstallWindowsFeature           WEBSRV1&#13;
d-----        4/16/2019   1:10 PM                Iperf                           WEBSRV1</pre>&#13;
<p class="caption" id="ch8list26"><em>Listing 8-26: Accessing network resources over a CredSSP-authenticated session</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_105"/>Notice that you have to explicitly tell <span class="literal">Invoke-Command</span> (or <span class="literal">Enter-PSSession)</span> that you’d like to use CredSSP authentication <span class="ent">❶</span>, and both commands—whichever you use—require a credential. You get that credential by using the <span class="literal">Get-Credential</span> command rather than the default Kerberos <span class="ent">❷</span>.</p>&#13;
<p class="indent">After you execute <span class="literal">Invoke-Command</span> and provide <span class="literal">Get-Credential</span> with a username and password with access to the <span class="literal">c$</span> share on DC, you can see the <span class="literal">Get-ChildItem</span> command works as expected!</p>&#13;
<h3 class="h3" id="ch8lev4">Summary</h3>&#13;
<p class="noindent">PowerShell remoting is, by far, the easiest way to remotely execute code on remote systems. As you learned in this chapter, the PowerShell remoting feature is easy to use and intuitive. Once you’ve grasped the concept of a scriptblock and where that code inside of it is being executed, remote scriptblocks will be second nature to you.</p>&#13;
<p class="indent">In <a href="part3.xhtml#part3">Part III</a> of this book—where you will build your own robust PowerShell module—you’ll use PowerShell remoting in nearly every command. If you had trouble following along in this chapter, please go over it again or begin to experiment. Try different scenarios, break things, fix them, do whatever you can to understand PowerShell remoting. It’s one of the most important skills you can learn from this book.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch9">Chapter 9</a> covers another major skill: testing with Pester.<span epub:type="pagebreak" id="page_106"/></p>&#13;
</body></html>