["```\ndef euclidean_dist(x1: float, y1: float, x2: float, y2: float) -> float:\n    return math.sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2)) \n```", "```\ndef greedy_search(g: Graph, h: list, start: int, goal: int) -> list: \n    visited: list = [False] * g.num_nodes\n    last: list = [-1] * g.num_nodes\n    pq: PriorityQueue = PriorityQueue(min_heap=True) ❶ pq.enqueue(start, h[start])\n  ❷ while not pq.is_empty() and not visited[goal]:\n        ind: int = pq.dequeue()\n        current: Node = g.nodes[ind]\n        visited[ind] = True\n\n        for edge in current.get_edge_list():\n            neighbor: int = edge.to_node\n          ❸ if not visited[neighbor] and not pq.in_queue(neighbor):\n                pq.enqueue(neighbor, h[neighbor])\n                last[neighbor] = ind\n\n    return last \n```", "```\nh: list = [5.0, 3.6, 2.24, 4.0, 2.24, 3.16, 0.0] \n```", "```\ndef astar_search(g: Graph, h: list, start: int, goal: int) -> list: \n    visited: list = [False] * g.num_nodes\n    last: list = [-1] * g.num_nodes\n    cost: list = [math.inf] * g.num_nodes\n    pq: PriorityQueue = PriorityQueue(min_heap=True)\n\n  ❶ pq.enqueue(start, h[start])\n    cost[start] = 0.0\n  ❷ while not pq.is_empty() and not visited[goal]:\n        ind: int = pq.dequeue()\n        current: Node = g.nodes[ind]\n        visited[ind] = True\n\n        for edge in current.get_edge_list():\n            neighbor: int = edge.to_node\n          ❸ if cost[neighbor] > cost[ind] + edge.weight:\n                cost[neighbor] = cost[ind] + edge.weight\n                last[neighbor] = ind\n\n              ❹ est_value: float = cost[neighbor] + h[neighbor]\n                if pq.in_queue(neighbor):\n                    pq.update_priority(neighbor, est_value)\n                else:\n                    pq.enqueue(neighbor, est_value)\n    return last \n```", "```\nh: list = [5.0, 3.6, 2.24, 4.0, 2.24, 3.16, 0.0] \n```", "```\ndef pg_generate_heuristic(g: Graph) -> list: \n    heuristic = [0.0] * g.num_nodes\n    for node in g.nodes:\n        state: PGState = node.label\n      ❶ num_left: int = state.guards_left + state.prisoners_left\n      ❷ min_trips_l_to_r: int = math.ceil(num_left / 2.0)\n      ❸ min_trips_r_to_l: int = max(0, min_trips_l_to_r - 1)\n        if not state.boat_side == \"L\" and min_trips_l_to_r > 0:\n            min_trips_r_to_l += 1\n        heuristic[node.index] = min_trips_l_to_r + min_trips_r_to_l\n\n    return heuristic \n```", "```\ng: Graph = create_prisoners_and_guards()\nh: list = pg_generate_heuristic(g)\nlast: list = astar_search(g, h, 0, 14) \n```", "```\nclass World:\n    def __init__(self, g: Graph, start_ind: int, goal_ind: int):\n        self.g = g\n        self.start_ind = start_ind\n        self.goal_ind = goal_ind\n\n    def get_num_states(self) -> int:\n        return self.g.num_nodes def is_goal(self, state: int) -> bool:\n        return state == self.goal_ind\n\n    def get_start_index(self) -> int:\n        return self.start_ind\n\n    def get_neighbors(self, state: int) -> set:\n        return self.g.nodes[state].get_neighbors()\n\n    def get_cost(self, from_state: int, to_state: int) -> float:\n        if not self.g.is_edge(from_state, to_state):\n            return math.inf\n        return self.g.get_edge(from_state, to_state).weight\n\n    def get_heuristic(self, state: int):\n      ❶ pos1 = self.g.nodes[state].label\n        pos2 = self.g.nodes[self.goal_ind].label\n      ❷ return math.sqrt((pos1[0]-pos2[0])**2 + (pos1[1]-pos2[1])**2) \n```", "```\ndef astar_dynamic(w: World): \n    visited: dict = {}\n    last: dict = {}\n    cost: dict = {}\n    pq: PriorityQueue = PriorityQueue(min_heap=True)\n    visited_goal: bool = False\n\n  ❶ start: int = w.get_start_index()\n    visited[start] = False\n    last[start] = -1\n    pq.enqueue(start, w.get_heuristic(start))\n    cost[start] = 0.0\n\n    while not pq.is_empty() and not visited_goal:\n        index: int = pq.dequeue() visited[index] = True\n        visited_goal = w.is_goal(index)\n\n      ❷ for other in w.get_neighbors(index):\n            c: float = w.get_cost(index, other)\n            h: float = w.get_heuristic(other)\n\n          ❸ if other not in visited:\n                visited[other] = False\n                cost[other] = cost[index] + c\n                last[other] = index\n                pq.enqueue(other, cost[other] + h)\n          ❹ elif cost[other] > cost[index] + c:\n                cost[other] = cost[index] + c\n                last[other] = index\n                pq.update_priority(other, cost[other] + h)\n\n    return last \n```", "```\ng.nodes[1].label = [0, 2] \n```"]