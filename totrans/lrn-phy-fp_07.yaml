- en: '6'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HIGHER-ORDER FUNCTIONS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Higher-order functions are central to functional programming and flow naturally
    from the idea that functions should be “first-class objects” in a language, with
    all of the rights and privileges that numbers or lists have. A *higher-order function*
    is one that accepts a function as input and/or returns a function as output. Many
    things we want the computer to do for us find a natural expression as a higher-order
    function.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll first look at higher-order functions that produce functions
    as output. We’ll see that these higher-order functions can be viewed as having
    one input, or alternatively, as having multiple inputs. From there, we’ll consider
    mapping, the idea of applying a function to every element of a list and producing
    a list of the results. We’ll then show how we can use the higher-order function
    `iterate`, another function that takes a function as input, to do our iteration.
    After looking at anonymous higher-order functions and operators, we’ll look at
    predicate-based higher-order functions. Finally, we’ll look in detail at numerical
    integration, a central tool in physics that has a natural expression as a higher-order
    function.
  prefs: []
  type: TYPE_NORMAL
- en: How to Think About Functions with Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider the force of a linear spring with a spring constant *k*. We usually
    write this as
  prefs: []
  type: TYPE_NORMAL
- en: '*F*[spring] = –*kx*'
  prefs: []
  type: TYPE_NORMAL
- en: where the minus sign indicates that the force acts in the direction opposite
    the displacement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we wish to write a Haskell function to give the force in Newtons produced
    by a spring with a spring constant of 5,500 N/m. We could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is a fine function, but it handles only the force produced by a spring
    with a spring constant of 5500 N/m. It would be nicer to have a function that
    could handle a spring with any spring constant.
  prefs: []
  type: TYPE_NORMAL
- en: Note that as usual, we are using the type synonym
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: because we like to think of these numbers as real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Because arrows between types associate to the right, `springForce`’s type, `R
    -> R -> R`, is equivalent to `R -> (R -> R)`, meaning that if we send the `spring`
    `Force` function an `R` (the spring constant), it will return to us a *function*
    with type `R -> R`. This latter function wants an `R` as input (the displacement)
    and will give an `R` as output (the force).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can look at the types of these functions using GHCi’s :type command (abbreviated
    `:t`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s look at the function `springForce 2200`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `springForce 2200` represents the force function (input: displacement,
    output: force) for a spring with a spring constant of 2200 N/m. It has the same
    type and plays the same role as the springForce5500 function above. However, it
    looks funny because it is a function made up of two parts: the springForce part
    and the 2200 part.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, look at the type of `springForce 2200 0.4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is not a function but just a number representing the force exerted by a
    spring with a spring constant of 2200 N/m when extended by a distance of 0.4 m.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function that takes another function as input or returns another function
    as a result is called a higher-order function. The function `springForce` is a
    higher-order function because it returns a function as its result. [Figure 6-1](ch06.xhtml#ch6fig1)
    shows that the `springForce` function takes a number as input (the spring constant
    `k :: R`) and returns a function as output (`springForce k :: R -> R`). The function
    `springForce k` then takes a number as input (the displacement `x :: R`) and returns
    a number as output (the force `springForce k x :: R`).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/071fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-1:* The higher-order function springForce takes a number as input
    and returns the function springForce k as output. The function springForce k then
    takes a number as input and returns a number as output.'
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions give us a convenient way to define a function that takes
    one or more parameters (like the spring constant) in addition to its “actual”
    input (like the displacement). [Table 6-1](ch06.xhtml#ch6tab1) shows some higher-order
    functions from the Prelude that return a function as output.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-1:** Some Higher-Order Functions from the Prelude That Produce a
    Function as Output'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** |  | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `take` | `::` | `Int -> [a] -> [a]` |'
  prefs: []
  type: TYPE_TB
- en: '| `drop` | `::` | `Int -> [a] -> [a]` |'
  prefs: []
  type: TYPE_TB
- en: '| `replicate` | `::` | `Int -> a -> [a]` |'
  prefs: []
  type: TYPE_TB
- en: Consider the higher-order function `take`. The `take` function produces a list
    by taking a given number of elements from a given list. [Table 6-2](ch06.xhtml#ch6tab2)
    shows some examples of its use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-2:** Examples of the Use of take'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** |  | **Evaluates to** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `take 3 [9,7,5,3,17]` | ⇝ | `[9,7,5]` |'
  prefs: []
  type: TYPE_TB
- en: '| `take 3 [3,2]` | ⇝ | `[3,2]` |'
  prefs: []
  type: TYPE_TB
- en: '| `take 4 [1..]` | ⇝ | `[1,2,3,4]` |'
  prefs: []
  type: TYPE_TB
- en: '| `take 4 [-10.0,-9.5..10]` | ⇝ | `[-10.0,-9.5,-9.0,-8.5]` |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s look at the type of `take`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: According to the type of `take`, when given an `Int`, it should return a function
    with type `[a] -> [a]`. What function should `take` return? If we give the integer
    *n* to `take`, the returned function will accept a list as input and return a
    list of the first *n* elements of the input list.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to think about the higher-order function `take` (and others
    like it that return a function as output), as shown in [Table 6-3](ch06.xhtml#ch6tab3).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-3:** Two Ways of Thinking About the Higher-Order Function take'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Way of thinking** | **Input to `take`** | **Output from `take`** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| One-input thinking | `Int` | `[a] -> [a]` |'
  prefs: []
  type: TYPE_TB
- en: '| Two-input thinking | `Int and then [a]` | `[a]` |'
  prefs: []
  type: TYPE_TB
- en: We have already described, with `springForce`, the “one-input thinking” in which
    we read the type signature of `take` as expecting a single `Int` as input and
    producing a `[a] -> [a]` (read “list of `a` to list of `a`”) as output. [Figure
    6-2](ch06.xhtml#ch6fig2) shows the one-input picture of `take`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/072fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-2:* One-input thinking about the higher-order function take'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative way to think about the type signature `Int -> [a] -> [a]` is
    that the function expects two inputs, the first of type `Int` and the second of
    type `[a]`, and produces an output of type `[a]`. [Figure 6-3](ch06.xhtml#ch6fig3)
    shows the two-input picture of `take`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/072fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-3:* Two-input thinking about the higher-order function take'
  prefs: []
  type: TYPE_NORMAL
- en: As readers and writers of higher-order functions, we have a choice in how to
    think about them. Sometimes it is convenient to think of a higher-order function
    as accepting multiple inputs, but it can also be very useful to think of every
    function, higher-order functions included, as accepting exactly one input. The
    Haskell compiler regards every function as having exactly one input.
  prefs: []
  type: TYPE_NORMAL
- en: Like `take`, the higher-order function `drop` is another everyday tool for working
    with lists. The function `drop` produces a list by discarding a given number of
    elements from a given list. [Table 6-4](ch06.xhtml#ch6tab4) shows some examples
    of its use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-4:** Examples of the Use of drop'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** |  | **Evaluates to** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `drop 3 [9,7,5,10,17]` | ⇝ | `[10,17]` |'
  prefs: []
  type: TYPE_TB
- en: '| `drop 3 [4,2]` | ⇝ | `[]` |'
  prefs: []
  type: TYPE_TB
- en: '| `drop 37 [-10.0,-9.5..10]` | ⇝ | `[8.5,9.0,9.5,10.0]` |'
  prefs: []
  type: TYPE_TB
- en: The function `replicate` produces a list by repeating one item a given number
    of times. [Table 6-5](ch06.xhtml#ch6tab5) shows some examples of its use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-5:** Examples of the Use of replicate'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** |  | **Evaluates to** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `replicate 2 False` | ⇝ | `[False,False]` |'
  prefs: []
  type: TYPE_TB
- en: '| `replicate 3 "ho"` | ⇝ | `["ho","ho","ho"]` |'
  prefs: []
  type: TYPE_TB
- en: '| `replicate 4 5` | ⇝ | `[5,5,5,5]` |'
  prefs: []
  type: TYPE_TB
- en: '| `replicate 3 ''x''` | ⇝ | `"xxx"` |'
  prefs: []
  type: TYPE_TB
- en: In this section, we’ve focused on higher-order functions that return functions
    as output. Now let’s take a look at a higher-order function that takes a function
    as input.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping a Function Over a List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Table 6-6](ch06.xhtml#ch6tab6) shows some higher-order Prelude functions that
    take other functions as input.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-6:** Some Higher-Order Functions from the Prelude That Accept a Function
    as Input'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** |  | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `map` | `::` | `(a -> b) -> [a] -> [b]` |'
  prefs: []
  type: TYPE_TB
- en: '| `iterate` | `::` | `(a -> a) -> a -> [a]` |'
  prefs: []
  type: TYPE_TB
- en: '| `flip` | `::` | `(a -> b -> c) -> b -> a -> c` |'
  prefs: []
  type: TYPE_TB
- en: The Prelude function `map` is a nice example of a higher-order function that
    takes another function as input. The function `map` will apply the function you
    give to every element of the list you give. [Table 6-7](ch06.xhtml#ch6tab7) shows
    some examples of the use of `map`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-7:** Examples of the Use of map'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** |  | **Evaluates to** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `map sqrt [1,4,9]` | ⇝ | `[1.0,2.0,3.0]` |'
  prefs: []
  type: TYPE_TB
- en: '| `map length ["Four","score","and"]` | ⇝ | `[4,5,3]` |'
  prefs: []
  type: TYPE_TB
- en: '| `map (logBase 2) [1,64,1024]` | ⇝ | `[0.0,6.0,10.0]` |'
  prefs: []
  type: TYPE_TB
- en: '| `map reverse ["Four","score"]` | ⇝ | `["ruoF","erocs"]` |'
  prefs: []
  type: TYPE_TB
- en: In the first example listed in [Table 6-7](ch06.xhtml#ch6tab7), we say that
    the function `sqrt` gets “mapped” over the list, meaning that it gets applied
    to each element of the list.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the parentheses around the function type `a -> b` in the type signature
    for `map` are essential. The type `a -> b -> [a] -> [b]`, in which no parentheses
    appear, is an entirely different type. This latter type would take as input a
    value of type `a`, a value of type `b`, and a list of type `[a]` and produce a
    list of type `[b]` as output. This latter type is short for `a -> (b -> ([a] ->
    [b]))` because arrows associate to the right.
  prefs: []
  type: TYPE_NORMAL
- en: A list comprehension can do the work of `map`. Whether you choose `map` or a
    list comprehension is a matter of style.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The idea of mapping a function over a structure actually extends past the structure
    of a list to other structures like trees. Haskell has a function `fmap` for this,
    although we will not have occasion to use it in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration and Recursion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Iteration is an essential feature in any programming language. The ability to
    do things over and over again is one of the chief sources of power that computers
    have. How do people express the idea of iteration in a programming language?
  prefs: []
  type: TYPE_NORMAL
- en: Imperative programming languages provide ways to write *loops*, which are instructions
    to do something over and over, either a fixed number of times or until some condition
    is reached.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming languages have a different way to express iteration.
    The most popular way to achieve iteration among functional programmers is to write
    *recursive functions*, that is, functions that call themselves. Recursive functions
    are very powerful, but it takes a person approaching recursive functions for the
    first time some time and effort to comprehend how to write them.
  prefs: []
  type: TYPE_NORMAL
- en: The Haskell Prelude has many built-in recursive functions that we can use without
    needing to write our own explicitly. In this book, we’ll avoid writing *explicitly*
    recursive functions, meaning that you can see from the function definition that
    the function calls itself. We will write functions using the built-in recursive
    functions from the Prelude, and these functions that we write may legitimately
    be called recursive because their behavior is recursive in that something is calling
    itself under the hood. However, the functions we write are not *explicitly* recursive
    because they will not call themselves.
  prefs: []
  type: TYPE_NORMAL
- en: We can understand and explain most of the recursive functions in the Prelude
    by their behavior through examples without needing to understand how they achieve
    this behavior through the power of recursion. Recursion is certainly very interesting,
    and I encourage you to look into it if you have the time. I learned recursion
    from *The Little Schemer* [**[4](bib.xhtml#bib4)**], a book using the Scheme language
    that I enthusiastically recommend. The book *Learn You a Haskell for Great Good!*
    [**[1](bib.xhtml#bib1)**], deals with recursion in its [Chapter 4](ch04.xhtml),
    showing how to write Prelude functions like `take`, `reverse`, `replicate`, and
    `repeat`.
  prefs: []
  type: TYPE_NORMAL
- en: How will we achieve iteration in Haskell without writing explicitly recursive
    functions? We’ll use the Prelude function `iterate`. Rather than thinking imperatively
    about what we want the computer to *do*, we will think functionally about what
    we want to *have* and arrange to have these things in a list. “Lists instead of
    loops” is the functional programming slogan we might apply here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Prelude function `iterate`, whose type is given in [Table 6-6](ch06.xhtml#ch6tab6),
    is a higher-order function that takes a function as input. Iteration and the `iterate`
    function will be important when we solve Newton’s second law in [Part II](part02.xhtml).
    The function `iterate` produces an infinite list as follows: if `f :: a -> a`
    and `x :: a` (read “`f` has type `a` to `a`” and “`x` has type `a`”), then `iterate
    f x` produces this infinite list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In other words, the result is a list with `f` applied zero times, once, twice,
    three times, and so on. [Table 6-8](ch06.xhtml#ch6tab8) shows some examples of
    the use of `iterate`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-8:** Examples of the Use of iterate'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** |  | **Evaluates to** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `iterate (\n -> 2*n) 1` | ⇝ | `[1,2,4,8,...]` |'
  prefs: []
  type: TYPE_TB
- en: '| `iterate (\n -> n*n) 1` | ⇝ | `[1,1,1,1,...]` |'
  prefs: []
  type: TYPE_TB
- en: '| `iterate (\n -> n*n) 2` | ⇝ | `[2,4,16,256,...]` |'
  prefs: []
  type: TYPE_TB
- en: '| `iterate (\v -> v - 9.8*0.1) 4` | ⇝ | `[4.0,3.02,2.04,1.06,...]` |'
  prefs: []
  type: TYPE_TB
- en: '[Figure 6-4](ch06.xhtml#ch6fig4) shows how iterate f applies the function f
    to its input zero times, one time, two times, and so on, and collects the results
    in a list.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/076fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-4: The function iterate f applies the function f to the input zero,
    one, two, three, and more times and collects the results in an infinite list.*'
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Higher-Order Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.xhtml), we discussed anonymous functions as a way to describe
    a function without giving it a name. We can do the same thing for higher-order
    functions, describing them without giving them a name.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s return to the function `springForce` discussed earlier. How could we write
    `springForce` without naming it? There are actually two ways to write this function
    as an anonymous function, corresponding to the one-input thinking and two-input
    thinking we described in “How to Think About Functions with Parameters.” In one-input
    thinking, we regard the input to `springForce` as being a number (`R`) and the
    output as being a function `R -> R`. The anonymous function for one-input thinking
    is shown in the first row of [Table 6-9](ch06.xhtml#ch6tab9). We can see from
    the form of that function that it returns a function, namely `\x -> -k*x`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-9:** Two Ways of Writing the springForce Function as an Anonymous
    Function'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Way of thinking** | **Anonymous function** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| One-input thinking | `\k -> \x -> -k*x` |'
  prefs: []
  type: TYPE_TB
- en: '| Two-input thinking | `\k x -> -k*x` |'
  prefs: []
  type: TYPE_TB
- en: In two-input thinking, we regard the inputs to `springForce` as an `R` for the
    spring constant and a second `R` for the position and the output as being simply
    an `R`. The anonymous function for two-input thinking is shown in the second row
    of [Table 6-9](ch06.xhtml#ch6tab9). The form of the anonymous function shows us
    that it returns a number. Either form is completely legitimate. In fact, the two
    forms describe the same function.
  prefs: []
  type: TYPE_NORMAL
- en: Operators as Higher-Order Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.xhtml), we introduced several infix operators in [Table
    1-2](ch01.xhtml#ch1tab2). Any infix operator can be converted into a higher-order
    function by enclosing it in parentheses. [Table 6-10](ch06.xhtml#ch6tab10) shows
    examples of how infix operators may be written as higher-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-10:** Infix Operators Transformed into Prefix Functions by Enclosing
    in Parentheses'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Infix expression** | **Equivalent prefix expression** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `f . g` | `(.) f g` |'
  prefs: []
  type: TYPE_TB
- en: '| `''A'':"moral"` | `(:) ''A'' "moral"` |'
  prefs: []
  type: TYPE_TB
- en: '| `[3,9] ++ [6,7]` | `(++) [3,9] [6,7]` |'
  prefs: []
  type: TYPE_TB
- en: '| `True && False` | `(&&) True False` |'
  prefs: []
  type: TYPE_TB
- en: '| `log . sqrt $ 10` | `($) (log . sqrt) 10` |'
  prefs: []
  type: TYPE_TB
- en: '[Table 6-11](ch06.xhtml#ch6tab11) shows the types of some higher-order functions
    obtained from operators. If you want to ask GHCi for the type of an operator,
    you must enclose the operator in parentheses when using the GHCi `:t` command.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-11:** Infix Operators Viewed as Higher-Order Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** |  | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `(.)` | `::` | `(b -> c) -> (a -> b) -> a -> c` |'
  prefs: []
  type: TYPE_TB
- en: '| `(:)` | `::` | `a -> [a] -> [a]` |'
  prefs: []
  type: TYPE_TB
- en: '| `(++)` | `::` | `[a] -> [a] -> [a]` |'
  prefs: []
  type: TYPE_TB
- en: '| `(&&)` | `::` | `Bool -> Bool -> Bool` |'
  prefs: []
  type: TYPE_TB
- en: '| `(&#124;&#124;)` | `::` | `Bool -> Bool -> Bool` |'
  prefs: []
  type: TYPE_TB
- en: '| `($)` | `::` | `(a -> b) -> a -> b` |'
  prefs: []
  type: TYPE_TB
- en: In [Chapter 5](ch05.xhtml), we discussed a type error that occurred when trying
    to concatenate lists with different types. Now that we know the type of `(++)`,
    we are in a better position to understand type errors more generally. A type error
    comes from trying to apply a function that expects input of one type to an expression
    that actually has a different type. When we apply the concatenation function `(++)`
    to the expression `physicists`,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'we obtain a function `(++) physicists`, which has type `[String] -> [String]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The concatenation function accepts a list of any type `a`. When given a list
    of strings, the concrete type `String` is substituted for all occurrences of the
    type variable `a` so that the function `(++) physicists` has type `[String] ->
    [String]`. This function `(++) physicists` expects an input with type `[String]`,
    so if we give it something with a different type instead, we get a type error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In GHCi, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The “Expected type” `[String]` is the type expected as input by the function
    `(++) physicists`, while the “Actual type” `[R]` is the type of the list `velocities`.
  prefs: []
  type: TYPE_NORMAL
- en: A class of functions and operators known as *combinators* that can be thought
    of as standard connectors can make it easier to use higher-order functions. We
    turn to these next.
  prefs: []
  type: TYPE_NORMAL
- en: Combinators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Combinators, in the broad sense of the term, are functions that combine things.
    They are often functions that have very general applicability, and their types
    show this by being full of type variables. They tend not to be specific to numbers,
    lists, Booleans, or any particular basic type. They are standard plumbing fixtures
    that make it easier to work with and connect higher-order functions. [Table 6-12](ch06.xhtml#ch6tab12)
    gives a short list of Haskell functions that are considered to be combinators.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-12:** Some Haskell Functions Regarded as Combinators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** |  | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `id` | `::` | `a -> a` |'
  prefs: []
  type: TYPE_TB
- en: '| `const` | `::` | `a -> b -> a` |'
  prefs: []
  type: TYPE_TB
- en: '| `flip` | `::` | `(a -> b -> c) -> b -> a -> c` |'
  prefs: []
  type: TYPE_TB
- en: '| `(.)` | `::` | `(b -> c) -> (a -> b) -> a -> c` |'
  prefs: []
  type: TYPE_TB
- en: '| `($)` | `::` | `(a -> b) -> a -> b` |'
  prefs: []
  type: TYPE_TB
- en: The identity function `id` seems at first to be a silly function, because when
    I apply it to some value, I get that same value back. So what purpose does the
    identity function serve? The relevance of the identity function, like the anonymous
    functions we studied in [Chapter 2](ch02.xhtml), lies in its use as an input to
    a higher-order function. In [Chapter 22](ch22.xhtml), we will write a higher-order
    function to display vector fields. One of the inputs to this function will be
    a scaling function that accepts one number and returns another. The most trivial
    scaling is achieved by using the identity function, which leaves every input unchanged.
    The higher-order function requires *some* scaling function to be given, and the
    identity function `id` can be given when no scaling is desired.
  prefs: []
  type: TYPE_NORMAL
- en: The combinator `const` turns a value into a constant function that returns that
    value. For example, `const 3` is the function that returns `3` regardless of its
    input. So, `const 3 7` evaluates to `3`, `const 3 5` evaluates to `3`, and `const
    3 "Hi"` evaluates to `3`. In [Chapter 14](ch14.xhtml), we will write a function
    to solve mechanics problems that takes a list of forces as input. The forces are
    functions that depend on inputs like velocity, so if we want to specify a constant
    force, we can use the `const` combinator. In [Chapter 23](ch23.xhtml), we will
    write surfaces like hemispheres and spheres. Our surfaces will be specified with
    two parameters that take values over some range. The limits for the parameters
    are allowed to be functions, so we can write, for example, a triangular surface.
    If we want a constant function, again we can use `const`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flip` combinator takes a higher-order function and exchanges the positions
    of its inputs. It is often used in conjunction with point-free style. For example,
    the exponentiation function `(**)` takes two inputs: the base and the exponent.
    If we provide the first input but not the second, as in `(**) 2`, we get the “two
    to the power of” function. What if we want the function that cubes its input?
    We would need to fix the second input of `(**)` at `3` while leaving the first
    open to be the input to the cubing function. We could do this with an anonymous
    function, as `\x -> x ** 3`. We could also do it with flip, as `flip (**) 3`.
    Either of these is an expression for the cubing function.'
  prefs: []
  type: TYPE_NORMAL
- en: The composition combinator was listed in [Table 1-2](ch01.xhtml#ch1tab2) and
    discussed in [Chapter 2](ch02.xhtml). We will use it in [Chapter 16](ch16.xhtml)
    when we solve mechanics problems by passing information through a sequence of
    functions. The full solution is given as a composition of the functions in the
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The function application combinator was listed in [Table 1-2](ch01.xhtml#ch1tab2)
    and discussed in [Chapter 1](ch01.xhtml) . It seems like a silly and useless operator
    until we realize that its precedence allows it to act like parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: The next section discusses a class of higher-order functions used to classify
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Predicate-Based Higher-Order Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *predicate* is a function with type `a -> Bool`, where `a` is any valid Haskell
    type. (For example, `a` could be a concrete type like `Int` or `R -> R`, a type
    variable like `a`, or a type that contains type variables like `[a]` or even `a
    -> [b]`.) A predicate expresses a property that an element of type `a` may or
    may not have. For example, the property of an integer being greater than or equal
    to 7 is a predicate. We can define such a predicate in Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 6-13](ch06.xhtml#ch6tab13) shows a few higher-order functions that take
    a predicate as the first argument.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-13:** Some Predicate-Based Higher-Order Functions from the Prelude'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** |  | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `filter` | `::` | `(a -> Bool) -> [a] -> [a]` |'
  prefs: []
  type: TYPE_TB
- en: '| `takeWhile` | `::` | `(a -> Bool) -> [a] -> [a]` |'
  prefs: []
  type: TYPE_TB
- en: '| `dropWhile` | `::` | `(a -> Bool) -> [a] -> [a]` |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s examine the use of these functions. Suppose we define the following “less
    than 10” predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 6-14](ch06.xhtml#ch6tab14) shows examples of how to use the higher-order
    functions in [Table 6-13](ch06.xhtml#ch6tab13).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-14:** Examples of the Use of Some Predicate-Based Higher-Order Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** |  | **Evaluates to** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `filter lt10 [6,4,8,13,7]` | ⇝ | `[6,4,8,7]` |'
  prefs: []
  type: TYPE_TB
- en: '| `takeWhile lt10 [6,4,8,13,7]` | ⇝ | `[6,4,8]` |'
  prefs: []
  type: TYPE_TB
- en: '| `dropWhile lt10 [6,4,8,13,7]` | ⇝ | `[13,7]` |'
  prefs: []
  type: TYPE_TB
- en: '| `any lt10 [6,4,8,13,7]` | ⇝ | `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `all lt10 [6,4,8,13,7]` | ⇝ | `False` |'
  prefs: []
  type: TYPE_TB
- en: Let’s go through the functions in this table. The `filter` function returns
    all elements in a list that satisfy the predicate, regardless of where they occur
    in the list. The `takeWhile` function returns elements of a list that satisfy
    the predicate *until* it finds one that fails to satisfy the predicate, and it
    returns the initial list of satisfying elements. Elements in the input list that
    occur after the first non-satisfying element are not even considered for inclusion
    in the result list. The `dropWhile` function returns a list that begins with the
    first non-satisfying element of the input list and includes every element from
    that point on, regardless of whether it satisfies the predicate. The `any` function
    returns `True` if one or more elements of the input list satisfy the predicate
    and returns `False` otherwise. The `all` function returns `True` if all elements
    of the input list satisfy the predicate, and it returns `False` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: A list comprehension can also do the work of `filter`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To filter a list using a list comprehension, include a Boolean expression (`x
    < 10` in the example above) after a comma on the right side of the list comprehension.
    Such an expression is called a *guard*. Only terms that satisfy the Boolean guard
    will be included in the resulting list.
  prefs: []
  type: TYPE_NORMAL
- en: Numerical Integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Acceleration is the rate at which velocity changes. If we know how velocity
    depends on time, we can use a derivative to find acceleration, as we did in [Chapter
    4](ch04.xhtml). What about the converse problem? What if we know how acceleration
    depends on time and we want to know velocity? This is the purpose of integration
    in calculus. Integrating is the opposite of differentiating (or taking the derivative);
    this claim is the content of the fundamental theorem of calculus.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Integrators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If *a*(*t*) is the acceleration of an object at time *t*, the velocity *v*(*t*)
    of the object can be found by integrating
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/081equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *v*(0) is the velocity of the object at time 0.
  prefs: []
  type: TYPE_NORMAL
- en: If we are integrating and the variable of integration is time, we can imagine
    a device that takes as input the value of acceleration at time *t* and produces
    as output the value of velocity at time *t*. Let’s call such a device an *integrator*,
    and we can picture it as in [Figure 6-5](ch06.xhtml#ch6fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/081fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-5: An integrator is continuous and stateful. The continuously changing
    output at the right depends on the continuously changing input at the left in
    addition to some stored state.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input to the integrator describes the rate at which the output is to change.
    For example, the input could be the volume flow rate of water from a faucet into
    a tub in gallons per minute. The output is the volume of water in the tub in gallons.
    Or the input could be the current flowing into a capacitor, and the output the
    charge on a capacitor plate. The current flowing into the capacitor describes
    the rate at which charge is deposited on the capacitor plate. [Table 6-15](ch06.xhtml#ch6tab15)
    shows some physical quantities related by integration.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-15:** Physical Quantities Related by Integration'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Input to integrator** | **Output of integrator** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration | Velocity |'
  prefs: []
  type: TYPE_TB
- en: '| Velocity | Position |'
  prefs: []
  type: TYPE_TB
- en: '| Flow rate | Volume |'
  prefs: []
  type: TYPE_TB
- en: '| Capacitor current | Capacitor charge |'
  prefs: []
  type: TYPE_TB
- en: The integrator is continuous and stateful. By *continuous*, I mean that the
    input is ever-present and the output is continuously changing. *Stateful* means
    that the integrator must maintain some internal information; that is, the output
    is not a pure function of the input. For the integrator to output the volume of
    water in the tub from the flow rate, it needs to maintain a value of the volume
    that will be updated by the flow rate. Similarly, for the integrator to output
    the charge on the capacitor from the current, it needs to maintain a value of
    the charge that will be updated by the input current.
  prefs: []
  type: TYPE_NORMAL
- en: Digital Integration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’d like to be able to teach Haskell how to integrate. Unfortunately, while
    nature supplies us with many good candidates for integrators, digital computation
    does not. The integrator is an analog continuous device. To model the integrator,
    we switch from continuous to discrete and work in time steps that are smaller
    than any time scales of interest in our problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-6](ch06.xhtml#ch6fig6) shows how we can model an integrator.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/082fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-6: Model of an integrator that is discrete and stateful*'
  prefs: []
  type: TYPE_NORMAL
- en: The model is intended to be used in a discrete way. At instants of time separated
    by Δ*t*, we sample the input, multiply it by Δ*t*, and then add it to the current
    value of the output to produce a new output. If Δ*t* is small compared with time
    scales on which the input changes, this discrete model will emulate the continuous
    integrator very well.
  prefs: []
  type: TYPE_NORMAL
- en: The model in [Figure 6-6](ch06.xhtml#ch6fig6) forms the basis for a method of
    numerical integration. To integrate a function, choose a small time step Δ*t*,
    sample the values the function produces at discrete times, multiply each function
    output by Δ*t*, and sum the results.
  prefs: []
  type: TYPE_NORMAL
- en: If we unwrap the stateful integrator in [Figure 6-6](ch06.xhtml#ch6fig6), we
    obtain the state-free integrator in [Figure 6-7](ch06.xhtml#ch6fig7), which is
    shown for the case in which we are integrating acceleration to obtain velocity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/083fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-7: A functional model of an integrator that is discrete and state
    free. This integrator uses the midpoint rule.*'
  prefs: []
  type: TYPE_NORMAL
- en: All of the rectangles are purely functional operations (addition and multiplication);
    the state contained in the circular integrator now exists only in the wires between
    pure functions. To approximate the velocity at time Δ*t*, we sample the acceleration
    at time Δ*t*/2, multiply it by Δ*t*, and add that to the velocity at time 0\.
    Sampling at Δ*t*/2 is called the *midpoint rule* for numerical integration. If
    Δ*t* is small compared with the important time scales for the situation, we will
    get a good approximation from this method. [Figure 6-7](ch06.xhtml#ch6fig7) shows
    four samples of the acceleration function; usually we will ask the computer to
    do many more.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we would like to be able to do is to give the computer a function *f*,
    give the computer limits *a* and *b*, and ask it to compute the number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/083equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Viewed in this way, `Integration` is a function that takes a function `R ->
    R` as input, along with two limits, and gives a number as output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Integration is often thought of as finding the area under the curve. The midpoint
    rule for numerical integration samples the function at the midpoint of each interval
    of the independent variable, as shown in [Figure 6-8](ch06.xhtml#ch6fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/084equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-8: Numerical integration using the midpoint rule,* Δ*t = 0.5*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the Haskell code for a numerical integrator that uses the midpoint
    rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first argument to the function is a step size to use for the numerical integration.
    We have been speaking as though the independent variable is time, but in mathematics
    it could be anything. The second argument to `integral` is the function to be
    integrated. Note how we use a single identifier (`f`) to name the function that
    the user of `integral` passes in. Also, we don’t need to define the function `f`;
    what we are doing here is *naming* the function that the user of `integral` is
    sending in.
  prefs: []
  type: TYPE_NORMAL
- en: We use an arithmetic sequence to specify the times at which we want to sample
    the function. We use a list comprehension to give back a list of the same size
    that contains the products of the values the function returns with the step size.
    These products are the areas of the rectangles in [Figure 6-8](ch06.xhtml#ch6fig8).
    All that remains is to add up these areas with the `sum` function.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s test out our integral function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we use an anonymous function to specify the function that squares its
    input because it’s easier than writing a function definition to name that function.
    In [Chapter 2](ch02.xhtml), we mentioned that anonymous functions would be useful
    as inputs to higher-order functions, and now we see an example of that. The exact
    value of this definite integral is 1/3, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/085equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing Antiderivatives
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The type synonym `Integration` corresponds to the idea of a definite integral,
    where one has a function and two limits and expects to get a number as output,
    as in Expression 6.2\. However, there is a second way of thinking about integration
    in which one integrates a function to obtain another function. In Equation 6.1,
    for example, we integrate an acceleration function to obtain a velocity function.
  prefs: []
  type: TYPE_NORMAL
- en: In calculus, a distinction is often made between a definite integral on one
    hand and an indefinite integral, or *antiderivative*, on the other. The antiderivative
    wants to be the inverse function to the derivative, but there is a catch, because
    functions like `sin` and `\x -> sin x + 7` have the same derivative, namely `cos`.
    Thus, the derivative, as a higher-order function from functions to functions,
    does not have a well-defined inverse function. An antiderivative of a function
    *f* is any function *F* whose derivative is *f* . In other words, *F* is an antiderivative
    of *f* exactly when *DF* = *f*. If *F* is an antiderivative of *f*, we write
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/085equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: using the indefinite integral symbol without limits and the constant of integration
    *C*. For example, we write
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/085equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *C* is an undetermined constant of integration. There is a relationship
    between a definite integral and an indefinite integral. The fundamental theorem
    of calculus claims that if *F* is any antiderivative of *f*, then
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/085equ04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Renaming variables and rearranging terms, we obtain an expression that allows
    us to relate the constant of integration to an initial value of *F*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/085equ05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For any real number *a*, an antiderivative *F* is a function whose value *F*(*x*)
    at *x* is the sum of its “initial” value *F*(*a*) at *a* and the definite integral
    of *f* from *a* to *x*. If we associate the indefinite integral *∫ f* (*x*)*dx*
    of Equation 6.3 with the definite integral ![Image](Images/e0085-06.jpg) of Equation
    6.4, we can associate the initial value *F*(*a*) in Equation 6.4 with – *C*, where
    *C* is the constant of integration in Equation 6.3\. In this sense, constants
    of integration are related to initial values.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical function has many functions that can serve as its antiderivative.
    How can we select one function in particular? There are two ways: we can specify
    a lower limit or we can specify an initial value. Specifying a lower limit corresponds
    to the definite integral `Integration` that we explored earlier. Specifying an
    initial value leads to the `AntiDerivative` we explore below.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s call an antiderivative a function that takes an initial value (such as
    *v*(0) in Equation 6.1) and a function (such as *a*) and returns a function (such
    as *v*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The idea of the antiderivative is closely related to the idea of the integral.
    We can define a function `antiDerivative` in terms of the `integral` we have already
    defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[Chapter 4](ch04.xhtml) showed how to implement Equations 4.5 and 4.12 as the
    functions `velFromPos` and `accFromVel`. Now let’s implement Equation 6.1 in Haskell.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We see that finding a velocity function from an acceleration function is nothing
    other than the antiderivative.
  prefs: []
  type: TYPE_NORMAL
- en: How about finding a position function from a velocity function?
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/086equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In Haskell, this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Again, nothing but the antiderivative. Here we use point-free style to show
    an alternative way of writing the function and to emphasize the equality of the
    two functions. The functions `velFromAcc` and `posFromVel` from earlier are the
    same, and each is the same as `antiDerivative`. Both integrate a given function
    from 0 to *t* and add on an initial value.
  prefs: []
  type: TYPE_NORMAL
- en: Type synonyms show that time, velocity, and acceleration are all treated as
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Perhaps you’d rather provide your numerical integrator with the number of steps
    to take from the lower limit to the upper limit rather than the step size. This
    is not hard to do.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `let` keyword introduces local variables and/or functions that can be used
    in the body after the `in` keyword. The variable dt is a local variable defined
    inside the function `integralN`. This dt is not visible outside of the definition
    of integralN. Any dt we use outside of this function has an independent meaning
    separate from this. Local variables are particularly useful to define if they
    are used more than once in the remainder of the definition. In this case, we use
    `dt` only once, so we could have inserted the definition of `dt` directly in the
    final line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Using the local variable `dt` saves us a set of parentheses and makes the code
    easier to read because the name `dt` has meaning to us as a step size. I encourage
    you to define local variables with `let` whenever you can think of a name that
    has meaning. It will help readers of the code, including the writer.
  prefs: []
  type: TYPE_NORMAL
- en: The division operator (`/`) can be used only between numbers of the same type.
    Since `b - a` has type `R` and `n` has type `Int`, we can’t directly divide one
    by the other. The solution is to transform `n` into something with type `R`, and
    `fromIntegral` does the trick.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A higher-order function takes another function as input and/or produces a function
    as output. Higher-order functions that produce functions as output can be thought
    of as taking multiple inputs. Numerical integration is a key example of a higher-order
    function that takes a function as input. The lambda notation for writing anonymous
    functions can be used for higher-order functions as well. Mapping a function over
    a list is an example of a higher-order function that takes another function as
    input and is similar to a list comprehension. We can make binary infix operators
    into higher-order functions by enclosing them in parentheses. Haskell can achieve
    iteration via the higher-order function `iterate`, which takes a function and
    a starting value and repeatedly applies the function to form an infinite list.
    Some higher-order functions, such as `filter`, take a predicate as input. We can
    also achieve filtering through list comprehensions. In the next chapter, we introduce
    a library that allows us to plot functions.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 6.1.** Let us return to the example of throwing a rock straight
    upward. Perhaps we don’t want to throw it upward at 30 m/s but would like to be
    able to throw it upward with whatever initial velocity we choose. Write a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: that takes as input an initial velocity and returns as output a function that
    takes as input a time and returns as output a height. Also, write a function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: that takes as input an initial velocity and returns as output a function that
    takes as input a time and returns as output a velocity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 6.2.** Give the type of `take 4`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 6.3.** The function `map` has type `(a -> b) -> [a] -> [b]`. This
    means that `map` is expecting a function with type `a -> b` as its first argument.
    The function `not` has type `Bool -> Bool`. Can `not` be the first argument to
    `map`? If so, what is the type of `map not`? Show how, starting from the types
    of `map` and `not`, you can figure out the type of `map not`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 6.4.** Write a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'that does the same thing as `greaterThanOrEq7` but doesn’t use an `if-then-else`
    construction. (Hint: look at the function `lt10`.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 6.5.** Write a function with type `Int -> String -> Bool` and describe
    in words what it does.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 6.6.** Write a predicate expressing the property “has more than
    six elements” that takes a list as input. Include a type signature with your predicate
    definition.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 6.7.** [Table 6-5](ch06.xhtml#ch6tab5) gives examples of the use
    of the `replicate` function. In the first three examples, a list is created with
    the requested length of the requested item. In the last case, a string is created.
    This seems different. Explain what is going on here.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 6.8.** Make a list of the first 1,000 squares. Don’t print the list;
    just print your definition. You could print the first 10 squares to see if your
    method is working.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 6.9.** Use `iterate` to define a function `repeat''` that does the
    same thing as the Prelude function `repeat`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 6.10.** Use `take` and `repeat` to define a function `replicate''`
    that does the same thing as the Prelude function `replicate`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 6.11.** A car starts from rest and accelerates at 5 m/s² on a straight,
    level highway. Use `iterate` to make an infinite list of velocities for this car,
    with one velocity every second. (The list should look like [0,5,10,15,...]. Use
    the `take` function to see the first several elements of your infinite list.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 6.12.** List comprehensions can be used as an alternative to the
    `map` function. To prove this, write a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: that does the same thing as `map`. Use a list comprehension to write your definition.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 6.13.** List comprehensions can be used as an alternative to the
    `filter` function. To prove this, write a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: that does the same thing as `filter`. Use a list comprehension to write your
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 6.14.** Write a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: that finds the average of a list of numbers. You can assume the list has at
    least one number. You may want to use the `fromIntegral` function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 6.15.** Produce one-input and two-input pictures, similar to [Figures
    6-2](ch06.xhtml#ch6fig2) and [6-3](ch06.xhtml#ch6fig3), for the higher-order function
    `drop`. Do the same thing for the higher-order function `replicate`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 6.16.** An alternative rule to the midpoint rule for numerical integration
    is the trapezoidal rule. In the trapezoidal rule, we approximate the area under
    a curve by the sum of the areas of a bunch of trapezoids, as shown in [Figure
    6-9](ch06.xhtml#ch6fig9).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/090fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-9: The trapezoidal rule*'
  prefs: []
  type: TYPE_NORMAL
- en: For the example, in [Figure 6-9](ch06.xhtml#ch6fig9), the area of the first
    trapezoid is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/090equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and the area of all four trapezoids in the figure is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/090equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Write a definition for the function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'that takes a number of trapezoids, a function, and two limits as its arguments
    and gives back (an approximation to) the definite integral, using the trapezoidal
    rule. Test your integrator on the following integrals and see how close you can
    get to the correct values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/090equ03.jpg)'
  prefs: []
  type: TYPE_IMG
