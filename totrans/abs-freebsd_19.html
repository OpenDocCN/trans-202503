<html><head></head><body>
<h2 class="h2" id="ch19"><span epub:type="pagebreak" id="page_451"/><strong><span class="big">19</span><br/>ADVANCED SECURITY FEATURES</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">FreeBSD includes a variety of tools for securing network traffic and users. Some of these tools are invisible to sysadmins but work behind the scenes to increase security, such as the sandboxing API capsicum(4). Packet filtering lets you control who can access your system. You can also use blacklisting to block network addresses that keep poking at your host. In addition, FreeBSD has a whole bunch of optional security features you can enable either in the installation process or later. In this chapter, we’ll examine these tools and techniques, look at monitoring your system’s security, and discuss how to react if you suffer an intrusion.</p>
<p class="indent">Let’s start with a core security topic: unprivileged users.</p>
<h3 class="h3" id="lev814"><span epub:type="pagebreak" id="page_452"/><strong>Unprivileged Users</strong></h3>
<p class="noindent">An <em>unprivileged user</em> is a specific user for a specific task. He has only the rights necessary to perform that limited task. Many programs run as unprivileged users or use unprivileged users to perform specific duties.</p>
<p class="indent">“Only the rights needed to perform its duties” sounds like every user account, doesn’t it? That’s true, but the account used by the least privileged human being still has more rights than many programs need. Anyone with shell access has a home directory. The normal user may create files in their home directory, run text editors, or process email. Your average shell user needs these minimal privileges, but programs do not. By having a program, particularly a network daemon, run as a very restricted user, you control the amount of damage an intruder can do to either the program or the user.</p>
<p class="indent">FreeBSD includes several unprivileged users. Take a look at <em>/etc/passwd</em> and you’ll see accounts like <em>audit</em>, <em>bind</em>, <em>uucp</em>, and <em>www</em>. These are all unprivileged accounts for use by specific server daemons. See what they have in common.</p>
<p class="indent">Unprivileged users don’t have normal home directories. Many have a home directory of <em>/nonexistent</em>, while others, such as <em>sshd</em>, have a special home directory such as <em>/var/empty</em>. Having a home directory where you may not write or read files makes the account less flexible but good enough for a server daemon. These users do own files on the system, but they usually can’t write to those files.</p>
<p class="indent">Similarly, nobody should ever log into these accounts. If the account <em>bind</em> is reserved for the DNS system, nobody should actually log into the system as that user! Such an account must have a user shell that specifically denies logging in, like <em>/usr/sbin/nologin</em>. How does all this enhance system security? Let’s look at an example.</p>
<p class="indent">Whatever web server you’re using, it generally runs under the unprivileged account <em>www</em>. Suppose that an intruder discovered a security flaw in the version of the web server program you’re using and can make the web server execute arbitrary code. This is among the worst types of security problems, where an intruder can make the server program do absolutely anything within its power. What <em>is</em> within this program’s power?</p>
<p class="indent">The intruder probably wants a command prompt on the system. A command prompt on a Unix-like system is the door to so much more access, after all. The unprivileged user has an assigned shell that specifically disallows logins. This really annoys intruders and requires them to work much harder to reach that command prompt.</p>
<p class="indent">If she’s really clever, though, the nologin shell won’t stop the intruder. Let’s assume that through clever trickery she makes the web server execute a simple shell, such as <em>/bin/sh</em>, and offer her the prompt. She’s in and can wreak untold damage . . . or can she?</p>
<p class="indent">She has no home directory and doesn’t have permissions to create one. That means that any files she wants to store must go in a globally accessible directory, such as <em>/tmp</em> or <em>/var/tmp</em>, increasing her visibility. The Apache configuration file is owned by root or by your web server administration group, and the <em>www</em> user isn’t part of that group. The intruder might have a path <span epub:type="pagebreak" id="page_453"/>into the web server, but she can’t reconfigure it. She can’t change the website files, as the <em>www</em> user doesn’t own them. The <em>www</em> user doesn’t have access to anything on the system except the web server itself. A sufficiently skilled intruder can make the web server serve up different pages or redirect to another site, at least until a reboot. Penetrating the application running on the server, or the host itself, requires another whole set of security breaches.</p>
<p class="indent">An unprivileged user doesn’t solve all security problems, mind you. Our compromised <em>www</em> user can view web application source files. If your application is badly written or has database passwords hardcoded into hidden files, you’re still in a lot of trouble. Still, if you’ve kept your system updated and all your packages up-to-date, an intruder will have a very hard time penetrating FreeBSD itself.</p>
<h4 class="h4" id="lev815"><strong><em>The nobody Account</em></strong></h4>
<p class="noindent">For years, system administrators used the account <em>nobody</em> as a generic unprivileged user. They’d run web servers, proxy servers, and whatever else as <em>nobody</em>. This was better than running those programs as root, but not as good as having separate users for each daemon. If an intruder successfully penetrated one of these programs, he had access to them all. Our hypothetical web server intruder would abruptly have access not only to the web server but also to whatever other programs run as that same user! If you’re using NFS, remember that NFS defaults to mapping remote root accounts to <em>nobody</em>. The whole point of using unprivileged users is to minimize the possible damage from a successful intrusion.</p>
<p class="indent">While you might test with the <em>nobody</em> account, never deploy production services with it. Use separate unprivileged accounts liberally.</p>
<h4 class="h4" id="lev816"><strong><em>A Sample Unprivileged User</em></strong></h4>
<p class="noindentb">Here are parameters useful for a generic unprivileged user:</p>
<p class="hang"><strong>Username</strong> Assign a username related to the user’s function. For example, the default user for web servers is <em>www</em>.</p>
<p class="hang"><strong>Home directory</strong> Unprivileged users should deliberately not have a home directory, so use <em>/nonexistent</em>. Do not create a <em>/nonexistent</em> directory either; the whole point is that it doesn’t exist!</p>
<p class="hang"><strong>Shell</strong> Unpriviliged users must not have a shell that can execute commands, so use <em>/usr/sbin/nologin</em>.</p>
<p class="hang"><strong>UID/GID</strong> Choose a special range of user and group IDs for unprivileged users.</p>
<p class="hang"><strong>Full name</strong> Assign a name describing the user’s function.</p>
<p class="hang"><strong>Password</strong> Use chpass(1) to assign the user a single asterisk as their encrypted password. This disables the account password. (Note that chpass(1) stands for <em>change password file</em>, not <em>change password</em>!)</p>
<p class="indentt">These settings make your unprivileged user very unprivileged indeed. You can set all of this easily with adduser(8), giving the account no password, the correct home directory, and an appropriate shell.</p>
<p class="indent"><span epub:type="pagebreak" id="page_454"/>Many ports and packages have assigned unprivileged users and groups, listed in <em>/usr/ports/UIDs</em> and <em>/usr/ports/GIDs</em>. Don’t be afraid to add more. Use UIDs above 1,000, so as not to conflict with those assigned by packages and FreeBSD’s core.</p>
<h3 class="h3" id="lev817"><strong>Network Traffic Control</strong></h3>
<p class="noindent">Sysadminis must have the ability to control traffic to and from their systems. Unwanted visitors must be stopped while legitimate users get access. FreeBSD provides a variety of tools that allow you to control outside access to your systems, including TCP wrappers, packet filtering, and blacklisting.</p>
<p class="indent">The TCP wrappers, or simply <em>wrappers</em>, control access to network daemons. While the program must be written to support TCP wrappers, most modern software has supported wrappers for many years. Wrappers are fairly simple to configure and don’t require much networking knowledge. As access controls go, however, wrappers are fairly limited. Wrappers do let you do interesting things with connections and with daemons offering connections, though, which is why we’ll discuss it.</p>
<p class="indent"><em>Packet filtering</em> controls which traffic the system allows to pass through it and which traffic it rejects. Most firewalls are packet filters with a pretty GUI on top, but you can use FreeBSD packet filtering and proxy software to build a solid firewall in and of itself. A rejected connection request never reaches any userland program; it’s blocked in the network stack. Packet filtering can control access to any program, service, or network port but does require more networking knowledge.</p>
<p class="indent"><em>Blacklisting</em> is useful when you want a program to be able to decide to stop listening to a remote host. The most common tool for blacklisting is fail2ban (<em><a href="https://www.fail2ban.org/">https://www.fail2ban.org/</a></em>), which is flexible but requires much special configuration. FreeBSD includes blacklistd, an easier-to-configure blacklisting tool that requires integration with programs that use it.</p>
<p class="indent">Which should you use? For basic TCP/IP access control, I recommend always using a packet filter. Only use TCP wrappers if you need their specific features. I discuss blocking and allowing connections with TCP wrappers only as a prerequisite to those advanced features. If you want a service to block clients after a certain number of failed connection attempts, consider blacklistd.</p>
<p class="indent">With wrappers or packet filtering, you must decide whether you want a default accept or default deny traffic control policy.</p>
<h3 class="h3" id="lev818"><strong>Default Accept vs. Default Deny</strong></h3>
<p class="noindent">One of the essential decisions in any security policy is between default accept and default deny. A <em>default accept</em> security stance means that you allow any type of connection except what you specifically disallow. A <em>default deny</em> stance means that you allow connections only from specified parts of the internet and/or to specified services and that you refuse all <span epub:type="pagebreak" id="page_455"/>other connections. The default is used unless you make a specific rule dictating otherwise. Once you’ve chosen your default security stance, you create exceptions one way or another to either provide or block services as necessary. The choice is really between whether you offer services to the world (default accept) or only to a select few (default deny).</p>
<p class="indent">For example, company policy might dictate that the intranet web server must be accessible only from within the company. If so, adopt a default deny stance and explicitly list who may access the server. Alternatively, if you have a public website but want to block certain parts of the internet from accessing it for whatever reason, adopt a default accept stance.</p>
<p class="indent">I always recommend a default deny stance. If you don’t make a choice, however, you’ve chosen default accept.</p>
<p class="indent">Choosing a default doesn’t mean that the default must be implemented without exceptions. My public web servers have a default deny security stance, but I specifically allow the world to access the websites. The machine rejects attempts to connect to other programs unless they come from one of a few specified IP addresses. This is a perfectly acceptable default deny stance.</p>
<p class="indent">Different security tools implement these stances in different ways. For example, with TCP wrappers, the <em>first</em> matching rule is applied. If your last rule denies everything, you’ve established a policy that says, “Unless I’ve specifically created a rule earlier to permit this traffic, block it.” On the other hand, with the PF packet filter, the <em>last</em> matching rule applies. If your first rule says, “Block all traffic,” you’ve implemented a policy that says, “Unless I specifically create a later rule to permit this traffic, block it.”</p>
<p class="indent">Both default accept and default deny annoy the sysadmin. If you have a default accept policy, you’ll spend your time continually plugging holes. If you choose a default deny policy, you’ll spend your time opening access for people. You’ll repeatedly apologize for either choice. With default deny, you’ll say things like, “I’ve just activated service for you. I apologize for the inconvenience.” With default accept, you’ll say things like, “. . . and that’s why the intruders were able to access our internal accounting database and why we lost millions of dollars.” In the latter case, “I apologize for the inconvenience” <em>really</em> doesn’t suffice.</p>
<h3 class="h3" id="lev819"><strong>TCP Wrappers</strong></h3>
<p class="noindent">Remember from <a href="ch07.xhtml#ch07">Chapter 7</a> that network connections are made to various programs that listen for connection requests. When a program is built with TCP wrappers support, the program checks the incoming request against the wrappers configuration. If the wrappers configuration says to reject the connection, the program immediately drops the request. Despite the name, TCP wrappers work with both TCP and UDP connections. Wrappers are a long-running Unix standard that have been incorporated into FreeBSD. Individual programs might or might not work with wrappers; while just about everything in the base FreeBSD system does, some third-party software doesn’t.</p>
<p class="indent"><span epub:type="pagebreak" id="page_456"/>TCP wrappers are implemented as a shared library, called <em>libwrap</em>. As seen in <a href="ch17.xhtml#ch17">Chapter 17</a>, shared libraries are small chunks of code that can be shared between programs. Any program that links with libwrap may use the TCP wrappers functions.</p>
<p class="indent">Wrappers most commonly protect inetd(8), the super server that handles network requests for smaller programs. We’ll discuss inetd in <a href="ch20.xhtml#ch20">Chapter 20</a>. While our examples cover inetd(8), you can protect any other program that supports wrappers in exactly the same way. While wrappers help protect inetd(8), make sure inetd(8) doesn’t offer any unnecessary services, just as you do for the main system.</p>
<h4 class="h4" id="lev820"><strong><em>Configuring Wrappers</em></strong></h4>
<p class="noindent">Wrappers check each incoming connection request against the rules in <em>/etc/hosts.allow</em>, in order. The first matching rule is applied, and processing stops immediately. This makes rule order very important. Each rule is on a separate line and is made up of three parts separated by colons: a daemon name, a client list, and a list of options. Here’s a sample rule:</p>
<pre>ftpd : all : deny</pre>
<p class="indent">The daemon name is <code>ftpd</code>; the client list is <code>all</code>, meaning all hosts; and the option is <code>deny</code>, telling wrappers to reject all connections. Nobody can connect to the FTP server on this host unless an earlier rule explicitly grants access.</p>
<p class="indent">In the early examples, I refer to only two options: <code>accept</code> and <code>deny</code>. They allow and reject connections, respectively. We’ll discuss the additional options later.</p>
<h5 class="h5" id="lev821"><strong>Daemon Name</strong></h5>
<p class="noindent">The daemon name is the program’s name as it appears on the command line. For example, inetd(8) starts the ftpd(8) program when it receives an incoming FTP request. The Apache web server starts a program called <em>httpd</em>, so if your version of Apache supports wrappers, give the daemon name as <code>httpd</code>. (Note that Apache doesn’t run out of inetd, but it can support wrappers anyway.) One special daemon name, <code>ALL</code>, matches all daemons that support wrappers.</p>
<p class="indent">If your system has multiple IP addresses, you can specify, as part of the daemon name, different wrapper rules for each IP address that a daemon listens on:</p>
<pre>ftpd@203.0.113.1 : ALL : deny<br/>ftpd@203.0.113.2 : ALL : accept</pre>
<p class="indent">In this example, we have two daemon names, <code>ftpd@203.0.113.1</code> and <code>ftpd@203.0.113.2</code>. Each has a separate TCP wrapper rule.</p>
<h5 class="h5" id="lev822"><span epub:type="pagebreak" id="page_457"/><strong>The Client List</strong></h5>
<p class="noindent">The client list is a list of specific IP addresses, network address blocks, hostnames, domain names, and keywords, separated by spaces. Hostnames and IP addresses are simple: just list them.</p>
<pre>ALL : netmanager.absolutefreebsd.com 203.0.113.5 : allow</pre>
<p class="indent">With this rule at the top of <em>/etc/hosts.allow</em>, wrappers allow my netmanager machine and any host with an IP address of 203.0.113.5 to connect to any service on this host. (I could block this access by other means, mind you.)</p>
<p class="indent">Specify network numbers in the client list with a slash between the IP address and the netmask, as discussed in <a href="ch07.xhtml#ch07">Chapter 7</a>. For example, if script kiddies attack your server from a bunch of addresses that begin with 192.0.2, you could block them like this:</p>
<pre>ALL : 192.0.2.0/255.255.255.0 : deny</pre>
<p class="indent">You can also use domain names in client lists by prefacing them with a dot. This works through reverse DNS, which means that anyone who controls the DNS server for a block of addresses can evade this restriction.</p>
<pre>ALL : .mycompany.com : allow</pre>
<p class="indent">If you have a long list of clients, you can even list them in a file and put the full path to the file in the client space in <em>/etc/hosts.allow</em>. I’ve been on networks with large numbers of widely scattered hosts, such as an ISP or corporate network environment with network management workstations scattered across the world. Each workstation shared the same wrapper rules as every other workstation and appeared on half a dozen lines in <em>hosts.allow</em>. By maintaining a single file with a workstation list, I could centralize all changes.</p>
<p class="indent">In addition to specifically listing client addresses and names, wrappers provide several special client keywords to add groups of clients to your list. <a href="ch19.xhtml#ch19tab1">Table 19-1</a> shows the keywords and their usage.</p>
<p class="indent">Most of the client keywords listed in <a href="ch19.xhtml#ch19tab1">Table 19-1</a> require a working DNS server. If you use these keywords, you must have a very reliable DNS service, and you must remember the vital link between DNS and the rest of your programs. If your DNS server fails, daemons that use wrappers and those keywords can’t identify any hosts. This means that everything matches your <code>UNKNOWN</code> rule, which probably denies the connection. Also, broken DNS on the client end can deny remote users access to your servers, as your DNS servers won’t be able to get proper information from the client’s servers. Finally, if you use DNS-based wrapping extensively, an intruder needs only to overload your nameserver or otherwise interrupt your nameserver to create a very effective denial-of-service attack against your network.</p>
<p class="tabcap" id="ch19tab1"><span epub:type="pagebreak" id="page_458"/><strong>Table 19-1:</strong> TCP Wrapper Keywords</p>
<table class="topbot-d">
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Keyword</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Usage</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>ALL</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">This matches every possible host.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>LOCAL</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">This matches every machine whose hostname does not include a dot. Generally, this means machines in the local domain. Machines on the other side of the world who happen to share your domain name are considered “local” under this rule.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>UNKNOWN</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">This matches machines with unidentifiable hostnames or usernames. As a general rule, any host making an IP connection has a known IP address. Tracing hostnames, however, requires DNS, and tracking usernames requires identd(8). Be very careful using this option because transitory DNS issues can make even local hostnames unresolvable and most hosts don’t run identd(8) by default. You don’t want a service to become unusable just because your nameserver was misconfigured—especially if that machine <em>is</em> your nameserver!</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>KNOWN</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">This matches any host with a determinable hostname and IP address. Be very careful using this, as DNS outages can interrupt service.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>PARANOID</code></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">This matches any host whose name does not match its IP address. You might receive a connection from a host with an IP address of 192.168.84.3 that claims to be called <em>mail.michaelwlucas.com</em>. Wrappers turn around and check the IP address of <em>mail.michaelwlucas.com</em>. If wrappers get a different IP address, the host matches this rule. Sysadmins who do not have time to maintain their DNS are the most likely to have unpatched, insecure systems.</p></td>
</tr>
</tbody>
</table>
<p class="indent">TCP wrappers provide additional keywords, but they’re not as useful or secure as these. For example, it’s possible to allow connections based on the username on the remote machine. You don’t want to rely on a client username on a remote machine, however. For example, if I set up wrappers to allow only someone with a username of <em>mwlucas</em> to connect to my home system, someone could easily add an account of that name to his FreeBSD system and get right in. Also, this relies on the same rarely used identd(1) protocol that was mentioned earlier. You can find a few other obscure keywords of similar usefulness in hosts_access(5).</p>
<h5 class="h5" id="lev823"><strong>The ALL and ALL EXCEPT Keywords</strong></h5>
<p class="noindent">Both daemon names and client lists can use the <code>ALL</code> and <code>ALL EXCEPT</code> keywords. The <code>ALL</code> keyword matches absolutely everything. For example, the default <em>hosts.allow</em> starts with a rule that permits all connections, from all locations, to any daemon:</p>
<pre>ALL : ALL : accept</pre>
<p class="indent">This matches all programs and all clients. You can limit this by giving a specific name to either the client list or the daemon list.</p>
<pre>ALL : 203.0.113.87 : deny</pre>
<p class="indent">In this example, we reject all connections from the host 203.0.113.87.</p>
<p class="indent"><span epub:type="pagebreak" id="page_459"/>Categorically blocking access to all hosts isn’t that great an idea, but remember that TCP wrappers follow rules in order and quit when they reach the first matching rule. The <code>ALL</code> keyword lets you set a default stance quite easily. Consider the following ruleset:</p>
<pre>ALL : 192.168.8.3 192.168.8.4 : accept<br/>ftpd : ALL : accept<br/>ALL : ALL : deny</pre>
<p class="indent">Our workstations 192.168.8.3 and 192.168.8.4 (probably the sysadmin’s workstations) may access anything they want. Anyone in the world may access the FTP server. Finally, we drop all other connections. This is a useful default deny stance.</p>
<p class="indent">Use the <code>ALL EXCEPT</code> keyword to compress rules. <code>ALL EXCEPT</code> allows you to list hosts by exclusion; what isn’t listed matches. Here, we write the same rules with <code>ALL EXCEPT</code>:</p>
<pre>ALL : 192.168.8.3 192.168.8.4 : accept<br/>ALL EXCEPT ftpd : ALL : deny</pre>
<p class="indent">Of course, this rule relies on having a default accept policy that permits the FTP connection later.</p>
<p class="indent">Some people find rules more clear when written with <code>ALL</code>, others prefer <code>ALL EXCEPT</code>. The important thing to remember is that the first matching rule ends the check, so be careful slinging <code>ALL</code> around.</p>
<p class="indent">It’s a good idea to allow any connections from the local host; you’re likely to discover a number of programs that break when they can’t talk to the local machine. Put a rule like this early in your <em>hosts.allow</em>:</p>
<pre>ALL : localhost : allow</pre>
<h5 class="h5" id="lev824"><strong>Options</strong></h5>
<p class="noindent">We’ve already seen two options: <code>allow</code> and <code>deny</code>. While <code>allow</code> permits the connection, <code>deny</code> blocks it. The first rule in the default <em>hosts.allow</em> applies to all daemons and clients, and it matches and allows all possible connections. This rule can’t be first in your <em>hosts.allow</em> if you want to wrap your services, but it’s a good final rule in a default accept security stance. Similarly, an <code>ALL</code>:<code>ALL</code>:<code>deny</code> rule is a good final rule in a default deny security stance. TCP wrappers support other options besides the simple <code>allow</code> and <code>deny</code>, however, giving you a great deal of flexibility.</p>
<div class="sidebar">
<p class="sidebart"><strong>LONG RULES</strong></p>
<p class="spara">If you’re using a lot of options, wrapper rules can get very long. To help keep rules readable, the <em>hosts.allow</em> file can use the backslash (<code>\</code>) followed by a return as a line-continuation character.</p>
</div>
<h5 class="h5" id="lev825"><span epub:type="pagebreak" id="page_460"/><strong>Logging</strong></h5>
<p class="noindent">Once you’ve decided to accept or reject the connection attempt, you can also log the connection. Suppose you want to permit but specifically log all incoming requests from a competitor. Similarly, you might want to know how many connections your server rejects because of DNS problems when using the <code>PARANOID</code> client keyword. Logging is good. More logging is better. Disk space is cheaper than your time.</p>
<p class="indent">The <code>severity</code> option sends a message to the system log, syslogd(8). You can configure syslogd to direct these messages to an arbitrary file based on the syslogd facility and level you choose (see <a href="ch21.xhtml#ch21">Chapter 21</a>).</p>
<pre>sshd : ALL : severity local0.info : allow</pre>
<p class="indent">This example permits all SSH connections but also logs them using the local0 facility.</p>
<h5 class="h5" id="lev826"><strong>Twisting</strong></h5>
<p class="noindent">The <code>twist</code> option allows you to run arbitrary shell commands and scripts when someone attempts to connect to a wrapped TCP daemon and returns the output to the remote user. The <code>twist</code> option works properly only with TCP connections. (Remember, UDP is connectionless; there’s no connection to return the response over, so you must jump through very sophisticated and annoying hoops to make <code>twist</code> work with UDP. Also, protocols that transmit over UDP frequently don’t expect such a response and aren’t usually equipped to receive or interpret it. Using <code>twist</code> with UDP isn’t worth the trouble.) The <code>twist</code> option takes a shell command as an argument and acts as a deny-plus-do-this rule. You must know basic shell scripting to use <code>twist</code>; very complicated uses of <code>twist</code> are possible, but we’ll stick with the simple ones.</p>
<p class="indent">The <code>twist</code> option is useful for a final rule in a default deny stance. Use <code>twist</code> to return an answer to the person attempting to connect as follows:</p>
<pre>ALL : ALL : twist /bin/echo "You cannot use this service."</pre>
<p class="indent">If you want to deny just a particular service to a particular host, you can use more specific daemon and client lists with <code>twist</code>:</p>
<pre>sendmail : .spammer.com : twist /bin/echo \<br/>    "You cannot use this service, spam-boy."</pre>
<p class="indent">This isn’t effective against spam, but it might make you feel better. Legit customers that encounter rude messages might trigger meetings, however.</p>
<p class="indent">If you’re feeling friendly, you can tell people why you’re rejecting their connection. The following <code>twist</code> rejects all connections from people whose hostname doesn’t match their IP address and tells them why:</p>
<pre>ALL : PARANOID : twist /bin/echo \<br/>    "Your DNS is broken. When you fix it, try again."</pre>
<p class="indent"><span epub:type="pagebreak" id="page_461"/>Using <code>twist</code> holds the network connection open until the shell command finishes. If your command takes a long time to finish, you could find that you’re holding open more connections than you like. This can impact system performance. A script kiddie can use <code>twist</code> to overload your system, creating a very simple DoS attack. Make <code>twist</code> simple and quick-finishing.</p>
<h5 class="h5" id="lev827"><strong>Spawning</strong></h5>
<p class="noindent">Like <code>twist</code>, the <code>spawn</code> option denies the connection and runs a specified shell command. Unlike <code>twist</code>, <code>spawn</code> doesn’t return the results to the client. Use <code>spawn</code> when you want your FreeBSD system to take an action upon a connection request but you don’t want the client to know about it. Spawned commands run in the background. The following example allows the connection but logs the client’s IP address to a file:</p>
<pre>ALL : PARANOID : spawn (/bin/echo %a &gt;&gt; /var/log/misconfigured ) \<br/>    : allow</pre>
<p class="indent">Wait a minute—where did the <code>%a</code> come from? TCP wrappers support several variables for use in <code>twist</code> and <code>spawn</code> commands, so you can easily customize your responses. This particular variable, <code>%a</code>, stands for <em>client address</em>. It expands into the client’s IP address in the shell command before the command is run. <a href="ch19.xhtml#ch19tab2">Table 19-2</a> lists other variables.</p>
<p class="tabcap" id="ch19tab2"><strong>Table 19-2:</strong> Variables for <code>twist</code> and <code>spawn</code> Scripts</p>
<table class="topbot-d">
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Variable</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="taba"><code>%a</code></p></td>
<td style="vertical-align: top;" class="table-a"><p class="taba">Client address.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-d"><p class="taba"><code>%A</code></p></td>
<td style="vertical-align: top;" class="table-d"><p class="taba">Server IP address.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="taba"><code>%c</code></p></td>
<td style="vertical-align: top;" class="table-a"><p class="taba">All available client information.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-d"><p class="taba"><code>%d</code></p></td>
<td style="vertical-align: top;" class="table-d"><p class="taba">Name of the daemon connected to.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="taba"><code>%h</code></p></td>
<td style="vertical-align: top;" class="table-a"><p class="taba">Client hostname, or IP address if hostname not available.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-d"><p class="taba"><code>%H</code></p></td>
<td style="vertical-align: top;" class="table-d"><p class="taba">Server hostname, or IP address if hostname not available.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="taba"><code>%n</code></p></td>
<td style="vertical-align: top;" class="table-a"><p class="taba">Client hostname, or <code>UNKNOWN</code> if no hostname is found. If the hostname and the IP address don’t match, this returns <code>PARANOID</code>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-d"><p class="taba"><code>%N</code></p></td>
<td style="vertical-align: top;" class="table-d"><p class="taba">Server hostname, but if no hostname is found, this returns either <code>UNKNOWN</code> or <code>PARANOID</code>.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="taba"><code>%p</code></p></td>
<td style="vertical-align: top;" class="table-a"><p class="taba">Daemon’s process ID.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-d"><p class="taba"><code>%s</code></p></td>
<td style="vertical-align: top;" class="table-d"><p class="taba">All available server information.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-a"><p class="taba"><code>%u</code></p></td>
<td style="vertical-align: top;" class="table-a"><p class="taba">Client’s username.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-da"><p class="taba"><code>%%</code></p></td>
<td style="vertical-align: top;" class="table-da"><p class="taba">A single <code>%</code> character.</p></td>
</tr>
</tbody>
</table>
<p class="indent">Use these variables anywhere you’d use the information they represent in a shell script. For example, to log all available client information to a file whenever anyone connects to a wrapped program, you could use this:</p>
<pre>ALL : ALL : spawn (/bin/echo %c &gt;&gt; /var/log/clients) : allow</pre>
<p class="indent"><span epub:type="pagebreak" id="page_462"/>Spaces and backslashes are illegal characters in shell commands and might cause problems. While neither appears in hostnames under normal circumstances, the internet is almost by definition not normal. TCP wrappers replace any character that might confuse the command shell with an underscore (<code>_</code>). Check for underscores in your logs; they might indicate possible intrusion attempts or just someone who doesn’t know what they’re doing.</p>
<h4 class="h4" id="lev828"><strong><em>Wrapping Up Wrappers</em></strong></h4>
<p class="noindent">Let’s take all the examples given so far in this section and build a complete <em>/etc/hosts.allow</em> to protect a hypothetical network system. We must first inventory the network resources this system offers, the IP addresses we have on the network, and the remote systems we wish to allow to connect.</p>
<p class="indent">While these requirements are fairly complicated, they boil down to a very simple ruleset:</p>
<pre>#reject all connections from hosts with invalid DNS and from our competitor<br/>ALL : PARANOID 198.51.100.0/24 : deny<br/>#localhost can talk to itself<br/>ALL : localhost : allow<br/>#our local network may access portmap, but no others<br/>portmap : ALL EXCEPT 203.0.113.0/24 : allow<br/>#allow SSH, pop3, and ftp, deny everything else<br/>sshd, POP3, ftpd : ALL : allow<br/>ALL : ALL : deny</pre>
<p class="indent">You can find many more commented-out examples in <em>/etc/hosts.allow</em> or in hosts_allow(5) and hosts_access(5).</p>
<h3 class="h3" id="lev829"><strong>Packet Filtering</strong></h3>
<p class="noindent">To control access to networked programs that don’t support TCP wrappers, or whenever your needs exceed what wrappers provide, use one of FreeBSD’s kernel-level packet filtering tools. If you need a packet filter, it’s best to entirely replace your TCP wrappers implementation with packet filtering. Using both tools at once on the same machine will simply confuse you.</p>
<p class="indent">A packet filter compares every network packet that enters the system to a list of rules. When a rule matches the packet, the kernel acts based upon that rule. Rules can tell the system to allow, drop, or alter the packet. You can’t use the nifty options provided by TCP wrappers, however; instead of spitting a comparatively friendly rejection message back at the client, the connection is severed at the network level before the client even reaches the application.</p>
<p class="indent">While the idea of packet filtering is straightforward enough, your first implementation will be a complete nightmare—er, I mean, a “valuable learning experience.” Be prepared to spend hours experimenting and don’t be discouraged by failures. In my experience, it’s ignorance of basic TCP/IP that causes grief with packet filtering, rather than the packet filter itself. Trying to filter network traffic without understanding the network is <span epub:type="pagebreak" id="page_463"/>frustrating and pointless. The only way to really understand TCP/IP is to do real work with it, however. Go study <a href="ch07.xhtml#ch07">Chapter 7</a> again. If that doesn’t suffice, dig into the books recommended there.</p>
<p class="indent">FreeBSD suffers from a wealth of packet filters: IPFW, IP Filter, and PF.</p>
<p class="indent">IPFW is the primordial FreeBSD packet filtering software. It’s tightly integrated with FreeBSD; in fact, the generically named files <em>/etc/rc.firewall</em> and <em>/etc/rc.firewall6</em> are purely for IPFW. While quite powerful and very popular with more experienced FreeBSD administrators, it’s a little difficult for a beginner.</p>
<p class="indent">The second packet filter, IP Filter, is not a FreeBSD-specific firewall program but is supported on several Unix-like operating systems. It’s primarily the work of one individual, Darren Reed, who has by heroic effort developed the overwhelming majority of the code and ported it to all those operating systems. IP Filter is most useful if you want to share one firewall configuration among multiple operating systems.</p>
<p class="indent">We’ll focus on the imaginatively named <em>PF</em>, or <em>packet filter</em>. PF originated in OpenBSD and was designed to be featureful, flexible, and easy to use. The average FreeBSD administrator can use PF to achieve almost any effect possible with the other two packet filters.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>For in-depth discussion of PF, you might check out Peter N. M. Hansteen’s</em> The Book of PF <em>(No Starch Press, 2014) or my book</em> Absolute OpenBSD <em>(No Starch Press, 2013), which contains several chapters about PF. You might also look at the online PF FAQ, but that has fewer haiku.</em></p>
</div>
<h4 class="h4" id="lev830"><strong><em>Enabling PF</em></strong></h4>
<p class="noindent">PF includes the packet filtering kernel module, <em>pf.ko</em>, and the userland program pfctl(8). Before using PF, you must load the kernel module. The simplest way is to enable PF in <em>rc.conf</em>:</p>
<pre>pf_enable="YES"</pre>
<p class="indent">PF defaults to the accept all stance, which means that you won’t lock yourself out of your server merely by enabling the firewall.</p>
<h4 class="h4" id="lev831"><strong><em>Default Accept and Default Deny in Packet Filtering</em></strong></h4>
<p class="noindent">The security stances (default accept and default deny) are critical in packet filtering. If you use the default accept stance and want to protect your system or network, you need numerous rules to block every possible attack. If you use the default deny stance, you must explicitly open holes for every little service you offer. In almost all cases, default deny is preferable; while it can be more difficult to manage, its increased security more than makes up for that difficulty.</p>
<p class="indent">When using a default deny stance, it’s very easy to lock yourself out of remotely accessing your machine. When you have an SSH connection to a remote machine and accidentally break the rule that allows SSH access, you’re in trouble. Everybody does this at least once, so don’t be too <span epub:type="pagebreak" id="page_464"/>embarrassed when it happens to you. The point is, it’s best not to learn about packet filtering on a remote machine; start with a machine that you can console into so you can recover easily. I’ve cut my own access many times, generally because I’m not thinking straight when solving an unrelated packet filtering problem. Without a remote console or IPMI, the only fix is to kick myself as I climb into the car, drive to the remote location, and apologize profusely to the people I’ve inconvenienced as I fix the problem. Fortunately, as I grow older, this happens less and less.<sup><a href="footnote.xhtml#ch19fn1" id="ch19fn1a">1</a></sup></p>
<p class="indent">Still, in almost all circumstances, a default deny stance is correct. As a new administrator, the only way you can reasonably learn packet filtering is if you have convenient access to the system console. If you’re not entirely confident in your configuration, don’t set up a packet filtering system across the country unless you have remote console and power access, a competent local administrator, or a serial console.</p>
<h4 class="h4" id="lev832"><strong><em>Basic Packet Filtering and Stateful Inspection</em></strong></h4>
<p class="noindent">Recall from <a href="ch07.xhtml#ch07">Chapter 7</a> that a TCP connection can be in a variety of states, such as opening, open, closing, and so on. For example, every connection opens when the client sends a SYN packet to the server to request connection synchronization. If the server is listening on the requested port, it responds with a SYN-ACK, meaning, “I’ve received your request, and here’s basic information for our connection.” The client acknowledges receipt of the information with an ACK packet, meaning, “I acknowledge receipt of the connection information.” Each part of this three-way handshake must complete for a connection to occur. Your packet filtering ruleset must permit all parts of the handshake, as well as the actual data transmission, to occur. Allowing your server to receive incoming connection requests is useless if your packet filter rules don’t permit transmitting that SYN-ACK.</p>
<p class="indent">In the early 1990s, packet filters checked each packet individually. If a packet matched a rule, it was allowed to pass. The system didn’t record what it had previously passed and had no idea whether a packet was part of a legitimate transaction or not. For example, if a packet arrived marked SYN-ACK with a destination address inside the packet filter, the packet filter generally decided that the packet had to be the response to a packet it had previously approved. Such a packet <em>had</em> to be approved to complete the three-way handshake. As a result, intruders forged SYN-ACK packets and used them to circumvent seemingly secure devices. Since the packet filter didn’t know who had previously sent a SYN packet, it couldn’t reject illegitimate SYN-ACK packets. Once an intruder gets packets inside a network, he can usually trigger a response from a random device and start to worm his way in.</p>
<p class="indent">Modern packet filters use stateful inspection to counteract this problem. <em>Stateful inspection</em> means keeping track of every connection and its current condition. If an incoming SYN-ACK packet appears to be part of an ongoing connection, but nobody sent a corresponding SYN request, the packet is <span epub:type="pagebreak" id="page_465"/>rejected. While this complicates the kernel, writing stateful inspection packet filter rules is easier than writing old-fashioned rules. The packet filter must track many, many possible states, so this is harder to program than it might seem—especially when you add in problems such as packet fragmentation, antispoofing, and so on.</p>
<p class="indent">PF performs stateful inspection by default. You don’t need to specify it in a rule.</p>
<p class="indent">If you’ve started to think, “Hey, packet filtering sounds like a firewall,” you’re right, to a point. The word <em>firewall</em> is applied to a variety of network protection devices. Some of these devices are very sophisticated; some lose intelligence contests to cinderblocks. These days, the term <em>firewall</em> is nothing more than a marketing buzzword with very little concrete meeting. The word <em>firewall</em> is like the word <em>car</em>: do you mean a rusty 1972 Gremlin with a 6-horsepower engine and an exhaust system that emits enough fumes to breach the Kyoto Accords, or a shiny Tesla Roadster with a 500-horsepower engine, a fancy tricolor paintjob, and the Stereo System of The Apocalypse? Both have their uses, but one is obviously designed for performance. While the Gremlins of firewalls might have their place, it’s preferable to get the best you can afford.</p>
<p class="indent">Having said that, FreeBSD can be made as solid a firewall as you desire. Packet filtering is only the beginning. The packages collection contains a variety of application proxies that can let your FreeBSD system go up against Checkpoint or a PIX and come out on top—for tens of thousands of dollars less.</p>
<h4 class="h4" id="lev833"><strong><em>Configuring PF</em></strong></h4>
<p class="noindent">Configure PF in <em>/etc/pf.conf</em>. This file contains statements and rules whose formats vary with the features they configure. Not only is the rule order extremely important but also the order in which features are configured. If you try to do stateful inspection before you reassemble fragmented packets, for example, connections won’t work properly.</p>
<p class="indent">The default <em>/etc/pf.conf</em> has the sample rules in the proper order, but if you’re in the slightest danger of becoming confused, I suggest that you put large comment markers between the sections, in capital letters if necessary. (Use hash marks to comment <em>pf.conf</em>.) The features must be entered in this exact order:</p>
<ol>
<li class="noindent">Macros</li>
<li class="noindent">Tables</li>
<li class="noindent">Options</li>
<li class="noindent">Packet normalization</li>
<li class="noindent">Bandwidth management</li>
<li class="noindent">Translation</li>
<li class="noindent">Redirection</li>
<li class="noindent">Packet filtering</li>
</ol>
<p class="indent"><span epub:type="pagebreak" id="page_466"/>Yes, PF does more than just filter packets. It’s a general-purpose TCP/IP manipulation tool. We won’t cover all of its features here; go read Peter’s book.</p>
<h5 class="h5" id="lev834"><strong>Macros</strong></h5>
<p class="noindent">A macro lets you define variables to make writing and reading rules easier. For example, here are macros to define your network interface and your IP address:</p>
<pre>interface="em0"<br/>serveraddr="203.0.113.2"</pre>
<p class="indent">Later in your rules, you may describe your network interface as <code>$interface</code> and your server’s IP address as <code>$serveraddr</code>. This means that if you renumber your server or change your network card, making one change in your <em>pf.conf</em> fully updates your rules.</p>
<p class="indent">Sometimes you’ll want a rule to refer to “all IP addresses currently on this interface.” You don’t care which address the traffic arrives at, you just want either to accept or reject traffic to that interface. PF provides shorthand for this. Enclose the interface name in parentheses, as we’ll see later. (You can use the interface name without parentheses, but then PF won’t notice any IP changes since the last reload or restart.)</p>
<h5 class="h5" id="lev835"><strong>Tables and Options</strong></h5>
<p class="noindent">PF can store long lists of addresses through tables. That’s a more sophisticated use of PF than we’re going to use, but you should know the capability exists.</p>
<p class="indent">Similarly, PF has a variety of options that control network connection timing, table sizes, and other internal settings. The default settings are generally adequate for normal (and most abnormal) use.</p>
<h5 class="h5" id="lev836"><strong>Packet Normalization</strong></h5>
<p class="noindent">TCP/IP packets can be broken up in transit, and processing these shards of data increases system load and the amount of work your server must do both to serve the request and filter the packets. A system must reassemble these fragments before handing them on to your client software, while deciding what to do with any other random crud that arrives. PF refers to this reassembly as <em>scrubbing</em>. For example, to reassemble all fragments coming in your network interface, drop all fragments too small to possibly be legitimate, and otherwise sensibly sanitize your incoming data stream, use the following rule:</p>
<pre>scrub in</pre>
<p class="indent">This affects all packets entering the computer.</p>
<p class="indent">While scrubbing seems like a “nice to have,” it’s actually quite important since PF filters are based on whole packets. Fragments are much more difficult to filter and require special handling unless reassembled. Not scrubbing your traffic causes connectivity problems.</p>
<h5 class="h5" id="lev837"><span epub:type="pagebreak" id="page_467"/><strong>Bandwidth, Translation, and Redirection</strong></h5>
<p class="noindent">PF includes other features vital for firewalls and performs other functions normally associated with network devices. Through queueing, PF can control how much traffic the host transmits on a per-IP or even per-port basis. PF includes a whole bunch of features to support Network Address Translation (NAT) and port redirection, two critical firewall features. The support exceeds that found in many commercial offerings.</p>
<p class="indent">All of this would fill another book. Literally. Peter Hansteen wrote <em>The Book of PF</em>. Go read that and build a firewall. Every sysadmin should build a firewall out of a raw operating system at least once in her life. Even if you revert to using a commercial offering, a little embedded device, or a product like pfSense or OPNsense, you’ll learn a whole bunch.<sup><a href="footnote.xhtml#ch19fn2" id="ch19fn2a">2</a></sup></p>
<h4 class="h4" id="lev838"><strong><em>Small-Server PF Rule Sample</em></strong></h4>
<p class="noindent">Here’s a sample set of PF rules for protecting a small internet server. Start from here and edit this to match your server’s requirements.</p>
<pre><span class="ent">➊</span> ext_if="em1"<br/><span class="ent">➋</span> set skip on lo0<br/><span class="ent">➌</span> scrub in<br/><br/><span class="ent">➍</span> block in<br/><span class="ent">➎</span> pass out<br/><br/><span class="ent">➏</span> pass in on $ext_if proto tcp from any to ($ext_if) port {22, 53, 80, 443}<br/><span class="ent">➐</span> pass in on $ext_if proto udp to ($ext_if) port 53<br/><span class="ent">➑</span> pass in on $ext_if inet proto icmp to ($ext_if) icmp-type { unreach, redir,<br/>       timex, echoreq }</pre>
<p class="indent">We start by defining a macro for our interface name <span class="ent">➊</span> so that if we change network cards, we won’t need to rewrite all our rules.</p>
<p class="indent">The second line instructs PF not to filter on the lo0 interface <span class="ent">➋</span>. The loopback interface is local to the machine. The only host that can communicate over it is the local machine.</p>
<p class="indent">Then, we scrub incoming traffic <span class="ent">➌</span>, reassembling packets into a coherent whole and throwing away what can’t be reassembled.</p>
<p class="indent">Now that we have a sensible stream of incoming data, we can filter it. This policy starts by blocking all incoming traffic <span class="ent">➍</span>, setting a default deny policy. Everything not explicitly permitted is forbidden.</p>
<p class="indent">Outbound traffic gets a default allow policy <span class="ent">➎</span>.</p>
<p class="indent">The final three rules in this policy address TCP, UDP, and ICMP. They have a similar format, which we’ll dissect shortly.</p>
<p class="indent">First, we permit TCP traffic to ports 22, 53, 80, and 443 <span class="ent">➏</span>.</p>
<p class="indent">Next, we permit UDP traffic to port 53 <span class="ent">➐</span>. If this host offered more services than DNS, we’d have a longer list of ports.</p>
<p class="indent"><span epub:type="pagebreak" id="page_468"/>The final rule allows vital ICMP traffic to our host and permits the host to respond <span class="ent">➑</span>.</p>
<p class="indent">Let’s take a closer look at the TCP rule.</p>
<pre><span class="ent">➊</span>pass in<span class="ent">➋</span>on $ext_if<span class="ent">➌</span>proto tcp<span class="ent">➍</span>from any<span class="ent">➎</span>to ($ext_if)<span class="ent">➏</span>port {22, 53, 80, 443}</pre>
<p class="indent">This host has a default deny policy on inbound traffic, so with the <code>pass in</code> statement <span class="ent">➊</span>, we’re carving out an exception to that policy.</p>
<p class="indent">The next chunk of the rule specifies which interface this rule applies to <span class="ent">➋</span>. This rule applies to the interface defined by the macro <code>$ext_if</code>, or em1.</p>
<p class="indent">Then, we specify a protocol <span class="ent">➌</span>. This rule applies to TCP connections.</p>
<p class="indent">You can write PF rules that apply only to specific source or destination addresses. This rule applies to traffic from any host <span class="ent">➍</span>. You can drop this part of the rule if you’re permitting any source address.</p>
<p class="indent">We then specify a destination address <span class="ent">➎</span>. The destination is the interface name in parentheses, which means “any IP address on this interface.”</p>
<p class="indent">Lastly, define the ports this rule applies to <span class="ent">➏</span>. The braces allow you to group several entities together. The filter permits connections to port 22 (ssh), 53 (DNS), 80 (HTTP), and 443 (HTTPS). You could specify a port by its name (from <em>/etc/services</em>), but I find numbers to be more reliable. Editing <em>/etc/services</em> shouldn’t break your firewall! Deploying a new TCP service on this host requires only adding a port to the list and reloading the firewall rules.</p>
<p class="indent">The UDP rule is very slightly different.</p>
<pre>pass in on $ext_if<span class="ent">➊</span>proto udp to ($ext_if)<span class="ent">➋</span>port 53</pre>
<p class="indent">The most obvious change is defining UDP protocol instead of TCP <span class="ent">➊</span>. One less obvious change is that this rule drops the source address. It applies to packets from any address. This packet filter allows only one port, 53 <span class="ent">➋</span>. Rules with a single port don’t need braces.</p>
<p class="indent">The ICMP rule looks a little tricky, but it’s really just the same.</p>
<pre>pass in on $ext_if inet<span class="ent">➊</span>proto icmp to ($ext_if)<span class="ent">➋</span>icmp-type<span class="ent">➌</span>{ unreach, redir, timex echoreq }</pre>
<p class="indent">Specifying that this rule applies to ICMP is straightforward <span class="ent">➊</span>. And this rule also doesn’t list a source address, so it applies to traffic from anywhere.</p>
<p class="indent">Where the TCP and UDP rules specify a destination port, this ICMP rule lists an <code>icmp-type</code> <span class="ent">➋</span>. ICMP doesn’t have ports, but it does have different types of traffic. For our purposes, though, ICMP types are much like ports. Types have numerical codes, but the names are easier.</p>
<p class="indent">This rule specifies four different types of ICMP traffic <span class="ent">➌</span>.</p>
<p class="indent">Taken as a whole, this rule permits ICMP traffic that’s generally necessary for proper internet functioning. Your environment might need other ICMP types. Your organization’s security policy might specify what ICMP you can and cannot pass. But these four are a reasonable combination for an internet-facing server.</p>
<p class="indent"><span epub:type="pagebreak" id="page_469"/>This simple policy defines basic rules for communicating with our server. While it’s not perfect, it can raise barriers for intruders. That jerk who broke into your web server and started a command prompt on port 10000? If your firewall rules don’t allow incoming connections on that port, all their hard work will be wasted. Such a tragedy.</p>
<h4 class="h4" id="lev839"><strong><em>Managing PF</em></strong></h4>
<p class="noindent">Manage PF with pfctl(8). If your rules have no errors, pfctl(8) runs silently; it produces output only when you have errors. You’ll want to test, activate, view, and remove rules.</p>
<h5 class="h5" id="lev840"><strong>Testing Rules</strong></h5>
<p class="noindent">As a firewall error can cause you much grief, it’s best to check your rules before activating them. While a rule check only parses the file, checking for grammatical errors in the rules themselves, activating rules with grammatical errors either leaves your system unprotected, locks you out, or both. Use the <code>-n</code> flag to check a file for problems and <code>-f</code> to specify the PF rules file.</p>
<pre># <span class="codestrong1">pfctl -nf /etc/pf.conf</span></pre>
<p class="indent">If you get errors, fix them and try again.</p>
<h5 class="h5" id="lev841"><strong>Activating Rules</strong></h5>
<p class="noindent">Once your syntax check runs silently, activate the new rules by removing the <code>-n</code> flag.</p>
<pre># <span class="codestrong1">pfctl -f /etc/pf.conf</span></pre>
<p class="indent">Changing PF configuration is very quick. This means you can have several PF configurations for different times or situations. Perhaps you want to allow access only to certain services at certain parts of the day; you could schedule a pfctl(8) run to install appropriate rules for those times. Or maybe you have separate rules for disaster situations and want to install a special ruleset when you lose your internet connection. Using pfctl(8) makes all these configurations simple.</p>
<h5 class="h5" id="lev842"><strong>View Rules</strong></h5>
<p class="noindent">If you want to see the rules currently running on your firewall, use <code>pfctl -sr</code>.</p>
<pre># <span class="codestrong1">pfctl -sr</span><br/>scrub in all fragment reassemble<br/>block drop in all<br/>pass in on em1 proto tcp from any to (em1) port = ssh flags S/SA keep state<br/>pass in on em1 proto tcp from any to (em1) port = domain flags S/SA keep state<br/>pass in on em1 proto tcp from any to (em1) port = http flags S/SA keep state<br/>pass in on em1 proto tcp from any to (em1) port = https flags S/SA keep state<br/>pass in on em1 proto udp from any to (em1) port = domain keep state<br/><span epub:type="pagebreak" id="page_470"/>pass in on em1 inet proto icmp from any to (em1) icmp-type unreach keep state<br/>pass in on em1 inet proto icmp from any to (em1) icmp-type redir keep state<br/>pass in on em1 inet proto icmp from any to (em1) icmp-type timex keep state<br/>pass in on em1 inet proto icmp from any to (em1) icmp-type echoreq keep state<br/>pass out all flags S/SA keep state</pre>
<p class="indent">You can write PF rules in exactly the format shown here.</p>
<p class="indent">Note that while we specified multiple TCP ports in the configuration file, in the packet filter each TCP and UDP port gets its own rule. Likewise, each ICMP type gets its own rule.</p>
<h5 class="h5" id="lev843"><strong>Removing Rules</strong></h5>
<p class="noindent">Finally, remove all rules from your running configuration with the <code>-Fa</code> (flush all) flags. (You could use flags other than <code>a</code> to remove parts of your firewall config, but that can leave your system in an inconsistent state.)</p>
<pre># <span class="codestrong1">pfctl -Fa</span></pre>
<p class="indent">You’ll see PF systematically erase all rules, NAT configurations, and anything else in your configuration. Do not manually clear the configuration before loading a new configuration; just load the new rules file to erase the old rules.</p>
<p class="indent">PF is terribly powerful, very flexible, and can abuse TCP/IP in almost any way you like (and some ways you won’t like). We’ve barely scratched the surface. Check out some of the resources listed at the start of “<a href="ch19.xhtml#lev829">Packet Filtering</a>” on <a href="ch19.xhtml#page_462">page 462</a> to explore PF in depth.</p>
<h3 class="h3" id="lev844"><strong>Blacklistd(8)</strong></h3>
<p class="noindent">Sometimes you want more thoughtful packet filtering than a simple allow or deny permits. I often have SSH servers open to the public internet so that I can log in from anywhere. I do rather resent botnets thinking that I’d be sufficiently daft to permit logins without a password, though. That’s where blacklistd(8) comes in.</p>
<p class="indent">Blacklistd lets a daemon report, “Hey, this IP address is bugging me.” Once blacklistd receives a sufficient number of complaints about an address, it tells the firewall to block that address. Those bots eternally poking at your SSH server? They’re history.</p>
<p class="indent">This sort of blacklisting is only marginally useful against distributed botnets like the Hail Mary Cloud, but even then, you might be able to configure sensitivity to block out the most annoying clients. It all depends on just how intrusive each botnet member is.</p>
<p class="indent">To use blacklistd, you must set up the packet filter to accept input from blacklistd, set tolerance levels for each service, and configure the service to use blacklistd.</p>
<h4 class="h4" id="lev845"><span epub:type="pagebreak" id="page_471"/><strong><em>PF and Blacklistd</em></strong></h4>
<p class="noindent">PF handles dynamic rules through anchors. You can use pfctl(8) to edit an active anchor, letting you insert rules at a specific point in the policy. Add the blacklistd anchor to your rules right before your first <code>block</code> and <code>pass</code> statements. Using the policy from the previous section, your rules would look like this:</p>
<pre>--<span class="codeitalic1">snip</span>--<br/>anchor "blacklistd/*" in on $ext_if<br/>block in<br/>pass out<br/>--<span class="codeitalic1">snip</span>--</pre>
<p class="indent">You must include the quotes around the anchor name, and you must specify the interface.</p>
<p class="indent">The packet filter is now ready for dynamic blacklisting.</p>
<h4 class="h4" id="lev846"><strong><em>Configuring Blacklistd</em></strong></h4>
<p class="noindent">Blacklistd gets its configuration from <em>/etc/blacklistd.conf</em>. While most of its configuration goes in this file, you can also modify the service’s behavior with command line options.</p>
<p class="indent">Start by enabling blacklistd in <em>/etc/rc.conf</em>.</p>
<pre># <span class="codestrong1">sysrc blacklistd_enable=YES</span><br/>blacklistd_enable: NO -&gt; YES</pre>
<p class="indent">The daemon won’t start until you either reboot or start it manually, so you can configure it now.</p>
<h5 class="h5" id="lev847"><strong>/etc/blacklistd.conf</strong></h5>
<p class="noindent">Blacklistd rules each support a single service, port, or group of addresses. Put your rules into <em>/etc/blacklistd.conf</em>, one rule per line. Blacklistd rules come in two groups, local and remote.</p>
<p class="indent"><em>Local</em> blacklistd rules apply to items local to the machine running blacklistd. This is where you set rules for the local SSH service, or port 99, or anything else local. The section of local rules is prefaced with <code>[local]</code>.</p>
<p class="indent"><em>Remote</em> blacklistd rules apply to items not local to the machine. Here, you might define rules like “this block gets reduced tolerance” or “disable these addresses for shorter times” or “never block these addresses.” The section of remote rules gets prefaced with <code>[remote]</code>. We’ll talk about local rules first and then the additions supported by remote rules.</p>
<p class="indent">Here’s a sample <em>blacklistd.conf</em> entry:</p>
<pre>[local]<br/>ssh             stream  *       *               *       3       24h</pre>
<p class="indent"><span epub:type="pagebreak" id="page_472"/>The first line is a <code>[local]</code> statement. Every rule that appears after this applies to the local machine, until we hit a <code>[remote]</code> entry.</p>
<p class="indent">Each rule has seven fields. The first four fields identify traffic to be blacklisted, while the last three fields define the blacklist behavior. An asterisk (<code>*</code>) is a wildcard, saying anything matches this field.</p>
<p class="indent">The first field is the <em>location</em>. For local rules, this gives the network port that this rule applies to. Entries like <code>ssh</code> and <code>ftp</code> are slightly deceiving. They don’t apply to the programs named <code>sshd</code> and <code>ftpd</code>, but rather to the network ports listed in <em>/etc/services</em>. While you can list a specific IP address and port in local rules, blacklistd ignores the address. Only the port applies. The sample rule blocks on <code>ssh</code>, or port 22.</p>
<p class="indent">The second field gives the socket type. TCP sockets use type <code>stream</code>, while UDP sockets need <code>dgram</code>. At this time, all services that support blacklistd use TCP. You can safely use an asterisk here to say “any socket type.” Our sample rule uses stream, so it’s for TCP connections.</p>
<p class="indent">The third field defines the <em>protocol</em>. Supported options include <code>tcp</code>, <code>udp</code>, <code>tcp6</code>, <code>udp6</code>, or <code>numeric</code>, or you can just use a wildcard and say “any protocol.” The only reason not to use a wildcard here is if you want to specifically match only one version of IP, such as using a different blacklist setting for TCP over IPv4 than for TCP over IPv6.</p>
<p class="indent">The fourth field gives the <em>owner</em> of the daemon complaining about the traffic. This can be a wildcard, a username, or a UID. Again, wildcards are the most common entry here. For blacklisting purposes, I don’t care which user runs the server running on port 22; I care that it gets protected from random poking.</p>
<p class="indent">The fifth field, the <em>packet filter rule name</em>, is the first entry that determines how the block works. Blacklistd defaults to putting all blocks under an anchor called <em>blacklistd</em>, which we put into <em>pf.conf</em> in the previous section. If you want separate blacklists to use different anchors, you can define an anchor name in this field; otherwise, just use the wildcard for the default.</p>
<p class="indent">If you start a name with a hyphen (<code>-</code>), it means “use an anchor with the default name prepended.”</p>
<pre>ssh             stream  *       *               -ssh       3       24h</pre>
<p class="indent">This entry adds any new blacklist rules to an anchor called <em>blacklistd-ssh</em>.</p>
<p class="indent">Using a slash (<code>/</code>) in the name field and the length of the netmask tells blacklistd to block entire subnets using prefix notation.</p>
<pre>22              stream  tcp       *               */24    3       24h</pre>
<p class="indent">When one host in a network misbehaves, we block everything in the adjoining /24. A /24 means very different things in IPv4 versus IPv6. Be sure to specify which protocol this rule applies to!</p>
<p class="indent">The sixth column, <em>nfail</em>, sets the number of login failures needed to blacklist the remote IP. Here, a wildcard means never. Our example rule sets a limit of 3, which is how many chances OpenSSH gives you to log in on one connection.</p>
<p class="indent"><span epub:type="pagebreak" id="page_473"/>The last column, <em>disable</em>, says how long to blacklist the host for. The default unit is seconds, but you can use <code>m</code>, <code>h</code>, and <code>d</code> for minutes, hours, and days, respectively. Our example rule is set to 24 hours.</p>
<p class="indent">So, with this rule in place, failing to authenticate to SSH three times will result in the client being blocked for 24 hours.</p>
<p class="indent">Once you have local rules set up, you can configure remote rules.</p>
<h5 class="h5" id="lev848"><strong>blacklistd.conf Remote Rules</strong></h5>
<p class="noindent">Use remote rules to specify how blacklistd varies its behavior depending on the remote host. Each of the fields in a remote rule is the same as that in the local rules, but how blacklistd uses them changes. Here’s a sample remote rule:</p>
<pre>[remote]<br/>203.0.113.128/25 *      *       *               =/25    =       48h</pre>
<p class="indent">The <em>address</em> column is an IP (either IPv4 or IPv6) address, a port, or both. This lets you set special rules for a specific remote address range. Our sample rule applies to the address range 203.0.113.128/25.</p>
<p class="indent">The <em>type</em>, <em>protocol</em>, and <em>owner</em> columns are interpreted identical to the local rules.</p>
<p class="indent">The <em>name</em> column gets interesting. The equal sign in a remote rule means “use the value from the local rule you’re matching.” This rule says to take the firewall rule name entry and add the network prefix /25 (a 255.255.255.128 netmask) to it. If a connection from this address range gets blacklisted, it will affect the entire subnet. If you put a PF anchor name here, the blacklistd adds rules for this address block to the named anchor. A wildcard reverts to the default table.</p>
<p class="indent">The <em>nfail</em> column lets you set a custom number of failures for this address. Maybe you want to offer that one customer that just can’t figure out how to type their password the first 30 times extra attempts to fail. Setting this column to an asterisk disables blocking.</p>
<p class="indent">The <em>disable</em> column lets you set a custom block time for this address block. Using a wildcard here disables blocking.</p>
<p class="indent">Remote rules let you enforce stricter limits on people you don’t like, while telling blacklistd(8) never to blacklist your office.</p>
<p class="indent">You can now start blacklistd. It won’t do anything, though, because programs don’t know they should complain to it. But once you configure them, it’ll be ready.</p>
<h4 class="h4" id="lev849"><strong><em>Configuring Blacklistd Clients</em></strong></h4>
<p class="noindent">FreeBSD includes a few blacklistd-aware clients. The two you’re most likely to use are ftpd(8) and sshd(8).</p>
<p class="indent">To enable blacklistd in your SSH server, add the following line to <em>/etc/ssh/sshd_config</em>.</p>
<pre>UseBlacklist yes</pre>
<p class="indent"><span epub:type="pagebreak" id="page_474"/>Restart sshd.</p>
<p class="indent">Enable blacklisting in ftpd(8) with the <code>-B</code> command line option, either in <em>/etc/inetd.conf</em> or in the standalone process’s <em>/etc/rc.conf</em> flags.</p>
<pre>ftpd_flags="-B"</pre>
<p class="indent">These programs will now whinge to blacklistd(8) any time someone fails to log in.</p>
<h4 class="h4" id="lev850"><strong><em>Managing Blacklistd</em></strong></h4>
<p class="noindent">Blacklisting annoying clients that have no right to poke at your services cuts down on the amount of log analysis you need to do, but you’ll probably want to see exactly what the blacklist is blocking. You want blacklistctl(8).</p>
<p class="indent">The blacklistctl(8) program has only one function: to display addresses and networks blocked by blacklistd. You always want the <code>blacklistctl dump</code> command.</p>
<p class="indent">By default, <code>blacklistctl dump</code> shows hosts that are in the list of candidates to be blocked but are not yet blocked. Add the <code>-b</code> flag to see all blocked hosts.</p>
<pre># <span class="codestrong1">blacklistctl dump -b</span><br/>        address/ma:port id      nfail   last access<br/>  203.0.113.128/25:22   OK      6/3     2018/08/28 16:30:09</pre>
<p class="indent">Here, we see that the address range 203.0.113.128/25 attempted 6 out of 3 permitted login attempts. How did it achieve this? SSH lets a client try multiple logins on a single TCP/IP connection. Blacklisting doesn’t stop a live connection. The last time the guilty host attempted to access this service was at the date shown in <code>last access</code>.</p>
<p class="indent">You might find the time remaining more useful than the time of last access. Add the <code>-r</code> flag.</p>
<pre># <span class="codestrong1">blacklistctl dump -br</span><br/>        address/ma:port id      nfail   remaining time<br/>  203.0.113.128/25:22   OK      4/3     36s</pre>
<p class="indent">Too soon, this subnet will be free to harass and harry my innocent SSH server. Maybe I need to increase the blacklist duration.</p>
<h4 class="h4" id="lev851"><strong><em>De-Blacklisting</em></strong></h4>
<p class="noindent">Despite your best efforts, one day you’ll need to pull an address from the blacklist before it expires naturally. The blacklistctl(8) program offers no way to do this: you must manually delete the address from the PF table. Doing so requires understanding how blacklistd manages addresses inside PF.</p>
<p class="indent">Each blocked port has a child anchor inside the blacklistd anchor. This anchor is named after the port. The child anchor that blocks port 22 would <span epub:type="pagebreak" id="page_475"/>be called <em>blacklistd/22</em>. Inside that child anchor, you’ll find a table containing the blocked addresses. The table is named <em>port</em>, followed by the port number. Hosts that can no longer connect to port 22 appear in a table called <em>port22</em>.</p>
<p class="indent">Here, I use the packet filter control program pfctl(8) to examine the contents of the port22 table inside child anchor blacklistd/22. I’m not going to explain all of this; just substitute your table and child anchor names. (Read Hansteen’s <em>The Book of PF</em> to let anchors drag you under. Far, far under.)</p>
<pre># <span class="codestrong1">pfctl -a blacklistd/22 -t port22 -T show</span><br/>--<span class="codeitalic1">snip</span>--<br/>   203.0.113.128/25<br/>--<span class="codeitalic1">snip</span>--</pre>
<p class="indent">Yes, our problem address is in there. Removing it requires a fairly arcane pfctl(8) command.</p>
<pre># <span class="codestrong1">pfctl -a blacklistd/22 -t port22 -T delete 203.0.113.128/25</span></pre>
<p class="indent">The blacklist is maintained in a database outside of PF, though, so the blacklisted address will still show up in blacklistctl(8). That database entry will eventually expire harmlessly. If the host misbehaves again, it will get blocked again.</p>
<h3 class="h3" id="lev852"><strong>Public-Key Encryption</strong></h3>
<p class="noindent">Many server daemons rely upon public-key encryption to ensure confidentiality, integrity, and authenticity of communications. Many different internet services also use public-key encryption. You need a basic grasp of public-key encryption to run services like secure websites (https) and secure POP3 mail (pop3ssl). If you’re already familiar with public-key encryption, you can probably skip this section. If not, gird your loins for a highly compressed introduction to the topic.</p>
<p class="indent">Encryption systems use a key to transform messages between readable (cleartext) and encoded (ciphertext) versions. Although the words <em>cleartext</em> and <em>ciphertext</em> include the word <em>text</em>, they aren’t restricted to text; they can also include graphics files, binaries, and any other data you might want to send.</p>
<p class="indent">All cryptosystems have three main purposes: integrity, confidentiality, and nonrepudiation. <em>Integrity</em> means that the message hasn’t been tampered with. <em>Confidentiality</em> means that the message can be read only by the intended audience. And <em>nonrepudiation</em> means that the author can’t later claim that he or she didn’t write that message.</p>
<p class="indent">Older ciphers relied on a single key, and anyone with the key could both encrypt and decrypt messages. You might have had to do a lot of work to transform the message, as with the Enigma engine that drove the Allies nuts during World War II, but the key made the transformation possible. A typical example is any code that requires a key or password. The one-time message pads popular in spy novels are the ultimate single-key ciphers, impossible to break unless you have that exact key.</p>
<p class="indent"><span epub:type="pagebreak" id="page_476"/>Unlike single-key ciphers, public-key (or asymmetric) encryption systems use two keys: a private key and a public key. Messages are encrypted with one key and decrypted with the other, and digital signatures ensure the message isn’t tampered with en route. The math to explain this is really quite horrendous, but it does work—just accept that really, really large numbers behave really, really oddly. Generally, the key owner keeps the private key secret but hands the public key out to the world at large, for anyone’s use. The key owner uses the private key, while everyone else uses the public key. The key owner can encrypt messages that anyone can read, while anyone in the public can send a message that only the key owner can read.</p>
<p class="indent">Public-key cryptography fills our need for integrity, confidentiality, and nonrepudiation. If an author wants anyone to be able to read his message, while ensuring that it isn’t tampered with, he can encrypt the message with his private key. Anyone with the public key (that is, the world) can read the message, but tampering with the message renders it illegible. (Depending on the use, he might choose to sign the message digitally instead.)</p>
<p class="indent">Encrypting messages this way also ensures that the author of the message has the private key. If someone wants to send a message that can be read only by a particular person, he can encrypt the message with the desired audience’s public key. Only the person with the matching private key can read the message.</p>
<p class="indent">This works well so long as the private key is kept private. Once the private key is stolen, lost, or made public, the security is lost. A careless person who has his private key stolen could even find others signing documents for him. Be careful with your keys, unless you want to learn that someone used your private key to order half a million dollars’ worth of high-end graphics workstations and have them overnighted to an abandoned-house maildrop in inner-city Detroit.<sup><a href="footnote.xhtml#ch19fn3" id="ch19fn3a">3</a></sup></p>
<p class="indent">The standard toolkit for all of these operations is OpenSSL.</p>
<div class="sidebar">
<p class="sidebart"><strong>WHY OPENSSL?</strong></p>
<p class="spara">For many years, OpenSSL was the only choice for an encryption library. Today’s newer alternatives, although probably more reliable, don’t meet FreeBSD’s long-term support model. The most obvious replacement, LibreSSL, supports each release for only one year. Until an encryption toolkit is both reliable and can be upgraded throughout the course of a FreeBSD release’s lifespan, OpenSSL won’t be replaced.</p>
</div>
<h4 class="h4" id="lev853"><span epub:type="pagebreak" id="page_477"/><strong><em>OpenSSL</em></strong></h4>
<p class="noindent">FreeBSD includes the OpenSSL toolkit for handling public-key cryptography. OpenSSL lets you perform a full range of encryption operations. While many programs use OpenSSL functionality, the sysadmin doesn’t need OpenSSL directly very often.</p>
<p class="indent">While OpenSSL works fine out of the box, I find it worthwhile to set a few defaults to make my life easier down the road. Configure OpenSSL with the file <em>/etc/ssl/openssl.cnf</em>. Almost all of the settings in this file are correct as they are, and you shouldn’t change them unless you’re a cryptographer. The few things useful to change are the defaults for generating cryptographic signatures. Each default value is marked by the string <code>_default</code>. You’d be most interested in the following settings for common OpenSSL operations, which I’ve adjusted to fit my needs:</p>
<pre><span class="ent">➊</span> countryName_default            = US<br/><span class="ent">➋</span> stateOrProvinceName_default    = Michigan<br/><span class="ent">➌</span> 0.organizationName_default     = Burke and Hare Word Mine, LLC</pre>
<p class="indent">The <code>countryName_default</code> <span class="ent">➊</span> is the two-letter code for your nation—in my case, <code>US</code>. The <code>stateOrProvinceName_default</code> <span class="ent">➋</span> is the name of your local state and can be of any length. I would set this to <code>Michigan</code>. The <code>0.organization</code><code>Name_default</code> field <span class="ent">➌</span> is your company name. If I’m buying a signed certificate, I’d put the same thing here that I want to appear on the certificate. If I’m just testing how programs work with SSL and don’t have a real company name, I might use the name of the company I work for or something that I make up.</p>
<p class="indent">The following values don’t show up in <em>openssl.cnf</em>, but if you set them, they appear as defaults in the OpenSSL command prompts. I find these useful, even though they change more frequently than the previous defaults—they remind me of the correct format of these answers, if nothing else.</p>
<pre><span class="ent">➊</span> localityName_default            = Detroit<br/><span class="ent">➋</span> organizationalUnitName_default  = Pen-Monkey Division<br/><span class="ent">➌</span> commonName_default              = www.michaelwlucas.com<br/><span class="ent">➍</span> emailAddress_default            = mwlucas@michaelwlucas.com</pre>
<p class="indent">The <code>localityName_default</code> <span class="ent">➊</span> is the name of your city. The <code>organizationalUnitName_default</code> <span class="ent">➋</span> is the part of your company this certificate is for. One of the most commonly misunderstood values in OpenSSL, <code>commonName_default</code> <span class="ent">➌</span>, is the hostname of the machine this certificate is for, as it appears in reverse DNS. Remember, reverse DNS isn’t necessarily the same as the hostname! Your web server might have a nice friendly name, but the hosting company might assign it a totally different name in reverse DNS. Finally, <code>emailAddress_default</code> <span class="ent">➍</span> is the email address of the site administrator.</p>
<p class="indent">These values all show up in prompts in the OpenSSL command as default choices. Setting them in the configuration file will save you annoyance later.</p>
<h4 class="h4" id="lev854"><span epub:type="pagebreak" id="page_478"/><strong><em>Certificates</em></strong></h4>
<p class="noindent">One interesting thing about public-key encryption is that the author and the audience don’t have to be people. They can be programs. Secure Shell (SSH) and the Secure Sockets Layer (SSL) are two different ways programs can communicate without fear of intruders listening in. Public-key cryptography is a major component of the <em>digital certificates</em> used by secure websites and secure mail services. When you open Firefox to buy something online, you might not realize that the browser is frantically encrypting and decrypting web pages. This is why your computer might complain about “invalid certificates;” someone’s public key has either expired or the certificate is self-signed. Today’s protocols encrypt and decrypt with <em>Transport Layer Security (TLS)</em> and use <em>TLS certificates</em>.</p>
<div class="sidebar">
<p class="sidebart"><strong>SSL VS. TLS</strong></p>
<p class="spara">You hear about SSL all the time, but it’s most often incorrect. Today, Transport Layer Security (TLS) has mostly replaced SSL. Most uses of the term <em>SSL</em> are lingering remnants. Generally speaking, internet-facing sites should use TLS version 1.1 or better. TLS version 1.0 is only weakly protected. Traffic secured by any version of the SSL protocol isn’t secured.</p>
</div>
<p class="indent">Many companies, such as VeriSign, provide a public-key signing service. These companies are called <em>Certificate Authorities (CAs)</em>, as they provide <em>TLS certificates</em>. Other companies that need a certificate signed provide proof of their identity, such as corporate papers and business records, and those public-key signing companies sign the applicant’s certificate with their CA certificate. By signing the certificate, the CA says, “I have inspected this person’s credentials and he, she, or it has proven their identity to my satisfaction.” They’re not guaranteeing anything else, however. A TLS certificate owner can use the certificate to run a website that sells fraudulent or dangerous products or use it to encrypt a ransom note. Signed TLS certificates guarantee certain types of technical security, not personal integrity or even unilateral technical security. Certificates don’t magically apply security patches for you.</p>
<p class="indent">Web browsers and other certificate-using software include certificates for the major CAs. When the browser receives a certificate signed by a CA, it recognizes the certificate as legitimate. Essentially, the web browser says, “I trust the Certificate Authority, and the Certificate Authority trusts this company, so I will trust the company.” So long as you trust the CA, everything works.</p>
<p class="indent">The package <code>ca_root_nss</code> contains the CA certificates recognized by the Mozilla Project. If a piece of software fails attempting to validate certificates, make sure you installed this package.</p>
<p class="indent"><span epub:type="pagebreak" id="page_479"/>Most CAs are big commercial companies. No matter the size of your organization, though, I encourage you to investigate Let’s Encrypt (<em><a href="https://www.letsencrypt.org/">https://www.letsencrypt.org/</a></em>). Let’s Encrypt is a CA that provides free, globally valid TLS certificates.</p>
<p class="indent">Using a certificate that’s not signed by any CA is perfectly fine for testing. It might also suffice for applications within a company, where you can install the certificate in the client web browser or tell your users to trust the certificate. We’ll look at both ways.</p>
<p class="indent">Both uses of the certificate require a host key.</p>
<h5 class="h5" id="lev855"><strong>TLS Host Key</strong></h5>
<p class="noindent">Both signed and self-signed certificates require a private key for the host. The host key is just a carefully crafted random number. The following command creates a 2,048-bit host key and places it in the file <em>host.key</em>:</p>
<pre># <span class="codestrong1">openssl genrsa 2048 &gt; host.key</span></pre>
<p class="indent">You’ll see a statement that OpenSSL is creating a host key and dots crossing the screen as key generation proceeds. In only a few seconds, you’ll have a file containing a key. The key is a plaintext file that contains the words <code>BEGIN RSA PRIVATE KEY</code> and a bunch of random characters.</p>
<p class="indent">Protect your host key! Make it owned by root and readable only by root. Once you place your certificate in production, anyone who has that key can use it to eavesdrop on your private communications.</p>
<pre># <span class="codestrong1">chown root host.key</span><br/># <span class="codestrong1">chmod 400 host.key</span></pre>
<p class="indent">Place this host key in a directory with the same permissions that we placed on the key file itself.</p>
<h5 class="h5" id="lev856"><strong>Create a Certificate Request</strong></h5>
<p class="noindent">You need a certificate request for either a signed or self-signed certificate. We don’t do much with OpenSSL, so we won’t dissect this command. Go to the directory with your host key and enter this verbatim:</p>
<pre># <span class="codestrong1">openssl req -new -key host.key -out csr.pem</span></pre>
<p class="indent">In response, you’ll see instructions and then a series of questions. By hitting <small>ENTER</small>, you’ll take the default answers. If you’ve configured OpenSSL, the default answers are correct.</p>
<pre><span class="ent">➊</span> Country Name (2 letter code) [US]:<br/><span class="ent">➋</span> State or Province Name (full name) [Michigan]:<br/><span class="ent">➌</span> Locality Name (eg, city) [Detroit]:<br/><span class="ent">➍</span> Organization Name (eg, company) [Burke and Hare Word Mine, LLC]:<br/><span class="ent">➎</span> Organizational Unit Name (eg, section) [Pen-Monkey Division]:<br/><span epub:type="pagebreak" id="page_480"/><span class="ent">➏</span> Common Name (eg, YOUR name) [www.michaelwlucas.com]:<br/><span class="ent">➐</span> Email Address [mwlucas@michaelwlucas.com]:</pre>
<p class="indent">The two-letter code for the country <span class="ent">➊</span> is defined in the ISO 3166 standard, so a quick web search will find this for you. If you don’t know the state <span class="ent">➋</span> and city <span class="ent">➌</span> you live in, ask someone who occasionally leaves the server room. The organization name <span class="ent">➍</span> is probably your company, and you list the department or division name <span class="ent">➎</span> as well. If you don’t have a company, list your family name or some other way to uniquely identify yourself, and for a self-signed certificate, you can list anything you want. Different CAs have different standards for noncorporate entities, so check the CA’s instructions.</p>
<p class="indent">The common name <span class="ent">➏</span> is frequently misunderstood. It’s not your name; it’s the name of the server as shown in reverse DNS. You must have a server name here, or the request will be useless.</p>
<p class="indent">I suggest using a generic email address <span class="ent">➐</span> rather than an individual’s email address. In this case, I <em>am</em> <a href="http://michaelwlucas.com">michaelwlucas.com</a>, so I might as well use my address. You don’t want your organization’s certificates tied to an individual who might leave the company for whatever reason.</p>
<pre>   Please enter the following 'extra' attributes<br/>   to be sent with your certificate request<br/><span class="ent">➊</span> A challenge password []:<br/><span class="ent">➋</span> An optional company name []:</pre>
<p class="indent">The challenge password <span class="ent">➊</span> is also known as a <em>passphrase</em>. Again, keep this secret because anyone with the passphrase can use your certificate. Use of a certificate passphrase is optional, however. If you use one, you must type it when your server starts. That means that if your web server crashes, the website won’t work until someone enters the passphrase. While passphrase use is highly desirable, this might be unacceptable. Hit <small>ENTER</small> to use a blank passphrase.</p>
<p class="indent">You’ve already entered quite a few company names, so a third <span class="ent">➋</span> is probably unnecessary.</p>
<p class="indent">Once you return to a command prompt, you’ll see the file <em>csr.pem</em> in the current directory. It looks much like your host key, except that the top line says <code>BEGIN CERTIFICATE REQUEST</code> instead of <code>BEGIN RSA PRIVATE KEY</code>.</p>
<p class="indent">Submit <em>csr.pem</em> to your Certificate Authority, who will return the actual certificate. I recommend saving the certificate in a file named after the host, such as <em>www.mwl.io.crt</em>. This signed certificate is good for any TLS service, including web pages, pop3ssl, or any other TLS-capable daemon.</p>
<p class="indent">Some CAs require you use an intermediate certificate with your cert. While most daemons have a configuration option to specify an intermediate certificate, if yours doesn’t, you can append the signed certificate to the end of the intermediate cert.</p>
<h5 class="h5" id="lev857"><strong>Sign a Certificate Yourself</strong></h5>
<p class="noindent">A self-signed certificate is technically identical to a signed certificate, but it’s not submitted to a Certificate Authority. Instead, you provide the signature <span epub:type="pagebreak" id="page_481"/>yourself. Most customers won’t accept a self-signed certificate on a production service, but it’s perfectly suitable for testing. To sign your own CSR, run the following:</p>
<pre># <span class="codestrong1">openssl x509 -req -days</span><span class="ent">➊</span><span class="codestrong1">365 -in csr.pem -signkey host.key \<br/>-out</span><span class="ent">➋</span><span class="codestrong1">selfsigned.crt</span><br/>Signature ok<br/>subject=/C=US/ST=Michigan/L=Detroit/O=Burke and Hare Word Mine, LLC/OU=Pen-<br/>Monkey Division/CN=michaelwlucas.com/emailAddress=mwlucas@michaelwlucas.com<br/>Getting Private key<br/>#</pre>
<p class="indent">That’s it! You now have a self-signed certificate good for 365 days <span class="ent">➊</span> in the file <em>selfsigned.crt</em> <span class="ent">➋</span>. You can use this key exactly like a signed certificate, so long as you’re willing to ignore the warnings your application displays.</p>
<p class="indent">If you sign your own certificates, client software generates warnings that the “certificate signer is unknown.” This is expected—after all, people outside my office have no idea who Michael W. Lucas is or why he’s signing web certificates. For some reason, people trust Symantec and other big-company CAs. I’m trusted by the people who know me,<sup><a href="footnote.xhtml#ch19fn4" id="ch19fn4a">4</a></sup> but not trusted by the world at large. For this reason, don’t use self-signed certificates anywhere the public will see them because the warnings will confuse, annoy, or even scare them away.</p>
<p class="indent">But before you go drop any amount of money on a CA certificate, definitely check out Let’s Encrypt. It really will change your system administration practice.</p>
<h4 class="h4" id="lev858"><strong><em>TLS Trick: Connecting to TLS-Protected Ports</em></strong></h4>
<p class="noindent">I said we wouldn’t do much with OpenSSL, and that’s correct. There’s one facility the software offers that’s too useful to pass up, however, and once you know it, you’ll use this one trick at least once a month and be glad you have it.</p>
<p class="indent">Throughout this book, we test network services by using telnet(1) to connect to the daemon running on that port and issuing commands. This works well for plaintext services such as SMTP, POP3, and HTTP. It doesn’t work for encrypted services such as HTTPS. You need a program to manage the encryption for you when you connect to these services. OpenSSL includes the <code>openssl s_client</code> command, which is intended for exactly this sort of client debugging. While you’ll see a lot of cryptographic information, you’ll also get the ability to issue plaintext commands to the daemon and view its responses. Use the command <code>openssl s_client -connect</code> with a hostname and port number, separated by a colon. Here, we connect to the secure web server at <em><a href="http://www.absolutefreebsd.com">www.absolutefreebsd.com</a></em>:</p>
<pre># <span class="codestrong1">openssl s_client -connect www.michaelwlucas.com:443</span><br/>CONNECTED(00000003)<br/>depth=2 O = Digital Signature Trust Co., CN = DST Root CA X3<br/><span epub:type="pagebreak" id="page_482"/>verify return:1<br/>depth=1 C = US, O = Let's Encrypt, CN = Let's Encrypt Authority X3<br/>--<span class="codeitalic1">snip</span>--</pre>
<p class="indent">You’ll see lots of stuff about chains of trust and limitations of liability, as well as lines and lines of the random-looking digital certificates. After all that, however, you’ll see a blank line with no command prompt. You’re speaking directly to the server daemon. As this is a web server, let’s try an HTTP command:</p>
<pre><span class="codestrong1">GET</span> /</pre>
<p class="indent">The system responds with:</p>
<pre>HTTP/1.1 400 Bad Request</pre>
<p class="indent">The HTTP protocol has changed since the last time I tried this, I guess. But I’m definitely connected to the web server. The network works.</p>
<p class="indent">Some of you are probably wondering why we encrypt the service if it’s so easy to talk to the encrypted service. The encryption doesn’t protect the daemon; it protects the data stream between the client and the server. TLS encryption prevents someone from eavesdropping your network conversation in transit—it doesn’t protect either the server or the client. TLS can’t save you if someone breaks into your desktop.</p>
<p class="indent">From this point on, I’ll assume that you understand this OpenSSL command and what happens when we use it.</p>
<div class="sidebar">
<p class="sidebart"><strong>HARDWARE CRYPTOGRAPHIC SUPPORT</strong></p>
<p class="spara">Most modern hardware has built-in encryption acceleration. Unfortunately, FreeBSD doesn’t include it in the default configuration. Hardware crypto acceleration reduces load on the CPU and probably accelerates encryption. The aesni(4) kernel module activates access to Intel’s hardware cryptographic accelerator. A driver for the new AMD accelerator is in development. In-kernel drivers affect only encryption that happens in the kernel, such as for encrypted disks and IPSec.</p>
</div>
<h3 class="h3" id="lev859"><strong>Global Security Settings</strong></h3>
<p class="noindent">FreeBSD supports many optional security settings. These settings change basic FreeBSD behavior, making it differ from the common Unix experience. Some other operating systems provide these settings by default, however, so they’re not unique to FreeBSD.</p>
<p class="indent"><span epub:type="pagebreak" id="page_483"/>Should you turn all these features on in the name of improved security? There’s no universally correct answer here. If restricting access to part of the system to the root account means that you’ll need to give more people root access, maybe you shouldn’t impose that restriction. A couple of these should be activated on all systems, though.</p>
<h4 class="h4" id="lev860"><strong><em>Install-Time Options</em></strong></h4>
<p class="noindent">The FreeBSD installer provides an option for enabling each of these settings on first boot. You can enable and disable them later with the given sysctl setting.</p>
<p class="indent">Many of these features are especially useful on servers that don’t have many users. If your application server doesn’t have unprivileged users other than those used by applications, you should probably enable features that restrict unprivileged users. If you have unprivileged users, though, consider the situation more closely. Most of my unprivileged users<sup><a href="footnote.xhtml#ch19fn5" id="ch19fn5a">5</a></sup> shouldn’t be looking at server processes or other users, so I lock them down.</p>
<p class="noindentt"><strong>Hiding Other UIDs’ Processes</strong></p>
<p class="hang">Normally, commands like <code>ps -ax</code> display all processes running on the system. When you set the sysctl <code>security.bsd.see_other_uids</code> to 0, users can see only their own processes. Root can see all processes, no matter how you set this.</p>
<p class="noindentt"><strong>Hiding Other GIDs’ Processes</strong></p>
<p class="hang">Similarly, users can normally see processes owned by other groups. Disable that ability by setting the sysctl <code>security.bsd.see_other_gids</code> to 0. Again, root can see every process, no matter how this is set.</p>
<p class="noindentt"><strong>Hiding Jailed Processes</strong></p>
<p class="hang">Users on a host can usually see all processes running in jails. By setting <code>security.bsd.see_jail_proc</code> to 0, unprivileged nonjailed users can’t see jailed processes. This feature appeared in FreeBSD 12.</p>
<p class="noindentt"><strong>Hide Message Buffer</strong></p>
<p class="hang">Unprivileged users can normally see the system message buffer, available through dmesg(8). Disable that access by setting the sysctl <code>security</code><code>.bsd.unprivileged_read_msgbuf</code> to 0.</p>
<p class="noindentt"><strong>Disable Process Debugging</strong></p>
<p class="hang">A debugger can tell users a whole bunch of useful information. Setting <code>security.bsd.unprivileged_proc_debug</code> to 0 disallows unprivileged users from using the debugger on processes.</p>
<p class="noindentt"><strong>Randomize Process IDs</strong></p>
<p class="hang">Traditional Unix systems create process IDs in sequential order, allowing attackers a chance at guessing what the next PID will be. Randomize <span epub:type="pagebreak" id="page_484"/>process IDs by setting the sysctl <code>kern.randompid</code> to a random large integer. If you set it to 1, the kernel picks a fresh random number between 100 and 1,123 at each boot.</p>
<p class="noindentt"><strong>Clean /tmp</strong></p>
<p class="hang">All sensible Unix-like systems clean <em>/tmp</em> at boot to dispose of temporary files. Somewhere in the last few years, FreeBSD turned this behavior off by default. You might use tmpfs(5) for <em>/tmp</em>, which gets destroyed at every power-down. If your <em>/tmp</em> is on disk, though, well . . . as you’re all sensible and wholesome sysadmins, always set <code>clear_tmp_enable</code> to <code>YES</code> in <em>/etc/rc.conf</em>.</p>
<p class="noindentt"><strong>Disable Syslogd Networking</strong></p>
<p class="hang">By default, syslogd(8) creates a half-open socket on UDP port 514. Nobody can connect to this socket; it’s used only as a placeholder so nothing else binds to that port. Some people consider this half-open socket problematic. I’d say it’s a feature; you don’t want something else binding to port 514, claiming to be syslogd, and sending either worrisome or falsely soothing messages to your logging host. But to disable that half-open socket, set <code>syslogd_flags</code> to <code>-ss</code> in <em>/etc/rc.conf</em>.</p>
<p class="noindentt"><strong>Disable Sendmail</strong></p>
<p class="hang">A default FreeBSD install doesn’t accept email from the network, but it does run a sendmail(8) daemon to sent outgoing messages. To completely disable sending mail from this host, set <code>sendmail_enable</code> to <code>NONE</code> in <em>/etc/rc.conf</em>.</p>
<p class="hang1">Disabling outbound mail won’t prevent the daily, weekly, and monthly maintenance tasks from running. It’ll prevent you from receiving the output of those messages unless you log directly onto the host, however. For people with multiple hosts, disabling outbound mail is unwise. Disabling Sendmail makes sense if you use an alternative mail agent, such as dma(8) (see <a href="ch20.xhtml#ch20">Chapter 20</a>).</p>
<h4 class="h4" id="lev861"><strong><em>Secure Console</em></strong></h4>
<p class="noindent">Most Unix systems consider the physical console secure. Anyone who has access to the physical machine can do anything to the host that they want, including changing the root password. By changing all of the <em>/etc/ttys</em> entries that say <code>secure</code> to <code>insecure</code>, you tell FreeBSD to demand the root password even in single-user mode.<sup><a href="footnote.xhtml#ch19fn6" id="ch19fn6a">6</a></sup> This won’t prevent someone from physical access gaining access to your operating system, but it’ll mean that they’ll have to do slightly more work to subvert your machine. <em>Very</em> slightly more work.</p>
<h4 class="h4" id="lev862"><strong><em>Nonexecutable Stack and Stack Guard</em></strong></h4>
<p class="noindent">One basic exploit mitigation technique is the nonexecutable stack. Once a program is loaded into memory, each page of memory allocated to that program should be either writable or executable, but not both.</p>
<p class="indent"><span epub:type="pagebreak" id="page_485"/>A common exploit technique is to trick a program into writing information to memory and then executing that memory. An attacker might convince a program to write to a chunk of memory, but with the nonexecutable stack, the kernel won’t execute it.</p>
<p class="indent">The stack defaults to nonexecutable on modern versions of FreeBSD. The only reason to disable this is if you have a badly written program that relies on executing and writing the same chunk of memory. Most such defective software has been rightfully purged from the open source ecosystem in the last 15 years. If you’re very unlucky and can’t avoid running a program that can’t handle a nonexecutable stack, you can disable this by setting the sysctls <code>kern.elf32.nxstack</code> (for 32-bit programs) or <code>kern.elf64.nxstack</code> (for 64-bit programs) to 0.</p>
<p class="indent">Related to the nonexecutable stack, a stack guard page adds a random-sized shred of extra memory between parts of a program’s memory allocation. This makes it harder for an attacker to guess memory addresses. FreeBSD allocates a stack guard page by default, but you can turn it off by setting the sysctl <code>security.bsd.stack_guard_page</code> to 0.</p>
<h4 class="h4" id="lev863"><strong><em>Other Security Settings</em></strong></h4>
<p class="noindent">Most of FreeBSD’s other kernel-level security settings are available in the <code>security.bsd</code> sysctl tree. More get added every few months. Run <code>sysctl -d security.bsd</code> to display your hosts’ available options. I’ve described many of these earlier in this section, but you might find some of the others useful. Options include disabling the root account’s privileges (<code>security.bsd.suser_enabled</code>), allowing nonroot users to set an idle priority (<code>security.bsd.unprivileged_idprio</code>), and blocking unprivileged users from using mlock(2) (<code>security.bsd.unprivileged_mlock</code>). Take a look at the current options and see what might be useful.</p>
<h3 class="h3" id="lev864"><strong>Preparing for Intrusions with mtree(1)</strong></h3>
<p class="noindent">One of the worst things to happen to a sysadmin is something that makes him think that his system could’ve been penetrated. If you find mysterious files in <em>/tmp</em> or extra commands in <em>/usr/local/sbin</em>, or if things “just don’t feel right,” you’ll be left wondering whether someone has compromised your system. The worst thing about this feeling is that there’s no way to prove it hasn’t happened. A skilled attacker can replace system binaries with her own customized versions, so that her actions are never logged and your attempts to find her will fail. Having Sherlock Holmes examine your server with a magnifying glass is useless when the magnifying glass has been provided by the criminal and includes the special criminal-cloaking feature! People have even hijacked the system compiler so that freshly built binaries <span epub:type="pagebreak" id="page_486"/>include the hijacker’s backdoor.<sup><a href="footnote.xhtml#ch19fn7" id="ch19fn7a">7</a></sup> What makes matters worse is that computers do weird things all the time. Operating systems are terribly complicated, and applications are worse. Maybe that weird file in <em>/tmp</em> is something your text editor barfed up when you hit the keys too fast, or perhaps it’s a leftover from a sloppy intruder.</p>
<p class="indent">The <em>only</em> way to recover a compromised system is to reinstall it from scratch, restore the data from backup, and hope that the security hole that led to the compromise is fixed. That’s a thin hope, and doubt is so easy to acquire that many sysadmins eventually stop caring or lie to themselves rather than live with the constant worry.</p>
<p class="indent">Most intruders change files that already exist on the system. FreeBSD’s mtree(1) can record the permissions, size, dates, and cryptographic checksums of files on your system. (While freebsd-update(8) includes similar features, and you don’t have to gather data beforehand, it covers only the base system.) If you record these characteristics when your system is freshly installed, you have a record of what those files look like intact. When an intruder changes those files, a comparison will highlight the differences. When you have even the vaguest feeling you’ve been hacked, you can check that same information on the existing files to see whether any have changed.</p>
<h4 class="h4" id="lev865"><strong><em>Running mtree(1)</em></strong></h4>
<p class="noindent">The following command runs mtree(1) across your root partition and stores SHA512 and SHA256 cryptographic checksums, placing them in a file for later analysis:</p>
<pre># <span class="codestrong1">mtree</span><span class="ent">➊</span><span class="codestrong1">-x</span><span class="ent">➋</span><span class="codestrong1">-ic</span><span class="ent">➌</span><span class="codestrong1">-K sha512</span><span class="ent">➍</span><span class="codestrong1">-K sha256</span><span class="ent">➎</span><span class="codestrong1">-p /</span><span class="ent">➏</span><span class="codestrong1">-X /home/mwlucas/mtree-exclude &gt;</span><span class="ent">➐</span><span class="codestrong1">/tmp/mtree.out</span></pre>
<p class="indent">While you can use mtree(1) across the entire server, most people use <code>-x</code> <span class="ent">➊</span> to run it once per partition. You don’t want to record checksums on frequently changing files, such as the database partition on your database server. Collecting checksums on NFS mounts has the twin features of running really slowly and increasing network congestion. The <code>-ic</code> flag <span class="ent">➋</span> tells mtree to print its results to the screen, with each subsequent layer in the filesystem indented. This format matches the system mtree files in <em>/etc/mtree</em>. The <code>-K</code> flag accepts several optional keywords; in this case, we want to generate SHA512 checksums <span class="ent">➌</span> and SHA256 checksums <span class="ent">➍</span>. The <code>-p</code> flag <span class="ent">➎</span> tells mtree which partition to check. Almost every partition has files or directories that change on a regular basis and that you therefore don’t want to record checksums for. Use <code>-X</code> <span class="ent">➏</span> to specify an <em>exclusion file</em>, a file containing a list of paths not to match. Finally, redirect the output of this command to the file <em>/tmp/mtree.out</em> <span class="ent">➐</span>.</p>
<h4 class="h4" id="lev866"><span epub:type="pagebreak" id="page_487"/><strong><em>mtree(1) Output: The Spec File</em></strong></h4>
<p class="noindent">mtree(1)’s output is known as a specification, or <em>spec</em>. While this specification was originally intended for use in installing software, we’re using it to verify a software install. Your spec starts with comments showing the user who ran the command, the machine the command ran on, the filesystem analyzed, and the date. The first real entry in the spec sets the defaults for this host and begins with <code>/set</code>.</p>
<pre>/set type=file uid=0 gid=0 mode=0755 nlink=1 flags=uarch</pre>
<p class="indent">The mtree(1) program picked these settings as defaults based on its analysis of the files in the partition. The default filesystem object is a file, owned by UID 0 and GID 0, with permissions of 0755, with one hard link and the user archive flag. After that, every file and directory on the system has a separate entry. Here’s the entry for the root directory:</p>
<pre><span class="ent">➊</span>.        <span class="ent">➋</span>type=dir<span class="ent">➌</span>nlink=19<span class="ent">➍</span>time=1504101311.033742000</pre>
<p class="indent">This file is the dot (<code>.</code>) <span class="ent">➊</span>, or <em>the directory we’re in right now</em>. It’s a directory <span class="ent">➋</span>, and it has 19 hard links <span class="ent">➌</span> to it. This directory was modified 1,504,101,311.033742000 seconds into Unix epochal time <span class="ent">➍</span>. The Unix epoch began January 1, 1970.</p>
<div class="sidebar">
<p class="sidebart"><strong>EPOCHAL SECONDS AND REAL DATES</strong></p>
<p class="spara">Don’t feel like counting seconds since the epoch began? To convert epochal seconds into normal dates, run <code>date -r</code> seconds. Cut off the fraction at the end of mtree’s time, however; date(1) likes only whole seconds.</p>
</div>
<p class="indent">In some ways, the entry for the directory is rather boring. An intruder can’t realistically replace the directory itself, after all! Here’s an entry for an actual file in the root directory:</p>
<pre>.cshrc      mode=0644 nlink=2<span class="ent">➊</span>size=950 time=1499096179.000000000 \<br/><span class="ent">➋</span> sha256digest=20d2a78c9773c159bac1df5585227c7b64b6aab6b77bccadbe4c65f1be474e8c \<br/><span class="ent">➌</span> sha512=24d4330e327f75f10101cd7c0d6a5e59163336ade5b9eb04b0d96ea43d221c5eea4c71a89dfe85a...</pre>
<p class="indent">We see the filename and the same mode, link, and time information as in the root directory, but also get the file size <span class="ent">➊</span>. Additionally, there’s the SHA256 <span class="ent">➋</span> and SHA512 <span class="ent">➌</span> cryptographic hashes computed from the files.</p>
<p class="indent">While it’s theoretically possible for an intruder to craft a file that matches a particular cryptographic hash, and while cryptographers are constantly trying to find practical ways to create files that match arbitrary SHA256 and SHA512 checksums, it’s extremely unlikely that an intruder can create a fake file that matches both checksums, contains his backdoor, <span epub:type="pagebreak" id="page_488"/>and still functions well enough that the system owner won’t immediately notice a problem. By the time this happens, we will have additional checksum algorithms resistant to those methods and will switch to them.</p>
<h4 class="h4" id="lev867"><strong><em>The Exclusion File</em></strong></h4>
<p class="noindent">The exclusion file (given with <code>-X</code>) lists filesystems you don’t want mtree(1) to analyze. Lots of filesystems will change without malicious intervention. Log files and user home directories should change. Directories like <em>/tmp</em> and <em>/var/db/entropy better</em> change on a functional system. List each directory you don’t want checked on its own line in the exclusion file, with a leading dot.</p>
<pre>./tmp<br/>./var/db/entropy<br/>./var/log<br/>./usr/home</pre>
<p class="indent">Wait a day or so, and then run mtree(1) again to generate a new spec file. Differences between the two mtree files will let you improve your exclusion file. You’ll do the exact same thing when you suspect a system intrusion.</p>
<h4 class="h4" id="lev868"><strong><em>Saving the Spec File</em></strong></h4>
<p class="noindent">The spec file contains the information needed to verify the integrity of your system after a suspected intrusion. Leaving the spec file on the server you want to verify means that an intruder can edit the file and conceal his wrongdoing. You must not save the file on the system itself! Now and then someone will suggest that you checksum the mtree spec file but keep it on the server. That’s not useful; if someone tampers with the mtree file and the checksum, how would you know? Or worse—if someone tampered with the spec file and you caught it, you couldn’t tell what change had been made! Copy your spec file to a safe location, preferably on an offline media, such as a flash drive or an optical disk.</p>
<h4 class="h4" id="lev869"><strong><em>Finding System Differences</em></strong></h4>
<p class="noindent">When something raises your suspicions and you begin to think that you might have suffered an intrusion, create a new mtree spec file and compare it with the “known good” spec file you stored offline. Use mtree(1) to check for differences between spec files.</p>
<pre># <span class="codestrong1">mtree -f mtree.suspect -f mtree.good &gt; mtree.differences</span></pre>
<p class="indent">Every entry in the file is something that has changed. My exclusion file is finely tuned, eliminating files I expect to have changed. This particular run generates two lines of output.</p>
<pre>                bin/sh file<span class="ent">➊</span>size=161672<br/><span class="ent">➋</span> sha256digest=a4a85ca3563d8f3bda449711c6b591b37093e668fc136f8829eb188b955f56ab<br/><span epub:type="pagebreak" id="page_489"/><span class="ent">➌</span> sha512=011793e3e6cacd99b4261e0a0f3a0b9bd6a6842f3ccd55da1ce2070b568e3c49ae7b0e51d33bb59eff...<br/>                bin/sh file size=<span class="ent">➍</span>10489808<br/><span class="ent">➎</span> sha256digest=45856525d4251b43d68df1429cf1fe0f4adb6640f06d7f995aace5b7ca0c03c2<br/><span class="ent">➏</span> sha512=a4f0e83e5fb12d615721fd7d57cb6a120068d1aa71fc305b7b86927391f33bec822cf14ce8a8a9db14...</pre>
<p class="indent">The file <em>/bin/sh</em> <span class="ent">➊</span> has changed size <span class="ent">➍</span> between mtree runs. This isn’t good. Also, note the two different SHA256 hashes <span class="ent">➋</span> <span class="ent">➎</span> and the two different SHA512 hashes <span class="ent">➌</span> <span class="ent">➏</span>. Don’t hit the panic button yet, but start asking your fellow sysadmins pointed, hard questions. If you can’t get a good answer as to why this binary changed, you might look for your installation media.</p>
<p class="indent">Or, perhaps you need to update your exclusion file. But if <em>/bin/sh</em> changed, probably not.</p>
<h3 class="h3" id="lev870"><strong>Monitoring System Security</strong></h3>
<p class="noindent">So, you think your server is secure. Maybe it is . . . for now.</p>
<p class="indent">Unfortunately, there’s a class of intruders with nothing better to do than to keep up on the latest security holes and try them out on systems they think might be vulnerable. Even if you read <em>FreeBSD-security</em> religiously and apply every single patch, you still might get hacked one day. While there’s no way to be absolutely sure you haven’t been hacked, the following hints will help you find out when something does happen:</p>
<ul>
<li class="noindent">Be familiar with your servers. Run <code>ps -axx</code> on them regularly, and learn what processes normally run on them. If you see a process you don’t recognize, investigate.</li>
<li class="noindent">Examine your open network ports with <code>netstat -na</code> and <code>sockstat</code>. What TCP and UDP ports should your server be listening on? If you don’t recognize an open port, investigate. Perhaps it’s innocent, but it might be an intruder’s backdoor.</li>
<li class="noindent">Unexplained system problems are hints. Many intruders are ham-fisted klutzes with poor sysadmin skills, who use click-and-drool attacks. They’ll crash your system and think that they’re the cyber incarnation of Samuel L. Jackson.</li>
<li class="noindent">Truly skilled intruders not only clean up after themselves but also ensure that the system has no problems that might alert you. Therefore, systems that are unusually stable are also suspicious.</li>
<li class="noindent">Unexplained reboots might indicate someone illicitly installing a new kernel. They might also be a sign of failing hardware or bad configuration, so investigate them anyway.</li>
<li class="noindent">FreeBSD sends you emails every day giving basic system status information. Read them. Save them. If something looks suspicious, investigate. Look at old messages to see when something has changed.</li>
</ul>
<p class="indent">I particularly recommend the <code>lsof</code> package to increase your familiarity with your system. The <code>lsof</code> program lists all open files on your system. Reading lsof(8) output is an education in and of itself; you probably had no <span epub:type="pagebreak" id="page_490"/>idea that your web server opened so much crud. Seeing strange files open indicates either that you’re not sufficiently familiar with your system or that someone’s doing something improper.</p>
<h3 class="h3" id="lev871"><strong>Package Security</strong></h3>
<p class="noindent">The FreeBSD Project provides a database of security vulnerabilities in the ports and packages system. This database is made available in <em>Vulnerability and eXposure Markup Language (VuXML)</em>. When someone volunteers to maintain a port, they’re also volunteering to watch out for security problems with that port.</p>
<p class="indent">An internet-connected FreeBSD host with pkg(8) installed downloads the latest VuXML file during the periodic(8) run (see <a href="ch21.xhtml#ch21">Chapter 21</a>) and stores it in <em>/var/db/pkg/vuln.xml</em>. It then compares the installed packages with that database. If one of your packages has a vulnerability, you’ll be notified in the daily status email. (You are reading your daily status emails, right?)</p>
<p class="indent">If your packages are insecure, upgrade them as per <a href="ch15.xhtml#ch15">Chapter 15</a>.</p>
<p class="indent">If need be, you can set a different location to fetch the <em>vuln.xml</em> file with the <code>VULNXML_SITE</code> option in <em>pkg.conf</em>. You might do this if you maintain your own package repository and vulnerability databases.</p>
<h3 class="h3" id="lev872"><strong>If You’re Hacked</strong></h3>
<p class="noindent">After all this, what do you do if your system is hacked? There’s no easy answer. Huge books are written on the subject. Here are a few general suggestions, however.</p>
<p class="indent">First and foremost: A hacked system can’t be trusted. If someone has gained root access on your internet server, he could have replaced any program on the system. Even if you close the hole he broke in through, he could have installed a hacked version of login(8) that sends your username and password to an IRC channel somewhere every time you log in. Do not trust this system. An upgrade can’t cleanse it, as even freebsd-update(8) and the compiler are suspect.</p>
<p class="indent">While rootkit-hunting software might help you verify the presence of intruders, nothing can verify that the intruder <em>isn’t</em> there. Feel free to write <em><a href="mailto:FreeBSD-security@FreeBSD.org">FreeBSD-security@FreeBSD.org</a></em> for advice. Describe what you’re seeing and why you think you’re hacked. Be prepared for the ugly answer, though: completely reinstall your computer from known secure media, and restore your data from backup. You did read <a href="ch05.xhtml#ch05">Chapter 5</a>, right?</p>
<p class="indent">Good security practices reduce your chances of being hacked, just as safe driving reduces your chances of being in a car wreck. Eventually you’ll total your wheels anyway and wonder why you bothered. Good luck!</p>
</body></html>