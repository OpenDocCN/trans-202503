- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Text and Files
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sketch 34: Fonts, Sizes, Character Properties'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When text is drawn on the screen, there are many ways to draw each character.
    The size, weight, orientation, and style can vary widely. A font specifies a particular
    size, weight, and style of a typeface. Fonts are saved as files that contain the
    instructions for drawing each character. Bold, italic, normal, and each important
    size are individual files. The font name, a style, and a size are frequently part
    of the filename.
  prefs: []
  type: TYPE_NORMAL
- en: Processing allows many fonts, but each one must be set up in advance as a file
    using the Tools menu. Select **Tools**▶**Create Font** to open a font-creation
    window, within which you can choose the font name, style, and size, as shown in
    [Figure 34-1](#figure34-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f034001](Images/f034001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 34-1: Setting up a font'
  prefs: []
  type: TYPE_NORMAL
- en: Select CourierNewPS-BoldMT with size 48 and click **OK** to create a file named
    *CourierNewPS-BoldMT-48.vlw* inside a local directory named *data*. You can repeat
    this process as often as needed, creating many font files. You need font files
    in order to load and use fonts in Processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a font is a somewhat involved process. You need to first create a variable
    of type `PFont` (Processing font) for each font desired, and then load the font
    using the `loadFont()` function 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To establish a font as the one to use, call `textFont()` with the font variable
    and desired size: `textFont(font1, 48)` 2.The size is specified in pixels, not
    the standard for a font, which is points. Finally, you can always change the font
    size by calling `textSize(size)` 3.'
  prefs: []
  type: TYPE_NORMAL
- en: This sketch loads the Courier Bold 48 font and establishes it. Then it draws
    the string “Hello” in sizes varying from 2 pixels to 55 pixels, changing by one
    pixel size each time `draw()` is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 35: Scrolling Text'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A news scroll is a common feature of television news and weather stations. It
    is a summary of stories that scrolls from right to left across the bottom of the
    screen as other things are happening on the rest of the screen. It’s common to
    see stock prices displayed in this way as well. How could we do this in a Processing
    sketch window?
  prefs: []
  type: TYPE_NORMAL
- en: First, the text for a particular item has an x-coordinate where it is drawn,
    and it will be drawn using the `text()` function. The y-coordinate is constant
    and will be somewhere near the bottom of the screen. In this sketch the screen
    is 400×200 and the y-coordinate for the text is 190\. The x-coordinate changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The text to be displayed should start near the right side of the screen; for
    example, at `width-10` pixels 2. Each frame displayed should move the text to
    the left, so `draw()` will subtract one from `x` each time it is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There will usually be more than one message in the scroll. The first message
    could disappear before the second one is displayed, but this is unusual for a
    text scroll. Another idea is to have multiple scroll strings being drawn next
    to each other, moving in lockstep. So the strings themselves are in an array called
    `headlines` 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have just two strings. Each one has an index into the array that
    accesses the strings (`i1` and `i2`) and x position (`x1`, `x2`). If the first
    string, `headlines[i1]`, is drawn at location `x1`, the second string should be
    drawn at location `x1` plus the number of pixels in the string `i1` plus a small
    space. In Processing terms, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`textWidth()` is a function that takes a string as a parameter and, using the
    current font size, returns the width in pixels of that string when drawn. The
    value 10 is the small space. When the first string disappears on the left of the
    screen, its plotted position plus its length will be less than 0 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, a new string (that is, the next index) should be obtained and
    positioned to the right of the second string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The same happens when the second string disappears on the left.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 36: Text Animation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Animating text can create an interesting effect. It has been used in commercials
    and by artists in the past, but it has never been as easy to do as it is now.
    A string can be drawn along a curved path, even a moving curved path; characters
    in the string can change in orientation, size, color, or even font. Motion can
    even vary according to user input, either by following the mouse or moving as
    a result of audio or video input.
  prefs: []
  type: TYPE_NORMAL
- en: A key to animating text is to access each character in the string using the
    `charAt()` function. The first character in the string `str` is returned by `str.charAt(0)`,
    the second character is `str.charAt(1)`, and so on. In this way, each character
    can be accessed individually and be made to behave in a different way from other
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: This sketch causes the word *Processing* to explode, the component letters flying
    in all directions at different speeds; character sizes change too. Each character
    has a distinct position (arrays `x` and `y`), velocity (arrays `dx` and `dy`),
    and size (array `size`) 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, we draw the word *Processing* neatly in the center of the screen
    as a set of individual characters 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After a few seconds (60 frames) 3, we change the position of each character
    every frame 4, thus moving them, and we adjust individual sizes too. The characters
    move off in random directions, eventually disappearing from the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 37: Inputting a Filename'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the sketches developed in this book so far use filename constants when
    reading an image. To be more flexible, most programs allow the user to enter a
    command or filename, even a number, from the keyboard, and that user input directs
    the code to use specific data. This is our next task—to ask the user to enter
    an image filename from the keyboard and display that image in the sketch window.
  prefs: []
  type: TYPE_NORMAL
- en: We already know that the `keyPressed()` function is called whenever the user
    presses a key, and the variable `key` contains the character that represents the
    key that was pressed, at least for letters and numbers. Other keys, like arrow
    keys, use a keycode value, like `ENTER` or `BACKSPACE`, to tell us what the key
    is. Given these facts, one way to read a user-given filename would be to append
    the characters typed by the user to a string and, when we see the enter value,
    to use the preceding string as a filename. This should work fine, but we need
    to handle some conventions.
  prefs: []
  type: TYPE_NORMAL
- en: First, the user needs to see what they are typing. The string that the user
    has entered so far must appear somewhere on the screen so that the user can see
    what has actually been typed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, corrections must be possible. Traditionally one presses the backspace
    key to move backward over the string and delete characters so that new, correct
    ones can be entered, so we’ll implement corrections using backspace. Finally,
    if an incorrect name is entered, a corresponding image file might not exist, and
    the user needs to be informed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user types a letter or number, indicated by the variable `key`, we
    add that character to a string named `s` using the concatenation operation 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If that character is a backspace and the string has characters in it, we remove
    the last character entered 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `draw()` function will display this string each time the screen is updated,
    allowing the user to see the current string. Finally, if the key pressed was enter,
    then the string is complete and we should open and display the file. If `loadImage()`
    returns `null`, there is no such image, and the word `Error` is displayed in place
    of the filename 2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Sketch 38: Inputting an Integer'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous sketch, we had the user enter a string from the keyboard, and
    we used the string as a filename. This is a basic use of a string—using a sequence
    of characters to communicate data to the computer and back. What if, instead of
    entering a filename, we wanted to specify some number of things to input? This
    would mean entering an integer. However, when a number is entered at the keyboard,
    the string is *not* the number but is a text representation of the number. To
    get the actual number, the characters that compose it have to be converted into
    numeric form.
  prefs: []
  type: TYPE_NORMAL
- en: The string “184” is an integer in string form, obviously representing the number
    one hundred eighty-four (184). This is one hundred plus eight tens plus four,
    or 10² + 8×10¹ + 4×10⁰. To convert from string form into numeric form, we need
    to peel off the digits one at a time and multiply by the correct power of 10.
  prefs: []
  type: TYPE_NORMAL
- en: We can take the first digit, 1, and add it to a sum. Then we take the next digit
    and add to the sum *multiplied by 10*; and repeat again and again until the incoming
    character is not a digit. The powers of 10 accumulate with the first digit representing
    the highest power and the final digit representing 10⁰, or one.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the essential piece of code 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression `key-''0''`, where `key` is a digit, represents the numeric
    value of a digit character (that is, from 0 to 9). Assuming that `val` is initially
    0, we get this after the user types `''1''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the user types `''8''`, and we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally the user types `''4''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To make this sketch marginally useful, it allows us to enter two values, an
    *x* and a *y* value, and draws a circle at these coordinates. An error on entry
    sets the coordinate to 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 39: Reading Parameters from a File'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many computer programs save values in files for use when the program starts,
    or restarts. Initial values, locations for buttons and other interface objects,
    high scores for a game: all can be read from files when a program begins. Most
    people have had the experience of playing a computer game and saving the state
    so that they can resume playing at a later time; this also involves saving data
    in a file and then retrieving it later. This sketch retrieves the state of a game,
    albeit a simple one—checkers—from a text file that contains the positions of all
    of the checkers in a game.'
  prefs: []
  type: TYPE_NORMAL
- en: Checkers uses an 8×8 grid of squares on which disks of two colors, usually referred
    to as black and white, are placed. Only half of the squares are really used, and
    these squares also have two colors. Checkers can only sit on one of those colors,
    so the easy part of this sketch is to draw the squares and place checkers on those
    squares when it is known what the locations are. The new part is reading the data
    and interpreting that data as checker positions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a scheme for representing a checker board, imagine a set of squares with
    eight rows of eight columns each. A square can be indexed as (*i*, *j*), where
    *i* is the row and *j* is the column. The color of the checker on the square can
    be 0 for one color and 1 for another—the actual colors do not matter, only that
    checkers of color 0 belong to one player and the color 1 checkers belong to the
    other. The squares have fixed positions, but the checker locations are read from
    the file, which contains a row for the position and color of each checker, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The file contains one-digit integers separated by single spaces, three per line.
    A structured format is easy to read and is, in fact, typical of data that has
    been created by a computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read a file in Processing, we’ll use the built-in function `loadStrings()`,
    which reads a set of strings from a file (given as a string parameter), with one
    string being one line in the file. `loadStrings()` returns an array of strings
    that we’ll assign to the variable `dlines`2. To find the number of items in the
    array (the same as the number of lines of data in the file), we use the `length`
    property in `dlines`: `dlines`**.**`length`.'
  prefs: []
  type: TYPE_NORMAL
- en: When a line is read in, we use it to place a checker on a square, and when all
    checkers are read in, we draw them on the screen. To place the checker, we extract
    the three integers from each string in `dlines` and then place the correct piece
    in the correct place using the row and column integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We convert the string data into numbers as follows 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Each piece is one of two colors, indicated by the variable `k[i]`. A checker
    is 20 pixels wide, so we draw one at location (`x[i]`, `y[i]`) with these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The horizontal position is offset from the left by 20 pixels, and each successive
    position is 40 pixels further right. The expression `x[i]*40+20` gives the *x*
    location at which to draw checker number `i`. It is symmetrical for the vertical
    *y* position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Squares are 40×40 pixels and alternate in color, so when we draw a red one,
    we toggle the fill color to that of the next square. After 8 squares, an extra
    toggle is done so that the colors alternate vertically as well. If `i` and `j`
    are the coordinates of a square, we draw it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the sketch, the checkers are red or green, and the squares are red or yellow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 40: Writing Text to a File'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Computer programs use text to tell their users what is going on. Sometimes,
    as in the previous sketch, they use text to save the state of the program, often
    a game; sometimes the program writes numerical results or records the progress
    of a program. Text is a typical and natural way for computers to communicate with
    humans.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the problem to be solved: we want to simulate a ball on the screen,
    moving at a constant speed, as was done in Sketch 28; write the position of the
    ball to a file during each frame; and record when the ball collides with the edge
    of the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: The output method that corresponds to `loadStrings()` is the function `saveStrings()`.
    We’ll declare an array of strings, where each string will be written as a line
    of text to the file. When a ball position is to be saved, a string is created
    that represents the position, and it is stored in one of the array locations.
    Then the array index is incremented so the next string goes in the next location
    2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When the ball collides with a side of the screen, we put a message like “Collision
    left” in the array and then increment the index 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the array is full, which happens when the index is greater than 499, `saveStrings()`
    writes all of the strings to a file and ends the program 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It is not possible to add more to a file using `saveStrings()` after the file
    has been closed; if you call it again with the same filename, it will overwrite
    the file. So you must save everything first, and then write it all out at once.
    With 500 strings, you can record about 7 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 41: Simulating Text on a Computer Screen'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine working on a made-for-TV movie. It’s about computers and hackers and
    programmers, and the actors playing the roles of the hackers are, well, *actors*.
    They don’t know anything about programming. They can’t type, and they certainly
    can’t enter code. So, in the scenes where the camera is looking over the main
    character’s shoulder at the screen while she types, we need a special effect—something
    that makes it appear as if she’s coding. Do we use computer animation? That can
    be expensive. No, the usual trick is to use a simple program that displays text,
    specific text, no matter what keys are struck. That way the actors don’t have
    to know anything except how to press a key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making this program in Processing is straightforward, given what we know so
    far. The program opens a window and initializes a string, `message`, to the text
    to be typed onto the screen 1, which could be read from a file. A variable `N`
    starts as `0` and indexes the string: every character up to character `N` has
    been typed and should appear on the screen. The `draw()` function draws all of
    the characters up to `N` each time it is called, one character at a time, spacing
    them (in the example) nine pixels apart horizontally.'
  prefs: []
  type: TYPE_NORMAL
- en: To organize the text into lines, we use the “!” character to indicate where
    lines end. When the program sees that character in the string, it doesn’t display
    it, but instead resets the *x* position to the starting value and increases the
    *y* position by 15 pixels (one line).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `draw()` function outputs the text, starting at the statement 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Either it displays one of the characters in the string 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'or the character in the string is “!” and it begins a new line 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Finally, when a key is pressed, as indicated by Processing calling the `keyPressed()`
    function, the count value `N` increases by one so that one more character appears
    on the screen 6. Regardless of what character was typed, the predefined character
    in the `message` string will be displayed. If `N` exceeds the string length, the
    program can set `N` to `0`, which starts over again with a fresh screen, or further
    key presses could just be ignored.
  prefs: []
  type: TYPE_NORMAL
