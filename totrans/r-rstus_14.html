<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><section aria-labelledby="ch11" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="title" id="ch11">
<span class="tpt"><span aria-label=" Page 181. " epub:type="pagebreak" id="pg_181" role="doc-pagebreak" class="calibre2"/><span class="sans_dogma_ot_bold_b_">11</span></span>
<span class="ct"><span class="sans_dogma_ot_bold_b_">AUTOMATICALLY ACCESSING ONLINE DATA</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener1" height="407" src="../images/chapter.jpg" width="407"/>
</figure>
<p class="cos">So far, you’ve imported data into your projects from CSV files. Many online datasets allow you to export CSVs, but before you do so, you should look for packages to automate your data access. If you can eliminate the manual steps involved in fetching data, your analysis and reporting will be more accurate. You’ll also be able to efficiently update your report when the data changes.</p>
<p class="tx">R offers many ways to automate the process of accessing online data. In this chapter, I’ll discuss two such approaches. First, you will use the <span class="sans_thesansmonocd_w5regular_">googlesheets4</span> package to fetch data directly from Google Sheets. You’ll learn how to connect your R Markdown project to Google so you can automatically download data when a Google Sheet updates. Then, you’ll use the <span class="sans_thesansmonocd_w5regular_">tidycensus</span> package to access data from the US Census Bureau. You’ll work with two large census datasets, the Decennial Census and the American Community Survey, and practice visualizing them.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="h1" id="sec1"><span id="h1-66"/><span aria-label=" Page 182. " epub:type="pagebreak" id="pg_182" role="doc-pagebreak"/><span class="sans_dogma_ot_bold_b_1">Importing Data from Google Sheets with googlesheets4</span></h3>
<p class="tni">By using the <span class="sans_thesansmonocd_w5regular_">googlesheets4</span> package to access data directly from Google Sheets, you avoid having to manually download data, copy it into your project, and adjust your code so it imports that new data every time you want to update a report. This package lets you write code that automatically fetches new data directly from Google Sheets. Whenever you need to update your report, you can simply run your code to refresh the data. In addition, if you work with Google Forms, you can pipe your data into Google Sheets, completely automating the workflow from data collection to data import.</p>
<p class="tx">Using the <span class="sans_thesansmonocd_w5regular_">googlesheets4</span> package can help you manage complex datasets that update frequently. For example, in her role at the Primary Care Research Institute at the University of Buffalo, Meghan Harris used it for a research project about people affected by opioid use disorder. The data came from a variety of surveys, all of which fed into a jumble of Google Sheets. Using <span class="sans_thesansmonocd_w5regular_">googlesheets4</span>, Harris was able to collect all of her data in one place and use R to put it to use. Data that had once been largely unused because accessing it was so complicated could now inform research on opioid use disorder.</p>
<p class="tx">This section demonstrates how the <span class="sans_thesansmonocd_w5regular_">googlesheets4</span> package works using a fake dataset about video game preferences that Harris created to replace her opioid survey data (which, for obvious reasons, is confidential).</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="h2" id="sec2"><span id="h2-84"/><span class="sans_futura_std_heavy_oblique_bi_">Connecting to Google</span></h4>
<p class="tni">To begin, install the <span class="sans_thesansmonocd_w5regular_">googlesheets4</span> package by running <span class="sans_thesansmonocd_w7bold_b_">install.packages("googlesheets4")</span>. Next, connect to your Google account by running the <span class="sans_thesansmonocd_w7bold_b_">gs4_auth()</span> function in the console. If you have more than one Google account, select the account that has access to the Google Sheet you want to work with.</p>
<p class="tx">Once you do so, a screen should appear. Check the box next to <b class="calibre9">See, Edit, Create, and Delete All Your Google Sheets Spreadsheets</b>. This will ensure that R can access data from your Google Sheets account. Click <b class="calibre9">Continue</b>, and you should see the message “Authentication complete. Please close this page and return to R.” The <span class="sans_thesansmonocd_w5regular_">googlesheets4</span> package will now save your credentials so that you can use them in the future without having to reauthenticate.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="h2" id="sec3"><span id="h2-85"/><span class="sans_futura_std_heavy_oblique_bi_">Reading Data from a Sheet</span></h4>
<p class="tni">Now that you’ve connected R to your Google account, you can import the fake data that Harris created about video game preferences (access it at <i class="calibre4"><a href="https://data.rfortherestofus.com/google-sheet" class="calibre3">https://data.rfortherestofus.com/google-sheet</a></i>). <a href="chapter11.xhtml#fig11-1" class="calibre3">Figure 11-1</a> shows what it looks like in Google Sheets.<span aria-label=" Page 183. " epub:type="pagebreak" id="pg_183" role="doc-pagebreak"/></p>
<figure class="img"><img alt="" class="img1" height="429" id="fig11-1" src="../images/fig11-1.jpg" width="1391"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">Figure 11-1: The video game data in Google Sheets</span></p></figcaption>
</figure>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">googlesheets4</span> package has a function called <span class="sans_thesansmonocd_w5regular_">read_sheet()</span> that allows you to pull in data directly from a Google Sheet. Import the data by passing the spreadsheet’s URL to the function like so:</p>
<pre id="pre-204" class="calibre10"><code class="calibre11">library(googlesheets4)

survey_data_raw &lt;- read_sheet("https://docs.google.com/spreadsheets/d/
1AR0_RcFBg8wdiY4Cj-k8vRypp_txh27MyZuiRdqScog/edit?usp=sharing")
</code></pre>
<p class="tx">Take a look at the <span class="sans_thesansmonocd_w5regular_">survey_data_raw</span> object to confirm that the data was imported. Using the <span class="sans_thesansmonocd_w5regular_">glimpse()</span> function from the <span class="sans_thesansmonocd_w5regular_">dplyr</span> package makes it easier to read:</p>
<pre id="pre-205" class="calibre10"><code class="calibre11">library(tidyverse)

survey_data_raw %&gt;%
  glimpse()
</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">glimpse()</span> function, which creates one output row per variable, shows that you’ve successfully imported the data directly from Google Sheets:</p>
<pre id="pre-206" class="calibre10"><code class="calibre11">#&gt; Rows: 5
#&gt; Columns: 5
#&gt; $ Timestamp                          &lt;dttm&gt; 05-16 15:20:50
#&gt; $ `How old are you?`                 &lt;chr&gt; "25-34", "45-54"...
#&gt; $ `Do you like to play video games?` &lt;chr&gt; "Yes", "No", "Ye...
#&gt; $ `What kind of games do you like?`  &lt;chr&gt; "Sandbox, Role-P...
#&gt; $ `What's your favorite game?`       &lt;chr&gt; "It's hard to ch...
</code></pre>
<p class="tx">Once you have the data in R, you can use the same workflow you’ve been using to create reports with R Markdown.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="h2" id="sec4"><span id="h2-86"/><span class="sans_futura_std_heavy_oblique_bi_">Using the Data in R Markdown</span></h4>
<p class="tni">The following code is taken from an R Markdown report that Harris made to summarize the video games data. You can see the YAML, the <span class="sans_thesansmonocd_w5regular_">setup</span> code <span aria-label=" Page 184. " epub:type="pagebreak" id="pg_184" role="doc-pagebreak"/>chunk, a code chunk that loads packages, and the code to import data from Google Sheets:</p>
<pre id="pre-207" class="calibre10"><code class="calibre11">---
title: "Video Game Survey"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning = FALSE,
                      message = FALSE)
```

```{r}
library(tidyverse)
library(janitor)
library(googlesheets4)
library(gt)
```

```{r}
# Import data from Google Sheets
<span aria-label="annotation1" class="codeannotationhang">❶</span> survey_data_raw &lt;- read_sheet("https://docs.google.com/spreadsheets/d/
1AR0_RcFBg8wdiY4Cj-k8vRypp_txh27MyZuiRdqScog/edit?usp=sharing")
```
</code></pre>
<p class="tx">This R Markdown document resembles those discussed in previous chapters, except for the way you import the data <span aria-label="annotation1" class="codeannotation">❶</span>. Because you’re bringing it in directly from Google Sheets, there’s no risk of, say, accidentally reading in the wrong CSV. Automating this step reduces the risk of error.</p>
<p class="tx">The next code chunk cleans the <span class="sans_thesansmonocd_w5regular_">survey_data_raw</span> object, saving the result as <span class="sans_thesansmonocd_w5regular_">survey_data_clean</span>:</p>
<pre id="pre-208" class="calibre10"><code class="calibre11">```{r}
# Clean data
survey_data_clean &lt;- survey_data_raw %&gt;%
  clean_names() %&gt;%
  mutate(participant_id = as.character(row_number())) %&gt;%
  rename(
    age = how_old_are_you,
    like_games = do_you_like_to_play_video_games,
    game_types = what_kind_of_games_do_you_like,
    favorite_game = whats_your_favorite_game
  ) %&gt;%
  relocate(participant_id, .before = age) %&gt;%
  mutate(age = factor(age, levels = c("Under 18", "18-24", "25-34",
"35-44", "45-54", "55-64", "Over 65")))
```
</code></pre>
<p class="tx">Here, the <span class="sans_thesansmonocd_w5regular_">clean_names()</span> function from the <span class="sans_thesansmonocd_w5regular_">janitor</span> package makes the variable names easier to work with. Defining a <span class="sans_thesansmonocd_w5regular_">participant_id</span> variable using the <span class="sans_thesansmonocd_w5regular_">row_number()</span> function then adds a consecutively increasing number to <span aria-label=" Page 185. " epub:type="pagebreak" id="pg_185" role="doc-pagebreak"/>each row, and the <span class="sans_thesansmonocd_w5regular_">as.character()</span> function makes the number a character. Next, the code changes several variable names with the <span class="sans_thesansmonocd_w5regular_">rename()</span> function. The <span class="sans_thesansmonocd_w5regular_">mutate()</span> function then transforms the <span class="sans_thesansmonocd_w5regular_">age</span> variable into a data structure known as a <i class="calibre4">factor</i>, which ensures that <span class="sans_thesansmonocd_w5regular_">age</span> will show up in the right order in your chart. Finally, the <span class="sans_thesansmonocd_w5regular_">relocate()</span> function positions <span class="sans_thesansmonocd_w5regular_">participant_id</span> before the <span class="sans_thesansmonocd_w5regular_">age</span> variable.</p>
<p class="tx">Now you can use the <span class="sans_thesansmonocd_w5regular_">glimpse()</span> function again to view your updated <span class="sans_thesansmonocd_w5regular_">survey_data_clean</span> data frame, which looks like this:</p>
<pre id="pre-209" class="calibre10"><code class="calibre11">#&gt; Rows: 5
#&gt; Columns: 6
#&gt; $ timestamp      &lt;dttm&gt; 2024-05-16 15:20:50, 2024-05-16 15:21:28, 2024-05...
#&gt; $ participant_id &lt;chr&gt; "1", "2", "3", "4", "5"
#&gt; $ age            &lt;fct&gt; 25-34, 45-54, Under 18, Over 65, Un...
#&gt; $ like_games     &lt;chr&gt; "Yes", "No", "Yes", "No", "Yes"
#&gt; $ game_types     &lt;chr&gt; "Sandbox, Role-Playing (RPG), Simul...
#&gt; $ favorite_game  &lt;chr&gt; "It's hard to choose. House Flipper...
</code></pre>
<p class="tx">The rest of the report uses this data to highlight various statistics:</p>
<pre id="pre-210" class="calibre10"><code class="calibre11"># Respondent Demographics

```{r}
# Calculate number of respondents
number_of_respondents &lt;- nrow(survey_data_clean) <span aria-label="annotation1" class="code_codeannotation">❶</span>
```

We received responses from `r number_of_respondents` respondents. Their ages are below.

```{r}
survey_data_clean %&gt;%
  select(participant_id, age) %&gt;%
  gt() %&gt;% <span aria-label="annotation2" class="code_codeannotation">❷</span>
  cols_label(
    participant_id = "Participant ID",
    age = "Age"
  ) %&gt;%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels()
  ) %&gt;%
  cols_align(
    align = "left",
    columns = everything()
  ) %&gt;%
  cols_width(
    participant_id ~ px(200),
    age ~ px(700)
  )
```

<span aria-label=" Page 186. " epub:type="pagebreak" id="pg_186" role="doc-pagebreak"/># Video Games

We asked if respondents liked video games. Their responses are below.

```{r}
survey_data_clean %&gt;%
  count(like_games) %&gt;%
  ggplot(aes(
    x = like_games, <span aria-label="annotation3" class="code_codeannotation">❸</span>
    y = n,
    fill = like_games
  )) +
  geom_col() +
  scale_fill_manual(values = c(
    "No" = "#6cabdd",
    "Yes" = "#ff7400"
  )) +
  labs(
    title = "How Many People Like Video Games?",
    x = NULL,
    y = "Number of Participants"
  ) +
  theme_minimal(base_size = 16) +
  theme(
    legend.position = "none",
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    axis.title.y = element_blank(),
    plot.title = element_text(
      face = "bold",
      hjust = 0.5
    )
  )
```
</code></pre>
<p class="tx">These sections calculate the number of survey respondents <span aria-label="annotation1" class="codeannotation">❶</span>, then put this value in the text using inline R code; create a table that breaks down the respondents by age group <span aria-label="annotation2" class="codeannotation">❷</span>; and generate a graph displaying how many respondents like video games <span aria-label="annotation3" class="codeannotation">❸</span>. <a href="chapter11.xhtml#fig11-2" class="calibre3">Figure 11-2</a> shows the resulting report.<span aria-label=" Page 187. " epub:type="pagebreak" id="pg_187" role="doc-pagebreak"/></p>
<figure class="img"><img alt="" class="img2" height="1101" id="fig11-2" src="../images/fig11-2.jpg" width="1044"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">Figure 11-2: The rendered video game report</span></p></figcaption>
</figure>
<p class="tx">You can rerun the code at any point to fetch updated data. The survey had five responses today, but if you run it again tomorrow and it has additional responses, they will be included in the import. If you used Google Forms to run your survey and saved the results to a Google Sheet, you could produce this up-to-date report simply by clicking the Knit button in RStudio.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="h2" id="sec5"><span id="h2-87"/><span class="sans_futura_std_heavy_oblique_bi_">Importing Only Certain Columns</span></h4>
<p class="tni">In the previous sections, you read the data of the entire Google Sheet, but you also have the option to import only a section of a sheet. For example, the survey data includes a <span class="sans_thesansmonocd_w5regular_">timestamp</span> column. This variable is added automatically whenever someone submits a Google Form that pipes data into a Google Sheet, but you don’t use it in your analysis, so you could get rid of it.</p>
<p class="tx">To do so, use the <span class="sans_thesansmonocd_w5regular_">range</span> argument in the <span class="sans_thesansmonocd_w5regular_">read_sheet()</span> function when importing the data like so:</p>
<pre id="pre-211" class="calibre10"><code class="calibre11">read_sheet("https://docs.google.com/spreadsheets/d/1AR0_RcFBg8wdiY4Cj-k8vRypp_
txh27MyZuiRdqScog/edit?usp=sharing",
<b class="calibre9">          range = "Sheet1!B:E") %&gt;%</b>
  glimpse()
</code></pre>
<p class="tx">This argument lets you specify a range of data to import. It uses the same syntax you may have used to select columns in Google Sheets. In this <span aria-label=" Page 188. " epub:type="pagebreak" id="pg_188" role="doc-pagebreak"/>example, <span class="sans_thesansmonocd_w5regular_">range = "Sheet1!B:E"</span> imports columns B through E (but not A, which contains the timestamp). Adding <span class="sans_thesansmonocd_w5regular_">glimpse()</span> and then running this code produces output without the <span class="sans_thesansmonocd_w5regular_">timestamp</span> variable:</p>
<pre id="pre-212" class="calibre10"><code class="calibre11">#&gt; Rows: 5
#&gt; Columns: 4
#&gt; $ `How old are you?`                 &lt;chr&gt; "25-34", "45-54"...
#&gt; $ `Do you like to play video games?` &lt;chr&gt; "Yes", "No", "Ye...
#&gt; $ `What kind of games do you like?`  &lt;chr&gt; "Sandbox, Role-P...
#&gt; $ `What's your favorite game?`       &lt;chr&gt; "It's hard to ch...
</code></pre>
<p class="tx">There are a number of other useful functions in the <span class="sans_thesansmonocd_w5regular_">googlesheets4</span> package. For example, if you ever need to write your output back to a Google Sheet, the <span class="sans_thesansmonocd_w5regular_">write_sheet()</span> function is there to help. To explore other functions in the package, check out its documentation website at <i class="calibre4"><a href="https://googlesheets4.tidyverse.org/index.xhtml" class="calibre3">https://googlesheets4.tidyverse.org/index.xhtml</a></i>.</p>
<p class="tx">Now we’ll turn our attention to another R package that allows you to automatically fetch data, this time from the US Census Bureau.</p>
</section>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="h1" id="sec6"><span id="h1-67"/><span class="sans_dogma_ot_bold_b_1">Accessing Census Data with tidycensus</span></h3>
<p class="tni">If you’ve ever worked with data from the US Census Bureau, you know what a hassle it can be. Usually, the process involves visiting the Census Bureau website, searching for the data you need, downloading it, and then analyzing it in your tool of choice. This pointing and clicking gets very tedious after a while.</p>
<p class="tx">Kyle Walker, a geographer at Texas Christian University, and Matt Herman (creator of the Westchester COVID-19 website discussed in <span class="xref"><a href="chapter9.xhtml" class="calibre3">Chapter 9</a></span>) developed the <span class="sans_thesansmonocd_w5regular_">tidycensus</span> package to automate the process of importing Census Bureau data into R. With <span class="sans_thesansmonocd_w5regular_">tidycensus</span>, you can write just a few lines of code to get data about, say, the median income in all counties in the United States.</p>
<p class="tx">In this section, I’ll show you how the <span class="sans_thesansmonocd_w5regular_">tidycensus</span> package works using examples from two datasets to which it provides access: the Decennial Census, administered every 10 years, and the annual American Community Survey. I’ll also show you how to use the data from these two sources to perform additional analysis and make maps by accessing geospatial and demographic data simultaneously.</p>
<section aria-labelledby="sec7" epub:type="division">
<h4 class="h2" id="sec7"><span id="h2-88"/><span class="sans_futura_std_heavy_oblique_bi_">Connecting to the Census Bureau with an API Key</span></h4>
<p class="tni">Begin by installing <span class="sans_thesansmonocd_w5regular_">tidycensus</span> using <span class="sans_thesansmonocd_w7bold_b_">install.packages("tidycensus")</span>. To use <span class="sans_thesansmonocd_w5regular_">tidycensus</span>, you must get an application programming interface (API) key from the Census Bureau. <i class="calibre4">API keys</i> are like passwords that online services use to determine whether you’re authorized to access data.</p>
<p class="tx">To obtain this key, which is free, go to <i class="calibre4"><a href="https://api.census.gov/data/key_signup.xhtml" class="calibre3">https://api.census.gov/data/key_signup.xhtml</a></i> and enter your details. Once you receive the key by email, you need to put it in a place where <span class="sans_thesansmonocd_w5regular_">tidycensus</span> can find it. The <span class="sans_thesansmonocd_w5regular_">census_api_key()</span> <span aria-label=" Page 189. " epub:type="pagebreak" id="pg_189" role="doc-pagebreak"/>function does this for you, so after loading the <span class="sans_thesansmonocd_w5regular_">tidycensus</span> package, run the function as follows, replacing <span class="sans_thesansmonocd_w5regular_italic_i_">123456789</span> with your actual API key:</p>
<pre id="pre-213" class="calibre10"><code class="calibre11">library(tidycensus)

<b class="calibre9">census_api_key("</b><b class="calibre9"><var class="calibre14">123456789</var></b><b class="calibre9">", install = TRUE)</b>
</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">install = TRUE</span> argument saves your API key in your <i class="calibre4">.Renviron</i> file, which is designed for storing confidential information. The package will look for your API key there in the future so that you don’t have to reenter it every time you use the package.</p>
<p class="tx">Now you can use <span class="sans_thesansmonocd_w5regular_">tidycensus</span> to access Census Bureau datasets. While the Decennial Census and the American Community Survey are the most common, <a href="chapter2.xhtml" class="calibre3">Chapter 2</a> of Kyle Walker’s book <i class="calibre4">Analyzing US Census Data: Methods, Maps, and Models in R</i> discusses others you can access.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="h2" id="sec8"><span id="h2-89"/><span class="sans_futura_std_heavy_oblique_bi_">Working with Decennial Census Data</span></h4>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">tidycensus</span> packages includes several functions dedicated to specific Census Bureau datasets, such as <span class="sans_thesansmonocd_w5regular_">get_decennial()</span> for Decennial Census data. To access data from the 2020 Decennial Census about the Asian population in each state, use the <span class="sans_thesansmonocd_w5regular_">get_decennial()</span> function with three arguments as follows:</p>
<pre id="pre-214" class="calibre10"><code class="calibre11">get_decennial(geography = "state",
              variables = "P1_006N",
              year = 2020)
</code></pre>
<p class="tx">Setting the <span class="sans_thesansmonocd_w5regular_">geography</span> argument to <span class="sans_thesansmonocd_w5regular_">"state"</span> tells <span class="sans_thesansmonocd_w5regular_">get_decennial()</span> to access data at the state level. In addition to the 50 states, it will return data for the District of Columbia and Puerto Rico. The <span class="sans_thesansmonocd_w5regular_">variables</span> argument specifies the variable or variables you want to access. Here, <span class="sans_thesansmonocd_w5regular_">P1_006N</span> is the variable name for the total Asian population. I’ll discuss how to identify other variables you may want to use in the next section. Finally, <span class="sans_thesansmonocd_w5regular_">year</span> specifies the year for which you want to access data—in this case, 2020.</p>
<p class="tx">Running this code returns the following:</p>
<pre id="pre-215" class="calibre10"><code class="calibre11">#&gt; # A tibble: 52 × 4
#&gt;    GEOID NAME                 variable   value
#&gt;    &lt;chr&gt; &lt;chr&gt;                &lt;chr&gt;      &lt;dbl&gt;
#&gt;  1 42    Pennsylvania         P1_006N   510501
#&gt;  2 06    California           P1_006N  6085947
#&gt;  3 54    West Virginia        P1_006N    15109
#&gt;  4 49    Utah                 P1_006N    80438
#&gt;  5 36    New York             P1_006N  1933127
#&gt;  6 11    District of Columbia P1_006N    33545
#&gt;  7 02    Alaska               P1_006N    44032
#&gt;  8 12    Florida              P1_006N   643682
#&gt;  9 45    South Carolina       P1_006N    90466
#&gt; 10 38    North Dakota         P1_006N    13213
<var class="calibre14">--snip--</var>
</code></pre>
<p class="tx"><span aria-label=" Page 190. " epub:type="pagebreak" id="pg_190" role="doc-pagebreak"/>The resulting data frame has four variables. <span class="sans_thesansmonocd_w5regular_">GEOID</span> is the geographic identifier assigned to the state by the Census Bureau. Each state has a geographic identifier, as do all counties, census tracts, and other geographies. <span class="sans_thesansmonocd_w5regular_">NAME</span> is the name of each state, and <span class="sans_thesansmonocd_w5regular_">variable</span> is the name of the variable you passed to the <span class="sans_thesansmonocd_w5regular_">get_decennial()</span> function. Finally, <span class="sans_thesansmonocd_w5regular_">value</span> is the numeric value for the state and variable in each row. In this case, it represents the total Asian population in each state.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="h2" id="sec9"><span id="h2-90"/><span class="sans_futura_std_heavy_oblique_bi_">Identifying Census Variable Values</span></h4>
<p class="tni">You’ve just seen how to retrieve the total number of Asian residents of each state, but say you want to calculate that number instead as a percentage of all the state’s residents. To do that, first you need to retrieve the variable for the state’s total population.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">tidycensus</span> package has a function called <span class="sans_thesansmonocd_w5regular_">load_variables()</span> that shows all of the variables from a Decennial Census. Run it with the <span class="sans_thesansmonocd_w5regular_">year</span> argument set to <span class="sans_thesansmonocd_w5regular_">2020</span> and <span class="sans_thesansmonocd_w5regular_">dataset</span> set to <span class="sans_thesansmonocd_w5regular_">pl</span> as follows:</p>
<pre id="pre-216" class="calibre10"><code class="calibre11">load_variables(year = 2020,
               dataset = "pl")
</code></pre>
<p class="tx">Running this code pulls data from so-called redistricting summary data files (which Public Law 94-171 requires the Census Bureau to produce every 10 years) and returns the name, label (description), and concept (category) of all available variables:</p>
<pre id="pre-217" class="calibre10"><code class="calibre11">#&gt; # A tibble: 301 × 3
#&gt;    name    label                                       concept
#&gt;    &lt;chr&gt;   &lt;chr&gt;                                       &lt;chr&gt;
#&gt;  1 H1_001N " !!Total:"                                 OCCU...
#&gt;  2 H1_002N " !!Total:!!Occupied"                       OCCU...
#&gt;  3 H1_003N " !!Total:!!Vacant"                         OCCU...
#&gt;  4 P1_001N " !!Total:"                                 RACE
#&gt;  5 P1_002N " !!Total:!!Population of one race:"        RACE
#&gt;  6 P1_003N " !!Total:!!Population of one race:!!Whi... RACE
#&gt;  7 P1_004N " !!Total:!!Population of one race:!!Bla... RACE
#&gt;  8 P1_005N " !!Total:!!Population of one race:!!Ame... RACE
#&gt;  9 P1_006N " !!Total:!!Population of one race:!!Asi... RACE
#&gt; 10 P1_007N " !!Total:!!Population of one race:!!Nat... RACE
<var class="calibre14">--snip--</var>
</code></pre>
<p class="tx">By looking at this list, you can see that the variable <span class="sans_thesansmonocd_w5regular_">P1_001N</span> returns the total population.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="h2" id="sec10"><span id="h2-91"/><span class="sans_futura_std_heavy_oblique_bi_">Using Multiple Census Variables</span></h4>
<p class="tni">Now that you know which variables you need, you can use the <span class="sans_thesansmonocd_w5regular_">get_decennial()</span> function again with two variables at once:</p>
<pre id="pre-218" class="calibre10"><code class="calibre11">get_decennial(geography = "state",
              variables = c(<b class="calibre9">"P1_001N", "P1_006N"</b>),
<span aria-label=" Page 191. " epub:type="pagebreak" id="pg_191" role="doc-pagebreak"/>              year = 2020) %&gt;%
  arrange(NAME)
</code></pre>
<p class="tx">Adding <span class="sans_thesansmonocd_w5regular_">arrange(NAME)</span> after <span class="sans_thesansmonocd_w5regular_">get_decennial()</span> sorts the results by state name, allowing you to easily see that the output includes both variables for each state:</p>
<pre id="pre-219" class="calibre10"><code class="calibre11">#&gt; # A tibble: 104 × 4
#&gt;    GEOID NAME       variable    value
#&gt;    &lt;chr&gt; &lt;chr&gt;      &lt;chr&gt;       &lt;dbl&gt;
#&gt;  1 01    Alabama    P1_001N   5024279
#&gt;  2 01    Alabama    P1_006N     76660
#&gt;  3 02    Alaska     P1_001N    733391
#&gt;  4 02    Alaska     P1_006N     44032
#&gt;  5 04    Arizona    P1_001N   7151502
#&gt;  6 04    Arizona    P1_006N    257430
#&gt;  7 05    Arkansas   P1_001N   3011524
#&gt;  8 05    Arkansas   P1_006N     51839
#&gt;  9 06    California P1_001N  39538223
#&gt; 10 06    California P1_006N   6085947
<var class="calibre14">--snip--</var>
</code></pre>
<p class="tx">When you’re working with multiple census variables like this, you might have trouble remembering what names like <span class="sans_thesansmonocd_w5regular_">P1_001N</span> and <span class="sans_thesansmonocd_w5regular_">P1_006N</span> mean. Fortunately, you can adjust the code in the call to <span class="sans_thesansmonocd_w5regular_">get_decennial()</span> to give these variables more meaningful names using the following syntax:</p>
<pre id="pre-220" class="calibre10"><code class="calibre11">get_decennial(geography = "state",
              variables = c(<b class="calibre9">total_population = "P1_001N",</b>
<b class="calibre9">                            asian_population = "P1_006N"</b>),
<b class="calibre9">              </b>year = 2020) %&gt;%
  arrange(NAME)
</code></pre>
<p class="tx">Within the <span class="sans_thesansmonocd_w5regular_">variables</span> argument, this code specifies the new names for the variables, followed by the equal sign and the original variable names. The <span class="sans_thesansmonocd_w5regular_">c()</span> function allows you to rename multiple variables at one time.</p>
<p class="tx">Now it’s much easier to see which variables you’re working with:</p>
<pre id="pre-221" class="calibre10"><code class="calibre11">#&gt; # A tibble: 104 × 4
#&gt;    GEOID NAME       variable            value
#&gt;    &lt;chr&gt; &lt;chr&gt;      &lt;chr&gt;               &lt;dbl&gt;
#&gt;  1 01    Alabama    total_population  5024279
#&gt;  2 01    Alabama    asian_population    76660
#&gt;  3 02    Alaska     total_population   733391
#&gt;  4 02    Alaska     asian_population    44032
#&gt;  5 04    Arizona    total_population  7151502
#&gt;  6 04    Arizona    asian_population   257430
#&gt;  7 05    Arkansas   total_population  3011524
#&gt;  8 05    Arkansas   asian_population    51839
#&gt;  9 06    California total_population 39538223
#&gt; 10 06    California asian_population  6085947
#&gt; # ... with 94 more rows
</code></pre>
<p class="tx"><span aria-label=" Page 192. " epub:type="pagebreak" id="pg_192" role="doc-pagebreak"/>Instead of <span class="sans_thesansmonocd_w5regular_">P1_001N</span> and <span class="sans_thesansmonocd_w5regular_">P1_006N</span>, the variables appear as <span class="sans_thesansmonocd_w5regular_">total_population</span> and <span class="sans_thesansmonocd_w5regular_">asian_population</span>. Much better!</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="h2" id="sec11"><span id="h2-92"/><span class="sans_futura_std_heavy_oblique_bi_">Analyzing Census Data</span></h4>
<p class="tni">Now you have the data you need to calculate the Asian population in each state as a percentage of the total. There are just a few functions to add to the code from the previous section:</p>
<pre id="pre-222" class="calibre10"><code class="calibre11">get_decennial(
  geography = "state",
  variables = c(
    total_population = "P1_001N",
    asian_population = "P1_006N"
  ),
  year = 2020
) %&gt;%
  arrange(NAME) %&gt;%
  group_by(NAME) %&gt;%
  mutate(pct = value / sum(value)) %&gt;%
  ungroup() %&gt;%
  filter(variable == "asian_population")
</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">group_by(NAME)</span> function creates one group for each state because you want to calculate the Asian population percentage in each state (not for the entire United States). Then <span class="sans_thesansmonocd_w5regular_">mutate()</span> calculates each percentage, taking the <span class="sans_thesansmonocd_w5regular_">value</span> in each row and dividing it by the <span class="sans_thesansmonocd_w5regular_">total_population</span> and <span class="sans_thesansmonocd_w5regular_">asian_population</span> rows for each state. The <span class="sans_thesansmonocd_w5regular_">ungroup()</span> function removes the state-level grouping, and <span class="sans_thesansmonocd_w5regular_">filter()</span> shows only the Asian population percentage.</p>
<p class="tx">When you run this code, you should see both the total Asian population and the Asian population as a percentage of the total population in each state:</p>
<pre id="pre-223" class="calibre10"><code class="calibre11">#&gt; # A tibble: 52 × 5
#&gt;    GEOID NAME                 variable          value      pct
#&gt;    &lt;chr&gt; &lt;chr&gt;                &lt;chr&gt;             &lt;dbl&gt;    &lt;dbl&gt;
#&gt;  1 01    Alabama              asian_popula...   76660 0.015029
#&gt;  2 02    Alaska               asian_popula...   44032 0.056638
#&gt;  3 04    Arizona              asian_popula...  257430 0.034746
#&gt;  4 05    Arkansas             asian_popula...   51839 0.016922
#&gt;  5 06    California           asian_popula... 6085947 0.133390
#&gt;  6 08    Colorado             asian_popula...  199827 0.033452
#&gt;  7 09    Connecticut          asian_popula...  172455 0.045642
#&gt;  8 10    Delaware             asian_popula...   42699 0.041349
#&gt;  9 11    District of Columbia asian_popula...   33545 0.046391
#&gt; 10 12    Florida              asian_popula...  643682 0.029018
<var class="calibre14">--snip--</var>
</code></pre>
<p class="tx">This is a reasonable way to calculate the Asian population as a percentage of the total population in each state—but it’s not the only way.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h4 class="h2" id="sec12"><span id="h2-93"/><span aria-label=" Page 193. " epub:type="pagebreak" id="pg_193" role="doc-pagebreak"/><span class="sans_futura_std_heavy_oblique_bi_">Using a Summary Variable</span></h4>
<p class="tni">Kyle Walker knew that calculating summaries like you’ve just done would be a common use case for <span class="sans_thesansmonocd_w5regular_">tidycensus</span>. To calculate, say, the Asian population as a percentage of the whole, you need to have a numerator (the Asian population) and denominator (the total population). So, to simplify things, Walker included the <span class="sans_thesansmonocd_w5regular_">summary_var</span> argument, which can be used within <span class="sans_thesansmonocd_w5regular_">get_decennial()</span> to import the total population as a separate variable. Instead of putting <span class="sans_thesansmonocd_w5regular_">P1_001N</span> (total population) in the <span class="sans_thesansmonocd_w5regular_">variables</span> argument and renaming it, you can assign it to the <span class="sans_thesansmonocd_w5regular_">summary_var</span> argument as follows:</p>
<pre id="pre-224" class="calibre10"><code class="calibre11">get_decennial(
  geography = "state",
  variables = c(asian_population = "P1_006N"),
<b class="calibre9">  summary_var = "P1_001N",</b>
  year = 2020
) %&gt;%
  arrange(NAME)
</code></pre>
<p class="tx">This returns a nearly identical data frame to what you just got, except that the total population is now a separate variable, rather than additional rows for each state:</p>
<pre id="pre-225" class="calibre10"><code class="calibre11">#&gt; # A tibble: 52 × 5
#&gt;    GEOID NAME                 variable         value summar...
#&gt;    &lt;chr&gt; &lt;chr&gt;                &lt;chr&gt;             &lt;dbl&gt;    &lt;dbl&gt;
#&gt;  1 01    Alabama              asian_popula...   76660  5024279
#&gt;  2 02    Alaska               asian_popula...   44032   733391
#&gt;  3 04    Arizona              asian_popula...  257430  7151502
#&gt;  4 05    Arkansas             asian_popula...   51839  3011524
#&gt;  5 06    California           asian_popula... 6085947 39538223
#&gt;  6 08    Colorado             asian_popula...  199827  5773714
#&gt;  7 09    Connecticut          asian_popula...  172455  3605944
#&gt;  8 10    Delaware             asian_popula...   42699   989948
#&gt;  9 11    District of Columbia asian_popula...   33545   689545
#&gt; 10 12    Florida              asian_popula...  643682 21538187
<var class="calibre14">--snip--</var>
#&gt; #   summary_value
</code></pre>
<p class="tx">With the data in this new format, now you can calculate the Asian population as a percentage of the whole by dividing the <span class="sans_thesansmonocd_w5regular_">value</span> variable by the <span class="sans_thesansmonocd_w5regular_">summary_value</span> variable. Then you drop the <span class="sans_thesansmonocd_w5regular_">summary_value</span> variable because you no longer need it after doing this calculation:</p>
<pre id="pre-226" class="calibre10"><code class="calibre11">get_decennial(
  geography = "state",
  variables = c(asian_population = "P1_006N"),
  summary_var = "P1_001N",
  year = 2020
) %&gt;%
  arrange(NAME) %&gt;%
<b class="calibre9">  mutate(pct = value / summary_value) %&gt;%</b>
<b class="calibre9">  select(-summary_value)</b>
</code></pre>
<p class="tx"><span aria-label=" Page 194. " epub:type="pagebreak" id="pg_194" role="doc-pagebreak"/>The resulting output is identical to the output of the previous section:</p>
<pre id="pre-227" class="calibre10"><code class="calibre11">#&gt; # A tibble: 52 × 5
#&gt;    GEOID NAME                 variable          value      pct
#&gt;    &lt;chr&gt; &lt;chr&gt;                &lt;chr&gt;             &lt;dbl&gt;    &lt;dbl&gt;
#&gt;  1 01    Alabama              asian_popula...   76660 0.015258
#&gt;  2 02    Alaska               asian_popula...   44032 0.060039
#&gt;  3 04    Arizona              asian_popula...  257430 0.035997
#&gt;  4 05    Arkansas             asian_popula...   51839 0.017214
#&gt;  5 06    California           asian_popula... 6085947 0.153930
#&gt;  6 08    Colorado             asian_popula...  199827 0.034610
#&gt;  7 09    Connecticut          asian_popula...  172455 0.047825
#&gt;  8 10    Delaware             asian_popula...   42699 0.043133
#&gt;  9 11    District of Columbia asian_popula...   33545 0.048648
#&gt; 10 12    Florida              asian_popula...  643682 0.029886
#&gt; # 42 more rows
</code></pre>
<p class="tx">How you choose to calculate summary statistics is up to you; <span class="sans_thesansmonocd_w5regular_">tidycensus</span> makes it easy to do either way.</p>
</section>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="h1" id="sec13"><span id="h1-68"/><span class="sans_dogma_ot_bold_b_1">Visualizing American Community Survey Data</span></h3>
<p class="tni">Once you’ve accessed data using the <span class="sans_thesansmonocd_w5regular_">tidycensus</span> package, you can do whatever you want with it. In this section, you’ll practice analyzing and visualizing survey data using the American Community Survey. This survey, which is conducted every year, differs from the Decennial Census in two major ways: it is given to a sample of people rather than the entire population, and it includes a wider range of questions.</p>
<p class="tx">Despite these differences, you can access data from the American Community Survey nearly identically to how you access Decennial Census data. Instead of <span class="sans_thesansmonocd_w5regular_">get_decennial()</span>, you use the <span class="sans_thesansmonocd_w5regular_">get_acs()</span> function, but the arguments you pass to it are the same:</p>
<pre id="pre-228" class="calibre10"><code class="calibre11">get_acs(
  geography = "state",
  variables = "B01002_001",
  year = 2020
)
</code></pre>
<p class="tx">This code uses the <span class="sans_thesansmonocd_w5regular_">B01002_001</span> variable to get median age data from 2020 for each state. Here’s what the output looks like:</p>
<pre id="pre-229" class="calibre10"><code class="calibre11">#&gt; # A tibble: 52 × 5
#&gt;    GEOID NAME                 variable   estimate   moe
#&gt;    &lt;chr&gt; &lt;chr&gt;                &lt;chr&gt;         &lt;dbl&gt; &lt;dbl&gt;
#&gt;  1 01    Alabama              B01002_001     39.2   0.1
#&gt;  2 02    Alaska               B01002_001     34.6   0.2
#&gt;  3 04    Arizona              B01002_001     37.9   0.2
#&gt;  4 05    Arkansas             B01002_001     38.3   0.2
#&gt;  5 06    California           B01002_001     36.7   0.1
#&gt;  6 08    Colorado             B01002_001     36.9   0.1
<span aria-label=" Page 195. " epub:type="pagebreak" id="pg_195" role="doc-pagebreak"/>#&gt;  7 09    Connecticut          B01002_001     41.1   0.2
#&gt;  8 10    Delaware             B01002_001     41.0   0.2
#&gt;  9 11    District of Columbia B01002_001     34.1   0.1
#&gt; 10 12    Florida              B01002_001     42.2   0.2
<var class="calibre14">--snip--</var>
</code></pre>
<p class="tx">You should notice two differences in the output from <span class="sans_thesansmonocd_w5regular_">get_acs()</span> compared to that from <span class="sans_thesansmonocd_w5regular_">get_decennial()</span>. First, instead of the <span class="sans_thesansmonocd_w5regular_">value</span> column, <span class="sans_thesansmonocd_w5regular_">get_acs()</span> produces a column called <span class="sans_thesansmonocd_w5regular_">estimate</span>. Second, it adds a column called <span class="sans_thesansmonocd_w5regular_">moe</span>, for the margin of error. These changes are the result of American Community Survey being given only to a sample of the population, since extrapolating values from that sample to produce an estimate for the population as a whole introduces a margin of error.</p>
<p class="tx">In the state-level data, the margins of error are relatively low, but in smaller geographies, they tend to be higher. Cases in which your margins of error are high relative to your estimates indicate a greater level of uncertainty about how well the data represents the population as a whole, so you should interpret such results with caution.</p>
<section aria-labelledby="sec14" epub:type="division">
<h4 class="h2" id="sec14"><span id="h2-94"/><span class="sans_futura_std_heavy_oblique_bi_">Making Charts</span></h4>
<p class="tni">To pipe your data on median age into ggplot to create a bar chart, add the following lines:</p>
<pre id="pre-230" class="calibre10"><code class="calibre11">get_acs(
  geography = "state",
  variables = "B01002_001",
  year = 2020
) %&gt;%
  ggplot(aes(
    x = estimate,
    y = NAME
  )) +
  geom_col()
</code></pre>
<p class="tx">After importing the data with the <span class="sans_thesansmonocd_w5regular_">get_acs()</span> function, the <span class="sans_thesansmonocd_w5regular_">ggplot()</span> function pipes it directly into ggplot. States (which use the variable <span class="sans_thesansmonocd_w5regular_">NAME</span>) will go on the y-axis, and median age (<span class="sans_thesansmonocd_w5regular_">estimate</span>) will go on the x-axis. A simple <span class="sans_thesansmonocd_w5regular_">geom_col()</span> creates the bar chart shown in <a href="chapter11.xhtml#fig11-3" class="calibre3">Figure 11-3</a>.<span aria-label=" Page 196. " epub:type="pagebreak" id="pg_196" role="doc-pagebreak"/></p>
<figure class="img"><img alt="" class="img2" height="1742" id="fig11-3" src="../images/fig11-3.jpg" width="1358"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">Figure 11-3: A bar chart generated using data acquired with the get_asc() function</span></p></figcaption>
</figure>
<p class="tx">This chart is nothing special, but the fact that it takes just six lines of code to create most definitely is!</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h4 class="h2" id="sec15"><span id="h2-95"/><span class="sans_futura_std_heavy_oblique_bi_">Making Population Maps with the geometry Argument</span></h4>
<p class="tni">In addition to co-creating <span class="sans_thesansmonocd_w5regular_">tidycensus</span>, Kyle Walker created the <span class="sans_thesansmonocd_w5regular_">tigris</span> package for working with geospatial data. As a result, these packages are tightly integrated. Within the <span class="sans_thesansmonocd_w5regular_">get_acs()</span> function, you can set the <span class="sans_thesansmonocd_w5regular_">geometry</span> argument to <span class="sans_thesansmonocd_w5regular_">TRUE</span> to receive both demographic data from the Census Bureau and geospatial data from <span class="sans_thesansmonocd_w5regular_">tigris</span>:</p>
<pre id="pre-231" class="calibre10"><code class="calibre11"><span aria-label=" Page 197. " epub:type="pagebreak" id="pg_197" role="doc-pagebreak"/>get_acs(
  geography = "state",
  variables = "B01002_001",
  year = 2020,
<b class="calibre9">  geometry = TRUE</b>
)
</code></pre>
<p class="tx">In the resulting data, you can see that it has the metadata and <span class="sans_thesansmonocd_w5regular_">geometry</span> column of the simple features objects that you saw in <span class="xref"><a href="chapter4.xhtml" class="calibre3">Chapter 4</a></span>:</p>
<pre id="pre-232" class="calibre10"><code class="calibre11">#&gt; Simple feature collection with 52 features and 5 fields
#&gt; Geometry type: MULTIPOLYGON
#&gt; Dimension:     XY
#&gt; Bounding box:  xmin: -179.1489 ymin: 17.88328 xmax: 179.7785 ymax: 71.36516
#&gt; Geodetic CRS:  NAD83
#&gt; First 10 features:
#&gt;    GEOID  NAME         variable   estimate  moe
#&gt; 1  35     New Mexico   B01002_001     38.1  0.1
#&gt; 2  72     Puerto Rico  B01002_001     42.4  0.2
#&gt; 3  06     California   B01002_001     36.7  0.1
#&gt; 4  01     Alabama      B01002_001     39.2  0.1
#&gt; 5  13     Georgia      B01002_001     36.9  0.1
#&gt; 6  05     Arkansas     B01002_001     38.3  0.2
#&gt; 7  41     Oregon       B01002_001     39.5  0.1
#&gt; 8  28     Mississippi  B01002_001     37.7  0.2
#&gt; 9  08     Colorado     B01002_001     36.9  0.1
#&gt; 10 49     Utah         B01002_001     31.1  0.1
#&gt;    geometry
#&gt; 1  MULTIPOLYGON (((-109.0502 3...
#&gt; 2  MULTIPOLYGON (((-65.23805 1...
#&gt; 3  MULTIPOLYGON (((-118.6044 3...
#&gt; 4  MULTIPOLYGON (((-88.05338 3...
#&gt; 5  MULTIPOLYGON (((-81.27939 3...
#&gt; 6  MULTIPOLYGON (((-94.61792 3...
#&gt; 7  MULTIPOLYGON (((-123.6647 4...
#&gt; 8  MULTIPOLYGON (((-88.50297 3...
#&gt; 9  MULTIPOLYGON (((-109.0603 3...
#&gt; 10 MULTIPOLYGON (((-114.053 37...
</code></pre>
<p class="tx">The geometry type is <span class="sans_thesansmonocd_w5regular_">MULTIPOLYGON</span>, which you learned about in <span class="xref"><a href="chapter4.xhtml" class="calibre3">Chapter 4</a></span>. To pipe this data into ggplot to make a map, add the following code:</p>
<pre id="pre-233" class="calibre10"><code class="calibre11">get_acs(
  geography = "state",
  variables = "B01002_001",
  year = 2020,
  geometry = TRUE
) <b class="calibre9">%&gt;%</b>
<b class="calibre9">  ggplot(aes(fill = estimate)) +</b>
<b class="calibre9">  geom_sf() +</b>
<b class="calibre9">  scale_fill_viridis_c()</b>
</code></pre>
<p class="tx"><span aria-label=" Page 198. " epub:type="pagebreak" id="pg_198" role="doc-pagebreak"/>After importing the data with <span class="sans_thesansmonocd_w5regular_">get_acs()</span> and piping it into the <span class="sans_thesansmonocd_w5regular_">ggplot()</span> function, this code sets the <span class="sans_thesansmonocd_w5regular_">estimate</span> variable to use for the <span class="sans_thesansmonocd_w5regular_">fill</span> aesthetic property; that is, the fill color of each state will vary depending on the median age of its residents. Then <span class="sans_thesansmonocd_w5regular_">geom_sf()</span> draws the map, and the <span class="sans_thesansmonocd_w5regular_">scale_fill_viridis_c()</span> function gives it a colorblind-friendly palette.</p>
<p class="tx">The resulting map, shown in <a href="chapter11.xhtml#fig11-4" class="calibre3">Figure 11-4</a>, is less than ideal because the Aleutian Islands in Alaska cross the 180-degree line of longitude, or the International Date Line. As a result, most of Alaska appears on one side of the map and a small part appears on the other side. What’s more, both Hawaii and Puerto Rico are hard to see.</p>
<figure class="img"><img alt="" class="img1" height="426" id="fig11-4" src="../images/fig11-4.jpg" width="1328"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">Figure 11-4: A hard-to-read map showing median age by state</span></p></figcaption>
</figure>
<p class="tx">To fix these problems, load the <span class="sans_thesansmonocd_w5regular_">tigris</span> package, then use the <span class="sans_thesansmonocd_w5regular_">shift_geometry()</span> function to move Alaska, Hawaii, and Puerto Rico into places where they’ll be more easily visible:</p>
<pre id="pre-234" class="calibre10"><code class="calibre11"><b class="calibre9">library(tigris)</b>

get_acs(
  geography = "state",
  variables = "B01002_001",
  year = 2020,
  geometry = TRUE
) %&gt;%
<b class="calibre9">  shift_geometry(preserve_area = FALSE) %&gt;%</b>
<b class="calibre9">  ggplot(aes(fill = estimate)) +</b>
<b class="calibre9">  geom_sf() +</b>
<b class="calibre9">  scale_fill_viridis_c()</b>
</code></pre>
<p class="tx">Setting the <span class="sans_thesansmonocd_w5regular_">preserve_area</span> argument to <span class="sans_thesansmonocd_w5regular_">FALSE</span> shrinks the giant state of Alaska and makes Hawaii and Puerto Rico larger. Although the state sizes in the map won’t be precise, the map will be easier to read, as you can see in <a href="chapter11.xhtml#fig11-5" class="calibre3">Figure 11-5</a>.<span aria-label=" Page 199. " epub:type="pagebreak" id="pg_199" role="doc-pagebreak"/></p>
<figure class="img"><img alt="" class="img1" height="647" id="fig11-5" src="../images/fig11-5.jpg" width="1328"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">Figure 11-5: An easier-to-read map tweaked using tigris functions</span></p></figcaption>
</figure>
<p class="tx">Now try making the same map for all 3,000 counties by changing the <span class="sans_thesansmonocd_w5regular_">geography</span> argument to <span class="sans_thesansmonocd_w5regular_">"county"</span>. Other geographies include <span class="sans_thesansmonocd_w5regular_">region</span>, <span class="sans_thesansmonocd_w5regular_">tract</span> (for census tracts), <span class="sans_thesansmonocd_w5regular_">place</span> (for census-designated places, more commonly known as towns and cities), and <span class="sans_thesansmonocd_w5regular_">congressional district</span>. There are also many more arguments in both the <span class="sans_thesansmonocd_w5regular_">get_decennial()</span> and <span class="sans_thesansmonocd_w5regular_">get_acs()</span> functions; I’ve shown you only a few of the most common. If you want to learn more, Walker’s book <i class="calibre4">Analyzing US Census Data: Methods, Maps, and Models in R</i> is a great resource.</p>
</section>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h3 class="h1" id="sec16"><span id="h1-69"/><span class="sans_dogma_ot_bold_b_1">Summary</span></h3>
<p class="tni">This chapter explored two packages that use APIs to access data directly from its source. The <span class="sans_thesansmonocd_w5regular_">googlesheets4</span> package lets you import data from a Google Sheet. It’s particularly useful when you’re working with survey data, as it makes it easy to update your reports when new results come in. If you don’t work with Google Sheets, you could use similar packages to fetch data from Excel365 (<span class="sans_thesansmonocd_w5regular_">Microsoft365R</span>), Qualtrics (<span class="sans_thesansmonocd_w5regular_">qualtRics</span>), Survey Monkey (<span class="sans_thesansmonocd_w5regular_">svmkrR</span>), and other sources.</p>
<p class="tx">If you work with US Census Bureau data, the <span class="sans_thesansmonocd_w5regular_">tidycensus</span> package is a huge time-saver. Rather than having to manually download data from the Census Bureau website, you can use <span class="sans_thesansmonocd_w5regular_">tidycensus</span> to write R code that accesses the data automatically, making it ready for analysis and reporting. Because of the package’s integration with <span class="sans_thesansmonocd_w5regular_">tigris</span>, you can also easily map this demographic data.</p>
<p class="tx">If you’re looking for census data from other countries, there are also R packages to bring data from Canada (<span class="sans_thesansmonocd_w5regular_">cancensus</span>), Kenya (<span class="sans_thesansmonocd_w5regular_">rKenyaCensus</span>), Mexico (<span class="sans_thesansmonocd_w5regular_">mxmaps</span> and <span class="sans_thesansmonocd_w5regular_">inegiR</span>), Europe (<span class="sans_thesansmonocd_w5regular_">eurostat</span>), and other regions. Before hitting that download button in your data collection tool to get a CSV file, it’s worth looking for a package that can import that data directly into R.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h3 class="h1" id="sec17"><span id="h1-70"/><span aria-label=" Page 200. " epub:type="pagebreak" id="pg_200" role="doc-pagebreak"/><span class="sans_dogma_ot_bold_b_1">Additional Resources</span></h3>
<ul class="ul">
<li class="listbullet">Isabella Vel<span class="copyright_accent">á</span>squez and Curtis Kephart, “Automated Survey Reporting with googlesheets4, pins, and R Markdown,” Posit, June 15, 2022, <i class="calibre4"><a href="https://posit.co/blog/automated-survey-reporting/" class="calibre3">https://posit.co/blog/automated-survey-reporting/</a></i>.</li>
<li class="listbullet">Kyle Walker, <i class="calibre4">Analyzing US Census Data: Methods, Maps, and Models in R</i> (Boca Raton, FL: CRC Press, 2023), <i class="calibre4"><a href="https://walker-data.com/census-r/" class="calibre3">https://walker-data.com/census-r/</a></i>.</li>
</ul>
</section>
</section>
</div></body></html>